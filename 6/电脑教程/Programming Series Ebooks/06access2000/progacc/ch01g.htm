<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Built-In Functions</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch01f.htm", "ch01h.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="28"><H1>Built-In Functions</H1></A>

<P>As many of the previous samples demonstrate, Access 2000 has a rich 
library of built-in functions. They can help you speed up development of custom 
solutions by minimizing and simplifying the original custom code you need 
to prepare. You can use the built-in functions in the same manner that you 
use your own custom ones, in procedures, queries, forms, and reports. By 
familiarizing yourself with the potential uses for built-in functions, you can 
discover new and innovative ways to apply your own custom functions.</P>

<P>This section includes three samples that use built-in functions: one for 
a query, one for a form, and one for a report. You can, and probably will, 
merge all three approaches in your applications. The third example shows how to 
make a control on a report act as a source for VBA code in a report module by 
using built-in functions. All three samples work with a small invoice table and 
demonstrate ways to report on invoices that are past due.</P>

<P>Figure 1-22 shows the original <I>InvoiceDates 
</I>table on the left and a query showing a view of the table on the right. The query selects 2 of the 10 rows 
in the <I>InvoiceDates </I>table and computes a new column called 
<I>Past Due Days</I>. (The date of the screen shot is 9/12/98.)</P>

<P><A HREF="javascript:fullSize('F01QH22x.htm')"> <img src="Images/F01QH22.JPG" width=404 height=178 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 1-22.</B> <I>An </I>InvoiceDates <I>table and the results of a query that selects rows and computes new fields with built-in functions.</I><!-- /CAPTION -->
</P>

<P>You can find the current date using one of two built-in functions: the 
<I>Date </I>function and the <I>Now </I>function. (The return value of the 
<I>Now </I>function also includes the current time. If you are working with dates only, it doesn't 
matter which one you use.)</P>

<P>The query includes both columns from the original 
<I>InvoiceDates </I>table. The criterion for the 
<I>InvoiceDate </I>column is <I>&lt;Date()-30</I>. Since the current date at 
the time of the query is 9/12/98, any invoice from before 8/13/98 is past 
due. Therefore, the query returns the invoices from 7/01/98 and 6/15/98.</P>

<P><I>Past Due Days</I> merit their own column. This computed field uses a 
pair of built-in date functions: <I>DateDiff</I> and 
<I>Now</I>. The <I>DateDiff </I>function is ideal 
for computing the difference between two dates. You can specify the 
difference in days, months, quarters, years, and various other units of time. The 
<I>DateDiff </I>function for the <I>Past Due 
Days</I> column returns the difference in days. 
The expression that calculates the field is <I>DateDiff(&quot;d&quot;, 
[InvoiceDate]+30,Now()). </I>This expression determines the current date using the 
<I>Now </I>function (although the <I>Date </I>function would work equally well). The term 
<I>[InvoiceDate] </I>refers to the table, which acts as a record source for the query. The 
<I>+30 </I>designates the grace period during which an invoice is not considered late.</P>

<P>The query is a start for generating some useful business results, but it 
has a number of drawbacks. An obvious one is that Datasheet view does not 
tell you what the current date is. Therefore, you might wonder what the basis 
is for computing past due bills. The <I>frmPastDueEvaluator 
</I>form object in Figure 123 solves this problem by presenting the more user-friendly Form 
view of the data. In this view, three fields on the form provide the critical 
information. The <I>Invoice Date</I> field shows the creation date of the invoice. The 
next field shows the current date. The third field computes the number of days 
that an invoice is past due. This field displays a 
<I>0</I> if the invoice age is less than or equal to 30 days.</P>

<P><A HREF="javascript:fullSize('F01QH23x.htm')"> <img src="Images/F01QH23.JPG" width=404 height=173 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 1-23.</B> <I>A form for computing the days that invoices are past due.</I><!-- /CAPTION -->
</P>

<P>The last two fields on the form use built-in functions to compute their 
values. The <I>Today's Date</I> field uses 
<I>Date.</I> In this case, <I>Date </I>is better than 
<I>Now </I>because <I>Now </I>causes the date and time to show unless you explicitly format 
the field. If you set the field's <I>Control Source 
</I>property to <I>=Date()</I>, no formatting is necessary. The 
<I>Days Late</I> field uses an <I>IIF </I>(<I>Immediate 
If</I>)<I> </I>function. You write expressions with this function in a way that former spreadsheet developers 
will find very natural. For example, the expression for the last field on the form 
is <I>IIF(Date()-[txtInvoiceDate]&gt;30,Date()-[txtInvoiceDate]-30,0)</I>. The expression has three arguments, like the spreadsheet 
<I>If </I>function. The first argument evaluates to 
<I>True </I>or <I>False</I>; it is a condition. If the condition is true, the 
<I>IIF </I>function returns the value of the second argument; if the condition is false, the 
<I>IIF </I>function returns the value of the third argument. Therefore, if the date in the 
text box with the invoice date, 
<I>txtInvoiceDate</I>, is more than 30 days before 
current date, the <I>IIF</I> function returns the number of days the invoice is beyond the 
30-day grace period. Otherwise, the <I>IIF</I> function returns 
<I>0</I>.</P>

<P>The report in Figure 1-24 shows another approach to summarizing 
past due bills. The report includes three columns. The last column is a 
computed one that calculates the number of days an invoice is past due. For any 
given invoice row, this column is blank if the invoice is not past due. The 
report's header reminds the user of the report date so that the user knows what 
date defines the invoices as past due.</P>

<P><A HREF="javascript:fullSize('F01QH24x.htm')"> <img src="Images/F01QH24.JPG" width=404 height=379 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 1-24.</B> <I>A report that conditionally shows the number of days that an invoice is past due. If the invoice is less than or equal to 30 days old, the last column is blank.</I><!-- /CAPTION -->
</P> 

<P>A formula is used to compute the last column in the report. You 
should be able to write the formula based on the previous two samples. What 
makes the report special is that the last column is sometimes blank. The 
<I>OnFormat </I>event procedure for the form's Detail section makes this possible by 
conditionally manipulating at run time the <I>Visible 
</I>property of the control for the report's last column. The event procedure logic is as follows:</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Private Sub Detail_Format(Cancel As Integer, FormatCount As Integer)
Dim ctlD As Control
    For Each ctlD In Me.Detail.Controls
        If ctlD.Name = &quot;txtPastDueDays&quot; Then
            If ctlD.Value &gt;= 0 Then
                ctlD.Visible = True
            Else
                ctlD.Visible = False
            End If
        End If
    Next ctlD
End Sub
</pre>
</TD></TR></TABLE></P>


<P>The event procedure uses a <I>For Each&#8230;Next 
</I>statement to loop through the controls for each record, looking for the 
<I>txtPastDueDays</I> text box. This text box contains the number of days that an invoice is past due. If the quantity is 
positive, the invoice is past due and the code sets the control's 
<I>Visible </I>property to true. Otherwise, the invoice is not past due and the code sets the control's 
<I>Visible </I>property to false. These few lines of code generate the flexible report 
formatting at run time.</P>

<A NAME="29"><H2>Summary of Selected Functions</H2></A>

<P>Access 2000 has over 170 built-in functions that perform a broad range of 
tasks, including conversion between data types, date/time processing, statistical 
analysis of content in tables and queries, mathematics, and text processing. You 
can learn about the functions by first developing a general appreciation for 
what they do. This can save you from writing new code for a task when 
Microsoft has already written the code for you. Next, you can try to decipher how 
the functions complement one another. You can also learn the characteristics 
of the return values. For example, the <I>Hex </I>function returns a string 
representing the hexadecimal equivalent of a decimal number, and the 
<I>Oct </I>function performs a similar conversion to an octal representation. The output of 
both functions is suitable for string concatenation and comparisons but not 
for arithmetic operations.</P>

<P>You can also explore the impact of a function's optional arguments on 
the function's return value. Failure to understand these arguments can 
sometimes lead to misleading or confusing results. For example, the 
<I>StrComp </I>function compares two strings. The first two arguments are the strings to be compared. A 
third, optional argument specifies the type of comparison that is to be performed 
on the strings. You can specify a case-insensitive comparison, a case-sensitive 
comparison, or an alternative based on the New Database Sort Order option on 
the General page of the Access 2000 Options dialog box. If you do not specify 
this optional comparison, the function falls back to the comparison method 
specified by the <I>Option Compare</I> statement in a module's Declaration area. (If 
no method is specified, Access uses a binary comparison.)</P>


<P>The following table shows a selection of function categories and 
describes the purpose of selected functions in each category. There are more 
categories than those shown in the table, and there are generally more functions in 
each category. Any categorization is arbitrary since many functions can fit into 
more than one category. For example, the <I>DateSerial 
</I>function processes dates by returning date serial numbers based on non_date/time arguments, but it can 
also convert string dates to serial numbers. It therefore fits into both the 
date/time and conversion categories.</P>

<P><b>Selected Function Categories</b></P>

<P>
<table valign="top" cellpadding=5 width="95%">
<tr><th valign="top"><I>Function Category</I></th>
<th valign="top"><I>Representative Functions</I></th>
<th valign="top"><I>Purpose</I></th>
</tr>
<tr>
<td valign="top">Conversion</td>
<td valign="top"><I>CDbl</I>, <I>CSng</I>, <I>CInt</I>,  <I>CCur</I>, <I>CDec, Str</I>, <I>Val,</I> <I>Hex</I>, <I>Oct</I></td>
<td valign="top">Determining the type of arithmetic an expression does and converting between data types</td>
</tr>
<tr>
<td valign="top">Date/time</td>
<td valign="top"><I>Date, Now, DateAdd,</I> <I>DatePart, DateDiff,</I> <I>Year, Month, Day,</I> <I>Hour, Minute, Second,</I> <I>Weekday, DateValue,</I> <I>DateSerial, MonthName, WeekdayName, FormatDateTime</I></td>
<td valign="top">Expressing, computing with, and extracting date and time values from date serial numbers and string representations of dates and times</td>
</tr>
<tr>
<td valign="top">Domain aggregate</td>
<td valign="top"><I>DLookup, DCount,</I> <I>DSum, DAvg, DVar</I></td>
<td valign="top">Computing statistical results, such as the count for a domain (such as a table or a query)</td>
</tr>
<tr>
<td valign="top">Error handling</td>
<td valign="top"><I>Error</I>, <I>CVErr</I>, <I>IsError</I></td>
<td valign="top">Error trapping and custom error codes</td>
</tr>
<tr>
<td valign="top">Inspection</td>
<td valign="top"><I>IsDate, IsTime,</I> <I>IsNumeric, IsNull,</I> <I>IsEmpty,VarType</I></td>
<td valign="top">Programmatically assessing data types</td>
</tr>
<tr>
<td valign="top">Math</td>
<td valign="top"><I>Rnd, Sqr, Exp, Log, Sin, Cos, Tan </I></td>
<td valign="top">Performing mathematical calculations</td>
</tr>
<tr>
<td valign="top">Messages</td>
<td valign="top"><I>MsgBox</I>,<I> InputBox</I></td>
<td valign="top">Issuing messages and gathering input from the keyboard</td>
</tr>
<tr>
<td valign="top">Text</td>
<td valign="top"><I>Left, Right, Mid, Trim,</I> <I>UCase, LCaseStrReverse, Replace, InStr, InStrReverse</I></td>
<td valign="top">Processing strings</td>
</tr>
<tr>
<td valign="top">Miscellaneous</td>
<td valign="top"><I>Sum, Count, RGB,</I> <I>FV, NPV, CreateObject, </I><I>GetObject, SysCmd </I></td>
<td valign="top"> Aggregating statistical results, setting color properties, computing financial results, creating or getting references to ActiveX objects, presenting progress meters, and more</td>
</tr>
</table></P>

 
<P>These functions perform a variety of tasks. String functions can 
extract, transform, and truncate unwanted parts of a text string, but you can also 
use the built-in functions to calculate financial results or mathematical values. 
Inspection functions are useful for determining data types before you attempt 
to compute expressions. Wise use of these functions and the conversion 
functions can enable your code to branch around potential data 
type<I> </I>mismatch errors. (Error processing is an essential part of any complete solution. Without it, 
your solutions cannot trap run-time errors or raise custom run-time errors.) 
Domain aggregate functions are not very fast, but they can replace a whole query or 
a more complicated SQL statement. For example, your applications can use 
the domain aggregate functions in VBA procedures as well as in queries and 
forms. SQL aggregate functions, such as <I>Count 
</I>and <I>Sum</I>, can also generate statistical 
results for record sources. These functions are not as widely applicable as 
domain aggregate functions. For instance, you cannot use them in VBA procedures.</P>

<P>Figure 1-25 shows a procedure and the Immediate window to 
illustrate the behavior of the <I>Hex </I>function. The procedure initially transforms 
both arguments to hexadecimal strings and then prints the results in the Immediate window.</P>

<P><A HREF="javascript:fullSize('F01QH25x.htm')"> <img src="Images/F01QH25.JPG" width=404 height=282 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 1-25.</B> <I>A procedure that tests the </I>Hex <I>function.</I><!-- /CAPTION -->
</P>

<P>The string returned by the <I>Hex </I>function is not appropriate for 
arithmetic. The <I>hextest</I> function works around this by performing arithmetic with its 
decimal arguments and then transforming the result with the 
<I>Hex </I>function. The next several lines of the procedure demonstrate this approach. They add 
<I>firstarg </I>and <I>secondarg </I>and save the result in 
<I>newarg</I>. Then the procedure transforms 
<I>newarg</I> to a hexadecimal string and stores it in 
<I>newhex</I>. The procedure then prints 
<I>newarg</I> and <I>newhex</I> in the Immediate window.</P>

<P>The last transformation in <I>hextest </I>converts decimal 
90<I> </I>to the hexadecimal equivalent of 
<I>5A</I>. The comment lines before the transformation indicate that 
90 is 5 * 16 + 10.</P>
 
<P>The last pair of lines in the Immediate window show that the 
<I>Hex </I>function returns string values. Actually, 
<I>Hex </I>returns a Variant data type, but the Variant's subtype is a string. The arithmetic operation hex 
16<I> </I>+ hex 16<I> </I>should yield hex 20. However, the Immediate window returns 1010. This shows 
that the plus sign in the <I>newarg = firstarg + 
secondarg</I> line performs a string concatenation instead of a numerical sum.</P>

<P>You should always look for techniques that minimize processing time. 
This is especially important for solutions that have a long lifetime of use or 
that perform essential business tasks. Figure 1-26 shows a 
procedure that can serve as the basis for timing the performance of your code. 
It computes the time that it takes to run a loop a fixed number of times. You 
can extend this basic design to compare the time it takes to perform a task with 
two different coding solutions. As you can see from the Immediate window, 
the simple code block runs quickly. On my test computer, it took just 2 
seconds to pass through the loop two million times.</P>

<P><A HREF="javascript:fullSize('F01QH26x.htm')"> <img src="Images/F01QH26.JPG" width=404 height=394 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 1-26.</B> <I>Timing the completion of a task. This </I>TimedLoop <I>procedure also shows how several built-in functions operate.</I><!-- /CAPTION -->
</P>

<P>The <I>TimedLoop </I>procedure accepts a single argument that specifies 
how many times to run its loop. You can often discern performance differences 
better if you run a loop for a reasonable number of iterations. This simple loop 
has just two short statements. Note that before the procedure starts the loop, it 
saves the current time (<I>Now</I>) in 
<I>dtmStartTime</I>. After all the iterations have 
completed, the procedure saves the completion time in 
<I>dtmEndTime</I>. The <I>DateDiff </I>function computes the difference between these two values in seconds. (You 
previously saw this same function compute the difference between dates in 
days. It works with many time units, including years, quarters, hours, weeks, and 
even weekdays.) The <I>DateDiff </I>function handles the conversions to seconds and 
any peculiarities that arise from passing through midnight, and extracts the 
relevant quantities from the start and end times.</P>

<P>Since this particular timing test uses such a large number of iterations, 
it is particularly convenient to express the number of iterations with commas. 
The use of the <I>Format </I>function reveals how to accomplish this.</P>

<P>The domain aggregate functions are another distinct class of 
functions. They return statistical and lookup information about a domain (a set of 
records). The records can reside in either a table or the result of a select query. 
The functions can return count, sum, average, variance, and standard deviation 
statistics about a domain. You can also use the domain aggregate 
<I>DMin</I> and <I>DMax</I> functions to return the smallest or largest value from a column in the 
domain. The <I>DFirst</I> and <I>DLast</I> domain aggregate functions return a random record 
rather than the first or last record from the records sorted on one or more fields. 
The <I>DLookup</I> domain aggregate function is very popular; it returns one or 
more records that match a criterion. All domain aggregate functions share a 
format similar to the one shown here:</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
DFunctionName(&quot;fieldexpression&quot;, &quot;domainname&quot;, &quot;criteria&quot;)
</pre>
</TD></TR></TABLE></P>


<P>All domain aggregate function names begin with 
<I>D</I>. Notice that the syntax embraces all three arguments in quotes. You can optionally place 
brackets around the field name in the first and third arguments. The first two 
arguments are mandatory, and the third is optional. The 
<I>fieldexpression </I>argument names a field on which to report. The 
<I>domainname </I>argument is the name of a record source. The optional third argument specifies a criterion statement for 
designating elements that you want in the return set. To return the company 
name from the first record in the <I>Shippers</I> table from the Northwind database, you 
use the following <I>DLookup</I> function:</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
DLookup(&quot;CompanyName&quot;, &quot;Shippers&quot;, &quot;ShipperID = 1&quot;)
</pre>
</TD></TR></TABLE></P>


<P>The criterion in this sample specifies the record in the table with 
a <I>ShipperID </I>field of one. This is an AutoNumber field with a table data type 
of Long Integer. When this type of criterion is acceptable for your solution, it 
simplifies the use of domain aggregate functions. This 
<I>DLookup </I>function returns the field value from the single record that matches the criterion. If more 
than one record matches the criterion for a <I>DLookup 
</I>function, <I>DLookup </I>returns the first matching record in the domain source.</P>

<P>Other domain aggregate<I> </I>functions, such as 
<I>DSum</I>, <I>DCount</I>, and <I>DAvg</I>, compute results based on one or more records. The following VBA 
statement prints the number of past due invoices to the Immediate window based on 
a <I>DCount </I>function calculation:</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>Debug.Print DCount(&quot;InvoiceDate&quot;, &quot;InvoiceDates&quot;, _
    &quot;InvoiceDate &lt; Now()-30&quot;)
</pre>
</TD></TR></TABLE></P>


<P>This sample computes a count of invoices that are past due and prints 
the result. When used on the <I>InvoiceDates</I> table in the sample file for <a href="ch02a.htm">Chapter 2</a> 
on 9/12/98, this <I>DCount </I>function returns two records. You might want to add 
new records to the table or change some dates to get a different count when 
you try this sample.</P>

<P>Figure 1-27 shows a form that allows the user to enter the red, green, 
and blue values for a color and then displays the color when the user clicks the 
text box on the right. The red, green, and blue values for a color can range from 
<I>0 </I>through <I>255</I>. If all three numbers are 
<I>0</I>, the color is black. If all three numbers are 
<I>255</I>, the color is white. Making any single number 
<I>255 </I>while setting the other two to <I>0 
</I>creates an intense red, green, or blue color. The settings on my 
computer display the color for Figure 1-27 as a pale red or pink.</P>


<P><img src="Images/F01QH27.GIF" width=400 height=239 border=0>
</P><P><!-- CAPTION --><B>Figure 1-27.</B> <I>A form showing a color viewer.</I><!-- /CAPTION -->
</P>


<P>The following event procedure for the text box on the right in 
Figure 1-27 does the simple processing for this color viewer. Aside from checking for 
Null entries in the color number text boxes, the procedure consists of a single 
statement. The statement uses the <I>RGB </I>function to set the 
<I>BackColor </I>of the large text box on the form's right.</P>


<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Private Sub txtColorMe_Click()
'If null color field, set a default value.
    If IsNull(Me.txtRed.Value) Then
        Me.txtRed.Value = 0
    End If
    If IsNull(Me.txtGreen.Value) Then
        Me.txtGreen.Value = 0
    End If
    If IsNull(Me.txtBlue.Value) Then
        Me.txtBlue.Value = 0
    End If
'Set BackColor property.
    Me.txtColorMe.BackColor = RGB(Me.txtRed.Value, _
        Me.txtGreen.Value, _
        Me.txtBlue.Value)
End Sub
</pre>
</TD></TR></TABLE></P>


<P>Checking for Null values is essential since a Null value can cause the 
<I>RGB </I>function to fail. There are many ways to tackle this issue, and the code 
in <I>txtColorMe_Click </I>is only one of them. For example, making the default 
value <I>0</I> if a color value is not specified is arbitrary. It could easily be 
<I>255 </I>or some quantity between <I>0 </I>and 
<I>255</I>. Another option is to not compute the 
<I>RGB </I>function but to merely send a message box that reminds the user to enter a value in all 
three text boxes on the left. Finally, you can actually let the run-time error occur 
for a Null value. Then you can trap the error and solve the problem. The 
next section explores ways of doing this.</P>

</BODY>
</HTML>




