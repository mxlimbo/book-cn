<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Custom Properties and Methods</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07c.htm", "ch07e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="234"><H1>Custom Properties and Methods</H1></A>

<P>When you use class modules, you inevitably work with two separate 
modules. The class module exposes properties and methods and propagates events. 
A second module references the class module; it assigns and reads property 
values as well as invokes methods. This module can initiate actions that fire 
events, and these, in turn, can invoke any associated event procedures in the class module.</p>

<A NAME="235"><H2>Exposing a Property with a Public Variable</H2></A>

<P>The following sample shows two listings. The first is from the 
<I>MyTestClass </I>module. It is a class module, and it starts with a couple of variable 
declarations&#8212;one for this sample and one for the next sample. The procedure named 
<I>EP </I>computes the extended price from three arguments passed to it: units, price, 
and discount. The procedure saves the result of its expression in the variable 
name <I>ExtendedPrice</I>. A declaration in the module's general area defines 
<I>ExtendedPrice </I>as a public variable. This enables a host procedure in another module that 
works with an instance of the <I>MyTestClass </I>object to read the variable's value.</P>

<p><table CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>FROM MyTestClass module (a class module)
Public ExtendedPrice As Currency
Private MyComputedPrice As Currency

Public Sub EP(units As Long, price As Currency, _
    discount As Single)
    
'Compute with result in public variable.
    ExtendedPrice = units * price * (1 - discount)

End Sub


FROM Module1 (a standard module)
Sub ComputeExtendedPrice()
'Create new instance of class module.
Dim MyPriceComputer As New MyTestClass

'Invoke EP method for class, and
'print Extended Price property.
    MyPriceComputer.EP 5, 5, 0.02
    Debug.Print MyPriceComputer.ExtendedPrice
End Sub
</pre>
</TD></TR></table></p>


<P>The host procedure, <I>ComputeExtendedPrice</I>, resides in a standard 
module named <I>Module1</I>. This procedure instantiates an object based on the 
class defined by <I>MyTestClass</I>. Next, it invokes the 
<I>EP </I>method for the object. Finally, it prints the 
<I>ExtendedPrice </I>property for the object.</P>

<P>
While this sample is very basic, it demonstrates several important 
points about using class modules:</p>

<UL>
<P><LI>Class modules are a good choice for computing critical 
business expressions. You will generally use class modules for 
encapsulating a more sophisticated computation than the one for extended price.
</LI></P>

<P><LI>The second procedure, which is in the standard module, starts 
by referencing the class module, 
<I>MyTestClass</I>. The <I>New </I>keyword instantiates an object based on the class. In the sample, the 
variable named <I>MyPriceComputer </I>references the class.
</LI></P>

<P><LI>You can use the object reference for the instance of the class 
to invoke methods and set or read property values. You reference 
the class's <I>EP </I>method with the standard dot notation. You list 
arguments after the method's name and you reference properties with the 
same basic notation.
</LI></P>

<P><LI>Creating a property for a class can be as simple as declaring a 
<I>Public </I>variable in the class module.
</LI></P>
</UL>

<A NAME="236"><H2>Exposing a Property with a Property Function</H2></A>

<P>The first of the following listings shows a different approach to the same task. It relies on a property defined with a <I>Property Get 
</I>function. The <I>ep2 </I>method is nearly identical to the 
<I>EP </I>method in the preceding sample. The only 
difference is that <I>ep2 </I>deposits the result of its expression into a private 
variable, <I>ComputedPrice</I>. (See the private variable declaration in the preceding 
sample.) All by itself, this means that instances of the class cannot expose the 
expression's result. You use a <I>Property Get 
</I>function to expose a private variable. Since 
there is no other property function defined for 
<I>ComputedPrice</I>, the property is read-only. If there were a 
<I>Property Let </I>function with the same name, the 
property would be read/write. Using read-only properties can help to secure the 
values of your properties&#8212;or at least the ways to set them.</P>


<p><table CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>FROM MyTestClass module (a class module)
Public Sub ep2(units As Long, price As Currency, _
    discount As Single)

'Compute with result in private variable; expose
'result through Property Get function.
    MyComputedPrice = units * price * (1 - discount)

End Sub


Property Get ComputedPrice()

'This is how to return a read-only property.
    ComputedPrice = MyComputedPrice

End Property


FROM Module1 (a standard module)
Sub GetComputedPrice()
Dim MyPriceComputer As New MyTestClass
    
'Using a value defined by a property looks the same
'as one defined with a public variable.
    MyPriceComputer.ep2 5, 5, 0.02
    Debug.Print MyPriceComputer.ComputedPrice
End Sub
</pre>
</TD></TR></table></p>

<A NAME="237"><H2>Public Variables vs. Property Functions</H2></A>

<P>The syntax for invoking the method and printing the property value is 
identical in the two samples, although the property is exposed differently. This 
confirms that properties work in the same way whether you define them with 
a public declaration or one or more property functions. Public variables 
might be a simpler way to implement properties in class modules, but property 
functions are a more flexible way to expose them. You use a 
<I>Property Get </I>function by itself for a read-only variable, and you use a 
<I>Property Let </I>function by itself for a write-only property. You use both types of property functions for a 
read/write property. If your property references an object instead of a scalar 
variable, you can use a <I>Property Set </I>function instead of a 
<I>Property Let </I>function. You use the <I>Property Get 
</I>function to return object property values whether you 
are working with a scalar variable or an object.</p>

<A NAME="238"><H2>Class Modules and Data Sources</H2></A>

<P>Class modules are good for encapsulating any kind of code. They have 
special values that are useful for when you want to a make a data source available 
for updating or viewing, but you need to secure the data source from 
accidental or inadvertent damage by users.</p>

<A NAME="239"><H3>Updating data with a SQL string</H3></A>

<P>The following sample uses a class module to update the 
<I>UnitsInStock </I>field for the <I>Products</I> table based on a 
<I>ProductID </I>field and the quantity ordered. A procedure with two lines passes two arguments to a subprocedure in a 
class module. This sample uses a different class module from the two samples 
for calculating extended price (<I>MyTestClass2 
</I>instead of <I>MyTestClass</I>). In practice, you divide your functions and declarations into homogeneous collections 
of method procedures and properties representing distinct object classes. 
The <I>OrderIt </I>variable represents the <I>MyTestClass2 
</I>module. Within the module is a function named 
<I>PO1</I>. It takes two arguments, one for the 
<I>ProductID </I>and one for the units ordered.</P>


<p><table CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>Sub MyOrder()
Dim OrderIt As New MyTestClass

    OrderIt.PO1 1, 10
    
End Sub
</pre>
</TD></TR></table></p>

<P>The next procedure, <I>PO1</I>, updates the Products database. Specifically, 
it decreases <I>UnitsInStock </I>by the number of units ordered. This procedure 
resides in the class module 
(<I>MyTestClass2</I>). Note the procedure's design: it uses 
a <I>Command </I>object with a SQL string that defines the update query. Although 
the procedure accepts two arguments, it does not apply a parameter query. 
Instead, it uses the passed arguments as variables in the string expression defining 
the SQL string. This design leads to a very compact procedure that is relatively 
easy to read.</P>


<p><table CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>'A method for updating a table
Public Sub PO1(ProductID, units)
Dim cmd1 As Command
Dim strSQL As String

'Assign the command reference and connection.
    Set cmd1 = New ADODB.Command
    cmd1.ActiveConnection = CurrentProject.Connection
    
'Define the SQL string; notice
'the insertion of passed arguments.
    strSQL = &quot;UPDATE Products &quot; &amp; _
        &quot;SET UnitsInStock = &quot; &amp; _
        &quot;UnitsInStock-&quot; &amp; units &amp; &quot; &quot; &amp; _
        &quot;WHERE ProductID=&quot; &amp; ProductID
        
'Assign the SQL string to the command and run it.
    cmd1.CommandText = strSQL
    cmd1.CommandType = adCmdText
    cmd1.Execute
    
End Sub
</pre>
</TD></TR></table></p>

<A NAME="240"><H3>Updating data with a parameter query</H3></A>

<P>Many developers prefer a more traditional approach that relies on a 
parameter query. The <I>PO2 </I>procedure below uses a parameter query to 
perform with a SQL string the task accomplished by 
<I>PO1</I>. A parameter query lets you declare 
data types with traditional VBA conventions. Notice that the ADO constant 
<I>adInteger </I>represents a long data type, and the constant 
<I>adSmallInt </I>designates an integer data type. You must create the parameters with the 
<I>CreateParameter </I>method in the same order in which you declare them in the 
<I>Parameters </I>clause of the query statement. Failing to do so will generate a run-time error.</P>


<P><DIV CLASS="NOTE"><BLOCKQUOTE><B>NOTE</B><HR>Look up the <I>Type 
</I>property of the ADO <I>Parameter </I>object in 
the Access 2000 online Help to see the complete selection of data types 
for variable declarations.
</BLOCKQUOTE></DIV></P>


<p><table CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>Public Sub PO2(ProductID As Long, units As Integer)
Dim cmd1 As Command
Dim strSQL As String
Dim prm1 As ADODB.Parameter, prm2 As ADODB.Parameter

'Assign the command reference and connection.
    Set cmd1 = New ADODB.Command
    cmd1.ActiveConnection = CurrentProject.Connection

'Write out SQL statement with parameters &amp; assign to cmd1.
    strSQL = &quot;Parameters PID Long,Quantity Integer;&quot; &amp; _
        &quot;UPDATE Products &quot; &amp; _
        &quot;SET UnitsInStock = &quot; &amp; _
        &quot;UnitsInStock-Quantity &quot; &amp; _
        &quot;WHERE ProductID=PID;&quot;
    cmd1.CommandText = strSQL
    cmd1.CommandType = adCmdText
    
'Declare parameters; must have same order as declaration.
    Set prm1 = cmd1.CreateParameter(&quot;PID&quot;, adSmallInt, _
        adParamInput)
    prm1.Value = ProductID
    cmd1.Parameters.Append prm1
    Set prm2 = cmd1.CreateParameter(&quot;Quantity&quot;, adInteger, _
        adParamInput)
    prm2.Value = units
    cmd1.Parameters.Append prm2
    
'Run update query.
    cmd1.Execute
    
End Sub
</pre>
</TD></TR></table></p>


<P>There are four main components to the parameter query design of 
the update task:</P>


<UL>

<P><LI>The procedure makes variable declarations and assigns references.
</LI></P>

<P><LI>It specifies the SQL string for the update query and assigns that string to a command property. 
</LI></P>

<P><LI>It creates and assigns values to the parameters declared in the 
second step.
</LI></P>

<P><LI>It runs the command to update the database.
</LI></P>
</UL>

</BODY>
</HTML>




