<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Security </TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch10d.htm", "ch10f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="335"><H1>Security </H1></A>


<P>Access offers a rich array of security features to support the needs of different types of Access applications. Most multi-user Access applications can benefit from user-level security, which lets developers designate groups of users. But some applications have more specialized needs. The following section offers a brief overview of security techniques other than user-level security. Subsequent sections cover programmatic approaches to managing user-level security using ADO.</P>


<A NAME="336"><H2>Alternatives to User-Level Security</H2></A>

<P>One of the strengths of Access is its ability to serve different audiences. Some applications are code-intensive, so you need to secure your investment in source code. Other applications serve small workgroups with limited technical capabilities but still require minimum levels of security to restrict access to data. Still other applications benefit from a custom user interface that restricts functionality simply by exposing a restricted set of commands.</P>


<A NAME="337"><H3>Using a custom interface</H3></A>


<P>Sometimes you can adequately secure an application by simply replacing 
the standard Access interface with a custom one. Choose Startup from the 
Tools menu to open a dialog box that lets you specify a custom application title and icon, a custom startup form, and custom menus to replace the standard Access ones. This dialog box also lets you suppress the Database window and the status bar. You can also manipulate the features of the Startup dialog box programmatically. If this type of manipulation is suitable for your security needs, consider augmenting it with the <I>Show </I>and <I>Hide </I>methods, the <I>Visible </I>property, and 
the <I>Hidden </I>property for objects in the Database window. (See earlier chapters for techniques on creating custom features: <a href="ch08a.htm">Chapter 8</a> describes how to program the <I>CommandBars </I>object model to build your own custom menus as well as adapt built-in ones, and <a href="ch05a.htm">Chapter 5</a> shows how to build a custom startup form.)</P>


<A NAME="338"><H3>Setting a database password</H3></A>


<P>You can require users to enter a password to gain unrestricted access to 
all Access data and database objects. Passwords are easy to administer 
compared to user-level security. Password security is appropriate if you have a group whose members need equal access to all elements of a database file but not everyone in the office is a member of that group.</P>


<P>
You cannot use a password-protected file as a member in a replica 
set because Jet database replication cannot synchronize with a 
password-protected file. (See <a href="ch11a.htm">Chapter 11</a> for details.) You should also be careful about linking to database files with password protection because anyone who can access 
the file that links the protected file has unrestricted access to the protected 
file. Furthermore, Access stores an encrypted version of the password along 
with other information about the linked file. Finally, if someone changes the 
password for a linked file, Access prompts for the new password the next 
time another database file links to it.</P>


<P>
To assign and remove a database password, you need exclusive 
access to the file. Take the following steps:</P>

<OL>

<P><LI>Open a file by choosing Open Exclusive from the Open button 
in the Open dialog box to assign a password to a file.</li></p>

<P><LI>Choose Security-Set Database Password from the Tools menu.</li></p>

<P><LI>In the Set Database Password dialog box, enter your password 
of choice in the Password and Verify text boxes and then click OK. 
The next time a user opens the file, the application will ask for the 
password.</li></p>

<P><LI>After opening a database exclusively, choose 
Tools-Security-Unset Database Password. Remove the password by typing the 
password in the Unset Database Password dialog box. This removes the 
initial prompt for a password before a database is made available.</li></p>

</OL>


<A NAME="339"><H3>Setting a module password</H3></A>

<P>Access 2000 uses password security for modules instead of user-level 
security. This new approach makes Access consistent with the other Office 2000 components. It applies to all standard and standalone class modules as well as the modules behind forms and reports.</P>


<P>
You set password security once for all the modules in a VBA project 
from the Visual Basic Editor (VBE). Choose the Properties command for the 
project from the Tools menu to open the Project Properties dialog box. The 
Protection tab (shown in Figure 10-1) offers the Lock Project For Viewing check box and text boxes for entering and confirming a password for the module. Assigning a password for viewing modules in a project does not prevent your code from running as if it were not protected. If you assign a password but do not select the Lock Project For Viewing check box, anyone can edit the code but the Project Properties dialog box will be protected. You remove password security from the modules in a project by clearing all entries on the Protection tab.</P>


<P><A HREF="javascript:fullSize('F10QH01x.htm')"> <img src="IMAGES/F10QH01.JPG" width=404 height=360 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 10-1.</B> <I>You use the Protection tab of the Project Properties dialog box to set password security for the modules in a project.</I><!-- /CAPTION -->
</P>


<P>
After securing your modules with a password, you must enter the 
password once per session before you can view, edit, or add new code. You 
can secure forms and reports with both user-level security and module 
password security. User-level security applies to designing and using forms and reports. You can require a user to have Modify Design permission to add controls to forms. That user will also need the password for modules in a project in order to write event procedures for the control. Conversely, knowing the password for the modules in a project does not enable a user to add controls to or remove controls from a form. Also, Modify Design permission does not allow a user to change the <I>HasModule </I>property of forms and reports to <I>No</I>; the user must first enter the password for the modules in a project.</P>


<A NAME="340"><H3>Using .mde files</H3></A>


<P>An .mde file totally secures the code for an Access database file. When 
you convert an .mdb file to an .mde file, Access compiles all your modules, 
removes editable code, and compacts the destination database while preserving 
the original .mdb file. The size of your database will shrink because of the 
removal of editable code. Also, since the conversion optimizes memory usage, your 
code will run faster.</P>

<P>
To convert an .mdb file to an .mde file, you must have exclusive 
access to the file (see the earlier section titled &quot;<A HREF="ch10e.htm#338">Setting a Database Password</A>&quot;). 
Choose Database Utilities from the Tools menu and then choose Make MDE File. 
After saving your converted file, be sure to save your original file. The only way 
to edit or add to the code in a database file is to modify the original file and 
then convert it to an .mde file.</P>

<P>An .mde file has some restrictions:</P>

<UL>
<P><LI>You cannot modify or add forms, reports, or modules.</LI></P>

<P><LI>You cannot import or export forms, reports, or modules to a 
standard .mdb file. You can, however, freely import and export tables, 
queries, macros, and shortcuts for data access pages with other database files.
</LI></P>

<P><LI>You cannot add, delete, or change references to other object 
libraries or databases.
</LI></P>

<P><LI>You cannot dynamically change code because .mde files contain 
no editable code. (See <a href="ch07a.htm">Chapter 7</a> for a sample illustrating this restriction.)
</LI></P>

<P><LI>You cannot convert any existing member of a replica set to an 
.mde file, but an .mde file can participate in a replica set.
</LI></P>

<P><LI>An .mde file can reference another database file only if that file 
is also an .mde file. You must start converting .mdb files (or .mda 
add-in files) that are referenced before you convert the .mdb file 
that references them. The new reference must point at the new .mde file.
</LI></P>
</UL>


<A NAME="341"><H2>Programmatically Controlling User-Level Security</H2></A>

<P>With user-level security, you can define a workgroup composed of user 
accounts and group accounts. You can programmatically create user and group 
accounts as well as assign permissions to those accounts. The new ADOX model supports this functionality through its <I>Catalog </I>object as well as its <I>Users </I>and <I>Groups </I>collection objects. Figure 10-2 shows the hierarchy: groups can belong to users, and users can belong to groups; users and groups both belong to the <I>Catalog </I>object.</P>

<P><A HREF="javascript:fullSize('F10QH02x.htm')"> <img src="Images/F10qh02.JPG" width=404 height=89 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 10-2.</B> <I>The relationship of the </I>User <I>and </I>Group <I>objects to the</I> Catalog <I>object.</I><!-- /CAPTION -->
</P>


<P>
You can assign permissions to users, groups, or both. It is generally 
most efficient to assign permissions to groups. You clear all default permissions from existing individual user accounts and then assign users to all appropriate groups. With this type of user-level design, you can administer permissions by assigning users to groups and assigning permissions to groups because users inherit all permissions from the groups to which they belong. By restricting permission assignments to groups, this design provides a single focal point for managing permissions.</P>


<P>
The upcoming samples show how to code typical user-level 
administration tasks. Because they are meant to highlight basic security management procedures, only a couple of the samples demonstrate error-trapping logic.</P>


<A NAME="342"><H3>Connecting to a secure database</H3></A>

<P>The following procedure connects to a secure database file. The 
connection string includes four phrases. The first phrase designates the 
<I>Provider </I>property for the procedure's <I>Connection 
</I>object. It specifies the Jet 4 OLE DB 
provider. The second phrase assigns the system database property for the connection. This is the name and path to the workgroup information file (systemdemo.mdw in the Office folder; you must manually copy the file to the Office folder). The third phrase specifies the data source, which in this case is the secure database file, UserLevel.mdb. The fourth phrase denotes user ID and password values for logging into the secure database. In this sample, the procedure logs on as the Admin user. Unless you change the default settings, this user has special administrative permissions.</P>


<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<PRE>'Turn logon procedure on before running this procedure.
'Assign password of &quot;password&quot; to Admin user account.

Sub openUserLevel()
Dim cnn1 As New ADODB.Connection
Dim rst1 As New ADODB.Recordset

'Open connection to target user-level secured data
'source; specify path for workgroup information
'file; designate logon ID and password.
    cnn1.Provider = &quot;Microsoft.Jet.OLEDB.4.0&quot;
    cnn1.Properties(&quot;Jet OLEDB:System database&quot;) = _
        &quot;C:\Program Files\Microsoft Office\&quot; &amp; _
        &quot;Office\systemdemo.mdw&quot;
    cnn1.Open &quot;Data Source=C:\Programming Access\Chap10\UserLevel.mdb;&quot; &amp; _
        &quot;User Id=Admin;Password=password;&quot;

'Print first field from first record to confirm connection.
    rst1.Open &quot;WebBasedList&quot;, cnn1, , , adCmdTable
    Debug.Print rst1.Fields(0)

    cnn1.Close

End Sub
</PRE>
</TD></TR></TABLE></P>


<P>The two lines following the comment open a recordset based on the 
connection and print the first field's value from the first record. This simply confirms the operation of the sample. The table, <I>WebBasedList</I>, is the same one used in the earlier multi-user sample.</P>


<P>For the <I>OpenUserLevel </I>procedure to work, you must invoke the 
logon procedure. This involves giving the Admin user a password. The 
procedure also requires a workgroup information file. In this case, its name must be systemdemo.mdw, and you must save it in the path indicated by the procedure. The companion CD includes both the secure database file and the workgroup information file for easy testing of the procedure.</P>


<A NAME="343"><H3>Adding and deleting users</H3></A>

<P>When you develop and manage a custom application with user-level 
security, you are likely to add and delete users. Before you can add users, you must log on as a member of the Admins group, such as Admin. You can use the <I>Append </I>method of the <I>Users </I>collection to add users to a catalog or group. You must specify a name for the new user, and you can designate a password. ADO lets you assign a password later using the <I>ChangePassword </I>method for the <I>User </I>object. Unfortunately, you cannot assign a PID. ADO picks one randomly.</P>


<P>
The following two procedures show one approach to invoking the 
<I>Append </I>method to add a new user to an application. The 
<I>callMakeUser </I>procedure launches the <I>makeUser 
</I>procedure as it passes along two arguments. The 
first argument designates a new user's name. The second argument sends a 
password. In the sample, the string  <I>&quot;password&quot;</I> is the value of the password argument.</P>


<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<PRE>'Make sure NewUser account does not exist prior to running
'this procedure; for example, run callDeleteUser first.

Sub callMakeUser()
    makeUser &quot;NewUser&quot;, &quot;password&quot;

End Sub


Sub makeUser(usrName As String, secureWord As String)
Dim cat1 As New ADOX.Catalog

    cat1.ActiveConnection = _
        &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Programming Access\Chap10\UserLevel.mdb;&quot; &amp; _
        &quot;Jet OLEDB:System database=C:\Program Files\&quot; &amp; _
        &quot;Microsoft Office\Office\systemdemo.mdw;&quot; &amp; _
        &quot;User Id=Admin;Password=password;&quot;
        
    cat1.Users.Append usrName, secureWord

End Sub
</PRE>
</TD></TR></TABLE></P>


<P>The <I>makeUser </I>procedure specifies a target for the new group using 
the <I>Catalog </I>object's <I>ActiveConnection </I>setting. Note that it designates a user ID with the authority to make a new user, and it points to a workgroup information file. The <I>Append </I>method in <I>makeUser </I>adds a new member to the <I>Catalog </I>object. Therefore, this new user is not yet a member of any groups. You can also add a member to a <I>Group </I>object so that the user has immediate membership in 
that group. One of the following samples uses this technique.</P>


<P>The next two procedures remove a user from the catalog for a 
database. The <I>Delete </I>method for the <I>Users 
</I>collection has the same syntax as the 
<I>Delete </I>method for the <I>Tables</I>, 
<I>Procedures</I>, and <I>Views </I>collection objects. The first 
procedure, <I>callDeleteUser</I>, passes a single argument&#8212;the user name&#8212;to the 
second procedure, <I>deleteUser</I>. The second procedure removes the user from the 
catalog and concurrently removes the user from any groups as well.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<PRE>'Make sure NewUser account exists prior to running this
'procedure; for example, run callMakeUser.

Sub callDeleteUser()
    deleteUser &quot;NewUser&quot;

End Sub


Sub deleteUser(usrName As String)
Dim cat1 As New ADOX.Catalog

    cat1.ActiveConnection = _
        &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Programming Access\Chap10\UserLevel.mdb;&quot; &amp; _
        &quot;Jet OLEDB:System database=C:\Program Files\&quot; &amp; _
        &quot;Microsoft Office\Office\systemdemo.mdw;&quot; &amp; _
        &quot;User Id=Admin;Password=password;&quot;
        
    cat1.Users.Delete usrName

End Sub
</PRE>
</TD></TR></TABLE></P>


<P>You must log on to a database as a member of the Admins group to 
delete a user. The <I>Delete </I>method does not require a password. All that the 
second procedure needs is a string argument naming the user to delete.</P>

<A NAME="344"><H3>Assigning groups to users</H3></A>


<P>One common technique for administering permissions is to assign groups 
to users and manage permissions for groups. Users derive all their 
permissions implicitly through their group memberships. The samples in this section 
add and remove group memberships from a user account. Both samples use 
the built-in Users group, but the same techniques work for custom groups.</P>

<P>
The following two procedures add a group to a user account 
called NewUser. Make sure the user account exists before running the 
procedure. The first procedure, 
<I>callAddGroupToUser</I>, passes a user name and a 
group name to the second procedure, 
<I>AddGroupToUser</I>, which uses the <I>Append 
</I>method to add the <I>Group </I>object to the 
<I>Groups </I>collection for the user. The sample passes arguments to the second procedure that tell it to add the 
Users group to the NewUser user.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<PRE>Sub callAddGroupToUser()
    AddGroupToUser &quot;NewUser&quot;, &quot;Users&quot;
End Sub


Sub AddGroupToUser(usrName As String, grpName As String)
On Error GoTo AddTrap
Dim cat1 As New ADOX.Catalog
Const acctNameAlreadyExist = -2147467259

    cat1.ActiveConnection = _
        &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Programming Access\Chap10\UserLevel.mdb;&quot; &amp; _
        &quot;Jet OLEDB:System database=C:\Program Files\&quot; &amp; _
        &quot;Microsoft Office\Office\systemdemo.mdw;&quot; &amp; _
        &quot;User Id=Admin;Password=password;&quot;
    
    cat1.Groups.Append grpName
    cat1.Users(usrName).Groups.Append grpName
    
AddExit:
    Exit Sub
    
AddTrap:
    If Err.Number = acctNameAlreadyExist Then
        Resume Next
    Else
        Debug.Print Err.Number; Err.Description
    End If

End Sub
</PRE>
</TD></TR></TABLE></P>


<P>The second procedure invokes the <I>Append </I>method in an attempt to 
create a group with the name of the second argument passed to it. This 
procedure works for groups whether or not they already exist. Since Users is a 
built-in group account, it will always exist. If a group with the name of the 
second argument does not already exist, the <I>Append 
</I>method succeeds; otherwise, the procedure falls into an error trap with error number _2147467259 and 
moves on to the next statement. Then, the procedure appends the group to the 
<I>Groups </I>collection for the <I>NewUser </I>object. Again, if the group is already in the 
<I>Groups </I>collection for the user, the procedure progresses to the next statement.</P>

<P>
The next two procedures remove a group from a user's 
<I>Groups </I>collection. The first procedure, 
<I>callRemoveUserFromGroup</I>, passes user and group 
name parameters to the second procedure, 
<I>removeUserFromGroup</I>, which does the work. Since there is no error checking in this sample, make sure the 
group belongs to the user. You can do this by running the preceding sample.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<PRE>'Make sure the group account exist for the user
'prior to running this procedure; for example,
'run callAddGroupToUser.

Sub callRemoveUserFromGroup()
    removeUserFromGroup &quot;NewUser&quot;, &quot;Users&quot;
End Sub


Sub removeUserFromGroup(usrName As String, grpName As String)
Dim cat1 As New ADOX.Catalog

    cat1.ActiveConnection = _
        &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Programming Access\Chap10\UserLevel.mdb;&quot; &amp; _
        &quot;Jet OLEDB:System database=C:\Program Files\&quot; &amp; _
        &quot;Microsoft Office\Office\systemdemo.mdw;&quot; &amp; _
        &quot;User Id=Admin;Password=password;&quot;
    
    cat1.Users(usrName).Groups.Delete grpName

End Sub
</PRE>
</TD></TR></TABLE></P>


<P>You invoke the <I>Delete </I>method to remove a group from the 
<I>Groups </I>collection for a <I>User </I>object. Notice the hierarchical specification for an 
individual user. After identifying a user, the syntax requires the designation of the 
<I>Groups </I>collection and, finally, the <I>Delete 
</I>method. The syntax designates the group name as a parameter for the 
<I>Delete </I>method.</P>

<A NAME="345"><H3>Creating, deleting, and tracking groups in a catalog</H3></A>


<P>When you develop custom user-level solutions, you'll probably want to 
create custom groups with names that are meaningful to your clients and whose 
permissions fit the special requirements of your custom application. The four 
upcoming samples do the following: create a custom group, delete a custom 
group, prepare a report itemizing all the groups in a catalog and the groups 
associated with each user account, and toggle the membership of a group in the 
<I>Users </I>collection, respectively.</P>

<P>
The two procedures below add a group named 
<I>MySecretGroup1</I>. After referencing a database file with a user ID sufficient to make the addition, 
the procedure invokes the <I>Append </I>method of the 
<I>Groups </I>collection. You must specify a container for the 
<I>Groups </I>collection. When you add a new group 
to the project's <I>Users </I>collection, the container is a 
<I>Catalog </I>object. When you assign a group to the 
<I>Groups </I>collection of a <I>User </I>object, you must specify the user 
as the root object for the <I>Groups </I>collection.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<PRE>'Make sure MySecretGroup1 does not exist before running
'this procedure; for example, run callDeleteGroup.

Sub callMakeGroup()
    makeGroup &quot;MySecretGroup1&quot;

End Sub


Sub makeGroup(grpName As String)
Dim cat1 As New ADOX.Catalog

    cat1.ActiveConnection = _
        &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Programming Access\Chap10\UserLevel.mdb;&quot; &amp; _
        &quot;Jet OLEDB:System database=C:\Program Files\&quot; &amp; _
        &quot;Microsoft Office\Office\systemdemo.mdw;&quot; &amp; _
        &quot;User Id=Admin;Password=password;&quot;
    
    cat1.Groups.Append grpName

End Sub

</PRE>
</TD></TR></TABLE></P>


<P>The two procedures below remove a group from a catalog. You must 
make sure that the group already exists in the catalog before running the 
procedures. You can do this by running the preceding sample. In fact, the sample 
below removes the group added in the preceding sample.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<PRE>'Make sure MySecretGroup1 exists prior to running this
'procedure; for example, run callMakeGroup.

Sub callDeleteGroup()
    deleteGroup &quot;MySecretGroup1&quot;

End Sub


Sub deleteGroup(grpName As String)
Dim cat1 As New ADOX.Catalog

    cat1.ActiveConnection = _
        &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Programming Access\Chap10\UserLevel.mdb;&quot; &amp; _
        &quot;Jet OLEDB:System database=C:\Program Files\&quot; &amp; _
        &quot;Microsoft Office\Office\systemdemo.mdw;&quot; &amp; _
        &quot;User Id=Admin;Password=password;&quot;
    
    cat1.Groups.Delete grpName
    
End Sub
</PRE>
</TD></TR></TABLE></P>


<P>The syntax for deleting a group very closely parallels that for adding 
a group. It invokes the <I>Delete </I>method of the catalog's 
<I>Groups </I>collection. You pass the method one parameter&#8212;the name of the group to delete.</P>

<P>
As you add and delete groups and users and reassign groups to users, 
you can easily create a custom report that tracks the group memberships for 
the <I>Catalog </I>and individual <I>User </I>objects. The procedure below itemizes the 
groups in a <I>Catalog </I>object that points at a specific database. Then it itemizes the 
<I>Groups </I>collection members for each user in the catalog's 
<I>Users </I>collection.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<PRE>Sub listGroupsInCat()
Dim cat1 As New ADOX.Catalog
Dim grp1 As New ADOX.Group, usr1 As New ADOX.User

cat1.ActiveConnection = _
   &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
    &quot;Data Source=C:\Programming Access\Chap10\UserLevel.mdb;&quot; &amp; _
    &quot;Jet OLEDB:System database=C:\Program Files\Microsoft Office\&quot; &amp; _
    &quot;Office\systemdemo.mdw;&quot; &amp; _
    &quot;User Id=Admin;Password=password;&quot;

'Groups in overall Catalog
    Debug.Print cat1.Groups.Count &amp; &quot; groups are in the catalog&quot;
    For Each grp1 In cat1.Groups
        Debug.Print String(3, &quot; &quot;) &amp; &quot;* &quot; &amp; grp1.Name
    Next grp1
    Debug.Print

'Groups in each user
    For Each usr1 In cat1.Users
        If usr1.Name &lt;&gt; &quot;Creator&quot; And usr1.Name &lt;&gt; &quot;Engine&quot; Then
            Debug.Print String(5, &quot; &quot;) &amp; usr1.Groups.Count &amp; _
                &quot; groups are in  &quot; &amp; usr1.Name
            For Each grp1 In cat1.Users(usr1.Name).Groups
                Debug.Print String(8, &quot; &quot;) &amp; &quot;* &quot; &amp; grp1.Name
            Next grp1
            Debug.Print
        End If
    Next usr1

End Sub

</PRE>
</TD></TR></TABLE></P>


<P>At the head of each listing of <I>Groups </I>collection members, the 
procedure reports the number of members in the collection by referencing the 
<I>Counts </I>property for the collection. Notice in Figure 10-2  that this 
varies by user. The Admin user belongs to the built-in Admins and Users groups. 
The NewUser user belongs to a single group, Users. You can use the 
preceding samples to create and delete users, groups, and user membership in groups.</P>

<P><img SRC="Images/F10qh03.GIF" width=345 height=238 border=0>
</P><P><!-- CAPTION --><B>Figure 10-3.</B> <I>A group membership report from the</I> listGroupsInCat <I>procedure.</I><!-- /CAPTION -->
</P>


<P>The following procedure shows one possible application of the 
<I>listGroups InCat </I>procedure above. The <I>toggleNewUserInAdminsGroup 
</I>procedure does what its name implies. It toggles the membership of the 
<I>NewUser </I>object in the Admins group. It also documents the current status of the <I>NewUser </I>object in the Admins group by calling the 
<I>listGroupsInCat </I>procedure.</P>


<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<PRE>Sub toggleNewUserInAdminsGroup()
On Error GoTo ToggleTrap
Dim cat1 As New ADOX.Catalog
Const notInCollection = 3265

cat1.ActiveConnection = _
    &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
    &quot;Data Source=C:\Programming Access\Chap10\UserLevel.mdb;&quot; &amp; _
    &quot;Jet OLEDB:System database=C:\Program Files\Microsoft Office\&quot; &amp; _
    &quot;Office\systemdemo.mdw;&quot; &amp; _
    &quot;User Id=Admin;Password=password;&quot;

cat1.Users(&quot;NewUser&quot;).Groups.Delete (&quot;Admins&quot;)
   
ToggleExit:
    listGroupsInCat
    Exit Sub
    
ToggleTrap:
    If Err.Number = notInCollection Then
        cat1.Users(&quot;NewUser&quot;).Groups.Append &quot;Admins&quot;
    Else
        Debug.Print Err.Number; Err.Description
    End If
    Resume Next

End Sub
</PRE>
</TD></TR></TABLE></P>


<P>Notice that the toggling procedure relies on error trapping. After 
connecting to the target database and working group information file through 
the <I>cat1 </I>object reference, the procedure attempts to delete 
<I>Admins </I>from the <I>Groups </I>collection of 
<I>NewUser</I>. If it is successful, the procedure closes by 
calling <I>listGroupsInCat </I>and exiting. Otherwise, an error occurs. If the error 
occurs because the group is not in the user's <I>Groups 
</I>collection, the procedure adds <I>Admins </I>to the 
<I>NewUser Groups </I>collection. Then it closes by resuming as if 
no error occurred.</P>


<A NAME="346"><H3>Setting permissions</H3></A>


<P>You can use the <I>SetPermissions </I>method for 
<I>Group </I>and <I>User </I>objects to manage the permissions available to a security account. You invoke the 
<I>GetPermissions </I>method for these objects to return a Long value that specifies the types 
of permissions assigned to a group or to a user. Both methods offer a wide 
array of outcomes; they can assign and report various permissions for a number 
of database object types. In addition, you can use the 
<I>SetPermission </I>method to assign, revoke, and deny permissions as well as audit their use.</P>

<P>
The two procedures below grant a group full permissions for any 
new table. Setting the permission for new tables has no impact for existing 
tables. Therefore, a group can have full permissions for all new tables and no 
permissions for existing tables.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<PRE>'Make sure MySecretGroup1 exists before running procedure.

Sub callSetAllTablePermissionsForGroup()
    setAllTablePermissionsForGroup &quot;MySecretGroup1&quot;

End Sub


Sub setAllTablePermissionsForGroup(grpName As String)
Dim cat1 As New ADOX.Catalog
Dim grp1 As New ADOX.Group, usr1 As New ADOX.User

cat1.ActiveConnection = _
    &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
    &quot;Data Source=C:\Programming Access\Chap10\UserLevel.mdb;&quot; &amp; _
    &quot;Jet OLEDB:System database=C:\Program Files\Microsoft Office\&quot; &amp; _
    &quot;Office\systemdemo.mdw;&quot; &amp; _
    &quot;User Id=Admin;Password=password;&quot;

cat1.Groups(grpName).SetPermissions Null, adPermObjTable, _
    adAccessSet, adRightFull

End Sub
</PRE>
</TD></TR></TABLE></P>


<P>The first procedure passes a group name, <I>MySecretGroup1</I>, to the second procedure. The second procedure invokes the <I>SetPermissions </I>method for the group member with that name. Therefore, you must make sure that the group exists before you run the procedure or add error-trapping logic. The method's first parameter has an explicit Null value. This parameter normally specifies the name of a database object, such as a table. A Null value indicates that you want to set permissions for any new database objects. The second parameter designates a <I>Table </I>object type. The third parameter serves as a verb; it indicates 
that the command will set a permission. Other constants indicate different actions, 
such as revoking permissions, that the method can launch. The fourth 
parameter grants the user full rights. The method and its parameters grant 
<I>MySecretGroup1 </I>full rights for all new tables in the UserLevel.mdb database file with the 
systemdemo.mdw workgroup information file.</P>

<P>
This basic design is flexible and can serve in many different situations. 
For example, to revoke all rights for new tables, you change the third 
parameter for the <I>SetPermissions </I>method from 
<I>adAccessSet </I>to <I>adAccessRevoke</I>. To set 
rights for an existing database object, you replace the Null for the first parameter 
with the database object's name.</P>

<A NAME="347"><H3>Putting it all together</H3></A>


<P>The following two procedures tap a cross-section of prior samples and show 
a new twist to the <I>SetPermissions </I>method. The first procedure calls the 
<I>makeGroup </I>procedure to create a new group in the systemdemo.mdw workgroup 
information file. Then it invokes the second procedure and passes along the 
new group's name as well as the name of a database object for which it wants 
to assign permissions. The last two lines in the first procedure create a new 
user named NewUser2 and add <I>MySecretGroup2 </I>to its 
<I>Groups </I>collection. In this way, NewUser2 inherits the permissions assigned to 
<I>MySecretGroup2 </I>by the second procedure.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<PRE>Sub callSetRIDTablePermissionsForGroupTable()

'This procedure makes a group called MySecretGroup2 and
'assigns Read/Insert/Delete Permissions for
'WebBasedList table to MySecretGroup2.
'Then, it creates NewUser2 and assigns
'MySecretGroup2 to NewUser2.

'Before running this, delete MySecretGroup2 and
'NewUser2 from UserLevel.mdb if they exist.

makeGroup &quot;MySecretGroup2&quot;
setRIDTablePermissionsForGroupTable &quot;MySecretGroup2&quot;, &quot;WebBasedList&quot;
makeUser &quot;NewUser2&quot;
AddGroupToUser &quot;NewUser2&quot;, &quot;MySecretGroup2&quot;

End Sub


Sub setRIDTablePermissionsForGroupTable(grpName As String, tblName)
Dim cat1 As New ADOX.Catalog
Dim grp1 As New ADOX.Group, usr1 As New ADOX.User

cat1.ActiveConnection = _
    &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
    &quot;Data Source=C:\Programming Access\Chap10\UserLevel.mdb;&quot; &amp; _
    &quot;Jet OLEDB:System database=C:\Program Files\Microsoft Office\&quot; &amp; _
    &quot;Office\systemdemo.mdw;&quot; &amp; _
    &quot;User Id=Admin;Password=password;&quot;

cat1.Groups(grpName).SetPermissions tblName, adPermObjTable, adAccessSet, _
    adRightRead Or adRightInsert Or adRightDelete

End Sub
</PRE>
</TD></TR></TABLE></P>


<P>The second procedure assigns read, insert, and delete permissions for 
the <I>WebBasedList </I>table in UserLevel.mdb to 
<I>MySecretGroup2</I>. This procedure is similar to the earlier sample that applied for rights to a specific database 
object, but this one concatenates three separate rights to get a combined set 
of permissions. Notice that the syntax uses an Or operator for concatenating rights.</P>

</BODY>
</HTML>





