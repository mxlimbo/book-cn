<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Conditional Logic and Looping Constructs</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch01e.htm", "ch01g.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="22"><H1>Conditional Logic and Looping Constructs</H1></A>

<P>Conditional code execution and looping are at the heart of many 
code-based solutions. VBA offers a rich choice of options for implementing this kind of 
logic. The following sections review the major statement types that enable 
conditional program execution and looping and provide practical examples.</P>

<A NAME="23"><H2><I>If...Then</I></H2></A>
<P>Many procedures cannot achieve their objective by progressing 
sequentially through lines of code. It is often desirable to execute code 
conditionally&#8212;to skip some lines and perform others. One flexible and robust way to 
achieve conditional execution in VBA procedures is with the 
<I>If&#8230;Then </I>statement. There are actually three major variations of this basic statement. The first 
variation conditionally performs a simple block of code. The syntax is</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
If <I>condition</I> Then
    'Statements
End If 
</pre>
</TD></TR></TABLE></P>


<P>One or more statements can reside within an <I>If&#8230;End If 
</I>block. The terminating <I>End If </I>marks the end of the block. VBA executes the statements 
within the block only when the condition evaluates to 
<I>True</I>. You can nest multiple <I>If&#8230;End If 
</I>blocks within one another.</P>

<P>A second variation of the <I>If&#8230;Then </I>statement enables your code to 
execute either of two blocks of code. It has this syntax:</P>


<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
If <I>condition</I> Then
    Statements1
Else
    Statements2
End If
</pre>
</TD></TR></TABLE></P>


<P>This form of the statement executes one of two blocks of code. When 
the condition is true, the statements in the first group execute. Otherwise, the 
statements in the second block execute.</P>


<P>While this design is more flexible than the first format, it's still limiting 
because you have only two options. You can, in fact, nest 
<I>If&#8230;Then </I>statements to enable more options, but VBA offers a third design that simplifies execution 
of any one of three or more statement blocks. The syntax is</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
If <I>condition1</I> Then
    'Statements
ElseIf <I>condition2</I> Then
    'Statements
Else
    'Statements
End If
</pre>
</TD></TR></TABLE></P>


<P>This form of the <I>If&#8230;Then </I>statement incorporates multiple conditions 
and three or more groups of statements. You can easily add new statement 
groups and conditions by inserting new <I>ElseIf 
</I>clauses with their own conditions and statements. This design is more powerful than the second variation not 
only because it can accommodate more conditions but because it restricts the 
execution of each statement block (except the last) to the case in which there is 
a precise match to a condition test. The second 
<I>If&#8230;Then </I>statement executes its second statement block whenever the condition for the first statement block 
is not true. When failing a match to the first condition does not automatically 
serve as a basis for executing the second statement block, you need the third 
style of the <I>If&#8230;Then </I>statement.</P>

<P>Consider the form shown in Figure 1-15. The form includes a text 
box, an option group, and a command button. The option group allows a user 
to designate a square or a cube operation on the numerical value in the text 
box. To compute the square of a number, you type the number in the text box, 
select Square It in the Compute Type option group, and then click Compute.</P>

<P><img src="Images/F01QH15.GIF" width=290 height=211 border=0>
</P><P><!-- CAPTION --><B>Figure 1-15.</B> <I>A form for calculating squares or cubes of numbers.</I><!-- /CAPTION -->
</P>

<P>The following code shows the two procedures that make this squaring 
operation possible. The <I>cmdComputer_Click</I> event procedure responds to the 
click. If the option group <I>(opgComputeType) 
</I>equals 1, the user selected the Square It option button. The procedure calls 
<I>MySquarer </I>when the option group equals 1. Otherwise, it ends without performing any computations.</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Sub cmdComputer_Click()
    If opgComputeType = 1 Then
        MySquarer txtInput.Value
    End If
End Sub

Sub MySquarer(MyOtherNumber As Double)
    dblResult = MyOtherNumber * MyOtherNumber
    MsgBox dblResult, vbInformation, _
        &quot;Programming Microsoft Access 2000&quot;
End Sub
</pre>
</TD></TR></TABLE></P>


<P>This <I>cmdComputer_Click </I>procedure uses the first 
<I>If&#8230;Then </I>structure. It merely conditionally executes a single statement block. In this case, the 
block consists of just one line. If the user selects Square It, 
<I>MySquarer </I>multiplies the text box's value by itself and presents the result in a message box.</P>

<P>If the user selects Cube It before clicking the command button, the 
code does nothing. The option group returns a value of 2, but there is no 
condition to detect this. In fact, it is all or nothing when the option group equals 1. 
The following code shows a new version of the event procedure along with the 
code to handle the situation in which the user does not select Square It.</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Sub cmdComputer_Click()
    If opgComputeType = 1 Then
        MySquarer txtInput.Value
    Else
        MyCuber txtInput.Value
    End If
End Sub

Sub MyCuber(MyOtherNumber As Double)
Dim dblResult As Double
    dblResult = MyOtherNumber ^ 3
    MsgBox dblResult, vbInformation, _
        &quot;Programming Microsoft Access 2000&quot;
End Sub
</pre>
</TD></TR></TABLE></P>


<P>The <I>cmdComputer_Click </I>procedure uses the second form of the 
<I>If&#8230;Then </I>statement. It calls <I>MySquarer 
</I>if <I>opgComputeType </I>equals 1 but otherwise 
calls <I>MyCuber</I>. This works correctly if the user selects Cube It. However, at least 
one problem remains: The form opens with neither option button selected. If a 
user enters a number in the text box and then clicks the command button, the 
form returns the cubed value of the number despite the fact that the user 
selected neither option button. The fault lies in the design of the 
<I>If&#8230;Then </I>statement. We need the third variation with two separate conditions&#8212;one for squaring and 
the other for cubing. The following code shows this design:</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Sub cmdComputer_Click()
    If opgComputeType = 1 Then
        MySquarer txtInput.Value
    ElseIf opgComputeType = 2 Then
        MyCuber txtInput.Value
    Else
        MsgBox &quot;Click a computation type&quot;, _
            vbCritical, _
            &quot;Programming Microsoft Access 2000&quot;
    End If
End Sub
</pre>
</TD></TR></TABLE></p>

<P>This sample includes two conditions. One tests whether the option 
group equals 1, and the other tests whether the option group equals 2. If the 
option group fails both tests, the procedure displays a message box reminding the 
user to click a computation type. If you add new option buttons to the option 
group for different computations, you can easily accommodate them. Just insert a 
new <I>ElseIf </I>clause with a special condition for each new button.</P>

<P>As you can see, the <I>If&#8230;Then </I>statement is very flexible. You can use it 
to handle many possible options, but it handles one or two items even more 
easily. Its syntax also changes slightly depending on what you are trying to accomplish.</P>

<A NAME="24"><H2><I>Select Case</I></H2></A>
<P>The <I>Select Case </I>statement does one thing: It evaluates an expression and 
conditionally executes one block of statements. When you work with more 
than one or two conditional options, the <I>Select Case 
</I>statement can be simpler to set up and easier to maintain than the 
<I>If&#8230;Then </I>statement. The general syntax 
for <I>Select Case </I>is</P>


<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Select Case <I>test expression</I>
    Case <I>expression list-1</I>
        'Statements
    Case <I>expression list-2</I>
        'Statements
    Case Else
        'Statements
End Select
</pre>
</TD></TR></TABLE></P>


<P>Notice that <I>Select Case </I>evaluates an initial test expression. This can be 
as simple as a passed parameter or as complicated as a rocket science 
expression. <I>expression list-1 </I>and <I>expression list-2 
</I>are ranges (or specific values) for the test expression. Some options for specifying expression lists include constants, 
delimited items in a series, or expressions that evaluate to 
<I>True</I> or <I>False</I>. When an expression list is true because it matches the test expression, the 
corresponding block of statements execute. The syntax sample above shows just two 
lists, but you can add more by inserting additional 
<I>Case </I>statements. The <I>Case Else </I>clause is optional, but it is good programming practice. This option 
captures any test expression values not trapped by the preceding 
<I>Case </I>clauses. You can nest <I>Select Case 
</I>statements within each other; each instance must start with 
<I>Select Case </I>and terminate with <I>End 
Select</I>.</P>

<P>Figure 1-16 shows a <I>Select Case </I>statement used in a function 
procedure. This procedure can perform one of four numerical operations on a pair 
of numbers passed to it. A string argument specifies the operation, and the 
Immediate window shows the result of the operation. As you can see from 
the Immediate window, the expression list tests are not case sensitive.</P>

<P>A misspelled operation causes the <I>Case Else 
</I>clause to operate. In this situation, the function prints a message in the Immediate window announcing 
that the operation is not valid.</P>

<P><A HREF="javascript:fullSize('F01QH16x.htm')"> <img src="Images/F01QH16.JPG" width=404 height=334 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 1-16.</B> <I>A function procedure and output illustrating the use of the </I>Select Case<I> statement.</I><!-- /CAPTION -->
</P>
 
<A NAME="25"><H2><I>For...Next</I></H2></A>
<P>The <I>For&#8230;Next </I>statement is most obviously used for looping through a 
block of statements a known number of times. Since you can conditionally branch 
out of this kind of loop with an <I>Exit For </I>statement, you can also use the 
<I>For&#8230;Next </I>statement when you are not sure how many times to run before stopping. 
However, you must specify a maximum number of loops. The general syntax for 
the statement is</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
For <I>counter</I> = <I>start</I> To <I>stop</I> Step <I>step</I>
    'Statements
    If <I>condition</I> Then
        Exit For
    End If
    'Statements
Next <I>counter</I>
</pre>
</TD></TR></TABLE></P>


<P>The <I>For </I>loop extends from the <I>For counter 
</I>line to the <I>Next counter</I> line. The <I>For&#8230;Next 
</I>statement initializes <I>counter </I>to the value of 
<I>start</I> and then executes the statements between 
<I>For </I>and <I>Next. </I>The flow of execution then 
returns to the top of the <I>For</I> loop, where 
<I>counter</I> is incremented by the optional 
<I>step</I>. (<I>counter</I> is incremented by 1 if 
<I>step</I> is not specified.)</P>

<P>The statements in the <I>For</I> loop are executed repeatedly until the value 
of <I>counter </I>exceeds <I>stop</I> (or when 
<I>counter</I> is less than <I>stop</I> if 
<I>step</I> is a negative number). Control then passes to the statement immediately following the 
<I>Next counter </I>statement. The optional <I>Exit For 
</I>statement causes the <I>For</I> loop to terminate prior to 
<I>counter </I>exceeding <I>stop</I>.</P>

<P>You can nest <I>For&#8230;Next </I>statements within one another. An inner 
loop passes control to an outer one when <I>counter 
</I>exceeds <I>stop</I>. VBA can generate a run-time error if it encounters a 
<I>Next </I>statement without a matching <I>For 
</I>statement, but you are likely to get a syntax error as you design your procedures.</P>

<P>The <I>CountFor </I>procedure (see below) applies 
<I>For&#8230;Next </I>logic while reinforcing techniques for working with arrays and 
<I>Static </I>declarations. (The array <I>aryMyArray 
</I>has five elements. Recall that array indexing begins with 0 
unless your code explicitly specifies otherwise.) Next, the code declares an 
<I>Integer </I>variable to serve as a counter. The 
<I>For&#8230;Next </I>statement successively assigns 
the values 1_5 to the counter variable, 
<I>intIndex</I>.</P>

<P>Two statements execute for each pass through the loop. First the 
value of an element in <I>aryMyArray </I>accumulates the current value of 
<I>intIndex </I>to its current value. Since the code declares 
<I>aryMyArray </I>with a <I>Static </I>statement, 
the array elements retain their values on successive runs through the 
procedure. After the first pass through the procedure, the array elements are the 
successive values of <I>intIndex</I>. After the second pass through the 
procedure, <I>aryMyArray </I>elements are twice the successive values of 
<I>intIndex</I>&#8212;and so on for each successive pass through the procedure. The second statement 
prints the current value of <I>intIndex </I>and the associated element of the array. Recall 
that you can reinitialize the value of the array elements to 0 by choosing 
Run-Reset from the VBE Run menu.</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Sub CountFor()
Static aryMyArray(4) As Integer
Dim intIndex As Integer
    For intIndex = 1 To 5
        aryMyArray(intIndex - 1) = _
            aryMyArray(intIndex - 1) + intIndex
        Debug.Print intIndex, aryMyArray(intIndex - 1)
    Next intIndex
    Debug.Print vbLf
End Sub
</pre>
</TD></TR></TABLE></P>


<P>Figure 1-17 shows Immediate window output for three successive 
runs through the procedure. The first column shows the successive values 
of <I>intIndex</I>,<I> </I>and the second column shows the corresponding values of the 
array elements. On the first run through the procedure, the array elements 
exactly match <I>intIndex</I>. On the second and third passes, the array element values 
are twice and three times the <I>intIndex </I>values. This accumulating outcome 
shows the impact of a <I>Static </I>variable declaration. The values of 
<I>intIndex </I>and <I>aryMyArray </I>exactly match each other on all passes through the procedure 
if you change the <I>Static </I>keyword in the <I>aryMyArray 
</I>declaration to <I>Dim</I>.</P>

<P><img src="Images/F01QH17.GIF" width=199 height=382 border=0>
</P><P><!-- CAPTION --><B>Figure 1-17.</B> <I>The Immediate window showing the result of running the </I>CountFor <I>procedure three successive times.</I><!-- /CAPTION -->
</P>

<A NAME="26"><H2><I>For Each...Next </I>and <I>With...End With</I></H2></A>
<P>The <I>For Each&#8230;Next </I>and <I>With&#8230;End With 
</I>statements can work together nicely for form data validation and classic enumeration tasks. 
<I>For Each&#8230;Next </I>iterates through any collection (such as the controls on a form) or array. It does 
not require that your application know the number of elements in the 
collection or array. The <I>With&#8230;End With 
</I>statement can complement <I>For Each&#8230;Next 
</I>by simplifying how you code multiple controls in a statement block.</P>

<P>The <I>For Each&#8230;Next </I>statement is both similar to and slightly less 
complicated than the <I>For&#8230;Next </I>statement. It is similar to 
<I>For&#8230;Next </I>in that its loop starts with a line that begins with 
<I>For </I>and ends with a line that begins with 
<I>Next</I>. However, the design of the <I>For 
</I>and <I>Next </I>lines are different for both 
versions of the <I>For </I>loop. The <I>For Each&#8230;Next 
</I>statement is less complicated than the <I>For&#8230;Next 
</I>statement because you do not have to track three separate 
parameters (<I>counter</I>, <I>start</I>, and 
<I>stop</I>) or worry about a positive or negative 
<I>step</I> value. The <I>For Each&#8230;Next </I>statement always starts at the beginning and loops 
forward until it reaches the end of a collection or the elements in an array. The 
general syntax for the statement is</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
For Each <I>element</I> In <I>group</I>
    'Statements
    If <I>condition</I> Then
        Exit For
    End If
    'Statements
Next <I>element</I>
</pre>
</TD></TR></TABLE></P>


<P>The <I>group </I>term in the first line of the 
<I>For Each&#8230;Next </I>statement refers to the collection or the array name. The 
<I>element </I>in both the first and last lines designates individual objects in a collection or elements in an array.</P>

<P>The <I>For Each&#8230;Next </I>statement repetitively executes the statements in 
its body for each element in the specified collection or array. You will often 
want an <I>Exit For </I>or other conditionally executed statement somewhere in the 
body of the <I>For </I>loop. This enables your code to respond dynamically to a 
special outcome in its environment. The condition test identifies this special 
outcome, and the <I>Exit For </I>or other conditionally executed statements engage only 
when the outcome occurs.</P>

<P>As with the <I>For&#8230;Next </I>statement, <I>For Each&#8230;Next 
</I>statements can nest inside one another. At the conclusion of a 
<I>For Each&#8230;Next </I>loop, control passes to the first statement following the loop.</P>

<P>The <I>With&#8230;End With </I>statement simplifies the referencing of several 
different properties or methods of the same object. You specify the object 
whose properties or methods you want to reference in the beginning 
<I>With </I>line, and you close the reference to that object with the 
<I>End With </I>line at the end of the block. Between the 
<I>With </I>and the <I>End With </I>lines you can access the 
object's properties or methods without specifying the object name. The following 
code shows the general syntax of the <I>With&#8230;End With 
</I>statement:</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
With <I>object</I>
    .<I>propertyname1</I> = &quot;new value1&quot;
    .<I>propertyname2</I> = &quot;new value 2&quot;
    .<I>method1</I>
    .<I>method2</I>
End With
</pre>
</TD></TR></TABLE></P>


<P><I>object</I> is the name of an object, a reference to an object, or an array 
name. <I>propertyname1</I> and 
<I>propertyname2</I> are properties of the object, and 
<I>method1</I> and <I>method2</I> are methods of the object. As you can see, the 
<I>With&#8230;End With </I>statement facilitates access to an object's properties and methods.</P>

<P>Figures 1-18, 1-19, and 1-20 show a data validation form in action. 
Although the form has only a pair of text boxes that require validation, the 
form's code uses a <I>For Each&#8230;Next </I>loop that can be expanded to accommodate 
more text box controls. You can make a slight change to include other types of 
controls in the validation procedure. Figure 1-18 shows the layout of the basic 
Input form with a pair of text boxes and a command button.</P>

<P>Clicking the Do It! command button invokes an event procedure 
that checks the text boxes to make sure they do not contain Nulls. If either 
control contains a Null, the event procedure displays a message box reminding the 
user to enter information in both text boxes.</P>

<P>The event procedure also calls a procedure that changes the 
background of each text box that contains a Null from white to yellow. The procedure 
also moves the focus to the last text box that contains a Null. The background 
stays yellow until the user updates the data in the text box.</P>

<P>Figure 1-19 shows a text box that contained a Null but now contains 
1. The background of the text box changes back to white as soon as the user 
enters some information and moves the focus off the text box. Figure 1-20 shows 
the form after the new value updates the text box's value.</P>

<P>The following pair of procedures&#8212;named 
<I>cmdSubmit_Click</I> and <I>MarkFieldsToEdit</I>&#8212;examines the text boxes and yellow-highlights any text 
box that contains a Null. The <I>Click </I>event procedure for the command button 
loops through all the controls on the form. This includes text box as well as 
non_text box controls. The event procedure uses a 
<I>TypeOf </I>keyword to detect which control is a text box. Failure to take this measure can result in a run-time 
error because not all controls have a <I>Value 
</I>property. If the event procedure detects a text box control, it queries the control's 
<I>Value </I>property to determine whether it contains a Null. Any control with a Null triggers the code inside the 
<I>If&#8230;Then </I>statement. This code displays the message box and calls the procedure to 
highlight the control with the missing entry.</P>

<P><A HREF="javascript:fullSize('F01QH18x.htm')"> <img src="Images/F01QH18.JPG" width=404 height=214 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 1-18.</B> <I>The result of clicking the Do It! command button when at least one text box contains a Null.</I><!-- /CAPTION -->
</P>

<P><img src="Images/F01QH19.GIF" width=368 height=227 border=0>
</P><P><!-- CAPTION --><B>Figure 1-19.</B> <I>A yellow-highlighted text box that contained a Null but now contains 1.</I><!-- /CAPTION -->
</P>

<P><img src="Images/F01QH20.GIF" width=368 height=227 border=0>
</P><P><!-- CAPTION --><B>Figure 1-20.</B> <I></I>After the user enters information and moves the focus, the text box's background color is reset to white.<!-- /CAPTION -->
</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Private Sub cmdSubmit_Click()
'Check for valid entries.
    For Each ctl In Screen.ActiveForm.Controls
        If TypeOf ctl Is TextBox Then
            If IsNull(ctl.Value) Then
                MsgBox &quot;Please enter information &quot; _
                    &amp; &quot;in both input boxes.&quot;, _
                    vbInformation, _
                    &quot;Programming Microsoft Access 2000&quot;
                MarkFieldsToEdit
                Exit For
            End If
        End If
    Next ctl
End Sub

Public Sub MarkFieldsToEdit()
    For Each ctl In Screen.ActiveForm.Controls
        If TypeOf ctl Is TextBox Then
            If IsNull(ctl.Value) Then
                With ctl
                    .BackColor = RGB(255, 255, 0)
                    .SetFocus
                End With
            End If
        End If
    Next ctl
End Sub
</pre>
</TD></TR></TABLE></P>


<P>The <I>MarkFieldsToEdit </I>procedure also uses the 
<I>TypeOf </I>keyword to identify text boxes. When it detects a text box that contains a Null, it uses 
a <I>With&#8230;End With </I>statement to change the control's background color and 
moves the focus to the control. This ensures that the last text box that contains 
Null has the focus at the end of the procedure.</P>

<P>Each of the event procedures in the code below fires on the 
<I>AfterUpdate </I>event. Each procedure uses a 
<I>With&#8230;End With </I>block to change the 
associated control's background color back to white if the background color is 
currently yellow. The <I>AfterUpdate</I> event occurs independently for both text boxes, 
but the code in each procedure is identical except for the name of the 
associated object (either <I>txtInput1 </I>or 
<I>txtInput2</I>).</P>


<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Private Sub txtInput1_AfterUpdate()
    With txtInput1
        If .BackColor = RGB(255, 255, 0) Then
            .BackColor = RGB(255, 255, 255)
        End If
    End With
End Sub


Private Sub txtInput2_AfterUpdate()
    With txtInput2
        If .BackColor = RGB(255, 255, 0) Then
            .BackColor = RGB(255, 255, 255)
        End If
    End With
End Sub
</pre>
</TD></TR></TABLE></P>


<A NAME="27"><H2><I>Do...Loop</I></H2></A>
<P>The <I>Do&#8230;Loop </I>statement is yet another variety of looping statement 
available with VBA. The <I>Do&#8230;Loop </I>statement is a more flexible alternative to 
the <I>While&#8230;Wend </I>statement&#8212;it has all the functionality of the 
<I>While&#8230;Wend </I>statement and more. VBA retains 
<I>While&#8230;Wend </I>for backward compatibility.</P>

<P>You can use a <I>Do </I>loop to repeatedly execute a group of statements 
until a condition evaluates to either <I>True</I> or 
<I>False</I>. The <I>Do&#8230;Loop </I>statement 
syntax explicitly supports performing its test of a condition either before executing 
a block of statements or immediately after executing the block. As with the 
other looping statements, there is also a special statement for exiting a block in 
the midst of its execution. The two variations of syntax for the 
<I>Do&#8230;Loop </I>statement are as follows:</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Do {While | Until} <I>condition</I>
    'Statements
    If <I>condition</I> Then
        Exit Do
    End If
    'Statements
Loop
</pre>
</TD></TR></TABLE></P>


<P>And:</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Do
    'Statements
    If <I>condition</I> Then
        Exit Do
    End If
    'Statements
Loop {While | Until} <I>condition</I>
</pre>
</TD></TR></TABLE></P>


<P>The first variation performs its condition evaluation before executing 
the statements in the loop. The other format evaluates the condition 
immediately after executing the statements. The condition test can use either a 
<I>While </I>keyword or an <I>Until </I>keyword. The 
<I>While </I>keyword causes the loop to continue executing as long as the condition is true; the 
<I>Until </I>keyword causes the loop to continue executing as long as the condition is false. Most 
experienced Access developers have written many 
<I>Do </I>loops for navigating through the records in a recordset until the detection of an EOF (end of file) or a BOF 
(beginning of file). As with the other VBA looping statements, you can exit 
<I>Do </I>loops in the middle of a statement block by using an 
<I>Exit Do</I> statement.</P>

<P>Figure 1-21 shows a pair of function procedures and their output to 
illustrate how to program <I>Do </I>loops. The <I>DaysToNextMonth 
</I>function accepts a date and returns the number of days from that date to the first of the next month. 
If you enter the current date, the procedure counts it as one of the days to 
the beginning of the next month. For example, there are two days (2/28/2000 
and 2/29/2000) from 2/28/2000 to the first day of the next month. The function 
starts by computing <I>dtmNextMonth</I>, which is the input date plus one month. (In 
this sample in Figure 1-21, the date is 
3/28/2000.) The procedure then sets the function's name, which serves as a counter variable, equal to 0. The third 
line launches a <I>Do </I>loop with a condition that tests for the inequality of the 
next month vs. the input date plus the quantity in the function's name. As long 
as they are unequal, the loop executes its block, which consists of one 
statement that increments the function's value by 1.</P>

<P><A HREF="javascript:fullSize('F01QH21x.htm')"> <img src="Images/F01QH21.JPG" width=404 height=348 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 1-21.</B> <I>A pair of function procedures that use condition tests at the beginning and end of a </I>Do loop.<!-- /CAPTION -->
</P>


<P>The <I>DaysFromFirstOfLastMonth </I>function shows the effect of a condition 
test at the end of a <I>Do </I>loop. The output shows the number of days from 
2/28/2000 to the first day of the previous month (1/1/2000). This equals 58 days, 
based on the 28 days in February and the last 30 days in January. This function 
begins by computing the previous month for the specified date. The 
function then passes that month to the <I>DateValue 
</I>function to determine the first day of that previous month. Just before starting the 
<I>Do </I>loop, the code sets 
<I>DaysFromFirstOfLastMonth</I> to 0. The code enters the loop without a 
condition test and increments <I>DaysFromFirstOfLastMonth 
</I>by 1. The condition test on the <I>Loop </I>line permits another pass through the loop as long as the input date 
minus <I>DaysFromFirstOfLastMonth </I>is less than the first of the previous month. 
In this way, the function counts 58 days from the input date to, but not 
including, the previous month's first day.</P>

</BODY>
</HTML>




