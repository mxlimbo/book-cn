<HTML>
<HEAD>
<TITLE>Opening and Closing Devices</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="ch02a.htm">[Previous]</A> <A HREF="ch02c.htm">[Next]</A><P>

<A NAME="11"><H1>Opening and Closing Devices</H1></A>

<p>One of the strengths of Windows is the sheer number of devices that it 
supports. In the context of this discussion, I define a device to be anything that 
allows communication. Table 2-1 lists some devices and their most common uses.</p>


<p><b>Table 2-1.</B>  <i>Various devices and their common uses</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Device  </th>
<th>Most Common Use  </th></tr>
<tr>
<td valign="top">File   </td>
<td valign="top">Persistent storage of arbitrary data  </td></tr>
<tr>
<td valign="top">Directory  </td>
<td valign="top"> Attribute and file compression settings </td></tr>
<tr>
<td valign="top">Logical disk drive  </td>
<td valign="top">Drive formatting  </td></tr>
<tr>
<td valign="top">Physical disk drive  </td>
<td valign="top">Partition table access  </td></tr>
<tr>
<td valign="top">Serial port  </td>
<td valign="top">Data transmission over a phone line  </td></tr>
<tr>
<td valign="top">Parallel port   </td>
<td valign="top">Data transmission to a printer  </td></tr>
<tr>
<td valign="top">Mailslot  </td>
<td valign="top">One-to-many transmission of data, usually over a network to a machine running Windows  </td></tr> 
<tr>
<td valign="top">Named pipe   </td>
<td valign="top">One-to-one transmission of data, usually over a network to a machine running Windows  </td></tr>
<tr>
<td valign="top">Anonymous pipe  </td>
<td valign="top">One-to-one transmission of data on a single machine (never over the network)  </td></tr>
<tr>
<td valign="top">Socket  </td>
<td valign="top">Datagram or stream transmission of data, usually over a network to any machine supporting sockets (The machine need not be running Windows.)  </td></tr>
<tr>
<td valign="top">Console   </td>
<td valign="top">A text window screen buffer  </td></tr>
</table></p>


<p>This chapter discusses how an application's threads communicate with 
these devices without waiting for the devices to respond. Windows tries to hide 
device differences from the software developer as much as possible. That is, once 
you open a device, the Windows functions that allow you to read and write data 
to the device are the same no matter what device you are communicating 
with. Although only a few functions are available for reading and writing data 
regardless of the device, devices are certainly different from one another. For 
example, it makes sense to set a baud rate for a serial port, but a baud rate has no 
meaning when using a named pipe to communicate over a network (or over the 
local machine). Devices are subtly different from one another, and I will not 
attempt to address all their nuances. However, I will spend some time addressing 
files because files are so common.</p>


<p>To perform any type of I/O, you must first open the desired device 
and get a handle to it. The way you get the handle to a device depends on 
the particular device. Table 2-2 lists various devices and the functions you 
should call to open them.</p>


<p><b>Table 2-2.</B>  <i>Functions for opening various devices</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Device  </th>
<th>Function Used to Open the Device  </th></tr>
<tr>
<td valign="top">File    </td>
<td valign="top"><I>CreateFile</I> (<I>pszName </I>is path name or UNC path name).  </td></tr>
<tr>
<td valign="top">Directory   </td>
<td valign="top"><I>CreateFile </I>(<I>pszName</I>is directory name or UNC directory name). Windows 2000 allows you to open a directory if you specify the FILE_FLAG_BACKUP_SEMANTICS flag in the call to 
<I>CreateFile</I>. Opening the directory allows you to change the directory's attributes (to normal, hidden, and so on) and its time stamp.  </td></tr>
<tr>
<td valign="top">Logical disk drive  </td>
<td valign="top"><I>CreateFile </I>(<I>pszName</I>is &quot;\\.\<I>x</I>:&quot;). Windows 2000 allows 
you to open a logical drive if you specify a string in the form 
of &quot;\\.\<I>x</I>:&quot; where <I>x</I> is a drive letter. For example, to open 
drive A, you specify &quot;\\.\A:&quot;. Opening a drive allows you to 
format the drive or determine the media size of the drive.  </td></tr>
<tr>
<td valign="top">Physical disk drive  </td>
<td valign="top"><I>CreateFile </I>(<I>pszName 
</I>is &quot;\\.\PHYSICALDRIVE<I>x</I>&quot;). Windows 2000 allows you to open a physical drive if 
you specify a string in the form of 
&quot;\\.\PHYSICALDRIVE<I>x</I>&quot; where 
<I>x</I> is a physical drive number. For example, to read 
or write to physical sectors on the user's first physical 
hard disk, you specify 
&quot;\\.\PHYSICALDRIVE0&quot;. Opening a physical drive allows you to access the hard drive's 
partition tables directly. Opening the physical drive is potentially 
dangerous; an incorrect write to the drive could make the 
disk's contents inaccessible by the operating system's file system.  </td></tr>
<tr>
<td valign="top">Serial port  </td>
<td valign="top"><I>CreateFile </I>(<I>pszName</I>is &quot;COM<I>x</I>&quot;).  </td></tr>
<tr>
<td valign="top">Parallel port  </td>
<td valign="top"><I>CreateFile </I>(<I>pszName</I>is &quot;LPT<I>x</I>&quot;).  </td></tr>
<tr>
<td valign="top">Mailslot server  </td>
<td valign="top"><I>CreateMailslot</I>(<I>pszName </I>is &quot;\\.\mailslot\<I>mailslotname</I>&quot;).  </td></tr>
<tr>
<td valign="top">Mailslot client  </td>
<td valign="top"><I>CreateFile </I>(<I>pszName</I>is &quot;\\<I>servername</I>\mailslot\<I>mailslotname</I>
&quot;).  </td></tr>
<tr>
<td valign="top">Named pipe server  </td>
<td valign="top"><I>CreateNamedPipe</I>(<I>pszName </I>is &quot;\\.\pipe\<I>pipename</I>&quot;).  </td></tr>
<tr>
<td valign="top">Named pipe client  </td>
<td valign="top"><I>CreateFile </I>(<I>pszName</I>is &quot;\\<I>servername</I>\pipe\<I>pipename</I>&quot;).  </td></tr>
<tr>
<td valign="top">Anonymous pipe    </td>
<td valign="top"><I>CreatePipe </I>client and server.  </td></tr>
<tr>
<td valign="top">Socket   </td>
<td valign="top"><I>socket</I>, <I>accept</I>, or <I>AcceptEx</I>.  </td></tr>
<tr>
<td valign="top">Console   </td>
<td valign="top"><I>CreateConsoleScreenBuffer</I> or <I>GetStdHandle.</I>  </td></tr>
</table></p>


<p>Each function in Table 2-2 returns a handle that identifies the device. 
You can pass the handle to various functions to communicate with the device. 
For example, you call <I>SetCommConfig</I> to set the baud rate of a serial port:</p>


<p>
<table cellpadding=5 width="95%"><tr><td><pre>BOOL SetCommConfig(
   HANDLE       hCommDev, 
   LPCOMMCONFIG pCC,
   DWORD        dwSize);
</pre></td></tr></table>
</p>


<p>And you use <I>SetMailslotInfo</I> to set the time-out value when waiting to 
read data:</p>


<p>
<table cellpadding=5 width="95%"><tr><td><pre>BOOL SetMailslotInfo(
   HANDLE hMailslot, 
   DWORD  dwReadTimeout);
</pre></td></tr></table>
</p>


<p>As you can see, these functions require a handle to a device for their 
first argument.</p>


<p>When you are finished manipulating a device, you must close it. For 
most devices, you do this by calling the very popular 
<I>CloseHandle </I>function:</p>


<p>
<table cellpadding=5 width="95%"><tr><td><pre>BOOL CloseHandle(HANDLE hObject);
</pre></td></tr></table>
</p>


<p>However, if the device is a socket, you must call 
<I>closesocket</I> instead:</p>


<p>
<table cellpadding=5 width="95%"><tr><td><pre>int closesocket(SOCKET s);
</pre></td></tr></table>
</p>


<p>Also, if you have a handle to a device, you can find out what type of 
device it is by calling <I>GetFileType</I>:</p>


<p>
<table cellpadding=5 width="95%"><tr><td><pre>DWORD GetFileType(HANDLE hDevice);
</pre></td></tr></table>
</p>


<p>All you do is pass to the <I>GetFileType</I> function the handle to a device, 
and the function returns one of the values listed in Table 2-3.</p>


<p><b>Table 2-3.</B>  <i>Values returned by the</i> GetFileType <i>function</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Value  </th>
<th>Description  </th></tr>
<tr>
<td valign="top">FILE_TYPE_UNKNOWN   </td>
<td valign="top">The type of the specified file is unknown.  </td></tr>
<tr>
<td valign="top">FILE_TYPE_DISK   </td>
<td valign="top">The specified file is a disk file.  </td></tr>
<tr>
<td valign="top">FILE_TYPE_CHAR  </td>
<td valign="top"> The specified file is a character file, typically an 
LPT device or a console. </td></tr>
<tr>
<td valign="top">FILE_TYPE_PIPE  </td>
<td valign="top">The specified file is either a named or an 
anonymous pipe.  </td></tr>
</table></p>


<A NAME="12"><H2>A Detailed Look at <I>CreateFile</I></H2></A>

<p>The <I>CreateFile</I> function, of course, creates and opens disk files, but don't 
let the name fool you&#8212;it opens lots of other devices as well:</p>


<p>
<table cellpadding=5 width="95%"><tr><td><pre>HANDLE CreateFile(
   PCTSTR pszName, 
   DWORD  dwDesiredAccess,
   DWORD  dwShareMode,
   PSECURITY_ATTRIBUTES psa,
   DWORD  dwCreationDistribution, 
   DWORD  dwFlagsAndAttrs, 
   HANDLE hfileTemplate);
</pre></td></tr></table>
</p>


<p>As you can see, <I>CreateFile </I>requires quite a few parameters, allowing for 
a great deal of flexibility when opening a device. At this point, I'll discuss all 
these parameters in detail.</p>


<p>When you call <I>CreateFile</I>, the <I>pszName</I> parameter identifies the device 
type as well as a specific instance of the device.</p>


<p>The <I>dwDesiredAccess</I> parameter specifies how you want to transmit 
data to and from the device. You can pass four possible values, which are 
described in Table 2-4.</p>


<p><b>Table 2-4.</B>  <i>Values that can be passed for</i> CreateFile'<i>s</i> dwDesiredAccess <i>parameter</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Value    </th>
<th>Meaning  </th></tr>
<tr>
<td valign="top">0 </td>
<td valign="top">You do not intend to read or write data to the 
device. Pass 0 when you just want to change the device's 
configuration settings&#8212;for example, if you want to change only 
a file's time stamp.  </td></tr>
<tr>
<td valign="top">GENERIC_READ  </td>
<td valign="top">Allows read-only access from the device.  </td></tr>
<tr>
<td valign="top">GENERIC_WRITE  </td>
<td valign="top">Allows write-only access to the device. For example, 
this value can be used to send data to a printer and by 
backup software. Note that GENERIC_WRITE does not 
imply GENERIC_READ.  </td></tr>
<tr>
<td valign="top" nowrap>GENERIC_READ |<br> GENERIC_WRITE </td>
<td valign="top">Allows both read and write access to the device. This value is the most common since it allows the free exchange of data.  </td></tr>
</table></p>


<p>The <I>dwShareMode</I> parameter specifies device-sharing privileges. It is 
likely that a single device can and will be accessed by several computers at the 
same time (in a networking environment) or by several processes at the same time 
(in a multithreaded environment). The potential for device sharing means that 
you must think about whether you should and how you will restrict other 
computers or processes from accessing the device's data. Table 2-5 describes the 
possible values that can be passed for the <I>dwShareMode</I> parameter.</p>


<p><b>Table 2-5.</B>  <i>Values related to I/O that can be passed for</i> CreateFile'<i>s</i> dwShareMode <i>parameter</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Value  </th>
<th>Meaning  </th></tr>
<tr>
<td valign="top">0    </td>
<td valign="top">You require that no other process is reading or 
writing to the device. If another process has opened the 
device, your call to <I>CreateFile </I>fails. If you successfully 
open the device, another process's call to <I>CreateFile 
</I>always fails.  </td></tr>
<tr>
<td valign="top">FILE_SHARE_READ  </td>
<td valign="top">You require that no other process is writing to 
the device. If another process has opened the device 
for write or exclusive access, your call to <I>CreateFile 
</I>fails. If you successfully open the device, another process's call 
to <I>CreateFile </I>fails if GENERIC_WRITE access is requested.  </td></tr>
<tr>
<td valign="top">FILE_SHARE_WRITE  </td>
<td valign="top">You require that no other process is reading from 
the device. If another process has opened the device 
for read or exclusive access, your call to <I>CreateFile 
</I>fails. If you successfully open the device, another process's call 
to <I>CreateFile </I>fails if GENERIC_READ access is requested.  </td></tr>
<tr>
<td valign="top" nowrap>FILE_SHARE_READ | <br>FILE_SHARE_WRITE </td>
<td valign="top"> You don't care if another process is reading from or writing to the device. If another process has opened the device for exclusive access, your call to <I>CreateFile </I> fails. If you successfully open the device, another process's call to <I>CreateFile </I>fails when exclusive read, exclusive write, or exclusive read/write access is requested.  </td></tr>
</table></p>


<p>
<div class="note"><blockquote><b>NOTE</B> <hr>
If you are opening a file, you can pass a pathname that is up 
to _MAX_PATH (defined as 260) characters long. However, you 
can transcend this limit by calling <I>CreateFileW</I> (the Unicode version of 
<I>CreateFile</I>) and precede the pathname with &quot;\\?\&quot;. Calling 
<I>CreateFileW</I> removes the prefix and allows you to pass a path that is almost 
32,000 Unicode characters long. Remember, however, that you must use 
fully qualified paths when using this prefix; the system does not process 
relative directories such as &quot;.&quot; and &quot;..&quot;. Also, each individual 
component of the path is still limited to _MAX_PATH characters.
</blockquote></div>
</p>


<p>The <I>psa </I>parameter points to a SECURITY_ATTRIBUTES structure 
that allows you to specify security information and whether or not you'd 
like <I>CreateFile</I>'s returned handle to be inheritable. The security descriptor inside 
this structure is used only if you are creating a file on a secure file system such 
as NTFS; the security descriptor is ignored in all other cases. Usually, you just 
pass NULL for the <I>psa </I>parameter, indicating that the file is created with 
default security and that the returned handle is noninheritable.</p>


<p>The <I>dwCreationDistribution</I> parameter is most meaningful 
when <I>CreateFile</I> is being called to open a file as opposed to another type of 
device. Table 2-6 lists the possible values that you can pass for this parameter.</p>


<p><b>Table 2-6.</B>  <i>Values that can be passed for</i> CreateFile'<i>s</i> dwCreationDistribution <i>parameter</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Value  </th>
<th>Meaning  </th></tr>
<tr>
<td valign="top">CREATE_NEW   </td>
<td valign="top">Tells <I>CreateFile</I> to create a new file and to fail if 
a file with the same name already exists.  </td></tr>
<tr>
<td valign="top">CREATE_ALWAYS   </td>
<td valign="top">Tells <I>CreateFile </I>to create a new file regardless 
of whether a file with the same name already exists. 
If a file with the same name already exists, 
<I>CreateFile </I>overwrites the existing file.  </td></tr>
<tr>
<td valign="top">OPEN_EXISTING    </td>
<td valign="top">Tells <I>CreateFile </I>to open an existing file or 
device and to fail if the file or device doesn't exist.  </td></tr>
<tr>
<td valign="top">OPEN_ALWAYS  </td>
<td valign="top">Tells <I>CreateFile </I>to open the file if it exists and 
to create a new file if it doesn't exist.  </td></tr>
<tr>
<td valign="top">TRUNCATE_EXISTING   </td>
<td valign="top">Tells <I>CreateFile </I>to open an existing file, truncate 
its size to 0 bytes, and fail if the file doesn't already exist.  </td></tr>
</table></p>

<p>
<div class="note"><blockquote><b>NOTE</B> <hr>
When you are calling <I>CreateFile</I> to open a device other than a file, 
you must pass OPEN_EXISTING for the <I>dwCreationDistribution</I> parameter.
</blockquote></div>
</p>


<p><I>CreateFile</I>'s <I>dwFlagsAndAttrs</I> parameter has two purposes: it allows 
you to set flags that fine-tune the communication with the device, and if the 
device is a file, you also get to set the file's attributes. Most of these 
communication flags are signals that tell the system how you intend to access the device. 
The system can then optimize its caching algorithms to help your application 
work more efficiently. I'll describe the communication flags first and then discuss 
the file attributes.</p>

<A NAME="13"><H3><I>CreateFile</I> Cache Flags</H3></A>

<p>
<B>FILE_FLAG_NO_BUFFERING</B> This flag indicates not to use any data 
buffering when accessing a file. To improve performance, the system caches data 
to and from disk drives. Normally you do not specify this flag, and the cache 
manager keeps recently accessed portions of the file system in memory. This way, 
if you read a couple of bytes from a file and then read a few more bytes, the 
file's data is most likely loaded in memory, and the disk has to be accessed only 
once instead of twice, greatly improving performance. However, this process 
does mean that portions of the file's data are in memory twice: the cache 
manager has a buffer, and you called some function (such as <I>ReadFile</I>) 
that copied some of the data from the cache manager's buffer into your own buffer.
</p>


<p>When the cache manager is buffering data, it might also read ahead 
so that the next bytes you're likely to read are already in memory. Again, 
speed is improved by reading more bytes than necessary from the file. Memory 
is potentially wasted if you never attempt to read further in the file. (See 
the FILE_FLAG_SEQUENTIAL_SCAN and FILE_FLAG_RANDOM_ACCESS flags, 
discussed next, for more about reading ahead.)</p>


<p>By specifying the FILE_FLAG_NO_BUFFERING flag, you tell the 
cache manager that you do not want it to buffer any data&#8212;you take on this 
responsibility yourself! Depending on what you're doing, this flag can improve 
your application's speed and memory usage. Because the file system's device 
driver is writing the file's data directly into the buffers that you supply, you must 
follow certain rules:</p>

<UL>

<p><li>You must always access the file by using offsets that are exact 
multiples of the disk volume's sector size. (Use the <I>GetDiskFreeSpace</I> 
function to determine the disk volume's sector size.)</li></p>


<p><li>You must always read/write a number of bytes that is an exact 
multiple of the sector size.</li></p>


<p><li>You must make sure that the buffer in your process's address 
space begins on an address that is integrally divisible by the sector size.</li></p>
</UL>


<p>
<B>FILE_FLAG_SEQUENTIAL_SCAN and FILE_FLAG_RANDOM_ACCESS</B>  
These flags are useful only if you allow the system to buffer the file data 
for you. If you specify the FILE_FLAG_NO_BUFFERING flag, both of 
these flags are ignored.
</p>


<p>If you specify the FILE_FLAG_SEQUENTIAL_SCAN flag, the 
system thinks you are accessing the file sequentially. When you read some data 
from the file, the system will actually read more of the file's data than the amount 
you requested. This process reduces the number of hits to the hard disk and 
improves the speed of your application. If you perform any direct seeks on the file, 
the system has spent a little extra time and memory caching data that you are 
not accessing. This is perfectly OK, but if you do it often, you'd be better off 
specifying the FILE_FLAG_RANDOM_ACCESS flag. This flag tells the system 
not to pre-read file data.</p>


<p>To manage a file, the cache manager must maintain some internal 
data structures for the file&#8212;the larger the file, the more data structures 
required. When working with extremely large files, the cache manager might not be 
able to allocate the internal data structures it requires and will fail to open the 
file. To access extremely large files, you must open the file using the FILE_
FLAG_NO_BUFFERING flag.</p>


<p>
<B>FILE_FLAG_WRITE_THROUGH</B> This is the last cache-related flag. It 
disables intermediate caching of file-write operations to reduce the potential for data 
loss. When you specify this flag, the system writes all file modifications directly to 
the disk. However, the system still maintains an internal cache of the file's data, 
and file-read operations use the cached data (if available) instead of reading 
data directly from the disk. When this flag is used to open a file on a network 
server, the Windows file-write functions do not return to the calling thread 
until the data is written to the server's disk drive.
</p>


<p>That's it for the buffer-related communication flags. Now let's discuss 
the remaining communication flags.</p>

<A NAME="14"><H3>Miscellaneous<I> CreateFile </I>Flags</H3></A>

<p>
<B>FILE_FLAG_DELETE_ON_CLOSE</B> Use this flag to have the file system 
delete the file after all handles to it are closed. This flag is most frequently 
used with the FILE_ATTRIBUTE_TEMPORARY attribute. When these two 
flags are used together, your application can create a temporary file, write to it, 
read from it, and close it. When the file is closed, the system automatically 
deletes the file&#8212;what a convenience!</p>


<p><B>FILE_FLAG_BACKUP_SEMANTICS</B> Use this flag in backup and restore 
software. Before opening or creating any files, the system normally performs 
security checks to be sure that the process trying to open or create a file has 
the requisite access privileges. However, backup and restore software is special 
in that it can override certain file security checks. When you specify the FILE_FLAG_
BACKUP_SEMANTICS flag, the system checks the caller's access token to see 
whether the Backup/Restore File and Directories privileges are enabled. If 
the appropriate privileges are enabled, the system allows the file to be opened. 
You can also use the FILE_FLAG_BACKUP_SEMANTICS flag to open a 
handle to a directory.</p>


<p><B>FILE_FLAG_POSIX_SEMANTICS</B> In Windows, filenames are 
case-preserved whereas filename searches are case-insensitive. However, the POSIX 
subsystem requires that filename searches be case-sensitive. The FILE_FLAG_
POSIX_SEMANTICS flag causes <I>CreateFile </I>to use a case-sensitive 
filename search when creating or opening a file. Use the FILE_FLAG_POSIX_
SEMANTICS flag with extreme caution&#8212;if you use it when you create a 
file, that file might not be accessible to Windows applications.</p>


<p><B>FILE_FLAG_OPEN_REPARSE_POINT</B> In my opinion, this flag should 
have been called FILE_FLAG_IGNORE_REPARSE_POINT since it tells the 
system to ignore the file's reparse attribute (if it exists). Reparse attributes allow 
a file system filter to modify the behavior of opening, reading, writing, and 
closing a file. Usually, the modified behavior is desired, so using the FILE_FLAG_OPEN_REPARSE_POINT flag is not recommended.</p>


<p><B>FILE_FLAG_OPEN_NO_RECALL </B> This flag tells the system not to restore 
a file's contents from offline storage (such as tape) back to online storage 
(such as a hard disk). When files are not accessed for long periods of time, the 
system can transfer the file's contents to offline storage, freeing up hard disk space. 
When the system does this, the file on the hard disk is not destroyed; only the data 
in the file is destroyed. When the file is opened, the system automatically 
restores the data from offline storage. The FILE_FLAG_OPEN_NO_RECALL 
flag instructs the system not to restore the data and causes I/O operations to 
be performed against the offline storage medium.</p>


<p><B>FILE_FLAG_OVERLAPPED </B> This flag tells the system that you want to 
access a device asynchronously. You'll notice that the default way of opening 
a device is synchronous I/O (not specifying FILE_FLAG_OVERLAPPED). Synchronous 
I/O is what most developers are used to. When you read data 
from a file, your thread is suspended, waiting for the information to be read. Once 
the information has been read, the thread regains control and continues executing.
</p>


<p>Because device I/O is slow when compared with most other 
operations, you might want to consider communicating with some devices 
asynchronously. Here's how it works: Basically, you call a function to tell the operating 
system to read or write data, but instead of waiting for the I/O to complete, your 
call returns immediately, and the operating system completes the I/O on your 
behalf using its own threads. When the operating system has finished performing 
your requested I/O, you can be notified. Asynchronous I/O is the key to 
creating high-performance service applications. Windows offers several different 
methods of asynchronous I/O, all of which are discussed in this chapter.</p>

<A NAME="15"><H3>File Attribute Flags</H3></A>

<p>Now it's time to examine the attribute flags for 
<I>CreateFile</I>'s <I>dwFlagsAndAttrs</I> 
parameter, described in Table 2-7. These flags are completely ignored by the 
system unless you are creating a brand new file and you pass NULL for <I>CreateFile</I>'s 
<I>hfileTemplate </I>parameter. Most of the attributes should already be familiar to you.</p>


<p><b>Table 2-7.</b> <i>File attribute flags that can be passed for</i> CreateFile'<i>s</i> dwFlagsAndAttrs <i>parameter</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Flag  </th>
<th>Meaning  </th></tr>
<tr>
<td valign="top">FILE_ATTRIBUTE_ARCHIVE  </td>
<td valign="top">The file is an archive file. Applications 
use this flag to mark files for backup or removal. When 
<I>CreateFile </I>creates a new file, this flag is automatically set.  </td></tr>
<tr>
<td valign="top">FILE_ATTRIBUTE_ENCRYPTED  </td>
<td valign="top">The file is encrypted.  </td></tr>
<tr>
<td valign="top">FILE_ATTRIBUTE_HIDDEN  </td>
<td valign="top">The file is hidden. It won't be included 
in an ordinary directory listing.  </td></tr>
<tr>
<td valign="top">FILE_ATTRIBUTE_NORMAL  </td>
<td valign="top">The file has no other attributes set. 
This attribute is valid only when it's used alone.  </td></tr>
<tr>
<td valign="top">FILE_ATTRIBUTE_NOT_CONTENT_INDEXED </td>
<td valign="top">The file will not be indexed by the content indexing service.  </td></tr>
<tr>
<td valign="top">FILE_ATTRIBUTE_OFFLINE   </td>
<td valign="top">The file exists, but its data has been moved to offline storage. This flag is useful for hierarchical storage systems.  </td></tr>
<tr>
<td valign="top">FILE_ATTRIBUTE_READONLY  </td>
<td valign="top">The file is read-only. Applications can 
read the file but can't write to it or delete it.  </td></tr>
<tr>
<td valign="top">FILE_ATTRIBUTE_SYSTEM   </td>
<td valign="top">The file is part of the operating system 
or is used exclusively by the operating system.  </td></tr>
<tr>
<td valign="top">FILE_ATTRIBUTE_TEMPORARY  </td>
<td valign="top">The file's data will be used only for a short time. The file system tries to keep the file's data in RAM rather than on disk to keep the access time to a minimum.  </td></tr>
</table>  </p>



<p>Use FILE_ATTRIBUTE_TEMPORARY if you are creating a 
temporary file. When <I>CreateFile</I> creates a file with the temporary attribute, 
<I>CreateFile </I>tries to keep the file's data in memory instead of on the disk. This makes 
accessing the file's contents much faster. If you keep writing to the file and the system 
can no longer keep the data in RAM, the operating system will be forced to 
start writing the data to the hard disk. You can improve the system's 
performance by combining the FILE_ATTRIBUTE_TEMPORARY flag with the FILE_
FLAG_DELETE_ON_CLOSE flag (discussed earlier). Normally, the 
system flushes a file's cached data when the file is closed. However, if the system 
sees that the file is to be deleted when it is closed, the system doesn't need to 
flush the file's cached data.</p>


<p>In addition to all these communication and attribute flags, a number 
of flags allow you to control the security quality of service when opening a 
named-pipe device. Since these flags are specific to named pipes only, I will not 
discuss them here. To learn about them, please read about the 
<I>CreateFile </I>function in the Platform SDK documentation.</p>


<p><I>CreateFile</I>'s last parameter, 
<I>hfileTemplate</I>, identifies the handle of an 
open file or is NULL. If <I>hfileTemplate</I> identifies a file handle, 
<I>CreateFile</I> ignores the attribute flags in the 
<I>dwFlagsAndAttrs</I> parameter completely and uses the 
attributes associated with the file identified by 
<I>hfileTemplate</I>. The file identified by 
<I>hfileTemplate</I> must have been opened with the GENERIC_READ flag 
for this to work. If <I>CreateFile</I> is opening an existing file (as opposed to creating 
a new file), the <I>hfileTemplate</I> parameter is ignored.</p>

<p>If <I>CreateFile</I> succeeds in creating or opening a file or device, the 
handle of the file or device is returned. If 
<I>CreateFile</I> fails, INVALID_HANDLE_VALUE is returned.</p>


<p><div class="note"><blockquote><b>NOTE</b><hr> Most Windows functions that return a handle return NULL when 
the function fails. However, <I>CreateFile</I> returns INVALID_HANDLE_
VALUE (defined as -1) instead. I have often seen code like this, 
which is incorrect:

<p><table cellpadding=5 width="95%"><tr><td>
<pre>HANDLE hfile = CreateFile(...);
if (hfile == NULL) {
   // We'll never get in here 
} else {
   // File may or may not be created OK
}
<img src="images/grayvellip.JPG" width=3 height=13 border="0">
</pre></td></tr></table>
</p>

<p>Here's the correct way to check for an invalid file handle:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>HANDLE hfile = CreateFile(...);
if (hfile == INVALID_HANDLE_VALUE) {
   // File not created
} else {
   // File created OK
}
<img src="images/grayvellip.JPG" width=3 height=13 border="0">
</pre></td></tr></table>
</p></blockquote></div>
</p>

</BODY>
</HTML>




