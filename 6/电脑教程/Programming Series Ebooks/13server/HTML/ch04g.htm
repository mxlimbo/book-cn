<HTML>
<HEAD>
<TITLE>Miscellaneous Service Control Program Functions</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="ch04f.htm">[Previous]</A> <A HREF="ch04h.htm">[Next]</A><P>

<A NAME="70"><H1>Miscellaneous Service Control Program Functions</H1></A>
<p>Windows offers just a few more service control functions. I'd like to 
mention them briefly to complete our discussion.</p>

<p>One function looks up a service's display name from its internal name:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
BOOL GetServiceDisplayName(
   SC_HANDLE hSCManager, 
   PCTSTR    pszServiceName,
   PTSTR     pszDisplayName,
   PDWORD    pdwChars);
</pre></td></tr></table>
</p>

<p>And another function does the reverse:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
BOOL GetServiceKeyName(
   SC_HANDLE hSCManager, 
   PCTSTR    pszDisplayName,
   PTSTR     pszServiceName,
   PDWORD    pdwChars);
</pre></td></tr></table>
</p>

<p>The parameters passed to these functions should be self-explanatory, so 
I won't go into them here. See the Platform SDK documentation for 
more information.</p>

<p>The <I>EnumServicesStatusEx </I>function asks the SCM to enumerate all 
the services (and their states) contained in the database:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
BOOL EnumServicesStatusEx(
   SC_HANDLE    hSCManager,
   SC_ENUM_TYPE InfoLevel,
   DWORD        dwServiceType,
   DWORD        dwServiceState,
   PBYTE        pbServices,
   DWORD        dwBufSize,
   PDWORD       pdwBytesNeeded,
   PDWORD       pdwServicesReturned,
   PDWORD       pdwResumeHandle,
   PCTSTR       pszGroupName); 
</pre></td></tr></table>
</p>

<p>The Services snap-in calls this function to populate its list of installed 
services. The first parameter, <I>hSCManager</I>, identifies the SCM whose services 
you wish to enumerate. The second parameter, 
<I>InfoLevel</I>, must be SC_ENUM_PROCESS_INFO, which tells the function that you wish to retrieve the 
name and service status for each service. Currently no other valid values exist for 
the <I>InfoLevel </I>parameter.</p>

<p>The third parameter, <I>dwServiceType</I>,<I> 
</I>tells the function to enumerate services or device drivers. For services, pass SERVICE_WIN32. The fourth 
parameter, <I>dwServiceState</I>,<I> </I>allows you to fine-tune your request. You can 
pass SERVICE_ACTIVE, SERVICE_INACTIVE, or SERVICE_STATE_ALL 
to enumerate running services, stopped services, or both. The last 
parameter, <I>pszGroupName</I>, allows you to fine-tune the set of returned services or 
device drivers even more. If <I>pszGroupName</I> identifies a group, only services that 
are part of the specified group are enumerated. If 
<I>pszGroupName</I> identifies an empty string (&quot;&quot;), services that are not part of any group are enumerated. Finally, 
if <I>pszGroupName</I> is NULL, all services are enumerated.</p>

<p>All the remaining parameters are concerned with the buffer that gets 
the returned data. When you call 
<I>EnumServicesStatusEx</I>, you pass it a buffer 
that will be filled with an array of ENUM_SERVICE_STATUS_PROCESS 
structures that look like this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
typedef struct _ENUM_SERVICE_STATUS_PROCESS {
   LPTSTR                 lpServiceName;
   LPTSTR                 lpDisplayName;
   SERVICE_STATUS_PROCESS ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESS, *LPENUM_SERVICE_STATUS_PROCESS; 
</pre></td></tr></table>
</p>

<p>Because each service has string data associated with it, the string data 
is copied to the end of the buffer. The fixed-size ENUM_SERVICE_
STATUS_PROCESS structures are contiguous at the beginning of the 
buffer, so you can easily iterate through the returned data structures. When the 
function returns, the DWORD pointed to by <I>pdwServicesReturned 
</I>contains the number of ENUM_SERVICE_STATUS_PROCESS structures that fit into 
the buffer.</p>

<p>The first time you call 
<I>EnumServicesStatusEx</I>, make sure that the 
DWORD pointed to by <I>pdwResumeHandle </I>is initialized to 0. This 
<I>pdwResumeHandle </I>is used in cases in which there is more data than your buffer can hold. If the 
buffer is too small, <I>EnumServicesStatusEx </I>fills this DWORD with a special value 
that it uses the next time you call 
<I>EnumServicesStatusEx</I> so that it knows where 
to continue the enumeration. The following code shows how to allocate a 
buffer that is large enough to hold all the service data so that multiple calls 
to <I>EnumServicesStatusEx </I>are not necessary:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>DWORD dwBytesNeeded, dwServicesReturned, dwResumeHandle = 0;
EnumServicesStatusEx(hSCManager, SC_ENUM_PROCESS_INFO, SERVICE_WIN32,
   SERVICE_STATE_ALL, NULL, 0, &amp;dwBytesNeeded, 
   &amp;dwServicesReturned, &amp;dwResumeHandle, NULL);

ENUM_SERVICE_STATUS_PROCESS* pessp =
   (ENUM_SERVICE_STATUS_PROCESS*) _alloca(dwBytesNeeded);
EnumServicesStatusEx(hSCManager, SC_ENUM_PROCESS_INFO, SERVICE_WIN32,
   SERVICE_STATE_ALL, (PBYTE) pessp, dwBytesNeeded, &amp;dwBytesNeeded,
   &amp;dwServicesReturned, &amp;dwResumeHandle, NULL);

for (DWORD dw = 0; dw &lt; dwServicesReturned; dw++) {
   // Refer to the members inside pessp, for example
   _tprintf(TEXT(&quot;%s\n&quot;), pessp[dw].lpDisplayName);
}
</pre></td></tr></table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
For the sake of clarity, the preceding code does not have any error 
checking. In particular, the call to <I>_alloca 
</I>could raise a stack overflow exception. Structured exception handling (SEH) is required to recover 
from this exception gracefully and without the service terminating. 
Using SEH in this code is particularly important because some machines 
running Windows 2000 Advanced Server and Windows 2000 Data 
Center might have well over 200 services installed on them.
</blockquote></div>
</p>

<p>The next function that I'll discuss allows you to determine which 
services depend on another service:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
BOOL EnumDependentServices(
   SC_HANDLE            hService, 
   DWORD                dwServiceState,
   ENUM_SERVICE_STATUS* pess,
   DWORD                dwBufSize,
   PDWORD               pdwBytesNeeded, 
   PDWORD               pdwServicesReturned);
</pre></td></tr></table>
</p>

<p>This function is similar to 
<I>EnumServicesStatusEx</I>,<I> </I>so all of its 
parameters should be self-explanatory. The Services snap-in calls this function if you 
try to stop a service on which other services depend. For example, if I try to 
stop the Workstation service, I get the dialog box shown in Figure 
4-1&#8212;<I>EnumDependentServices</I> was used to fill in the list of dependent services.</p>

<p>Many developers call <I>EnumDependentServices </I>recursively to get 
each service's dependent services. Doing so is not necessary because the SCM 
performs the recursion for you while processing the 
<I>EnumDependentServices </I>function. The set of services returned by this function is the complete set; your 
SCP application should simply iterate through the set to stop each of the 
services if desired.</p>

<p>
<img src="images/F04FJ01.JPG" width=384 height=269 border="0">
</p><p>
<!-- caption --><b>Figure 4-1.</b> <i>The dialog box displayed when an attempt is made to stop a service that has running dependent services</i><!-- /caption -->
</p>

<p>Finally we come to the last two service control functions, 
<I>QueryServiceObjectSecurity </I>and 
<I>SetServiceObjectSecurity</I>:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
BOOL QueryServiceObjectSecurity(
   SC_HANDLE            hService,
   SECURITY_INFORMATION dwSecurityInformation,
   PSECURITY_DESCRIPTOR psd,
   DWORD                dwBufSize,
   PDWORD               pdwBytesNeeded);

BOOL SetServiceObjectSecurity(
   SC_HANDLE            hService,
   SECURITY_INFORMATION dwSecurityInformation,
   PSECURITY_DESCRIPTOR psd);
</pre></td></tr></table>
</p>

<p>These two functions allow you to query and change a security 
descriptor associated with a service. These functions are rarely called because the 
default security placed on the service when <I>CreateService </I>is called is 
sufficient for most needs. See <A HREF="ch10a.htm">Chapter 10</A> for more discussion of security descriptors and 
related topics.</p>

</BODY>
</HTML>




