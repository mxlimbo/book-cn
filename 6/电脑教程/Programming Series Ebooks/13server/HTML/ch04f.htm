<HTML>
<HEAD>
<TITLE>Locking the SCM's Database</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="ch04e.htm">[Previous]</A> <A HREF="ch04g.htm">[Next]</A><P>

<A NAME="69"><H1>Locking the SCM's Database</H1></A>
<p>If you find yourself making several changes to services in the SCM's 
database, you might want to temporarily stop the SCM from starting any services 
by obtaining the SCM's lock. A good time to obtain the lock is when you want 
to query a service's configuration and then change it &quot;atomically.&quot; Locking 
the SCM might also be useful when the service is dependent on other services. 
To prevent the SCM from starting any more services, call the 
<I>LockServiceDatabase</I> function, passing it the handle returned from a call to 
<I>OpenSCManager </I>by using the SC_MANAGER_LOCK access:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
SC_LOCK LockServiceDatabase(SC_HANDLE hSCManager);
</pre></td></tr></table>
</p>

<p>The <I>LockServiceDatabase</I> function returns a value that identifies the 
lock. Hold on to this value because you'll need to pass it to 
<I>UnlockServiceDatabase </I>when you wish to release the lock:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
BOOL UnlockServiceDatabase(SC_LOCK scLock);
</pre></td></tr></table>
</p>

<p>Only one process at a time can own the SCM's lock, and of course, 
you should own the lock for as short a time as possible. If the process that owns 
the lock terminates, the SCM automatically reclaims the lock so that services 
can start again.</p>

<p>Note that the lock is not automatically released if you close the handle 
to the SCM. Consider this example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_LOCK);
// Lock the SCM's database
SC_LOCK scLock = LockServiceDatabase(hSCM);
CloseServiceHandle(hSCM);
// NOTE: The database is still locked
<img src="images/grayvellip.JPG" width=3 height=13 border="0">
UnlockServiceDatabase(scLock);
// The database is now unlocked
</pre></td></tr></table>
</p>

<p>The <I>QueryServiceLockStatus</I> function returns information that allows 
you to see the status of the SCM's lock:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
BOOL QueryServiceLockStatus(
   SC_HANDLE                  hSCManager,
   QUERY_SERVICE_LOCK_STATUS* pqsls,
   DWORD                      dwBufSize,
   PDWORD                     pdwBytesNeeded);
</pre></td></tr></table>
</p>

<p>If the SCM is locked, the function also returns which user account 
owns the lock and how long the lock has been owned. All this information is 
returned via a QUERY_SERVICE_LOCK_STATUS structure:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
typedef struct _QUERY_SERVICE_LOCK_STATUS {
   DWORD  fIsLocked;
   PTSTR  lpLockOwner;
   DWORD  dwLockDuration;
} QUERY_SERVICE_LOCK_STATUS, *LPQUERY_SERVICE_LOCK_STATUS;
</pre></td></tr></table>
</p>

<p>As with the <I>QueryServiceConfig </I>function, the buffer that you pass 
to <I>QueryServiceLockStatus </I>must actually be larger than the size of the 
structure. Again, this is because the structure contains a string value 
(<I>lpLockOwner</I>) that will be copied into the buffer immediately after the fixed-size structure.</p>

</BODY>
</HTML>




