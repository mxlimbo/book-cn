<HTML>
<HEAD>
<TITLE>Working with Registry Keys</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="ch05c.htm">[Previous]</A> <A HREF="ch05e.htm">[Next]</A><P>

<A NAME="77"><h1>Working with Registry Keys</h1></A>
<p>This section describes functions implemented by the system that can be used to access the system registry. Before discussing specific functions, however, I would like to make a distinction between two sets of functions: the registry functions, and the shell registry functions.</p>

<A NAME="78"><h2>Registry and Shell Registry Functions</h2></A>
<p>Registry functions are a basic set of functions, implemented by the system, for accessing the system registry. These functions have existed since the creation of the Win32 programming interface and reside in a DLL named AdvAPI32.dll. Anything that can be done with the registry can be implemented using the registry functions. They are characterized by the three-character prefix <i>Reg</i>&#8212;for example, <i>RegOpenKeyEx.</i></p>

<p>Shell registry functions are built on these &quot;regular&quot; registry functions and provide extended or simplified functionality. Shell registry functions are intended to ease access to the registry, as well as to enforce a more uniform usage of the registry by applications. These functions are available only when Microsoft Internet Explorer 4.0 or later is installed on the system.</p>

<p>To use the shell functions, you have to include the ShlWAPI.h header file in your source code as well as the ShlWAPI.lib file with your linker options. The regular registry functions do not require any special inclusions.</p>

<p>The shell functions are characterized by simpler parameter lists as well as the two-character prefix <i>SH</i>&#8212;for example, <i>SHCopyKey</i>.</p>

<p>Because the regular registry functions provide the base interface to the registry, I will be focusing on them in this chapter. However, I will make occasional mention of shell functions where appropriate.</p>

<A NAME="79"><h2>Opening Registry Keys</h2></A>
<p>Before you can begin storing and retrieving information in registry values, you must obtain a handle to a registry key. You can obtain a handle to a registry key in two basic ways: open an existing key or create a new key. The <i>RegOpenKeyEx</i> function should be used to open existing registry keys. It is prototyped as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
LONG RegOpenKeyEx(
   HKEY   hkeyRoot,
   PCTSTR pszSubKey,
   DWORD  ulOptions,
   REGSAM samDesired,
   PHKEY  phkResult);
</pre></td></tr></table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
The <i>RegOpenKey</i> function can also be used to obtain a handle to a registry key. However, you should always use the <i>Ex</i> version of a registry function, if it exists.
</blockquote></div>
</p>

<p>To open a subkey, you pass the handle of the root key for the <i>hkeyRoot</i> parameter. The handle should be either the parent of the subkey you want to open or some grandparent of the desired subkey. The system also allows you to pass any of the predefined root key values as listed in Table 5-1 to <i>hkeyRoot</i>. Typically, an application will have to make at least one call to <i>RegOpenKeyEx</i>, passing HKEY_LOCAL_MACHINE or HKEY_CURRENT_USER as the <i>hkeyRoot</i> parameter.</p>

<p>The <i>pszSubKey</i> parameter is the textual name of the key that you want to open. This name must include all keys between the desired key and the root, separated with backslash characters. For example, if you wanted to obtain a handle with read access to the HKEY_LOCAL_MACHINE\Software\Microsoft\Windows subkey, your call to <i>RegOpenKeyEx</i> would look something like the following:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
HKEY hkeyWindows;
LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
   TEXT(&quot;Software\\Microsoft\\Windows&quot;), NULL, KEY_READ, &amp;hkeyWindows);
</pre></td></tr></table>
</p>

<p>If you are opening a key that is an immediate subkey of the specified root key, you don't need to include parent key names or backslashes in the <i>pszSubKey</i> parameter; include only the name of the desired key. If you pass an empty string or a NULL value as the <i>pszSubKey</i> parameter, the system returns a new handle to the specified root key. Pass NULL to <i>pszSubKey</i> when you need a handle with security access that is different from that of the original root key handle.</p>

<p>The <i>ulOptions</i> parameter is currently unused and reserved for future use. For now, you should always pass zero for this parameter.</p>

<p>The <i>samDesired</i> parameter describes what your application intends to do with the requested registry key, and can be any combination of the flags described in Table 5-3. Avoid the temptation to pass KEY_ALL_ACCESS, because your application might have limited security access to a given registry key. Requesting only the access your application intends to use increases the odds of a successful call to <i>RegOpenKeyEx</i>.</p>

<p><b>Table 5-3.</b> <i>Flags that can be passed to</i> RegOpenKeyEx'<i>s</i> samDesired <i>parameter</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>Registry Access Flags</th>
			<th>Description</th>
		</tr>

		<tr>
			<td valign="top">KEY_ALL_ACCESS</td>
			<td valign="top">Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, KEY_NOTIFY, KEY_CREATE_SUB_KEY, KEY_CREATE_LINK, and KEY_SET_VALUE access</td>
		</tr>

		<tr>
			<td valign="top">KEY_CREATE_LINK</td>
			<td valign="top">Permission to create a symbolic link</td>
		</tr>

		<tr>
			<td valign="top">KEY_CREATE_SUB_KEY</td>
			<td valign="top">Permission to create subkeys</td>
		</tr>

		<tr>
			<td valign="top">KEY_ENUMERATE_SUB_KEYS</td>
			<td valign="top">Permission to enumerate subkeys</td>
		</tr>

		<tr>
			<td valign="top">KEY_EXECUTE</td>
			<td valign="top">Permission for read access</td>
		</tr>
		
		<tr>
			<td valign="top">KEY_NOTIFY</td>
			<td valign="top">Permission for change notifications</td>
		</tr>

		<tr>
			<td valign="top">KEY_QUERY_VALUE</td>
			<td valign="top">Permission to query subkey data</td>
		</tr>

		<tr>
			<td valign="top">KEY_READ</td>
			<td valign="top">Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY access</td>
		</tr>

		<tr>
			<td valign="top">KEY_SET_VALUE</td>
			<td valign="top">Permission to set subkey data</td>
		</tr>

		<tr>
			<td valign="top">KEY_WRITE</td>
			<td valign="top">Combination of KEY_SET_VALUE and KEY_CREATE_SUB_KEY access</td>
		</tr>
		
	</table>
</p>

<p>You should pass the address of an HKEY variable as the value of the <i>phkResult</i> parameter. The system fills this variable with the handle of the open key, if <i>RegOpenKeyEx</i> succeeds. The <i>RegOpenKeyEx</i> function returns ERROR_SUCCESS if it is successful and ERROR_FILE_NOT_FOUND if the key does not exist.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Unlike most other Windows functions, the registry functions return error codes. You should not call <i>GetLastError</i> to get more specific error information for a registry function.
</blockquote></div>
</p>

<A NAME="80"><h2>Creating Registry Keys</h2></A>
<p>The <i>RegCreateKeyEx</i> function allows you to create a key. You can also use the <i>RegCreateKeyEx</i> function to retrieve a handle to a key. Unlike <i>RegOpenKeyEx</i>, however, <i>RegCreateKeyEx</i> will not automatically fail if the key does not exist. Instead, it will attempt to create a new key with the name you provide. <i>RegCreateKeyEx</i> is prototyped as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
LONG RegCreateKeyEx(
   HKEY                 hkeyRoot,
   PCTSTR               pszSubKey, 
   DWORD                Reserved,
   PTSTR                pszClass, 
   DWORD                dwOptions, 
   REGSAM               samDesired,
   PSECURITY_ATTRIBUTES psa,
   PHKEY                phkResult,
   PDWORD               pdwDisposition);
</pre></td></tr></table>
</p>

<p>You will recognize the <i>hkeyRoot</i>, <i>pszSubKey</i>, <i>samDesired</i>, and <i>phkResult</i> parameters from the <i>RegOpenKeyEx</i> function. These parameters are used identically to those for <i>RegCreateKeyEx</i>, but with one noteworthy exception: if the key specified in the <i>pszSubKey</i> parameter does not already exist, the system attempts to create a new subkey to complete the request.</p>

<p>In addition to the familiar parameters, <i>RegCreateKeyEx</i> has a <i>pszClass</i> parameter, which points to a zero-terminated string with a class name for the key. The class name is reserved, and you should always pass NULL for this parameter.</p>

<p>The <i>dwOptions</i> parameter can be any of the values in Table 5-4.</p>

<p>The <i>psa</i> parameter points to a SECURITY_ATTRIBUTES structure, which allows you to define the access rights for the newly created subkey. The security descriptor information is ignored if the subkey already exists. (For more information on security and the registry, see <A HREF="ch10a.htm">Chapter 10</A>.)</p>

<p><b>Table 5-4.</b> <i>Values that can be passed for</i> RegCreateKeyEx'<i>s</i> dwOptions <i>parameter</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>Option Values</th>
			<th>Description</th>
		</tr>

		<tr>
			<td valign="top">REG_OPTION_NON_VOLATILE</td>
			<td valign="top">The key is created in the registry and is persistent on the system's hard disk.</td>
		</tr>

		<tr>
			<td valign="top">REG_OPTION_VOLATILE</td>
			<td valign="top">The key is stored in memory and does not persist when the system is restarted.</td>
		</tr>

		<tr>
			<td valign="top">REG_OPTION_BACKUP_RESTORE</td>
			<td valign="top">The key is used by backup software to back up and restore the registry.</td>
		</tr>
		
	</table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
The typical registry key is nonvolatile. Volatile data is always deleted when the computer reboots. Volatile keys are convenient for avoiding clutter while using keys that are only temporarily necessary. Volatile keys can be used to efficiently exchange data between processes&#8212;the communication even works well for processes operating on different machines because the registry is remoteable. (See the <i>RegConnectRegistry</i> function discussed later in &quot;<A HREF="ch05g.htm#85">Accessing the Registry Remotely</A>.&quot;)
</blockquote></div>
</p>

<p>The <i>pdwDisposition</i> parameter is a pointer to a DWORD variable that the system fills with one of two values: REG_CREATED_NEW_KEY or REG_OPENED_EXISTING_KEY. Examining the variable when the function returns reveals whether the function created the subkey or simply opened the existing subkey. Most of the time, your software does not need to know whether it actually created the subkey and, therefore, <i>RegCreateKeyEx</i> allows you to pass NULL for this last parameter.</p>

<p>Software commonly uses <i>RegCreateKeyEx</i> to create and open its keys for configuration data, understanding that the system might have created a new key for the software on the spot. <i>RegCreateKeyEx</i> provides a convenient way for an application to rebuild necessary portions of its configuration information with default data in the event that a registry key is deleted, which the curious administrator has been known to do from time to time.</p>

<p>Whether you received your handle to an open registry key by making a call to <i>RegCreateKeyEx</i> or by making a call to <i>RegOpenKeyEx</i>, you should always pass your open registry handles to <i>RegCloseKey</i> when you are finished using them:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
LONG RegCloseKey(HKEY hkey);
</pre></td></tr></table>
</p>

<A NAME="81"><h2>Enumerating Registry Keys</h2></A>
<p>When software is being installed or configured, it typically knows the required registry key names. However, in some cases, the subkey names within an open key may not be known. The <i>RegEnumKeyEx</i> function can be used to enumerate subkeys. <i>RegEnumKeyEx</i> has the following prototype:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
LONG RegEnumKeyEx(
   HKEY      hkey,
   DWORD     dwIndex, 
   PTSTR     pszName,
   PDWORD    pcbName, 
   PDWORD    pdwReserved,
   PTSTR     pszClass,
   PDWORD    pcbClass,
   PFILETIME pftLastWriteTime);
</pre></td></tr></table>
</p>

<p>Because your code must provide the buffers for the returned class name and key name values, it is your responsibility to pass buffers large enough to hold any subkey and class name; otherwise, the function will fail. To do this, you should make an initial call to <i>RegQueryInfoKey</i> to retrieve the length of the longest subkey and class names under the desired key. Your code must still be capable of handling an even longer subkey name, because a new subkey might be added between the times that your code calls <i>RegQueryInfoKey</i> and <i>RegEnumKeyEx</i>. The <i>RegQueryInfoKey</i> function is prototyped as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
LONG RegQueryInfoKey(
   HKEY      hkey,
   PTSTR     pszClass,
   PDWORD    pcbClass,
   PDWORD    pdwReserved,
   PDWORD    pcSubKeys,
   PDWORD    pcbMaxSubKeyLen,
   PDWORD    pcbMaxClassLen,
   PDWORD    pcValues,
   PDWORD    pcbMaxValueNameLen,
   PDWORD    pcbMaxValueLen,
   PDWORD    pcbSecurityDescriptor,
   PFILETIME pftLastWriteTime);
</pre></td></tr></table>
</p>

<p>The following code fragment illustrates how to enumerate subkey names under an arbitrary key:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
VOID PrintSubKeyNames(HKEY hkey) {

   // Get length of longest key name in characters
   DWORD dwMaxSubkeyLen;
   RegQueryInfoKey(hkey, NULL, NULL, NULL, NULL, &amp;dwMaxSubkeyLen, 
      NULL, NULL, NULL, NULL, NULL, NULL);

   // Add one for the NULL terminator
   dwMaxSubkeyLen++;

   // Allocate buffer for subkey names
   PTSTR pszKeyName = (PTSTR) _alloca(dwMaxSubkeyLen * sizeof(TCHAR));

   // Store buffer length
   DWORD dwKeyNameLen = dwMaxSubkeyLen;

   // Start from the beginning
   DWORD dwIndex = 0;
   FILETIME ftLastWritten;

   // Loop until failure
   while (ERROR_SUCCESS == RegEnumKeyEx(hkey, dwIndex++, pszKeyName,
      &amp;dwKeyNameLen, NULL, NULL, NULL, &amp;ftLastWritten)) {

      // Print key name
      _tprintf(TEXT(&quot;%s\n&quot;), pszKeyName);

      // Restore buffer length with each iteration
      dwKeyNameLen = dwMaxSubkeyLen;
   }
}
</pre></td></tr></table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
The shell registry functions include two functions that parallel the functionality of <i>RegQueryInfoKey</i> and <i>RegEnumKeyEx</i>. They are defined as follows:
<p>
<table cellpadding=5 width="95%"><tr><td><pre>
DWORD SHQueryInfoKey(
   HKEY   hkey,
   PDWORD pcSubKeys, 
   PDWORD pcchMaxSubKeyLen, 
   PDWORD pcValues, 
   PDWORD pcchMaxValueNameLen);  
</pre></td></tr></table>
</p>
and
<p>
<table cellpadding=5 width="95%"><tr><td><pre>
DWORD SHEnumKeyEx(
   HKEY   hkey,
   DWORD  dwIndex, 
   PTSTR  pszName, 
   PDWORD pcchName);
</pre></td></tr></table>
</p>
Notice that the shell registry functions are simpler to use because infrequently needed parameters are not required.
</blockquote></div>
</p>

</BODY>
</HTML>




