<HTML>
<HEAD>
<TITLE>Understanding Privileges and Account Rights</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="ch09e.htm">[Previous]</A> <A HREF="ch09g.htm">[Next]</A><P>

<A NAME="191"><h1>Understanding Privileges and Account Rights</h1></A>
<p>A privilege is a right assigned to a trustee that has system-wide ramifications. (In contrast, an access right assigned to a trustee defines access allowed to a specific object in the system.) Examples of privileges include the rights to log on locally, back up files and directories, and shut down the system.</p>

<p>Another way of looking at a privilege is as a way to secure a system function. For example, certain system functions, such as <i>LogonUser</i> and <i>InitiateSystemShutdown</i>, require that the calling software have the proper privileges or else the function will fail.</p> 

<p>Privileges have two textual representations you should be aware of. These representations are the <i>friendly name</i> that shows up in the user interface for Windows and the <i>programmatic name</i> used by your software. Each of the programmatic names is defined in a header file in the SDK.</p>

<p>Table 9-10 lists all the privileges available in Windows 2000 at the time of this book's printing. A partial list is given in the Platform SDK documentation.</p>

<p><b>Table 9-10.</b> <i>Privileges and account rights</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th>Programmatic Name</th>
			<th>Display Name</th>
			<th>Header File</th>
		</tr>

		<tr>
			<td valign="top">SeAssignPrimaryTokenPrivilege<br>
SE_ASSIGNPRIMARYTOKEN_NAME</td>
			<td valign="top">Replace a process level token</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeAuditPrivilege<br> 
SE_AUDIT_NAME</td>
			<td valign="top">Generate security audits</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeBackupPrivilege<br>
SE_BACKUP_NAME</td>
			<td valign="top">Back up files and directories</td>
			<td valign="top">WinNT.h</td>
		</tr>

 		<tr>
			<td valign="top">SeChangeNotifyPrivilege<br>
SE_CHANGE_NOTIFY_NAME</td>
			<td valign="top">Bypass traverse checking</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeCreatePagefilePrivilege<br>
SE_CREATE_PAGEFILE_NAME</td>
			<td valign="top">Create a pagefile</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeCreatePermanentPrivilege<br>
SE_CREATE_PERMANENT_NAME</td>
			<td valign="top">Create permanent shared objects</td>
			<td valign="top">WinNT.h</td>
		</tr>
 
		<tr>
			<td valign="top">SeCreateTokenPrivilege<br>
SE_CREATE_TOKEN_NAME</td>
			<td valign="top">Create a token object</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeDebugPrivilege<br>
SE_DEBUG_NAME</td>
			<td valign="top">Debug programs</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeEnableDelegationPrivilege<br>
SE_ENABLE_DELEGATION_NAME</td>
			<td valign="top">Enable computer and user accounts to be trusted for delegation</td>
			<td valign="top">WinNT.h</td>
		</tr>
		
		<tr>
			<td valign="top">SeIncreaseBasePriorityPrivilege<br>
SE_INC_BASE_PRIORITY_NAME</td>
			<td valign="top">Increase scheduling priority</td>
			<td valign="top">WinNT.h</td>
		</tr>
		
		<tr>
			<td valign="top">SeIncreaseQuotaPrivilege 
<br>SE_INCREASE_QUOTA_NAME</td>
			<td valign="top">Increase quotas</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeLoadDriverPrivilege<br>
SE_LOAD_DRIVER_NAME</td>
			<td valign="top">Load and unload device drivers</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeLockMemoryPrivilege<br>
SE_LOCK_MEMORY_NAME</td>
			<td valign="top">Lock pages in memory</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeMachineAccountPrivilege<br>
SE_MACHINE_ACCOUNT_NAME</td>
			<td valign="top">Add workstations to domain</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeProfileSingleProcessPrivilege
<br>SE_PROF_SINGLE_PROCESS_NAME</td>
			<td valign="top">Profile single process</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeRemoteShutdownPrivilege<br>
SE_REMOTE_SHUTDOWN_NAME</td>
			<td valign="top">Force shutdown from a remote system</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeRestorePrivilege<br>
SE_RESTORE_NAME</td>
			<td valign="top">Restore files and directories</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeSecurityPrivilege<br>
SE_SECURITY_NAME</td>
			<td valign="top">Manage auditing and security log</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top"> SeShutdownPrivilege<br>
SE_SHUTDOWN_NAME</td>
			<td valign="top">Shut down the system</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeSyncAgentPrivilege<br>
SE_SYNC_AGENT_NAME</td>
			<td valign="top">Synchronize directory service data</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeSystemEnvironmentPrivilege<br>
SE_SYSTEM_ENVIRONMENT_NAME</td>
			<td valign="top">Modify firmware environment values</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeSystemProfilePrivilege<br>
SE_SYSTEM_PROFILE_NAME</td>
			<td valign="top">Profile system performance</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeSystemtimePrivilege<br>
SE_SYSTEMTIME_NAME</td>
<td valign="top">Change the system time</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeTakeOwnershipPrivilege<br>
SE_TAKE_OWNERSHIP_NAME</td>
			<td valign="top">Take ownership of files or other objects</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeTcbPrivilege<br>
SE_TCB_NAME</td>
			<td valign="top">Act as part of the operating system</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeUndockPrivilege<br>
SE_UNDOCK_NAME</td>
			<td valign="top">Remove computer from docking station</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeUnsolicitedInputPrivilege<br>
SE_UNSOLICITED_INPUT_NAME</td>
			<td valign="top">Receive unsolicited device input</td>
			<td valign="top">WinNT.h</td>
		</tr>

		<tr>
			<td valign="top">SeBatchLogonRight<br>
SE_BATCH_LOGON_NAME</td>
			<td valign="top">Log on as a batch job</td>
			<td valign="top">NTSecAPI.h</td>
		</tr>

		<tr>
			<td valign="top">SeDenyBatchLogonRight<br>
SE_DENY_BATCH_LOGON_NAME</td>
			<td valign="top">Deny logon as a batch job</td>
			<td valign="top">NTSecAPI.h</td>
		</tr>

		<tr>
			<td valign="top">SeDenyInteractiveLogonRight<br>
SE_DENY_INTERACTIVE_LOGON_NAME</td>
			<td valign="top">Deny logon locally</td>
			<td valign="top">NTSecAPI.h</td>
		</tr>
  
		<tr>
			<td valign="top">SeDenyNetworkLogonRight<br>
SE_DENY_NETWORK_LOGON_NAME</td>
			<td valign="top">Deny access to this computer from the network</td>
			<td valign="top">NTSecAPI.h</td>
		</tr>

		<tr>
			<td valign="top">SeDenyServiceLogonRight<br>
SE_DENY_SERVICE_LOGON_NAME</td>
			<td valign="top">Deny logon as a service</td>
			<td valign="top">NTSecAPI.h</td>
		</tr>

		<tr>
			<td valign="top">SeInteractiveLogonRight<br>
SE_INTERACTIVE_LOGON_NAME</td>
			<td valign="top">Log on locally</td>
			<td valign="top">NTSecAPI.h</td>
		</tr>
 
		<tr>
			<td valign="top">SeNetworkLogonRight<br>
SE_NETWORK_LOGON_NAME</td>
			<td valign="top">Access this computer from the network</td>
			<td valign="top">NTSecAPI.h</td>
		</tr>

		<tr>
			<td valign="top">SeServiceLogonRight<br>
SE_SERVICE_LOGON_NAME</td>
			<td valign="top">Log on as a service</td>
			<td valign="top">NTSecAPI.h</td>
		</tr>
 
	</table>
</p>

<p>The system actually distinguishes between the privilege and its close cousin, the account right, but they are assigned and revoked identically. In Table 9-10, the privileges are defined in WinNT.h and the account rights are defined in NTSecAPI.h.</p> 

<p>Now that you have some familiarity with what privileges are and how the system represents them, let's dive into assigning and revoking privileges on a system.</p>

<A NAME="192"><h2>The LSA Functions</h2></A>
<p>To assign privileges programmatically, you need to become familiar with a set of functions known as the LSA functions. LSA stands for Local Security Authority, which handles user logon and authentication on the local machine. The LSA functions can be used to do a number of tasks, of which we will only be concerned with privilege assignment in this chapter.The first step in using the LSA functions is to retrieve a handle to a <i>policy object</i>. A policy object represents the system on which you will be performing account management functions. To obtain a handle to a policy object, you must call <i>LsaOpenPolicy</i>.</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
NTSTATUS LsaOpenPolicy(
   PLSA_UNICODE_STRING    plsastrSystemName,
   PLSA_OBJECT_ATTRIBUTES pObjectAttributes,
   ACCESS_MASK            DesiredAccess,
   PLSA_HANDLE            pPolicyHandle);
</pre></td></tr></table>
</p>

<p>This function might look a bit strange at first, because the data types aren't commonly used in other Win32 functions. So let's examine them one by one.</p>

<p>The <i>plsastrSystemName</i> parameter is a pointer to an LSA_UNICODE_STRING structure, which is defined as follows:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
typedef struct _LSA_UNICODE_STRING {
   USHORT Length;
   USHORT MaximumLength;
   PWSTR  Buffer;
} LSA_UNICODE_STRING
</pre></td></tr></table>
</p>

<p>Like the Net functions, the LSA functions deal only with strings in Unicode format. However, unlike the Net functions, the LSA functions require that all strings be managed in terms of the LSA_UNICODE_STRING structure, which is simply a string length, a buffer length, and a pointer to a buffer.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
It is important to remember that the <i>Length</i> (indicating the length of the string) and <i>MaximumLength</i> (indicating the length of the buffer) members are stored in terms of bytes, not characters.</blockquote></div>
</p>

<p>The string pointed to by the <i>Buffer</i> member of the LSA_UNICODE_STRING structure is not explicitly defined to be zero-terminated. Although you can choose to end a string with a zero, you must be sure not to include the null termination in your calculation of the length of the string. Also keep in mind that when the system returns an LSA_UNICODE_STRING structure to your software, it cannot count on zero termination of the string pointed to by the <i>Buffer</i> member.</p> 

<p>Dealing with the LSA_UNICODE_STRING type can be a little awkward because it is length-delimited rather than zero-terminated. Because of this, I think that the LSA_UNICODE_STRING virtually begs to be wrapped in a simple C++ class. I've made a class called CLSAStr, which does this, and use it liberally in the TrusteeMan sample application described later in this chapter.</p>

<p>To call <i>LsaOpenPolicy</i>, initialize an instance of the LSA_UNICODE_STRING structure and point it to a Unicode string containing the name of the system for which you wish to manipulate privileges. Passing NULL as the <i>plsastrSystemName</i> parameter indicates the local machine.</p>

<p>The <i>pObjectAttributes</i> parameter points to an instance of the LSA_OBJECT_ATTRIBUTES structure, which is unused at this time and should have each of its members initialized to 0.</p> 

<p>The <i>DesiredAccess</i> parameter is declared as type ACCESS_MASK, which maps to a 32-bit unsigned integer. If you will be viewing privilege information on your system, combine POLICY_VIEW_LOCAL_INFORMATION and POLICY_LOOKUP_NAMES as in the example that follows this discussion. If you will be setting privilege information, you should also combine the POLICY_CREATE_ACCOUNT access flag.</p>

<p>The final parameter of <i>LsaOpenPolicy</i> requires that you pass the address of a variable of type LSA_HANDLE. Upon success, the system will place the handle to the open LSA policy object in this variable. Once you have finished with the policy object, you should pass this handle to the <i>LsaClose</i> function:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
NTSTATUS LsaClose(LSA_HANDLE hObjectHandle);
</pre></td></tr></table>
</p>

<p>All LSA functions return a value of type NTSTATUS, and you should pass this value to <i>LsaNtStatusToWinError</i>:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
ULONG LsaNtStatusToWinError(NTSTATUS Status);
</pre></td></tr></table>
</p>

<p>The <i>LsaNtStatusToWinError</i> function converts the NT status code to a familiar Win32 error code just like those returned from <i>GetLastError.</i> After conversion, a successful call to <i>LsaOpenPolicy</i> returns a value of ERROR_SUCCESS.</p>

<p>The following code shows the proper way to open an LSA policy object for a system on the network whose name is &quot;JasonsComputer&quot;:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
LSA_OBJECT_ATTRIBUTES   lsaOA = { 0 };
LSA_UNICODE_STRING      lsastrComputer = { 0 };
LSA_HANDLE              hPolicy = NULL;

// Computer Name
WCHAR* pstrName = L&quot;JasonsComputer&quot;;

// Set the size of the useless LSA_OBJECT_ATTRIBUTES structure
lsaOA.Length = sizeof(lsaOA);

// Fill in the members of the LSA_UNICODE_STRING structure
lsastrComputer.Length = (USHORT) (lstrlen(pstrName) * sizeof(WCHAR));
lsastrComputer.MaximumLength = lsastrComputer.Length + sizeof(WCHAR);
lsastrComputer.Buffer = pstrName;

// Retrieve the policy handle
NTSTATUS ntStatus = LsaOpenPolicy(&amp;lsastrComputer, &amp;lsaOA,
   POLICY_VIEW_LOCAL_INFORMATION | POLICY_LOOKUP_NAMES |
   POLICY_CREATE_ACCOUNT, &amp;hPolicy);

ULONG lErr = LsaNtStatusToWinError(ntStatus);
if (lErr != ERROR_SUCCESS){
   // Handle error
}
</pre></td></tr></table>
</p>

<p>Now that you know how to obtain an open handle to an LSA policy object, you are ready to begin managing the privileges on the system.</p>

<A NAME="193"><h2>Enumerating Privileges</h2></A>
<p>There are two ways to enumerate the privileges on a system: either obtain a list of the privileges held by a specific trustee, or request a list of trustees that hold a specific privilege.</p>

<A NAME="194"><h3>Privileges Held by a Specific Trustee</h3></A>
<p>Let's start by discussing how to obtain a list of privileges held by a specific trustee of the system. To enumerate the privileges, use the <i>LsaEnumerateAccountRights</i> function:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
NTSTATUS LsaEnumerateAccountRights(
   LSA_HANDLE           hPolicy, 
   PSID                 psidTrustee, 
   PLSA_UNICODE_STRING* pplsastrUserRights,  
   PULONG               plCountOfRights);
</pre></td></tr></table>
</p>

<p>You must pass an open policy object created with POLICY_LOOKUP_NAMES access as the <i>hPolicy</i> parameter of <i>LSAEnumerateAccountRights</i>. The <i>psidTrustee</i> parameter is a pointer to the SID for the trustee for which you want to enumerate privileges. You can use <i>LookupAccountName</i> (discussed earlier in the section &quot;<A HREF="ch09e.htm#184">Understanding SIDs</A>&quot;) to obtain a SID from a trustee's account name. This trustee can be a user account, group account, or computer account.</p>

<p>You should pass the address of a variable of type LSA_UNICODE_STRING as the <i>pplsastrUserRights</i> parameter of <i>LsaEnumerateAccountRights.</i> The system generates an array of LSA_UNICODE_STRING structures, allocates a buffer to hold the array, and then places a pointer to the buffer in the variable pointed to by the <i>pplsastrUserRights</i> parameter. The system then returns the number of privileges in the array in the ULONG variable pointed to by <i>plCountOfRights</i>.</p>

<p>Because the system has allocated a buffer on your behalf, you must free the buffer when you are finished with it. Passing a pointer to the buffer to the <i>LsaFreeMemory</i> function does this:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
NTSTATUS LsaFreeMemory(PVOID pvBuffer);
</pre></td></tr></table>
</p>

<p>If <i>LsaEnumerateAccountRights</i> succeeds, the translated status code will be ERROR_SUCCESS. If the account has no privileges assigned to it, the translated error code will be ERROR_FILE_NOT_FOUND. The elements of the array returned by <i>LsaEnumerateAccountRights</i> are of type LSA_UNICODE_STRING (defined earlier in the section &quot;<A HREF="ch09f.htm#192">The LSA Functions</A>&quot;). Each element will point to a buffer containing a Unicode string representation of an account right, including values such as SeDebugPrivilege and SeEnableDelegationPrivilege. You can refer back to Table 9-10 for a list of all possible returned privileges.</p> 

<p>Although it is not directly related to enumerating privileges, the <i>LookupPrivilegeDisplayName</i> function should be mentioned. This function translates a programmatic privilege name, such as SeTcbPrivilege, into its friendly display name, which in this case would be &quot;Act as part of the operating system&quot;.</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL LookupPrivilegeDisplayName(
   PCTSTR pszSystemName,
   PCTSTR pszName,
   PTSTR  pszDisplayName,
   PDWORD cbDisplayName, 
   PDWORD pLanguageId);
</pre></td></tr></table>
</p>

<p>This function takes the system name and the programmatic name for the privilege, and then returns the friendly name in a buffer that you supply.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
 <i>LookupPrivilegeDisplayName</i> will not return the display name for an account right. It works only for privileges. Although our discussion here does not distinguish between these two types of account right, this topic is discussed more fully in <A HREF="ch11a.htm">Chapter 11</A>. 

<p>You can determine whether an account right is a privilege by referring to Table 9-10. If the right in question is defined in the WinNT.h header file, it is a privilege. If it is defined in the NTSecAPI.h header file, it is only an account right, not an actual privilege.</p>
</blockquote></div>
</p>

<p>The following sample function shows how to list all the privileges held by a trustee. It takes an LSA policy handle and a PSID as its parameters.</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL PrintTrusteePrivs(LSA_HANDLE hPolicy, PSID psid) {
   BOOL fSuccess = FALSE;
   WCHAR szTempPrivBuf[256];
   WCHAR szPrivDispBuf[1024];
   PLSA_UNICODE_STRING plsastrPrivs = NULL;

   __try {
      // Retrieve the array of privileges for the given SID
      ULONG lCount = 0;
      NTSTATUS ntStatus = LsaEnumerateAccountRights(hPolicy, psid,
         &amp;plsastrPrivs, &amp;lCount);
      ULONG lErr = LsaNtStatusToWinError(ntStatus);
      if (lErr != ERROR_SUCCESS) {
         plsastrPrivs = NULL;
         __leave;
      }

      ULONG lDispLen = 0;
      ULONG lDispLang = 0;

      for (ULONG lIndex = 0; lIndex &lt; lCount; lIndex++) {
         // Assure zero termination
         lstrcpyn(szTempPrivBuf,
            plsastrPrivs[lIndex].Buffer, plsastrPrivs[lIndex].Length);
         szTempPrivBuf[plsastrPrivs[lIndex].Length] = 0;

         wprintf(L&quot;Programmatic Name: %s\n&quot;, szTempPrivBuf);

         // Translate to Display Name
         lDispLen = 1024; // Size of static Display buffer
         if (LookupPrivilegeDisplayName(NULL, szTempPrivBuf, 
            szPrivDispBuf, &amp;lDispLen, &amp;lDispLang))
            wprintf(L&quot;Display Name: %s\n\n&quot;, szPrivDispBuf);
      }

      fSuccess = TRUE;
   }
   __finally {
      if (plsastrPrivs) LsaFreeMemory(plsastrPrivs);
   }
   return(fSuccess);
}
</pre></td></tr></table>
</p>

<A NAME="195"><h3>Trustees That Hold a Specific Privilege</h3></A>
<p>Now for the second way to retrieve privilege information for a Windows 2000 system: request a list of trustees that hold a specific privilege by calling <i>LsaEnumerateAccountsWithUserRight</i>.</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
NTSTATUS LsaEnumerateAccountsWithUserRight(
   LSA_HANDLE          hPolicy, 
   PLSA_UNICODE_STRING plsastrUserRight, 
   PVOID*              ppvEnumerationBuffer, 
   PULONG              CountReturned);
</pre></td></tr></table>
</p>

<p>This function requires a handle to an LSA policy object much like <i>LsaEnumerateAccountRights</i> does. However, instead of filling an LSA_UNICODE_STRING structure with the name of a trustee, you should pass a pointer to an LSA_UNICODE_STRING structure complete with the programmatic name of a privilege or an account right.</p> 

<p>The system returns trustee information to your software by allocating a buffer and returning its pointer via the <i>ppvEnumerationBuffer</i> parameter. Although this parameter is defined as a pointer to a PVOID, you should pass the address of a pointer to a variable of type PLSA_ENUMERATION_INFORMATION because the system will return the information as an array of LSA_ENUMERATION_INFORMATION structures. It would have been nice if the developers of Windows had defined <i>LsaEnumerateAccountsWithUserRight</i> to take a pointer to the correct type, but they chose instead to require a pointer to a PVOID, so you will have to cast this parameter.</p> 

<p>The LSA_ENUMERATION_INFORMATION structure is actually very simple and contains only a single member&#8212;a pointer to a SID:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
typedef struct _LSA_ENUMERATION_INFORMATION {
   PSID Sid;
} LSA_ENUMERATION_INFORMATION;
</pre></td></tr></table>
</p>

<p>The number of elements in the array is returned in the variable pointed to by <i>CountReturned</i>, which is the final parameter of <i>LsaEnumerateAccountsWithUserRight</i>. The SIDs in the returned array can be used to generate a trustee name by passing the SID to <i>LookupAccountSid</i>, discussed earlier in this chapter. When you are finished with the buffer returned by <i>LsaEnumerateAccountsWithUserRight</i>, you should pass its pointer to <i>LsaFreeMemory</i>.</p>

<A NAME="196"><h2>Assigning and Removing Privileges</h2></A>
<p>It is uncommon to have to create software solely to enumerate the privileges given to a trustee account. However, just about any software that creates trustee accounts will need to assign (and perhaps remove) privileges from an account. Fortunately, the LSA functions provide two simple functions to perform these tasks. The first, <i>LsaAddAccountRights</i>, is used to grant privileges to a trustee:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
NTSTATUS LsaAddAccountRights(
   LSA_HANDLE          hPolicy,
   PSID                psidTrustee,
   PLSA_UNICODE_STRING plsastrUserRights,
   ULONG               lCountOfRights);
</pre></td></tr></table>
</p>

<p>This function is easy to use. You must pass the handle to an open LSA policy object, as well as a pointer to the SID for the trustee whose privileges you wish to modify. (You can obtain a SID for a user or group account by calling <i>LookupAccountName</i>, as discussed earlier in this chapter.)</p>

<p>Before calling <i>LsaAddAccountRights</i>, however, you should build an array of LSA_UNICODE_STRING structures, each with the name of a privilege you want the trustee to hold. Pass a pointer to this array as the <i>plsastrUserRights</i> parameter of <i>LsaAddAccountRights</i>. Finally, pass the number of elements in the array as the final parameter, <i>lCountOfRights</i>.</p> 

<p>The <i>LsaAddAccountRights</i> function ignores any account rights or privileges already held by the trustee. It fails, however, if any of the rights in the array are not valid names for the system.</p>

<p>The following code provides an example of how to assign the SeInteractiveLogonRight account right and the SeTcbPrivilege privilege to a trustee account whose SID is pointed to by the variable <i>psid</i>.</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
LSA_UNICODE_STRING lsastrPrivs[2] = { 0 };
lsastrPrivs[0].Buffer = SE_INTERACTIVE_LOGON_NAME;
lsastrPrivs[0].Length = 
   lstrlen(lsastrPrivs[0].Buffer) * sizeof(WCHAR);
lsastrPrivs[0].MaximumLength = lsastrPrivs[0].Length + sizeof(WCHAR);

lsastrPrivs[1].Buffer = SE_TCB_NAME;
lsastrPrivs[1].Length =
   lstrlen(lsastrPrivs[1].Buffer) * sizeof(WCHAR);
lsastrPrivs[1].MaximumLength = lsastrPrivs[1].Length + sizeof(WCHAR);

NTSTATUS ntStatus = LsaAddAccountRights(hPolicy, psid,
   lsastrPrivs, 2);
ULONG lErr = LsaNtStatusToWinError(ntStatus);
</pre></td></tr></table>
</p>

<p>The function used to remove privileges from a trustee account is similar to <i>LsaAddAccountRights</i>. It is called <i>LsaRemoveAccountRights</i> and is prototyped as follows:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
NTSTATUS LsaRemoveAccountRights(
   LSA_HANDLE          hPolicy,
   PSID                psidTrustee,
   BOOLEAN             fAllRights,
   PLSA_UNICODE_STRING plsastrUserRights,
   ULONG               lCountOfRights);
</pre></td></tr></table>
</p>

<p>This function is the same as <i>LsaAddAccountRights</i> except that it removes the list of rights from the trustee indicated by <i>psidTrustee</i> and has one extra parameter, the Boolean <i>fAllRights.</i></p> 

<p>The <i>fAllRights</i> parameter allows you to remove all privileges from a trustee without building a list of the privileges held by the trustee. If you pass TRUE for this parameter, the <i>plsastrUserRights</i> and <i>lCountOfRights</i> parameters should be NULL and 0, respectively. If you pass FALSE for the <i>fAllRights</i> parameter, <i>LsRemoveAccountRights</i> is used the same way as <i>LsaAddAccountRights.</i></p> 

<p>Before wrapping up our discussion of <i>LsaRemoveAccountRights</i>, I should point out one detail about removing all rights from an account. The Platform SDK documentation states that if you pass TRUE for the <i>fAllRights</i> parameter, the system will remove all privileges from the account and then delete the account from the system. However, this is true only from a certain perspective. Each system running Windows 2000 must maintain a local database of account privilege entries (technically implemented internally as a local account) even if the trustee account lives on another machine such as a domain controller. The <i>LsaRemoveAccountRights</i> function will not delete a trustee account (even if the account is local) from the system that hosts the account; it deletes only the account privilege entries from its local database.</p>

</BODY>
</HTML>




