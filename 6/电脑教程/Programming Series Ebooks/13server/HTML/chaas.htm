<HTML>
<HEAD>
<TITLE>The CSystemInfo C++ Class</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="chaar.htm">[Previous]</A> <A HREF="chaba.htm">[Next]</A><P>

<A NAME="296"><h1>The CSystemInfo C++ Class</h1></A>
<p>This very simple C++ class wraps the Windows SYSTEM_INFO structure and initializes this structure when an instance of the class is constructed. Many of the sample applications make use of members in this structure; wrapping the structure in a C++ class insures that the members are always initialized and simplifies some of the code.</p>

<p><b>Listing A-1</b> <i>The CmnHdr.h header file</i></p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
<p><b>CmnHdr.h</b></p>
/******************************************************************************
Module:  CmnHdr.h
Notices: Copyright (c) 2000 Jeffrey Richter
Purpose: Common header file containing handy macros and definitions
         used throughout all the applications in the book.
         See Appendix A.
******************************************************************************/

#pragma once   // Include this header file once per compilation unit

/////////////////////////// Force Windows subsystem ///////////////////////////

#pragma comment(linker, &quot;/subsystem:Windows,5&quot;)


/////////////////////////// Force Windows 2000 ////////////////////////////////

#pragma comment(linker, &quot;/version:5&quot;)


//////////////////////// Windows Version Build Option /////////////////////////

#define _WIN32_WINNT 0x0500
#define WINVER       0x0500


//////////////////////////// Unicode Build Option /////////////////////////////

// If we are not compiling for an x86 CPU, we always compile using Unicode.
#ifndef _M_IX86
#define UNICODE
#endif

// To compile without Unicode, comment out the line below.
#define UNICODE

// When using Unicode Windows functions, use Unicode C-Runtime functions too.
#ifdef UNICODE
#define _UNICODE
#endif


///////////////////////// Include Windows Definitions /////////////////////////


#pragma warning(push, 4)
#include &lt;Windows.h&gt;
#include &lt;TChar.h&gt;


///////////// Verify that the proper header files are being used //////////////


#ifndef WT_EXECUTEINPERSISTENTIOTHREAD
#pragma message(&quot;You are not using the latest Platform SDK header/library &quot;)
#pragma message(&quot;files. This may prevent the project from building correctly.&quot;)
#pragma message(&quot;You may install the Platform SDK from the book's CD-ROM or &quot;)
#pragma message(&quot;from http://msdn.microsoft.com/downloads/&quot;)
#endif


////////////// Allow code to compile cleanly at warning level 4 ///////////////


/* nonstandard extension 'single line comment' was used */
#pragma warning(disable:4001)

// unreferenced formal parameter
#pragma warning(disable:4100)

// Note: Creating precompiled header 
#pragma warning(disable:4699)

// function not inlined
#pragma warning(disable:4710)

// unreferenced inline function has been removed
#pragma warning(disable:4514)

// assignment operator could not be generated
#pragma warning(disable:4512)

// cast truncates constant value
#pragma warning(disable:4310)


///////////////////////// Pragma message helper macro /////////////////////////


/* 
When the compiler sees a line like this:
   #pragma chMSG(Fix this later)

it outputs a line like this:

  c:\CD\CmnHdr.h(82):Fix this later

You can easily jump directly to this line and examine the surrounding code.
*/

#define chSTR2(x)   #x
#define chSTR(x)    chSTR2(x)
#define chMSG(desc) message(__FILE__ &quot;(&quot; chSTR(__LINE__) &quot;):&quot; #desc)


////////////////////////////// chINRANGE Macro ////////////////////////////////


// This macro returns TRUE if a number is between two others
#define chINRANGE(low, Num, High) (((low) &lt;= (Num)) &amp;&amp; ((Num) &lt;= (High)))


//////////////////////////////// chDIMOF Macro ////////////////////////////////


// This macro evaluates to the number of elements in an array. 
#define chDIMOF(Array) (sizeof(Array) / sizeof(Array[0]))


///////////////////////////// chSIZEOFSTRING Macro ////////////////////////////


// This macro evaluates to the number of bytes needed by a string.
#define chSIZEOFSTRING(psz)   ((lstrlen(psz) + 1) * sizeof(TCHAR))


/////////////////// chROUNDDOWN &amp; chROUNDUP inline functions //////////////////


// This inline function rounds a value down to the nearest multiple
template &lt;class TV, class TM&gt;
inline TV chROUNDDOWN(TV Value, TM Multiple) {
   return((Value / Multiple) * Multiple);
}


// This inline function rounds a value down to the nearest multiple
template &lt;class TV, class TM&gt;
inline TV chROUNDUP(TV Value, TM Multiple) {
   return(chROUNDDOWN(Value, Multiple) + 
      (((Value % Multiple) &gt; 0) ? Multiple : 0));
}


///////////////////////////// chBEGINTHREADEX Macro ///////////////////////////


// This macro function calls the C runtime's _beginthreadex function. 
// The C runtime library doesn't want to have any reliance on Windows' data 
// types such as HANDLE. This means that a Windows programmer needs to cast
// values when using _beginthreadex. Since this is terribly inconvenient, 
// I created this macro to perform the casting.
typedef unsigned (__stdcall *PTHREAD_START) (void *);

#define chBEGINTHREADEX(psa, cbStack, pfnStartAddr, \
   pvParam, fdwCreate, pdwThreadId)                 \
      ((HANDLE)_beginthreadex(                      \
         (void *)        (psa),                     \
         (unsigned)      (cbStack),                 \
         (PTHREAD_START) (pfnStartAddr),            \
         (void *)        (pvParam),                 \
         (unsigned)      (fdwCreate),               \
         (unsigned *)    (pdwThreadId)))


////////////////// DebugBreak Improvement for x86 platforms ///////////////////


#ifdef _X86_
#define DebugBreak()    _asm { int 3 }
#endif


/////////////////////////// Software Exception Macro //////////////////////////


// Useful macro for creating your own software exception codes
#define MAKESOFTWAREEXCEPTION(Severity, Facility, Exception) \
   ((DWORD) ( \
   /* Severity code    */  (Severity       ) |     \
   /* MS(0) or Cust(1) */  (1         &lt;&lt; 29) |     \
   /* Reserved(0)      */  (0         &lt;&lt; 28) |     \
   /* Facility code    */  (Facility  &lt;&lt; 16) |     \
   /* Exception code   */  (Exception &lt;&lt;  0)))


/////////////////////////// Quick MessageBox Macro ////////////////////////////


inline void chMB(PCSTR s) {
   char szTMP[256];
   GetModuleFileNameA(NULL, szTMP, chDIMOF(szTMP));
   HWND hwnd = GetActiveWindow();
   MessageBoxA(hwnd, s, szTMP, 
      MB_OK | ((hwnd == NULL ) ? MB_SERVICE_NOTIFICATION : 0));
}


//////////////////////////// Assert/Verify Macros /////////////////////////////


inline void chMBANDDEBUG(PSTR szMsg) {
   chMB(szMsg);
   DebugBreak();
}


// Put up an assertion failure message box.
inline void chASSERTFAIL(LPCSTR file, int line, PCSTR expr) {
   char sz[256];
   wsprintfA(sz, &quot;File %s, line %d : %s&quot;, file, line, expr);
   chMBANDDEBUG(sz);
}

// Put up a message box if an assertion fails in a debug build.
#ifdef _DEBUG
#define chASSERT(x) if (!(x)) chASSERTFAIL(__FILE__, __LINE__, #x)
#else
#define chASSERT(x)
#endif


// Put up a failure message box in a debug build.
#ifdef _DEBUG
#define chFAIL() chASSERTFAIL(__FILE__, __LINE__, &quot;&quot;)
#else
#define chFAIL()
#endif


// Assert in debug builds, but don't remove the code in retail builds.
#ifdef _DEBUG
#define chVERIFY(x) chASSERT(x)
#else
#define chVERIFY(x) (x)
#endif


/////////////////////////// chHANDLE_DLGMSG Macro /////////////////////////////


// The normal HANDLE_MSG macro in WindowsX.h does not work properly for dialog
// boxes because DlgProc return a BOOL instead of an LRESULT (like
// WndProcs). This chHANDLE_DLGMSG macro corrects the problem:
#define chHANDLE_DLGMSG(hwnd, message, fn)                 \
   case (message): return (SetDlgMsgResult(hwnd, uMsg,     \
      HANDLE_##message((hwnd), (wParam), (lParam), (fn))))


//////////////////////// Dialog Box Icon Setting Macro ////////////////////////


// Sets the dialog box icons
inline void chSETDLGICONS(HWND hwnd, int idi) {
   SendMessage(hwnd, WM_SETICON, TRUE,  (LPARAM) 
      LoadIcon((HINSTANCE) GetWindowLongPtr(hwnd, GWLP_HINSTANCE), 
         MAKEINTRESOURCE(idi)));
   SendMessage(hwnd, WM_SETICON, FALSE, (LPARAM) 
      LoadIcon((HINSTANCE) GetWindowLongPtr(hwnd, GWLP_HINSTANCE), 
      MAKEINTRESOURCE(idi)));
}
    
///////////////////////////// UNICODE Check Macro /////////////////////////////


// Since Windows 98 does not support Unicode, issue an error and terminate
// the process if this is a native Unicode build running on Windows 98

// This is accomplished by creating a global C++ object. Its constructor is 
// executed before WinMain/main.

#ifdef UNICODE

class CUnicodeSupported {
public:
   CUnicodeSupported() {
      if (GetWindowsDirectoryW(NULL, 0) &lt;= 0) {
         chMB(&quot;This application requires an OS that supports Unicode.&quot;);
         ExitProcess(0);
      }
   }
};

// &quot;static&quot; stops the linker from complaining that multiple instances of the
// object exist when a single project contains multiple source files.
static CUnicodeSupported g_UnicodeSupported;

#endif

/////////////////////////// OS Version Check Macros ///////////////////////////


inline void chWindows9xNotAllowed() {
   OSVERSIONINFO vi = { sizeof(vi) };
   GetVersionEx(&amp;vi);
   if (vi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) {
      chMB(&quot;This application requires features not present in Windows 9x.&quot;);
      ExitProcess(0);
   }
}


inline void chWindows2000Required() {
   OSVERSIONINFO vi = { sizeof(vi) };
   GetVersionEx(&amp;vi);
   if ((vi.dwPlatformId != VER_PLATFORM_WIN32_NT) &amp;&amp; (vi.dwMajorVersion &lt; 5)) {
      chMB(&quot;This application requires features present in Windows 2000.&quot;);
      ExitProcess(0);
   }
}


////////////////////////// SYSTEM_INFO Wrapper Class //////////////////////////


class CSystemInfo : public SYSTEM_INFO {
public:
   CSystemInfo() { GetSystemInfo(this); }
};


///////////////////////////////// End of File /////////////////////////////////
</pre></td></tr></table>
</p>

</body>
</html>





