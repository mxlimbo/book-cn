<HTML>
<HEAD>
<TITLE>Adding a Service to the SCM's Database</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="ch04a.htm">[Previous]</A> <A HREF="ch04c.htm">[Next]</A><P>

<A NAME="65"><H1>Adding a Service to the SCM's Database</H1></A>
<p>One of the most common reasons to manipulate the SCM database is to add 
a service. To add a service, you must call 
<I>OpenSCManager</I>,<I> </I>specifying the SC_MANAGER_CREATE_SERVICE access, and then call 
<I>CreateService</I>:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
SC_HANDLE CreateService(
   SC_HANDLE hSCManager,
   PCTSTR    pszServiceName,    // Internal, programmatic string name
   PCTSTR    pszDisplayName,
   DWORD     dwDesiredAccess,
   DWORD     dwServiceType,
   DWORD     dwStartType,
   DWORD     dwErrorControl,
   PCTSTR    pszPathName,
   PCTSTR    pszLoadOrderGroup,
   PDWORD    pdwTagId,          // Always 0 for services
   PCTSTR    pszDependencies,   // Double zero-terminated string
   PCTSTR    pszUserName,
   PCTSTR    pszUserPswd);
</pre></td></tr></table>
</p>

<p>As you can see, <I>CreateService </I> requires quite a few parameters (13 to be 
exact). The <I>hSCManager </I>parameter is the handle returned from 
<I>OpenSCManager</I>. The next two parameters, <I>pszServiceName 
</I>and <I>pszDisplayName</I>, indicate the name 
of the service. Services have an internal name for use by programmers and 
a display name that is shown to users. The internal name, identified 
by <I>pszServiceName</I>, is used by the SCM to store the service information 
inside the registry. For example, the Logical Disk Manager service has the internal 
name &quot;dmserver,&quot; and its service information can be found under the following 
registry key:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\dmserver
</pre></td></tr></table>
</p>

<p><I>CreateService</I>'s <I>dwDesiredAccess </I>parameter is useful because it tells the 
SCM what you intend to do with the newly installed service 
after<I> CreateService </I>returns a handle to it (so you can manipulate the service right away). If you 
are only installing a service and do not intend to manipulate it after it is 
installed, simply pass 0 for 
<I>dwDesiredAccess</I>, and then immediately close the handle 
returned from <I>CreateService </I>by calling 
<I>CloseServiceHandle</I>. Table 4-2 shows the access rights you can specify for 
<I>dwDesiredAccess</I> when you use 
<I>CreateService</I>.</p>

<p><b>Table 4-2.</b> <i>Access right values for</i> CreateService'<i>s</i> 
dwDesiredAccess <i>parameter that specify access to the service added to the SCM database</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Access Rights  </th>
<th>Description  </th></tr>
<tr>
<td valign="top">SERVICE_START   </td>
<td valign="top">Enables calling of <I>StartService</I>to start the service.  </td></tr>
<tr>
<td valign="top">SERVICE_STOP   </td>
<td valign="top">Enables calling of <I>ControlService</I> to stop the service.  </td></tr>
<tr>
<td valign="top">SERVICE_PAUSE_CONTINUE  </td>
<td valign="top">Enables calling of <I>ControlService </I>to pause and continue the service. This access also allows changing a service's parameters.  </td></tr>
<tr>
<td valign="top">SERVICE_INTERROGATE   </td>
<td valign="top">Enables calling of <I>ControlService</I>to ask the service to report its status immediately.  </td></tr>
<tr>
<td valign="top">SERVICE_USER_DEFINED_CONTROL   </td>
<td valign="top">Enables calling of <I>ControlService </I>to specify a user-defined control code.  </td></tr>
<tr>
<td valign="top">SERVICE_QUERY_STATUS  </td>
<td valign="top">Enables calling of <I>QueryServiceStatus(Ex) </I>functions to ask the service control manager about the status of the service.  </td></tr>
<tr>
<td valign="top">SERVICE_ENUMERATE_DEPENDENTS  </td>
<td valign="top">Enables calling of <I>EnumDependentServices</I> to enumerate all the services dependent on the service.  </td></tr>
<tr>
<td valign="top">SERVICE_CHANGE_CONFIG   </td>
<td valign="top">Enables calling of <I>ChangeServiceConfig(2) </I>to change the service configuration.  </td></tr>
<tr>
<td valign="top">SERVICE_QUERY_CONFIG  </td>
<td valign="top">Enables calling of <I>QueryServiceConfig(2)</I> to query the service configuration.  </td></tr>
<tr>
<td valign="top">DELETE   </td>
<td valign="top">Enables calling of <I>DeleteService</I>to delete the service.  </td></tr>
</table></p>


<p>The <I>CreateService </I>function does not have a parameter that accepts a 
pointer to a SECURITY_ATTRIBUTES structure. So when a new service is 
installed in the SCM's database, the SCM sets default security on the service. You 
can alter these security settings using the <I>QueryServiceObjectSecurity 
</I>and <I>SetServiceObjectSecurity </I>functions. These are the SCM's access settings for 
the service's default security:</p>

<UL>
<p><li>Administrators and System Operators have<br>
SERVICE_CHANGE_CONFIG, <br>
SERVICE_ENUMERATE_DEPENDENTS,<br> SERVICE_INTERROGATE, 
SERVICE_PAUSE_CONTINUE,<br> SERVICE_QUERY_CONFIG, 
SERVICE_QUERY_STATUS,<br> SERVICE_START, SERVICE_STOP,<br> SERVICE_USER_DEFINED_CONTROL, 
READ_CONTROL,<br> WRITE_OWNER, WRITE_DAC, and DELETE access to 
the service.</li></p>

<p><li>LocalSystem has 
SERVICE_ENUMERATE_DEPENDENTS,<br> SERVICE_INTERROGATE, 
SERVICE_PAUSE_CONTINUE,<br> SERVICE_QUERY_CONFIG, 
SERVICE_QUERY_STATUS,<br> SERVICE_START, SERVICE_STOP,<br> SERVICE_USER_DEFINED_CONTROL, 
and<br> READ_CONTROL access to the service.</li></p>

<p><li>Authenticated users have<br>
 SERVICE_ENUMERATE_DEPENDENTS,<br> SERVICE_INTERROGATE, 
SERVICE_QUERY_CONFIG,<br> SERVICE_QUERY_STATUS,<br> SERVICE_USER_DEFINED_CONTROL, 
and<br> READ_CONTROL access to the service.</li></p>

<p><li>On Windows 2000 Professional and Windows 2000 Server, 
Power<br> Users have SERVICE_QUERY_CONFIG,<br> 
SERVICE_QUERY_STATUS, <br>
SERVICE_ENUMERATE_DEPENDENTS,<br> SERVICE_INTERROGATE, SERVICE_START, 
SERVICE_STOP,<br> SERVICE_PAUSE_CONTINUE,<br> SERVICE_USER_DEFINED_CONTROL, 
and<br> READ_CONTROL access to the service.</li></p>
</UL>
 
<p>The <I>dwServiceType </I>parameter tells the system whether the executable 
file contains one or multiple services. Pass 
SERVICE_WIN32_OWN_PROCESS when the executable implements a single service, or 
SERVICE_WIN32_SHARE_PROCESS when the executable implements two or more 
services. You can also combine the SERVICE_INTERACTIVE_PROCESS flag 
with either SERVICE_WIN32_OWN_PROCESS or SERVICE_WIN32_SHARE_PROCESS 
if you want the services in a process to interact with the user's desktop.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
For SERVICE_WIN32_SHARE_PROCESS service executables, if 
one service requires the SERVICE_INTERACTIVE_PROCESS flag, 
all services must use this flag. When the system starts the first service, 
the setting of that service determines whether the whole process is 
allowed to interact with the desktop.
</blockquote></div>
</p>

<p>The <I>dwStartType </I>parameter tells the system when the service should 
be started. A value of SERVICE_AUTO_START instructs the SCM to start 
the service when the machine boots. A value of SERVICE_DEMAND_START 
tells the system that the service should not be started when the machine boots; 
an administrator can start the service manually. In addition, SERVICE_DEMAND_START 
specifies that the service is a demand-start service, which tells the 
SCM to automatically start the service if the administrator attempts to start a 
service that depends on it. I'll talk more about service dependencies shortly. A 
value of SERVICE_DISABLED prevents the system from starting the service at all.</p>

<p>A service is a very important part of the system, so the system needs 
to know what it should do if the service fails to start. This instruction is the job 
of the <I>dwErrorControl </I>parameter. Passing a value of SERVICE_ERROR_IGNORE 
or SERVICE_ERROR_NORMAL tells the system to log the 
service's error in the system's event log and continue starting the system. The 
difference between these two codes is that SERVICE_ERROR_NORMAL has the 
system display a message box notifying the user that the service failed to start. 
Services that are demand-started should always specify SERVICE_ERROR_IGNORE.</p>

<p>The values of SERVICE_ERROR_SEVERE and SERVICE_ERROR_CRITICAL 
tell the system to abort startup when the service fails to start. 
When a service fails and one of these codes is specified, the system logs the error 
in the system's event log and then reboots automatically using the last-known 
good configuration. If the system is booting the last-known good configuration 
and a service with an error control of SERVICE_ERROR_SEVERE fails to 
start, the system continues to boot. If a service with an error control of 
SERVICE_ERROR_CRITICAL fails to start, the system will also abort the booting of 
the last-known good configuration.</p>

<p><I>CreateService</I>'s <I>pszPathName </I>parameter identifies the full pathname of 
the executable that contains the service or services. Many service files are 
installed in the \WINNT\System32 directory, but you can place a service executable 
anywhere in the file system.</p>

<p>Now we get to the issue of service dependencies. Loosely speaking, a 
service is like part of the operating system, and many services will not work 
properly unless they know that other parts of the system are up and running 
first. When the system boots, it follows an algorithm that dictates the order in 
which services should start. Microsoft has divided the system services into a set 
of predefined groups, listed here:</p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<td class="columns"><ul><li>System Reserved</li></ul>  </td>
<td class="columns"><ul><li>File system (CD-ROM and NTFS file system support)</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>Boot Bus Extender</li></ul>  </td>
<td class="columns"><ul><li>Event log (event log support)</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>System Bus Extender (PCMCIA support)</li></ul>  </td>
<td class="columns"><ul><li>Streams Drivers</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>SCSI miniport (SCSI device drivers)</li></ul>  </td>
<td class="columns"><ul><li>NDIS Wrapper</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>Port</li></ul>  </td>
<td class="columns"><ul><li>PNP_TDI (NetBT and TCP/IP support)</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>Primary disk (floppy/hard drives)</li></ul>  </td>
<td class="columns"><ul><li>NDIS (network support)</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>SCSI class (SCSI drives)</li></ul>  </td>
<td class="columns"><ul><li>TDI (AFD networking support and DHCP)</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>SCSI CDROM class (CD-ROM drives)</li></ul>  </td>
<td class="columns"><ul><li>NetBIOSGroup (NetBIOS support)</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>Filter (CD audio)</li></ul>  </td>
<td class="columns"><ul><li>PlugPlay</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>Boot file system (fast FAT drive access)</li></ul>  </td>
<td class="columns"><ul><li>SpoolerGroup (print spooling support)</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>Base (system beep)</li></ul>  </td>
<td class="columns"><ul><li>NetDDEGroup (network DDE support)</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>Pointer Port (mouse support)</li></ul>  </td>
<td class="columns"><ul><li>Parallel arbitrator (parallel port support)</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>Keyboard Port (keyboard support)</li></ul>  </td>
<td class="columns"><ul><li>Extended base (modem, serial, and parallel support)</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>Pointer Class (more mouse support)</li></ul>  </td>
<td class="columns"><ul><li>RemoteValidation (net logon support)</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>Keyboard Class (more keyboard support)</li></ul>  </td>
<td class="columns"><ul><li>PCI Configuration</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>Video Init (video support)</li></ul>  </td>
<td class="columns"><ul><li>MS Transactions</li></ul>  </td></tr>
<tr> 
<td class="columns"><ul><li>Video (video chip support)</li></ul>  </td>
<td class="columns">  </td></tr>
<tr> 
<td class="columns"><ul><li>Video Save (more video support)</li></ul>  </td>
<td class="columns">  </td></tr>
</table></p>

 
<p>You can also find this list in the registry under the following registry subkey:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\ServiceGroupOrder
</pre></td></tr></table>
</p>

<p>As the system boots, it iterates through the list, loading any device 
drivers and services that are part of each group. For example, the system loads 
all the device drivers and services that are part of the System Reserved group 
before loading the device drivers and services that are part of the SCSI 
miniport group.</p>

<p>When you add a service to the SCM's database, you can assign it to be 
in one of the predefined groups in the preceding list by passing the name of 
the group in <I>CreateService</I>'s <I>pszLoadOrderGroup 
</I>parameter. Usually, your services don't need to load early in the system's boot cycle and should load after all 
the grouped devices and services have started to run. To make your service load 
after all the more system-critical device drivers and services, simply pass NULL 
for the <I>pszLoadOrderGroup </I>parameter.</p>

<p>If you are adding a device driver to the SCM (as opposed to a service), 
you can get even greater granularity in establishing the driver's start time by 
specifying a tag ID. Services cannot take advantage of this additional granularity 
and must always pass NULL to <I>CreateService</I>'s 
<I>pdwTagId </I>parameter. If you're interested in device drivers, the Platform SDK documentation and DDK 
documentation discuss the <I>pdwTagId </I>parameter as well as two additional start 
options (SERVICE_BOOT_START and SERVICE_SYSTEM_START).</p>

<p>In addition to telling the SCM that your service is part of a particular 
load-order group, you can tell the SCM that your service requires certain other 
services and groups to be running before your service can run. For example, 
the Computer Browser service requires that the Workstation and Server services 
be up and running before it can work properly, and the ClipBook service 
requires that the Network DDE service be running.</p>

<p>Specifying which services your service depends on is typically much 
more useful than indicating that your service is part of a group. You use 
<I>CreateService</I>'s <I>pszDependencies </I>parameter to tell the SCM's database which services you 
depend on. If your service has no dependencies, simply pass NULL for this parameter.</p>

<p>The <I>pszDependencies </I>parameter is a little unusual because you must 
pass the address of a double zero-terminated array of zero-separated names. In 
other words, <I>pszDependencies </I>must point to a block of memory that contains a set 
of zero-terminated strings with an extra zero character at the end of the buffer.</p>

<p>So to create a service that is dependent on the Workstation service 
(like the Alerter service), you would set <I>pszDependencies </I>
(as shown in the following code) before passing it to <I>CreateService</I>:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
// The buffer below ends with two zero characters
PCTSTR pszDependencies = TEXT(&quot;LanmanWorkstation\0&quot;);
CreateService(..., pszDependencies, ...);
</pre></td></tr></table>
</p>

<p>And to create a service that is dependent on the Workstation and 
Remote Procedure Call (RPC) services (such as the Messenger service), you would 
set <I>pszDependencies </I>like this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
// The buffer below separates the strings with a zero character
// and ends with two zero characters
PCTSTR pszDependencies = TEXT(&quot;LanmanWorkstation\0RpcSs\0&quot;);
CreateService(..., pszDependencies, ...);
</pre></td></tr></table>
</p>

<p>A service can also be dependent on a group rather than on a single 
service, but this is very uncommon. Dependency on a load-order group means that 
the service can run if at least one member of the group is running after an 
attempt has been made to start all members of the group. To specify a group in 
the <I>pszDependencies </I>buffer, you must precede the group name with the 
special SC_GROUP_IDENTIFIER character, defined in WinSvc.h as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
#define SC_GROUP_IDENTIFIERW           L'+'
#define SC_GROUP_IDENTIFIERA           '+'

#ifdef UNICODE
#define SC_GROUP_IDENTIFIER            SC_GROUP_IDENTIFIERW
#else 
#define SC_GROUP_IDENTIFIER            SC_GROUP_IDENTIFIERA
#endif
</pre></td></tr></table>
</p>

<p>Therefore, to create a service that is dependent on the Workstation 
service and the TDI group, you would set <I>pszDependencies 
</I>like this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
// The buffer below specifies two dependencies: the Workstation service
// and the TDI group (a group because of the '+' before TDI)
PCTSTR pszDependencies = TEXT(&quot;LanmanWorkstation\0+TDI\0&quot;);
CreateService(..., pszDependencies, ...);
</pre></td></tr></table>
</p>

<p>When setting the <I>pszDependencies </I>value, you can specify as many 
services and groups as you like. Just remember to place a zero character between 
each service or group, to put a plus sign in front of all group names, and to place 
a terminating zero character just before the closing quote.</p>

<p>This brings us now to <I>CreateService</I>'s final two parameters: 
<I>pszUserName </I>and <I>pszUserPswd</I>. These parameters allow you to specify under which user 
account the service is to run. To have the service run under the 
LocalSystem account (the most common case), pass NULL for these two parameters. If 
you want the service to run under a specific user account, pass an account name 
in the form of <I>DomainName</I>\<I>UserName</I> for the 
<I>pszUserName </I>parameter, and pass the user account's password for the 
<I>pszUserPswd </I>parameter.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Interactive services must be configured to run under the 
LocalSystem account. <I>CreateService </I>fails to add the service to the SCM's database 
if you attempt to add an interactive service with a non-LocalSystem account.
</blockquote></div>
</p>

<p>If <I>CreateService </I>is successful in adding the service to the SCM's 
database, a non-NULL handle is returned. This handle is required by other functions 
to manipulate the service. Be sure you pass this handle to 
<I>CloseServiceHandle </I>when you're finished using it. If 
<I>CreateService </I>fails, it returns NULL, and a call 
to <I>GetLastError </I>returns a value indicating the reason for failure. Here are the 
most common reasons <I>CreateService </I>can fail:</p>

<UL>
<p><li>The handle returned from 
<I>OpenSCManager </I>doesn't have SC_MANAGER_CREATE_SERVICE access.</li></p>

<p><li>The new service specifies a circular dependency.</li></p>

<p><li>A service with the same display name already exists.</li></p>

<p><li>The specified service name is invalid.</li></p>

<p><li>A parameter is invalid.</li></p>

<p><li>The specified user account does not exist.</li></p>
</UL>
 
<p>I always write my service executables so that they can install 
themselves. In my <I>(w)main</I> or <I>(w)WinMain 
</I>function, I call a function such as 
<I>ServiceInstall </I>(shown in the next code snippet) if &quot;-install&quot; is passed as a command-line 
argument. The TimeService sample service presented in the last chapter 
demonstrates this technique.</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
void ServiceInstall(PCTSTR pszInternalName, PCTSTR pszDisplayName,
   DWORD dwServiceType, DWORD dwStartType, DWORD dwErrorControl) {

   // Open the SCM database to add a service
   SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);

   // Get the full pathname of our service's executable
   char szModulePathname[_MAX_PATH];
   GetModuleFileName(NULL, szModulePathname, sizeof(szModulePathname));

   // Add this service to the SCM database
   SC_HANDLE hService = CreateService(
      hSCM, pszInternalName, pszDisplayName, 0, dwServiceType,
      dwStartType, dwErrorControl, szModulePathname,
      NULL, NULL, NULL, NULL, NULL);

   // Close the newly created service and the SCM
   CloseServiceHandle(hService);
   CloseServiceHandle(hSCM);
}
</pre></td></tr></table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
For the sake of clarity, the preceding code does not conduct any 
error checking. <I>OpenSCManager </I>and <I>CreateService 
</I>can fail for many reasons. Please add the proper error checking when adding code like this 
into your own application.
</blockquote></div>
</p>

</BODY>
</HTML>




