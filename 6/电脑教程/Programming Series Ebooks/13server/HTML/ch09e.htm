<HTML>
<HEAD>
<TITLE>Understanding SIDs</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="ch09d.htm">[Previous]</A> <A HREF="ch09f.htm">[Next]</A><P>

<A NAME="184"><h1>Understanding SIDs</h1></A>
<p>SIDs are integral to Windows 2000 security. SIDs have already been touched on in this chapter and will appear again in subsequent chapters, but now is the time to look at them in detail. Here is what you know so far: SIDs are security identifiers, which identify trustees to the system. A SID is a unique binary representation of a trustee.</p> 

<p>Here are a few common tasks you'll become familiar with:</p>

<ul>
<p><li>Converting a user's or group's textual name to a SID.</li></p>

<p><li>Converting a SID to the textual name for the trustee.</li></p>

<p><li>Building a well-known SID from scratch. These SIDs exist on all systems and indicate accounts such as Guest or Everybody.</li></p>

<p><li>Copying a SID structure.</li></p>

<p><li>And finally, converting to and from binary and string representations of a SID.</li></p>
</ul>

<p>A SID is a security identifier, a structure that identifies a trustee to the system. A SID is composed of a 48-bit value followed by a variable number of 32-bit components. In documentation, a SID is typically represented in the SRI-S-S&#8230; format. (See the sidebar.)</p>

<p>
<div class="sidebar"><blockquote>
<b>SID Format</b>

<p>A SID is typically formatted as: S-R-I-S-S&#8230;</p> 

<p>where:</p>

<blockquote>
<p><b>S</b> is written literally as &quot;S&quot; and indicates that this series of numbers is a SID.</p>

<p><b>R</b> is the SID's revision level, indicated by a number (currently 1).</p>

<p><b>I</b> is a 48I-bit number indicating the authority.</p>

<p><b>S</b> is a 32-bit number indicating a subauthority, also known as a relative identifier, or RID.</p>

<p><b>S</b> is another subauthority. There can be any number of subauthorities in a SID.</p>

<p><b>Example</b> : S-1-5-11</p>
</blockquote>
</blockquote></div>
</p>

<p>The revision number of the SID structure has been 1 since Windows NT 3.1; however, it is possible that the structure will change and we will one day see a revision level of 2. The authority &quot;number&quot; indicates under whose authority the SID was created&#8212;that is, what &quot;entity&quot; owns the SID and manages its account. Table 9-6 provides a list of currently supported authorities.</p>

<p><b>Table 9-6.</b> <i>SID authorities</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th>Authority</th>
			<th>Definition</th>
		</tr>

		<tr>
			<td valign="top">SECURITY_NULL_SID_AUTHORITY</td>
			<td valign="top">Defined as 0, this authority is used in building a SID indicating a null group or nobody.</td>
		</tr>

		<tr>
			<td valign="top">SECURITY_WORLD_SID_AUTHORITY</td>
			<td valign="top">Defined as 1, this authority is used in building the well-known group account Everybody.</td>
		</tr>

		<tr>
			<td valign="top">SECURITY_LOCAL_SID_AUTHORITY</td>
			<td valign="top">Defined as 2, this authority is used in building the well-known group account LOCAL.</td>
		</tr>

		<tr>
			<td valign="top">SECURITY_CREATOR_SID_AUTHORITY</td>
			<td valign="top">Defined as 3, this authority is used with the well-known Creator Owner SID.</td>
		</tr>

		<tr>
			<td valign="top">SECURITY_NON_UNIQUE_AUTHORITY</td>
			<td valign="top">Defined as 4, this authority is used in creating SIDs that are not unique. The first subauthority is always set to SECURITY_NT_NON_UNIQUE, which is defined as 0x15.</td>
		</tr>

		<tr>
			<td valign="top">SECURITY_NT_AUTHORITY</td>
			<td valign="top">Defined as 5, this authority is used by user and group accounts created by Windows 2000 systems.</td>
		</tr>

	</table>
</p>

<p>The subauthority is a 32-bit value that is unique relative to the authority of the SID. The next subauthority is unique relative to the previous subauthorities and finally the authority of the SID. Subauthorities are also known as RIDs.</p>

<p>Table 9-7 shows some well-known RIDs. (For a complete list, see WinNT.h in the Platform SDK documentation.) Remember that unlike the authorities listed previously, these RIDs are not all unique. This is because they are only unique relative to an authority and, as such, have no meaning independent of the authority.</p>

<p><b>Table 9-7.</b> <i>Some well-known RIDs</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>RID</th>
			<th>Relevant Authority</th>
			<th>Definition</th>
		</tr>

		<tr>
			<td valign="top">SECURITY_NULL_RID</td>
			<td valign="top">NULL</td>			
			<td valign="top">Defined as 0, this is the single subauthority for the well-known group NULL.</td>
		</tr>

		<tr>
			<td valign="top">SECURITY_WORLD_RID</td>
			<td valign="top">WORLD</td>			
			<td valign="top">Defined as 0, this is the single subauthority for the well-known group Everyone.</td>
		</tr>

		<tr>
			<td valign="top">SECURITY_CREATOR_OWNER_RID</td>
			<td valign="top">CREATOR</td>			
			<td valign="top">Defined as 0, this is the single subauthority for the well-known user Creator Owner.</td>
		</tr>

		<tr>
			<td valign="top">SECURITY_CREATOR_GROUP_RID</td>
			<td valign="top">CREATOR</td>			
			<td valign="top">Defined as 1, this is the single subauthority for the well-known user Creator Group.</td>
		</tr>

		<tr>
			<td valign="top">SECURITY_CREATOR_OWNER_SERVER_RID</td>
			<td valign="top">CREATOR</td>			
			<td valign="top">Defined as 2, this is the single subauthority for the well-known user Creator Owner Server.</td>
		</tr>

		<tr>
			<td valign="top">SECURITY_CREATOR_GROUP_SERVER_RID</td>
			<td valign="top">CREATOR</td>			
			<td valign="top">Defined as 3, this is the single subauthority for the well-known user Creator Group Server.</td>
		</tr>
		
	</table>
</p>

<p>By combining a well-known RID with its respective authority, you can create a well-known SID. Well-known SIDs identify users and groups that are defined by the system and are known by every installation of Windows 2000 on every network. Table 9-8 lists some well-known SIDs and their uses.</p>

<p><b>Table 9-8.</b> <i>Well-known SIDs and their uses</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>SID</th>
			<th>Common Name</th>
			<th>Use</th>
		</tr>

		<tr>
			<td valign="top">S-1-0-0</td>
			<td valign="top">Null SID</td>			
			<td valign="top">Indicates an empty or NULL group. It is defined as a group with no users and is typically used to indicate nobody.</td>
		</tr>

		<tr>
			<td valign="top">S-1-1-0</td>
			<td valign="top">Everyone</td>			
			<td valign="top">Indicates a group of which all trustees are implicitly members. This is a very important SID and can be useful in creating access lists for securable objects in the system. It is also known as the World SID or World group.</td>
		</tr>

		<tr>
			<td valign="top">S-1-2-0</td>
			<td valign="top">Local SID</td>			
			<td valign="top">Indicates a group that includes all users who log on to a system locally or physically.</td>
		</tr>

		<tr>
			<td valign="top">S-1-3-0</td>
			<td valign="top">Creator Owner SID</td>			
			<td valign="top">Acts as a placeholder for the creator of an object. It is used with inheritable access-control lists. You will find more information on this SID in <A HREF="ch10a.htm">Chapter 10</A>.</td>
		</tr>

		<tr>
			<td valign="top">S-1-3-1</td>
			<td valign="top">Creator Group SID</td>			
			<td valign="top">Acts as a placeholder for the primary group of the creator of an object. It is used with inheritable access-control lists. You will find more information on this SID in <A HREF="ch10a.htm">Chapter 10</A>.</td>
		</tr>

		<tr>
			<td valign="top">S-1-5-1</td>
			<td valign="top">Dialup</td>			
			<td valign="top">Indicates a group of which all user accounts are automatically made members while they are logged on to a Windows 2000 system via dialup.</td>
		</tr>

		<tr>
			<td valign="top">S-1-5-2</td>
			<td valign="top">Network</td>			
			<td valign="top">Indicates a group of which all user accounts are automatically made members while they are logged on to a Windows 2000 system via the network.</td>
		</tr>

		<tr>
			<td valign="top">S-1-5-3</td>
			<td valign="top">Batch</td>			
			<td valign="top">Indicates a group of which all user accounts are automatically made members while they are logged on to a Windows 2000 system via a batch logon.</td>
		</tr>

		<tr>
			<td valign="top">S-1-5-4</td>
			<td valign="top">Interactive</td>			
			<td valign="top">Indicates a group of which all user accounts are automatically made members while they are logged on to a Windows 2000 system via an interactive logon.</td>
		</tr>

		<tr>
			<td valign="top">S-1-5-6</td>
			<td valign="top">Service</td>			
			<td valign="top">Indicates a group of which all user accounts are automatically made members while they are logged on to a Windows 2000 system as a service.</td>
		</tr>

		<tr>
			<td valign="top">S-1-5-7</td>
			<td valign="top">AnonymousLogon</td>
			<td valign="top">Associated with a null session logon.</td>
		</tr>

		<tr>
			<td valign="top">S-1-5-9</td>
			<td valign="top">ServerLogon</td>
			<td valign="top">Associated with a domain controller account.</td>
		</tr>

		<tr>
			<td valign="top">S-1-5-10</td>
			<td valign="top">Self (or Principal Self)</td>			
			<td valign="top">Acts as a placeholder and applies only to the access lists of group or user accounts. When present, it indicates the trustee account for which the access list applies.</td>
		</tr>

		<tr>
			<td valign="top">S-1-5-11</td>
			<td valign="top">Authenticated User</td>			
			<td valign="top">Indicates a well-known group of which all currently authenticated user accounts are implicitly members.</td>
		</tr>

		<tr>
			<td valign="top">S-1-5-13</td>
			<td valign="top">Terminal Server</td>			
			<td valign="top">Associated with a user logged on to a terminal server.</td>
		</tr>
		
		<tr>
			<td valign="top"><nobr>S-1-5-18</nobr></td>
			<td valign="top">LocalSystem</td>
			<td valign="top">This special account, which many service processes run under, exists on all Windows 2000 systems. For more information, see <A HREF="ch11a.htm">Chapter 11</A>.</td>
		</tr>

	</table>
</p>

<p>You will see some of these well-known SIDs only occasionally, and others crop up quite often. It is good to be familiar with these built-in trustees of the system.</p>

<p>The SID data structure itself is defined as follows:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
typedef struct _SID {
   BYTE  Revision;
   BYTE  SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
   DWORD SubAuthority[ANYSIZE_ARRAY];
} SID;
</pre></td></tr></table>
</p>

<p>Each member of this structure should now be familiar to you. ANYSIZE_ARRAY is defined as 1, primarily to indicate that the structure does not necessarily end with only a single DWORD representing a subauthority. Although the SID structure itself is very clear, it is an &quot;opaque&quot; data structure and should be manipulated only by using the system functions provided. This opacity affords the developers at Microsoft the freedom to change the internal structure of the SID in the future. Your software should follow this rule to a fault.</p>

<A NAME="185"><h2>Building SIDs</h2></A>
<p>As a rule, you will be building SIDs for well-known trustees such as the Everyone group. You build a SID by looking up the authority and trustee values for the trustee in question and passing them to the <i>AllocateAndInitializeSid</i> function:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL AllocateAndInitializeSid(
   PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
   BYTE  nSubAuthorityCount,
   DWORD dwSubAuthority0,
   DWORD dwSubAuthority1,
   DWORD dwSubAuthority2,
   DWORD dwSubAuthority3,
   DWORD dwSubAuthority4,
   DWORD dwSubAuthority5,
   DWORD dwSubAuthority6,
   DWORD dwSubAuthority7,
   PSID* ppSid);
</pre></td></tr></table>
</p>

<p>You should recognize the purpose of each of these parameters, but some points are worth mentioning. The <i>pIdentifierAuthority</i> parameter identifies the authority value for the SID you are building. The <i>pIdentifierAuthority</i> parameter is of type SID_IDENTIFIER_AUTHORITY, which is defined as an array of 6 bytes. This might seem a bit awkward, but thankfully the Platform SDK documentation defines the useful SID authorities. You should pass one of the values shown in Table 9-6, such as SECURITY_NT_AUTHORITY.</p> 

<p>The second parameter, <i>nSubAuthorityCount</i>, indicates the number of subauthorities that you require for the SID. Although the system has defined the value SID_MAX_SUB_AUTHORITIES as 15, <i>AllocateAndInitializeSid</i> will only build SIDs with 8 or fewer subauthorities.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Regardless of the limitations of <i>AllocateAndInitializeSid</i>, you should continue to treat SIDs as though they can be any size now and in the future (that is, avoid static buffers).</blockquote></div>
</p>

<p>The next eight parameters indicate the subauthorities for your new SID. I've often wondered why the developers at Microsoft didn't choose to consolidate these parameters into a single pointer to an array of DWORDs. Regardless, you should pass relevant values for as many subauthorities as you need and pass 0 for the remaining parameters.</p> 

<p>The final parameter, <i>ppSid</i>, is worthy of extra notice. It is defined as PSID*, which is a pointer to a pointer to a SID. Unlike most functions provided by Windows, <i>AllocateAndInitializeSid</i> allocates a buffer for you, rather than expecting you to provide a buffer of sufficient length. The address of the allocated memory is returned via this parameter.</p>

<p>If <i>AllocateAndInitializeSid</i> returns FALSE, most likely you have passed a subauthority count larger than 8. Because the function allocates memory for you, another cause of failure can be low memory.</p>

<p>If <i>AllocateAndInitilizeSid</i> succeeds, the PSID variable will contain a pointer to your new SID. When you are finished with the SID, you should pass it to <i>FreeSid</i> so that the system can free the memory used by the SID:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
PVOID FreeSid(PSID pSid);
</pre></td></tr></table>
</p>

<p>Using <i>AllocateAndInitializeSid</i>, you can build well-known SIDs as well as dynamic SIDs for which your software knows the authority and subauthority values. The following example shows how to use this function to build a SID representing the well-known group Everyone:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
PSID BuildEveryoneSid() {
   SID_IDENTIFIER_AUTHORITY auth = SECURITY_WORLD_SID_AUTHORITY;
   PSID pSID = NULL;
   BOOL fSuccess = AllocateAndInitializeSid(&amp;auth, 1,
      SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &amp;pSID);
   return(fSuccess ? pSID : NULL);
}
</pre></td></tr></table>
</p>

<p>Once you are finished with the SID returned by this function you would naturally pass its pointer to the <i>FreeSid</i> function. Notice that you can easily modify this function to build another well-known SID by changing the initialization value of the <i>auth</i> variable and passing a different RID define to <i>AllocateAndInitializeSid</i>.</p>

<A NAME="186"><h2>Trustee Name and Binary SID Conversion</h2></A>
<p>Two useful tasks you will commonly need to perform are conversions to and from trustee account names and binary SIDs. The system provides two functions to perform these tasks. These functions have potentially confusing names, so here is the best way to remember which is which:</p>

<ul>
<p><li>If you have the account name of a trustee but you want a binary SID, call <i>LookupAccountName</i>.</li></p>

<p><li>Conversely, if you have a binary SID but you want the trustee account name, call <i>LookupAccountSid</i>.</li></p>
</ul>

<p>As you can see, the functions have the name of the information you already have.</p>

<A NAME="187"><h3>Retrieving a Trustee's Binary SID</h3></A>
<p><i>LookupAccountName</i> is prototyped as follows:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL LookupAccountName(
   PCTSTR        pszSystemName,
   PCTSTR        pszAccountName,
   PSID          pSid,
   PDWORD        pcbSid,
   PTSTR         pszReferencedDomainName,
   PDWORD        pcbReferencedDomainName,
   PSID_NAME_USE peUse);
</pre></td></tr></table>
</p>

<p>The <i>pszSystemName</i> parameter should be the name of the system on which you wish to look up the name specified in the <i>pszAccountName</i> parameter. You can pass NULL for the <i>pszSystemName</i> parameter to indicate the local machine.</p> 

<p>You should pass a pointer to a buffer in memory large enough to hold the requested SID as the <i>pSid</i> parameter, as well as the address of a DWORD containing the size of your buffer as the <i>pcbSid</i> parameter. If your buffer is too small, the system will return failure and the <i>GetLastError</i> function will return ERROR_INSUFFICIENT_BUFFER. <i>LookupAccountName</i> will also fill the DWORD variable you supplied via the <i>pcbSid</i> parameter with the size the buffer should be. </p>

<p>The <i>pszReferencedDomainName</i> and <i>pcbReferencedDomainName</i> work similarly for a buffer to receive the domain name associated with the account and for the pointer to a DWORD variable containing the size, respectively. You cannot pass NULL for either of these values, even if the trustee's associated domain name is not required.</p> 

<p>You should pass the address of a SID_NAME_USE variable as the <i>peUse</i> parameter. <i>LookupAccountName</i> will return a value, in the variable pointed to by <i>peUse</i>, indicating the type of SID it has returned to you. Table 9-9 lists the possible values.</p> 

<p><b>Table 9-9.</b> <i>SID_NAME_USE enumeration type values</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>Value</th>
			<th>Use</th>
		</tr>

		<tr>
			<td valign="top"><i>SidTypeUser</i></td>
			<td valign="top">Indicates a SID for a user trustee account</td>
		</tr>

		<tr>
			<td valign="top"><i>SidTypeGroup</i></td>
			<td valign="top">Indicates a SID for a group trustee account</td>
		</tr>

		<tr>
			<td valign="top"><i>SidTypeDomain</i></td>
			<td valign="top">Indicates a SID representing a domain object</td>
		</tr>

		<tr>
			<td valign="top"><i>SidTypeAlias</i></td>
			<td valign="top">Indicates a SID representing a built-in group such as the Administrators group</td>
		</tr>

		<tr>
			<td valign="top"><i>SidTypeWellKnownGroup</i></td>
			<td valign="top">Indicates a SID for a well-known group such as the Everyone group</td>
		</tr>

		<tr>
			<td valign="top"><i>SidTypeDeletedAccount</i></td>
			<td valign="top">Indicates a SID for a deleted account</td>
		</tr>

		<tr>
			<td valign="top"><i>SidTypeInvalid</i></td>
			<td valign="top">Indicates an invalid SID</td>
		</tr>

		<tr>
			<td valign="top"><i>SidTypeUnknown</i></td>
			<td valign="top">Indicates an unknown SID type</td>
		</tr>

		<tr>
			<td valign="top"><i>SidTypeComputer</i></td>
			<td valign="top">Indicates a SID for a computer account on the domain</td>
		</tr>
		
	</table>
</p>

<p>Although <i>LookupAccountName</i> takes a computer name as a parameter, its search is not limited to the machine indicated. The search should be thought of as being performed from the perspective of the machine indicated. That said, the following list shows the search order for a trustee:</p>

<ol>
<p><li>Well-known SID names</li></p>

<p><li>Built-in and defined accounts on the local machine</li></p>

<p><li>The primary domain of the system</li></p>

<p><li>Trusted domains</li></p>

<p><li>Any domain in a domain forest</li></p>
</ol>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Although you can use <i>LookupAccountName</i> to find well-known SIDs, you should always use <i>AllocateAndInitializeSid</i> to directly build well-known SIDs.</blockquote></div>
</p>

<p>As you can see, the namespace for trustees is shared among users, groups, computers, and domains. Although the system will not allow you to create a user or a group with the same name as another user or group, the system does allow a user or a group to have the same name as a computer or a domain. This creates potential problems, because <i>LookupAccountName</i> will return the SID for a computer before it returns the SID for a user.</p>

<p>Your software must account for the possibility of a user or a group having the same name as a computer or a domain. The best way to deal with this is to explicitly indicate the computer name for the account as part of the account name. For example, if both a computer and a user are named &quot;JClark&quot;, and the &quot;JClark&quot; account exists on the &quot;JClark&quot; computer, the following code will return a SID for the user account:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL fRet = LookupAccountName(NULL, &quot;JClark\\JClark&quot;,
   &amp;sid, &amp;dwSizeSid, szBuffer, &amp;dwSizeBuf, &amp;use);
</pre></td></tr></table>
</p>

<A NAME="188"><h3>Retrieving a Trustee's Account Name</h3></A>
<p>If your software needs to find the account name for a trustee when it already has a binary SID, it should use <i>LookupAccountSid</i>:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL LookupAccountSid(
   PCTSTR        pszSystemName,
   PSID          pSid,
   PTSTR         pszName,
   PDWORD        pcbName,
   PTSTR         pszReferencedDomainName,
   PDWORD        pcbReferencedDomainName,
   PSID_NAME_USE peUse);
</pre></td></tr></table>
</p>

<p>The <i>pszSystemName</i> parameter is the name of the machine from which you perform the search. When <i>LookupAccountSid</i> searches for a trustee name, it follows the same search order and rules as does <i>LookupAccountName</i>.</p>

<p>The <i>pSid</i> parameter is a pointer to an existing SID for which you want to retrieve the corresponding account name. This SID can be any valid SID built by you or previously returned by the system in a token or some other structure.</p> 

<p>The <i>pszName</i> and <i>pszReferencedDomainName</i> should point to buffers that you provide to receive the trustee name and its domain name from the system. These buffers should be large enough to hold the return values; their sizes are passed via pointers to DWORD variables, where <i>pcbName</i> indicates the length of the buffer pointed to by <i>pszName,</i> and <i>pcbReferencedDomainName</i> indicates the length of the buffer pointed to by <i>pszReferencedDomainName</i>. If you do not pass buffers of sufficient size to receive these names from the system, the system returns the required buffer sizes in these two variables.</p> 

<p>You should pass the address of a SID_NAME_USE variable for <i>peUse</i> to receive from the system the use for the SID. For an explanation of the SID_NAME_USE enumeration type, see Table 9-9.</p>

<A NAME="189"><h2>Copying SIDs</h2></A>
<p>Many system functions return SIDs, and likewise many security-related functions expect you to build structures including SIDs or pointers to SIDs. This wouldn't be a problem except that SID structures are variable in length and the system designers have asked us to treat the structure as opaque. Luckily, the system provides a function to copy a SID:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL CopySid(
   DWORD dwDestinationSidLength,
   PSID  pSidDestination,
   PSID  pSidSource);
</pre></td></tr></table>
</p>

<p>This easy-to-use function simply takes the length of your buffer (in bytes), a pointer to a destination SID, and a pointer to the original SID.</p>

<p>Although the system knows the length of the SID that it is copying, it still needs to be sure that it does not write past the length of your buffer. This is why <i>CopySid</i> requires that you pass a length as the first parameter. More importantly, you will need to know how large a buffer to allocate. You can find the length of a SID in bytes using the <i>GetLengthSid</i> function:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
DWORD GetLengthSid(PSID pSid);
</pre></td></tr></table>
</p>

<p>Using the value returned from this function, you can allocate a buffer for your new SID.</p>

<A NAME="190"><h2>Textual and Binary SID Conversion</h2></A>
<p>At this point, you know how to perform the most commonly needed tasks concerning SIDs. However, our discussion of SIDs wouldn't be complete unless I told you how to convert a textual representation of a SID to a binary representation and vice versa.</p>

<p>Before proceeding, let me clarify what I mean by &quot;textual SID.&quot; I am <i>not</i> referring to the string representing the account name of the trustee; rather, I am referring to the string representing the binary SID structure. For example, &quot;S-1-1-0&quot; is a textual SID representing the SID whose trustee account name is Everyone.</p>

<p>Textual SIDs can be useful when storing SID names in persistent storage, such as the system registry, or when representing a SID in a user interface. The functions you use to convert to and from textual SIDs are <i>ConvertSidToStringSid</i> and <i>ConvertStringSidToSid</i>, respectively. Here are their prototypes:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL ConvertSidToStringSid(
   PSID   pSid,
   PTSTR* StringSid);

BOOL ConvertStringSidToSid(
   PCTSTR StringSid,
   PSID*  ppSid);
</pre></td></tr></table>
</p>

<p>Both of these functions allocate buffers for you, and it is your job to free them when you are finished with the returned data. Use the <i>LocalFree</i> function to free the buffers returned by these functions.</p> 

<p>Now that you have an exhaustive understanding of the system's binary identification for trustee accounts, you have all the information necessary to exploit both methods of manipulating membership of local groups as described earlier in this chapter. So let's begin our discussion on assigning and removing privileges for trustee accounts.</p>

</BODY>
</HTML>




