<HTML>
<HEAD>
<TITLE>Working with Registry Values</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="ch05d.htm">[Previous]</A> <A HREF="ch05f.htm">[Next]</A><P>

<A NAME="82"><h1>Working with Registry Values</h1></A>
<p>Up to this point, I have mostly discussed registry keys, without much mention of how to work with registry values. The registry value is the actual meat and potatoes of the registry. Registry values store the actual configuration data for your applications. Once you have a valid handle to an open registry key, you are ready to retrieve data contained within that key.</p>

<p>Three functions retrieve values from the system registry: <i>RegQueryValueEx</i>, <i>RegEnumValue</i>, and <i>RegQueryMultipleValues</i>. I will focus on <i>RegQueryValueEx</i> and <i>RegEnumValue</i> now. I'll discuss <i>RegQueryMultipleValues</i> shortly, in the section &quot;<A HREF="ch05g.htm#85">Accessing the Registry Remotely</A>.&quot;</p>

<p>You should use the <i>RegEnumValue</i> function when you do not know the name of the value that contains the data you want to retrieve, or when you want to systematically retrieve the data for all values contained within a given key. Conversely, you should use <i>RegQueryValueEx</i> to obtain data from a single value within a key, whose name (or lack of a name, in the case of the default value) is known ahead of time. The <i>RegQueryValueEx</i> function is prototyped as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
LONG RegQueryValueEx(
   HKEY   hkey,
   PTSTR  pszValueName, 
   PDWORD pdwReserved,
   PDWORD pdwType,
   PBYTE  pbData,
   PDWORD pcbData); 
</pre></td></tr></table>
</p>

<p>The <i>hkey</i> parameter is the handle to an open key with KEY_QUERY_VALUE access, and the <i>pszValueName</i> is the name of the value you wish to retrieve. If you pass NULL or a pointer to an empty string for the <i>pszValueName</i> parameter, the system will retrieve data from the default value for the key.</p>

<p>The <i>pdwType</i> parameter is a pointer to a DWORD variable that the system will fill with one of the data type values (such as REG_SZ or REG_BINARY) listed in Table 5-2, indicating the registry value's data type.</p>

<p>The <i>pbData</i> parameter is a pointer to a buffer that the function fills with the registry value's data, and the <i>pcbData</i> parameter points to a DWORD that contains the size of the passed buffer. You can also pass NULL for the <i>pbData</i> parameter, in which case the function fills the DWORD pointed to by <i>pcbData</i> with the size, in bytes, of the data contained in the registry value.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
<i>RegQueryValueEx</i> returns the error ERROR_MORE_DATA if your buffer size is not sufficient to retrieve all the data from the value. Under all circumstances, your application should be able to deal gracefully with this error. Usually the response is to allocate a larger buffer and execute the call to the function again. Checking the size of a value's data before calling <i>RegQueryValueEx</i> is not a guarantee of success, because some other process might make changes to the registry value after your application checked its data size.

<p>The CAutoBuf class included on this book's companion CD offers an elegant (if I do say so myself) way to handle functions that require data buffers of varying sizes. This C++ class is used frequently in the sample applications in this book.</p>
</blockquote></div>
</p>

<p>Typically if an application is going to retrieve only a single registry value, it will make two calls to <i>RegQueryValueEx</i>. The initial call is used to retrieve the required size of the buffer. After allocating a buffer of the proper size, a second call to <i>RegQueryValueEx</i> is made to actually retrieve the data.</p>

<p>There is, however, a second approach that might be more efficient depending largely on the number of registry values that you will be reading: make a single call to <i>RegQueryInfoKey</i> that returns the size of the largest value contained in the key. Then your application can allocate a single buffer to be used in multiple calls to <i>RegQueryValueEx</i>.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
The shell registry functions implement a function for retrieving data from registry values, named <i>SHGetValue</i>. It is defined as follows:
<p>
<table cellpadding=5 width="95%"><tr><td><pre>
DWORD SHGetValue( 
   HKEY   hkey,
   PCTSTR pszSubKey,
   PCTSTR pszValue,
   PDWORD pdwType,
   PVOID  pvData,
   PDWORD pcbData);
</pre></td></tr></table>
</p>
Notice that this function is very similar to <i>RegQueryValueEx</i>, but it also includes a <i>pszSubKey</i> parameter that allows you to specify the name of the key containing the value. This frees your application from the responsibility of calling <i>RegOpenKeyEx</i> and <i>RegCloseKey</i>.
</blockquote></div>
</p>

<p>If you do not know the name of the registry value in question, or if you wish to retrieve the data for every value contained within a single key, you should use <i>RegEnumValue</i>, which is prototyped as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
LONG RegEnumValue(
   HKEY   hkey,
   DWORD  dwIndex,
   PTSTR  pszValueName,
   PDWORD pcbValueName, 
   PDWORD pdwReserved,
   PDWORD pdwType,
   PBYTE  pbData,
   PDWORD pcbData);
</pre></td></tr></table>
</p>

<p>As you can see, <i>RegEnumValue</i> is very similar to <i>RegQueryValueEx</i>, except that rather than passing <i>RegEnumValue</i> a value name, you pass it an index value that correlates to the sequential location of the value within the key referenced in <i>hkey</i>. <i>RegEnumValue</i> returns the value name in a buffer pointed to by the <i>pszValueName</i> parameter.</p>

<p>To find the proper size of the buffer so that you can retrieve the value's name, your application can make an initial call to <i>RegQueryValueEx</i>, specifying NULL for <i>pbData</i>. Doing so retrieves the length of the longest value name contained within the key.</p>

<A NAME="83"><h2>The RegScan Sample Application</h2></A>
<p>The RegScan sample application (&quot;05 RegScan.exe&quot;), shown in Listing 5-1, demonstrates how to enumerate keys and values under a specified key, as well as how to retrieve data from the enumerated values. The source code and resource files for the application are in the 05-RegScan directory on the companion CD. The sample application will recursively traverse the registry as it searches for a specified text string either in a key name or in a value.</p>

<p>When you launch RegScan, you can enter the machine name whose registry you wish to search. Then you select a root key and a starting subkey and enter a search string in the String edit box. Figure 5-2 shows the results of my search.</p>

<p>Later in this chapter (in the section &quot;<A HREF="ch05g.htm#85">Accessing the Registry Remotely</A>&quot;), I'll discuss how RegScan can search a remote machine's registry.</p>

<p>
<A HREF="javascript:fullSize('F05FJ02x.htm')"> <img src="images/F05FJ02.JPG" width=404 height=278 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<caption><b>Figure 5-2.</b> <i>A search using the RegScan sample application</i>
</p>

<p><b>Listing 5-1.</b> <i>The RegScan sample application</i></p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
<p><b>RegScan.cpp</b></p>
/******************************************************************************
Module:  RegScan.cpp
Notices: Copyright (c) 2000 Jeffrey Richter
******************************************************************************/


#include &quot;..\CmnHdr.h&quot;                 // See Appendix A.
#include &lt;WindowsX.h&gt;
#include &lt;stdio.h&gt;
#include &quot;Resource.h&quot;

#define UILAYOUT_IMPL
#include &quot;..\ClassLib\UILayout.h&quot;      // See Appendix B.

#define PRINTBUF_IMPL
#include &quot;..\ClassLib\PrintBuf.h&quot;      // See Appendix B.

#define AUTOBUF_IMPL
#include &quot;..\ClassLib\AutoBuf.h&quot;       // See Appendix B.

#define REGWALK_IMPL
#include &quot;RegWalk.h&quot;
///////////////////////////////////////////////////////////////////////////////


class CRegScan : private CRegWalk {
public:
   CRegScan() : m_pb(256 * 1024) { }
   BOOL Go(PCTSTR pszMachine, HKEY hkeyRoot, PCTSTR pszSubkey, 
      PCTSTR pszString, BOOL fSearchKeyNames, BOOL fSearchValueNames, 
      BOOL fSearchValueData, BOOL fCaseSensitive);
   PCTSTR Result() { return(m_pb); }

   void ForceSearchStop() { m_fStopSearch = TRUE; }
   BOOL WasSearchStopped() { return(m_fStopSearch); }
   
private:
   PCTSTR m_pszString;           // String to search for
   BOOL   m_fSearchKeyNames;     // Search key names?
   BOOL   m_fSearchValueNames;   // Search values names?
   BOOL   m_fSearchValueData;    // Search value string data?
   BOOL   m_fShownThisSubkey;    // Any matches from the current subkey?
   BOOL   m_fStopSearch;         // Prematurely stop the search?
   CPrintBuf m_pb;               // Growable results buffer

   typedef PTSTR (WINAPI* PFNSTRCMP)(PCTSTR pszFirst, PCTSTR pszSearch);
   PFNSTRCMP m_pfnStrCmp;        // String comparison function

protected:
   REGWALKSTATUS onSubkey(PCTSTR pszSubkey, int nDepth, 
      BOOL fRecurseRequested);
   REGWALKSTATUS onValue(HKEY hkey, PCTSTR pszValue, int nDepth);
   void ProcessUI();
};


///////////////////////////////////////////////////////////////////////////////


BOOL CRegScan::Go(PCTSTR pszMachine, HKEY hkeyRoot, PCTSTR pszSubkey, 
   PCTSTR pszString, BOOL fSearchKeyNames, BOOL fSearchValueNames, 
   BOOL fSearchValueData, BOOL fCaseSensitive) {

   m_pszString         = pszString;
   m_fSearchKeyNames   = fSearchKeyNames;
   m_fSearchValueNames = fSearchValueNames;
   m_fSearchValueData  = fSearchValueData;
   m_pfnStrCmp         = fCaseSensitive ? StrStr : StrStrI;
   m_fShownThisSubkey  = FALSE;
   m_fStopSearch       = FALSE;
   m_pb.Clear();
   BOOL fOk = TRUE;
   if (!m_fSearchKeyNames &amp;&amp; !m_fSearchValueNames &amp;&amp; !m_fSearchValueData) {
      chMB(&quot;You must at least select one field to search.&quot;);
   } else fOk = CRegWalk::Go(pszMachine, hkeyRoot, pszSubkey, TRUE);
   return(fOk);
}


///////////////////////////////////////////////////////////////////////////////


void CRegScan::ProcessUI() {
   MSG msg;
   while (PeekMessage(&amp;msg, 0, 0, 0, PM_REMOVE)) {
      // There are UI messages, process them.      
      if (!IsDialogMessage(GetActiveWindow(), &amp;msg)) {
         TranslateMessage(&amp;msg);
         DispatchMessage(&amp;msg);  
      }   
   }
}


///////////////////////////////////////////////////////////////////////////////


CRegWalk::REGWALKSTATUS CRegScan::onSubkey(PCTSTR pszSubkey, int nDepth, 
   BOOL fRecurseRequested) {

   REGWALKSTATUS rws = RWS_FULLSTOP;
   if (fRecurseRequested || (nDepth == 0)) rws = RWS_RECURSE;

   // Get this subkey's name without the full path
   PCTSTR pszSubkeyName = PathFindFileName(pszSubkey);
   if (m_fSearchKeyNames) 
      m_fShownThisSubkey = (m_pfnStrCmp(pszSubkeyName, m_pszString) != NULL);
   else m_fShownThisSubkey = FALSE;
   
   if (m_fShownThisSubkey) {
      m_pb.Print(TEXT(&quot;%s\r\n&quot;), pszSubkey);
   }

   ProcessUI();
   return(WasSearchStopped() ? RWS_FULLSTOP : rws);
}


///////////////////////////////////////////////////////////////////////////////


CRegWalk::REGWALKSTATUS CRegScan::onValue(
   HKEY hkey, PCTSTR pszValue, int nDepth) {
   
   if (m_fSearchValueNames &amp;&amp; (m_pfnStrCmp(pszValue, m_pszString) != NULL)) {
      if (!m_fShownThisSubkey) {
         m_pb.Print(TEXT(&quot;%s\r\n&quot;), m_szSubkeyPath);
         m_fShownThisSubkey = TRUE;
      }
      m_pb.Print(TEXT(&quot;\t%s\r\n&quot;), pszValue);
   }

   if (m_fSearchValueData) {
      // Check the value's data
      DWORD dwType;
      RegQueryValueEx(hkey, pszValue, NULL, &amp;dwType, NULL, NULL);

      if ((dwType == REG_EXPAND_SZ) || (dwType == REG_SZ)) {
         CAutoBuf&lt;TCHAR, sizeof(TCHAR)&gt; szData;
         // Give buffer a size &gt; 0 so that RegQueryValueEx returns 
         // ERROR_MORE_DATA instead of ERROR_SUCCESS.
         szData = 1;
         while (RegQueryValueEx(hkey, pszValue, NULL, NULL, szData, szData)
            == ERROR_MORE_DATA) ;

         // szData is NULL is there is no value data
         if (((PCTSTR) szData != NULL) &amp;&amp; 
            (m_pfnStrCmp(szData, m_pszString) != NULL)) {
            
            if (!m_fShownThisSubkey) {
               m_pb.Print(TEXT(&quot;%s\r\n&quot;), m_szSubkeyPath);
               m_fShownThisSubkey = TRUE;
            }
            m_pb.Print(TEXT(&quot;\t%s (%s)\r\n&quot;), 
             ((pszValue[0] == 0) ? TEXT(&quot;(default)&quot;) : pszValue), 
             (PCTSTR) szData);
         }
      }
   }
   ProcessUI();
   return(WasSearchStopped() ? RWS_FULLSTOP : RWS_CONTINUE);
}


///////////////////////////////////////////////////////////////////////////////


CUILayout g_UILayout;   // Repositions controls when dialog box size changes.


///////////////////////////////////////////////////////////////////////////////


BOOL Dlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam) {

   chSETDLGICONS(hwnd, IDI_REGSCAN);

   HWND hwndRootKey = GetDlgItem(hwnd, IDC_ROOTKEY);
   int n = 0;
   n = ComboBox_AddString(hwndRootKey, TEXT(&quot;HKEY_LOCAL_MACHINE&quot;));
   ComboBox_SetItemData(hwndRootKey, n, HKEY_LOCAL_MACHINE);
   ComboBox_SetCurSel(hwndRootKey, n);   // HKLM is default

   n = ComboBox_AddString(hwndRootKey, TEXT(&quot;HKEY_CURRENT_CONFIG&quot;));
   ComboBox_SetItemData(hwndRootKey, n, HKEY_CURRENT_CONFIG);
   
   n = ComboBox_AddString(hwndRootKey, TEXT(&quot;HKEY_CLASSES_ROOT&quot;));
   ComboBox_SetItemData(hwndRootKey, n, HKEY_CLASSES_ROOT);

   n = ComboBox_AddString(hwndRootKey, TEXT(&quot;HKEY_USERS&quot;));
   ComboBox_SetItemData(hwndRootKey, n, HKEY_USERS);

   n = ComboBox_AddString(hwndRootKey, TEXT(&quot;HKEY_CURRENT_USER&quot;));
   ComboBox_SetItemData(hwndRootKey, n, HKEY_CURRENT_USER);

   // Set up the resizeing of the controls
   g_UILayout.Initialize(hwnd); 
   g_UILayout.AnchorControl(CUILayout::AP_TOPLEFT, CUILayout::AP_TOPRIGHT, 
      IDC_MACHINE, FALSE);
   g_UILayout.AnchorControl(CUILayout::AP_TOPLEFT, CUILayout::AP_TOPRIGHT, 
      IDC_ROOTKEY, FALSE);
   g_UILayout.AnchorControl(CUILayout::AP_TOPLEFT, CUILayout::AP_TOPRIGHT, 
      IDC_SUBKEY, FALSE);
   g_UILayout.AnchorControl(CUILayout::AP_TOPLEFT, CUILayout::AP_TOPRIGHT, 
      IDC_STRING, FALSE);

   g_UILayout.AnchorControl(CUILayout::AP_TOPRIGHT, CUILayout::AP_TOPRIGHT, 
      IDC_SEARCHKEYNAMES, FALSE);
   g_UILayout.AnchorControl(CUILayout::AP_TOPRIGHT, CUILayout::AP_TOPRIGHT, 
      IDC_SEARCHVALUENAMES, FALSE);
   g_UILayout.AnchorControl(CUILayout::AP_TOPRIGHT, CUILayout::AP_TOPRIGHT, 
      IDC_SEARCHVALUEDATA, FALSE);
   g_UILayout.AnchorControl(CUILayout::AP_TOPRIGHT, CUILayout::AP_TOPRIGHT, 
      IDC_CASESENSITIVE, FALSE); 
   g_UILayout.AnchorControl(CUILayout::AP_TOPRIGHT, CUILayout::AP_TOPRIGHT, 
      IDC_SEARCHSTART, FALSE); 
   g_UILayout.AnchorControl(CUILayout::AP_TOPRIGHT, CUILayout::AP_TOPRIGHT, 
      IDC_SEARCHSTOP, FALSE); 

   g_UILayout.AnchorControl(CUILayout::AP_TOPLEFT, CUILayout::AP_BOTTOMRIGHT, 
      IDC_SEARCHRESULTS, FALSE);
   
   CheckDlgButton(hwnd, IDC_SEARCHKEYNAMES,   TRUE);
   CheckDlgButton(hwnd, IDC_SEARCHVALUENAMES, TRUE);
   CheckDlgButton(hwnd, IDC_SEARCHVALUEDATA,  TRUE);
   return(TRUE);
}


///////////////////////////////////////////////////////////////////////////////


void EnableControls(HWND hwnd, BOOL fEnable) {

   EnableWindow(GetDlgItem(hwnd, IDC_MACHINE),          fEnable);
   EnableWindow(GetDlgItem(hwnd, IDC_ROOTKEY),          fEnable);
   EnableWindow(GetDlgItem(hwnd, IDC_SUBKEY),           fEnable);
   EnableWindow(GetDlgItem(hwnd, IDC_STRING),           fEnable);

   EnableWindow(GetDlgItem(hwnd, IDC_SEARCHKEYNAMES),   fEnable);
   EnableWindow(GetDlgItem(hwnd, IDC_SEARCHVALUENAMES), fEnable);
   EnableWindow(GetDlgItem(hwnd, IDC_SEARCHVALUEDATA),  fEnable);
   EnableWindow(GetDlgItem(hwnd, IDC_CASESENSITIVE),    fEnable);

   ShowWindow(GetDlgItem(hwnd, IDC_SEARCHSTART), fEnable ? SW_SHOW : SW_HIDE);
   ShowWindow(GetDlgItem(hwnd, IDC_SEARCHSTOP),  fEnable ? SW_HIDE : SW_SHOW);
}


///////////////////////////////////////////////////////////////////////////////


void Dlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify) {

   static CRegScan x;
   
   switch (id) {
   case IDCANCEL:
      EndDialog(hwnd, id);
      break;

   case IDC_SEARCHSTOP:
      x.ForceSearchStop();
      break;

   case IDC_SEARCHSTART:
      SetDlgItemText(hwnd, IDC_SEARCHRESULTS, TEXT(&quot;Scanning Registry...&quot;));
      EnableControls(hwnd, FALSE);

      TCHAR szString[1000];
      GetDlgItemText(hwnd, IDC_STRING, szString, chDIMOF(szString));

      TCHAR szMachine[100], szSubkey[1000];
      GetDlgItemText(hwnd, IDC_MACHINE, szMachine, chDIMOF(szMachine));
      GetDlgItemText(hwnd, IDC_SUBKEY, szSubkey, chDIMOF(szSubkey));
      HWND hwndRootKey = GetDlgItem(hwnd, IDC_ROOTKEY);
      int nIndex = ComboBox_GetCurSel(hwndRootKey);
      HKEY hkeyRoot = (HKEY) ComboBox_GetItemData(hwndRootKey, nIndex);

      if (!x.Go(
         (szMachine[0] == 0) ? NULL : szMachine, hkeyRoot, szSubkey, 
         szString,
         IsDlgButtonChecked(hwnd, IDC_SEARCHKEYNAMES), 
         IsDlgButtonChecked(hwnd, IDC_SEARCHVALUENAMES), 
         IsDlgButtonChecked(hwnd, IDC_SEARCHVALUEDATA), 
         IsDlgButtonChecked(hwnd, IDC_CASESENSITIVE))) {
         chMB(&quot;Couldn't access the registry&quot;);
      }

      SetDlgItemText(hwnd, IDC_SEARCHRESULTS, 
         x.WasSearchStopped() ? TEXT(&quot;Scan Canceled&quot;) : 
            ((x.Result()[0] == 0) ? TEXT(&quot;No entries found&quot;) : x.Result()));
      EnableControls(hwnd, TRUE);         
      break;
   }
}


///////////////////////////////////////////////////////////////////////////////


void Dlg_OnSize(HWND hwnd, UINT state, int cx, int cy) {

   // Reposition the child controls
   g_UILayout.AdjustControls(cx, cy);    
}


///////////////////////////////////////////////////////////////////////////////


void Dlg_OnGetMinMaxInfo(HWND hwnd, PMINMAXINFO pMinMaxInfo) {

   // Return minimum size of dialog box
   g_UILayout.HandleMinMax(pMinMaxInfo);
}


///////////////////////////////////////////////////////////////////////////////


INT_PTR WINAPI Dlg_Proc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

   switch (uMsg) {
   chHANDLE_DLGMSG(hwnd, WM_INITDIALOG,    Dlg_OnInitDialog);
   chHANDLE_DLGMSG(hwnd, WM_COMMAND,       Dlg_OnCommand);
   chHANDLE_DLGMSG(hwnd, WM_SIZE,          Dlg_OnSize);
   chHANDLE_DLGMSG(hwnd, WM_GETMINMAXINFO, Dlg_OnGetMinMaxInfo);
   }
   return(FALSE);
}


///////////////////////////////////////////////////////////////////////////////


int WINAPI _tWinMain(HINSTANCE hinstExe, HINSTANCE, PTSTR pszCmdLine, int) {

   DialogBox(hinstExe, MAKEINTRESOURCE(IDD_REGSCAN), NULL, Dlg_Proc);
   return(0);
}


//////////////////////////////// End of File //////////////////////////////////
</pre></td></tr></table>
</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
<p><b>RegWalk.h</b></p>
/******************************************************************************
Module: RegWalk.h
Notices: Copyright (c) 2000 Jeffrey Richter
******************************************************************************/


#pragma once   // Include this header file once per compilation unit


///////////////////////////////////////////////////////////////////////////////


#include &lt;ShlWapi.h&gt;


///////////////////////////////////////////////////////////////////////////////


class CRegWalk {
public:
   CRegWalk() {}
   virtual ~CRegWalk() {}
   BOOL Go(PCTSTR pszMachine, HKEY hkeyRoot, PCTSTR pszSubkey, BOOL fRecurse);
   enum REGWALKSTATUS { RWS_FULLSTOP, RWS_CONTINUE, RWS_RECURSE };

protected:
   virtual REGWALKSTATUS onSubkey(PCTSTR pszSubkey, int nDepth, 
      BOOL fRecurseRequested);
   virtual REGWALKSTATUS onValue(HKEY hkey, PCTSTR pszValue, int nDepth);

protected:
   HKEY   m_hkeyRootMachine;        // Root key on machine
   BOOL   m_fRecurse;               // Recurse into subkeys?
   int    m_nDepth;                 // Recurse depth
   TCHAR  m_szSubkeyPath[MAX_PATH]; // Subkey path

private:
   REGWALKSTATUS RegWalkRecurse();
   REGWALKSTATUS EnumValuesInSubkey();
};


///////////////////////////////////////////////////////////////////////////////


#ifdef REGWALK_IMPL


///////////////////////////////////////////////////////////////////////////////


#pragma comment(lib, &quot;shlwapi&quot;)


///////////////////////////////////////////////////////////////////////////////


CRegWalk::REGWALKSTATUS CRegWalk::onSubkey(PCTSTR pszSubkey, int nDepth, 
   BOOL fRecurseRequested) { 

   return(fRecurseRequested ? RWS_RECURSE : RWS_CONTINUE);
}


CRegWalk::REGWALKSTATUS CRegWalk::onValue(HKEY hkey, PCTSTR pszValue, 
   int nDepth) {

   return(RWS_CONTINUE);
}


///////////////////////////////////////////////////////////////////////////////


CRegWalk::REGWALKSTATUS CRegWalk::EnumValuesInSubkey() {

   HKEY hkey = NULL;
   REGWALKSTATUS rws = RWS_CONTINUE;

   if (ERROR_SUCCESS == RegOpenKeyEx(m_hkeyRootMachine, m_szSubkeyPath, 0, 
      KEY_QUERY_VALUE, &amp;hkey)) {

      for (int nIndex = 0; rws != RWS_FULLSTOP; nIndex++) {

         TCHAR szValueName[256]; // No value name exceeds 255 characters
         DWORD cbValueName = chDIMOF(szValueName);
         if (ERROR_SUCCESS != RegEnumValue(hkey, nIndex, 
            szValueName, &amp;cbValueName, NULL, NULL, NULL, NULL))
            break;

         rws = onValue(hkey, szValueName, m_nDepth);
      }
      chVERIFY(RegCloseKey(hkey) == ERROR_SUCCESS);
   }
   return(rws);
}


///////////////////////////////////////////////////////////////////////////////


CRegWalk::REGWALKSTATUS CRegWalk::RegWalkRecurse() {

   // Report this Subkey
   REGWALKSTATUS rws = onSubkey(m_szSubkeyPath, ++m_nDepth, m_fRecurse);

   // Enumerate the values in this subkey?
   if (rws == RWS_RECURSE) rws = EnumValuesInSubkey();

   // Continue enumerating subkeys?
   if (rws != RWS_FULLSTOP) {

      HKEY hkey = NULL;
      if (ERROR_SUCCESS == RegOpenKeyEx(m_hkeyRootMachine, m_szSubkeyPath, 0, 
         KEY_ENUMERATE_SUB_KEYS, &amp;hkey)) {

         for (int nIndex = 0; rws != RWS_FULLSTOP; nIndex++) {

            TCHAR szSubkeyName[256]; // No subkey name exceeds 255 characters
            DWORD cbSubkeyName = chDIMOF(szSubkeyName);
            if (ERROR_SUCCESS != RegEnumKeyEx(hkey, nIndex, 
               szSubkeyName, &amp;cbSubkeyName, NULL, NULL, NULL, NULL))
               break;

            // Append the subkey to the path
            if (m_szSubkeyPath[0] != 0) StrCat(m_szSubkeyPath, TEXT(&quot;\\&quot;));
            StrCat(m_szSubkeyPath, szSubkeyName);

            rws = RegWalkRecurse();
            
            // Truncate the last subkey from the path
            PTSTR p = StrRChr(m_szSubkeyPath, NULL, TEXT(`\\'));
            if (p != NULL) *p = 0;
            else m_szSubkeyPath[0] = 0;
         }
         chVERIFY(RegCloseKey(hkey) == ERROR_SUCCESS);
      }
   }
   m_nDepth--;
   return(rws);
}


///////////////////////////////////////////////////////////////////////////////


BOOL CRegWalk::Go(PCTSTR pszMachine, HKEY hkeyRoot, PCTSTR pszSubkey, 
   BOOL fRecurse) {

   // nDepth indicates how many levels from the top we are.
   m_nDepth = -1;
   m_fRecurse = fRecurse;
   m_hkeyRootMachine = NULL;
   
   REGWALKSTATUS rws = RWS_FULLSTOP;
   __try {
      if (ERROR_SUCCESS != 
         RegConnectRegistry(pszMachine, hkeyRoot, &amp;m_hkeyRootMachine))
         __leave;

      lstrcpy(m_szSubkeyPath, pszSubkey);

      // Call the recursive function to walk the subkeys
      rws = RegWalkRecurse();
   }
   __finally {
      if (m_hkeyRootMachine != NULL)
         RegCloseKey(m_hkeyRootMachine);
   }
   return(rws != RWS_FULLSTOP);
}


///////////////////////////////////////////////////////////////////////////////


#endif   // REGWALK_IMPL


//////////////////////////////// End of File //////////////////////////////////
</pre></td></tr></table>
</p>

</BODY>
</HTML>




