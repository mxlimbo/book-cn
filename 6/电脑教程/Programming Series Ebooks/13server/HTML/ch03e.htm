<HTML>
<HEAD>
<TITLE>Control Codes and Status Reporting</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="ch03d.htm">[Previous]</A> <A HREF="ch03f.htm">[Next]</A><P>

<A NAME="53"><H1>Control Codes and Status Reporting</H1></A>
<p>The <I>HandlerEx </I>function is responsible for handling all requested actions of 
the service and all notifications. 
<I>HandlerEx</I>'s first parameter is a code indicating 
the action request or notification. Table 3-2 describes the codes that indicate 
an action request. An action request tells the service to perform some action to 
alter its execution state.</p>

<p><b>Table 3-2.</b> <i>Control codes that indicate an action request</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Control Code  </th>
<th>Description  </th></tr>
<tr>
<td valign="top">SERVICE_CONTROL_STOP  </td>
<td valign="top">Requests the service to stop.  </td></tr>
<tr>
<td valign="top">SERVICE_CONTROL_PAUSE  </td>
<td valign="top">Requests the service to pause.  </td></tr>
<tr>
<td valign="top">SERVICE_CONTROL_CONTINUE  </td>
<td valign="top">Requests the paused service to resume.  </td></tr>
<tr>
<td valign="top">SERVICE_CONTROL_INTERROGATE  </td>
<td valign="top">Requests the service to immediately update its current status information to the SCM. This is the only control code that all services must respond to.  </td></tr>
</table></p>


<p>Table 3-3 describes the codes that indicate notifications. 
Notifications inform services of &quot;interesting&quot; events in the system. However, services 
usually do not alter their execution state in response to notifications (although a 
service might choose to alter its execution state).</p>

<p><b>Table 3-3.</b> <i>Control codes that indicate a notification</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Control Code  </th>
<th>Description  </th></tr>
<tr>
<td valign="top">SERVICE_CONTROL_PARAMCHANGE  </td>
<td valign="top">Notifies the service that configuration parameters have changed. A service can ignore this or reconfigure itself while running.  </td></tr>
<tr>
<td valign="top">SERVICE_CONTROL_DEVICEEVENT </td>
<td valign="top">Notifies the service of a device event. The service must call <I>RegisterDeviceNotification </I>to receive these notifications.  </td></tr>
<tr>
<td valign="top">SERVICE_CONTROL_HARDWAREPROFILECHANGE   </td>
<td valign="top">Notifies the service of a hardware profile change.  </td></tr>
<tr>
<td valign="top">SERVICE_CONTROL_POWEREVENT  </td>
<td valign="top">Notifies the service of a power event.  </td></tr>
<tr>
<td valign="top">A number between 128 and 255, inclusive  </td>
<td valign="top">Notifies the service of a user-defined event.  </td></tr>
</table></p>
      

<A NAME="54"><H2>Codes Requiring Status Reporting</H2></A>
<p>The work performed by the <I>HandlerEx</I> function differs dramatically 
depending on the control code it receives. In particular, the action request codes 
require special attention in your code. When the 
<I>HandlerEx </I>function receives a SERVICE_CONTROL_STOP, 
SERVICE_CONTROL_SHUTDOWN, SERVICE_CONTROL_PAUSE, or 
SERVICE_CONTROL_CONTINUE control code, <I>SetServiceStatus 
</I>must be called to acknowledge receipt of the 
code and to specify how long the service thinks it will take to process the state 
change. For example, you acknowledge receipt of the control code by setting 
the SERVICE_STATUS structure's <I>dwCurrentState 
</I>member to SERVICE_STOP_PENDING, SERVICE_PAUSE_PENDING, or 
SERVICE_CONTINUE_PENDING. In addition, the <I>HandlerEx </I>function must return within 30 
seconds, or the SCP application will again think that the service has stopped 
responding. If the SCM thinks that the service has stopped responding, it doesn't 
kill the service; it just returns failure to the SCP that initiated the service control code.</p>

<p>While a stop, shutdown, pause, or continue operation is pending, you 
must also specify how long you think the operation will take to complete. 
Specifying the duration is useful because a service might not be able to change its 
state immediately&#8212;it might have to wait for a network request to complete or 
for data to be flushed to a drive. You indicate how long the state change will 
take to complete by using the <I>dwCheckPoint </I>and 
<I>dwWaitHint </I>members of the SERVICE_STATUS structure, just as you did when you reported that the 
service was first starting. If you want, you can report periodic progress 
by incrementing the <I>dwCheckPoint </I>member and setting the 
<I>dwWaitHint </I>member to indicate how long you expect the service to take to get to the next step.</p>

<p>After the service has performed all the actions required to stop, shut 
down, pause, or continue itself, <I>SetServiceStatus 
</I>should be called again. This time you set the 
<I>dwCurrentStatus </I>member to SERVICE_STOPPED, SERVICE_PAUSED, or 
SERVICE_RUNNING. When you report any of these three 
status codes, both the <I>dwCheckPoint </I>and <I>dwWaitHint 
</I>members should be 0 because the service has completed its state change.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
After a service calls <I>SetServiceStatus 
</I>to report SERVICE_STOPPED, the SCM allows that service to run for up to 30 seconds more. If 
the service is still running after 30 seconds, the SCM terminates the 
service's process if there are no other services currently running in that process.
</blockquote></div>
</p>

<p>When the <I>HandlerEx </I>function receives a 
SERVICE_CONTROL_INTERROGATE control code, the service should simply acknowledge 
receipt by setting <I>dwCurrentState </I>to the service's current state and 
calling <I>SetServiceStatus</I>. (Again, set both 
<I>dwCheckPoint </I>and <I>dwWaitHint </I>to 0 
before making this call<I> </I>to <I>SetServiceStatus</I>.)</p>

<p>When the system is shutting down, the <I>HandlerEx 
</I>function receives a SERVICE_CONTROL_SHUTDOWN notification code. The service 
should perform the minimal set of actions necessary to save any data and should 
ultimately call <I>SetServiceStatus </I>to report SERVICE_STOPPED. To ensure that 
a machine shuts down in a timely fashion, a service should process this 
control code only if it absolutely has to. By default, the system gives just 20 seconds 
for all services to shut down. After 20 seconds, the SCM process (Services.exe) 
is killed and the machine continues to shut down. This 20-second period is 
set by the <I>WaitToKillServiceTimeout </I>value, which is contained in the 
following registry subkey:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control
</pre></td></tr></table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
When the system is shutting down, the SCM notifies all services 
that accept the SERVICE_CONTROL_SHUTDOWN notification 
code. Some services might ignore the code, some might save data to 
disk, some might stop themselves and terminate. You must be very 
careful not to execute any actions in your service that require the assistance 
of other services. These other services might be in a &quot;bad&quot; state or 
might even have terminated. The system completely ignores service 
dependencies when shutting down. Microsoft's goal was to make the system 
shut down as quick as possible. In fact, other services might even receive 
their shutdown notifications before your service receives its notification. 
The problem with this shutdown notification order is that services you 
depend on might stop running at any time, and your service must 
handle this situation gracefully.
</blockquote></div>
</p>

<p>For the notification codes listed in Table 3-3, your 
<I>HandlerEx</I> function should handle the notification and return. Do not call the 
<I>SetServiceStatus </I>function unless the notification response forces the service to change its 
execution state. If the service is going to change its execution state, 
<I>SetServiceStatus </I>should be called to set the 
<I>dwCurrentState</I>, <I>dwCheckPoint</I>, and 
<I>dwWaitHint </I>members to the appropriate values as previously discussed.</p>

<A NAME="55"><H2>Dealing with Interthread Communication Issues</H2></A>
<p>A service is awkward to write because although the primary thread 
executing the <I>HandlerEx </I>function receives the action request, often the service 
thread needs to do the actual work to process the request. For example, you might 
be writing a service that processes client requests that come in over a named 
pipe. Your service's thread suspends itself waiting for a client to 
connect. If your <I>HandlerEx </I>thread receives a SERVICE_CONTROL_STOP code, how do 
you stop the service? I've seen many developers simply call 
<I>TerminateThread </I>from the <I>HandlerEx </I>function to kill the service thread forcibly. By now, you 
should know that <I>TerminateThread </I>is one of the worst functions you can possibly 
call because the thread doesn't get a chance to clean up: the thread's stack is 
not destroyed, the thread can't release any kernel objects that it might have 
waited on, DLLs are not notified that the thread has been destroyed, and so on.</p>

<p>The proper way for the service to stop is to somehow wake up, see that 
it is supposed to stop, clean up properly, and then return from its 
<I>ServiceMain </I>function. To make the service do this, you must implement some form 
of interthread communication between your <I>HandlerEx 
</I>function and your <I>ServiceMain </I>function. You can use any queuing interthread 
communication mechanism you like, including APC queues, sockets, and window messages. 
I always use I/O completion ports.</p>

<p>To update its current status, a service must frequently call 
<I>SetServiceStatus</I>. All this status reporting can be another difficult aspect of coding a 
service. Service implementers often debate about where to place the calls 
to <I>SetServiceStatus</I>. Here are some of the possibilities:</p>

<UL>
<p><li>Have the <I>HandlerEx </I>function make the initial call to 
<I>SetServiceStatus </I>to report the pending action, and then use interthread 
communication to get the code to the <I>ServiceMain 
</I>thread. The <I>ServiceMain </I>thread does the work and then uses interthread communication 
to let the <I>HandlerEx </I>function know that the action is complete. At 
that point, the <I>HandlerEx </I>function calls 
<I>SetServiceStatus </I>again to report the service's new execution state.</li></p>

<p><li>Have the <I>HandlerEx </I>function use interthread communication to 
get the code to the <I>ServiceMain </I>thread. The 
<I>ServiceMain </I>thread makes the initial call to 
<I>SetServiceStatus </I>to report the pending 
action, does the work, and then calls <I>SetServiceStatus 
</I>again to report the service's new execution state.</li></p>

<p><li>Have the <I>HandlerEx </I>function make the initial call to 
<I>SetServiceStatus </I>to report the pending action, and then use interthread 
communication to get the code to the <I>ServiceMain 
</I>thread. The <I>ServiceMain </I>thread does the work and also calls 
<I>SetServiceStatus </I>again to report the service's new execution state.</li></p>
</UL>
 
<p>All of the above scenarios have pros and cons. I have experimented at 
great length with all of these possibilities and feel very confident in 
recommending the last option. Here are my reasons.</p>

<p>First, the SCP calls a function to control a service, and the SCM passes 
this control to the service. At this point, the SCP is suspended, waiting for the 
service to call <I>SetServiceStatus </I>to indicate that the service has received the 
control code. If the service's <I>HandlerEx </I>function doesn't return within 30 seconds, 
the SCM allows the SCP to wake, and the SCP's function call to control the 
service returns failure.</p>

<p>Second, the <I>HandlerEx </I>function is executed by the service process's 
primary thread. (All services in a single process have their 
<I>HandlerEx </I>functions executed by the primary thread.) If the 
<I>HandlerEx </I>function waited for the <I>ServiceMain 
</I>thread to complete the action before returning, any other 
services in the same process would not be able to receive action requests or 
notifications. This would make all the other services appear nonresponsive, which is 
unacceptable (in my opinion).</p>

<p>So I prefer the third method&#8212;the <I>HandlerEx 
</I>function makes the initial call to 
<I>SetServiceStatus</I>, interthread communication is used to get the code 
to the <I>ServiceMain</I> thread, and the 
<I>ServiceMain</I> thread performs the work and 
calls <I>SetServiceStatus</I> to report the new execution state. However, this method 
has a problem: a potential race condition exists. Imagine a service's 
<I>HandlerEx </I>receives a SERVICE_CONTROL_PAUSE code, responds with a 
SERVICE_PAUSE_PENDING, and then passes the code to the 
<I>ServiceMain </I>thread. The <I>ServiceMain </I>thread starts processing the code when, all of a sudden, 
the <I>HandlerEx </I>thread preempts the <I>ServiceMain 
</I>thread and receives a SERVICE_CONTROL_STOP code. The 
<I>HandlerEx</I> function now responds with a SERVICE_STOP_PENDING code and queues the new code to 
the <I>ServiceMain </I>thread. When the <I>ServiceMain 
</I>thread gets CPU time again, it completes its processing of the SERVICE_CONTROL_PAUSE code and 
reports SERVICE_PAUSED. Then the thread sees the queued SERVICE_CONTROL_STOP code, stops the service, and reports 
SERVICE_STOPPED. After all of this, the SCM receives the following state updates:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
SERVICE_PAUSE_PENDING
SERVICE_STOP_PENDING
SERVICE_PAUSED
SERVICE_STOPPED
</pre></td></tr></table>
</p>

<p>As you can see, these updates are gibberish, and an administrator 
could become quite confused. Note, however, that the service is running fine. 
You'd be surprised how many services I've seen that can actually report this 
sequence. The developers of these services never fix the problem, because it is quite 
unlikely that an administrator will issue action requests to the service so 
quickly&#8212;but it can happen! To solve this sequence problem, you must use a 
thread synchronization mechanism. The TimeService sample application at the end 
of this chapter uses a CGate C++ class to solve this problem efficiently.</p>

<p>When I first started working with services, I thought that the SCM 
would be responsible for preventing race conditions from occurring. But my 
experiments show that the SCM does absolutely nothing to time the sending of 
control codes. In fact, the SCM does absolutely nothing to ensure that a 
service receives control codes properly, either. Here's what I mean: While a service 
is already paused, try sending the service a SERVICE_CONTROL_PAUSE 
code. You won't be able to do this with the Services snap-in because the snap-in 
will see that the service is paused and thus disable the Pause button. But if you 
use the SC.exe command-line utility, nothing is stopping you from sending a 
pause code to a service that is already paused. I would have expected the SCM to 
report failure to the SC.exe utility, but the SCM simply calls the service's 
<I>HandlerEx</I> function, passing it the SERVICE_CONTROL_PAUSE code. Your service 
must be able to handle these erroneous control codes gracefully.</p>

<p>I have seen many services written that don't deal with the possibility of 
the same control code being sent to the service multiple times in a row. For 
example, I know of a service that closed the handle to a named pipe when the service 
was suspended. The service then proceeded to create another kernel object 
that, coincidentally, got the same handle value as the handle of the original named 
pipe. Then the service received another pause control code and called 
<I>CloseHandle</I>,<I> </I>passing the handle value of the old pipe. Since this value happened to be 
the same as another kernel object's handle, the new kernel object was destroyed 
and the rest of the service started failing in strange and mysterious ways! I can't 
tell you how much of a pleasure this mess was to debug.</p>

<p>To fix this multiple stop, pause, or continue control code problem, 
check first to see whether your service is already in the desired state. If it is, don't 
call <I>SetServiceStatus</I>, and don't execute your code to change states&#8212;just return.</p>

<p>Here is some logic I've seen used in services quite frequently. When 
the <I>HandlerEx</I> function receives a SERVICE_CONTROL_PAUSE code, 
<I>HandlerEx </I>calls <I>SetServiceStatus </I>to report SERVICE_PAUSE_PENDING, calls 
<I>SuspendThread </I>to &quot;pause&quot; the service's thread, and then calls 
<I>SetServiceStatus </I>again to report SERVICE_PAUSED. This series of calls does avoid the race 
conditions, because all the work is being done by one thread, but what 
<I>is </I>this code doing? Does suspending the service thread pause the service? Well, I guess I have 
to answer &quot;Yes&quot; to that. However, what does it mean to pause a service? The 
answer depends on the service.</p>

<p>If I am writing a service that processes client requests over the 
network, to me, pause means that I'll stop accepting new requests. But what about 
the request I might be in the middle of processing right now? Maybe I should 
finish it so that my client doesn't indefinitely hang. If my 
<I>HandlerEx </I>function simply calls 
<I>SuspendThread</I>, the service thread might be in the middle of 
who knows what. Maybe the thread's inside a call to 
<I>malloc</I>,<I> </I>trying to allocate some memory. If another service running inside the same process also calls 
<I>malloc</I>, this other service gets suspended too (since access to the heap is serialized). 
This is certainly not what we want happening!</p>

<p>Oh&#8212;and what about this: do you think you should be allowed to stop 
a service that is paused? I do, and apparently Microsoft thinks so too, because 
the Services snap-in allows me to click on the Stop button even when a service 
is paused. But how can I stop a service that is paused because its thread has 
been suspended? Please don't say <I>TerminateThread</I>.</p>

<p>These are some of the issues that make service development challenging.</p>

</BODY>
</HTML>




