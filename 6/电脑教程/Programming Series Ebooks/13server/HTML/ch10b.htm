<HTML>
<HEAD>
<TITLE>Introduction to Access Control</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="ch10a.htm">[Previous]</A> <A HREF="ch10c.htm">[Next]</A><P>

<A NAME="200"><h1>Introduction to Access Control</h1></A>
<p>In general, when people refer to &quot;Windows security,&quot; they mean Windows implementation of <i>access control</i>. Access control can be defined as the assignment and enforcement of who can and cannot perform certain activities on securable objects. Windows applies access control to a number of system objects and provides a mechanism for securing custom objects as well.</p>

<A NAME="201"><h2>Securable Objects</h2></A>
<p>The system enforces security on a number of objects and features provided by the system. Any object the system secures through access control is considered to be a securable object. Table 10-1 shows the types of securable objects in Windows 2000 as of the writing of this book. (The system also provides an enumerated type called SE_OBJECT_TYPE that includes a value for each type.) As you can see, many of the major components in Windows can (and do) take advantage of access control, including custom and private objects.</p>

<p>Windows 2000 allows your service software to subject application-defined objects of any type to Windows access control. The system manages the security of the object, whereas your software associates the security with the object and manages the functionality of the object itself. This security management is called <i>private object security</i> and is discussed in detail later in this chapter.</p>

<p><b>Table 10-1.</b> <i>Securable object types in Windows 2000</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Category  </th>
<th>SE_OBJECT_TYPE <br> Enumerated Type  </th>
<th>Description  </th></tr>
<tr>
<td valign="top">File objects  </td>
<td valign="top">SE_FILE_OBJECT  </td>
<td valign="top">Files or directories on an NTFS file system.  </td></tr>
<tr>
<td valign="top">Service objects  </td>
<td valign="top">SE_SERVICE  </td>
<td valign="top">A service installed on a system or the Service Control Manager (SCM) of a system.  </td></tr>
<tr>
<td valign="top">Printer objects </td>
<td valign="top">SE_PRINTER  </td>
<td valign="top">A printer or a print server.  </td></tr>
<tr>
<td valign="top">Registry keys  </td>
<td valign="top">SE_REGISTRY_KEY  </td>
<td valign="top">A registry key on a Windows 2000 system.  </td></tr>
<tr>
<td valign="top">Share objects  </td>
<td valign="top">SE_LMSHARE  </td>
<td valign="top">A share object indicating a shared directory on a Windows 2000 system.  </td></tr>
<tr>
<td valign="top">Kernel objects  </td>
<td valign="top">SE_KERNEL_OBJECT  </td>
<td valign="top">The system can secure each of the following kernel objects: process objects, thread objects, job objects, semaphore objects, event objects, mutex objects, file-mapping objects, waitable timer objects, access tokens, named pipes, and anonymous pipes.  </td></tr>
<tr>
<td valign="top">Window objects  </td>
<td valign="top">SE_WINDOW_OBJECT  </td>
<td valign="top">Window station and desktop objects (described later in this chapter).  </td></tr>
<tr>
<td valign="top">Directory services objects  </td>
<td valign="top">SE_DS_OBJECT<br>SE_DS_OBJECT_ALL  </td>
<td valign="top">Windows 2000 allows you to apply security to objects in Active Directory or directory services.  </td></tr>
<tr>
<td valign="top">WMI objects  </td>
<td valign="top">SE_WMIGUID_OBJECT  </td>
<td valign="top">Objects exposed to WMI.  </td></tr>
<tr>
<td valign="top">Security provider objects </td>
<td valign="top">SE_PROVIDER_DEFINED_OBJECT  </td>
<td valign="top">Windows 2000 supports replaceable security providers, and these can expose securable objects.  </td></tr>
<tr>
<td valign="top">Private objects   </td>
<td valign="top">  </td>
<td valign="top">Custom objects created by a service or application secured by the system.  </td></tr>
</table></p>


<p>One strength of access control in Windows is that the process of securing an object is largely the same from object type to object type. This common design makes it easier for administrators and programmers to secure different objects.</p>

<p>Each securable object maintains an <i>access control list (ACL)</i> that determines who can and cannot perform certain securable actions on an object. This ACL is the center of Windows 2000 access control, and is associated with a securable object in some combination of the following three ways:</p>


<ul>
<p><li><b>Default assignment</b> Windows 2000 provides a flexible default security mechanism that assigns access control to objects that are not explicitly secured by the creating software. This mechanism is the most common method of assigning security to objects, and it is the one used by all software that ignores security on Windows 2000. Default security is assigned to an object at the time the object is created.</li></p>

<p><li><b>Inheritance</b> System and private objects that exist in a hierarchy of parent-child relationships (such as files and registry keys) might also be subject to security inheritance. Inheritance allows security applied to a parent object to propagate to child objects in the hierarchy. If inherited access control entries (ACEs) are available, they are applied to new objects rather than default security. Inheritance is applied to objects regardless of whether an explicit access control list is also assigned.</li></p>

<p><li><b>Explicit assignment</b> You can explicitly assign access control to a securable object upon creation or after the object has been created. This method of assigning security is much more common in service software than in application and client software.</li></p>
</ul>


<p>Building and assigning ACLs for securable objects is the primary topic of this chapter.</p>

<A NAME="202"><h2>Overview of Access Rights</h2></A>
<p>Although I have explained which objects are securable, I have not yet discussed what it really means for an object to be securable. Windows provides a fine level of control over the actions that can be performed on securable objects. Securable actions are performed only if the requesting trustee has the proper <i>access rights</i> to the object. Table 10-2 describes the three groups of access rights that can apply to an object.</p>

<p><b>Table 10-2.</b> <i>Access rights, defined by the system, that can apply to an object</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Access Type  </th>
<th>Description  </th></tr>
<tr>
<td valign="top">Standard rights  </td>
<td valign="top">Standard rights apply to all object types in the system, and include rights such as the ability to delete an object or to read an object's security. For a list of all the standard rights defined by Windows 2000, see Table 10-13.  </td></tr>
<tr>
<td valign="top">Specific rights  </td>
<td valign="top">Specific rights apply only to a specific type of securable object. For example, a specific right for a file object would be the right to append data or to read data from the file.  </td></tr>
<tr>
<td valign="top">Generic rights  </td>
<td valign="top">Generic rights indicate a collection of standard and specific rights for an object. The system defines four generic rights: read, write, execute, and all. The meaning of each generic right differs from object to object.  </td></tr>
</table></p>


<p>I will discuss each type of right in more detail throughout this chapter. At this time, however, it is important simply to think of a right as something that either allows or disallows a user to do something to an object. For example, a file might allow a user to read a file but disallow that same user to delete the file; this is possible because the system defines different rights for the reading of and deleting of a file.</p>

<p>When a user attempts to perform a securable task on an object, the system performs an <i>access check</i>. The access check searches the rights assigned to the object and compares them to the identity of the user attempting the action. If the system determines that the user has the requested access to the object, the action is performed. If the user does not have proper access, the action is not performed and the software running on the user's behalf receives an &quot;Access Denied&quot; error.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
The system also provides the ability to report on access attempts (successful and unsuccessful) made to securable objects. This is called auditing. Audit events are reported to the event log. Any access right that can be allowed or denied for an object can also be audited for that object. Although auditing is similar to access control, it is a separate and far less commonly used feature. Much of what you learn regarding access control will apply to auditing, so it might be helpful for you to be aware of the feature now. (I will discuss auditing in the section &quot;<A HREF="ch10c.htm#225">Auditing and the SACL</A>&quot; later in this chapter.)</blockquote>
</div>
</p>

<A NAME="203"><h2>The Security Descriptor</h2></A>
<p>As I mentioned earlier, the security for each type of securable object in the system is largely stored and manipulated in the same manner as security for any other securable object. This is because all access control in Windows 2000 is implemented via a data structure called a <i>security descriptor</i>. The security descriptor maintains important security information for an object, such as its owner, and a list of rights associated with users of the system. Each securable object in Windows has a security descriptor. Figure 10-1 shows a representation of a security descriptor, and Table 10-3 describes the components. You'll find that you are most often concerned with the owner and discretionary access control list (DACL) components of the security descriptor.</p>

<p>
<img src="images/F10fj01.JPG" width=246 height=544 border="0">
</p><p>
<!-- caption --><b>Figure 10-1.</b> <i>The security descriptor</i><!-- /caption -->
</p>

<p>As I discussed, manipulating security for objects in Windows is pretty much the same process from one type to another. In a typical scenario, a security descriptor is created by your software and then passed to a system function that creates the object, which assigns the security to the object.</p>

<p><b>Table 10-3.</b> <i>Components of a security descriptor</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Component  </th>
<th>Description  </th></tr>
<tr>
<td valign="top">Revision  </td>
<td valign="top">A value indicating the revision level of the security descriptor structure.  </td></tr>
<tr>
<td valign="top">Control  </td>
<td valign="top">A set of flags indicating the meaning of the contents of the security descriptor.  </td></tr>
<tr>
<td valign="top">Owner  </td>
<td valign="top">The security identifier (SID) of the owner of the object. The owner of an object has special rights&#8212;the owner can always read and modify the security for the object regardless of whether he has explicitly assigned rights to do so as described in the DACL. All securable objects have an owner. (For a discussion on SIDs, see <A HREF="ch09a.htm">Chapter 9</A>.)  </td></tr>
<tr>
<td valign="top">Group  </td>
<td valign="top">The SID of the primary group of the object. Windows 2000 does not utilize the primary group in access control. The information is maintained so that Microsoft Windows NT can be used as a file-server platform for operating systems other than Windows.  </td></tr>
<tr>
<td valign="top">DACL  </td>
<td valign="top">The discretionary access control list (DACL) is an access control list that describes all the access rights for an object. This list defines who can and cannot perform securable actions on an object. If a DACL is not present, everyone has all rights to the object. If a DACL is present but empty, no one but the owner has rights to the object.  </td></tr>
<tr>
<td valign="top">SACL  </td>
<td valign="top">The system access control list (SACL) is a list of access rights associated with users for the purpose of auditing. The SACL does not affect access to an object, but it does cause access to an object to be reported to the event log. See the section &quot;<A HREF="ch10c.htm#225">Auditing and the SACL</A>&quot; later in this chapter for more information.  </td></tr>
</table></p>

<p>You can also retrieve a copy of the security descriptor of an existing object, use system functions to read or modify the security descriptor, and then use a system function to set the security descriptor of the original object.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
It might seem less efficient to use system functions to modify the security descriptor once you have retrieved a copy of it from the object. You might ask yourself why you would not access the data directly with your software&#8212;after all, you do have a copy of the data structure in your process's memory. Although you could access the data this way, it is important not to because the security descriptor is intended to be accessed as an &quot;opaque&quot; structure so that your code will function properly in future versions of Windows.</blockquote>
</div>
</p>

<A NAME="204"><h3>ACLs, ACEs, and the DACL</h3></A>
<p>An ACL is little more than a sequential list of structures of variable lengths called <i>access control entries,</i> or <i>ACEs</i>. Each ACE indicates an access right and the SID of a trustee to which the right is associated for the object.</p>

<p>The DACL and the SACL are ACLs. The DACL is used for access control of an object; its ACEs indicate who is allowed or disallowed access to the object. The SACL is used for access auditing. The structure for the DACL and the SACL are the same, and the code to manipulate them is implemented similarly. I will discuss the SACL later in this chapter in the section &quot;<A HREF="ch10c.htm#225">Auditing and the SACL</A>,&quot; but much of our discussion here regarding the DACL applies to the SACL.</p>

<p>When an application attempts to access a secured object, the system scans the DACL of the object looking for ACEs, which indicate either the user trustee account under which the application is running or a group trustee account of which the user is a member. If a matching ACE is found, the system checks to see if the ACE grants or denies the right to perform the access requested by the application. The access check is discussed in more detail shortly, but first let's look at the six types of ACE. Table 10-4 describes them. The access-allowed ACE and the access-denied ACE are by far the most common.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Object-type ACEs are not used with any securable objects in the system except the directory services objects. However, you can use object-type ACEs with your own private objects. I will focus mostly on the regular ACE types, but I will discuss object-type ACEs briefly throughout this chapter.</blockquote>
</div>
</p>

<p><b>Table 10-4.</b> <i>ACE types in Windows 2000</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>ACE Type<br> (value used by the system)  </th>
<th>Description  </th></tr>
<tr>
<td valign="top">Access allowed <br> (ACCESS_ALLOWED_ACE_TYPE)</td>
<td valign="top">Defines a set of access rights allowed to  a specified trustee account  </td></tr>
<tr>
<td valign="top">Access denied <br>(ACCESS_DENIED_ACE_TYPE) </td>
<td valign="top">Defines a set of access rights denied to  a specified trustee account  </td></tr>
<tr>
<td valign="top">System audit <br>(SYSTEM_AUDIT_ACE_TYPE) </td>
<td valign="top">Defines a securable action that will  cause an audit report if performed by the specified trustee account  </td></tr>
<tr>
<td valign="top">Access-allowed object <br> (ACCESS_ALLOWED_OBJECT_ACE_TYPE) </td>
<td valign="top">Defines a single access right that is  allowed for a specified trustee account for an object or an object's subobject or property (typically used with directory services objects)  </td></tr>
<tr>
<td valign="top">Access-denied object <br>(ACCESS_DENIED_OBJECT_ACE_TYPE) </td>
<td valign="top">Defines a single access right that is  denied for a specified trustee account for an object or an object's subobject or property (typically used with directory services objects)  </td></tr>
<tr>
<td valign="top">System audit object <br>(SYSTEM_AUDIT_OBJECT_ACE_TYPE) </td>
<td valign="top">Defines a single access right that will  cause an audit report if performed by a specified trustee account for an object or an object's subobject or property (typically used with directory services objects)  </td></tr>
</table></p>

<p>Standard access-allowed ACEs and access-denied ACEs are pretty simple. Table 10-5 shows the contents of a standard ACE.</p>

<p><b>Table 10-5.</b> <i>Contents of a standard (nonobject) ACE</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>ACE<br> Component  </th>
<th>Description  </th></tr>
<tr>
<td valign="top">ACE type  </td>
<td valign="top">A numerical value indicating the ACE type. (Table 10-4 shows ACE types in Windows 2000.)  </td></tr>
<tr>
<td valign="top">ACE flags  </td>
<td valign="top">Indicate inheritance rules for ACEs as well as auditing rules for ACEs in a SACL. (For a list of the available inheritance flags, see Table 10-11.)  </td></tr>
<tr>
<td valign="top">Access mask  </td>
<td valign="top">A 32-bit value indicating the access rights described by the ACE.  </td></tr>
<tr>
<td valign="top">Trustee's SID   </td>
<td valign="top">Indicates the trustee user, group, or computer account with which the access rights of the ACE are associated.  </td></tr>
</table></p>


<p>Earlier in the chapter you learned about the three types of access rights defined by the system: standard, specific, and generic. The access mask portion of an ACE is a 32-bit value in which each possible access right for a given object is mapped to a bit.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
A single ACE can be used to indicate multiple access rights for a given trustee, because each access right maps to a single bit in the ACE's access map.</blockquote>
</div>
</p>

<p>The access mask is divided into sections for each of the three types of access rights supported by Windows. Figure 10-2 shows the bits and their purposes.</p>

<p>
<A HREF="javascript:fullSize('F10fj02x.htm')"> <img src="images/F10fj02.JPG" width=404 height=125 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 10-2.</b> <i>Access mask format</i><!-- /caption -->
</p>

<p>ACEs for system and private objects that exist in a hierarchy of parent/child relationships can indicate inheritance rules. I will cover inheritance in more detail when we begin our discussion on programmatically manipulating ACLs; however, it is useful to know now what types of inheritance are allowed. The following list explains the possibilities:</p>


<ul>
<p><li>A parent object contains an ACE that does not affect the parent but does affect child objects. Conversely, it is possible to have an ACE that affects both the parent object and the child objects.</li></p>

<p><li>A parent has an ACE that affects child objects but does not continue to inherit to grandchild objects, great-grandchild objects, and so on. You can also indicate that an ACE should inherit indefinitely.</li></p>

<p><li>An ACE that inherits to a child (or grandchild) object that is also a container can affect the container object, or it can be set to affect only non-container child objects.</li></p>

<p><li>An ACE can be defined to inherit only to child objects that are also containers. Or it can be defined to inherit to any child object.</li></p>
</ul>

 

<p>Each of these decisions can be made for an ACE irrespective of the other inheritance properties of the ACE, so as you can see, an ACE can be made inheritable in a number of different ways.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
It is also possible to create an object whose security descriptor does not allow ACEs to inherit from parents. Such a descriptor is called a <i>protected security descriptor</i>. It stops inheritance to the object as well as to children of the object. It does not, however, affect the security descriptor of the parent object or any of the other children of the parent. 

<p>The system keeps track of which ACEs are inherited and which are explicitly set to an object. This way, if a security descriptor is set protected after the object is created, the system knows which ACEs to remove from the DACL and SACL. ACEs that are explicitly set to an object take precedence over ACEs that are inherited.</p>
</blockquote>
</div>
</p>

<A NAME="205"><h3>Access Checks</h3></A>
<p>You now have a good idea of how the security for a securable object is maintained. We will soon be ready to begin our discussion of the security API, but first it is important that you understand access checks.</p>

<p>When you log on to a system running Windows 2000, you enter your username and password. The system looks up your user account and the group trustee accounts of which you are a member, and stores each trustee account's SID in an internal structure called a <i>token</i>. The system also stores a list of privileges that are assigned to your trustee and group trustee accounts. You'll learn more about tokens in <A HREF="ch11a.htm">Chapter 11</A>, but for now you should think of the token as the structure that stores your identity and privileges.</p>

<p>After the system builds a token for you and launches the shell process, it associates your token with the shell. From this point forward, any process that the shell process launches automatically inherits a copy of your token. This is how the system maintains a sense of your identity.</p>

<p>Processes that are associated with your token are said to be running in your <i>user context</i> or <i>security context</i>. When a process running in your security context attempts to perform a securable action on a securable object, the system first performs an access check to determine whether you or one of your groups has sufficient rights to perform the task. Figure 10-3 shows the relationship of the entities involved in an access check.</p>

<p>
<A HREF="javascript:fullSize('F10fj03x.htm')"> <img src="images/F10fj03.JPG" width=404 height=354 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 10-3.</b> <i>A process accessing a securable object</i><!-- /caption -->
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
It is also possible for a thread in a process to run in a user context different from the process. This is called <i>impersonation</i> and is covered in detail in the <a href="ch11a.htm">next chapter</a>.</blockquote>
</div>
</p>

<p>Here are the steps the system takes when it performs an access check:</p>

<ol>
<p><li>The system maps requested generic rights to standard and specific rights.</li></p>

<p><li>The system checks your token for relevant privileges in this access check. Most access checks do not take privileges into consideration. However, if you hold the SeTakeOwnershipPrivilege privilege, the system always passes an access check for the WRITE_OWNER standard right. (See Table 10-13.) Also, if the ACCESS_SYSTEM_SECURITY standard right is required, you must hold the SeAuditPrivilege privilege. (See <A HREF="ch09a.htm">Chapter 9</A> for a discussion of privileges.)</li></p>

<p><li>The system compares your SID and the group SIDs in your token with the owner SID of the object. If you are the owner of the object and you request the READ_CONTROL or WRITE_DAC standard access right, the system grants access regardless of the contents of the DACL.</li></p>

<p><li>The system checks for existence of a DACL in the security descriptor. If one is not present, access is granted.</li></p>

<p><li>The system checks the SID in the first ACE of the DACL against the SIDs in your token. If a match is found, the access mask of the ACE is checked against the access rights required by this access check.</li></p>

<p><li>If the ACE is an access-denied ACE, and the access mask matches any of the access rights required, the access check fails immediately.</li></p>

<p><li>If the ACE is an access-allowed ACE, and it fulfills any or all of the access rights required for the access check, the system makes note of the success.</li></p>

<p><li>After all the rights required for the access check are met, the system passes the access check.</li></p>

<p><li>If the last ACE in the DACL is checked, and not all of the rights required by the check are found, the system fails the access check.</li></p>
</ol>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
You can create a token that is restricted to the access rights of additional, arbitrarily selected trustee accounts. This is called a <i>restricted token</i>. If your process or thread is associated with a restricted token, the rules of an access check change. This topic is covered in detail in <A HREF="ch11a.htm">Chapter 11</A>.</blockquote>
</div>
</p>

<p>The most important steps in this process are steps 4, 6, 8, and 9. In step 4, if the system finds that the object's security descriptor does not include a DACL, the access check succeeds for everyone. In step 6, an access check fails if an access-denied ACE matches your user or group SIDs and any of the access rights for the access check. It fails immediately regardless of whether a later ACE in the DACL would have passed the access check. Step 8 passes the access check after all of the requested rights are found, regardless of whether an access-denied ACE later in the DACL would have failed the access check. And finally, in step 9, not enough ACEs to pass a check indicates implicit failure.</p>

<p>As you can see, in an access check, the order of ACEs in a DACL is very important. You should always place access-denied ACEs before access-allowed ACEs in a DACL. The Windows 2000 user interface enforces ACE ordering; however, in your own software, you can place ACEs in any order. If you place an access-denied ACE after an access-allowed ACE in your object's DACL, you should have a good reason!</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
An access-denied ACE at the end of a DACL is a wasted ACE. If the ACE denies access that was already allowed, the access check would never even see the denied ACE at the end. And if the ACE denies access that was not explicitly allowed, it was not necessary to deny the access in the first place&#8212;access is implicitly denied unless it is explicitly allowed.</blockquote>
</div>
</p>

<p>Microsoft has published a preferred order of ACEs in a DACL. It is referred to as a &quot;preferred&quot; order because it is not completely enforced. Table 10-6 shows the preferred ordering of ACEs in a DACL.</p>

<p><b>Table 10-6.</b> <i>Preferred ordering of ACEs in a DACL</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>ACE Type  </th>
<th>Group  </th></tr>
<tr>
<td valign="top">Access-denied ACEs  <p>Access-denied object ACEs that apply to subobjects or properties of the object</p> <p>Access-allowed ACEs</p> <p>Access-allowed object ACEs that apply to subobjects or properties of the object</p></td>
<td valign="top">Explicitly assigned (noninherited) ACEs  </td></tr>
<tr>
<td valign="top">Access-denied ACEs <p>Access-denied object ACEs that apply to subobjects or properties of the object</p> <p>Access-allowed ACEs</p> <p>Access-allowed object ACEs that apply to subobjects or properties of the object</p></td>
<td valign="top">Inherited ACEs  </td></tr>
</table></p>


<p>The ordering rule in Table 10-6 might look complex, but remember that object ACEs are not used for any securable object in the system except directory services objects (objects in Active Directory). Ignoring object ACEs will simplify the order of ACEs dramatically.</p>

<A NAME="206"><h2>Understanding Custom or Private Object Security</h2></A>
<p>I have discussed system securable objects, the structure of the security descriptor that secures the object, and how the system uses the DACL to check security against a request made by software. However, I have not yet explained how your software can create secure objects that use the Windows security model. Windows refers to this ability as <i>securing private objects</i>.</p>

<p>Private object security is a very powerful and flexible feature included in Windows. Later in this chapter I discuss the security API used with private objects. At this point, I would like to explain how private object security ties in to the existing security model in Windows.</p>

<p>Everything you have learned about security descriptors, ACLs, DACLs, and ACEs also applies to private objects, except that your software, rather than the system, must decide which of the standard rights (listed in Table 10-13) apply to your objects. Additionally, you must define specific rights for your objects, and map the four generic rights to appropriate combinations of standard and specific rights.</p>

<p>Your software performs the access check by calling a system function. Typically, your software is a service that passes the token of a connected client to the system along with a security descriptor. The system then indicates whether the required access rights exist for the client. Your service is responsible for performing or refusing to perform the requested action, based on the results of the access check.</p>

<p>The system creates and destroys security descriptors in memory for your private objects. You must associate the security descriptors with the data that they protect. Your service is also responsible for storing the security with the data in persistent storage when your service ends (if the objects persist, that is).</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Private object security does not automatically secure the data of the objects defined by your software&#8212;if your objects are stored in files, you must still secure the files. Private object security does, however, provide a mechanism for allowing you to control your data at a fine level of granularity, without being limited to file security or the security of some other storage mechanism in Windows.</blockquote>
</div>
</p>

<A NAME="207"><h2>Exploring Security in Windows</h2></A>
<p>To become a successful security developer, it is important to understand and also be comfortable with security in Windows 2000. Spending some time modifying the security of system objects via the user interface will greatly increase your ability to effectively design software that incorporates security.</p>

<p>The following sections walk you through the tools supplied with Windows to help you become familiar with security. In Windows, registry keys are securable and files and directories (on NTFS partitions only) are securable. The file system is probably the most effective way to become familiar with security, because its inheritance model includes both container objects (directories) and non-container objects (files). If you do not have an NTFS partition with which to meddle, the registry will also do just fine.</p>

<A NAME="208"><h3>Access Control for the Registry</h3></A>
<p>These steps describe how security options can be specified in the registry:</p>

<ol>
<p><li>Log on to your system as Administrator or as a member of the Administrators group.</li></p>

<p><li>Run the RegEdt32.exe utility. You will see a screen similar to Figure 10-4.</li></p>

<p>
<A HREF="javascript:fullSize('F10FJ04x.htm')"> <img src="images/F10FJ04.JPG" width=404 height=303 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 10-4.</b> <i>The registry editor (RegEdt32.exe)</i><!-- /caption -->
</p>

<p><li>Select the window titled HKEY_LOCAL_MACHINE On Local Machine. This window shows the HKEY_LOCAL_MACHINE hive on your system.</li></p>

<p><li>Open the Software key and select Add Key from the Edit menu. Add a new key named <i>ANewKey</i>. (I am calling my new key ANewKey so that it shows up near the top of the list of keys under Software.)</li></p>

<p><li>Click on the new key, and select Permissions from the Security menu. A Permissions dialog box appears.</li></p>

<p><li>Uncheck the Allow Inheritable Permissions From Parent To Propagate To This Object check box. This causes the security descriptor for your new key to be protected, which disallows inheritable permissions to propagate from parent keys. The system will ask you whether you wish to copy or remove the current inherited permissions, as shown in Figure 10-5.</li></p>

<p>
<A HREF="javascript:fullSize('F10FJ05x.htm')"> <img src="images/F10FJ05.JPG" width=404 height=299 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 10-5.</b> <i>Setting inheritable permissions for ANewKey</i><!-- /caption -->
</p>

<p><li>Click the Remove button to remove the access list.</li></p>

<p><li>Right now your new key has an empty DACL. If you were to click OK in the dialog box, nobody but you (because you are the key's owner) could do anything with the key. And the only things <i>you</i> could do would be read or write the security of the object.</li></p>

<p><li>Click the Add button to display the Select Users, Computers, Or Groups dialog box. Select Everyone from the list box, click the Add button, and then OK. This adds an ACE for everyone to your key's DACL.</li></p>

<p><li>Click the check box under Allow to indicate Full Control. Now click OK. The registry editor creates a new security descriptor for your key that allows everyone full control of the key.</li></p>

<p><li>Add two new subkeys to ANewKey by selecting it and choosing Add Key from the Edit menu. (I named my new keys <i>First</i> and <i>Second</i>, but you can name them anything you like.)</li></p>

<p><li>Log off of your machine, log on as the built-in Guest account (you might need to enable the account), and then rerun RegEdt32.exe. You can use any trustee account other than your own for this portion. (An alternative to logging off is to use the RunAs utility to launch RegEdt32.exe as the Guest account. For example: RunAs.exe /env /user:mymachine\Guest RegEdt32.exe.)</li></p>

<p><li>Find your new key under HKEY_LOCAL_MACHINE\Software and open it. You should see your new subkeys. Check the permissions of both subkeys by clicking on them and then selecting the Permissions option from the Security menu. Notice that both keys have inherited the simple Everyone\Full Control security from their parent key. Do not uncheck the Allow Inheritable Permissions check box this time.</li></p>

<p><li>By virtue of being a member of the built-in Everyone group, the otherwise poorly endowed Guest account can do whatever it wants to these keys, including change their permissions. So take advantage of this power and open the permissions for one of your subkeys.</li></p>

<p><li>Check the box under Deny for Full Control, which denies full control to the Everyone group. Don't click OK just yet.</li></p>

<p><li>What you are doing is adding an access-denied ACE to the DACL for the subkey. Notice, however, that the check boxes under Allow are still checked. This is because the inherited access-allowed ACE allowing Full Control to Everyone is still present in the DACL as well. However, your explicitly applied ACE will take precedence over any inherited ACEs. Click the OK button, and click Yes in the Security dialog box asking if you want to continue.</li></p>

<p><li>Now you have actually denied everyone (including the account that you logged in as) any access to this key. No one can create subkeys or values under this key. And only the owner (which should be your regular logon account) can modify the security to allow permissions.</li></p>

<p><li>Before logging off and logging back on with your normal account, try editing the permissions of the registry key that was just modified. The system should tell you that you do not have sufficient access rights to view or edit the security for the key. (Then the system will show you an empty security descriptor, just in case you do have the right to write access to the key, which you do not.)</li></p>
</ol>

<A NAME="209"><h3>Access Control for an NTFS Partition</h3></A>
<p>Here are some examples that illustrate how permissions work for files on an NTFS partition:</p>

<ol>
<p><li>To view permissions for files, right-click on a file or folder in Windows Explorer, and select Properties from the context menu to display the Properties dialog box. Select the Security tab to display permissions for the file. File permissions are set in much the same way that they are for registry keys in RegEdt32.</li></p>

<p><li>In the Properties dialog box, click the Advanced button to display the Access Control Settings dialog box as shown in Figure 10-6. Add access rights that don't inherit, or add access rights that inherit only to non-containers (or files).</li></p>

<p>
<A HREF="javascript:fullSize('F10FJ06x.htm')"> <img src="images/F10FJ06.JPG" width=404 height=345 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 10-6.</b> <i>Setting permissions for a file on an NTFS partition</i><!-- /caption -->
</p>

<p><li>In the Properties dialog box, click the Advanced button. If you or a group that you are a member of is the owner, you should be able to set the owner to yourself or one of your groups. Additionally, if your account has the SeTakeOwnershipPrivilege privilege, you should be able to set the owner of any object in the system. To see the list of owners, click the Owner tab.</li></p>

<p><li>In Explorer, create several levels of directories, of which the top level is a new directory that you created with a protected security descriptor, and add enough access rights to continue creating directories. Then change the security of a directory in the middle of the hierarchy by adding more access-allowed or access-denied ACEs. Now look at a directory or file at the bottom of your hierarchy, and notice how it has inherited permissions from multiple parents. Try removing some of the permissions from a parent in the hierarchy and notice how it affects the child or grandchild. You can also do this type of testing with a hierarchy of registry keys.</li></p>
</ol>

<p>I strongly suggest you spend more time experimenting with permissions of registry keys or files (if you have an NTFS partition). Exploring will work wonders for your abilities as a security programmer.</p>

<A NAME="210"><h2>Review of Access Control Terminology</h2></A>
<p>If you are new to security programming in Windows, you have just been bombarded with new terms and ideas. So now is a good time for us to rehash what we have covered before we dive into the depths of the security API.</p>


<ul>
<p><li><b>Access check</b> A check performed by the system (or your software for private objects) that determines whether the user identified by a token has a requested set of access rights allowed by an object's DACL.</li></p>

<p><li><b>Access control</b> System-provided feature for managing and enforcing security access to objects.</li></p>

<p><li><b>Access mask</b> The 32-bit value within an ACE that contains a bit for each access right for an object, including standard, specific, and generic rights.</li></p>

<p><li><b>Access right</b> A system-defined or software-defined value that indicates a right required to perform some action on or with a securable object.</li></p>

<p><li><b>ACE</b> Stands for access control entry. The ACE contains a SID identifying a trustee of the system and an access mask indicating access rights. An ACE can allow or deny access to an object.</li></p>

<p><li><b>ACL</b> Stands for access control list. The ACL contains ACEs that define the security or security reporting of an object.</li></p>

<p><li><b>DACL</b> Stands for discretionary access control list. The DACL contains ACEs that explicitly allow and deny access to an object.</li></p>

<p><li><b>Generic access rights</b> The right to generically &quot;read,&quot; &quot;write,&quot; or &quot;execute&quot; an object, as well as the generic &quot;all&quot; access right. Each generic right maps to a set of standard and specific rights; these mappings differ for each type of object.</li></p>

<p><li><b>Protected security descriptor</b> A security descriptor with a control flag that indicates that it and its children should not receive inheritable ACEs from its parent object.</li></p>

<p><li><b>SACL</b> Stands for system access control list. The SACL contains ACEs that specify events to be reported to the event log for associated users.</li></p>

<p><li><b>Securable object</b> Any object, private or system, that is secured with the Windows access control model.</li></p>

<p><li><b>Security descriptor</b> A structure associated with every securable object in the system. A security descriptor includes a SID indicating owner and primary group, as well as optional DACL and SACL.</li></p>

<p><li><b>SID</b> Stands for security identifier, which identifies a trustee account to the system. SIDs are discussed in detail in <A HREF="ch09a.htm">Chapter 9</A>.</li></p>

<p><li><b>Specific access rights</b> System-defined or software-defined access rights that apply only to a specific type of system or private securable object.</li></p>

<p><li><b>Standard access rights</b> System-defined access rights of which a subset will be applicable to each securable object type in the system.</li></p>

<p><li><b>Token</b> A structure associated with a process or a thread that contains a SID identifying a user and SIDs identifying the user's groups, as well as the privileges held by the user. Tokens are discussed in detail in <A HREF="ch11a.htm">Chapter 11</A>.</li></p>

<p><li><b>User context</b> If software is running under your token, it is said to be running in your user context.</li></p>
</ul>

 

</BODY>
</HTML>




