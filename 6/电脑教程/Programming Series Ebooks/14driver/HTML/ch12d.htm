<HTML>
<HEAD>
<TITLE>Launching an Application</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch12c.htm">[Previous]</A> <A HREF="ch12e.htm">[Next]</a>
</p>

<A NAME="421"><H1>Launching an Application</H1></A>

<p>You can enhance the end user experience of your hardware by providing an application that
starts whenever one of your devices exists. Microsoft provides a special-purpose mechanism for
still-image cameras but hasn't provided a general-purpose mechanism that other devices can
use. I'll describe just such a mechanism, named AutoLaunch, in this section.</p>

<A NAME="422"><H2>The AutoLaunch Service</H2></A>

<p>Windows 98 and Windows 2000 both provide for notifications to applications when hardware
events occur. Microsoft Windows 95 introduced the WM_DEVICECHANGE message. As originally
conceived for Windows 95, the system broadcasts this message in user mode to all top-level
windows for each of several possible device events.</p>

<p>Building on WM_DEVICECHANGE, Windows 2000 generates notifications to interested service
applications whenever a device driver enables or disables a registered device interface. I
wrote an AutoLaunch service to take advantage of these notifications. The service subscribes
for notifications about a special interface GUID by calling a new user-mode API named <b>
RegisterDeviceNotification</b>:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#include &lt;dbt.h&gt;

DEV_BROADCAST_DEVICEINTERFACE filter = {0};
filter.dbcc_size = sizeof(filter);
filter.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;
filter.dbcc_classguid = GUID_AUTOLAUNCH_NOTIFY;

HDEVNOTIFY hNotification = RegisterDeviceNotification(hService,
  (PVOID) &amp;filter, DEVICE_NOTIFY_SERVICE_HANDLE);</pre>
</td></tr>
</table>
</p>

<p>To receive the interface notifications, the service must initialize by calling <b>
RegisterServiceCtrlHandlerEx</b> instead of <b>RegisterServiceCtrlHandler</b> in its <b>
ServiceMain</b> function:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>hService = RegisterServiceCtrlHandlerEx(<i>&lt;svcname&gt;</i>,
  HandlerEx, <i>&lt;context&gt;</i>);</pre>
</td></tr>
</table>
</p>

<p>When you call RegisterServiceCtrlHandlerEx, you specify a <b>HandlerEx</b> event handler
function that receives three more parameters than a standard service <b>Handler</b> 
function:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>DWORD _ _stdcall HandlerEx(DWORD ctlcode, DWORD evtype,
  PVOID evdata, PVOID context)
  {
  }</pre>
</td></tr>
</table>
</p>

<p>In the situation we're concerned with here, <b>ctlcode</b> will equal
SERVICE_CONTROL_DEVICEEVENT, <b>evtype</b> will equal DBT_DEVICEARRIVAL, and <b>evdata</b> will be the address
of a device interface broadcast structure. The <b>context</b> parameter will be whatever value
you specified as the third argument to RegisterServiceCtrlHandlerEx.</p>

<p>The device interface broadcast structure looks like this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>struct _DEV_BROADCAST_DEVICEINTERFACE_W {
  DWORD dbcc_size;
  DWORD dbcc_devicetype;
  DWORD dbcc_reserved;
  GUID dbcc_classguid;
  WCHAR dbcc_name[1];
  };</pre>
</td></tr>
</table>
</p>

<p>The <b>dbcc_devicetype</b> value will be DBT_DEVTYP_DEVICEINTERFACE. The <b>dbcc_classguid</b> will be the 128-bit interface GUID that some device driver enabled or
disabled, and the <b>dbcc_name</b> will be the symbolic link name you can use to open a handle
to the device. This particular structure comes in both ANSI and Unicode versions. The service
notification always uses the Unicode version, even if your service happens to have been built,
as AutoLaunch is, using ANSI.</p>

<A NAME="423"><H2>Triggering AutoLaunch</H2></A>

<p>To trigger a device interface arrival notification to AutoLaunch, a driver simply has to
register and enable an interface by using the AutoLaunch GUID:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>typedef struct _DEVICE_EXTENSION {
  ...
  UNICODE_STRING AutoLaunchInterfaceName;
  } DEVICE_EXTENSION, *PDEVICE_EXTENSION;

NTSTATUS AddDevice(...)
  {
  ...
  IoRegisterDeviceInterface(pdo, &amp;GUID_AUTOLAUNCH_NOTIFY,
    NULL, &amp;pdx-&gt;AutoLaunchInterfaceName);
  ...
  }

NTSTATUS StartDevice(PDEVICE_OBJECT fdo, ...)
  {
  ...
  IoSetDeviceInterfaceState(&amp;pdx-&gt;AutoLaunchInterfaceName, TRUE);
  ...
  }</pre>
</td></tr>
</table>
</p>

<p>I discussed device interfaces in <A HREF="ch02a.htm">Chapter 2</A> as a method of giving a name to a device so that
an application could find the device and open a handle to it. A single device can register as
many interfaces as make sense. In this particular situation, you would register an AutoLaunch
interface <i>in addition to</i> any interfaces that you might support. The only purpose of the
AutoLaunch interface is to generate the notification for which the service is waiting.</p>

<p>When your driver enables its GUID_AUTOLAUNCH_NOTIFY interface, the system sends the AutoLaunch
service a device arrival notification, which the service processes in this function:</p>

<p>
<table cellpadding=5 width="95%"><tr>

<td valign=top>
<pre>






1 <img src="images/arorite2.jpg" width=17 height=10 border=0>


2 <img src="images/arorite2.jpg" width=17 height=10 border=0>
</pre>
</td>
<td>
<pre>DWORD CAutoLaunch::HandleDeviceChange(DWORD evtype,
  _DEV_BROADCAST_HEADER* dbhdr)
  {
  if (!dbhdr 
    || evtype != DBT_DEVICEARRIVAL
    || dbhdr-&gt;dbcd_devicetype != DBT_DEVTYP_DEVICEINTERFACE)
    return 0;
  PDEV_BROADCAST_DEVICEINTERFACE_W p =
    (PDEV_BROADCAST_DEVICEINTERFACE_W) dbhdr;
  CString devname = p-&gt;dbcc_name;
  HDEVINFO info = SetupDiCreateDeviceInfoList(NULL, NULL);
  SP_DEVICE_INTERFACE_DATA ifdata =
    {sizeof(SP_DEVICE_INTERFACE_DATA)};
  SP_DEVINFO_DATA devdata = {sizeof(SP_DEVINFO_DATA)};
  SetupDiOpenDeviceInterface(info, devname, 0, &amp;ifdata);
  SetupDiGetDeviceInterfaceDetail(info, &amp;ifdata, NULL, 0, NULL,
    &amp;devdata);
  OnNewDevice(devname, info, &amp;devdata);
  SetupDiDestroyDeviceInfoList(info);
  return 0;
  }</pre>
</td></tr>
</table>
</p>

<ol>
<p><li> There are other notifications besides the ones we're interested in. Some of
them are queries. Returning 0 is how we indicate success or acquiescence to some query we
don't specifically process. In fact, the real AUTOLAUNCH sample on the disc handles the
DBT_DEVICEREMOVECOMPLETE notification too so that it can keep track of which arrival
notifications it's already processed and avoid duplication during system startup. I left
that detail out here to avoid clutter.</li></p>

<p><li> I built the AutoLaunch sample without UNICODE. This statement therefore converts
the UNICODE linkname in the notification structure to ANSI.</li></p>
</ol>

<p>My <b>OnNewDevice</b> function is going to spawn a new process to perform whatever command
line it finds in the registry. It was most convenient to use the device's <i>hardware
key</i> as a repository for the command line. The code to do this is as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr>
<td valign=top>
<pre>



1 <img src="images/arorite2.jpg" width=17 height=10 border=0>






2 <img src="images/arorite2.jpg" width=17 height=10 border=0>



3 <img src="images/arorite2.jpg" width=17 height=10 border=0>






4 <img src="images/arorite2.jpg" width=17 height=10 border=0>


5 <img src="images/arorite2.jpg" width=17 height=10 border=0>

6 <img src="images/arorite2.jpg" width=17 height=10 border=0>




7 <img src="images/arorite2.jpg" width=17 height=10 border=0>

8 <img src="images/arorite2.jpg" width=17 height=10 border=0>
</pre>
</td>
<td>
<pre>
void CAutoLaunch::OnNewDevice(const CString&amp; devname,
  HDEVINFO info, PSP_DEVINFO_DATA devdata)
  {
  HKEY hkey = SetupDiOpenDevRegKey(info, devdata, DICS_FLAG_GLOBAL,
    0, DIREG_DEV, KEY_READ);

  DWORD junk;
  TCHAR buffer[_MAX_PATH];
  DWORD size = sizeof(buffer);
  CString Command;
  RegQueryValueEx(hkey, &quot;AutoLaunch&quot;, NULL, &amp;junk,
    (LPBYTE) buffer, &amp;size);
  Command = buffer;

  CString FriendlyName;
  SetupDiGetDeviceRegistryProperty(info, devdata,
    SPDRP_FRIENDLYNAME, NULL, (PBYTE) buffer, sizeof(buffer), NULL);
  FriendlyName.Format(_T(&quot;\&quot;%s\&quot;&quot;), buffer);

  RegCloseKey(hkey);

  ExpandEnvironmentStrings(Command, buffer, arraysize(buffer));
  CString name;
  name.Format(_T(&quot;\&quot;%s\&quot;&quot;), (LPCTSTR) devname);
  Command.Format(buffer, (LPCTSTR) name, (LPCTSTR) FriendlyName);

  STARTUPINFO si = {sizeof(STARTUPINFO)};
  si.lpDesktop = &quot;WinSta0\\Default&quot;;
  si.wShowWindow = SW_SHOW;

  PROCESS_INFORMATION pi;
  CreateProcess(NULL, (LPTSTR) (LPCTSTR) Command, NULL, NULL,
    FALSE, 0, NULL, NULL, &amp;si, &amp;pi);
  CloseHandle(pi.hProcess);
  CloseHandle(pi.hThread);
  }</pre>
</td></tr>
</table>
</p>

<ol>
<p><li> This statement opens the <b>Device Parameters</b> subkey of the device's
hardware registry key.</li></p>

<p><li> The INF file put an <b>AutoLaunch</b> value in the registry. We read that value
here.</li></p>

<p><li> Here we fetch the <b>FriendlyName</b> of the device for use as a command line
argument. There might be blanks in the name, so we want to put quotes around it before
submitting the command.</li></p>

<p><li> I wanted to allow the command line template in the registry to include
environment variables surrounded by <b>%</b> characters. This statement expands the environment
strings.</li></p>

<p><li> I also wanted the command line template to use a <b>%s</b> escape to indicate
where the device name and friendly name belong. This statement produces a command line with the
substitution taken care of.</li></p>

<p><li> We're about to call CreateProcess to execute the command. Unless we're
careful, the command will use the same hidden desktop as our own service process, which is not
going to be very useful to the end user! So we create a STARTUPINFO structure that specifies
the interactive session desktop.</li></p>

<p><li> Here's where we actually launch the application whose name we found in the
registry. <b>CreateProcess</b> returns right away; the application lives on until someone
closes it.</li></p>

<p><li> CreateProcess also gives us handles to the process and its initial thread. We
need to close those handles, or else the process and thread will never go away.</li></p>
</ol>

<A NAME="424"><H2>Chickens and Eggs</H2></A>

<p>The process I just described works great in a steady-state situation, where the AutoLaunch
service is already up and running on a computer when a device comes along and tries to launch a
special application. Two other situations need to be dealt with, though.</p>

<p>First, devices that are already plugged in when the system is bootstrapped will manage to
register their GUID_AUTOLAUNCH_NOTIFY interfaces before the service manager starts up the
AutoLaunch service. Yet, you still (presumably) want the AutoLaunch applications to start
too.</p>

<p>AutoLaunch deals with this startup issue by enumerating all instances of the interface when it
first starts:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>VOID CAutoLaunch::EnumerateExistingDevices(const GUID* guid)
  {
  HDEVINFO info = SetupDiGetClassDevs(guid, NULL, NULL,
    DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
  SP_INTERFACE_DEVICE_DATA ifdata;
  ifdata.cbSize = sizeof(ifdata);
  DWORD devindex;
  for (devindex = 0;
    SetupDiEnumDeviceInterfaces(info, NULL, guid, devindex, &amp;ifdata);
    ++devindex)
    {
    DWORD needed;
    SetupDiGetDeviceInterfaceDetail(info, &amp;ifdata, NULL, 0,
      &amp;needed, NULL);
    PSP_INTERFACE_DEVICE_DETAIL_DATA detail =
      (PSP_INTERFACE_DEVICE_DETAIL_DATA) malloc(needed);
    detail-&gt;cbSize = sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);
    SP_DEVINFO_DATA devdata = {sizeof(SP_DEVINFO_DATA)};
<b>    SetupDiGetDeviceInterfaceDetail(info, &amp;ifdata, detail,
      needed, NULL, &amp;devdata);</b> 
    <b>CString devname = detail-&gt;DevicePath;</b> 
    free((PVOID) detail);
    OnNewDevice(devname, guid);
    }
  }</pre>
</td></tr>
</table>
</p>

<p>The only interesting lines of code in this whole function are the ones in bold face, where
we obtain the necessary SP_DEVINFO_DATA structure and symbolic link name. We then call <b>
OnNewDevice</b> (the function you've already seen) to deal with this pre-existing
device.</p>

<A NAME="425"><H2>Getting the Service Running</H2></A>

<p>The second startup situation you have to deal with is when your device is being installed
for the first time onto a machine that's never seen the AutoLaunch service before. Your INF
file needs to define the AutoLaunch service and copy the service binary file onto the end user
computer. It can add a registry entry to the so-called <b>RunOnce</b> key to trigger the
service. For example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>[DestinationDirs]
AutoLaunchCopyFiles=10
<i>[etc.]</i>

[DriverInstall.NT]
CopyFiles=DriverCopyFiles,AutoLaunchCopyFiles
AddReg=DriverAddReg.NT

[DriverAddReg.NT]
HKLM,%RUNONCEKEYNAME%,AutoLaunchStart,,\
  &quot;rundll32 StartService,StartService AutoLaunch&quot;

[DriverInstall.NT.Services]
AddService=AutoLaunch,,AutoLaunchService
<i>[etc.]</i>

[AutoLaunchCopyFiles]
AutoLaunch.exe,,,0x60
StartService.exe,,,0x60

[AutoLaunchService]
ServiceType=16
StartType=2
DisplayName=&quot;AutoLaunch Service&quot;
ErrorControl=1
ServiceBinary=%10%\AutoLaunch.exe

[Strings]
RUNONCEKEYNAME=&quot;Software\Microsoft\Windows\CurrentVersion\RunOnce&quot;</pre>
</td></tr>
</table>
</p>

<p>Refer to the DEVICE.INF in the SYS subdirectory of the AUTOLAUNCH sample for the full
picture.</p>

<p>After the installation of your device finishes, the system executes any commands that are
within the RunOnce registry key. The command we put there starts the AutoLaunch service if
it's not already running. Note that STARTSERVICE.DLL is a tiny DLL I wrote that starts a
service without displaying any user interface or popping up a dialog box. You'll want to
use RUNDLL32 as the command verb in the RunOnce value so that it will work correctly with a
remote install of your driver package.</p>

<p>
<div class="note"><blockquote><b>NOTE</b> <hr>
Microsoft Knowledge Base article Q173039 suggests that the immediate-processing
behavior of entries in the RunOnce key is essentially a side effect of a call to RUNDLL32. One
of the Microsoft developers responsible for the device installer has assured me that the
RunOnce values are always processed at the conclusion of installing a new device, regardless of
what this article says.</blockquote></div>
</p>

</BODY>
</HTML>





