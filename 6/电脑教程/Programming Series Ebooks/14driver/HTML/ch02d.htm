<HTML>
<HEAD>
<TITLE>The AddDevice Routine</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch02c.htm">[Previous]</A> <A HREF="ch02e.htm">[Next]</a>
</p>

<A NAME="44"><H1>The AddDevice Routine</H1></A>

<p>In the preceding main section, I showed how you initialize a WDM driver when it's first
loaded. In general, though, a driver might be called upon to manage more than one actual
device. In the WDM architecture, a driver has a special <b>AddDevice</b> function that the PnP
Manager can call for each such device. The function has the following prototype:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
NTSTATUS AddDevice(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT pdo)
  {
  }
</pre>
</td></tr>
</table>
</p>

<p>The <b>DriverObject</b> argument points to the same driver object that you initialized in
your DriverEntry routine. The <b>pdo</b> argument is the address of the physical device object
at the bottom of the device stack, even if there are already filter drivers below.</p>

<p>The basic responsibility of AddDevice in a function driver is to create a device object and
link it into the stack rooted in this PDO. The steps involved are as follows:</p>

<ol>
<p><li> Call IoCreateDevice to create a device object and an instance of your own device
extension object.</li></p>

<p><li> Register one or more device interfaces so that applications know about the
existence of your device. Alternatively, give the device object a name and then create a
symbolic link.</li></p>

<p><li> Next initialize your device extension and the Flags member of the device
object.</li></p>

<p><li> Call IoAttachDeviceToDeviceStack to put your new device object into the
stack.</li></p>
</ol>

<p>Now I'll explain these steps in more detail.</p>

<A NAME="45"><H2>Creating a Device Object</H2></A>

<p>You create a device object by calling <b>IoCreateDevice</b>. For example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
PDEVICE_OBJECT fdo;
NTSTATUS status = IoCreateDevice(DriverObject, 
  sizeof(DEVICE_EXTENSION), NULL,
  FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;fdo);
</pre>
</td></tr>
</table>
</p>

<p>The first argument (<b>DriverObject</b>) is the same value supplied to AddDevice as the
first argument. This argument establishes the connection between your driver and the new device
object, thereby allowing the I/O Manager to send you IRPs intended for the device. The second
argument is the size of your device extension structure. As I discussed earlier in this
chapter, the I/O Manager allocates this much additional memory and sets the DeviceExtension
pointer in the device object to point to it.</p>

<p>The third argument, which is <b>NULL</b> in this example, can be the address of a
UNICODE_STRING providing a name for the device object. Deciding whether to name your device
object and which name to give it requires some thought, and I'll describe these
surprisingly complex considerations a bit further on in the section, &quot;<A HREF="ch02d.htm#48">Should I Name My Device Object?</A>&quot;</p>

<p>The fourth argument (<b>FILE_DEVICE_UNKNOWN</b>) is one of the device types listed in Table
2-4. Whatever value you specify here can be overridden by an entry in the device's hardware
key or class key. If both keys have an override, the hardware key has precedence. For devices
that fit into one of the established categories, specify the right value in one of these places
because some details about the interaction between your driver and the surrounding system
depend on it. In addition, the default security settings for your device object depend on this
device type.</p>

<p>The fifth argument (<b>0</b>) provides the Characteristics flag for the device object. (See
Table 2-3.) These flags are relevant mostly for mass storage devices. The
undocumented flag bit FILE_AUTOGENERATED_DEVICE_NAME is for internal use only&#8212;the DDK
documenters didn't simply forget to mention it. Whatever value you specify here can be
overridden by an entry in the device's hardware key or class key. If both keys have an
override, the hardware key has precedence.</p>

<p>The sixth argument to IoCreateDevice (<b>FALSE</b> in my example) indicates whether the
device is <i>exclusive</i>. The I/O Manager allows only one handle to be opened by normal means
to an exclusive device. Whatever value you specify here can be overridden by an entry in the
device's hardware key or class key. If both keys have an override, the hardware key has
precedence.</p>

<p>
<div class="note"><blockquote><b>NOTE</b> <hr>
The exclusivity attribute matters only for whatever named device object is the
target of an open request. If you follow Microsoft's recommended guidelines for WDM
drivers, you won't give your device object a name. Open requests will then target the PDO,
but the PDO will <i>not</i> usually be marked exclusive because the bus driver usually has no
way of knowing whether you need your device to be exclusive. The only time the PDO will be
marked exclusive is when there's an <b>Exclusive</b> override in the device's hardware
key or class key's Properties subkey. You're best advised, therefore, to avoid relying
on the exclusive attribute altogether. Instead, make your IRP_MJ_CREATE handler reject open
requests that would violate whatever restriction you require.</blockquote></div>
</p>

<p>The last argument (<b>&amp;fdo</b>) points to a location where IoCreateDevice will store the
address of the device object it creates.</p>

<p>If IoCreateDevice fails for some reason, it returns a status code and does not alter the
PDEVICE_OBJECT described by the last argument. If it succeeds, it returns a successful status
code and sets the PDEVICE_OBJECT pointer. You can then proceed to initialize your device
extension and do the other work associated with creating a new device object. Should you
discover an error after this point, you should release the device object and return a status
code. The code to accomplish these tasks would be something like this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
NTSTATUS status = IoCreateDevice(...);
if (!NT_SUCCESS(status))
  return status;
...
if (<i>&lt;some other error discovered&gt;</i>)
  {
  IoDeleteDevice(fdo);
  return status;
  }
</pre>
</td></tr>
</table>
</p>

<p>I'll explain the NTSTATUS status codes and the NT_SUCCESS macro in the <a href="ch03a.htm">next chapter</a>.</p>

<A NAME="46"><H2>Naming Devices</H2></A>

<p>Windows NT uses a centralized Object Manager to manage many of its internal data structures,
including the driver and device objects I've been talking about. David Solomon presents a
fairly complete explanation of the Windows NT Object Manager and namespace in Chapter 3,
&quot;System Mechanisms,&quot; of <i>Inside Windows NT, Second Edition</i> (Microsoft Press,
1998). Objects have names, which the Object Manager maintains in a hierarchical namespace.
Figure 2-16 is a screen shot of my DEVVIEW application showing the top level of the name
hierarchy. The objects displayed as folders in this screen shot are <i>directory objects,</i>
which can contain subdirectories and &quot;regular&quot; objects. The objects displayed with
other icons are examples of these regular objects. (In this respect, DEVVIEW is similar to the
WINOBJ utility that you'll find in the BIN\WINNT directory of the Platform SDK. WINOBJ
can't give you information about device objects and drivers, though, which is why I wrote
DEVVIEW in the first place.)</p>

<p>
<A HREF="javascript:fullSize('F02wi16x.htm')"> <img src="images/F02wi16.JPG" width=404 height=428 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 2-16.</b> <i>Using DEVVIEW to view the namespace.</i><!--/caption-->
</p>


<p>Device objects can have names that conventionally live in the \Device directory. Names for
devices serve two purposes in Windows 2000. Giving your device object a name allows other
kernel-mode components to find it by calling service functions like <b>
IoGetDeviceObjectPointer</b>. Having found your device object, they can send you IRPs.</p>

<p>The other purpose of naming a device object is to allow applications to open handles to the
device so <i>they</i> can send you IRPs. An application uses the standard <b>CreateFile</b> API
to open a handle, whereupon it can use <b>ReadFile</b>, <b>WriteFile</b>, and <b>
DeviceIoControl</b> to talk to you. The pathname an application uses to open a device handle
begins with the prefix <b>\\.\</b> rather than with a standard Universal Naming Convention
(UNC) name such as C:\MYFILE.CPP or \\FRED\C-Drive\HISFILE.CPP. Internally, the I/O Manager
converts this prefix into <b>\??\</b> before commencing a name search. To provide a mechanism
for connecting names in the <b>\??</b> directory to objects whose names are elsewhere (such as
in the \Device directory), the Object Manager implements an object called a <i>symbolic
link.</i></p>

<A NAME="47"><H3>Symbolic Links</H3></A>

<p>A symbolic link is a little bit like a desktop shortcut in that it points to some other
entity that's the real object of attention. Symbolic links are mainly used in Windows NT to
connect the leading portion of DOS-style names to devices. Figure 2-17 shows a portion of the
\?? directory, which includes a number of symbolic links. Notice, for example, that C: and
other drive letters in the DOS file-naming scheme are actually links to objects whose names are
in the \Device directory. These links allow the Object Manager to &quot;jump&quot; somewhere
else in the namespace as it parses through a name. So, if I call CreateFile with the name
C:\MYFILE.CPP, the Object Manager will take this path to open the file:</p>

<ol>
<p><li> Kernel-mode code initially sees the name \??\C:\MYFILE.CPP. The Object Manager
looks up &quot;??&quot; in the root directory and finds a directory object with that name.</li></p>

<p><li> The Object Manager now looks up &quot;C:&quot; in the \?? directory. It finds a
symbolic link by that name, so it forms the <i>new</i> kernel-mode pathname
\Device\HarddiskVolume1\MYFILE.CPP and parses that.</li></p>

<p><li> Working with the new pathname, the Object Manager looks up &quot;Device&quot; in
the root directory and finds a directory object.</li></p>

<p><li> The Object Manager looks up &quot;HarddiskVolume1&quot; in the \Device directory.
It finds a device object by that name.</li></p>
</ol>

<p>
<A HREF="javascript:fullSize('F02wi17x.htm')"> <img src="images/F02wi17.JPG" width=404 height=281 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 2-17.</b> <i>The \?? directory with several symbolic links.</i><!--/caption-->
</p>


<p>At this point in the process, the Object Manager will create an IRP that it will send to the
driver(s) for HarddiskVolume1. The IRP will eventually cause some file system driver or another
to locate and open a disk file. Describing how a file system driver works is beyond the scope
of this book. If we were dealing with a device name like COM1, the driver that ends up
receiving the IRP would be the driver for \Device\Serial0. How a device driver handles an open
request is definitely within the scope of this book, and I'll be discussing it in this
chapter (in the section &quot;<A HREF="ch02d.htm#48">Should I Name My Device Object?</A>&quot;) and in <a href="ch05a.htm">Chapter 5</a> when
I'll talk about IRP processing in general.</p>

<p>A user-mode program can create a symbolic link by calling <b>DefineDosDevice</b>, as in this
example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL okay = DefineDosDevice(DDD_RAW_TARGET_PATH,
  &quot;barf&quot;, &quot;\\Device\\SECTEST_0&quot;);
</pre>
</td></tr>
</table>
</p>

<p>You can see the aftermath of a call like this one in Figure 2-17, by the way.</p>

<p>You can create a symbolic link in a WDM driver by calling <b>IoCreateSymbolicLink</b>,</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
IoCreateSymbolicLink(linkname, targname);
</pre>
</td></tr>
</table>
</p>

<p>where <b>linkname</b> is the name of the symbolic link you want to create and <b>
targname</b> is the name to which you're linking. Incidentally, the Object Manager
doesn't care whether targname is the name of any existing object: someone who tries to
access an object by using a link that points to an undefined name simply receives an error. If
you want to allow user-mode programs to override your link and point it somewhere else, you
should call <b>IoCreateUnprotectedSymbolicLink</b> instead.</p>

<p><div class="sidebar"><blockquote>
<b>ARC Names </b>

<p>In the Advanced RISC Computing (ARC) architecture, there is a concept known as <i>ARC
naming</i> that Windows 2000 relies on. You can see ARC names at work in the BOOT.INI file in
the root directory of your boot drive. Here's what my copy of that file looked like at one
point in the development of this book:</p>


<p>
<table cellpadding=5><tr><td>
<pre>
[boot loader]
timeout=30
default=c:\
[operating systems]
C:\=&quot;Microsoft Windows 98&quot;
scsi(0)disk(1)rdisk(0)partition(1)\BETA2F=&quot;Win2k Beta-2 (Free Build)&quot; 
  /fastdetect /noguiboot
scsi(0)disk(1)rdisk(0)partition(1)\WINNT=&quot;Win2K Beta-3 (Free Build)&quot; 
  /fastdetect /noguiboot
</pre>
</td></tr>
</table>
</p>

<p>On an Intel platform, ARC names like scsi(0)disk(1)rdisk(0)partition(1) are
symbolic links within the kernel's \ArcName directory that point&#8212;eventually, that is,
if you resolve all the links in the way&#8212;to regular device objects. DEVVIEW will show you
these links on your own system.</p>

<p>Drivers for mass-storage devices other than hard disks should call <b>IoAssignArcName</b> 
during initialization to set up one of these links. The I/O Manager automatically creates the
ARC names for hard disk devices, since these are needed to boot the system in the first
place.</p>
</blockquote></div>
</p>
<A NAME="48"><H3>Should I Name My Device Object?</H3></A>

<p>Deciding whether to give your device object a name requires, as I said earlier, a little
thought. If you give your object a name, it will be possible for any kernel-mode program to try
to open a handle to your device. Furthermore, it will be possible for any kernel-mode or
user-mode program to create a symbolic link to your device object and to use the symbolic link
to try to open a handle. You might or might not want to allow these actions.</p>

<p>The primary consideration in deciding whether to name your device object is security. When
someone opens a handle to a named object, the Object Manager verifies that they have permission
to do so. When IoCreateDevice creates a device object for you, it assigns a default security
descriptor based on the device type you specify as the fourth argument. There are three basic
categories that the I/O Manager uses to select a security descriptor. (Refer to the second
column in Table 2-4.)</p>

<ul>
<p><li> Most file system device objects (that is, disk, CD-ROM, file, and tape) receive the
&quot;public default unrestricted&quot; access control list (ACL). This list gives just
SYNCHRONIZE, READ_CONTROL, FILE_READ_ATTRIBUTES, and FILE_TRAVERSE access to everyone except
the System account and all administrators. File system device objects, by the way, exist only
so that there can be a target for a CreateFile call that will open a handle to a file managed
by the file system.</li></p>

<p><li> Disk devices and network file system objects receive the same ACL as the file system
objects with some modifications. For example, everyone gets full access to a named floppy disk
device object, and administrators get sufficient rights to run ScanDisk. (User-mode network
provider DLLs need greater access to the device object for their corresponding file system
driver, which is why network file systems are treated differently than other file
systems.)</li></p>

<p><li> All other device objects receive the &quot;public open unrestricted&quot; ACL, which
allows anyone with a handle to the device to do pretty much anything.</li></p>
</ul>


<p>You can see that anyone will be able to access a nondisk device for both reading and writing
if the driver gives the device object a name at the time when it calls IoCreateDevice. This is
because the default security allows nearly full access <i>and because there is no security
check at all associated with creating a symbolic link&#8212;</i>the security checks happen at
open time, based on the named object's security descriptor. This is true even if other
device objects in the same stack have more restrictive security.</p>

<p>DEVVIEW will show you the security attributes of the device objects it displays. You can see
the operation of the default rules I just described by examining a file system, a disk device,
and any other random device.</p>

<p>The PDO also receives a default security descriptor, but it's possible to override it
with a security descriptor stored in the hardware key or in the Properties subkey of the class
key. (The hardware key has precedence if both keys specify a descriptor.) Even lacking a
specific security override, if either the hardware key or the class key's Properties subkey
overrides the device type or characteristics specification, the I/O Manager constructs a <i>
new</i> default security descriptor based on the new type. The I/O Manager does not, however,
override the security setting for any of the other device objects above the PDO. Consequently,
for the overrides (and the administrative actions that set them up) to have any effect, you
should not name your device object. Don't despair though&#8212;applications can still access
your device by means of a <i>registered interface,</i> which I'll discuss very shortly.</p>

<p>You need to know about one last security concern. As the Object Manager parses its way
through an object name, it needs only FILE_TRAVERSE access to the intermediate components of
the name. It only performs a full security check on the object named by the final component.
So, suppose you had a device object reachable under the name \Device\SECTEST_0 or by the
symbolic link \??\SecurityTest_0. A user-mode application that tries to open \\.\SecurityTest_0
for writing will be blocked if the object security has been set up to deny write access. But if
the application tries to open a name like \\.\SecurityTest_0\ExtraStuff that has additional
name qualifications, the open request will make it all the way to the device driver (in the
form of an IRP_MJ_CREATE I/O request) if the user merely has FILE_TRAVERSE permission, which is
routinely granted. The I/O Manager expects the device driver to deal with the additional name
components and to perform any required security checks with regard to them.</p>

<p>To avoid the security concern I just described, you can supply the flag FILE_DEVICE_SECURE_OPEN in the device characteristics argument to IoCreateDevice. This flag causes
Windows 2000 to verify that someone has the right to open a handle to a device even if
additional name components are present.</p>

<A NAME="49"><H3>The Device Name</H3></A>

<p>If you decide to name the device object, you would normally put the name in the \Device
branch of the namespace. To give it a name, you have to create a UNICODE_STRING structure to hold the name, and you have to specify that string as an argument to
IoCreateDevice:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
UNICODE_STRING devname;
RtlInitUnicodeString(&amp;devname, L&quot;\\Device\\Simple0&quot;);
IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION), &amp;devname, ...);
</pre>
</td></tr>
</table>
</p>

<p>I'll discuss the usage of <b>RtlInitUnicodeString</b> in the <a href="ch03a.htm">next chapter</a>.</p>

<p>Conventionally, drivers assign their device objects a name by concatenating a string naming
their device type (&quot;Simple&quot; in this fragment) with a zero-based integer denoting an
instance of that type. In general, you don't want to hard-code a name like I just
did&#8212;you want to compose it dynamically using string-manipulation functions like the
following:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
UNICODE_STRING devname;
static LONG lastindex = -1;
LONG devindex = InterlockedIncrement(&amp;lastindex);
WCHAR name[32];
_snwprintf(name, arraysize(name), L&quot;\\Device\\SIMPLE%2.2d&quot;, devindex);
RtlInitUnicodeString(&amp;devname, name);
IoCreateDevice(...);
</pre>
</td></tr>
</table>
</p>

<p>I'll explain the various service functions used in this fragment in the next couple of
chapters. The instance number you derive for private device types might as well be a static
variable, as shown in the previous fragment.</p>

<p><div class="sidebar"><blockquote>
<b>Notes on Device Naming</b> 

<p>If all you wanted to do was to provide a quick-and-dirty way for an application to open a
handle to your device during development, you could perfectly well assign the device object a
name in the \?? branch. For a production driver, however, you're better advised to do what
the text suggests and name the device object with a \Device directory name.</p>

<p>The \?? directory used to be named \DosDevices. In fact, \DosDevices will still work, but it
itself is a symbolic link to \??. The change was made to move the often-searched directory of
user-mode names to the front of the alphabetical list of directories. <i>See the &quot;<A HREF="ch02e.htm#60">Windows98 Compatibility Notes</A>&quot; section at the end of this chapter for an important caution about
using \?? in your names.</i></p>

<p>In previous versions of Windows NT, drivers for certain classes of devices (notably disks,
tapes, serial ports, and parallel ports) called <b>IoGetConfigurationInformation</b> to obtain
a pointer to a global table containing counts of devices in each of these special classes. A
driver would use the current value of the counter to compose a name like Harddisk0, Tape1, and
so on, and would also increment the counter. WDM drivers don't need to use this service
function or the table it returns, however. Constructing names for the devices in these classes
is now the responsibility of a Microsoft type-specific class driver (such as DISK.SYS).</p>
</blockquote></div>
</p>

<A NAME="50"><H3>Device Interfaces</H3></A>

<p>The older method of naming I just discussed&#8212;naming your device object and creating a
symbolic link name that applications can use&#8212;has two major problems. We've already
discussed the security implications of giving your device object a name. In addition, the
author of an application that wants to access your device has to know the scheme you adopted to
name your devices. If you're the only one writing the applications that will be accessing
your hardware, that's not much of a problem. But if many different companies will be
writing applications for your hardware, and especially if many hardware companies are making
similar devices, devising a suitable naming scheme is difficult. Finally, many naming schemes
rely on the language spoken by the programmer, which isn't necessarily a good choice in an
increasingly global economy. (My favorite example involves an American chef who tells a German
diner he's eating a &quot;gift&quot; [poison], whereupon the diner, only incompletely
realizing the linguistic difficulty, calls the chef a &quot;schmuck&quot; [jewelry].)</p>

<p>To solve these problems, WDM introduces a new naming scheme for devices that is
language-neutral, easily extensible, usable in an environment with many hardware and software
vendors, and easily documented. The scheme relies on the concept of a <i>device interface,</i>
which is basically a specification for how software can access hardware. A device interface is
uniquely identified by a 128-bit GUID. You can generate GUIDs by running the Platform SDK
utilities UUIDGEN or GUIDGEN&#8212;both utilities generate the same kind of number, but they
output the result in different formats. The idea is that some industry group gets together to
define a standard way of accessing a certain kind of hardware. As part of the standard-making
process, someone runs GUIDGEN and publishes the resulting GUID as the identifier that will be
forever after associated with that interface standard.</p>

<p><div class="sidebar"><blockquote>
<b>More About GUIDs </b>

<p>The GUIDs used to identify software interfaces are the same kind of unique identifier
that's used in the Component Object Model (COM) to identify COM interfaces and in the Open
Software Foundation (OSF) Distributed Computing Environment (DCE) to identify the target of a
remote procedure call (RPC). For an explanation of how GUIDs are generated so as to be
statistically unique, see page 66 of Kraig Brockschmidt's <i>Inside OLE, Second Edition</i>
(Microsoft Press, 1995), which contains a further reference to the original algorithm
specification by the OSF. I found the relevant portion of the OSF specification online at <i>
<a href="http://www.opengroup.org/onlinepubs/9629399/apdxa.htm" target="_window2">http://www.opengroup.org/onlinepubs/9629399/apdxa.htm</a></i>.</p>

<p>The mechanics of creating a GUID for use in a device driver involve running either UUIDGEN
or GUIDGEN and then capturing the resulting identifier in a header file. GUIDGEN is easier to
use because it allows you to choose to format the GUID for use with the DEFINE_GUID macro and
to copy the resulting string onto the clipboard. Figure 2-18 shows the GUIDGEN window. You can
paste its output into a header file to end up with this:</p>

<p>
<table cellpadding=5><tr><td>
<pre>
// {CAF53C68-A94C-11d2-BB4A-00C04FA330A6}
DEFINE_GUID(<i>&lt;&lt;name&gt;&gt;</i>, 
0xcaf53c68, 0xa94c, 0x11d2, 0xbb, 0x4a, 0x0, 0xc0, 0x4f, 0xa3, 0x30, 0xa6);
</pre>
</td></tr>
</table>
</p>

You then replace the <i>&lt;&lt;name&gt;&gt;</i> with something more mnemonic like
GUID_SIMPLE and include the definition in your driver and applications.
</blockquote></div>
</p>

<p>
<img src="images/F02wi18.JPG" width=375 height=339 border=0>
</p><p>
<!--caption--><b>Figure 2-18.</b> <i>Using GUIDGEN to generate a GUID.</i><!--/caption-->
</p>


<p>I think of an interface as being analogous to the protein markers that populate the surface
of living cells. An application desiring to access a particular kind of device has its own
protein markers that fit like a key into the markers exhibited by conforming device drivers.
See Figure 2-19.</p>

<p>
<A HREF="javascript:fullSize('F02wi19x.htm')"> <img src="images/F02wi19.JPG" width=404 height=222 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 2-19.</b> <i>Using device interfaces to match up applications and devices.</i><!--/caption-->
</p>


<p><b>Registering a Device Interface</b> A function driver's AddDevice function should register one
or more device interfaces by calling <b>IoRegisterDeviceInterface</b>, as shown here:</p>

<p>
<table cellpadding=5 width="95%">
<tr><td valign=top>
<pre>
1 <img src="images/arorite2.jpg" width=17 height=10 border=0>
2 <img src="images/arorite2.jpg" width=17 height=10 border=0>




3 <img src="images/arorite2.jpg" width=17 height=10 border=0>
</pre>
</td>
<td valign=top>
<pre>
#include &lt;initguid.h&gt;
#include &quot;guids.h&quot;
...
  NTSTATUS AddDevice(...)
    {
    ...
    IoRegisterDeviceInterface(pdo, &amp;GUID_SIMPLE, NULL, &amp;pdx-&gt;ifname);
    ...
    }
</pre>
</td></tr>
</table>
</p>

<ol>
<p><li> We're about to include a header (GUIDS.H) that contains one or more
DEFINE_GUID macros. DEFINE_GUID normally declares an external variable. Somewhere in the
driver, though, we have to actually reserve initialized storage for every GUID we're going
to reference. The system header file INITGUID.H works some preprocessor magic to make
DEFINE_GUID reserve the storage even if the definition of the DEFINE_GUID macro happens to be in
one of the precompiled header files.</li></p>

<p><li> I'm assuming here that I put the GUID definitions I want to reference into a
separate header file. This would be a good idea, inasmuch as user-mode code will also need to
include these definitions and will <i>not</i> want to include a bunch of extraneous kernel-mode
declarations relevant only to our driver.</li></p>

<p><li> The first argument to IoRegisterDeviceInterface must be the address of the PDO
for your device. The second argument identifies the GUID associated with your interface, and
the third argument specifies additional qualified names that further subdivide your interface.
Only Microsoft code uses this name subdivision scheme. The last argument is the address of a
UNICODE_STRING structure that will receive the name of a symbolic link that resolves to this
device object.</li></p>
</ol>

<p>The return value from IoRegisterDeviceInterface is a Unicode string that applications will
be able to determine without knowing anything special about how you coded your driver and will
then be able to use in opening a handle to the device. The name is pretty ugly, by the way;
here's an example that I generated for one of my sample devices in Windows 98:
\DosDevices\0000000000000007#{CAF53C68-A94C-11d2-BB4A-00C04FA330A6}. (You can call it 007 once you get to know it better.)</p>

<p>All that registration actually does is create the symbolic link name and save it in the
registry. Later on, in response to the IRP_MN_START_DEVICE Plug and Play request we'll
discuss in <A HREF="ch06a.htm">Chapter 6</A>, you'll make the following call to <b>IoSetDeviceInterfaceState</b> to
&quot;enable&quot; the interface:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
IoSetDeviceInterfaceState(&amp;pdx-&gt;ifname, TRUE);
</pre>
</td></tr>
</table>
</p>

<p>In response to this call, the I/O Manager creates an actual symbolic link <i>object</i>
pointing to the PDO for your device. You'll make a matching call to disable the interface
at a still later time (just call IoSetDeviceInterfaceState with a FALSE argument), whereupon
the I/O Manager will delete the symbolic link object while preserving the registry entry that
contains the name. In other words, the name persists and will always be associated with this
particular instance of your device; the symbolic link object comes and goes with the
hardware.</p>

<p>Since the interface name ends up pointing to the PDO, the PDO's security descriptor ends
up controlling whether people can access your device. That's good, because it's the
PDO's security that an administrator can control through the Management Console.</p>

<p><b>Enumerating Device Interfaces</b> Both kernel-mode and user-mode code can locate all the devices
that happen to support an interface in which they're interested. I'm going to explain
how to enumerate all the devices for a particular interface in user mode. The enumeration code
is so tedious to write that I eventually wrote a C++ class to make my own life simpler.
You'll find this code in the DEVICELIST.CPP and DEVICELIST.H files that are part of the
WDMIDLE sample in Chapter 8, &quot;<A HREF="ch08a.htm#265">Power Management</A>.&quot; These files declare and implement a
<b>CDeviceList</b> class, which contains an array of <b>CDeviceListEntry</b> objects. These two
classes have the following declaration:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
class CDeviceListEntry
{
public:
  CDeviceListEntry(LPCTSTR linkname, LPCTSTR friendlyname);
  CDeviceListEntry(){}
  CString m_linkname;
  CString m_friendlyname;
};

class CDeviceList
{
public:
  CDeviceList(const GUID&amp; guid);
  ~CDeviceList();
  GUID m_guid;
  CArray&lt;CDeviceListEntry, CDeviceListEntry&amp;&gt; m_list;
  int Initialize();
};
</pre>
</td></tr>
</table>
</p>

<p>The classes rely on the <b>CString</b> class and <b>CArray</b> template class that are part
of the Microsoft Foundation Classes (MFC) framework. The constructors for these two classes
simply copy their arguments into the obvious data members:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
CDeviceList::CDeviceList(const GUID&amp; guid)
  {
  m_guid = guid;
  }

CDeviceListEntry::CDeviceListEntry(LPCTSTR linkname,
  LPCTSTR friendlyname)
  {
  m_linkname = linkname;
  m_friendlyname = friendlyname;
  }
</pre>
</td></tr>
</table>
</p>

<p>All the interesting work occurs in the <b>CDeviceList::Initialize</b> function. The
executive overview of what it does is this: it will enumerate all of the devices that expose
the interface whose GUID was supplied to the constructor. For each such device, it will
determine a &quot;friendly&quot; name that we're willing to show to an unsuspecting end
user. Finally, it will return the number of devices it found. Here's the code for this
function:</p>

<p>
<table cellpadding=5 width="95%">
<tr><td valign=top>
<pre>


1 <img src="images/arorite2.jpg" width=17 height=10 border=0>






2 <img src="images/arorite2.jpg" width=17 height=10 border=0>




3 <img src="images/arorite2.jpg" width=17 height=10 border=0>









4 <img src="images/arorite2.jpg" width=17 height=10 border=0>






5 <img src="images/arorite2.jpg" width=17 height=10 border=0>
</pre>
</td>
<td valign=top>
<pre>
int CDeviceList::Initialize()
  {
  HDEVINFO info = SetupDiGetClassDevs(&amp;m_guid, NULL, NULL,
    DIGCF_PRESENT | DIGCF_INTERFACEDEVICE);
  if (info == INVALID_HANDLE_VALUE)
    return 0;
  SP_INTERFACE_DEVICE_DATA ifdata;
  ifdata.cbSize = sizeof(ifdata);
  DWORD devindex;
  for (devindex = 0; 
    SetupDiEnumDeviceInterfaces(info, NULL, &amp;m_guid, 
    devindex, &amp;ifdata); ++devindex)
    {
    DWORD needed;
    SetupDiGetDeviceInterfaceDetail(info, &amp;ifdata, NULL, 0,
      &amp;needed, NULL);

    PSP_INTERFACE_DEVICE_DETAIL_DATA detail = 
      (PSP_INTERFACE_DEVICE_DETAIL_DATA) malloc(needed);
    detail-&gt;cbSize = sizeof(SP_INTERFACE_DEVICE_DETAIL_DATA);
    SP_DEVINFO_DATA did = {sizeof(SP_DEVINFO_DATA)};
    SetupDiGetDeviceInterfaceDetail(info, &amp;ifdata, detail,
      needed, NULL, &amp;did));

    TCHAR fname[256];
    if (!SetupDiGetDeviceRegistryProperty(info, &amp;did, SPDRP_FRIENDLYNAME,
        NULL, (PBYTE) fname, sizeof(fname), NULL)
      &amp;&amp; !SetupDiGetDeviceRegistryProperty(info, &amp;did, SPDRP_DEVICEDESC,
        NULL, (PBYTE) fname, sizeof(fname), NULL))
      _tcsncpy(fname, detail-&gt;DevicePath, 256);

    CDeviceListEntry e(detail-&gt;DevicePath, fname);
    free((PVOID) detail);

    m_list.Add(e);
    }

  SetupDiDestroyDeviceInfoList(info);
  return m_list.GetSize();
  }</pre>
</td></tr>
</table></p>

<ol>
<p><li> This statement opens an enumeration handle that we can use to find all devices
that have registered an interface that uses the same GUID.</li></p>

<p><li> Here we call <b>SetupDiEnumDeviceInterfaces</b> in a loop to find each
device.</li></p>

<p><li> The only two items of information we need are the &quot;detail&quot; information
about the interface and information about the device instance. The detail is just the symbolic
name for the device. Since it's variable in length, we make two calls to <b>
SetupDiGetDeviceInterfaceDetail</b>. The first call determines the length. The second call
retrieves the name.</li></p>

<p><li> We obtain a &quot;friendly&quot; name for the device from the registry by asking
for either the <b>FriendlyName</b> or the <b>DeviceDesc</b>.</li></p>

<p><li> We create a temporary instance named <b>e</b> of the CDeviceListEntry class,
using the device's symbolic name as both the link name and the friendly name.</li></p>
</ol>

<p><div class="sidebar"><blockquote>
<b>Friendly Names</b>

<p>You might be wondering how the registry comes to have a FriendlyName for a device. The INF
file you use to install your device driver&#8212;see <A HREF="ch12a.htm">Chapter 12</A>&#8212;can have an HW section that
specifies registry parameters for the device. You should normally provide a FriendlyName as one
of these parameters.</p>
</blockquote></div>
</p>

<A NAME="51"><H2>Other Global Device Initialization</H2></A>

<p>You need to take some other steps during AddDevice to initialize your device object. I'm
going to describe these steps in the order you should do them, which isn't exactly the same
order as their respective logical importance. I want to emphasize that the code snippets in
this section are even more fragmented than usual&#8212;I'm going to show only enough of the
entire AddDevice routine to establish the surrounding context for the small pieces I'm
trying to illustrate.</p>

<A NAME="52"><H3>Initializing the Device Extension</H3></A>

<p>The content and management of the device extension are entirely up to you. The data members
you place in this structure will obviously depend on the details of your hardware and on how
you go about programming the device. Most drivers would need a few items placed there, however,
as illustrated in the following fragment of a declaration:</p>

<p>
<table cellpadding=5 width="95%">
<tr><td valign=top>
<pre>
1 <img src="images/arorite2.jpg" width=17 height=10 border=0>
2 <img src="images/arorite2.jpg" width=17 height=10 border=0>
3 <img src="images/arorite2.jpg" width=17 height=10 border=0>
4 <img src="images/arorite2.jpg" width=17 height=10 border=0>
5 <img src="images/arorite2.jpg" width=17 height=10 border=0>
6 <img src="images/arorite2.jpg" width=17 height=10 border=0>
7 <img src="images/arorite2.jpg" width=17 height=10 border=0>




8 <img src="images/arorite2.jpg" width=17 height=10 border=0>
</pre>
</td>
<td valign=top>
<pre>
typedef struct _DEVICE_EXTENSION {
  PDEVICE_OBJECT DeviceObject;
  PDEVICE_OBJECT LowerDeviceObject;
  PDEVICE_OBJECT Pdo;
  UNICODE_STRING ifname;
  IO_REMOVE_LOCK RemoveLock;
  DEVSTATE devstate;
  DEVSTATE prevstate;
  POWERSTATE powerstate;
  DEVICE_POWER_STATE devpower;
  SYSTEM_POWER_STATE syspower;
  DEVICE_CAPABILITIES devcaps;
  ...
  } DEVICE_EXTENSION, *PDEVICE_EXTENSION;
</pre>
</td></tr>
</table>
</p>

<ol>
<p><li> I find it easiest to mimic the pattern of structure declaration used in the
official DDK, so I declared this device extension as a structure with a tag as well as a type
and pointer-to-type name.</li></p>

<p><li> You already know that you locate your device extension by following the <b>
DeviceExtension</b> pointer from the device object. It's also useful in several situations
to be able to go the other way&#8212;to find the device object given a pointer to the extension.
The reason is that the logical argument to certain functions is the device extension itself
(since that's where all of the per-instance information about your device resides). Hence,
I find it useful to have this <b>DeviceObject</b> pointer.</li></p>

<p><li> I'll mention in a few paragraphs that you need to record the address of the
device object immediately below yours when you call IoAttachDeviceToDeviceStack, and <b>
LowerDeviceObject</b> is the place to do that.</li></p>

<p><li> A few service routines require the address of the PDO instead of some higher
device object in the same stack. It's very difficult to locate the PDO, so the easiest way
to satisfy the requirement of those functions is to record the PDO address in a member of the
device extension that you initialize during AddDevice.</li></p>

<p><li> Whichever method (symbolic link or device interface) you use to name your device,
you'll want an easy way to remember the name you assign. In this fragment, I've
declared a Unicode string member named <b>ifname</b> to record a device interface name. If you
were going to use a symbolic link name instead of a device interface, it would make sense to
give this member a more mnemonic name, such as &quot;linkname.&quot;</li></p>

<p><li> I'll discuss in <A HREF="ch06a.htm">Chapter 6</A> a synchronization problem affecting how you decide
when it's safe to remove this device object by calling <b>IoDeleteDevice</b>. The solution
to that problem involves using an IO_REMOVE_LOCK object that needs to be allocated in your
device extension as shown here. AddDevice needs to initialize that object.</li></p>

<p><li> You'll probably need a device extension variable to keep track of the current
Plug and Play state and current power states of your device. DEVSTATE and POWERSTATE are
enumerations that I'm assuming you've declared elsewhere in your own header file.
I'll discuss the use of all these state variables in later chapters.</li></p>

<p><li> Another part of power management involves remembering some capability settings
that the system initializes by means of an IRP. The <b>devcaps</b> structure in the device
extension is where I save those settings in my sample drivers.</li></p>
</ol>

<p>The initialization statements in AddDevice (with emphasis on the parts involving the device
extension) would be as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
NTSTATUS AddDevice(...)
  {
  PDEVICE_OBJECT fdo;
  IoCreateDevice(..., sizeof(DEVICE_EXTENSION), ..., &amp;fdo);
  PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION) fdo-&gt;DeviceExtension;
  pdx-&gt;DeviceObject = fdo;
  pdx-&gt;Pdo = pdo;
  IoInitializeRemoveLock(&amp;pdx-&gt;RemoveLock, ...);
  pdx-&gt;devstate = STOPPED;
  pdx-&gt;powerstate = POWERON;
  pdx-&gt;devpower = PowerDeviceD0;
  pdx-&gt;syspower = PowerSystemWorking;
  IoRegisterDeviceInterface(..., &amp;pdx-&gt;ifname);
  pdx-&gt;LowerDeviceObject = IoAttachDeviceToDeviceStack(...);
  }
</pre>
</td></tr>
</table>
</p>

<A NAME="53"><H3>Initializing the Default DPC Object</H3></A>

<p>Many devices signal completion of operations by means of an interrupt. As you'll learn
when I discuss interrupt handling in Chapter 7, &quot;<A HREF="ch07a.htm#226">Reading and Writing Data</A>,&quot; there are
strict limits on what your interrupt service routine (ISR) can do. In particular, an ISR
isn't allowed to call the routine (<b>IoCompleteRequest</b>) that signals completion of an
IRP, but that's exactly one of the steps you're likely to want to take. You utilize a
<i>deferred procedure call</i> (DPC) to get around the limitations. Your device object contains
a subsidiary DPC object that can be used for scheduling your particular DPC routine, and you
need to initialize it shortly after creating the device object:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
NTSTATUS AddDevice(...)
  {
  IoCreateDevice(...);
  IoInitializeDpcRequest(fdo, DpcForIsr);
  }
</pre>
</td></tr>
</table>
</p>

<A NAME="54"><H3>Setting the Buffer Alignment Mask</H3></A>

<p>Devices which perform direct memory access (DMA) transfers work directly with data buffers
in memory. The HAL might require that buffers used for DMA be aligned to some particular
boundary, and your device might require still more stringent alignment. The <b>
AlignmentRequirement</b> field of the device object expresses the restriction&#8212;it is a bit
mask equal to one less that the required address boundary. You can round an arbitrary address
down to this boundary with this statement:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
PVOID address = ...;
SIZE_T ar = fdo-&gt;AlignmentRequirement;
address = (PVOID) ((SIZE_T) address &amp; ~ar);
</pre>
</td></tr>
</table>
</p>

<p>You round an arbitrary address <i>up</i> to the next alignment boundary like this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
PVOID address = ...;
SIZE_T ar = fdo-&gt;AlignmentRequirement;
address = (PVOID) (((SIZE_T) address + ar) &amp; ~ar);
</pre>
</td></tr>
</table>
</p>

<p>In these two code fragments, I used <b>SIZE_T</b> casts to transform the pointer (which may
be 32 bits or 64 bits wide, depending on the platform for which you're compiling) into an
integer wide enough to span the same range as the pointer.</p>

<p>IoCreateDevice sets the AlignmentRequirement field of the new device object equal to whatever
the HAL requires. For example, the HAL for Intel x86 chips has no alignment requirement, so
AlignmentRequirement is 0 initially. If your device requires a more stringent alignment for the
data buffers it works with (say, because you have bus-mastering DMA capability with a special
alignment requirement), you want to override the default setting. For example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
if (MYDEVICE_ALIGNMENT - 1 &gt; fdo-&gt;AlignmentRequirement)
  fdo-&gt;AlignmentRequirement = MYDEVICE_ALIGNMENT - 1;
</pre>
</td></tr>
</table>
</p>

<p>I've assumed here that elsewhere in your driver is a manifest constant named
MYDEVICE_ALIGNMENT that equals a power of two and represents the required alignment of your
device's data buffers.</p>

<A NAME="55"><H3>Miscellaneous Objects</H3></A>

<p>Your device might well use other objects that need to be initialized during AddDevice. Such
objects might include a controller object, various synchronization objects, various queue
anchors, scatter/gather list buffers, and so on. I'll discuss these objects, and the fact
that initialization during AddDevice would be appropriate, in various other parts of the
book.</p>

<A NAME="56"><H3>Initializing the Device Flags</H3></A>

<p>Two of the flag bits in your device object need to be initialized during AddDevice and never
changed thereafter: the DO_BUFFERED_IO and DO_DIRECT_IO flags. You can set one (but only one)
of these bits to declare once and for all how you want to handle memory buffers coming from
user mode as part of read and write requests. (I'll explain in <A HREF="ch07a.htm">Chapter 7</A> what the
difference between these two buffering methods is and why you'd want to pick one or the
other.) The reason you have to make this important choice during AddDevice is that any upper
filter drivers that load after you will be copying your flag settings and it's the setting
of the bits in the topmost device object that's actually important. Were you to change your
mind after the filter drivers load, they probably wouldn't know about the change.</p>

<p>Three of the flag bits in the device object pertain to power management. In contrast to the
two buffering flags, these three can be changed at any time. I'll discuss them in greater
detail in <A HREF="ch08a.htm">Chapter 8</A>, but here's a preview. DO_POWER_PAGABLE means that the Power Manager
must send you IRP_MJ_POWER requests at interrupt request level (IRQL) DISPATCH_LEVEL. (If you
don't understand all of the concepts in the preceding sentence, don't
worry&#8212;I'll completely explain all of them in later chapters.) DO_POWER_INRUSH means
that your device draws a large amount of current when powering on, such that the Power Manager
should make sure that no other in-rush device is powering up simultaneously. DO_POWER_NOOP
means that you don't participate in power management in the first place and is only an
appropriate setting for WDM drivers that don't manage any hardware.</p>

<A NAME="57"><H3>Setting the Initial Power State</H3></A>

<p>Most devices start life in the fully powered state. If you know the initial state of your
device, you should tell the Power Manager:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
POWER_STATE state;
state.DeviceState = PowerDeviceD0;
PoSetPowerState(fdo, DevicePowerState, state);
</pre>
</td></tr>
</table>
</p>

<p>See <A HREF="ch08a.htm">Chapter 8</A> for much more detail about power management.</p>

<A NAME="58"><H3>Building the Device Stack</H3></A>

<p>Each filter and function driver has the responsibility of building up the stack of device
objects, starting from the PDO and working upward. You accomplish your part of this work with a
call to IoAttachDeviceToDeviceStack:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
NTSTATUS AddDevice(..., PDEVICE_OBJECT pdo)
  {
  PDEVICE_OBJECT fdo;
  IoCreateDevice(..., &amp;fdo);
  pdx-&gt;LowerDeviceObject = IoAttachDeviceToDeviceStack(fdo, pdo);
  }
</pre>
</td></tr>
</table>
</p>

<p>The first argument to IoAttachDeviceToDeviceStack (<b>fdo</b>) is the address of your own
newly created device object. The second argument is the address of the PDO. The second argument
to AddDevice is this address. The return value is the address of whatever device object is
immediately underneath yours, which can be the PDO or the address of some lower filter device
object.</p>

<A NAME="59"><H3>Clear DO_DEVICE_INITIALIZING</H3></A>

<p>Pretty much the last thing you do in AddDevice should be to clear the DO_DEVICE_INITIALIZING flag in your driver object:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
fdo-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING;
</pre>
</td></tr>
</table>
</p>

<p>While this flag is set, the I/O Manager will refuse to attach other device objects to yours
or to open a handle to your device. You have to clear the flag because your device object
initially arrives in the world with the flag set. In previous releases of Windows NT, most
drivers created all of their device objects during DriverEntry. When DriverEntry returns, the
I/O Manager automatically traverses the list of device objects linked from the driver object
and clears this flag. Since you're creating <i>your</i> device object long after
DriverEntry returns, however, this automatic flag clearing won't occur, and you must do it
yourself.</p>

</BODY>
</HTML>





