<HTML>
<HEAD>
<TITLE>String Handling</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch03d.htm">[Previous]</A> <A HREF="ch03f.htm">[Next]</a>
</p>

<A NAME="92"><H1>String Handling</H1></A>

<p>WDM drivers can work with string data in any of four formats:</p>

<ul>
<p><li> A Unicode string, normally described by a UNICODE_STRING structure, contains 16-bit
characters. Unicode has sufficient code points to accommodate the language scripts used on this
planet (and on at least one other&#8212;see <i>
<a href="http://www.indigo.ie/egt/standards/csur/klingon.html" target="_window2">http://www.indigo.ie/egt/standards/csur/klingon.html</a></i> ).</li></p>

<p><li> An ANSI string, normally described by an ANSI_STRING structure, contains 8-bit
characters. A variant is an OEM_STRING, which also describes a string of 8-bit characters. The
difference between the two is that an OEM string has characters whose graphic depends on the
current code page, whereas an ANSI string has characters whose graphic is independent of code
page. WDM drivers would not normally deal with OEM strings because they would have to originate
in user mode, and some other kernel-mode component will have already translated them into
Unicode strings by the time the driver sees them.</li></p>

<p><li> A null-terminated string of characters. You can express constants using normal C syntax,
such as <b>&quot;Hello, world!&quot;</b> Strings employ 8-bit characters of type CHAR, which
are assumed to be from the ANSI character set. The characters in string constants originate in
whatever editor you used to create your source code. If you use an editor that relies on the
then-current code page to display graphics in the editing window, be aware that some characters
might have a different meaning when treated as part of the Windows ANSI character set.</li></p>

<p><li> A null-terminated string of wide characters (type WCHAR). You can express wide string
constants using normal C syntax, such as <b>L&quot;Goodbye, cruel world!&quot;</b> Such strings
look like Unicode constants, but, being ultimately derived from some text editor or another,
actually use only the ASCII and Latin1 code points (0020-007F and 00A0-00FF) that correspond to
the Windows ANSI set.</li></p>
</ul>


<p>The UNICODE_STRING and ANSI_STRING data structures both have the layout depicted in Figure
3-14. The <b>Buffer</b> field of either structure points to a data area elsewhere in memory
that contains the string data. <b>MaximumLength</b> gives the length of the buffer area, and
<b>Length</b> provides the (current) length of the string without regard to any null terminator
that might be present. Both length fields are <i>in bytes,</i> even for the UNICODE_STRING
structure.</p>

<p>
<img src="images/F03wi14.JPG" width=403 height=234 border="0">
</p><p>
<!--caption--><b>Figure 3-14.</b> <i>The UNICODE_STRING and ANSI_STRING structures.</i><!--/caption-->
</p>


<p>Table 3-7 lists the service functions that you can use for working with Unicode and ANSI
strings. I've listed them side by side because there's a fair amount of duplication.
I've also listed some functions from the standard C run-time library that are available in
kernel mode for manipulating regular C-style strings. The standard DDK headers include
declarations of these functions, and the libraries with which you link drivers contain them, so
there's no particular reason not to use them even though they've never been documented
in the DDK as being available.</p>

<p><b>Table 3-7.</b> <i>Functions for string manipulation.</i></p>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>Operation</i></th>
<th><i>ANSI String Function</i></th>
<th><i>Unicode String Function</i></th>
</tr>
<tr>
<td valign="top">Length</td>
<td valign="top">strlen</td>
<td valign="top">wcslen</td>
</tr>
<tr>
<td valign="top">Concatenate</td>
<td valign="top">strcat, strncat</td>
<td valign="top">wcscat, wcsncat, 
RtlAppendUnicodeStringToString, 
RtlAppendUnicodeToString</td>
</tr>
<tr>
<td valign="top">Copy</td>
<td valign="top">strcpy, strncpy, 
RtlCopyString</td>
<td valign="top">wcscpy, wcsncpy, 
RtlCopyUnicodeString</td>
</tr>
<tr>
<td valign="top">Reverse</td>
<td valign="top">_strrev</td>
<td valign="top">_wcsrev</td>
</tr>
<tr>
<td valign="top">Compare</td>
<td valign="top">strcmp, strncmp, 
_stricmp, _strnicmp, 
RtlCompareString, 
RtlEqualString</td>
<td valign="top">wcscmp, wcsncmp, _wcsicmp, 
_wcsnicmp, 
RtlCompareUnicodeString, 
RtlEqualUnicodeString, 
RtlPrefixUnicodeString</td>
</tr>
<tr>
<td valign="top">Initialize</td>
<td valign="top">_strset, _strnset, 
RtlInitAnsiString, 
RtlInitString</td>
<td valign="top">_wcsnset, 
RtlInitUnicodeString</td>
</tr>
<tr>
<td valign="top">Search</td>
<td valign="top">strchr, strrchr, 
strspn, strstr</td>
<td valign="top">wcschr, wcsrchr, wcsspn, wcsstr</td>
</tr>
<tr>
<td valign="top">Upper/lowercase</td>
<td valign="top">_strlwr, _strupr, 
RtlUpperString</td>
<td valign="top">_wcslwr, _wcsupr, 
RtlUpcaseUnicodeString</td>
</tr>
<tr>
<td valign="top">Character</td>
<td valign="top">isdigit, islower, isprint, 
isspace, isupper, 
isxdigit, tolower, 
toupper, 
RtlUpperChar</td>
<td valign="top">towlower, towupper, 
RtlUpcaseUnicodeChar</td>
</tr>
<tr>
<td valign="top">Format</td>
<td valign="top">sprintf, vsprintf, 
 _snprintf, _vsnprintf</td>
<td valign="top">swprintf, _snwprintf</td>
</tr>
<tr>
<td valign="top">String conversion</td>
<td valign="top">atoi, atol, _itoa</td>
<td valign="top">_itow, 
RtlIntegerToUnicodeString, 
RtlUnicodeStringToInteger</td>
</tr>
<tr>
<td valign="top">Type conversion</td>
<td valign="top">RtlAnsiStringToUnicodeSize, 
RtlAnsiStringToUnicodeString</td>
<td valign="top">RtlUnicodeStringToAnsiString</td>
</tr>
<tr>
<td valign="top">Memory release</td>
<td valign="top">RtlFreeAnsiString</td>
<td valign="top">RtlFreeUnicodeString</td>
</tr>
</table>
</p>


<p>Many more <b>Rtl</b><i>Xxx</i> functions are exported by the system DLLs, but I've listed
the ones for which the DDK header files (and the SDK headers they include) define prototypes.
These are the only ones we should use in drivers.</p>

<A NAME="93"><H3>Allocating and Releasing String Buffers</H3></A>

<p>I'm not going to describe the string manipulation functions in detail because the DDK
documentation does this perfectly well and you already know, based on your general programming
experience, how to put functions like this together to get your work done. But I do want to
discuss a problem that can rear up and bite you if you don't look out for it.</p>

<p>You often define UNICODE_STRING (or ANSI_STRING) structures as automatic variables or as parts
of your own device extension. The string buffers to which these structures point usually occupy
dynamically allocated memory, but you'll sometimes want to work with string constants, too.
Keeping track of who owns the memory to which a particular UNICODE_STRING or ANSI_STRING
structure points can be a bit of a problem. Consider the following fragment of a function:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
UNICODE_STRING foo;
if (bArriving)
  RtlInitUnicodeString(&amp;foo, L&quot;Hello, world!&quot;);
else
  RtlAnsiStringToUnicodeString(&amp;foo, &quot;Goodbye, cruel world!&quot;, TRUE);
...
RtlFreeUnicodeString(&amp;foo); // <img src="images/tlarrow.jpg" width=13 height=12 border="0"> don't do this!
</pre>
</td></tr>
</table>
</p>

<p>In one case, we initialize <b>foo.Length</b>, <b>foo.MaximumLength</b>, and <b>
foo.Buffer</b> to describe a wide character string constant in our driver. In another case, we
ask the system (by means of the TRUE third argument to <b>RtlAnsiStringToUnicodeString</b>) to
allocate memory for the Unicode translation of an ANSI string. In the first case, it's a
mistake to call <b>RtlFreeUnicodeString</b> because it will unconditionally try to release a
memory block that's part of our code or data. In the second case, it's mandatory to
call RtlFreeUnicodeString eventually if we want to avoid a memory leak.</p>

<A NAME="94"><H2>Data Blobs</H2></A>

<p>I've borrowed the term <i>data blob</i> from the world of database management to
describe a random collection of bytes that you want to manipulate somehow. Table 3-8 lists the
functions (including some from the standard run-time library) that you can call in kernel mode
for that purpose. Once again, I'm going to assume that you can figure out how to use these
functions (based on their largely mnemonic names). I need to point out a few nonobvious facts,
however:</p>

<ul>
<p><li> The difference between a memory &quot;copy&quot; and a memory &quot;move&quot; is whether
the implementation can tolerate an overlap between the target and source. A move operation is
more general in that it works correctly whether or not there's an overlap. The copy
operation is faster because it assumes it can perform a left-to-right copy (which won't
work if the target overlaps the right portion of the source).</li></p>

<p><li> The difference between a &quot;byte&quot; and a &quot;memory&quot; operation is in the
granularity of the operation. A byte operation is guaranteed to proceed byte by byte. A memory
operation can use larger chunks internally, provided all the chunks add up to the specified
number of bytes. If this distinction is meaningless on a particular platform (as is true for
x86 computers), the byte operations are actually macro'ed to the corresponding memory
operations. Thus, <b>RtlCopyBytes</b> is a different function than <b>RtlCopyMemory</b> on an
Alpha but is #define'd equal to RtlCopyMemory on a 32-bit Intel.</li></p>
</ul>

<p><b>Table 3-8.</b> <i>Service functions for working with blobs of data.</i></P>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>Service Function or Macro</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">memchr</td>
<td valign="top">Find a byte in a blob</td>
</tr>
<tr>
<td valign="top">memcpy, RtlCopyBytes, 
RtlCopyMemory</td>
<td valign="top">Copy bytes, assuming no overlap</td>
</tr>
<tr>
<td valign="top">memmove, RtlMoveMemory</td>
<td valign="top">Copy bytes when there might be an 
overlap</td>
</tr>
<tr>
<td valign="top">memset, RtlFillBytes, 
RtlFillMemory</td>
<td valign="top">Fill blob with given value</td>
</tr>
<tr>
<td valign="top">memcmp, RtlCompareMemory, 
RtlEqualMemory</td>
<td valign="top">Compare one blob to another</td>
</tr>
<tr>
<td valign="top">memset, RtlZeroBytes, 
RtlZeroMemory</td>
<td valign="top">Zero-fill a blob</td>
</tr>
</table>
</p>


</BODY>
</HTML>





