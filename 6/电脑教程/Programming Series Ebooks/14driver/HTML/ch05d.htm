<HTML>
<HEAD>
<TITLE>Completing I/O Requests</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch05c.htm">[Previous]</A> <A HREF="ch05e.htm">[Next]</a>
</p>

<A NAME="159"><H1>Completing I/O Requests</H1></A>

<p>Every IRP has an urge toward completion. In the standard processing model, you might
complete an IRP in at least two circumstances. The DpcForIsr routine would generally complete
the request that's responsible for the most recent interrupt. A dispatch function might
also complete an IRP in situations like these:</p>

<ul>

<p><li> If the request is erroneous in some easily determined way (such as a request to rewind a
printer or to eject the keyboard), the dispatch routine should fail the request by completing
it with an appropriate status code.</li></p>

<p><li> If the request calls for information that the dispatch function can easily determine
(such as a control request asking for the driver's version number), the dispatch routine
should provide the answer and complete the request with a successful status code.</li></p>

</ul>


<A NAME="160"><H2>Completion Mechanics</H2></A>

<p>Mechanically, completing an IRP entails filling in the <b>Status</b> and <b>Information</b> 
members within the IRP's <b>IoStatus</b> block and calling <b>IoCompleteRequest</b>. The
Status value is one of the codes defined by manifest constants in the DDK header file
NTSTATUS.H. Refer to Table 5-1 for an abbreviated list of status codes for common situations.
The Information value depends on what type of IRP you're completing and on whether
you're succeeding or failing the IRP. Most of the time, when you're failing an IRP
(that is, completing it with an error status of some kind), you'll set Information to zero.
When you succeed an IRP that involves data transfer, you ordinarily set the Information field
equal to the number of bytes transferred.</p>

<p><b>Table 5-1.</b> <i>Some commonly used NTSTATUS codes.</i></p>

<P>
	<TABLE CELLPADDING=5 WIDTH="95%">

		<TR>
			<TH><i>Status Code</i></TH>
			<TH><i>Description</i></TH>
		</TR>

		<TR>
			<TD VALIGN="TOP">STATUS_SUCCESS</TD>
			<TD VALIGN="TOP">Normal completion</TD>
		</TR>
		
		<TR>
			<TD VALIGN="TOP">STATUS_UNSUCCESSFUL</TD>
			<TD VALIGN="TOP">Request failed, but no other status code describes the reason specifically</TD>
		</TR>
		
		<TR>
			<TD VALIGN="TOP">STATUS_NOT_IMPLEMENTED</TD>
			<TD VALIGN="TOP">A function hasn't been implemented</TD>
		</TR>

		<TR>
			<TD VALIGN="TOP">STATUS_INVALID_HANDLE</TD>
			<TD VALIGN="TOP">An invalid handle was supplied for an operation</TD>
		</TR>
		
		<TR>
			<TD VALIGN="TOP">STATUS_INVALID_PARAMETER</TD>
			<TD VALIGN="TOP">A parameter is in error</TD>
		</TR>
		
		<TR>
			<TD VALIGN="TOP">STATUS_INVALID_DEVICE_REQUEST</TD>
			<TD VALIGN="TOP">The request is invalid for this device</TD>
		</TR>

		<TR>
			<TD VALIGN="TOP">STATUS_END_OF_FILE</TD>
			<TD VALIGN="TOP">End-of-file marker reached</TD>
		</TR>
		
		<TR>
			<TD VALIGN="TOP">STATUS_DELETE_PENDING</TD>
			<TD VALIGN="TOP">The device is in the process of being removed from the system</TD>
		</TR>
		
		<TR>
			<TD VALIGN="TOP">STATUS_INSUFFICIENT_RESOURCES</TD>
			<TD VALIGN="TOP">Not enough system resources (often memory) to perform an operation</TD>
		</TR>

	</TABLE>
</P>

<p>
<div class="note"><blockquote><b>NOTE</b> <hr>
Always be sure to consult the DDK documentation for the correct setting of
IoStatus.Information for the IRP you're dealing with. In some flavors of IRP_MJ_PNP, for
example, this field is used as a pointer to a data structure that the PnP Manager is
responsible for releasing. If you were to overstore the Information field with zero when
failing the request, you would unwittingly cause a resource leak.</blockquote></div>
</p>

<p>Since completing a request is something you do so often, I find it useful to have a helper
routine to carry out the mechanics:</p>

<p>
<table cellpadding=5 width="95%"><tr><td valign=top>
<pre>
NTSTATUS CompleteRequest(PIRP Irp, NTSTATUS status, ULONG_PTR Information)
  {
  Irp-&gt;IoStatus.Status = status;
  Irp-&gt;IoStatus.Information = Information;
  IoCompleteRequest(Irp, IO_NO_INCREMENT);
  return status;
  }</pre>
</td></tr>
</table>
</p>

<p>I defined this routine in such a way that it returns whatever status value you supply as its
second argument. That's because I'm such a lazy typist: the return value allows me to
use this helper whenever I want to complete a request and then immediately return a status
code. For example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td valign=top>
<pre>NTSTATUS DispatchControl(PDEVICE_OBJECT device, PIRP Irp)
  {
  PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
  ULONG code = stack-&gt;Parameters.DeviceIoControl.IoControlCode;
  if (code == IOCTL_TOASTER_BOGUS)
    return CompleteRequest(Irp, STATUS_INVALID_DEVICE_REQUEST, 0);
  ...
  }</pre>
</td></tr>
</table>
</p>

<p>You might notice that the <b>Information</b> argument to the <b>CompleteRequest</b> function
is typed as a ULONG_PTR. In other words, this value can be either a ULONG or a pointer to
something (and therefore potentially 64 bits wide).</p>

<p>When you call IoCompleteRequest, you supply a priority boost value to be applied to whatever
thread is currently waiting for this request to complete. You normally choose a boost value
that depends on the type of device, as suggested by the manifest constant names listed in Table
5-2. The priority adjustment improves the throughput of threads that frequently wait for I/O
operations to complete. Events for which the end user is directly responsible, such as keyboard
or mouse operations, result in greater priority boosts in order to give preference to
interactive tasks. Consequently, you want to choose the boost value with at least some care.
Don't use IO_SOUND_INCREMENT for absolutely every operation a sound card driver finishes,
for example&#8212;it's not necessary to apply this extraordinary priority increment to a
get-driver-version control request.</p>

<p><b>Table 5-2.</b> <i>Priority boost values for IoCompleteRequest.</i></p>

<P>
	<TABLE CELLPADDING=5 WIDTH="95%">		
	
		<TR>
			<TH><i>Manifest Constant</i></TH>
			<TH><i>Numeric Priority Boost</i></TH>
		</TR>
		
		<TR>
			<TD VALIGN="TOP">IO_NO_INCREMENT</TD>
			<TD VALIGN="TOP">0</TD>
		</TR>		
		
		<TR>
			<TD VALIGN="TOP">IO_CD_ROM_INCREMENT</TD>
			<TD VALIGN="TOP">1</TD>
		</TR>		
		
		<TR>
			<TD VALIGN="TOP">IO_DISK_INCREMENT</TD>
			<TD VALIGN="TOP">1</TD>
		</TR>		
		
		<TR>
			<TD VALIGN="TOP">IO_KEYBOARD_INCREMENT</TD>
			<TD VALIGN="TOP">6</TD>
		</TR>		
		
		<TR>
			<TD VALIGN="TOP">IO_MAILSLOT_INCREMENT</TD>
			<TD VALIGN="TOP">2</TD>
		</TR>		
		
		<TR>
			<TD VALIGN="TOP">IO_MOUSE_INCREMENT</TD>
			<TD VALIGN="TOP">6</TD>
		</TR>		
		
		<TR>
			<TD VALIGN="TOP">IO_NAMED_PIPE_INCREMENT</TD>
			<TD VALIGN="TOP">2</TD>
		</TR>		
		
		<TR>
			<TD VALIGN="TOP">IO_NETWORK_INCREMENT</TD>
			<TD VALIGN="TOP">2</TD>
		</TR>		
		
		<TR>
			<TD VALIGN="TOP">IO_PARALLEL_INCREMENT</TD>
			<TD VALIGN="TOP">1</TD>
		</TR>		
		
		<TR>
			<TD VALIGN="TOP">IO_SERIAL_INCREMENT</TD>
			<TD VALIGN="TOP">2</TD>
		</TR>		
		
		<TR>
			<TD VALIGN="TOP">IO_SOUND_INCREMENT</TD>
			<TD VALIGN="TOP">8</TD>
		</TR>		
		
		<TR>
			<TD VALIGN="TOP">IO_VIDEO_INCREMENT</TD>
			<TD VALIGN="TOP">1</TD>
		</TR>

	</TABLE>
</P>		

<p>Don't, by the way, complete an IRP with the special status code STATUS_PENDING. Dispatch 
routines often return STATUS_PENDING as their return value, but you should
never set <b>IoStatus.Status</b> to this value. Just to make sure, the checked build of
IoCompleteRequest generates an ASSERT failure if it sees STATUS_PENDING in the ending status.
Another popular value for people to use by mistake is apparently &quot;-1&quot;, which
doesn't have any meaning as an NTSTATUS code at all. There's a checked-build ASSERT to
catch that mistake, too.</p>


<A NAME="161"><H2>Using Completion Routines</H2></A>

<p>You often need to know the results of I/O requests that you pass down to lower levels of the
driver hierarchy or that you originate. To find out what happened to a request, you install a
<i>completion routine</i> by calling <b>IoSetCompletionRoutine</b>:</p>

<p>
<table cellpadding=5 width="95%"><tr><td valign=top>
<pre>IoSetCompletionRoutine(Irp, CompletionRoutine, context,
  InvokeOnSuccess, InvokeOnError, InvokeOnCancel);</pre>
</td></tr>
</table>
</p>

<p><b>Irp</b> is the request whose completion you want to know about. <b>CompletionRoutine</b> 
is the address of the completion routine you want called, and <b>context</b> is an arbitrary
pointer-sized value you want passed as an argument to the completion routine. The <b>
InvokeOn</b><i>Xxx</i> arguments are Boolean values indicating whether you want the completion
routine called in three different circumstances:</p>

<ul>

<p><li> <b>InvokeOnSuccess</b> means you want the completion routine called when something
completes the IRP with a status code that passes the NT_SUCCESS test.</li></p>

<p><li> <b>InvokeOnError</b> means you want the completion routine called when something
completes the IRP with a status code that does <i>not</i> pass the NT_SUCCESS test.</li></p>

<p><li> <b>InvokeOnCancel</b> means you want the completion routine called when something calls
IoCancelIrp before completing the IRP. I worded this quite delicately: IoCancelIrp will set the
Cancel flag in the IRP, and that's the condition that gets tested if you specify this
argument. A cancelled IRP might end up being completed with STATUS_CANCELLED (which would fail
the NT_SUCCESS test) or with any other status at all. If the IRP gets completed with an error
and you specified InvokeOnError, InvokeOnError by itself would cause your completion routine to
be called. Conversely, if the IRP gets completed without error and you specified
InvokeOnSuccess, InvokeOnSuccess by itself would cause your completion routine to be called. In
these cases, InvokeOnCancel would be redundant. But if you left out one or the other (or both)
of InvokeOnSuccess or InvokeOnError, the InvokeOnCancel flag would let you see the eventual
completion of an IRP whose Cancel flag had been set no matter what status is used for the
completion.</li></p>

</ul>

<p>At least one of these three flags must be TRUE. Note that IoSetCompletionRoutine is a macro,
so you want to avoid arguments that generate side effects. The three flag arguments and the
function pointer, in particular, are each referenced twice by the macro.</p>

<p>IoSetCompletionRoutine installs the completion routine address and context argument in the
<i>next</i> IO_STACK_LOCATION&#8212;that is, in the stack location in which the next lower
driver will find its parameters. Consequently, the lowest-level driver in a particular stack of
drivers does not dare attempt to install a completion routine. Doing so would be pretty futile,
of course, because&#8212;by definition of what it means to be the lowest-level
driver&#8212;there's no driver left to pass the request on to.</p>

<p>A completion routine looks like this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td valign=top>
<pre>NTSTATUS CompletionRoutine(PDEVICE_OBJECT device, PIRP Irp, PVOID context)
  {
  if (Irp-&gt;PendingReturned)
    IoMarkIrpPending(Irp);
  ...
  return <i>&lt;some status code&gt;</i>;
  }</pre>
</td></tr>
</table>
</p>

<p>It receives pointers to the device object and the IRP, and it also receives whatever context
value you specified in the call to IoSetCompletionRoutine. Completion routines are usually
called at DISPATCH_LEVEL and in an arbitrary thread context, but can be called at PASSIVE_LEVEL
or APC_LEVEL. To accommodate the usual case (DISPATCH_LEVEL), completion routines therefore
need to be in nonpaged memory and must call only service functions that are callable at
DISPATCH_LEVEL. To accommodate the possibility of being called at a lower IRQL, however, a
completion routine shouldn't call functions like <b>KeAcquireSpinLockAtDpcLevel</b> that
assume they're at DISPATCH_LEVEL to start with.</p>

<p>
<div class="note"><blockquote><b>NOTE</b> <hr>
The device object pointer argument to a completion routine is the value left in
the I/O stack location's DeviceObject pointer. IoCallDriver ordinarily sets this value.
People sometimes create an IRP with an extra stack location so that they can pass parameters to
a completion routine without creating an extra context structure. Such a completion routine
gets a NULL device object pointer unless the creator sets the DeviceObject field.</blockquote></div>
</p>


<A NAME="162"><H3>How Completion Routines Get Called</H3></A>

<p>IoCompleteRequest is responsible for calling all of the completion routines that drivers
installed in their respective stack locations. The way the process works, as shown in the
flowchart in Figure 5-7, is this: Something calls IoCompleteRequest to signal the end of
processing for the IRP. IoCompleteRequest then consults the current stack location to see
whether the driver <i>above</i> the current level installed a completion routine. If not, it
moves the stack pointer up one level and repeats the test. This process repeats until a stack
location is found that <i>does</i> specify a completion routine or until IoCompleteRequest
reaches the top of the stack. Then IoCompleteRequest takes steps that eventually result in
something releasing the memory occupied by the IRP (among other things).</p>

<p>When IoCompleteRequest finds a stack frame with a completion routine pointer, it calls that
routine and examines the return code. If the return code is anything other than
STATUS_MORE_PROCESSING_REQUIRED, IoCompleteRequest moves the stack pointer up one level and
continues as before. If the return code is STATUS_MORE_PROCESSING_REQUIRED, however, IoCompleteRequest 
stops dead in its tracks and returns to its caller. The IRP will then be in a sort of limbo state. 
The driver whose completion routine halted the stack unwinding process is expected to do more work 
with the IRP.</p>

<p>Within a completion routine, a call to IoGetCurrentIrpStackLocation will retrieve the same
stack pointer as was current when something called IoSetCompletionRoutine to install the
completion routine pointer. In other words, it returns the stack location above the one which
contains the actual pointer to this completion routine. You should not rely in a completion
routine on the contents of any lower stack location. To reinforce this rule, IoCompleteRequest
zeroes most of the next location just before calling a completion routine.</p>

<p>
<A HREF="javascript:fullSize('F05wi07x.htm')"> <img src="images/F05wi07.JPG" width=404 height=439 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 5-7.</b> <i>Logic of IoCompleteRequest.</i><!--/caption-->
</p>



<A NAME="163"><H3>Why Completion Routines Call IoMarkIrpPending</H3></A>

<p>You may have noticed these two lines at the beginning of the skeleton completion routine I
just showed you:</p>

<p>
<table cellpadding=5 width="95%"><tr><td valign=top>
<pre>
if (Irp-&gt;PendingReturned)
  IoMarkIrpPending(Irp);</pre>
</td></tr>
</table>
</p>

<p>This particular piece of boilerplate is required in any completion routine that doesn't
return STATUS_MORE_PROCESSING_REQUIRED. If you'd like to know why, read the rest of this
section. However, be aware that you should not develop drivers that rely on the information
related to how the I/O Manager processes pending IRPs&#8212;that process is likely to change in
future versions of Windows.</p>
<p>
<img src="images/nerdalert.JPG" width=73 height=54 alt="" border="0">
</p>
<P><DIV CLASS="NOTE"><BLOCKQUOTE>
This explanation is complicated!
</BLOCKQUOTE></DIV>
</P>


<p>To maximize system throughput, the I/O Manager expects drivers to defer the completion of
IRPs that take a long time to complete. A driver indicates that completion will be deferred by
calling <b>IoMarkIrpPending</b> and returning STATUS_PENDING from the dispatch routine. Often,
though, the original caller of the I/O Manager wants to wait until the operation finishes
before proceeding. The I/O Manager will therefore have logic similar to this (not the actual
source code of any particular Microsoft Windows NT function) to deal with the deferred
completion:</p>

<p>
<table cellpadding=5 width="95%"><tr><td valign=top>
<pre>Irp-&gt;UserEvent = pEvent; // <img src="images/tlarrow.jpg" width=13 height=12 border="0"> don't do this yourself
status = IoCallDriver(...);
if (status == STATUS_PENDING)
  KeWaitForSingleObject(pEvent, ...);</pre>
</td></tr>
</table>
</p>

<p>In other words, if IoCallDriver returns STATUS_PENDING, this code will wait on a kernel
event. IoCompleteRequest is responsible for setting this event when the IRP finally completes.
The address of the event (<b>UserEvent</b> ) is in one of the opaque fields of the IRP so that
IoCompleteRequest can find it. But there's more to the story than that.</p>

<p>To keep things simple for the moment, suppose that there were just one driver involved in
processing this request. Its dispatch function does the two things we've discussed: it
calls IoMarkIrpPending, and it returns STATUS_PENDING. That status code will be the return
value from IoCallDriver as well, so you can see that something is now going to wait on an
event. The eventual call to IoCompleteRequest occurs in an arbitrary thread context, so
IoCompleteRequest will schedule a <i>special kernel APC</i> to execute in the context of the
original thread (which is currently blocked). The APC (asynchronous procedure call) routine
will set the event, thereby releasing whatever is waiting for the operation to finish. There
are reasons we don't need to go into right now for why an APC is used for this purpose
instead of a simple call to <b>KeSetEvent</b>.</p>

<p>But queuing an APC is relatively expensive. Suppose that, instead of returning
STATUS_PENDING, the dispatch routine were to call IoCompleteRequest and return some other
status. In this case, the call to IoCompleteRequest is in the same thread context as the caller
of IoCallDriver. It's not necessary to queue an APC, therefore. Furthermore, it's not
even necessary to call KeSetEvent since the I/O Manager isn't going to be waiting on an
event if it doesn't get STATUS_PENDING back from the dispatch routine. If IoCompleteRequest
just had a way to know this case were occurring, it could optimize its processing to avoid the
APC, couldn't it? That's where IoMarkIrpPending comes in.</p>

<p>What IoMarkIrpPending does&#8212;it's a macro in WDM.H, so you can see this for
yourself&#8212;is set a flag named SL_PENDING_RETURNED in the current stack location.
IoCompleteRequest will set the IRP's <b>PendingReturned</b> flag equal to whatever value it
finds in the topmost stack location. Later on, it inspects this flag to see whether the
dispatch routine has returned or will return STATUS_PENDING. If you do your job correctly, it
won't matter whether the return from the dispatch routine happens before or after
IoCompleteRequest makes this determination. &quot;Doing your job correctly,&quot; in this
particular case, means calling IoMarkIrpPending before you do anything that might result in the
IRP getting completed.</p>

<p>So, anyway, IoCompleteRequest looks at the PendingReturned flag. If it's set, and if the
IRP in question is of the kind that normally gets completed asynchronously, IoCompleteRequest
simply returns to its caller <i>without</i> queuing the APC. It assumes that it's running
in the originator's thread context and that some dispatch routine is shortly going to
return a nonpending status code to the originator. The originator, in turn, avoids waiting for
the event, which is just as well because no one is ever going to signal that event. So far, so
good.</p>

<p>Now let's put some additional drivers into the picture. The top-level driver has no clue
what will happen below it. It simply passes the request down using code such as the following.
(See the next section, &quot;<A HREF="ch05e.htm#164">Passing Requests Down to Lower Levels</A>.&quot;)</p>

<p>
<table cellpadding=5 width="95%"><tr><td valign=top>
<pre>
IoCopyCurrentIrpStackLocationToNext(Irp);
IoSetCompletionRoutine(Irp, ...);
return IoCallDriver(...);
</pre>
</td></tr>
</table>
</p>

<p>In other words, the top-level driver installs a completion routine, calls IoCallDriver, and
then returns whatever status code IoCallDriver happens to return. This process might now repeat
additional times as other drivers pass the request down to whatever is really destined to
service it. When the request reaches that level, the dispatch routine calls IoMarkIrpPending
and returns STATUS_PENDING. The STATUS_PENDING value then percolates all the way back up to the
top and out into the originator of the IRP, which will promptly decide to wait for something to
signal the event.</p>

<p>But notice that the driver that called IoMarkIrpPending only managed to set SL_PENDING_RETURNED
in its own stack location. The drivers above it actually returned STATUS_PENDING, but they
didn't call IoMarkIrpPending on their own behalf because they didn't know they'd
end up returning STATUS_PENDING as proxies for the guy at the bottom of the stack. Sorting this
out is where the boilerplate code in the completion routine comes in, as follows. As
IoCompleteRequest walks up the I/O stack, it pauses at each level to set the IRP's
PendingReturned flag to the value of the current stack's SL_PENDING_RETURNED flag. If
there's no completion routine at this level, it then sets the next higher stack's
SL_PENDING_RETURNED if PendingReturned is set and repeats its loop. It doesn't change
SL_PENDING_RETURNED if PendingReturned is clear. In this way, SL_PENDING_RETURNED gets
propagated from the bottom to the top of the stack, and the IRP's PendingReturned flag ends
up TRUE if any of the drivers ever called IoMarkIrpPending.</p>

<p>IoCompleteRequest does <i>not</i> automatically propagate SL_PENDING_RETURNED across a
completion routine, however. The completion routine must do this itself by testing the
IRP's PendingReturned flag (that is, did the driver below me return STATUS_PENDING?) and
then calling IoMarkIrpPending. If every completion routine does its job, the
SL_PENDING_RETURNED flag makes its way to the top of the stack just as if IoCompleteRequest had
done all of its work.</p>

<p>Now that I've explained these intricacies, you can see why it's important for
dispatch routines to call IoMarkIrpPending if they're going to explicitly return
STATUS_PENDING and why completion routines should conditionally do so. If a completion routine
were to break the chain, you'd end up with a thread waiting in vain on an event that's
destined never to be signalled. Failing to see PendingReturned, IoCompleteRequest would act as
if it were dealing with a same-context completion and therefore would not queue the APC
that's supposed to signal the event. The same thing would happen if a dispatch routine were
to omit the IoMarkIrpPending call and then return STATUS_PENDING.</p>

<p>On the other hand, it's okay, albeit slightly inefficient, to call IoMarkIrpPending and
then complete the IRP synchronously. All that will happen is that IoCompleteRequest will queue
an APC to signal an event on which no one will ever wait. (Logic is in place to make sure that
the event object can't cease to exist before the call to KeSetEvent, too.) This is slower
than need be, but it's not harmful.</p>

<p>Do not, by the way, be tempted, in the hope of avoiding the boilerplate call to
IoMarkIrpPending inside your completion routine, to code like this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td valign=top>
<pre>
status = IoCallDriver(...);
if (status == STATUS_PENDING)
  IoMarkIrpPending(...);     // <img src="images/tlarrow.jpg" width=13 height=12 border="0"> DON'T DO THIS!</pre>
</td></tr>
</table>
</p>

<p>The reason this is a bad idea is that you must treat the IRP pointer as poison after you
give it away by calling IoCallDriver. Whatever receives the IRP can complete it, allowing
something to call <b>IoFreeIrp</b>, which will render your pointer invalid long before you
regain control from IoCallDriver.</p>


</BODY>
</HTML>





