<HTML>
<HEAD>
<TITLE>Addressing a Data Buffer</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch07b.htm">[Previous]</A> <A HREF="ch07d.htm">[Next]</a>
</p>

<A NAME="228"><H1>Addressing a Data Buffer</H1></A>

<p>When an application initiates a read or write operation, it provides a data buffer by giving
the I/O Manager a user-mode virtual address and length. As I said back in Chapter 3,
&quot;<A HREF="ch03a.htm#65">Basic Programming Techniques</A>,&quot; a kernel driver hardly ever accesses memory using a
user-mode virtual address because, in general, you can't pin down the thread context with
certainty. Microsoft Windows 2000 gives you three ways to access a user-mode data buffer:</p>

<ul>
<p><li> In the <i>buffered</i> method, the I/O Manager creates a system buffer equal in size to
the user-mode data buffer. You work with this system buffer. The I/O Manager takes care of
copying data between the user-mode buffer and the system buffer.</li></p>

<p><li> In the <i>direct</i> method, the I/O Manager locks the physical pages containing the
user-mode buffer and creates an auxiliary data structure called a memory descriptor list (MDL)
to describe the locked pages. You work with the MDL.</li></p>

<p><li> In the <i>neither</i> method, the I/O Manager simply passes the user-mode virtual address
to you. You work&#8212;very carefully!&#8212;with the user-mode address.</li></p>
</ul>


<p>Figure 7-2 illustrates the first two methods. The last method, of course, is kind of a
nonmethod in that the system doesn't do anything to help you reach your data.</p>

<p>
<A HREF="javascript:fullSize('F07wi02x.htm')"> <img src="images/F07wi02.JPG" width=404 height=300 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 7-2.</b> <i>Accessing user-mode data buffers.</i><!--/caption-->
</p>


<A NAME="229"><H2>Specifying a Buffering Method</H2></A>

<p>You specify your device's buffering method for reads and writes by setting certain flag
bits in your device object shortly after you create it in your <b>AddDevice</b> function:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>NTSTATUS AddDevice(...)
  {
  PDEVICE_OBJECT fdo;
  IoCreateDevice(..., &amp;fdo);
  fdo-&gt;Flags |= DO_BUFFERED_IO;
           <i>&lt;or&gt;</i>
  fdo-&gt;Flags |= DO_DIRECT_IO;
           <i>&lt;or&gt;</i>
  fdo-&gt;Flags |= 0; // i.e., neither direct nor buffered
  }</pre>
</td></tr>
</table>
</p>

<p>You can't change your mind about the buffering method afterward. Filter drivers might
copy this flag setting and will have no way to know if you <i>do</i> change your mind and
specify a different buffering method.</p>

<A NAME="230"><H3>The Buffered Method</H3></A>

<p>When the I/O Manager creates an IRP_MJ_READ or IRP_MJ_WRITE request, it inspects the direct
and buffered flags to decide how to describe the data buffer in the new I/O request packet
(IRP). If DO_BUFFERED_IO is set, the I/O Manager allocates nonpaged memory equal in size to the
user buffer. It saves the address and length of the buffer in two wildly different places, as
shown in boldface in the following code fragment. You can imagine the I/O Manager code being
something like this&#8212;this is not the actual Microsoft Windows NT source code.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>PVOID uva;             // <img src="images/tlarrow.jpg" width=13 height=12 border="0"> user-mode virtual buffer address
ULONG length;          // <img src="images/tlarrow.jpg" width=13 height=12 border="0"> length of user-mode buffer

PVOID sva; = ExAllocatePoolWithQuota(NonPagedPoolCacheAligned, length);
if (writing)
  RtlCopyMemory(sva, uva, length);

<b>Irp-&gt;AssociatedIrp.SystemBuffer = sva;</b> 

PIO_STACK_LOCATION stack = IoGetNextIrpStackLocation(Irp);
if (reading)
  <b>stack-&gt;Parameters.Read.Length = length;</b> 
else
<b>  stack-&gt;Parameters.Write.Length = length;</b> 

<i>&lt;code to send and await IRP&gt;</i>

if (reading)
  RtlCopyMemory(uva, sva, length);

ExFreePool(sva);</pre>
</td></tr>
</table>
</p>

<p>In other words, the system (copy) buffer address is in the IRP's <b>
AssociatedIrp.SystemBuffer</b> field, and the request length is in the <b>
stack-&gt;Parameters</b> union. This process includes additional details that you and I
don't need to know to write drivers. For example, the copy that occurs after a successful
read operation actually happens during an asynchronous procedure call (APC) in the original
thread context and in a different subroutine than the one that constructs the IRP. The I/O
Manager saves the user-mode virtual address (my <b>uva</b> variable in the preceding fragment)
in the IRP's <b>UserBuffer</b> field so that the copy step can find it. Don't count on
either of these facts, though&#8212;they're subject to change at any time.<br>
The I/O Manager also takes care of releasing the free storage obtained for the system copy
buffer when something eventually completes the IRP.</p>

<A NAME="231"><H3>The Direct Method</H3></A>

<p>If you specified DO_DIRECT_IO in the device object, the I/O Manager creates a MDL to
describe locked pages containing the user-mode data buffer. The MDL structure has the following
declaration:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>typedef struct _MDL {
  struct _MDL *Next;
  CSHORT Size;
  CSHORT MdlFlags;
  struct _EPROCESS *Process;
  PVOID MappedSystemVa;
  PVOID StartVa;
  ULONG ByteCount;
  ULONG ByteOffset;
  } MDL, *PMDL;</pre>
</td></tr>
</table>
</p>

<p>Figure 7-3 illustrates the role of the MDL. The <b>StartVa</b> member gives the virtual
address&#8212;valid only in the context of the user-mode process that owns the data&#8212;of the
buffer. <b>ByteOffset</b> is the offset of the beginning of the buffer within a page frame, and
<b>ByteCount</b> is the size of the buffer in bytes. The <b>Pages</b> array, which is not
formally declared as part of the MDL structure, follows the MDL in memory and contains the
numbers of the physical page frames to which the user-mode virtual addresses map.<br>

<p>
<A HREF="javascript:fullSize('F07wi03x.htm')"> <img src="images/F07wi03.JPG" width=404 height=339 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 7-3.</b> <i>The memory descriptor list structure.</i><!--/caption-->
</p>


<p>We never, by the way, access members of an MDL structure directly. We use macros and support
functions instead&#8212;see Table 7-2.</p>

<p><b>Table 7-2.</b> <i>Macros and support functions for accessing an MDL.</i></p>

<table cellpadding="5" width="95%">
<tr><th><i>Macro or Function</i></th><th><i>Description</i></th></tr>
<tr><td valign="top">IoAllocateMdl</td><td valign="top">Creates an MDL</td></tr>
<tr><td valign="top">IoBuildPartialMdl</td><td valign="top">Builds an MDL for a subset of an existing MDL</td></tr>
<tr><td valign="top">IoFreeMdl</td><td valign="top">Destroys an MDL</td></tr>
<tr><td valign="top">MmBuildMdlForNonPagedPool</td><td valign="top">Modifies an MDL to describe a region of kernel-mode nonpaged memory</td></tr>
<tr><td valign="top">MmGetMdlByteCount</td><td valign="top">Determines byte size of buffer</td></tr>
<tr><td valign="top">MmGetMdlByteOffset</td><td valign="top">Gets buffer offset within first page</td></tr>
<tr><td valign="top">MmGetMdlVirtualAddress</td><td valign="top">Gets virtual address</td></tr>
<tr><td valign="top">MmGetPhysicalAddress</td><td valign="top">Gets physical address corresponding to a virtual address within the MDL-described region</td></tr>
<tr><td valign="top">MmGetSystemAddressForMdl</td><td valign="top">Creates a kernel-mode virtual address that maps to the same locations in memory</td></tr>
<tr><td valign="top">MmGetSystemAddressForMdlSafe</td><td valign="top">Same as MmGetSystemAddressForMdl but preferred in Windows 2000</td></tr>
<tr><td valign="top">MmInitializeMdl</td><td valign="top">(Re)initializes an MDL to describe a given virtual buffer</td></tr>
<tr><td valign="top">MmPrepareMdlForReuse</td><td valign="top">Reinitializes an MDL</td></tr>
<tr><td valign="top">MmProbeAndLockPages</td><td valign="top">Locks pages after verifying address validity</td></tr>
<tr><td valign="top">MmSizeOfMdl</td><td valign="top">Determines how much memory would be needed to create an MDL to describe a given virtual buffer</td></tr>
<tr><td valign="top">MmUnlockPages</td><td valign="top">Unlocks the pages for this MDL</td></tr>
</table>

<p>You can imagine the I/O Manager executing code like the following to perform a direct-method
read or write:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>KPROCESSOR_MODE mode;   // <img src="images/tlarrow.jpg" width=13 height=12 border="0"> either KernelMode or UserMode
PMDL mdl = IoAllocateMdl(uva, length, FALSE, TRUE, Irp);
<b>MmProbeAndLockPages(mdl, mode,
  reading ? IoWriteAccess : IoReadAccess);</b> 

<i>&lt;code to send and await IRP&gt;</i>

MmUnlockPages(mdl);
ExFreePool(mdl);</pre>
</td></tr>
</table>
</p>

<p>The I/O Manager first creates an MDL to describe the user buffer. The third argument to <b>
IoAllocateMdl</b> (FALSE) indicates this is the primary data buffer. The fourth argument (TRUE)
indicates that the Memory Manager should charge the process quota. The last argument
(<b>Irp</b>) specifies the IRP to which this MDL should be attached. Internally, IoAllocateMdl
sets <b>Irp-&gt;MdlAddress</b> to the address of the newly created MDL, which is how you find
it and how the I/O Manager eventually finds it so as to clean up.</p>

<p>The key event in this code sequence is the call to <b>MmProbeAndLockPages</b>, shown in
boldface. This function verifies that the data buffer is valid and can be accessed in the
appropriate mode. If we're writing to the device, we must be able to read the buffer. If
we're reading from the device, we must be able to write to the buffer. In addition, the
function locks the physical pages containing the data buffer and fills in the array of page
numbers that follows the MDL proper in memory. In effect, a locked page becomes part of the
nonpaged pool until as many callers unlock it as locked it in the first place.</p>

<p>The thing you'll most likely do with an MDL in a direct-method read or write is to pass it
as an argument to something else. DMA transfers, for example, require an MDL for the <b>
MapTransfer</b> step you'll read about later in this chapter in &quot;<A HREF="ch07f.htm#252">Performing DMA Transfers</A>.&quot; Universal serial bus (USB) reads and writes, to give another example, always
work internally with an MDL, so you might as well specify DO_DIRECT_IO and pass the resulting
MDLs along to the USB bus driver.</p>

<P>Incidentally, the I/O Manager does save the read or write request length in the
stack-&gt;Parameters union. It's nonetheless customary for drivers to learn the request
length directly from the MDL:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>ULONG length = MmGetMdlByteCount(mdl);</pre>
</td></tr>
</table>
</p>

<A NAME="232"><H3>The Neither Method</H3></A>

<p>If you omit both the DO_DIRECT_IO and DO_BUFFERED_IO flags in the device object, you get the
neither method by default. The I/O Manager simply gives you a user-mode virtual address and a
byte count (as shown in boldface) and leaves the rest to you:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre><b>Irp-&gt;UserBuffer = uva;</b> 
PIO_STACK_LOCATION stack = IoGetNextIrpStackLocation(Irp);
if (reading)
  <b>stack-&gt;Parameters.Read.Length = length;</b> 
else
<b>  stack-&gt;Parameters.Write.Length = length;</b> 

<i>&lt;code to send and await IRP&gt;</i></pre>
</td></tr>
</table>
</p>

</BODY>
</HTML>





