<HTML>
<HEAD>
<TITLE>Specifying the Base Address of a Memory-Mapped File</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch17f.htm">[Previous]</A> <A HREF="ch17h.htm">[Next]</A><P>

<A NAME="227"><H1>Specifying the Base Address of a Memory-Mapped File</H1></A>

<p>Just as you can use the <i>VirtualAlloc</i> function to suggest an
initial address to reserve address space, you can also use the <i>
MapViewOfFileEx</i> function instead of the <i>MapViewOfFile</i>
function to suggest that a file be mapped into a particular
address.</p>

<p><table width="95%" cellpadding="5"><tr><td>
<pre>
PVOID MapViewOfFileEx(
   HANDLE hFileMappingObject, 
   DWORD dwDesiredAccess,
   DWORD dwFileOffsetHigh, 
   DWORD dwFileOffsetLow,
   SIZE_T dwNumberOfBytesToMap, 
   PVOID pvBaseAddress);
</pre></td></tr></table></p>

<p>All the parameters and the return value for this function are
identical to those of the <i>MapViewOfFile</i> function with the single
exception of the last parameter, <i>pvBaseAddress</i>. In this
parameter, you specify a target address for the file you're
mapping. As with <i>VirtualAlloc</i>, the target address you specify
should be on an allocation granularity boundary (64 KB); otherwise, <i>
MapViewOfFileEx</i> returns NULL, indicating an error.</p>

<p>Under Windows 2000, specifying an address that is not a multiple of the
allocation granularity causes the function to fail, and <i>
GetLastError</i> will return 1132 (ERROR_MAPPED_ALIGNMENT). In Windows
98, the address will be rounded down to an allocation granularity
boundary.</p>

<p>If the system can't map the file at this location (usually because
the file is too large and would overlap another reserved address
space), the function fails and returns NULL. <i>MapViewOfFileEx</i>
does not attempt to locate another address space that can accommodate
the file. Of course, you can specify NULL as the <i>pvBaseAddress</i>
parameter, in which case <i>MapViewOfFileEx</i> behaves exactly the
same as <i>MapViewOfFile</i>.</p>

<p><i>MapViewOfFileEx</i> is useful when you're using memory-mapped
files to share data with other processes. As an example, you might need
a memory-mapped file at a particular address when two or more
applications are sharing a group of data structures containing pointers
to other data structures. A linked list is a perfect example. In a
linked list, each node, or element, of the list contains the memory
address of another element in the list. To walk the list, you must know
the address of the first element and then reference the member of the
element that contains the address of the next element. This can be a
problem when you're using memory-mapped files.</p>

<p>If one process prepares the linked list in a memory-mapped file and
then shares this file with another process, it is possible that the
other process will map the file into a completely different location in
its address space. When the second process attempts to walk the linked
list, it looks at the first element of the list, retrieves the memory
address of the next element, and then tries to reference this next
element. However, the address of the next element in the first node
will be incorrect for this second process.</p>

<p>You can solve this problem in two ways. First, the second process can
simply call <i>MapViewOfFileEx</i> instead of <i>MapViewOfFile</i> when
it maps the memory-mapped file containing the linked list into its own
address space. Of course, this method requires that the second process
know where the first process originally mapped the file when
constructing the linked list. When the two applications have been
designed to interact with each other&#8212;which is most likely the
case&#8212;this isn't a problem: the address can be hard-coded into
both, or one process can notify the other process using another form of
interprocess communication, such as sending a message to a window.</p>

<p>The second method for solving the problem is for the process that
creates the linked list to store in each node the offset from within
the address space where the next node is located. This requires that
the application add the offset to the base address of the memory-mapped
file in order to access each node. This method is not great: it can be
slow, it makes the program bigger (because of the additional code the
compiler generates to perform all the calculations), and it can be
quite error prone. However, it is certainly a viable method, and the
Microsoft compiler offers assistance for based-pointers using the 
<i>_ _based</i> keyword.</p>

<p><div class="note"><blockquote><b>Windows 98</b><hr>
When calling <i>MapViewOfFileEx</i>, you must specify an address that is
between 0x80000000 and 0xBFFFFFFF, or <i>MapViewOfFileEx</i> will
return NULL.</blockquote></div></p>

<p><div class="note"><blockquote><b>Windows 2000</b><hr>
When calling <i>MapViewOfFileEx</i>, you must specify an address that
is in your process's user-mode partition, or <i>MapViewOfFileEx</i>
will return NULL.</blockquote></div></p>

</BODY>
</HTML>






