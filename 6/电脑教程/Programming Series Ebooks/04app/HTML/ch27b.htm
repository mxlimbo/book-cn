<HTML>
<HEAD>
<TITLE>The Raw Input Thread</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch27a.htm">[Previous]</A> <A HREF="ch27c.htm">[Next]</A><P>

<A NAME="360"><H1>The Raw Input Thread</H1></A>

<p>Figure 27-1 summarizes the system's hardware input model. When
the system initializes, it creates a special thread known as the <i>raw input thread</i> (RIT). In addition, the system creates a queue called the <i>system hardware input queue</i> (SHIQ). The RIT and the SHIQ compose the heart of the system's hardware input model.</p>

<p>The RIT usually sleeps, waiting for an entry to appear in the SHIQ. When the user presses and releases a key, presses and releases a mouse button, or moves the mouse, the device driver for the hardware device appends a hardware event to the SHIQ, which wakes up the RIT. The RIT then extracts the entry from the SHIQ and translates the event into the appropriate WM_KEY*, WM_?BUTTON*, or WM_MOUSEMOVE message. The translated message is then appended to the appropriate thread's virtualized input queue (VIQ) (discussed in <A HREF="ch26a.htm">Chapter 26</A>). The RIT then loops back to wait for more messages to appear in the SHIQ. Because the RIT executes code written only by Microsoft&#8212;and because this code
is heavily tested&#8212;the RIT can never stop responding to hardware input events.</p>

<p>So how does the RIT know which thread's virtualized input queue to append the hardware input messages to? Well, for mouse messages, the RIT simply determines which window is under the mouse cursor. Using the window, the RIT calls <i>GetWindowThreadProcessId</i> to find out which thread created the window. The thread ID returned identifies which thread gets the mouse message.</p>

<p>Things work a bit differently for keystroke hardware events. At any given time, one thread is &quot;connected&quot; to the RIT. This thread is called the <i>foreground thread</i> because it created the window that the user is interacting with and this thread's windows are in the foreground with respect to windows created by other threads.</p>

<p>
<A HREF="javascript:fullSize('F27si01x.htm')"> <img src="images/F27si01.JPG" width=404 height=333 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><b>Figure 27-1.</b> <i>The system's hardware input model</i><!-- /CAPTION -->
</p>

<p>When a user logs on to the system, the Windows Explorer process has a thread that creates the taskbar and the desktop. This thread is connected to the RIT. If you now spawn Calculator, it has a thread that creates a window, and this thread becomes connected to the RIT. Note that Windows Explorer's thread is no longer connected to the RIT since the RIT can only have one thread connected to it at a time. So now, when a keystroke message enters the SHIQ, the RIT simply wakes up, translates the event into the appropriate keystroke message, and places the message in the connected thread's virtualized input queue.</p>

<p>So how do different thread's get connected to the RIT? Well, as I've just explained, when a process is spawned, this process's
thread can create a window. This window comes to the foreground and its thread gets connected to the RIT. In addition, the RIT is responsible for handling special key sequences such as Alt+Tab, Alt+Esc, and Ctrl+Alt+Del. Since the RIT handles these key sequences internally, users are guaranteed that they can always activate windows with the keyboard; there is no way for an application to intercept and discard these key sequences. When the user presses one of the special key sequences, the RIT activates the selected window and connects its thread to the RIT. Windows also offers functions that activate a window, causing the window's thread to be connected to the RIT. These functions will be discussed later in this chapter.</p>

<p>From Figure 27-1, you can see how threads are protected from one another. If the RIT dispatches a message for Window B1 or Window B2, the message goes in Thread B's virtualized input queue. When processing the message, Thread B could enter an infinite loop or deadlock while synchronizing on a kernel object. If this happens, Thread B is still connected to the RIT and more messages might be appended to Thread B's virtualized input queue.</p>

<p>However, the user will probably notice that both Windows B1 and B2 are not responding and might want to switch to Window A1. To make the switch, the user presses Alt+Tab. Since the RIT handles the Alt+Tab keystroke combination, the user can always switch to another window without a problem. After selecting Window A1, Thread A is connected to the RIT. At this point, the user can enter input into Window A1 even though Thread B and both its windows are not responding.</p>

</BODY>
</HTML>






