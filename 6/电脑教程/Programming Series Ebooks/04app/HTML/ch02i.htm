<HTML>
<HEAD>
<TITLE>How to Write Unicode Source Code</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch02h.htm">[Previous]</A> <A HREF="ch02j.htm">[Next]</A><P>

<A NAME="15"><H1>How to Write Unicode Source Code</H1></A>

<p>Microsoft designed the Windows API for Unicode so that it would have
as little impact on your code as possible. In fact, it is possible to
write a single source code file so that it can be compiled with or
without using Unicode&#8212;you need only define two macros (UNICODE and
_UNICODE) to make the change and then recompile.</p>

<A NAME="16"><H2>Unicode Support in the C Run-Time Library</H2></A>

<p>To take advantage of Unicode character strings, some data types have
been defined. The standard C header file, String.h, has been modified
to define a data type named <i>wchar_t</i>, which is the data type of a
Unicode character:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef unsigned short wchar_t;
</pre></td></tr></table></p>

<p>For example, if you want to create a buffer to hold a Unicode string
of up to 99 characters and a terminating zero character, you can use
the following statement:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
wchar_t szBuffer[100];
</pre></td></tr></table></p>

<p>This statement creates an array of one hundred 16-bit values. Of
course, the standard C run-time string functions, such as <i>
strcpy</i>, <i>strchr</i>, and <i>strcat</i>, operate on ANSI strings
only; they don't correctly process Unicode strings. So, ANSI C also
has a complementary set of functions. Figure 2-1 shows some of the
standard ANSI C string functions followed by their equivalent Unicode
functions.</p>

<p><b>Figure 2-1.</b> <i>Standard ANSI C string functions and their Unicode equivalents</i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
char * strcat(char *, const char *);
wchar_t * wcscat(wchar_t *, const wchar_t *);

char * strchr(const char *, int);
wchar_t * wcschr(const wchar_t *, wchar_t);

int strcmp(const char *, const char *);
int wcscmp(const wchar_t *, const wchar_t *);

char * strcpy(char *, const char *);
wchar_t * wcscpy(wchar_t *, const wchar_t *);
 
size_t strlen(const char *);
size_t wcslen(const wchar_t *);
</pre></td></tr></table></p>

<p>Notice that all the Unicode functions begin with <i>wcs</i>, which
stands for <i>wide character string</i>. To call the Unicode function,
simply replace the <i>str</i> prefix of any ANSI string function with
the <i>wcs</i> prefix. 
</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>
One very important point that most developers don't
remember is that the C run-time library provided by Microsoft conforms
to the ANSI standard C run-time library. ANSI C dictates that the C
run-time library supports Unicode characters and strings. This means
that you can always call C run-time functions to manipulate Unicode
characters and strings&#8212;even if you're running on Windows 98.
In other words, <i>wcscat</i>, <i>wcslen</i>, <i>wcstok</i>, and so on
all work just fine on Windows 98; it's the operating system
functions you need to worry about.</blockquote></div></p>

<p>Code that includes explicit calls to either the <i>str</i> functions
or the <i>wcs</i> functions cannot be compiled easily for both ANSI and
Unicode. Earlier in this chapter, I said that it's possible to make
a single source code file that can be compiled for both. To set up the
dual capability, you include the TChar.h file instead of including
String.h.</p>

<p>TChar.h exists for the sole purpose of helping you create
ANSI/Unicode generic source code files. It consists of a set of macros
that you should use in your source code instead of making direct calls
to either the <i>str</i> or the <i>wcs</i> functions. If you define
_UNICODE when you compile your source code, the macros reference the
<i>wcs</i> set of functions. If you do not define _UNICODE, the macros
reference the <i>str</i> set of functions.</p>

<p>For example, there is a macro called <i>_tcscpy</i> in TChar.h. If
_UNICODE is not defined when you include this header file, <i>
_tcscpy</i> expands to the ANSI <i>strcpy</i> function. However, if
_UNICODE is defined, <i>_tcscpy</i> expands to the Unicode <i>
wcscpy</i> function. All C run-time functions that take string
arguments have a generic macro defined in TChar.h. If you use the
generic macros instead of the ANSI/Unicode specific function names,
you'll be well on your way to creating source code that can be
compiled natively for ANSI or Unicode.</p>

<p>Unfortunately, you need to do a little more work than just use these
macros. TChar.h includes some additional macros.</p>

<p>To define an array of string characters that is ANSI/Unicode
generic, use the following TCHAR data type. If _UNICODE is defined,
TCHAR is declared as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef wchar_t TCHAR;
</pre></td></tr></table></p>

<p>If _UNICODE is not defined, TCHAR is declared as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef char TCHAR;
</pre></td></tr></table></p>

<p>Using this data type, you can allocate a string of characters as
follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
TCHAR szString[100];
</pre></td></tr></table></p>

<p>You can also create pointers to strings:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
TCHAR *szError = &quot;Error&quot;;
</pre></td></tr></table></p>

<p>However, there is a problem with the previous line. By default,
Microsoft's C++ compiler compiles all strings as though they were
ANSI strings, not Unicode strings. As a result, the compiler will
compile this line correctly if _UNICODE is not defined, but will
generate an error if _UNICODE is defined. To generate a Unicode string
instead of an ANSI string, you would have to rewrite the line as
follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
TCHAR *szError = L&quot;Error&quot;;
</pre></td></tr></table></p>

<p>An uppercase <i>L</i> before a literal string informs the compiler
that the string should be compiled as a Unicode string. When the
compiler places the string in the program's data section, it
intersperses zero bytes between every character. The problem with this
change is that now the program will compile successfully only if
_UNICODE is defined. We need another macro that selectively adds the
uppercase <i>L</i> before a literal string. This is the job of the
_TEXT macro, also defined in TChar.h. If _UNICODE is defined, _TEXT is
defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
#define _TEXT(x) L ## x
</pre></td></tr></table></p>

<p>If _UNICODE is not defined, _TEXT is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
#define _TEXT(x) x
</pre></td></tr></table></p>

<p>Using this macro, we can rewrite the line above so that it compiles
correctly whether or not the _UNICODE macro is defined, as shown
here:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
TCHAR *szError = _TEXT(&quot;Error&quot;);
</pre></td></tr></table></p>

<p>The _TEXT macro can also be used for literal characters. For
example, to check whether the first character of a string is an
uppercase <i>J,</i> write the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
if (szError[0] == _TEXT('J')) {
   // First character is a 'J'
   
<img src="images/grayvellip.JPG" width=3 height=13 border="0">

} else {
   // First character is not a 'J'
  
<img src="images/grayvellip.JPG" width=3 height=13 border="0">

}
</pre></td></tr></table></p>

<A NAME="17"><H2>Unicode Data Types Defined by Windows</H2></A>

<p>The Windows header files define the data types listed in the
following table.</p>

<p><table cellpadding=5 width="95%"><tr>
<th>Data Type</th>
<th>Description</th>
</tr>
<tr>
<td valign="top">WCHAR</td>
<td valign="top">Unicode character</td>
</tr>
<tr>
<td valign="top">PWSTR</td>
<td valign="top">Pointer to a Unicode string</td>
</tr>
<tr>
<td valign="top">PCWSTR</td>
<td valign="top">Pointer to a constant Unicode string</td>
</tr></table></p>


<p>These data types always refer to Unicode characters and strings. The
Windows header files also define the ANSI/Unicode generic data types
PTSTR and PCTSTR. These data types point to either an ANSI string or a
Unicode string, depending on whether the UNICODE macro is defined when
you compile the module.</p>

<p>Notice that this time the UNICODE macro is not preceded by an
underscore. The _UNICODE macro is used for the C run-time header files
and the UNICODE macro is used for the Windows header files. You usually
need to define both macros when compiling a source code module.</p>

<A NAME="18"><H2>Unicode and ANSI Functions in Windows</H2></A>

<p>I implied earlier that two functions are called <i>
CreateWindowEx</i>: a <i>CreateWindowEx</i> that accepts Unicode
strings and a second <i>CreateWindowEx</i> that accepts ANSI strings.
This is true, but the two functions are actually prototyped as
follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
HWND WINAPI CreateWindowExW(
   DWORD dwExStyle, 
   PCWSTR pClassName,
   PCWSTR pWindowName, 
   DWORD dwStyle, 
   int X, 
   int Y,
   int nWidth, 
   int nHeight, 
   HWND hWndParent, 
   HMENU hMenu,
   HINSTANCE hInstance, 
   PVOID pParam);

HWND WINAPI CreateWindowExA(
   DWORD dwExStyle, 
   PCSTR pClassName,
   PCSTR pWindowName, 
   DWORD dwStyle, 
   int X, 
   int Y,
   int nWidth, 
   int nHeight, 
   HWND hWndParent, 
   HMENU hMenu,
   HINSTANCE hInstance, 
   PVOID pParam);
</pre></td></tr></table></p>

<p><i>CreateWindowExW</i> is the version that accepts Unicode strings.
The uppercase <i>W</i> at the end of the function name stands for <i>
wide</i>. Unicode characters are 16 bits each, so they are frequently
referred to as wide characters. The uppercase <i>A</i> at the end of
<i>CreateWindowExA</i> indicates that the function accepts ANSI
character strings. </p>
<p>But usually we just include a call to <i>CreateWindowEx</i> in our code
and don't directly call either <i>CreateWindowExW</i> or <i>
CreateWindowExA</i>. In WinUser.h, <i>CreateWindowEx</i> is actually a
macro defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
#ifdef UNICODE
#define CreateWindowEx CreateWindowExW
#else
#define CreateWindowEx CreateWindowExA
#endif // !UNICODE
</pre></td></tr></table></p>

<p>Whether UNICODE is defined when you compile your source code module
determines which version of <i>CreateWindowEx</i> is called. When you
port a 16-bit Windows application, you probably won't define
UNICODE when you compile. Any calls you make to <i>CreateWindowEx</i>
expand the macro to call <i>CreateWindowExA</i>&#8212;the ANSI version
of <i>CreateWindowEx</i>. Because 16-bit Windows offers only an ANSI
version of <i>CreateWindowEx</i>, your porting will go much easier. </p>
<p>Under Windows 2000, Microsoft's source code for <i>
CreateWindowExA</i> is simply a thunking, or translation, layer that
allocates memory to convert ANSI strings to Unicode strings; the code
then calls <i>CreateWindowExW</i>, passing the converted strings. When
<i>CreateWindowExW</i> returns, <i>CreateWindowExA</i> frees its memory
buffers and returns the window handle to you. </p>
<p>If you're creating dynamic-link libraries (DLLs) that other
software developers will use, consider using this technique: supply two
exported functions in the DLL&#8212;an ANSI version and a Unicode
version. In the ANSI version, simply allocate memory, perform the
necessary string conversions, and call the Unicode version of the
function. (I'll demonstrate this process later in this
chapter.)</p>

<p>Under Windows 98, Microsoft's source code for <i>
CreateWindowExA</i> is the function that does the work. Windows 98
offers all the entry points to all the Windows functions that accept a
Unicode parameter, but these functions do not translate Unicode strings
to ANSI strings&#8212;they just return failure. A call to <i>
GetLastError</i> returns ERROR_CALL_NOT_IMPLEMENTED. Only ANSI versions
of these functions work properly. If your compiled code makes calls to
any of the wide-character functions, your application will not run
under Windows 98.</p>

<p>Certain functions in the Windows API, such as <i>WinExec</i> and <i>
OpenFile</i>, exist solely for backward compatibility with 16-bit
Windows programs and should be avoided. You should replace any calls to
<i>WinExec</i> and <i>OpenFile</i> with calls to the <i>
CreateProcess</i> and <i>CreateFile</i> functions. Internally, the old
functions call the new functions anyway. The big problem with the old
functions is that they don't accept Unicode strings. When you call
these functions, you must pass ANSI strings. All the new and
nonobsolete functions, on the other hand, do have both ANSI and Unicode
versions on Windows 2000.</p>

<A NAME="19"><H2>Windows String Functions</H2></A>

<p>Windows also offers a comprehensive set of string manipulation
functions. These functions are similar to the C run-time string
functions, such as <i>strcpy</i> and <i>wcscpy</i>. However, the
operating system functions are part of the OS, and many OS components
use these functions instead of the C run-time library. I recommend that
you favor the OS functions over the C run-time string functions. This
will help your application's performance slightly because the OS
string functions are used frequently by heavyweight applications such
as the operating system's shell process, Explorer.exe. Since the
functions are used heavily, they will probably already be loaded into
RAM while your application runs.</p>

<p>To use these functions, the system must be running Windows 2000 or
Windows 98. The functions are also available on earlier versions of
Windows if Internet Explorer 4.0 or later is installed.</p>

<p>In classic OS function style, the OS string function names contain
both uppercase and lowercase letters and look like this: <i>StrCat</i>,
<i>StrChr</i>, <i>StrCmp</i>, and <i>StrCpy</i> (to name just a few).
To use these functions, you must include the ShlWApi.h header file.
Also, as previously discussed, these string functions come in both ANSI
and Unicode versions, such as <i>StrCatA</i> and <i>StrCatW</i>.
Because these are operating system functions, the symbols will expand
to their wide versions if you define UNICODE (without the preceding
underscore) when you build your application.</p>

</BODY>
</HTML>






