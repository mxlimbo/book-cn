<HTML>
<HEAD>
<TITLE>Character Sets</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch02a.htm">[Previous]</A> <A HREF="ch02c.htm">[Next]</A><P>

<A NAME="6"><H1>Character Sets</H1></A>

<p>The real problem with localization has always been manipulating
different character sets. For years, most of us have been coding text
strings as a series of single-byte characters with a zero at the end.
This is second nature to us. When we call <i>strlen</i>, it returns the
number of characters in a zero-terminated array of single-byte
characters.</p>

<p>The problem is that some languages and writing systems (Japanese
kanji being the classic example) have so many symbols in their
character sets that a single byte, which offers no more than 256
different symbols at best, is just not enough. So double-byte character
sets (DBCSs) were created to support these languages and writing
systems.</p>

<A NAME="7"><H2>Single-Byte and Double-Byte Character Sets</H2></A>

<p>In a double-byte character set, each character in a string consists
of either 1 or 2 bytes. With kanji, for example, if the first character
is between 0x81 and 0x9F or between 0xE0 and 0xFC, you must look at the
next byte to determine the full character in the string. Working with
double-byte character sets is a programmer's nightmare because some
characters are 1 byte wide and some are 2 bytes wide.</p>

<p>Simply placing a call to <i>strlen</i> doesn't really tell you
how many characters are in the string&#8212;it tells you the number of
bytes before you hit a terminating zero. The ANSI C run-time library
has no functions that allow you to manipulate double-byte character
sets. However, the Microsoft Visual C++ run-time library does include a
number of functions, such as <i>_mbslen</i>, that allow you to
manipulate multibyte (that is, both single-byte and double-byte)
character strings.</p>

<p>To help manipulate DBCS strings, Windows offers the following set of
helper functions.</p>

<p><table cellpadding=5 width="95%"><tr>
<th>Function</th>
<th>Description</th>
</tr>
<tr>
<td valign="top"><i>PTSTR CharNext (PCTSTR pszCurrentChar);</i></td>
<td valign="top">Returns the address of the next character in a string</td>
</tr>
<tr>
<td valign="top"><i>PTSTR CharPrev (PCTSTR pszStart, PCTSTR pszCurrentChar);</i></td>
<td valign="top">Returns the address of the previous character in a string </td>
</tr>
<tr>
<td valign="top"><i>BOOL IsDBCSLeadByte(BYTE bTestChar);</i></td>
<td valign="top">Returns TRUE if the byte is the first byte of a DBCS character</td>
</tr></table></p>


<p>The first two functions, <i>CharNext</i> and <i>CharPrev,</i> allow
you to traverse forward or backward through a DBCS string one character
at a time. The third function, <i>IsDBCSLeadByte</i>, returns TRUE if
the byte passed to it is the first byte of a 2-byte character.</p>

<p>Although these functions make manipulating DBCS strings a little
easier, a better approach is definitely needed. Enter Unicode.</p>

<A NAME="8"><H2>Unicode:The Wide-Byte Character Set</H2></A>

<p>Unicode is a standard founded by Apple and Xerox in 1988. In 1991, a
consortium was created to develop and promote Unicode. The consortium
consists of companies such as Apple, Compaq, Hewlett-Packard, IBM,
Microsoft, Oracle, Silicon Graphics, Inc., Sybase, Unisys, and Xerox.
(A complete and updated list of consortium members is available at 
<a href="http://www.Unicode.org" target="_window2"><i>www.Unicode.org</i></a>.) This group of companies is responsible for
maintaining the Unicode standard. The full description of Unicode can
be found in <i>The Unicode Standard,</i> published by Addison-Wesley.
(This book is available through <a href="http://www.Unicode.org" target="_window2"><i>www.Unicode.org.</i></a>)</p>

<p>Unicode offers a simple and consistent way of representing strings.
All characters in a Unicode string are 16-bit values (2 bytes). There
are no special bytes that indicate whether the next byte is part of the
same character or is a new character. This means that you can traverse
the characters in a string by simply incrementing or decrementing a
pointer. Calls to functions such as <i>CharNext</i>, <i>CharPrev</i>,
and <i>IsDBCSLeadByte</i> are no longer necessary.</p>

<p>Because Unicode represents each character with a 16-bit value, more
than 65,000 characters are available, making it possible to encode all
the characters that make up written languages throughout the world.
This is a far cry from the 256 characters available with a single-byte
character set.</p>

<p>Currently, Unicode code points<a href="footnotesa.htm#ch0201"><sup>1</sup></a> are defined for the
Arabic, Chinese bopomofo, Cyrillic (Russian), Greek, Hebrew, Japanese
kana, Korean hangul, and Latin (English) alphabets&#8212;and more. A
large number of punctuation marks, mathematical symbols, technical
symbols, arrows, dingbats, diacritics, and other characters are also
included in the character sets. When you add together all these
alphabets and symbols, they total about 35,000 different code points,
which leaves about half of the 65,000 total code points available for
future expansion.</p>

 
<p>These 65,536 characters are divided into regions. The following
table shows some of the regions and the characters that are assigned to
them.</p>

<p><table cellpadding=5 width="95%"><tr>
<th>16-Bit Code</th>
<th>Characters</th>
<th>16-Bit Code</th>
<th>Characters</th>
</tr>
<tr>
<td valign="top">0000-007F</td>
<td valign="top">ASCII</td>
<td valign="top">0300-036F</td>
<td valign="top">Generic diacritical marks</td>
</tr>
<tr>
<td valign="top">0080-00FF</td>
<td valign="top">Latin1 characters</td>
<td valign="top">0400-04FF</td>
<td valign="top">Cyrillic</td>
</tr>
<tr>
<td valign="top">0100-017F</td>
<td valign="top">European Latin</td>
<td valign="top">0530-058F</td>
<td valign="top">Armenian</td>
</tr>
<tr>
<td valign="top">0180-01FF</td>
<td valign="top">Extended Latin</td>
<td valign="top">0590-05FF</td>
<td valign="top">Hebrew</td>
</tr>
<tr>
<td valign="top">0250-02AF</td>
<td valign="top">Standard phonetic</td>
<td valign="top">0600-06FF</td>
<td valign="top">Arabic</td>
</tr>
<tr>
<td valign="top">02B0-02FF</td>
<td valign="top">Modified letters</td>
<td valign="top">0900-097F</td>
<td valign="top">Devanagari</td>
</tr></table></p>



<p>Approximately 29,000 code points are currently unassigned, but they
are reserved for future use. And approximately 6000 code points are
reserved for your own personal use.</p>

</BODY>
</HTML>






