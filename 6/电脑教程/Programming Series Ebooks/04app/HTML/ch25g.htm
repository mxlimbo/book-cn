<HTML>
<HEAD>
<TITLE>C++ Exceptions Versus Structured Exceptions</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch25f.htm">[Previous]</A> <A HREF="ch26a.htm">[Next]</A><P>

<A NAME="346"><H1>C++ Exceptions Versus Structured Exceptions</H1></A>

<p>Developers frequently ask me whether they should use structured
exceptions or C++ exceptions when developing their applications.
I'd like to offer an answer in this section.</p>

<p>Let me start by reminding you that SEH is an operating system facility
available in any programming language, while C++ EH can only be used
when writing C++ code. If you're writing a C++ application, you
should use C++ exceptions instead of structured exceptions. The reason
is that C++ exceptions are part of the language and therefore the
compiler knows what a C++ class object is. This means that the compiler
automatically generates code to call C++ object destructors in order to
guarantee object cleanup.</p>

<p>However, you should know that Microsoft's Visual C++ compiler has
implemented C++ exception handling using the operating system's
structured exception handling. So, when you create a C++ <i>try</i>
block, the compiler is generating an SEH <i>_ _try</i> block. A C++ <i>
catch</i> test becomes an SEH exception filter and the code in the <i>
catch</i> block becomes the code in the SEH <i>_ _except</i> block. In
fact, when you write a C++ <i>throw</i> statement, the compiler
generates a call to the Windows <i>RaiseException</i> function. The
variable used in the <i>throw</i> statement is passed as an additional
argument to <i>RaiseException</i>.</p>

<p>The following code fragment will help make all of this a little
clearer. The function on the top uses C++ exception handling and the
function on the bottom demonstrates how the C++ compiler generates the
equivalent structured exception handling.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
void ChunkyFunky() {
   try {
      // Try body

      <img src="images/grayvellip.JPG" width=3 height=13 border=0>

      throw 5;


   }
   catch (int x) {


      // Catch body

      <img src="images/grayvellip.JPG" width=3 height=13 border=0>

   }

   <img src="images/grayvellip.JPG" width=3 height=13 border=0>

}
</PRE>
</TD></TR></TABLE>
</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>
void ChunkyFunky() {
   _ _try {
      // Try body

      <img src="images/grayvellip.JPG" width=3 height=13 border=0>

      RaiseException(Code=0xE06D7363,
         Flag=EXCEPTION_NONCONTINUABLE,
         Args=5);
   }
   _ _except ((ArgType == Integer) ? 
      EXCEPTION_EXECUTE_HANDLER : 
      EXCEPTION_CONTINUE_SEARCH) {
      // Catch body

      <img src="images/grayvellip.JPG" width=3 height=13 border=0>

   }

   <img src="images/grayvellip.JPG" width=3 height=13 border=0>

}
</pre></td></tr></table></p>

<p>You'll notice a few interesting details about the code above.
First, notice that <i>RaiseException</i> is called with an exception
code of 0xE06D7363. This is the software exception code selected by the
Visual C++ team to be used when throwing C++ exceptions. In fact, you
can verify this if you open the debugger's Exceptions dialog box
and scroll to the bottom of the exceptions list, shown here.</p>

<p>
<A HREF="javascript:fullSize('G25si15x.htm')"> <img src="images/G25si15.JPG" width=404 height=200 border=0 ALT="Click to view at full size."> </A>
</p>

<p>You'll also notice that the EXCEPTION_NONCONTINUABLE flag is always
used when a C++ exception is thrown. C++ exceptions can never be
re-executed, and it would be an error for a filter diagnosing a C++
exception to return EXCEPTION_CONTINUE_EXECUTION. In fact, if you look
at the <i>_ _except</i> filter in the function on the right, you'll
see that it is only capable of evaluating to EXCEPTION_EXECUTE_HANDLER
or EXCEPTION_CONTINUE_SEARCH.</p>

<p>The remaining parameters to <i>RaiseException</i> are used as the
mechanism that actually throws the specified variable. Exactly how the
thrown variable information is passed to <i>RaiseException</i> is not
documented, but it's not too hard to imagine ways that the compiler
team could have implemented this.</p>

<p>The last thing I'd like to point out is the <i>_ _except</i> filter.
The purpose of this filter is to compare the <i>throw</i> variables
data type with the variable type used in the C++ <i>catch</i>
statement. If the data types are the same, the filter returns
EXCEPTION_EXECUTE_HANDLER, causing the statements in the <i>catch</i>
block (<i>_ _except</i> block) to execute. If the data types are
different, the filter returns EXCEPTION_CONTINUE_SEARCH, allowing <i>
catch</i> filters farther up the call tree to be evaluated.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
Since C++ exceptions are implemented internally via structured exceptions, you
can use both mechanisms in a single application. For example, I love
using virtual memory to commit storage when access violations are
raised. The C++ language does not support this type of <i>resumptive
exception handling</i> at all. However, I can use structured exception
handling in the parts of my code where I want to take advantage of this
and have my own <i>_ _except</i> filter return EXCEPTION_CONTINUE_ 
EXECUTION. For all other parts of my code that do not require
resumptive exception handling, I'll stick with C++ exception
handling.</blockquote></div></p>

<A NAME="347"><H2>Catching Structured Exceptions with C++</H2></A>

<p>Normally, C++ exception handling does not allow an application to
recover from a hard exception such as an access violation or a division
by 0. However, Microsoft has added this support to their compiler. For
example, the following code will prevent the process from terminating
abnormally:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
void main() {
   try {
      * (PBYTE) 0 = 0;       // Access violation 
   }
   catch (...) {
      // This code handles the access-violation exception
   }
   // The process is terminating normally
}
</pre></td></tr></table></p>

<p>This is nice, since it allows your application to recover gracefully
from hard exceptions. However, it would also be nice if the catch's
exception-declaration could somehow distinguish between different
exception codes. For example, it would be nice to be able to write code
like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
void Functastic() {

   try {
      * (PBYTE) 0 = 0;       // Access violation

      int x = 0;
      x = 5 / x;             // Division by zero
   }
   catch (StructuredException) {
      switch (StructuredExceptionCode) {
         case EXCEPTION_ACCESS_VIOLATION:
            // This code handles an access-violation exception
            break;

         case EXCEPTION_INT_DIVIDE_BY_ZERO:
            // This code handles a division-by-zero exception
            break;

         default:
            // We don't handle any other exceptions
            throw;   // Maybe another catch is looking for this
            break;   // Never executes
      }
   }
}
</pre></td></tr></table></p>

<p>Well, you’ll be happy to know that Visual C++ has a mechanism that makes
this possible. Here’s what you need to do. Create your own C++ class to use in
your code to identify structured exceptions. Here is an example:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
#include &lt;eh.h&gt;              // For _set_se_translator

<img src="images/grayvellip.JPG" width=3 height=13 border=0>

class CSE {
public:
   // Call this function for each thread.
   static void MapSEtoCE() { _set_se_translator(TranslateSEtoCE); }
   operator DWORD() { return(m_er.ExceptionCode); }
private:
   CSE(PEXCEPTION_POINTERS pep) {
      m_er      = *pep-&gt;ExceptionRecord;
      m_context = *pep-&gt;ContextRecord;
   }
   static void _cdecl TranslateSEtoCE(UINT dwEC, 
      PEXCEPTION_POINTERS pep) {
      throw CSE(pep);
   }
private:
   EXCEPTION_RECORD m_er;      // CPU independent exception information
   CONTEXT          m_context; // CPU dependent exception information
};
</pre></td></tr></table></p>

<p>Inside each of your thread’s entry-point functions, call the static member
function <i>MapSEtoCE</i>. This function calls the C run-time function
<i>_set_se_translator</i> passing it the address of the CSE class’s <i>TranslateSEtoCE</i>
function. By calling <i>_set_se_translator</i>, you’re telling the C++ run time to call
the <i>TranslateSEtoCE</i> function whenever a structured exception is raised. This
function constructs a CSE class object and initializes the two data members
to contain the CPU-independent and CPU-dependent information about the
exception. After the CSE object is constructed, it is thrown just as any normal
variable can be thrown. Now, your C++ code can handle structured exceptions
by catching a variable of this type.</p>

<p>Here’s an example of how to catch this C++ object:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
void Functastic() {
   CSE::MapSEtoCE(); // Must be called before any exceptions are raised
   try {
      * (PBYTE) 0 = 0;       // Access violation
      int x = 0;
      x = 5 / x;             // Division by zero
   }
   catch (CSE se) {
      switch (se) {    // Calls the operator DWORD() member function
         case EXCEPTION_ACCESS_VIOLATION:
            // This code handles an access-violation exception
            break;
         case EXCEPTION_INT_DIVIDE_BY_ZERO:
            // This code handles a division-by-zero exception
            break;
         default:
            // We don’t handle any other exceptions
            throw;   // Maybe another catch is looking for this
            break;   // Never executes
      }
   }
}
</pre></td></tr></table></p>

</body>
</html>







