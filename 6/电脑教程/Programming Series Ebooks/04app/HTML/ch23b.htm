<HTML>
<HEAD>
<TITLE>Understanding Termination Handlers by Example</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch23a.htm">[Previous]</A> <A HREF="ch24a.htm">[Next]</A><P>

<A NAME="302"><H1>Understanding Termination Handlers by Example</H1></A>

<p>Because the compiler and the operating system are intimately
involved with the execution of your code when you use SEH, I believe
that the best way to demonstrate how SEH works is by examining source
code samples and discussing the order in which the statements execute
in each example.</p>

<p>Therefore, the next few sections show different source code
fragments, and the text associated with each fragment explains how the
compiler and operating system alter the execution order of your
code.</p>


<A NAME="303"><h2><i>Funcenstein1</i></h2></A>
<p>To appreciate the ramifications of using termination handlers,
let's examine a more concrete coding example.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD Funcenstein1() {
   DWORD dwTemp;

   // 1. Do any processing here.

   <img src="images/grayvellip.JPG" width=3 height=13 border="0">

   _ _try { 
      // 2. Request permission to access
      //    protected data, and then use it.
      WaitForSingleObject(g_hSem, INFINITE);

      g_dwProtectedData = 5;
      dwTemp = g_dwProtectedData;
   }
   _ _finally {
      // 3. Allow others to use protected data.
      ReleaseSemaphore(g_hSem, 1, NULL);
   }

   // 4. Continue processing.
   return(dwTemp);
}
</pre></td></tr></table></p>

<p>The numbered comments above indicate the order in which your code
will execute. In <i>Funcenstein1</i>, using the <i>try-finally</i>
blocks isn't doing much for you. The code will wait for a
semaphore, alter the contents of the protected data, save the new value
in the local variable <i>dwTemp</i>, release the semaphore, and return
the new value to the caller.</p>


<A NAME="304"><h2><i>Funcenstein2</i></h2></A>
<p>Now let's modify the function a little and see what happens:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD Funcenstein2() {
   DWORD dwTemp;

   // 1. Do any processing here.

   <img src="images/grayvellip.JPG" width=3 height=13 border="0">

   _ _try { 
      // 2. Request permission to access
      //    protected data, and then use it.
      WaitForSingleObject(g_hSem, INFINITE);

      g_dwProtectedData = 5;
      dwTemp = g_dwProtectedData;

      // Return the new value.
      return(dwTemp);
   }
   _ _finally {
      // 3. Allow others to use protected data.
      ReleaseSemaphore(g_hSem, 1, NULL);
   }

   // Continue processing--this code
   // will never execute in this version.
   dwTemp = 9;
   return(dwTemp);
}
</pre></td></tr></table></p>

<p>In <i>Funcenstein2</i>, a <i>return</i> statement has been added to
the end of the <i>try</i> block. This <i>return</i> statement tells the
compiler that you want to exit the function and return the contents of
the <i>dwTemp</i> variable, which now contains the value 5. However, if
this <i>return</i> statement had been executed, the thread would not
have released the semaphore&#8212;and no other thread would ever regain
control of the semaphore. As you can imagine, this kind of sequence can
become a really big problem because threads waiting for the semaphore
might never resume execution.</p>

<p>However, by using the termination handler, you have avoided the
premature execution of the <i>return</i> statement. When the <i>
return</i> statement attempts to exit the <i>try</i> block, the
compiler makes sure that the code in the <i>finally</i> block executes
first. The code inside the <i>finally</i> block is guaranteed to
execute before the <i>return</i> statement in the <i>try</i> block is
allowed to exit. In <i>Funcenstein2</i>, putting the call to <i>
ReleaseSemaphore</i> into a termination handler block ensures that the
semaphore will always be released. There is no chance for a thread to
accidentally retain ownership of the semaphore, which would mean that
all other threads waiting for the semaphore would never be scheduled
CPU time.</p>

<p>After the code in the <i>finally</i> block executes, the function does,
in fact, return. Any code appearing below the <i>finally</i> block
doesn't execute because the function returns in the <i>try</i>
block. Therefore, this function returns the value 5, not the value
9.</p>
 
<p>You might be asking yourself how the compiler guarantees that the <i>
finally</i> block executes before the <i>try</i> block can be exited.
When the compiler examines your source code, it sees that you have
coded a <i>return</i> statement inside a <i>try</i> block. Having seen
this, the compiler generates code to save the return value (5 in our
example) in a temporary variable created by the compiler. The compiler
then generates code to execute the instructions contained inside the
<i>finally</i> block; this is called a <i>local unwind.</i> More
specifically, a local unwind occurs when the system executes the
contents of a <i>finally</i> block because of the premature exit of
code in a <i>try</i> block. After the instructions inside the <i>
finally</i> block execute, the value in the compiler's temporary
variable is retrieved and returned from the function.</p>

<p>As you can see, the compiler must generate additional code and the
system must perform additional work to pull this whole thing off. On
different CPUs, the steps needed for termination handling to work vary.
The Alpha processor, for example, must execute several hundred or even
several thousand CPU instructions to capture the <i>try</i> block's
premature return and call the <i>finally</i> block. You should avoid
writing code that causes premature exits from the <i>try</i> block of a
termination handler because the performance of your application could
be adversely impacted. Later in this chapter, I'll discuss the
_ _<i>leave</i> keyword, which can help you avoid writing code that
forces local unwinds.</p>

<p>Exception handling is designed to capture exceptions&#8212;the
exceptions to the rule that you expect to happen infrequently (in our
example, the premature <i>return</i>). If a situation is the norm,
checking for the situation explicitly is much more efficient than
relying on the SEH capabilities of the operating system and your
compiler to trap common occurrences.</p>

<p>Note that when the flow of control naturally leaves the <i>try</i>
block and enters the <i>finally</i> block (as shown in <i>
Funcenstein1</i>), the overhead of entering the <i>finally</i> block is
minimal. On the <i>x</i>86 CPUs using Microsoft's compiler, a
single machine instruction is executed as execution leaves the <i>
try</i> block to enter the <i>finally</i> block&#8212;I doubt that you
will even notice this overhead in your application. When the compiler
has to generate additional code and the system has to perform
additional work, as in <i>Funcenstein2</i>, the overhead is much more
noticeable.</p>


<A NAME="305"><h2><i>Funcenstein3</i></h2></A>
<p>Now let's modify the function again and take a look at what
happens:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD Funcenstein3() {
   DWORD dwTemp;

   // 1. Do any processing here.

   <img src="images/grayvellip.JPG" width=3 height=13 border="0">

   _ _try { 
      // 2. Request permission to access
      //    protected data, and then use it.
      WaitForSingleObject(g_hSem, INFINITE);

      g_dwProtectedData = 5;
      dwTemp = g_dwProtectedData;

      // Try to jump over the finally block.
      goto ReturnValue;
   }

   _ _finally {
      // 3. Allow others to use protected data.
      ReleaseSemaphore(g_hSem, 1, NULL);
   }

   dwTemp = 9;
   // 4. Continue processing.
   ReturnValue:
   return(dwTemp);
}
</pre></td></tr></table></p>

<p>In <i>Funcenstein3</i>, when the compiler sees the <i>goto</i>
statement in the <i>try</i> block, it generates a local unwind to
execute the contents of the <i>finally</i> block first. However, this
time, after the code in the <i>finally</i> block executes, the code
after the <i>ReturnValue</i> label is executed because no return occurs
in either the <i>try</i> or the <i>finally</i> block. This code causes
the function to return a 5. Again, because you have interrupted the
natural flow of control from the <i>try</i> block into the <i>
finally</i> block, you could incur a high performance penalty depending
on the CPU your application is running on.</p>


<A NAME="306"><h2><i>Funcfurter1</i></h2></A>
<p>Now let's look at another scenario in which termination handling
really proves its value. Look at this function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD Funcfurter1() {
   DWORD dwTemp;

   // 1. Do any processing here.

   <img src="images/grayvellip.JPG" width=3 height=13 border="0">

   _ _try { 
      // 2. Request permission to access
      //    protected data, and then use it.
      WaitForSingleObject(g_hSem, INFINITE);

      dwTemp = Funcinator(g_dwProtectedData);
   }
   _ _finally {
      // 3. Allow others to use protected data.
      ReleaseSemaphore(g_hSem, 1, NULL);
   }

   // 4. Continue processing.
   return(dwTemp);
}
</pre></td></tr></table></p>

<p>Now imagine that the <i>Funcinator</i> function called in the <i>
try</i> block contains a bug that causes an invalid memory access.
Without SEH, this situation would present the user with the
ever-popular Application Error dialog box. When the user dismissed the
error dialog box, the process would be terminated. When the process is
terminated (because of an invalid memory access), the semaphore would
still be owned and would never be released&#8212;any threads in other
processes that were waiting for this semaphore would never be scheduled
CPU time. But placing the call to <i>ReleaseSemaphore</i> in a <i>
finally</i> block guarantees that the semaphore gets released even if
some other function causes a memory access violation.</p>

<p>If termination handlers are powerful enough to capture a process while
terminating because of an invalid memory access, we should have no
trouble believing that they will also capture <i>setjump</i> and <i>
longjump</i> combinations and, of course, simple statements such as <i>
break</i> and <i>continue</i>.</p>


<A NAME="307"><h2>Pop Quiz Time: <i>FuncaDoodleDoo</i></h2></A>
<p>Now for a test. Can you determine what the following function
returns?</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD FuncaDoodleDoo() {
   DWORD dwTemp = 0;

   while (dwTemp &lt; 10) {

      _ _try { 
         if (dwTemp == 2)
            continue;

         if (dwTemp == 3)
            break;
      }
      _ _finally {
         dwTemp++;
      }

      dwTemp++;
   }

   dwTemp += 10;
   return(dwTemp);
}
</pre></td></tr></table></p>

<p>Let's analyze what the function does step by step. First <i>
dwTemp</i> is set to 0. The code in the <i>try</i> block executes, but
neither of the <i>if</i> statements evaluates to TRUE. Execution moves
naturally to the code in the <i>finally</i> block, which increments <i>
dwTemp</i> to 1. Then the instruction after the <i>finally</i> block
increments <i>dwTemp</i> again, making it 2.</p>

<p>When the loop iterates, <i>dwTemp</i> is 2 and the <i>continue</i>
statement in the <i>try</i> block will execute. Without a termination
handler to force execution of the <i>finally</i> block before exit from
the <i>try</i> block, execution would immediately jump back up to the
<i>while</i> test, <i>dwTemp</i> would not be changed, and we would
have started an infinite loop. With a termination handler, the system
notes that the <i>continue</i> statement causes the flow of control to
exit the <i>try</i> block prematurely and moves execution to the <i>
finally</i> block. In the <i>finally</i> block, <i>dwTemp</i> is
incremented to 3. However, the code after the <i>finally</i> block
doesn't execute because the flow of control moves back to <i>
continue</i> and thus to the top of the loop.</p>

<p>Now we are processing the loop's third iteration. This time, the
first <i>if</i> statement evaluates to FALSE, but the second <i>if</i>
statement evaluates to TRUE. The system again catches our attempt to
break out of the <i>try</i> block and executes the code in the <i>
finally</i> block first. Now <i>dwTemp</i> is incremented to 4. Because
a <i>break</i> statement was executed, control resumes after the loop.
Thus, the code after the <i>finally</i> block and still inside the loop
doesn't execute. The code below the loop adds 10 to <i>dwTemp</i>
for a grand total of 14&#8212;the result of calling this function. It
should go without saying that you should never actually write code like
<i>FuncaDoodleDoo</i>. I placed the <i>continue</i> and <i>break</i>
statements in the middle of the code only to demonstrate the operation
of the termination handler.</p>

<p>Although a termination handler will catch most situations in which the
<i>try</i> block would otherwise be exited prematurely, it can't
cause the code in a <i>finally</i> block to be executed if the thread
or process is terminated. A call to <i>ExitThread</i> or <i>
ExitProcess</i> will immediately terminate the thread or process
without executing any of the code in a <i>finally</i> block. Also, if
your thread or process should die because some application called <i>
TerminateThread</i> or <i>TerminateProcess</i>, the code in a <i>
finally</i> block again won't execute. Some C run-time functions
(such as <i>abort</i>) that in turn call <i>ExitProcess</i> again
preclude the execution of <i>finally</i> blocks. You can't do
anything to prevent another application from terminating one of your
threads or processes, but you can prevent your own premature calls to
<i>ExitThread</i> and <i>ExitProcess</i>.</p>


<A NAME="308"><h2><i>Funcenstein4</i></h2></A>
<p>Let's take a look at one more termination handling scenario.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD Funcenstein4() {
   DWORD dwTemp;
   // 1. Do any processing here.

   <img src="images/grayvellip.JPG" width=3 height=13 border="0">

   _ _try { 
      // 2. Request permission to access
      //    protected data, and then use it.
      WaitForSingleObject(g_hSem, INFINITE);

      g_dwProtectedData = 5;
      dwTemp = g_dwProtectedData;

      // Return the new value.
      return(dwTemp);
   }
   _ _finally {
      // 3. Allow others to use protected data.
      ReleaseSemaphore(g_hSem, 1, NULL);
      return(103);
   }

   // Continue processing--this code will never execute.
   dwTemp = 9;
   return(dwTemp);
}
</pre></td></tr></table></p>

<p>In <i>Funcenstein4</i>, the <i>try</i> block will execute and try to
return the value of <i>dwTemp</i> (5) back to <i>Funcenstein4</i>'s
caller. As noted in the discussion of <i>Funcenstein2</i>, trying to
return prematurely from a <i>try</i> block causes the generation of
code that puts the return value into a temporary variable created by
the compiler. Then the code inside the <i>finally</i> block is
executed. Notice that in this variation on <i>Funcenstein2</i> I have
added a <i>return</i> statement to the <i>finally</i> block. Will <i>
Funcenstein4</i> return 5 or 103 to the caller? The answer is 103
because the <i>return</i> statement in the <i>finally</i> block causes
the value 103 to be stored in the same temporary variable in which the
value 5 has been stored, overwriting the 5. When the <i>finally</i>
block completes execution, the value now in the temporary variable
(103) is returned from <i>Funcenstein4</i> to its caller.</p>

<p>We've seen termination handlers do an effective job of rescuing
execution from a premature exit of the <i>try</i> block, and we've
also seen termination handlers produce an unwanted result because they
prevented a premature exit of the <i>try</i> block. A good rule of
thumb is to avoid any statements that would cause a premature exit of
the <i>try</i> block part of a termination handler. In fact, it is
always best to remove all <i>return</i>s, <i>continue</i>s, <i>
break</i>s, <i>goto</i>s, and so on from inside both the <i>try</i> and
the <i>finally</i> blocks of a termination handler and to put these
statements outside the handler. Such a practice will cause the compiler
to generate both a smaller amount of code&#8212;because it won't
have to catch premature exits from the <i>try</i> block&#8212;and faster
code, because it will have fewer instructions to execute in order to
perform the local unwind. In addition, your code will be much easier to
read and maintain.</p>


<A NAME="309"><h2><i>Funcarama1</i></h2></A>
<p>We've pretty much covered the basic syntax and semantics of
termination handlers. Now let's look at how a termination handler
could be used to simplify a more complicated programming problem.
Let's look at a function that doesn't take advantage of
termination handlers at all:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL Funcarama1() {
   HANDLE hFile = INVALID_HANDLE_VALUE;
   PVOID pvBuf = NULL;
   DWORD dwNumBytesRead;
   BOOL fOk;

   hFile = CreateFile(&quot;SOMEDATA.DAT&quot;, GENERIC_READ,
      FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
   if (hFile == INVALID_HANDLE_VALUE) {
      return(FALSE);
   }

   pvBuf = VirtualAlloc(NULL, 1024, MEM_COMMIT, PAGE_READWRITE);
   if (pvBuf == NULL) {
      CloseHandle(hFile);
      return(FALSE);
   }

   fOk = ReadFile(hFile, pvBuf, 1024, &amp;dwNumBytesRead, NULL);
   if (!fOk || (dwNumBytesRead == 0)) {
      VirtualFree(pvBuf, MEM_RELEASE | MEM_DECOMMIT);
      CloseHandle(hFile);
      return(FALSE);
   }

   // Do some calculation on the data.

   <img src="images/grayvellip.JPG" width=3 height=13 border="0">

   // Clean up all the resources.
   VirtualFree(pvBuf, MEM_RELEASE | MEM_DECOMMIT);
   CloseHandle(hFile);
   return(TRUE);
}
</pre></td></tr></table></p>

<p>All the error checking in <i>Funcarama1</i> makes the function
difficult to read, which also makes the function difficult to
understand, maintain, and modify.</p>


<A NAME="310"><h2><i>Funcarama2</i></h2></A>
<p>Of course, it's possible to rewrite <i>Funcarama1</i> so that it
is a little cleaner and easier to understand:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL Funcarama2() {
   HANDLE hFile = INVALID_HANDLE_VALUE;
   PVOID pvBuf = NULL;
   DWORD dwNumBytesRead;
   BOOL fOk, fSuccess = FALSE;

   hFile = CreateFile(&quot;SOMEDATA.DAT&quot;, GENERIC_READ,
      FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

   if (hFile != INVALID_HANDLE_VALUE) {

      pvBuf = VirtualAlloc(NULL, 1024, MEM_COMMIT, PAGE_READWRITE);

      if (pvBuf != NULL) {

         fOk = ReadFile(hFile, pvBuf, 1024, &amp;dwNumBytesRead, NULL);

         if (fOk &amp;&amp; (dwNumBytesRead != 0)) {
            // Do some calculation on the data.

            <img src="images/grayvellip.JPG" width=3 height=13 border="0">     
       
            fSuccess = TRUE;
         }

      }

      VirtualFree(pvBuf, MEM_RELEASE | MEM_DECOMMIT);
   }

   CloseHandle(hFile);
   return(fSuccess);
}
</pre></td></tr></table></p>

<p>Although easier to understand than <i>Funcarama1</i>, <i>
Funcarama2</i> is still difficult to modify and maintain. Also, the
indentation level gets to be pretty extreme as more conditional
statements are added; with such a rewrite, you soon end up writing code
on the far right of your screen and wrapping statements after every
five characters!</p>


<A NAME="311"><h2><i>Funcarama3</i></h2></A>
<p>Let's rewrite the first version, <i>Funcarama1</i>, to take
advantage of an SEH termination handler:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD Funcarama3() {

   // IMPORTANT: Initialize all variables to assume failure.
   HANDLE hFile = INVALID_HANDLE_VALUE;
   PVOID pvBuf = NULL;

   _ _try { 
      DWORD dwNumBytesRead;
      BOOL fOk;

      hFile = CreateFile(&quot;SOMEDATA.DAT&quot;, GENERIC_READ,
         FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
      if (hFile == INVALID_HANDLE_VALUE) {
         return(FALSE);
      }

      pvBuf = VirtualAlloc(NULL, 1024, MEM_COMMIT, PAGE_READWRITE);
      if (pvBuf == NULL) {
         return(FALSE);
      }

      fOk = ReadFile(hFile, pvBuf, 1024, &amp;dwNumBytesRead, NULL);
      if (!fOk || (dwNumBytesRead != 1024)) {
         return(FALSE);
      }

      // Do some calculation on the data.

      <img src="images/grayvellip.JPG" width=3 height=13 border="0">

   }

   _ _finally {
      // Clean up all the resources.
      if (pvBuf != NULL)
         VirtualFree(pvBuf, MEM_RELEASE | MEM_DECOMMIT);
      if (hFile != INVALID_HANDLE_VALUE)
         CloseHandle(hFile);
   }
   // Continue processing.
   return(TRUE);
}
</pre></td></tr></table></p>

<p>The real virtue of the <i>Funcarama3</i> version is that all of the
function's cleanup code is localized in one place and one place
only: the <i>finally</i> block. If we ever need to add some additional
code to this function, we can simply add a single cleanup line in the
<i>finally</i> block&#8212;we won't have to go back to every
possible location of failure and add our cleanup line to each failure
location.</p>


<A NAME="312"><h2><i>Funcarama4</i>: The Final Frontier</h2></A>
<p>The real problem with the <i>Funcarama3</i> version is the overhead.
As I mentioned after the discussion of <i>Funcenstein4</i>, you really
should avoid putting <i>return</i> statements into a <i>try</i> block
as much as possible.</p>

<p>To help make such avoidance easier, Microsoft added another keyword,
_ _<i>leave</i>, to its C/C++ compiler. Here is the <i>Funcarama4</i>
version, which takes advantage of the _ _<i>leave</i> keyword:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD Funcarama4() {

   // IMPORTANT: Initialize all variables to assume failure.
   HANDLE hFile = INVALID_HANDLE_VALUE;
   PVOID pvBuf = NULL;

   // Assume that the function will not execute successfully.
   BOOL fFunctionOk = FALSE;

   _ _try { 
      DWORD dwNumBytesRead;
      BOOL fOk;

      hFile = CreateFile(&quot;SOMEDATA.DAT&quot;, GENERIC_READ,
         FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);
      if (hFile == INVALID_HANDLE_VALUE) {
         _ _leave;
      }

      pvBuf = VirtualAlloc(NULL, 1024, MEM_COMMIT, PAGE_READWRITE);

      if (pvBuf == NULL) {
         _ _leave;
      }

      fOk = ReadFile(hFile, pvBuf, 1024, &amp;dwNumBytesRead, NULL);
      if (!fOk || (dwNumBytesRead == 0)) {
         _ _leave;
      }

      // Do some calculation on the data.

      <img src="images/grayvellip.JPG" width=3 height=13 border="0">

      // Indicate that the entire function executed successfully.
      fFunctionOk = TRUE;
   }
   _ _finally {
      // Clean up all the resources.
      if (pvBuf != NULL)
         VirtualFree(pvBuf, MEM_RELEASE | MEM_DECOMMIT);
      if (hFile != INVALID_HANDLE_VALUE)
         CloseHandle(hFile);
   }
   // Continue processing.
   return(fFunctionOk);
}
</pre></td></tr></table></p>

<p>The use of the _ _<i>leave</i> keyword in the <i>try</i> block causes
a jump to the end of the <i>try</i> block. You can think of it as
jumping to the <i>try</i> block's closing brace. Because the flow
of control will exit naturally from the <i>try</i> block and enter the
<i>finally</i> block, no overhead is incurred. However, it was
necessary to introduce a new Boolean variable, <i>fFunctionOk</i>, to
indicate the success or failure of the function. That's a
relatively small price to pay.</p>

<p>When designing your functions to take advantage of termination
handlers in this way, remember to initialize all of your resource
handles to invalid values before entering your <i>try</i> block. Then,
in the <i>finally</i> block, you can check to see which resources have
been allocated successfully so that you'll know which ones to free.
Another popular method for tracking which resources will need to be
freed is to set a flag when a resource allocation is successful. Then
the code in the <i>finally</i> block can examine the state of the flag
to determine whether the resource needs freeing.</p>


<A NAME="313"><h2>Notes About the <i>finally</i> Block</h2></A>
<p>So far we have explicitly identified two scenarios that force the
<i>finally</i> block to be executed:</p>

<ul>

<p><li>Normal flow of control from the <i>try</i> block into the <i>
finally</i> block</li></p>

<p><li>Local unwind: premature exit from the <i>try</i> block
(<i>goto</i>, <i>longjump</i>, <i>continue</i>, <i>break</i>, <i>
return</i>, and so on) forcing control to the <i>finally</i> block</li></p>

</ul>

<p>A third scenario&#8212;a <i>global unwind&#8212;</i>occurred without
explicit identification as such in the <i>Funcfurter1</i> function we
saw earlier in the chapter. Inside the <i>try</i> block of this
function was a call to the <i>Funcinator</i> function. If the <i>
Funcinator</i> function caused a memory access violation, a global
unwind caused <i>Funcfurter1</i>'s <i>finally</i> block to execute.
We'll look at global unwinding in greater detail in the <a href="ch24a.htm">next
chapter</a>.</p>

<p>Code in a <i>finally</i> block always starts executing as a result of
one of these three situations. To determine which of the three
possibilities caused the <i>finally</i> block to execute, you can call
the <a href="footnotesa.htm#ch2301">intrinsic function <sup>1</sup></a> <i>AbnormalTermination</i>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL AbnormalTermination();
</pre></td></tr></table></p>

<p>This intrinsic function can be called only from inside a <i>
finally</i> block and returns a Boolean value indicating whether the
<i>try</i> block associated with the <i>finally</i> block was exited
prematurely. In other words, if the flow of control leaves the <i>
try</i> block and naturally enters the <i>finally</i> block, <i>
AbnormalTermination</i> will return FALSE. If the flow of control exits
the <i>try</i> block abnormally&#8212;usually because a local unwind has
been caused by a <i>goto</i>, <i>return</i>, <i>break</i>, or <i>
continue</i> statement or because a global unwind has been caused by a
memory access violation or another exception&#8212;a call to <i>
AbnormalTermination</i> will return TRUE. It is impossible to determine
whether a <i>finally</i> block is executing because of a global or a
local unwind. This is usually not a problem because you have, of
course, avoided writing code that performs local unwinds.</p>



<A NAME="314"><h2><i>Funcfurter2</i></h2></A>
<p>Here is <i>Funcfurter2</i>, which demonstrates use of the <i>
AbnormalTermination</i> intrinsic function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD Funcfurter2() {
   DWORD dwTemp;

   // 1. Do any processing here.

   <img src="images/grayvellip.JPG" width=3 height=13 border="0">

   _ _try { 
      // 2. Request permission to access
      //    protected data, and then use it.
      WaitForSingleObject(g_hSem, INFINITE);

      dwTemp = Funcinator(g_dwProtectedData);
   }
   _ _finally {
      // 3. Allow others to use protected data.
      ReleaseSemaphore(g_hSem, 1, NULL);

      if (!AbnormalTermination()) {
         // No errors occurred in the try block, and
         // control flowed naturally from try into finally.

         <img src="images/grayvellip.JPG" width=3 height=13 border="0">

      } else {
         // Something caused an exception, and
         // because there is no code in the try block
         // that would cause a premature exit, we must
         // be executing in the finally block
         // because of a global unwind.

         // If there were a goto in the try block,
         // we wouldn't know how we got here.

         <img src="images/grayvellip.JPG" width=3 height=13 border="0">

      }
   }

   // 4. Continue processing.
   return(dwTemp);
}
</pre></td></tr></table></p>

<p>Now that you know how to write termination handlers, you'll see
that they can be even more useful and important when we look at
exception filters and exception handlers in the <a href="ch24a.htm">next chapter</a>. Before we
move on, let's review the reasons for using termination
handlers:</p>

<ul>

<p><li>They simplify error processing because all cleanup is in one
location and is guaranteed to execute.</li></p>

<p><li>They improve program readability.</li></p>

<p><li>They make code easier to maintain.</li></p>

<p><li>They have minimal speed and size overhead if used correctly.</li></p>

</ul>


<A NAME="315"><H2>The SEH Termination Sample Application</H2></A>

<p>The SEHTerm application,&quot;23 SEHTerm.exe&quot; (listed in Figure
23-1), demonstrates how termination handlers work. The source code and
resource files for the application are in the 23-SEHTerm directory on
the companion CD-ROM.</p>

<p>When you run the application, the primary thread enters a <i>try</i>
block. Inside this <i>try</i> block, the following message box is
displayed.</p>

<p>
<img src="images/G23si01.JPG" width=185 height=100 border="0">
</p>

<p>This message box asks whether you want the program to access an
invalid byte in memory. (Most applications aren't as considerate as
this; they usually just access invalid memory without asking.)
Let's examine what happens if you click on the Yes button. In this
case, the thread attempts to write a 5 to memory address NULL. Writing
to address NULL always causes an access violation exception. When the
thread raises an access violation, the system displays the message box
shown below on Windows 98.</p>

<p>
<img src="images/G23si02.JPG" width=404 height=124 border="0">
</p>

<p>On Windows 2000, the message box shown here is displayed.</p>

<p>
<A HREF="javascript:fullSize('G23si03x.htm')"> <img src="images/G23si03.JPG" width=404 height=123 border=0 ALT="Click to view at full size."> </A>
</p>

<p>If you now click on the Close button (in Windows 98) or the OK
button (in Windows 2000), the process will be terminated. However,
there is a <i>finally</i> block in the source code, so the <i>
finally</i> block executes before the process terminates. The finally
block displays this message box.</p>

<p>
<img src="images/G23si04.JPG" width=186 height=100 border="0">
</p>

<p>The <i>finally</i> block is executing because its associated <i>try</i>
block exited abnormally. When this message box is dismissed, the
process does, in fact, terminate.</p>

<p>OK, now let's run the application again. This time, however,
let's click on the No button so that we do not attempt to access
invalid memory. When you click No, the thread naturally flows out of
the <i>try</i> block and enters the <i>finally</i> block. Again, the
<i>finally</i> block displays a message box.</p>

<p>
<img src="images/G23si05.JPG" width=186 height=100 border="0">
</p>

<p>Notice, however, that this time the message box indicates that the
<i>try</i> block exited normally. When we dismiss this message box, the
thread leaves the <i>finally</i> block and displays one last message
box.</p>

<p>
<img src="images/G23si06.JPG" width=203 height=100 border="0">
</p>

<p>When this message box is dismissed, the process terminates naturally,
because <i>WinMain</i> returns. Notice that you do not see this last
message box when the process is terminated because of an access
violation.</p>

<p><b>Figure 23-1.</b> <i>The SEHTerm sample application</i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<p><b>SEHTerm.cpp</b></p>
<PRE>
/******************************************************************************
Module:  SEHTerm.cpp
Notices: Copyright (c) 2000 Jeffrey Richter
******************************************************************************/

#include &quot;..\CmnHdr.h&quot;     /* See Appendix A. */
#include &lt;tchar.h&gt;

///////////////////////////////////////////////////////////////////////////////

int WINAPI _tWinMain(HINSTANCE hinstExe, HINSTANCE, PTSTR pszCmdLine, int) {

   _ _try {
      int n = MessageBox(NULL, TEXT(&quot;Perform invalid memory access?&quot;), 
         TEXT(&quot;SEHTerm: In try block&quot;), MB_YESNO);

      if (n == IDYES) {
         * (PBYTE) NULL = 5;  // This causes an access violation.
      }
   }
   _ _finally {
      PCTSTR psz = AbnormalTermination() 
         ? TEXT(&quot;Abnormal termination&quot;) : TEXT(&quot;Normal termination&quot;);
      MessageBox(NULL, psz, TEXT(&quot;SEHTerm: In finally block&quot;), MB_OK);
   }

   MessageBox(NULL, TEXT(&quot;Normal process termination&quot;), 
      TEXT(&quot;SEHTerm: After finally block&quot;), MB_OK);

   return(0);
}


//////////////////////////////// End of File /////////////////////////////////
</pre></td></tr></table></p>


</body>

</html>







