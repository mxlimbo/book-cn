<HTML>
<HEAD>
<TITLE>Determining the State of an Address Space</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch14c.htm">[Previous]</A> <A HREF="ch15a.htm">[Next]</A><P>

<A NAME="188"><H1>Determining the State of an Address Space</H1></A>

<p>Windows offers a function that lets you query certain information (for example, size, storage type, and protection attributes) about a memory address in your address space. In fact, the VMMap sample application shown later in this chapter uses this function to produce the virtual memory map dumps that appeared in <A HREF="ch13a.htm">Chapter 13</A>. This function is called <i>VirtualQuery</i>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD VirtualQuery(
   LPCVOID pvAddress,
   PMEMORY_BASIC_INFORMATION pmbi,
   DWORD dwLength);
</pre>
</td></tr></table></p>

<p>Windows also offers a function that allows one process to query memory information about another process:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD VirtualQueryEx(
   HANDLE hProcess, 
   LPCVOID pvAddress, 
   PMEMORY_BASIC_INFORMATION pmbi, 
   DWORD dwLength);
</pre>
</td></tr></table></p>

<p>The two functions are identical except that <i>VirtualQueryEx</i> allows you to pass the handle of a process whose address space you want to query. Debuggers and other utilities most often use this function&#8212;nearly all applications will need only to call <i>VirtualQuery</i>. When you call <i>VirtualQuery(Ex)</i>, the <i>pvAddress</i> parameter must contain the virtual memory address that you want information about. The <i>pmbi</i> parameter is the address to a MEMORY_BASIC_INFORMATION structure that you must allocate. This structure is defined in WinNT.h as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef struct _MEMORY_BASIC_INFORMATION {
   PVOID BaseAddress;
   PVOID AllocationBase;
   DWORD AllocationProtect;
   SIZE_T RegionSize;
   DWORD State;
   DWORD Protect;
   DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;
</pre>
</td></tr></table></p>

<p>The last parameter, <i>dwLength</i>, specifies the size of the
MEMORY_BASIC_INFORMATION structure. <i>VirtualQuery(Ex)</i> returns the number of bytes copied into the buffer.</p>

<p>Based on the address that you pass in the <i>pvAddress</i> parameter, <i>VirtualQuery(Ex)</i> fills the MEMORY_BASIC_INFORMATION structure with information about the range of adjoining pages that share the same state, protection attributes, and type. The following table offers a description of the structure's members.</p>

<p><table width="95%" cellpadding="5">
<tr>
<th>Member Name</th>
<th>Description</th>
</tr>
<tr>
<td valign="TOP"><i>BaseAddress</i></td>
<td valign="TOP">The same value as the <i>pvAddress</i> parameter rounded down to a page boundary.</td>
</tr>
<tr>
<td valign="TOP"><i>AllocationBase</i></td>
<td valign="TOP">Identifies the base address of the region containing the address specified in the <i>pvAddress</i> parameter.</td>
</tr>
<tr>
<td valign="TOP"><i>AllocationProtect</i></td>
<td valign="TOP">Identifies the protection attribute assigned to the region when it was initially reserved.</td>
</tr>
<tr>
<td valign="TOP"><i>RegionSize</i></td>
<td valign="TOP">Identifies the size, in bytes, for all pages starting at <i>BaseAddress</i> that have the same protection attributes, state, and type as the page containing the address specified in the <i>pvAddress</i> parameter.</td>
</tr>
<tr>
<td valign="TOP"><i>State</i></td>
<td valign="TOP">Identifies the state (MEM_FREE, MEM_RESERVE, or MEM_COMMIT) for all adjoining pages that have the same protection attributes, state, and type as the page containing the address specified in the <i>pvAddress</i> parameter.

<p>If the state is free, the <i>AllocationBase</i>, <i>AllocationProtect</i>, <i>Protect</i>, and <i>Type</i> members are undefined.</p>

<p>If the state is MEM_RESERVE, the <i>Protect</i> member is
undefined.</p></td>
</tr>
<tr>
<td valign="TOP"><i>Protect</i></td>
<td valign="TOP">Identifies the protection attribute (PAGE_*) for all adjoining pages that have the same protection attributes, state, and type as the page containing the address specified in the <i>pvAddress</i> parameter.</td>
</tr>
<tr>
<td valign="TOP"><i>Type</i></td>
<td valign="TOP">Identifies the type of physical storage (MEM_IMAGE, MEM_MAPPED, or MEM_PRIVATE) that is backing all adjoining pages that have the same protection attributes, state, and type as the page containing the address specified in the <i>pvAddress</i> parameter. For Windows 98, this member will always indicate MEM_PRIVATE.</td>
</tr>
</table></p>

<A NAME="189"><h2>The <i>VMQuery</i> Function</h2></A>
<p>When I was first learning about Windows memory architecture, I used <i>VirtualQuery</i> as my guide. In fact, if you examine the first edition of this book, you'll see that the VMMap sample application was much simpler than the new version I present in the next section. In the old version, I had a simple loop that repeatedly called <i>VirtualQuery</i>, and for each call I simply constructed a single line containing the members of the MEMORY_BASIC_INFORMATION structure. I studied this dump and tried to piece the memory management architecture together while referring to the SDK documentation (which was rather poor at the time). Well, I've learned a lot since then. While <i>VirtualQuery</i> and the MEMORY_BASIC_INFORMATION structure give you a lot of insight into what's going on, I now know that they don't give you enough information to really understand it all.</p>

<p>The problem is that the MEMORY_BASIC_INFORMATION structure does not return all of the information that the system has stored internally. If you have a memory address and want to obtain some simple information about it, <i>VirtualQuery</i> is great. If you just want to know whether there is committed physical storage to an address or whether a memory address can be read from or written to, <i>VirtualQuery</i> works fine. But if you want to know the total size of a reserved region or the number of blocks in a region or whether a region contains a thread's stack, a single call to <i>VirtualQuery</i> is just not going to give you the information you're looking for.</p>

<p>To obtain much more complete memory information, I have created my own function, <i>VMQuery</i>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL VMQuery(
   HANDLE hProcess, 
   PVOID pvAddress, 
   PVMQUERY pVMQ);
</pre>
</td></tr></table></p>

<p>This function is similar to <i>VirtualQueryEx</i> in that it takes a process handle (in <i>hProcess</i>), a memory address (in <i>pvAddress</i>), and a pointer to a structure that is to be filled (specified by <i>pVMQ</i>). This structure is a <i>VMQUERY</i> structure that I have also defined:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef struct {
   // Region information
   PVOID pvRgnBaseAddress;
   DWORD dwRgnProtection;  // PAGE_*
   SIZE_T RgnSize;
   DWORD dwRgnStorage;     // MEM_*: Free, Image, Mapped, Private
   DWORD dwRgnBlocks;
   DWORD dwRgnGuardBlks;   // If &gt; 0, region contains thread stack
   BOOL fRgnIsAStack;      // TRUE if region contains thread stack

   // Block information
   PVOID pvBlkBaseAddress;
   DWORD dwBlkProtection;  // PAGE_*
   SIZE_T BlkSize;
   DWORD dwBlkStorage;     // 
 MEM_*: Free, Reserve, Image, Mapped, Private
} VMQUERY, *PVMQUERY;
</pre>
</td></tr></table></p>

<p>As you can see from just a quick glance, my VMQUERY structure
contains much more information than the Windows MEMORY_BASIC_ 
INFORMATION structure. My structure is divided into two distinct parts: region information and block information. The region portion describes information about the region, and the block portion includes information about the block containing the address specified by the <i>pvAddress</i> parameter. The following table describes all the members.</p>

<p><table width="95%" cellpadding="5">
<tr>
<th>Member Name</th>
<th>Description</th>
</tr>
<tr>
<td valign="TOP"><i>pvRgnBaseAddress</i></td>
<td valign="TOP">Identifies the base address of the virtual address space region containing the address specified in the <i>pvAddress</i> parameter.</td>
</tr>
<tr>
<td valign="TOP"><i>dwRgnProtection</i></td>
<td valign="TOP">Identifies the protection attribute (PAGE_*) that was assigned to the region of address space when it was initially reserved.</td>
</tr>
<tr>
<td valign="TOP"><i>RgnSize</i></td>
<td valign="TOP">Identifies the size, in bytes, of the region that was reserved. </td>
</tr>
<tr>
<td valign="TOP"><i>dwRgnStorage</i> </td>
<td valign="TOP">Identifies the type of physical storage that is used for the bulk of the blocks in the region. The value is one of the following: MEM_FREE, MEM_IMAGE, MEM_MAPPED, or MEM_ 
PRIVATE. Windows 98 doesn't distinguish between different storage
types, so this member will always be MEM_FREE or MEM_PRIVATE under Windows 98.</td>
</tr>
<tr>
<td valign="TOP"><i>dwRgnBlocks</i></td>
<td valign="TOP">Identifies the number of blocks contained within the region.</td>
</tr>
<tr>
<td valign="TOP"><i>dwRgnGuardBlks</i></td>
<td valign="TOP">Identifies the number of blocks that have the PAGE_GUARD protection attribute flag turned on. This value will usually be either 0 or 1. If it's 1, that's a good indicator that the region was reserved to contain a thread's stack. Under Windows 98, this member will always be 0.</td>
</tr>
<tr>
<td valign="TOP"><i>fRgnIsAStack</i></td>
<td valign="TOP">Identifies whether the region contains a thread's stack. This value is determined by taking a &quot;best guess&quot; because it is impossible to be 100 percent sure whether a region contains a stack.</td>
</tr>
<tr>
<td valign="TOP"><i>pvBlkBaseAddress</i></td>
<td valign="TOP">Identifies the base address of the block that contains the address specified in the <i>pvAddress</i> parameter.</td>
</tr>
<tr>
<td valign="TOP"><i>dwBlkProtection</i></td>
<td valign="TOP">Identifies the protection attribute for the block that contains the address specified in the <i>pvAddress</i>
parameter.</td>
</tr>
<tr>
<td valign="TOP"><i>BlkSize</i></td>
<td valign="TOP">Identifies the size, in bytes, of the block that contains the address specified in the <i>pvAddress</i> parameter.</td>
</tr>
<tr>
<td valign="TOP"><i>dwBlkStorage</i></td>
<td valign="TOP">Identifies the content of the block that contains the address specified in the <i>pvAddress</i> parameter. The value is one of the following: MEM_FREE, MEM_RESERVE, MEM_IMAGE, MEM_MAPPED, or MEM_PRIVATE. Under Windows 98, this member will never be MEM_IMAGE or MEM_MAPPED. </td>
</tr>
</table></p>

<p>No doubt <i>VMQuery</i> must do a significant amount of processing, including many calls to <i>VirtualQueryEx</i>, in order to obtain all this information&#8212;which means it executes much more slowly than <i>VirtualQueryEx</i>. For this reason, you should think carefully when deciding which of these two functions to call. If you do not need the extra information obtained by <i>VMQuery</i>, call <i>VirtualQuery</i>
or <i>VirtualQueryEx</i>.</p>

<p>The VMQuery.cpp file, listed in Figure 14-3, shows how I obtain and massage all the information needed to set the members of the VMQUERY structure. The VMQuery.cpp and VMQuery.h files are in the 14-VMMap directory on the companion CD-ROM. Rather than go into detail in the text about how I process this data, I'll let my comments (sprinkled liberally throughout the code) speak for themselves.</p>

<p>
<b>Figure 14-3.</b> <i>The VMQuery listings</i>
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<p><b>VMQuery.cpp</b></p>
<PRE>
/******************************************************************************
Module:  VMQuery.cpp
Notices: Copyright (c) 2000 Jeffrey Richter
******************************************************************************/

#include &quot;..\CmnHdr.h&quot;     /* See Appendix A. */
#include &lt;windowsx.h&gt;
#include &quot;VMQuery.h&quot;

///////////////////////////////////////////////////////////////////////////////

// Helper structure
typedef struct {
   SIZE_T RgnSize;
   DWORD  dwRgnStorage;     // MEM_*: Free, Image, Mapped, Private
   DWORD  dwRgnBlocks;
   DWORD  dwRgnGuardBlks;   // If &gt; 0, region contains thread stack
   BOOL   fRgnIsAStack;     // TRUE if region contains thread stack
} VMQUERY_HELP;


// This global, static variable holds the allocation granularity value for 
// this CPU platform. Initialized the first time VMQuery is called.
static DWORD gs_dwAllocGran = 0;


///////////////////////////////////////////////////////////////////////////////


// Iterates through a region's blocks and returns findings in VMQUERY_HELP
static BOOL VMQueryHelp(HANDLE hProcess, LPCVOID pvAddress, 
   VMQUERY_HELP *pVMQHelp) {

   // Each element contains a page protection
   // (i.e.: 0=reserved, PAGE_NOACCESS, PAGE_READWRITE, etc.)
   DWORD dwProtectBlock[4] = { 0 }; 

   ZeroMemory(pVMQHelp, sizeof(*pVMQHelp));

   // Get address of region containing passed memory address.
   MEMORY_BASIC_INFORMATION mbi;
   BOOL fOk = (VirtualQueryEx(hProcess, pvAddress, &amp;mbi, sizeof(mbi)) 
      == sizeof(mbi));

   if (!fOk)
      return(fOk);   // Bad memory address, return failure

   // Walk starting at the region's base address (which never changes)
   PVOID pvRgnBaseAddress = mbi.AllocationBase;

   // Walk starting at the first block in the region (changes in the loop)
   PVOID pvAddressBlk = pvRgnBaseAddress;

   // Save the memory type of the physical storage block.
   pVMQHelp-&gt;dwRgnStorage = mbi.Type;

   for (;;) {
      // Get info about the current block.
      fOk = (VirtualQueryEx(hProcess, pvAddressBlk, &amp;mbi, sizeof(mbi)) 
         == sizeof(mbi));
      if (!fOk)
         break;   // Couldn't get the information, end loop.

      // Is this block in the same region?
      if (mbi.AllocationBase != pvRgnBaseAddress)
         break;   // Found a block in the next region; end loop.

      // We have a block contained in the region.

      // The following if statement is for detecting stacks in Windows 98.
      // A Windows 98 stack region's last 4 blocks look like this:
      // reserved block, no access block, read-write block, reserved block
      if (pVMQHelp-&gt;dwRgnBlocks &lt; 4) {
         // 0th through 3rd block, remember the block's protection
         dwProtectBlock[pVMQHelp-&gt;dwRgnBlocks] = 
            (mbi.State == MEM_RESERVE) ? 0 : mbi.Protect;
      } else {
         // We've seen 4 blocks in this region.
         // Shift the protection values down in the array.
         MoveMemory(&amp;dwProtectBlock[0], &amp;dwProtectBlock[1], 
            sizeof(dwProtectBlock) - sizeof(DWORD));

         // Add the new protection value to the end of the array.
         dwProtectBlock[3] = (mbi.State == MEM_RESERVE) ? 0 : mbi.Protect;
      }

      pVMQHelp-&gt;dwRgnBlocks++;             // Add another block to the region
      pVMQHelp-&gt;RgnSize += mbi.RegionSize; // Add block's size to region size

      // If block has PAGE_GUARD attribute, add 1 to this counter
      if ((mbi.Protect &amp; PAGE_GUARD) == PAGE_GUARD)
         pVMQHelp-&gt;dwRgnGuardBlks++;

      // Take a best guess as to the type of physical storage committed to the
      // block. This is a guess because some blocks can convert from MEM_IMAGE
      // to MEM_PRIVATE or from MEM_MAPPED to MEM_PRIVATE; MEM_PRIVATE can
      // always be overridden by MEM_IMAGE or MEM_MAPPED.
      if (pVMQHelp-&gt;dwRgnStorage == MEM_PRIVATE)
         pVMQHelp-&gt;dwRgnStorage = mbi.Type;

      // Get the address of the next block.
      pvAddressBlk = (PVOID) ((PBYTE) pvAddressBlk + mbi.RegionSize);
   }

   // After examining the region, check to see whether it is a thread stack
   // Windows 2000: Assume stack if region has at least 1 PAGE_GUARD block
   // Windows 9x:   Assume stack if region has at least 4 blocks with
   //               3rd block from end: reserved
   //               2nd block from end: PAGE_NOACCESS
   //               1st block from end: PAGE_READWRITE
   //               block at end: another reserved block.
   pVMQHelp-&gt;fRgnIsAStack =
      (pVMQHelp-&gt;dwRgnGuardBlks &gt; 0)         ||
      ((pVMQHelp-&gt;dwRgnBlocks &gt;= 4)          &amp;&amp;
      (dwProtectBlock[0] == 0)               &amp;&amp; 
      (dwProtectBlock[1] == PAGE_NOACCESS)  &amp;&amp;
      (dwProtectBlock[2] == PAGE_READWRITE) &amp;&amp;
      (dwProtectBlock[3] == 0));

   return(TRUE);
}


///////////////////////////////////////////////////////////////////////////////


BOOL VMQuery(HANDLE hProcess, LPCVOID pvAddress, PVMQUERY pVMQ) {

   if (gs_dwAllocGran == 0) {
      // Set allocation granularity if this is the first call
      SYSTEM_INFO sinf;
      GetSystemInfo(&amp;sinf);
      gs_dwAllocGran = sinf.dwAllocationGranularity;
   }

   ZeroMemory(pVMQ, sizeof(*pVMQ));

   // Get the MEMORY_BASIC_INFORMATION for the passed address.
   MEMORY_BASIC_INFORMATION mbi;
   BOOL fOk = (VirtualQueryEx(hProcess, pvAddress, &amp;mbi, sizeof(mbi)) 
      == sizeof(mbi));

   if (!fOk)
      return(fOk);   // Bad memory address, return failure

   // The MEMORY_BASIC_INFORMATION structure contains valid information.
   // Time to start setting the members of our own VMQUERY structure.

   // First, fill in the block members. We'll fill the region members later.
   switch (mbi.State) {
      case MEM_FREE:       // Free block (not reserved)
         pVMQ-&gt;pvBlkBaseAddress = NULL;
         pVMQ-&gt;BlkSize = 0;
         pVMQ-&gt;dwBlkProtection = 0;
         pVMQ-&gt;dwBlkStorage = MEM_FREE;
         break;

      case MEM_RESERVE:    // Reserved block without committed storage in it.
         pVMQ-&gt;pvBlkBaseAddress = mbi.BaseAddress;
         pVMQ-&gt;BlkSize = mbi.RegionSize;

         // For an uncommitted block, mbi.Protect is invalid. So we will 
         // show that the reserved block inherits the protection attribute 
         // of the region in which it is contained.
         pVMQ-&gt;dwBlkProtection = mbi.AllocationProtect;  
         pVMQ-&gt;dwBlkStorage = MEM_RESERVE;
         break;

      case MEM_COMMIT:     // Reserved block with committed storage in it.
         pVMQ-&gt;pvBlkBaseAddress = mbi.BaseAddress;
         pVMQ-&gt;BlkSize = mbi.RegionSize;
         pVMQ-&gt;dwBlkProtection = mbi.Protect;   
         pVMQ-&gt;dwBlkStorage = mbi.Type;
         break;

      default:
         DebugBreak();
         break;
   }

   // Now fill in the region data members.
   VMQUERY_HELP VMQHelp;
   switch (mbi.State) {
      case MEM_FREE:       // Free block (not reserved)
         pVMQ-&gt;pvRgnBaseAddress = mbi.BaseAddress;
         pVMQ-&gt;dwRgnProtection  = mbi.AllocationProtect;
         pVMQ-&gt;RgnSize          = mbi.RegionSize;
         pVMQ-&gt;dwRgnStorage     = MEM_FREE;
         pVMQ-&gt;dwRgnBlocks      = 0;
         pVMQ-&gt;dwRgnGuardBlks   = 0;
         pVMQ-&gt;fRgnIsAStack     = FALSE;
         break;

      case MEM_RESERVE:    // Reserved block without committed storage in it.
         pVMQ-&gt;pvRgnBaseAddress = mbi.AllocationBase;
         pVMQ-&gt;dwRgnProtection  = mbi.AllocationProtect;

         // Iterate through all blocks to get complete region information.
         VMQueryHelp(hProcess, pvAddress, &amp;VMQHelp);

         pVMQ-&gt;RgnSize          = VMQHelp.RgnSize;
         pVMQ-&gt;dwRgnStorage     = VMQHelp.dwRgnStorage;
         pVMQ-&gt;dwRgnBlocks      = VMQHelp.dwRgnBlocks;
         pVMQ-&gt;dwRgnGuardBlks   = VMQHelp.dwRgnGuardBlks;
         pVMQ-&gt;fRgnIsAStack     = VMQHelp.fRgnIsAStack;
         break;

      case MEM_COMMIT:     // Reserved block with committed storage in it.
         pVMQ-&gt;pvRgnBaseAddress = mbi.AllocationBase;
         pVMQ-&gt;dwRgnProtection  = mbi.AllocationProtect;

         // Iterate through all blocks to get complete region information.
         VMQueryHelp(hProcess, pvAddress, &amp;VMQHelp);

         pVMQ-&gt;RgnSize          = VMQHelp.RgnSize;
         pVMQ-&gt;dwRgnStorage     = VMQHelp.dwRgnStorage;
         pVMQ-&gt;dwRgnBlocks      = VMQHelp.dwRgnBlocks;
         pVMQ-&gt;dwRgnGuardBlks   = VMQHelp.dwRgnGuardBlks;
         pVMQ-&gt;fRgnIsAStack     = VMQHelp.fRgnIsAStack;
         break;

      default:
         DebugBreak();
         break;
   }

   return(fOk);
}

//////////////////////////////// End of File //////////////////////////////////
</PRE>
</TD></TR></TABLE></P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<p><b>VMQuery.h</b></p>
<PRE>
/******************************************************************************
Module:  VMQuery.h
Notices: Copyright (c) 2000 Jeffrey Richter
******************************************************************************/

typedef struct {
   // Region information
   PVOID  pvRgnBaseAddress;
   DWORD  dwRgnProtection;  // PAGE_*
   SIZE_T RgnSize;
   DWORD  dwRgnStorage;     // MEM_*: Free, Image, Mapped, Private
   DWORD  dwRgnBlocks;
   DWORD  dwRgnGuardBlks;   // If &gt; 0, region contains thread stack
   BOOL   fRgnIsAStack;     // TRUE if region contains thread stack
   // Block information
   PVOID  pvBlkBaseAddress;
   DWORD  dwBlkProtection;  // PAGE_*
   SIZE_T BlkSize;
   DWORD  dwBlkStorage;     // MEM_*: Free, Reserve, Image, Mapped, Private
} VMQUERY, *PVMQUERY;

///////////////////////////////////////////////////////////////////////////////

BOOL VMQuery(HANDLE hProcess, LPCVOID pvAddress, PVMQUERY pVMQ);


//////////////////////////////// End of File //////////////////////////////////
</pre>
</td></tr></table></p>

<A NAME="190"><H2>The Virtual Memory Map Sample Application</H2></A>

<p>The VMMap application (14 VMMap.exe), listed in Figure 14-4, walks a process's address space and shows the regions and the blocks within regions. The source code and resource files for the application are in the 14-VMMap directory on the companion CD-ROM. When you start the program, the following window appears.</p>

<p>
<A HREF="javascript:fullSize('G14si03x.htm')"> <img src="images/G14si03.JPG" width=404 height=288 border=0 ALT="Click to view at full size."> </A>
</p>

<p>I used the contents of this application's list box to produce the virtual memory map dumps presented in Table 13-2, Table 13-3, and Table 13-4 in <A HREF="ch13a.htm">Chapter 13</A>.</p>

<p>Each entry in the list box shows the result of information obtained by calling my <i>VMQuery</i> function. The main loop, in the <i>Refresh</i> function, looks like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL fOk = TRUE;
PVOID pvAddress = NULL;

<img src="images/grayvellip.JPG" width=3 height=13 border="0">

while (fOk) {

   VMQUERY vmq;
   fOk = VMQuery(hProcess, pvAddress, &amp;vmq);

   if (fOk) {
      // Construct the line to be displayed, and add it to the list box.
      TCHAR szLine[1024];
      ConstructRgnInfoLine(hProcess, &amp;vmq, szLine, sizeof(szLine));
      ListBox_AddString(hwndLB, szLine);

      if (fExpandRegions) {
         for (DWORD dwBlock = 0; fOk &amp;&amp; (dwBlock &lt; vmq.dwRgnBlocks);
            dwBlock++) {

            ConstructBlkInfoLine(&amp;vmq, szLine, sizeof(szLine));
            ListBox_AddString(hwndLB, szLine);

            // Get the address of the next region to test.
            pvAddress = ((PBYTE) pvAddress + vmq.BlkSize);
            if (dwBlock &lt; vmq.dwRgnBlocks - 1) {
               // Don't query the memory info after the last block.
               fOk = VMQuery(hProcess, pvAddress, &amp;vmq);
            }
         }
      }

      // Get the address of the next region to test.
      pvAddress = ((PBYTE) vmq.pvRgnBaseAddress + vmq.RgnSize);
   }
}
</pre>
</td></tr></table></p>

<p>This loop starts walking from virtual address NULL and ends when <i>VMQuery</i> returns FALSE, indicating that it can no longer walk the process's address space. With each iteration of the loop, there is a call to <i>ConstructRgnInfoLine</i>; this function fills a character buffer with information about the region. Then this information is appended to the list box.</p>

<p>Within this main loop is a nested loop that iterates through each block in the region. Each iteration of this loop calls <i>ConstructBlkInfoLine</i> to fill a character buffer with information about the region's blocks. Then the information is appended to the list box. It's easy to walk the process's address space using the <i>VMQuery</i> function.</p>

<p>
<b>Figure 14-4.</b> <i>The VMMap application</i>
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<p><b>VMMap.cpp</b></p>
<PRE>
/******************************************************************************
Module:  VMMap.cpp
Notices: Copyright (c) 2000 Jeffrey Richter
******************************************************************************/


#include &quot;..\CmnHdr.h&quot;     /* See Appendix A. */
#include &lt;psapi.h&gt;
#include &lt;windowsx.h&gt;
#include &lt;tchar.h&gt;
#include &lt;stdio.h&gt;         // For sprintf
#include &quot;..\04-ProcessInfo\Toolhelp.h&quot;
#include &quot;Resource.h&quot;
#include &quot;VMQuery.h&quot;


///////////////////////////////////////////////////////////////////////////////


DWORD g_dwProcessId = 0;  // Which process to walk?
BOOL  g_fExpandRegions = FALSE;
CToolhelp g_toolhelp;


// GetMappedFileName is only on Windows 2000 in PSAPI.DLL
// If this function exists on the host system, we'll use it
typedef DWORD (WINAPI* PFNGETMAPPEDFILENAME)(HANDLE, PVOID, PTSTR, DWORD);
static PFNGETMAPPEDFILENAME g_pfnGetMappedFileName = NULL;


///////////////////////////////////////////////////////////////////////////////


// I use this function to obtain the dump figures in the book.
void CopyControlToClipboard(HWND hwnd) {
   TCHAR szClipData[128 * 1024] = { 0 };

   int nCount = ListBox_GetCount(hwnd);
   for (int nNum = 0; nNum &lt; nCount; nNum++) {
      TCHAR szLine[1000];
      ListBox_GetText(hwnd, nNum, szLine);
      _tcscat(szClipData, szLine);
      _tcscat(szClipData, TEXT(&quot;\r\n&quot;));
   }        

   OpenClipboard(NULL); 
   EmptyClipboard();

   // Clipboard accepts only data that is in a block allocated 
   // with GlobalAlloc using the GMEM_MOVEABLE and GMEM_DDESHARE flags.
   HGLOBAL hClipData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, 
      sizeof(TCHAR) * (_tcslen(szClipData) + 1));
   PTSTR pClipData = (PTSTR) GlobalLock(hClipData);
   
   _tcscpy(pClipData, szClipData);

#ifdef UNICODE
   BOOL fOk = (SetClipboardData(CF_UNICODETEXT, hClipData) == hClipData);
#else
   BOOL fOk = (SetClipboardData(CF_TEXT, hClipData) == hClipData);
#endif
   CloseClipboard();

   if (!fOk) {
      GlobalFree(hClipData);
      chMB(&quot;Error putting text on the clipboard&quot;);
   }
}


///////////////////////////////////////////////////////////////////////////////


PCTSTR GetMemStorageText(DWORD dwStorage) {

   PCTSTR p = TEXT(&quot;Unknown&quot;);
   switch (dwStorage) {
   case MEM_FREE:    p = TEXT(&quot;Free   &quot;); break;
   case MEM_RESERVE: p = TEXT(&quot;Reserve&quot;); break;
   case MEM_IMAGE:   p = TEXT(&quot;Image  &quot;); break;
   case MEM_MAPPED:  p = TEXT(&quot;Mapped &quot;); break;
   case MEM_PRIVATE: p = TEXT(&quot;Private&quot;); break;
   }
   return(p);
}


///////////////////////////////////////////////////////////////////////////////


PTSTR GetProtectText(DWORD dwProtect, PTSTR szBuf, BOOL fShowFlags) {

   PCTSTR p = TEXT(&quot;Unknown&quot;);
   switch (dwProtect &amp; ~(PAGE_GUARD | PAGE_NOCACHE | PAGE_WRITECOMBINE)) {
   case PAGE_READONLY:          p = TEXT(&quot;-R--&quot;); break;
   case PAGE_READWRITE:         p = TEXT(&quot;-RW-&quot;); break;
   case PAGE_WRITECOPY:         p = TEXT(&quot;-RWC&quot;); break;
   case PAGE_EXECUTE:           p = TEXT(&quot;E---&quot;); break;
   case PAGE_EXECUTE_READ:      p = TEXT(&quot;ER--&quot;); break;
   case PAGE_EXECUTE_READWRITE: p = TEXT(&quot;ERW-&quot;); break;
   case PAGE_EXECUTE_WRITECOPY: p = TEXT(&quot;ERWC&quot;); break;
   case PAGE_NOACCESS:          p = TEXT(&quot;----&quot;); break;
   }
   _tcscpy(szBuf, p);
   if (fShowFlags) {
      _tcscat(szBuf, TEXT(&quot; &quot;));
      _tcscat(szBuf, (dwProtect &amp; PAGE_GUARD)        ? TEXT(&quot;G&quot;) : TEXT(&quot;-&quot;));
      _tcscat(szBuf, (dwProtect &amp; PAGE_NOCACHE)      ? TEXT(&quot;N&quot;) : TEXT(&quot;-&quot;));
      _tcscat(szBuf, (dwProtect &amp; PAGE_WRITECOMBINE) ? TEXT(&quot;W&quot;) : TEXT(&quot;-&quot;));
   }
   return(szBuf);
}


///////////////////////////////////////////////////////////////////////////////


void ConstructRgnInfoLine(HANDLE hProcess, PVMQUERY pVMQ, 
   PTSTR szLine, int nMaxLen) {

   _stprintf(szLine, TEXT(&quot;%p     %s  %16u  &quot;),
      pVMQ-&gt;pvRgnBaseAddress,
      GetMemStorageText(pVMQ-&gt;dwRgnStorage),
      pVMQ-&gt;RgnSize);

   if (pVMQ-&gt;dwRgnStorage != MEM_FREE) {
      wsprintf(_tcschr(szLine, 0), TEXT(&quot;%5u  &quot;), pVMQ-&gt;dwRgnBlocks);
      GetProtectText(pVMQ-&gt;dwRgnProtection, _tcschr(szLine, 0), FALSE);
   }

   _tcscat(szLine, TEXT(&quot;     &quot;));

   // Try to obtain the module pathname for this region.
   int nLen = _tcslen(szLine);
   if (pVMQ-&gt;pvRgnBaseAddress != NULL) {
      MODULEENTRY32 me = { sizeof(me) };
      
      if (g_toolhelp.ModuleFind(pVMQ-&gt;pvRgnBaseAddress, &amp;me)) {
         lstrcat(&amp;szLine[nLen], me.szExePath);
      } else {
         // This is not a module; see if it's a memory-mapped file
         if (g_pfnGetMappedFileName != NULL) {
            DWORD d = g_pfnGetMappedFileName(hProcess,  
               pVMQ-&gt;pvRgnBaseAddress, szLine + nLen, nMaxLen - nLen);
            if (d == 0) {
               // NOTE: GetMappedFileName modifies the string when it fails
               szLine[nLen] = 0;
            }
         }
      }
   }

   if (pVMQ-&gt;fRgnIsAStack) {
      _tcscat(szLine, TEXT(&quot;Thread Stack&quot;));
   }
}


///////////////////////////////////////////////////////////////////////////////


void ConstructBlkInfoLine(PVMQUERY pVMQ, PTSTR szLine, int nMaxLen) {

   _stprintf(szLine, TEXT(&quot;   %p  %s  %16u         &quot;),
      pVMQ-&gt;pvBlkBaseAddress,
      GetMemStorageText(pVMQ-&gt;dwBlkStorage),
      pVMQ-&gt;BlkSize);

   if (pVMQ-&gt;dwBlkStorage != MEM_FREE) {
      GetProtectText(pVMQ-&gt;dwBlkProtection, _tcschr(szLine, 0), TRUE);
   }
}


///////////////////////////////////////////////////////////////////////////////


void Refresh(HWND hwndLB, DWORD dwProcessId, BOOL fExpandRegions) {

   // Delete contents of list box &amp; add a horizontal scroll bar
   ListBox_ResetContent(hwndLB);
   ListBox_SetHorizontalExtent(hwndLB, 300 * LOWORD(GetDialogBaseUnits()));

   // Is the process still running?
   HANDLE hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, 
      FALSE, dwProcessId);

   if (hProcess == NULL) {
      ListBox_AddString(hwndLB, TEXT(&quot;&quot;));   // Blank line, looks better
      ListBox_AddString(hwndLB, 
         TEXT(&quot;    The process ID identifies a process that is not running&quot;));
      return;
   }

   // Grab a new snapshot of the process
   g_toolhelp.CreateSnapshot(TH32CS_SNAPALL, dwProcessId);
   
   // Walk the virtual address space, adding entries to the list box.
   BOOL fOk = TRUE;
   PVOID pvAddress = NULL;

   SetWindowRedraw(hwndLB, FALSE);
   while (fOk) {

      VMQUERY vmq;
      fOk = VMQuery(hProcess, pvAddress, &amp;vmq);

      if (fOk) {
         // Construct the line to be displayed, and add it to the list box.
         TCHAR szLine[1024];
         ConstructRgnInfoLine(hProcess, &amp;vmq, szLine, sizeof(szLine));
         ListBox_AddString(hwndLB, szLine);

         if (fExpandRegions) {
            for (DWORD dwBlock = 0; fOk &amp;&amp; (dwBlock &lt; vmq.dwRgnBlocks);
               dwBlock++) {

               ConstructBlkInfoLine(&amp;vmq, szLine, sizeof(szLine));
               ListBox_AddString(hwndLB, szLine);

               // Get the address of the next region to test.
               pvAddress = ((PBYTE) pvAddress + vmq.BlkSize);
               if (dwBlock &lt; vmq.dwRgnBlocks - 1) {
                  // Don't query the memory info after the last block.
                  fOk = VMQuery(hProcess, pvAddress, &amp;vmq);
               }
            }
         }

         // Get the address of the next region to test.
         pvAddress = ((PBYTE) vmq.pvRgnBaseAddress + vmq.RgnSize);
      }
   }
   SetWindowRedraw(hwndLB, TRUE);
   CloseHandle(hProcess);


///////////////////////////////////////////////////////////////////////////////


BOOL Dlg_OnInitDialog(HWND hwnd, HWND hwndFocus, LPARAM lParam) {

   chSETDLGICONS(hwnd, IDI_VMMAP);

   // Show which process we're walking in the window's caption
   TCHAR szCaption[MAX_PATH * 2];
   GetWindowText(hwnd, szCaption, chDIMOF(szCaption));
   g_toolhelp.CreateSnapshot(TH32CS_SNAPALL, g_dwProcessId);
   PROCESSENTRY32 pe = { sizeof(pe) };
   wsprintf(&amp;szCaption[lstrlen(szCaption)], TEXT(&quot; (PID=%u \&quot;%s\&quot;)&quot;), 
      g_dwProcessId, g_toolhelp.ProcessFind(g_dwProcessId, &amp;pe) 
         ? pe.szExeFile : TEXT(&quot;unknown&quot;));
   SetWindowText(hwnd, szCaption);

   // VMMap has so much info to show, let's maximize it by default
   ShowWindow(hwnd, SW_MAXIMIZE);

   // Force the list box to refresh itself
   Refresh(GetDlgItem(hwnd, IDC_LISTBOX), g_dwProcessId, g_fExpandRegions);
   return(TRUE);
}


///////////////////////////////////////////////////////////////////////////////


void Dlg_OnSize(HWND hwnd, UINT state, int cx, int cy) {

   // The list box always fills the whole client area
   SetWindowPos(GetDlgItem(hwnd, IDC_LISTBOX), NULL, 0, 0, cx, cy, 
      SWP_NOZORDER);
}


///////////////////////////////////////////////////////////////////////////////


void Dlg_OnCommand(HWND hwnd, int id, HWND hwndCtl, UINT codeNotify) {

   switch (id) {
      case IDCANCEL:
         EndDialog(hwnd, id);
         break;

      case ID_REFRESH:
         Refresh(GetDlgItem(hwnd, IDC_LISTBOX), 
            g_dwProcessId, g_fExpandRegions);
         break;

      case ID_EXPANDREGIONS:
         g_fExpandRegions = g_fExpandRegions ? FALSE: TRUE;
         Refresh(GetDlgItem(hwnd, IDC_LISTBOX), 
            g_dwProcessId, g_fExpandRegions);
         break;
      case ID_COPYTOCLIPBOARD:
         CopyControlToClipboard(GetDlgItem(hwnd, IDC_LISTBOX));
         break;
   }
}


///////////////////////////////////////////////////////////////////////////////


INT_PTR WINAPI Dlg_Proc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {

   switch (uMsg) {
      chHANDLE_DLGMSG(hwnd, WM_INITDIALOG, Dlg_OnInitDialog);
      chHANDLE_DLGMSG(hwnd, WM_COMMAND,    Dlg_OnCommand);
      chHANDLE_DLGMSG(hwnd, WM_SIZE,       Dlg_OnSize);
   }
   return(FALSE);
}


///////////////////////////////////////////////////////////////////////////////


int WINAPI _tWinMain(HINSTANCE hinstExe, HINSTANCE, PTSTR pszCmdLine, int) {

   CToolhelp::EnableDebugPrivilege();

   // Try to load PSAPI.DLL and get the address of GetMappedFileName
   HMODULE hmodPSAPI = LoadLibrary(TEXT(&quot;PSAPI&quot;));
   if (hmodPSAPI != NULL) {
#ifdef UNICODE
      g_pfnGetMappedFileName = (PFNGETMAPPEDFILENAME) 
         GetProcAddress(hmodPSAPI, &quot;GetMappedFileNameW&quot;);
#else
      g_pfnGetMappedFileName = (PFNGETMAPPEDFILENAME) 
         GetProcAddress(hmodPSAPI, &quot;GetMappedFileNameA&quot;);
#endif      
   }

   g_dwProcessId = _ttoi(pszCmdLine);
   if (g_dwProcessId == 0) {
      g_dwProcessId = GetCurrentProcessId();
   }

   DialogBox(hinstExe, MAKEINTRESOURCE(IDD_VMMAP), NULL, Dlg_Proc);

   if (hmodPSAPI != NULL) 
      FreeLibrary(hmodPSAPI); // Free PSAPI.DLL if we loaded it

   return(0);
}


//////////////////////////////// End of File //////////////////////////////////
</PRE>
</TD></TR></TABLE></P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<p><b>VMMap.rc</b></p>
<PRE>
//Microsoft Developer Studio generated resource script.
//
#include &quot;Resource.h&quot;

#define APSTUDIO_READONLY_SYMBOLS
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include &quot;afxres.h&quot;

/////////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

/////////////////////////////////////////////////////////////////////////////
// English (U.S.) resources

#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
#ifdef _WIN32
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
#endif //_WIN32

#ifdef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE DISCARDABLE 
BEGIN
    &quot;Resource.h\0&quot;
END

2 TEXTINCLUDE DISCARDABLE 
BEGIN
   &quot;#include &quot;&quot;afxres.h&quot;&quot;\r\n&quot;
   &quot;\0&quot;
END

3 TEXTINCLUDE DISCARDABLE 
BEGIN
   &quot;\r\n&quot;
   &quot;\0&quot;
END

#endif    // APSTUDIO_INVOKED

/////////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_VMMAP DIALOG DISCARDABLE  10, 18, 250, 250
STYLE WS_MINIMIZEBOX | WS_MAXIMIZEBOX | WS_POPUP | WS_VISIBLE | WS_CAPTION | 
    WS_SYSMENU | WS_THICKFRAME
CAPTION "Virtual Memory Map"
MENU IDR_VMMAP
FONT 8, "Courier"
BEGIN
   LISTBOX         IDC_LISTBOX,0,0,248,248,LBS_NOINTEGRALHEIGHT | NOT 
                   WS_BORDER | WS_VSCROLL | WS_HSCROLL | WS_GROUP | 
                   WS_TABSTOP
END


/////////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDI_VMMAP               ICON    DISCARDABLE     "VMMap.Ico"

/////////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_VMMAP MENU DISCARDABLE 
BEGIN
   MENUITEM "&amp;Refresh!",                   ID_REFRESH
   MENUITEM "&amp;Expand Regions!",            ID_EXPANDREGIONS
   MENUITEM &amp;Copy to Clipboard!,         ID_COPYTOCLIPBOARD
END

#endif    // English (U.S.) resources
/////////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//


/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED









</pre>
</td></tr></table></p>

</body>
</html>







