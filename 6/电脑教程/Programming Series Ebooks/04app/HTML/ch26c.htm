<HTML>
<HEAD>
<TITLE>Posting Messages to a Thread's Message Queue</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch26b.htm">[Previous]</A> <A HREF="ch26d.htm">[Next]</A><P>

<A NAME="350"><H1>Posting Messages to a Thread's Message Queue</H1></A>

<p>Once a thread has a THREADINFO structure associated with it, the
thread also has its very own set of message queues. If a single process
creates three threads and all these threads call <i>CreateWindow</i>,
there will be three message queue sets. Messages are placed in a
thread's posted-message queue by calling the <i>PostMessage</i>
function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL PostMessage(
   HWND hwnd, 
   UINT uMsg, 
   WPARAM wParam,
   LPARAM lParam);
</pre></td></tr></table></p>

<p>When a thread calls this function, the system determines which
thread created the window identified by the <i>hwnd</i> parameter. The
system then allocates a block of memory, stores the message parameters
in this block of memory, and appends the block of memory to the
appropriate thread's posted-message queue. In addition, the
function sets the QS_POSTMESSAGE wake bit (I'll discuss this
shortly). <i>PostMessage</i> returns immediately after posting the
message&#8212;the calling thread has no idea whether the posted message
was processed by the specified window's window procedure. In fact,
it is possible that the specified window will never receive the posted
message. This could happen if the thread that created the specified
window were somehow to terminate before processing all of the messages
in its queue.</p>

<p>A message can also be placed in a thread's posted-message queue
by calling <i>PostThreadMessage</i>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL PostThreadMessage(
   DWORD dwThreadId, 
   UINT uMsg, 
   WPARAM wParam,
   LPARAM lParam);
</pre></td></tr></table></p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
<p>You can determine which thread created a window by calling <i>GetWindowThreadProcessId</i>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD GetWindowThreadProcessId(
   HWND hwnd, 
   PDWORD pdwProcessId);
</pre></td></tr></table></p>

<p>This function returns the system-wide unique ID of the
thread that created the window identified by the <i>hwnd</i> parameter.
You can also get the system-wide unique ID of the process that owns this thread by
passing the address of a DWORD for the <i>pdwProcessId</i> parameter.
Usually, we do not need the process ID and simply pass NULL for this
parameter.</p>
</blockquote></div></p>

<p>The desired thread is identified by the first parameter, 
<i>dwThreadId</i>. When this message is placed in the queue, the 
<i>hwnd</i> member in the MSG structure will be set to NULL. This function
is usually called when an application performs some special processing
in its main message loop.</p>

<p>The main message loop for the thread is written so that, after 
<i>GetMessage</i> or <i>PeekMessage</i> retrieves a message, the code
checks for an <i>hwnd</i> of NULL and can examine the <i>msg</i> member
of the MSG structure to perform the special processing. If the thread
determines that this message is not destined for a window, 
<i>DispatchMessage</i> is not called, and the message loop iterates to
retrieve the next message.</p>

<p>Like the <i>PostMessage</i> function, <i>PostThreadMessage</i>
returns immediately after posting the message to the thread's
queue. The calling thread has no idea when or if the message gets
processed.</p>

<p>The last function that posts a message to a thread's queue is
<i>PostQuitMessage</i>:</p>

<p><table cellpadding=5><tr><td>
<PRE>
VOID PostQuitMessage(int nExitCode);
</pre></td></tr></table></p>

<p>You call this function in order to terminate a thread's message
loop. Calling <i>PostQuitMessage</i> is similar to calling</p>

<p><table cellpadding=5><tr><td>
<PRE>
PostThreadMessage(GetCurrentThreadId(), WM_QUIT, nExitCode, 0); 
</pre></td></tr></table></p>

<p>However, <i>PostQuitMessage</i> doesn't really post a message to
any of the THREADINFO structure's queues. Internally 
<i>PostQuitMessage</i> just turns on the QS_QUIT wake flag (which I'll
discuss later) and sets the <i>nExitCode</i> member of the THREADINFO
structure. Since these actions can never fail, <i>PostQuitMessage</i>
is prototyped as returning VOID.</p>

</BODY>
</HTML>






