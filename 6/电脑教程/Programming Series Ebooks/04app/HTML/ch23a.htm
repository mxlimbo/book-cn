<html>
<head>
<title>Chapter 23 -- Termination Handlers</title>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<A HREF="ch22j.htm">[Previous]</A> <A HREF="ch23b.htm">[Next]</A><P>



<FONT SIZE="+3">Chapter 23</FONT>


<A NAME="301"><H1>Termination Handlers</H1></A>

<p>Close your eyes for a moment and imagine writing your application
as though your code could never fail. That's right&#8212;there's
always enough memory, no one ever passes you an invalid pointer, and
the files you count on always exist. Wouldn't it be a pleasure to
write your code if you could make these assumptions? Your code would be
so much easier to write, to read, and to understand. No more fussing
with <i>if</i> statements here and <i>goto</i>s there&#8212;in each
function, you'd just write your code top to bottom.</p>

<p>If this kind of straightforward programming environment seems like a
dream to you, you'll love structured exception handling (SEH). The
virtue of SEH is that as you write your code, you can focus on getting
your task done. If something goes wrong at run time, the system catches
it and notifies you of the problem.</p>

<p>With SEH, you can't totally ignore the possibility of an error
in your code, but you can separate the main job from the error-handling
chores. This division makes it easy to concentrate on the problem at
hand and focus on possible errors later.</p>

<p>One of Microsoft's main motivations for adding SEH to Windows
was to ease the development of the operating system itself. The
developers of the operating system use SEH to make the system more
robust. We can use SEH to make our own applications more robust.</p>

<p>The burden of getting SEH to work falls more on the compiler than on
the operating system. Your compiler must generate special code when
exception blocks are entered into and exited from. The compiler must
produce tables of support data structures to handle SEH. The compiler
also must supply callback functions that the operating system can call
so that exception blocks can be traversed. And the compiler is
responsible for preparing stack frames and other internal information
that is used and referenced by the operating system. Adding SEH support
to a compiler is not an easy task. It shouldn't surprise you that
different compiler vendors implement SEH in different ways.
Fortunately, we can ignore compiler implementation details and just use
the compiler's SEH capabilities.</p>

<p>Differences among compiler implementations could make it difficult
to discuss the advantages of SEH in specific ways with specific code
examples. However, most compiler vendors follow Microsoft's
suggested syntax. The syntax and keywords I use in my examples might
differ from those of another company's compiler, but the main SEH
concepts are the same. I'll use the Microsoft Visual C++
compiler's syntax throughout this chapter.</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>
Don't confuse structured exception handling with C++ exception
handling. C++ exception handling is a different form of exception
handling, a form that makes use of the C++ keywords <i>catch</i> and
<i>throw</i>. Microsoft's Visual C++ also supports C++ exception
handling and is implemented internally by taking advantage of the
structured exception handling capabilities already present in the
compiler and in Windows operating systems.
</blockquote></div></p>

<p>SEH really consists of two main capabilities: termination handling
and exception handling. We'll discuss termination handlers in this
chapter and exception handling in the next chapter.</p>

<p>A termination handler guarantees that a block of code (the
termination handler) will be called and executed regardless of how
another section of code (the guarded body) is exited. The syntax (using
the Microsoft Visual C++ compiler) for a termination handler is as
follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
_ _try {
   // Guarded body
   
   <img src="images/grayvellip.JPG" width=3 height=13 border="0">
   
}
_ _finally {
   // Termination handler
 
   <img src="images/grayvellip.JPG" width=3 height=13 border="0">
   
}
</pre></td></tr></table></p>

<p>The _ _<i>try</i> and _ _<i>finally</i> keywords delineate the two
sections of the termination handler. In the code fragment above, the
operating system and the compiler work together to guarantee that the
_ _<i>finally</i> block code in the termination handler will be executed
no matter how the guarded body is exited. Regardless of whether you put
a <i>return</i>, a <i>goto</i>, or even a call to <i>longjump</i> in
the guarded body, the termination handler will be called. I'll show
you several examples demonstrating this.</p>


</BODY>
</HTML>






