<HTML>
<HEAD>
<TITLE>Delay-Loading a DLL</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch20c.htm">[Previous]</A> <A HREF="ch20e.htm">[Next]</A><P>

<A NAME="274"><H1>Delay-Loading a DLL</H1></A>

<p>Microsoft Visual C++ 6.0 offers a fantastic new feature to make working with DLLs easier: delay-load DLLs. A delay-load DLL is a DLL that is implicitly linked but not actually loaded until your code attempts to reference a symbol contained within the DLL. Delay-load DLLs are helpful in these situations:</p>

<ul>
<p><li>If your application uses several DLLs, its initialization time might be slow because the loader maps all of the required DLLs into the process's address space. One way to alleviate this problem is to spread out the loading of the DLLs as the process executes. Delay-load DLLs let you accomplish this easily.</li></p>

<p><li>If you call a new function in your code and then try to run your application on an older version of the system in which the function does not exist, the loader reports an error and does not allow the application to run. You need a way to allow your application to run and then, if you detect (at run time) that the application is running on an older system, you don't call the missing function. For example, let's say that an application wants to use the PSAPI functions when running on Windows 2000 and the ToolHelp functions (like <i>Process32Next</i>) when running on Windows 98. When the application initializes, it calls <i>GetVersionEx</i> to determine the host operating system and properly calls the appropriate functions. Attempting to run this application on Windows 98 causes the loader to display an error message because the PSAPI.dll module doesn't exist on Windows 98. Again, delay-load DLLs let you solve this problem easily.</li></p>
</ul>

<p>I've spent quite a bit of time playing with the delay-load DLL
feature of Visual C++ 6.0, and I must say that Microsoft has done an excellent job in implementing it. It offers many features and works equally well on both Windows 98 and Windows 2000.</p>

<p>Let's start with the easy stuff: getting delay-load DLLs to work. First, you create a DLL just as you normally would. You also create an executable as you normally would but you do have to change a couple of linker switches and relink the executable. Here are the two linker switches you need to add:
<P> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/Lib:DelayImp.lib<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/DelayLoad:MyDll.dll
<P>The /Lib switch tells the linker to embed a special function, <i>_ _delayLoadHelper</i>, into your executable. The second switch tells the linker the following things:</p>

<ul>
<p><li>Remove MyDll.dll from the executable module's import section so that the operating system loader does not implicitly load the DLL when the process initializes.</li></p>

<p><li>Embed a new Delay Import section (called .didata) in the
executable indicating which functions are being imported from
MyDll.dll.</li></p>

<p><li>Resolve calls to the delay-loaded functions by having calls jump to the <i>_ _delayLoadHelper</i> function.</li></p>
</ul>

<p>When the application runs, a call to a delay-loaded function
actually calls the <i>_ _delayLoadHelper</i> function instead. This function references the special Delay Import section and knows to call <i>LoadLibrary</i> followed by <i>GetProcAddress</i>. Once the address of the delay-loaded function is obtained, <i>_ _delayLoadHelper</i> fixes up calls to that function so future calls go directly to the delay-loaded function. Note that other functions in the same DLL still have to be fixed up the first time you call them. Also note that you can specify the /DelayLoad linker switch multiple times&#8212;once for every DLL that you want to delay-load.</p>

<p>OK, that's it. It's that simple! It is, really. But you
should also consider a couple of other issues. Normally, when the
operating system loader loads your executable, it tries to load the required DLLs. If a DLL can't be loaded, the loader displays an error message. But for delay-loaded DLLs, the existence of the DLL is not checked at initialization time. If the DLL can't be found when a delay-loaded function is called, the <i>_ _delayLoadHelper</i> function raises a software exception. You can trap this exception using structured exception handling (SEH) and keep your application running. If you don't trap the exception, your process is terminated. (SEH is discussed in Chapters <a href="ch23a.htm">23</a>, <a href="ch24a.htm">24</a>, and <a href="ch25a.htm">25</a>.)</p>

<p>Another problem can occur when <i>_ _delayLoadHelper</i> does find your DLL but the function you're trying to call isn't in the
DLL. This can happen if the loader finds an old version of the DLL, for example. In this case, <i>_ _delayLoadHelper</i> also raises a software exception and the same rules apply. The sample application presented in the next section shows how to properly write the SEH code to handle these errors.</p>

<p>You'll notice a lot of other stuff in the code that has nothing to do with SEH and error handling. It has to do with additional features that are available when you use delay-load DLLs. I'll describe these features shortly. If you don't use the more advanced features, you can delete this additional code.</p>

<p>As you can see, the Visual C++ team has defined two software
exception codes: <i>VcppException(ERROR_SEVERITY_ERROR,
ERROR_MOD_NOT_FOUND)</i> and <i>VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND)</i>. These indicate that the DLL module was not found and that the function was not found, respectively. My exception filter function, <i>DelayLoadDllExceptionFilter</i>, checks for these two exception codes. If neither code is thrown, the filter returns EXCEPTION_CONTINUE_SEARCH, as any good filter should. (Never swallow exceptions that you don't know how to handle.) However, if one of these codes is thrown, the <i>_ _delayLoadHelper</i> function provides a pointer to a <i>DelayLoadInfo</i> structure containing some additional
information. The <i>DelayLoadInfo</i> structure is defined in Visual C++'s DelayImp.h file as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef struct DelayLoadInfo {
   DWORD           cb;         // Size of structure
   PCImgDelayDescr pidd;       // Raw data (everything is there)
   FARPROC *       ppfn;       // Points to address of function to load
   LPCSTR          szDll;      // Name of dll
   DelayLoadProc   dlp;        // Name or ordinal of procedure
   HMODULE         hmodCur;    // hInstance of loaded library
   FARPROC         pfnCur;     // Actual function that will be called
   DWORD           dwLastError;// Error received
} DelayLoadInfo, * PDelayLoadInfo; 
</pre>
</td></tr></table></p>

<p>This data structure is allocated and initialized by the <i>_ _delayLoadHelper</i> function. As the function progresses through its work of dynamically loading the DLL and getting the address of the called function, it populates the members of this structure. Inside your SEH filter, the <i>szDll</i> member points to the name of the DLL you're attempting to load and the function you're attempting to look up is in the <i>dlp</i> member. Since you can look up functions by ordinal or by name, the <i>dlp</i> member looks like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef struct DelayLoadProc {
   BOOL fImportByName;
   union {
      LPCSTR szProcName;
      DWORD  dwOrdinal;
   };
} DelayLoadProc; 
</pre>
</td></tr></table></p>

<p>If the DLL successfully loads but does not contain the desired
function, you might also look at the <i>hmodCur</i> member to see the memory address where the DLL is loaded. You can also check the <i>dwLastError</i> member to see what error caused the exception to be raised, but this probably isn't necessary for an exception filter because the exception code tells you what happened. The <i>pfnCur</i> member contains the address of the desired function. This is always set to NULL in the exception filter because <i>_ _delayLoadHelper</i> couldn't find the address of the function.</p>

<p>Of the remaining members, <i>cb</i> is for versioning, <i>pidd</i> points to the section embedded in the module that contains the list of delay-load DLLs and functions, and <i>ppfn</i> is the address where the function's address will go if the function is found. These last two members are used by the <i>_ _delayLoadHelper</i> function internally. They are for super-advanced use; it is extremely unlikely that you will
ever have to examine or understand them.</p>

<p>So far, I've explained the basics of using delay-load DLLs and
properly recovering from error conditions. However, Microsoft's
implementation of delay-load DLLs goes beyond what I have discussed so far. Your application can unload a delay-loaded DLL, for example. Let's say that your application requires a special DLL to print the user's document. This DLL is a perfect candidate to be a delay-load DLL because most of the time it probably won't be used. However, if the user chooses the Print command, you can call a function in the DLL and it will automatically load. This is great, but after the document is printed, the user probably won't print another document immediately, so you can unload the DLL and free system resources. If the user decides to print another document, the DLL will again be loaded on demand.</p>

<p>To unload a delay-loaded DLL, you must do two things. First, you must specify an additional linker switch (<i>/Delay:unload</i>) when you build your executable file. Second, you must modify your source code and place a call to the <i>_ _FUnloadDelayLoadedDLL</i> function at the point where you want the DLL to be unloaded:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL _ _FUnloadDelayLoadedDLL(PCSTR szDll); 
</pre>
</td></tr></table></p>

<p>The <i>/Delay:unload</i> linker switch tells the linker to place another section inside the file. This section contains the information necessary to reset the functions you have already called so that they again call the <i>_ _delayLoadHelper</i> function. When you call <i>_ _FUnloadDelayLoadedDLL</i>, you pass it the name of the delay-load DLL that you want to unload. The function then goes to the unload section in the file and resets all of the DLL's function addresses. Then <i>_ _FUnloadDelayLoadedDLL</i> calls <i>FreeLibrary</i> to unload the DLL.</p>

<p>Let me point out a few important items. First, make sure that you don't call <i>FreeLibrary</i> yourself to unload the DLL or the function's address will not be reset; this will cause an access violation the next time you attempt to call a function in the DLL. Second, when you call <i>_ _FUnloadDelayLoadedDLL</i>, the DLL name you pass should not include a path and the letters in the name must be the same case that was used when you passed the DLL name to the <i>/DelayLoad</i> linker switch; otherwise, <i>_ _FUnloadDelayLoadedDLL</i> will fail. Third, if you never intend to unload a delay-loaded DLL, do not specify the <i>/Delay:unload</i> linker switch and your executable file will be smaller in size. Lastly, if you call <i>_ _FUnloadDelayLoadedDLL</i> from a module that was not built with the /<i>Delay:unload</i> switch, nothing bad happens: <i>_ _FUnloadDelayLoadedDLL</i> simply does nothing and returns FALSE.</p>

<p>Another feature of the delay-load DLLs is that by default, the
functions that you call are bindable to memory addresses where the system thinks the function will be in a process's address.
(I'll discuss binding later in this chapter.) Since creating
bindable delay-load DLL sections makes your executable file bigger, the linker also supports a <i>/Delay:nobind</i> switch. Since binding is generally preferred, most applications should not use this linker switch.</p>

<p>The last feature of delay-load DLLs is for advanced users and really shows Microsoft's attention to detail. As the <i>_ _delayLoadHelper</i> function executes, it can call hook functions that you provide. These functions receive notifications of <i>_ _delayLoadHelper</i>'s progress and notifications of errors. In addition, these functions can override how the DLL is loaded and how the function's virtual memory address is obtained.</p>

<p>To get the notification or override behavior, you must do two things to your source code. First, you must write a hook function that looks like the <i>DliHook</i> function in Figure 20-6. The <i>DliHook</i> skeleton function does not affect <i>_ _delayLoadHelper</i>'s operation. To alter the behavior, start with the <i>DliHook</i> function and then modify it as necessary. Then tell <i>_ _delayLoadHelper</i> the address
of the function.</p>

<p>Inside the DelayImp.lib static-link library, two global variables are defined: <i>_ _pfnDliNotifyHook</i> and <i>_ _pfnDliFailureHook</i>. Both of these variables are of type <i>PfnDliHook</i>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef FARPROC (WINAPI *PfnDliHook)(
   unsigned dliNotify, 
   PDelayLoadInfo pdli); 
</pre>
</td></tr></table></p>

<p>As you can see, this is a function data type and matches the
prototype of my <i>DliHook</i> function. Inside DelayImp.lib, the two variables are initialized to NULL, which tells <i>_ _delayLoadHelper</i> not to call any hook functions. To have your hook function called, you must set one of these variables to your hook function's address. In my code, I simply add these two lines of code at global scope:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
PfnDliHook _ _pfnDliNotifyHook  = DliHook;
PfnDliHook _ _pfnDliFailureHook = DliHook; 
</pre>
</td></tr></table></p>

<p>As you can see, <i>_ _delayLoadHelper</i> actually works with two callback functions. It calls one to report notifications and the other to report failures. Since the prototypes are identical for both functions, and the first parameter, <i>dliNotify</i>, tells why the function is being called, I always make life simpler by creating a single function and setting both variables to point to my one function.</p>

<p>This new delay-load DLL feature of Visual C++ 6.0 is pretty cool, and I know a lot of developers who wish that they had this feature years ago. I can think of a lot of applications (especially Microsoft applications) that will take advantage of this mechanism.</p>

<A NAME="275"><H2>The DelayLoadApp Sample Application</H2></A>

<p>The DelayLoadApp application (&quot;20 DelayLoadApp.exe&quot;), listed in Figure 20-6, shows everything you need to do to take full advantage of delay-load DLLs. For demonstration purposes, a simple DLL is required; the code for that is in the 20-DelayLoadLib directory.</p>

<p>Since the application loads the &quot;20 DelayLoadLib&quot; module, the loader does not map this module into the process's address space when you run the application. Inside the application, I periodically call the <i>IsModuleLoaded</i> function. This function simply displays a message box notifying you whether a module is loaded into the process's address space. When the application first starts, the &quot;20 DelayLoadLib&quot; module is not loaded, causing the message box in Figure 20-4 to appear.</p>

<p>
<A HREF="javascript:fullSize('F20si04x.htm')"> <img src="images/F20si04.JPG" width=404 height=81 border=0 ALT="Click to view at full size."> </A>
</p><p>
<b>Figure 20-4.</b> <i>DelayLoadApp indicating that the &quot;20
DelayLoadLib&quot; module is not loaded</i>
</p>

<p>The application then calls a function imported from the DLL, which causes the <i>_ _delayLoadHelper</i> function to automatically load the DLL. When the function returns, the message box in Figure 20-5 is displayed.</p>

<p>
<A HREF="javascript:fullSize('F20si05x.htm')"> <img src="images/F20si05.JPG" width=404 height=81 border=0 ALT="Click to view at full size."> </A>
</p><p>
<b>Figure 20-5.</b> <i>DelayLoadApp indicating that the &quot;20 DelayLoadLib&quot; module is loaded</i>
</p>

<p>When this message box is dismissed, another function in the DLL is called. Since this function is in the same DLL, the DLL does not get loaded in the address space again, but the address of this new function is resolved and called.</p>

<p>At this point, <i>_ _FUnloadDelayLoadedDLL</i> is called; it unloads the &quot;20 DelayLoadLib&quot; module. Again, the call to <i>IsModuleLoaded</i> shows the message box in Figure 20-4. Finally, an imported function is again called, which reloads the &quot;20 DelayLoadLib&quot; module, causing the last call to <i>
IsModuleLoaded</i> to show the message box in Figure 20-5.</p>

<p>If all is OK, the application will work as I've described.
However, if you delete the &quot;20 DelayLoadLib&quot; module before running the application or if the module doesn't contain one of the imported functions, exceptions will be raised. The sample code shows how to recover &quot;gracefully&quot; (so to speak) from this situation.</p>

<p>Finally, the application shows how to properly set a delay load hook function. My skeleton <i>DliHook</i> function doesn't do anything of interest. However, it does trap various notifications and shows what you can do when you receive these notifications.</p>

</p><p>
<!-- CAPTION --><b>Figure 20-6.</b> <i>The DelayLoadApp sample application</i><!-- /CAPTION -->
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>

<p><b>DelayLoadApp.cpp</b></p>

<PRE>
/******************************************************************************
Module:  DelayLoadApp.cpp
Notices: Copyright (c) 2000 Jeffrey Richter
******************************************************************************/


#include &quot;..\CmnHdr.h&quot;     /* See Appendix A. */
#include &lt;Windowsx.h&gt;
#include &lt;tchar.h&gt;


///////////////////////////////////////////////////////////////////////////////


#include &lt;Delayimp.h&gt;   // For error handling &amp; advanced features
#include &quot;..\20-DelayLoadLib\DelayLoadLib.h&quot;    // My DLL function prototypes


///////////////////////////////////////////////////////////////////////////////


// Statically link _ _delayLoadHelper/_ _FUnloadDelayLoadedDLL
#pragma comment(lib, &quot;Delayimp.lib&quot;)

// Tell the linker that my DLL should be delay loaded
// Note the 2 (\&quot;) because the filename has a space in it
#pragma comment(linker, &quot;/DelayLoad:\&quot;20 DelayLoadLib.dll\&quot;&quot;)

// Tell the linker that I want to be able to unload my DLL
#pragma comment(linker, &quot;/Delay:unload&quot;)

// Tell the linker to make the delay load DLL unbindable
// You usually want this, so I commented out this line
//#pragma comment(linker, &quot;/Delay:nobind&quot;)


// The name of the Delay-Load module (only used by this sample app)
TCHAR g_szDelayLoadModuleName[] = TEXT(&quot;20 DelayLoadLib&quot;);


///////////////////////////////////////////////////////////////////////////////


// Forward function prototype
LONG WINAPI DelayLoadDllExceptionFilter(PEXCEPTION_POINTERS pep);


///////////////////////////////////////////////////////////////////////////////


void IsModuleLoaded(PCTSTR pszModuleName) {

   HMODULE hmod = GetModuleHandle(pszModuleName);
   char sz[100];
#ifdef UNICODE
   wsprintfA(sz, &quot;Module \&quot;%S\&quot; is %Sloaded.&quot;, 
      pszModuleName, (hmod == NULL) ? L&quot;not &quot; : L&quot;&quot;);
#else
   wsprintfA(sz, &quot;Module \&quot;%s\&quot; is %sloaded.&quot;, 
      pszModuleName, (hmod == NULL) ? &quot;not &quot; : &quot;&quot;);
#endif
   chMB(sz);
}

///////////////////////////////////////////////////////////////////////////////


int WINAPI _tWinMain(HINSTANCE hinstExe, HINSTANCE, PTSTR pszCmdLine, int) {

   // Wrap all calls to delay-load DLL functions inside SEH
   _ _try {
      int x = 0;

      // If you're in the debugger, try the new Debug.Modules menu item to 
      // see that the DLL is not loaded prior to executing the line below
      IsModuleLoaded(g_szDelayLoadModuleName);

      x = fnLib();  // Attempt to call delay-load function

      // Use Debug.Modules to see that the DLL is now loaded
      IsModuleLoaded(g_szDelayLoadModuleName);

      x = fnLib2(); // Attempt to call delay-load function

      // Unload the delay-loaded DLL
      // NOTE: Name must exactly match /DelayLoad:(DllName)
      _ _FUnloadDelayLoadedDLL(&quot;20 DelayLoadLib.dll&quot;);

      // Use Debug.Modules to see that the DLL is now unloaded
      IsModuleLoaded(g_szDelayLoadModuleName);

      x = fnLib();  // Attempt to call delay-load function

      // Use Debug.Modules to see that the DLL is loaded again
      IsModuleLoaded(g_szDelayLoadModuleName);
   }
   _ _except (DelayLoadDllExceptionFilter(GetExceptionInformation())) {
      // Nothing to do in here, thread continues to run normally
   }

   // More code can go here...

   return(0);
}


///////////////////////////////////////////////////////////////////////////////


LONG WINAPI DelayLoadDllExceptionFilter(PEXCEPTION_POINTERS pep) {

   // Assume we recognize this exception
   LONG lDisposition = EXCEPTION_EXECUTE_HANDLER;  

   // If this is a Delay-load problem, ExceptionInformation[0] points 
   // to a DelayLoadInfo structure that has detailed error info
   PDelayLoadInfo pdli = 
      PDelayLoadInfo(pep-&gt;ExceptionRecord-&gt;ExceptionInformation[0]);

   // Create a buffer where we construct error messages
   char sz[500] = { 0 };

   switch (pep-&gt;ExceptionRecord-&gt;ExceptionCode) {
   case VcppException(ERROR_SEVERITY_ERROR, ERROR_MOD_NOT_FOUND):
      // The DLL module was not found at run time
      wsprintfA(sz, &quot;Dll not found: %s&quot;, pdli-&gt;szDll); 
      break;

   case VcppException(ERROR_SEVERITY_ERROR, ERROR_PROC_NOT_FOUND):
      // The DLL module was found, but it doesn't contain the function
      if (pdli-&gt;dlp.fImportByName) {
         wsprintfA(sz, &quot;Function %s was not found in %s&quot;,
            pdli-&gt;dlp.szProcName, pdli-&gt;szDll);
      } else {
         wsprintfA(sz, &quot;Function ordinal %d was not found in %s&quot;,
            pdli-&gt;dlp.dwOrdinal, pdli-&gt;szDll);
      }
      break; 

   default:
      // We don't recognize this exception
      lDisposition = EXCEPTION_CONTINUE_SEARCH;  
      break;
   }

   if (lDisposition == EXCEPTION_EXECUTE_HANDLER) {
      // We recognized this error and constructed a message, show it
      chMB(sz);
   }

   return(lDisposition);
}


///////////////////////////////////////////////////////////////////////////////


// Skeleton DliHook function that does nothing interesting
FARPROC WINAPI DliHook(unsigned dliNotify, PDelayLoadInfo pdli) {

   FARPROC fp = NULL;   // Default return value

   // NOTE: The members of the DelayLoadInfo structure pointed
   // to by pdli shows the results of progress made so far. 

   switch (dliNotify) {
   case dliStartProcessing:
      // Called when _ _delayLoadHelper attempts to find a DLL/function
      // Return 0 to have normal behavior or nonzero to override
      // everything (you will still get dliNoteEndProcessing)
      break;

   case dliNotePreLoadLibrary:
      // Called just before LoadLibrary
      // Return NULL to have _ _delayLoadHelper call LoadLibary
      // or you can call LoadLibrary yourself and return the HMODULE
      fp = (FARPROC) (HMODULE) NULL;
      break;

   case dliFailLoadLib:
      // Called if LoadLibrary fails
      // Again, you can call LoadLibary yourself here and return an HMODULE
      // If you return NULL, _ _delayLoadHelper raises the 
      // ERROR_MOD_NOT_FOUND exception
      fp = (FARPROC) (HMODULE) NULL;
      break;

   case dliNotePreGetProcAddress:
      // Called just before GetProcAddress
      // Return NULL to have _ _delayLoadHelper call GetProcAddress
      // or you can call GetProcAddress yourself and return the address
      fp = (FARPROC) NULL;
      break;

   case dliFailGetProc:
      // Called if GetProcAddress fails
      // You can call GetProcAddress yourself here and return an address
      // If you return NULL, _ _delayLoadHelper raises the 
      // ERROR_PROC_NOT_FOUND exception
      fp = (FARPROC) NULL;
      break;

   case dliNoteEndProcessing:
      // A simple notification that _ _delayLoadHelper is done
      // You can examine the members of the DelayLoadInfo structure
      // pointed to by pdli and raise an exception if you desire
      break;
   }

   return(fp);
}


///////////////////////////////////////////////////////////////////////////////


// Tell _ _delayLoadHelper to call my hook function
PfnDliHook _ _pfnDliNotifyHook  = DliHook;
PfnDliHook _ _pfnDliFailureHook = DliHook;


//////////////////////////////// End of File //////////////////////////////////
</PRE>
</TD></TR></TABLE></P>

<P>
<TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>

<p><b>DelayLoadLib.cpp</b></p>

<PRE>
/******************************************************************************
Module:  DelayLoadLib.cpp
Notices: Copyright (c) 2000 Jeffrey Richter
******************************************************************************/


#include &quot;..\CmnHdr.h&quot;     /* See Appendix A. */
#include &lt;Windowsx.h&gt;
#include &lt;tchar.h&gt;


///////////////////////////////////////////////////////////////////////////////


#define DELAYLOADLIBAPI extern &quot;C&quot; _ _declspec(dllexport)
#include &quot;DelayLoadLib.h&quot;


///////////////////////////////////////////////////////////////////////////////


int fnLib() {

   return(321);
}


///////////////////////////////////////////////////////////////////////////////


int fnLib2() {

   return(123);
}


//////////////////////////////// End of File //////////////////////////////////
</PRE>
</TD></TR></TABLE></P>

<P>
<TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>

<p><b>DelayLoadLib.h</b></p>

<PRE>
/******************************************************************************
Module:  DelayLoadLib.h
Notices: Copyright (c) 2000 Jeffrey Richter
******************************************************************************/


#ifndef DELAYLOADLIBAPI 
#define DELAYLOADLIBAPI extern &quot;C&quot; _ _declspec(dllimport)
#endif


///////////////////////////////////////////////////////////////////////////////


DELAYLOADLIBAPI int fnLib();
DELAYLOADLIBAPI int fnLib2();


//////////////////////////////// End of File //////////////////////////////////


</pre>
</td></tr></table></p>

</BODY>
</HTML>






