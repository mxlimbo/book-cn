<HTML>
<HEAD>
<TITLE>Inside the UnhandledExceptionFilter Function</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch25d.htm">[Previous]</A> <A HREF="ch25f.htm">[Next]</A><P>

<A NAME="343"><h1>Inside the <i>UnhandledExceptionFilter</i> Function</h1></A>
<p>When I first started working with exceptions, I believed that a lot
of information could be gained from understanding exactly what the
system's <i>UnhandledExceptionFilter</i> function did. So, I
researched this function in great detail. The following steps describe
exactly what <i>UnhandledExceptionFilter</i> does internally:</p>

<ol>
<p><li>If an access violation occurred and it was due to an attempted
write (versus a read), the system checks to see if you're
attempting to modify a resource in an .exe or DLL module. By default,
resources are (and should be) read-only; attempting to modify a
resource raises an access violation. However, 16-bit Windows allows
resources to be modified, and for backward compatibility this should
work in 32-bit and 64-bit Windows as well. Thus, if you are attempting
to modify a resource, <i>UnhandledExceptionFilter</i> calls <i>
VirtualProtect</i> to change the protection on the resource's page
to PAGE_READWRITE and returns EXCEPTION_CONTINUE_EXECUTION.</li></p>

<p><li>If you have called <i>SetUnhandledExceptionFilter</i> to specify
your own filter, <i>UnhandledExceptionFilter</i> calls your filter
function. If your filter function returns EXCEPTION_EXECUTE_HANDLER or
EXCEPTION_CONTINUE_EXECUTION, the <i>UnhandledExceptionFilter</i>
returns this value back to the system. If you have not set your own
unhandled exception filter or if your unhandled exception filter
returns EXCEPTION_CONTINUE_SEARCH, processing continues with step
3.</li></p>
</ol>

<p><div class="note"><blockquote><b>Windows 98</b><hr>
Windows 98 has the following bug: it only calls your own unhandled
exception filter function if the process is not being debugged. This
made it impossible for me to debug the Spreadsheet sample application
presented later in this chapter.
</blockquote></div></p>

<ol>
<p><li value="3">If your process is under the care of a debugger, 
EXCEPTION_CONTINUE_SEARCH is returned. This should seem odd to you because
the system is already executing the highest <i>try</i> or <i>except</i>
frame for the thread; there is no other exception filter to continue
searching for higher up. When the system sees that the highest filter
returns EXCEPTION_CONTINUE_SEARCH, the system knows to contact the
debugger and tell the debugger that the debuggee has just had an
unhandled exception. In response, the debugger displays a message box
and allows you to debug the process. (By the way, the <i>
IsDebuggerPresent</i> function is used to determine if a process is
being debugged.)</li></p>

<p><li>If a thread in the process had called <i>SetErrorMode</i>
passing the SEM_NOGPFAULTERRORBOX flag, <i>UnhandledExceptionFilter</i>
returns EXCEPTION_EXECUTE_HANDLER.</li></p>

<p><li>If the process is in a job (see <A HREF="ch05a.htm">Chapter 5</A>) and the job's
limit information has the JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION 
flag turned on, <i>UnhandledExceptionFilter</i> returns
EXCEPTION_EXECUTE_HANDLER.</li></p>
</ol>

<p><div class="note"><blockquote><b>Windows 98</b><hr>
Windows 98 doesn't support jobs so this step is skipped.
</blockquote></div></p>

<ol>
<p><li value="6"><i>UnhandledExceptionFilter</i> looks in the registry and grabs
the value of the Auto value. If this value is 1, jump to step 7. If
this value is 0, the message box is displayed to the user. The message
box indicates which exception was raised. If the registry subkey also
contains the Debugger value, the message box has both OK and Cancel
buttons. If the registry subkey does not have the Debugger value, the
message box contains only an OK button. If the user clicks on the OK
button, <i>UnhandledExceptionFilter</i> returns EXCEPTION_EXECUTE_HANDLER. 
If the Cancel button is available and the user
clicks on it, processing continues with step 7.</li></p>
</ol>

<p><div class="note"><blockquote><b>Windows 98</b><hr>
In Windows 98, these values are not stored in the registry&#8212;they are
stored in the Win.ini file.
</blockquote></div></p>

<ol>
<p><li value="7"><i>UnhandledExceptionFilter</i> is now going to spawn the
debugger. It first calls <i>CreateEvent</i> to create a nonsignaled,
manual-reset event. The handle of this event is inheritable. Next it
grabs the Debugger value out of the registry and calls <i>sprintf</i>
to paste in the process ID (obtained by calling the <i>
GetCurrentProcessId</i> function) and the event handle. The
STARTUPINFO's <i>lpDesktop</i> member is also set to
&quot;Winsta0\\Default&quot; so that the debugger appears on the
interactive desktop. <i>CreateProcess</i> is then called with its <i>
fInheritHandles</i> parameter set to TRUE, which invokes the debugger
process and allows it to inherit the event object's handle. <i>
UnhandledExceptionFilter</i> now waits for the debugger to initialize
by calling <i>WaitForSingleObjectEx</i>, passing the event's
handle. Note that <i>WaitForSingleObjectEx</i> is used instead of <i>
WaitForSingleObject</i> so that the thread can wait in an alertable
state. This allows any queued asynchronous procedure calls (APCs) for
the thread to be processed.</li></p>

<p><li>When the debugger is fully initialized, it sets the event
handle, which causes the thread inside <i>UnhandledExceptionFilter</i>
to wake up. Now that the process is under the care of a debugger, <i>
UnhandledExceptionFilter</i> returns EXCEPTION_CONTINUE_SEARCH. Notice
that this is exactly what happened in step 3.</li></p>
</ol>

</BODY>
</HTML>






