<HTML>
<HEAD>
<TITLE>C/C++ Run-Time Library Considerations</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch06g.htm">[Previous]</A> <A HREF="ch06i.htm">[Next]</A><P>

<A NAME="91"><H1>C/C++ Run-Time Library Considerations</H1></A>

<p>Six C/C++ run-time libraries ship with Visual C++. The following
table describes them. </p>

<p><table cellpadding=5 width="95%"><tr>
<th>Library Name</th>
<th>Description</th>
</tr><tr>
<td valign="top">LibC.lib</td>
<td valign="top">Statically linked library for single-threaded applications.
(This is the default library when you create a new project.)</td>
</tr><tr>
<td valign="top">LibCD.lib</td>
<td valign="top">Statically linked debug version of the library for
single-threaded applications.</td>
</tr><tr>
<td valign="top">LibCMt.lib</td>
<td valign="top">Statically linked release version of the library for
multithreaded applications.</td>
</tr><tr>
<td valign="top">LibCMtD.lib</td>
<td valign="top">Statically linked debug version of the library for
multithreaded applications.</td>
</tr><tr>
<td valign="top">MSVCRt.lib</td>
<td valign="top">Import library for dynamically linking the release
version of the MSVCRt.dll library. This library supports both
single-threaded and multithreaded applications.</td>
</tr><tr>
<td valign="top">MSVCRtD.lib</td>
<td valign="top">Import library for dynamically linking the debug version
of the MSVCRtD.dll library. The library supports both single-threaded
and multithreaded applications.</td>
</tr></table></p>

<p>When you implement any type of project, you must know which library
you're linking your project with. You select a library using the
Project Settings dialog box, shown below. On the C/C++ tab, in the Code
Generation category, select one of the six options from the Use
Run-Time Library combo box.</p>

<p>
<A HREF="javascript:fullSize('G06SI01x.htm')"> <img src="images/G06SI01.JPG" width=404 height=260 border=0 ALT="Click to view at full size."> </A>
</p>

<p>The first thing you're probably wondering is, &quot;Why do I
need one library for single-threaded applications and another library
for multithreaded applications?&quot; The reason is that the standard C
run-time library was invented around 1970, long before threads were
available on any operating system. The inventors of the library
didn't consider the problems of using the C run-time library with
multithreaded applications.</p>

<p>Consider the standard C run-time global variable <i>errno</i>. Some
functions set this variable when an error occurs. Let's say you
have the following code fragment:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL fFailure = (system(&quot;NOTEPAD.EXE README.TXT&quot;) == -1);

if (fFailure) {
   switch (errno) {
   case E2BIG:   // Argument list or environment too big
      break;
   case ENOENT:  // Command interpreter cannot be found
      break;
   case ENOEXEC: // Command interpreter has bad format
      break;
   case ENOMEM:  // Insufficient memory to run command
      break;
   }
}
</pre></td></tr></table></p>

<p>Now let's say that the thread executing the code above is
interrupted after the call to the <i>system</i> function and before the
<i>if</i> statement. And imagine that the thread is being interrupted
to allow a second thread in the same process to execute and that this
new thread will execute another C run-time function that sets the
global variable <i>errno</i>. When the CPU is later assigned back to
the first thread, the value of <i>errno</i> no longer reflects the
proper error code for the call to <i>system</i> in the code above. To
solve this problem, each thread requires its own <i>errno</i> variable.
In addition, there must be some mechanism that allows a thread to
reference its own <i>errno</i> variable but not touch another
thread's <i>errno</i> variable. </p>
<p>This is only one example of how the standard C/C++ run-time library was
not originally designed for multithreaded applications. The C/C++
run-time library variables and functions that have problems in
multithreaded environments include <i>errno</i>, <i>_doserrno</i>, <i>
strtok</i>, <i>_wcstok</i>, <i>strerror</i>, <i>_strerror</i>, <i>
tmpnam</i>, <i>tmpfile</i>, <i>asctime</i>, <i>_wasctime</i>, <i>
gmtime</i>, <i>_ecvt</i>, and <i>_fcvt</i>&#8212;to name just a few. </p>
<p>For multithreaded C and C++ programs to work properly, a data structure
must be created and associated with each thread that uses C/C++
run-time library functions. Then, when you make C/C++ run-time library
calls, those functions must know to look in the calling thread's
data block so that no other thread is adversely affected. </p>
<p>So how does the system know to allocate this data block when a new
thread is created? The answer is that it doesn't. The system has no
idea that your application is written in C/C++ and that you are calling
functions that are not natively thread-safe. The onus is on you to do
everything correctly. To create a new thread, you must not call the
operating system's <i>CreateThread</i> function&#8212;you must call
the C/C++ run-time library function <i>_beginthreadex</i>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
unsigned long _beginthreadex(
   void *security, 
   unsigned stack_size, 
   unsigned (*start_address)(void *), 
   void *arglist, 
   unsigned initflag, 
   unsigned *thrdaddr);
</pre></td></tr></table></p>

<p>The <i>_beginthreadex</i> function has the same parameter list as
the <i>CreateThread</i> function, but the parameter names and types are
not exactly the same. This is because Microsoft's C/C++ run-time
library group believes that C/C++ run-time library functions should not
have any dependencies on Windows data types. The <i>_beginthreadex</i>
function also returns the handle of the newly created thread, just like
<i>CreateThread</i> does. So, if you've been calling <i>
CreateThread</i> in your source code, it is fairly easy to globally
replace all these calls with calls to <i>_beginthreadex</i>. However,
since the data types are not quite the same, you might have to perform
some casting to make the compiler happy. To make things easier,
I've created a macro, <i>chBEGINTHREADEX</i>, to use in my source
code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef unsigned (_ _stdcall *PTHREAD_START) (void *);

#define chBEGINTHREADEX(psa, cbStack, pfnStartAddr, \
   pvParam, fdwCreate, pdwThreadID)                 \
      ((HANDLE) _beginthreadex(                     \
         (void *) (psa),                            \
         (unsigned) (cbStack),                      \
         (PTHREAD_START) (pfnStartAddr),            \
         (void *) (pvParam),                        \
         (unsigned) (fdwCreate),                    \
         (unsigned *) (pdwThreadID))) 
</pre></td></tr></table></p>

<p>Note that the <i>_beginthreadex</i> function exists only in the
multithreaded versions of the C/C++ run-time library. If you are
linking to a single-thread run-time library, you get an
&quot;unresolved external symbol&quot; error reported from the linker.
This is by design, of course, because the single-threaded library does
not work properly in a multithreaded application. Also note that Visual
Studio defaults to selecting the single-threaded library when you
create a new project. This is not the safest default, and for
multithreaded applications you must explicitly change to a
multithreaded C/C++ run-time library. </p>
<p>Since Microsoft ships the source code to the C/C++ run-time library,
it's easy to determine exactly what <i>_beginthreadex</i> does that
<i>CreateThread</i> doesn't do. In fact, I searched the Visual
Studio CD-ROM and found the source code for <i>_beginthreadex</i> in
Threadex.c. Rather than reprint the source code for it here, I'll
give you a pseudocode version of it and highlight the interesting
points.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
unsigned long _ _cdecl _beginthreadex (
   void *psa,
   unsigned cbStack,
   unsigned (_ _stdcall * pfnStartAddr) (void *),
   void * pvParam,
   unsigned fdwCreate,
   unsigned *pdwThreadID) {

   _ptiddata ptd;         // Pointer to thread's data block
   unsigned long thdl;    // Thread's handle

   // Allocate data block for the new thread.
   if ((ptd = _calloc_crt(1, sizeof(struct tiddata))) == NULL)
      goto error_return;

   // Initialize the data block.
   initptd(ptd);

   // Save the desired thread function and the parameter
   // we want it to get in the data block.
   ptd-&gt;_initaddr = (void *) pfnStartAddr;
   ptd-&gt;_initarg = pvParam;

   // Create the new thread.
   thdl = (unsigned long) CreateThread(psa, cbStack,
      _threadstartex, (PVOID) ptd, fdwCreate, pdwThreadID);
   if (thdl == NULL) {
      // Thread couldn't be created, cleanup and return failure.
      goto error_return;
   }

   // Create created OK, return the handle.
   return(thdl);

error_return:
   // Error: data block or thread couldn't be created.

   _free_crt(ptd);
   return((unsigned long)0L);
}
</pre></td></tr></table></p>

<p>Here are the important things to note about <i>
_beginthreadex</i>:</p>

<ul>
<p><li>Each thread gets its very own <i>tiddata</i> memory block
allocated from the C/C++ run-time library's heap. (The <i>
tiddata</i> structure is in the Visual C++ source code in the Mtdll.h
file). Just for fun, I'll reproduce the structure in Figure
6-2.</li></p>

<p><li>The address of the thread function passed to <i>
_beginthreadex</i> is saved in the <i>tiddata</i> memory block. The
parameter to be passed to this function is also saved in this data
block.</li></p>

<p><li><i>_beginthreadex</i> does call <i>CreateThread</i> internally
since this is the only way that the operating system knows how to
create a new thread.</li></p>

<p><li>When <i>CreateThread</i> is called, it is told to start executing
the new thread with a function called <i>_threadstartex</i>, not <i>
pfnStartAddr</i>. Also, note that the parameter passed to the thread
function is the address of the <i>tiddata</i> structure, not <i>
pvParam</i>.</li></p>

<p><li>If all goes well, the thread handle is returned just like <i>
CreateThread</i>. If any operation fails, NULL is returned.</li></p>
</ul>

<p><b>Figure 6-2.</b> <i>The C/C++ run-time library's thread local</i> tiddata <i>structure</i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
struct _tiddata {
   unsigned long   _tid;       /* thread ID */

   unsigned long   _thandle;   /* thread handle */

   int     _terrno;            /* errno value */
   unsigned long   _tdoserrno; /* _doserrno value */
   unsigned int    _fpds;      /* Floating Point data segment */
   unsigned long   _holdrand;  /* rand() seed value */
   char *      _token;         /* ptr to strtok() token */
#ifdef _WIN32
   wchar_t *   _wtoken;        /* ptr to wcstok() token */
#endif  /* _WIN32 */
   unsigned char * _mtoken;    /* ptr to _mbstok() token */

   /* following pointers get malloc'd at runtime */
   char *      _errmsg;        /* ptr to strerror()/_strerror() buff */
   char *      _namebuf0;      /* ptr to tmpnam() buffer */
#ifdef _WIN32
   wchar_t *   _wnamebuf0;     /* ptr to _wtmpnam() buffer */
#endif  /* _WIN32 */
   char *      _namebuf1;      /* ptr to tmpfile() buffer */
#ifdef _WIN32
   wchar_t *   _wnamebuf1;     /* ptr to _wtmpfile() buffer */
#endif  /* _WIN32 */
   char *      _asctimebuf;    /* ptr to asctime() buffer */
#ifdef _WIN32
   wchar_t *   _wasctimebuf;   /* ptr to _wasctime() buffer */
#endif  /* _WIN32 */
   void *      _gmtimebuf;     /* ptr to gmtime() structure */
   char *      _cvtbuf;        /* ptr to ecvt()/fcvt buffer */

   /* following fields are needed by _beginthread code */
   void *      _initaddr;      /* initial user thread address */
   void *      _initarg;       /* initial user thread argument */

   /* following three fields are needed to support signal handling and
   * runtime errors */
   void *      _pxcptacttab;   /* ptr to exception-action table */
   void *      _tpxcptinfoptrs; /* ptr to exception info pointers */
   int         _tfpecode;      /* float point exception code */

   /* following field is needed by NLG routines */
   unsigned long   _NLG_dwCode;

   /*
   * Per-Thread data needed by C++ Exception Handling
   */
   void *      _terminate;     /* terminate() routine */
   void *      _unexpected;    /* unexpected() routine */
   void *      _translator;    /* S.E. translator */
   void *      _curexception;  /* current exception */
   void *      _curcontext;    /* current exception context */
#if defined (_M_MRX000)
   void *      _pFrameInfoChain;
   void *      _pUnwindContext;
   void *      _pExitContext;
   int         _MipsPtdDelta;
   int         _MipsPtdEpsilon;
#elif defined (_M_PPC)
   void *      _pExitContext;
   void *      _pUnwindContext;
   void *      _pFrameInfoChain;
   int         _FrameInfo[6];
#endif  /* defined (_M_PPC) */
};

typedef struct _tiddata * _ptiddata;

</pre></td></tr></table></p>

<p>So now that a <i>tiddata</i> structure has been allocated and
initialized for the new thread, we need to see how this structure is
associated with the thread. Let's take a look at the <i>
_threadstartex</i> function (which is also in the C/C++ run-time
library's Threadex.c file). Here is my pseudocode version of this
function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
static unsigned long WINAPI threadstartex (void* ptd) {
   // Note: ptd is the address of this thread's tiddata block.

   // Associate the tiddata block with this thread.
   TlsSetValue(_ _tlsindex, ptd);

   // Save this thread ID in the tiddata block.
   ((_ptiddata) ptd)-&gt;_tid = GetCurrentThreadId();

   // Initialize floating-point support (code not shown). 

   // Wrap desired thread function in SEH frame to 
   // handle run-time errors and signal support.
   _ _try {
      // Call desired thread function, passing it the desired parameter.
      // Pass thread's exit code value to _endthreadex.
      _endthreadex(
         ( (unsigned (WINAPI *)(void *))(((_ptiddata)ptd)-&gt;_initaddr) )
            ( ((_ptiddata)ptd)-&gt;_initarg ) ) ;
   }
   _ _except(_XcptFilter(GetExceptionCode(), GetExceptionInformation())){
      // The C run-time's exception handler deals with run-time errors
      // and signal support; we should never get it here.
      _exit(GetExceptionCode());
   }

   // We never get here; the thread dies in this function.
   return(0L);
}
</pre></td></tr></table></p>

<p>Here are the important things to note about <i>
_threadstartex</i>:</p>

<ul>
<p><li>The new thread begins executing with <i>BaseThreadStart</i> (in
Kernel32.dll) and then jumps to <i>_threadstartex</i>.</li></p>

<p><li><i>_threadstartex</i> is passed the address to this new
thread's <i>tiddata</i> block as its only parameter.</li></p>

<p><li><i>TlsSetValue</i> is an operating system function that
associates a value with the calling thread. This is called Thread Local
Storage (TLS) and is discussed in <A HREF="ch21a.htm">Chapter 21</A>. The <i>_threadstartex</i>
function associates the <i>tiddata</i> block with the new thread.</li></p>

<p><li>An SEH frame is placed around the desired thread function. This
frame handles many things related to the run-time library&#8212;for
example, run-time errors (such as throwing C++ exceptions that are not
caught) and the C/C++ run-time library's <i>signal</i> function.
This is critically important. If you were to create a thread using <i>
CreateThread</i> and then call the C/C++ run-time library's <i>
signal</i> function, the function would not work correctly.</li></p>

<p><li>The desired thread function is called and passed the desired
parameter. Recall that the address of the function and the parameter
were saved in the <i>tiddata</i> block by <i>_beginthreadex</i>.</li></p>

<p><li>The return value from the desired thread function is supposed to
be the thread's exit code. Note that <i>_threadstartex</i> does not
simply return back to <i>BaseThreadStart</i>. If it were to do that,
the thread would die and its exit code would be set correctly but the
thread's <i>tiddata</i> memory block would not be destroyed. This
would cause a leak in your application. To prevent this leak, another
C/C++ run-time library function, <i>_endthreadex</i>, is called and
passed the exit code.</li></p>
</ul>


<p>The last function that we need to look at is <i>_endthreadex</i>
(which is also in the C run-time library's Threadex.c file). Here
is my pseudocode version of this function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
void _ _cdecl _endthreadex (unsigned retcode) {
   _ptiddata ptd;         // Pointer to thread's data block

   // Clean up floating-point support (code not shown).

   // Get the address of this thread's tiddata block.
   ptd = _getptd();

   // Free the tiddata block.
   _freeptd(ptd);

   // Terminate the thread.
   ExitThread(retcode);
}
</pre></td></tr></table></p>

<p>Here are the important things to note about <i>_endthreadex</i>:</p>

<ul>
<p><li>The C run-time library's <i>_getptd</i> function internally
calls the operating system's <i>TlsGetValue</i> function, which
retrieves the address of the calling thread's <i>tiddata</i> memory
block.</li></p>

<p><li>This data block is then freed and the operating system's <i>
ExitThread</i> function is called to truly destroy the thread. Of
course, the exit code is passed and set correctly.</li></p>
</ul>

<p>Earlier in this chapter, I said that you should always try to avoid
using the <i>ExitThread</i> function. This is true and I'm not
going to go back on my word. I said that it kills the calling thread
and doesn't allow it to return from the currently executing
function. Because the function doesn't return, any C++ objects you
can construct will not be destructed. Here's another reason not to
call <i>ExitThread</i>: it prevents the thread's <i>tiddata</i>
memory block from being freed, so your application will leak memory
(until the whole process is terminated). </p>
<p>Microsoft's Visual C++ team realizes that developers like to call
<i>ExitThread</i> anyway, so they have made this possible without
forcing your application to leak memory. If you really want to forcibly
kill your thread, you can have it call <i>_endthreadex</i> (instead of
<i>ExitThread</i>) to free the thread's <i>tiddata</i> block and
then exit. Still, I discourage you from calling <i>
_endthreadex</i>. </p>
<p>By now you should understand why the C/C++ run-time library's
functions need a separate data block for each thread created, and you
should also see how calling <i>_beginthreadex</i> allocates,
initializes, and associates this data block with the newly created
thread. You should also understand how the <i>_endthreadex</i> function
frees the data block when the thread terminates. </p>
<p>Once this data block is initialized and associated with the thread, any
C/C++ run-time library functions the thread calls that require
per-thread instance data can easily retrieve the address to the calling
thread's data block (via <i>TlsGetValue</i>) and manipulate the
thread's data. This is fine for functions, but you might wonder how
this works for a global variable such as <i>errno</i>. Well, <i>
errno</i> is defined in the standard C headers, like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
#if defined(_MT) || defined(_DLL)
extern int * _ _cdecl _errno(void);
#define errno (*_errno())
#else /* ndef _MT &amp;&amp; ndef _DLL */
extern int errno;
#endif /* _MT || _DLL */
</pre></td></tr></table></p>

<p>If you're creating a multithreaded application, you must specify
the /MT (multithreaded application) or /MD (multithreaded DLL) switch
on the compiler's command line. This causes the compiler to define
the _MT identifier. Then, whenever you reference <i>errno</i>, you
actually make a call to the internal C/C++ run-time library function
<i>_errno</i>. This function returns the address to the <i>errno</i>
data member in the calling thread's associated data block.
You'll notice that the <i>errno</i> macro is defined as taking the
contents of this address. This definition is necessary because it's
possible to write code like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
int *p = &amp;errno;
if (*p == ENOMEM) {

   <img src="images/grayvellip.JPG" width=3 height=13 border="0">

}
</pre></td></tr></table></p>

<p>If the internal <i>_errno</i> function simply returned the value of
<i>errno</i>, the above code wouldn't compile. </p>
<p>The multithreaded version of the C/C++ run-time library also places
synchronization primitives around certain functions. For example, if
two threads simultaneously call <i>malloc</i>, the heap can become
corrupted. The multithreaded version of the C/C++ run-time library
prevents two threads from allocating memory from the heap at the same
time. It does this by making the second thread wait until the first has
returned from <i>malloc</i>. Then the second thread is allowed to
enter. (Thread synchronization is discussed in more detail in Chapters
<a href="ch08a.htm">8</a>, <a href="ch09a.htm">9</a>, and <a href="ch10a.htm">10</a>.) </p>
<p>Obviously, all this additional work affects the performance of the
multithreaded version of the C/C++ run-time library. This is why
Microsoft supplies the single-threaded version of the statically linked
C/C++ run-time library in addition to the multithreaded version.</p> 
<p>The dynamically linked version of the C/C++ run-time library was
written to be generic so that it can be shared by any and all running
applications and DLLs using the C/C++ run-time library functions. For
this reason, the library exists only in a multithreaded version. Because the C/C++ run-time library is supplied in a DLL, applications
(.exe files) and DLLs don't need to include the code for the C/C++
run-time library function and are smaller as a result. Also, if
Microsoft fixes a bug in the C/C++ run-time library DLL, applications
automatically gain the fix as well.</p> 
<p>As you might expect, the C/C++ run-time library's startup code
allocates and initializes a data block for your application's
primary thread. This allows the primary thread to safely call any of
the C/C++ run-time functions. When your primary thread returns from its
entry-point function, the C/C++ run-time library frees the associated
data block. In addition, the startup code sets up the proper structured
exception handling code so that the primary thread can successfully
call the C/C++ run-time library's <i>signal</i> function.</p>

<A NAME="92"><h3>Oops&#8212;I Called <i>CreateThread</i> Instead of <i>_beginthreadex</i> by Mistake</h3></A>
<p>You might wonder what happens if you create your new threads by
calling <i>CreateThread</i> instead of the C/C++ run-time library's
<i>_beginthreadex</i> function. When a thread calls a C/C++ run-time
library function that requires the <i>tiddata</i> structure, here is
what happens. (Most C/C++ run-time library functions are thread-safe
and do not require this structure.) First, the C/C++ run-time function
attempts to get the address of the thread's data block (by calling
<i>TlsGetValue</i>). If NULL is returned as the address of the <i>
tiddata</i> block, the calling thread doesn't have a <i>tiddata</i>
block associated with it. At this point, the C/C++ run-time function
allocates and initializes a <i>tiddata</i> block for the calling thread
right on the spot. The block is then associated with the thread (via
<i>TlsSetValue</i>) and this block stays with the thread for as long as
the thread continues to run. The C/C++ run-time function can now use
the thread's <i>tiddata</i> block, and so can any C/C++ run-time
functions that are called in the future.</p> 
<p>This, of course, is fantastic because your thread runs without a hitch
(almost). Well, actually there are a few problems. First, if the thread
uses the C/C++ run-time library's <i>signal</i> function, the
entire process terminates because the structured exception handling
frame has not been prepared. Second, if the thread terminates without
calling <i>_endthreadex</i>, the data block cannot be destroyed and a
memory leak occurs. (And who would call <i>_endthreadex</i> for a
thread created with <i>CreateThread</i>?)</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>
If your module links to the multithreaded DLL version of the C/C++ run-time
library, the library receives a DLL_THREAD_DETACH notification when the
thread terminates and frees the <i>tiddata</i> block (if allocated).
Even though this prevents the leaking of the <i>tiddata</i> block, I
strongly recommend that you create your threads using <i>
_beginthreadex</i> instead of <i>CreateThread</i>.</blockquote></div></p>

<A NAME="93"><H3>C/C++ Run-Time Library Functions That You Should Never Call</H3></A>

<p>The C/C++ run-time library also contains two other functions:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
unsigned long _beginthread(
   void (_ _cdecl *start_address)(void *),
   unsigned stack_size, 
   void *arglist);
</pre></td></tr></table></p>

<p>and</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
void _endthread(void);
</pre></td></tr></table></p>

<p>These two functions were originally created to do the work of the
new <i>_beginthreadex</i> and <i>_endthreadex</i> functions,
respectively. However, as you can see, the <i>_beginthread</i> function
has fewer parameters and is therefore more limited than the
full-featured <i>_beginthreadex</i> function. For example, if you use
<i>_beginthread</i>, you cannot create the new thread with security
attributes, you cannot create the thread suspended, and you cannot
obtain the thread's ID value. The <i>_endthread</i> function has a
similar story: it takes no parameters, which means that the
thread's exit code is hard-coded to 0.</p>

<p>The <i>_endthread</i> function has another significant problem that
you can't see. Just before <i>_endthread</i> calls <i>
ExitThread</i>, it calls <i>CloseHandle</i>, passing the handle of the
new thread. To see why this is a problem, examine the following
code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD dwExitCode;
HANDLE hThread = _beginthread(...);
GetExitCodeThread(hThread, &amp;dwExitCode);
CloseHandle(hThread);
</pre></td></tr></table></p>

<p>The newly created thread might execute, return, and terminate before
the first thread can call <i>GetExitCodeThread</i>. If this happens,
the value in <i>hThread</i> will be invalid because <i>_endthread</i>
has closed the new thread's handle. Needless to say, the call to
<i>CloseHandle</i> will also fail for the same reason.</p>
<p>The new <i>_endthreadex</i> function does not close the thread's
handle, so the code fragment above will work correctly if we replace
the call to <i>_beginthread</i> with a call to <i>_beginthreadex</i>.
Remember that when your thread function returns, <i>_beginthreadex</i>
calls <i>_endthreadex</i>, while <i>_beginthread</i> calls <i>
_endthread</i>.</p>

</BODY>
</HTML>






