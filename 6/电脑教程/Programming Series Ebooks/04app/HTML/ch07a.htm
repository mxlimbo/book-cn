<html>
<head>
<title>Chapter 7 -- Thread Scheduling, Priorities, and Affinities</title>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>

<BODY bgcolor="#ffffff" text="#000000">
<A HREF="ch06i.htm">[Previous]</A> <A HREF="ch07b.htm">[Next]</A><P>



<font size="+3">Chapter 7</font>

<A NAME="96"><H1>Thread Scheduling, Priorities, and Affinities</H1></A>

<p>A preemptive operating system must use some algorithm to determine which threads should be scheduled when and for how long. In this chapter, we'll look at the algorithms that Microsoft Windows 98 and Windows 2000 use.</p>

<p>In <A HREF="ch06a.htm">Chapter 6</A>, we discussed how every thread has a context structure, which is maintained inside the thread's kernel object. This context structure reflects the state of the thread's CPU registers when the thread was last executing. Every 20 milliseconds or so, Windows looks at all of the thread kernel objects currently in existence. Of these objects, only some are considered schedulable. Windows selects one of the schedulable thread kernel objects and loads the CPU's registers with the values that were last saved in the thread's context. This action is called a <i>context switch</i>. Windows actually keeps a record of how many times each thread gets a chance to run. You can see this using a tool such as Microsoft Spy++. The figure below shows the properties for a thread. Notice that this thread has been scheduled 37,379 times.</p>

<p>
<img src="images/G07si01.JPG" width=344 height=286 border="0">
</p>

<p>At this point, the thread is executing code and manipulating data in its process's address space. After another 20 milliseconds or so, Windows saves the CPU's registers back into the thread's context. The thread is no longer running. The system again examines the remaining schedulable thread kernel objects, selects another thread's kernel object, loads this thread's context into the CPU's registers, and continues. This operation of loading a thread's context, letting the thread run, saving the context, and repeating the operation begins when the system boots and continues until the system is shut down.</p>

<p>That, in short, is how the system schedules multiple threads.
We'll discuss more details later, but that is basically it. Simple, isn't it? Windows is called a preemptive multithreaded operating system because a thread can be stopped at any time and another thread can be scheduled. As you'll see, you have some control over this, but not much. Just remember that you cannot guarantee that your thread will always be running, that your thread will get the whole processor, that no other thread will be allowed to run, and so on.</p>

<p><div class="note"><blockquote>
<b>NOTE</b><HR>
Developers frequently ask me how they can guarantee that their thread will start running within some time period of some event&#8212;for example, how can you ensure that a particular thread will start running within 1 millisecond of data coming from the serial port? I have an easy answer: You can't. Real-time operating systems can make these promises, but Windows is not a real-time operating system. A real-time operating system requires intimate knowledge of the hardware it is running on so that it knows the latency associated with its hard disk controllers, keyboards, and so on. Microsoft's goal with Windows is to make it work on a wide variety of hardware: different CPUs, different drives, different networks, and so forth. In short, Windows
is not designed to be a real-time operating system.
</blockquote></div></p>

<p>I stress the idea that the system only schedules schedulable
threads, but as it turns out, most of the threads in the system are not schedulable. For example, some thread objects might have a suspend count greater than 0. This means that the thread is suspended and should not be scheduled any CPU time. You can create a suspended thread by calling <i>CreateProcess</i> or <i>CreateThread</i> using the CREATE_SUSPENDED flag. (Later in this chapter, I'll also discuss the <i>SuspendThread</i> and <i>ResumeThread</i> functions.)</p>

<p>In addition to suspended threads, many other threads are not
schedulable because they are waiting for something to happen. For
example, if you run Notepad and don't type, Notepad's thread
has nothing to do. The system does not assign CPU time to threads that have nothing to do. When you move Notepad's window, or if
Notepad's window needs to repaint its contents, or if you type into Notepad, the system automatically makes Notepad's thread
schedulable. This does not mean that Notepad's thread gets CPU time immediately. It's just that Notepad's thread has something to do and the system will get around to scheduling it at some time&#8212;in the near future, we hope.</p>

</BODY>
</HTML>






