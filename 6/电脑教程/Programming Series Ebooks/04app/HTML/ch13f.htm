<HTML>
<HEAD>
<TITLE>Physical Storage and the Paging File</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch13e.htm">[Previous]</A> <A HREF="ch13g.htm">[Next]</A><P>

<A NAME="174"><H1>Physical Storage and the Paging File</H1></A>

<p>In older operating systems, physical storage was considered to be
the amount of RAM that you had in your machine. In other words, if you
had 16 MB of RAM in your machine, you could load and run applications
that used up to 16 MB of RAM. Today's operating systems have the
ability to make disk space look like memory. The file on the disk is
typically called a <i>paging file</i> and it contains the virtual
memory that is available to all processes.</p>

<p>Of course, for virtual memory to work, a great deal of assistance is
required from the CPU itself. When a thread attempts to access a byte
of storage, the CPU must know whether that byte is in RAM or on the
disk.</p>

<p>From an application's perspective, a paging file transparently
increases the amount of RAM (or storage) that the application can use.
If you have 64 MB of RAM in your machine and also have a 100-MB paging
file on your hard disk, the applications you're running believe
that your machine has a grand total of 164 MB of RAM.</p>

<p>Of course, you don't actually have 164 MB of RAM. Instead, the
operating system, in coordination with the CPU, saves portions of RAM
to the paging file and loads portions of the paging file back into RAM
as the running applications need them. Because a paging file increases
the apparent amount of RAM available for applications, the use of a
paging file is optional. If you don't have a paging file, the system just thinks that there is less RAM
available for applications to use. However, users are strongly
encouraged to use paging files so that they can run more applications
and those applications can work on larger data sets. It is best to
think of physical storage as data stored in a paging file on a disk
drive (usually a hard disk drive). So when an application commits
physical storage to a region of address space by calling the <i>
VirtualAlloc</i> function, space is actually allocated from a file on
the hard disk. The size of the system's paging file is the most
important factor in determining how much physical storage is available
to applications; the amount of RAM you have has very little effect.</p>

<p>
<A HREF="javascript:fullSize('F13si01x.htm')"> <img src="images/F13si01.JPG" width=404 height=533 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><b>Figure 13-1.</b> <i>Example process address spaces for different CPUs</i><!-- /CAPTION -->
</p>

<p>Now, when a thread in your process attempts to access a block of
data in the process's address space, one of two things can happen,
as shown in the flowchart in Figure 13-2.</p>

<p>
<A HREF="javascript:fullSize('F13si02x.htm')"> <img src="images/F13si02.JPG" width=404 height=398 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><b>Figure 13-2.</b> <i>Translating a virtual address to a physical storage address</i><!-- /CAPTION -->
</p>

<p>In the first possibility, the data that the thread is attempting to
access is in RAM. In this case, the CPU maps the data's virtual
memory address to the physical address in memory, and then the desired
access is performed.</p>

<p>In the second possibility, the data that the thread is attempting to
access is not in RAM but is contained somewhere in the paging file. In
this case, the attempted access is called a page fault, and the CPU
notifies the operating system of the attempted access. The operating
system then locates a free page of memory in RAM; if a free page cannot
be found, the system must free one. If a page has not been modified,
the system can simply free the page. But if the system needs to free a
page that was modified, it must first copy the page from RAM to the
paging file. Next the system goes to the paging file, locates the block
of data that needs to be accessed, and loads the data into the free
page of memory. The operating system then updates its table indicating
that the data's virtual memory address now maps to the appropriate
physical memory address in RAM. The CPU now retries the instruction
that generated the initial page fault, but this time the CPU is able to
map the virtual memory address to a physical RAM address and access the
block of data.</p>

<p>The more often the system needs to copy pages of memory to the
paging file and vice versa, the more your hard disk thrashes and the
slower the system runs. (<i>Thrashing</i> means that the operating
system spends all its time swapping pages in and out of memory instead
of running programs.) Thus by adding more RAM to your computer, you
reduce the amount of thrashing necessary to run your applications,
which will, of course, greatly improve the system's performance.
So, here is a general rule of thumb: to make your machine run faster,
add more RAM. In fact, for most situations, you'll get a better
performance boost from adding RAM than you will by getting a faster
CPU.</p>

<A NAME="175"><H2>Physical Storage Not Maintained in the Paging File</H2></A>

<p>After reading the previous section, you must be thinking that the
paging file can get pretty large if many programs are all running at
once&#8212;especially if you're thinking that every time you run a
program the system must reserve regions of address space for the
process's code and data, commit physical storage to these regions,
and then copy the code and data from the program's file on the hard
disk to the committed physical storage in the paging file.</p>

<p>The system does not do what I just described; if it did, it would
take a very long time to load a program and start it running. Instead,
when you invoke an application, the system opens the application's
.exe file and determines the size of the application's code and
data. Then the system reserves a region of address space and notes that
the physical storage associated with this region is the .exe file
itself. That's right&#8212;instead of allocating space from the
paging file, the system uses the actual contents, or <i>image</i>, of
the .exe file as the program's reserved region of address space.
This, of course, makes loading an application very fast and allows the
size of the paging file to remain small.</p>

<p>When a program's file image (that is, an .exe or a DLL file) on
the hard disk is used as the physical storage for a region of address
space, it is called a <i>memory-mapped file</i>. When an .exe or a DLL
is loaded, the system automatically reserves a region of address space
and maps the file's image to this region. However, the system also
offers a set of functions that allow you to map data files to a region
of address space. We will talk about memory-mapped files much more in
<A HREF="ch17a.htm">Chapter 17</A>.</p>

<p><div class="note"><blockquote><b>Windows 2000</b><HR>
Windows 2000 is capable of using multiple paging files. If multiple
paging files exist on different physical hard drives, the system can
perform much faster because it can write to the multiple drives
simultaneously. You can add and remove paging files by opening the
System Properties Control Panel applet, choosing the Advanced tab and
clicking on the Performance Options button. The following figure shows
what this dialog box looks like.

<p>
<img src="images/G13si01.JPG" width=384 height=439 border="0">
</p>
</blockquote></div></p>

<p><div class="note"><blockquote><b>NOTE</b><HR>
When an .exe or a DLL file is loaded from a floppy disk, both Windows 98 and
Windows 2000 copy the entire file from the floppy into the system's
RAM. In addition, the system allocates enough storage from the paging
file to hold the file's image. This storage is only written to if
the system chooses to trim a page of RAM that currently contains a part
of the file's image. If the load on the system's RAM is light,
the file always runs directly from RAM.

<p>Microsoft was forced to make image files executed from
floppies work this way so that setup applications would work correctly.
Often a setup program begins with one floppy, which the user removes
from the drive in order to insert another floppy. If the system needs
to go back to the first floppy to load some of the .exe's or the
DLL's code, it is, of course, no longer in the floppy drive.
However, because the system copied the file to RAM (and is backed by
the paging file), it will have no trouble accessing the setup program.</p>

<p>The system does not copy to RAM image files on other removable media
such as CD-ROMs or network drives unless the image is linked using the
/SWAPRUN:CD or /SWAPRUN:NET switches. Note that Windows 98 does not
support the /SWAPRUN image flags.</p>
</blockquote></div></p>

</BODY>
</HTML>






