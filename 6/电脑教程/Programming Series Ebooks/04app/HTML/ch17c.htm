<HTML>
<HEAD>
<TITLE>Memory-Mapped Data Files</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch17b.htm">[Previous]</A> <A HREF="ch17d.htm">[Next]</A><P>

<A NAME="213"><H1>Memory-Mapped Data Files</H1></A>

<p>The operating system makes it possible to memory map a data file
into your process's address space. Thus it is very convenient to
manipulate large streams of data.</p>

<p>To understand the power of using memory-mapped files this way,
let's look at four possible methods of implementing a program to
reverse the order of all the bytes in a file.</p>

<A NAME="214"><H2>Method 1: One File, One Buffer</H2></A>

<p>The first and theoretically simplest method involves allocating a
block of memory large enough to hold the entire file. The file is
opened, its contents are read into the memory block, and the file is
closed. With the contents in memory, we can now reverse all the bytes
by swapping the first byte with the last, the second byte with the
second-to-last, and so on. This swapping continues until you reach the
middle of the file. After all the bytes have been swapped, you reopen
the file and overwrite its contents with the contents of the memory
block.</p>

<p>This method is pretty easy to implement but has two major drawbacks.
First, a memory block the size of the file must be allocated. This
might not be so bad if the file is small, but what if the file is
huge&#8212;say, 2 GB? A 32-bit system will not allow the application to
commit a block of physical storage that large. Large files require a
different method.</p>

<p>Second, if the process is interrupted in the middle&#8212;while the
reversed bytes are being written back out to the file&#8212;the contents
of the file will be corrupted. The simplest way to guard against this
is to make a copy of the original file before reversing its contents.
If the whole process succeeds, you can delete the copy of the file.
Unfortunately, this safeguard requires additional disk space.</p>

<A NAME="215"><H2>Method 2: Two Files, One Buffer</H2></A>

<p>In the second method, you open the existing file and create a new
file of 0 length on the disk. Then you allocate a small internal
buffer&#8212;say, 8 KB. You seek to the end of the original file minus 8
KB, read the last 8 KB into the buffer, reverse the bytes, and write
the buffer's contents to the newly created file. The process of
seeking, reading, reversing, and writing repeats until you reach the
beginning of the original file. Some special&#8212;but not
extensive&#8212;handling is required if the file's length is not an
exact multiple of 8 KB. After the original file is fully processed,
both files are closed and the original file is deleted.</p>

<p>This method is a bit more complicated to implement than the first one.
It uses memory much more efficiently because only an 8-KB chunk is ever
allocated, but it has two big problems. First, the processing is slower
than in the first method because on each iteration you must perform a
seek on the original file before performing a read. Second, this method
can potentially use an enormous amount of hard disk space. If the
original file is 400 MB, the new file will grow to be 400 MB as the
process continues. Just before the original file is deleted, the two
files will occupy 800 MB of disk space. This is 400 MB more than should
be required&#8212;a disadvantage that leads us to the next method.</p>

<A NAME="216"><H2>Method 3: One File, Two Buffers</H2></A>

<p>For this method, let's say the program initializes by allocating
two separate 8-KB buffers. The program reads the first 8 KB of the file
into one buffer and the last 8 KB of the file into the other buffer.
The process then reverses the contents of both buffers and writes the
contents of the first buffer back to the end of the file and the
contents of the second buffer back to the beginning of the same file.
Each iteration continues by moving blocks from the front and back of
the file in 8-KB chunks. Some special handling is required if the
file's length is not an exact multiple of 16 KB and the two 8-KB
chunks overlap. This special handling is more complex than the special
handling in the previous method, but it's nothing that should scare
off a seasoned programmer.</p>

<p>Compared with the previous two methods, this method is better at
conserving hard disk space. Because everything is read from and written
to the same file, no additional disk space is required. As for memory
use, this method is also not too bad, using only 16 KB. Of course, this
method is probably the most difficult to implement. Like the first
method, this method can result in corruption of the data file if the
process is somehow interrupted.</p>

<p>Now let's take a look at how this process might be accomplished
using memory-mapped files.</p>

<A NAME="217"><H2>Method 4: One File, Zero Buffers</H2></A>

<p>When using memory-mapped files to reverse the contents of a file,
you open the file and then tell the system to reserve a region of
virtual address space. You tell the system to map the first byte of the
file to the first byte of this reserved region. You can then access the
region of virtual memory as though it actually contained the file. In
fact, if there were a single 0 byte at the end of the file, you could
simply call the C run-time function <i>_strrev</i> to reverse the data
in the file.</p>

<p>This method's great advantage is that the system manages all the
file caching for you. You don't have to allocate any memory, load
file data into memory, write data back to the file, or free any memory
blocks. Unfortunately, the possibility that an interruption such as a
power failure could corrupt data still exists with memory-mapped
files.</p>

</BODY>
</HTML>






