<HTML>
<HEAD>
<TITLE>Wait Functions</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch09a.htm">[Previous]</A> <A HREF="ch09c.htm">[Next]</A><P>

<A NAME="124"><H1>Wait Functions</H1></A>

<p><i>Wait functions</i> cause a thread to voluntarily place itself
into a wait state until a specific kernel object becomes signaled. By
far the most common of these functions is <i>WaitForSingleObject</i>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD WaitForSingleObject(
   HANDLE hObject, 
   DWORD dwMilliseconds);
</pre></td></tr></table></p>

<p>When a thread calls this function, the first parameter, <i>
hObject</i>, identifies a kernel object that supports being
signaled/nonsignaled. (Any object mentioned in the list in the previous section
works just great.) The second parameter, <i>dwMilliseconds</i>, allows
the thread to indicate how long it is willing to wait for the object to
become signaled.</p>

<p>The following function call tells the system that the calling thread
wants to wait until the process identified by the <i>hProcess</i>
handle terminates:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
WaitForSingleObject(hProcess, INFINITE); 
</pre></td></tr></table></p>

<p>The second parameter tells the system that the calling thread is
willing to wait forever (an infinite amount of time) until this process
terminates.</p>

<p>Usually, INFINITE is passed as the second parameter to <i>
WaitForSingleObject</i>, but you can pass any value (in milliseconds).
By the way, INFINITE is defined as 0xFFFFFFFF (or -1). Of course,
passing INFINITE can be a little dangerous. If the object never becomes
signaled, the calling thread never wakes up&#8212;it is forever
deadlocked but, fortunately, not wasting precious CPU time.</p>

<p>Here's an example of how to call <i>WaitForSingleObject</i> with
a timeout value other than INFINITE:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD dw = WaitForSingleObject(hProcess, 5000);
switch (dw) {

   case WAIT_OBJECT_0:
      // The process terminated.
      break;

   case WAIT_TIMEOUT:
      // The process did not terminate within 5000 milliseconds.
      break;

   case WAIT_FAILED:
      // Bad call to function (invalid handle?)
      break;
}
</pre></td></tr></table></p>

<p>The code above tells the system that the calling thread should not
be schedulable until either the specified process has terminated or
5000 milliseconds have expired, whichever comes first. So this call
returns in less than 5000 milliseconds if the process terminates, and
it returns in about 5000 milliseconds if the process hasn't
terminated. Note that you can pass 0 for the <i>dwMilliseconds</i>
parameter. If you do this, <i>WaitForSingleObject</i> always returns
immediately.</p>

<p><i>WaitForSingleObject</i>'s return value indicates why the calling
thread became schedulable again. If the object the thread is waiting on
became signaled, the return value is WAIT_OBJECT_0; if the timeout
expires, the return value is WAIT_TIMEOUT. If you pass a bad parameter
(such as an invalid handle) to <i>WaitForSingleObject</i>, the return
value is WAIT_FAILED (call <i>GetLastError</i> for more
information).</p>

<p>The function below, <i>WaitForMultipleObjects</i>, is similar to <i>
WaitForSingleObject</i> except that it allows the calling thread to
check the signaled state of several kernel objects simultaneously:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD WaitForMultipleObjects(
   DWORD dwCount, 
   CONST HANDLE* phObjects,
   BOOL fWaitAll, 
   DWORD dwMilliseconds); 
</pre></td></tr></table></p>

<p>The <i>dwCount</i> parameter indicates the number of kernel objects
you want the function to check. This value must be between 1 and
MAXIMUM_WAIT_OBJECTS (defined as 64 in the Windows header files). The <i>
phObjects</i> parameter is a pointer to an array of kernel object
handles.</p> 

<p>You can use <i>WaitForMultipleObjects</i> in two different ways&#8212;to
allow a thread to enter a wait state until any one of the specified
kernel objects becomes signaled, or to allow a thread to wait until all
of the specified kernel objects become signaled. The <i>fWaitAll</i>
parameter tells the function which way you want it to work. If you pass
TRUE for this parameter, the function will not allow the calling thread
to execute until all of the objects have become signaled.</p>

<p>The <i>dwMilliseconds</i> parameter works exactly as it does for <i>
WaitForSingleObject</i>. If, while waiting, the specified time expires,
the function returns anyway. Again, INFINITE is usually passed for this
parameter, but you should write your code carefully to avoid the
possibility of deadlock.</p>

<p>The <i>WaitForMultipleObjects</i> function's return value tells the
caller why it got rescheduled. The possible return values are
WAIT_FAILED and WAIT_TIMEOUT, which are self-explanatory. If you pass TRUE for <i>
fWaitAll</i> and all of the objects become signaled, the return value
is WAIT_OBJECT_0. If you pass FALSE for <i>fWaitAll</i>, the function
returns as soon as any of the objects becomes signaled. In this case,
you probably want to know which object became signaled. The return
value is a value between WAIT_OBJECT_0 and (WAIT_OBJECT_0 + <i>
dwCount</i> -1). In other words, if the return value is not
WAIT_TIMEOUT and is not WAIT_FAILED, you should subtract WAIT_OBJECT_0
from the return value. The resulting number is an index into the array
of handles that you passed as the second parameter to <i>
WaitForMultipleObjects</i>. The index tells you which object became
signaled.</p>

<p>Here's some sample code to make this clear:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
HANDLE h[3];
h[0] = hProcess1;
h[1] = hProcess2;
h[2] = hProcess3;
DWORD dw = WaitForMultipleObjects(3, h, FALSE, 5000);
switch (dw) {
   case WAIT_FAILED:
      // Bad call to function (invalid handle?)
      break;

   case WAIT_TIMEOUT:
      // None of the objects became signaled within 5000 milliseconds.
      break;

   case WAIT_OBJECT_0 + 0:
      // The process identified by h[0] (hProcess1) terminated.
      break;

   case WAIT_OBJECT_0 + 1:
      // The process identified by h[1] (hProcess2) terminated.
      break;

   case WAIT_OBJECT_0 + 2:
      // The process identified by h[2] (hProcess3) terminated.
      break;
}
</pre></td></tr></table></p>

<p>If you pass FALSE for the <i>fWaitAll</i> parameter, <i>
WaitForMultipleObjects</i> scans the handle array from index 0 on up,
and the first object that is signaled terminates the wait. This can
have some undesirable ramifications. For example, your thread might be
waiting for three child processes to terminate by passing three process
handles to this function. If the process at index 0 in the array
terminates, <i>WaitForMultipleObjects</i> returns. Now the thread can
do whatever it needs to and then loop back around, waiting for another
process to terminate. If the thread passes the same three handles, the
function returns immediately with WAIT_OBJECT_0 again. Unless you
remove the handles that you've already received notifications from,
your code will not work correctly.</p>


</BODY>
</HTML>






