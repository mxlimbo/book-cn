<HTML>
<HEAD>
<TITLE>Miscellaneous Heap Functions</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch18d.htm">[Previous]</A> <A HREF="ch19a.htm">[Next]</A><P>

<A NAME="249"><H1>Miscellaneous Heap Functions</H1></A>

<p>In addition to the heap functions I've already mentioned,
Windows offers several more. In this section, I'll just briefly
mention them.</p>

<p>The ToolHelp functions (mentioned at the end of <A HREF="ch04a.htm">Chapter 4</A>) allow you to
enumerate a process's heaps as well as the allocations within those
heaps. For more information, look up the following functions in the
Platform SDK documentation: <i>Heap32First</i>, <i>Heap32Next</i>, 
<i>Heap32ListFirst</i>, and <i>Heap32ListNext.</i> What's great about
the ToolHelp functions is that they are available in both Windows 98
and Windows 2000.</p>

<p>The remaining heap functions discussed in this section exist only in
Windows 2000.</p>

<p>Since a process can have multiple heaps within its address space,
the <i>GetProcessHeaps</i> function allows you to get the handles of
the existing heaps:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD GetProcessHeaps(
   DWORD dwNumHeaps, 
   PHANDLE pHeaps);
</pre></td></tr></table></p>

<p>To call <i>GetProcessHeaps</i>, you must first allocate an array of
HANDLEs and then call the function as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
HANDLE hHeaps[25];
DWORD dwHeaps = GetProcessHeaps(25, hHeaps);
if (dwHeaps &gt; 25) {
   // More heaps are in this process than we expected.
} else {
   // hHeaps[0] through hHeap[dwHeaps - 1] 
   // identify the existing heaps.
}
</pre></td></tr></table></p>

<p>Note that the handle of your process's default heap is also
included in the array of heap handles when this function returns. The
<i>HeapValidate</i> function validates the integrity of a heap:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL HeapValidate(
   HANDLE hHeap, 
   DWORD fdwFlags, 
   LPCVOID pvMem);
</pre></td></tr></table></p>

<p>You will usually call this function by passing a heap handle, a flag
of 0 (the only other legal flag is HEAP_NO_SERIALIZE), and NULL for 
<i>pvMem</i>. This function will then walk the blocks within the heap,
making sure that no blocks are corrupt. To make the function execute
faster, you might want to pass the address of a specific block for the
<i>pvMem</i> parameter. Doing so causes the function to check the
validity of only the single block.</p>

<p>To coalesce free blocks within a heap and also decommit any pages of
storage that do not contain allocated heap blocks, you can call</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
UINT HeapCompact(
   HANDLE hHeap, 
   DWORD fdwFlags);
</pre></td></tr></table></p>

<p>Normally, you'll pass 0 for the <i>fdwFlags</i> parameter, but
you can also pass HEAP_NO_SERIALIZE.</p>

<p>The next two functions, <i>HeapLock</i> and <i>HeapUnlock</i>, are used
together:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL HeapLock(HANDLE hHeap);
BOOL HeapUnlock(HANDLE hHeap);
</pre></td></tr></table></p>

<p>These functions are for thread synchronization purposes. When you
call <i>HeapLock</i>, the calling thread becomes the owner of the
specified heap. If any other thread calls a heap function (specifying
the same heap handle), the system will suspend the calling thread and
not allow it to wake until the heap is unlocked by calling <i>
HeapUnlock</i>.</p>

<p>Functions such as <i>HeapAlloc</i>, <i>HeapSize</i>, <i>HeapFree</i>,
and so on call <i>HeapLock</i> and <i>HeapUnlock</i> internally to make
sure that access to the heap is serialized. It would be unusual for you
ever to have to call <i>HeapLock</i> or <i>HeapUnlock</i> yourself.</p>

<p>The final heap function is <i>HeapWalk</i>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL HeapWalk(
   HANDLE hHeap, 
   PPROCESS_HEAP_ENTRY pHeapEntry);
</pre></td></tr></table></p>

<p>This function is useful for debugging purposes only. It allows you
to walk the contents of a heap. You will call this function multiple
times. Each time, you'll pass in the address of a
PROCESS_HEAP_ENTRY structure that you must allocate and initialize:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef struct _PROCESS_HEAP_ENTRY {
   PVOID lpData;
   DWORD cbData;
   BYTE cbOverhead;
   BYTE iRegionIndex;
   WORD wFlags;
   union {
      struct {
         HANDLE hMem;
         DWORD dwReserved[ 3 ];
      } Block;
      struct {
         DWORD dwCommittedSize;
         DWORD dwUnCommittedSize;
         LPVOID lpFirstBlock;
         LPVOID lpLastBlock;
      } Region;
   };
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;
</PRE>
</TD></TR></TABLE>
</P>

<p>When you start enumerating the blocks in the heap, you’ll have to set 
the <i>lpData</i> member to NULL. This tells <i>HeapWalk</i> to initialize the members 
inside the structure. You can examine the members of the structure after 
each successful call to <i>HeapWalk</i>. To get to the next block in the heap, 
you just call <i>HeapWalk</i> again, passing the same heap handle and the address 
of the PROCESS_HEAP_ENTRY structure you passed on the previous call. When 
<i>HeapWalk</i> returns FALSE, there are no more blocks in the heap. See the 
Platform SDK documentation for a description of the members in the structure.</p>

<p>You will probably want to use the <i>HeapLock</i> and <i>HeapUnlock</i> functions around 
your <i>HeapWalk</i> loop so that other threads cannot allocate and free blocks of 
memory inside the heap while you’re walking it.</p>


</body>

</html>







