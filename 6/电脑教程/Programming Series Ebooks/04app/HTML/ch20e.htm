<HTML>
<HEAD>
<TITLE>Function Forwarders</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch20d.htm">[Previous]</A> <A HREF="ch20f.htm">[Next]</A><P>

<A NAME="276"><H1>Function Forwarders</H1></A>

<p>A function forwarder is an entry in a DLL's export section that redirects a function call to another function in another DLL. For example, if you run the Visual C++ DumpBin utility on the Windows 2000 Kernel32.dll, you'll see a part of the output that looks like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
C:\winnt\system32&gt;DumpBin -Exports Kernel32.dll
<i>     (some output omitted)</i>
360  167   HeapAlloc (forwarded to NTDLL.RtlAllocateHeap)
361  168   HeapCompact  (000128D9)
362  169   HeapCreate  (000126EF)
363  16A   HeapCreateTagsW  (0001279E)
364  16B   HeapDestroy  (00012750)
365  16C   HeapExtend  (00012773)
366  16D   HeapFree (forwarded to NTDLL.RtlFreeHeap)
367  16E   HeapLock  (000128ED)
368  16F   HeapQueryTagW  (000127B8)
369  170   HeapReAlloc (forwarded to NTDLL.RtlReAllocateHeap)
370  171   HeapSize (forwarded to NTDLL.RtlSizeHeap)
<i>     (remainder of output omitted)</i> 
</pre>
</td></tr></table></p>

<p>This output shows four forwarded functions. Whenever your
application calls <i>HeapAlloc</i>, <i>HeapFree</i>, <i>HeapReAlloc</i>, or <i>HeapSize</i>, your executable is dynamically linked with Kernel32.dll. When you invoke your executable, the loader loads Kerenl32.dll and sees that forwarded functions are actually contained inside NTDLL.dll. It then loads the NTDLL.dll module as well. When your executable calls <i>HeapAlloc</i>, it is actually calling the <i>RtlAllocateHeap</i> function inside NTDLL.dll. A <i>HeapAlloc</i> function doesn't exist anywhere in the system!</p>

<p>If you call the following function, <i>GetProcAddress</i> looks in Kernel32's export section, sees that <i>HeapAlloc</i> is a forwarded function, and then calls <i>GetProcAddress</i> recursively, looking for <i>RtlAllocateHeap</i> inside NTDLL.dll's export section.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
GetProcAddress(GetModuleHandle(&quot;Kernel32&quot;), &quot;HeapAlloc&quot;); 
</pre>
</td></tr></table></p>

<p>You can take advantage of function forwarders in your DLL module as well. The easiest way to do this is by using a <i>pragma</i> directive, as shown here:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
// Function forwarders to functions in DllWork
#pragma comment(linker, &quot;/export:SomeFunc=DllWork.SomeOtherFunc&quot;) 
</pre>
</td></tr></table></p>

<p>This <i>pragma</i> tells the linker that the DLL being compiled should export a function called <i>SomeFunc</i>. But the actual implementation of <i>SomeFunc</i> is in another function called <i>SomeOtherFunc</i>, which is contained in a module called DllWork.dll. You must create separate <i>pragma</i> lines for each function you want to forward.</p>

</BODY>
</HTML>






