<html>
<head>
<title>Chapter 9 -- Thread Synchronization with Kernel Objects</title>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<A HREF="ch08e.htm">[Previous]</A> <A HREF="ch09b.htm">[Next]</A><P>



<font size="+3">Chapter 9</font>


<A NAME="123"><H1>Thread Synchronization With Kernel Objects</H1></A>

<p>In the last chapter, we discussed how to synchronize threads using
mechanisms that allow your threads to remain in user mode. The
wonderful thing about user-mode synchronization is that it is very
fast. If you are concerned about your thread's performance, you
should first determine whether a user-mode thread synchronization
mechanism will work for you.</p>

<p>While user-mode thread synchronization mechanisms offer great
performance, they do have limitations, and for many applications they
simply do not work. For example, the interlocked family of functions
operates only on single values and never places a thread into a wait
state. You can use critical sections to place a thread in a wait state,
but you can use them only to synchronize threads contained within a
single process. Also, you can easily get into deadlock situations with
critical sections because you cannot specify a timeout value while
waiting to enter the critical section.</p>

<p>In this chapter, we'll discuss how to use kernel objects to
synchronize threads. As you'll see, kernel objects are far more
versatile than the user-mode mechanisms. In fact, the only bad side to
kernel objects is their performance. When you call any of the new
functions mentioned in this chapter, the calling thread must transition
from user mode to kernel mode. This transition is costly: it takes
about 1000 CPU cycles on the <i>x</i>86 platform for a
round-trip&#8212;and this, of course, does not include the execution of
the kernel-mode code that actually implements the function your thread
is calling.</p>

<p>Throughout this book, we've discussed several kernel objects,
including processes, threads, and jobs. You can use almost all of these
kernel objects for synchronization purposes. For thread
synchronization, each of these kernel objects is said to be in a
signaled or nonsignaled state. The toggling of this state is determined
by rules that Microsoft has created for each object. For example,
process kernel objects are always created in the nonsignaled state.
When the process terminates, the operating system automatically makes
the process kernel object signaled. Once a process kernel object is
signaled, it remains that way forever; its state never changes back to
nonsignaled.</p>

<p>A process kernel object is nonsignaled while the process is running,
and it becomes signaled when the process terminates. Inside a process
kernel object is a Boolean value that is initialized to FALSE
(nonsignaled) when the object is created. When the process terminates,
the operating system automatically changes the corresponding
object's Boolean value to TRUE, indicating that the object is
signaled.</p>

<p>If you want to write code that checks whether a process is still
running, all you do is call a function that asks the operating system
to check the process object's Boolean value. That's easy
enough. You might also want to tell the system to put your thread in a
wait state and wake it up automatically when the Boolean changes from
FALSE to TRUE. This way, you can write code in which a thread in a
parent process that needs to wait for the child process to terminate
can simply put itself to sleep until the kernel object identifying the
child process becomes signaled. As you'll see, Microsoft Windows
offers functions that accomplish all this easily.</p>

<p>I've just described the rules that Microsoft has defined for a
process kernel object. As it turns out, thread kernel objects follow
the same rules. That is, thread kernel objects are always created in
the nonsignaled state. When the thread terminates, the operating system
automatically changes the thread object's state to signaled.
Therefore, you can use the same technique in your application to
determine whether a thread is no longer executing. Just like process
kernel objects, thread kernel objects never return to the nonsignaled
state.</p>

<p>The following kernel objects can be in a signaled or nonsignaled
state:</p>

<P>
	<TABLE CELLPADDING=5 WIDTH="95%">
		<TR>
			<TD CLASS="COLUMNS"><li>Processes</li></TD>
			<TD CLASS="COLUMNS"><li>File change notifications</li></TD>
		</TR>

		<TR>
			<TD CLASS="COLUMNS"><li>Threads</li></TD>
			<TD CLASS="COLUMNS"><li>Events</li></TD>
		</TR>
		
		<TR>
			<TD CLASS="COLUMNS"><li>Jobs</li></TD>
			<TD CLASS="COLUMNS"><li>Waitable timers</li></TD>
		</TR>

		<TR>
			<TD CLASS="COLUMNS"><li>Files</li></TD>
			<TD CLASS="COLUMNS"><li>Semaphores</li></TD>
		</TR>
		
		<TR>
			<TD CLASS="COLUMNS"><li>Console input</li></TD>
			<TD CLASS="COLUMNS"><li>Mutexes</li></TD>
		</TR>
		
	</TABLE>
</P>

<p>Threads can put themselves into a wait state until an object becomes
signaled. Note that the rules that govern the signaled/nonsignaled
state of each object depend on the type of object. I've already
mentioned the rules for process and thread objects. I discuss the rules
for jobs in <A HREF="ch05a.htm">Chapter 5</A>.</p>

<p>In this chapter, we'll look at the functions that allow a thread
to wait for a specific kernel object to become signaled. Then we'll
look at the kernel objects that Windows offers specifically to help you
synchronize threads: events, waitable timers, semaphores, and
mutexes.</p>

<p>When I was first learning this stuff, it helped if I imagined that
kernel objects contained a flag (the wave-in-the-air kind, not the bit
kind). When the object was signaled, the flag was raised; when the
object was nonsignaled, the flag was lowered.</p>

<p>
<A HREF="javascript:fullSize('G09SI01x.htm')"> <img src="images/G09SI01.JPG" width=404 height=153 border=0 ALT="Click to view at full size."> </A>
</p>

<p>Threads are not schedulable when the objects they are waiting for
are nonsignaled (the flag is lowered). However, as soon as the object
becomes signaled (the flag goes up), the thread sees the flag, becomes
schedulable, and shortly resumes execution.</p>

<p>
<A HREF="javascript:fullSize('G09SI02x.htm')"> <img src="images/G09SI02.JPG" width=404 height=158 border=0 ALT="Click to view at full size."> </A>
</p>


</BODY>
</HTML>






