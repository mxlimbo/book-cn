<HTML>
<HEAD>
<TITLE>Some Thread Internals</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch06f.htm">[Previous]</A> <A HREF="ch06h.htm">[Next]</A><P>

<A NAME="90"><H1>Some Thread Internals</H1></A>

<p>So far, I've explained how to implement a thread function and
how to have the system create a thread to execute that function. In
this section, we'll look at how the system pulls this off. </p>
<p>Figure 6-1 shows what the system must do to create and initialize a
thread. Let's look closely at this figure to understand exactly
what's going on. A call to <i>CreateThread</i> causes the system to
create a thread kernel object. This object has an initial usage count
of 2. (The thread kernel object is not destroyed until the thread stops
running <i>and</i> the handle returned from <i>CreateThread</i> is
closed.) Other properties of the thread's kernel object are also
initialized: the suspension count is set to 1, the exit code is set to
STILL_ACTIVE (0x103), and the object is set to the nonsignaled
state. </p>
<p>Once the kernel object has been created, the system allocates memory,
which is used for the thread's stack. This memory is allocated from
the process's address space since threads don't have an address
space of their own. The system then writes two values to the upper end
of the new thread's stack. (Thread stacks always build from high
memory addresses to low memory addresses.) The first value written to
the stack is the value of the <i>pvParam</i> parameter that you passed
to <i>CreateThread</i>. Immediately below it is the <i>pfnStartAddr</i>
value that you also passed to <i>CreateThread</i>.</p>

<p>
<A HREF="javascript:fullSize('F06SI01x.htm')"> <img src="images/F06SI01.JPG" width=404 height=213 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><b>Figure 6-1.</b> <i>How a thread is created and initialized</i><!-- /CAPTION -->
</p>

<p>Each thread has its own set of CPU registers, called the
thread's <i>context</i>. The context reflects the state of the
thread's CPU registers when the thread last executed. The set of
CPU registers for the thread is saved in a CONTEXT structure (defined
in the WinNT.h header file). The CONTEXT structure is itself contained
in the thread's kernel object.</p>

<p>The instruction pointer and stack pointer registers are the two most
important registers in the thread's context. Remember that threads
always run in the context of a process. So both these addresses
identify memory in the owning process's address space. When the
thread's kernel object is initialized, the CONTEXT structure's
stack pointer register is set to the address of where <i>
pfnStartAddr</i> was placed on the thread's stack. The instruction
pointer register is set to the address of an undocumented (and
unexported) function called <i>BaseThreadStart</i>. This function is
contained inside the Kernel32.dll module (which is also where the <i>
CreateThread</i> function is implemented). Figure 6-1 shows all of
this.</p>

<p>Here is what <i>BaseThreadStart</i> basically does:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
VOID BaseThreadStart(PTHREAD_START_ROUTINE pfnStartAddr, PVOID pvParam) {
   _ _try {
      ExitThread((pfnStartAddr)(pvParam));
   }
   _ _except(UnhandledExceptionFilter(GetExceptionInformation())) {
      ExitProcess(GetExceptionCode());
   }
   // NOTE: We never get here.
}
</pre></td></tr></table></p>

<p>After the thread has completely initialized, the system checks to
see whether the CREATE_SUSPENDED flag was passed to <i>
CreateThread</i>. If this flag was not passed, the system decrements
the thread's suspend count to 0 and the thread can be scheduled to
a processor. The system then loads the actual CPU registers with the
values that were last saved in the thread's context. The thread can
now execute code and manipulate data in its process's address
space. </p>
<p>Because a new thread's instruction pointer is set to <i>
BaseThreadStart</i>, this function is really where the thread begins
execution. <i>BaseThreadStart</i>'s prototype makes you think that
the function receives two parameters, but this implies that the
function is called from another function, which is not true. The new
thread simply comes into existence and starts executing here. <i>
BaseThreadStart</i> believes that it was called from another function
because it has access to two parameters. But access to these parameters
works because the operating system explicitly wrote the values to the
thread's stack (which is how parameters are normally passed to a
function). Note that some CPU architectures pass parameters using CPU
registers instead of the stack. For these architectures, the system
initializes the proper registers correctly before allowing the thread
to execute the <i>BaseThreadStart</i> function. </p>
<p>When the new thread executes the <i>BaseThreadStart</i> function, the
following things happen:</p>

<ul>
<p><li>A structured exception handling (SEH) frame is set up around your
thread function so that any exceptions raised while your thread
executes get some default handling by the system. (See Chapters 23, 24,
and 25 for more information about structured exception handling.)</li></p>

<p><li>The system calls your thread function, passing it the <i>
pvParam</i> parameter that you passed to the <i>CreateThread</i>
function.</li></p>

<p><li>When your thread function returns, <i>BaseThreadStart</i> calls
<i>ExitThread</i>, passing it your thread function's return value.
The thread kernel object's usage count is decremented and the
thread stops executing.</li></p>

<p><li>If your thread raises an exception that is not handled, the SEH
frame set up by the <i>BaseThreadStart</i> function handles the
exception. Usually, this means that a message box is presented to the
user and that when the user dismisses the message box, <i>
BaseThreadStart</i> calls <i>ExitProcess</i> to terminate the entire
process, not just the offending thread.</li></p>
</ul>


<p>Notice that within <i>BaseThreadStart</i>, the thread calls either
<i>ExitThread</i> or <i>ExitProcess</i>. This means that the thread
cannot ever exit this function; it always dies inside it. This is why
<i>BaseThreadStart</i> is prototyped as returning VOID&#8212;it never
returns.</p>

<p>Also, your thread function can return when it's done processing
because of <i>BaseThreadStart</i>. When <i>BaseThreadStart</i> calls
your thread function, it pushes its return address on the stack so your
thread function knows where to return. But <i>BaseThreadStart</i> is
not allowed to return. If it didn't forcibly kill the thread and
simply tried to return, an access violation would almost definitely be
raised because there is no function return address on the thread's
stack and <i>BaseThreadStart</i> would try to return to some random
memory location.</p>

<p>When a process's primary thread is initialized, its instruction
pointer is set to another undocumented function called <i>
BaseProcessStart</i>. This function is almost identical to <i>
BaseThreadStart</i> and looks something like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
VOID BaseProcessStart(PPROCESS_START_ROUTINE pfnStartAddr) {
   _ _try {
      ExitThread((pfnStartAddr)());
   }
   _ _except(UnhandledExceptionFilter(GetExceptionInformation())) {
      ExitProcess(GetExceptionCode());
   }
   // NOTE: We never get here.
}
</pre></td></tr></table></p>

<p>The only real difference is that there is no reference to the <i>
pvParam</i> parameter. When <i>BaseProcessStart</i> begins executing,
it calls the C/C++ run time library's startup code, which
initializes and then calls your <i>main, wmain, WinMain</i>, or <i>
wWinMain</i> function. When your entry-point function returns, the
C/C++ run-time library startup code calls <i>ExitProcess</i>. So for a
C/C++ application, the primary thread never returns to the <i>
BaseProcessStart</i> function.</p>

</BODY>
</HTML>






