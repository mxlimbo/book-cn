<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>Connection Notification</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="421"><H1>Connection Notification</H1></A>

<P>Windows CE Services gives you two ways of notifying PC-based applications when a connection is made with a Windows CE device. The first method is to simply launch all the applications listed under a given registry key. When the connection is broken, all applications listed under another key are launched. This method has the advantage of simplicity at the cost of having the application not know why it was launched.

<P>The second method of notification is a COM-interface method. This notification method involves two interfaces: <I>IDccMan</I>, provided by RAPI.DLL, and <I>IDccManSink,</I> which must be implemented by the application that wants to be notified. This method has the advantage of providing much more information to the application as to what is actually happening at the cost of having to implement a COM-style interface.

<A NAME="422"><H2>Registry Method</H2></A>

<P>To have your PC application launched when a connection is made to a Windows CE device, simply add a value to the PC registry under the following key:

<p><pre>
[HKEY_LOCAL_MACHINE]
\Software\Microsoft\Windows CE Services\AutoStartOnConnect
</PRE>

<P>I'll show you shortly how to access this key using <I>CeSvcOpen</I> so that the precise name of the key can be abstracted. The name of the value under <I>AutoStartOnConnect</I> can be anything, but it must be something unique. The best way to ensure this is to include your company name and product name plus its version in the value name. The actual data for the value should be a string that contains the fully specified path for the application you want to launch. The string can only be the filename; appending a command line string causes an error when the program is launched. For example, to launch a myapp program that's loaded in the directory <I>c:\windowsce\tools\syncstuff</I>, the value and data might be

<p><pre>
MyCorpThisApp  c:\windowsce\tools\syncstuff\myapp.exe
</PRE>

<P>To have a command line passed to your application, you can have the entry in the registery point to a shortcut that will launch your application. The entry in the registry can't pass a command line, but shortcuts don't have that limitation.

<P>You can have an application launched when the connection is broken between the PC and the Windows CE device by placing a value under the following key:


<p><pre>
[HKEY_LOCAL_MACHINE]
\Software\Microsoft\Windows CE Services\AutoStartOnDisconnect
</PRE>

<P>The format for the value name and the data is the same as the format used in the <I>AutoStartOnConnect</I> key.

<P>A routine to set these values is simple to write. The example routine below uses the <I>CeSvcOpen</I> and <I>CeSvcSetString</I> functions to write the name of the module to the registry. Remember that since this routine runs on a PC, and therefore perhaps under Windows NT, you'll need administrator access for this routine to have write access to the registry.

<p><pre>
//
// RegStartOnConnect _ Have module started when connect occurs.
//
LPARAM RegStartOnConnect (HINSTANCE hInst) {
    TCHAR szName[MAX_PATH];
    HCESVC hSvc;
    HRESULT rc;

    // Get the name of the module.
    GetModuleFileName (hInst, szName, dim(szName));

    // Open the AutoStartOnConnect key.
    rc = CeSvcOpen (CESVC_ROOT_MACHINE, &quot;AutoStartOnConnect&quot;,
        TRUE, &amp;hSvc);
    if (rc == NOERROR) {
        // Write the module name into the registry.
        CeSvcSetString (hSvc, TEXT (&quot;MyCompanyMyApp&quot;), szName);
        CeSvcClose (hSvc);
    }
    return rc;
}
</PRE>

<P>The routine above doesn't have to know the absolute location of the Windows CE Services keys in the registry, only that the AutoStart key is under CESVC_ROOT_MACHINE. You can modify this routine to have your application started when a connection is broken by substituting <I>AutoStartOnConnect</I> with <I>AutoStartOnDisconnect</I> in the call to <I>CeSvcOpen</I>.

<A NAME="423"><H2>COM Method</H2></A>

<P>As I mentioned before, the COM method of connection notification is implemented using two COM interfaces&#8212;<I>IDccMan</I> and <I>IDccManSink</I>. The system implements <I>IDccMan</I>, while you are responsible for implementing <I>IDccManSink</I>. The <I>IDccMan</I> interface gives you a set of methods that allow you to control the link between the PC and the Windows CE device. Unfortunately, most of the methods in <I>IDccMan</I> aren't currently implemented. The <I>IDccManSink</I> interface is a series of methods that are called by the connection manager to notify you that a connection event has occurred. Implementing each of the methods in <I>IDccManSink</I> is trivial because you don't need to take any action to acknowledge the notification.

<P>The process of connection notification is simple. You request an <I>IDccMan </I>interface. You call a method in <I>IDccMan</I> to pass a pointer to your <I>IDccManSink</I> interface. Windows CE Services calls the methods in <I>IDccManSink</I> to notify you of events as they occur. In this section, I'll talk about the unique methods in <I>IDccManSink </I>and <I>IDccMan</I>, but I'll skip over the <I>IUnknown</I> methods that are part of every COM interface. For a very brief introduction to COM, read the sidebar, &quot;<A HREF="ch11e.htm#443">COM Isn't a Four-Letter Word</a>&quot; at the end of this chapter and the Appendix, &quot;<A HREF="appa.htm#3">COM Basics</a>.&quot;

<A NAME="424"><H3>The <I>IDccMan</I> interface</H3></A>

<P>To gain access to the <I>IDccMan </I>interface, you need to call the COM library function <I>CoInitialize</I> to initialize the COM library. Then you make a call to <I>CoCreateInstance</I> to retrieve a pointer to the <I>IDccMan</I> interface. Once you have this interface pointer, you call the method <i>IDccMan::Advise</i> to notify the connection manager that you want to be notified about connection events. This method is prototyped as

<p><pre>
HRESULT IDccMan::Advise (IDccManSink *pDccSink,
                         DWORD *pdwContext);
</PRE>

<P>The first parameter is a pointer to an <I>IDccManSink</I> interface that you must have previously created. I'll talk about <I>IDccManSink </I>shortly. The second parameter is a pointer to a DWORD that receives a context value that you pass to another <I>IDccMan</I> method when you request that you no longer be advised of events.

<P>You can display the communications configuration dialog of Windows CE Services by calling this method:

<p><pre>
HRESULT IDccMan::ShowCommSettings (void);
</PRE>

<P>There are no parameters. This method simply displays the communications dialog box. The user is responsible for making any changes to the configuration and for dismissing the dialog box.

<P>When you no longer need connection notifications, you call the <I>Unadvise</I> method, prototyped as

<p><pre>
HRESULT IDccMan::Unadvise (DWORD dwContext);
</PRE>

<P>The only parameter is the context value that was returned by the <I>Advise</I> method. After you have called <I>Unadvise</I>, you no longer need to maintain the <I>IDccManSink </I>interface.

<A NAME="425"><H3>The <I>IDccManSink</I> interface</H3></A>

<P>You are responsible for creating and maintaining the <I>IDccManSink</I> interface for as long as you want notifications from the connection manager. The interface methods are simple to implement&#8212;you simply provide a set of methods that are called by the connection manager when a set of events occurs. Following are the prototypes for the methods of <I>IDccManSink</I>:

<p><pre>
HRESULT IDccManSink::OnLogListen (void);

HRESULT IDccManSink::OnLogAnswered (void);

HRESULT IDccManSink::OnLogIpAddr (DWORD dwIpAddr);

HRESULT IDccManSink::OnLogActive (void);

HRESULT IDccManSink::OnLogTerminated (void);

HRESULT IDccManSink::OnLogInactive (void);

HRESULT IDccManSink::OnLogDisconnection (void);

HRESULT IDccManSink::OnLogError (void);
</PRE>

<P>While the documentation describes a step-by-step notification by the connection manager, calling each of the methods of <I>IDccManSink</I> as the events occur, I've found that only a few of the methods are actually called with any consistency.

<P>When you call <I>CoCreateInstance</I> to get a pointer to the <I>IDccManSink</I> interface, the connection manager is loaded into memory. When you call <I>Advise</I>, the connection manager responds with a call to <I>OnLogListen</I>, indicating that the connection manager is listening for a connection. When a connection is established, the connection manager calls <I>OnLogIpAddr</I> to notify you of the IP address of the connected device. <I>OnLogIpAddr</I> is the only method in <I>IDccManSink</I> that has a parameter. This parameter is the IP address of the device being connected. This address is handy if you want to establish a socket connection to the device, bypassing the extensive support of the connection manager and RAPI. This IP address can change between different devices and even when connecting the same device if one connection is made using the serial link and a later connection is made across a LAN. The connection manager then calls <I>OnLogActive </I>to indicate that the connection between the PC and the device is up and fully operational.

<P>When the connection between the PC and the Windows CE devices is dropped, the connection manager calls the <I>OnLogDisconnection</I> method. This disconnection notification can take up to a few seconds before it's sent after the connection has actually been dropped. The connection manager then calls the <I>OnLogListen</I> method to indicate that it is in the listen state, ready to initiate another connection.

<P>Some of the other methods are called under Windows 98. Those methods simply refine the state of the connection even further. Since your application has to operate as well under Windows NT as it does under Windows 98, you'll need to be able to operate properly using only the notifications I've just described.

<A NAME="426"><H2>The CnctNote Example Program</H2></A>

<P>The CnctNote program is a simple dialog box-based application that uses the COM-based method for monitoring the PC-to-Windows CE device connection state. The example doesn't act on the notifications&#8212;it simply displays them in a list box. The source code for CnctNote is shown in Figure 11-7.

<P><B>Figure 11-7.</B> <I>CnctNote source code.</I>

<p><TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="427"><H3>CnctNote.rc</H3></A>
<P><pre>
//====================================================================
// Resource file

//
// Written for the book Programming Windows CE


// Copyright (C) 1998 Douglas Boling
//====================================================================

#include &quot;windows.h&quot;
#include &quot;CnctNote.h&quot;                     // Program-specific stuff

//-----------------------------------------------------------------------
// Icons and bitmaps
//
ID_ICON ICON   &quot;CnctNote.ico&quot;             // Program icon

//-----------------------------------------------------------------------
CnctNote DIALOG discardable 10, 10, 220, 160
STYLE  WS_OVERLAPPED | WS_VISIBLE | WS_CAPTION | WS_SYSMENU | 
       DS_CENTER | DS_MODALFRAME
CAPTION &quot;CnctNote&quot;
CLASS &quot;CnctNote&quot;

BEGIN
    LISTBOX                  IDC_RPTLIST,   2,  10, 216, 140, 
                                       WS_TABSTOP | WS_VSCROLL
END
</pre>
</td></tr></table>

<p><TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="428"><H3>CnctNote.h</H3></A>
<P><pre>
//====================================================================
// Header file
//

// Written for the book Programming Windows CE

// Copyright (C) 1998 Douglas Boling
//====================================================================
// Returns number of elements
#define dim(x) (sizeof(x) / sizeof(x[0])) 
//-----------------------------------------------------------------------
// Generic defines and data types
//
struct decodeUINT {                            // Structure associates
    UINT Code;                                 // messages 
                                               // with a function.
    LRESULT (*Fxn)(HWND, UINT, WPARAM, LPARAM);
}; 
struct decodeCMD {                             // Structure associates
    UINT Code;                                 // menu IDs with a 
    LRESULT (*Fxn)(HWND, WORD, HWND, WORD);    // function.
};

//-----------------------------------------------------------------------
// Generic defines used by application

#define  ID_ICON             1   
#define  IDC_RPTLIST         10                // Control IDs

//-----------------------------------------------------------------------
// Function prototypes
//
int InitApp (HINSTANCE);
HWND InitInstance (HINSTANCE, LPSTR, int);
int TermInstance (HINSTANCE, int);
void Add2List (HWND hWnd, LPTSTR lpszFormat, ...);

// Window procedures
LRESULT CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM);

//********************************************************************
// MyDccSink
//
class MyDccSink : public IDccManSink {
public:
    MyDccSink (HWND hWnd, IDccMan *pDccMan);
    ~MyDccSink ();

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (THIS_ REFIID riid, LPVOID * ppvObj);
    // Note: No reference counting is actually maintained on this object.
    STDMETHODIMP_(ULONG) AddRef (THIS);
    STDMETHODIMP_(ULONG) Release (THIS);

    // These methods correspond to GW_LOG messages generated by the Win95
    // DccMan application. (On NT, the GW_LOG messages are simulated.)
    STDMETHODIMP OnLogIpAddr (THIS_ DWORD dwIpAddr);
    STDMETHODIMP OnLogTerminated (THIS);
    STDMETHODIMP OnLogActive (THIS);
    STDMETHODIMP OnLogInactive (THIS);
    STDMETHODIMP OnLogAnswered (THIS);
    STDMETHODIMP OnLogListen (THIS);
    STDMETHODIMP OnLogDisconnection (THIS);
    STDMETHODIMP OnLogError (THIS);

private:
    long m_lRef;
    HWND hWnd;
    IDccMan *m_pDccMan;
};
</pre>
</td></tr></table>

<p><TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="429"><H3>CnctNote.cpp</H3></A>
<P><pre>
//====================================================================
// CnctNote - A simple application for Windows CE

//

// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//====================================================================
#include &lt;windows.h&gt;                   // For all that Windows stuff
#include &lt;stdio.h&gt;
#include &lt;initguid.h&gt;
#include &lt;dccole.h&gt;
#include &quot;CnctNote.h&quot;                  // Program-specific stuff

//-----------------------------------------------------------------------
// Global data
//
const TCHAR szAppName[] = TEXT (&quot;CnctNote&quot;);
HINSTANCE hInst;                      // Program instance handle
BOOL fFirst = TRUE;

IDccMan *pDccMan;
MyDccSink *pMySink;                   // Notification interface
DWORD g_Context;                      // Context variable

//====================================================================
// Program entry point
//
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPSTR lpCmdLine, int nCmdShow) {
    MSG msg;
    int rc = 0;
    HWND hwndMain;
    // Initialize application.
    rc = InitApp (hInstance);
    if (rc) return rc;

    // Initialize this instance.
    hwndMain = InitInstance (hInstance, lpCmdLine, nCmdShow);
    if (hwndMain == 0)
        return TermInstance (hInstance, 0x10);

    // Application message loop
    while (GetMessage (&amp;msg, NULL, 0, 0)) {
        if ((hwndMain == 0) || !IsDialogMessage (hwndMain, &amp;msg)) {
            TranslateMessage (&amp;msg);
            DispatchMessage (&amp;msg);
        }
    }
    // Instance cleanup
    return TermInstance (hInstance, msg.wParam);
}
//-----------------------------------------------------------------------
// InitApp - Application initialization
//
int InitApp (HINSTANCE hInstance) {
    WNDCLASS wc;

    // Register application main window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = MainWndProc;             // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = DLGWINDOWEXTRA;           // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = szAppName;             // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;
    return 0;
}
//-----------------------------------------------------------------------
// InitInstance - Instance initialization
//
HWND InitInstance (HINSTANCE hInstance, LPSTR lpCmdLine, int nCmdShow){
    HWND hWnd;
    HRESULT hr;
    INT rc;
    // Save program instance handle in global variable.
    hInst = hInstance;

    // Initialize COM.
    hr = CoInitialize(NULL);
    if (FAILED(hr)) {
        MessageBox (NULL, &quot;CoInitialize failed&quot;, szAppName, MB_OK);
        return 0;
    }
    // Create main window.
    hWnd = CreateDialog (hInst, szAppName, NULL, NULL);
    rc = GetLastError();

    // Return fail code if window not created.
    if (!IsWindow (hWnd)) return 0;

    // Standard show and update calls
    ShowWindow (hWnd, nCmdShow);
    UpdateWindow (hWnd);
    return hWnd;
}
//-----------------------------------------------------------------------
// TermInstance - Program cleanup
//
int TermInstance (HINSTANCE hInstance, int nDefRC) {

    // Release COM.
    CoUninitialize();

    return nDefRC;
}
//====================================================================
// MainWndProc - Callback function for application window
//
LRESULT CALLBACK MainWndProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                              LPARAM lParam) {
    switch (wMsg) {

    case WM_SIZE:
        if (fFirst) {
            HRESULT hr;
            IDccManSink *pdms;
            fFirst = FALSE;

            // Get a pointer to the IDccMan COM interface.
            hr = CoCreateInstance (CLSID_DccMan, NULL, CLSCTX_SERVER,
                                   IID_IDccMan, (LPVOID*)&amp;pDccMan);
            if (FAILED(hr)) {
                Add2List (hWnd, &quot;CoCreateInstance failed&quot;);
                break;
            }

            // Create new notification object.
            pMySink = new MyDccSink(hWnd, pDccMan);
            pMySink-&gt;QueryInterface (IID_IDccManSink, (void **)&amp;pdms);
            // Ask to be advised of connect state changes.
            pDccMan-&gt;Advise (pdms, &amp;g_Context);
        }
        break;
    case WM_COMMAND:

        switch (LOWORD (wParam)) {
        case IDOK:
        case IDCANCEL:
            SendMessage (hWnd, WM_CLOSE, 0, 0);
            break;
        }
        break;
    case WM_DESTROY:
        // Stop receiving notifications.
        pDccMan-&gt;Unadvise (g_Context);

        // Release the DccMan object.
        pDccMan-&gt;Release();

        PostQuitMessage (0);
        break;
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//-----------------------------------------------------------------------
// Add2List - Add string to the report list box.
//
void Add2List (HWND hWnd, LPTSTR lpszFormat, ...) {
    int nBuf, i;
    TCHAR szBuffer[512];

    va_list args;
    va_start(args, lpszFormat);

    nBuf = vsprintf(szBuffer, lpszFormat, args);

    i = SendDlgItemMessage (hWnd, IDC_RPTLIST, LB_ADDSTRING, 0,
                            (LPARAM)(LPCTSTR)szBuffer);
    if (i != LB_ERR)
        SendDlgItemMessage (hWnd, IDC_RPTLIST, LB_SETTOPINDEX, i,
                            (LPARAM)(LPCTSTR)szBuffer);
    va_end(args);
}
//********************************************************************
// Constructor
MyDccSink::MyDccSink (HWND hwndMain, IDccMan *pDccMan) {

    m_pDccMan = pDccMan;
    hWnd = hwndMain;

    m_pDccMan-&gt;AddRef();
    return;
}
//-----------------------------------------------------------------------
// Destructor
MyDccSink::~MyDccSink () {

    m_pDccMan-&gt;Release();
    return;
}
//-----------------------------------------------------------------------
// AddRef - Increment object ref count.
STDMETHODIMP_(ULONG) MyDccSink::AddRef (THIS) {

    return (ULONG)InterlockedIncrement (&amp;m_lRef);
}
//-----------------------------------------------------------------------
// Release - Decrement object ref count.
STDMETHODIMP_(ULONG) MyDccSink::Release (THIS) {
    ULONG cnt;
    cnt = (ULONG)InterlockedDecrement (&amp;m_lRef);
    if (cnt == 0) {
        delete this;
        return 0;
    }
    return cnt;
}
//-----------------------------------------------------------------------
// QueryInterface _ Return a pointer to interface.
STDMETHODIMP MyDccSink::QueryInterface (REFIID riid, LPVOID * ppvObj) {

    if (IID_IUnknown==riid || IID_IDccManSink==riid)
        *ppvObj = (IDccManSink*)this;
    else {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NO_ERROR;
}
//-----------------------------------------------------------------------
//
STDMETHODIMP MyDccSink::OnLogIpAddr (DWORD dwIpAddr) {
    Add2List (hWnd, TEXT (&quot;OnLogIpAddr %08x&quot;), dwIpAddr);
    return NO_ERROR;
}
//-----------------------------------------------------------------------
//
STDMETHODIMP MyDccSink::OnLogTerminated () {
    Add2List (hWnd, TEXT (&quot;OnLogTerminated &quot;));
    return NO_ERROR;
}
//-----------------------------------------------------------------------
//
STDMETHODIMP MyDccSink::OnLogActive () {
    Add2List (hWnd, TEXT (&quot;OnLogActive &quot;));
    return NO_ERROR;
}
//-----------------------------------------------------------------------
//
STDMETHODIMP MyDccSink::OnLogInactive () {
    Add2List (hWnd, TEXT (&quot;OnLogInactive &quot;));
    return NO_ERROR;
}
//-----------------------------------------------------------------------
//
STDMETHODIMP MyDccSink::OnLogAnswered () {
    Add2List (hWnd, TEXT (&quot;OnLogAnswered&quot;));
    return NO_ERROR;
}
//-----------------------------------------------------------------------
//
STDMETHODIMP MyDccSink::OnLogListen () {
    Add2List (hWnd, TEXT (&quot;OnLogListen &quot;));
    return NO_ERROR;
}
//-----------------------------------------------------------------------
//
STDMETHODIMP MyDccSink::OnLogDisconnection () {
    Add2List (hWnd, TEXT (&quot;OnLogDisconnection &quot;));
    return NO_ERROR;
}
//-----------------------------------------------------------------------
//
STDMETHODIMP MyDccSink::OnLogError () {
    Add2List (hWnd, TEXT (&quot;OnLogError &quot;));
    return NO_ERROR;
}
</pre>
</td></tr></table>

<P>The meat of CnctNote is in the WM_SIZE handler of the window procedure. Here, <I>CoCreateInstance</I> is called to get a pointer to the <I>IDccMan</I> interface. If this is successful, an object is created that implements an <I>IDccManSink</I> interface. The <I>Advise</I> method is then called to register the <I>IDccManSink</I> object. The sole job of the methods in <I>IDccManSink</I> is to report when they're called by posting a message in the list box, which is the only control on the dialog box.

<A NAME="430"><H2>Connection Detection on the Windows CE Side</H2></A>

<P>As you know, this chapter describes the PC-side applications that work with remote Windows CE devices. However, while reading the previous section, you probably wondered how a Windows CE application can know when a connection is made between the Windows CE device and a PC.

<P>Windows CE supports a unique API known as the Notification API. While I'll describe this API fully in the next chapter, a quick mention of one function, <I>CeRunAppAtEvent</I>, which provides Windows CE applications the ability to be notified when a connection is made, wouldn't hurt. <I>CeRunAppAtEvent</I> registers an application with the system so that it can be launched when a specified event occurs in the system. Such events include when the system time is changed, when a system is restored from a backup, and yes, when a connection is made to a PC. This function is prototyped as

<p><pre>
BOOL CeRunAppAtEvent (TCHAR *pwszAppName, LONG lWhichEvent);
</PRE>

<P>The first parameter is the name of the application to be launched when the event occurs. The second parameter is a set of bit flags that indicate which events you want to monitor. A number of flags are related to various events in the system. For the moment, I'll mention two: APP_RUN_AT_RS232_DETECT and APP_RUN_AFTER_SYNC. These flags launch the specified program after a connection is detected and after the synchronization process has completed.

<P>When the application is launched by the notification system, a predefined string is passed to the application on the command line. For an application launched due to an RS232 detection, the command line string is <I>AppRunAtRs232Detect</I>. For an application launched at the end of synchronization, the command line is <I>AppRunAfterSync</I>. For a complete description of this function and the other notification functions, refer to <A HREF="ch12a.htm">Chapter 12</a>.

</BODY>
</HTML>




