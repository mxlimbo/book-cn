<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>Writing Cross-Platform Windows CE Applications</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="523"><H1>Writing Cross-Platform Windows CE Applications</H1></A>

<P>Over the years, Windows programmers have had to deal concurrently with different versions of the operating system. Part of the solution to the problem this situation posed was to call <I>GetVersion</I> or <I>GetVersionEx</I> and to act differently depending on the version of the operating system you were working with. You can't do that under Windows CE. Because of the flexible nature of Windows CE, two builds of the same version of Windows CE can have different APIs. The question remains, though, how do you support multiple platforms with a common code base? How does the operating system version relate to the different platforms?

<A NAME="524"><H2>Platforms and Operating System Versions</H2></A>

<P>To understand how the different platforms relate to the different versions of Windows CE, it helps to know how the Windows CE development team is organized within Microsoft. Windows CE is supported by a core OS group within Microsoft. This team is responsible for developing the operating system, including the file system and the various communication stacks.

<P>Coordinating efforts with the OS team are the various platform teams, working on the Handheld/PC, Palm-size PC, Auto PC, and Handheld/PC Pro as well as many other platforms yet to be announced. Each team is responsible for defining a suggested hardware platform, defining applications that will be bundled with the platform, and deciding which version of the operating system the platform will use. Because the OS team works continually to enhance Windows CE, planning new versions over time, each platform team generally looks to see what version of Windows CE will be ready when that team's platform ships.

<P>The individual platform teams also develop the shells for their platforms. Because each team develops its own shell, many new functions or platform-specific functions first appear as part of the shell of a specific platform. Then if the newly introduced functions have a more general applicability, they're moved to the base operating system in a later version. You can see this process in both the Notification API and the SIP API. Both these sets of functions started in their specific platform group and have now been moved out of the shell and are in the base operating system.

<P>Following is a list of the different platforms that have been released up to this point and the version of Windows CE that those platforms use.

<p><table cellpadding=5 width="95%">
<tr><td valign="top"><b>Platform</b></td>
<td valign="top"><b>Windows CE version</b></td></tr>

<tr><td valign="top">Original H/PC</td>
<td valign="top">1.00</td></tr>

<tr><td valign="top">Japanese release of H/PC</td>
<td valign="top">1.01</td></tr>

<tr><td valign="top">H/PC</td>
<td valign="top">2.00</td></tr>

<tr><td valign="top">Original Palm-size PC</td>
<td valign="top">2.01</td></tr>

<tr><td valign="top">Windows CE 2.1 for embedded systems</td>
<td valign="top">2.10</td></tr>

<tr><td valign="top">Handheld PC Pro</td>
<td valign="top">2.11</td></tr>
</table>

<P>It's not presently difficult to remember what platform is associated with which version of Windows CE, but this task will get more difficult as more platforms are added to the list.

<P>You can choose from a number of ways to deal with the problem of different platforms and different versions of Windows CE. Let's look at a few.

<A NAME="525"><H2>Compile-Time Versioning</H2></A>

<P>The version problem can be tackled in a couple of places in the development process of an application. At compile time, you can use the preprocessor definition _WIN32_WCE to determine the version of the operating system you're currently building for. By enclosing code in an <I>#if</I> preprocessor bracket, you can cause code to be compiled for specific versions of Windows CE.

<P>Following is an example of a routine that's tuned both for the original Palm-size PC and for other platforms equipped with a SIP that are based on Windows CE 2.1.

<p><pre>
//
// Get SIP rectangle.
//
void MyGetSipRect (RECT *prect) {

#if _WIN32_WCE == 201

    SIPINFO si;

    memset (&amp;si, 0, sizeof (si));
    si.cbSize = sizeof (SIPINFO);
    // On original Palm-size PC, use old PPC Shell function.
    SHSipInfo (SPI_GETSIPINFO, 0, &amp;si, 0);
    *prect = si.rcSipRect;

#elif _WIN32_WCE &gt;= 210
    SIPINFO si;

    si.cbSize = sizeof (SIPINFO);
    // On Windows CE 2.1 or later, use new function.
    SipGetInfo (&amp;si);
    *prect = si.rcSipRect;

#else
    // Else, there isn't support for this function.
#error No SIP support.
#endif
    return;
}
</PRE>

<P>A virtue of this code is that linker links the appropriate function for the appropriate platform. Without this sort of compile-time code, you couldn't simply put a run-time <I>if</I> statement around the call to <I>SHSipInfo</I> because the program would never load on anything but a Palm-size PC. The loader wouldn't be able to find the exported function <I>SHSipInfo</I> in Coredll.dll because it's present only in Palm-size PC versions of Windows CE.

<P>Builds for the Palm-size PC have an additional define set named <I>Palm</I>. So you can bracket Palm-size PC code in the following way:

<p><pre>
#ifdef Palm
    // Insert Palm-size PC code here.
#endif
</PRE>

<P>The reason I didn't use the <I>Palm</I> define in the previous code is that I wanted to target specifically the original Palm-size PC, which used Windows CE version 2.01. Otherwise, if I'd used the <I>Palm</I> define, that code would be included even when I was compiling for newer versions of the Palm-size PC, which will use a newer version of Windows CE. The problem with using conditional compilation is that while you still have a common source file, the resulting executable will be different for each platform.


<A NAME="526"><H2>Explicit Linking</H2></A>

<P>You can tackle the version problem other ways. Sometimes one platform requires that you call a function different from one you need for another platform you're working with but you want the same executable file for both platforms. A way to accomplish this is to explicitly link to a DLL using <I>LoadLibrary</I>, <I>GetProcAddress</I>, and <I>FreeLibrary</I>. You can then call the function as if it had been implicitly linked by the loader.

<P><I>LoadLibrary</I> is prototyped as

<p><pre>
HINSTANCE LoadLibrary (LPCTSTR lpLibFileName);
</PRE>

<P>The only parameter is the filename of the DLL. The system searches for DLLs in the following order:

<OL>

<P><LI>The image of the DLL that has already been loaded in memory.
<P><LI>The statically linked DLL in ROM for a ROM-based executable.
<P><LI>The file in the path specified in <I>lpLibFileName</I> parameter.
<P><LI>The directory of the executable loading the library. (This is supported only for Windows CE 2.1 and later.)
<P><LI>The Windows directory.
<P><LI>The root directory.
<P><LI>The image of the DLL in ROM.
</OL>

<P>Notice in the search sequence above that if the DLL has already been loaded into memory, the system uses that copy of the DLL even if your pathname specifies a different file from the DLL originally loaded. Another peculiarity of <I>LoadLibrary</I> is that it ignores the extension of the DLL when comparing the library name to what's already in memory. For example, if SIMPLE.dll is already loaded in memory and you attempt to load the control panel applet SIMPLE.cpl, which is under the covers simply a DLL with a different extension, the system won't load SIMPLE.cpl. Instead the system returns the handle to the previously loaded SIMPLE.dll.

<P><I>LoadLibrary</I> returns either an instance handle to the DLL that's now loaded or 0 if for some reason the function couldn't load the library.

<P>Once you have the DLL loaded, you get a pointer to a function exported by that DLL by using <I>GetProcAddress</I>, which is prototyped as

<p><pre>
FARPROC GetProcAddress (HMODULE hModule, LPCWSTR lpProcName);
</PRE>

<P>The two parameters are the handle of the module and the name of the function you want to get a pointer to. The function returns a pointer to the function or 0 if the function isn't found. Once you have a pointer to a function, you can simply call the function as if the loader had implicitly linked it.

<P>When you are finished with the functions from a particular library, you need to call <I>FreeLibrary</I>, prototyped as


<p><pre>
BOOL FreeLibrary (HMODULE hLibModule);
</PRE>

<P><I>FreeLibrary</I> decrements the use count on the DLL. If the use count drops to 0, the library is removed from memory.

<P>The following routine solves that same problem I presented earlier (how to retrieve the SIP rectangle without using compile-time switches). The routine explicitly loads the two possible functions, calls the one found, and frees the libraries loaded. A more efficient application would load the libraries and query the function pointers when the program was initialized instead of performing this task each time the functions were needed.


<p><pre>
// Type definitions for the function pointers.
typedef HRESULT (CALLBACK* GETSIPINFOFUNC)(SIPINFO *);
typedef HRESULT (CALLBACK* SHSIPINFOFUNC)(INT, INT, PVOID, INT);

int MyGetSipRect1 (RECT *prect) {
    HINSTANCE hCoreDll, hAGYShell;

    GETSIPINFOFUNC lpfnGetSipInfo;
    SHSIPINFOFUNC lpfnSHSipInfo;
    SIPINFO si;
    INT rc = 0;

    //Load the DLL.
    hCoreDll = LoadLibrary(TEXT(&quot;coredll.dll&quot;));
    // If we can't load Coredll, something is really strange!
    if (!hCoreDll) 
        return -2;

    // Prepare structure for call.
    memset (&amp;si, 0, sizeof (si));
    si.cbSize = sizeof (SIPINFO);

    // Attempt to get a pointer to GetSipInfo.
    lpfnGetSipInfo = (GETSIPINFOFUNC)GetProcAddress(hCoreDll, 
                                                    TEXT(&quot;GetSipInfo&quot;));
    if (lpfnGetSipInfo) {
        // Call GetSipInfo.
        (*lpfnGetSipInfo)(&amp;si);

    } else {
        // This DLL exports the Palm-size PC shell APIs.
        hAGYShell= LoadLibrary(TEXT(&quot;aygshell.dll&quot;));
        if (hAGYShell) {

            // Attempt to get a pointer to SHSipInfo.
            lpfnSHSipInfo = (SHSIPINFOFUNC)GetProcAddress(
                                          hAGYShell, TEXT(&quot;SHSipInfo&quot;));
            if (lpfnSHSipInfo) {
                (*lpfnSHSipInfo)(SPI_GETSIPINFO, 0, &amp;si, 0);
            } else
                rc = -1;
            FreeLibrary (hAGYShell);
        } else
            rc = -1;
    }
    // At this point, one of the two functions has been called.
    if (!rc)
        *prect = si.rcSipRect;

    // Free the library.
    FreeLibrary(hCoreDll);
    return rc;
}
</PRE>

<P>This routine can be run on any platform, but will work only with those that export one of the two get SIP information functions. On the other platforms, the routine simply returns an error code of -1.

<A NAME="527"><H2>Run-Time Version Checking</H2></A>

<P>When you're determining the version of the Windows CE operating system at run time, you use the same function as under other versions of Windows&#8212;<I>GetVersionEx</I>, which fills in a OSVERSIONINFO structure defined as

<p><pre>
typedef struct _OSVERSIONINFO{ 
    DWORD dwOSVersionInfoSize; 
    DWORD dwMajorVersion; 
    DWORD dwMinorVersion; 
    DWORD dwBuildNumber; 
    DWORD dwPlatformId; 

    TCHAR szCSDVersion[ 128 ]; 
} OSVERSIONINFO;
</PRE>

<P>Upon return from <I>GetVersionEx</I>, the major and minor version fields are filled with the Windows CE version. This means, of course, that you can't simply copy desktop Windows code that branches on classic version numbers like 3.1 or 4.0. The <I>dwPlatformId</I> field contains the constant VER_PLATFORM_WIN32_CE under Windows CE.

<P>Although it's possible to differentiate platforms by means of their unique Windows CE versions numbers, you shouldn't. For example, you can identify the current Palm-size PC by its unique Windows CE version, 2.01, but newer versions of the Palm-size PC will be using different versions of Windows CE. Instead, you should call <I>SystemParametersInfo</I> with the SPI_GETPLATFORMTYPE constant, as in

<p><pre>
TCHAR szPlat[256];
INT rc;

rc = SystemParametersInfo (SPI_GETPLATFORMTYPE, sizeof (szPlat), 
                           szPlat, 0);
if (lstrcmp (szPlat, TEXT (&quot;Jupiter&quot;) == 0) {

    // Running on an H/PC Pro
} else if (lstrcmp (szPlat, TEXT (&quot;Palm PC&quot;) == 0) {
    // Running on a Palm-size PC
} else if (lstrcmp (szPlat, TEXT (&quot;HPC&quot;) == 0) {
    // Running on an H/PC
}
</PRE>

<P>Aside from the differences in their shells, though, the platform differences aren't really that important. The base operating system is identical in all but some fringe cases.<SUP>5</SUP> The best strategy for writing cross-platform Windows CE software is to avoid differentiating among the platforms at all&#8212;or at least as little as possible.

<P>For the most part, discrepancies among the user interfaces for the different consumer Windows CE devices can be illustrated by the issue of screen dimension. The Palm-size PC's portrait-mode screen requires a completely different layout for most windows compared to the Handheld PC's landscape-mode screen. The Handheld PC Pro's screen is landscape, but it's at least double the height of an H/PC screen. So, instead of looking at the platform type to determine what screen layout to use, you'd do better to simply check the screen dimensions using <I>GetDeviceCaps</I>.

<P>This has been a brief tour of some of the system issues for Windows CE. The configurability of Windows CE makes it the chameleon of operating systems, changing its API and even its size, depending on the platform. Whatever the platform differences, though, remember that underneath the covers, all configurations of Windows CE share the same basic design. Keep this in mind as you look at the wide variety of platforms developed for Windows CE.

<P>The configurability of Windows CE makes it a powerful tool for the systems designer. Its Win32 API makes it familiar to thousands of programmers. But most of all, the Windows CE operating system is fun. Enjoy it.

<P><div class="sidebar"><blockquote><ol start=5>
<LI>For example, first generation Palm-size PCs don't support printing, so you wouldn't want to implicitly link to any printing APIs if you wanted an application that ran on both the H/PC 2 and the original Palm-size PC.
</ol></blockquote></div>

</BODY>
</HTML>




