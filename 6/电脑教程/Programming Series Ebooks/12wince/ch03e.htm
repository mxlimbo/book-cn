<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>Resources</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="93"><H1>Resources</H1></A>

<P>Resources are read-only data segments of an application or a DLL that are linked to the file after it has been compiled. The point of a resource is to give a developer a compiler-independent place for storing content data such as dialog boxes, strings, bitmaps, icons, and yes, menus. Since resources aren't compiled into a program, they can be changed without having to recompile the application.

<P>You create a resource by building an ASCII file&#8212;called a <I>resource script&#8212;</I> describing the resources. Your ASCII file has an extension of RC. You compile this file with a resource compiler, which is provided by every maker of Windows development tools, and then you link them into the compiled executable again using the linker. These days, these steps are masked by a heavy layer of visual tools, but the fundamentals remain the same. For example, Visual C++ 5.0 creates and maintains an ASCII resource (RC) file even though few programmers directly look at the resource file text any more.

<P>It's always a struggle for the author of a programming book to decide how to approach tools. Some lay out a very high level of instruction, talking about menu selections and describing dialog boxes for specific programming tools. Others show the reader how to build all the components of a program from the ground up, using ASCII files and command line compilers. Resources can be approached the same way: I could describe how to use the visual tools or how to create the ASCII files that are the basis for the resources. In this book, I stay primarily at the ASCII resource script level since the goal is to teach Windows CE programming, not how to use a particular set of tools. I'll show how to create and use the ASCII RC file for adding menus and the like, but later in the book in places where the resource file isn't relevant, I won't always include the RC file in the listings. The files are, of course, on the CD included with this book.

<A NAME="94"><H2>Resource Scripts</H2></A>

<P>Creating a resource script is as simple as using Notepad to create a text file. The language used is simple, with C-like tendencies. Comment lines are prefixed by a double slash (//) and files can be included using a <I>#include</I> statement.

<P>An example menu template would be the following:

<p><pre>
// 
// A menu template
//
ID_MENU MENU DISCARDABLE
BEGIN
    POPUP &quot;&amp;File&quot;
    BEGIN
        MENUITEM &quot;&amp;Open...&quot;,                    100
        MENUITEM &quot;&amp;Save...&quot;,                    101
        MENUITEM SEPARATOR
        MENUITEM &quot;E&amp;xit&quot;,                       120
    END
    POPUP &quot;&amp;Help&quot;
    BEGIN
        MENUITEM &quot;&amp;About&quot;,                      200
    END
END
</pre>

<P>The initial ID_MENU is the ID value for the resource. Alternatively, this ID value can be replaced by a string identifying the resource. The ID value method provides more compact code while using a string may provide more readable code when the application loads the resource in the source file. The next word, <I>MENU</I>, identifies the type of resource. The menu starts with <I>POPUP</I>, indicating that the menu item <I>File</I> is actually a pop-up (cascade) menu attached to the main menu. Because it's a menu within a menu, it too has <I>BEGIN</I> and <I>END</I> keywords surrounding the description of the File menu. The ampersand (&amp;) character tells Windows that the next character should be the key assignment for that menu item. The character following the ampersand is automatically underlined by Windows when the menu item is displayed, and if the user presses the Alt key along with the character, that menu item is selected. Each item in a menu is then specified by the <I>MENUITEM</I> keyword followed by the string used on the menu. The ellipsis following the <I>Open</I> and <I>Save</I> strings is a Windows UI custom indicating to the user that selecting that item displays a dialog box. The numbers following the <I>Open</I>, <I>Save</I>, <I>Exit</I>, and <I>About</I> menu items are the menu identifiers. These values identify the menu items in the WM_COMMAND message. It's good programming practice to replace these values with equates that are defined in a common include file so that they match the WM_COMMAND handler code.

<P>Figure 3-10 lists other resource types that you might find in a resource file. The <I>DISCARDABLE</I> keyword is optional and tells Windows that the resource can be discarded from memory if it's not in use. The remainder of the menu is couched in <I>BEGIN</I> and <I>END</I> keywords, although bracket characters { and } are recognized as well.

<P><B>Figure 3-10.</B> <I>The resource types allowed by the resource compiler.</I>

<P>
<TABLE cellpadding=5 width="95%">
<TR><th><i>Resource Type</i></Th><th><i>Explanation</i></th></TR>
<tr><td valign="top">MENU</td><td valign="top">Defines a menu</td></tr>
<tr><td valign="top">ACCELERATORS</td><td valign="top">Defines a keyboard accelerator table</td></tr>
<tr><td valign="top">DIALOG</td><td valign="top">Defines a dialog box template</td></tr>
<tr><td valign="top">BITMAP</td><td valign="top">Includes a bitmap file as a resource</td></tr>
<tr><td valign="top">ICON</td><td valign="top">Includes an icon file as a resource</td></tr>
<tr><td valign="top">FONT</td><td valign="top">Includes a font file as a resource</td></tr>
<tr><td valign="top">RCDATA</td><td valign="top">Defines application-defined binary data block</td></tr>
<tr><td valign="top">STRINGTABLE</td><td valign="top">Defines a list of strings</td></tr>
<tr><td valign="top">VERSIONINFO</td><td valign="top">Includes file version information</td></tr>
</table>

<A NAME="95"><H2>Icons</H2></A>

<P>Now that we're working with resource files, it's a trivial matter to modify the icon that the Windows CE shell uses to display a program. Simply create an icon with your favorite icon editor and add to the resource file an icon statement such as

<p><pre>
ID_ICON ICON &quot;tictac2.ico&quot;
</pre>

<P>When Windows displays a program in Windows Explorer, it looks inside the EXE file for the first icon in the resource list and uses it to represent the program.

<P>Having that icon represent an application's window is somewhat more of a chore. Windows CE uses a small 16-by-16-pixel icon on the taskbar to represent windows on the desktop. Under other versions of Windows, the <I>RegisterClassEx</I> function could be used to associate a small icon with a window, but Windows CE doesn't support this function. Instead, the icon must be explicitly loaded and assigned to the window. The following code fragment assigns a small icon to a window.

<p><pre>
    hIcon = (HICON) SendMessage (hWnd, WM_GETICON, FALSE, 0);
    if (hIcon == 0) {
        hIcon = LoadImage (hInst, MAKEINTRESOURCE (ID_ICON1), IMAGE_ICON,
                           16, 16, 0);
        SendMessage (hWnd, WM_SETICON, FALSE, (LPARAM)hIcon);
    }
</pre>	
	
<P>The first <I>SendMessage</I> call gets the currently assigned icon for the window. The FALSE value in <I>wParam</I> indicates that we're querying the small icon for the window. If this returns 0, indicating that no icon has been assigned, a call to <I>LoadImage</I> is made to load the icon from the application resources. The <I>LoadImage </I>function can take either a text string or an ID value to identify the resource being loaded. In this case, the MAKEINTRESOURCE macro is used to label an ID value to the function. The icon being loaded must be a 16-by-16 icon because under Windows CE, <I>LoadImage</I> won't resize the icon to fit the requested size. Also under Windows CE, <I>LoadImage</I> is limited to loading icons and bitmaps from resources. Windows CE provides the function <I>ShLoadDIBitmap</I> to load a bitmap from a file.

<P>Unlike other versions of Windows, Windows CE stores window icons on a per class basis. This means if two windows in an application have the same class, they share the same window icon. A subtle caveat here&#8212;window classes are specific to a particular instance of an application. So, if you have two different instances of the application FOOBAR, they each have different window classes, so they may have different window icons even though they were registered with the same class information. If the second instance of FOOBAR had two windows of the same class open, those two windows would share the same icon, independent of the window icon in the first instance of FOOBAR.

<A NAME="96"><H2>Accelerators</H2></A>

<P>Another resource that can be loaded is a keyboard accelerator table. This table is used by Windows to enable developers to designate shortcut keys for specific menus or controls in your application. Specifically, accelerators provide a direct method for a key combination to result in a WM_COMMAND message being sent to a window. These accelerators are different from the Alt-F key combination that, for example, can be used to access a File menu. File menu key combinations are handled automatically as long as the File menu item string was defined with the <I>&amp;</I> character, as in <I>&amp;File</I>. The keyboard accelerators are independent of menus or any other controls, although their assignments typically mimic menu operations, as in using Ctrl-O to open a file.

<P>Below is a short resource script that defines a couple of accelerator keys.

<p><pre>
ID_ACCEL ACCELERATORS DISCARDABLE
BEGIN
    &quot;N&quot;, IDM_NEWGAME, VIRTKEY, CONTROL
    &quot;Z&quot;, IDM_UNDO,  VIRTKEY, CONTROL
END
</pre>

<P>As with the menu resource, the structure starts with an ID value. The ID value is followed by the type of resource and, again optionally, the discardable keyword. The entries in the table consist of the letter identifying the key, followed by the ID value of the command, <I>VIRTKEY</I>, which indicates that the letter is actually a virtual key value, followed finally by the <I>CONTROL</I> keyword, indicating that the control shift must be pressed with the key.

<P>Simply having the accelerator table in the resource doesn't accomplish much. The application must load the accelerator table and, for each message it pulls from the message queue, see whether an accelerator has been entered. Fortunately, this is accomplished with a few simple modifications to the main message loop of a program. Here's a modified main message loop that handles keyboard accelerators.

<p><pre>
// Load accelerator table.
hAccel = LoadAccelerators (hInst, MAKEINTRESOURCE (ID_ACCEL));

// Application message loop
while (GetMessage (&amp;msg, NULL, 0, 0)) {
    // Translate accelerators
    if (!TranslateAccelerator (hwndMain, hAccel, &amp;msg)) {
        TranslateMessage (&amp;msg);
        DispatchMessage (&amp;msg);
    }
}
</pre>

<P>The first difference in this main message loop is the loading of the accelerator table using the <I>LoadAccelerators</I> function. Then after each message is pulled from the message queue, a call is made to <I>TranslateAccelerator</I>. If this function translates the message, it returns TRUE, which skips the standard <I>TranslateMessage </I>and <I>DispatchMessage</I> loop body. If no translation was performed, the loop body executes normally.

<A NAME="97"><H2>Bitmaps</H2></A>

<P>Bitmaps can also be stored as resources. Windows CE works with bitmap resources somewhat differently from other versions of Windows. With Windows CE, the call

<p><pre>
HBITMAP LoadBitmap(HINSTANCE hInstance, LPCTSTR lpBitmapName);
</pre>

<P>loads a read-only version of the bitmap. This means that after the bitmap is selected into a device context, the image can't be modified by other drawing actions in that DC. To load a read/write version of a bitmap resource, use the <I>LoadImage</I> function.

<A NAME="98"><H2>Strings</H2></A>

<P>String resources are a good method for reducing the memory footprint of an application while keeping language-specific information out of the code to be compiled. An application can call

<p><pre>
int LoadString(HINSTANCE hInstance, UINT uID, LPTSTR lpBuffer,
               int nBufferMax);
</pre>
			  
<P>to load a string from a resource. The ID of the string resource is <I>uID,</I> the <I>lpBuffer</I> parameter points to a buffer to receive the string, and <I>nBufferMax</I> is the size of the buffer. To conserve memory, <I>LoadString</I> has a new feature under Windows CE. If <I>lpBuffer</I> is NULL, <I>LoadString</I> returns a read-only pointer to the string as the return value. Simply cast the return value as a pointer to a constant Unicode string (<I>LPCTSTR</I>) and use the string as needed. The length of the string, not including any null terminator, will be located in the word immediately preceding the start of the string.

<P>While I will be covering memory management and strategies for memory conservation in <A HREF="ch06a.htm">Chapter 6</a>, one quick note here. It's not a good idea to load a number of strings from a resource into memory. This just uses memory both in the resource and in RAM. If you need a number of strings at the same time, it might be a better strategy to use the new feature of <I>LoadString </I>to return a pointer directly to the resource itself. As an alternative, you can have the strings in a read-only segment compiled with the program. You lose the advantage of a separate string table, but you reduce your memory footprint.

<A NAME="99"><H2>The TicTac2 Example Program</H2></A>

<P>The final program in this chapter encompasses all of the information presented up to this point as well as a few new items. The TicTac2 program is an extension of TicTac1; the additions are a menu, a window icon, and keyboard accelerators. The TicTac2 window, complete with menu, is shown in Figure 3-11, while the source is shown in Figure 3-12.

<P><A HREF="javascript:fullSize('f03rg11x.htm')"> <img src="f03rg11.jpg" width=404 height=203 border="0" ALT="Click to view at full size."></a>
<P><!-- caption --><B>Figure 3-11.</B> <I>The TicTac2 window wInsertDelete (Many Windows CE keyboards use Shift-Backspace for this function.)</I><!-- /caption -->

<P><B>Figure 3-12.</B> <I>The Tictac2 program.</I>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="100"><H3>TicTac2.rc</H3></A>
<p><pre>
//======================================================================
// TicTac2 - Resource file
//

// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//
//======================================================================

#include &quot;tictac2.h&quot;

//----------------------------------------------------------------------
//
// Icon
//
ID_ICON ICON &quot;tictac2.ico&quot;

//----------------------------------------------------------------------
//
// Menu
//
ID_MENU MENU DISCARDABLE
BEGIN
    POPUP &quot;&amp;File&quot;
    BEGIN
        MENUITEM &quot;&amp;New game\tCtrl-N&quot;,           IDM_NEWGAME
        MENUITEM &quot;&amp;Undo last move\tCtrl-Z&quot;,     IDM_UNDO
        MENUITEM SEPARATOR
        MENUITEM &quot;E&amp;xit&quot;,                       IDM_EXIT
    END
END
//----------------------------------------------------------------------
//
// Accelerator table
//
ID_ACCEL ACCELERATORS DISCARDABLE 
BEGIN
    &quot;N&quot;, IDM_NEWGAME, VIRTKEY, CONTROL
    &quot;Z&quot;, IDM_UNDO,  VIRTKEY, CONTROL
END
//----------------------------------------------------------------------
//
// String table
//
STRINGTABLE DISCARDABLE 
BEGIN
    IDS_XTURN, &quot; Xs turn&quot;
    IDS_OTURN, &quot; Os turn&quot;
END
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="101"><H3>TicTac2.h</H3></A>
<p><pre>
//======================================================================
// Header file

//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//
//======================================================================
// Returns number of elements
#define dim(x) (sizeof(x) / sizeof(x[0]))

//----------------------------------------------------------------------
// Generic defines and data types
//
struct decodeUINT {                             // Structure associates
    UINT Code;                                  // messages 
                                                // with a function. 
    LRESULT (*Fxn)(HWND, UINT, WPARAM, LPARAM);
}; 
struct decodeCMD {                              // Structure associates
    UINT Code;                                  // menu IDs with a 
    LRESULT (*Fxn)(HWND, WORD, HWND, WORD);     // function.
};

//----------------------------------------------------------------------
// Generic defines used by application
#define  IDC_CMDBAR 1                           // Command bar ID

#define  ID_ICON           10                   // Icon resource ID
#define  ID_MENU           11                   // Main menu resource ID
#define  ID_ACCEL          12                   // Main menu resource ID

#define  IDM_NEWGAME       100                  // Menu item ID
#define  IDM_UNDO          101                  // Menu item ID
#define  IDM_EXIT          102                  // Menu item ID

#define  IDS_XTURN         201                  // String ID
#define  IDS_OTURN         202                  // String ID

//----------------------------------------------------------------------
// Function prototypes
//
int InitApp (HINSTANCE);
HWND InitInstance (HINSTANCE, LPWSTR, int);
int TermInstance (HINSTANCE, int);

// Window procedures
LRESULT CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM);

// Message handlers
LRESULT DoCreateMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoSizeMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoPaintMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoInitMenuPopMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoCommandMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoLButtonUpMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDestroyMain (HWND, UINT, WPARAM, LPARAM);

// Command functions
LPARAM DoMainCommandNewGame (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandUndo (HWND, WORD, HWND, WORD);
LPARAM DoMainCommandExit (HWND, WORD, HWND, WORD);

// Game functon prototypes
void ResetGame (void);
void DrawXO (HDC hdc, HPEN hPen, RECT *prect, INT nCell, INT nType);
void DrawBoard (HDC hdc, RECT *prect);
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="102"><H3>TicTac2.c</H3></A>
<p><pre>
//======================================================================

// TicTac2 - Simple tic-tac-toe game with menus
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;commctrl.h&gt;                // Command bar includes
#include &quot;tictac2.h&quot;                 // Program-specific stuff

//----------------------------------------------------------------------
// Global data
//
const TCHAR szAppName[] = TEXT (&quot;TicTac2&quot;);
HINSTANCE hInst;                     // Program instance handle

// State data for game
RECT rectBoard = {0, 0, 0, 0};       // Used to place game board.
RECT rectPrompt;                     // Used to place prompt.
BYTE bBoard[9];                      // Keeps track of Xs and Os.
BYTE bTurn;                          // Keeps track of the turn.
char bLastMove;                      // Last cell changed

// Message dispatch table for MainWindowProc
const struct decodeUINT MainMessages[] = {
    WM_CREATE, DoCreateMain,
    WM_SIZE, DoSizeMain,
    WM_PAINT, DoPaintMain,
    WM_INITMENUPOPUP, DoInitMenuPopMain,
    WM_COMMAND, DoCommandMain,
    WM_LBUTTONUP, DoLButtonUpMain,
    WM_DESTROY, DoDestroyMain,
};

// Command Message dispatch for MainWindowProc
const struct decodeCMD MainCommandItems[] = {
    IDM_NEWGAME, DoMainCommandNewGame,
    IDM_UNDO, DoMainCommandUndo,
    IDM_EXIT, DoMainCommandExit,
};

//======================================================================
//
// Program entry point
//
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPWSTR lpCmdLine, int nCmdShow) {
    MSG msg;
    int rc = 0;
    HWND hwndMain;
    HACCEL hAccel;

    // Initialize application.
    rc = InitApp (hInstance);
    if (rc) return rc;

    // Initialize this instance.
    hwndMain = InitInstance (hInstance, lpCmdLine, nCmdShow);
    if (hwndMain == 0)
        return 0x10;

    // Load accelerator table.
    hAccel = LoadAccelerators (hInst, MAKEINTRESOURCE (ID_ACCEL));

    // Application message loop
    while (GetMessage (&amp;msg, NULL, 0, 0)) {
        // Translate accelerators 
        if (!TranslateAccelerator (hwndMain, hAccel, &amp;msg)) {
            TranslateMessage (&amp;msg);
            DispatchMessage (&amp;msg);
        }
    }
    // Instance cleanup
    return TermInstance (hInstance, msg.wParam);
}
//----------------------------------------------------------------------
// InitApp - Application initialization
//
int InitApp (HINSTANCE hInstance) {
    WNDCLASS wc;

    // Register application main window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = MainWndProc;             // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = szAppName;             // Window class name

    if (RegisterClass(&amp;wc) == 0) return 1;

    return 0;
}
//----------------------------------------------------------------------
// InitInstance - Instance initialization
//
HWND InitInstance (HINSTANCE hInstance, LPWSTR lpCmdLine, int nCmdShow) {
    HWND hWnd;

    // Save program instance handle in global variable.
    hInst = hInstance;

    // Create main window.
    hWnd = CreateWindow (szAppName,           // Window class
                         TEXT (&quot;TicTac2&quot;),    // Window title
                         WS_VISIBLE,          // Style flags
                         CW_USEDEFAULT,       // x position
                         CW_USEDEFAULT,       // y position
                         CW_USEDEFAULT,       // Initial width
                         CW_USEDEFAULT,       // Initial height
                         NULL,                // Parent                
                         NULL,                // Menu, must be null
                         hInstance,           // Application instance
                         NULL);               // Pointer to create 
                                              // parameters
    // Return fail code if window not created.
    if (!IsWindow (hWnd)) return 0;

    // Standard show and update calls
    ShowWindow (hWnd, nCmdShow);
    UpdateWindow (hWnd);
    return hWnd;
}
//----------------------------------------------------------------------
// TermInstance - Program cleanup
//
int TermInstance (HINSTANCE hInstance, int nDefRC) {

    return nDefRC;
}
//======================================================================
// Message handling procedures for MainWindow
//

//----------------------------------------------------------------------
// MainWndProc - Callback function for application window
//
LRESULT CALLBACK MainWndProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                              LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(MainMessages); i++) {
        if (wMsg == MainMessages[i].Code)
            return (*MainMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateMain - Process WM_CREATE message for window.
//
LRESULT DoCreateMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                      LPARAM lParam) {
    HWND hwndCB;
    HICON hIcon;

    // Create a command bar.
    hwndCB = CommandBar_Create (hInst, hWnd, IDC_CMDBAR);
    // Add the menu.
    CommandBar_InsertMenubar (hwndCB, hInst, ID_MENU, 0);
    // Add exit button to command bar. 
    CommandBar_AddAdornments (hwndCB, 0, 0);

    hIcon = (HICON) SendMessage (hWnd, WM_GETICON, 0, 0);
    if (hIcon == 0) {
        hIcon = LoadImage (hInst, MAKEINTRESOURCE (ID_ICON),
                           IMAGE_ICON, 16, 16, 0);
        SendMessage (hWnd, WM_SETICON, FALSE, (LPARAM)hIcon);
    }

    // Initialize game.
    ResetGame ();
    return 0;
}
//----------------------------------------------------------------------
// DoSizeMain - Process WM_SIZE message for window.
//
LRESULT DoSizeMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                    LPARAM lParam) {
    RECT rect;

    // Adjust the size of the client rect to take into account
    // the command bar height.
    GetClientRect (hWnd, &amp;rect);
    rect.top += CommandBar_Height (GetDlgItem (hWnd, IDC_CMDBAR));

    // Define the playing board rect.
    rectBoard = rect;
    rectPrompt = rect;
    // Layout depends on portrait or landscape screen.
    if (rect.right - rect.left &gt; rect.bottom - rect.top) {
        rectBoard.left += 20;
        rectBoard.top += 10;
        rectBoard.bottom -= 10;
        rectBoard.right = rectBoard.bottom - rectBoard.top + 10; 

        rectPrompt.left = rectBoard.right + 10;

    } else {
        rectBoard.left += 20;
        rectBoard.right -= 20;
        rectBoard.top += 10;
        rectBoard.bottom = rectBoard.right - rectBoard.left + 10;

        rectPrompt.top = rectBoard.bottom + 10;
    }
    return 0;
}
//----------------------------------------------------------------------
// DoPaintMain - Process WM_PAINT message for window.
//
LRESULT DoPaintMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                     LPARAM lParam) {
    PAINTSTRUCT ps;
    RECT rect;
    HFONT hFont, hOldFont;
    TCHAR szPrompt[32];
    HDC hdc;

    // Adjust the size of the client rect to take into account
    // the command bar height.
    GetClientRect (hWnd, &amp;rect);
    rect.top += CommandBar_Height (GetDlgItem (hWnd, IDC_CMDBAR));

    hdc = BeginPaint (hWnd, &amp;ps);

    // Draw the board.
    DrawBoard (hdc, &amp;rectBoard);

    // Write the prompt to the screen.
    hFont = GetStockObject (SYSTEM_FONT);
    hOldFont = SelectObject (hdc, hFont);

    if (bTurn == 0)
        LoadString (hInst, IDS_XTURN, szPrompt, sizeof (szPrompt));
    else
        LoadString (hInst, IDS_OTURN, szPrompt, sizeof (szPrompt));

    DrawText (hdc, szPrompt, -1, &amp;rectPrompt, 
              DT_CENTER | DT_VCENTER | DT_SINGLELINE);

    SelectObject (hdc, hOldFont);
    EndPaint (hWnd, &amp;ps);
    return 0;
}
//----------------------------------------------------------------------
// DoInitMenuPopMain - Process WM_INITMENUPOPUP message for window.
//
LRESULT DoInitMenuPopMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                           LPARAM lParam) {
    HMENU hMenu;

    hMenu = CommandBar_GetMenu (GetDlgItem (hWnd, IDC_CMDBAR), 0);

    if (bLastMove == -1) 
        EnableMenuItem (hMenu, IDM_UNDO, MF_BYCOMMAND | MF_GRAYED);
    else
        EnableMenuItem (hMenu, IDM_UNDO,  MF_BYCOMMAND | MF_ENABLED);
    return 0;
}
//----------------------------------------------------------------------
// DoCommandMain - Process WM_COMMAND message for window. 
// 
//
LRESULT DoCommandMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {
    WORD idItem, wNotifyCode;
    HWND hwndCtl;
    INT  i;

    // Parse the parameters.
    idItem = (WORD) LOWORD (wParam);
    wNotifyCode = (WORD) HIWORD(wParam);
    hwndCtl = (HWND) lParam;

    // Call routine to handle control message.
    for (i = 0; i &lt; dim(MainCommandItems); i++) {
        if (idItem == MainCommandItems[i].Code)
            return (*MainCommandItems[i].Fxn)(hWnd, idItem, hwndCtl, 
                                           wNotifyCode);
    }
    return 0;
}
//----------------------------------------------------------------------
// DoLButtonUpMain - Process WM_LBUTTONUP message for window.
//
LRESULT DoLButtonUpMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                         LPARAM lParam) {
    POINT pt;
    INT cx, cy, nCell = 0;

    pt.x = LOWORD (lParam);
    pt.y = HIWORD (lParam);

    // See if pen on board.  If so, determine which cell.
    if (PtInRect (&amp;rectBoard, pt)){
        // Normalize point to upper left corner of board.
        pt.x -= rectBoard.left;
        pt.y -= rectBoard.top;

        // Compute size of each cell.
        cx = (rectBoard.right - rectBoard.left)/3;
        cy = (rectBoard.bottom - rectBoard.top)/3;

        // Find column.
        nCell = (pt.x / cx); 

        // Find row.
        nCell += (pt.y / cy) * 3; 

        // If cell empty, fill it with mark.
        if (bBoard[nCell] == 0) {
            if (bTurn) {
                bBoard[nCell] = 2;
                bTurn = 0;
            } else {
                bBoard[nCell] = 1;
                bTurn = 1;
            }
            // Save the cell for the undo command.
            bLastMove = nCell;
            // Force the screen to be repainted.
            InvalidateRect (hWnd, NULL, FALSE);
        } else {
            // Inform the user of the filled cell.
            MessageBeep (0);
            return 0;
        }
    }
    return 0;
}
//----------------------------------------------------------------------
// DoDestroyMain - Process WM_DESTROY message for window.
//
LRESULT DoDestroyMain (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {
    PostQuitMessage (0);
    return 0;
}
//======================================================================
// Command handler routines
//
//----------------------------------------------------------------------
// DoMainCommandNewGame - Process New Game command.
//
LPARAM DoMainCommandNewGame (HWND hWnd, WORD idItem, HWND hwndCtl,
                             WORD wNotifyCode) {
    INT i, j = 0, rc;

    // Count the number of used spaces.
    for (i = 0; i &lt; 9; i++)
        if (bBoard[i])
            j++;
    // If not new game or complete game, ask user before clearing.
    if (j &amp;&amp; (j != 9)) {
        rc = MessageBox (hWnd,
                         TEXT (&quot;Are you sure you want to clear the board?&quot;),
                         TEXT (&quot;New Game&quot;), MB_YESNO | MB_ICONQUESTION);
        if (rc == IDNO)
            return 0;
    }
    ResetGame ();
    InvalidateRect (hWnd, NULL, TRUE);
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandUndo - Process Undo Last Move command.
//
LPARAM DoMainCommandUndo (HWND hWnd, WORD idItem, HWND hwndCtl,
                          WORD wNotifyCode) {

    if (bLastMove != -1) {
        bBoard[bLastMove] = 0;
        if (bTurn) {
            bTurn = 0;
        } else {
            bTurn = 1;
        }
        // Only one level of undo
        bLastMove = -1;
        InvalidateRect (hWnd, NULL, TRUE);
    }
    return 0;
}
//----------------------------------------------------------------------
// DoMainCommandExit - Process Program Exit command.
//
LPARAM DoMainCommandExit (HWND hWnd, WORD idItem, HWND hwndCtl, 
                          WORD wNotifyCode) {

    SendMessage (hWnd, WM_CLOSE, 0, 0);
    return 0;
}
//======================================================================
// Game-specific routines
//
//----------------------------------------------------------------------
// ResetGame - Initialize the structures for a game.
//
void ResetGame (void) {
    INT i;

    // Initialize the board.
    for (i = 0; i &lt; dim(bBoard); i++)
        bBoard[i] = 0;

    bTurn = 0;
    bLastMove = -1;
    return;
}
//----------------------------------------------------------------------
// DrawXO - Draw a single X or O in a square.
//
void DrawXO (HDC hdc, HPEN hPen, RECT *prect, INT nCell, INT nType) {
    POINT pt[2];
    INT cx, cy;
    RECT rect;

    cx = (prect-&gt;right - prect-&gt;left)/3;
    cy = (prect-&gt;bottom - prect-&gt;top)/3;

    // Compute the dimensions of the target cell.
    rect.left = (cx * (nCell % 3) + prect-&gt;left) + 10;
    rect.right = rect.left + cx - 20,
    rect.top = cy * (nCell / 3) + prect-&gt;top + 10,
    rect.bottom =  rect.top + cy - 20;

    // Draw an X?
    if (nType == 1) {
        pt[0].x = rect.left;
        pt[0].y = rect.top;
        pt[1].x = rect.right;
        pt[1].y = rect.bottom;
        Polyline (hdc, pt, 2);

        pt[0].x = rect.right;
        pt[1].x = rect.left;
        Polyline (hdc, pt, 2);
    // How about an O?
    } else if (nType == 2) {
        Ellipse (hdc, rect.left, rect.top, rect.right, rect.bottom);
    }
    return;
}
//----------------------------------------------------------------------
// DrawBoard - Draw the tic-tac-toe board.
//
void DrawBoard (HDC hdc, RECT *prect) {
    HPEN hPen, hOldPen;
    POINT pt[2];
    LOGPEN lp;
    INT i, cx, cy;

    // Create a nice thick pen.
    lp.lopnStyle = PS_SOLID;
    lp.lopnWidth.x = 5;
    lp.lopnWidth.y = 5;
    lp.lopnColor = RGB (0, 0, 0);
    hPen = CreatePenIndirect (&amp;lp);

    hOldPen = SelectObject (hdc, hPen);

    cx = (prect-&gt;right - prect-&gt;left)/3;
    cy = (prect-&gt;bottom - prect-&gt;top)/3;

    // Draw lines down.
    pt[0].x = cx + prect-&gt;left;
    pt[1].x = cx + prect-&gt;left;
    pt[0].y = prect-&gt;top;
    pt[1].y = prect-&gt;bottom;
    Polyline (hdc, pt, 2);

    pt[0].x += cx;
    pt[1].x += cx;
    Polyline (hdc, pt, 2);

    // Draw lines across.
    pt[0].x = prect-&gt;left;
    pt[1].x = prect-&gt;right;
    pt[0].y = cy + prect-&gt;top;
    pt[1].y = cy + prect-&gt;top;
    Polyline (hdc, pt, 2);

    pt[0].y += cy;
    pt[1].y += cy;
    Polyline (hdc, pt, 2);

    // Fill in Xs and Os.
    for (i = 0; i &lt; dim (bBoard); i++)
        DrawXO (hdc, hPen, &amp;rectBoard, i, bBoard[i]);
<P>
<P>    SelectObject (hdc, hOldPen);
    DeleteObject (hPen);
    return;
}
</pre>
</td></tr></table>

<P>The biggest change in TicTac2 is the addition of a WM_COMMAND handler in the form of the routine <I>OnCommandMain</I>. Because a program might end up handling a large number of different menu items and other controls, I extend the table-lookup design of the window procedure to another table lookup for command IDs from menus and accelerators. For TicTac2, I use three command handlers, one for each of the menu items. This results in another table of IDs and procedure pointers that associates menu IDs with handler procedures. Again, this way of using a table lookup instead of the standard switch statement isn't necessary or specific to Windows CE. It's simply my programming style.

<P>The first menu handler, <I>OnCommandNewGame</I>, simply calls the reset game routine to clear the game structures. The routine itself returns 0, which is the default value for a WM_COMMAND handler.

<P>The <I>OnCommandUndo</I> command handler is interesting in that it isn't always enabled. TicTac2 handles an additional message WM_INITMENUPOPUP, which is sent to a window immediately before the window menu is displayed. This gives the window a chance to initialize any of the menu items. In this case, the routine <I>OnInitMenuPopMain</I> looks to see whether the <I>bLastMove</I> field contains a valid cell value (0 through 8). If not, the routine disables the Undo menu item using <I>EnableMenuItem</I>. This action also disables the keyboard accelerator for that menu item as well.

<P>The final command handler, <I>OnCommandExit</I>, sends a WM_CLOSE message to the main window. Closing the window eventually results in Windows sending a WM_DESTROY message, which results in a <I>PostQuitMessage</I> call that terminates the program. Sending a WM_CLOSE message is, by the way, the same action that results from clicking on the Close button on the command bar.

<P>Other changes from the first TicTac example include modification of the message loop to provide for keyboard accelerators and the addition of code in the <I>OnCreateMain</I> routine to load and assign a window icon. Also, the string prompts for whose turn it is are loaded from the resource file.

<P>Looking at the <I>OnCommandNewGame</I> handler introduces one last new function. If the game isn't complete, the program asks the players whether they really want to clear the game board. This query is accomplished by calling

<p><pre>
int MessageBox (HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption,
                UINT uType);
</pre>				

<P>This function displays a message box, a simple dialog box, with definable text and buttons. A message box can display a message along with a limited series of buttons. Message boxes are often used to query users for a simple response or to notify them of some event. The <I>uType </I>parameter allows the programmer to select different button configurations, such as Yes/No, OK/Cancel, Yes/No/Cancel, and simply OK. You can also select an icon to appear in the message box that signals the level of importance of the answer.

<P>A message box is essentially a poor man's dialog box. It offers a simple method of querying the user but little flexibility in how the dialog box is configured. Now that we've introduced the subject of <I>dialog boxes</I>, it's time to take a closer look at them and other types of secondary and child windows.

</BODY>
</HTML>




