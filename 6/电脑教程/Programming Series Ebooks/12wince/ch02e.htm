<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>Lines and Shapes</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="61"><H1>Lines and Shapes</H1></A>

<P>One of the areas in which Windows CE provides substantially less functionality than other versions of Windows is in the primitive line-drawing and shape-drawing functions. Gone are the <I>Chord</I>, <I>Arc,</I> and <I>Pie</I> functions that created complex circular shapes. Gone too is the concept of <I>current point</I>. Other versions of Windows track a current point, which is then used as the starting point for the next drawing command. So drawing a series of connected lines and curves by calling <I>MoveTo</I> to move the current point followed by calls to <I>LineTo</I>, <I>ArcTo</I>, <I>PolyBezierTo</I> and so forth is no longer possible. But even with the loss of a number of graphic functions, Windows CE still provides the essential functions necessary to draw lines and shapes.

<A NAME="62"><H2>Lines</H2></A>

<P>Drawing one or more lines is as simple as a call to

<p><pre>
BOOL Polyline (HDC hdc, const POINT *lppt, int cPoints);
</pre>

<P>The second parameter is a pointer to an array of POINT structures that are defined as the following:

<p><pre>
typedef struct tagPOINT {
    LONG x; 
    LONG y; 
} POINT;
</pre>

<P>Each <I>x</I> and <I>y</I> combination describes a pixel from the upper left corner of the screen. The third parameter is the number of point structures in the array. So to draw a line from (0, 0) to (50, 100), the code would look like this:

<p><pre>
POINTS pts[2];

pts[0].x = 0;
pts[0].y = 0;
pts[1].x = 50;
pts[1].y = 100;
PolyLine (hdc, &amp;pts, 2);
</pre>

<P>Just as in the early text examples, this code fragment makes a number of assumptions about the default state of the device context. For example, just what does the line drawn between (0,0) and (50, 100) look like? What is its width and its color, and is it a solid line? All versions of Windows, including Windows CE, allow these parameters to be specified.

<P>The tool for specifying the appearance of lines and the outline of shapes is called, appropriately enough, a <I>pen</I>. A pen is another GDI object and, like the others described in this chapter, is created, selected into a device context, used, deselected, and then destroyed. Among other stock GDI objects, stock pens can be retrieved using the following code:

<p><pre>
HGDIOBJ GetStockObject (int fnObject);
</pre>

<P>All versions of Windows provide three stock pens, each 1 pixel wide. The stock pens come in 3 colors: white, black, and null. Using <I>GetStockObject</I>, the call to retrieve one of those pens employs the parameters WHITE_PEN, BLACK_PEN, and NULL_PEN respectively. Unlike standard graphic objects created by applications, stock objects should never be deleted by the application. Instead, the application should simply deselect the pen from the device context when it's no longer needed.

<P>To create a custom pen under Windows, two functions are available. The first is this:

<p><pre>
HPEN CreatePen ( int fnPenStyle, int nWidth, COLORREF crColor);
</pre>

<P>The <I>fnPenStyle</I> parameter specifies the appearance of the line to be drawn. For example, the PS_DASH flag can be used to create a dashed line. The <I>nWidth</I> parameter specifies the width of the pen. Finally, the <I>crColor</I> parameter specifies the color of the pen. The <I>crColor</I> parameter is typed as COLORREF, which under Windows CE 2.0 is an RGB value. The RGB macro is as follows:

<p><pre>
COLORREF RGB (BYTE bRed, BYTE bGreen, BYTE bBlue);
</pre>

<P>So to create a solid red pen, the code would look like this:

<p><pre>
hPen = CreatePen (PS_SOLID, 1, RGB (0xff, 0, 0));
</pre>

<P>The other pen creation function is the following:

<p><pre>
HPEN CreatePenIndirect (const LOGPEN *lplgpn);
</pre>

<P>where the logical pen structure LOGPEN is defined as

<p><pre>
typedef struct tagLOGPEN {
    UINT lopnStyle;
    POINT lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
</pre>

<P><I>CreatePenIndirect</I> provides the same parameters to Windows, in a different form. To create the same 1-pixel-wide red pen with <I>CreatePenIndirect</I>, the code would look like this:

<p><pre>
LOGPEN lp;
HPEN hPen;

lp.lopnStyle = PS_SOLID;
lp.lopnWidth.x = 1;
lp.lopnWidth.y = 1;
lp.lopnColor = RGB (0xff, 0, 0);

hPen = CreatePenIndirect (&amp;lp);
</pre>

<P>Windows CE devices don't support complex pens such as wide (more than one pixel wide), dashed lines. To determine what's supported, our old friend <I>GetDeviceCaps</I> comes into play, taking LINECAPS as the second parameter. Refer to the Windows CE documentation for the different flags returned by this call.

<A NAME="63"><H2>Shapes</H2></A>

<P>Lines are useful but Windows also provides functions to draw shapes, both filled and unfilled. Here, Windows CE does a good job supporting most of the functions familiar to Windows programmers. The <I>Rectangle</I>, <I>RoundRect</I>, <I>Ellipse,</I> and <I>Polygon</I> functions are all supported.

<A NAME="64"><H3>Brushes</H3></A>

<P>Before I can talk about shapes such as rectangles and ellipses I need to describe another GDI object that I've only mentioned briefly before now, called a <I>brush</I>. A brush is a small 8-by-8 bitmap used to fill shapes. It's also used by Windows to fill the background of a client window. Windows CE provides a number of stock brushes and also the ability to create a brush from an application-defined pattern. A number of stock brushes, each a solid color, can be retrieved using <I>GetStockObject</I>. Among the brushes available is one for each of the grays of a four grayscale display: white, light gray, dark gray, and black.

<P>To create solid color brushes, the function to call is the following:

<p><pre>
HBRUSH CreateSolidBrush (COLORREF crColor);
</pre>

<P>This function isn't really necessary when you're writing an application for a four-color Windows CE device because those four solid brushes can be retrieved with the <I>GetStockObject</I> call. For higher color devices however, the <I>crColor</I> parameter can be generated using the RGB macro.

<P>To create custom pattern brushes, Windows CE supports the Win32 function:

<p><pre>
HBRUSH CreateDIBPatternBrushPt (const void *lpPackedDIB,
                                UINT iUsage);
</pre>

<P>The first parameter to this function is a pointer to a DIB in <I>packed</I> format. This means that the pointer points to a buffer that contains a BITMAPINFO structure immediately followed by the bits in the bitmap. Remember that a BITMAPINFO structure is actually a BITMAPINFOHEADER structure followed by a palette in RGBQUAD format, so the buffer contains everything necessary to create a DIB&#8212;that is, bitmap information, a palette, and the bits to the bitmap. The second parameter must be set to DIB_RGB_COLORS for Windows CE applications. This setting indicates that the palette specified contains RGBQUAD values in each entry. The complimentary flag, DIB_PAL_COLORS, used in other versions of Windows isn't supported in Windows CE.

<P>The <I>CreateDIBPatternBrushPt</I> function is more important under Windows CE because the hatched brushes, supplied under other versions of Windows by the <I>CreateHachBrush</I> function, aren't supported under Windows CE. Hatched brushes are brushes composed of any combination of horizontal, vertical, or diagonal lines. Ironically, they're particularly useful with grayscale displays because you can use them to accentuate different areas of a chart with different hatch patterns. These brushes, however, can be reproduced by using <I>CreateDIBPatternBrushPt</I> and the proper bitmap patterns. The Shapes code example, later in the chapter, demonstrates a method for creating hatched brushes under Windows CE.

<P>By default, the brush origin will be in the upper left corner of the window. This isn't always what you want. Take, for example, a bar graph where the bar filled with a hatched brush fills a rectangle from (100, 100) to (125, 220). Since this rectangle isn't divisible by 8 (brushes being 8 by 8 pixels square), the upper left corner of the bar will be filled with a partial brush that might not look pleasing to the eye.

<P>To avoid this situation, you can move the origin of the brush so that each shape can be drawn with the brush aligned correctly in the corner of the shape to be filled. The function available for this remedy is the following:

<p><pre>
BOOL SetBrushOrgEx (HDC hdc, int nXOrg, int nYOrg, LPPOINT lppt);
</pre>

<P>The <I>nXOrg</I> and <I>nYOrg</I> parameters allow the origin to be set between 0 and 7 so that you can position the origin anywhere in the 8-by-8 space of the brush. The <I>lppt</I> parameter is filled with the previous origin of the brush so that you can restore the previous origin if necessary.

<A NAME="65"><H3>Rectangles</H3></A>

<P>The rectangle function draws either a filled or a hollow rectangle; the function is defined as the following:

<p><pre>
BOOL Rectangle (HDC hdc, int nLeftRect, int nTopRect,
                int nRightRect, int nBottomRect);
</pre>				
				
<P>The function uses the currently selected pen to draw the outline of the rectangle and the current brush to fill the interior. To draw a hollow rectangle, select the null brush into the device context before calling <I>Rectangle</I>.

<P>The actual pixels drawn for the border are important to understand. Say we're drawing a 5-by-7 rectangle at 0, 0. The function call would look like this:

<p><pre>
Rectangle (0, 0, 5, 7);
</pre>

<P>Assuming that the selected pen was 1 pixel wide, the resulting rectangle would look like the one shown in Figure 2-8.

<P><img src="f02rg08.gif" width=223 height=234 border="0">
<P><!-- caption --><B>Figure 2-8.</B> <I>Expanded view of a rectangle drawn with the </I>Rectangle<I> function.</I><!-- /caption -->

<P>Notice how the right edge of the drawn rectangle is actually drawn in column 4 and that the bottom edge is drawn on row 6. This is standard Windows practice. The rectangle is drawn inside the right and bottom boundary specified for the <I>Rectangle</I> function. If the selected pen is wider than one pixel, the right and bottom edges are drawn with the pen centered on the bounding rectangle. (Other versions of Windows support the PS_INSIDEFRAME pen style that forces the rectangle to be drawn inside the frame regardless of the pen width.)

<A NAME="66"><H3>Circles and ellipses</H3></A>

<P>Circles and ellipses can be drawn with this function:

<p><pre>
BOOL Ellipse (HDC hdc, int nLeftRect, int nTopRect,
              int nRightRect, int nBottomRect);
</pre>			  
			  
<P>The ellipse is drawn using the rectangle passed as a bounding rectangle, as shown in Figure 2-9. As with the <I>Rectangle</I> function, while the interior of the ellipse is filled with the current brush, the outline is drawn with the current pen.

<P><img src="f02rg09.gif" width=401 height=247 border="0">
<P><!-- caption --><B>Figure 2-9.</B> <I>The ellipse is drawn within the bounding rectangle passed to the </I>Ellipse<I> function.</I><!-- /caption -->

<A NAME="67"><H3>Round rectangles</H3></A>

<P>The <I>RoundRect</I> function,

<p><pre>
BOOL RoundRect (HDC hdc, int nLeftRect, int nTopRect, 
                int nRightRect, int nBottomRect,
                int nWidth, int nHeight);
</pre>				
				
<P>draws a rectangle with rounded corners. The roundedness of the corners is defined by the last two parameters that specify the width and height of the ellipse used to round the corners, as shown in Figure 2-10. Specifying the ellipse height and width enables your program to draw identically symmetrical rounded corners. Shortening the ellipse height flattens out the sides of the rectangle, while shortening the width of the ellipse flattens the top and bottom of the rectangle.

<P><A HREF="javascript:fullSize('f02rg10x.htm')"> <img src="f02rg10.jpg" width=404 height=255 border=0 ALT="Click to view at full size."> </A>
<P><!-- caption --><B>Figure 2-10.</B> <I>The height and width of the ellipse define the round corners of the rectangle drawn by </I>RoundRect<I>.</I><!-- /caption -->

<A NAME="68"><H3>Polygons</H3></A>

<P>Finally, the <I>Polygon</I> function,

<p><pre>
BOOL Polygon (HDC hdc, const POINT *lpPoints, int nCount);
</pre>

<P>draws a many-sided shape. The second parameter is a pointer to an array of point structures defining the points that delineate the polygon. The resulting shape has one more side than the number of points because the function automatically completes the last line of the polygon by connecting the last point with the first. Under Windows CE 1.0, this function is limited to producing convex polygons.

<A NAME="69"><H2>The Shapes Example Program</H2></A>

<P>The Shapes program, shown in Figure 2-11, demonstrates a number of these functions. In Shapes, five figures are drawn, each filled with a different brush.

<P><B>Figure 2-11.</B> <I>The Shapes program.</I>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="70"><H3>Shapes.h</H3></A>
<p><pre>
//================================================================
// Header file
//

// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//
//======================================================================
// Returns number of elements
#define dim(x) (sizeof(x) / sizeof(x[0]))

//----------------------------------------------------------------------
// Generic defines and data types
//
struct decodeUINT {                             // Structure associates
    UINT Code;                                  // messages 
                                                // with a function. 
    LRESULT (*Fxn)(HWND, UINT, WPARAM, LPARAM);
}; 
struct decodeCMD {                              // Structure associates
    UINT Code;                                  // menu IDs with a 
    LRESULT (*Fxn)(HWND, WORD, HWND, WORD);     // function.
};

//----------------------------------------------------------------------
// Generic defines used by application
#define  IDC_CMDBAR 1                           // Command bar ID
//----------------------------------------------------------------------
// Defines used by MyCreateHatchedBrush
//
typedef struct {
    BITMAPINFOHEADER bmi;
    COLORREF dwPal[2];
    BYTE bBits[64];
} BRUSHBMP;

#define HS_HORIZONTAL       0       /* ----- */
#define HS_VERTICAL         1       /* ||||| */
#define HS_FDIAGONAL        2       /* \\\\\ */
#define HS_BDIAGONAL        3       /* ///// */
#define HS_CROSS            4       /* +++++ */
#define HS_DIAGCROSS        5       /* xxxxx */


//----------------------------------------------------------------------
// Function prototypes
//
int InitApp (HINSTANCE);
HWND InitInstance (HINSTANCE, LPWSTR, int);
int TermInstance (HINSTANCE, int);

// Window procedures
LRESULT CALLBACK MainWndProc (HWND, UINT, WPARAM, LPARAM);

// Message handlers
LRESULT DoCreateMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoPaintMain (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDestroyMain (HWND, UINT, WPARAM, LPARAM);
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="71"><H3>Shapes.c</H3></A>
<p><pre>
//======================================================================
// Shapes- Brush and shapes demo for Windows CE

//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;commctrl.h&gt;                // Command bar includes
#include &quot;shapes.h&quot;                  // Program-specific stuff
//----------------------------------------------------------------
// Global data
//
const TCHAR szAppName[] = TEXT (&quot;Shapes&quot;);
HINSTANCE hInst;                     // Program instance handle

// Message dispatch table for MainWindowProc
const struct decodeUINT MainMessages[] = {
    WM_CREATE, DoCreateMain,
    WM_PAINT, DoPaintMain,
    WM_DESTROY, DoDestroyMain,
};

//======================================================================
//
// Program entry point
//
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPWSTR lpCmdLine, int nCmdShow) {
    MSG msg;
    int rc = 0;
    HWND hwndMain;

    // Initialize application.
    rc = InitApp (hInstance);
    if (rc) return rc;

    // Initialize this instance.
    hwndMain = InitInstance(hInstance, lpCmdLine, nCmdShow);
    if (hwndMain == 0)
        return 0x10;

    // Application message loop
    while (GetMessage (&amp;msg, NULL, 0, 0)) {
        TranslateMessage (&amp;msg);
        DispatchMessage (&amp;msg);
    }
    // Instance cleanup
    return TermInstance (hInstance, msg.wParam);
}
//----------------------------------------------------------------------
// InitApp - Application initialization
//
int InitApp (HINSTANCE hInstance) {
    WNDCLASS wc;

    // Register application main window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = MainWndProc;             // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = szAppName;             // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    return 0;
}
//----------------------------------------------------------------------
// InitInstance - Instance initialization
//
HWND InitInstance (HINSTANCE hInstance, LPWSTR lpCmdLine, int nCmdShow){
    HWND hWnd;

    // Save program instance handle in global variable.
    hInst = hInstance;

    // Create main window.
    hWnd = CreateWindow (szAppName,           // Window class
                         TEXT(&quot;Shapes&quot;),      // Window title
                         WS_VISIBLE,          // Style flags
                         CW_USEDEFAULT,       // x position
                         CW_USEDEFAULT,       // y position
                         CW_USEDEFAULT,       // Initial width
                         CW_USEDEFAULT,       // Initial height
                         NULL,                // Parent
                         NULL,                // Menu, must be null
                         hInstance,           // Application instance
                         NULL);               // Pointer to create
                                              // parameters
    // Return fail code if window not created.
    if (!IsWindow (hWnd)) return 0;

    // Standard show and update calls
    ShowWindow (hWnd, nCmdShow);
    UpdateWindow (hWnd);
    return hWnd;
}
//----------------------------------------------------------------------
// TermInstance - Program cleanup
//
int TermInstance (HINSTANCE hInstance, int nDefRC) {

    return nDefRC;
}
//======================================================================
// Message handling procedures for MainWindow
//

//----------------------------------------------------------------------
// MainWndProc - Callback function for application window
//
LRESULT CALLBACK MainWndProc (HWND hWnd, UINT wMsg, WPARAM wParam, 
                              LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(MainMessages); i++) {
        if (wMsg == MainMessages[i].Code)
             return (*MainMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateMain - Process WM_CREATE message for window.
//
LRESULT DoCreateMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                      LPARAM lParam) {
    HWND hwndCB;

    // Create a command bar.
    hwndCB = CommandBar_Create (hInst, hWnd, IDC_CMDBAR);

    // Add exit button to command bar. 
    CommandBar_AddAdornments (hwndCB, 0, 0);
    return 0;
}
//----------------------------------------------------------------
// MyCreateHachBrush - Creates hatched brushes
//
HBRUSH MyCreateHachBrush (INT fnStyle, COLORREF clrref) {
    BRUSHBMP brbmp;
    BYTE *pBytes;
    int i;
    DWORD dwBits[6][2] = {
        {0x000000ff,0x00000000}, {0x10101010,0x10101010},
        {0x01020408,0x10204080}, {0x80402010,0x08040201},
        {0x101010ff,0x10101010}, {0x81422418,0x18244281},
    };

    if ((fnStyle &lt; 0) || (fnStyle &gt; dim(dwBits)))
        return 0;
    memset (&amp;brbmp, 0, sizeof (brbmp));

    brbmp.bmi.biSize = sizeof (BITMAPINFOHEADER);
    brbmp.bmi.biWidth = 8;
    brbmp.bmi.biHeight = 8;
    brbmp.bmi.biPlanes = 1;
    brbmp.bmi.biBitCount = 1;
    brbmp.bmi.biClrUsed = 2;
    brbmp.bmi.biClrImportant = 2;

    // Initialize the palette of the bitmap.
    brbmp.dwPal[0] = PALETTERGB(0xff,0xff,0xff);
    brbmp.dwPal[1] = PALETTERGB((BYTE)((clrref &gt;&gt; 16) &amp; 0xff),
                                (BYTE)((clrref &gt;&gt; 8) &amp; 0xff),
                                (BYTE)(clrref &amp; 0xff));

    // Write the hatch data to the bitmap.  
    pBytes = (BYTE *)&amp;dwBits[fnStyle];
    for (i = 0; i &lt; 8; i++)
        brbmp.bBits[i*4] = *pBytes++;

    // Return the handle of the brush created.
    return CreateDIBPatternBrushPt (&amp;brbmp, DIB_RGB_COLORS);
}
//----------------------------------------------------------------------
// DoPaintMain - Process WM_PAINT message for window.
//
//#define ENDPOINTS 32
#define ENDPOINTS 64
LRESULT DoPaintMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                     LPARAM lParam) {
    PAINTSTRUCT ps;
    RECT rect;
    HDC hdc;
    POINT ptArray[ENDPOINTS];
    HBRUSH hBr, hOldBr;
    TCHAR szText[128];

    // Adjust the size of the client rect to take into account
    // the command bar height.
    GetClientRect (hWnd, &amp;rect);
    rect.top += CommandBar_Height (GetDlgItem (hWnd, IDC_CMDBAR));

    hdc = BeginPaint (hWnd, &amp;ps); 

    // Draw rectangle.
    hBr = GetStockObject (BLACK_BRUSH);
    hOldBr = SelectObject (hdc, hBr);
    Rectangle (hdc, 50, 50, 125, 150);
    SelectObject (hdc, hOldBr);

    // Draw ellipse.
    hBr = GetStockObject (DKGRAY_BRUSH);
    hOldBr = SelectObject (hdc, hBr);
    Ellipse (hdc, 150, 50, 225, 150);
    SelectObject (hdc, hOldBr);

    // Draw round rectangle.
    hBr = GetStockObject (LTGRAY_BRUSH);
    hOldBr = SelectObject (hdc, hBr);
    RoundRect (hdc, 250, 50, 325, 150, 30, 30);
    SelectObject (hdc, hOldBr);

    // Draw hexagon using Polygon. 
    hBr = GetStockObject (WHITE_BRUSH);
    hOldBr = SelectObject (hdc, hBr);
    ptArray[0].x = 387;
    ptArray[0].y = 50;
    ptArray[1].x = 350;
    ptArray[1].y = 75;
    ptArray[2].x = 350;
    ptArray[2].y = 125;
    ptArray[3].x = 387;
    ptArray[3].y = 150;
    ptArray[4].x = 425;
    ptArray[4].y = 125;
    ptArray[5].x = 425;
    ptArray[5].y = 75;

    Polygon (hdc, ptArray, 6);
    SelectObject (hdc, hOldBr);

    hBr = MyCreateHachBrush (HS_DIAGCROSS, RGB (0, 0, 0));
    hOldBr = SelectObject (hdc, hBr);
    Rectangle (hdc, 50, 165, 425, 210);
    SelectObject (hdc, hOldBr);
    DeleteObject (hBr);

    SetBkMode (hdc, OPAQUE);
    lstrcpy (szText, TEXT (&quot;Opaque background&quot;));
    ExtTextOut (hdc, 60, 175, 0, NULL, 
                szText, lstrlen (szText), NULL);

    SetBkMode (hdc, TRANSPARENT);
    lstrcpy (szText, TEXT (&quot;Transparent background&quot;));
    ExtTextOut (hdc, 250, 175, 0, NULL,
                szText, lstrlen (szText), NULL);

    EndPaint (hWnd, &amp;ps); 
    return 0;
}
//----------------------------------------------------------------------
// DoDestroyMain - Process WM_DESTROY message for window.
//
LRESULT DoDestroyMain (HWND hWnd, UINT wMsg, WPARAM wParam, 
                       LPARAM lParam) {
    PostQuitMessage (0);
    return 0;
}
</pre>
</td></tr></table>

<P>In Shapes, <I>OnPaintMain</I> draws the five figures using the different functions discussed earlier. For each of the shapes, a different brush is created, selected into the device context, and, after the shape has been drawn, deselected from the DC. The first four shapes are filled with solid grayscale shades, ranging from black to white. These solid brushes are loaded with the <I>GetStockObject</I> function. The final shape is filled with a brush created with the <I>CreateDIBPatternBrushPt</I>. The creation of this brush is segregated into a function called <I>MyCreateHatchBrush</I> that mimics the <I>CreateHatchBrush</I> function not available under Windows CE. To create the hatched brushes, a black and white bitmap is built by filling in a bitmap structure and setting the bits to form the hatch patterns. The bitmap itself is the 8-by-8 bitmap specified by <I>CreateDIBPatternBrushPt</I>. Since the bitmap is monochrome, its total size, including the palette and header, is only around 100 bytes. Notice, however, that since each scan line of a bitmap must be double-word aligned, the last three bytes of each one-byte scan line are left unused.

<P>Finally the program completes the painting by writing two lines of text into the lower rectangle. The text further demonstrate the difference between the opaque and transparent drawing modes of the system. In this case, the opaque mode of drawing the text might be a better match for the situation because the hatched lines tend to obscure letters drawn in transparent mode. A view of the Shapes window is shown in Figure 2-12.

<P><A HREF="javascript:fullSize('f02rg12x.htm')"> <img src="f02rg12.jpg" width=404 height=203 border=0 ALT="Click to view at full size."> </A>
<P><!-- caption --><B>Figure 2-12.</B> <I>The Shapes example demonstrates drawing different filled shapes.</I><!-- /caption -->

<P>To keep things simple, the Shapes example assumes that it's running on at least a 480-pixel-wide display. To properly display the same shapes on a Palm-size PC requires a few minor changes to the coordinates used to position the shapes displayed.

<P>I have barely scratched the surface of the abilities of the Windows CE GDI portion of GWE. The goal of this chapter wasn't to provide total presentation of all aspects of GDI programming. Instead, I wanted to demonstrate the methods available for basic drawing and text support under Windows CE. In other chapters in the book, I extend some of the techniques touched on in this chapter. I talk about these new techniques and newly introduced functions at the point, generally, where I demonstrate how to use them in code. To further your knowledge, I recommend <I>Programming Windows 95</I>, by Charles Petzold (Microsoft Press, 1996), as the best source for learning about the Windows GDI.

<P>Now that we've looked at output, it's time to turn our attention to the input side of the system, the keyboard and touch panel.

</BODY>
</HTML>




