<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>The CeUtil Functions</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="417"><H1>The CeUtil Functions</H1></A>

<P>Windows CE Services uses the PC registry to store voluminous amounts of information about the Windows CE devices that have partnered with the PC. Windows CE Services also uses the registry to store extensive configuration information. While most of these registry keys are documented, if you access them by name you're assuming that those key names will always remain the same. This might not be the case, especially in international versions of Windows where registry keys are sometimes in a different language.

<P>The CeUtil DLL exports functions that provide an abstraction layer over the registry keys used by Windows CE Services. Using this DLL allows a PC application to query the devices that are currently registered and to add or delete registry values underneath the keys that hold data for specific devices. The CeUtil DLL doesn't communicate with a remote Windows CE device; it only looks in the PC registry for information that has already been put there by Windows CE Services.

<P>The keys in the registry related to Windows CE Services are separated into either HKEY_LOCAL_MACHINE, for generic configurations such as the initial configuration for a newly registered device, or HKEY_CURRENT_USER, where the configuration information for the already registered devices is located. When a new device is registered, CE Services copies the template in HKEY_LOCAL_MACHINE to a new subkey under HKEY_CURRENT_USER that identifies the specific device.

<P>In general, you register a new filter in the keys under HKEY_LOCAL_MACHINE to ensure that all devices that are registered in the future also use your filter. You use the registry entries under HKEY_CURRENT_USER to register that filter for a specific device that was already registered before you installed that same filter.

<A NAME="418"><H3>Accessing Windows CE Services registry entries</H3></A>

<P>To open one of the many registry keys that hold connection information, you can use this function:

<p><pre>
HRESULT CeSvcOpen (UINT uSvc, LPTSTR pszPath, BOOL fCreate,
                   PHCESVC phSvc);
</PRE>

<P>The first parameter of this function is a flag that indicates which predefined key you want to open. The available flags are listed below.

<P><B>Keys under HKEY_LOCAL_MACHINE that apply to generic Windows CE Services configuration information</B>

<UL>
<P><LI><I>CESVC_ROOT_MACHINE</I> Windows CE Services root key under HKEY_LOCAL_MACHINE
<P><LI><I>CESVC_FILTERS</I> Root key for filter registration
<P><LI><I>CESVC_CUSTOM_MENUS</I> Root key for custom menu registration
<P><LI><I>CESVC_SERVICES_COMMON</I> Root key for services
<P><LI><I>CESVC_SYNC_COMMON</I> Root key for synchronization services registration
</UL>

<P><B>Keys under HKEY_CURRENT_USER that apply to specific Windows CE devices that are partnered with the PC</B>

<UL>
<P><LI><I>CESVC_ROOT_USER</I> Windows CE Services root key under HKEY_LOCAL_USER
<P><LI><I>CESVC_DEVICES</I> Root key for individual device registration
<P><LI><I>CESVC_DEVICEX</I> Root key for a specific device
<P><LI><I>CESVC_DEVICE_SELECTED</I> Root key for the device currently selected in the Windows CE Services window
<P><LI><I>CESVC_SERVICES_USER</I> Root services subkey for a specific device
<P><LI><I>CESVC_SYNC</I> Synchronization subkey for a specific device
</UL>

<P>Of the many registry keys that can be returned by <I>CeSvcOpen</I>, the ones I'll be using throughout the chapter are CESVC_FILTERS, the key in which a filter is registered for all future devices; CESVC_DEVICES, the key in which information for all registered devices is located; and CESVC_DEVICEX, which is used to open keys for a specific registered devices. The other flags are useful for registering synchronization objects as well as for registering general Windows CE Services configuration information.

<P>The second parameter to <I>CeSvcOpen</I> is <I>pszPath</I>. This parameter points either to the name of a subkey to open underneath the key specified by the <I>uSvc</I> flag or to a DWORD value that specifies the registered Windows CE device that you want to open if the <I>uSvc</I> flag requires that a device be specified. The <I>fCreate</I> parameter should be set to TRUE if you want to create the key being opened because it currently doesn't exist. If this parameter is set to FALSE, <I>CeSvcOpen</I> fails if the key doesn't already exist in the registry. Finally, the <I>phSvc</I> parameter points to a <I>CESVC</I> handle that receives the handle of the newly opened key. While this isn't typed as a handle to a registry key (an HKEY), the key can be used in both the CeUtil registry functions as well as the standard registry functions.

<P><I>CeSvcOpen</I> returns a standard Win32 error code if the function fails. Otherwise, the key to the opened registry key is placed in the variable pointed to by <I>phSvc</I>.

<P>You can open registry keys below those opened by <I>CeSvcOpen</I> by calling <I>CeSvcOpenEx</I>. This function is prototyped as

<p><pre>
HRESULT CeSvcOpenEx (HCESVC hSvcRoot, LPTSTR pszPath, BOOL fCreate,
                     PHCESVC phSvc);
</PRE>

<P>The parameters for this closely mirror those of <I>RegOpenKey</I>. The first parameter is a handle to a previously opened key. Typically, this key would have been opened by <I>CeSvcOpen</I>. The second parameter is the string that specifies the name of the subkey to be opened. Notice that since we're running on the PC, this string might not be a Unicode value. The <I>fCreate</I> parameter should be set to TRUE if you want the key to be created if it doesn't already exist. Finally, the <I>phSvc</I> parameter points to a <I>CESVC</I> handle that receives the handle to the opened key.

<P>When you have finished with a key, you should close it with a call to this function:

<p><pre>
HRESULT CeSvcClose (HCESVC hSvc);
</PRE>

<P>The only parameter is the handle you want to close.

<A NAME="419"><H3>Enumerating registered devices</H3></A>

<P>Of course, the requirement to specify the device ID value in <I>CeSvcOpen</I> begs the question of how you determine what devices have already been partnered with the PC. To determine this, you can use the function

<p><pre>
HRESULT CeSvcEnumProfiles (PHCESVC phSvc, DWORD lProfileIndex,
                           PDWORD plProfile);
</PRE>

<P>The first parameter to <I>CeSvcEnumProfiles</I> is a pointer to a CESVC handle. The handle this parameter points to is uninitiated the first time the function is called. The function returns a handle that must be passed in subsequent calls to <I>CeSvcEnumProfiles</I>. The second parameter is an index value. This value should be set to 0 the first time the function is called and incremented for each subsequent call. The final parameter is a pointer to a DWORD that receives the device ID for the registered device. This value can be used when calling <I>CeSvcOpen</I> to open a registry key for that device.

<P>Each time the function is called, it returns NOERROR if a new device ID is returned. When all devices have been enumerated, <I>CeSvcEnumProfiles</I> returns ERROR_NO_MORE_ITEMS. You should be careful to continue calling <I>CeSvcEnumProfiles</I> until the function returns ERROR_NO_MORE_ITEMS so that the enumeration process will close the handle parameter pointed to by <I>phSvc</I>. If you want to stop enumerating after you've found a particular device ID, you'll need to call <I>CeSvcClose</I> to close the <I>hSvc </I>handle manually.

<P>The following routine enumerates the Windows CE devices that have been registered on the PC. The program enumerates all the registered Windows CE devices and prints out the name and device type of each of the devices. The program uses the function <I>CeSvcGetString</I>, which I'll describe shortly.

<p><pre>
int PrintCeDevices (void) {
    HCESVC hSvc, hDevKey;
    TCHAR szName[128], szType[64];
    DWORD dwPro;
    INT i;

    // Enumerate each registered device.
    i = 0;
    while (CeSvcEnumProfiles (&amp;hSvc, i++, &amp;dwPro) == 0) {

        // Open the registry key for the device enumerated.
        CeSvcOpen (CESVC_DEVICEX, (LPTSTR)dwPro, FALSE, &amp;hDevKey);

        // Get the name and device type strings.
        CeSvcGetString (hDevKey, TEXT (&quot;DisplayName&quot;),
            szName, dim(szName));
        CeSvcGetString (hDevKey, TEXT (&quot;DeviceType&quot;),
            szType, dim(szType));

        // Print to the console.
        printf (TEXT (&quot;Name: %s\t\tType: %s&quot;), szName, szType);

        // Close the key opened by CeSvcOpen.
        CeSvcClose (hDevKey);
    }
    return i-1;         // Return the number of devices found.
}
</PRE>

<A NAME="420"><H3>Reading and writing values</H3></A>

<P>The remainder of the <I>CeUtil </I>library functions concern reading and writing values in the registry. In fact, you can skip these functions and use the registry functions directly, but the <I>CeSvc</I>xxx functions are a bit simpler to use. These functions allow you to read and write three of the data types used in the registry, DWORD, string, and binary data. These just happen to be the only data types used in the values under the Windows CE Services keys. The functions are all listed here:

<p><pre>
HRESULT CeSvcGetDword (HCESVC hSvc, LPCTSTR pszValName,
                       LPDWORD pdwVal);
HRESULT CeSvcSetDword (HCESVC hSvc, LPCTSTR pszValName,
                       DWORD dwVal);
					   
HRESULT CeSvcGetString (HCESVC hSvc, LPCTSTR pszValName,
                        LPTSTR pszVal, DWORD cbVal);

HRESULT CeSvcSetString (HCESVC hSvc, LPCTSTR pszValName,
                        LPCTSTR pszVal);
						
HRESULT CeSvcGetBinary (HCESVC hSvc, LPCTSTR pszValName,
                        LPBYTE pszVal, LPDWORD pcbVal);

HRESULT CeSvcSetBinary (HCESVC hSvc, LPCTSTR pszValName,
                        LPBYTE pszVal, DWORD cbVal);
</PRE>

<P>The parameters for these functions are fairly self-explanatory. The first parameter is the handle to an open key. The second parameter is the name of the value being read or written. The third parameter specifies the data or a pointer to where the data will be written. The fourth parameter on some of the functions specifies the size of the buffer for the data being read or, in the case of <I>CeSvcSetBinary</I>, the length of the data being written.

<P>One final function in the <I>CeUtil</I> library is

<p><pre>
HRESULT CeSvcDeleteVal (HCESVC hSvc, LPCTSTR pszValName);
</PRE>

<P>This function, as you might expect, lets you delete a value from the registry. The parameters are the handle to an open key and the name of the value to be deleted.

<P>The <I>CeUtil </I>library doesn't provide any function that you couldn't do yourself with a bit of work and the standard registry functions. However, using these functions frees you from having to depend on hard-coded registry key names that could change in the future. I strongly advise using these functions whenever possible when you're accessing registry entries that deal with Windows CE Services.

</BODY>
</HTML>




