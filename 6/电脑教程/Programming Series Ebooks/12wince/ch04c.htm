<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>Windows Controls</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="115"><H1>Windows Controls</H1></A>

<P>While scroll bars hold a special place because of their easy association with standard windows, there are a large number of other controls that Windows applications often use, including buttons, edit boxes, and list boxes. In short, controls are simply predefined window classes. Each has a custom window procedure supplied by Windows that gives each of these controls a tightly defined user and programming interface.

<P>Since a control is just another window, it can be created with a call to <I>CreateWindow </I>or <I>CreateWindowEx</I>, or, as I will explain later in this chapter, automatically by the dialog manager during the creation of a dialog box. Like menus, controls notify the parent window of events via WM_COMMAND messages encoding events and the ID and window handle of the control encoded in the parameters of the message. Controls can also be configured and manipulated using predefined messages sent to the control. Among other things, applications can set the state of buttons, add or delete items to list boxes, and set the selection of text in edit boxes all by sending messages to the controls.

<P>There are six predefined window control classes. They are

<UL>
<p><LI><I>Button</I> A wide variety of buttons.
<p><LI><I>Edit</I> A window that can be used to enter or display text.
<p><LI><I>List</I> A window that contains a list of strings.
<p><LI><I>Combo</I> A combination edit box and list box.
<p><LI><I>Static</I> A window that displays text or graphics that a user can't change.
<p><LI><I>Scroll bar</I> A scroll bar not attached to a specific window.
</UL>

<P>Each of these controls has a wide range of function, far too much for me to cover completely in this chapter. But I'll quickly review these controls, mentioning at least the highlights. Afterward, I'll show you an example program, CtlView, to demonstrate these controls and their interactions with their parent windows.

<A NAME="116"><H2>Button Controls</H2></A>

<P>Button controls enable several forms of input to the program. Buttons come in many styles, including push buttons, check boxes, and radio buttons. Each style is designed for a specific use&#8212;for example, push buttons are designed for receiving momentary input, check boxes are designed for on/off input, and radio buttons allow a user to select one of a number of choices.

<A NAME="117"><H3>Push buttons</H3></A>

<P>In general, push buttons are used to invoke some action. When a user presses a push button using a stylus, the button sends a WM_COMMAND message with a BN_CLICKED (for button notification clicked) notify code in the high word of the <I>wParam</I> parameter.

<A NAME="118"><H3>Check boxes</H3></A>

<P>Check boxes display a square box and a label that asks the user to specify a choice. A check box retains its state, either checked or unchecked, until the user clicks it again or the program forces the button to change state. In addition to the standard BS_CHECKBOX style, check boxes can come in a 3-state style, BS_3STATE, that allows the button to be disabled and shown grayed out. Two additional styles, BS_AUTOCHECKBOX and BS_AUTO3STATE, automatically update the state and look of the control to reflect the checked, unchecked, and in the case of the 3-state check box, the disabled state.

<P>As with push buttons, check boxes send a BN_CLICKED notification when the button is clicked. Unless the check box has one of the automatic styles, it's the responsibility of the application to manually change the state of the button. This can be done by sending a BM_SETCHECK message to the button with the <I>wParam</I> set to 0 to uncheck the button or 1 to check the button. The 3-state check boxes have a third, disabled state that can be set by means of the BM_SETCHECK message with the <I>wParam</I> value set to 2. An application can determine the current state using the BM_GETCHECK message.

<A NAME="119"><H3>Radio buttons</H3></A>

<P>Radio buttons allow a user to select from a number of choices. Radio buttons are grouped in a set, with only one of the set ever being checked at a time. If it's using the standard BS_RADIOBUTTON style, the application is responsible for checking and unchecking the radio buttons so that only one is checked at a time. However, like check boxes, radio buttons have an alternative style, BS_AUTORADIOBUTTON, that automatically maintains the group of buttons so that only one is checked.

<A NAME="120"><H3>Group boxes</H3></A>

<P>Strangely, the group box is also a type of button. A group box appears to the user as a hollow box with an integrated text label surrounding a set of controls that are naturally grouped together. Group boxes are merely an organizational device and have no programming interface other than the text of the box, which is specified in the window title text upon creation of the group box. Group boxes should be created after the controls within the box are created. This ensures that the group box will be &quot;beneath&quot; the controls it contains in the window Z-order.

<P>You should also be careful when using group boxes on Windows CE devices. The problem isn't with the group box itself, but with the small size of the Windows CE screen. Group boxes take up valuable screen real estate that can be better used by functional controls. This is especially the case on the Palm-size PC with its very small screen. In many cases, a line drawn between sets of controls can visually group the controls as well as a group box can.

<A NAME="121"><H3>Customizing the appearance of a button</H3></A>

<P>You can further customize the appearance of the buttons described so far by using a number of additional styles. The styles, BS_RIGHT, BS_LEFT, BS_BOTTOM, and BS_TOP, allow you to position the button text in a place other than the default center of the button. The BS_MULTILINE style allows you to specify more than one line of text in the button. The text is flowed to fit within the button. The newline character (\n) in the button text can be used to specifically define where line breaks occur. Windows CE doesn't support the BS_ICON and BS_BITMAP button styles supported by other versions of Windows.

<A NAME="122"><H3>Owner-draw buttons</H3></A>

<P>You can totally control the look of a button by specifying the BS_OWNERDRAW style. When a button is specified as owner-draw, its owner window is entirely responsible for drawing the button for all the states in which it might occur. When a window contains an owner-draw button, it's sent a WM_DRAWITEM message to inform it that a button needs to be drawn. For this message, the <I>wParam</I> parameter contains the ID value for the button and the <I>lParam</I> parameter points to a DRAWITEMSTRUCT structure defined as

<p><pre>
typedef struct tagDRAWITEMSTRUCT {
    UINT  CtlType;
    UINT  CtlID;
    UINT  itemID;
    UINT  itemAction;
    UINT  itemState;
    HWND  hwndItem;
    HDC   hDC;
    RECT  rcItem;
    DWORD itemData;
} DRAWITEMSTRUCT;
</pre>

<P>The <I>CtlType</I> field is set to ODT_BUTTON while the <I>CtlID</I> field, like the <I>wParam</I> parameter, contains the button's ID value. The <I>itemAction</I> field contains flags that indicate what needs to be drawn and why. The most significant of these fields is <I>itemState</I>, which contains the state (selected, disabled, and so forth) of the button. The <I>hDC</I> field contains the device context handle for the button window while the <I>rcItem</I> RECT contains the dimensions of the button. The <I>itemData</I> field is NULL for owner-draw buttons.

<P>As you might expect, the WM_DRAWITEM handler contains a number of GDI calls to draw lines, rectangles, and whatever else is needed to render the button. An important aspect of drawing a button is matching the standard colors of the other windows in the system. Since these colors can change, they shouldn't be hard coded. You can query to find out which are the proper colors by using the function

<p><pre>
DWORD GetSysColor (int nIndex);
</pre>

<P>This function returns an RGB color value for the colors defined for different aspects of windows and controls in the system. Among a number of predefined index values passed in the index parameter, an index of COLOR_BTNFACE returns the proper color for the face of a button while COLOR_BTNSHADOW returns the dark color for creating the three-dimensional look of a button.

<A NAME="123"><H2>The Edit Control</H2></A>

<P>The edit control is a window that allows the user to enter and edit text. As you might imagine, the edit control is one of the handiest controls in the Windows control pantheon. The edit control is equipped with full editing capability, including cut, copy, and paste interaction with the system clipboard, all without assistance from the application. Edit controls display a single line, or by specifying the ES_MULTILINE style, multiple lines of text. The Notepad accessory, provided with the desktop versions of Windows, is simply a top-level window that contains a multiline edit control.

<P>The edit control has a few other features that should be mentioned. An edit control with the ES_PASSWORD style displays an asterisk (*) character by default in the control for each character typed; the control saves the real character. The ES_READONLY style protects the text contained in the control so that it can be read, or copied into the clipboard, but not modified. The ES_LOWERCASE and ES_UPPERCASE styles force characters entered into the control to be changed to the specified case.

<P>You can add text to an edit control by using the WM_SETTEXT message and retrieve text by using the WM_GETTEXT message. Selection can be controlled using the EM_SETSEL message. This message specifies the starting and ending characters in the selected area. Other messages allow the position of the caret (the marker that indicates the current entry point in an edit field) to be queried and set. Multiline edit controls contain a number of additional messages to control scrolling as well as to access characters by line and column position.

<A NAME="124"><H2>The List Box Control</H2></A>

<P>The list box control displays a list of text items so that the user might select one or more of the items within the list. The list box stores the text, optionally sorts the items, and manages the display of the items, including scrolling. List boxes can be configured to allow selection of a single item or multiple items or to prevent any selection at all.

<P>You add an item to a list box by sending an LB_ADDSTRING or LB_INSERTSTRING message to the control, passing a pointer to the string to add in the <I>lParam</I> parameter. The LB_ADDSTRING message places the newly added string at the end of the list of items while LB_INSERTSTRING can place the string anywhere within the list of items in the list box. The list box can be searched for a particular item using the LB_FIND message.

<P>Selection status can be queried using the LB_GETCURSEL for single selection list boxes. For multiple selection list boxes, the LB_GETSELCOUNT and LB_GETSELITEMS can be used to retrieve the items currently selected. Items in the list box can be selected programmatically using the LB_SETCURSEL and LB_SETSEL messages.

<P>Windows CE supports most of the list box functionality available in other versions of Windows with the exception of owner-draw list boxes, and the LB_DIR family of messages. A new style, LBS_EX_CONSTSTRINGDATA, is supported under Windows CE. A list box with this style doesn't store strings passed to it. Instead, the pointer to the string is stored and the application is responsible for maintaining the string. For large arrays of strings that might be loaded from a resource, this procedure can save RAM because the list box won't maintain a separate copy of the list of strings.

<A NAME="125"><H2>The Combo Box Control</H2></A>

<P>The combo box is (as the name implies) a combination of controls&#8212;in this case, a single-line edit control and a list box. The combo box is a space-efficient control for selecting one item from a list of many or for providing an edit field with a list of predefined, suggested entries. Under Windows CE, the combo box comes in two styles: drop-down and drop-down list. (Simple combo boxes aren't supported.) The drop-down style combo box contains an edit field with a button at the right end. Clicking on the button displays a list box that might contain more selections. Clicking on one of the selections fills the edit field of the combo box with the selection. The drop-down list style replaces the edit box with a static text control. This allows the user to select from an item in the list but prevents the user from entering an item that's not in the list.

<P>Since the combo box combines the edit and list controls, a list of the messages used to control the combo box strongly resembles a merged list of the messages for the two base controls. CB_ADDSTRING, CB_INSERTSTRING, and CB_FINDSTRING act like their list box cousins. Likewise the CB_SETEDITSELECT and CB_GETEDITSELECT messages set and query the selected characters in the edit box of a drop-down or a drop-down list combo box. To control the drop-down state of a drop-down or drop-down list combo box, the messages CB_SHOWDROPDOWN and CB_GETDROPPEDSTATE can be used.

<P>As in the case of the list box, Windows CE doesn't support owner-draw combo boxes. However, the combo box supports the CBS_EX_CONSTSTRINGDATA extended style, which instructs the combo box to store a pointer to the string for an item instead of the string itself. As with the list box LBS_EX_CONSTSTRINGDATA style, this procedure can save RAM if an application has a large array of strings stored in ROM because the combo box won't maintain a separate copy of the list of strings.

<A NAME="126"><H2>Static Controls</H2></A>

<P>Static controls are windows that display text, icons, or bitmaps not intended for user interaction. You can use static text controls to label other controls in a window. What a static control displays is defined by the text and the style for the control Under Windows CE, static controls support the following styles:

<UL>
<p><LI><I>SS_LEFT</I> Displays a line of left-aligned text. The text is wrapped, if necessary, to fit inside the control.
<p><LI><I>SS_CENTER</I> Displays a line of text centered in the control. The text is wrapped, if necessary, to fit inside the control.
<p><LI><I>SS_RIGHT</I> Displays a line of text aligned with the right side of the control. The text is wrapped, if necessary, to fit inside the control.
<p><LI><I>SS_LEFTNOWORDWRAP</I> Displays a line of left-aligned text. The text isn't wrapped to multiple lines. Any text extending beyond the right side of the control is clipped.
<p><LI><I>SS_BITMAP</I> Displays a bitmap. Window text for the control specifies the name of the resource containing the bitmap.
<p><LI><I>SS_ICON</I> Displays an icon. Window text for the control specifies the name of the resource containing the icon.
</UL>

<P>Static controls with the SS_NOTIFY style send a WM_COMMAND message when the control is clicked, enabled, or disabled, although the Windows CE version of the static control doesn't send a notification when it's double-clicked. The SS_CENTERIMAGE style, used in combination with the SS_BITMAP or SS_ICON style, centers the image within the control. The SS_NOPREFIX style can be used in combination with the text styles. It prevents the ampersand (&amp;) character from being interpreted as indicating the next character is an accelerator character.

<P>Windows CE doesn't support static controls that display filled or hollow rectangles such as those drawn with the SS_WHITEFRAME or SS_BLACKRECT styles. Also, Windows CE doesn't support owner-draw static controls.

<A NAME="127"><H2>The Scroll Bar Control</H2></A>

<P>The scroll bar control operates identically to the window scroll bars described previously with the exception that the <I>fnBar</I> field used in <I>SetScrollInfo</I> and <I>GetScrollInfo</I> must be set to SB_CTL. The <I>hwnd</I> field then must be set to the handle of the scroll bar control, not to the window that owns the scroll bar. Like window scroll bars, the owner of the scroll bar is responsible for fielding the scroll messages WM_VSCROLL and WM_HSCROLL and setting the new position of the scroll bar in response to these messages.

<A NAME="128"><H2>The CtlView Example Program</H2></A>

<P>The CtlView example program, shown in Figure 4-5, demonstrates all the controls I've just described. The example makes use of several application-defined child windows that contain various controls. You switch between the different child windows by clicking on one of five radio buttons displayed across the top of the main window. As each of the controls reports a notification through a WM_COMMAND message, that notification is displayed in a list box on the right side of the window. CtlView is handy for observing just what messages a control sends to its parent window and when they're sent. One problem with CtlView is that it's designed for an H/PC screen, not a Palm-size PC screen. If you run CtlView on a Palm-size PC, you'll see that the controls don't all fit onto the small Palm-size PC screen.

<P><B>Figure 4-5.</B> <I>The CtlView program.</I>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="129"><H3>CtlView.rc</H3></A>
<p><pre>
//======================================================================
// Resource file
//

// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================

#include &quot;CtlView.h&quot;                 // Program-specific stuff

ID_ICON      ICON   &quot;CtlView.ico&quot;    // Program icon
TEXTICON     ICON   &quot;btnicon.ico&quot;    // Icon used in static window
STATICBMP    BITMAP &quot;statbmp.bmp&quot;    // Bitmap used in static window
</pre>
</td></tr></table>


<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="130"><H3>CtlView.h</H3></A>
<p><pre>
//======================================================================
// Header file

//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
// Returns number of elements
#define dim(x) (sizeof(x) / sizeof(x[0]))
//----------------------------------------------------------------------
// Generic defines and data types
//
struct decodeUINT {                             // Structure associates
    UINT Code;                                  // messages
                                                // with a function.
    LRESULT (*Fxn)(HWND, UINT, WPARAM, LPARAM);
};
struct decodeCMD {                              // Structure associates
    UINT Code;                                  // menu IDs with a
    LRESULT (*Fxn)(HWND, WORD, HWND, WORD);     // function.
};

//----------------------------------------------------------------------
// Generic defines used by application
#define  IDI_BTNICON        20                  // Icon used on button

#define  ID_ICON            1                   // Icon ID
#define  IDC_CMDBAR         2                   // Command bar ID
#define  IDC_RPTLIST        3                   // Report window ID

// Client window IDs go from 5 through 9.
#define  IDC_WNDSEL         5                   // Starting client
                                                // window IDs

// Radio button IDs go from 10 through 14.
#define  IDC_RADIOBTNS      10                  // Starting ID of
                                                // radio buttons

// Button window defines
#define  IDC_PUSHBTN   100
#define  IDC_CHKBOX    101
#define  IDC_ACHKBOX   102
#define  IDC_A3STBOX   103
#define  IDC_RADIO1    104
#define  IDC_RADIO2    105
#define  IDC_OWNRDRAW  106

// Edit window defines
#define  IDC_SINGLELINE 100
#define  IDC_MULTILINE  101
#define  IDC_PASSBOX    102

// List box window defines
#define  IDC_COMBOBOX   100
#define  IDC_SNGLELIST  101
#define  IDC_MULTILIST  102

// Static control window defines
#define  IDC_LEFTTEXT   100
#define  IDC_RIGHTTEXT  101
#define  IDC_CENTERTEXT 102
#define  IDC_ICONCTL    103
#define  IDC_BITMAPCTL  104

// Scroll bar window defines
#define  IDC_LRSCROLL   100
#define  IDC_UDSCROLL   101

// User defined message to add a line to the window
#define MYMSG_ADDLINE   (WM_USER + 10)

typedef struct {
    TCHAR *szClass;
    INT   nID;
    TCHAR *szTitle;
    INT   x;
    INT   y;
    INT   cx;
    INT   cy;
    DWORD lStyle;
} CTLWNDSTRUCT, *PCTLWNDSTRUCT;

typedef struct {
    WORD wMsg;
    INT nID;
    WPARAM wParam;
    LPARAM lParam;
} CTLMSG, * PCTLMSG;

typedef struct {
    TCHAR *pszLabel;
    WORD wNotification;
} NOTELABELS, *PNOTELABELS;

//----------------------------------------------------------------------
// Function prototypes
//
int InitApp (HINSTANCE);
HWND InitInstance (HINSTANCE, LPWSTR, int);
int TermInstance (HINSTANCE, int);

// Window procedures
LRESULT CALLBACK FrameWndProc (HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK ClientWndProc (HWND, UINT, WPARAM, LPARAM);

// Message handlers
LRESULT DoCreateFrame (HWND, UINT, WPARAM, LPARAM);
LRESULT DoCommandFrame (HWND, UINT, WPARAM, LPARAM);
LRESULT DoAddLineFrame (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDestroyFrame (HWND, UINT, WPARAM, LPARAM);

//----------------------------------------------------------------------
// Window prototypes and defines for BtnWnd
//
#define BTNWND    TEXT (&quot;ButtonWnd&quot;)
int InitBtnWnd (HINSTANCE);

// Window procedures
LRESULT CALLBACK BtnWndProc (HWND, UINT, WPARAM, LPARAM);

LRESULT DoCreateBtnWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoCtlColorBtnWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoCommandBtnWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDrawItemBtnWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoMeasureItemBtnWnd (HWND, UINT, WPARAM, LPARAM);

//----------------------------------------------------------------------
// Window prototypes and defines for EditWnd
//
#define EDITWND    TEXT (&quot;EditWnd&quot;)
int InitEditWnd (HINSTANCE);

// Window procedures
LRESULT CALLBACK EditWndProc (HWND, UINT, WPARAM, LPARAM);

LRESULT DoCreateEditWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoCommandEditWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDrawItemEditWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoMeasureItemEditWnd (HWND, UINT, WPARAM, LPARAM);

//----------------------------------------------------------------------
// Window prototypes and defines for ListWnd
//
#define LISTWND    TEXT (&quot;ListWnd&quot;)
int InitListWnd (HINSTANCE);

// Window procedures
LRESULT CALLBACK ListWndProc (HWND, UINT, WPARAM, LPARAM);

LRESULT DoCreateListWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoCommandListWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDrawItemListWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoMeasureItemListWnd (HWND, UINT, WPARAM, LPARAM);

//----------------------------------------------------------------------
// Window prototypes and defines for StatWnd
//
#define STATWND    TEXT (&quot;StaticWnd&quot;)
int InitStatWnd (HINSTANCE);

// Window procedures
LRESULT CALLBACK StatWndProc (HWND, UINT, WPARAM, LPARAM);

LRESULT DoCreateStatWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoCommandStatWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoDrawItemStatWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoMeasureItemStatWnd (HWND, UINT, WPARAM, LPARAM);

//----------------------------------------------------------------------
// Window prototypes and defines ScrollWnd
//
#define SCROLLWND    TEXT (&quot;ScrollWnd&quot;)
int InitScrollWnd (HINSTANCE);

// Window procedures
LRESULT CALLBACK ScrollWndProc (HWND, UINT, WPARAM, LPARAM);

LRESULT DoCreateScrollWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoVScrollScrollWnd (HWND, UINT, WPARAM, LPARAM);
LRESULT DoHScrollScrollWnd (HWND, UINT, WPARAM, LPARAM);
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="131"><H3>CtlView.c</H3></A>
<p><pre>
//======================================================================

// CtlView - Lists the available fonts in the system.
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &lt;commctrl.h&gt;                // Command bar includes
#include &quot;CtlView.h&quot;                 // Program-specific stuff

//----------------------------------------------------------------------
// Global data
//
const TCHAR szAppName[] = TEXT (&quot;CtlView&quot;);
HINSTANCE hInst;                     // Program instance handle

// Message dispatch table for FrameWindowProc
const struct decodeUINT FrameMessages[] = {
    WM_CREATE, DoCreateFrame,
    WM_COMMAND, DoCommandFrame,
    MYMSG_ADDLINE, DoAddLineFrame,
    WM_DESTROY, DoDestroyFrame,
};

typedef struct {
    TCHAR *szTitle;
    INT   nID;
    TCHAR *szCtlWnds;
    HWND  hWndClient;
} RBTNDATA;

// Text for main window radio buttons
TCHAR *szBtnTitle[] = {TEXT (&quot;Buttons&quot;), TEXT (&quot;Edit&quot;), TEXT (&quot;List&quot;),
                       TEXT (&quot;Static&quot;), TEXT (&quot;Scroll&quot;)};
// Class names for child windows containing controls
TCHAR *szCtlWnds[] = {BTNWND, EDITWND, LISTWND, STATWND, SCROLLWND};

INT nWndSel = 0;

//HWND hwndVisClient = 0;
//======================================================================
// Program entry point
//
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    LPWSTR lpCmdLine, int nCmdShow) {
    MSG msg;
    int rc = 0;
    HWND hwndFrame;

    // Initialize application.
    rc = InitApp (hInstance);
    if (rc) return rc;

    // Initialize this instance.
    hwndFrame = InitInstance (hInstance, lpCmdLine, nCmdShow);
    if (hwndFrame == 0)
        return 0x10;

    // Application message loop
    while (GetMessage (&amp;msg, NULL, 0, 0)) {
        TranslateMessage (&amp;msg);
        DispatchMessage (&amp;msg);
    }
    // Instance cleanup
    return TermInstance (hInstance, msg.wParam);
}

//----------------------------------------------------------------------
// InitApp - Application initialization
//
int InitApp (HINSTANCE hInstance) {
    WNDCLASS wc;

    // Register application frame window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = FrameWndProc;            // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetSysColorBrush (COLOR_STATIC);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = szAppName;             // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    // Initialize client window classes
    if (InitBtnWnd (hInstance) != 0) return 2;
    if (InitEditWnd (hInstance) != 0) return 2;
    if (InitListWnd (hInstance) != 0) return 2;
    if (InitStatWnd (hInstance) != 0) return 2;
    if (InitScrollWnd (hInstance) != 0) return 2;
    return 0;
}
//----------------------------------------------------------------------
// InitInstance - Instance initialization
//
HWND InitInstance (HINSTANCE hInstance, LPWSTR lpCmdLine, int nCmdShow) {
    HWND hWnd;

    // Save program instance handle in global variable.
    hInst = hInstance;

    // Create frame window.
    hWnd = CreateWindow (szAppName,             // Window class
                         TEXT (&quot;Control View&quot;), // Window title
                         WS_VISIBLE,            // Style flags
                         CW_USEDEFAULT,         // x position
                         CW_USEDEFAULT,         // y position
                         CW_USEDEFAULT,         // Initial width
                         CW_USEDEFAULT,         // Initial height
                         NULL,                  // Parent
                         NULL,                  // Menu, must be null
                         hInstance,             // Application instance
                         NULL);                 // Pointer to create
                                                // parameters
    // Return fail code if window not created.
    if (!IsWindow (hWnd)) return 0;

    // Standard show and update calls
    ShowWindow (hWnd, nCmdShow);
    UpdateWindow (hWnd);

    return hWnd;
}
//----------------------------------------------------------------------
// TermInstance - Program cleanup
//
int TermInstance (HINSTANCE hInstance, int nDefRC) {

    return nDefRC;
}
//======================================================================
// Message handling procedures for FrameWindow
//
//----------------------------------------------------------------------
// FrameWndProc - Callback function for application window
//
LRESULT CALLBACK FrameWndProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                               LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(FrameMessages); i++) {
        if (wMsg == FrameMessages[i].Code)
            return (*FrameMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateFrame - Process WM_CREATE message for window.
//
LRESULT DoCreateFrame (HWND hWnd, UINT wMsg, WPARAM wParam,
                       LPARAM lParam) {
    LPCREATESTRUCT lpcs;
    HWND hwndCB, hwndChild;
    INT sHeight, i, x, y, cx, cy;

    // Convert lParam into pointer to create struct.
    lpcs = (LPCREATESTRUCT) lParam;
    x = lpcs-&gt;x;
    y = lpcs-&gt;y;
    cx = lpcs-&gt;cx;
    cy = lpcs-&gt;cy;
    nWndSel = 0;
    // Create a command bar.
    hwndCB = CommandBar_Create (hInst, hWnd, IDC_CMDBAR);
    // Add exit button to command bar.
    CommandBar_AddAdornments (hwndCB, 0, 0);
    sHeight = CommandBar_Height (GetDlgItem (hWnd, IDC_CMDBAR));

    // Create the radio buttons.
    for (i = 0; i &lt; dim(szBtnTitle); i++) {
        hwndChild = CreateWindow (TEXT (&quot;BUTTON&quot;),
                                 szBtnTitle[i], BS_AUTORADIOBUTTON |
                                 WS_VISIBLE | WS_CHILD,
                                 10 + (i * 85), sHeight,
                                 80, 23, hWnd, (HMENU)(IDC_RADIOBTNS+i),
                                 hInst, NULL);

        // Destroy frame if window not created.
        if (!IsWindow (hwndChild)) {
            DestroyWindow (hWnd);
            break;
        }
    }
    //
    // Create report window.  Size it so that it fits under
    // the command bar and fills the remaining client area.
    //
    hwndChild = CreateWindowEx (WS_EX_CLIENTEDGE, TEXT (&quot;listbox&quot;),
                         TEXT (&quot;&quot;), WS_VISIBLE | WS_CHILD | WS_VSCROLL |
                         LBS_USETABSTOPS | LBS_NOINTEGRALHEIGHT,
                         cx/2, y + sHeight + 25,
                         cx/2, cy - sHeight - 25,
                         hWnd, (HMENU)IDC_RPTLIST,
                         hInst, NULL);

    // Destroy frame if window not created.
    if (!IsWindow (hwndChild)) {
        DestroyWindow (hWnd);
        return 0;
    }

    // Initialize tab stops for display list box.
    i = 25;
    SendMessage (hwndChild, LB_SETTABSTOPS, 1, (LPARAM)&amp;i);

    //
    // Create the child windows.  Size them so that they fit under
    // the command bar and fill the left side of the child area.
    //
    for (i = 0; i &lt; dim(szCtlWnds); i++) {
        hwndChild = CreateWindowEx (WS_EX_CLIENTEDGE,
                             szCtlWnds[i],
                             TEXT (&quot;&quot;), WS_CHILD,
                             x, y + sHeight + 25,
                             cx/2, cy - sHeight - 25,
                             hWnd, (HMENU)(IDC_WNDSEL+i),
                             hInst, NULL);
        // Destroy frame if client window not created.
        if (!IsWindow (hwndChild)) {
            DestroyWindow (hWnd);
            return 0;
        }
    }
    // Check one of the auto radio buttons.
    SendDlgItemMessage (hWnd, IDC_RADIOBTNS+nWndSel, BM_SETCHECK, 1, 0);
    hwndChild = GetDlgItem (hWnd, IDC_WNDSEL+nWndSel);
    ShowWindow (hwndChild, SW_SHOW);
    return 0;
}
//----------------------------------------------------------------------
// DoCommandFrame - Process WM_COMMAND message for window.
//
LRESULT DoCommandFrame (HWND hWnd, UINT wMsg, WPARAM wParam,
                        LPARAM lParam) {
    HWND hwndTemp;
    int nBtn;
    // Don't look at list box messages.
    if (LOWORD (wParam) == IDC_RPTLIST)
        return 0;
    nBtn = LOWORD (wParam) - IDC_RADIOBTNS;
    if (nWndSel != nBtn) {

        // Hide the currently visible window.
        hwndTemp = GetDlgItem (hWnd, IDC_WNDSEL+nWndSel);
        ShowWindow (hwndTemp, SW_HIDE);

        // Save the current selection.
        nWndSel = nBtn;

        // Show the window selected via the radio button.
        hwndTemp = GetDlgItem (hWnd, IDC_WNDSEL+nWndSel);
        ShowWindow (hwndTemp, SW_SHOW);
    }
    return 0;
}
//----------------------------------------------------------------------
// DoAddLineFrame - Process MYMSG_ADDLINE message for window.
//
LRESULT DoAddLineFrame (HWND hWnd, UINT wMsg, WPARAM wParam,
                        LPARAM lParam) {
    TCHAR szOut[128];
    INT i;

    if (LOWORD (wParam) == 0xffff)
        wsprintf (szOut, TEXT (&quot;      \t %s&quot;), (LPTSTR)lParam);
    else
        wsprintf (szOut, TEXT (&quot;id:%x \t %s&quot;), LOWORD (wParam),
                  (LPTSTR)lParam);


    i = SendDlgItemMessage (hWnd, IDC_RPTLIST, LB_ADDSTRING, 0,
                            (LPARAM)(LPCTSTR)szOut);

    if (i != LB_ERR)
        SendDlgItemMessage (hWnd, IDC_RPTLIST, LB_SETTOPINDEX, i,
                            (LPARAM)(LPCTSTR)szOut);
    return 0;
}
//----------------------------------------------------------------------
// DoDestroyFrame - Process WM_DESTROY message for window.
//
LRESULT DoDestroyFrame (HWND hWnd, UINT wMsg, WPARAM wParam,
                        LPARAM lParam) {
    PostQuitMessage (0);
    return 0;
}
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="132"><H3>BtnWnd.c</H3></A>
<p><pre>

//======================================================================
// BtnWnd - Button window code
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &quot;Ctlview.h&quot;                 // Program-specific stuff

extern HINSTANCE hInst;

LRESULT DrawButton (HWND hWnd, LPDRAWITEMSTRUCT pdi);
//----------------------------------------------------------------------
// Global data
//

// Message dispatch table for BtnWndWindowProc
const struct decodeUINT BtnWndMessages[] = {
    WM_CREATE, DoCreateBtnWnd,
    WM_CTLCOLORSTATIC, DoCtlColorBtnWnd,
    WM_COMMAND, DoCommandBtnWnd,
    WM_DRAWITEM, DoDrawItemBtnWnd,
};

// Structure defining the controls in the window
CTLWNDSTRUCT  Btns [] = {
    {TEXT (&quot;BUTTON&quot;), IDC_PUSHBTN, TEXT (&quot;Button&quot;),
     10,  10, 120,  23, BS_PUSHBUTTON | BS_NOTIFY},
    {TEXT (&quot;BUTTON&quot;), IDC_CHKBOX, TEXT (&quot;Check box&quot;),
     10,  35, 120,  23, BS_CHECKBOX},
    {TEXT (&quot;BUTTON&quot;), IDC_ACHKBOX, TEXT (&quot;Auto check box&quot;),
     10,  60, 120,  23, BS_AUTOCHECKBOX},
    {TEXT (&quot;BUTTON&quot;), IDC_A3STBOX, TEXT (&quot;Auto 3-state box&quot;),
     10,  85, 120,  23, BS_AUTO3STATE},
    {TEXT (&quot;BUTTON&quot;), IDC_RADIO1, TEXT (&quot;Auto radio button 1&quot;),
     10, 110, 120,  23, BS_AUTORADIOBUTTON},
    {TEXT (&quot;BUTTON&quot;), IDC_RADIO2, TEXT (&quot;Auto radio button 2&quot;),
     10, 135, 120,  23, BS_AUTORADIOBUTTON},
    {TEXT (&quot;BUTTON&quot;), IDC_OWNRDRAW, TEXT (&quot;OwnerDraw&quot;),
     150,  10,  44,  44, BS_PUSHBUTTON | BS_OWNERDRAW},
};
// Structure labeling the button control WM_COMMAND notifications
NOTELABELS nlBtn[] = {{TEXT (&quot;BN_CLICKED &quot;),      0},
                      {TEXT (&quot;BN_PAINT   &quot;),      1},
                      {TEXT (&quot;BN_HILITE  &quot;),      2},
                      {TEXT (&quot;BN_UNHILITE&quot;),      3},
                      {TEXT (&quot;BN_DISABLE &quot;),      4},
                      {TEXT (&quot;BN_DOUBLECLICKED&quot;), 5},
                      {TEXT (&quot;BN_SETFOCUS &quot;),     6},
                      {TEXT (&quot;BN_KILLFOCUS&quot;),     7}
};

// Handle for icon used in owner-draw icon
HICON hIcon = 0;
//----------------------------------------------------------------------
// InitBtnWnd - BtnWnd window initialization
//
int InitBtnWnd (HINSTANCE hInstance) {
    WNDCLASS wc;

    // Register application BtnWnd window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = BtnWndProc;              // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = BTNWND;                // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    return 0;
}

//======================================================================
// Message handling procedures for BtnWindow
//----------------------------------------------------------------------
// BtnWndWndProc - Callback function for application window
//
LRESULT CALLBACK BtnWndProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                             LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(BtnWndMessages); i++) {
        if (wMsg == BtnWndMessages[i].Code)
            return (*BtnWndMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateBtnWnd - Process WM_CREATE message for window.
//
LRESULT DoCreateBtnWnd (HWND hWnd, UINT wMsg, WPARAM wParam,
                        LPARAM lParam) {
    INT i;

    for (i = 0; i &lt; dim(Btns); i++) {

        CreateWindow (Btns[i].szClass, Btns[i].szTitle,
                      Btns[i].lStyle | WS_VISIBLE | WS_CHILD,
                      Btns[i].x, Btns[i].y, Btns[i].cx, Btns[i].cy,
                      hWnd, (HMENU) Btns[i].nID, hInst, NULL);
    }
    hIcon = LoadIcon (hInst, TEXT (&quot;TEXTICON&quot;));

    // We need to set the initial state of the radio buttons.
    CheckRadioButton (hWnd, IDC_RADIO1, IDC_RADIO2, IDC_RADIO1);
    return 0;
}
//----------------------------------------------------------------------
// DoCtlColorBtnWnd - process WM_CTLCOLORxx messages for window.
//
LRESULT DoCtlColorBtnWnd (HWND hWnd, UINT wMsg, WPARAM wParam, 
                          LPARAM lParam) {
    return GetStockObject (WHITE_BRUSH);
}
//----------------------------------------------------------------------
// DoCommandBtnWnd - Process WM_COMMAND message for window.
//
LRESULT DoCommandBtnWnd (HWND hWnd, UINT wMsg, WPARAM wParam,
                         LPARAM lParam) {
    TCHAR szOut[128];
    INT i;

    // Since the Check Box button is not an auto check box, it
    // must be set manually.
    if ((LOWORD (wParam) == IDC_CHKBOX) &amp;&amp;
        (HIWORD (wParam) == BN_CLICKED)) {
        // Get the current state, complement, and set.
        i = SendDlgItemMessage (hWnd, IDC_CHKBOX, BM_GETCHECK, 0, 0);
        if (i == 0)
            SendDlgItemMessage (hWnd, IDC_CHKBOX, BM_SETCHECK, 1, 0);
        else
            SendDlgItemMessage (hWnd, IDC_CHKBOX, BM_SETCHECK, 0, 0);
    }

    // Report WM_COMMAND messages to main window.
    for (i = 0; i &lt; dim(nlBtn); i++) {
        if (HIWORD (wParam) == nlBtn[i].wNotification) {
            lstrcpy (szOut, nlBtn[i].pszLabel);
            break;
        }
    }
    if (i == dim(nlBtn))
        wsprintf (szOut, TEXT (&quot;notification: %x&quot;), HIWORD (wParam));

    SendMessage (GetParent (hWnd), MYMSG_ADDLINE, wParam,
                 (LPARAM)szOut);
    return 0;
}
//----------------------------------------------------------------------
// DoDrawItemBtnWnd - Process WM_DRAWITEM message for window.
//
LRESULT DoDrawItemBtnWnd (HWND hWnd, UINT wMsg, WPARAM wParam,
                          LPARAM lParam) {

    return DrawButton (hWnd, (LPDRAWITEMSTRUCT)lParam);
}

//---------------------------------------------------------------------
// DrawButton - Draws an owner-draw button
//
LRESULT DrawButton (HWND hWnd, LPDRAWITEMSTRUCT pdi) {

    HPEN hPenShadow, hPenLight, hPenDkShadow, hOldPen;

    HBRUSH hBr, hOldBr;
    LOGPEN lpen;
    TCHAR szOut[128];
    POINT ptOut[3], ptIn[3];

    // Reflect the messages to the report window.
    wsprintf (szOut, TEXT (&quot;WM_DRAWITEM  Action:%x  State:%x&quot;),
              pdi-&gt;itemAction, pdi-&gt;itemState);
    SendMessage (GetParent (hWnd), MYMSG_ADDLINE, pdi-&gt;CtlID,
                 (LPARAM)szOut);

    // Create pens for drawing.
    lpen.lopnStyle = PS_SOLID;
    lpen.lopnWidth.x = 3;
    lpen.lopnWidth.y = 3;
    lpen.lopnColor = GetSysColor (COLOR_3DSHADOW);
    hPenShadow = CreatePenIndirect (&amp;lpen);
    lpen.lopnWidth.x = 1;
    lpen.lopnWidth.y = 1;
    lpen.lopnColor = GetSysColor (COLOR_3DLIGHT);
    hPenLight = CreatePenIndirect (&amp;lpen);

    lpen.lopnColor = GetSysColor (COLOR_3DDKSHADOW);
    hPenDkShadow = CreatePenIndirect (&amp;lpen);

    // Create a brush for the face of the button.
    hBr = CreateSolidBrush (GetSysColor (COLOR_3DFACE));

    // Draw a rectangle with a thick outside border to start the
    // frame drawing.
    hOldPen = SelectObject (pdi-&gt;hDC, hPenShadow);
    hOldBr = SelectObject (pdi-&gt;hDC, hBr);
    Rectangle (pdi-&gt;hDC, pdi-&gt;rcItem.left, pdi-&gt;rcItem.top,
               pdi-&gt;rcItem.right, pdi-&gt;rcItem.bottom);

    // Draw the upper left inside line.
    ptIn[0].x = pdi-&gt;rcItem.left + 1;
    ptIn[0].y = pdi-&gt;rcItem.bottom - 2;
    ptIn[1].x = pdi-&gt;rcItem.left + 1;
    ptIn[1].y = pdi-&gt;rcItem.top + 1;
    ptIn[2].x = pdi-&gt;rcItem.right - 2;
    ptIn[2].y = pdi-&gt;rcItem.top+1;

    // Select a pen to draw shadow or light side of button.
    if (pdi-&gt;itemState &amp; ODS_SELECTED) {
        SelectObject (pdi-&gt;hDC, hPenDkShadow);
    }  else {
        SelectObject (pdi-&gt;hDC, hPenLight);
    }
    Polyline (pdi-&gt;hDC, ptIn, 3);

    // If selected, also draw a bright line inside the lower
    // right corner.
    if (pdi-&gt;itemState &amp; ODS_SELECTED) {
        SelectObject (pdi-&gt;hDC, hPenLight);
        ptIn[1].x = pdi-&gt;rcItem.right- 2;
        ptIn[1].y = pdi-&gt;rcItem.bottom - 2;
        Polyline (pdi-&gt;hDC, ptIn, 3);
    }

    // Now draw the black outside line on either the upper left or lower
    // right corner.
    ptOut[0].x = pdi-&gt;rcItem.left;
    ptOut[0].y = pdi-&gt;rcItem.bottom-1;
    ptOut[2].x = pdi-&gt;rcItem.right-1;
    ptOut[2].y = pdi-&gt;rcItem.top;

    SelectObject (pdi-&gt;hDC, hPenDkShadow);
    if (pdi-&gt;itemState &amp; ODS_SELECTED) {
        ptOut[1].x = pdi-&gt;rcItem.left;
        ptOut[1].y = pdi-&gt;rcItem.top;
    }  else {
        ptOut[1].x = pdi-&gt;rcItem.right-1;
        ptOut[1].y = pdi-&gt;rcItem.bottom-1;
    }
    Polyline (pdi-&gt;hDC, ptOut, 3);

    // Draw the icon.
    if (hIcon) {
        ptIn[0].x = (pdi-&gt;rcItem.right - pdi-&gt;rcItem.left)/2 -
                     GetSystemMetrics (SM_CXICON)/2 - 2;
        ptIn[0].y = (pdi-&gt;rcItem.bottom - pdi-&gt;rcItem.top)/2 -
                     GetSystemMetrics (SM_CYICON)/2 - 2;
        // If pressed, shift image down one pel to simulate depress.
        if (pdi-&gt;itemState &amp; ODS_SELECTED) {
            ptOut[1].x += 2;
            ptOut[1].y += 2;
        }
        DrawIcon (pdi-&gt;hDC, ptIn[0].x, ptIn[0].y, hIcon);
    }

    // If button has the focus, draw the dotted rect inside the button.
    if (pdi-&gt;itemState &amp; ODS_FOCUS) {
        pdi-&gt;rcItem.left += 3;
        pdi-&gt;rcItem.top += 3;
        pdi-&gt;rcItem.right -= 4;
        pdi-&gt;rcItem.bottom -= 4;
        DrawFocusRect (pdi-&gt;hDC, &amp;pdi-&gt;rcItem);
    }

    // Clean up. First select the original brush and pen into the DC.
    SelectObject (pdi-&gt;hDC, hOldBr);
    SelectObject (pdi-&gt;hDC, hOldPen);

    // Now delete the brushes and pens created.
    DeleteObject (hBr);
    DeleteObject (hPenShadow);
    DeleteObject (hPenDkShadow);
    DeleteObject (hPenLight);
    return 0;
}
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="133"><H3>EditWnd.c</H3></A>

<p><pre>
//======================================================================
// EditWnd - Edit control window code
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &quot;Ctlview.h&quot;                 // Program-specific stuff

extern HINSTANCE hInst;
//----------------------------------------------------------------------
// Global data
//
// Message dispatch table for EditWndWindowProc
const struct decodeUINT EditWndMessages[] = {
    WM_CREATE, DoCreateEditWnd,
    WM_COMMAND, DoCommandEditWnd,
};

// Structure defining the controls in the window
CTLWNDSTRUCT  Edits[] = {
    {TEXT (&quot;edit&quot;), IDC_SINGLELINE, TEXT (&quot;Single line edit control&quot;),
     10,  10, 130,  23, ES_AUTOHSCROLL},

    {TEXT (&quot;edit&quot;), IDC_MULTILINE, TEXT (&quot;Multi line edit control&quot;),
     10,  35, 130,  90, ES_MULTILINE | ES_AUTOVSCROLL},

    {TEXT (&quot;edit&quot;), IDC_PASSBOX, TEXT (&quot;&quot;),
     10, 127, 130,  23, ES_PASSWORD},
};
// Structure labeling the edit control WM_COMMAND notifications
NOTELABELS nlEdit[] = {{TEXT (&quot;EN_SETFOCUS &quot;), 0x0100},
                       {TEXT (&quot;EN_KILLFOCUS&quot;), 0x0200},
                       {TEXT (&quot;EN_CHANGE   &quot;), 0x0300},
                       {TEXT (&quot;EN_UPDATE   &quot;), 0x0400},
                       {TEXT (&quot;EN_ERRSPACE &quot;), 0x0500},
                       {TEXT (&quot;EN_MAXTEXT  &quot;), 0x0501},
                       {TEXT (&quot;EN_HSCROLL  &quot;), 0x0601},
                       {TEXT (&quot;EN_VSCROLL  &quot;), 0x0602},
};
//----------------------------------------------------------------------
// InitEditWnd - EditWnd window initialization
//
int InitEditWnd (HINSTANCE hInstance) {
    WNDCLASS wc;

    // Register application EditWnd window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = EditWndProc;             // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = EDITWND;               // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    return 0;
}
//======================================================================
// Message handling procedures for EditWindow
//----------------------------------------------------------------------
// EditWndWndProc - Callback function for application window
//
LRESULT CALLBACK EditWndProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                              LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(EditWndMessages); i++) {
        if (wMsg == EditWndMessages[i].Code)
            return (*EditWndMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateEditWnd - Process WM_CREATE message for window.
//
LRESULT DoCreateEditWnd (HWND hWnd, UINT wMsg, WPARAM wParam,
                         LPARAM lParam) {
    INT i;

    for (i = 0; i &lt; dim(Edits); i++) {

        CreateWindow (Edits[i].szClass, Edits[i].szTitle,
                      Edits[i].lStyle | WS_VISIBLE | WS_CHILD | WS_BORDER,
                      Edits[i].x, Edits[i].y, Edits[i].cx, Edits[i].cy,
                      hWnd, (HMENU) Edits[i].nID, hInst, NULL);
    }
    return 0;
}
//----------------------------------------------------------------------
// DoCommandEditWnd - Process WM_COMMAND message for window.
//
LRESULT DoCommandEditWnd (HWND hWnd, UINT wMsg, WPARAM wParam,
                          LPARAM lParam) {
    TCHAR szOut[128];
    INT i;

    for (i = 0; i &lt; dim(nlEdit); i++) {
        if (HIWORD (wParam) == nlEdit[i].wNotification) {
            lstrcpy (szOut, nlEdit[i].pszLabel);
            break;
        }
    }

    if (i == dim(nlEdit))
        wsprintf (szOut, TEXT (&quot;notification: %x&quot;), HIWORD (wParam));

    SendMessage (GetParent (hWnd), MYMSG_ADDLINE, wParam,
                 (LPARAM)szOut);
    return 0;
}
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td valign="top">

<A NAME="134"><H3>ListWnd.c</H3></A>
<p><pre>
//======================================================================
// ListWnd - List box control window code
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &quot;Ctlview.h&quot;                 // Program-specific stuff

extern HINSTANCE hInst;
//----------------------------------------------------------------------
// Global data
//
// Message dispatch table for ListWndWindowProc
const struct decodeUINT ListWndMessages[] = {
    WM_CREATE, DoCreateListWnd,
    WM_COMMAND, DoCommandListWnd,
};

// Structure defining the controls in the window
CTLWNDSTRUCT  Lists[] = {
    {TEXT (&quot;combobox&quot;), IDC_COMBOBOX, TEXT (&quot;&quot;), 10,  10, 170, 100,
     WS_VSCROLL},

    {TEXT (&quot;Listbox&quot;), IDC_SNGLELIST, TEXT (&quot;&quot;),   10,  35, 100, 120,
     WS_VSCROLL | LBS_NOTIFY},

    {TEXT (&quot;Listbox&quot;), IDC_MULTILIST, TEXT (&quot;&quot;), 115,  35, 100, 120,
     WS_VSCROLL | LBS_EXTENDEDSEL | LBS_NOTIFY}
};
// Structure labeling the list box control WM_COMMAND notifications
NOTELABELS nlList[] = {{TEXT (&quot;LBN_ERRSPACE &quot;), (-2)},
                       {TEXT (&quot;LBN_SELCHANGE&quot;), 1},
                       {TEXT (&quot;LBN_DBLCLK   &quot;), 2},
                       {TEXT (&quot;LBN_SELCANCEL&quot;), 3},
                       {TEXT (&quot;LBN_SETFOCUS &quot;), 4},
                       {TEXT (&quot;LBN_KILLFOCUS&quot;), 5},
};
// Structure labeling the combo box control WM_COMMAND notifications
NOTELABELS nlCombo[] = {{TEXT (&quot;CBN_ERRSPACE    &quot;), (-1)},
                        {TEXT (&quot;CBN_SELCHANGE   &quot;), 1},
                        {TEXT (&quot;CBN_DBLCLK      &quot;), 2},
                        {TEXT (&quot;CBN_SETFOCUS    &quot;), 3},
                        {TEXT (&quot;CBN_KILLFOCUS   &quot;), 4},
                        {TEXT (&quot;CBN_EDITCHANGE  &quot;), 5},
                        {TEXT (&quot;CBN_EDITUPDATE  &quot;), 6},
                        {TEXT (&quot;CBN_DROPDOWN    &quot;), 7},
                        {TEXT (&quot;CBN_CLOSEUP     &quot;), 8},
                        {TEXT (&quot;CBN_SELENDOK    &quot;), 9},
                        {TEXT (&quot;CBN_SELENDCANCEL&quot;), 10},
};
//----------------------------------------------------------------------
// InitListWnd - ListWnd window initialization
//
int InitListWnd (HINSTANCE hInstance) {
    WNDCLASS wc;

    // Register application ListWnd window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = ListWndProc;             // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = LISTWND;               // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    return 0;
}
//======================================================================
// Message handling procedures for ListWindow
//----------------------------------------------------------------------
// ListWndProc - Callback function for application window
//
LRESULT CALLBACK ListWndProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                              LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(ListWndMessages); i++) {
        if (wMsg == ListWndMessages[i].Code)
            return (*ListWndMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateListWnd - Process WM_CREATE message for window.
//
LRESULT DoCreateListWnd (HWND hWnd, UINT wMsg, WPARAM wParam,
                         LPARAM lParam) {
    INT i;
    TCHAR szOut[64];

    for (i = 0; i &lt; dim(Lists); i++) {

        CreateWindow (Lists[i].szClass, Lists[i].szTitle,
                      Lists[i].lStyle | WS_VISIBLE | WS_CHILD | WS_BORDER,
                      Lists[i].x, Lists[i].y, Lists[i].cx, Lists[i].cy,
                      hWnd, (HMENU) Lists[i].nID, hInst, NULL);
    }

    for (i = 0; i &lt; 20; i++) {
        wsprintf (szOut, TEXT (&quot;Item %d&quot;), i);
        SendDlgItemMessage (hWnd, IDC_SNGLELIST, LB_ADDSTRING, 0,
                            (LPARAM)szOut);

        SendDlgItemMessage (hWnd, IDC_MULTILIST, LB_ADDSTRING, 0,
                            (LPARAM)szOut);

        SendDlgItemMessage (hWnd, IDC_COMBOBOX, CB_ADDSTRING, 0,
                            (LPARAM)szOut);
    }
    // Set initial selection.
    SendDlgItemMessage (hWnd, IDC_COMBOBOX, CB_SETCURSEL, 0, 0);
    return 0;
}
//----------------------------------------------------------------------
// DoCommandListWnd - Process WM_COMMAND message for window.
//
LRESULT DoCommandListWnd (HWND hWnd, UINT wMsg, WPARAM wParam,
                          LPARAM lParam) {
    TCHAR szOut[128];
    INT i;

    if (LOWORD (wParam) == IDC_COMBOBOX) {
        for (i = 0; i &lt; dim(nlCombo); i++) {
            if (HIWORD (wParam) == nlCombo[i].wNotification) {
                lstrcpy (szOut, nlCombo[i].pszLabel);
                break;
            }
        }
        if (i == dim(nlList))
            wsprintf (szOut, TEXT (&quot;notification: %x&quot;), HIWORD (wParam));
    } else {
        for (i = 0; i &lt; dim(nlList); i++) {
            if (HIWORD (wParam) == nlList[i].wNotification) {
                lstrcpy (szOut, nlList[i].pszLabel);
                break;
            }
        }
        if (i == dim(nlList))
            wsprintf (szOut, TEXT (&quot;notification: %x&quot;), HIWORD (wParam));
    }
    SendMessage (GetParent (hWnd), MYMSG_ADDLINE, wParam,
                 (LPARAM)szOut);
    return 0;
}
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="135"><H3>StatWnd.c</H3></A>
<p><pre>
//======================================================================
// StatWnd - Static control window code
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff
#include &quot;Ctlview.h&quot;                 // Program-specific stuff


extern HINSTANCE hInst;
//----------------------------------------------------------------------
// Global data
//
// Message dispatch table for StatWndWindowProc
const struct decodeUINT StatWndMessages[] = {
    WM_CREATE, DoCreateStatWnd,
    WM_COMMAND, DoCommandStatWnd,
};

// Structure defining the controls in the window
CTLWNDSTRUCT  Stats [] = {
    {TEXT (&quot;static&quot;), IDC_LEFTTEXT, TEXT (&quot;Left text&quot;),
     10,  10, 120,  23, SS_LEFT | SS_NOTIFY},

    {TEXT (&quot;static&quot;), IDC_RIGHTTEXT, TEXT (&quot;Right text&quot;),
     10,  35, 120,  23, SS_RIGHT},

    {TEXT (&quot;static&quot;), IDC_CENTERTEXT, TEXT (&quot;Center text&quot;),
     10,  60, 120,  23, SS_CENTER | WS_BORDER},

    {TEXT (&quot;static&quot;), IDC_ICONCTL, TEXT (&quot;TEXTICON&quot;),
     10,  85, 120,  23, SS_ICON},

    {TEXT (&quot;static&quot;), IDC_BITMAPCTL, TEXT (&quot;STATICBMP&quot;),
     170,  10,  44,  44, SS_BITMAP | SS_NOTIFY},
};

// Structure labeling the static control WM_COMMAND notifications
NOTELABELS nlStatic[] = {{TEXT (&quot;STN_CLICKED&quot;), 0},
                         {TEXT (&quot;STN_ENABLE &quot;), 2},
                         {TEXT (&quot;STN_DISABLE&quot;), 3},
};
//----------------------------------------------------------------------
// InitStatWnd - StatWnd window initialization
//
int InitStatWnd (HINSTANCE hInstance) {
    WNDCLASS wc;

    // Register application StatWnd window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = StatWndProc;             // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = STATWND;               // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    return 0;
}
//======================================================================
// Message handling procedures for StatWindow
//----------------------------------------------------------------------
// StatWndProc - Callback function for application window
//
LRESULT CALLBACK StatWndProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                              LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(StatWndMessages); i++) {
        if (wMsg == StatWndMessages[i].Code)
            return (*StatWndMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateStatWnd - Process WM_CREATE message for window.
//
LRESULT DoCreateStatWnd (HWND hWnd, UINT wMsg, WPARAM wParam,
                         LPARAM lParam) {
    INT i;

    for (i = 0; i &lt; dim(Stats); i++) {

        CreateWindow (Stats[i].szClass, Stats[i].szTitle,
                      Stats[i].lStyle | WS_VISIBLE | WS_CHILD,
                      Stats[i].x, Stats[i].y, Stats[i].cx, Stats[i].cy,
                      hWnd, (HMENU) Stats[i].nID, hInst, NULL);
    }
    return 0;
}
//----------------------------------------------------------------------
// DoCommandStatWnd - Process WM_COMMAND message for window.
//
LRESULT DoCommandStatWnd (HWND hWnd, UINT wMsg, WPARAM wParam,
                          LPARAM lParam) {
    TCHAR szOut[128];
    INT i;

    for (i = 0; i &lt; dim(nlStatic); i++) {
        if (HIWORD (wParam) == nlStatic[i].wNotification) {
            lstrcpy (szOut, nlStatic[i].pszLabel);
            break;
        }
    }
    if (i == dim(nlStatic))
        wsprintf (szOut, TEXT (&quot;notification: %x&quot;), HIWORD (wParam));

    SendMessage (GetParent (hWnd), MYMSG_ADDLINE, wParam,
                 (LPARAM)szOut);
    return 0;
}
</pre>
</td></tr></table>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="136"><H3>ScrollWnd.c</H3></A>
<p><pre>
//======================================================================
// ScrollWnd - Scroll bar control window code
//
// Written for the book Programming Windows CE
// Copyright (C) 1998 Douglas Boling
//======================================================================
#include &lt;windows.h&gt;                 // For all that Windows stuff

#include &quot;Ctlview.h&quot;                 // Program-specific stuff

extern HINSTANCE hInst;
//----------------------------------------------------------------------
// Global data
//
// Message dispatch table for ScrollWndWindowProc
const struct decodeUINT ScrollWndMessages[] = {
    WM_CREATE, DoCreateScrollWnd,
    WM_HSCROLL, DoVScrollScrollWnd,
    WM_VSCROLL, DoVScrollScrollWnd,
};

// Structure defining the controls in the window
CTLWNDSTRUCT  Scrolls [] = {
    {TEXT (&quot;Scrollbar&quot;), IDC_LRSCROLL, TEXT (&quot;&quot;),
     10,  10, 150,  23, SBS_HORZ},

    {TEXT (&quot;Scrollbar&quot;), IDC_UDSCROLL, TEXT (&quot;&quot;),
     180,  10,  23, 150, SBS_VERT},
};

// Structure labeling the scroll bar control scroll codes for WM_VSCROLL
NOTELABELS nlVScroll[] = {{TEXT (&quot;SB_LINEUP       &quot;), 0},
                          {TEXT (&quot;SB_LINEDOWN     &quot;), 1},
                          {TEXT (&quot;SB_PAGEUP       &quot;), 2},
                          {TEXT (&quot;SB_PAGEDOWN     &quot;), 3},
                          {TEXT (&quot;SB_THUMBPOSITION&quot;), 4},
                          {TEXT (&quot;SB_THUMBTRACK   &quot;), 5},
                          {TEXT (&quot;SB_TOP          &quot;), 6},
                          {TEXT (&quot;SB_BOTTOM       &quot;), 7},
                          {TEXT (&quot;SB_ENDSCROLL    &quot;), 8},
};
// Structure labeling the scroll bar control scroll codes for WM_HSCROLL
NOTELABELS nlHScroll[] = {{TEXT (&quot;SB_LINELEFT     &quot;), 0},
                          {TEXT (&quot;SB_LINERIGHT    &quot;), 1},
                          {TEXT (&quot;SB_PAGELEFT     &quot;), 2},
                          {TEXT (&quot;SB_PAGERIGHT    &quot;), 3},
                          {TEXT (&quot;SB_THUMBPOSITION&quot;), 4},
                          {TEXT (&quot;SB_THUMBTRACK   &quot;), 5},
                          {TEXT (&quot;SB_LEFT         &quot;), 6},
                          {TEXT (&quot;SB_RIGHT        &quot;), 7},
                          {TEXT (&quot;SB_ENDSCROLL    &quot;), 8},
};
//----------------------------------------------------------------------
// InitScrollWnd - ScrollWnd window initialization
//
int InitScrollWnd (HINSTANCE hInstance) {
    WNDCLASS wc;

    // Register application ScrollWnd window class.
    wc.style = 0;                             // Window style
    wc.lpfnWndProc = ScrollWndProc;           // Callback function
    wc.cbClsExtra = 0;                        // Extra class data
    wc.cbWndExtra = 0;                        // Extra window data
    wc.hInstance = hInstance;                 // Owner handle
    wc.hIcon = NULL,                          // Application icon
    wc.hCursor = NULL;                        // Default cursor
    wc.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH);
    wc.lpszMenuName =  NULL;                  // Menu name
    wc.lpszClassName = SCROLLWND;             // Window class name

    if (RegisterClass (&amp;wc) == 0) return 1;

    return 0;
}
//======================================================================
// Message handling procedures for ScrollWindow
//----------------------------------------------------------------------
// ScrollWndProc - Callback function for application window
//
LRESULT CALLBACK ScrollWndProc (HWND hWnd, UINT wMsg, WPARAM wParam,
                                LPARAM lParam) {
    INT i;
    //
    // Search message list to see if we need to handle this
    // message.  If in list, call procedure.
    //
    for (i = 0; i &lt; dim(ScrollWndMessages); i++) {
        if (wMsg == ScrollWndMessages[i].Code)
            return (*ScrollWndMessages[i].Fxn)(hWnd, wMsg, wParam, lParam);
    }
    return DefWindowProc (hWnd, wMsg, wParam, lParam);
}
//----------------------------------------------------------------------
// DoCreateScrollWnd - Process WM_CREATE message for window.
//
LRESULT DoCreateScrollWnd (HWND hWnd, UINT wMsg, WPARAM wParam,
                           LPARAM lParam) {
    INT i;

    for (i = 0; i &lt; dim(Scrolls); i++) {
        CreateWindow (Scrolls[i].szClass, Scrolls[i].szTitle,
                      Scrolls[i].lStyle | WS_VISIBLE | WS_CHILD,
                      Scrolls[i].x, Scrolls[i].y, Scrolls[i].cx,
                      Scrolls[i].cy,
                      hWnd, (HMENU) Scrolls[i].nID, hInst, NULL);
    }
    return 0;
}

//----------------------------------------------------------------------
// DoVScrollScrollWnd - Process WM_VSCROLL message for window.
//
LRESULT DoVScrollScrollWnd (HWND hWnd, UINT wMsg, WPARAM wParam,
                            LPARAM lParam) {
    TCHAR szOut[128];
    SCROLLINFO si;
    INT i, sPos;

    // Update the report window.
    if (GetDlgItem (hWnd, 101) == (HWND)lParam) {

        for (i = 0; i &lt; dim(nlVScroll); i++) {
            if (LOWORD (wParam) == nlVScroll[i].wNotification) {
                lstrcpy (szOut, nlVScroll[i].pszLabel);
                break;
            }
        }
        if (i == dim(nlVScroll))
            wsprintf (szOut, TEXT (&quot;notification: %x&quot;), HIWORD (wParam));
    } else {
        for (i = 0; i &lt; dim(nlHScroll); i++) {
            if (LOWORD (wParam) == nlHScroll[i].wNotification) {
                lstrcpy (szOut, nlHScroll[i].pszLabel);
                break;
            }
        }
        if (i == dim(nlHScroll))
            wsprintf (szOut, TEXT (&quot;notification: %x&quot;), HIWORD (wParam));
    }
    SendMessage (GetParent (hWnd), MYMSG_ADDLINE, -1, (LPARAM)szOut);

    // Get scroll bar position.
    si.cbSize = sizeof (si);
    si.fMask = SIF_POS;
    GetScrollInfo ((HWND)lParam, SB_CTL, &amp;si);
    sPos = si.nPos;

    // Act on the scroll code.
    switch (LOWORD (wParam)) {
    case SB_LINEUP:      // Also SB_LINELEFT
        sPos -= 2;
        break;
    case SB_LINEDOWN:    // Also SB_LINERIGHT
        sPos += 2;
        break;

    case SB_PAGEUP:      // Also SB_PAGELEFT
        sPos -= 10;
        break;

    case SB_PAGEDOWN:    // Also SB_PAGERIGHT
        sPos += 10;
        break;

    case SB_THUMBPOSITION:
        sPos = HIWORD (wParam);
        break;
    }
    // Check range.
    if (sPos &lt; 0)
        sPos = 0;
    if (sPos &gt; 100)
        sPos = 100;

    // Update scrollbar position.
    si.cbSize = sizeof (si);
    si.nPos = sPos;
    si.fMask = SIF_POS;
    SetScrollInfo ((HWND)lParam, SB_CTL, &amp;si, TRUE);
    return 0;
}
</pre>
</td></tr></table>

<P>When the CtlView program starts, the WM_CREATE handler of the main window, <I>DoCreateFrame</I>, creates a row of radio buttons across the top of the window, a list box on the right side of the window, and five different child windows on the left side of the window. (The five child windows are all created without the WS_VISIBLE style, so they're initially hidden.) Each of the child windows in turn creates a number of controls. Before returning from the <I>DoCreateFrame</I>, CtlView checks one of the auto radio buttons and makes the BtnWnd child window (the window that contains the example button controls) visible using <I>ShowWindow</I>.

<P>As each of the controls on the child windows are tapped, clicked, or selected, the control sends WM_COMMAND messages to its parent window. That window in turn sends the information from the WM_COMMAND message to its parent, the frame window, using the application-defined message MYMSG_ADDLINE. There the notification data is formatted and displayed in the list box on the right side of the frame window.

<P>The other function of the frame window is to switch between the different child windows. The application accomplishes this by displaying only the child window that matches the selection of the radio buttons across the top of the frame window. The processing for this is done in the WM_COMMAND handler, <I>DoCommandFrame</I> in CtlView.c.

<P>The best way to discover how and when these controls send notifications is to run the example program and use each of the controls. Figure 4-6 shows the CtlView window with the button controls displayed. As each of the buttons is clicked, a BN_CLICKED notification is sent to the parent window of the control. The parent window simply labels the notification and forwards it to the display list box. Because the Check Box button isn't an auto check box, CtlView must manually change the state of the check box when a user clicks it. The other check boxes and radio buttons, however, do automatically change state because they were created with the BS_AUTOCHECKBOX, BS_AUTO3STATE, and BS_AUTORADIOBUTTON styles. The square button with the exclamation mark inside a triangular icon is an owner-draw button.

<P><A HREF="javascript:fullSize('f04rg06x.htm')"> <img src="f04rg06.jpg" width=404 height=152 border="0" ALT="Click to view at full size."></a>
<!-- caption --><P><B>Figure 4-6.</B> <I>The CtlView window with the button child window displayed in the left pane.</I><!-- /caption -->

<P>The source code for each child window is contained in a separate file. The source for the window containing the button controls is contained in BtnWnd.c. The file contains an initialization routine (<I>InitBtnWnd</I>) that registers the window and a window procedure (<I>BtnWndProc</I>) for the window itself. The button controls themselves are created during the WM_CREATE message using <I>CreateWindow</I>. The position, style, and other aspects of each control are contained in an array of structures named <I>Btns</I>. The <I>DoCreateBtnWnd</I> function cycles through each of the entries in the array, calling <I>CreateWindow</I> for each one. Each child window in CtlView uses a similar process to create its controls.

<P>To support the owner-draw button, <I>BtnWndProc</I> must handle the WM_DRAWITEM message. The WM_DRAWITEM message is sent when the button needs to be drawn because it has changed state, gained or lost the focus, or because it has been uncovered. Although the <I>DrawButton</I> function (called each time a WM_DRAWITEM message is received) expends a great deal of effort to make the button look like a standard button, there's no reason a button can't have any look you want.

<P>The other window procedures provide only basic support for their controls. The WM_COMMAND handlers simply reflect the notifications back to the main window. The ScrollWnd child window procedure, <I>ScrollWndProc</I>, handles WM_VSCROLL and WM_HSCROLL messages because that's how scroll bar controls communicate with their parent windows.

<A NAME="137"><H3>Controls and colors</H3></A>

<P>Finally, a word about colors. A large number of Windows CE devices use a gray-scale display instead of a color display, including all of the first generation H/PC and Palm-size PC systems. This has made many Windows CE developers, including me, somewhat lazy in managing color in our Windows CE programs. Now that newer Windows CE systems sport color displays, we have to think a bit more.

<P>In CtlView, the frame window class is registered in a subtly different way from the way I've registered it in previous programs. In the CtlView example, I set the background brush for the frame window using the line

<p><pre>
wc.hbrBackground = (HBRUSH)GetSysColorBrush (COLOR_STATIC);
</pre>

<P>This sets the background color of the frame window to the same background color I used to draw the radio buttons. The function <I>GetSysColorBrush</I> returns a brush that matches the color used by the system to draw various objects in the system. In this case, the constant COLOR_STATIC is passed to <I>GetSysColorBrush</I>, which then returns the background color Windows uses when drawing static text and the text for check box and radio buttons. This makes the frame window background match the static text background.

<P>In the window that contains the button controls, the check box and radio button background is changed to match the white background of the button window, by fielding the WM_CTLCOLORSTATIC message. This message is sent to the parent of a static control or a button control when the button is a check box or radio button to ask the parent which colors to use when drawing the control. In CtlView, the button window returns the handle to a white brush so that the control background will match the white background of the window. Modifying the color of a push button is done by fielding the WM_CTLCOLORBUTTON message. Other controls send different WM_CTLCOLOR<I>xxx</I> messages so that the colors used to draw them can be modified by the parent window.

</BODY>
</HTML>




