<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>Memory Basics</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="214"><H1>Memory Basics</H1></A>

<P>As with all computers, systems running Windows CE have both ROM (read only memory) and RAM (random access memory). Under Windows CE, however, both ROM and RAM are used somewhat differently than they are in a standard personal computer.

<A NAME="215"><H2>About RAM</H2></A>

<P>The RAM in a Windows CE system is divided into two areas: <I>program memory</I> and <I>object store</I>. The object store can be considered something like a permanent virtual RAM disk. Unlike the old virtual RAM disks on a PC, the object store retains the files stored in it even if the system is turned off.<SUP>1</SUP> This is the reason Windows CE systems such as the Handheld PC and the Palm-size PC each have a battery and a backup battery. When the user replaces the main batteries, the backup battery's job is to provide power to the RAM to retain the files in the object store. Even when the user hits the reset button, the Windows CE kernel starts up looking for a previously created object store in RAM and uses that store if it finds one.

<P>The other area of the RAM is devoted to the program memory. Program memory is used like the RAM in personal computers. It stores the heaps and stacks for the applications that are running. The boundary between the object store and the program RAM is movable. The user can move the dividing line between object store and program RAM using the System control panel applet. Under low-memory conditions, the system will ask the user for permission to take some object store RAM to use as program RAM to satisfy an application's demand for more RAM.
<P><div class="sidebar"><blockquote><ol>
<p><li>On mobile systems like the H/PC and the Palm-size PC, the system is never really off.  When the user presses the Off button, the system enters a very low power suspended state.</ol></blockquote></div>

<A NAME="216"><H2>About ROM</H2></A>

<P>In a personal computer, the ROM is used to store the BIOS (basic input output system) and is typically 64_128 KB. In a Windows CE system, the ROM can range from 4 to 16 MB and stores the entire operating system, as well as the applications that are bundled with the system. In this sense, the ROM in a Windows CE system is like a small, read-only hard disk.

<P>In a Windows CE system, ROM-based programs can be designated as Execute in Place (XIP). That is, they're executed directly from the ROM instead of being loaded into program RAM and then executed. This is a huge advantage for small systems in two ways. The fact that the code is executed directly from ROM means that the program code doesn't take up valuable program RAM. Also, since the program doesn't have to be copied into RAM before it's launched, it takes less time to start an application. Programs that aren't in ROM but are contained in the object store or on a Flash memory storage card aren't executed in place; they're copied into the RAM and executed.

<A NAME="217"><H2>About Virtual Memory</H2></A>

<P>Windows CE implements a virtual memory management system. In a virtual memory system, applications deal with virtual memory, which is a separate, imaginary address space that might not relate to the physical memory address space that's implemented by the hardware. The operating system uses the memory management unit of the microprocessor to translate virtual addresses to physical addresses in real time.

<P>The key advantage of a virtual memory system can be seen in the complexity of the MS-DOS address space. Once demand for RAM exceeded the 640-KB limit of the original PC design, programmers had to deal with schemes such as <I>expanded</I> and <I>extended</I> memory to increase the available RAM. OS/2 1.<I>x</I> and Windows 3.0 replaced these schemes with a segment-based virtual memory system. Applications using virtual memory have no idea (nor should they care) where the actual physical memory resides, only that the memory is available. In these systems, the virtual memory was implemented in segments, resizable blocks of memory that ranged from 16 bytes to 64 KB in size. The 64-KB limit wasn't due to the segments themselves, but to the 16-bit nature of the Intel 80286 that was the basis for the segmented virtual memory system in Windows 3.<I>x</I> and OS/2 1.<I>x</I>.

<A NAME="218"><H3>Paged memory</H3></A>

<P>The Intel 80386 supported segments larger than 64 KB, but when Microsoft and IBM began the design for OS/2 2.0, they chose to use a different virtual memory system, also supported by the 386, known as a <I>paged virtual memory system</I>. In a paged memory system, the smallest unit of memory the microprocessor manages is the <I>page</I>. For Windows NT and OS/2 2.0, the pages were set to 386's default page size of 4096 bytes. When an application accesses a page, the microprocessor translates the virtual address of the page to a physical page in ROM or RAM. A page can also be tagged so that accessing the page causes an exception. The operating system then determines whether the virtual page is valid and, if so, maps a physical page of memory to the virtual page.

<P>Windows CE implements a paged virtual memory management system similar to the other Win32 operating systems, Windows NT and Windows 98. Under Windows CE, a page is either 1024 or 4096 bytes, depending on the microprocessor, with the 1-KB page size preferred by the Windows CE architects. This is a change from Windows NT, where page sizes are 4096 bytes for Intel microprocessors and 8192 bytes for the DEC Alpha. For the CPUs currently supported by Windows CE, the NEC 4100 series and the Hitachi SH3 use 1024-byte pages and the 486, the Phillips 3910, and Power PC 821 use 4096-byte pages.

<P>Virtual pages can be in one of three states: <I>free</I>, <I>reserved</I>, or <I>committed</I>. A free page is, as it sounds, free and available to be allocated. A reserved page is a page that has been reserved so that its virtual address can't be allocated by the operating system or another thread in the process. A reserved page can't be used elsewhere, but it also can't be used by the application because it isn't mapped to physical memory. To be mapped, a page must be committed. A committed page has been reserved by an application and has been directly mapped to a physical address.

<P>All that I've just explained is old hat to experienced Win32 programmers. The important thing for the Windows CE programmer is to learn how Windows CE changes the equation. While Windows CE implements most of the same memory API set of its bigger Win32 cousins, the underlying architecture of Windows CE does impact programs. To better understand how the API is affected, it helps to look at how Windows CE uses memory under the covers.

<A NAME="219"><H2>The Windows CE Address Space</H2></A>

<P>In OS circles, much is made of the extent to which the operating system goes to protect one application's memory from other applications. Microsoft Windows 95 used a single address space that provided minimal protection between applications and the Windows operating system code. Windows NT, on the other hand, implements completely separate address spaces for each Win32 application, although old 16-bit applications under Windows NT do share a single address space.

<P>Windows CE implements a single, 2-GB virtual address space for all applications, but the memory space of an application is protected so that it can't be accessed by another application. A diagram of the Windows CE virtual address space is shown in Figure 6-1. A little over half of the virtual address space is divided into thirty-three 32-MB <I>slots</I>. Each slot is assigned to a currently running process, with the lowest slot, slot 0, assigned to the active process. As Windows CE switches between processes, it remaps the address space to move the old process out of slot 0 and the new process into slot 0. This task is quickly accomplished by the OS by manipulating the page translation tables of the microprocessor.

<P><B>Figure 6-1.</B> <I>A diagram of the Windows CE memory map.</I>

<P>
<TABLE cellpadding=5 width="95%">
<tr><td valign="top"><b><i>Address</i></b></td>
<td valign="top"><b><i>Slot</i></b></td>
<td valign="top"><b><i>Comments</i></b></td></tr>

<tr><td valign="top">0000 0000</td>
<td valign="top">Slot 0</td>
<td valign="top">Slot for the currently active process. First 64 KB reserved by the OS.</td></tr>

<tr><td valign="top">0200 0000</td>
<td valign="top">Slot 1</td>
<td valign="top">Process 1: Each slot from 1 to 32 contains one process. When a process is active, it's also mapped into slot 0.</td></tr>

<tr><td valign="top">0400 0000</td>
<td valign="top">Slot 2</td>
<td valign="top"></td></tr>

<tr><td valign="top">0600 0000</td>
<td valign="top">Slot 3</td>
<td valign="top"></td></tr>
</table>

<P>
<TABLE cellpadding=5 width="95%">

<tr><td valign="top"><b><i>Address</i></b></td>
<td valign="top"><b><i>Slot</i></b></td>
<td valign="top"><b><i>Comments</i></b></td></tr>

<tr><td valign="top">0800 0000</td>
<td valign="top">Slot 4</td>
<td valign="top"></td></tr>

<tr><td valign="top">0A00 0000 </td>
<td valign="top">Slot 5</td>
<td valign="top"></td></tr>

<tr><td valign="top">0C00 0000 </td>
<td valign="top">Slot 6</td>
<td valign="top"></td></tr>

<tr><td valign="top">0E00 0000 </td>
<td valign="top">Slot 7</td>
<td valign="top"></td></tr>

<tr><td valign="top">1000 0000 </td>
<td valign="top">Slot 8</td>
<td valign="top"></td></tr>

<tr><td valign="top">1200 0000 </td>
<td valign="top">Slot 9</td>
<td valign="top"></td></tr>

<tr><td valign="top">1400 0000 </td>
<td valign="top">Slot 10</td>
<td valign="top"></td></tr>

<tr><td valign="top">1600 0000 </td>
<td valign="top">Slot 11</td>
<td valign="top"></td></tr>

<tr><td valign="top">1800 0000 </td>
<td valign="top">Slot 12</td>
<td valign="top"></td></tr>

<tr><td valign="top">1A00 0000 </td>
<td valign="top">Slot 13</td>
<td valign="top"></td></tr>

<tr><td valign="top">1C00 0000 </td>
<td valign="top">Slot 14</td>
<td valign="top"></td></tr>

<tr><td valign="top">1E00 0000 </td>
<td valign="top">Slot 15</td>
<td valign="top"></td></tr>

<tr><td valign="top">2000 0000 </td>
<td valign="top">Slot 16</td>
<td valign="top"></td></tr>

<tr><td valign="top">2200 0000 </td>
<td valign="top">Slot 17</td>
<td valign="top"></td></tr>

<tr><td valign="top">2400 0000 </td>
<td valign="top">Slot 18</td>
<td valign="top"></td></tr>

<tr><td valign="top">2600 0000 </td>
<td valign="top">Slot 19</td>
<td valign="top"></td></tr>

<tr><td valign="top">2800 0000 </td>
<td valign="top">Slot 20</td>
<td valign="top"></td></tr>

<tr><td valign="top">2A00 0000 </td>
<td valign="top">Slot 21</td>
<td valign="top"></td></tr>

<tr><td valign="top">2C00 0000 </td>
<td valign="top">Slot 22</td>
<td valign="top"></td></tr>

<tr><td valign="top">2E00 0000 </td>
<td valign="top">Slot 23</td>
<td valign="top"></td></tr>

<tr><td valign="top">3000 0000 </td>
<td valign="top">Slot 24</td>
<td valign="top"></td></tr>

<tr><td valign="top">3200 0000 </td>
<td valign="top">Slot 25</td>
<td valign="top"></td></tr>

<tr><td valign="top">3400 0000 </td>
<td valign="top">Slot 26</td>
<td valign="top"></td></tr>

<tr><td valign="top">3600 0000 </td>
<td valign="top">Slot 27</td>
<td valign="top"></td></tr>

<tr><td valign="top">3800 0000 </td>
<td valign="top">Slot 28</td>
<td valign="top"></td></tr>

<tr><td valign="top">3A00 0000 </td>
<td valign="top">Slot 29</td>
<td valign="top"></td></tr>

<tr><td valign="top">3C00 0000 </td>
<td valign="top">Slot 30</td>
<td valign="top"></td></tr>

<tr><td valign="top">3E00 0000 </td>
<td valign="top">Slot 31</td>
<td valign="top"></td></tr>

<tr><td valign="top">4000 0000 </td>
<td valign="top">Slot 32</td>
<td valign="top"></td></tr>

<tr><td valign="top">4200 0000 </td>
<td valign="top">Used for memory-mapped files</td>
<td valign="top"></td></tr>

<tr><td valign="top">7FFF FFFF </td><td valign="top">End of virtual address space</td>
<td valign="top"></td></tr>
</table>
	 
<P>The region of the address space above the 33 slots is reserved for the operating system and for mapping memory-mapped files. Like Windows NT, Windows CE also reserves the lowest 64-KB block of the address space from access by any process.

<A NAME="220"><H3>Querying the system memory</H3></A>

<P>If an application knows the current memory state of the system, it can better manage the available resources. Windows CE implements both the Win32 <I>GetSystemInfo</I> and <I>GlobalMemoryStatus</I> functions. The <I>GetSystemInfo</I> function is prototyped below:

<P><pre>
VOID GetSystemInfo (LPSYSTEM_INFO lpSystemInfo);
</pre>

<P>It's passed a pointer to a SYSTEM_INFO structure defined as

<p><pre>
typedef struct {
    WORD wProcessorArchitecture;
    WORD wReserved;
    DWORD  dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD  dwActiveProcessorMask;
    DWORD  dwNumberOfProcessors;
    DWORD  dwProcessorType;
    DWORD  dwAllocationGranularity;
    WORD  wProcessorLevel; 
    WORD  wProcessorRevision;
} SYSTEM_INFO;
</pre>

<P>The <I>wProcessorArchitecture</I> field identifies the type of microprocessor in the system. The value should be compared to the known constants defined in Winnt.h, such as PROCESSOR_ARCHITECTURE_INTEL. Windows CE has extended these constants to include PROCESSOR_ARCHITECTURE_ARM, PROCESSOR_ARCHITECTURE_SHx and others. Additional processor constants are added as net CPUs are supported by any of the Win32 operating systems. Skipping a few fields, the <I>dwProcessorType</I> field further narrows the microprocessor from a family to a specific microprocessor. Constants for the Hitachi SHx architecture include PROCESSOR_HITACHI_SH3 and PROCESSOR_HITACHI_SH4. The last two fields, <I>wProcessorLevel</I> and <I>wProcessorRevision</I>, further refine the CPU type. The <I>wProcessorLevel</I> field is similar to the <I>dwProcessorType</I> field in that it defines the specific microprocessor within a family. The <I>dwProcessorRevision </I>field tells you the model and the stepping level of the chip.

<P>The <I>dwPageSize </I>field specifies the page size, in bytes, of the microprocessor. Knowing this value comes in handy when you're dealing directly with the virtual memory API, which I talk about shortly. The <I>lpMinimumApplicationAddress</I> and <I>lpMaximumApplicationAddress</I> fields specify the minimum and maximum virtual address available to the application. The <I>dwActiveProcessorMask</I> and <I>dwNumberOfProcessors</I> fields are used in Windows NT for systems that support more than one microprocessor. Since Windows CE supports only one microprocessor, you can ignore these fields. The <I>dwAllocationGranularity</I> field specifies the boundaries to which virtual memory regions are rounded. Like Windows NT, Windows CE rounds virtual regions to 64-KB boundaries.

<P>A second handy function for determining the system memory state is this:

<p><pre>
void GlobalMemoryStatus(LPMEMORYSTATUS lpmst);
</pre>

<P>which returns a MEMORYSTATUS structure defined as

<p><pre>
typedef struct { 
    DWORD dwLength; 
    DWORD dwMemoryLoad; 
    DWORD dwTotalPhys; 
    DWORD dwAvailPhys; 
    DWORD dwTotalPageFile; 
    DWORD dwAvailPageFile; 
    DWORD dwTotalVirtual; 
    DWORD dwAvailVirtual; 
} MEMORYSTATUS;
</pre>

<P>The <I>dwLength</I> field must be initialized by the application before the call is made to <I>GlobalMemoryStatus</I>. The <I>dwMemoryLoad</I> field is of dubious value; it makes available a general loading parameter that's supposed to indicate the current memory use in the system. The <I>dwTotalPhys </I>and <I>dwAvailPhys</I> fields indicate how many pages of RAM are assigned to the program RAM and how many are available. These values don't include RAM assigned to the object store.

<P>The <I>dwTotalPageFile</I> and <I>dwAvailPageFile</I> fields are used under Windows NT and Windows 98 to indicate the current status of the paging file. Because paging files aren't supported under Windows CE, these fields are always 0. The <I>dwTotalVirtual</I> and <I>dwAvailVirtual</I> fields indicate the total and available number of virtual memory pages accessible to the application.

<P>The information returned by <I>GlobalMemoryStatus</I> provides confirmation of the memory architecture of Windows CE. Making this call on an HP 360 H/PC with 8 MB of RAM returned the following values:

<p><pre>
dwMemoryLoad       0x18          (24)
dwTotalPhys        0x00555400    (5,592,064)
dwAvailPhys        0x00415C00    (4,283,392)
dwTotalPageFile    0
dwAvailPageFile    0
dwTotalVirtual     0x02000000    (33,554,432)
dwAvailVirtual     0x01EF0000    (32,440,320)
</pre>

<P>The <I>dwTotalPhys </I>field indicates that of the 8 MB of RAM in the system, I have dedicated 5.5 MB to the program RAM, of which 4.2 MB is still free. Note that there's no way for an application, using this call, to know that another 3 MB of RAM has been dedicated to the object store. To determine the amount of RAM dedicated to the object store, use the function <I>GetStoreInformation</I>.

<P>The <I>dwTotalPageFile</I> and <I>dwAvailPageFile</I> fields are 0, indicating no support for a paging file under Windows CE. The <I>dwTotalVirtual</I> field is interesting because it shows the 32-MB limit on virtual memory that Windows CE enforces on an application. Meanwhile, the <I>dwAvailVirtual</I> field indicates that in this application little of that 32 MB of virtual memory is being used.

<A NAME="221"><H2>An Application's Address Space</H2></A>

<P>Although it's always interesting to look at the global memory map for an operating system, the fact is an application should be interested only in its own memory space, not the global address space. Nevertheless, the design of the Windows CE address space does have an impact on applications. Under Windows CE, an application is limited to the virtual memory space available in its 32-MB slot. While 32 MB might seem like a fair amount of space available to an application that might run on a system with only 4 MB of RAM, Win32 application programmers, used to a 2-GB virtual address space, need to keep in mind the limited virtual address space available to a Windows CE application.

<P>Figure 6-2 shows the layout of an application's 32-MB virtual address space. Each line of the figure represents a block of virtual memory made up of one or more pages. The address of the blocks are offsets into the application's slot in the system address space. The Page status is free, reserved, private, or image. While I've just explained the terms <I>free </I>and <I>reserved</I>, <I>private</I> and <I>image </I>merit an explanation. <I>Image</I> indicates pages that have been committed and mapped to the image of an executable file in ROM or RAM. <I>Private</I> simply means the pages have been committed for use by the application. The size field indicates the size of the block, which is always a multiple of the page size. The access rights field displays the access rights for the block.

<P>This memory map was captured on a Casio H/PC that has a SH3 processor with a 1024-byte page size. The application used in this example was stored in the object store and then launched. This allowed Windows CE to demand page only parts of the EXE image into RAM, as they're needed. If the application had been launched from an external storage device that didn't support demand paging, Windows CE would have loaded the entire application into memory when it was launched.

<P><B>Figure 6-2.</B> <I>Memory map of a Windows CE Application.</I>

<P>
<TABLE cellpadding=5 width="95%">

<tr><td valign="top"><b><i>Address</i></b></td>


<td valign="top"><b><i>Page Status</i></b></td>
<td valign="top"><b><i>Size</i></b></td>
<td valign="top"><b><i>Access Rights</i></b></td>
<td valign="top"><b><i>Comments</i></b></td></tr>

<tr><td valign="top">0000 0000</td>
<td valign="top">Reserved</td>
<td valign="top">65,536</td>
<td valign="top"></td>
<td valign="top"><B>EXE image</B></td></tr>

<tr><td valign="top">0001 0000</td>
<td valign="top">Reserved</td>
<td valign="top">4,096</td>
<td valign="top"></td>
<td valign="top"><B>Code</B></td></tr>

<tr><td valign="top">0001 1000</td>
<td valign="top">Image</td>
<td valign="top">2,048</td>
<td valign="top">Execute, Read only</td>
<td valign="top"><B>Code</B></td></tr>

<tr><td valign="top">0001 1800</td>
<td valign="top">Reserved</td>
<td valign="top">1,024</td>
<td valign="top"></td>
<td valign="top"><B>Code</B></td></tr>

<tr><td valign="top">0001 1C00</td>
<td valign="top">Image</td>
<td valign="top">1,024</td>
<td valign="top">Execute, Read only</td>
<td valign="top"><B>Code</B></td></tr>

<tr><td valign="top">0001 2000</td>
<td valign="top">Reserved</td>
<td valign="top">2,048</td>
<td valign="top"></td>
<td valign="top"><B>Code</B></td></tr>

<tr><td valign="top">0001 2800</td>
<td valign="top">Image</td>
<td valign="top">8,192</td>
<td valign="top">Execute, Read only</td>
<td valign="top"><B>Code</B></td></tr>

<tr><td valign="top">0001 4800</td>
<td valign="top">Reserved</td>
<td valign="top">2,048</td>
<td valign="top"></td>
<td valign="top"><B>Code</B></td></tr>

<tr><td valign="top">0001 5000</td>
<td valign="top">Image</td>
<td valign="top">1,024</td>
<td valign="top">Execute, Read only</td>
<td valign="top"><B>Code</B></td></tr>

<tr><td valign="top">0001 5400</td>
<td valign="top">Reserved</td>
<td valign="top">11,264</td>
<td valign="top"></td>
<td valign="top"></td></tr>

<tr><td valign="top">0001 8000</td>
<td valign="top">Image</td>
<td valign="top">3,072</td>
<td valign="top">Read only</td>
<td valign="top"><B>Read only static data</B></td></tr>

<tr><td valign="top">0001 8C00</td>
<td valign="top">Reserved</td>
<td valign="top">1,024</td>
<td valign="top"></td>
<td valign="top"></td></tr>  

<tr><td valign="top">0001 9000</td>
<td valign="top">Image</td>
<td valign="top">1,024</td>
<td valign="top">Read/Write</td>
<td valign="top"><B>Read/Write static data</B></td></tr>

<tr><td valign="top">0001 9400</td>
<td valign="top">Reserved</td>
<td valign="top">1,024</td>
<td valign="top"></td>
<td valign="top"><B>Read/Write static data</B></td></tr>

<tr><td valign="top">0001 9800</td>
<td valign="top">Image</td>
<td valign="top">7,168</td>
<td valign="top">Read/Write</td>
<td valign="top"><B>Read/Write static data</B></td></tr>

<tr><td valign="top">0001 B400</td>
<td valign="top">Reserved</td>
<td valign="top">7,168</td>
<td valign="top"></td>
<td valign="top"></td></tr>

<tr><td valign="top">0001 D000</td>
<td valign="top">Image</td>
<td valign="top">2,048</td>
<td valign="top">Read only</td>
<td valign="top"><B>Resource data segment</B></td></tr>

<tr><td valign="top">0001 D800</td>
<td valign="top">Reserved</td>
<td valign="top">2,048</td>
<td valign="top"></td>
<td valign="top"><B>Resource data  segment</B></td></tr>

<tr><td valign="top">0001 E000</td>
<td valign="top">Free</td>
<td valign="top">8,192</td>
<td valign="top"></td>
<td valign="top"></td></tr>

<tr><td valign="top">0002 0000</td>
<td valign="top">Reserved</td>
<td valign="top">54,272</td>
<td valign="top"></td>
<td valign="top"><B>Stack</B></td></tr>

<tr><td valign="top">0002 D400</td>
<td valign="top">Private</td>
<td valign="top">7,168</td>
<td valign="top">Read/Write</td>
<td valign="top"></td></tr>

<tr><td valign="top">0002 F000</td>
<td valign="top">Free</td>
<td valign="top">4,096</td>
<td valign="top"></td>
<td valign="top"></td></tr>

<tr><td valign="top">0003 0000</td>
<td valign="top">Private</td>
<td valign="top">1,024</td>
<td valign="top">Read/Write</td>
<td valign="top"><B>Local heap</B></td></tr>

<tr><td valign="top">0003 0400</td>
<td valign="top">Reserved</td>
<td valign="top">92,192</td>
<td valign="top"></td>
<td valign="top"></td></tr>

<tr><td valign="top">0009 0000</td>
<td valign="top">Free</td>
<td valign="top">30,408,704</td>
<td valign="top"></td>
<td valign="top"><B>Free</B></td></tr>

<tr><td valign="top">01D9 0000</td>
<td valign="top">Reserved</td>
<td valign="top">1,024</td>
<td valign="top"></td>
<td valign="top"><B>COMMCTRL image</B></td></tr>

<tr><td valign="top">01D9 0400</td>
<td valign="top">Image</td>
<td valign="top">237,568</td>
<td valign="top">Execute, Read only</td>
<td valign="top"></td></tr>

<tr><td valign="top">01DC A400</td>
<td valign="top">Image</td>
<td valign="top">2,048</td>
<td valign="top">Read/Write</td>
<td valign="top"></td></tr>

<tr><td valign="top">01DC AC00</td>
<td valign="top">Reserved</td>
<td valign="top">7,168</td>
<td valign="top"></td>
<td valign="top"></td></tr>

<tr><td valign="top">01DC C800</td>
<td valign="top">Image</td>
<td valign="top">7,168</td>
<td valign="top">Read only</td>
<td valign="top"></td></tr>

<tr><td valign="top">01DC E400</td>
<td valign="top">Reserved</td>
<td valign="top">13,312</td>
<td valign="top"></td>
<td valign="top"></td></tr>

<tr><td valign="top">01DD 1800</td>
<td valign="top">Free</td>
<td valign="top">2,091,008</td>
<td valign="top"></td>
<td valign="top"><B>Free</B></td></tr>

<tr><td valign="top">01FD 0000</td>
<td valign="top">Reserved</td>
<td valign="top">1,024</td>
<td valign="top"></td>
<td valign="top"><B>COREDLL image</B></td></tr>

<tr><td valign="top">01FD 0400</td>
<td valign="top">Image</td>
<td valign="top">119,808</td>
<td valign="top">Execute, Read only</td>
<td valign="top"></td></tr>

<tr><td valign="top">01FE D800</td>
<td valign="top">Image</td>
<td valign="top">1,024</td>
<td valign="top">Read/Write</td>
<td valign="top"></td></tr>

<tr><td valign="top">01FE DC00</td>
<td valign="top">Reserved</td>
<td valign="top">8,192</td>
<td valign="top"></td>
<td valign="top"></td></tr>

<tr><td valign="top">01FE FC00</td>
<td valign="top">Image</td>
<td valign="top">1,024</td>
<td valign="top">Read only</td>
<td valign="top"></td></tr>

<tr><td valign="top">01FF 0000</td>
<td valign="top">Reserved</td>
<td valign="top">5,120</td>
<td valign="top"></td>
<td valign="top"></td></tr>

<tr><td valign="top">01FF 1400</td>
<td valign="top">Free</td>
<td valign="top">60,416</td>
<td valign="top"></td>
<td valign="top"></td></tr>
</table>

<P>Notice that the application is mapped as a 64-KB region starting at 0x10000. Remember, the lowest 64 KB of the address space for any application is reserved by Windows CE. The image of the file contains the code along with the static data segments and the resource segments. Although it appears that the program code is broken into a number of disjointed pages from 0x10000 to 0x15400, this is actually the result of demand paging. What's happening is that only the pages containing executed code are mapped into the address space. The reserved pages within the code segment will be mapped into the space only when they're executed.

<P>The read-only static data segment is mapped at 0x18000 and takes three pages. The read/write static data is mapped from 0x19000 to 0x1B3FF. Like the code, the read/write data segment is committed to RAM only as it's written to by the application. Any static data that was initialized by the loader is already committed, as is the static variables written before this capture of the address space was made. The resources for the application are mapped starting at 0x1D000. The resources are read only and are paged into the RAM only as they're accessed by the application.

<P>Starting at 0x20000, the application's stack is mapped. The stack segment is easily recognized because the committed pages are at the end of the reserved section, indicative of a stack that grows from higher addresses down. If this application had more than one thread, more than one stack segment would be reserved in the application's address space.

<P>Following the stack is the local heap. The heap has only a few blocks currently allocated, requiring only one page of RAM. The loader reserves another 392,192 bytes, or 383 pages, for the heap to grow. The over-30 MB of address space from the end of the reserved pages for the local heap to the start of the DLLs mapped into the address space is free to be reserved and, if RAM permits, committed by the application.

<P>This application accesses two dynamic-link libraries. Coredll.dll is the DLL that contains the entry points to the Windows CE operating system. In Windows CE, the function entry points are combined into one DLL, unlike in Windows NT or Windows 98, where the core functions are distributed across Kernel, User, and GDI. The other DLL is the common control DLL, commctrl.dll. As with the executable image, these DLLs are mapped into the address space as linear images. However, unlike the EXE, these DLLs are in ROM and directly mapped into the virtual address space of the application; therefore, they don't take up any RAM.




</BODY>
</HTML>




