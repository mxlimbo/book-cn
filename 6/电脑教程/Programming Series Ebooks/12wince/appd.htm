<HTML>
 <HEAD>
	<LINK REL=StyleSheet HREF="prowice.css" TYPE="text/css">
<TITLE>COM Servers</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="6"><H1>COM Servers</H1></A>

<P>On the other side of the COM fence is a COM server. A COM server is a module, EXE or DLL, which provides one or more COM interfaces. There are three types of COM servers: in-proc, which operate in the process space of the caller; local, which operate in separate process spaces; and remote, which reside on different machines from the COM clients. For all our cases, I'll stick to COM in-proc servers.

<P>A COM server doesn't just provide a pointer to a requested interface. That would be too easy. Instead, a COM server must make available an additional interface, <I>IClassFactory</I>. <I>IClassFactory</I> is composed of the <I>IUnknown</I> methods, <I>QueryInterface</I>, <I>AddRef</I>, and <I>Release</I> along with two additional methods, <I>CreateInstance</I> and <I>LockServer</I>. It's through calling methods within <I>IClassFactory</I> that the server creates other objects provided by the server. To create an instance of an interface, the client calls the <I>IClassFactory</I> <I>CreateInstance</I> method. The prototype for this function is

<P><pre>
HRESULT CreateInstance (IUnknown * pUnkOuter, REFIID riid,
                    void ** ppvObject);
</PRE>

<P>If the first parameter isn't NULL, it's a pointer to the controlling <I>IUnknown </I>interface of the aggregate object. The second parameter is the CLSID for the object you want to create. Finally, the <I>ppvObject</I> parameter points to a value that receives a pointer to the interface provided by the newly created object. When <I>CreateInstance</I> is called, <I>IClassFactory</I> examines the GUID in the <I>riid </I>parameter to see what interface it identifies; if that interface is provided, <I>IClassFactory </I>creates the object that implements the interface and queries that object for a pointer to the newly created interface that it then returns.


<P>So, just how does a client get access to <I>IClassFactory</I>? Well, if we're talking about in-proc servers, COM must fall back on functions exported from the DLL or EXE. A COM server must provide at least two exported functions&#8212;<I>DllGetClassObject</I> and <I>DllCanUnloadNow</I>. The first of these two functions is the more interesting. It's prototyped as

<P><pre>
STDAPI DllGetClassObject (REFCLSID rclsid, REFIID riid,
                          LPVOID *ppv);
</PRE>

<P>The first parameter is a class ID, which is a GUID that uniquely identifies this object. Many objects, for example, might export a file filter interface, but each will have a unique class ID. The COM server must ensure that the object's class ID matches its class ID and, if not, return an error to the caller.



<P>The second parameter is the reference ID for the interface that the client wants. When calling <I>DllGetClassObject</I>, the reference ID usually identifies either <I>IUnknown</I> or <I>IClassFactory</I>, but it doesn't have to. The server's responsibility here is to compare the requested interface with those that are provided. If that interface is provided, a pointer to it is returned in a variable pointed to by the third parameter, <I>ppv</I>.

<P>The other exported function is

<P><pre>
STDAPI DllCanUnloadNow (void);
</PRE>

<P>This function is called to determine whether the DLL can be removed from memory. The COM server is required to know whether any object instances are currently active. Each object tracks this information by keeping a count of the number of instances of itself currently created. This is what the <I>AddRef </I>and <I>Release</I> methods of <I>IUnknown </I>are used for. When the use count for a specific object/interface reaches 0, the <I>Release</I> method of the object deletes the object. The server must keep track of which objects are still in use and return S_FALSE from <I>DllCanUnloadNow</I> if any of the objects it serves are still in use.



<P>One final point. Plenty of DLLs are in a system. How does the COM library know to load a specific DLL to look for a specific class? It looks in the registry. If you look in the registry under [HKEY_CLASSES_ROOT]\CLSID, you'll see hundreds of keys with class IDs for names. Each of these class ID keys has a series of subkeys that identify the DLL that implements that COM object as well as identifying other information important to the implementation of the server.

<P>So, to sum up, when a client requests an object identified by a class ID, the COM library finds the name of the DLL that implements that object in the registry. The DLL is then loaded into memory and the exported function <I>DllGetClassObject</I> is called to confirm the class ID and to (usually) request a pointer to the object's associated <I>IClassFactory</I> object. The client then calls a method in the <I>IClassFactory</I> interface to request that an object that has a requested interface be created. If it can comply, the <I>IClassFactory</I> object creates the requested object and returns a pointer to an interface exposed by that object. Whew.

<P>This short and almost trivial COM primer isn't meant to turn you into a COM expert. My goal is to help you identify all those extra functions implemented in the examples that use COM in this book. I strongly encourage you to learn more about COM from other books and papers. For all its complexity, COM is the wave of the present and future in Windows programming.

</BODY>
</HTML>




