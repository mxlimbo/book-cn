<HTML>
<HEAD>
<TITLE>Datagram Operations</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch01d.htm" , "ch01f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="16"><H1>Datagram Operations</H1></A>

<p>Datagrams are connectionless methods of communication. A sender merely addresses each packet with its destination NetBIOS name and sends it on its way. No checking is performed to ensure data integrity, order of arrival, or reliability.</p>

<p>There are three ways to send a datagram. The first is to direct the datagram at a specific (unique or group) name. This means that only one process can receive that datagram&#8212;the process that registered the destination name. The second method is to send a datagram to a group name. Only those processes that registered the given group name will be able to receive the message. Finally, the third way to send a datagram is to broadcast it to the entire network. Any process on any workstation on the local area network can receive the datagram. Sending a datagram to either a unique or a group name uses the <i>NCBDGSEND</i> command, while broadcasts use the <i>NCBDGSENDBC</i> command.</p>

<p>Using any of the datagram send commands is a simple process. Set the <i>ncb_num</i> field to the name number returned from an <i>NCBADDNAME</i> command or an <i>NCBADDGRNAME</i> command. This is the number that identifies the message sender. Set <i>ncb_buffer</i> to the address of the buffer with the data you need to send, and set <i>ncb_length</i> to the number of bytes to send. Next, set the <i>ncb_lana_num</i> field to the LANA over which you want the datagram to be transmitted. The last step is to set <i>ncb_callname</i> to the name of the destination NetBIOS name. This can be a unique name or a group name. If you are sending broadcast datagrams, you perform all of the above steps except for the last one: since all workstations will receive the message, no <i>ncb_callname</i> is required.</p>

<p>Of course, in each of the sender scenarios mentioned above, there must be a corresponding datagram receive command to actually receive the data. Datagrams are connectionless; if a datagram reaches a client but the client does not have a receive command already pending, the data is lost and there is no way for the client to recover that data (unless the server resends the data). That is the disadvantage of sending datagrams. However, datagrams are much faster than connection-based methods because they don't require the overhead of error checking, connection setup, and so on.</p>

<p>There are also three methods for receiving datagrams. The first two receive types use the <i>NCBDGRECV</i> command. First, you can issue a datagram receive command for messages destined for a specific name&#8212;unique or group. Second, you can issue a datagram receive command for any datagram destined for any name in the process's NetBIOS name table. Third, you can issue a receive command for a broadcast datagram with the <i>NCBDGRECVBC</i> command.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>It is not possible to post a receive command for datagrams destined for a name registered by a different process unless both processes have registered a group name, in which case both processes can receive the same message.</blockquote></div></p>

<p>To issue a receive command, set the <i>ncb_num</i> field to the name number returned from a successful <i>NCBADDNAME</i> or <i>NCBADDGRNAME</i> call. This name number specifies which name you are listening on for incoming datagrams. If you set this field to 0xFF, you will receive datagrams destined for any name in this process's NetBIOS name table. Additionally, create a buffer to receive data and set <i>ncb_buffer</i> to the buffer's address. Set <i>ncb_length</i> to the size of the buffer. Finally, set <i>ncb_lana_num</i> to the LANA number on which to wait for datagrams. When a successful call to <i>Netbios</i> with the <i>NCBDGRECV</i> command (or the <i>NCBDGRECVBC</i> command) returns, <i>ncb_length</i> will contain the actual number of bytes received and <i>ncb_callname</i> will contain the NetBIOS name of the sending process.</p>

<p>The code in Figure 1-7 contains basic datagram functions. All the sends are blocking calls&#8212;once the command is issued and the data is on the wire, the function returns, and you shouldn't experience blocking because of data overload. The receive calls are asynchronous events because we do not know what LANA numbers data will come in on. The code is similar to that for the session-oriented server using events. For each LANA, the code posts an asynchronous <i>NCBDGRECV</i> (or <i>NCBDGRECVBC</i>) and waits until one succeeds, at which point it checks all posted commands, prints the messages for those that succeed, and cancels those commands that are still pending. The example provides functions for both directed and broadcast sends and receives. The program can be compiled into a sample application that can be configured to send or receive datagrams. The program accepts several command line parameters that allow the user to specify the number of datagrams to send or receive, the delay between sends, the use of broadcasts instead of directed datagrams, the receipt of datagrams for any name, and so on.</p>

<p><b>Figure 1-7.</b> <i>NetBIOS datagram sample (Nbdgram.c) </i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
// Nbdgram.c

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &quot;..\Common\nbcommon.h&quot;

#define MAX_SESSIONS            254
#define MAX_NAMES               254
#define MAX_DATAGRAM_SIZE       512

BOOL   bSender = FALSE,               // Send or receive datagrams
       bRecvAny = FALSE,              // Receive for any name
       bUniqueName = TRUE,            // Register my name as unique?
       bBroadcast = FALSE,            // Use broadcast datagrams?
       bOneLana = FALSE;              // Use all LANAs or just one?
char   szLocalName[NCBNAMSZ + 1],     // Local NetBIOS name
       szRecipientName[NCBNAMSZ + 1]; // Recipient's NetBIOS name
DWORD  dwNumDatagrams = 25,           // Number of datagrams to send
       dwOneLana,                     // If using one LANA, which one?
       dwDelay = 0;                   // Delay between datagram sends

//
// Function: ValidateArgs
//
// Description:
//    This function parses the command line arguments
//    and sets various global flags indicating the selections
//
void ValidateArgs(int argc, char **argv)
{
    int                i;

    for(i = 1; i &lt; argc; i++)

    {
        if (strlen(argv[i]) &lt; 2)
            continue;
        if ((argv[i][0] == '-') || (argv[i][0] == '/'))
        {
            switch (tolower(argv[i][1]))
            {
                case 'n':        // Use a unique name
                    bUniqueName = TRUE;
                    if (strlen(argv[i]) &gt; 2)
                        strcpy(szLocalName, &amp;argv[i][3]);
                    break;
                case 'g':        // Use a group name
                    bUniqueName = FALSE;
                    if (strlen(argv[i]) &gt; 2)
                        strcpy(szLocalName, &amp;argv[i][3]);
                    break;
                case 's':        // Send datagrams
                    bSender = TRUE;
                    break;
                case 'c':        // # of datagrams to send or receive
                    if (strlen(argv[i]) &gt; 2)
                        dwNumDatagrams = atoi(&amp;argv[i][3]);
                    break;
                case 'r':        // Recipient's name for datagrams
                    if (strlen(argv[i]) &gt; 2)
                        strcpy(szRecipientName, &amp;argv[i][3]);
                    break;
                case 'b':        // Use broadcast datagrams
                    bBroadcast = TRUE;
                    break;
                case 'a':        // Receive datagrams on any name
                    bRecvAny = TRUE;
                    break;
                case 'l':        // Operate on this LANA only
                    bOneLana = TRUE;
                    if (strlen(argv[i]) &gt; 2)
                        dwOneLana = atoi(&amp;argv[i][3]);
                    break;
                case 'd':        // Delay (millisecs) between sends
                    if (strlen(argv[i]) &gt; 2)
                        dwDelay = atoi(&amp;argv[i][3]);
                    break;
                default:
                    printf(&quot;usage: nbdgram ?\n&quot;);
                    break;
             }
        }
    }
    return;
}

//
// Function: DatagramSend
//
// Description:
//    Send a directed datagram to the specified recipient on the 
//    specified LANA number from the given name number to the
//    specified recipient. Also specified is the data buffer and 
//    the number of bytes to send.
//
int DatagramSend(int lana, int num, char *recipient, 
                 char *buffer, int buflen)
{
    NCB                ncb;

    ZeroMemory(&amp;ncb, sizeof(NCB));
    ncb.ncb_command = NCBDGSEND;
    ncb.ncb_lana_num = lana;
    ncb.ncb_num = num;
    ncb.ncb_buffer = (PUCHAR)buffer;
    ncb.ncb_length = buflen;

    memset(ncb.ncb_callname, ' ', NCBNAMSZ);
    strncpy(ncb.ncb_callname, recipient, strlen(recipient));

    if (Netbios(&amp;ncb) != NRC_GOODRET)
    {
        printf(&quot;Netbios: NCBDGSEND failed: %d\n&quot;, ncb.ncb_retcode);
        return ncb.ncb_retcode;
    }
    return NRC_GOODRET;
}

//
// Function: DatagramSendBC
//
// Description:
//    Send a broadcast datagram on the specified LANA number from the 
//    given name number. Also specified is the data buffer and the number
//    of bytes to send.
//
int DatagramSendBC(int lana, int num, char *buffer, int buflen)
{

    NCB                ncb;

    ZeroMemory(&amp;ncb, sizeof(NCB));
    ncb.ncb_command = NCBDGSENDBC;
    ncb.ncb_lana_num = lana;
    ncb.ncb_num = num;
    ncb.ncb_buffer = (PUCHAR)buffer;
    ncb.ncb_length = buflen;

    if (Netbios(&amp;ncb) != NRC_GOODRET)
    {
        printf(&quot;Netbios: NCBDGSENDBC failed: %d\n&quot;, ncb.ncb_retcode);
        return ncb.ncb_retcode;
    }
    return NRC_GOODRET;
}

//
// Function: DatagramRecv
//
// Description:
//    Receive a datagram on the given LANA number directed toward the
//    name represented by num. Data is copied into the supplied buffer.
//    If hEvent is not 0, the receive call is made asynchronously
//    with the supplied event handle. If num is 0xFF, listen for a
//    datagram destined for any NetBIOS name registered by the process.
//
int DatagramRecv(PNCB pncb, int lana, int num, char *buffer, 
                 int buflen, HANDLE hEvent)
{
    ZeroMemory(pncb, sizeof(NCB));
    if (hEvent)
    {
        pncb-&gt;ncb_command = NCBDGRECV | ASYNCH;
        pncb-&gt;ncb_event = hEvent;
    }
    else
        pncb-&gt;ncb_command = NCBDGRECV;
    pncb-&gt;ncb_lana_num = lana;
    pncb-&gt;ncb_num = num;
    pncb-&gt;ncb_buffer = (PUCHAR)buffer;
    pncb-&gt;ncb_length = buflen;

    if (Netbios(pncb) != NRC_GOODRET)
    {
        printf(&quot;Netbos: NCBDGRECV failed: %d\n&quot;, pncb-&gt;ncb_retcode);
        return pncb-&gt;ncb_retcode;
    }
    return NRC_GOODRET;
}

//
// Function: DatagramRecvBC
//
// Description:
//    Receive a broadcast datagram on the given LANA number.
//    Data is copied into the supplied buffer. If hEvent is not 0, 
//    the receive call is made asynchronously with the supplied 
//    event handle.
//
int DatagramRecvBC(PNCB pncb, int lana, int num, char *buffer, 
                   int buflen, HANDLE hEvent)
{
    ZeroMemory(pncb, sizeof(NCB));
    if (hEvent)
    {
        pncb-&gt;ncb_command = NCBDGRECVBC | ASYNCH;
        pncb-&gt;ncb_event = hEvent;
    }
    else
        pncb-&gt;ncb_command = NCBDGRECVBC;
    pncb-&gt;ncb_lana_num = lana;
    pncb-&gt;ncb_num = num;
    pncb-&gt;ncb_buffer = (PUCHAR)buffer;
    pncb-&gt;ncb_length = buflen;
  
    if (Netbios(pncb) != NRC_GOODRET)   
    {
        printf(&quot;Netbios: NCBDGRECVBC failed: %d\n&quot;, pncb-&gt;ncb_retcode);
        return pncb-&gt;ncb_retcode;
    }
    return NRC_GOODRET;
}

//
// Function: main
//
// Description:
//    Initialize the NetBIOS interface, allocate resources, and then
//    send or receive datagrams according to the user's options
//
int main(int argc, char **argv)
{
    LANA_ENUM   lenum;

    int         i, j;
    char        szMessage[MAX_DATAGRAM_SIZE],
                szSender[NCBNAMSZ + 1];
    DWORD      *dwNum = NULL,
                dwBytesRead,
                dwErr;

    ValidateArgs(argc, argv);
    //
    // Enumerate and reset the LANA numbers
    //
    if ((dwErr = LanaEnum(&amp;lenum)) != NRC_GOODRET)
    {
        printf(&quot;LanaEnum failed: %d\n&quot;, dwErr);
        return 1;
    }
    if ((dwErr = ResetAll(&amp;lenum, (UCHAR)MAX_SESSIONS,
        (UCHAR)MAX_NAMES, FALSE)) != NRC_GOODRET)
    {
        printf(&quot;ResetAll failed: %d\n&quot;, dwErr);
        return 1;
    }
    //
    // This buffer holds the name number for the NetBIOS name added
    // to each LANA
    //
    dwNum = (DWORD *)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
            sizeof(DWORD) * lenum.length);
    if (dwNum == NULL)
    {
        printf(&quot;out of memory\n&quot;);
        return 1;
    }
    //
    // If we're going to operate on only one LANA, register the name
    // on only that specified LANA; otherwise, register it on all 
    // LANAs
    // 
    if (bOneLana)
    {
        if (bUniqueName)
            AddName(dwOneLana, szLocalName, &amp;dwNum[0]);
        else
            AddGroupName(dwOneLana, szLocalName, &amp;dwNum[0]);
    }
    else
    {
        for(i = 0; i &lt; lenum.length; i++)
        {
            if (bUniqueName)
                AddName(lenum.lana[i], szLocalName, &amp;dwNum[i]);
            else
                AddGroupName(lenum.lana[i], szLocalName, &amp;dwNum[i]);
        }
    }
    // We are sending datagrams
    //
    if (bSender)
    {
        // Broadcast sender
        //
        if (bBroadcast)
        {
            if (bOneLana)
            {
                // Broadcast the message on the one LANA only
                //
                for(j = 0; j &lt; dwNumDatagrams; j++)
                {
                    wsprintf(szMessage,
                        &quot;[%03d] Test broadcast datagram&quot;, j);
                    if (DatagramSendBC(dwOneLana, dwNum[0],
                        szMessage, strlen(szMessage))
                        != NRC_GOODRET)
                        return 1;
                    Sleep(dwDelay);
                }
            }
            else
            {
                // Broadcast the message on every LANA on the local 
                // machine
                //
                for(j = 0; j &lt; dwNumDatagrams; j++)
                {
                    for(i = 0; i &lt; lenum.length; i++)
                    {
                        wsprintf(szMessage,
                            &quot;[%03d] Test broadcast datagram&quot;, j);
                        if (DatagramSendBC(lenum.lana[i], dwNum[i],
                            szMessage, strlen(szMessage)) 
                            != NRC_GOODRET)
                            return 1;
                    }

                    Sleep(dwDelay);
                }
            }
        }
        else
        {
            if (bOneLana)
            {
                // Send a directed message to the one LANA specified
                //
                for(j = 0; j &lt; dwNumDatagrams; j++)
                {
                    wsprintf(szMessage,
                        &quot;[%03d] Test directed datagram&quot;, j);
                    if (DatagramSend(dwOneLana, dwNum[0],
                        szRecipientName, szMessage,
                        strlen(szMessage)) != NRC_GOODRET)
                        return 1;
                    Sleep(dwDelay);
                }
            }
            else
            {
                // Send a directed message to each LANA on the 
                // local machine
                //
                for(j = 0; j &lt; dwNumDatagrams; j++)
                {
                    for(i = 0; i &lt; lenum.length; i++)
                    {
                        wsprintf(szMessage, 
                            &quot;[%03d] Test directed datagram&quot;, j);
                        printf(&quot;count: %d.%d\n&quot;, j,i);
                        if (DatagramSend(lenum.lana[i], dwNum[i], 
                            szRecipientName, szMessage, 
                            strlen(szMessage)) != NRC_GOODRET)
                            return 1;
                    }
                    Sleep(dwDelay);
                }
            }
        }
    }
    else                // We are receiving datagrams
    {
        NCB     *ncb=NULL;
        char    **szMessageArray = NULL;
        HANDLE  *hEvent=NULL;
        DWORD   dwRet;

        // Allocate an array of NCB structure to submit to each recv
        // on each LANA
        //
        ncb = (NCB *)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT,
                    sizeof(NCB) * lenum.length);
        //
        // Allocate an array of incoming data buffers
        //
        szMessageArray = (char **)GlobalAlloc(GMEM_FIXED, 
                sizeof(char *) * lenum.length);
        for(i = 0; i &lt; lenum.length; i++)
            szMessageArray[i] = (char *)GlobalAlloc(GMEM_FIXED, 
                    MAX_DATAGRAM_SIZE);
        //
        // Allocate an array of event handles for 
        // asynchronous receives
        //
        hEvent = (HANDLE *)GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, 
                sizeof(HANDLE) * lenum.length);
        for(i = 0; i &lt; lenum.length; i++)
            hEvent[i] = CreateEvent(0, TRUE, FALSE, 0);

        if (bBroadcast)
        {
            if (bOneLana)
            {
                // Post synchronous broadcast receives on 
                // the one LANA specified
                //
                for(j = 0; j &lt; dwNumDatagrams; j++)
                {
                    if (DatagramRecvBC(&amp;ncb[0], dwOneLana, dwNum[0], 
                        szMessageArray[0], MAX_DATAGRAM_SIZE,  
                        NULL) != NRC_GOODRET)
                        return 1;
                    FormatNetbiosName(ncb[0].ncb_callname, szSender);
                    printf(&quot;%03d [LANA %d] Message: '%s' &quot;
                        &quot;received from: %s\n&quot;, j,
                        ncb[0].ncb_lana_num, szMessageArray[0],
                        szSender);
                }
            }
            else

            {
                // Post asynchronous broadcast receives on each LANA 
                // number available. For each command that succeeded, 
                // print the message; otherwise, cancel the command.
                //
                for(j = 0; j &lt; dwNumDatagrams; j++)
                {
                    for(i = 0; i &lt; lenum.length; i++)
                    {
                        dwBytesRead = MAX_DATAGRAM_SIZE;
                        if (DatagramRecvBC(&amp;ncb[i], lenum.lana[i],
                            dwNum[i], szMessageArray[i],
                            MAX_DATAGRAM_SIZE, hEvent[i])
                            != NRC_GOODRET)
                            return 1;
                    }
                    dwRet = WaitForMultipleObjects(lenum.length, 
                        hEvent, FALSE, INFINITE);
                    if (dwRet == WAIT_FAILED)
                    {
                        printf(&quot;WaitForMultipleObjects failed: %d\n&quot;,
                            GetLastError());
                        return 1;
                    }
                    for(i = 0; i &lt; lenum.length; i++)
                    {
                        if (ncb[i].ncb_cmd_cplt == NRC_PENDING)
                            Cancel(&amp;ncb[i]);
                        else
                        {
                            ncb[i].ncb_buffer[ncb[i].ncb_length] = 0;
                            FormatNetbiosName(ncb[i].ncb_callname, 
                                szSender);
                            printf(&quot;%03d [LANA %d] Message: '%s' &quot;
                                &quot;received from: %s\n&quot;, j,
                                ncb[i].ncb_lana_num, 
                                szMessageArray[i], szSender);
                        }
                        ResetEvent(hEvent[i]);
                    }
                }
            }
        }
        else
        {
            if (bOneLana)
            {
                // Make a blocking datagram receive on the specified
                // LANA number
                //
                for(j = 0; j &lt; dwNumDatagrams; j++)
                {
                    if (bRecvAny)
                    {
                        // Receive data destined for any NetBIOS name
                        // in this process's name table
                        //
                        if (DatagramRecv(&amp;ncb[0], dwOneLana, 0xFF, 
                            szMessageArray[0], MAX_DATAGRAM_SIZE,
                            NULL) != NRC_GOODRET)
                            return 1;
                    }
                    else
                    {
                        if (DatagramRecv(&amp;ncb[0], dwOneLana,
                            dwNum[0], szMessageArray[0],
                            MAX_DATAGRAM_SIZE, NULL) 
                            != NRC_GOODRET)
                            return 1;
                    }
                    FormatNetbiosName(ncb[0].ncb_callname, szSender);
                    printf(&quot;%03d [LANA %d] Message: '%s' &quot;
                           &quot;received from: %s\n&quot;, j,
                           ncb[0].ncb_lana_num, szMessageArray[0],
                           szSender);
                }
            }
            else
            {
                // Post asynchronous datagram receives on each LANA
                // available. For all those commands that succeeded,
                // print the data; otherwise, cancel the command.
                //
                for(j = 0; j &lt; dwNumDatagrams; j++)
                {
                    for(i = 0; i &lt; lenum.length; i++)
                    {
                        if (bRecvAny)
                        {
                            // Receive data destined for any NetBIOS 
                            // name in this process's name table
                            // 
                            if (DatagramRecv(&amp;ncb[i], lenum.lana[i],
                                0xFF, szMessageArray[i],

                                MAX_DATAGRAM_SIZE, hEvent[i])
                                != NRC_GOODRET)
                                return 1;
                        }
                        else
                        {
                            if (DatagramRecv(&amp;ncb[i], lenum.lana[i],
                                dwNum[i], szMessageArray[i],
                                MAX_DATAGRAM_SIZE, hEvent[i])
                                != NRC_GOODRET)
                                return 1;
                        }
                    }
                    dwRet = WaitForMultipleObjects(lenum.length, 
                        hEvent, FALSE, INFINITE);
                    if (dwRet == WAIT_FAILED)
                    {
                        printf(&quot;WaitForMultipleObjects failed: %d\n&quot;,
                            GetLastError());
                        return 1;
                    }
                    for(i = 0; i &lt; lenum.length; i++)
                    {
                        if (ncb[i].ncb_cmd_cplt == NRC_PENDING)
                            Cancel(&amp;ncb[i]);
                        else
                        {
                            ncb[i].ncb_buffer[ncb[i].ncb_length] = 0;
                            FormatNetbiosName(ncb[i].ncb_callname, 
                                szSender);
                            printf(&quot;%03d [LANA %d] Message: '%s' &quot;
                                &quot;from: %s\n&quot;, j, ncb[i].ncb_lana_num,
                                szMessageArray[i], szSender);
                        }
                        ResetEvent(hEvent[i]);
                    }
                }
            }
        }
        // Clean up
        //
        for(i = 0; i &lt; lenum.length; i++)
        {
            CloseHandle(hEvent[i]);
            GlobalFree(szMessageArray[i]);
        }
        GlobalFree(hEvent);
        GlobalFree(szMessageArray);
    }
    // Clean things up
    //
    if (bOneLana)
        DelName(dwOneLana, szLocalName);
    else
    {
        for(i = 0; i &lt; lenum.length; i++)
            DelName(lenum.lana[i], szLocalName);
    }
    GlobalFree(dwNum);

    return 0;
}
</pre>
</td></tr></table>
</p>

<p>Once you've compiled the example, run the following tests to get an idea of how datagrams work. For learning purposes, you should run two instances of the applications, but on separate machines. If you run them on the same machine, they'll work, but this hides some important concepts. When run on the same machine, the LANA numbers for each side correspond to the same protocol. It's more interesting when they don't. Table 1-5 lists some commands to try. Additionally, Table 1-6 lists all the command line options available for use with the sample program.</p>

<p><b>Table 1-5.</b> <i>Nbdgram.c commands</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th><i>Client Command</i>  </th>
<th> <i>Server Command</i> </th></tr>
<tr>
<td valign="top">Nbdgram /n:CLIENT01  </td>
<td valign="top">Nbdgram /s /n:SERVER01 /r:CLIENT01  </td></tr>
<tr>
<td valign="top">Nbdgram /n:CLIENT01 /b </td>
<td valign="top"> Nbdgram /s /n:SERVER01 /b  </td></tr>
<tr>
<td valign="top">Nbdgram /g:CLIENTGROUP  </td>
<td valign="top">Nbdgram /s /r:CLIENTGROUP  </td></tr>
</table></p>
 
<p>For the third command, run several clients on various machines. This illustrates one server sending one message to a group, and each member of the group waiting for data will receive the message. Also, try various combinations of the listed commands with the /l:<i>x</i> command line option, where <i>x</i> is a valid LANA number. This command line option switches the program's mode from performing the commands on all LANAs to performing the commands on the listed LANA only. For example, the command Nbdgram /n:CLIENT01 /l:0 makes the application listen only for incoming datagrams on LANA 0 and ignore any data arriving on any other LANA. Additionally, option /a is meaningful only to the clients. This flag causes the receive command to pick up incoming datagrams destined for any NetBIOS name registered by the process. In our example, this isn't very meaningful because the client registers only one name, but you can at least see how this would be coded. You might want to try modifying the code so that it
registers a name for every /n:<i>name</i> option in the command line. Start up the server with the recipient flag set to only one of the names that the client registered. The client will receive the data, even though the <i>NCBDGRECV</i> command does not specifically refer to a particular name.</p>

<p><b>Table 1-6.</b> <i>Command parameters for Nbdgram.c</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th><i>Flag</i>  </th>
<th><i>Meaning</i>  </th></tr>
<tr>
<td valign="top">/n:<i>my-name</i>  </td>
<td valign="top">Register the unique name <i>my-name</i>.  </td></tr>
<tr>
<td valign="top">/g:<i>group-name</i>  </td>
<td valign="top">Register the group name <i>group-name</i>.  </td></tr>
<tr>
<td valign="top">/s  </td>
<td valign="top">Send datagrams (by default, the sample receives datagrams).  </td></tr>
<tr>
<td valign="top">/c:<i>n</i>  </td>
<td valign="top">Send or receive <i>n</i> number of datagrams.  </td></tr>
<tr>
<td valign="top">/r:<i>receiver</i>  </td>
<td valign="top">Specify the NetBIOS name to send the datagrams to.  </td></tr>
<tr>
<td valign="top">/b  </td>
<td valign="top">Use broadcast datagrams.  </td></tr>
<tr>
<td valign="top">/a  </td>
<td valign="top"> Post receives for any NetBIOS name (set <i>ncb_num</i> to 0xFF). </td></tr>
<tr>
<td valign="top">/l:<i>n</i>  </td>
<td valign="top">Perform all operations on LANA <i>n</i> only (by default, all sends and receives are posted on each LANA).  </td></tr>
<tr>
<td valign="top">/d:<i>n</i>  </td>
<td valign="top">Wait <i>n</i> milliseconds between sends.  </td></tr>
</table></p>
 

</BODY>
</HTML>




