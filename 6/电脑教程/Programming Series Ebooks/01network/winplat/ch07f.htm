<HTML>
<HEAD>
<TITLE>Miscellaneous API Functions</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07e.htm" , "ch07g.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="163"><H1>Miscellaneous API Functions</H1></A>

<p>In this section, we'll cover a few Winsock API functions that you might find useful when you put together your own network applications.</p>

<A NAME="164"><h3><i>getpeername</i></h3></A>
<p>This function is used to obtain the peer's socket address information on a connected socket. The function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int getpeername(
    SOCKET s,
    struct sockaddr FAR* name, 
    int FAR* namelen
);
</pre>
</td></tr></table>
</p>

<p>The first parameter is the socket for the connection, while the last two parameters are a pointer to a <i>SOCKADDR</i> structure of the underlying protocol type and its length. For datagram sockets, this function returns the address passed to a connect call; however, it will not return the address passed to a <i>sendto</i> or <i>WSASendTo</i> call.</p>

<A NAME="165"><h3><i>getsockname</i></h3></A>
<p>This function is the opposite of <i>getpeername</i>. It returns the address information for the local interface of a given socket. The function is defined as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int getsockname(
    SOCKET s, 
    struct sockaddr FAR* name, 
    int FAR* namelen
);
</pre>
</td></tr></table>
</p>

<p>The parameters are the same as the <i>getpeername</i> parameters except that the address information returned for socket <i>s</i> is the local address information. In the case of TCP, the address is the same as the server socket listening on a specific port and IP interface.</p>

<A NAME="166"><h3><i>WSADuplicateSocket</i></h3></A>
<p>The <i>WSADuplicateSocket</i> function is used to create a <i>WSAPROTOCOL_INFO</i> structure that can be passed to another process, thus enabling the other process to open a handle to the same underlying socket so that it too can perform operations on that resource. Note that this is only necessary between processes; threads in the same process can freely pass the socket descriptors. This function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSADuplicateSocket(
    SOCKET s,
    DWORD dwProcessId, 
    LPWSAPROTOCOL_INFO lpProtocolInfo
);
</pre>
</td></tr></table>
</p>

<p>The first parameter is the socket handle to duplicate. The second parameter, <i>dwProcessId</i>, is the process ID of the process that intends to use the duplicated socket. Third, the <i>lpProtocolInfo</i> parameter is a pointer to a <i>WSAPROTOCOL_INFO</i> structure that will contain the necessary information for the target process to open a duplicate handle. Some form of interprocess communication must occur so that the current process can pass the <i>WSAPROTOCOL_INFO</i> structure to the target process, which then uses this structure to create a handle to the socket (using the <i>WSASocket</i> function).</p>

<p>The descriptors in both sockets can be used independently for I/O; however, Winsock provides no access control, so it is up to the programmer to enforce some kind of synchronization. All of the state information associated with a socket is held in common across all the descriptors because the socket descriptors are duplicated, not the actual socket. For example, any socket option set by the <i>setsockopt</i> function on one of the descriptors is subsequently visible using the <i>getsockopt</i> function from any or all descriptors. If a process calls <i>closesocket</i> on a duplicated socket, it causes the descriptor in that process to become deallocated; however, the underlying socket will remain open until <i>closesocket</i> is called on the last remaining descriptor.</p>

<p>Additionally, be aware of some issues with notification on shared sockets when using <i>WSAAsyncSelect</i> and <i>WSAEventSelect</i>. These two functions are used in asynchronous I/O (discussed in <a href="ch08a.htm">Chapter 8</A>). Issuing either of these calls using any of the shared descriptors cancels any previous event registration for the socket, regardless of which descriptor was used to make that registration. Thus, for example, a shared socket cannot deliver <i>FD_READ</i> events to process A and <i>FD_WRITE</i> events to process B. If you require event notifications on both descriptors, you should rethink the design of your application to use threads as opposed to processes.</p>

<A NAME="167"><h3><i>TransmitFile</i></h3></A>
<p><i>TransmitFile</i> is a Microsoft-specific Winsock extension that allows for high-performance data transfers from a file. This is efficient is because the entire data transfer can occur in kernel mode. That is, if your application reads a chunk of data from the file and then uses <i>send</i> or <i>WSASend,</i> there are multiple send calls that involve user-mode-to-kernel-mode transitions. With <i>TransmitFile,</i> the entire read and send process is performed in kernel mode. The function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL TransmitFile( 
    SOCKET hSocket, 
    HANDLE hFile, 
    DWORD nNumberOfBytesToWrite, 
    DWORD nNumberOfBytesPerSend, 
    LPOVERLAPPED lpOverlapped, 
    LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    DWORD dwFlags 
); 
</pre>
</td></tr></table>
</p>

<p>The <i>hSocket</i> parameter identifies the connected socket on which to transfer the file. The <i>hFile</i> parameter is a handle to an opened file. (This is the file that will be sent.) The <i>nNumberOfBytesToWrite</i> indicates how many bytes to write from the file. Passing 0 indicates the entire file should be sent. The <i>nNumberOfBytesPerSend</i> parameter indicates the send size to use for write operations. For example, specifying 2048 causes <i>TransmitFile</i> to send the given file on the socket in 2-KB chunks. Passing 0 indicates using the default send size. The <i>lpOverlapped</i> parameter specifies an <i>OVERLAPPED</i> structure that is used in overlapped I/O. (See <a href="ch08a.htm">Chapter 8</A> for information on overlapped I/O.)</p>

<p>The next parameter, <i>lpTransmitBuffers,</i> is a <i>TRANSMIT</i>_<i>FILE</i>_<i>BUFFERS</i> structure that contains data to be sent before and after the file transfer. The structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _TRANSMIT_FILE_BUFFERS { 
    PVOID Head; 
    DWORD HeadLength; 
    PVOID Tail; 
    DWORD TailLength; 
} TRANSMIT_FILE_BUFFERS;
</pre>
</td></tr></table>
</p>

<p>The <i>Head</i> field is a pointer to the data to send before transmitting the file. <i>HeadLength</i> indicates the amount of data to send beforehand. The <i>Tail</i> field points to the data to send after the file is transmitted. <i>TailLength</i> is the number of bytes to send afterward.</p>

<p>The last parameter of <i>TransmitFile</i>, <i>dwFlags</i>, is used to specify flags to affect the behavior of <i>TransmitFile</i>. Table 7-2 contains the flags and their explanations.</p>

<p><b>Table 7-2.</b> <i>TransmitFile flags</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th><i>Flag</i>  </th>
<th><i>Description</i>  </th></tr>
<tr>
<td valign="top"><i>TF_DISCONNECT</i>  </td>
<td valign="top">Initiates socket closure after data has been sent.  </td></tr>
<tr>
<td valign="top"><i>TF_REUSE_SOCKET</i>  </td>
<td valign="top">Allows the socket handle to be reused in <i>AcceptEx</i> as a client socket.  </td></tr>
<tr>
<td valign="top"><i>TF_USE_DEFAULT_WORKER</i>  </td>
<td valign="top">Indicates that the transfer should take place in the context of the system's default thread. This is useful for long file transfers.  </td></tr>
<tr>
<td valign="top"><i>TF_USE_SYSTEM_THREAD</i>  </td>
<td valign="top">Indicates that the transfer should take place in the context of the system thread. This is also useful for long file transfers.  </td></tr>
<tr>
<td valign="top"><i>TF_USE_KERNEL_APC</i>  </td>
<td valign="top">Indicates that kernel Asynchronous Procedure Calls (APC) should process the file transfer. This can offer a significant performance increase if reading the file into the cache requires only one read.  </td></tr>
<tr>
<td valign="top"><i>TF_WRITE_BEHIND</i>  </td>
<td valign="top">Indicates that <i>TransmitFile</i> should complete without having all the data acknowledged by the remote system.  </td></tr>
</table></p>

</BODY>
</HTML>




