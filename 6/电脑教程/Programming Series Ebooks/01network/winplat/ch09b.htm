<HTML>
<HEAD>
<TITLE>Socket Options</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch09a.htm" , "ch09c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="199"><H1>Socket Options</H1></A>

<p>The <i>getsockopt</i> function is most frequently used to obtain information regarding the given socket. The prototype for this function is as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int getsockopt (
    SOCKET s, 
    int level, 
    int optname, 
    char FAR* optval, 
    int FAR* optlen
);
</pre>
</td></tr></table>
</p>

<p>The first parameter, <i>s</i>, is the socket on which you want to perform the specified option. This must be a valid socket for the given protocol you are using. A number of options are specific to a particular protocol and socket type, while others pertain to all types of sockets. This ties in with the second parameter, <i>level</i>. An option of level <i>SOL_SOCKET</i> means it is a generic option that isn't necessarily specific to a given protocol. We say &quot;necessarily&quot; because not all protocols implement each socket option of level <i>SOL_SOCKET</i>. For example, <i>SO_BROADCAST</i> puts the socket into broadcast mode, but not all supported protocols support the notion of broadcast sockets. The <i>optname</i> parameter is the actual option you are interested in. These option names are constant values defined in the Winsock header files. The most common and protocol-independent options (such as those with the <i>SOL_SOCKET</i> level) are defined in Winsock.h and Winsock2.h. Each specific protocol has its own header file that defines options specific to it. Finally, the <i>optval</i> and <i>optlen</i> parameters are the variables returned with the value of the desired option. In most cases&#8212;but not all&#8212;the option value is an integer.</p>

<p>The <i>setsockopt</i> function is used to set socket options on either a socket level or a protocol-specific level. The function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int setsockopt (
    SOCKET s, 
    int level, 
    int optname, 
    const char FAR * optval, 
    int optlen
);
</pre>
</td></tr></table>
</p>

<p>The parameters are the same as in <i>getsockopt</i> except that you pass in a value as the <i>optval</i> and <i>optlen</i> parameters, which are the values to set for the specified option. As with <i>getsockopt</i>, <i>optval</i> is often, but not always, an integer. Consult each option for the specifics on what is passed as the option value.</p>

<p>The most common mistake associated with calling either <i>getsockopt</i> or <i>setsockopt</i> is attempting to obtain socket information for a socket whose underlying protocol doesn't possess that particular characteristic. For example, a socket of type <i>SOCK_STREAM</i> is not capable of broadcasting data; therefore, attempting to set or get the <i>SO_BROADCAST</i> option results in the error <i>WSAENOPROTOOPT</i>.</p>

<A NAME="200"><h2><i>SOL_SOCKET</i> Option Level</h2></A>
<p>This section describes the socket options that return information based on the characteristics of the socket itself and are not specific to the protocol of that socket.</p>

<A NAME="201"><h3><i>SO_ACCEPTCONN</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, socket is in listening mode.</td>
		</tr>

	</table>
</p>


<p>If the socket has been put into listening mode by the <i>listen</i> function, this option returns <i>TRUE</i>. Sockets of type <i>SOCK_DGRAM</i> do not support this option.</p>

<A NAME="202"><h3><i>SO_BROADCAST</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, socket is configured for sending broadcast messages.</td>
		</tr>
		
	</table>
</p>

<p>If the given socket has been configured for sending or receiving broadcast data, querying this socket option returns <i>TRUE</i>. Use <i>setsockopt</i> with <i>SO_BROADCAST</i> to enable broadcast abilities on the socket. This option is valid for sockets that aren't of type <i>SOCK_STREAM</i>.</p>

<p>Broadcasting is the ability to send data so that every machine on the local subnet receives the data. Of course, there must be some process on each machine that listens for incoming broadcast data. The drawback of broadcasting is that if many processes are all sending broadcast data, the network can become saturated and network performance suffers. In order to receive a broadcast message, you must enable the broadcast option and then use one of the datagram receive functions, such as <i>recvfrom</i> or <i>WSARecvfrom</i>. You can also connect the socket to the broadcast address by calling <i>connect</i> or <i>WSAConnect</i> and then use <i>recv</i> or <i>WSARecv</i>. For UDP broadcasts, you must specify a port number to send the datagram to; likewise, the receiver must request to receive the broadcast data on that port also. The following code example illustrates how to send a broadcast message with UDP:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SOCKET       s;
BOOL         bBroadcast;
char         *sMsg = &quot;This is a test&quot;;
SOCKADDR_IN bcast;

s = WSASocket(AF_INET, SOCK_DGRAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED);
bBroadcast = TRUE;
setsockopt(s, SOL_SOCKET, SO_BROADCAST, (char *)&amp;bBroadcast,
    sizeof(BOOL));
bcast.sin_family = AF_INET;
bcast.sin_addr.s_addr = inet_addr(INADDR_BROADCAST);
bcast.sin_port = htons(5150);
sendto(s, sMsg, strlen(sMsg), 0, (SOCKADDR *)&amp;bcast, sizeof(bcast));
</pre>
</td></tr></table>
</p>

<p>For UDP, a special broadcast address exists to which broadcast data should be sent. This address is 255.255.255.255. A <i>#define</i> directive for <i>INADDR_BROADCAST</i> is provided to make things a bit simpler and easier to read.</p>

<p>AppleTalk is another protocol capable of sending broadcast messages. AppleTalk also has a special address used by broadcast data. You learned in <a href="ch06a.htm">Chapter 6</A> that an AppleTalk address has three parts: network, node, and socket (destination). For broadcasting, set the destination to <i>ATADDR_BROADCAST</i> (0xFF), which causes the datagram to be sent to all endpoints on the given network.</p>

<p>Normally, you need to set only the <i>SO_BROADCAST</i> option when sending broadcast datagrams. To receive a broadcast datagram, you need to be listening only for incoming datagrams on that specified port. However, on Windows 95 when using IPX, the receiving socket must set the <i>SO_BROADCAST</i> option in order to receive broadcast data, as described in Knowledge Base article Q137914, which can be found at <a href="http://support.microsoft.com/support/search" target="_window2">http://support.microsoft.com/support/search</a>. This is a bug in Windows 95.</p>

<A NAME="203"><h3><i>SO_CONNECT_TIME</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1+</td>
			<td valign="top">Returns the number of seconds the socket has been connected</td>
		</tr>
		
	</table>
</p>

<p><i>SO_CONNECT_TIME</i> is a Microsoft-specific option that returns the number of seconds a connection has been established. The most frequent use of this option is with the <i>AcceptEx</i> function. <i>AcceptEx</i> requires that a valid socket handle be passed for the incoming client connection. This option can be called on the client's <i>SOCKET</i> handle to determine whether the connection has been made and how long the connection as been established. If the socket is not currently connected, the value returned is 0xFFFFFFFF.</p>

<A NAME="204"><h3><i>SO_DEBUG</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, debug output is enabled.</td>
		</tr>
		
	</table>
</p>

<p>Winsock service providers are encouraged (but not required) to supply output debug information if the <i>SO_DEBUG</i> option is set by an application. How the debug information is presented depends on the underlying service provider's implementation. To turn debug information on, call <i>setsockopt</i> with <i>SO_DEBUG</i> and a Boolean variable set to <i>TRUE</i>. Calling <i>getsockopt</i> with <i>SO_DEBUG</i> returns <i>TRUE</i> or <i>FALSE</i> if debugging is enabled or disabled, respectively. Unfortunately, no Win32 platform currently implements the <i>SO_DEBUG</i> option, as described in Knowledge Base article Q138965. No error is returned when the option is set, but the underlying network provider ignores the option.</p>

<A NAME="205"><h3><i>SO_DONTLINGER</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, <i>SO_LINGER</i> is disabled.</td>
		</tr>
		
	</table>
</p>

<p>For protocols that support graceful socket connection closure, a mechanism is implemented so that if one or both sides close the socket, any data still pending or in transmission will be sent or received by both parties. It is possible, with <i>setsockopt</i> and the <i>SO_LINGER</i> option, to change this behavior so that after a specified period of time, the socket and all its resources will be torn down. Any pending or arriving data associated with that socket is discarded and the peer's connection reset (<i>WSAECONNRESET</i>). The <i>SO_DONTLINGER</i> option can be checked to ensure that a linger period has not been set. Calling <i>getsockopt</i> with <i>SO_DONTLINGER</i> will return a Boolean <i>TRUE</i> or <i>FALSE</i> if a linger value is set or not set, respectively. A call to <i>setsockopt</i> with <i>SO_DONTLINGER</i> disables lingering. Sockets of type <i>SOCK_DGRAM</i> do not support this option.</p>

<A NAME="206"><h3><i>SO_DONTROUTE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, messages are sent directly to the network interface without consulting the routing table.</td>
		</tr>
		
	</table>
</p>

<p>The <i>SO_DONTROUTE</i> option tells the underlying network stack to ignore the routing table and to send the data out on the interface the socket is bound to. For example, if you create a UDP socket and bind it to interface A and then send a packet destined for a machine on the network attached to interface B, the packet will in fact be routed so that it is sent on interface B. Using <i>setsockopt</i> with the Boolean value <i>TRUE</i> prevents this because the packet goes out on the bound interface. The <i>getsockopt</i> function can be called to determine whether routing is enabled (which it is by default).</p>

<p>Calling this option on a Win32 platform will succeed; however, the Microsoft provider silently ignores the request and always uses the routing table to determine the appropriate interface for outgoing data.</p>

<A NAME="207"><h3><i>SO_ERROR</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1+</td>
			<td valign="top">Returns the error status</td>
		</tr>
		
	</table>
</p>

<p>The <i>SO_ERROR</i> option returns and resets the per-socket-based error code, which is different from the per-thread-based error code that is handled using the <i>WSAGetLastError</i> and <i>WSASetLastError</i> function calls. A successful call using the socket does not reset the per-socket-based error code returned by the <i>SO_ERROR</i> option. Calling this option will not fail; however, the error value is not always updated immediately, so there is a possibility of this option returning 0 (indicating no error). It is best to use <i>WSAGetLastError</i> unless it is absolutely necessary to rely on the individual error code.</p>

<A NAME="208"><h3><i>SO_EXCLUSIVEADDRUSE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">2+</td>
			<td valign="top">If <i>TRUE</i>, the local port that the socket is bound to cannot be reused by another process.</td>
		</tr>
		
	</table>
</p>

<p>This option is the complement of <i>SO_REUSEADDR</i>, which we will describe shortly. This option exists to prevent other processes from using the <i>SO_REUSEADDR</i> on a local address that your application is using. If two separate processes are bound to the same local address (assuming that <i>SO_REUSEADDR</i> is set earlier), which of the two sockets receives notifications for incoming connections is not defined. This is extremely unfortunate if your application is mission-critical. The <i>SO_EXCLUSIVEADDRUSE</i> option locks down the local address to which the socket is bound, so if any other process tries to use <i>SO_REUSEADDR</i> with the same local address, that process fails. Administrator rights are required to set this option. It is available only on Windows 2000.</p>

<A NAME="209"><h3><i>SO_KEEPALIVE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, socket is configured to send keepalive messages on the session.</td>
		</tr>
		
	</table>
</p>

<p>For a TCP-based socket, an application can request that the underlying service provider enable the use of keepalive packets on TCP connections by turning on the <i>SO_KEEPALIVE</i> socket option. On Win32 platforms, keepalives are implemented in accordance with section 4.2.3.6 of RFC 1122. If a connection is dropped as the result of keepalives, the error code <i>WSAENETRESET</i> is returned to any calls in progress on the socket, and any subsequent calls will fail with <i>WSAENOTCONN</i>. For the exact implementation details, consult the RFC. The important thing to note here is that keepalives are sent at intervals no less than 2 hours apart. The 2-hour keepalive time is configurable via the Registry; however, changing the default value changes the keepalive behavior for all TCP connections on the system, which is generally discouraged. Another solution is to implement your own keepalive strategy. <a href="ch07a.htm">Chapter 7</A> discusses this kind of strategy. Sockets of type <i>SOCK_DGRAM</i> do not support this option.</p>

<p>The Registry keys for keepalives are <i>KeepAliveInterval</i> and <i>KeepAliveTime</i>. Both keys store values of type <i>REG_DWORD</i> in milliseconds. The former key is the interval separating keepalive retransmissions until a response is received; the latter entry controls how often TCP sends a keepalive packet in an attempt to verify that an ideal connection is still valid. In Windows 95 and Windows 98, these keys are located under the following Registry path:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
\HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\VxD\MSTCP
</pre>
</td></tr></table>
</p>

<p>In Windows NT and Windows 2000, store the keys under</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
\HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services\TCPIP\Parameters
</pre>
</td></tr></table>
</p>

<p>With Windows 2000, a new socket ioctl command&#8212;<i>SIO_KEEPALIVE_VALS</i>&#8212;allows you to change the keepalive value and interval on a per-socket basis, as opposed to a system-wide basis. This ioctl command is described later in this chapter.</p>

<A NAME="210"><h3><i>SO_LINGER</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>struct linger</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">Sets or gets the current linger values</td>
		</tr>
		
	</table>
</p>

<p><i>SO_LINGER</i> controls the action taken when unsent data is queued on a socket and a <i>closesocket</i> is performed. A call to <i>getsockopt</i> with this socket option returns the current linger times in a <i>linger</i> structure, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
struct linger { 
    u_short l_onoff; 
    u_short l_linger;
}
</pre>
</td></tr></table>
</p>

<p>A nonzero value for <i>l_onoff</i> means that lingering is enabled, while <i>l_linger</i> is the timeout in seconds, at which point any pending data to be sent or received is discarded and the connection with the peer is reset. Conversely, you can call <i>setsockopt</i> to turn lingering on and specify the length of time before discarding any queued data. This is accomplished by setting the desired values in a variable of type <i>struct linger</i>. When setting a linger value with <i>setsockopt,</i> you must set the <i>l_onoff</i> field of the structure to a nonzero value. To turn lingering off once it has been enabled, you can call <i>setsockopt</i> with the <i>SO_LINGER</i> option and the <i>l_onoff</i> field of the <i>linger</i> structure set to 0, or you can call <i>setsockopt</i> with the <i>SO_DONTLINGER</i> option, passing the value <i>TRUE</i> for the <i>optval</i> parameter. Sockets of type <i>SOCK_DGRAM</i> do not support this option.</p>

<p>Setting the linger option directly affects how a connection behaves when the <i>closesocket</i> function is called. Table 9-1 lists these behaviors.</p>

<p><b>Table 9-1.</b> <i>Linger options</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th><i>Option</i></th>
			<th><i>Interval</i></th>
			<th><i>Type of Close</i></th>
			<th><i>Wait for Close?</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>SO_DONTLINGER</i></td>
			<td valign="top">Not applicable</td>
			<td valign="top">Graceful</td>			
			<td valign="top">No</td>
		</tr>

		<tr>
			<td valign="top"><i>SO_LINGER</i></td>
			<td valign="top">0</td>
			<td valign="top">Hard</td>			
			<td valign="top">No</td>
		</tr>

		<tr>
			<td valign="top"><i>SO_LINGER</i></td>
			<td valign="top">Nonzero</td>
			<td valign="top">Graceful</td>			
			<td valign="top">Yes</td>
		</tr>

	</table>
</p>

<p>If <i>SO_LINGER</i> is set with a zero timeout interval (that is, the <i>linger</i> structure member <i>l_onoff</i> is not 0 and <i>l_linger</i> is 0), <i>closesocket</i> is not blocked, even if queued data has not yet been sent or acknowledged. This is called a hard, or abortive, close because the socket's virtual circuit is reset immediately and any unsent data is lost. Any receive call on the remote side of the circuit fails with <i>WSAECONNRESET</i>.</p>

<p>If <i>SO_LINGER</i> is set with a nonzero timeout interval on a blocking socket, the <i>closesocket</i> call blocks on a blocking socket until the remaining data has been sent or until the timeout expires. This is called a graceful disconnect. If the timeout expires before all data has been sent, the Windows Sockets implementation terminates the connection before <i>closesocket</i> returns.</p>

<A NAME="211"><h3><i>SO_MAX_MSG_SIZE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>unsigned int</i></td>
			<td valign="top">Get only</td>
			<td valign="top">2+</td>
			<td valign="top">The maximum size of a message for a message-oriented socket</td>
		</tr>
		
	</table>
</p>

<p>This is a get-only socket option that indicates the maximum outbound (send) size of a message for message-oriented socket types as implemented by a particular service provider. It has no meaning for byte-stream-oriented sockets. There is no provision for finding the maximum inbound message size.</p>

<A NAME="212"><h3><i>SO_OOBINLINE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, any out-of-band data is returned in the normal data stream.</td>
		</tr>
		
	</table>
</p>

<p>By default, out-of-band (OOB) data is not inlined. That means a call to a receive function (with the appropriate <i>MSG_OOB</i> flag set) returns the OOB data in a single call. If this option is set, the OOB data appears within the data stream returned from a receive call, and a call to <i>ioctlsocket</i> with the <i>SIOCATMARK</i> option is required to determine which byte is the OOB data. Sockets of type <i>SOCK_DGRAM</i> do not support this option. Unfortunately, this socket option is broken on all current Win32 implementations. See <a href="ch07a.htm">Chapter 7</A> for more details on OOB data.</p>

<A NAME="213"><h3><i>SO_PROTOCOL_INFO</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>WSAPROTOCOL_INFO</i></td>
			<td valign="top">Get only</td>
			<td valign="top">2+</td>
			<td valign="top">The protocol characteristics for the protocol that the socket is bound to</td>
		</tr>
		
	</table>
</p>

<p>This is another get-only option that fills in the supplied <i>WSAPROTOCOL_INFO</i> structure with the characteristics of the protocol associated with the socket. See <a href="ch06a.htm">Chapter 6</a> for a description of the <i>WSAPROTOCOL_INFO</i> structure and its member fields.</p>

<A NAME="214"><h3><i>SO_RCVBUF</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">Gets or sets the per-socket buffer size for receive operations</td>
		</tr>
		
	</table>
</p>

<p>This is a simple option that either returns the size or sets the size of the buffer allocated to this socket for receiving data. When a socket is created, a send buffer and a receive buffer are assigned to the socket for sending and receiving data. When requesting to set the receive buffer size to a value, the call to <i>setsockopt</i> can succeed even when the implementation does not provide the entire amount requested. To ensure that the requested buffer size is allocated, call <i>getsockopt</i> to get the actual size allocated. All Win32 platforms can get or set the receive buffer size except Windows CE, which does not allow you to change the value&#8212;you can get only the receive buffer size.</p>

<p>One possible reason for changing the buffer size is to specifically tailor buffer sizes according to your application's behavior. For example, when writing code to receive UDP datagrams, you should generally make the receive buffer size an even multiple of the datagram size. For overlapped I/O, setting the buffer sizes to 0 can increase performance in certain situations: when these buffers are nonzero, an extra memory copy is involved in moving data from the system buffer to the user-supplied buffer. If there is no intermediate buffer, data is immediately copied to the user-supplied buffer. The one caveat is that this is efficient only with multiple outstanding receive calls. Posting only a single receive can hurt performance, as the local system cannot accept any incoming data unless you have a buffer posted and ready to receive the data. For more information, see the section called &quot;<A HREF="ch08c.htm#193">Other Issues</A>&quot; under the completion port I/O model in Chapter 8.</p>

<A NAME="215"><h3><i>SO_REUSEADDR</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, the socket can be bound to an address already in use by another socket or to an address in the <i>TIME_WAIT</i> state.</td>
		</tr>
		
	</table>
</p>

<p>By default, a socket cannot be bound to a local address that is already in use; however, occasionally it is necessary to reuse an address in this way. Remember from <a href="ch07a.htm">Chapter 7</A> that each connection is uniquely identified by the combination of its local and remote addresses. As long as the address to which you are connecting is unique in the slightest respect (such as a different port number in TCP/IP), the binding will be allowed.</p>

<p>The only exception is for a listening socket. Two separate sockets cannot bind to the same local interface (and port, in the case of TCP/IP) to await incoming connections. If two sockets are actively listening on the same port, the behavior is undefined as to which socket will receive notification of an incoming connection. The <i>SO_REUSEADDR</i> option is most useful in TCP when a server shuts down or exits abnormally so that the local address and port are in the <i>TIME_WAIT</i> state, which prevents any other sockets from binding to that port. By setting this option, the server can listen on the same local interface and port when it is restarted.</p>

<A NAME="216"><h3><i>SO_SNDBUF</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top"><i>TRUE</i> (nonzero) means socket is configured for sending broadcast messages.</td>
		</tr>
		
	</table>
</p>

<p>This is a simple option that either returns the size or sets the size of the buffer allocated to this socket for sending data. When a socket is created, a send buffer and a receive buffer are assigned to the socket for sending and receiving data. When requesting to set the size of the send buffer, the call to <i>setsockopt</i> can succeed even when the implementation does not provide the entire amount requested. To ensure that the requested buffer size is allocated, call <i>getsockopt</i> to get the actual size allocated. All Win32 platforms can get or set the send buffer size except Windows CE, which does not allow you to change the value&#8212;you can get only the receive buffer size.</p>

<p>As with <i>SO_RCVBUF</i>, you can use the <i>SO_SNDBUF</i> option to set the size of the send buffer to 0. The advantage of the buffer size being 0 for blocking send calls is that when the call completes you know that your data is on the wire. Also, as in the case of a receive operation with a zero-length buffer, there is no extra memory copy of your data to system buffers. The drawback is that you lose the pipelining gained by the default stack buffering when the send buffers are nonzero in size. In other words, if you have a loop performing sends, the local network stack can copy your data to a system buffer to be sent when possible (depending on the I/O model being used). On the other hand, if your application is concerned with other logistics, disabling the send buffers can save you a few machine instructions in the memory copy. For additional information, see the section entitled &quot;<A HREF="ch08c.htm#193">Other Issues</A>&quot; under the completion port I/O model in Chapter 8.</p>

<A NAME="217"><h3><i>SO_TYPE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1+</td>
			<td valign="top">Returns the socket type (e.g., <i>SOCK_DGRAM</i>, <i>SOCK_STREAM</i>, etc.) of the given socket</td>
		</tr>
		
	</table>
</p>

<p>The <i>SO_TYPE</i> option is a get-only option that simply returns the socket type of the given socket. The possible socket types are <i>SOCK_DGRAM</i>, <i>SOCK_STREAM</i>, <i>SOCK_SEQPACKET</i>, <i>SOCK_RDM</i>, and <i>SOCK_RAW</i>.</p>

<A NAME="218"><h3><i>SO_SNDTIMEO</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">Gets/sets the timeout value (in milliseconds) associated with sending data on the socket</td>
		</tr>
		
	</table>
</p>

<p>The <i>SO_SNDTIMEO</i> option sets the timeout value on a blocking socket when calling a Winsock send function. The timeout value is an integer in milliseconds that indicates how long the send function should block when attempting to send data. If you need to use the <i>SO_SNDTIMEO</i> option and you use the <i>WSASocket</i> function to create the socket, you must specify <i>WSA_FLAG_OVERLAPPED</i> as part of <i>WSASocket</i>'s <i>dwFlags</i> parameter. Subsequent calls to any Winsock send function (<i>send</i>, <i>sendto</i>, <i>WSASend</i>, <i>WSASendTo</i>, and so on) block only for the amount of time specified. If the send operation cannot complete within that time, the call fails with error 10060 (<i>WSAETIMEDOUT</i>).</p>

<p>For performance reasons, this option was disabled in Windows CE 2.1. If you attempt to set this option, the option is silently ignored and no failure is returned. Previous versions of Windows CE do implement this option.</p>

<A NAME="219"><h3><i>SO_RCVTIMEO</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">Gets/sets the timeout value (in milliseconds) associated with receiving data on the socket</td>
		</tr>
		
	</table>
</p>

<p>The <i>SO_RCVTIMEO</i> option sets the receive timeout value on a blocking socket. The timeout value is an integer in milliseconds that indicates how long a Winsock receive function should block when attempting to receive data. If you need to use the <i>SO_RCVTIMEO</i> option and you use the <i>WSASocket</i> function to create the socket, you must specify <i>WSA_FLAG_OVERLAPPED</i> as part of <i>WSASocket</i>'s <i>dwFlags</i> parameter. Subsequent calls to any Winsock receive function (<i>recv</i>, <i>recvfrom</i>, <i>WSARecv</i>, <i>WSARecvFrom</i>, and so on) block only for the amount of time specified. If no data arrives within that time, the call fails with the error 10060 (<i>WSAETIMEDOUT</i>).</p>

<p>For performance reasons, this option was disabled in Windows CE 2.1. If you attempt to set this option, it is silently ignored and no failure returns. Previous versions of Windows CE do implement this option.</p>

<A NAME="220"><h3><i>SO_UPDATE_ACCEPT_CONTEXT</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>SOCKET</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">Gets/sets the timeout value (in milliseconds) associated with receiving data on the socket</td>
		</tr>
		
	</table>
</p>

<p>This option is a Microsoft-specific extension most commonly used in conjunction with the <i>AcceptEx</i> function. The unique characteristic of this function is that it is part of the Winsock 1 specification and allows the use of overlapped I/O for an accept call. The function takes the listening socket as a parameter as well as a socket handle that becomes the accepted client. This socket option must be set in order for the characteristics of the listening socket to be carried over to the client socket. This is particularly important for Quality of Service (QOS)-enabled listening sockets. In order for the client socket to be QOS-enabled, this option must be set. To set this option on a socket, use the listening socket as the <i>SOCKET</i> parameter to <i>setsockopt</i> and pass the accepting socket handle (for example, the client handle) as <i>optval</i>. This option is specific to Windows NT and Windows 2000.</p>

<A NAME="221"><h2><i>SOL_APPLETALK</i> Option Level</h2></A>
<p>The following options are socket options specific to the AppleTalk protocol and can be used only with sockets created using <i>socket</i> or <i>WSASocket</i> with the <i>AF_APPLETALK</i> flag. A majority of the options listed here deal with either setting or obtaining AppleTalk names. For more information on the AppleTalk address family, refer back to <a href="ch06a.htm">Chapter 6</A>. Some AppleTalk socket options&#8212;such as <i>SO_DEREGISTER_NAME</i>&#8212;have more than one option name. In such cases, all the option's names can be used interchangeably.</p>

<A NAME="222"><h3><i>SO_CONFIRM_NAME</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>WSH_NBP_TUPLE</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1</td>
			<td valign="top">Confirms that the given AppleTalk name is bound to the given address</td>
		</tr>
		
	</table>
</p>

<p>The <i>SO_CONFIRM_NAME</i> option is used to verify that a given AppleTalk name is bound to the supplied address. This results in a Name Binding Protocol (NBP) lookup request being sent to the address to verify the name. If the call fails with the error <i>WSAEADDRNOTAVAIL</i>, the name is no longer bound to the address given.</p>

<A NAME="223"><h3><i>SO_DEREGISTER_NAME</I>, <I>SO_REMOVE_NAME</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>WSH_REGISTER_NAME</i></td>
			<td valign="top">Set only</td>
			<td valign="top">1</td>
			<td valign="top">Deregisters the given name from the network</td>
		</tr>
		
	</table>
</p>

<p>This option is used to deregister a name from the network. If the name does not currently exist on the network, the call will return indicating success. Refer to the section entitled &quot;<A HREF="ch06f.htm#126">Registering an AppleTalk Name</A>&quot; in Chapter 6 for a description of the <i>WSH_REGISTER_NAME</i> structure, which is simply another name for the <i>WSH_NBP_NAME</i> structure.</p>

<A NAME="224"><h3><i>SO_LOOKUP_MYZONE</I>, <I>SO_GETMYZONE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>char *</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1</td>
			<td valign="top">Returns the default zone on the network</td>
		</tr>
		
	</table>
</p>

<p>This option returns the default zone on the network. The <i>optval</i> parameter to <i>getsockopt</i> should be a character string of at least 33 characters. Remember that the maximum length of an NBP name is <i>MAX_ENTITY_LEN</i>, which is defined as 32. The extra character is required for the null terminator.</p>

<A NAME="225"><h3><i>SO_LOOKUP_NAME</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>WSH_LOOKUP_NAME</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1</td>
			<td valign="top">Looks up a specified NBP name and returns the matching tuples of names and NBP information</td>
		</tr>
		
	</table>
</p>

<p>This option is used to look up a specified name on the network (for example, when a client wants to connect to a server). The well-known textual name must be resolved to an AppleTalk address before a connection can be established. See the section &quot;<A HREF="ch06f.htm#127">Resolving an AppleTalk Name</A>&quot; in Chapter 6 for sample code on how to look up an AppleTalk name.</p>

<p>One thing to be aware of is that upon successful return, the <i>WSH_NBP_TUPLE</i> structures occupy the space in the supplied buffer after the <i>WSH_LOOKUP_NAME</i> information. That is, you should supply <i>getsockopt</i> with a buffer large enough to hold the <i>WSH_LOOKUP_NAME</i> information at the start of the buffer and a number of <i>WSH_NBP_TUPLE</i> structures in the remaining space. Figure 9-1 illustrates how the buffer should be prepared prior to the call (with respect to <i>WSH_LOOKUP_NAME</i>) and where the <i>WSH_NBP_TUPLE</i> structures are placed upon return.</p>

<p>
<A HREF="javascript:fullSize('F09ji01x.htm')"> <img src="images/F09ji01.JPG" width=404 height=43 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 9-1.</b> SO_LOOKUP_NAME <i>buffer</i><!-- /caption -->
</p>

<A NAME="226"><h3><i>SO_LOOKUP_ZONES</I>, <I>SO_GETZONELIST</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>WSH_LOOKUP_ZONES</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1</td>
			<td valign="top">Returns zone names from the Internet zone lists</td>
		</tr>
		
	</table>
</p>

<p>This option requires a buffer large enough to contain a <i>WSH_LOOKUP_ZONES</i> structure at the head. Upon successful return, the space after the <i>WSH_LOOKUP_ZONES</i> structure contains the list of null-terminated zone names. The following code demonstrates how to use the <i>SO_LOOKUP_ZONES</i> option:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
PWSH_LOOKUP_NAME     atlookup;
PWSH_LOOKUP_ZONES    zonelookup;
char                 cLookupBuffer[4096],
                     *pTupleBuffer = NULL;

atlookup = (PWSH_LOOKUP_NAME)cLookupBuffer;
zonelookup = (PWSH_LOOKUP_ZONES)cLookupBuffer;
ret = getsockopt(s, SOL_APPLETALK, SO_LOOKUP_ZONES, (char *)atlookup, 
    &amp;dwSize);
pTupleBuffer = (char *)cLookupBuffer + sizeof(WSH_LOOKUP_ZONES);
for(i = 0; i &lt; zonelookup-&gt;NoZones; i++)
{
    printf(&quot;%3d: '%s'\n&quot;, i + 1, pTupleBuffer);
    while (*pTupleBuffer++);
}
</pre>
</td></tr></table>
</p>

<A NAME="227"><h3><i>SO_LOOKUP_ZONES_ON_ADAPTER</I>, <I>SO_GETLOCALZONES</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>WSH_LOOKUP_ZONES</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1</td>
			<td valign="top">Returns a list of zone names known to the given adapter name</td>
		</tr>
		
	</table>
</p>

<p>This option is similar to <i>SO_LOOKUP_ZONES</i> except that you specify the adapter name for which you want to obtain a list of zones local to the network that that adapter is connected to. Again, you must supply a sufficiently large buffer that has a <i>WSH_LOOKUP_ZONES</i> structure at the head. The returned list of null-terminated zone names begins in the space after the <i>WSH_LOOKUP_ZONES</i> structure. Additionally, the name of the adapter must be passed in as a UNICODE string (<i>WCHAR</i>).</p>

<A NAME="228"><h3><i>SO_LOOKUP_NETDEF_ON_ADAPTER</I>, <I>SO_GETNETINFO</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>WSH_LOOKUP_NETDEF_ON_ADAPTER</i></td>
			<td valign="top">Set only</td>
			<td valign="top">1</td>
			<td valign="top">Returns the seeded values for the network as well as the default zone</td>
		</tr>
		
	</table>
</p>

<p>This option returns the seeded values for the network numbers and a null-terminated ANSI string containing the default zone for the network on the indicated adapter. The adapter is passed as a UNICODE (<i>WCHAR</i>) string following the structure and is overwritten by the default zone upon function return. If the network is not seeded, the network range 1-0xFFFE is returned and the null-terminated ANSI string contains the default zone &quot;*.&quot;</p>

<A NAME="229"><h3><i>SO_PAP_GET_SERVER_STATUS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>WSH_PAP_GET_SERVER_STATUS</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1</td>
			<td valign="top">Returns the PAP status from a given server</td>
		</tr>
		
	</table>
</p>

<p>This option gets the Printer Access Protocol (PAP) status registered on the address specified in <i>ServerAddr</i> (usually obtained via an NBP lookup). The four reserved bytes correspond to the four reserved bytes in the PAP status packet. These will be in network byte order. A PAP status string can be arbitrary and is set with the option <i>SO_PAP_SET_SERVER_STATUS</i>, which we'll explain later in this chapter. The <i>WSH_PAP_GET_SERVER_STATUS</i> structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
#define    MAX_PAP_STATUS_SIZE        255
#define    PAP_UNUSED_STATUS_BYTES        4

typedef struct _WSH_PAP_GET_SERVER_STATUS
{
    SOCKADDR_AT            ServerAddr;
    UCHAR                  Reserved[PAP_UNUSED_STATUS_BYTES];
    UCHAR                  ServerStatus[MAX_PAP_STATUS_SIZE + 1];

} WSH_PAP_GET_SERVER_STATUS, *PWSH_PAP_GET_SERVER_STATUS;
</pre>
</td></tr></table>
</p>

<p>The following code snippet is a quick example of how to request the PAP status. The length of the status string is the first byte of the <i>ServerStatus</i> field.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
WSH_PAP_GET_SERVER_STATUS  status;
int                        nSize = sizeof(status);

status.ServerAddr.sat_family = AF_APPLETALK;
ret = getsockopt(s, SOL_APPLETALK, SO_PAP_GET_SERVER_STATUS, 
    (char *)&amp;status, &amp;nSize);
</pre>
</td></tr></table>
</p>

<A NAME="230"><h3><i>SO_PAP_PRIME_READ</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>char []</i></td>
			<td valign="top">Set only</td>
			<td valign="top">1</td>
			<td valign="top">This call primes a read on a PAP connection so that the sender can actually send the data.</td>
		</tr>
		
	</table>
</p>

<p>When this option is called on a socket describing a PAP connection, it enables the remote client to send the data without the local application having called <i>recv</i> or <i>WSARecvEx</i>. After this option is set, the application can block on a <i>select</i> call and then the actual reading of the data can occur. The <i>optval</i> parameter to this call is the buffer that is to receive the data, which must be at least <i>MIN_PAP_READ_BUF_SIZE</i> (4096) bytes in length. This option allows support for nonblocking sockets on the read-driven PAP protocol. Note that for each buffer you want to read, you must make a call to <i>setsockopt</i> with the <i>SO_PAP_PRIME_READ</i> option.</p>

<A NAME="231"><h3><i>SO_PAP_SET_SERVER_STATUS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>char []</i></td>
			<td valign="top">Set only</td>
			<td valign="top">1</td>
			<td valign="top">Sets the status to be sent if another client requests the status</td>
		</tr>
		
	</table>
</p>

<p>A client can request to obtain the PAP status by using <i>SO_PAP_GET_SERVER_STATUS</i>. This option can be used to set the status so that if clients request the PAP status, the buffer submitted to the set command will be returned on the get command. The status is a buffer of at most 255 bytes containing the status of the associated socket. If the set option is called with a null buffer, the previous status value set is erased.</p>

<A NAME="232"><h3><i>SO_REGISTER_NAME</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>WSH_REGISTER_NAME</i></td>
			<td valign="top">Set only</td>
			<td valign="top">1</td>
			<td valign="top">Registers the given name on the AppleTalk network</td>
		</tr>
		
	</table>
</p>

<p>This option is used to register the supplied name on the AppleTalk network. If the name already exists on the network, the error <i>WSAEADDRINUSE</i> is returned. Refer to <a href="ch06a.htm">Chapter 6</A> for a description of the <i>WSH_REGISTER_NAME</i> structure.</p>

<A NAME="233"><h2><i>SOL_IRLMP</i> Option Level</h2></A>
<p>The <i>SOL_IRLMP</i> level deals with the IrDA protocol, whose address family is <i>AF_IRDA</i>. One important thing to keep in mind when using IrDA socket options is that the implementation of infrared sockets varies among platforms. Because Windows CE first offered IR support, it does not have all the options available that were introduced later, in Windows 98 or Windows 2000. In this section, each option is followed by the platforms it is supported on.</p>

<A NAME="234"><h3><i>IRLMP_9WIRE_MODE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">Gets/sets IP options within the IP header</td>
		</tr>
		
	</table>
</p>

<p>This is another rarely used option needed to communicate with Windows 98 via IrCOMM, which is at a lower level than the level at which IrSock normally operates. In 9-wire mode, each TinyTP or IrLMP packet contains an additional 1-byte IrCOMM header. To accomplish this through the socket interface, you need to first get the maximum PDU size of an IrLMP packet with the <i>IRLMP_SEND_PDU_LEN</i> option. The socket is then put in 9-wire mode with <i>setsockopt</i> before connecting or accepting a connection. This tells the stack to add the 1-byte IrCOMM header (always set to 0) to each outgoing frame. Each <i>send</i> must be of a size less than the maximum PDU length to leave room for the added IrCOMM byte. IrCOMM is beyond the scope of this book. This option is available on Windows 98 and Windows 2000.</p>

<A NAME="235"><h3><i>IRLMP_ENUMDEVICES</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>DEVICELIST</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1+</td>
			<td valign="top">Returns a list of IrDA device IDs for IR-capable devices within range</td>
		</tr>
		
	</table>
</p>

<p>Because of the nature of infrared networking, devices capable of communicating are mobile and can move in and out of range. This option &quot;queries&quot; which IR devices are within range, and to connect to another device you must perform this step to obtain the device ID for each device you want to connect to.</p>

<p>The <i>DEVICELIST</i> structures are different on the various platforms that support IrSock because the latest platforms that added support also added functionality. Recall that Windows CE offered IrSock support first, and Windows 98 and Windows 2000 added support shortly thereafter. The <i>DEVICELIST</i> structure definition for Windows 98 and Windows 2000 is</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _WINDOWS_DEVICELIST
{
    ULONG                       numDevice;
    WINDOWS_IRDA_DEVICE_INFO    Device[1];
} WINDOWS_DEVICELIST, *PWINDOWS_DEVICELIST, FAR *LPWINDOWS_DEVICELIST;

typedef struct _WINDOWS_IRDA_DEVICE_INFO
{
    u_char  irdaDeviceID[4];
    char      irdaDeviceName[22];
    u_char  irdaDeviceHints1;
    u_char  irdaDeviceHints2;
    u_char  irdaCharSet;
} WINDOWS_IRDA_DEVICE_INFO, *PWINDOWS_IRDA_DEVICE_INFO, 
  FAR *LPWINDOWS_IRDA_DEVICE_INFO;
</pre>
</td></tr></table>
</p>

<p>In Windows CE, the <i>DEVICELIST</i> structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _WCE_DEVICELIST
{
    ULONG                       numDevice;
    WCE_IRDA_DEVICE_INFO        Device[1];
} WCE_DEVICELIST, *PWCE_DEVICELIST;

typedef struct _WCE_IRDA_DEVICE_INFO
{
    u_char  irdaDeviceID[4];
    char    irdaDeviceName[22];
    u_char  Reserved[2];
} WCE_IRDA_DEVICE_INFO, *PWCE_IRDA_DEVICE_INFO;
</pre>
</td></tr></table>
</p>

<p>As you can see, the device information structure varies as well: <i>WCE_IRDA_DEVICE_INFO</i> for Windows CE and <i>WINDOWS_IRDA_DEVICE_INFO</i> for Windows 98 and Windows 2000. Each of these structures contains a field, <i>irdaDeviceID</i>, which is a 4-byte identification tag used to uniquely identify that device. You need this field to fill out the <i>SOCKADDR_IRDA</i> structure used to connect to a specific device or to manipulate or obtain an Information Access Service (IAS) entry with the options <i>IRLMP_IAS_SET</i> and <i>IRLMP_IAS_QUERY</i>.</p>

<p>When you call <i>getsockopt</i> to enumerate infrared devices, the <i>optval</i> parameter must be a <i>DEVICELIST</i> structure. The only requirement is that the <i>numDevice</i> field be set to 0 at first. The call to <i>getsockopt</i> does not return an error if no IR devices are discovered. After a call, the <i>numDevice</i> field should be checked to see whether it is greater than 0, which means that one or more devices were found. The <i>Device</i> field returns with a number of structures equal to the value returned in <i>numDevice</i>.</p>

<A NAME="236"><h3><i>IRLMP_EXCLUSIVE_MODE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, socket connection is in exclusive mode.</td>
		</tr>
		
	</table>
</p>

<p>This option isn't normally used by user applications, as it bypasses the TinyTP layer in the IrDA stack and communicates directly with IrLMP. If you are really interested in using this option, you should consult the IrDA specification at <i><a href="http://www.irda.org" target="_window2">http://www.irda.org</a></i>. This option is available on Windows CE and Windows 2000.</p>

<A NAME="237"><h3><i>IRLMP_IAS_QUERY</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>IAS_QUERY</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1+</td>
			<td valign="top">Queries IAS on a given service and class name for its attributes</td>
		</tr>
		
	</table>
</p>

<p>This socket option is the complement of <i>IRLMP_IAS_SET</i>, as it retrieves information about a class name and its service. Before making the call to <i>getsockopt</i>, you must first fill out the <i>irdaDeviceID</i> field to the device you are querying. Set the <i>irdaAttribName</i> field to the property string on which you want to retrieve its value. The most common query would be for the LSAP-SEL number; its property string is &quot;IrDA:IrLMP:LsapSel.&quot; Next, you need to set the <i>irdaClassName</i> field to the name of the service that the given property string applies to. Once these fields are filled, make the call to <i>getsockopt.</i> Upon success, the <i>irdaAttribType</i> field indicates which field in the union to obtain the information from. Use the identifiers in Table 9-2 to decode this entry. The most common error is <i>WSASERVICE_NOT_FOUND</i>, which is returned when the given service is not found on that device. This option is available on Windows CE, Windows 98, and Windows 2000.</p>

<A NAME="238"><h3><i>IRLMP_IAS_SET</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>IAS_QUERY</i></td>
			<td valign="top">Set only</td>
			<td valign="top">1+</td>
			<td valign="top">Sets an attribute value for a given class name and attribute</td>
		</tr>
		
	</table>
</p>

<p>IAS is a dynamic service registration entity that can be queried and modified. The <i>IRLMP_IAS_SET</i> option allows you to set a single attribute for a single class within the local IAS. As with <i>IRLMP_ENUMDEVICES</i>, there are separate structures for Windows CE and for Windows 98 and Windows 2000. The structures for Windows 98 and Windows 2000 are</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _WINDOWS_IAS_QUERY
{
    u_char     irdaDeviceID[4];
    char       irdaClassName[IAS_MAX_CLASSNAME];
    char       irdaAttribName[IAS_MAX_ATTRIBNAME];
    u_long     irdaAttribType;
    union
    {
        LONG   irdaAttribInt;
        struct
        {
            u_long   Len;
            u_char   OctetSeq[IAS_MAX_OCTET_STRING];
        } irdaAttribOctetSeq;
        struct
        {
            u_long   Len;
            u_long   CharSet;
            u_char   UsrStr[IAS_MAX_USER_STRING];
        } irdaAttribUsrStr;
    } irdaAttribute;
} WINDOWS_IAS_QUERY, *PWINDOWS_IAS_QUERY, FAR *LPWINDOWS_IAS_QUERY;
</pre>
</td></tr></table>
</p>

<p>The IAS query structure for Windows CE is</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _WCE_IAS_QUERY
{
    u_char     irdaDeviceID[4];
    char       irdaClassName[61];
    char       irdaAttribName[61];
    u_short    irdaAttribType;
    union
    {
        int    irdaAttribInt;
        struct
        {
            int      Len;
            u_char   OctetSeq[1];
            u_char   Reserved[3];
        } irdaAttribOctetSeq;
        struct
        {
            int      Len;
            u_char   CharSet;
            u_char   UsrStr[1];
            u_char   Reserved[2];
        } irdaAttribUsrStr;
    } irdaAttribute;
} WCE_IAS_QUERY, *PWCE_IAS_QUERY;
</pre>
</td></tr></table>
</p>

<p>Table 9-2 provides the different constants for the <i>irdaAttribType</i> field, which indicates which type the attribute belongs to. The last two entries are not values that you can set, but values that a call to <i>getsockopt</i> with an <i>IRLMP_IAS_QUERY</i> socket option can return in the <i>irdaAttribType</i> field. These are included in the table for the sake of completeness.</p>

<p><b>Table 9-2.</b> <i>IAS attribute types</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th>irdaAttribType <i>Value</i></th>
			<th><i>Field to Set</i></th>
		</tr>

		<tr>
			<td valign="top"><i>IAS_ATTRIB_INT</i></td>
			<td valign="top"><i>IrdaAttribInt</i></td>
		</tr>

		<tr>
			<td valign="top"><i>IAS_ATTRIB_OCTETSEQ</i></td>
			<td valign="top"><i>IrdaAttribOctetSeq</i></td>
		</tr>

		<tr>
			<td valign="top"><i>IAS_ATTRIB_STR</i></td>
			<td valign="top"><i>IrdaAttribUsrStr</i></td>
		</tr>

		<tr>
			<td valign="top"><i>IAS_ATTRIB_NO_CLASS</i></td>
			<td valign="top">None</td>
		</tr>

		<tr>
			<td valign="top"><i>IAS_ATTRIB_NO_ATTRIB</i></td>
			<td valign="top">None</td>
		</tr>
		
	</table>
</p>

<p>In order to set a value, you must fill in <i>irdaDeviceID</i> to the IR device on which to modify the IAS entry. Also, <i>irdaAttribName</i> must be set to the class on which to set the attribute, while <i>irdaClassName</i> usually refers to the service on which to set the attribute. Remember that with IrSock, socket servers are services registered with IAS that have an associated LSAP-SEL number used by clients to connect to the server. The LSAP-SEL number is an attribute associated with that service. To modify the LSAPSEL number in the service's IAS entry, set the <i>irdaDeviceID</i> field to the device ID on which the service is running. Set the <i>irdaAttribName</i> field to the property string &quot;IrDA:IrLMP:LsapSel&quot; and the <i>irdaClassName</i> field to the name of the service (for example, &quot;MySocketServer&quot;). From there, set <i>irdaAttribType</i> to <i>IAS_ATTRIB_INT</i> and <i>irdaAttribInt</i> to the new LSAP-SEL number. Of course, changing the service's LSAP-SEL number is a bad idea, but this example is for illustration only.</p>

<A NAME="239"><h3><i>IRLMP_IRLPT_MODE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, socket is configured to communicate to IR capable printers.</td>
		</tr>
		
	</table>
</p>

<p>It is possible to connect to an infrared printer using Winsock and send data to be printed. This is accomplished by putting the socket in IRLPT mode before establishing the connection. Simply pass the Boolean value <i>TRUE</i> to this option after socket creation. You can use the option <i>IRLMP_ENUMDEVICES</i> to find infrared-capable printers within range. Note that some legacy IR printers do not register themselves with IAS; you might need to connect to them directly using the &quot;LSAP-SEL-<i>xxx</i>&quot; identifier. See <a href="ch06a.htm">Chapter 6</A> and its discussion of IrSock for more details on bypassing IAS. This option is available on Windows CE and Windows 2000.</p>

<A NAME="240"><h3><i>IRLMP_SEND_PDU_LEN</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1+</td>
			<td valign="top">Gets the maximum PDU length</td>
		</tr>
		
	</table>
</p>

<p>This option retrieves the maximum Protocol Data Unit (PDU) size needed when using the option <i>IRLMP_9WIRE_MODE</i>. See the description of <i>IRLMP_9WIRE_MODE</i> for more information about this option, which is available on Windows CE and Windows 2000.</p>

<A NAME="241"><h2><i>IPPROTO_IP</i> Option Level</h2></A>
<p>The socket options on the <i>IPPROTO_IP</i> level pertain to attributes specific to the IP protocol, such as modifying certain fields in the IP header and adding a socket to an IP multicast group. Many of these options are declared in both Winsock.h and Winsock2.h with different values. Note that if you load Winsock 1, you must include the correct header and link with Wsock32.lib. Likewise for Winsock 2, you should include the Winsock 2 header file and link with Ws2_32.lib. This is especially relevant to multicasting, which is available under both versions. Multicasting is supported on all Win32 platforms except Windows CE, in which it is available on versions 2.1 and later.</p>

<A NAME="242"><h3><i>IP_OPTIONS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>char []</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">Gets/sets IP options within the IP header</td>
		</tr>
		
	</table>
</p>

<p>This flag allows you to set various IP options within the IP header. Some of the possible options are</p>

<ul>
<p><li> <b>Security and handling restrictions</b> RFC 1108.</li></p>

<p><li> <b>Record route</b> Each router adds its IP address to the header (see the ping sample in <A HREF="ch13a.htm">Chapter 13</A>).</li></p>

<p><li> <b>Timestamp</b> Each router adds its IP address and time.</li></p>

<p><li> <b>Loose source routing</b> The packet is required to visit each IP address listed in the option header.</li></p>

<p><li> <b>Strict source routing</b> The packet is required to visit <i>only</i> those IP addresses listed in the option header.</li></p>
</ul>

<p>Be aware that hosts and routers do not support all of these options.</p>

<p>When setting an IP option, the data that you pass into the <i>setsockopt</i> call follows the structure shown in Figure 9-2. The IP option header can be up to 40 bytes in length.</p>

<p>
<A HREF="javascript:fullSize('F09ji02x.htm')"> <img src="images/F09ji02.JPG" width=404 height=110 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 9-2.</b> <i>IP option header format</i><!-- /caption -->
</p>

<p>The code field indicates what type of IP option is present. For example, the value 0x7 represents the record route option. Length is simply the length of the option header, while offset is the offset value into the header where the data portion of the header begins. The data portion of the header is specific to the particular option. In the following code snippet, we set up the record route option. Notice that we declare a structure (<i>struct ip_option_hdr</i>) that contains the first three option values (code, length, offset), and then we declare the option-specific data as an array of nine unsigned long integers, as the data to be recorded is up to nine IP addresses. Remember that the maximum size of the IP option header is 40 bytes; however, our structure occupies only 39 bytes. The system will pad the header to a multiple of a 32-bit word for you (up to 40 bytes).</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
struct ip_option_hdr 
{
    unsigned char    code;
    unsigned char    length;
    unsigned char    offset;
    unsigned long    addrs[9];
} opthdr;

...

ZeroMemory((char *)&amp;opthdr, sizeof(opthdr));
opthdr.code = 0x7;
opthdr.length = 39;
opthdr.offset = 4;  // Offset to first address (addrs)
ret = setsockopt(s, IPPROTO_IP, IP_OPTIONS, (char *)&amp;opthdr,
        sizeof(opthdr));
</pre>
</td></tr></table>
</p>

<p>Once the option is set, it applies to any packets sent on the given socket. At any pointer thereafter, you can call <i>getsockopt</i> with <i>IP_OPTIONS</i> to retrieve which options were set; however, this will not return any data filled into the option-specific buffers. In order to retrieve the data set in the IP options, either the socket must be created as a raw socket (<i>SOCK_RAW</i>) or the <i>IP_HDRINCL</i> option should be set&#8212;in which case, the IP header is returned along with data after a call to a Winsock receive function.</p>

<A NAME="243"><h3><i>IP_HDRINCL</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">2+</td>
			<td valign="top">If <i>TRUE</i>, IP header is submitted with data to be sent and returned from data that is read.</td>
		</tr>
		
	</table>
</p>

<p>Setting the <i>IP_HDRINCL</i> option to <i>TRUE</i> causes the send function to include the IP header ahead of the data it's sending and causes the receive function to include the IP header as part of the data. Thus, when you call a Winsock send function, you must include the entire IP header ahead of the data and fill each field of the IP header correctly. Figure 9-3 shows what the IP header should look like. This option is available only on Windows 2000.</p>

<p>
<A HREF="javascript:fullSize('F09ji03x.htm')"> <img src="images/F09ji03.JPG" width=404 height=352 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 9-3.</b> <i>The IP header</i><!-- /caption -->
</p>

<p>The first field of the header is the IP version, which is currently version 4. The header length is the number of 32-bit words in the header. An IP header must always be a multiple of 32 bits. The next field is the type of service field. Consult the <i>IP_TOS</i> socket option, discussed next, for additional information. The total length field is the length, in bytes, of the IP header and data. The identification field is a unique value used to identify each IP packet sent. Normally, the system increments this value with each packet sent. The flags and fragmentation offset fields are used when IP packets are fragmented into smaller packets. The time to live field, or TTL, limits the number of routers through which the packet can pass. Each time a router forwards the packet, the TTL is decremented by 1. Once the TTL is 0, the packet is dropped. This limits the amount of time a packet can be live on the network. The protocol field is used to demultiplex incoming packets. Some of the valid protocols that use IP addressing are TCP, UDP, IGMP, and ICMP. The checksum is the 16-bit one's complement sum of the header. It is calculated over the header only and not the data. The next two fields are the 32-bit IP source and destination addresses. The IP options field is a variable length field that contains optional information, usually regarding security or routing.</p>

<p>The easiest way to include an IP header with the data that you are sending is to define a structure that contains the IP header and the data, and pass the structure into the Winsock <i>send</i> call. See <A HREF="ch13a.htm">Chapter 13</A> for more details and an example of this option. This option works only on Windows 2000.</p>

<A NAME="244"><h3><i>IP_TOS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">IP type of service</td>
		</tr>
		
	</table>
</p>

<p>The type of service (TOS) is a field present in the IP header that is used to signify certain characteristics about a packet. The field is 8 bits long and is broken into three parts: a 3-bit precedence field (which is ignored), a 4-bit TOS field, and the remaining bit (which must be 0). The 4 TOS bits are minimize delay, maximize throughput, maximize reliability, and minimize monetary costs. Only 1 bit can be set at a time. All 4 bits being 0 implies normal service. RFC 1340 specifies the recommended bits to set for various standard applications such as TCP, SMTP, NNTP, and so on. Additionally, RFC 1349 contains some corrections to the original RFC.</p>

<p>Interactive applications&#8212;such as Rlogin or Telnet&#8212;might want to minimize delay. Any kind of file transfer&#8212;such as FTP&#8212;is interested in maximum throughput. Maximum reliability is used by network management (SNMP) and routing protocols. Finally, Usenet news (NNTP) is an example of minimizing monetary costs. The <i>IP_TOS</i> option is not available on Windows CE.</p>

<p>There is an additional issue when you attempt to set the TOS bits on a QOS-enabled socket. Because IP precedence is used by QOS to differentiate levels of service, it is undesirable to allow developers the ability to change these values. As a result, when you call <i>setsockopt</i> with <i>IP_TOS</i> on a QOS-enabled socket, the QOS service provider intercepts the call to verify whether the change can take place. See <A HREF="ch12a.htm">Chapter 12</A> for more information about QOS.</p>

<A NAME="245"><h3><i>IP_TTL</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">IP time-to-live parameter</td>
		</tr>
		
	</table>
</p>

<p>The time-to-live (TTL) field is present in an IP header. Datagrams use the TTL field to limit the number of routers through which the datagram can pass. The purpose of this limitation is to prevent routing loops in which datagrams can spin in circles forever. The idea behind this is that each router that the datagram passes through decrements the datagram's TTL value by 1. When the value equals 0, the datagram is discarded. This option is not available on Windows CE.</p>

<A NAME="246"><h3><i>IP_MULTICAST_IF</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>unsigned long</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">Gets/sets the local interface for multicast data to be sent from</td>
		</tr>
		
	</table>
</p>

<p>The IP multicast interface (IF) option sets the local interface from which any multicast data sent by the local machine will be sent. This option is only of interest on machines that have more than one connected network interface (network card, modem, and so on). The <i>optval</i> parameter should be an unsigned long integer representing the binary IP address of the local interface. The function <i>inet_addr</i> can be used to convert a string IP dotted decimal address to an unsigned long integer, as in the following sample:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
DWORD    mcastIF;

// First join socket s to a multicast group
mcastIF = inet_addr(&quot;129.113.43.120&quot;);
ret = setsockopt(s, IPPROTO_IP, IP_MULTICAST_IF, (char *)&amp;mcastIF,
    sizeof(mcastIF));
</pre>
</td></tr></table>
</p>

<A NAME="247"><h3><i>IP_MULTICAST_TTL</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">Gets/sets the time to live on multicast packets for this socket</td>
		</tr>
		
	</table>
</p>

<p>Similar to the IP TTL, this option performs the same function except that it applies only to multicast data sent using the given socket. Again, the purpose of the TTL is to prevent routing loops, but in the case of multicasting, setting the TTL narrows the scope of how far the data will travel. Therefore, multicast group members must be within &quot;range&quot; to receive datagrams. The default TTL value for multicast datagrams is 1.</p>

<A NAME="248"><h3><i>IP_MULTICAST_LOOP</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, data sent to a multicast address will be echoed to the socket's incoming buffer.</td>
		</tr>
		
	</table>
</p>

<p>By default, when you send IP multicast data, the data will be looped back to the sending socket if it is also a member of that multicast group. If you set this option to <i>FALSE</i>, any data sent will not be posted to the incoming data queue for the socket.</p>

<A NAME="249"><h3><i>IP_ADD_MEMBERSHIP</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>struct ip_mreq</i></td>
			<td valign="top">Set only</td>
			<td valign="top">1+</td>
			<td valign="top">Adds the socket to the given IP group membership</td>
		</tr>
		
	</table>
</p>

<p>This option is the Winsock 1 method of adding a socket to an IP multicast group. This is done by creating a socket of address family <i>AF_INET</i> and the socket type <i>SOCK_DGRAM</i> with the <i>socket</i> function. To add the socket to a multicast group, use the following structure:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
struct ip_mreq 
{
    struct in_addr  imr_multiaddr; 
    struct in_addr  imr_interface; 
};
</pre>
</td></tr></table>
</p>

<p>In the <i>ip_mreq</i> structure, <i>imr_multiaddr</i> is the binary address of the multicast group to join, while <i>imr_interface</i> is the local interface that multicast data should be sent out and received on. See <A HREF="ch11a.htm">Chapter 11</A> for more information about valid multicast addresses. The <i>imr_interface</i> field is either the binary IP address of a local interface or the value <i>INADDR_ANY</i>, which can be used to select the default interface.</p>

<A NAME="250"><h3><i>IP_DROP_MEMBERSHIP</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>struct ip_mreq</i></td>
			<td valign="top">Set only</td>
			<td valign="top">1+</td>
			<td valign="top">Removes the socket from the given IP group membership</td>
		</tr>
		
	</table>
</p>

<p>This option is the opposite of <i>IP_ADD_MEMBERSHIP</i>. By calling this option with an <i>ip_mreq</i> structure that contains the same values used when joining the given multicast group, the socket <i>s</i> will be removed from the given group. Again, <a href="ch11a.htm">Chapter 11</a> contains much more detailed information on IP multicasting.</p>

<A NAME="251"><h3><i>IP_DONTFRAGMENT</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, do not fragment IP datagrams.</td>
		</tr>
		
	</table>
</p>

<p>This flag tells the network not to fragment the IP datagram during transmission. However, if the size of the IP datagram exceeds the maximum transmission unit (MTU) and the IP don't fragment flag is set within the IP header, the datagram will be dropped and an ICMP error message (&quot;fragmentation needed but don't fragment bit set&quot;) will be returned to the sender. This option is not available on Windows CE.</p>

<A NAME="252"><h2><i>IPPROTO_TCP</i> Option Level</h2></A>
<p>There is only one option belonging to the <i>IPPROTO_TCP</i> level. The option is valid only for sockets that are stream sockets (<i>SOCK_STREAM</i>) and belong to family <i>AF_INET</i>. This option is available on all versions of Winsock and is supported on all Win32 platforms.</p>

<A NAME="253"><h3><i>TCP_NODELAY</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, the Nagle algorithm is disabled on the socket.</td>
		</tr>
		
	</table>
</p>

<p>In order to increase performance and throughput by minimizing overhead, the system implements the Nagle algorithm. When an application requests to send a chunk of data, the system might hold on to that data for a while and wait for other data to accumulate before actually sending it on the wire. Of course, if no other data accumulates in a given period of time, the data will be sent regardless. This results in more data in a single TCP packet, as opposed to smaller chunks of data in multiple TCP packets. The overhead is that the TCP header for each packet is 20 bytes long. Sending a couple bytes here and there with a 20-byte header is wasteful. The other part of this algorithm is the delayed acknowledgments. Once a system receives TCP data it must send an ACK to the peer. However, the host will wait to see whether it has data it is sending to the peer so that it can piggyback the ACK on the data to be sent&#8212;resulting in one less packet on the network.</p>

<p>The purpose of this option is to disable the Nagle algorithm, as its behavior can be detrimental in a few cases. This algorithm can adversely affect any network application that sends relatively small amounts of data and expects a timely response. A classic example is Telnet. Telnet is an interactive application that allows the user to log on to a remote machine and send it commands. Typically the user hits only a few keystrokes per second. The Nagle algorithm would make such a session seem sluggish and unresponsive.</p>

<A NAME="254"><h2><i>NSPROTO_IPX</i> Option Level</h2></A>
<p>These socket options are Microsoft-specific extensions to the Window IPX/SPX Windows Sockets interface, provided for use as necessary for compatibility with existing applications. They are otherwise not recommended for use, as they are guaranteed to work only over the Microsoft IPX/SPX stack. An application that uses these extensions might not work over other IPX/SPX implementations. These options are defined in WSNwLink.h, which should be included after Winsock.h and Wsipx.h.</p>

<A NAME="255"><h3><i>IPX_PTYPE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">Gets/sets the IPX packet type</td>
		</tr>
		
	</table>
</p>

<p>This option sets or gets the IPX packet type. The value specified in the <i>optval</i> argument will be set as the packet type on every IPX packet sent from this socket. The <i>optval</i> parameter is an integer.</p>

<A NAME="256"><h3><i>IPX_FILTERPTYPE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">Gets/sets the IPX packet type to filter on</td>
		</tr>
		
	</table>
</p>

<p>This option gets or sets the receive filter packet type. Only IPX packets with a packet type equal to the value specified in the <i>optval</i> argument are returned on any receive call; packets with a packet type that does not match are discarded.</p>

<A NAME="257"><h3><i>IPX_STOPFILTERPTYPE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Set only</td>
			<td valign="top">1+</td>
			<td valign="top">Removes the filter on the given IPX packet</td>
		</tr>
		
	</table>
</p>

<p>You can use this option to stop filtering on packet types that are set with the <i>IPX_FILTERPTYPE</i> option.</p>

<A NAME="258"><h3><i>IPX_DSTYPE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">Sets/gets the value of the datastream field in the SPX header</td>
		</tr>
		
	</table>
</p>

<p>This option gets or sets the value of the datastream field in the SPX header of every packet sent.</p>

<A NAME="259"><h3><i>IPX_EXTENDED_ADDRESS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, enables extended addressing on IPX packets</td>
		</tr>
		
	</table>
</p>

<p>This option enables or disables extended addressing. On sends, it adds the element <i>unsigned char sa_ptype</i> to the <i>SOCKADDR_IPX</i> structure, making the total length of the structure 15 bytes. On receives, the option adds both the <i>sa_ptype</i> and <i>unsigned char sa_flags</i> elements to the <i>SOCKADDR_IPX</i> structure, making the total length 16 bytes. The current bits defined in <i>sa_flags</i> are</p>

<ul>
<p><li> <b>0x01</b> The received frame was sent as a broadcast.</li></p>

<p><li> <b>0x02</b> The received frame was sent from this machine.</li></p>
</ul>

<A NAME="260"><h3><i>IPX_RECVHDR</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, returns IPX header with receive call</td>
		</tr>
		
	</table>
</p>

<p>If this option is set to true, any Winsock receive call returns the IPX header along with the data.</p>

<A NAME="261"><h3><i>IPX_MAXSIZE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1+</td>
			<td valign="top">Returns the maximum IPX datagram size</td>
		</tr>
		
	</table>
</p>

<p>Calling <i>getsockopt</i> with this option returns the maximum IPX datagram size possible.</p>

<A NAME="262"><h3><i>IPX_ADDRESS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>IPX_ADDRESS_DATA</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1+</td>
			<td valign="top">Returns information regarding an IPX-capable adapter</td>
		</tr>
		
	</table>
</p>

<p>This option queries for information about a specific adapter that IPX is bound to. In a system with <i>n</i> adapters, the adapters are numbered 0 through <i>n</i> - 1. To find the number of IPX-capable adapters on the system, use the <i>IPX_MAX_ADAPTER_NUM</i> option with <i>getsockopt</i>, or call <i>IPX_ADDRESS</i> with increasing values of <i>adapternum</i> until it fails. The <i>optval</i> parameter points to an <i>IPX_ADDRESS_DATA</i> structure defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _IPX_ADDRESS_DATA 
{
    INT     adapternum;  // Input: 0-based adapter number
    UCHAR   netnum[4];   // Output: IPX network number
    UCHAR   nodenum[6];  // Output: IPX node address
    BOOLEAN wan;         // Output: TRUE = adapter is on a WAN link
    BOOLEAN status;      // Output: TRUE = WAN link is up (or adapter 
                         // is not WAN)
    INT     maxpkt;      // Output: max packet size, not including IPX
                         // header
    ULONG   linkspeed;   // Output: link speed in 100 bytes/sec 
                         // (i.e., 96 == 9600 bps)
} IPX_ADDRESS_DATA, *PIPX_ADDRESS_DATA;
</pre>
</td></tr></table>
</p>

<A NAME="263"><h3><i>IPX_GETNE TINFO</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>IPX_NETNUM_DATA</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1+</td>
			<td valign="top">Returns information regarding a specific IPX network number</td>
		</tr>
		
	</table>
</p>

<p>This option obtains information about a specific IPX network number. If the network is in IPX's cache, the option returns the information directly; otherwise, it issues RIP requests to find it. The <i>optval</i> parameter points to a valid <i>IPX_NETNUM_DATA</i> structure defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _IPX_NETNUM_DATA 
{
    UCHAR  netnum[4];  // Input: IPX network number
    USHORT hopcount;   // Output: hop count to this network, in machine
                       // order
    USHORT netdelay;   // Output: tick count to this network, in machine
                       // order
    INT    cardnum;    // Output: 0-based adapter number used to route 
                       // to this net; can be used as adapternum input 
                       // to IPX_ADDRESS
    UCHAR  router[6];  // Output: MAC address of the next hop router,
                       // zeroed if the network is directly attached
} IPX_NETNUM_DATA, *PIPX_NETNUM_DATA;
</pre>
</td></tr></table>
</p>

<A NAME="264"><h3><i>IPX_GETNETINFO_NORIP</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>IPX_NETNUM_DATA</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, do not fragment IP datagrams.</td>
		</tr>
		
	</table>
</p>

<p>This option is similar to <i>IPX_GETNETINFO</i> except that it does not issue RIP requests. If the network is in IPX's cache, it returns the information; otherwise, it fails. (See also <i>IPX_RERIPNETNUMBER</i>, which always issues RIP requests.) Like <i>IPX_GETNETINFO</i>, this option requires passing an <i>IPX_NETNUM_DATA</i> structure as the <i>optval</i> parameter.</p>

<A NAME="265"><h3><i>IPX_SPXGETCONNECTIONSTATUS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>IPX_SPXCONNSTATUS_DATA</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1+</td>
			<td valign="top">Returns information regarding a connected SPX socket</td>
		</tr>
		
	</table>
</p>

<p>This option returns information on a connected SPX socket. The <i>optval</i> parameter points to an <i>IPX_SPXCONNSTATUS_DATA</i> structure defined below. All numbers are in network (high-low) byte order.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _IPX_SPXCONNSTATUS_DATA 
{
    UCHAR  ConnectionState;
    UCHAR  WatchDogActive;
    USHORT LocalConnectionId;
    USHORT RemoteConnectionId;
    USHORT LocalSequenceNumber;
    USHORT LocalAckNumber;
    USHORT LocalAllocNumber;
    USHORT RemoteAckNumber;
    USHORT RemoteAllocNumber;
    USHORT LocalSocket;
    UCHAR  ImmediateAddress[6];
    UCHAR  RemoteNetwork[4];
    UCHAR  RemoteNode[6];
    USHORT RemoteSocket;
    USHORT RetransmissionCount;
    USHORT EstimatedRoundTripDelay; /* In milliseconds */
    USHORT RetransmittedPackets;
    USHORT SuppressedPacket;
} IPX_SPXCONNSTATUS_DATA, *PIPX_SPXCONNSTATUS_DATA;
</pre>
</td></tr></table>
</p>

<A NAME="266"><h3><i>IPX_ADDRESS_NOTIFY</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>IPX_ADDRESS_DATA</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1+</td>
			<td valign="top">Asynchronously notifies when the status of an IPX adapter changes</td>
		</tr>
		
	</table>
</p>

<p>This option submits a request to be notified when the status of an adapter that IPX is bound to changes, which typically occurs when a WAN line goes up or down. This option requires the caller to submit an <i>IPX_ADDRESS_DATA</i> structure as the <i>optval</i> parameter. The exception, however, is that the <i>IPX_ADDRESS_DATA</i> structure is followed immediately by a handle to an unsignaled event. The following pseudo-code illustrates one method for calling this option.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
char  buff[sizeof(IPX_ADDRESS_DATA) + sizeof(HANDLE)];
IPX_ADDRESS_DATA *ipxdata;
HANDLE *hEvent;

ipxdata = (IPX_ADDRESS_DATA *)buff;
hEvent = (HANDLE *)(buff + sizeof(IPX_ADDRESS_DATA));
ipxdata-&gt;adapternum = 0;  // Set to the appropriate adapter
*hEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
setsockopt(s, NSPROTO_IPX, IPX_ADDRESS_NOTIFY, (char *)buff,
sizeof(buff));
</pre>
</td></tr></table>
</p>

<p>When the <i>getsockopt</i> query is submitted, it completes successfully. However, the <i>IPX_ADDRESS_DATA</i> structure pointed to by <i>optval</i> will not be updated at that point. Instead, the request is queued internally inside the transport, and when the status of an adapter changes, IPX locates a queued <i>getsockopt</i> query and fills in all the fields in the <i>IPX_ADDRESS_DATA</i> structure. It then signals the event pointed to by the handle in the <i>optval</i> buffer. If multiple <i>getsockopt</i> calls are submitted at once, different events must be used. The event is used because the call needs to be asynchronous; <i>getsockopt</i> does not currently support this.</p>

<p><div class="warning"><blockquote><b>WARNING</b><hr>
In the current implementation, the transport signals only one queued query for each status change. Therefore, only one service that uses a queued query should run at once.
</blockquote></div></p>

<A NAME="267"><h3><i>IPX_MAX_ADAPTER_NUM</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>int</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1+</td>
			<td valign="top">Returns the number of IPX adapters present</td>
		</tr>
		
	</table>
</p>

<p>This option returns the number of IPX-capable adapters present on the system. If this call returns <i>n</i> adapters, the adapters are numbered 0 through <i>n</i> - 1.</p>

<A NAME="268"><h3><i>IPX_RERIPNETNUMBER</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>IPX_NETNUM_DATA</i></td>
			<td valign="top">Get only</td>
			<td valign="top">1+</td>
			<td valign="top">Returns information regarding a network number</td>
		</tr>
		
	</table>
</p>

<p>This option is related to IPX_GETNETINFO except that it forces IPX to reissue RIP requests even if the network is in its cache (but not if it is directly attached to that network). Like <i>IPX_GETNETINFO</i>, it requires passing an <i>IPX_NETNUM_DATA</i> structure as the <i>optval</i> parameter.</p>

<A NAME="269"><h3><i>IPX_RECEIVE_BROADCAST</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Set only</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, do not receive broadcast IPX packets.</td>
		</tr>
		
	</table>
</p>

<p>By default, an IPX socket is capable of receiving broadcast packets. Applications that do not need to receive broadcast packets should set this option to <i>FALSE</i>, which can cause better system performance. Note, however, that setting the option to <i>FALSE</i> does not necessarily cause broadcasts to be filtered for the application.</p>

<A NAME="270"><h3><i>IPX_IMMEDIATESPXACK</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>optval <i>Type</i></th>
			<th><i>Get/Set</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">Both</td>
			<td valign="top">1+</td>
			<td valign="top">If <i>TRUE</i>, do not delay sending ACKs on SPX connections.</td>
		</tr>
		
	</table>
</p>

<p>If you set this option to <i>true</i>, acknowledgement packets will not be delayed for SPX connections. Applications that do not tend to have back-and-forth traffic over SPX should set this&#8212;it increases the number of ACKs sent but prevents the appearance of slow performance as a result of delayed acknowledgments.</p>

</BODY>
</HTML>




