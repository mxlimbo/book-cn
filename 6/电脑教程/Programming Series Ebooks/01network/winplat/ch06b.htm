<HTML>
<HEAD>
<TITLE>IP</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06a.htm" , "ch06c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="98"><H1>IP</H1></A>

<p>The Internet Protocol (IP) is commonly known as the network protocol that is used on the Internet. IP is widely available on most computer operating systems and can be used on most local area networks (LANs), such as a small network in your office, and on wide area networks (WANs), such as the Internet. By design, IP is a connectionless protocol and doesn't guarantee delivery of data. Two higher-level protocols&#8212;TCP and UDP&#8212;are used for data communication over IP.</p>

<A NAME="99"><H2>TCP</H2></A>

<p>Connection-oriented communication is accomplished through the Transmission Control Protocol (TCP). TCP provides reliable error-free data transmission between two computers. When applications communicate using TCP, a virtual connection is established between the source computer and the destination computer. Once a connection is established, data can be exchanged between the computers as a two-way stream of bytes.</p>

<A NAME="100"><H2>UDP</H2></A>

<p>Connectionless communication is accomplished through the User Datagram Protocol (UDP). UDP doesn't guarantee reliable data transmission and is capable of sending data to multiple destinations and receiving data from multiple sources. For example, if a client sends data to a server, the data is transmitted immediately, whether or not the server is ready to receive the data. If the server receives data from the client, it doesn't acknowledge the receipt. Data is transmitted using datagrams.</p>

<p>Both TCP and UDP use IP for data transmission and are normally referred to as TCP/IP and UDP/IP. Winsock addresses IP communication through the <i>AF_INET</i> address family, which is defined in Winsock.h and Winsock2.h.</p>

<A NAME="101"><H2>Addressing</H2></A>

<p>In IP, computers are assigned an IP address that is represented as a 32-bit quantity, formally known as an IP version 4 (IPv4) address. When a client wants to communicate with a server through TCP or UDP, it must specify the server's IP address along with a service port number. Also, when servers want to listen for incoming client requests, they must specify an IP address and a port number. In Winsock, applications specify IP addresses and service port information through the <i>SOCKADDR_IN</i> structure, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
struct sockaddr_in
{
    short           sin_family;
    u_short         sin_port;
    struct in_addr  sin_addr;
    char            sin_zero[8];
};
</pre>
</td></tr></table>
</p>

<p>The <i>sin_family</i> field must be set to <i>AF_INET</i>, which tells Winsock we are using the IP address family.</p>

<p><div class="sidebar"><blockquote>
<b>IP Version 6</b><hr>
IP version 6 is an updated specification of IP that allows for a larger address space, which 
will become necessary in the near future, as IP version 4 addresses become scarce. Many of the Winsock 
header files contain conditional definitions for IPv6 structures; however, 
no current Win32 platform provides an IPv6 network stack (including Windows 2000). 
Microsoft Research has made available an experimental IPv6 stack that you can download and 
use (<a href="http://research.microsoft.com/msripv6/" target ="_window2">http://research.microsoft.com/msripv6/</a>); however, it isn't supported, and we do not address any version 6-specific issues in this text.</blockquote></div></p>


<p>The <i>sin_port</i> field defines which TCP or UDP communication port will be used to identify a server service. Applications should be particularly careful in choosing a port because some of the available port numbers are reserved for well-known services such as File Transfer Protocol (FTP) and Hypertext Transfer Protocol (HTTP). The ports used by well-known services are controlled and assigned by the Internet Assigned Numbers Authority (IANA) and are described in RFC 1700. Essentially, the port numbers are divided into the three ranges explained below: well-known, registered, and dynamic and/or private ports.</p>

<ul>
<p><li>0-1023 are controlled by the IANA and are reserved for well-known services.</li></p>

<p><li>1024-49151 are registered ports listed by the IANA and can be used by ordinary user processes or programs executed by ordinary users.</li></p>

<p><li>49152-65535 are dynamic and/or private ports.</li></p>
</ul>

<p>Ordinary user applications should choose the registered ports in the range 1024-49151 to avoid the possibility of using a port already in use by another application or a system service. Ports in the range 49152-65535 can also be used freely because no services are registered on these ports with the IANA. If, when using the <i>bind</i> API function, your application binds to a port that is already in use by another application on your host, the system will return the Winsock error <i>WSAEADDRINUSE</i>. <a href="ch07a.htm">Chapter 7</A> describes the Winsock bind process in greater detail.</p>

<p>The <i>sin_addr</i> field of the <i>SOCKADDR_IN</i> structure is used for storing an IP address as a 4-byte quantity, which is an unsigned long integer data type. Depending on how this field is used, it can represent a local or remote IP address. IP addresses are normally specified in Internet standard dotted notation as &quot;a.b.c.d.&quot; Each letter represents a number for each byte and is assigned, from left to right, to the four bytes of the unsigned long integer. The final field, <i>sin_zero</i>, functions only as padding to make the <i>SOCKADDR_IN</i> structure the same size as the <i>SOCKADDR</i> structure.</p>

<p>A useful support function named <i>inet_addr</i> converts a dotted IP address to a 32-bit unsigned long integer quantity. The <i>inet_addr</i> function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
unsigned long inet_addr(
    const char FAR *cp<i> </i> 
); 
</pre>
</td></tr></table>
</p>

<p>The <i>cp</i> field is a null-terminated character string that accepts an IP address in dotted notation. Note that this function returns an IP address as a 32-bit unsigned long integer in network-byte order. (Network-byte order is described shortly, under &quot;<A HREF="ch06b.htm#103">Byte ordering</A>.&quot;)</p>

<A NAME="102"><H3>Special addresses</H3></A>

<p>Two special IP addresses affect the behavior of a socket in certain situations. The special address <i>INADDR_ANY</i> allows a server application to listen for client activity over every network interface on a host computer. Typically, server applications use this address when they bind a socket to the local interface to listen for connections. If you have a multihomed system, this address allows a single application to accept responses from multiple interfaces.</p>

<p>The special address <i>INADDR_BROADCAST</i> can be used to send broadcast UDP datagrams over an IP network. Using this special address requires an application to set the socket option <i>SO_BROADCAST</i>. <a href="ch09a.htm">Chapter 9</A> explains this option in greater detail.</p>

<A NAME="103"><H3>Byte ordering</H3></A>

<p>Different computer processors represent numbers in <i>big-endian</i> and <i>little-endian</i> form, depending on how they are designed. For example, on Intel x86 processors, multibyte numbers are represented in little-endian form: the bytes are ordered from least significant byte to most significant byte. When an IP address and port number are specified as multibyte quantities in a computer, they are represented in <i>host-byte</i> order. However, when IP addresses and port numbers are specified over a network, Internet networking standards specify that multibyte values must be represented in big-endian form (most significant byte to least significant byte), normally referred to as <i>network-byte</i> order.</p>

<p>A series of functions can be used to convert a multibyte number from host-byte order to network-byte order and vice versa. The following four API functions convert a number from host-byte to network-byte order:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
u_long htonl(u_long hostlong);

int WSAHtonl(
    SOCKET s,
    u_long hostlong,
    u_long FAR * lpnetlong
);

u_short htons(u_short hostshort);

int WSAHtons(
    SOCKET s,
    u_short hostshort,
    u_short FAR * lpnetshort
);
</pre>
</td></tr></table>
</p>

<p>The <i>hostlong</i> parameter of <i>htonl</i> and <i>WSAHtonl</i> is a 4-byte number in host-byte order. The <i>htonl</i> function returns the number in network-byte order, whereas the <i>WSAHtonl</i> function returns the number in network-byte order through the <i>lpnetlong</i> parameter. The <i>hostshort</i> parameter of <i>htons</i> and <i>WSAHtons</i> is a 2-byte number in host-byte order. The <i>htons</i> function returns the number as a 2-byte value in network-byte order, whereas the <i>WSAHtons</i> function returns the number through the <i>lpnetshort</i> parameter.</p>

<p>The next four functions are the opposite of the preceding four functions: they convert from network-byte order to host-byte order.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
u_long ntohl(u_long netlong);

int WSANtohl(
    SOCKET s,
    u_long netlong,
    u_long FAR * lphostlong
);

u_short ntohs(u_short netshort);

int WSANtohs(
    SOCKET s,
    u_short netshort,
    u_short FAR * lphostshort
);
</pre>
</td></tr></table>
</p>

<p>We will now demonstrate how to create a <i>SOCKADDR_IN</i> structure using the <i>inet</i>_<i>addr</i> and <i>htons</i> functions described above.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SOCKADDR_IN InternetAddr;
INT nPortId = 5150;

InternetAddr.sin_family = AF_INET;

// Convert the proposed dotted Internet address 136.149.3.29
// to a 4-byte integer, and assign it to sin_addr

InternetAddr.sin_addr.s_addr = inet_addr(&quot;136.149.3.29&quot;);

// The nPortId variable is stored in host-byte order. Convert
// nPortId to network-byte order, and assign it to sin_port.

InternetAddr.sin_port = htons(nPortId);
</pre>
</td></tr></table>
</p>

<p>Now that you have the basics of addressing IP through a <i>SOCKADDR_IN</i> structure, you can prepare to set up communication for TCP or UDP by creating a socket.</p>

<A NAME="104"><H2>Creating a Socket</H2></A>

<p>Creating an IP socket offers applications the capability to communicate over the TCP, UDP, and IP protocols. To open an IP socket using the TCP protocol, call the <i>socket</i> function or the <i>WSASocket</i> function with the address family <i>AF_INET</i> and the socket type <i>SOCK_STREAM</i>, and set the protocol field to 0, as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
s = socket(AF_INET, SOCK_STREAM, 0);

s = WSASocket(AF_INET, SOCK_STREAM, 0, NULL, 0,
    WSA_FLAG_OVERLAPPED);
</pre>
</td></tr></table>
</p>

<p>To open an IP socket using the UDP protocol, simply specify the socket type <i>SOCK_DGRAM</i> instead of <i>SOCK_STREAM</i> in the <i>socket</i> and <i>WSASocket</i> calls above. It is also possible to open a socket to communicate directly over IP. This is accomplished by setting the socket type to <i>SOCK_RAW</i>. <A HREF="ch13a.htm">Chapter 13</A> describes the <i>SOCK_RAW</i> option in greater detail.</p>

<A NAME="105"><H2>Name Resolution</H2></A>

<p>When a Winsock application wants to communicate with a host over IP, it must know the host's IP address. From an application user's point of view, IP addresses aren't easy to remember. Most people would much rather refer to a machine by using an easy-to-remember, user-friendly host name instead of an IP address. Winsock provides two support functions that can help you resolve a host name to an IP address.</p>

<p>The Windows Sockets <i>gethostbyname</i> and <i>WSAAsyncGetHostByName</i> API functions retrieve host information corresponding to a host name from a host database. Both functions return a <i>HOSTENT</i> structure that is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
struct hostent 
{
    char FAR *       h_name;
    char FAR * FAR * h_aliases;
    short            h_addrtype;
    short            h_length;
    char FAR * FAR * h_addr_list;
};
</pre>
</td></tr></table>
</p>

<p>The <i>h_name</i> field is the official name of the host. If your network uses the Domain Name System (DNS), it is the Fully Qualified Domain Name (FQDN) that causes the name server to return a reply. If your network uses a local &quot;hosts&quot; file, it is the first entry after the IP address. The <i>h_aliases</i> field is a null-terminated array of alternative names for the host. The <i>h_addrtype</i> represents the address family being returned. The <i>h_length</i> field defines the length in bytes of each address in the <i>h_addr_list</i> field. The <i>h_addr_list</i> field is a null-terminated array of IP addresses for the host. (A host can have more than one IP address assigned to it.) Each address in the array is returned in network-byte order. Normally, applications use the first address in the array. However, if more than one address is returned, applications should randomly choose an available address rather than always use the first address.</p>

<p>The <i>gethostbyname</i> API function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
struct hostent FAR * gethostbyname (
    const char FAR *<i> </i> name <i> </i> 
); 
</pre>
</td></tr></table>
</p>

<p>The <i>name</i> parameter represents a friendly name of the host you are looking for. If this function succeeds, a pointer to a <i>HOSTENT</i> structure is returned. Note that the memory where the <i>HOSTENT</i> structure is stored is system memory. An application shouldn't rely on this to remain static. Since this memory is maintained by the system, your application doesn't have to free the returned structure.</p>

<p>The <i>WSAAsyncGetHostByName</i> API function is an asynchronous version of the <i>gethostbyname</i> function that uses Windows messages to inform an application when this function completes. <i>WSAAsyncGetHostByName</i> is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
HANDLE WSAAsyncGetHostByName( 
    HWND hWnd,
    unsigned int wMsg,
    const char FAR * name,
    char FAR * buf,
    int buflen
);
</pre>
</td></tr></table>
</p>

<p>The <i>hWnd</i> parameter is the handle of the window that will receive a message when the asynchronous request completes. The <i>wMsg</i> parameter is the Windows message to be received when the asynchronous request completes. The <i>name</i> parameter represents a user-friendly name of the host we are looking for. The <i>buf</i> parameter is a pointer to the data area to receive the <i>HOSTENT</i> data. This buffer must be larger than a <i>HOSTENT</i> structure and should be set to the size defined in <i>MAXGETHOSTSTRUCT</i>.</p>

<p>Two more functions that retrieve host information are worth mentioning: the <i>gethostbyaddr</i> and <i>WSAAsyncGetHostByAddr</i> API functions, which are designed to retrieve host information corresponding to an IP network address. These functions are useful when you have the IP address of a host and want to look up its user-friendly name. The <i>gethostbyaddr</i> function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
struct HOSTENT FAR * gethostbyaddr(
    const char FAR * addr,
    int len,
    int type
);
</pre>
</td></tr></table>
</p>

<p>The <i>addr</i> parameter is a pointer to an IP address in network-byte order. The <i>len</i> parameter specifies the byte length of the <i>addr</i> parameter. The <i>type</i> parameter should specify the value <i>AF_INET,</i> which indicates that this is an IP address type. The <i>WSAAsyncGetHostByAddr</i> API function is an asynchronous version of <i>gethostbyaddr</i>.</p>

<A NAME="106"><H3>Port numbers</H3></A>

<p>In addition to the IP address of a remote computer, an application must know the service's 
port number to communicate with a service running on a local or remote computer. When using 
TCP and UDP, applications must decide which ports they plan to communicate over. 
There are well-known port numbers reserved by server services that support protocols of a 
level higher than TCP. For example, port 21 is reserved for FTP, and port 80 is reserved for HTTP. 
As mentioned earlier, well-known services typically use ports 1-1023 to set up communication. If you are developing a TCP application that doesn't use one of the well-known services, consider using ports above 1023 to avoid using a port already being used. You can retrieve port numbers for well-known services by calling the <i>getservbyname</i> and <i>WSAAsyncGetServByName</i> functions. These functions simply retrieve static information from a file named <i>services</i>. In Windows 95 and Windows 98, the services file is located under %WINDOWS%; and in Windows NT and Windows 2000, it is located under %WINDOWS%\System32\Drivers\Etc. The <i>getservbyname</i> function is defined as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
struct servent FAR * getservbyname(
    const char FAR * name,
    const char FAR * proto
); 
</pre>
</td></tr></table>
</p>

<p>The <i>name</i> parameter represents the name of the service you are looking for. For example, if you are trying to locate the port for FTP, you should set the <i>name</i> parameter to point to the string &quot;ftp.&quot; The <i>proto</i> parameter optionally points to a string that indicates the protocol that the service in <i>name</i> is registered under. The <i>WSAAsyncGetServByName</i> function is an asynchronous version of <i>getservbyname</i>.</p>

<p>Windows 2000 has a new dynamic method to register and query service information for TCP and UDP. Server applications can register the service name, IP address, and port number of a service by using the <i>WSASetService</i> function. Client applications can query this service information by using a combination of the following API functions: <i>WSALookupServiceBegin</i>, <i>WSALookupServiceNext</i>, and <i>WSALookupServiceEnd</i>. <a href="ch10a.htm">Chapter 10</a> covers the details of using these capabilities.</p>

</BODY>
</HTML>




