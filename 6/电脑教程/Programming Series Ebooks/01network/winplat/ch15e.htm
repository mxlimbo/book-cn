<HTML>
<HEAD>
<TITLE>UDP Example</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch15d.htm" , "ch15f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="463"><H1>UDP Example</H1></A>

<p>Let's examine a sample UDP application. Take a look at the sample Visual Basic project SockUDP.vbp in the Chapter 15 directory on the CD. When the project is compiled and run, you will see a dialog similar to the one illustrated in Figure 15-1. This sample application is both a sender and a receiver of UDP messages, and therefore you can use just one instance to send and receive messages. Additionally, all the code behind the form, buttons, and Winsock controls is given in Figure 15-2.</p>

<p>
<A HREF="javascript:fullSize('F15JI01x.htm')"> <img src="images/F15JI01.JPG" width=404 height=232 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 15-1.</b> <i>Sample UDP application</i><!-- /caption -->
</p>

<p>When you look at the form, you see two Winsock controls. One control is used to send datagrams, and the other is used to receive datagrams. You can also see three group boxes: one for the sender, one for the receiver, and one for general Winsock information. For the sender, you need somewhere to put the recipient's host name or IP address. When you set the <i>RemoteHost</i> property, you can use either the machine's textual name or a string representation of the dotted-decimal numeric IP address. The control resolves the name if needed. You also need the remote port to which you will send the UDP packets. Also, notice the text box for the local port, <i>txtSendLocalPort</i>. For the sender, it doesn't really matter which local port you send the data on, only which port you're sending to. If you leave the local port set to 0, the system assigns an unused port. The last text box, <i>txtSendData</i>, is for the string data to be sent. Additionally, there are two command buttons: one for sending the data and one for closing the socket. To send datagrams, you must bind the Winsock control to a remote address, a remote port, and a local port before you can send any data. This means that if you want to change any one of these three parameters, you need to close the socket first and then rebind to the new parameters. That is why the form has a Close Socket button.</p>

<p><b>Figure 15-2.</b> <i>UDP sample code</i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Option Explicit

Private Sub cmdExit_Click()
    Unload Me
End Sub

Private Sub cmdSendDgram_Click()
    ' If the socket state is closed, we need to bind to a
    ' local port and also to the remote host's IP address and port
    If (sockSend.State = sckClosed) Then
        sockSend.RemoteHost = txtRecipientIP.Text
        sockSend.RemotePort = CInt(txtSendRemotePort.Text)
        sockSend.Bind CInt(txtSendLocalPort.Text)
        
        cmdCloseSend.Enabled = True
    End If
    '
    ' Now we can send the data
    '
    sockSend.SendData txtSendData.Text
End Sub

Private Sub cmdListen_Click()
    ' Bind to the local port
    '
    sockRecv.Bind CInt(txtRecvLocalPort.Text)
    '
    ' Disable this button since it would be an error to bind
    ' twice (a close needs to be done before rebinding occurs)
    '
    cmdListen.Enabled = False
    cmdCloseListen.Enabled = True
End Sub

Private Sub cmdCloseSend_Click()
    ' Close the sending socket, and disable the Close button
    '
    sockSend.Close
    cmdCloseSend.Enabled = False
End Sub

Private Sub cmdCloseListen_Click()
    ' Close the listening socket
    '
    sockRecv.Close
    ' Enable the right buttons
    '
    cmdListen.Enabled = True
    cmdCloseListen.Enabled = False
    lstRecvData.Clear
End Sub

Private Sub Form_Load()
    ' Initialize the socket protocols, and set up some default
    ' labels and values
    '
    sockSend.Protocol = sckUDPProtocol
    sockRecv.Protocol = sckUDPProtocol
    
    lblHostName.Caption = sockSend.LocalHostName
    lblLocalIP.Caption = sockSend.LocalIP
    
    cmdCloseListen.Enabled = False
    cmdCloseSend.Enabled = False
    
    Timer1.Interval = 500
    Timer1.Enabled = True
End Sub

Private Sub sockSend_Error(ByVal Number As Integer, _
        Description As String, ByVal Scode As Long, _
        ByVal Source As String, ByVal HelpFile As String, _
        ByVal HelpContext As Long, CancelDisplay As Boolean)
    MsgBox Description
End Sub

Private Sub sockRecv_DataArrival(ByVal bytesTotal As Long)
    Dim data As String
    
    ' Allocate a string of sufficient size, and get the data;
    ' then add it to the list box
    data = String(bytesTotal + 2, Chr$(0))
    sockRecv.GetData data, , bytesTotal
    lstRecvData.AddItem data
    ' Update the remote IP and port labels
    '
    lblRemoteIP.Caption = sockRecv.RemoteHostIP
    lblRemotePort.Caption = sockRecv.RemotePort
End Sub

Private Sub sockRecv_Error(ByVal Number As Integer, _
        Description As String, ByVal Scode As Long, _
        ByVal Source As String, ByVal HelpFile As String, _
        ByVal HelpContext As Long, CancelDisplay As Boolean)
    MsgBox Description
End Sub

Private Sub Timer1_Timer()
    ' When the timer goes off, update the socket status labels
    '
    Select Case sockSend.State
        Case sckClosed
            lblSenderState.Caption = &quot;sckClosed&quot;
        Case sckOpen
            lblSenderState.Caption = &quot;sckOpen&quot;
        Case sckListening
            lblSenderState.Caption = &quot;sckListening&quot;
        Case sckConnectionPending
            lblSenderState.Caption = &quot;sckConnectionPending&quot;
        Case sckResolvingHost
            lblSenderState.Caption = &quot;sckResolvingHost&quot;
        Case sckHostResolved
            lblSenderState.Caption = &quot;sckHostResolved&quot;
        Case sckConnecting
            lblSenderState.Caption = &quot;sckConnecting&quot;
        Case sckClosing
            lblSenderState.Caption = &quot;sckClosing&quot;
        Case sckError
            lblSenderState.Caption = &quot;sckError&quot;
        Case Else
            lblSenderState.Caption = &quot;unknown&quot;
    End Select
    Select Case sockRecv.State
        Case sckClosed
            lblReceiverState.Caption = &quot;sckClosed&quot;
        Case sckOpen
            lblReceiverState.Caption = &quot;sckOpen&quot;
        Case sckListening
            lblReceiverState.Caption = &quot;sckListening&quot;
        Case sckConnectionPending
            lblReceiverState.Caption = &quot;sckConnectionPending&quot;
        Case sckResolvingHost
            lblReceiverState.Caption = &quot;sckResolvingHost&quot;
        Case sckHostResolved
            lblReceiverState.Caption = &quot;sckHostResolved&quot;
        Case sckConnecting
            lblReceiverState.Caption = &quot;sckConnecting&quot;
        Case sckClosing
            lblReceiverState.Caption = &quot;sckClosing&quot;
        Case sckError
            lblReceiverState.Caption = &quot;sckError&quot;
        Case Else
            lblReceiverState.Caption = &quot;unknown&quot;
    End Select
End Sub
</pre>
</td></tr></table>
</p>

<A NAME="464"><H2>Sending UDP Messages</H2></A>

<p>Now that you know the sender's general capabilities, let's look at the code behind the scenes. First take a look at the <i>Form_Load</i> routine. The first step is to set the <i>Protocol</i> property of the <i>sockSend</i> Winsock control to UDP by using the <i>sckUDPProtocol</i> enumerated type. The other commands in this routine don't apply to the sending functionality except for disabling the <i>cmdCloseSend</i> command button. We do this for completeness because calling the <i>Close</i> method on an already closed control does nothing. Note that the default state of the Winsock control is closed.</p>

<p>Next look at the <i>cmdSendDgram_Click</i> routine, which is triggered by clicking on the Send Data button. This is the heart of sending a UDP message. The first step in the code is to check the socket's state. If the socket is in the closed state, the code binds the socket to a remote address, a remote port, and a local port. Once the code binds a UDP Winsock control with these parameters, the state of the control changes from <i>sckClosed</i> to <i>sckOpen</i>. If the code doesn't perform this check and attempts to bind the socket on every send, the run-time error 40020, &quot;Invalid operation at current state,&quot; will be generated. Once a socket is bound, it remains bound until it is closed. This is why the code enables the Close Socket button for the sending socket once the control is bound. The last step is to call the <i>SendData</i> method with the data the user wants to send. When the <i>SendData</i> method returns, the code has finished sending data.</p>

<p>Only two other subroutines are associated with sending UDP messages. The first is <i>cmdCloseSend</i>, which as its name implies closes the sending socket, allowing the user to change the remote host, remote port, or local port parameter before sending data again. The other routine is <i>sockSend</i>_<i>Error</i>, which is a Winsock event. This event is triggered whenever a Winsock error is generated. Because UDP is unreliable, few errors will be generated. If an error does occur, the code simply prints out the error's description. The only message a user might see in this application is a destination unreachable message.</p>

<A NAME="465"><H2>Receiving UDP Messages</H2></A>

<p>As you can see, sending a UDP packet with the Winsock control is simple and straightforward. Receiving UDP packets is even easier. Let's go back to the <i>Form_Load</i> routine to see what needs to be done to receive a UDP message. As we saw with the sending Winsock control, the code sets the <i>Protocol</i> property to UDP. The code also disables the Close Listen button. Again, closing an already closed socket won't hurt, but the code does it for the sake of completeness. Also, it's always a good idea to think, &quot;What could happen if I call method X?&quot; at different points in the program. This is the source of most of the problems developers encounter with the control: calling a method when the state of control is invalid. An example of this is calling the <i>Connect</i> method on a Winsock control that is already connected.</p>

<p>To listen for incoming UDP packets, let's look at the <i>cmdListen_Click</i> routine. This is the handler for the Listen button. The only necessary step is to call the <i>Bind</i> method on the receiving Winsock control, passing the local port on which the user wants to listen for incoming UDP datagrams. When listening for incoming UDP packets, the code needs only the local port&#8212;the remote port on which the data was sent is not relevant. After the code binds the control, it disables the <i>cmdListen</i> button&#8212;this prevents the possibility of the user clicking the Listen button twice. Trying to bind an already bound control will fail with a run-time error.</p>

<p>At this point, the <i>sockRecv</i> control is registered to receive UDP data. When the control receives UDP data on the port it's bound to, the <i>DataArrival</i> event is triggered. This event is implemented in the <i>sockRecv_DataArrival</i> routine. The parameter passed into the event, <i>bytesTotal</i>, is the number of bytes available to be read. The code allocates a string slightly larger than the amount of data being read. Then it calls the <i>GetData</i> method, passing the allocated string as the first parameter. The second parameter defaults to the Visual Basic type <i>vbString</i>, and the third parameter specifies the number of bytes that need to be read, which, in this example, is the value <i>bytesTotal</i>. If the code requests to read a smaller number of bytes than that specified by the <i>bytesTotal</i> parameter, a run-time error is generated. Once the data is read into the character buffer, the code adds it to the list box of messages read. The last few steps in this subroutine set the label captions for the remote host's IP address and port number. Upon receipt of each UDP packet, the <i>RemoteHostIP</i> and <i>RemotePort</i> properties are set to the remote host's IP address and port number for the packet just received. Therefore, if the program receives multiple UDP packets from several hosts, the values of these properties will change often.</p>

<p>The last two subroutines associated with receiving UDP messages are <i>cmdCloseListen_Click</i> and <i>sockRecv_Error</i>. The user invokes the <i>cmdCloseListen_Click</i> handler by clicking the Close Listen button. The routine simply calls the <i>Close</i> method on the Winsock control. Closing a UDP control frees the underlying socket descriptor. The <i>sockRecv_Error</i> event is called whenever a Winsock error is generated. As we mentioned previously in the UDP send section, few UDP errors are generated to begin with because of their unreliable nature.</p>

<A NAME="466"><H2>Obtaining Winsock Information</H2></A>

<p>The last part of our UDP example is the Winsock Information group box. The local name and local IP labels are set at form load time. As soon the form loads and Winsock controls are instantiated, the properties <i>LocalHostName</i> and <i>LocalIP</i> are set to the host name and IP address of the host machine and can be read at any time. The next two labels, Sender State and Receiver State, display the current state of the two Winsock controls used by the application. The state information is updated every half second. This is where the Timer control comes in. Every 500 milliseconds, the timer control triggers the Timer handler, which queries the socket states and updates the labels. We print the socket states for informative purposes only. The last two labels, Remote IP and Remote Port, are set whenever a UDP message is received, as discussed in the previous paragraph.</p>

<A NAME="467"><H2>Running the UDP Example</H2></A>

<p>Now that you understand how to send and receive UDP messages, let's take a look at the example as it runs. The best way to test it is to run an instance of the application on three separate machines. On one of the applications, click the Listen button. On the other two, set the Recipient's Name/IP field to the name of the machine on which the first application is running. This can be either a host name or an IP address. Now click the Send Datagram button a few times, and the messages should appear in the receiver's message window. Upon receipt of each message, the Winsock Information fields should be updated with the IP address of the sender and the port number on which the message was sent. You can even use the Sender commands on the same application as the receiver to send messages on the same machine.</p>

<p>Another interesting test is using either subnet-directed broadcasts or broadcast datagrams. Assuming that you're testing all three machines on the same subnet, you can send a datagram to a specified subnet and all listening applications receive the message. For example, on our test machines we have two single-homed machines with IP addresses 157.54.185.186 and 157.54.185.224. The last machine is multihomed, with IP addresses 169.254.26.113 and 157.54.185.206. As you can see, all three machines share the subnet 157.54.185.255. Let's digress for a moment to discuss an important detail. If you want to receive UDP messages, you must implicitly bind to the first IP address stored in the network bindings when you call the <i>Bind</i> method. This is sufficient if your machine has only one network card. In some cases, however, a machine has more than one network interface and therefore more than one IP address. In these cases, the second parameter to the <i>Bind</i> method is the IP address on which to bind. Unfortunately, the Winsock control property <i>LocalIP</i> returns only one IP address, and the control provides no other method for obtaining other IP addresses associated with the local machine.</p>

<p>Now let's try some broadcasting. Close each sending or listening socket on each of the instances running. On the two single-homed machines, click the Listen button so that each machine can receive datagram messages. We don't use the multihomed machine because we aren't binding to any particular IP address in the code. On the third machine, enter the recipient's address as 157.54.185.255 and click on the Send Data button a few times. You should see the message being received by both listening applications. If your sending machine is also multihomed, you might be wondering how it knows which network interface to send the datagram over. It is one of the routing table's functions to determine the best interface to send the message over, given the message's destination address and the address of each interface on the local machine. If you would like to learn more about subnets and routing, consult a book on TCP/IP such as <i>TCP/IP Illustrated Volume 1,</i> by W. Richard Stevens (Addison-Wesley, 1994) or <i>TCP/IP: Architecture, Protocols, and Implementation with IP v6 and IP Security,</i> by Dr. Sidnie Feit (McGrawHill, 1996). The last test to try is to close the sender's socket on the third machine, enter the recipient's address as 255.255.255.255, and click the Send Datagram button a few times. The results should be the same: the other two listening programs should receive the message. However, the only difference on a multihomed machine is that the UDP message is being broadcast on each network attached to the machine.</p>

<A NAME="468"><H2>UDP States</H2></A>

<p>You might be a bit confused by the order in which method calls should be made to successfully send or receive datagrams. As mentioned earlier, the most common mistake when programming the Winsock control is to call a method whose operation is not valid for the current state of the control. To help alleviate this kind of mistake, take a look at Figure 15-3, which is a state diagram of the socket states when you are using UDP messages. Notice that the default starting state is always <i>sckClosed</i>, and no errors are generated for invalid host names.</p>

<p>
<A HREF="javascript:fullSize('F15ji03x.htm')"> <img src="images/F15ji03.JPG" width=404 height=204 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 15-3.</b> <i>UDP state diagram</i><!-- /caption -->
</p>

</BODY>
</HTML>




