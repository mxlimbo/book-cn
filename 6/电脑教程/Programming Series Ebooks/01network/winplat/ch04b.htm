<HTML>
<HEAD>
<TITLE>Named Pipe Implementation Details</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04a.htm" , "ch04c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="58"><H1>Named Pipe Implementation Details</H1></A>

<p>Named pipes are designed around the Windows file system using the Named Pipe File System (NPFS) interface. As a result, client and server applications use standard Win32 file system API functions such as <i>ReadFile</i> and <i>WriteFile</i> to send and receive data. Using these API functions allows applications to take advantage of Win32 file system naming conventions and Windows NT or Windows 2000 file system security. NPFS relies on the MSNP redirector to send and receive named pipe data over a network. This makes the interface protocol-independent: when developing an application that uses named pipes to form communications among processes across a network, a programmer does not have to worry about the details of underlying network transport protocols, such as TCP and IPX. Named pipes are identified to NPFS using the Universal Naming Convention (UNC). <a href="ch02a.htm">Chapter 2</A> describes the UNC, the Windows redirector, and security in greater detail.</p>

<A NAME="59"><H2>Named Pipe Naming Conventions</H2></A>

<p>Named pipes are identified using the following UNC format:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
\\server\Pipe\[path]name
</pre>
</td></tr></table>
</p>

<p>The string above is divided into three parts: <i>\\</i>server, <i>\</i>Pipe, and <i>\</i>[path]name<i>.</i> The first string part, <i>\\</i>server, represents the server name in which a named pipe is created and the server that listens for incoming connections. The second part, <i>\</i>Pipe, is a hardcoded mandatory string requirement for identifying that this filename belongs to NPFS. The third part, <i>\</i>[path]name, allows applications to uniquely define and identify a named pipe name, and it can have multiple levels of directories. For example, the following name types are legal for identifying a named pipe:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
\\myserver\PIPE\mypipe
\\Testserver\pipe\cooldirectory\funtest\jim
\\.\Pipe\Easynamedpipe
</pre>
</td></tr></table>
</p>

<p>The server string portion can be represented as a dot (.) or a server name.</p>

<A NAME="60"><H2>Byte Mode and Message Mode</H2></A>

<p>Named pipes offer two basic communication modes: byte mode and message mode. In byte mode, messages travel as a continuous stream of bytes between the client and the server. This means that a client application and a server application do not know precisely how many bytes are being read from or written to a pipe at any given moment. So a write on one side will not always result in a same-size read on the other. This allows a client and a server to transfer data without regard to the contents of the data. In message mode, the client and the server send and receive data in discrete units. Every time a message is sent on the pipe, it must be read as a complete message. Figure 4-1 compares the two pipe modes.</p>

<p>
<A HREF="javascript:fullSize('F04ji01x.htm')"> <img src="images/F04ji01.JPG" width=404 height=256 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 4-1.</b> <i>Byte mode and message mode</i><!-- /caption -->
</p>

<A NAME="61"><H2>Compiling Applications</H2></A>

<p>When you build a named pipe client or server application using Microsoft Visual C++, your application must include the Winbase.h file in your program files. But if your application includes Windows.h&#8212;as most do&#8212;you can omit Winbase.h. Your application is also responsible for linking with Kernel32.lib, which typically is configured with the Visual C++ linker flags.</p>

<A NAME="62"><H2>Error Codes</H2></A>

<p>All Win32 API functions (except <i>CreateFile</i> and <i>CreateNamedPipe</i>) that are used in developing named pipe client and server applications return the value 0 when they fail. <i>CreateFile</i> and <i>CreateNamedPipe</i> return <i>INVALID_HANDLE_VALUE</i>. When either of these functions fails, applications should call the <i>GetLastError</i> function to retrieve specific information about the failure. For a complete list of error codes, consult the header file Winerror.h or see <a href="chaca.htm">Appendix C</a>, &quot;Winsock Error Codes.&quot;</p>

</BODY>
</HTML>




