<HTML>
<HEAD>
<TITLE>NetBIOS</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06d.htm" , "ch06f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="121"><H1>NetBIOS</H1></A>

<p>The NetBIOS address family is yet another protocol family accessible from Winsock. You will be familiar with many of the topics and caveats discussed here from the NetBIOS discussion in <a href="ch01a.htm">Chapter 1</A>. Addressing NetBIOS from Winsock still requires the knowledge of NetBIOS names and LANA numbers. We'll assume you've read those sections in <a href="ch01a.htm">Chapter 1</A>, and we'll continue on with the specifics of accessing NetBIOS from Winsock.</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>
The NetBIOS address family is exposed by Winsock only on Windows NT and Windows 2000. It is not available on the Windows 95 and Windows 98 platforms or on Windows CE.
</blockquote></div></p>

<A NAME="122"><H2>Addressing</H2></A>

<p>The basis for addressing a machine under NetBIOS is a NetBIOS name, which we covered in <a href="ch01a.htm">Chapter 1</A>. To review, a NetBIOS name is 16 characters long, with the last character reserved as a qualifier to define what type of service the name belongs to. There are two types of NetBIOS names: unique and group. A unique name can be registered by only one process on the entire network. For example, a session-based server would register the name FOO, and clients who wanted to contact that server would attempt a connection to FOO. Group names allow a group of applications to register the same name, so datagrams sent to that name will be received by all processes that registered that name.</p>

<p>In Winsock, the NetBIOS addressing structure is defined in Wsnetbs.h, as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
#define NETBIOS_NAME_LENGTH 16

typedef struct sockaddr_nb
{
    short   snb_family;
    u_short snb_type;
    char    snb_name[NETBIOS_NAME_LENGTH];
} SOCKADDR_NB, *PSOCKADDR_NB, FAR *LPSOCKADDR_NB;
</pre>
</td></tr></table>
</p>

<p>The <i>snb_family</i> field specifies the address family of this structure and should always be set to <i>AF_NETBIOS</i>. The <i>snb_type</i> field is used to specify a unique or a group name. The following defines can be used for this field:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
#define NETBIOS_UNIQUE_NAME         (0x0000)
#define NETBIOS_GROUP_NAME          (0x0001)
</pre>
</td></tr></table>
</p>

<p>Finally, the <i>snb_name</i> field is the actual NetBIOS name.</p>

<p>Now that you know what each field means and what it should be set to, the following handy macro defined in the header file sets all of this for you:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
#define SET_NETBIOS_SOCKADDR(_snb, _type, _name, _port)       \
    {                                                         \
        int _i;                                               \
        (_snb)-&gt;snb_family = AF_NETBIOS;                      \
        (_snb)-&gt;snb_type = (_type);                           \
        for (_i = 0; _i &lt; NETBIOS_NAME_LENGTH - 1; _i++) {    \
            (_snb)-&gt;snb_name[_i] = ' ';                       \
        }                                                     \
        for (_i = 0;                                          \
             *((_name) + _i) != '\0'                          \
             &amp;&amp; _i &lt; NETBIOS_NAME_LENGTH - 1;                 \
             _i++)                                            \
        {                                                     \
            (_snb)-&gt;snb_name[_i] = *((_name)+_i);             \
        }                                                     \
        (_snb)-&gt;snb_name[NETBIOS_NAME_LENGTH - 1] = (_port);  \
    }
</pre>
</td></tr></table>
</p>

<p>The first parameter to the macro, <i>_snb</i>, is the address of the <i>SOCKADDR_NB</i> structure you are filling in. As you can see, it automatically sets the <i>snb_family</i> field to <i>AF_NETBIOS</i>. For the <i>_type</i> parameter to the macro, specify <i>NETBIOS_UNIQUE_NAME</i> or <i>NETBIOS_GROUP_NAME</i>. The _<i>name</i> parameter is the NetBIOS name. The macro assumes it is either at least <i>NETBIOS_NAME_LENGTH</i> _ 1 characters in length or is null-terminated if shorter. Notice that the <i>snb_name</i> field is prefilled with spaces. Finally, the macro sets the 16th character of the <i>snb_name</i> character string to the value of the <i>_port</i> parameter.</p>
<p>You can see that the NetBIOS name structure in Winsock is straightforward and shouldn't present any particular difficulties. The name resolution is performed under the hood, so unlike with TCP and IrDA, you don't have to resolve a name into a physical address before any operations. This becomes clear when you consider that NetBIOS is implemented over multiple protocols and each protocol has its own addressing scheme. In the <a href="ch07a.htm">next chapter</a>, we'll present a simple client/server using the NetBIOS interface in Winsock.</p>

<A NAME="123"><H2>Creating a Socket</H2></A>

<p>The most important consideration when you create a NetBIOS socket is the LANA number. Just as in the native NetBIOS API, you have to be aware of which LANA numbers concern your application. Remember that in order for a NetBIOS client and server to communicate, they must have a common transport protocol on which they both listen or connect. There are two ways to create a NetBIOS socket. The first is to call <i>socket</i> or <i>WSASocket</i>, as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
s = WSASocket(AF_NETBIOS, SOCK_DGRAM | SOCK_SEQPACKET, -lana,
              NULL, 0, WSA_FLAG_OVERLAPPED);
</pre>
</td></tr></table>
</p>

<p>The <i>type</i> parameter of <i>WSASocket</i> is either <i>SOCK_DGRAM</i> or <i>SOCK_SEQPACKET</i> (don't specify both), depending on whether you want a connectionless datagram or a connection-oriented session socket. The third parameter, <i>protocol</i>, is the LANA number on which the socket should be created, except that you have to make it negative. The fourth parameter is null because you are specifying your own parameters, not using a <i>WSAPROTOCOL_INFO</i> structure. The fifth parameter isn't used. Finally, the <i>dwFlags</i> parameter is set to <i>WSA_FLAG_OVERLAPPED</i>; you should specify <i>WSA_FLAG_OVERLAPPED</i> on all calls to <i>WSASocket</i>.</p>

<p>The drawback to the first method of socket creation is that you need to know which LANA numbers are valid to begin with. Unfortunately, Winsock doesn't have a nice, short method of enumerating available LANA numbers. The alternative in Winsock is to enumerate all transport protocols with <i>WSAEnumProtocols</i>. Of course, you could call the <i>Netbios</i> function with the <i>NCBENUM</i> command to get the valid LANAs. <a href="ch05a.htm">Chapter 5</A> described how to call <i>WSAEnumProtocols</i>. The following sample enumerates all transport protocols, searches for a NetBIOS transport, and creates a socket for each one.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
dwNum = WSAEnumProtocols(NULL, lpProtocolBuf, &amp;dwBufLen);
if (dwNum == SOCKET_ERROR)
{
    // Error
}
for (i = 0; i &lt; dwNum; i++)
{
    // Look for those entries in the AF_NETBIOS address family
    if (lpProtocolBuf[i].iAddressFamily == AF_NETBIOS)
    {
        // Look for either SOCK_SEQPACKET or SOCK_DGRAM
        if (lpProtocolBuf[i].iSocketType == SOCK_SEQPACKET)
        {
             s[j++] = WSASocket(FROM_PROTOCOL_INFO,
                FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO,
                   &amp;lpProtocolBuf[i], 0, WSA_FLAG_OVERLAPPED);
        }
    }
}
</pre>
</td></tr></table>
</p>

<p>In the above pseudocode, we enumerate the available protocols and iterate through them looking for those belonging to the <i>AF_NETBIOS</i> address family. Next we check the socket type, and in this case, look for entries of type <i>SOCK_SEQPACKET</i>. Otherwise, if we wanted datagrams we would check for <i>SOCK_DGRAM</i>. If this matches, we have a NetBIOS transport we can use. If you need the LANA number, take the absolute value of the <i>iProtocol</i> field in the <i>WSAPROTOCOL_INFO</i> structure. The only exception is for LANA 0. The <i>iProtocol</i> field for this LANA is 0x80000000 because 0 is reserved for use by Winsock. The variable <i>j</i> will contain the number of valid transports.</p>

</BODY>
</HTML>




