<HTML>
<HEAD>
<TITLE>Basic Server and Client</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04b.htm" , "ch04d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="63"><H1>Basic Server and Client</H1></A>

<p>Named pipes feature a simple client/server design architecture in which data can flow in both a unidirectional and a bidirectional manner between a client and server. This is useful because it allows you to send and receive data whether your application is a client or a server. The main difference between a named pipe server and a client application is that a named pipe server is the only process capable of creating a named pipe and accepting pipe client connections. A client application is capable only of connecting to an existing named pipe server. Once a connection is formed between a client application and a server application, both processes are capable of reading and writing data on a pipe using standard Win32 functions such as <i>ReadFile</i> and <i>WriteFile</i>. Note that a named pipe server application can operate only on Windows NT or Windows 2000&#8212;Windows 95 and Windows 98 do not permit applications to create a named pipe. This limitation makes it impossible to form communications directly between two Windows 95 or Windows 98 computers. However, Windows 95 and Windows 98 clients can form connections to Windows NT and Windows 2000 computers.</p>

<A NAME="64"><H2>Server Details</H2></A>

<p>Implementing a named pipe server requires developing an application to create one or more named pipe instances, which can be accessed by clients. To a server, a pipe instance is nothing more than a handle used to accept a connection from a local or remote client application. The following steps describe how to write a basic server application:</p>

<ol>
<p><li>Create a named pipe instance handle using the CreateNamedPipe API function.</li></p>

<p><li>Use the <i>ConnectNamedPipe</i> API function to listen for a client connection on the named pipe instance.</li></p>

<p><li>Receive data from and send data to the client using the <i>ReadFile</i> and <i>WriteFile</i> API functions.</li></p>

<p><li>Close down the named pipe connection using the <i>DisconnectNamedPipe</i> API function.</li></p>

<p><li>Close the named pipe instance handle using the <i>CloseHandle</i> API function.</li></p>
</ol>

<p>First, your server process needs to create a named pipe instance using the <i>CreateNamedPipe</i> API call, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
HANDLE CreateNamedPipe(
    LPCTSTR<i> lpName</i>,
    DWORD<i> dwOpenMode</i>, 
    DWORD<i> dwPipeMode</i>, 
    DWORD<i> nMaxInstances</i>, 
    DWORD<i> nOutBufferSize</i>,
    DWORD<i> nInBufferSize</i>, 
    DWORD<i> nDefaultTimeOut</i>,
    LPSECURITY_ATTRIBUTES<i> lpSecurityAttributes</i>
);
</pre>
</td></tr></table>
</p>

<p>The first parameter, <i>lpName</i>, specifies the name of a named pipe. The name must have the following UNC form:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
\\.\Pipe\[<i>path</i>]<i>name</i> 
</pre>
</td></tr></table>
</p>

<p>Notice that the server name is represented as a dot, which represents the local machine. You cannot create a named pipe on a remote computer. The <i>[path]name</i> part of the parameter must represent a unique name. This might simply be a filename, or it might be a full directory path followed by a filename.</p>

<p>The <i>dwOpenMode</i> parameter describes the directional, I/O control, and security modes of a pipe when it is created. Table 4-1 describes all the available flags that can be used. A pipe can be created using a combination of these flags by ORing them together.</p>

<p>The <i>PIPE_ACCESS_</i> flags determine flow direction on a pipe between a client and a server. A pipe can be opened as bidirectional (two-way) using the <i>PIPE_ACCESS_DUPLEX</i> flag: data can flow in both directions between the client and the server. In addition, you can also control the direction of data flow by opening the pipe as unidirectional (one-way) using the flag <i>PIPE_ACCESS_INBOUND</i> or <i>PIPE_ACCESS_OUTBOUND</i>: data can flow only one way from the client to the server or vice versa. Figure 4-2 describes the flag combinations further and shows the flow of data between a client and a server.</p>

<p><b>Table 4-1.</b> <i>Named pipe open mode flags</i></p>

<table cellpadding=5 width="95%">
<tr><th valign="top"><i>Open Mode</i></th> <th valign="top"><i>Flags</i></th> <th valign="top"><i>Description</i></th></tr>

<tr><td valign="top" rowspan=3>Directional</td> 
<td valign="top"><i>PIPE_ACCESS_DUPLEX</i> </td>
<td valign="top">The pipe is bidirectional: both the server and client processes can read from and write data to the pipe.</td></tr>

<tr>
<td valign="top"><i>PIPE_ACCESS_OUTBOUND</i></td> 
<td valign="top">The flow of data in the pipe goes from server to client only.</td></tr>

<tr>
<td valign="top"><i>PIPE_ACCESS_INBOUND</i></td> 
<td valign="top">The flow of data in the pipe goes from client to server only.</td></tr>

<tr><td valign="top" rowspan=2>I/O Control</td> 
<td valign="top"><i>FILE_FLAG_WRITE_THROUGH</i></td> 
<td valign="top">Works only for byte-mode pipes. Functions writing to a named pipe do not return until the data written is transmitted across the network and is in the pipe's buffer on the remote computer.</td></tr>

<tr>
<td valign="top"><i>FILE_FLAG_OVERLAPPED</i></td> 
<td valign="top">Allows functions that perform read, write, and connect operations to use overlapped I/O.</td></tr>

<tr>
<td valign="top" rowspan=3>Security</td> 
<td valign="top"><i>WRITE_DAC</i></td> 
<td valign="top">Allows your application to have write access to the named pipe's DACL.</td></tr>

<tr>

<td valign="top"><i>ACCESS_SYSTEM_SECURITY</i></td> 
<td valign="top">Allows your application to have write access to the named pipe's SACL.</td>
</tr>

<tr>

<td valign="top"><i>WRITE_OWNER</i></td> 
<td valign="top">Allows your application to have write access to the named pipe's owner and group SID.</td>
</tr>
</table>


<p>
<A HREF="javascript:fullSize('F04ji02x.htm')"> <img src="images/F04ji02.JPG" width=404 height=296 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 4-2.</b> <i>Mode flags and flow direction</i><!-- /caption -->
</p>

<p>The next set of <i>dwOpenMode</i> flags controls I/O behavior on a named pipe from the server's perspective. The <i>FILE_FLAG_WRITE_THROUGH</i> flag controls the write operations so that functions writing to a named pipe do not return until the data written is transmitted across the network and is in the pipe's buffer on the remote computer. This flag works only for byte-mode named pipes when the client and the server are on different computers. The <i>FILE_FLAG_OVERLAPPED</i> flag allows functions performing read, write, and connect operations to return immediately, even if those functions take significant time to complete. We will discuss the details of overlapped I/O when we develop an advanced server later in this chapter.</p>

<p>The last set of <i>dwOpenMode</i> flags described in Table 4-1 controls the server's ability to access the security descriptor that is created by a named pipe. If your application needs to modify or update the pipe's security descriptor after the pipe is created, you should set these flags accordingly to permit access. The <i>WRITE_DAC</i> flag allows your application to update the pipe's discretionary access control list (DACL), whereas <i>ACCESS_SYSTEM_SECURITY</i> allows access to the pipe's system access control list (SACL). The <i>WRITE_OWNER</i> flag allows you to change the pipe's owner and group security ID (SID). For example, if you want to deny access to a particular user who has access rights to your pipe, you can modify the pipe's DACL using security API functions. <a href="ch02a.htm">Chapter 2</A> discusses DACLs, SACLs, and SIDs in greater detail.</p>

<p><i>CreateNamedPipe</i>'s <i>dwPipeMode</i> parameter specifies the read, write, and wait operating modes of a pipe. Table 4-2 describes all the available mode flags that can be used. The flags can be issued by ORing one flag from each mode category. If a pipe is opened as byte-oriented using the <i>PIPE_READMODE_BYTE</i> | <i>PIPE_TYPE_BYTE</i> mode flags, data can be read and written only as a stream of bytes. This means that when you read and write data to a pipe, you do not have to balance each read and write because your data does not have any message boundaries. For example, if a sender writes 500 bytes to a pipe, a receiver might want to read 100 bytes at a time until it receives all of the data. To establish clear boundaries around messages, place the pipe in message-oriented mode using the flags <i>PIPE_READMODE_MESSAGE</i> | <i>PIPE_TYPE_MESSAGE</i>, meaning each read and write must be balanced. For example, if a sender writes a 500-byte message to a pipe, the receiver must provide the <i>ReadFile</i> function a 500-byte or larger buffer when reading data. If the receiver fails to do so, <i>ReadFile</i> will fail with error <i>ERROR_MORE_DATA</i>. You can also combine <i>PIPE_TYPE_MESSAGE</i> with <i>PIPE_READMODE_BYTE</i>, allowing a sender to write messages to a pipe and the receiver to read an arbitrary amount of bytes at a time. The message delimiters will be ignored in the data stream. You cannot mix the <i>PIPE_TYPE_BYTE</i> flag with the <i>PIPE_READMODE_MESSAGE</i> flag. Doing so will cause the <i>CreateNamedPipe</i> function to fail with error <i>ERROR_INVALID_PARAMETER</i> because no message delimiters are in the I/O stream when data is written into the pipe as bytes. The <i>PIPE_WAIT</i> or <i>PIPE_NOWAIT</i> flag can also be combined with read and write mode flags. The <i>PIPE_WAIT</i> flag places a pipe in blocking mode and the <i>PIPE_NOWAIT</i> flag places a pipe in nonblocking mode. In blocking mode, I/O operations such as <i>ReadFile</i> will block until the I/O request is
complete. This is the default behavior if you do not specify any flags. The nonblocking mode flag <i>PIPE_NOWAIT</i> is designed to allow I/O operations to return immediately. However, it should not be used to achieve asynchronous I/O in Win32 applications. It is included to provide backward compatibility with older Microsoft LAN Manager 2.0 applications. The <i>ReadFile</i> and <i>WriteFile</i> functions allow applications to accomplish asynchronous I/O using Win32 overlapped I/O, which will be demonstrated later in this chapter.</p>

<p><b>Table 4-2.</b> <i>Named pipe read/write mode flags</i></p>

<table cellpadding=5 width="95%">
<tr><th valign="top"><i>Mode</i></th> <th valign="top"><i>Flags</i></th><th valign="top"><i>Description</i></th></tr>
<tr><td valign="top" rowspan=2>Write </td>
<td valign="top"><i>PIPE_TYPE_BYTE</i></td> 
<td valign="top">Data is written to the pipe as a stream of bytes.</td></tr>

<tr>
<td valign="top"><i>PIPE_TYPE_MESSAGE</i></td> 
<td valign="top">Data is written to the pipe as a stream of messages.</td>
</tr>

<tr>
<td valign="top" rowspan=2>Read</td> 
<td valign="top"><i>PIPE_READMODE_BYTE</i></td> 
<td valign="top">Data is read from the pipe as a stream of bytes.</td>
</tr>

<tr>
<td valign="top"><i>PIPE_READMODE_MESSAGE</i></td> 
<td valign="top">Data is read from the pipe as a stream of messages.</td>
</tr>

<tr>
<td valign="top" rowspan=2>Wait</td> 
<td valign="top"><i>PIPE_WAIT</i></td> 
<td valign="top">Blocking mode is enabled.</td>
</tr>

<tr>
<td valign="top"><i>PIPE_NOWAIT</i></td> 
<td valign="top">Nonblocking mode is enabled.</td>
</tr>
</table>

<p><div class="note"><blockquote><b>NOTE</b><hr>The <i>PIPE_NOWAIT</i> flag is obsolete and should not be used in Win32 environments to accomplish asynchronous I/O. It is included in this book to provide backward compatibility with older Microsoft LAN Manager 2.0 software.</blockquote></div></p>

<p>The <i>nMaxInstances</i> parameter specifies how many instances or pipe handles can be created for a named pipe. A pipe instance is a connection from a local or remote client application to a server application that created the Named Pipe. Acceptable values are in the range 1 through <i>PIPE_UNLIMITED_INSTANCES</i>. For example, if you want to develop a server that can service only five client connections at a time, set this parameter to 5. If you set this parameter to <i>PIPE_UNLIMITED_INSTANCES</i>, the number of pipe instances that can be created is limited only by the availability of system resources.</p>

<p><i>CreateNamedPipe</i>'s <i>nOutBufferSize</i> and <i>nInBufferSize</i> parameters represent the number of bytes to reserve for internal input and output buffer sizes. These sizes are advisory in that every time a named pipe instance is created, the system sets up inbound and/or outbound buffers using the nonpaged pool (the physical memory used by the operating system). The buffer size specified should be reasonable (not too large) so that your system will not run out of nonpaged pool memory, but it should also be large enough to accommodate typical I/O requests. If an application attempts to write data that is larger than the buffer sizes specified, the system will try to automatically expand the buffers to accommodate the data using nonpaged pool memory. For practical purposes, applications should size these internal buffers to match the size of the application's send and receive buffers used when calling <i>ReadFile</i> and <i>WriteFile</i>.</p>

<p>The <i>nDefaultTimeOut</i> parameter specifies the default timeout value (how long a client will wait to connect to a named pipe) in milliseconds. This affects only client applications that use the <i>WaitNamedPipe</i> function to determine when an instance of a named pipe is available to accept connections. We will discuss this concept in greater detail later in this chapter, when we develop a named pipe client application.</p>

<p>The <i>lpSecurityAttributes</i> parameter allows the application to specify a security descriptor for a named pipe and determines whether a child process can inherit the newly created handle. If this parameter is specified as <i>NULL</i>, the named pipe gets a default security descriptor and the handle cannot be inherited. A default security descriptor grants the named pipe the same security limits and access controls as the process that created it following the Windows NT and Windows 2000 security model described in <a href="ch02a.htm">Chapter 2</A>. An application can apply access control restrictions to a pipe by setting access privileges for particular users and groups in a <i>SECURITY_DESCRIPTOR</i> structure using security API functions. If a server wants to open access to any client, you should assign a null discretionary access control list (DACL) to the <i>SECURITY_DESCRIPTOR</i> structure.</p>

<p>After you successfully receive a handle from <i>CreateNamedPipe</i>, which is known as a pipe instance, you have to wait for a connection from a named pipe client. This connection can be made through the <i>ConnectNamedPipe</i> API function, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL ConnectNamedPipe( 
    HANDLE<i> hNamedPipe</i>,
    LPOVERLAPPED<i> lpOverlapped</i>
);
</pre>
</td></tr></table>
</p>

<p>The <i>hNamedPipe</i> parameter represents the pipe instance handle returned from <i>CreateNamedPipe</i>. The <i>lpOverlapped</i> parameter allows this API function to operate asynchronously, or in nonblocking mode, if the pipe was created using the <i>FILE_FLAG_OVERLAPPED</i> flag, which is known as Win32 overlapped I/O. If this parameter is specified as <i>NULL</i>, <i>ConnectNamedPipe</i> blocks until a client forms a connection to the server. We will discuss overlapped I/O in greater detail when you learn to create a more advanced named pipe server later in this chapter.</p>

<p>Once a named pipe client successfully connects to your server, the <i>ConnectNamedPipe</i> API call completes. The server is then free to send data to a client using the <i>WriteFile</i> API function and to receive data from the client using <i>ReadFile</i>. Once the server has finished communicating with a client, it should call <i>DisconnectNamedPipe</i> to close the communication session. Figure 4-3 demonstrates how to write a simple server application that can communicate with one client.</p>

<p><b>Figure 4-3.</b> <i>Simple named pipe server</i></p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>
// Server.cpp

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

void main(void)
{
    HANDLE PipeHandle;
    DWORD BytesRead;
    CHAR buffer[256];

    if ((PipeHandle = CreateNamedPipe(&quot;\\\\.\\Pipe\\Jim&quot;,
        PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE, 1,e
        0, 0, 1000, NULL)) == INVALID_HANDLE_VALUE)
    {
        printf(&quot;CreateNamedPipe failed with error %d\n&quot;,
            GetLastError());
        return;
    }

    printf(&quot;Server is now running\n&quot;);

    if (ConnectNamedPipe(PipeHandle, NULL) == 0)
    {
        printf(&quot;ConnectNamedPipe failed with error %d\n&quot;,
            GetLastError());
        CloseHandle(PipeHandle);
        return;
    }

    if (ReadFile(PipeHandle, buffer, sizeof(buffer),
        &amp;BytesRead,  NULL) &lt;= 0)
    {
        printf(&quot;ReadFile failed with error %d\n&quot;, GetLastError());
        CloseHandle(PipeHandle);
        return;
    }

    printf(&quot;%.*s\n&quot;, BytesRead, buffer);

    if (DisconnectNamedPipe(PipeHandle) == 0)
    {
        printf(&quot;DisconnectNamedPipe failed with error %d\n&quot;,
            GetLastError());
        return;
    }

    CloseHandle(PipeHandle);
}


</pre>
</td></tr></table>
</p>

<p><div class="sidebar"><blockquote>
<b>Building Null Discretionary Access Control Lists (Null DACLs)</b>

<p>When applications create securable objects such as files and named pipes on Windows NT or Windows 2000 using Win32 API functions, the operating system grants the applications the ability to set up access control rights by specifying a <i>SECURITY_ATTRIBUTES</i> structure, defined as:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
typedef struct _SECURITY_ATTRIBUTES {
    DWORD   nLength; 
    LPVOID  lpSecurityDescriptor; 
    BOOL    bInheritHandle 
} SECURITY_ATTRIBUTES; 
</pre></td></tr></table>
</p>

<p>The <i>lpSecurityDescriptor</i> field defines the access rights for an object in a <i>SECURITY_DESCRIPTOR</i> structure. A <i>SECURITY_DESCRIPTOR</i> structure contains a DACL field that defines which users and groups can access the object. If you set this field to <i>NULL</i>, any user or group can access your resource.</p>

<p>Applications cannot directly access a <i>SECURITY_DESCRIPTOR</i> structure and must use Win32 security API functions to do so. If you want to assign a null DACL to a <i>SECURITY_DESCRIPTOR</i> structure, you must do the following:</p>

<ol>
<p><li>Create and initialize a <i>SECURITY_DESCRIPTOR</i> structure by calling the <i>InitializeSecurityDescriptor</i> API function.</li></p>

<p><li>Assign a null DACL to the <i>SECURITY_DESCRIPTOR</i> structure by calling the <i>SetSecurityDescriptorDacl</i> API function.</li></p>
</ol>

After you successfully build a new <i>SECURITY_DESCRIPTOR</i> structure, you must assign it to the <i>SECURITY_ATTRIBUTES</i> structure. Now you are ready to begin calling Win32 functions such as <i>CreateNamedPipe</i> with your new <i>SECURITY_ATTRIBUTES</i> structure, which contains a null DACL. The following code fragment demonstrates how to call the security API functions needed to accomplish this.

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
// Create new SECURITY_ATTRIBUTES and SECURITY_DESCRIPTOR
// structure objects
SECURITY_ATTRIBUTES sa;
SECURITY_DESCRIPTOR sd;

// Initialize the new SECURITY_DESCRIPTOR object to empty values
if (InitializeSecurityDescriptor(&amp;sd, SECURITY_DESCRIPTOR_REVISION)
    == 0)
{
    printf(&quot;InitializeSecurityDescriptor failed with error %d\n&quot;,
        GetLastError());
    return;
}

// Set the DACL field in the SECURITY_DESCRIPTOR object to NULL
if (SetSecurityDescriptorDacl(&amp;sd, TRUE, NULL, FALSE) == 0)
{
    printf(&quot;SetSecurityDescriptorDacl failed with error %d\n&quot;,
        GetLastError());
    return;
}

// Assign the new SECURITY_DESCRIPTOR object to the 
// SECURITY_ATTRIBUTES object
sa.nLength = sizeof(SECURITY_ATTRIBUTES);
sa.lpSecurityDescriptor = &amp;sd;
sa.bInheritHandle = TRUE;
</pre>
</td></tr></table>
</p>
</blockquote></div></p>

<A NAME="65"><H2>Advanced Server</H2></A>

<p>Figure 4-3 demonstrates how to develop a named pipe server application that handles only a single pipe instance. All of the API calls operate in a synchronous mode in which each call waits until an I/O request is complete. A named pipe server is also capable of having multiple pipe instances so that clients can form two or more connections to the server; the number of pipe instances is limited by the number specified in the <i>nMaxInstances</i> parameter of the <i>CreateNamedPipe</i> API call. To handle more than one pipe instance, a server must consider using multiple threads or asynchronous Win32 I/O mechanisms&#8212;such as overlapped I/O and completion ports&#8212;to service each pipe instance. Asynchronous I/O mechanisms allow a server to service all pipe instances simultaneously from a single application thread. Our discussion will demonstrate how to develop advanced servers using threads and overlapped I/O. See <a href="ch08a.htm">Chapter 8</A> for more information on completion ports as they apply to Windows sockets.</p>

<A NAME="66"><H3>Threads</H3></A>

<p>Developing an advanced server that can support more than one pipe instance using threads is simple. All you need to do is create one thread for each pipe instance and service each instance using the techniques we described earlier for the simple server. Figure 4-4 demonstrates a server that is capable of serving five pipe instances. The application is an echo server that reads data from a client and echoes the data back.</p>

<p><b>Figure 4-4.</b> <i>Advanced named pipe server using threads in Win32</i></p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>
// Threads.cpp

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;

#define NUM_PIPES 5

DWORD WINAPI PipeInstanceProc(LPVOID lpParameter);

void main(void) 
{
    HANDLE ThreadHandle;
    INT i;
    DWORD ThreadId;

    for(i = 0; i &lt; NUM_PIPES; i++)
    {
        // Create a thread to serve each pipe instance  
        if ((ThreadHandle = CreateThread(NULL, 0, PipeInstanceProc,
            NULL, 0, &amp;ThreadId)) == NULL)
        {
            printf(&quot;CreateThread failed with error %\n&quot;,
                GetLastError());
            return;
        }
        CloseHandle(ThreadHandle);
    }

    printf(&quot;Press a key to stop the server\n&quot;);
    _getch();
}

//
// Function: PipeInstanceProc
//
// Description:
//     This function handles the communication details of a single
//     named pipe instance
//     
DWORD WINAPI PipeInstanceProc(LPVOID lpParameter)
{
    HANDLE PipeHandle;
    DWORD BytesRead;
    DWORD BytesWritten;
    CHAR Buffer[256];

    if ((PipeHandle = CreateNamedPipe(&quot;\\\\.\\PIPE\\jim&quot;,
        PIPE_ACCESS_DUPLEX, PIPE_TYPE_BYTE | PIPE_READMODE_BYTE,
        NUM_PIPES, 0, 0, 1000, NULL)) == INVALID_HANDLE_VALUE)
    {
        printf(&quot;CreateNamedPipe failed with error %d\n&quot;,
            GetLastError());
        return 0;
    }

    // Serve client connections forever
    while(1) 
    {
        if (ConnectNamedPipe(PipeHandle, NULL) == 0)
        {
            printf(&quot;ConnectNamedPipe failed with error %d\n&quot;,
                GetLastError());
            break;
        }

        // Read data from and echo data to the client until
        // the client is ready to stop
        while(ReadFile(PipeHandle, Buffer, sizeof(Buffer),
            &amp;BytesRead,  NULL) &gt; 0)
        {
            printf(&quot;Echo %d bytes to client\n&quot;, BytesRead);

            if (WriteFile(PipeHandle, Buffer, BytesRead,
                &amp;BytesWritten, NULL) == 0)
            {
                printf(&quot;WriteFile failed with error %d\n&quot;,
                    GetLastError());
                break;
            }
        }

        if (DisconnectNamedPipe(PipeHandle) == 0)
        {
            printf(&quot;DisconnectNamedPipe failed with error %d\n&quot;,
                GetLastError());
            break;
        }
    }

    CloseHandle(PipeHandle);
    return 0;
}
</pre>
</td></tr></table>
</p>

<p>To develop your server to handle five pipe instances, start by calling the <i>CreateThread</i> API function. <i>CreateThread</i> starts five execution threads, all of which execute the <i>PipeInstanceProc</i> function simultaneously. The <i>PipeInstanceProc</i> function operates exactly like the basic server application (Figure 4-3) except that it reuses a named pipe handle by calling the <i>DisconnectNamedPipe</i> API function, which closes a client's session to the server. Once an application calls <i>DisconnectNamedPipe</i>, it is free to service another client by calling the <i>ConnectNamedPipe</i> function with the same pipe instance handle.</p>

<A NAME="67"><H3>Overlapped I/O</H3></A>

<p>Overlapped I/O is a mechanism that allows Win32 API functions such as <i>ReadFile</i> and <i>WriteFile</i> to operate asynchronously when I/O requests are made. This is accomplished by passing an <i>OVERLAPPED</i> structure to these API functions and later retrieving the results of an I/O request through the original <i>OVERLAPPED</i> structure using the <i>GetOverlappedResult</i> API function. When a Win32 API function is invoked with an overlapped structure, the call returns immediately.</p>

<p>To develop an advanced named pipe server that can manage more than one named pipe instance using overlapped I/O, you need to call <i>CreateNamedPipe</i> with the <i>nMaxInstances</i> parameter set to a value greater than 1. You also must set the <i>dwOpenMode</i> flag to <i>FILE_FLAG_OVERLAPPED</i>. Figure 4-5 demonstrates how to develop this advanced named pipe server. The application is an echo server that reads data from a client and writes the data back.</p>

<p><b>Figure 4-5.</b> <i>Advanced named pipe server using Win32 overlapped I/O</i></p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>
// Overlap.cpp

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

#define NUM_PIPES 5
#define BUFFER_SIZE 256

void main(void)
{
    HANDLE PipeHandles[NUM_PIPES];
    DWORD BytesTransferred;
    CHAR Buffer[NUM_PIPES][BUFFER_SIZE];
    INT i;
    OVERLAPPED Ovlap[NUM_PIPES];
    HANDLE Event[NUM_PIPES];

    // For each pipe handle instance, the code must maintain the 
    // pipes' current state, which determines if a ReadFile or 
    // WriteFile is posted on the named pipe. This is done using
    // the DataRead variable array. By knowing each pipe's 
    // current state, the code can determine what the next I/O 
    // operation should be.
    BOOL DataRead[NUM_PIPES];

    DWORD Ret;
    DWORD Pipe;

    for(i = 0; i &lt; NUM_PIPES; i++)
    {
        // Create a named pipe instance
        if ((PipeHandles[i] = CreateNamedPipe(&quot;\\\\.\\PIPE\\jim&quot;,
            PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
            PIPE_TYPE_BYTE | PIPE_READMODE_BYTE, NUM_PIPES,
            0, 0, 1000, NULL)) == INVALID_HANDLE_VALUE)
        {
            printf(&quot;CreateNamedPipe for pipe %d failed &quot;
                &quot;with error %d\n&quot;, i, GetLastError());
            return;
        }

        // Create an event handle for each pipe instance. This
        // will be used to monitor overlapped I/O activity on 
        // each pipe.
        if ((Event[i] = CreateEvent(NULL, TRUE, FALSE, NULL)) 
            == NULL)
        {
            printf(&quot;CreateEvent for pipe %d failed with error %d\n&quot;,
                i, GetLastError());
            continue;
        }

        // Maintain a state flag for each pipe to determine when data
        // is to be read from or written to the pipe
        DataRead[i] = FALSE;

        ZeroMemory(&amp;Ovlap[i], sizeof(OVERLAPPED));
        Ovlap[i].hEvent = Event[i];

        // Listen for client connections using ConnectNamedPipe()
        if (ConnectNamedPipe(PipeHandles[i], &amp;Ovlap[i]) == 0)
        {
            if (GetLastError() != ERROR_IO_PENDING)
            {
                printf(&quot;ConnectNamedPipe for pipe %d failed with&quot;
                    &quot; error %d\n&quot;, i, GetLastError());
                CloseHandle(PipeHandles[i]);
                return;
            }
        }
    }

    printf(&quot;Server is now running\n&quot;);


    // Read and echo data back to Named Pipe clients forever
    while(1) 
    {
        if ((Ret = WaitForMultipleObjects(NUM_PIPES, Event, 
            FALSE, INFINITE)) == WAIT_FAILED)
        {
            printf(&quot;WaitForMultipleObjects failed with error %d\n&quot;,
                GetLastError());
            return;
        }

        Pipe = Ret - WAIT_OBJECT_0;

        ResetEvent(Event[Pipe]);

        // Check overlapped results, and if they fail, reestablish 
        // communication for a new client; otherwise, process read 
        // and write operations with the client

        if (GetOverlappedResult(PipeHandles[Pipe], &amp;Ovlap[Pipe],
            &amp;BytesTransferred, TRUE) == 0)
        {
            printf(&quot;GetOverlapped result failed %d start over\n&quot;, 
                GetLastError());

            if (DisconnectNamedPipe(PipeHandles[Pipe]) == 0)
            {
                printf(&quot;DisconnectNamedPipe failed with error %d\n&quot;,
                    GetLastError());
                return;
            }

            if (ConnectNamedPipe(PipeHandles[Pipe],
                &amp;Ovlap[Pipe]) == 0)
            {
                if (GetLastError() != ERROR_IO_PENDING)
                {
                    // Severe error on pipe. Close this
                    // handle forever.
                    printf(&quot;ConnectNamedPipe for pipe %d failed with&quot;
                        &quot; error %d\n&quot;, i, GetLastError());
                    CloseHandle(PipeHandles[Pipe]);
                }
            }

            DataRead[Pipe] = FALSE;
        } 
        else
        {
            // Check the state of the pipe. If DataRead equals 
            // FALSE, post a read on the pipe for incoming data.
            // If DataRead equals TRUE, then prepare to echo data 
            // back to the client.

            if (DataRead[Pipe] == FALSE)
            {
                // Prepare to read data from a client by posting a
                // ReadFile operation

                ZeroMemory(&amp;Ovlap[Pipe], sizeof(OVERLAPPED));
                Ovlap[Pipe].hEvent = Event[Pipe];

                if (ReadFile(PipeHandles[Pipe], Buffer[Pipe],
                    BUFFER_SIZE, NULL, &amp;Ovlap[Pipe]) == 0)
                {
                    if (GetLastError() != ERROR_IO_PENDING)
                    {
                        printf(&quot;ReadFile failed with error %d\n&quot;,
                        GetLastError());
                    }
                }

                DataRead[Pipe] = TRUE;
            }
            else
            {
                // Write received data back to the client by
                // posting a WriteFile operation
                printf(&quot;Received %d bytes, echo bytes back\n&quot;,
                    BytesTransferred);

                ZeroMemory(&amp;Ovlap[Pipe], sizeof(OVERLAPPED));
                Ovlap[Pipe].hEvent = Event[Pipe];

                if (WriteFile(PipeHandles[Pipe], Buffer[Pipe],
                    BytesTransferred, NULL, &amp;Ovlap[Pipe]) == 0)
                {
                    if (GetLastError() != ERROR_IO_PENDING)
                    {
                        printf(&quot;WriteFile failed with error %d\n&quot;,
                        GetLastError());
                    }
                }

                DataRead[Pipe] = FALSE;
            }
        }
    }        
}
</pre>
</td></tr></table>
</p>

<p>For the server application to service five pipe instances at a time, it must call <i>CreateNamedPipe</i> five times to retrieve an instance handle for each pipe. After the server retrieves all the instance handles, it begins to listen for clients by calling <i>ConnectNamedPipe</i> asynchronously five times using an overlapped I/O structure for each pipe. As clients form connections to the server, all I/O is processed asynchronously. When clients disconnect, the server reuses each pipe instance handle by calling <i>DisconnectNamedPipe</i> and reissuing a <i>ConnectNamedPipe</i> call.</p>

<A NAME="68"><H3>Security impersonation</H3></A>

<p>One of the best reasons for using named pipes as a network programming solution is that they rely on Windows NT and Windows 2000 security features to control access when clients attempt to form communication to a server. Windows NT and Windows 2000 security offers security impersonation, which allows a named pipe server application to execute in the security context of a client. When a named pipe server executes, it normally operates at the security context permission level of the process that starts the application. For example, if a person with administrator privileges starts up a named pipe server, the server has the ability to access almost every resource on a Windows NT or Windows 2000 system. Such security access for a named pipe server is bad if the <i>SECURITY_DESCRIPTOR</i> structure specified in <i>CreateNamedPipe</i> allows all users to access your named pipe.</p>

<p>When a server accepts a client connection using the <i>ConnectNamedPipe</i> function, it can make its execution thread operate in the security context of the client by calling the <i>ImpersonateNamedPipeClient</i> API function, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL ImpersonateNamedPipeClient(
    HANDLE<i> hNamedPipe</i>
);
</pre>
</td></tr></table>
</p>

<p>The <i>hNamedPipe</i> parameter represents the pipe instance handle that is returned from <i>CreateNamedPipe</i>. When this function is called, the operating system changes the thread security context of the server to the security context of the client. This is quite handy: if your server is designed to access resources such as files, it will do so using the client's access rights, thereby allowing your server to preserve access control to resources regardless of who started the process.</p>

<p>When a server thread executes in a client's security context, it does so through a security impersonation level. There are four basic impersonation levels: Anonymous, Identification, Impersonation, and Delegation. Security impersonation levels govern the degree to which a server can act on behalf of a client. We will discuss these impersonation levels in greater detail when we develop a client application later in this chapter. After the server finishes processing a client's session, it should call <i>RevertToSelf</i> to return to its original thread execution security context. The <i>RevertToSelfAPI</i> function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL RevertToSelf(VOID); 
</pre>
</td></tr></table>
</p>

<p>This function does not have any parameters.</p>

<A NAME="69"><H2>Client Details</H2></A>

<p>Implementing a named pipe client requires developing an application that forms a connection to a named pipe server. Clients cannot create named pipe instances. However, clients do open handles to preexisting instances from a server. The following steps describe how to write a basic client application:</p>

<ol>
<p><li>Wait for a named pipe instance to become available using the <i>WaitNamedPipe</i> API function.</li></p>

<p><li>Connect to the named pipe using the <i>CreateFile</i> API function.</li></p>

<p><li>Send data to and receive data from the server using the <i>WriteFile</i> and <i>ReadFile</i> API functions.</li></p>

<p><li>Close the named pipe session using the <i>CloseHandle</i> API function.</li></p>
</ol>

<p>Before forming a connection, clients need to check for the existence of a named pipe instance using the <i>WaitNamedPipe</i> function, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL WaitNamedPipe(
    LPCTSTR<i> lpNamedPipeName</i>,
    DWORD<i> nTimeOut</i>
);
</pre>
</td></tr></table>
</p>

<p>The <i>lpNamedPipeName</i> parameter represents the named pipe you are trying to connect to. The <i>nTimeOut</i> parameter represents how long a client is willing to wait for a pipe's server process to have a pending <i>ConnectNamedPipe</i> operation on the pipe.</p>

<p>After <i>WaitNamedPipe</i> successfully completes, the client needs to open a handle to the server's named pipe instance using the <i>CreateFile</i> API function. <i>CreateFile</i> is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
HANDLE CreateFile(
    LPCTSTR<i> lpFileName</i>,
    DWORD<i> dwDesiredAccess</i>,
    DWORD<i> dwShareMode</i>,
    LPSECURITY_ATTRIBUTES<i> lpSecurityAttributes</i>,
    DWORD<i> dwCreationDisposition</i>,
    DWORD<i> dwFlagsAndAttributes</i>,
    HANDLE<i> hTemplateFile</i>
);
</pre>
</td></tr></table>
</p>

<p>The <i>lpFileName</i> parameter is the name of the pipe you are trying to open; the name must conform to the named pipe naming conventions mentioned earlier.</p>

<p>The <i>dwDesiredAccess</i> parameter defines the access mode and should be set to <i>GENERIC_READ</i> for reading data off the pipe and <i>GENERIC_WRITE</i> for writing data to the pipe. These flags can also be specified together by ORing both flags. The access mode must be compatible with how the pipe was created in the server. Match the mode specified in the <i>dwOpenMode</i> parameter of <i>CreateNamedPipe</i>, as described earlier. For example, if the server creates a pipe with <i>PIPE<u>_</u>ACCESS<u>_</u>INBOUND</i>, the client should specify <i>GENERIC_WRITE</i>.</p>

<p>The <i>dwShareMode</i> parameter should be set to 0 because only one client is capable of accessing a pipe instance at a time. The <i>lpSecurityAttributes</i> parameter should be set to <i>NULL</i> unless you need a child process to inherit the client's handle. This parameter is incapable of specifying security controls because <i>CreateFile</i> is not capable of creating named pipe instances. The <i>dwCreationDisposition</i> parameter should be set to <i>OPEN_EXISTING</i>, which means that the <i>CreateFile</i> function will fail if the named pipe does not exist.</p>

<p>The <i>dwFlagsAndAttributes</i> parameter should always be set to <i>FILE_ATTRIBUTE_NORMAL</i>. Optionally, you can specify the <i>FILE_FLAG_WRITE_THROUGH</i>, <i>FILE_FLAG_OVERLAPPED</i>, and <i>SECURITY_SQOS_PRESENT</i> flags by ORing them with the <i>FILE_ATTRIBUTE_NORMAL</i> flag. The <i>FILE_FLAG_WRITE_THROUGH</i> and <i>FILE_FLAG_OVERLAPPED</i> flags behave like the server's mode flags. The <i>SECURITY_SQOS_PRESENT</i> flag controls client impersonation security levels in a named pipe server. Security impersonation levels govern the degree to which a server process can act on behalf of a client process. A client can specify this information when it connects to a server. When the client specifies the <i>SECURITY_SQOS_PRESENT</i> flag, it must use one or more of the security flags listed below.</p>

<ul>
<p><li><b><i>SECURITY_ANONYMOUS</i></b> Specifies to impersonate the client at the Anonymous impersonation security level. The server process cannot obtain identification information about the client, and it cannot execute in the security context of the client.</li></p>

<p><li><b><i>SECURITY_IDENTIFICATION</i></b> Specifies to impersonate the client at the Identification impersonation security level. The server process can obtain information about the client, such as security identifiers and privileges, but it cannot execute in the security context of the client. This is useful for named pipe clients that want to allow the server to identify the client but not to act as the client.</li></p>

<p><li><b><i>SECURITY_IMPERSONATION</i></b> Specifies to impersonate the client at the Impersonation security level. The client wants to allow the server process to obtain information about the client and execute in the client's security context on its local system. Using this flag, the client allows the server to access any local resource on the server as the client. The server, however, cannot impersonate the client on remote systems.</li></p>

<p><li> <b><i>SECURITY_DELEGATION</i></b> Specifies to impersonate the client at the Delegation impersonation security level. The server process can obtain information about the client and execute in the client's security context on its local system and on remote systems.</li></p>


<p><div class="note"><blockquote><b>NOTE</b><hr><i>SECURITY_DELEGATION</i> works only if the server process is running on Windows 2000. Windows NT 4 does not implement security delegation.</blockquote></div></p>


<p><li><b><i>SECURITY_CONTEXT_TRACKING</i></b> Specifies that the security-tracking mode is dynamic. If this flag is not specified, security-tracking mode is static.</li></p>

<p><li><b><i>SECURITY_EFFECTIVE_ONLY</i></b> Specifies that only the enabled aspects of the client's security context are available to the server. If you do not specify this flag, all aspects of the client's security context are available.</li></p>
</ul>

<p>Named pipe security impersonation is described earlier in this chapter in the &quot;<A HREF="ch04c.htm#64">Server Details</A>&quot; section.</p>

<p>The final parameter of <i>CreateFile</i>, <i>hTemplateFile</i>, does not apply to named pipes and should be specified as <i>NULL</i>. If <i>CreateFile</i> completes without an error, the client application can begin to send and receive data on the named pipe using the <i>ReadFile</i> and <i>WriteFile</i> functions. Once the application is finished processing data, it can close down the connection using the <i>CloseHandle</i> function.</p>

<p>The program in Figure 4-6 is a simple named pipe client that demonstrates the API calls needed to successfully develop a basic named pipe client application. When this application successfully connects to a named pipe, it writes the message, &quot;This is a test&quot; to the server.</p>

<p><b>Figure 4-6.</b> <i>Simple named pipe client</i></p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>
// Client.cpp

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

#define PIPE_NAME &quot;\\\\.\\Pipe\\jim&quot;

void main(void)
{
    HANDLE PipeHandle;
    DWORD BytesWritten;

    if (WaitNamedPipe(PIPE_NAME, NMPWAIT_WAIT_FOREVER) == 0)
    {
        printf(&quot;WaitNamedPipe failed with error %d\n&quot;,
            GetLastError());
        return;
    }

    // Create the named pipe file handle
    if ((PipeHandle = CreateFile(PIPE_NAME,
        GENERIC_READ | GENERIC_WRITE, 0,
        (LPSECURITY_ATTRIBUTES) NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        (HANDLE) NULL)) == INVALID_HANDLE_VALUE)
    {
        printf(&quot;CreateFile failed with error %d\n&quot;, GetLastError());
        return;
    }

    if (WriteFile(PipeHandle, &quot;This is a test&quot;, 14, &amp;BytesWritten, 
        NULL) == 0)
    {
        printf(&quot;WriteFile failed with error %d\n&quot;, GetLastError());
        CloseHandle(PipeHandle);
        return;
    }

    printf(&quot;Wrote %d bytes&quot;, BytesWritten);

    CloseHandle(PipeHandle);
}
</pre>
</td></tr></table>
</p>



</BODY>
</HTML>




