<HTML>
<HEAD>
<TITLE>Examples</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch12e.htm" , "ch12g.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="398"><H1>Examples</H1></A>

<p>In this section, we'll take a look at three programming examples of how to use QOS. The first example, which uses TCP, is the most straightforward because it is connection-oriented. The second example uses UDP and does not use any connect calls. The last example uses multicast UCP. In all three examples, we will use <i>WSAEventSelect</i> because it's a bit simpler than <i>WSAAsyncSelect</i>. While we include the entire TCP unicast example, we include only important code snippets for the UDP and multicasting examples because many of the concepts are the same, no matter what type of socket is used. See the accompanying CD for the entire example. All three examples rely on a couple of support routines, <i>PrintQos</i> and <i>FindProtocolInfo</i>, which are defined in the files Printqos.c and Provider.c, respectively. The former routine simply prints out the contents of a QOS structure, while the latter finds a protocol from the provider catalog with the required attributes, such as QOS.</p>

<A NAME="399"><H2>Unicast TCP</H2></A>

<p>The example for unicast TCP QOS is given in Figure 12-3. The code for this example can be found in the Chapter 12 folder as Qostcp.c. The example is a bit long, but not particularly complicated. Most of the code is nothing more than the usual <i>WSAEventSelect</i> code that we introduced in <a href="ch08a.htm">Chapter 8</A>. The only exception is what we do in the case of an <i>FD_QOS</i> event. The main function doesn't do anything out of the ordinary. The arguments are parsed, a socket is created, and either the <i>Server</i> or the <i>Client</i> function is called&#8212;depending on whether the application is called as the server or the client. Let's examine the client connection first.</p>

<p>In all three examples, a command line parameter tells the example when to set QOS: before connection, during connection, after connection, or after the peer requests QOS to set QOS locally. (The command line parameters for Qostp.c are listed in Table 12-8.) If QOS is selected to be set before connection (for the client), bind the socket to a random port and then call <i>SIO_SET_QOS</i> with a sending QOS <i>FLOWSPEC</i>. Note that it isn't really necessary to bind before calling <i>SIO_SET_QOS</i> because the peer's address is not known until a connect call is made, and an RSVP session cannot be initiated until the peer's address is known.</p>

<p>If the user elects to set QOS during connection, the example code passes the QOS structure into the <i>WSAConnect</i> call. This call initiates an RSVP session and connects the client to the specified server. Otherwise, the user specifies that the example should wait for the peer to set QOS, and no QOS structure is passed to <i>WSAConnect</i>. Instead the code takes the sending QOS structure, ORs in the <i>SERVICE_NO_QOS_SIGNALING</i> flag to the <i>ServiceType</i> field in the <i>FLOWSPEC</i> structures, and calls <i>WSAIoctl</i> with the <i>SIO_SET_FLAG</i> ioctl command. This tells the QOS service provider not to invoke Traffic Control but to still look for RSVP messages.</p>

<p>After QOS is set, the events that the client wants to be notified of are registered, including <i>FD_QOS</i>. Notice that QOS must be set on the socket beforehand in order for the application to request receiving <i>FD_QOS</i>. Once this occurs, the client waits in a loop on <i>WSAWaitForMultipleEvents</i>, which unblocks when one of the selected events is signaled. Once an event occurs, the events are enumerated along with any errors in <i>WSAEnumNetworkEvents</i>.</p>

<p>For the most part, Qostcp.c handles the other events, such as <i>FD_READ</i>, <i>FD_WRITE</i>, and <i>FD_CLOSE</i>, in the same way as the <i>WSAEventSelect</i> example code in <a href="ch08a.htm">Chapter 8</A>. The only item of note is in the <i>FD_WRITE</i> event. One of the command line options is to wait until an RSVP PATH message has been received before sending the data. This is especially relevant if the data being transmitted is likely to exceed the best-effort bandwidth available on the network. The <i>AbleToSend</i> function calls <i>SIO_CHK_QOS</i> to determine whether the QOS parameters requested are within the available best-effort limits. If so, it should be OK to start sending data; otherwise, wait for a confirmation to send data.</p>

<p>In our client's case, we want to receive the <i>WSA_QOS_RECEIVERS</i> message to indicate the receipt of a RESV message. This can be indicated upon receipt of an <i>FD_QOS</i> event. At this point, we call the <i>SIO_CHK_QOS</i> command to obtain status information. This <i>WSA_QOS_RECEIVERS</i> flag can be returned in two ways. First the flag can be returned in the <i>iErrorCode</i> field of the <i>WSANETWORKEVENTS</i> structure as the element indexed by <i>FD_QOS_BIT</i>. Second an <i>RSVP_STATUS_INFO</i> structure can be returned in the buffer passed to <i>WSAIoctl</i> using the <i>SIO_GET_QOS</i> ioctl command. This structure too might contain the <i>WSA_QOS_RECEIVERS</i> flag in its <i>StatusCode</i> field. If the wait to send flag has been specified, we check the error field from <i>WSANETWORKEVENTS</i> to see whether an <i>RSVP_STATUS_INFO</i> structure has been returned. If the flag is present, we send data. That's all! The code necessary to support QOS for the client is
straightforward.</p>

<p>The server side of the example is a bit more complicated, but only because it needs to manage zero or more client connections. The listening socket and the client sockets are handled in a single array, <i>sc</i>. Array element 0 is the listening socket, while the rest are possible client connections. The global variable <i>nConns</i> contains the number of current clients. Whenever a client connection finishes, all active sockets are compacted toward the beginning of the socket array. There is also a corresponding array of event handles.</p>

<p>The server first binds the listening socket and sets receiving QOS if the user chooses to set QOS before accepting client connections. Any QOS parameters set on the listening socket are copied to the client connection (unless the server is using <i>AcceptEx</i>). The listening socket registers to receive only <i>FD_ACCEPT</i> events. The rest of the server routine is a loop that waits for events on the array of socket handles. At first the only socket in the array is the listening socket, but as more client connections are established there will be more sockets and their corresponding events. If <i>WSAWaitForMultipleEvents</i> unblocks as a result of an event and indicates the event handle in array element 0, the event is occurring on the listening socket. If so, the code calls <i>WSAEnumNetworkEvents</i> to find out which event is occurring. If the event is occurring on a client socket, the code calls the handler routine <i>HandleClientEvents</i>.</p>

<p>On the listening socket, the event of interest is <i>FD_ACCEPT</i>. When this event happens, <i>WSAAccept</i> is called with a conditional function. Remember that the QOS parameters passed into the conditional function can't be trusted, and if the QOS parameter is non-null on Windows 98, some sort of QOS must be set. Windows 2000 does not have that limitation; QOS can be set at any time. If the user specifies that QOS be set during the accept call, this occurs within the conditional function. Once the client socket is accepted, a corresponding event handle is created and the appropriate events are registered for the socket.</p>

<p>The function <i>HandleClientEvents</i> handles any events occurring on the client sockets. The read and write events are straightforward&#8212;the only exception is whether to wait for the reservation confirmation before sending. If the user specifies to wait for the reservation confirmation to arrive before sending data, the client waits for the <i>WSA_QOS_RECEIVERS</i> message to be returned in an <i>FD_QOS</i> event. If the message returns, the sending of the data doesn't occur until <i>FD_QOS</i> is received. Usually the most significant aspect of this example is the setting of QOS on the socket and the <i>FD_QOS</i> handler.</p>

<p><b>Figure 12-3.</b> <i>Unicast TCP example (Qostcp.c)</i> </p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
// Module: Qostcp.c
//
#include &lt;winsock2.h&gt;
#include &lt;windows.h&gt;
#include &lt;qos.h&gt;
#include &lt;qossp.h&gt;

#include &quot;provider.h&quot;
#include &quot;printqos.h&quot;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define QOS_BUFFER_SZ       16000 // Default buffer size for 
                                  // SIO_GET_QOS
#define DATA_BUFFER_SZ       2048 // Send/Recv buffer size

#define SET_QOS_NONE          0   // No QOS
#define SET_QOS_BEFORE        1   // Set QOS on listening socket
#define SET_QOS_DURING        2   // Set QOS in conditional accept
#define SET_QOS_AFTER         3   // Set QOS after accept
#define SET_QOS_EVENT         4   // Wait for FD_QOS and then set

#define MAX_CONN              10

int  iSetQos,          // When to set QOS?
     nConns;
BOOL bServer,          // Client or server?
     bWaitToSend,      // Wait to send data until RESV
     bConfirmResv;
char szServerAddr[64]; // Server's address
QOS  clientQos,        // QOS client structure
     serverQos;        // QOS server structure
RSVP_RESERVE_INFO  qosreserve; 

//
// Set up some common FLOWSPEC structures
//
const FLOWSPEC flowspec_notraffic = {QOS_NOT_SPECIFIED,
                                     QOS_NOT_SPECIFIED,
                                     QOS_NOT_SPECIFIED,
                                     QOS_NOT_SPECIFIED,
                                     QOS_NOT_SPECIFIED,
                                     SERVICETYPE_NOTRAFFIC,
                                     QOS_NOT_SPECIFIED,
                                     QOS_NOT_SPECIFIED};

const FLOWSPEC flowspec_g711 = {8500,
                                680,
                                17000,
                                QOS_NOT_SPECIFIED,
                                QOS_NOT_SPECIFIED,
                                SERVICETYPE_CONTROLLEDLOAD,
                                340,
                                340};

const FLOWSPEC flowspec_guaranteed = {17000,
                                      1260,
                                      34000,
                                      QOS_NOT_SPECIFIED,
                                      QOS_NOT_SPECIFIED,
                                      SERVICETYPE_GUARANTEED,
                                      340,
                                      340};

//
// Function: SetReserveInfo
//
// Description:
//    For receivers, if a confirmation is requested this must be
//    done with an RSVP_RESERVE_INFO structure
//
void SetQosReserveInfo(QOS *lpqos)
{
    qosreserve.ObjectHdr.ObjectType = RSVP_OBJECT_RESERVE_INFO;
    qosreserve.ObjectHdr.ObjectLength = sizeof(RSVP_RESERVE_INFO);
    qosreserve.Style = RSVP_DEFAULT_STYLE;
    qosreserve.ConfirmRequest = bConfirmResv;
    qosreserve.NumPolicyElement  = 0;
    qosreserve.PolicyElementList = NULL;
    qosreserve.FlowDescList = NULL;

    lpqos-&gt;ProviderSpecific.buf = (char *)&amp;qosreserve;
    lpqos-&gt;ProviderSpecific.len = sizeof(qosreserve);

    return;
}

//
// Function: InitQos
//
// Description:
//    Set up the client and server QOS structures. This is 
//    broken out into a separate function so that you can change 
//    the requested QOS parameters to see how that affects 
//    the application.
//
void InitQos()
{
    clientQos.SendingFlowspec = flowspec_g711;
    clientQos.ReceivingFlowspec =  flowspec_notraffic;
    clientQos.ProviderSpecific.buf = NULL;
    clientQos.ProviderSpecific.len = 0;

    serverQos.SendingFlowspec = flowspec_notraffic;
    serverQos.ReceivingFlowspec = flowspec_g711;
    serverQos.ProviderSpecific.buf = NULL;
    serverQos.ProviderSpecific.len = 0;
    if (bConfirmResv)
        SetQosReserveInfo(&amp;serverQos);
}

//
// Function: usage
//
// Description:
//    Print out usage information
//
void usage(char *progname)
{
    printf(&quot;usage: %s -q:x -s -c:IP\n&quot;, progname);
    printf(&quot;      -q:[b,d,a,e] When to request QOS\n&quot;);
    printf(&quot;          b        Set QOS before bind or connect\n&quot;);
    printf(&quot;          d        Set QOS during accept cond func\n&quot;);
    printf(&quot;          a        Set QOS after session setup\n&quot;);
    printf(&quot;          e        Set QOS only upon receipt of FD_QOS\n&quot;);
    printf(&quot;      -s           Act as server\n&quot;);
    printf(&quot;      -c:Server-IP Act as client\n&quot;);
    printf(&quot;      -w           Wait to send until RESV has arrived\n&quot;);
    printf(&quot;      -r           Confirm reservation request\n&quot;);
    ExitProcess(-1);
}

// 
// Function: ValidateArgs
//
// Description:
//    Parse command line arguments and set global variables to
//    indicate how the application should act
//
void ValidateArgs(int argc, char **argv)
{
    int      i;

    // Initialize globals to a default value
    //
    iSetQos = SET_QOS_NONE;
    bServer = TRUE;
    bWaitToSend = FALSE;
    bConfirmResv = FALSE;

    for(i = 1; i &lt; argc; i++)
    {
        if ((argv[i][0] == '-') || (argv[i][0] == '/'))
        {
            switch (tolower(argv[i][1]))
            {
                case 'q':        // When to set QOS
                    if (tolower(argv[i][3]) == 'b')
                        iSetQos = SET_QOS_BEFORE;
                    else if (tolower(argv[i][3]) == 'd')
                        iSetQos = SET_QOS_DURING;
                    else if (tolower(argv[i][3]) == 'a')
                        iSetQos = SET_QOS_AFTER;
                    else if (tolower(argv[i][3]) == 'e')
                        iSetQos = SET_QOS_EVENT;
                    else
                        usage(argv[0]);
                    break;
                case 's':        // Server
                    printf(&quot;Server flag set!\n&quot;);
                    bServer = TRUE;
                    break;
                case 'c':        // Client
                    printf(&quot;Client flag set!\n&quot;);
                    bServer = FALSE;
                    if (strlen(argv[i]) &gt; 3)
                        strcpy(szServerAddr, &amp;argv[i][3]);
                    else
                        usage(argv[0]);
                    break;
                case 'w':       // Wait to send data until
                                // RESV has arrived
                    bWaitToSend = TRUE;
                    break;
                case 'r':
                    bConfirmResv = TRUE;
                    break;
                default:
                    usage(argv[0]);
                    break;
            }
        }
    }
    return;
}

//
// Function: AbleToSend
//
// Description:
//    Checks to see whether data can be sent on the socket before
//    any RESV messages have arrived. This function checks to see whether  
//    the best-effort level currently available on the network is 
//    sufficient for the QOS levels that were set on the socket.
//
BOOL AbleToSend(SOCKET s)
{
    int     ret;
    DWORD   dwCode = ALLOWED_TO_SEND_DATA,
            dwValue,
            dwBytes;

    ret = WSAIoctl(s, SIO_CHK_QOS, &amp;dwCode, sizeof(dwCode),
                &amp;dwValue, sizeof(dwValue), &amp;dwBytes, NULL, NULL);
    if (ret == SOCKET_ERROR)
    {
        printf(&quot;WSAIoctl() failed: %d\n&quot;, WSAGetLastError());
        return FALSE;
    }
    return (BOOL)dwValue;
}

//
// Function: ChkForQosStatus
//
// Description:
//    Check for the presence of an RSVP_STATUS_INFO object and
//    determine whether the supplied flags are present in that
//    object
//

DWORD ChkForQosStatus(QOS *lpqos, DWORD dwFlags)
{
    QOS_OBJECT_HDR   *objhdr = NULL;
    RSVP_STATUS_INFO *status = NULL;
    char             *bufptr = NULL;
    BOOL              bDone = FALSE;
    DWORD             objcount = 0;

    if (lpqos-&gt;ProviderSpecific.len == 0)
        return 0;

    bufptr = lpqos-&gt;ProviderSpecific.buf;
    objhdr = (QOS_OBJECT_HDR *)bufptr;


    while (!bDone)
    {
        if (objhdr-&gt;ObjectType == RSVP_OBJECT_STATUS_INFO)
        {
            status = (RSVP_STATUS_INFO *)objhdr;
            if (status-&gt;StatusCode &amp; dwFlags)
                return 1;
        }
        else if (objhdr-&gt;ObjectType == QOS_OBJECT_END_OF_LIST)
            bDone = TRUE;

        bufptr += objhdr-&gt;ObjectLength;
        objcount += objhdr-&gt;ObjectLength;
        objhdr = (QOS_OBJECT_HDR *)bufptr;

        if (objcount &gt;= lpqos-&gt;ProviderSpecific.len)
            bDone = TRUE;
    }
    return 0;
}

//
// Function: HandleClientEvents
//
// Description:
//    This function is called by the Server function to handle
//    events that occurred on client SOCKET handles. The socket
//    array is passed in along with the event array and the index
//    of the client who received the signal. Within the function,
//    the event is decoded and the appropriate action occurs.
//
void HandleClientEvents(SOCKET socks[], HANDLE events[], int index)
{
    WSANETWORKEVENTS  ne;
    char              databuf[4096];
    WSABUF            wbuf;
    DWORD             dwBytesRecv,
                      dwFlags;
    int               ret,
                      i;

    // Enumerate the network events that occurred
    //
    ret = WSAEnumNetworkEvents(socks[index], events[index], &amp;ne);
    if (ret == SOCKET_ERROR)
    {
        printf(&quot;WSAEnumNetworkEvents() failed: %d\n&quot;, 
            WSAGetLastError());
        return;
    }
    // Data to be read
    //
    if ((ne.lNetworkEvents &amp; FD_READ) == FD_READ)
    {
        wbuf.buf = databuf;
        wbuf.len = 4096;

        if (ne.iErrorCode[FD_READ_BIT])
            printf(&quot;FD_READ error: %d\n&quot;, 
                ne.iErrorCode[FD_READ_BIT]);
        else
            printf(&quot;FD_READ\n&quot;);

        dwFlags = 0;
        ret = WSARecv(socks[index], &amp;wbuf, 1, &amp;dwBytesRecv, 
            &amp;dwFlags, NULL, NULL);
        if (ret == SOCKET_ERROR)
        {
            printf(&quot;WSARecv() failed: %d\n&quot;, WSAGetLastError());
            return;
        }
        wbuf.len = dwBytesRecv;

        printf(&quot;Read: %d bytes\n&quot;, dwBytesRecv);
    }
    // Able to write data; nothing to do here
    //
    if ((ne.lNetworkEvents &amp; FD_WRITE) == FD_WRITE)
    {
        if (ne.iErrorCode[FD_WRITE_BIT])

            printf(&quot;FD_WRITE error: %d\n&quot;, 
                ne.iErrorCode[FD_WRITE_BIT]);
        else
            printf(&quot;FD_WRITE\n&quot;);
    }
    // The client closed the connection. Close the socket on our 
    // end and clean up the data structures.
    //
    if ((ne.lNetworkEvents &amp; FD_CLOSE) == FD_CLOSE)
    {
        if (ne.iErrorCode[FD_CLOSE_BIT])
            printf(&quot;FD_CLOSE error: %d\n&quot;, 
                ne.iErrorCode[FD_CLOSE_BIT]);
        else
            printf(&quot;FD_CLOSE ...\n&quot;);
        closesocket(socks[index]);
        WSACloseEvent(events[index]);

        socks[index] = INVALID_SOCKET;
        //
        // Remote the client socket entry from the array and 
        // compact the remaining clients to the beginning of the 
        // array
        //
        for(i = index; i &lt; MAX_CONN - 1; i++)
            socks[i] = socks[i + 1];
        nConns--;
    }
    // Received an FD_QOS event. This could mean several things.
    //
    if ((ne.lNetworkEvents &amp; FD_QOS) == FD_QOS)
    {
        char        buf[QOS_BUFFER_SZ];
        QOS        *lpqos = NULL;
        DWORD       dwBytes;

        if (ne.iErrorCode[FD_QOS_BIT])
            printf(&quot;FD_QOS error: %d\n&quot;, 
                ne.iErrorCode[FD_QOS_BIT]);
        else
            printf(&quot;FD_QOS\n&quot;);

        lpqos = (QOS *)buf;
        lpqos-&gt;ProviderSpecific.buf = &amp;buf[sizeof(QOS)];
        lpqos-&gt;ProviderSpecific.len = sizeof(buf) - sizeof(QOS);

        ret = WSAIoctl(socks[index], SIO_GET_QOS, NULL, 0,
                buf, QOS_BUFFER_SZ, &amp;dwBytes, NULL, NULL);
        if (ret == SOCKET_ERROR)
        {
            printf(&quot;WSAIoctl(SIO_GET_QOS) failed: %d\n&quot;, 
                WSAGetLastError());
            return;
        }
        PrintQos(lpqos);
        //
        // See whether we're set for receiving FD_QOS events only. 
        // If so, we need to invoke QOS on the connection 
        // now; otherwise, client will never receive a RESV message.
        //
        if (iSetQos == SET_QOS_EVENT)
        {
            lpqos-&gt;ReceivingFlowspec.ServiceType = 
                serverQos.ReceivingFlowspec.ServiceType;

            ret = WSAIoctl(socks[index], SIO_SET_QOS, lpqos, 
                dwBytes, NULL, 0, &amp;dwBytes, NULL, NULL);
            if (ret == SOCKET_ERROR)
            {
                printf(&quot;WSAIoctl(SIO_SET_QOS) failed: %d\n&quot;, 
                    WSAGetLastError());
                return;
            }
            //
            // Change iSetQos so we don't set QOS again if we 
            // receive another FD_QOS event
            //
            iSetQos = SET_QOS_BEFORE;
        }
    }
    return;
}

//
// Function: SrvCondAccept
//
// Description:
//    This is the conditional function for WSAAccept. The QOS service 
//    provider is limited in that the QOS values passed into here are
//    unreliable, so the option SET_QOS_DURING is useless unless we call 
//    SIO_SET_QOS with our own values (as opposed to the values the client
//    is requesting since those values are supposed to be returned in
//    lpSQOS). Note that on Windows 98, if lpSQOS is not NULL you have to
//    set some QOS values (with SIO_SET_QOS) in the conditional 
//    function; otherwise, WSAAccept will fail.
//

int CALLBACK SrvCondAccept(LPWSABUF lpCallerId, 
    LPWSABUF lpCallerdata, LPQOS lpSQOS, LPQOS lpGQOS, 
    LPWSABUF lpCalleeId, LPWSABUF lpCalleeData, GROUP *g, 
    DWORD dwCallbackData)
{
    DWORD       dwBytes = 0;
    SOCKET      s = (SOCKET)dwCallbackData;
    SOCKADDR_IN client;
    int         ret;

    if (nConns == MAX_CONN)
        return CF_REJECT;

    memcpy(&amp;client, lpCallerId-&gt;buf, lpCallerId-&gt;len);
    printf(&quot;Client request: %s\n&quot;, inet_ntoa(client.sin_addr));

    if (iSetQos == SET_QOS_EVENT)
    {
        printf(&quot;Setting for event!\n&quot;);
        serverQos.SendingFlowspec.ServiceType |= 
            SERVICE_NO_QOS_SIGNALING;
        serverQos.ReceivingFlowspec.ServiceType |= 
            SERVICE_NO_QOS_SIGNALING;

        ret = WSAIoctl(s, SIO_SET_QOS, &amp;serverQos, 
            sizeof(serverQos), NULL, 0, &amp;dwBytes, NULL, NULL);
        if (ret == SOCKET_ERROR)
        {
            printf(&quot;WSAIoctl() failed: %d\n&quot;, 
                WSAGetLastError());
            return CF_REJECT;
        }
    }
    return CF_ACCEPT;
}

//
// Function: Server
//
// Description:
//    This server routine handles incoming client connections.
//    First it sets up the listening socket, sets QOS when
//    appropriate, and waits for incoming clients and events.
//
void Server(SOCKET s)
{
    SOCKET        sc[MAX_CONN + 1];
    WSAEVENT      hAllEvents[MAX_CONN+1];
    SOCKADDR_IN   local,
                  client;
    int           clientsz,
                  ret,
                  i;
    DWORD         dwBytesRet;
    WSANETWORKEVENTS ne;

    // Initialize the arrays to invalid values
    //
    for(i = 0; i &lt; MAX_CONN+1; i++)
    {
        hAllEvents[i] = WSA_INVALID_EVENT;
        sc[i] = INVALID_SOCKET;
    }
    // Array index 0 will be our listening socket
    //
    hAllEvents[0] = WSACreateEvent();
    sc[0]         = s;
    nConns        = 0;

    local.sin_family = AF_INET;
    local.sin_port = htons(5150);
    local.sin_addr.s_addr = htonl(INADDR_ANY);

    if (bind(s, (SOCKADDR *)&amp;local, sizeof(local)) == SOCKET_ERROR)
    {
        printf(&quot;bind() failed: %d\n&quot;, WSAGetLastError());
        return;
    }
    listen(s, 7);

    if (iSetQos == SET_QOS_BEFORE)
    {
        ret = WSAIoctl(sc[0], SIO_SET_QOS, &amp;serverQos, 
            sizeof(serverQos), NULL, 0, &amp;dwBytesRet, NULL, NULL);
        if (ret == SOCKET_ERROR)
        {
            printf(&quot;WSAIoctl(SIO_SET_QOS) failed: %d\n&quot;, 
                WSAGetLastError());
            return;
        }
        printf(&quot;Set QOS on listening socket:\n&quot;);
        PrintQos(&amp;serverQos);
    }


    if (WSAEventSelect(sc[0], hAllEvents[0], FD_ACCEPT) == 
        SOCKET_ERROR)
    {
        printf(&quot;WSAEventSelect() failed: %d\n&quot;, WSAGetLastError());
        return;
    }

    while (1)
    {
        ret = WSAWaitForMultipleEvents(nConns+1, hAllEvents, FALSE,
            WSA_INFINITE, FALSE); 
        if (ret == WSA_WAIT_FAILED)
        {
            printf(&quot;WSAWaitForMultipleObject() failed: %d\n&quot;,
                WSAGetLastError());
            return;
        }
        if ((i = ret - WSA_WAIT_EVENT_0) &gt; 0)  // Client network event
            HandleClientEvents(sc, hAllEvents, i);
        else
        {
            ret = WSAEnumNetworkEvents(sc[0], hAllEvents[0], 
                &amp;ne);
            if (ret == SOCKET_ERROR)
            {
                printf(&quot;WSAEnumNetworkevents() failed: %d\n&quot;, 
                    WSAGetLastError());
                return;
            }
            if ((ne.lNetworkEvents &amp; FD_ACCEPT) == FD_ACCEPT)
            {
                if (ne.iErrorCode[FD_ACCEPT_BIT])
                    printf(&quot;FD_ACCEPT error: %d\n&quot;, 
                        ne.iErrorCode[FD_ACCEPT_BIT]);
                else
                    printf(&quot;FD_ACCEPT\n&quot;);

                clientsz = sizeof(client);
                sc[++nConns] = WSAAccept(s, (SOCKADDR *)&amp;client, 
                    &amp;clientsz, SrvCondAccept, sc[nConns]);
                if (sc[nConns] == SOCKET_ERROR)
                {
                    printf(&quot;WSAAccept() failed: %d\n&quot;, 
                        WSAGetLastError());
                    nConns--;
                    return;
                }
                hAllEvents[nConns] = WSACreateEvent();

                Sleep(10000);
                if (iSetQos == SET_QOS_AFTER)
                {
                    ret = WSAIoctl(sc[nConns], SIO_SET_QOS, 
                        &amp;serverQos, sizeof(serverQos), NULL, 0,
                        &amp;dwBytesRet, NULL, NULL);
                    if (ret == SOCKET_ERROR)
                    {
                        printf(&quot;WSAIoctl() failed: %d\n&quot;, 
                            WSAGetLastError());
                        return;
                    }
                }
                ret = WSAEventSelect(sc[nConns],
                    hAllEvents[nConns], FD_READ | FD_WRITE | 
                    FD_CLOSE | FD_QOS);
                if (ret == SOCKET_ERROR)
                {
                    printf(&quot;WSAEventSelect() failed: %d\n&quot;, 
                        WSAGetLastError());
                    return;
                }
            }
            if (ne.lNetworkEvents &amp; FD_CLOSE)
                printf(&quot;FD_CLOSEn&quot;);
            if (ne.lNetworkEvents &amp; FD_READ)
                printf(&quot;FD_READn&quot;);
            if (ne.lNetworkEvents &amp; FD_WRITE)
                printf(&quot;FD_WRITEn&quot;);
            if (ne.lNetworkEvents &amp; FD_QOS)
                printf(&quot;FD_QOS\n&quot;);
        }
    }
    return;
}

//
// Function: Client
//
// Description:
//    The client routine initiates the connection, sets QOS when
//    appropriate, and handles incoming events.
//
void Client(SOCKET s)
{
    SOCKADDR_IN  server,
                 local;
    WSABUF       wbuf;
    DWORD        dwBytes,
                 dwBytesSent,
                 dwBytesRecv,
                 dwFlags;
    HANDLE       hEvent;
    int          ret, i;
    char         databuf[DATA_BUFFER_SZ];
    QOS         *lpqos;
    WSANETWORKEVENTS ne;

    hEvent = WSACreateEvent();
    if (hEvent == NULL)
    {
        printf(&quot;WSACreateEvent() failed: %d\n&quot;, WSAGetLastError());
        return;
    }

    lpqos = NULL;
    if (iSetQos == SET_QOS_BEFORE)
    {
        local.sin_family = AF_INET;
        local.sin_port = htons(0);
        local.sin_addr.s_addr = htonl(INADDR_ANY);
        
        if (bind(s, (SOCKADDR *)&amp;local, sizeof(local)) == 
            SOCKET_ERROR) 
        {
            printf(&quot;bind() failed: %d\n&quot;, WSAGetLastError());
            return;
        }
        ret = WSAIoctl(s, SIO_SET_QOS, &amp;clientQos, 
            sizeof(clientQos), NULL, 0, &amp;dwBytes, NULL, NULL);
        if (ret == SOCKET_ERROR)
        {
            printf(&quot;WSAIoctl(SIO_SET_QOS) failed: %d\n&quot;,
                WSAGetLastError());
            return;
        }
    }
    else if (iSetQos == SET_QOS_DURING)
        lpqos = &amp;clientQos;
    else if (iSetQos == SET_QOS_EVENT)
    {
        clientQos.SendingFlowspec.ServiceType |= 
            SERVICE_NO_QOS_SIGNALING;
        clientQos.ReceivingFlowspec.ServiceType |= 
            SERVICE_NO_QOS_SIGNALING;

        ret = WSAIoctl(s, SIO_SET_QOS, &amp;clientQos, 
            sizeof(clientQos), NULL, 0, &amp;dwBytes, NULL, NULL);
        if (ret == SOCKET_ERROR)
        {
            printf(&quot;WSAIoctl() failed: %d\n&quot;, WSAGetLastError());
            return;
        }
    }

    server.sin_family = AF_INET;
    server.sin_port = htons(5150);
    server.sin_addr.s_addr = inet_addr(szServerAddr);

    printf(&quot;Connecting to: %s\n&quot;, inet_ntoa(server.sin_addr));

    ret = WSAConnect(s, (SOCKADDR *)&amp;server, sizeof(server),
        NULL, NULL, lpqos, NULL);
    if (ret == SOCKET_ERROR)
    {
        printf(&quot;WSAConnect() failed: %d\n&quot;, WSAGetLastError());
        return;
    }


    ret = WSAEventSelect(s, hEvent, FD_READ | FD_WRITE | 
        FD_CLOSE | FD_QOS);
    if (ret == SOCKET_ERROR)
    {
        printf(&quot;WSAEventSelect() failed: %d\n&quot;, WSAGetLastError());
        return;
    }

    wbuf.buf = databuf;
    wbuf.len = DATA_BUFFER_SZ;

    memset(databuf, '#', DATA_BUFFER_SZ);
    databuf[DATA_BUFFER_SZ-1] = 0;
 
    while (1)
    {
        ret = WSAWaitForMultipleEvents(1, &amp;hEvent, FALSE, 
            WSA_INFINITE, FALSE);
        if (ret == WSA_WAIT_FAILED)
        {
            printf(&quot;WSAWaitForMultipleEvents() failed: %d\n&quot;, 

                WSAGetLastError());
            return;
        }

        ret = WSAEnumNetworkEvents(s, hEvent, &amp;ne);
        if (ret == SOCKET_ERROR)
        {
            printf(&quot;WSAEnumNetworkEvents() failed: %d\n&quot;, 
                WSAGetLastError());
            return;
        }
        if (ne.lNetworkEvents &amp; FD_READ)
        {
            if (ne.iErrorCode[FD_READ_BIT])
                printf(&quot;FD_READ error: %d\n&quot;, 
                    ne.iErrorCode[FD_READ_BIT]);
            else
                printf(&quot;FD_READ\n&quot;);

            wbuf.len = 4096;
            dwFlags = 0;
            ret = WSARecv(s, &amp;wbuf, 1, &amp;dwBytesRecv, &amp;dwFlags, 
                NULL, NULL);
            if (ret == SOCKET_ERROR)
            {
                printf(&quot;WSARecv() failed: %d\n&quot;, 
                    WSAGetLastError());
                return;
            }
            printf(&quot;Read: %d bytes\n&quot;, dwBytesRecv);

            wbuf.len = dwBytesRecv;
            ret = WSASend(s, &amp;wbuf, 1, &amp;dwBytesSent, 0, NULL, 
                NULL);
            if (ret == SOCKET_ERROR)
            {
                printf(&quot;WSASend() failed: %d\n&quot;, 
                    WSAGetLastError());
                return;
            }
            printf(&quot;Sent: %d bytes\n&quot;, dwBytesSent);
        }
        if (ne.lNetworkEvents &amp; FD_WRITE)
        {
            if (ne.iErrorCode[FD_WRITE_BIT])
                printf(&quot;FD_WRITE error: %d\n&quot;, 
                    ne.iErrorCode[FD_WRITE_BIT]);
            else
                printf(&quot;FD_WRITE\n&quot;);

            if (!bWaitToSend)
            {
                wbuf.buf = databuf;
                wbuf.len = DATA_BUFFER_SZ;
                //
                // If the network can't support the bandwidth,
                // don't send
                //
                if (!AbleToSend(s))
                {
                    printf(&quot;Network is unable to provide &quot;
                        &quot;sufficient best-effort bandwidth\n&quot;);
                    printf(&quot;before the reservation &quot;
                        &quot;request is approved\n&quot;);
                }
                
                for(i = 0; i &lt; 1; i++)
                {
                    ret = WSASend(s, &amp;wbuf, 1, &amp;dwBytesSent, 0, 
                        NULL, NULL);
                    if (ret == SOCKET_ERROR)
                    {
                        printf(&quot;WSASend() failed: %d\n&quot;, 
                            WSAGetLastError());
                        return;
                    }
                    printf(&quot;Sent: %d bytes\n&quot;, dwBytesSent);
                }
            }
        }
        if (ne.lNetworkEvents &amp; FD_CLOSE)
        {
            if (ne.iErrorCode[FD_CLOSE_BIT])
                printf(&quot;FD_CLOSE error: %d\n&quot;, 
                    ne.iErrorCode[FD_CLOSE_BIT]);
            else
                printf(&quot;FD_CLOSE ...\n&quot;);
            closesocket(s);
            WSACloseEvent(hEvent);
            return;
        }
        if (ne.lNetworkEvents &amp; FD_QOS)
        {
            char        buf[QOS_BUFFER_SZ];
            QOS        *lpqos = NULL;
            DWORD       dwBytes;
            BOOL        bRecvRESV = FALSE;

            if (ne.iErrorCode[FD_QOS_BIT])
            {
                printf(&quot;FD_QOS error: %d\n&quot;, 
                    ne.iErrorCode[FD_QOS_BIT]);
                if (ne.iErrorCode[FD_QOS_BIT] == WSA_QOS_RECEIVERS)
                    bRecvRESV = TRUE;
            }
            else
                printf(&quot;FD_QOS\n&quot;);

            lpqos = (QOS *)buf;
            ret = WSAIoctl(s, SIO_GET_QOS, NULL, 0,
                    buf, QOS_BUFFER_SZ, &amp;dwBytes, NULL, NULL);
            if (ret == SOCKET_ERROR)
            {
                printf(&quot;WSAIoctl(SIO_GET_QOS) failed: %d\n&quot;, 
                    WSAGetLastError());
                return;
            }
            PrintQos(lpqos);
            //
            // Check to see whether a status object is returned 
            // in the QOS structure that might also contain the
            // WSA_QOS_RECEIVERS flag
            //
            if (ChkForQosStatus(lpqos, WSA_QOS_RECEIVERS))
                bRecvRESV = TRUE;

            if (iSetQos == SET_QOS_EVENT)
            {
                lpqos-&gt;SendingFlowspec.ServiceType = 
                    clientQos.SendingFlowspec.ServiceType;
                ret = WSAIoctl(s, SIO_SET_QOS, lpqos, dwBytes,
                        NULL, 0, &amp;dwBytes, NULL, NULL);
                if (ret == SOCKET_ERROR)
                {
                    printf(&quot;WSAIoctl(SIO_SET_QOS) failed: %d\n&quot;, 
                        WSAGetLastError());
                    return;
                }
                //
                // Change iSetQos so that we don't set QOS again if we 
                // receive another FD_QOS event
                //
                iSetQos = SET_QOS_BEFORE;
            }

            if (bWaitToSend &amp;&amp; bRecvRESV)
            {
                wbuf.buf = databuf;
                wbuf.len = DATA_BUFFER_SZ;

                for(i = 0; i &lt; 1; i++)
                {
                    ret = WSASend(s, &amp;wbuf, 1, &amp;dwBytesSent, 0, 
                        NULL, NULL);
                    if (ret == SOCKET_ERROR)
                    {
                        printf(&quot;WSASend() failed: %d\n&quot;, 
                            WSAGetLastError());
                        return;
                    }
                    printf(&quot;Sent: %d bytes\n&quot;, dwBytesSent);
                }
            }
        }
    }
    return;
}

//
// Function: main
//
// Description:
//    Initialize Winsock, parse command line arguments, create
//    a QOS TCP socket, and call the appropriate handler 
//    routine depending on the arguments supplied
//
int main(int argc, char **argv)
{
    WSADATA           wsd;
    WSAPROTOCOL_INFO *pinfo = NULL;
    SOCKET            s;

    // Parse the command line
    ValidateArgs(argc, argv);
    if (WSAStartup(MAKEWORD(2,2), &amp;wsd) != 0)
    {
        printf(&quot;Unable to load Winsock: %d\n&quot;, GetLastError());
        return -1;
    }
    pinfo = FindProtocolInfo(AF_INET, SOCK_STREAM, IPPROTO_TCP,
        XP1_QOS_SUPPORTED);
    if (!pinfo)
    {
        printf(&quot;unable to find suitable provider!\n&quot;);
        return -1;
    }
    printf(&quot;Provider returned: %s\n&quot;, pinfo-&gt;szProtocol); 
   
    s = WSASocket(FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO, 
        FROM_PROTOCOL_INFO, pinfo, 0, WSA_FLAG_OVERLAPPED);
    if (s == INVALID_SOCKET)
    {
        printf(&quot;WSASocket() failed: %d\n&quot;, WSAGetLastError());
        return -1;
    }
    InitQos();

    if (bServer)
        Server(s);
    else
        Client(s);

    closesocket(s);
    WSACleanup();
    return 0;
}
</pre>
</td></tr></table>
</p>

<p><b>Table 12-8.</b> <i>Qostcp.c command line parameters</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th><i>Parameter</i>  </th>
<th><i>Meaning</i>  </th></tr>
<tr>
<td valign="top">-q:[b,d,a,e]  </td>
<td valign="top">Set QOS either before (b), during (d), or after (a), or wait for an <i>FD_QOS</i> event (e) before setting  </td></tr>
<tr>
<td valign="top">-s  </td>
<td valign="top">Act as the server  </td></tr>
<tr>
<td valign="top">-c:Server-IP  </td>
<td valign="top">Act as the client, and connect to the server at the given IP address  </td></tr>
<tr>
<td valign="top">-w   </td>
<td valign="top">Wait to send data until a RESV message has been received  </td></tr>
<tr>
<td valign="top">-r   </td>
<td valign="top">Set the option to receive notification once the reservation has been confirmed  </td></tr>
</table></p>


<A NAME="400"><H2>Unicast UDP</H2></A>

<p>Using unicast UDP offers a few more possibilities than TCP does. The UDP example on the accompanying CD is named <i>Qosudp.c.</i> It incorporates both the sender and the receiver. For the sender, there are two methods for telling the QOS service provider where data is to be sent. Remember that the peer's address is required to initiate an RSVP session. This can be accomplished by calling either <i>WSAConnect</i> or <i>SIO_SET_QOS</i> with the <i>QOS_DESTADDR</i> object. The unicast UDP example also takes a parameter on when QOS is to be set. If the user specifies that QOS is to be set before binding or connecting, the <i>SIO_SET_QOS</i> ioctl command with a <i>QOS_DESTADDR</i> object is used. If the user specifies that QOS is to be set during <i>WSAAccept</i>'s conditional function, QOS parameters are specified in the <i>WSAConnect</i> call. If the user specifies that QOS is to be set after session setup, <i>WSAConnect</i> is called without QOS and <i>SIO_SET_QOS</i> is invoked later without the
<i>QOS_DESTADDR</i> object. Finally, if the user specifies that QOS is to be set only upon receipt of a <i>FD_QOS</i> event notification, <i>SIO_SET_QOS</i> is called with a <i>QOS_DESTADDR</i> object, but the flag <i>SERVICE_QOS_NO_SIGNALING</i> is ORed in with the <i>ServiceType</i> <i>FLOWSPEC</i> field.</p>

<p>The receiving side has considerably fewer options. The various flags for when to set QOS don't really apply here. QOS can be set before data is to be received, or the receiver can wait for an <i>FD_QOS</i> event to occur. This is because UDP doesn't receive any connection request&#8212;there is no setting QOS during the accept function or after session setup. The receiver also has the option of specifying a different filter style, such as fixed filter or shared explicit. If a different filter is specified, an IP address must be given with the -r:IP option. The function <i>SetQosReceivers</i> fills in an <i>RSVP_RESERVE_INFO</i> structure with an <i>RSVP_FILTERSPEC</i> structure, which defines the sender's IP address. One particularly important aspect of setting the filter is that the port number of the sender must be specified. This means that the receiver must know each sender's IP address and the port number it is bound to on the sender's side.</p>

<p>Note that the receiver can also use <i>WSAConnect</i> to associate the sender's IP address with the socket. However, because the UDP receiver can specify various filter styles as well as a number of senders, <i>WSAConnect</i> cannot be used. Remember that if <i>WSAConnect</i> is used to associate the endpoint's IP address, send and receive operations can occur only with that peer and have QOS associated with it.</p>

<p>If you compare the unicast UDP example to the TCP example, you'll find they're quite similar. The only exception is the different way QOS can be set on the socket. UDP applications require that the sender specify the recipient's IP address to invoke RSVP, and QOS provides two methods for this. TCP applications by their nature do this by default in the connect call. The event loop for both applications is almost the same. Don't forget the one major &quot;gotcha&quot; for UDP applications: the socket must be bound locally before any QOS (sending or receiving) can be set on it with <i>SIO_SET_QOS</i> when <i>WSAConnect</i> is not used. Binding to <i>INADDR_ANY</i> and port 0 is perfectly legal, as well as using a specific IP and port. Using <i>WSAConnect</i> performs an implicit bind, so if QOS is set at that point, you do not have to explicitly bind beforehand.</p>

<A NAME="401"><H2>Multicast UDP</H2></A>

<p>The last example provided is multicast QOS, which can be found on the CD as Qosmcast.c. The central function here is <i>WSAJoinLeaf</i>, which an application must call to join a multicast group, as we saw in the <a href="ch11a.htm">previous chapter</a>. When an application joins the group, it can also pass QOS parameters. The multicast example takes the same parameters as the unicast UDP example. You can select the point at which QOS can be set on the socket. If you choose to set QOS during the accept conditional function, QOS is passed into the <i>WSAJoinLeaf</i> call. Otherwise, set QOS by calling <i>WSAIoctl</i> with <i>SIO_SET_QOS</i>.</p>

<p>One of the parameters for receivers allows users to set the filter style to either fixed filter or shared explicit. Remember that multicast UDP uses wildcard style by default. Specifying a different filter type applies only to receivers, and if either of these two filter types is desired, each sender's address is specified in an -r:SenderIP command line option. Users can specify the filters via the -f option with se for shared explicit and with ff for fixed filter.</p>

<p>For both sender and receiver, the -m option is used to specify the multicast group to join. Note that this option can be specified multiple times to join as many groups as you want. The -s option indicates that the program should act as a sender. The w option tells the sender to wait until there is a <i>WSA_QOS_RECEIVERS</i> notification before sending any data. Finally, the -q option identifies when to set QOS. No matter when QOS is specified to be set, the socket is bound locally to port 5150. In actuality, any port can be chosen or 0 can be specified so that the port is chosen for you; however, if the receiver is to set either the fixed or the shared explicit filter, it must also provide the IP and port of the sender. We use a fixed port for the sake of simplicity. Unlike in unicast UDP, the receiver is not <i>required</i> to bind the port locally to set QOS. The reason for this is that <i>WSAJoinLeaf</i> implicitly binds the socket if it is not already bound. The other question you might be asking is
whether the socket option commands <i>IP_ ADD_MEMBERSHIP</i> and <i>IP_ DROP_MEMBERSHIP</i> can be used instead of <i>WSAJoinLeaf</i>. The answer is no. If these commands are used, the QOS parameters requested will not be applied to the socket.</p>

<p>We won't go into the exact details of what happens when QOS is chosen to be set because it is quite similar to the unicast UDP example. By now, you should be familiar with how the RSVP session is initiated and what is needed to generate the PATH and RESV messages.</p>

</BODY>
</HTML>




