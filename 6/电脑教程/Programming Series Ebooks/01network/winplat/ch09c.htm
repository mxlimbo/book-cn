<HTML>
<HEAD>
<TITLE>IOCTLSOCKET and WSAIOCTL</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch09b.htm" , "ch09d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="271"><h1><i>IOCTLSOCKET</i> and <i>WSAIOCTL</i></h1></A>
<p>The socket <i>ioctl</i> functions are used to control the behavior of I/O upon the socket, as well as obtain information about I/O pending on that socket. The first function, <i>ioctlsocket</i>, originated in the Winsock 1 specification and is declared as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int ioctlsocket (
    SOCKET s, 
    long cmd, 
    u_long FAR *argp
);
</pre>
</td></tr></table>
</p>

<p>The parameter <i>s</i> is the socket descriptor to act upon, while <i>cmd</i> is a predefined flag for the I/O control command to execute. The last parameter, <i>argp</i>, is a pointer to a variable specific to the given command. When each command is described, the type of the required variable is given. Winsock 2 introduced a new <i>ioctl</i> function that adds quite a few new options. First, it breaks the single <i>argp</i> parameter into a set of input parameters for values passed into the function and a set of output parameters used to return data from the call. Additionally, the function call can use overlapped I/O. This function is <i>WSAIoctl</i>, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSAIoctl(
    SOCKET s, 
    DWORD dwIoControlCode, 
    LPVOID lpvInBuffer, 
    DWORD cbInBuffer, 
    LPVOID lpvOutBuffer, 
    DWORD cbOutBuffer, 
    LPDWORD lpcbBytesReturned, 
    LPWSAOVERLAPPED lpOverlapped, 
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine 
);
</pre>
</td></tr></table>
</p>

<p>The first two parameters are the same as those in <i>ioctlsocket</i>. The second two parameters, <i>lpvInBuffer</i> and <i>cbInBuffer</i>, describe the input parameters. The <i>lpvInBuffer</i> parameter is a pointer to the value passed in, while <i>cbInBuffer</i> is the size of that data in bytes. Likewise, <i>lpvOutBuffer</i> and <i>cbOutBuffer</i> are used for any data returned from the call. The <i>lpvOutBuffer</i> parameter points to a data buffer in which any information returned is placed. The <i>cbOutBuffer</i> parameter is the size in bytes of the buffer passed in as <i>lpvOutBuffer</i>. Note that some calls might use only input or output parameters, while others will use both. The seventh parameter, <i>lpcbBytesReturned</i>, is the number of bytes actually returned. The last two parameters, <i>lpOverlapped</i> and <i>lpCompletionRoutine</i>, are used when calling this function with overlapped I/O. Consult <a href="ch08a.htm">Chapter 8</A> for detailed information on using overlapped I/O.</p>

<A NAME="272"><H2>Standard Ioctl Commands</H2></A>

<p>These three ioctl commands are the most common and are carryovers from the Unix world. They are available on all Win32 platforms. Also, these three commands can be called using either <i>ioctlsocket</i> or <i>WSAIoctl</i>.</p>

<A NAME="273"><h3><i>FIONBIO</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>
		
		<tr>
			<td valign="top"><i>ioctlsocket/WSAIoctl</i></td>
			<td valign="top"><i>unsigned</i></td>
			<td valign="top">None</td>
			<td valign="top">1+</td>
			<td valign="top">Puts socket in nonblocking mode</td>
		</tr>

	</table>
</p>

<p>This command enables or disables nonblocking mode on socket <i>s</i>. By default, all sockets are blocking sockets upon creation. When you call <i>ioctlsocket</i> with the <i>FIONBIO</i> ioctl command, set <i>argp</i> to pass a pointer to an unsigned long integer whose value is nonzero if nonblocking mode is to be enabled. The value 0 places the socket in blocking mode. If you use <i>WSAIoctl</i> instead, simply pass the unsigned long integer in as the <i>lpvInBuffer</i> parameter.</p>

<p>Calling the <i>WSAAsyncSelect</i> or <i>WSAEventSelect</i> function automatically sets a socket to nonblocking mode. If either of these functions has been called, any attempt to set the socket back to blocking mode fails with <i>WSAEINVAL</i>. To set the socket back to blocking mode, an application must first disable <i>WSAAsyncSelect</i> by calling <i>WSAAsyncSelect</i> with the <i>lEvent</i> parameter equal to 0, or disable <i>WSAEventSelect</i> by calling <i>WSAEventSelect</i> with the <i>lNetworkEvents</i> parameter equal to 0.</p>

<A NAME="274"><h3><i>FIONREAD</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top">Both</td>
			<td valign="top">None</td>
			<td valign="top"><i>unsigned long</i></td>
			<td valign="top">1+</td>
			<td valign="top">Returns the amount of data to be read on the socket</td>
		</tr>

	</table>
</p>

<p>This command determines the amount of data that can be read atomically from the socket. For <i>ioctlsocket</i>, the <i>argp</i> value returns with an unsigned integer that will contain the number of bytes to be read. When using <i>WSAIoctl</i>, the unsigned integer is returned in <i>lpvOutBuffer</i>. If socket <i>s</i> is stream-oriented (<i>SOCK_STREAM</i>), <i>FIONREAD</i> returns the total amount of data that can be read in a single receive call. Remember that using this or any other message-peeking mechanism is not always guaranteed to return the correct amount. When this ioctl command is used on a datagram socket (<i>SOCK_DGRAM</i>), the return value is the size of the first message queued on the socket.</p>

<A NAME="275"><h3><i>SIOCATMARK</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top">Both</td>
			<td valign="top">None</td>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">1+</td>
			<td valign="top">Determines whether out-of-band data has been read</td>
		</tr>

	</table>
</p>

<p>When a socket has been configured to receive out-of-band (OOB) data and has been set to receive this OOB data in line (by setting the <i>SO_OOBINLINE</i> socket option), this ioctl command returns a Boolean value indicating <i>TRUE</i> if the OOB data is to be read next. Otherwise, <i>FALSE</i> is returned and the next receive operation returns all or some of the data that precedes the OOB data. For <i>ioctlsocket</i>, <i>argp</i> returns with a pointer to a Boolean variable, while for <i>WSAIoctl</i>, the pointer to the Boolean variable returns in <i>lpvOutBuffer</i>. Remember that a receive call will never mix OOB data and normal data in the same call. Refer back to <a href="ch07a.htm">Chapter 7</A> for more information on OOB data.</p>

<A NAME="276"><H2>Other Ioctl Commands</H2></A>

<p>These ioctl commands are specific to Winsock 2 except for those dealing with SSL, which are available only on Windows CE. If you examine the Winsock 2 headers, you might actually see other ioctl commands declared; however, the ioctls listed in this section are the only ones that are meaningful or available to a user's application. Additionally, as you will see, not all ioctl commands work on all (or any) Win32 platforms, but of course this could change with operating system updates. For Winsock 2, a majority of these commands are defined in Winsock2.h. Some of the newer, Windows 2000-specific, ioctls are defined in Mstcpip.h.</p>

<A NAME="277"><h3><i>SIO_ENABLE_CIRCULAR_QUEUEING</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">2+</td>
			<td valign="top">If the incoming buffer queue overflows, discard oldest message first.</td>
		</tr>

	</table>
</p>

<p>This ioctl command controls how the underlying service provider handles incoming datagram messages when the queues are full. By default, when the incoming queue is full, any datagram messages subsequently received are dropped. When this option is set to <i>TRUE</i>, it indicates that the newly arrived messages should never be dropped as a result of buffer overflow; instead, the oldest message in the queue should be discarded in order to make room for the newly arrived message. This command is valid only for sockets associated with unreliable, message-oriented, protocols. If this ioctl command is used on a socket of another type (such as a stream-oriented protocol socket), or if the service provider doesn't support the command, the error <i>WSAENOPROTOOPT</i> is returned. This option is supported only on Windows NT and Windows 2000.</p>

<p>This ioctl command can be used either to set circular queuing on or off or to query the current state of the option. When you are setting the option, only the input parameters need to be used. When you are querying the current value of the option, only the output <i>BOOL</i> parameter needs to be supplied.</p>

<A NAME="278"><h3><i>SIO_FIND_ROUTE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"><i>SOCKADDR</i></td>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">2+</td>
			<td valign="top">Verifies that a route to the given address exists</td>
		</tr>

	</table>
</p>

<p>This ioctl command is used to check whether a particular address can be reached via the network. The <i>lpvInBuffer</i> parameter points to a <i>SOCKADDR</i> structure for the given protocol. If the address already exists in the local cache, it is invalidated. For IPX, this call initiates an IPX <i>GetLocalTarget</i> call that queries the network for the given remote address. Unfortunately, the Microsoft provider for current Win32 platforms does not implement this ioctl command.</p>

<A NAME="279"><h3><i>SIO_FLUSH</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top">None</td>
			<td valign="top">None</td>
			<td valign="top">2+</td>
			<td valign="top">Determines whether OOB data has been read</td>
		</tr>

	</table>
</p>

<p>This ioctl command discards the current contents of the sending queue associated with the given socket. There are no input or output parameters for this option. Currently only Windows 2000 and Windows NT 4 Service Pack 4 implement this option.</p>

<A NAME="280"><h3><i>SIO_GET_BROADCAST_ADDRESS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top">None</td>
			<td valign="top"><i>SOCKADDR</i></td>
			<td valign="top">2+</td>
			<td valign="top">Returns a broadcast address for the address family of the socket</td>
		</tr>

	</table>
</p>

<p>This ioctl command returns a <i>SOCKADDR</i> structure (via <i>lpvOutBuffer</i>) that contains the broadcast address for the address family of socket <i>s</i> that can be used in <i>sendto</i> or <i>WSASendTo</i>. This ioctl works only on Windows NT and Windows 2000. Windows 95 and Windows 98 return <i>WSAEINVAL</i>.</p>

<A NAME="281"><h3><i>SIO_GET_EXTENSION_FUNCTION_POINTER</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top">GUID</td>
			<td valign="top">function pointer?</td>
			<td valign="top">2+</td>
			<td valign="top">Retrieves a function pointer specific to underlying provider</td>
		</tr>

	</table>
</p>

<p>This ioctl command is used to obtain functions that are provider-specific but are not part of the Winsock specification. If a provider chooses, it can make functions available to programmers through this ioctl command by assigning each function a GUID. Then an application can obtain a pointer to this function by using the <i>SIO_GET_EXTENSION_FUNCTION_POINTER</i> ioctl. The header file Mswsock.h defines those Winsock functions that Microsoft has added, including their GUIDs. For example, to query whether the installed Winsock provider supports the <i>TransmitFile</i> function, you can query the provider by using its GUID, which is given by the following define:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
#define WSAID_TRANSMITFILE \
   {0xb5367df0,0xcbac,0x11cf,{0x95,0xca,0x00,0x80,0x5f,0x48,0xa1,0x92}}
</pre>
</td></tr></table>
</p>

<p>Once you obtain the function pointer for an extension function such as <i>TransmitFile</i>, you can call it directly without having to link your application to the Mswsock.lib library. This will actually reduce one intermediate function call that is made in Mswsock.lib.</p>

<p>You can look through Mswsock.h for other Microsoft-specific extensions that have these GUIDs defined for them. This ioctl command is an important part of developing a layered service provider. See <A HREF="ch14a.htm">Chapter 14</A> for more details of the service provider interface.</p>

<A NAME="282"><h3><i>SIO_CHK_QOS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"><i>DWORD</i></td>
			<td valign="top"><i>DWORD</i></td>
			<td valign="top">2+</td>
			<td valign="top">Sets the QOS attributes for the given socket</td>
		</tr>

	</table>
</p>

<p>This ioctl command can be used to check the status of six states within QOS and is currently supported only on Windows 2000. Six different flags correspond to these states: <i>ALLOWED_TO_SEND_DATA</i>, <i>ABLE_TO_RECV_RSVP</i>, <i>LINE_RATE</i>, <i>LOCAL_TRAFFIC_CONTROL</i>, <i>LOCAL_QOSABILITY</i>, and <i>END_TO_END_QOSABILITY</i>.</p>

<p>The first flag, <i>ALLOWED_TO_SEND_DATA</i>, is used once QOS levels are set on a socket using <i>SIO_SET_QOS</i> but before any RSVP reservation request (RESV) message has been received. Receiving a RESV message indicates that the desired bandwidth requirements have been allocated to your flow. Prior to receiving the RESV message, the flow corresponding to the socket is given only best-effort service. The RSVP protocol and reservation of network resources are covered in greater detail in <a href="ch12a.htm">Chapter 12</a>. Use the <i>ALLOWED_TO_SEND_DATA</i> flag to see whether the current best-effort service is sufficient for the levels of QOS requested by <i>SIO_SET_QOS</i>. The return value will be either 1&#8212;meaning that the current best-effort bandwidth is sufficient&#8212;or 0, meaning that the bandwidth cannot accommodate the requested levels. If the <i>ALLOWED_TO_SEND_DATA</i> flag returns 0, the sending application should wait until a RESV message is received before sending data.</p>

<p>The second flag, <i>ABLE_TO_RECV_RSVP</i>, indicates whether the host is able to receive and process RSVP messages on the interface that the given socket is bound to. The return value is either 1 or 0, corresponding to whether RSVP messages can or cannot be received, respectively.</p>

<p>The next flag, <i>LINE_RATE</i>, returns the best-effort line rate in kilobits per second (kbps). If the line rate is not known, the value <i>INFO_NOT_AVAILABLE</i> is returned.</p>

<p>The last three flags indicate whether certain capabilities exist on the local machine or the network. All three options return 1 to indicate the option is supported, 0 if it is not supported, or <i>INFO_NOT_AVAILABLE</i> if there is no way to check. <i>LOCAL_TRAFFIC_CONTROL</i> is used to determine whether the Traffic Control component is installed and available on the machine. <i>LOCAL_QOSABILITY</i> determines whether QOS is supported on the local machine. Finally <i>END_TO_END_QOSABILITY</i> indicates whether the local network is QOS-enabled.</p>

<A NAME="283"><h3><i>SIO_GET_QOS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top">None</td>
			<td valign="top"><i>QOS</i></td>
			<td valign="top">2+</td>
			<td valign="top">Returns the <i>QOS</i> structure associated with the socket</td>
		</tr>

	</table>
</p>

<p>This ioctl command retrieves the <i>QOS</i> structure associated with the socket. The supplied buffer must be large enough to contain the whole structure, which in some cases is larger than <i>sizeof(QOS)</i>, as the structure might contain provider-specific information. For more information on QOS, see <A HREF="ch12a.htm">Chapter 12</A>. If this ioctl command is used on a socket whose address family does not support QOS, the error <i>WSAENOPROTOOPT</i> is returned. This option and <i>SIO_SET_QOS</i> are available only on platforms that provide a QOS-capable transport, such as Windows 98 and Windows 2000.</p>

<A NAME="284"><h3><i>SIO_SET_QOS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"><i>QOS</i></td>
			<td valign="top">None</td>
			<td valign="top">2+</td>
			<td valign="top">Sets the QOS attributes for the given socket</td>
		</tr>

	</table>
</p>

<p>This ioctl command is the companion to <i>SIO_GET_QOS</i>. The input parameter for this call is a <i>QOS</i> structure that defines the bandwidth requirements for this socket. This call does not return any output values. See <A HREF="ch12a.htm">Chapter 12</A> for more information about QOS. This option and <i>SIO_GET_QOS</i> are available only on those platforms that provide a QOS-capable transport, such as Windows 98 and Windows 2000.</p>

<A NAME="285"><h3><i>SIO_MULTIPOINT_LOOPBACK</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top"><i>BOOL</i></td>
			<td valign="top">2+</td>
			<td valign="top">Sets/gets whether multicast data will be looped back to the socket</td>
		</tr>

	</table>
</p>

<p>When sending multicast data, the default behavior is to have any data sent to the multicast group posted as incoming data on the socket's receive queue. Of course, this loopback is in effect only if the socket is also a member of the multicast group that it is sending to. Currently this loopback behavior is seen only in IP multicasting and is not present in ATM multicasting. To disable this loopback, pass a Boolean variable with the value <i>FALSE</i> into the input parameter <i>lpvInBuffer</i>. To obtain the current value of this option, leave the input value as <i>NULL</i> and supply a Boolean variable as the output parameter.</p>

<A NAME="286"><h3><i>SIO_MULTICAST_SCOPE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"><i>int</i></td>
			<td valign="top"><i>int</i></td>
			<td valign="top">2+</td>
			<td valign="top">Gets/sets the time-to-live (TTL) value for multicast data</td>
		</tr>

	</table>
</p>

<p>This ioctl command controls the lifetime, or scope, of multicast data. The scope is the number of routed network segments that data is allowed to traverse; by default, the value is only 1. When a multicast packet hits a router, the TTL value is decremented by 1. Once the TTL reaches 0, the packet is discarded. To set the value, pass an integer with the desired TTL as <i>lpvInBuffer</i>; otherwise, to simply obtain the current TTL value, call <i>WSAIoctl</i> with the <i>lpvOutBuffer</i> pointing to an integer.</p>

<A NAME="287"><h3><i>SIO_KEEPALIVE_VALS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"><i>tcp_keepalive</i></td>
			<td valign="top"><i>tcp_keepalive</i></td>
			<td valign="top">2+</td>
			<td valign="top">Sets the TCP keepalive active on a per-connection basis</td>
		</tr>

	</table>
</p>

<p>This ioctl command allows setting the TCP keepalive active on a per-connection basis and allows you to specify the keepalive interval. The socket option <i>SO_KEEPALIVE</i> also enables TCP keepalives, but the interval on which they are sent is set in the Registry. Changing the Registry value changes the keepalive interval for all processes on the machine. This ioctl command allows you to set the interval on a per-socket basis. To set the keepalive active on the given connected socket, initialize a <i>tcp_keepalive</i> structure and pass it as the input buffer. The structure is defined as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
struct tcp_keepalive
{
    u_long    onoff;
    u_long    keepalivetime;
    u_long    keepaliveinterval;
}
</pre>
</td></tr></table>
</p>

<p>The meaning of the structure fields <i>keepalivetime</i> and <i>keepaliveinterval</i> are identical to the Registry values discussed in the <i>SO_KEEPALIVE</i> option presented earlier in this chapter. Once a keepalive is set, you can query for the current keepalive values by calling <i>WSAIoctl</i> with the <i>SIO_KEEPALIVE_VALS</i> ioctl command and supplying a <i>tcp_keepalive</i> structure as the output buffer. This ioctl command is available on Windows 2000 only.</p>

<A NAME="288"><h3><i>SIO_RCVALL</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"><i>unsigned int</i></td>
			<td valign="top">None</td>
			<td valign="top">2+</td>
			<td valign="top">Receives all packets on the network</td>
		</tr>

	</table>
</p>

<p>Using this ioctl command with the value <i>TRUE</i> allows the given socket to receive all IP packets on the network. This requires that the socket handle be passed to <i>WSAIoctl</i> and that the socket be of address family <i>AF_INET</i>, socket type <i>SOCK_RAW</i>, and protocol <i>IPPROTO_IP</i>. Additionally, the socket must be bound to an explicit local interface. That is, you cannot bind to <i>INADDR_ANY</i>. Once the socket is bound and the ioctl is set, calls to <i>recv/WSARecv</i> return IP datagrams. Keep in mind that these are datagrams&#8212;you must supply a sufficiently large buffer. Because the total length field of the IP header is a 16-bit quantity, the maximum theoretical limit is 65,535 bytes; however, in practice the maximum transmission unit (MTU) of networks is much lower. Using this ioctl command requires Administrator privileges on the local machine. Additionally, this ioctl command is available on Windows 2000 only. A sample application on the companion CD, Rcvall.c, illustrates
using this and the other two <i>SIO_RCVALL</i> ioctl commands.</p>

<A NAME="289"><h3><i>SIO_RCVALL_MCAST</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"><i>unsigned int</i></td>
			<td valign="top">None</td>
			<td valign="top">2+</td>
			<td valign="top">Receives all multicast packets on the network</td>
		</tr>

	</table>
</p>

<p>This ioctl command is similar to the <i>SIO_RCVALL</i> command described earlier. The same usage rules mentioned for <i>SIO_RCVALL</i> also apply here except that the socket passed to <i>WSAIoctl</i> should be created with the protocol equal to <i>IPPROTO_IGMP</i>. The one difference is that only multicast IP traffic is returned, as opposed to all IP packets. This means that only IP packets destined for addresses in the range 224.0.0.0 through 239.255.255.255 are returned. This ioctl command is available on Windows 2000 only.</p>

<A NAME="290"><h3><i>SIO_RCVALL_IGMPMCAST</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"><i>unsigned int</i></td>
			<td valign="top">None</td>
			<td valign="top">2+</td>
			<td valign="top">Receives all IGMP packets on the network</td>
		</tr>

	</table>
</p>

<p>Again, this ioctl command is the same as <i>SIO_RCVALL</i>, except that the socket passed into <i>WSAIoctl</i> should be created with the protocol equal to <i>IPPROTO_IGMP</i>. Setting this option returns only IGMP packets. See the <i>SIO_RCVALL</i> entry for instructions on how to use this option. This ioctl is available on Windows 2000 only.</p>

<A NAME="291"><h3><i>SIO_ROUTING_INTERFACE_QUERY</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top">Both</td>
			<td valign="top"><i>SOCKADDR</i></td>
			<td valign="top">None</td>
			<td valign="top">2+</td>
			<td valign="top">Determines whether OOB data has been read</td>
		</tr>

	</table>
</p>

<p>This ioctl command allows you to find the address of the local interface that should be used to send data to a remote machine. The address of the remote machine should be supplied in the form of a <i>SOCKADDR</i> structure as the <i>lpvInBuffer</i> parameter. Additionally, a sufficiently large buffer needs to be supplied as the <i>lpvOutBuffer</i>, which will contain an array of one or more <i>SOCKADDR</i> structures describing the local interface(s) that can be used. This command can be used for either unicast or multicast endpoints, and the interface returned from this call can be used in a subsequent call to <i>bind</i>.</p>

<p>The Windows 2000 plug-and-play capabilities are the motivation for having an ioctl like this. The user can insert or remove a PCMCIA network card, affecting which interfaces an application can use. A well-written application on Windows 2000 should take this into account.</p>

<p>Therefore, applications cannot rely on the information returned by <i>SIO_ROUTING_INTERFACE_QUERY</i> to be persistent. To handle this situation, you should also use the <i>SIO_ROUTING_INTERFACE_CHANGE</i> ioctl command, which notifies your application when the interfaces change. Once this occurs, call <i>SIO_ROUTING_INTERFACE_QUERY</i> once again to obtain the latest information.</p>

<A NAME="292"><h3><i>SIO_ROUTING_INTERFACE_CHANGE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"><i>SOCKADDR</i></td>
			<td valign="top">None</td>
			<td valign="top">2+</td>
			<td valign="top">Sends notification when an interface to an endpoint has changed</td>
		</tr>

	</table>
</p>

<p>Using this ioctl command indicates that you want to be notified of any change in the local routing interface that is used to access the specified remote address. When you use this command, a <i>SOCKADDR</i> structure to the remote address in question is submitted in the input buffer and no data is returned upon successful completion. However, if the interface to that route changes in some way, the application will be notified, at which point the application can call <i>SIO_ROUTING_INTERFACE_QUERY</i> to determine which interface to use as a result.</p>

<p>There are several ways to make a call to this command. If the socket is blocking, the <i>WSAIoctl</i> call will not complete until some point at which the interface changes. If the socket is in nonblocking mode, the error <i>WSAEWOULDBLOCK</i> is returned. Then the application can wait for routing-change events through either <i>WSAEventSelect</i> or <i>WSAAsyncSelect</i>, with the <i>FD_ROUTING_INTERFACE_CHANGE</i> flag set in the network event bitmask. Overlapped I/O can also be used to make the call. With this method, you supply an event handle in the <i>WSAOVERLAPPED</i> structure, which is signaled upon a routing change.</p>

<p>The address specified in the input <i>SOCKADDR</i> structure can be a specific address, or you can use the wildcard <i>INADDR_ANY</i>, indicating that you want to be notified of any routing changes. Note that because routing information remains fairly static, providers have the option of ignoring the information supplied by the application in the input buffer and simply sending a notification upon any interface change. As a result, it is probably a good idea to register for notification on any change and simply call <i>SIO_ROUTING_INTERFACE_QUERY</i> to see whether the change affects your application.</p>

<A NAME="293"><h3><i>SIO_ADDRESS_LIST_QUERY</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"> None</td>
			<td valign="top"><i>SOCKET_ADDRESS_LIST</i></td>
			<td valign="top">2+</td>
			<td valign="top">Returns a list of interfaces to which the socket can bind</td>
		</tr>

	</table>
</p>

<p>This ioctl is used to obtain a list of local transport addresses matching the socket's protocol family that the application can bind to. The output buffer is a <i>SOCKET_ADDRESS_LIST</i> structure, defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _SOCKET_ADDRESS_LIST 
{ 
INT            iAddressCount<i>; </i> 
SOCKET_ADDRESS Address[1]<i>;</i>
} SOCKET_ADDRESS_LIST, FAR * LPSOCKET_ADDRESS_LIST; 

typedef struct _SOCKET_ADDRESS 
{
    LPSOCKADDR lpSockaddr;
    INT        iSockaddrLength;
} SOCKET_ADDRESS, *PSOCKET_ADDRESS, FAR * LPSOCKET_ADDRESS;
</pre>
</td></tr></table>
</p>

<p>The <i>iAddressCount</i> field returns the number of address structures in the list, while the <i>Address</i> field is an array of protocol family-specific addresses.</p>

<p>In Win32 plug-and-play environments, the number of valid addresses can change dynamically; therefore, applications cannot rely on the information returned from this ioctl command to remain constant. In order to take this into account, applications should first call <i>SIO_ADDRESS_LIST_QUERY</i> to obtain current interface information and then call <i>SIO_ADDRESS_LIST_CHANGE</i> to receive notification of future changes. If the address list changes, the application should again make a query.</p>

<p>If the supplied output buffer is not of sufficient size, <i>WSAIoctl</i> fails with <i>WSAEFAULT</i>, and the <i>lcbBytesReturned</i> parameter indicates the required buffer size.</p>

<A NAME="294"><h3><i>SIO_ADDRESS_LIST_CHANGE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"> None</td>
			<td valign="top">None</td>
			<td valign="top">2+</td>
			<td valign="top">Notifies when local interfaces change</td>
		</tr>

	</table>
</p>

<p>An application can use this command to receive notification of changes in the list of local transport addresses of the given socket's protocol family to which the application can bind. No information is returned in the output parameters upon successful completion of the call.</p>

<p>There are several ways to make a call to this command. If the socket is blocking, the <i>WSAIoctl</i> call will not complete until some point at which the interface changes. If the socket is in nonblocking mode, the error <i>WSAEWOULDBLOCK</i> is returned. Then the application can wait for routing-change events through either <i>WSAEventSelect</i> or <i>WSAAsyncSelect</i> with the <i>FD_ADDRESS_LIST_CHANGE</i> flag set in the network event bitmask. Additionally, overlapped I/O can be used to make the call. With this method, you supply an event handle in the <i>WSAOVERLAPPED</i> structure, which is signaled upon a routing change.</p>

<A NAME="295"><h3><i>SIO_GET_INTERFACE_LIST</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"> None</td>
			<td valign="top"><i>INTERFACE_INFO []</i></td>
			<td valign="top">2+</td>
			<td valign="top">Returns a list of local interfaces</td>
		</tr>

	</table>
</p>

<p>This ioctl is defined in Ws2tcpip.h. It is used to return information regarding each interface on the local machine. Nothing is required on input, but upon output, an array of <i>INTERFACE_INFO</i> structures is returned. The structures are defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _INTERFACE_INFO
{
    u_long          iiFlags;            /* Interface flags   */
    sockaddr_gen    iiAddress;          /* Interface address */
    sockaddr_gen    iiBroadcastAddress; /* Broadcast address */
    sockaddr_gen    iiNetmask;          /* Network mask      */
} INTERFACE_INFO, FAR * LPINTERFACE_INFO;

#define IFF_UP             0x00000001 /* Interface is up                 */
#define IFF_BROADCAST      0x00000002 /* Broadcast is supported          */
#define IFF_LOOPBACK       0x00000004 /* This is loopback interface      */
#define IFF_POINTTOPOINT   0x00000008 /* This is point-to-point interface*/
#define IFF_MULTICAST      0x00000010 /* Multicast is supported          */

typedef union sockaddr_gen
{
    struct sockaddr Address;
    struct sockaddr_in  AddressIn;
    struct sockaddr_in6 AddressIn6;
} sockaddr_gen;
</pre>
</td></tr></table>
</p>

<p>The <i>iiFlags</i> member returns a bitmask of flags indicating whether the interface is up (<i>IFF_UP</i>) as well as whether broadcast (<i>IFF_BROADCAST</i>) or multicast (<i>IFF_MULTICAST</i>) is supported. It also indicates whether the interface is loopback (<i>IFF_LOOPBACK</i>) or point-to-point (<i>IFF_POINTTOPOINT</i>). The other three fields contain the address of the interface, the broadcast address, and the corresponding netmask.</p>

<A NAME="296"><H2>Secure Socket Layer Ioctl Commands</H2></A>

<p>Secure Socket Layer (SSL) commands are supported only in Windows CE. Currently Windows 95 and 98, Windows NT, and Windows 2000 do not provide an SSL-capable provider. As these are available only in Windows CE, the only version of Winsock currently supported for these options is version 1.</p>

<A NAME="297"><h3><i>SO_SSL_GET_CAPABILITIES</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top">None</td>
			<td valign="top"><i>DWORD</i></td>
			<td valign="top">Returns the Winsock security provider's capabilities</td>
		</tr>

	</table>
</p>

<p>This command retrieves a set of flags describing the Windows Sockets security provider's capabilities. The output buffer must be a pointer to a <i>DWORD</i> bit field. At present, only the flag <i>SO_CAP_CLIENT</i> is defined.</p>

<A NAME="298"><h3><i>SO_SSL_GET_FLAGS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top">None</td>
			<td valign="top"><i>DWORD</i></td>
			<td valign="top">Returns <i>s</i>-channel-specific flags associated with socket</td>
		</tr>

	</table>
</p>

<p>This command retrieves <i>s</i>-channel_specific flags associated with a particular socket. The output buffer must be a pointer to a <i>DWORD</i> bit field. See <i>SO_SSL_SET_FLAGS</i> below for details of valid flags.</p>

<A NAME="299"><h3><i>SO_SSL_SET_FLAGS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"><i>DWORD</i></td>
			<td valign="top">None</td>
			<td valign="top">Sets the socket's <i>s</i>-channel-specific flags</td>
		</tr>

	</table>
</p>

<p>Here the input buffer must be a pointer to a <i>DWORD</i> bit field. Currently only the <i>SSL_FLAG_DEFER_HANDSHAKE</i> flag, which allows the application to send and receive plain text data before switching to cipher text, is defined. This flag is required for setting up communication through proxy servers.</p>

<p>Normally the Windows Sockets security provider performs the secure handshake in the Windows Sockets <i>connect</i> function. However, if this flag is set, the handshake is deferred until the application issues the <i>SO_SSL_PERFORM_HANDSHAKE</i> control code. After the handshake, this flag is reset.</p>

<A NAME="300"><h3><i>SO_SSL_GET_PROTOCOLS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top">None</td>
			<td valign="top"><i>SSLPROTOCOLS</i></td>
			<td valign="top">Returns a list of protocols supported by the security provider</td>
		</tr>

	</table>
</p>

<p>This command retrieves a list of protocols that the provider currently supports on this socket. The output buffer must be a pointer to a <i>SSLPROTOCOLS</i> structure, as described here:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _SSLPROTOCOL 
{
    DWORD dwProtocol;
    DWORD dwVersion;
    DWORD dwFlags;
} SSLPROTOCOL, *LPSSLPROTOCOL;
typedef struct _SSLPROTOCOLS 
{
    DWORD       dwCount;
    SSLPROTOCOL ProtocolList[1];
} SSLPROTOCOLS, FAR *LPSSLPROTOCOLS;
</pre>
</td></tr></table>
</p>

<p>Valid protocols for the <i>dwProtocol</i> field include <i>SSL_PROTOCOL_SSL2</i>, <i>SSL_PROTOCOL_SSL3</i>, and <i>SSL_PROTOCOL_PCT1</i>.</p>

<A NAME="301"><h3><i>SO_SSL_SET_PROTOCOLS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"><i>SSLPROTOCOLS</i></td>
			<td valign="top">None</td>
			<td valign="top">Sets a list of protocols that the underlying provider should support</td>
		</tr>

	</table>
</p>

<p>This ioctl command specifies a list of protocols that the provider is to support on this socket. The input buffer must be a pointer to the <i>SSLPROTOCOLS</i> structure described above.</p>

<A NAME="302"><h3><i>SO_SSL_SET_VALIDATE_CERT_HOOK</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"><i>SSLVALIDATECERTHOOK</i></td>
			<td valign="top">None</td>
			<td valign="top">Sets the validation function for accepting SSL certificates</td>
		</tr>

	</table>
</p>

<p>This ioctl command sets the pointer to the socket's certificate validation hook. It is used to specify the callback function invoked by the Windows Sockets security provider when a set of credentials is received from the remote party. The input buffer must be a pointer to the <i>SSLVALIDATECERTHOOK</i> structure, described as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct 
{
    SSLVALIDATECERTFUNC    HookFunc;
    LPVOID                 pvArg;
} SSLVALIDATECERTHOOK, *PSSLVALIDATECERTHOOK;
</pre>
</td></tr></table>
</p>

<p>The <i>HookFunc</i> field is a pointer to a certificate validation callback function; <i>pvArg</i> is a pointer to application-specific data and can be used by the application for any purpose.</p>

<A NAME="303"><h3><i>SO_SSL_PERFORM_HANDSHAKE</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top">None</td>
			<td valign="top">None</td>
			<td valign="top">Initiates a secure handshake on a connected socket</td>
		</tr>

	</table>
</p>

<p>This ioctl command initiates the secure handshake sequence on a connected socket in which the <i>SSL_FLAG_DEFER_HANDSHAKE</i> flag has been set prior to the connection. Data buffers are not required, but the <i>SSL_FLAG_DEFER_HANDSHAKE</i> flag will be reset.</p>

<A NAME="304"><H2>ATM Ioctl Commands</H2></A>

<p>These ioctl commands are specific to the ATM protocol family. They are fairly basic, dealing mainly with obtaining the number of ATM devices and ATM addresses of the local interfaces. See <a href="ch06a.htm">Chapter 6</A> for more detailed information about the addressing mechanisms for ATM.</p>

<A NAME="305"><h3><i>SIO_GET_NUMBER_OF_ATM_DEVICES</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"> None</td>
			<td valign="top"><i>DWORD</i></td>
			<td valign="top">2+</td>
			<td valign="top">Returns the number of ATM adapters</td>
		</tr>

	</table>
</p>

<p>This ioctl command fills the output buffer pointed to by <i>lpvOutBuffer</i> with a <i>DWORD</i> containing the number of ATM devices in the system. Each specific device is identified by a unique ID, in the range 0 to the number returned by this ioctl command minus 1.</p>

<A NAME="306"><h3><i>SIO_GET_ATM_ADDRESS</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"> <i>DWORD</i></td>
			<td valign="top"><i>ATM_ADDRESS</i></td>
			<td valign="top">2+</td>
			<td valign="top">Returns the ATM address for the given device</td>
		</tr>

	</table>
</p>

<p>This ioctl command retrieves the local ATM address associated with the specified device. A device ID of type <i>DWORD</i> is specified in the input buffer for this ioctl command, and the output buffer pointed to by <i>lpvOutBuffer</i> will be filled with an <i>ATM_ADDRESS</i> structure containing a local ATM address suitable for use with <i>bind</i>.</p>

<A NAME="307"><h3><i>SIO_ASSOCIATE_PVC</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>WSAIoctl</i></td>
			<td valign="top"> <i>ATM_PVC_PARAMS</i></td>
			<td valign="top">None</td>
			<td valign="top">2+</td>
			<td valign="top">Associates socket with a permanent virtual circuit</td>
		</tr>

	</table>
</p>

<p>This ioctl command associates the socket with a permanent virtual circuit (PVC), as indicated in the input buffer, which contains the <i>ATM_PVC_PARAMS</i> structure. The socket should be of the <i>AF_ATM</i> address family. After successfully returning from this function, the application is able to start sending and receiving data as if the connection has been set up.</p>

<p>The <i>ATM_PVC_PARAMS</i> structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct 
{
    ATM_CONNECTION_ID   PvcConnectionId;
    QOS                 PvcQos;
} ATM_PVC_PARAMS;

typedef struct 
{
    DWORD  DeviceNumber;
    DWORD  VPI;
    DWORD  VCI;
} ATM_CONNECTION_ID;
</pre>
</td></tr></table>
</p>

<A NAME="308"><h3><i>SIO_GET_ATM_CONNECTION_ID</i></h3></A>
<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th><i>Which Function?</i></th>
			<th><i>Input</i></th>
			<th><i>Output</i></th>
			<th><i>Winsock Version</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top">Both</td>
			<td valign="top">None</td>
			<td valign="top"> <i>ATM_CONNECTION_ID</i></td>
			<td valign="top">2+</td>
			<td valign="top">Determines whether OOB data has been read</td>
		</tr>

	</table>
</p>

<p>This ioctl command retrieves the ATM Connection ID associated with the socket. Upon successfully returning from this function, the output buffer pointed to by <i>lpvOutBuffer</i> is filled with an <i>ATM_CONNECTION_ID</i> structure containing the device number and VPI/VCI values, which are defined in the earlier entry for <i>SIO_ASSOCIATE_PVC</i>.</p>

</BODY>
</HTML>




