<HTML>
<HEAD>
<TITLE>IPX/SPX</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06c.htm" , "ch06e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="114"><H1>IPX/SPX</H1></A>

<p>The Internetwork Packet Exchange (IPX) protocol is commonly known as the protocol used with computers featuring Novell NetWare client/server networking services. IPX provides connectionless communication between two processes; therefore, if a workstation transmits a data packet, there is no guarantee that the packet will be delivered to the destination. If an application needs guaranteed delivery of data and insists on using IPX, it can use a higher-level protocol over IPX, such as the Sequence Packet Exchange (SPX) and SPX II protocols, in which SPX packets are transmitted through IPX. Winsock provides applications with the capability to communicate through IPX on Windows 95, Windows 98, Windows NT, and Windows 2000 but not on Windows CE.</p>

<A NAME="115"><H2>Addressing</H2></A>

<p>In an IPX network, network segments are bridged together using an IPX router. Each network segment is assigned a unique 4-byte network number. As more network segments are bridged together, IPX routers manage communication between different network segments using the unique network segment numbers. When a computer is attached to a network segment, it is identified using a unique 6-byte node number, which is usually the physical address of the network adapter. A node (which is a computer) is typically capable of having one or more processes forming communication over IPX. IPX uses socket numbers to distinguish communication for processes on a node.</p>

<p>To prepare a Winsock client or server application for IPX communication, you have to set up a <i>SOCKADDR</i>_<i>IPX</i> structure. The <i>SOCKADDR</i>_<i>IPX</i> structure is defined in the Wsipx.h header file, and your application must include this file after including Winsock2.h. The <i>SOCKADDR</i>_<i>IPX</i> structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct sockaddr_ipx
{
    short          sa_family;
    char           sa_netnum[4];
    char           sa_nodenum[6];
    unsigned short sa_socket;
} SOCKADDR_IPX, *PSOCKADDR_IPX, FAR *LPSOCKADDR_IPX;
</pre>
</td></tr></table>
</p>

<p>The <i>sa_family</i> field should always be set to the <i>AF_IPX</i> value. The <i>sa_netnum</i> field is a 4-byte number representing a network number of a network segment on an IPX network. The <i>sa_nodenum</i> field is a 6-byte number representing a node number of a computer's physical address. The <i>sa_socket</i> field represents a socket or port used to distinguish IPX communication on a single node.</p>

<A NAME="116"><H2>Creating a Socket</H2></A>

<p>Creating a socket using IPX offers several possibilities. To open an IPX socket, call the <i>socket</i> function or the <i>WSASocket</i> function with the address family <i>AF_IPX</i>, the socket type <i>SOCK_DGRAM</i>, and the protocol <i>NSPROTO_IPX</i>, as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
s = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX);

s = WSASocket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX,
    NULL, 0, WSA_FLAG_OVERLAPPED);
</pre>
</td></tr></table>
</p>

<p>Note that the third parameter protocol must be specified and cannot be 0. This is important because this field can be used to set specific IPX packet types.</p>

<p>As we mentioned earlier, IPX provides unreliable connectionless communication using datagrams. If an application needs reliable communication using IPX, it can use higher-level protocols over IPX, such as SPX and SPX II. This can be accomplished by setting the type and protocol fields of the <i>socket</i> and <i>WSASocket</i> calls to the socket type <i>SOCK_SEQPACKET</i> or <i>SOCK_STREAM</i>, and the protocol <i>NSPROTO_SPX</i> or <i>NSPROTO_SPXII</i>.</p>

<p>If <i>SOCK_STREAM</i> is specified, data is transmitted as a continuous stream of bytes with no message boundaries&#8212;similar to the behavior of sockets in TCP/IP. On the other hand, if <i>SOCK_SEQPACKET</i> is specified, data is transmitted with message boundaries. For example, if a sender transmits 2000 bytes, the receiver won't return until all 2000 bytes have arrived. SPX and SPX II accomplish this by setting an end-of-message bit in an SPX header. When <i>SOCK_SEQPACKET</i> is specified, this bit is respected&#8212;meaning Winsock <i>recv</i> and <i>WSARecv</i> calls won't complete until a packet is received with this bit set. If <i>SOCK_STREAM</i> is specified, the end-of-message bit isn't respected, and <i>recv</i> completes as soon as any data is received, regardless of the setting of the end-of-message bit. From the sender's perspective (using the <i>SOCK_SEQPACKET</i> type), sends smaller than a single packet are always sent with the endof-message bit set. Sends larger than single packets are packetized with the end-ofmessage bit set on only the last packet of the send.</p>

<A NAME="117"><H3>Binding a socket</H3></A>

<p>When an IPX application associates a local address with a socket using <i>bind</i>, you shouldn't specify a network number and a node address in a <i>SOCKADDR_IPX</i> structure. The <i>bind</i> function populates these fields using the first IPX network interface available on the system. In the case of a machine with multiple network interfaces (a multihomed machine), it isn't necessary to bind to a specific interface. Windows 95, Windows 98, Windows NT, and Windows 2000 provide a virtual internal network in which each network interface can be reached regardless of the physical network it is attached to. We will describe internal network numbers in greater detail later in this chapter. After your application successfully binds to a local interface, you can retrieve local network number and node number information using the <i>getsockname</i> function, as in the following code fragment:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SOCKET sdServer;
SOCKADDR_IPX IPXAddr;
int addrlen = sizeof(SOCKADDR_IPX);

if ((sdServer = socket (AF_IPX, SOCK_DGRAM, NSPROTO_IPX))
    == INVALID_SOCKET)
{
    printf(&quot;socket failed with error %d\n&quot;, 
        WSAGetLastError());
    return;
} 

ZeroMemory(&amp;IPXAddr, sizeof(SOCKADDR_IPX));
IPXAddr.sa_family = AF_IPX;
IPXAddr.sa_socket = htons(5150);

if (bind(sdServer, (PSOCKADDR) &amp;IPXAddr, sizeof(SOCKADDR_IPX))
    == SOCKET_ERROR)
{
    printf(&quot;bind failed with error %d\n&quot;,
        WSAGetLastError());
    return;
}

if (getsockname((unsigned) sdServer, (PSOCKADDR) &amp;IPXAddr, &amp;addrlen)
    == SOCKET_ERROR)
{
    printf(&quot;getsockname failed with error %d&quot;, 
        WSAGetLastError());
    return;
}

// Print out SOCKADDR_IPX information returned from
// getsockname()
</pre>
</td></tr></table>
</p>

<A NAME="118"><H3>Network number vs. internal network number</H3></A>

<p>A network number (known as an external network number) identifies network segments in IPX and is used for routing IPX packets between network segments. Windows 95, Windows 98, Windows NT, and Windows 2000 also feature an internal network number that is used for internal routing purposes and to uniquely identify the computer on an inter-network (several networks bridged together). The internal network number is also known as a virtual network number&#8212;the internal network number identifies another (virtual) segment on the inter-network. Thus, if you configure an internal network number for a computer running Windows 95, Windows 98, Windows NT, or Windows 2000, a NetWare server or an IPX router will add an extra hop in its route to that computer.</p>

<p>The internal virtual network serves a special purpose in the case of a multihomed computer. When applications bind to a local network interface, they shouldn't specify local interface information but instead should set the <i>sa_netnum</i> and <i>sa_nodenum</i> fields of a <i>SOCKADDR_IPX</i> structure to 0. This is because IPX is able to route packets from any external network to any of the local network interfaces using the internal virtual network. For example, even if your application explicitly binds to the network interface on Network A, and a packet comes in on Network B, the internal network number will cause the packet to be routed internally so that your application receives it.</p>

<A NAME="119"><H3>Setting IPX packet types through Winsock</H3></A>

<p>Winsock allows your application to specify IPX packet types when you create a socket using the <i>NSPROTO_IPX</i> protocol specification. The packet type field in an IPX packet indicates the type of service offered or requested by the IPX packet. In Novell, the following IPX packet types are defined:</p>

<ul>
<p><li><b>01h</b> Routing Information Protocol (RIP) Packet</li></p>

<p><li><b>04h</b> Service Advertising Protocol (SAP) Packet</li></p>

<p><li><b>05h</b> Sequenced Packet Exchange (SPX) Packet</li></p>

<p><li><b>11h</b> NetWare Core Protocol (NCP) Packet</li></p>

<p><li><b>14h</b> Propagated Packet for Novell NetBIOS</li></p>
</ul>

<p>To modify the IPX packet type, simply specify <i>NSPROTO_IPX</i> + <i>n</i> as the protocol parameter of the <i>socket</i> API, with <i>n</i> representing the packet type number. For example, to open an IPX socket that sets the packet type to 04h (SAP Packet), use the following <i>socket</i> call:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
s = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX + 0x04);
</pre>
</td></tr></table>
</p>

<A NAME="120"><H2>Name Resolution</H2></A>

<p>As you can probably tell, addressing IPX in Winsock is sort of ugly since you must supply multibyte network and node numbers to form an address. IPX provides applications with the ability to locate services by using user-friendly names to retrieve network number, node number, and port number in an IPX network through the SAP protocol. As we will see in <A HREF="ch10a.htm">Chapter 10</A>, Winsock 2 provides a protocol-independent method for name registration using the <i>WSASetService</i> API function. Through the SAP protocol, IPX server applications can use <i>WSASetService</i> to register under a user-friendly name the network number, node number, and port number they are listening on. Winsock 2 also provides a protocol-independent method of name resolution through the following API functions: <i>WSALookupServiceBegin</i>, <i>WSALookupServiceNext</i>, and <i>WSALookupServiceEnd</i>.</p>

<p>It is possible to perform your own name-service registration and lookups by opening an IPX socket and specifying an SAP packet type. After opening the socket, you can begin broadcasting SAP packets to the IPX network to register and locate services on the network. This requires that you understand the SAP protocol in great detail and that you deal with the programming details of decoding an IPX SAP packet.</p>

</BODY>
</HTML>




