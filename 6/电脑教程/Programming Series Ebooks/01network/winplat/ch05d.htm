<HTML>
<HEAD>
<TITLE>Winsock 2 Protocol Information</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch05c.htm" , "ch05e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="89"><H1>Winsock 2 Protocol Information</H1></A>

<p>Winsock 2 provides a method for determining which protocols are installed on a given workstation and returning a variety of characteristics for each protocol. If a protocol is capable of multiple behaviors, each distinct behavior type has its own catalog entry within the system. For example, if you install TCP/IP on your system, there will be two IP entries: one for TCP, which is reliable and connection-oriented, and one for UDP, which is unreliable and connectionless.</p>

<p>The function call to obtain information on installed network protocols is <i>WSAEnumProtocols</i> and is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSAEnumProtocols (
    LPINT lpiProtocols, 
    LPWSAPROTOCOL_INFO lpProtocolBuffer, 
    LPDWORD lpdwBufferLength
);
</pre>
</td></tr></table>
</p>

<p>This function supersedes the Winsock 1.1 function <i>EnumProtocols</i>, which is the necessary function for Windows CE. The only difference is that <i>WSAEnumProtocols</i> returns an array of <i>WSAPROTOCOL_INFO</i> structures, whereas <i>EnumProtocols</i> returns an array of <i>PROTOCOL_INFO</i> structures that contain fewer fields than the <i>WSAPROTOCOL_INFO</i> structure (but more or less the same information). The <i>WSAPROTOCOL_INFO</i> structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _WSAPROTOCOL_INFOW { 
    DWORD             dwServiceFlags1; 
    DWORD             dwServiceFlags2; 
    DWORD             dwServiceFlags3; 
    DWORD             dwServiceFlags4; 
    DWORD             dwProviderFlags; 
    GUID              ProviderId; 
    DWORD             dwCatalogEntryId; 
    WSAPROTOCOLCHAIN  ProtocolChain; 
    int               iVersion; 
    int               iAddressFamily; 
    int               iMaxSockAddr; 
    int               iMinSockAddr; 
    int               iSocketType; 
    int               iProtocol; 
    int               iProtocolMaxOffset; 
    int               iNetworkByteOrder; 
    int               iSecurityScheme; 
    DWORD             dwMessageSize; 
    DWORD             dwProviderReserved; 
    WCHAR             szProtocol[WSAPROTOCOL_LEN + 1];
} WSAPROTOCOL_INFOW, FAR * LPWSAPROTOCOL_INFOW;
</pre>
</td></tr></table>
</p>

<p>
<div class="sidebar"><blockquote>
<b>Initializing Winsock</b> 

<p>Before you can call a Winsock function, you must load the correct version of the Winsock library. The Winsock initialization routine is <i>WSAStartup</i>, defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSAStartup(WORD wVersionRequested, LPWSADATA lpWSAData);
</pre>
</td></tr></table>
</p>

<p>The first parameter is the version of the Winsock library that you want to load. For current Win32 platforms, the latest Winsock 2 library is version 2.2. The only exception is Windows CE, which supports only Winsock version 1.1. If you wanted Winsock version 2.2, you could either specify the value (0x0202) or use the macro <i>MAKEWORD(2, 2)</i>. The high-order byte specifies the minor version number, while the low-order byte specifies the major version number.</p>

<p>The second parameter is a structure, <i>WSADATA</i>, that is returned upon completion. <i>WSADATA</i> contains information about the version of Winsock that <i>WSAStartup</i> loaded. Table 5-2 lists the individual fields of the <i>WSADATA</i> structure, which is actually defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct WSAData { 
    WORD            wVersion; 
    WORD            wHighVersion; 
    char            szDescription[WSADESCRIPTION_LEN + 1]; 
    char            szSystemStatus[WSASYS_STATUS_LEN + 1]; 
    unsigned short  iMaxSockets; 
    unsigned short  iMaxUdpDg; 
    char FAR *      lpVendorInfo;
} WSADATA, FAR * LPWSADATA;
</pre>
</td></tr></table>
</p>

<p>For the most part, the only useful information returned in the <i>WSADATA</i> structure is <i>wVersion</i> and <i>wHighVersion</i>. The entries pertaining to maximum sockets and maximum UDP size should be obtained from the catalog entry for the specific protocol you are using. The above section on <i>WSAEnumProtocols</i> discusses this.</p>

<p><b>Table 5-2.</b> <i>Member fields of the WSADATA structure</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>Field</th>
			<th>Description</th>
		</tr>

		<tr>
			<td valign="top"><i>wVersion</i></td>
			<td valign="top">The Winsock version the caller is expected to use</td>
		</tr>

		<tr>
			<td valign="top"><i>wHighVersion</i></td>
			<td valign="top">The highest Winsock version supported by the loaded library, usually the same value as <i>wVersion</i></td>
		</tr>

		<tr>
			<td valign="top"><i>szDescription</i></td>
			<td valign="top">A text description of the loaded library</td>
		</tr>

		<tr>
			<td valign="top"><i>szSystemStatus</i></td>
			<td valign="top">A text string containing relevant status or configuration information</td>
		</tr>

		<tr>
			<td valign="top"><i>iMaxSockets</i></td>
			<td valign="top">Maximum number of sockets (ignore this field for Winsock 2 or later)</td>
		</tr>
		
		<tr>
			<td valign="top"><i>iMaxUdpDg</i></td>
			<td valign="top">Maximum UDP datagram size (ignore this field for Winsock 2 or later)</td>
		</tr>

		<tr>
			<td valign="top"><i>lpVendorInfo</i></td>
			<td valign="top">Vendor-specific information (ignore this field for Winsock 2 or later)</td>
		</tr>
		
	</table>
</p>

<p>When you are finished with the Winsock library and no longer want to call any Winsock functions, the companion routine <i>WSACleanup</i> unloads the library and frees any resources. This function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSACleanup (void);
</pre>
</td></tr></table>
</p>

<p>Keep in mind that for each call to <i>WSAStartup</i> a matching call to <i>WSACleanup</i> will be needed because each startup call increments the reference count to the loaded Winsock DLL, requiring an equal number of calls to <i>WSACleanup</i> to decrement the count.</p>

<p>Note that Winsock 2 is fully compatible with all Winsock 1.1 function calls. Thus an application written to the Winsock 1.1 specification will be able to run if it loads the Winsock 2 library, as the Winsock 1.1 functions are mapped through their Winsock 2 equivalents.</p>
</blockquote></div>
</p>

<p>The easiest way to call <i>WSAEnumProtocols</i> is to make the first call with <i>lpProtocolBuffer</i> equal to <i>NULL</i> and <i>lpdwBufferLength</i> set to 0. The call fails with <i>WSAENOBUFS</i>, but <i>lpdwBufferLength</i> then contains the correct size of the buffer required to return all the protocol information. Once you allocate the correct buffer size and make another call with the supplied buffer, the function returns the number of <i>WSAPROTOCOL_INFO</i> structures returned. At this point, you can step through the structures to find the protocol entry with your required attributes. The sample program Enum.c on the companion CD-ROM enumerates all installed protocols and prints out the characteristics of each protocol.</p>

<p>The most commonly used field of the <i>WSAPROTOCOL_INFO</i> structure is <i>dwServiceFlags1</i>, which is a bit field for the various protocol attributes. Table 5-3 lists the various bit flags that can be set in the field and describes the meaning of each property. To check for the presence of a particular property, select the appropriate property flag and perform a bitwise AND of the property and the <i>dwServiceFlags1</i> field. If the resultant value is nonzero, that property is present in the given protocol; otherwise, it isn't.</p>

<p><b>Table 5-3.</b> <i>Protocol flags</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th><i>Property</i></th>
			<th><i>Meaning</i></th>
		</tr>

		<tr>
			<td valign="top"><i>XP1_CONNECTIONLESS</i></td>
			<td valign="top">This protocol provides connectionless service. If not set, the protocol supports connection-oriented data transfers.</td>
		</tr>

		<tr>
			<td valign="top"><i>XP1_GUARANTEED_DELIVERY</i></td>
			<td valign="top">This protocol guarantees that all data sent will reach the intended recipient.</td>
		</tr>

		<tr>
			<td valign="top"><i>XP1_GUARANTEED_ORDER</i></td>
			<td valign="top">This protocol guarantees that the data will arrive in the order in which it was sent and that it will not be duplicated. However, this does not guarantee delivery.</td>
		</tr>

		<tr>
			<td valign="top"><i>XP1_MESSAGE_ORIENTED</i></td>
			<td valign="top">This protocol honors message boundaries.</td>
		</tr>

		<tr>
			<td valign="top"><i>XP1_PSEUDO_STREAM</i></td>
			<td valign="top">This protocol is message-oriented, but the message boundaries are ignored on the receiver side.</td>
		</tr>
		
		<tr>
			<td valign="top"><i>XP1_GRACEFUL_CLOSE</i></td>
			<td valign="top">This protocol supports two-phase closes: each party is notified of the other's intent to close the communication channel. If not set, only abortive closes are performed.</td>
		</tr>

		<tr>
			<td valign="top"><i>XP1_EXPEDITED_DATA</i></td>
			<td valign="top">This protocol supports urgent data (out-of-band data).</td>
		</tr>

		<tr>
			<td valign="top"><i>XP1_CONNECT_DATA</i></td>
			<td valign="top">This protocol supports transferring data with the connection request.</td>
		</tr>

		<tr>
			<td valign="top"><i>XP1_DISCONNECT_DATA</i></td>
			<td valign="top">This protocol supports transferring data with the disconnect request.</td>
		</tr>

		<tr>
			<td valign="top"><i>XP1_SUPPORT_BROADCAST</i></td>
			<td valign="top">This protocol supports the broadcast mechanism.</td>
		</tr>
		
		<tr>
			<td valign="top"><i>XP1_SUPPORT_MULTIPOINT</i></td>
			<td valign="top">This protocol supports multipoint or multicast mechanisms.</td>
		</tr>

		<tr>
			<td valign="top"><i>XP1_MULTIPOINT_CONTROL_PLANE</i></td>
			<td valign="top">If this flag is set, the control plane is rooted. Otherwise, it is nonrooted.</td>
		</tr>

		<tr>
			<td valign="top"><i>XP1_MULTIPOINT_DATA_PLANE</i></td>
			<td valign="top">If this flag is set, the data plane is rooted. Otherwise, it is nonrooted.</td>
		</tr>

		<tr>
			<td valign="top"><i>XP1_QOS_SUPPORTED</i></td>
			<td valign="top">This protocol supports QOS requests.</td>
		</tr>

		<tr>
			<td valign="top"><i>XP1_UNI_SEND</i></td>
			<td valign="top">This protocol is unidirectional in the send direction.</td>
		</tr>
		
		<tr>
			<td valign="top"><i>XP1_UNI_RECV</i></td>
			<td valign="top">This protocol is unidirectional in the receive direction.</td>
		</tr>

		<tr>
			<td valign="top"><i>XP1_IFS_HANDLES</i></td>
			<td valign="top">The socket descriptors returned by the provider are Installable File System (IFS) handles and can be used in API functions such as <i>ReadFile</i> and <i>WriteFile</i>.</td>
		</tr>

		<tr>
			<td valign="top"><i>XP1_PARTIAL_MESSAGE</i></td>
			<td valign="top">The <i>MSG_PARTIAL</i> flag is supported in <i>WSASend</i> and <i>WSASendTo</i>.</td>
		</tr>
		
	</table>
</p>

<p>Most of these flags will be discussed in one or more of the following chapters, so we won't go into detail about the full meaning of each flag now. The other fields of importance are <i>iProtocol</i>, <i>iSocketType</i>, and <i>iAddressFamily</i>. The <i>iProtocol</i> field defines which protocol this entry belongs to. The <i>iSocketType</i> field is important if the protocol is capable of multiple behaviors, such as stream-oriented connections or datagram connections. Finally, <i>iAddressFamily</i> is used to distinguish the correct addressing structure to use for the given protocol. These three entries are of great importance when creating a socket for a given protocol and will be discussed in detail in the <A HREF="ch05e.htm">next section</A>.</p>

</BODY>
</HTML>




