<HTML>
<HEAD>
<TITLE>ATM</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06f.htm" , "ch06h.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="129"><H1>ATM</H1></A>

<p>The Asynchronous Transfer Mode (ATM) protocol is one of the newest protocols available that is supported by Winsock 2 on Windows 98 and Windows 2000. ATM is usually used for high-speed networking on LANs and WANs and can be used for all types of communication, such as voice, video, and data requiring high-speed communication. In general, ATM provides guaranteed quality of service (QOS) using Virtual Connections (VCs) on a network. As you will see in a moment, Winsock is capable of using VCs on an ATM network through the ATM address family. An ATM network&#8212;as shown in Figure 6-2&#8212;typically comprises endpoints (or computers) that are interconnected by switches that bridge an ATM network together.<br>

<p><A HREF="javascript:fullSize('F06ji02x.htm')"> <img src="images/F06ji02.JPG" width=404 height=213 border=0 ALT = "Click to view at full size."> </A></p>

<p><b>Figure 6-2.</b>  <i>ATM network</i></p>

<p>There are a few things to be aware of when programming for the ATM protocol. First, ATM is a media type and not really a protocol per se. That is, ATM is similar to writing Ethernet frames directly on an Ethernet network. Like Ethernet, the ATM protocol doesn't provide flow control. It is a connection-oriented protocol that provides either message or stream modes. This also means that a sending application might overrun the local buffers if data cannot be sent quickly enough. Likewise, a receiving application must post receives frequently; otherwise, when the receiving buffers become full, any additional incoming data might be dropped. If your application requires flow control, one alternative is to use IP over ATM, which is simply the IP protocol running over an ATM network. As a result, the application follows the IP address family described above. Of course, ATM does offer some advantages over IP, such as a rooted multicast scheme (described in <A HREF="ch12a.htm">Chapter 12</A>); however, the protocol that best suits you
depends on your application's needs.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Since ATM is new to Winsock 2, the information in this section was tested against ATM 
implementations on Windows 2000 Beta 3 only. Windows 98 (Service Pack 1) wasn't available 
for testing at the time of this writing, and it is possible that some of the information might 
not conform to the final implementation details of both Windows 2000 and Windows 98 
(Service Pack 1).
</blockquote></div>
</p>

<A NAME="130"><H2>Addressing</H2></A>

<p>An ATM network has two network interfaces: the user network interface (UNI) and the network node interface (NNI). The UNI interface is the communication established between an endpoint and an ATM switch, while the NNI interface is the communication established between two switches. Each of these interfaces has a related communication protocol, described below.</p>

<ul>
<p><li> <b>UNI signaling protocol</b>  Allows an endpoint to establish communication on an ATM network by sending setup and control information between an endpoint and an ATM switch. Note that this protocol is limited to transmissions between an endpoint and an ATM switch and isn't directly transmitted over an ATM network through switches.</li></p>

<p><li> <b>NNI signaling protocol</b>  Allows an ATM switch to communicate routing and control information between two switches.</li></p>
</ul>



<p>For purposes of setting up an ATM connection through Winsock, we will only discuss certain information elements in the UNI signaling protocol. Winsock on Windows 2000 and Windows 98 (service pack 1) currently supports the UNI version 3.1 signaling protocol.</p>
<p>Winsock allows a client/server application to communicate over an ATM network by setting up a Service Access Point (SAP) to form connections using the ATM UNI signaling protocol. ATM is a connection-oriented protocol that requires endpoints to establish virtual connections across an ATM network for communication. An SAP simply allows Winsock applications to register and identify a socket interface for communication on an ATM network through a <i>SOCKADDR_ATM</i> address structure. Once an SAP is established, Winsock uses the SAP to establish a virtual connection between a Winsock client and server over ATM by making calls to the ATM network using the UNI signaling protocol. The <i>SOCKADDR_ATM</i> structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct sockaddr_atm 
{
    u_short      satm_family;
    ATM_ADDRESS  satm_number;
    ATM_BLLI     satm_blli;
    ATM_BHLI     satm_bhli;
} sockaddr_atm, SOCKADDR_ATM, *PSOCKADDR_ATM, *LPSOCKADDR_ATM;
</pre>
</td></tr></table>
</p>

<p>The <i>satm_family</i> field should always be set to <i>AF_ATM</i>. The <i>satm_number</i> field represents an actual ATM address represented as an <i>ATM_ADDRESS</i> structure using one of two basic ATM addressing schemes: E.164 and Network Service Access Point (NSAP). NSAP addresses are also referred to as an NSAP-style ATM Endsystem Address (AESA). The <i>ATM_ADDRESS</i> structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct 
{
    DWORD AddressType;
    DWORD NumofDigits;
    UCHAR Addr[ATM_ADDR_SIZE];
} ATM_ADDRESS;
</pre>
</td></tr></table>
</p>

<p>The <i>AddressType</i> field defines the specified addressing scheme. This should be set to <i>ATM_E164</i> for the E.164 addressing scheme and <i>ATM_NSAP</i> for the NSAP-style addressing scheme. Additionally, the <i>AddressType</i> field can be set to other values defined in Table 6-2 on the following  when an application tries to bind a socket to an SAP, which we will discuss in more detail later in this chapter. The <i>NumofDigits</i> field should always be set to <i>ATM_ADDR_SIZE</i>. The <i>Addr</i> field represents an actual ATM 20-byte E.164 or NSAP address.</p>
<p>The <i>satm_blli</i> and <i>satm_bhli</i> fields of the <i>SOCKADDR_ATM</i> structure represent Broadband Lower Layer Information (BLLI) and Broadband Higher Layer Information (BHLI) in ATM UNI signaling, respectively. In general, these structures are used to identify the protocol stack that operates over an ATM connection. Several well-known combinations of BHLI and BLLI values are described in ATM Form/IETF documents. (A particular combination of values identifies a connection as being used by LAN Emulation over ATM, another combination identifies native IP over ATM, and so on.) Complete ranges of values for the fields in these structures are given in the ATM UNI 3.1 standards book. ATM Form/IETF documents can be found at 
<a href="http://www.ietf.org" target="_window2">http://www.ietf.org</a>.</p>

<p><b>Table 6-2.</b> <i>ATM socket address types</i></p>

<p>
<table valign="top" cellpadding="5" width="95%">

<tr>
<th>ATM_ADDRESS AddressType </th><th>Setting Type of Address</th>
</tr>
<tr>
<td valign="top"><i>ATM_E164</i> </td><td valign="top">An E.164 address; applies when connecting to an SAP</td>
</tr>

<tr>
<td valign="top"><i>ATM_NSAP</i> </td><td valign="top">An NSAP-style ATM Endsystem Address (AESA); applies when connecting to an SAP</td>
</tr>

<tr>
<td valign="top"><i>SAP_FIELD_ANY_AESA_SEL</i></td> <td valign="top">An NSAP-style ATM Endsystem Address with the selector octet wildcarded; 
applies to binding a socket to an SAP</td>
</tr>

<tr>
<td valign="top"><i>SAP_FIELD_ANY_AESA_REST</i> </td><td valign="top">An NSAP-style ATM Endsystem Address with all the octets 
except for the selector octet wildcarded; applies to binding a socket to an SAP</td>
</tr>

</table>
</p>

<p>The BHLI and BLLI data structures are defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct
{
    DWORD HighLayerInfoType;
    DWORD HighLayerInfoLength;
    UCHAR HighLayerInfo[8];
} ATM_BHLI;

typedef struct
{
    DWORD Layer2Protocol;
    DWORD Layer2UserSpecifiedProtocol;
    DWORD Layer3Protocol;
    DWORD Layer3UserSpecifiedProtocol;
    DWORD Layer3IPI;
    UCHAR SnapID[5];
} ATM_BLLI;
</pre>
</td></tr></table>
</p>

<p>Further details of the definition and use of these fields are beyond the scope of this book. An application that simply wants to form Winsock communication over an ATM network should set the following fields in the BHLI and BLLI structures to the <i>SAP_FIELD_ABSENT</i> value:</p>

<ul>
<p><li> ATM_BLLI&#8212;Layer2Protocol</li></p>

<p><li> ATM_BLLI&#8212;Layer3Protocol</li></p>

<p><li> ATM_BHLI&#8212;HighLayerInfoType</li></p>
</ul>



<p>When these fields are set to this value, none of the other fields in both structures are used. The following pseudocode demonstrates how an application might use the <i>SOCKADDR_ATM</i> structure to set up an SAP for an NSAP address:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SOCKADDR_ATM atm_addr;
UCHAR MyAddress[ATM_ADDR_SIZE];

atm_addr.satm_family                 = AF_ATM;
atm_addr.satm_number.AddressType     = ATM_NSAP;
atm_addr.satm_number.NumofDigits     = ATM_ADDR_SIZE;
atm_addr.satm_blli.Layer2Protocol    = SAP_FIELD_ABSENT;
atm_addr.satm_blli.Layer3Protocol    = SAP_FIELD_ABSENT;
atm_addr.satm_bhli.HighLayerInfoType = SAP_FIELD_ABSENT;

memcpy(&amp;atm_addr.satm_number.Addr, MyAddress, ATM_ADDR_SIZE);
</pre>
</td></tr></table>
</p>

<p>ATM addresses are normally represented as a hexadecimal ASCII string of 40 characters, which corresponds to the 20 bytes that make up either an NSAP-style or an E.164 address in an <i>ATM_ADDRESS</i> structure. For example, an ATM NSAP-style address might look like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
47000580FFE1000000F21A1D540000D10FED5800
</pre>
</td></tr></table>
</p>

<p>Converting this string to a 20-byte address can be a rather tedious task. However, Winsock provides a protocol-independent API function, <i>WSAStringToAddress</i>, which allows you to convert a 40-character ATM hexadecimal ASCII string to an <i>ATM_ADDRESS</i> structure. We describe this API function in more detail at the end of this chapter. Another way to convert a hexadecimal ASCII string to hexadecimal (binary) format is to use the function <i>AtoH</i> defined in Figure 6-3. This function isn't a part of Winsock. However, it is simple enough to develop, and you will see it in the samples in <a href="ch07a.htm">Chapter 7</A>.</p>

<p><b>Figure 6-3.</b>  <i>Conversion functions for ATM hexadecimal strings </i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
//
// Function: AtoH
//
// Description: This function coverts the ATM
// address specified in string (ASCII) format to 
// binary (hexadecimal) format
//
void AtoH(CHAR *szDest, CHAR *szSource, INT iCount)
{
    while (iCount--)
    {
        *szDest++ = ( BtoH ( *szSource++ ) &lt;&lt; 4 )
            + BtoH ( *szSource++ );
    }
    return;
}
//
// Function: BtoH

//
// Description: This function returns the equivalent
// binary value for an individual character specified
// in ASCII format
//
UCHAR BtoH( CHAR ch )
{
    if ( ch &gt;= '0' &amp;&amp; ch &lt;= '9' )
    {
        return ( ch - '0' );
    }

    if ( ch &gt;= 'A' &amp;&amp; ch &lt;= 'F' )
    {
        return ( ch - 'A' + 0xA );
    }

    if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'f' )
    {
        return ( ch - 'a' + 0xA );
    }
    //
    // Illegal values in the address will not be
    // accepted
    //
    return -1;
}
</pre>
</td></tr></table>
</p>

<A NAME="131"><H2>Creating a Socket</H2></A>

<p>In ATM, applications can create only connection-oriented sockets because ATM allows communication only over a VC. Therefore, data can be transmitted either as a stream of bytes or in a message-oriented fashion. To open a socket using the ATM protocol, call the <i>socket</i> function or the <i>WSASocket</i> function with the address family <i>AF_ATM</i> and the socket type <i>SOCK_RAW</i>, and set the protocol field to <i>ATMPROTO_AAL5</i>. For example:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
s = socket(AF_ATM, SOCK_RAW, ATMPROTO_AAL5);

s = WSASocket(AF_ATM, SOCK_RAW, ATMPROTO_AAL5, NULL, 0,
    WSA_FLAG_OVERLAPPED);
</pre>
</td></tr></table>
</p>

<p>By default, opening a socket (as in the example) creates a stream-oriented ATM socket. Windows also features an ATM provider that can perform message-oriented data transfers. Using the message-oriented provider requires you to explicitly specify the native ATM protocol provider to the <i>WSASocket</i> function by using a <i>WSAPROTOCOL_INFO</i> structure, as described in <a href="ch05a.htm">Chapter 5</A>. This is necessary because the three elements in the <i>socket</i> call and the <i>WSASocket</i> call (address family, socket type, and protocol) match every ATM provider available in Winsock. By default, Winsock returns the protocol entry that matches those three attributes and that is marked as default, which in this case is the stream-oriented provider. The following pseudocode demonstrates how to retrieve the ATM message-oriented provider and establish a socket:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
dwRet = WSAEnumProtocols(NULL, lpProtocolBuf, &amp;dwBufLen);

for (i = 0; i &lt; dwRet; i++)
{
    if ((lpProtocolBuf[i].iAddressFamily == AF_ATM) &amp;&amp;
       (lpProtocolBuf[i].iSocketType == SOCK_RAW) &amp;&amp;
       (lpProtocolBuf[i].iProtocol == ATMPROTO_AAL5) &amp;&amp;
       (lpProtocolBuf[i].dwServiceFlags1 &amp; 
         XP1_MESSAGE_ORIENTED))
    {
        s = WSASocket(FROM_PROTOCOL_INFO, FROM_PROTOCOL_INFO, 
            FROM_PROTOCOL_INFO, lpProtocolBuf[i], 0,
            WSA_FLAG_OVERLAPPED);
    }
}
</pre>
</td></tr></table>
</p>

<A NAME="132"><H2>Binding a Socket to an SAP</H2></A>

<p>ATM addresses are actually quite complicated because the 20 bytes they comprise contain many informational elements. Winsock application programmers need not worry about all the specific details of these elements with the exception of the last byte. The last byte in NSAP-style and E.164 addresses represents a selector value that uniquely allows your application to define and specify a particular SAP on an endpoint. As we described earlier, Winsock uses an SAP to form communication over an ATM network.</p>



<p>When Winsock applications want to communicate over ATM, a server application must register an SAP on an endpoint and wait for a client application to connect on the registered SAP. For a client application, this simply involves setting up a <i>SOCKADDR_ATM</i> structure with the <i>ATM_E164</i> or <i>ATM_NSAP</i> address type and supplying the ATM address associated with the server's SAP. To create an SAP to listen for connections, your application must first create a socket for the <i>AF_ATM</i> address family. Once the socket is created, your application must define a <i>SOCKADDR_ATM</i> structure using the <i>SAP_FIELD_ANY_AESA_SEL</i>, <i>SAP_FIELD_ANY_AESA_REST</i>, <i>ATM_E164</i>, or <i>ATM_NSAP</i> address type as defined in Table 6-2 on  168. For an ATM socket, an SAP will be created once your application calls the Winsock <i>bind</i> API function (which we describe in <a href="ch07a.htm">Chapter 7</A>), and these address types define how Winsock creates an SAP on your endpoint.</p>

<p>The address type <i>SAP_FIELD_ANY_AESA_SEL</i> tells Winsock to create an SAP that is capable of listening for any incoming ATM Winsock connection, which is known as wildcarding an ATM address and the selector. This means that only one socket can be bound to this endpoint listening for any connection&#8212;if another socket tries to bind with this address type, it will fail with Winsock error <i>WSAEADDRINUSE</i>. However, you can have another socket bound explicitly to your endpoint on a particular selector. The address type <i>SAP_FIELD_ANY_AESA_REST</i> can be used to create an SAP that is explicitly bound to a specified selector on an endpoint. This is known as wildcarding only the ATM address and not the selector. You can have only one socket at a time bound to a particular selector on an endpoint, or the <i>bind</i> call will fail with error <i>WSAEADDRINUSE</i>. When you use the <i>SAP_FIELD_ANY_AESA_SEL</i> type, you should specify an ATM address of all zeros in the <i>ATM_ADDRESS</i> structure. If
you use <i>SAP_FIELD_ANY_AESA_REST</i>, you should specify all zeros for the first 19 bytes of the ATM address and the last byte should indicate what selector number you plan to use.</p>

<p>Sockets that are bound to explicit selectors (<i>SAP_FIELD_ANY_AESA_REST</i>) take higher precedence than those sockets that are bound to a wildcarded selector (<i>SAP_FIELD_ANY_AESA_SEL</i>). Those sockets that are bound to explicit selectors (<i>SAP_FIELD_ANY_AESA_REST</i>) or explicit interfaces (<i>ATM_NSAP</i> and <i>ATM_E164</i>) will get first choice at connections. (That is, if a connection comes in on the endpoint and the selector that a socket is explicitly listening on, that socket gets the connection.) Only when no explicitly bound socket is available will a wildcarded selector socket get the connection. <a href="ch07a.htm">Chapter 7</A> further demonstrates how to set up a socket that listens for connections on an SAP.
</p>
<p>Finally, a utility named Atmadm.exe allows you to retrieve all ATM address and virtual connection information on an endpoint. This utility can be useful when you are developing an ATM application and need to know which interfaces are available on an endpoint. The command line options listed in the following table are available.</p>

<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th>Parameter </th><th>Description</th>
</tr>

<tr>
<td valign="top"> -c </td><td valign="top">List all connections (VC). Lists the remote address and the local interface.</td>
</tr>
<tr>
<td valign="top"> -a </td><td valign="top">Lists all registered addresses (i.e., all local ATM interfaces and their addresses).</td>
</tr>
<tr>
<td valign="top"> -s </td><td valign="top">Prints statistics (current number of calls, number of signaling and ILMI packets sent/received, etc.).</td>
</tr>
</table>
</p>

<A NAME="133"><H2>Name Resolution</H2></A>

<p>Currently no name providers are available for ATM under Winsock. This unfortunately requires applications to specify the 20-byte address ATM to establish socket communication over an ATM network. <A HREF="ch10a.htm">Chapter 10</A> discusses the Windows 2000 domain name space that can be generically used to register ATM addresses with user-friendly service names.</p>

</BODY>
</HTML>




