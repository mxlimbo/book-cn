<HTML>
<HEAD>
<TITLE>Basic Client/Server</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch03b.htm" , "ch03d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="48"><H1>Basic Client/Server</H1></A>

<p>As we mentioned earlier, mailslots feature a simple client/server design architecture in which data can flow only from a client to a server. The data communication model is one-way, or unidirectional. The server is responsible for creating a mailslot and is the only process that can read data from it. Mailslot clients are processes that open instances of mailslots and are the only processes that can write data to them.</p>

<A NAME="49"><H2>Mailslot Server Details</H2></A>

<p>Implementing a mailslot requires developing a server application to create a mailslot. The following steps describe how to write a basic server application:</p>

<ol>
<p><li>Create a mailslot handle using the <i>CreateMailslot</i> API function.</li></p>

<p><li>Receive data from any client by calling the <i>ReadFile</i> API function using the mailslot handle.</li></p>

<p><li>Close the mailslot handle using the <i>CloseHandle</i> API function.</li></p>
</ol>

<p>As you can see, very few API calls are needed to develop a mailslot server application.</p>

<p>Server processes create mailslots using the <i>CreateMailslot</i> API call, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
HANDLE CreateMailslot(
    LPCTSTR<i> lpName</i>,
    DWORD<i> nMaxMessageSize</i>, 
    DWORD<i> lReadTimeout</i>, 
    LPSECURITY_ATTRIBUTES<i> lpSecurityAttributes</i>
);
</pre>
</td></tr></table>
</p>

<p>The first parameter, <i>lpName</i>, specifies the name of the mailslot. The name must have the following form:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
\\.\Mailslot\[<i>path</i>]<i>name</i> 
</pre>
</td></tr></table>
</p>

<p>Notice that the server name is represented as a dot, which represents the local machine. This is required because you cannot create a mailslot on a remote computer. In the <i>lpName</i> parameter, name must represent a unique name. This might simply be a name, or a full directory path might precede it.</p>

<p>The <i>nMaxMessageSize</i> parameter defines the maximum size&#8212;in bytes&#8212;of a message that can be written to a mailslot. If a client writes more than <i>nMaxMessageSize</i> bytes, the server doesn't see the message. Specifying the value 0 allows the server to accept a message of any size.</p>

<p>Read operations can operate in blocking or nonblocking mode on a mailslot, depending on the <i>lReadTimeout</i> parameter, which determines the amount of time in milliseconds that read operations wait for incoming messages. Specifying the value <i>MAILSLOT_WAIT_FOREVER</i> allows read operations to block and wait indefinitely until incoming data is available to be read. If you specify 0, read operations return immediately. We will discuss details of reading later in this chapter. The <i>lpSecurityAttributes</i> parameter determines access control rights to a mailslot. On Windows 95 and 98, this parameter must be <i>NULL</i> because you cannot apply security to objects. On Windows NT and Windows 2000, this parameter is only partially implemented, so you should also specify a <i>NULL</i> parameter. The only security that you can enforce on a mailslot is for local I/O, in which a client attempts to open a mailslot with a dot (.) for the server name. A client can get around this security by specifying the server's actual name instead of a dot (.), as when making a remote I/O call. The <i>lpSecurityAttributes</i> parameter is not implemented for remote I/O on Windows NT and Windows 2000 because of the extreme inefficiency of forming an authenticated session between the client and the server every time a message is sent. Mailslots, therefore, only partially follow the Windows NT and Windows 2000 security model found in the standard file systems. As a consequence, any mailslot client on your network can send data to your server.</p>

<p>After a mailslot is created with a valid handle, you can begin reading data. The server is the only process that can read data from a mailslot. The server should use the Win32 <i>ReadFile</i> function to accomplish this. <i>ReadFile</i> is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL ReadFile(
    HANDLE<i> hFile</i>,
    LPVOID<i> lpBuffer</i>,
    DWORD<i> nNumberOfBytesToRead</i>, 
    LPDWORD<i> lpNumberOfBytesRead</i>, 
    LPOVERLAPPED<i> lpOverlapped</i>
);
</pre>
</td></tr></table>
</p>

<p><i>CreateMailslot</i> returns the handle <i>hFile</i>. The <i>lpBuffer</i> and <i>nNumberOfBytesToRead</i> parameters determine how much data can be read off a mailslot. It is important to make the size of this buffer greater than the <i>nMaxMessageSize</i> parameter from the <i>CreateMailslot</i> API call. Additionally, the buffer must be larger than incoming messages on the mailslot; if it is not larger, <i>ReadFile</i> will fail with the error <i>ERROR_INSUFFICIENT_BUFFER</i>. The <i>lpNumberOfBytesRead</i> parameter reports the actual number of bytes read when the <i>ReadFile</i> operation completes.</p>

<p>The <i>lpOverlapped</i> parameter provides a way to read data asynchronously off a mailslot. This parameter uses the Win32 overlapped I/O mechanism, which we describe in greater detail in <a href="ch04a.htm">Chapter 4</A>. By default, the <i>ReadFile</i> operation blocks (waits) on I/O until data is available for reading. Overlapped I/O can be accomplished only on Windows NT and Windows 2000; you should specify <i>NULL</i> for this parameter when using Windows 95 or Windows 98. Figure 3-1 further demonstrates how to write a simple mailslot server application.</p>

<p><b>Figure 3-1.</b> <i>Server mailslot example</i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
// Server1.cpp

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

void main(void)
{
    HANDLE Mailslot;
    char buffer[256];
    DWORD NumberOfBytesRead;

    // Create the mailslot
    if ((Mailslot = CreateMailslot(&quot;\\\\.\\Mailslot\\Myslot&quot;, 0,
        MAILSLOT_WAIT_FOREVER, NULL)) == INVALID_HANDLE_VALUE)
    {
        printf(&quot;Failed to create a mailslot %d\n&quot;, GetLastError());
        return;
    }

    // Read data from the mailslot forever!
    while(ReadFile(Mailslot, buffer, 256, &amp;NumberOfBytesRead,
        NULL) != 0)
    {
        printf(&quot;%.*s\n&quot;, NumberOfBytesRead, buffer);
    }
}
</pre>
</td></tr></table>
</p>

<A NAME="50"><H2>Mailslot Client Details</H2></A>

<p>Implementing a client requires developing an application to reference and write to an existing mailslot. The following steps describe how to write a basic client application:</p>

<ol>
<p><li>Open a reference handle to the mailslot we want to send data to using the <i>CreateFile</i> API.</li></p>

<p><li>Write data to the mailslot by calling the <i>WriteFile</i> API.</li></p>

<p><li>Once you are finished writing data, close the mailslot handle using the <i>CloseHandle</i> API.</li></p>
</ol>

<p>As we described earlier, mailslot clients communicate to mailslot servers in a connectionless manner. When a client opens a reference handle to a mailslot, the client does not form a connection to the mailslot server. Mailslots are referenced by using the <i>CreateFile</i> API call, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
HANDLE CreateFile(
    LPCTSTR<i> lpFileName</i>,
    DWORD<i> dwDesiredAccess</i>,
    DWORD<i> dwShareMode</i>, 
    LPSECURITY_ATTRIBUTES<i> lpSecurityAttributes</i>, 
    DWORD<i> dwCreationDisposition</i>, 
    DWORD<i> dwFlagsAndAttributes</i>, 
    HANDLE<i> hTemplateFile</i>
);
</pre>
</td></tr></table>
</p>

<p>The <i>lpFileName</i> parameter describes one or more mailslots that can be written to by using the mailslot name format described earlier in this chapter. Table 3-2 describes mailslot naming conventions in greater detail. The <i>dwDesiredAccess</i> parameter must be set to <i>GENERIC_WRITE</i> because a client can only write data to the server. The <i>dwShareMode</i> parameter must be set to <i>FILE_SHARE_READ</i>, allowing the server to open and perform read operations on the mailslot. The <i>lpSecurityAttributes</i> parameter has no effect on mailslots and should be set to <i>NULL</i>. The <i>dwCreationDisposition</i> flag should be set to <i>OPEN_EXISTING</i>. This setting is useful when a client and a server are operating on the same machine: If the server has not created the mailslot, the <i>CreateFile</i> API function fails. The <i>dwCreationDisposition</i> parameter has no effect if the server is operating remotely. The <i>dwFlagsAndAttributes</i> parameter should be defined as <i>FILE_ATTRIBUTE_NORMAL</i>. The <i>hTemplateFile</i> parameter should be set to <i>NULL</i>.</p>

<p><b>Table 3-2.</b> <i>Mailslot name types</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th><i>Name Format</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top">\\.\mailslot\name</td>
			<td valign="top">Identifies a local mailslot on the same machine</td>
		</tr>

		<tr>
			<td valign="top">\\servername\mailslot\name</td>
			<td valign="top">Identifies a remote mailslot server named <i>servername</i></td>
		</tr>

		<tr>
			<td valign="top">\\domainname\mailslot\name</td>
			<td valign="top">Identifies all mailslots of a particular <i>name</i> in the specified <i>domain</i></td>
		</tr>

		<tr>
			<td valign="top">\\*\mailslot\name</td>
			<td valign="top">Identifies all mailslots of a particular <i>name</i> in the system's primary domain</td>
		</tr>
		
	</table>
</p>

<p>After a handle has been successfully created, you can begin writing data to a mailslot. Remember, a client can only write data to the mailslot. This can be accomplished using the Win32 <i>WriteFile</i> function, defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL WriteFile(
    HANDLE<i> hFile</i>,
    LPCVOID<i> lpBuffer</i>,
    DWORD<i> nNumberOfBytesToWrite</i>,
    LPDWORD<i> lpNumberOfBytesWritten</i>,
    LPOVERLAPPED<i> lpOverlapped</i>
);
</pre>
</td></tr></table>
</p>

<p>The <i>hFile</i> parameter is the reference handle that <i>CreateFile</i> returns. The <i>lpBuffer</i> and <i>nNumberOfBytesToWrite</i> parameters determine how many bytes will be sent from the client to the server. The maximum size of a message is 64 KB. If the mailslot handle was created using a domain or asterisk format, the message size is limited to 424 bytes on Windows NT and Windows 2000 and 64 KB on Windows 95 and Windows 98. If a client attempts to send a message that exceeds those limits, the <i>WriteFile</i> function fails and the <i>GetLastError</i> function returns <i>ERROR_BAD_NETPATH</i>. This happens because the message is sent as a broadcast datagram to all servers on the network. The <i>lpNumberOfBytesWritten</i> parameter returns the number of bytes sent to a server when the <i>WriteFile</i> operation completes.</p>

<p>The <i>lpOverlapped</i> parameter provides a way to write data asynchronously to a mailslot. Since mailslots feature connectionless data transfer, the <i>WriteFile</i> function is not subject to blocking on I/O calls. This parameter should be set to <i>NULL</i> on the client. Figure 3-2 further demonstrates how to write a simple mailslot client application.</p>

<p><b>Figure 3-2.</b> <i>Client mailslot example</i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
// Client.cpp

#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;

void main(int argc, char *argv[])
{
    HANDLE Mailslot;
    DWORD BytesWritten;
    CHAR ServerName[256];

    // Accept a command line argument for the server to send
    // a message to
    if (argc &lt; 2)
    {
        printf(&quot;Usage: client &lt;server name&gt;\n&quot;);
        return;
    }

    sprintf(ServerName, &quot;\\\\%s\\Mailslot\\Myslot&quot;, argv[1]);

    if ((Mailslot = CreateFile(ServerName, GENERIC_WRITE,
        FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
        NULL)) == INVALID_HANDLE_VALUE)
    {
        printf(&quot;CreateFile failed with error %d\n&quot;, GetLastError());
        return;
    }

    if (WriteFile(Mailslot, &quot;This is a test&quot;, 14, &amp;BytesWritten, 
        NULL) == 0)
    {
        printf(&quot;WriteFile failed with error %d\n&quot;, GetLastError());
        return;
    }

    printf(&quot;Wrote %d bytes\n&quot;, BytesWritten);

    CloseHandle(Mailslot);
}
</pre>
</td></tr></table>
</p>

</BODY>
</HTML>




