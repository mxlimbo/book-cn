<HTML>
<HEAD>
<TITLE>AppleTalk</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06e.htm" , "ch06g.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="124"><H1>AppleTalk</H1></A>

<p>AppleTalk support in Winsock has been around for a while, although few people are aware of it. AppleTalk probably won't be a protocol you choose to use unless you are communicating with Macintosh computers. AppleTalk is somewhat similar to NetBIOS in that it is name-based on a per-process basis. That is, a server dynamically registers a particular name that it will be known as. Clients use this name to establish a connection. However, AppleTalk names are substantially more complicated than NetBIOS names. The next section will discuss how computers using the AppleTalk protocol are addressed on the network.</p>

<A NAME="125"><H2>Addressing</H2></A>

<p>An AppleTalk name is actually based on three separate names: the name, the type, and the zone. Each name can be up to 32 characters in length. The name identifies the process and its associated socket on a machine. The type is a subgrouping mechanism for zones. Traditionally, a zone is a network of AppleTalk-enabled computers physically located on the same loop. Microsoft's implementation of AppleTalk allows a Windows machine to specify the default zone it is located within. Multiple networks can be bridged together. These human-friendly names map to a socket number, a node number, and a network number. An AppleTalk name must be unique within the given type and zone. This requirement is enforced by the Name Binding Protocol (NBP), which broadcasts a query to see whether the name is already in use. Under the hood, AppleTalk uses the Routing Table Maintenance Protocol (RTMP) to dynamically discover routes to the different AppleTalk networks linked together.</p>

<p>The following structure provides the basis for addressing AppleTalk hosts from Winsock:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct sockaddr_at
{
    USHORT  sat_family;
    USHORT  sat_net;
    UCHAR   sat_node;
    UCHAR   sat_socket;
} SOCKADDR_AT, *PSOCKADDR_AT;
</pre>
</td></tr></table>
</p>

<p>Notice that the address structure contains only characters or short integers and not friendly names. The <i>SOCKADDR_AT</i> structure is passed into Winsock calls such as <i>bind</i>, <i>connect</i>, and <i>WSAConnect</i>, but in order to translate the human-readable names you must query the network to either resolve or register that name first. This is done by using a call to <i>getsockopt</i> or <i>setsockopt</i>, respectively.</p>

<A NAME="126"><H3>Registering an AppleTalk name</H3></A>

<p>A server that wants to register a particular name so that clients can easily connect to it calls <i>setsockopt</i> with the <i>SO_REGISTER_NAME</i> option. For all socket options involving AppleTalk names, use the <i>WSH_NBP_NAME</i> structure, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct
{
    CHAR    ObjectNameLen;
    CHAR    ObjectName[MAX_ENTITY];
    CHAR    TypeNameLen;
    CHAR    TypeName[MAX_ENTITY];
    CHAR    ZoneNameLen;
    CHAR    ZoneName[MAX_ENTITY];
} WSH_NBP_NAME, *PWSH_NBP_NAME;
</pre>
</td></tr></table>
</p>

<p>A number of types&#8212;such as <i>WSH_REGISTER_NAME</i>, <i>WSH_DEREGISTER_NAME</i>, and <i>WSH_REMOVE_NAME</i>&#8212;are defined based on the <i>WSH_NBP_NAME</i> structure. Using the appropriate type depends on whether you look up a name, register a name, or remove a name.</p>

<p>The following code sample illustrates how to register an AppleTalk name.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
#define MY_ZONE    &quot;*&quot;
#define MY_TYPE    &quot;Winsock-Test-App&quot;
#define MY_OBJECT    &quot;AppleTalk-Server&quot;

WSH_REGISTER_NAME    atname;
SOCKADDR_AT          ataddr;
SOCKET               s;
//
// Fill in the name to register
//
strcpy(atname.ObjectName, MY_OBJECT);
atname.ObjectNameLen = strlen(MY_OBJECT);
strcpy(atname.TypeName, MY_TYPE);
atname.TypeNameLen = strlen(MY_TYPE);
strcpy(atname.ZoneName, MY_ZONE);
atname.ZoneNameLen = strlen(MY_ZONE);

s = socket(AF_APPLETALK, SOCK_STREAM, ATPROTO_ADSP);
if (s == INVALID_SOCKET)
{
    // Error
}
ataddr.sat_socket = 0;
ataddr.sat_family = AF_APPLETALK;
if (bind(s, (SOCKADDR *)&amp;ataddr, sizeof(ataddr)) == SOCKET_ERROR)
{
    // Unable to open an endpoint on the AppleTalk network
}
if (setsockopt(s, SOL_APPLETALK, SO_REGISTER_NAME,
               (char *)&amp;atname, sizeof(WSH_NBP_NAME)) == SOCKET_ERROR)
{
    // Name registration failed!
}
</pre>
</td></tr></table>
</p>

<p>The first thing you'll notice is the <i>MY_ZONE</i>, <i>MY_TYPE</i>, and <i>MY_OBJECT</i> strings. Remember that an AppleTalk name is three-tiered. Notice that the zone is an asterisk (*). This is a special character used in the zone field to specify the &quot;current&quot; zone the computer is located in. Next we create a socket of type <i>SOCK_STREAM</i> of the AppleTalk protocol ADSP. Following socket creation, you'll notice a call to the <i>bind</i> function with an address structure that has a zeroed-out <i>sat_socket</i> field and only the protocol family field set. This is important because it creates an endpoint on the AppleTalk network for your application to make requests from. Note that while this call to <i>bind</i> allows you to perform simple actions on the network, it doesn't by itself allow your application to accept incoming connection requests from clients. To accept client connections, you must register your name on the network, which is the next step.</p>

<p>Registering an AppleTalk name is simple. Make the call to <i>setsockopt</i> by passing <i>SOL_APPLETALK</i> as the <i>level</i> parameter and <i>SO_REGISTER_NAME</i> as the <i>optname</i> parameter. The last two parameters are a pointer to our <i>WSH_REGISTER_NAME</i> structure and its size. If the call succeeds, our server name was successfully registered. If the call fails, the requested name is probably already in use by someone else. The Winsock error returned is <i>WSAEADDRINUSE</i> (10048 or 0x02740h). Note that for both datagram-oriented and stream-oriented AppleTalk protocols, a process that wants to receive data must register a name that clients can either send datagrams to or connect to.</p>

<A NAME="127"><H3>Resolving an AppleTalk name</H3></A>

<p>On the client side of the equation, an application usually knows a server by its friendly name and must resolve that into the network, node, and socket numbers used by Winsock calls. This is accomplished by calling <i>getsockopt</i> with the <i>SO_LOOKUP_NAME</i> option. Performing a name lookup relies on the <i>WSH_LOOKUP_NAME</i> structure. This structure and its dependent structure are defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct
{
    WSH_ATALK_ADDRESS   Address;
    USHORT              Enumerator;
    WSH_NBP_NAME        NbpName;
} WSH_NBP_TUPLE, *PWSH_NBP_TUPLE;

typedef struct _WSH_LOOKUP_NAME
{
    //  Array of NoTuple WSH_NBP_TUPLEs
    WSH_NBP_TUPLE       LookupTuple;
    ULONG               NoTuples;
} WSH_LOOKUP_NAME, *PWSH_LOOKUP_NAME;
</pre>
</td></tr></table>
</p>

<p>When we call <i>getsockopt</i> with the <i>SO_LOOKUP_NAME</i> option, we pass a buffer cast as a <i>WSH_LOOKUP_NAME</i> structure and fill in the <i>WSH_NBP_NAME</i> field within the first <i>LookupTuple</i> member. Upon a successful call, <i>getsockopt</i> returns an array of <i>WSH_NBP_TUPLE</i> elements containing physical address information for that name. Figure 6-1 contains the file Atalknm.c<i>,</i> which illustrates how to look up a name. In addition, it shows how to list all &quot;discovered&quot; AppleTalk zones and how to find your default zone. Zone information can be obtained by using the <i>getsockopt</i> options <i>SO_LOOKUP_ZONES</i> and <i>SO_LOOKUP_MYZONE</i>.</p>

<p><b>Figure 6-1.</b> <i> AppleTalk name and zone lookup</i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
#include &lt;winsock.h&gt;
#include &lt;atalkwsh.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define DEFAULT_ZONE       &quot;*&quot;
#define DEFAULT_TYPE       &quot;Windows Sockets&quot;
#define DEFAULT_OBJECT     &quot;AppleTalk-Server&quot;

char szZone[MAX_ENTITY],
     szType[MAX_ENTITY],
     szObject[MAX_ENTITY];

BOOL bFindName = FALSE,
     bListZones = FALSE,
     bListMyZone = FALSE;

void usage()
{
    printf(&quot;usage: atlookup [options]\n&quot;);
    printf(&quot;         Name Lookup:\n&quot;);
    printf(&quot;           -z:ZONE-NAME\n&quot;);
    printf(&quot;           -t:TYPE-NAME\n&quot;);
    printf(&quot;           -o:OBJECT-NAME\n&quot;);
    printf(&quot;         List All Zones:\n&quot;);
    printf(&quot;           -lz\n&quot;);
    printf(&quot;         List My Zone:\n&quot;);
    printf(&quot;           -lm\n&quot;);
    ExitProcess(1);
}

void ValidateArgs(int argc, char **argv)
{
    int                i;

    strcpy(szZone, DEFAULT_ZONE);
    strcpy(szType, DEFAULT_TYPE);
    strcpy(szObject, DEFAULT_OBJECT);

    for(i = 1; i &lt; argc; i++)
    {
        if (strlen(argv[i]) &lt; 2)
            continue;
        if ((argv[i][0] == '-') || (argv[i][0] == '/'))
        {
            switch (tolower(argv[i][1]))
            {
                case 'z':        // Specify a zone name
                    if (strlen(argv[i]) &gt; 3)
                        strncpy(szZone, &amp;argv[i][3], MAX_ENTITY);
                    bFindName = TRUE;
                    break;
                case 't':        // Specify a type name
                    if (strlen(argv[i]) &gt; 3)
                        strncpy(szType, &amp;argv[i][3], MAX_ENTITY);
                    bFindName = TRUE;
                    break;
                case 'o':        // Specify an object name
                    if (strlen(argv[i]) &gt; 3)
                        strncpy(szObject, &amp;argv[i][3], MAX_ENTITY);
                    bFindName = TRUE;
                    break;
                case 'l':        // List zones information
                    if (strlen(argv[i]) == 3)
                        // List all zones
                        if (tolower(argv[i][2]) == 'z')
                            bListZones = TRUE;
                        // List my zone
                        else if (tolower(argv[i][2]) == 'm')
                            bListMyZone = TRUE;
                    break;
                default:
                    usage();
            }
        }
    }
}

int main(int argc, char **argv)
{
    WSADATA              wsd;
    char                 cLookupBuffer[16000],
                        *pTupleBuffer = NULL;
    PWSH_NBP_TUPLE       pTuples = NULL;
    PWSH_LOOKUP_NAME     atlookup;
    PWSH_LOOKUP_ZONES    zonelookup;
    SOCKET               s;
    DWORD                dwSize = sizeof(cLookupBuffer);
    SOCKADDR_AT          ataddr;
    int                  i;

    // Load the Winsock library
    //
    if (WSAStartup(MAKEWORD(2, 2), &amp;wsd) != 0)
    {
        printf(&quot;Unable to load Winsock library!\n&quot;);
        return 1;
    }

    ValidateArgs(argc, argv);

    atlookup = (PWSH_LOOKUP_NAME)cLookupBuffer;
    zonelookup = (PWSH_LOOKUP_ZONES)cLookupBuffer;
    if (bFindName)


    {
        // Fill in the name to look up
        //
        strcpy(atlookup-&gt;LookupTuple.NbpName.ObjectName, szObject);
        atlookup-&gt;LookupTuple.NbpName.ObjectNameLen = 
            strlen(szObject);
        strcpy(atlookup-&gt;LookupTuple.NbpName.TypeName, szType);
        atlookup-&gt;LookupTuple.NbpName.TypeNameLen = strlen(szType);
        strcpy(atlookup-&gt;LookupTuple.NbpName.ZoneName, szZone);
        atlookup-&gt;LookupTuple.NbpName.ZoneNameLen = strlen(szZone);
    }
    // Create the AppleTalk socket
    // 
    s = socket(AF_APPLETALK, SOCK_STREAM, ATPROTO_ADSP);
    if (s == INVALID_SOCKET)
    {
        printf(&quot;socket() failed: %d\n&quot;, WSAGetLastError());
        return 1;
    }
    // We need to bind in order to create an endpoint on the
    // AppleTalk network to make our query from
    //
    ZeroMemory(&amp;ataddr, sizeof(ataddr));
    ataddr.sat_family = AF_APPLETALK; 
    ataddr.sat_socket = 0;
    if (bind(s, (SOCKADDR *)&amp;ataddr, sizeof(ataddr)) == 
            INVALID_SOCKET)
    {
        printf(&quot;bind() failed: %d\n&quot;, WSAGetLastError());
        return 1;
    }

    if (bFindName)
    {
        printf(&quot;Looking up: %s:%s@%s\n&quot;, szObject, szType, szZone);
        if (getsockopt(s, SOL_APPLETALK, SO_LOOKUP_NAME,
                   (char *)atlookup, &amp;dwSize) == INVALID_SOCKET)
        {
            printf(&quot;getsockopt(SO_LOOKUP_NAME) failed: %d\n&quot;,
                WSAGetLastError());
            return 1;
        }
        printf(&quot;Lookup returned: %d entries\n&quot;, 
            atlookup-&gt;NoTuples);
        //
        // Our character buffer now contains an array of 
        // WSH_NBP_TUPLE structures after our WSH_LOOKUP_NAME 
        // structure
        //
        pTupleBuffer = (char *)cLookupBuffer + 
            sizeof(WSH_LOOKUP_NAME);
        pTuples = (PWSH_NBP_TUPLE) pTupleBuffer;
    
        for(i = 0; i &lt; atlookup-&gt;NoTuples; i++)
        {
            ataddr.sat_family = AF_APPLETALK;
            ataddr.sat_net    = pTuples[i].Address.Network;
            ataddr.sat_node   = pTuples[i].Address.Node;
            ataddr.sat_socket = pTuples[i].Address.Socket;
            printf(&quot;server address = %lx.%lx.%lx.\n&quot;, 
                ataddr.sat_net, 
                ataddr.sat_node, 
                ataddr.sat_socket); 
        } 
    }
    else if (bListZones)
    {
        // It is very important to pass a sufficiently big buffer 
        // for this option. Windows NT 4 SP3 blue screens if it 
        // is too small.
        //
        if (getsockopt(s, SOL_APPLETALK, SO_LOOKUP_ZONES,
                   (char *)atlookup, &amp;dwSize) == INVALID_SOCKET)
        {
            printf(&quot;getsockopt(SO_LOOKUP_NAME) failed: %d\n&quot;,
                WSAGetLastError());
            return 1;
        }
        printf(&quot;Lookup returned: %d zones\n&quot;, zonelookup-&gt;NoZones);
        //
        // The character buffer contains a list of null-separated
        //  strings after the WSH_LOOKUP_ZONES structure
        //
        pTupleBuffer = (char *)cLookupBuffer + 
            sizeof(WSH_LOOKUP_ZONES);
        for(i = 0; i &lt; zonelookup-&gt;NoZones; i++)
        {
            printf(&quot;%3d: '%s'\n&quot;, i+1, pTupleBuffer);
            while (*pTupleBuffer++);
        } 
    }
    else if (bListMyZone)
    {
        // This option returns a simple string
        //



        if (getsockopt(s, SOL_APPLETALK, SO_LOOKUP_MYZONE,
                (char *)cLookupBuffer, &amp;dwSize) == INVALID_SOCKET)
        {
            printf(&quot;getsockopt(SO_LOOKUP_NAME) failed: %d\n&quot;,
                WSAGetLastError());
            return 1;
        }
        printf(&quot;My Zone: '%s'\n&quot;, cLookupBuffer);
    }
    else
        usage();

    WSACleanup();

    return 0;
}
</pre>
</td></tr></table>
</p>

<p>When you are using most of the AppleTalk socket options&#8212;such as <i>SO_LOOKUP_MYZONE</i>, <i>SO_LOOKUP_ZONES</i>, and <i>SO_LOOKUP_NAME</i>&#8212;you need to provide a large character buffer to the <i>getsockopt</i> call. If you call an option that requires you to provide a structure, that structure needs to be at the start of the supplied character buffer. If the call to <i>getsockopt</i> is successful, the function places return data in the character buffer after the end of the supplied structure. Take a look at the <i>SO_LOOKUP_NAME</i> section in Figure 6-1. The variable <i>cLookupBuffer</i> is a simple character array used in the call to <i>getsockopt</i>. First we cast it as a <i>PWSH_LOOKUP_NAME</i> and fill in the name information we want to find. We pass the buffer into <i>getsockopt</i>, and upon return, we increment the character pointer <i>pTupleBuffer</i> so that it points to the character after the end of the <i>WSH_LOOKUP_NAME</i> structure. Next we cast that pointer to a variable of <i>
PWSH_NBP_TUPLE</i> because the data returned from a lookup name call is an array of <i>WSH_NBP_TUPLE</i> structures. Once we have the proper starting location and type of the tuples, we can walk through the array. <a href="ch09a.htm">Chapter 9</A> contains more in-depth information about the various socket options specific to the AppleTalk address family.</p>

<A NAME="128"><H2>Creating a Socket</H2></A>

<p>AppleTalk is available in Winsock 1.1 and later, so you can use either socket-creation routine. 
Again, you have two options of how to specify the underlying AppleTalk protocols. First you can supply 
the corresponding define from <i>Atalkwsh.h</i> for the protocol you want, or you can enumerate the 
protocols using <i>WSAEnumProtocols</i> and passing the <i>WSAPROTOCOL_INFO</i> structure. Table 6-1 
lists the required parameters for each AppleTalk protocol type when you create a socket directly using 
<i>socket</i> or <i>WSASocket</i>.</p>

<p><b>Table 6-1.</b>  <i>AppleTalk protocols and parameters</i></p>

<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th>Protocol </th><th>Address Family </th><th>Socket Type </th><th>Protocol Type</th>
</tr>
<tr>
<td valign="top">MSAFD AppleTalk [ADSP]</td> <td valign="top"></td>
<td valign="top"><i>SOCK_RDM</i> </td><td valign="top"><i>ATPROTO_ADSP</i></td>
</tr>
<tr>
<td valign="top">MSAFD AppleTalk [ADSP] [Pseudo-Stream]</td><td valign="top"></td>
<td valign="top"><i>SOCK_STREAM</i> </td><td valign="top"><i>ATPROTO_ADSP</i></td>
</tr>
<tr>
<td valign="top"></td><td valign="top"> <i>AF_APPLETALK</i> </td>
<td valign="top"></td><td valign="top"></td>
</tr>
<tr>
<td valign="top">MSAFD AppleTalk [PAP]</td><td valign="top"></td>
<td valign="top"><i>SOCK_RDM</i></td><td valign="top"> <i>ATPROTO_PAP</i></td>
</tr>
<tr>
<td valign="top">MSAFD AppleTalk [RTMP]</td> <td valign="top"></td>
<td valign="top"><i>SOCK_DGRAM</i> </td><td valign="top"><i>DDPPROTO_RTMP</i></td>
</tr>
<tr>
<td valign="top">MSAFD AppleTalk [ZIP]</td><td valign="top"></td> 
<td valign="top"><i>SOCK_DGRAM</i> </td><td valign="top"><i>DDPPROTO_ZIP</i></td>
</tr>
</table>
</p>

</BODY>
</HTML>




