<HTML>
<HEAD>
<TITLE>Name Space Service Providers</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch14c.htm" , "ch14e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="435"><H1>Name Space Service Providers</H1></A>

<p>In <A HREF="ch10a.htm">Chapter 10</A>, we showed you how an application can register and resolve services within a name space, which is an especially powerful feature for services that might be dynamically created on the network. Unfortunately, the existing name spaces available are limited in their usefulness. The Winsock 2 specification, however, provides a method for creating your own name spaces in which you can handle name registration and resolution in whatever manner you prefer.</P>

<P>This is accomplished by creating a DLL that implements the nine name space functions. These functions all begin with the NSP prefix and are companions to the RNR functions from <A HREF="ch10a.htm">Chapter 10</A>. For example, the name space function equivalent to <i>WSASetService</i> is <i>NSPSetService</i>. After the DLL is created, it is then installed into the system catalog with a GUID that identifies the name space. Once this is done, applications can register and query services in your name space.</P>

<P>In this section, we'll first present how to install a name space provider, and then we'll describe the functions a name space provider must implement. Finally, we'll present a sample name space provider as well as a sample application that registers and resolves services.</p>

<A NAME="436"><H2>Installing a Name Space Provider</H2></A>

<p>A name space provider is simply a DLL that implements the name space provider functions. Before applications can use a name space, you must make the system aware of it via the <i>WSCInstallNameSpace</i> function. Conversely, once a provider is installed, you can either disable the provider or remove the provider altogether from the system catalog using the functions <i>WSAEnableNSProvider</i> and <i>WSAUnInstallNameSpace</i>, respectively. We will describe each of these functions next.</p>

<A NAME="437"><h3><i>WSCInstallNameSpace</i></h3></A>
<p>This function is used to install a provider into the system catalog and is declared as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSCInstallNameSpace ( 
    LPWSTR lpszIdentifier, 
    LPWSTR lpszPathName, 
    DWORD dwNameSpace, 
    DWORD dwVersion, 
    LPGUID lpProviderId 
);
</pre>
</td></tr></table>
</p>

<p>The first thing that you will notice is that all string parameters are wide character strings. Actually, all name space providers are implemented using wide character strings. We'll talk more about this later. The <i>lpszIdentifier</i> parameter is the name of the name space provider. This is the name that is enumerated when you call <i>WSAEnumNameSpaceProviders</i>, which we saw in <A HREF="ch10a.htm">Chapter 10</A>. The <i>lpszPathName</i> parameter is the location of the DLL. The string can include environment variables, such as %SystemRoot%. The <i>dwNameSpace</i> parameter is a numeric identifier for the name space. For example, the header file Nspapi.h defines constants for other well-known name spaces, such as <i>NS_SAP</i> for IPX SAP. The <i>dwVersion</i> parameter sets the version number for the name space. Finally, <i>lpProviderId</i> is a GUID that identifies the name space provider.</p>

<p>Upon success, <i>WSCInstallNameSpace</i> returns 0; upon failure, the function returns <i>SOCKET_ERROR</i>. The most common failures are <i>WSAEINVAL</i>, which indicates that a name space with that GUID already exists; and <i>WSAEACCESS</i>, which indicates that the calling process does not have sufficient privilege. Only users of the Administrators group can install a name space.</p>

<A NAME="438"><h3><i>WSCEnableNSProvider</i></h3></A>
<p>This function is used to modify the state of a name space provider. It can be used to enable or disable the provider. The function is declared as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSCEnableNSProvider ( 
    LPGUID lpProviderId,
    BOOL fEnable
); 
</pre>
</td></tr></table>
</p>

<p>The <i>lpProviderId</i> parameter is the GUID identifier for the name space that you want to modify. The <i>fEnable</i> parameter is a Boolean value indicating you should either enable or disable the provider. A disabled provider is unable to process queries or registrations.</p>

<p>Upon success, <i>WSCEnableNSProvider</i> returns 0; upon failure, the function returns <i>SOCKET_ERROR</i>. If the provider GUID is invalid, <i>WSAEINVAL</i> is returned.</p>

<A NAME="439"><h3><i>WSCUninstallNameSpace</i></h3></A>
<p>This function removes a name space provider from the catalog. The function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSCUnInstallNameSpace ( LPGUID lpProviderId ); 
</pre>
</td></tr></table>
</p>

<p>The <i>lpProviderId</i> parameter is the GUID for the name space to remove. If the GUID is invalid, the function fails with <i>WSAEINVAL</i>.</p>

<A NAME="440"><H2>Implementing a Name Space</H2></A>

<p>A name space must implement all nine name space functions that map to the RNR functions covered in <A HREF="ch10a.htm">Chapter 10</A>. In addition to implementing these functions, you must also develop a method for persisting the data. That is, you must maintain the data beyond the instance of the DLL. Each process that loads the DLL receives its own data segment, which means that data stored within the DLL cannot be shared between instances. (Actually, it is possible to share information between multiple applications that have loaded the DLL, but this practice is discouraged.) See <i>Programming Applications for Microsoft Windows, 4th ed.</i>, by Jeffrey Richter (Microsoft Press, 1999) for more information on DLLs. Remember from <A HREF="ch10a.htm">Chapter 10</A> that there are three types of name spaces: dynamic, persistent, and static. Obviously, implementing a static name space might not be a good idea since it disallows programmatic registration of services. Later in this chapter, we'll present some ideas on how to maintain the data that the
name space needs to persist.</p>

<p>You must also understand the importance of using wide character strings in all name space provider functions. This not only includes string parameters to functions but also strings within the RNR structures, such as <i>WSAQUERYSET</i> and <i>WSASERVICECLASSINFO</i>. You might be wondering how this is possible since when an application registers or resolves a name it can use either the normal (ASCII) or the wide character (UNICODE) version of the RNR functions and structure. The answer is that either version works because all ASCII calls go through an intermediate layer that converts all strings to wide character strings. This is true upon function call and return. That is, if <i>WSAQUERYSET</i> is returned to the calling application&#8212;as with <i>WSALookupServiceNext</i>&#8212;any data returned by the name space provider is originally UNICODE and is converted to ASCII before returning from the function call. That said, you can see that if your application uses RNR functions, calling the wide character
versions will be faster since no conversions are required.</p>

<p>Of the nine functions that a name space provider must implement, only seven of the functions map to Winsock 2 RNR functions, as shown in Table 14-3. The remaining two functions are for initialization and cleanup. Once the name space is installed into the system, applications can utilize the name space by specifying either the GUID under which the name space was installed or the name space identifier that is also specified during installation. An application then makes calls to the standard Winsock 2 RNR function, as described in <A HREF="ch10a.htm">Chapter 10</A>. When one of these functions is called, the equivalent name space provider function is invoked. For example, when an application calls <i>WSAInstallServiceClass</i>, which references the GUID for a custom name space, the function <i>NSPInstallServiceClass</i> for that provider is invoked. In the next section, we'll cover each of the name space functions.</p>

<P><b>Table 14-3.</b> <i>Mapping Winsock 2 registration and name resolution functions to name space provider functions</i></p>


<table cellpadding="5" border="0" width="95%">
<tr><th><i>Winsock Function</i></TH><TH><i>Equivalent Name Space Provider Function</i></TH></TR>
<tr><td valign="top"><i>WSAInstallServiceClass</i></td><td valign="top"><i>NSPInstallServiceClass</i></td></tr>
<tr><td valign="top"><i>WSARemoveServiceClass</i></td><td valign="top"><i>NSPRemoveServiceClass</i></td></tr>
<tr><td valign="top"><i>WSAGetServiceClassInfo</i></td><td valign="top"><i>NSPGetServiceClassInfo</i></td></tr>
<tr><td valign="top"><i>WSASetService</i></td><td valign="top"><i>NSPSetService</i></td></tr>
<tr><td valign="top"><i>WSALookupServiceBegin</i></td><td valign="top"><i>NSPLookupServiceBegin</i></td></tr>
<tr><td valign="top"><i>WSALookupServiceNext</i></td><td valign="top"><i>NSPLookupServiceNext</i></td></tr>
<tr><td valign="top"><i>WSALookupServiceEnd</i></td><td valign="top"><i>NSPLookupServiceEnd</i></td></tr>
</table>

<A NAME="441"><h3><i>NSPStartup</i></h3></A>
<p>The <i>NSPStartup</i> function is called whenever the name space provider DLL is loaded. Your name space implementation <i>must</i> include this function, and it must be exported from the DLL. Any per-DLL data structures required for the provider to operate can be allocated when this function is called. <i>NSPStartup</i> is prototyped as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int NSPStartup ( 
    LPGUID lpProviderId, 
    LPNSP_ROUTINE lpnspRoutines 
); 
</pre>
</td></tr></table>
</p>

<p>The first parameter, <i>lpProviderId</i>, is the GUID for this name space provider. The <i>lpnspRoutines</i> parameter is an <i>NSP_ROUTINE</i> structure that your implementation of this function must fill out. This structure provides function pointers to the other eight name space functions that belong to your provider. The <i>NSP_ROUTINE</i> object is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _NSP_ROUTINE 
{
    DWORD                    cbSize;
    DWORD                    dwMajorVersion;
    DWORD                    dwMinorVersion;
    LPNSPCLEANUP             NSPCleanup;
    LPNSPLOOKUPSERVICEBEGIN  NSPLookupServiceBegin;
    LPNSPLOOKUPSERVICENEXT   NSPLookupServiceNext;
    LPNSPLOOKUPSERVICEEND    NSPLookupServiceEnd;
    LPNSPSETSERVICE          NSPSetService;
    LPNSPINSTALLSERVICECLASS NSPInstallServiceClass;
    LPNSPREMOVESERVICECLASS  NSPRemoveServiceClass;
    LPNSPGETSERVICECLASSINFO NSPGetServiceClassInfo;
} NSP_ROUTINE, FAR * LPNSP_ROUTINE;
</pre>
</td></tr></table>
</p>

<p>The first field of the structure, <i>cbSize</i>, indicates the size of the <i>NSP_ROUTINE</i> structure. The next two fields, <i>dwMajorVersion</i> and <i>dwMinorVersion</i>, are included for versioning your provider. The versioning is arbitrary and serves no other purpose. The provider sets the rest of the entries to their respective function pointers. For example, the provider assigns its <i>NSPSetService</i> function address (no matter what it is named) to the <i>NSPSetService</i> field. The names of your provider functions can be arbitrary, but their parameters and return types must match the provider definition.</p>

<p>The only action required of an <i>NSPStartup</i> implementation is filling in the <i>NSP_ROUTINE</i> structure. Once the provider completes this and any other initialization routines of its own, it returns <i>NO_ERROR</i> if everything is successful. If an error occurs, the <i>NSPStartup</i> implementation returns <i>SOCKET_ERROR</i> and sets the Winsock error code. For example, if a provider attempts and fails to allocate memory, it calls <i>WSASetLastError</i> with <i>WSA_NOT_ENOUGH_MEMORY</i> as the parameter and then returns <i>SOCKET_ERROR</i>.</p>

<p>This might be a good time to discuss error handling in your provider's DLL. All of the functions you must implement for a provider return <i>NO_ERROR</i> upon success and <i>SOCKET_ERROR</i> upon failure. If you determine that the call fails, set the appropriate Winsock error code before returning. If you fail to do this, any application attempting to register or query services using your name space provider will report the failure of an RNR function but <i>WSAGetLastError</i> will return 0. This will cause tremendous trouble for applications that attempt to handle errors gracefully; 0 is certainly not an expected return value upon error.</p>

<A NAME="442"><h3><i>NSPCleanup</i></h3></A>
<p>This routine is called when the provider's DLL is unloaded. Within this function, you can free any memory allocated in the <i>NSPStartup</i> routine. This routine is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int NSPCleanup ( LPGUID lpProviderId ); 
</pre>
</td></tr></table>
</p>

<p>The only parameter is your name space provider's GUID. Other than cleaning up any dynamically allocated memory, you're not required to do anything in this function.</p>

<A NAME="443"><h3><i>NSPInstallServiceClass</i></h3></A>
<p>The <i>NSPInstallServiceClass</i> function maps to <i>WSAInstallServiceClass</i> and is responsible for registering a service class. <i>NSPInstallServiceClass</i> is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int NSPInstallServiceClass ( 
    LPGUID lpProviderId, 
    LPWSASERVICECLASSINFOW lpServiceClassInfo 
);
</pre>
</td></tr></table>
</p>

<p>The first parameter is the provider's GUID. The <i>lpServiceClassInfo</i> parameter is the <i>WSASERVICECLASSINFOW</i> structure that is being registered. Your provider has to maintain a list of service classes and has to ensure that a service class doesn't already exist using the same GUID within the <i>WSASERVICECLASSINFOW</i> structure. In the event that the GUID is already in use, the provider must return the error <i>WSAEALREADY</i>. Otherwise, the provider should maintain this service class so that other RNR operations can refer to it.</p>

<p>The majority of the remaining name space provider functions refer to an installed service class.</p>

<A NAME="444"><h3><i>NSPRemoveServiceClass</i></h3></A>
<p>This function is the complement of the <i>NSPInstallServiceClass</i> function and removes the specified service class. This name space function maps to <i>WSARemoveServiceClass</i>. The function is declared as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int NSPRemoveServiceClass ( 
    LPGUID lpProviderId, 
    LPGUID lpServiceClassId 
); 
</pre>
</td></tr></table>
</p>

<p>As in the previous function, the first parameter is the provider's GUID. The second parameter, <i>lpServiceClassId</i>, is the service class GUID that is to be removed. The provider must remove the given service class from its storage. If the service class specified by <i>lpServiceClassId</i> is not found, the provider must generate the error <i>WSATYPE_NOT_FOUND</i>.</p>

<A NAME="445"><h3><i>NSPGetServiceClassInfo</i></h3></A>
<p>The <i>NSPGetServiceClassInfo</i> function maps to the <i>WSAGetServiceClassInfo</i> function. It retrieves the <i>WSANAMESPACE_INFOW</i> structure associated with a GUID. The function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int NSPGetServiceClassInfo ( 
LPGUID lpProviderId, 
LPDWORD lpdwBufSize, 
LPWSASERVICECLASSINFOW lpServiceClassInfo 
); 
</pre>
</td></tr></table>
</p>

<p>Again, the first parameter is the provider's GUID. The <i>lpdwBufSize</i> parameter indicates the number of bytes contained in the third parameter, <i>lpServiceClassInfo</i>. On input, the third parameter is a <i>WSASERVICECLASSINFOW</i> structure that contains the search criteria specifying which service class to return. This structure can contain either a service class name or the GUID for the service class to return. If the provider finds a match, it must return the <i>WSASERVICECLASSINFOW</i> structure in <i>lpServiceClassInfo</i> and should update <i>lpdwBufSize</i> to indicate the number of bytes being returned.</p>

<p>If, given the criteria, no service classes are found, the call should fail and set <i>WSATYPE_NOT_FOUND</i> as the error. Additionally, if a service class does match but the supplied buffer is too small, the provider should update the <i>lpdwBufSize</i> parameter to indicate the correct number of bytes required and the error <i>WSAEFAULT</i> should be set.</p>

<A NAME="446"><h3><i>NSPSetService</i></h3></A>
<p>The <i>NSPSetService</i> function maps to <i>WSASetService</i> and either registers or removes services from the name space. The function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int NSPSetService ( 
    LPGUID lpProviderId, 
    LPWSASERVICECLASSINFOW lpServiceClassInfo, 
    LPWSAQUERYSETW lpqsRegInfo, 
    WSAESETSERVICEOP essOperation, 
    DWORD dwControlFlags 
);
</pre>
</td></tr></table>
</p>

<p>The first parameter is the provider's GUID. The <i>lpServiceClassInfo</i> parameter is the <i>WSASERVICECLASSINFOW</i> structure to which this service belongs. The <i>lpqsRegInfo</i> parameter is the service to either register or delete depending on the operation specified in the fourth parameter, <i>essOperation</i>. The last parameter, <i>dwControlFlags</i>, might specify the flag <i>SERVICE</i>_<i>MULTIPLE</i> that can modify the specified operation.</p>

<p>The name space provider first verifies that the supplied service class does exist. Then, depending on which operation is specified, appropriate action is taken. For a full description of valid <i>essOperation</i> values as well as the effect of <i>dwControlFlags</i> on them, see the section on service registration in <A HREF="ch10a.htm">Chapter 10</A>, which discusses <i>WSASetService</i>. Your provider's <i>NSPSetService</i> function handles these flags accordingly.</p>

<p>If your service provider is updating or deleting a service that cannot be found, the error <i>WSASERVICE_NOT_FOUND</i> is set. If the provider is registering a service and the <i>WSAQUERYSETW</i> structure is invalid or incomplete, the provider generates the <i>WSAEINVAL</i> error.</p>

<p>This function is one of the most complicated name space provider functions to implement (next to <i>NSPLookupServiceNext</i>). The provider must maintain a scheme for persisting the services that can be registered and must allow the <i>NSPSetService</i> function to update this data.</p>

<A NAME="447"><h3><i>NSPLookupServiceBegin</i></h3></A>
<p>The <i>NSPLookupServiceBegin</i> function is associated with the functions <i>NSPLookupServiceNext</i> and <i>NSPLookupServiceEnd</i> and is used to initiate a query of your name space. This function maps to <i>WSALookupServiceBegin</i> and establishes the criteria for your search. This function is prototyped as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int NSPLookupServiceBegin ( 
    LPGUID lpProviderId, 
    LPWSAQUERYSETW lpqsRestrictions, 
    LPWSASERVICECLASSINFOW lpServiceClassInfo, 
    DWORD dwControlFlags, 
    LPHANDLE lphLookup 
);
</pre>
</td></tr></table>
</p>

<p>As with previous functions in this section, the first parameter is the provider's GUID. The <i>lpqsRestrictions</i> parameter is the <i>WSAQUERYSETW</i> structure that defines the parameters for the query. The third parameter, <i>lpServiceClassInfo</i>, is the <i>WSASERVICECLASSINFOW</i> structure containing the schema information for the service class in which the query is to take place. The <i>dwControlFlags</i> parameter takes zero or more flags that affect how the query is performed. Again, for information on <i>WSALookupServiceBegin</i> and the different flags that can be used, refer to <A HREF="ch10a.htm">Chapter 10</A>. Note that not all of the flags make sense for every provider. For example, if your name space does not support the notion of container objects, you don't have to worry about those flags dealing with containers. (A container is simply a way of conceptually organizing the services&#8212;what constitutes a container is open to interpretation.) Finally, <i>lphLookup</i> is an output parameter, which is a handle that defines this particular query. The handle is used in the subsequent calls to <i>WSALookupServiceNext</i> and <i>WSALookupServiceEnd</i>.</p>

<p>When implementing <i>NSPLookupServiceBegin</i>, keep in mind that the operation cannot be canceled, and it should complete as quickly as possible. Therefore, if you need to initiate a network query, a response should not be required in order to return successfully.</p>

<p>The provider itself should save the query parameters and associate a unique handle with the query for later reference. In addition to saving the handle and the query, the provider should maintain state information. We'll explore the significance of this in our discussion of the next function, <i>NSPLookupServiceNext</i>.</p>

<A NAME="448"><h3><i>NSPLookupServiceNext</i></h3></A>
<p>Once a query has been initiated with <i>WSALookupServiceBegin</i>, an application calls <i>WSALookupServiceNext</i>, which in turn calls the name space provider function <i>NSPLookupServiceNext</i>. This call is what actually searches for results that match the search criteria registered for this query. The function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int NSPAPI WSALookupServiceNext ( 
    HANDLE hLookup, 
    DWORD dwControlFlags, 
    LPDWORD lpdwBufferLength, 
    LPWSAQUERYSET lpqsResults 
); 
</pre>
</td></tr></table>
</p>

<p>The first parameter, <i>hLookup</i>, is the query handle returned from <i>WSALookupServiceBegin</i>. The <i>dwControlFlags</i> parameter can be the flag <i>LUP_FLUSHPREVIOUS</i>, which indicates that the provider should discard the last result set and move to the next one. Typically an application requests that the last result set be discarded when the application cannot supply a large enough buffer for the results. The next parameter, <i>lpdwBufferLength</i>, indicates the size of the buffer passed as the last parameter, <i>lpqsResults</i>.</p>

<p>When <i>NSPLookupServiceNext</i> is triggered, the provider should look up the query parameters identified by the handle <i>hLookup</i>. Once the query parameters are retrieved, a search should be initiated for all registered services within the service class specified by the query that match the supplied criteria. As we mentioned in the section on <i>NSPLookupServiceBegin</i>, the state of the query should be saved. In the event of multiple matching entries, a calling process calls <i>WSALookupServiceNext</i> multiple times, and with each call your provider needs to return a data set. When there are no more matches, the provider returns the error <i>WSA_E_NO_MORE</i>. It is also possible to cancel a query in progress if the application makes a call to <i>WSALookupServiceEnd</i> from another thread while a call to <i>WSALookupServiceNext</i> is in progress. In this event, <i>NSPLookupServiceNext</i> should fail with the error <i>WSA_E_CANCELLED</i>.</p>

<A NAME="449"><h3><i>NSPLookupServiceEnd</i></h3></A>
<p>After a query has been completed, <i>NSPLookupServiceEnd</i> is called to end the query and release any underlying resources. This function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int NSPLookupServiceEnd ( HANDLE hLookup ); 
</pre>
</td></tr></table>
</p>

<p>The single parameter to the function is <i>hLookup</i>, which is the handle to the query that is to be closed. If the given handle cannot be found (for example, if it's an invalid handle), the call must fail with the error <i>WSA_INVALID_HANDLE</i>.</p>

<A NAME="450"><H2>Name Space Provider Example</H2></A>

<p>We have covered the steps for creating your own name space, and we have touched on some of the important name-space creation issues, such as methods for data persistence. However, developing an entire name space provider can be complicated, and the rest of this section will be devoted to our example name space provider. While the example is not the fastest or most optimized code, it illustrates the topics that require the most attention. Additionally, we kept it simple so that it's easy to follow and understand.</p>

<p>The example provider is located on the companion CD-ROM under the Examples\Chapter14\NSP directory in the files Mynsp.h, Mynsp.cpp, and Mynsp.def. These three files make up the name space DLL. In addition to the DLL, you'll find the name space service that is a Winsock server responsible for handling requests from the DLL. This server, which maintains the service registration data, is found in the file Mynspsvc.cpp. Two additional files, Nspsvc.cpp and Printobj.cpp, are used by both the DLL and the service and contain support routines for marshaling and demarshaling data sent on a socket between the service and the DLL. Marshaling and demarshaling data will be explained later in this section. In addition to these two files, you'll find their header files, Nspsvc.h and Printobj.h, which contain the function prototypes for the support routines. Finally, the file Rnrcs.c is a modified sample from <A HREF="ch10a.htm">Chapter 10</A> that registers and looks up services in our custom name space.</p>

<p>In the following sections, we will discuss how our name space is implemented. First we'll give an overview of the method we chose to persist the data. This overview will be followed by an examination of how the actual name space DLL is structured as well as how to install the name space. Then we'll cover the implementation of the name space service. Finally, we'll look at how an application performs service registrations and queries to our custom name space.</p>

<A NAME="451"><H3>Data persistence</H3></A>

<p>For our name space, we chose a separate Winsock service to maintain the name space information. In each of the name space functions implemented in the DLL, a connection is made to this service and data is transacted in order to complete the operation. For the sake of simplicity, this service runs locally (the service listens on the loopback address 127.0.0.1). In an actual implementation, our name space service's IP address would be accessible via the Registry or some other means so that when an application invoked the name space, it could connect to the service wherever it was running. For example, in the case of DNS, the IP address of the DNS server is either set statically or obtained during a DHCP request.</p>

<p>Of course, writing a service to maintain the information is not the only option available. You could maintain a file on the network that keeps the necessary information; however, this is probably not the best option, as performance is then bound by disk operations. One performance limitation of our sample name space is that it establishes TCP connections to the service. A production-quality implementation is more likely to use a connectionless datagram protocol such as UDP to improve performance. Of course, this would involve additional programming requirements&#8212;such as ensuring that dropped packets are retransmitted&#8212;but the overall performance gains would be considerable.</p>

<A NAME="452"><H3>Name space DLL</H3></A>

<p>Before we look at how the name space service is implemented, let's take a look at the name space DLL. Each name space provider requires a unique GUID, and ours is defined in Mynsp<i>.</i>h. In addition to the unique identifier, we need a simple integer identifier for our name space. This identifier can be used in the <i>dwNameSpace</i> field of the <i>WSAQUERYSET</i> structure, as you saw in <A HREF="ch10a.htm">Chapter 10</A>. The GUID and name space identifier are</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
GUID MY_NAMESPACE_GUID = {0x55a2bd9e,0xbb30,0x11d2,
                          {0x91,0x66,0x00,0xa0,0xc9,0xa7,0x86,0xe8}
                         };
#define NS_MYNSP     66
</pre>
</td></tr></table>
</p>

<p>These values are important because applications that want to use this name space must specify these values in their Winsock calls. Of course, the developer of an application can specify these values directly or retrieve them with a <i>WSAEnumNameSpaceProviders</i> call. (See <A HREF="ch10a.htm">Chapter 10</A> for more information.) Also, be aware that if an application performs an operation specifying the <i>NS_ALL</i> name provider, the operation occurs on all installed name providers. You should bear this in mind because several Windows applications, such as Microsoft Internet Explorer, perform queries on all installed name providers. Be very careful, therefore, when testing a name provider. A poorly written name provider can cause systemwide problems. Additionally, the GUID and name space identifier values are important because they are required to install the name provider.</p>

<p>Now let's take a look at the <i>NSP</i> functions implemented in Mynsp.cpp. For the most part, these functions are quite similar except for the startup and cleanup functions, <i>NSPStartup</i> and <i>NSPCleanup</i>. The startup function simply initializes the <i>NSP_ROUTINE</i> structure with our custom name space functions. The cleanup routine does nothing because no cleanup is necessary.</p>

<p>The rest of the functions require interaction with our service to either query or register data. When communication with the service is necessary, follow these steps:</p>

<ol>
<p><li> Connect to the service (via the <i>MyNspConnect</i> function).</li></p>

<p><li> Write a 1-byte action code. This indicates to the service which action is about to take place (service registration, service deletion, query, and so on).</li></p>

<p><li> Marshal parameters and send them to the service. The type of parameters sent depends on the operation. For example, <i>NSPLookupServiceNext</i> sends the query handle to the service so that the service can resume the query, whereas <i>NSPSetService</i> sends an entire <i>WSAQUERYSET</i> structure.</li></p>

<p><li> Read the return code. Once the service has the necessary parameters to perform the requested operation, the return code (success or failure) of the operation is returned. The file <i>Mynsp.h</i> defines two constants&#8212;<i>MYNSP_SUCCESS</i> and <i>MYNSP_ERROR</i>&#8212;for this purpose.</li></p>

<p><li> If the requested operation was a query and the return code was success, read and demarshal the results. For example, <i>NSPLookupServiceNext</i> returns a <i>WSAQUERYSET</i> structure in the event that a matching service is found.</li></p>
</ol>

<p>As you can see, implementing the DLL is not overly complicated. The <i>NSP</i> functions must take the parameters and process them, which in our case is to pass this information to the name space service. After this, it is up to the service to perform the requested operation. However, we have glossed over one difficult operation that must be performed: sending data over a socket. Normally there aren't any special requirements for sending data, but in the case of sending entire data structures there are. Most of the name space functions take either a <i>WSAQUERYSET</i> or a <i>WSASERVICECLASSINFO</i> structure as a parameter. This object must be sent or received on the socket connection to the service. This presents some difficulty because these structures aren't contiguous blocks of memory. That is, they contain pointers to strings and other structures that can be located anywhere in memory, as illustrated in Figure 14-7. What you need to do is take all these pieces of memory&#8212;wherever they
are&#8212;and copy them into a single buffer one after another. This is known as <i>marshaling</i> <i>data</i>. On the receiving end, this process has to be reversed. That is, the data read needs to be reassembled into the original structure, and the pointers have to be &quot;fixed&quot; so that they point to valid memory locations on the recipient's machine.</p>

<p>For our name space provider, we provide functions to marshal and demarshal both the <i>WSANAMESPACEINFO</i> and <i>WSAQUERYSET</i> structures. These functions are located in Nspsvc.cpp and are used by both the name space DLL and the name space service (since both sides need the ability to marshal and demarshal these structures). All four functions are self-explanatory&#8212;we won't cover them in depth here.</p>

<p>
<A HREF="javascript:fullSize('F14JI07x.htm')"> <img src="images/F14JI07.JPG" width=404 height=166 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 14-7.</b> <i>Marshaling data</i><!-- /caption -->
</p>

<A NAME="453"><H3>Installing the name space</H3></A>

<p>Installing a name space provider is the most trivial step in the entire process. The file <i>Nspinstall.c</i> is a simple installation program. The following code installs our provider:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
ret = WSCInstallNameSpace(L&quot;Custom Name Space Provider&quot;,
    L&quot;%SystemRoot%\\System32\\Mynsp.dll&quot;, NS_MYNSP, 1, 
    &amp;MY_NAMESPACE_GUID);
if (ret == SOCKET_ERROR)
{
    printf(&quot;Failed to install name space provider: %d\n&quot;,             
        WSAGetLastError());
}
</pre>
</td></tr></table>
</p>

<p>The only parameters to the call are the name of the provider, the location of the DLL, the integer identifier, the version, and the GUID. After installation, the only requirement is to make sure the name space DLL is actually located where you say it is. The only error that's a real possibility is trying to install a name provider with a GUID that's already in use by another provider.</p>

<p>Removing a name space provider is even easier. The following code snippet from our installation program removes our provider:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
ret = WSCUnInstallNameSpace(&amp;MY_NAMESPACE_GUID);
if (ret == SOCKET_ERROR)
{
    printf(&quot;Failed to remove provider: %d\n&quot;, WSAGetLastError());
}
</pre>
</td></tr></table>
</p>

<A NAME="454"><H3>Name space service</H3></A>

<p>The name space service is the real guts of the name provider. This service keeps track of all registered service classes and service instances. When the name space DLL is triggered by a user's application, it connects to the name space service to perform the operation. The service is simple. Within the <i>main</i> function, a listening socket is established. Then, within a loop, connections are accepted from instances of the name space DLL. For the sake of simplicity, only a single connection is handled at a time. This also prevents you from having to synchronize access to the data structures that maintain the name space information. Again, a real provider would not do this because it degrades performance, but it does make the example easier to understand. Once a connection is accepted, the service reads a single byte from the name space DLL that identifies the action to follow.</p>

<p>Within the loop, the action is decoded and parameters are passed from the name space DLL to the service. From there, the requested actions are performed. These actions aren't complicated. The code is easy to follow, and by examining the steps for each possible action you can determine how the service works&#8212;we don't need to go into detail here. However, we will examine the structures that maintain the information. There are only two data types that name space providers are really concerned about: the <i>WSASERVICECLASSINFO</i> and <i>WSAQUERYSET</i> structures. As you have seen, the majority of the RNR functions reference one or the other of these two structures in their parameters. As a result, we maintain two global arrays&#8212;one for each structure type&#8212;along with a counter for each.</p>

<p>When the DLL requests to install a service class, the name service provider's <i>main</i> function first calls <i>LookupServiceClass</i>, a support routine defined in Mynspsvc.cpp. This function iterates through the array of <i>WSASERVICECLASSINFO</i> structures, <i>ServiceClasses</i>. If a service class is found with the same GUID, the service returns an error (which the DLL translates as <i>WSAEALREADY</i>). Otherwise, the new service class is added to the end of the array and the <i>dwNumServiceClasses</i> counter is incremented.</p>

<p>During the deletion of a service class (as when installing a service class), the <i>main</i> function calls <i>LookupServiceClass</i>. In this case however, if the service class is found, the code moves the last service class in the array to the location of the deleted class. The code then decrements the counter. One thing that is not specifically covered in the Winsock 2 specification for name space providers is what happens when a service class is to be deleted but there are still services registered that refer to it. How you choose to handle this case is up to you. Our example name space won't allow the removal of a service class if there are services registered that reference it.</p>

<p>The same principle that's used for maintaining <i>WSASERVICECLASSINFO</i> structures is also used for keeping track of <i>WSAQUERYSET</i> structures. There is an array of these structures named <i>Services</i> and a counter named <i>dwNumServices</i>. The addition and deletion of services is handled in the same manner as for service classes.</p>

<p>The last bits of information that the service must maintain are for queries. When an application initiates a query, the query parameters must be maintained for the life of the query and assigned a unique handle. This is necessary because <i>WSALookupServiceNext</i> refers to the query by the handle only. The other piece of information that must be kept is the state of the query. That is, each call to <i>WSALookupServiceNext</i> can return a single information set. The code must remember the last position within the <i>Services</i> array where data was returned so that subsequent calls to <i>WSALookupServiceNext</i> begin where the previous call left off.</p>

<A NAME="455"><H3>Querying the name space</H3></A>

<p>The last part of our name space sample is the file Rnrcs<i>.</i>c. This is a modified version of the name registration and resolution example presented in <A HREF="ch10a.htm">Chapter 10</A>. We've made only a few changes to make the example as simple as possible. The first change causes the code to enumerate the installed name space providers but to return only the <i>NS_MYNSP</i> provider. Second, when registering a service, Rnrcs.c enumerates only the local IP interfaces to use as the address of our service. Our service provider supports the registration of any <i>SOCKADDR</i> type. Finally, for service registration this example does not create an instance of the service; it just registers the name. Otherwise, this example behaves like the <A HREF="ch10a.htm">Chapter 10</A> example.</p>

<A NAME="456"><H3>Running the example</H3></A>

<p>Once all the examples have been compiled, installing and using the provider is simple. The following command installs the provider:</p>

<p><blockquote>Nspinstall.exe install</blockquote></p>

<p>Of course, don't forget to copy Mynsp.dll to %SystemRoot%\System32. Once the name space is installed, an instance of the service must be running in order to query and register services. This is done by the following command:</p>

<p><blockquote>Mynspsvc.exe</blockquote></p>

<p>Now you can query and register services using Rnrcs.exe. Table 14-4 shows some commands that you should execute and the order you should follow. This sequence of commands registers two services and then performs a wildcard query and a specific query. Then the command sequence queries for each of the two services and deletes them. Finally, we perform a wildcard query to illustrate that the services have been deleted.</p>

<p><b>Table 14-4.</b> <i>The sequence of commands that uses the example name space to register and query services</i></p>

<table cellpadding="5" border="0" width="95%">
<tr><th><i>Command</i></th><th><i>Meaning</i></th></tr>
<tr><td valign="top">Rnrcs.exe -s:ASERVICE</td><td valign="top">Register the service ASERVICE.</td></tr>
<tr><td valign="top">Rnrcs.exe -s:BSERVICE</td><td valign="top">Register the service BSERVICE.</td></tr>
<tr><td valign="top">Rnrcs.exe -c:*</td><td valign="top">Query for all registered services.</td></tr>
<tr><td valign="top">Rnrcs.exe -c:BSERVICE</td><td valign="top">Query only for services named BSERVICE.</td></tr>
<tr><td valign="top">Rnrcs.exe -c:ASERVICE -d</td><td valign="top">Query only for services named ASERVICE, and delete them if found.</td></tr>
<tr><td valign="top">Rnrcs.exe -c:BSERVICE -d</td><td valign="top">Query only for services named BSERVICE, and delete them if found.</td></tr>
<tr><td valign="top">Rnrcs.exe -c:*</td><td valign="top">Query for all registered services.</td></tr>
</table>

</BODY>
</HTML>




