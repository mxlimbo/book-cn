<html>
<head>
<TITLE>ADO Recordset Object Functions and Methods </title>
<link rel="STYLESHEET" type="text/css" href="progado.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor = "#ffffff" text="#000000">
<A HREF="ch04b.htm">[Previous]</A> <A HREF="ch04d.htm">[Next]</A><P>

<A NAME="107"><H1>ADO Recordset Object Functions and Methods </H1></A>


<p>Now let's take a closer look at the functions and methods
available on the Recordset object. The following table offers a brief
description of each available function and method.</p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th colspan="2">Recordset Object Functions and Methods  </th></tr>
<tr>
<th><i>Function or Method Name</i>  </th>
<th><i>Description</i>  </th></tr>
<tr>
<td valign="top"><i>AddNew</i>  </td>
<td valign="top">Adds a new record to your Recordset  </td></tr>
<tr>
<td valign="top"><i>Cancel</i>  </td>
<td valign="top">Cancels an asynchronous query  </td></tr>
<tr>
<td valign="top"><i>CancelBatch</i>  </td>
<td valign="top">Cancels pending changes in a Recordset that uses
batch optimistic updates  </td></tr>
<tr>
<td valign="top"><i>CancelUpdate</i>  </td>
<td valign="top">Cancels pending changes on a record currently
being edited  </td></tr>
<tr>
<td valign="top"><i>Clone</i>  </td>
<td valign="top">Creates a new reference to your Recordset that allows
independent navigation  </td></tr>
<tr>
<td valign="top"><i>Close</i>  </td>
<td valign="top">Closes the Recordset object, releasing its contents  </td></tr>
<tr>
<td valign="top"><i>CompareBookmarks</i>  </td>
<td valign="top">Compares two bookmarks in the same
Recordset  </td></tr>
<tr>
<td valign="top"><i>Delete</i>  </td>
<td valign="top">Deletes the current record from your Recordset  </td></tr>
<tr>
<td valign="top"><i>Find</i>  </td>
<td valign="top">Searches your Recordset for a record based on a string
criteria  </td></tr>
<tr>
<td valign="top"><i>GetRows</i>  </td>
<td valign="top">Returns data from your Recordset in a two-dimensional Variant array  </td></tr>
<tr>
<td valign="top"> <i>GetString</i> </td>
<td valign="top">Returns data from your Recordset in a string  </td></tr>
<tr>
<td valign="top"><i>Move</i>  </td>
<td valign="top">Moves the position of the current record in your
Recordset  </td></tr>
<tr>
<td valign="top"><i>MoveFirst</i>  </td>
<td valign="top">Moves to the first record in your Recordset  </td></tr>
<tr>
<td valign="top"><i>MoveLast</i>  </td>
<td valign="top">Moves to the last record in your Recordset  </td></tr>
<tr>
<td valign="top"><i>MoveNext</i>  </td>
<td valign="top">Moves to the next record in your Recordset  </td></tr>
<tr>
<td valign="top"><i>MovePrevious</i>  </td>
<td valign="top">Moves to the previous record in your
Recordset  </td></tr>
<tr>
<td valign="top"><i>NextRecordset</i>  </td>
<td valign="top">Retrieves the results of the next query in your
batch query  </td></tr>
<tr>
<td valign="top"><i>Open</i>  </td>
<td valign="top">Opens the Recordset  </td></tr>
<tr>
<td valign="top"><i>Requery</i>  </td>
<td valign="top">Reexecutes the query that generated the Recordset  </td></tr>
<tr>
<td valign="top"><i>Resync</i>  </td>
<td valign="top">Retrieves the current data for the records in the
Recordset from your database  </td></tr>
<tr>
<td valign="top"><i>Save</i>  </td>
<td valign="top">Writes the contents of the Recordset to a file  </td></tr>
<tr>
<td valign="top"><i>Seek</i>   </td>
<td valign="top">Searches the Recordset for a specified string  </td></tr>
<tr>
<td valign="top"><i>Supports</i>   </td>
<td valign="top">Specifies whether the Recordset supports a
particular type of functionality  </td></tr>
<tr>
<td valign="top"><i>Update</i>  </td>
<td valign="top">Writes pending changes to the Recordset  </td></tr>
<tr>
<td valign="top"><i>UpdateBatch</i>  </td>
<td valign="top">Submits pending changes in a Recordset that uses
batch optimistic updating to the database  </td></tr>
</table></p>


<A NAME="108"><h2><i>AddNew</i> Method</h2></A>
<p>Use the <i>AddNew</i> method to insert new data into the Recordset.
This method accepts the following optional parameters:</p>

<ul>
<p><li> <i><b>FieldList</b></i> This parameter accepts
a Variant array containing the names of the fields you want to
populate.</li></p>

<p><li> <i><b>Values</b></i> This parameter accepts a
Variant array containing the values for the fields you want to
populate.</li></p>
</ul>



<p>There are two ways to use this method. You can call <i>AddNew</i>,
populate the Value property of the desired Field objects, and then call
the <i>Update</i> method:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
rsCustomers.AddNew
rsCustomers.Fields(&quot;CustomerID&quot;).Value = &quot;NewID&quot;
rsCustomers.Fields(&quot;CompanyName&quot;) = &quot;New Customer&quot;
rsCustomers.Fields(&quot;Address&quot;).Value = &quot;23 Highview St.&quot;
rsCustomers.Fields(&quot;City&quot;) = &quot;Westwood&quot;
rsCustomers.Fields(&quot;State&quot;) = &quot;MA&quot;
rsCustomers.Fields(&quot;Zip&quot;) = &quot;02090&quot;
rsCustomers.Update
</pre>
</td></tr></table>
</p>

<p>You can also perform all these actions in a single function call
using the two optional parameters on the <i>AddNew</i> method, each of
which accepts a Variant array. The first Variant array contains the
names of the fields to populate, and the second contains the values to
insert into those fields.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
varFields = Array(&quot;CustomerID&quot;, &quot;CompanyName&quot;, _
                  &quot;Address&quot;, &quot;City&quot;, &quot;State&quot;, &quot;Zip&quot;)
varValues = Array(&quot;NewID&quot;, &quot;New Customer&quot;, _
                  &quot;23 Highview St.&quot;, &quot;Westwood&quot;, _
                  &quot;MA&quot;, &quot;02090&quot;)
rsCustomers.AddNew varFields, varValues
</pre>
</td></tr></table>
</p>

<p>If you're in immediate update mode (with a LockType of
adLockOptimistic or adLockPessimistic), the provider will attempt to
write the new record to the database as soon as you have completed the
insertion (immediately after the call to <i>Update</i> in the first
example, and after the call to <i>AddNew</i> in the second example). If
you're using batch optimistic updating, this newly inserted record
will be marked as a pending insert in the Recordset (with a Status
value of adRecNew) until you call the <i>UpdateBatch</i> method to
submit the changes to the database.</p>

<A NAME="109"><h2><i>Cancel</i> Method</h2></A>
<p>The <i>Cancel</i> method allows you to terminate the execution of an
asynchronous query. Although I've used this feature with
server-side Recordsets, I've yet to successfully use it on a
client-side Recordset. Before relying on this feature in your
application, be sure to test the State property on the Recordset before
(to see if the Recordset is open) and after (to see if the Recordset is
closed) issuing this method to ensure that <i>Cancel</i> is behaving as
expected.</p>

<A NAME="110"><h2><i>CancelBatch</i> Method</h2></A>
<p>Use the <i>CancelBatch</i> method when you want to cancel pending
batch changes in an optimistically locked Recordset. The <i>
CancelBatch</i> method has one parameter, which controls the records in
your Recordset for which you want to roll back changes:</p>

<ul>
<p><li> <i><b>AffectRecords</b></i> Controls which
records will be affected by the <i>CancelBatch</i> method. This
optional parameter takes its value from AffectEnum. See the sidebar for
more information on the behavior associated with each constant.</li></p>
</ul>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th colspan="3">AffectEnum Values  </th></tr>
<tr>
<th><i>Constant</i>  </th>
<th><i>Value</i>  </th>
<th><i>Description</i>  </th></tr>
<tr>
<td valign="top">adAffectCurrent  </td>
<td valign="top">1   </td>
<td valign="top">Affects only the current record.  </td></tr>
<tr>
<td valign="top">adAffectGroup  </td>
<td valign="top">2   </td>
<td valign="top">Affects only the records currently visible based on
whether the Filter property is set to an array of bookmarks or to a
value in FilterGroupEnum other than adFilterNone.  </td></tr>
<tr>
<td valign="top">adAffectAll  </td>
<td valign="top">3   </td>
<td valign="top">Default, but hidden in the type library; affects all
records in the Recordset, except for other levels of a hierarchy or
other chapters at the same level. If a string-based filter is used,
only those records visible through the filter will be affected.  </td></tr>
<tr>
<td valign="top">adAffectAllChapters  </td>
<td valign="top">4   </td>
<td valign="top">Affects all chapters at the same level of the
Recordset, regardless of the current filter.  </td></tr>
</table></p>

<p><div class="sidebar"><blockquote>
<b>The Strange Tale of AffectEnum</b>

<p>The ADO development team devised a wonderful way to control the
records that a method such as <i>UpdateBatch</i> affects: they offered
the optional parameter <i>AffectRecords</i>. Depending on the value you
specify for this parameter, the method will affect only the current
record, all the currently visible records, and so on. To me, this is
much more elegant than providing separate methods such as <i>
UpdateBatchCurrent</i> or <i>UpdateBatchAll</i>. Simply provide a value
from the AffectEnum enumeration in the <i>AffectRecords</i> parameter,
and voila!</p>

<p>For several reasons, which I'll try to explain without
performing a &quot;career-limiting move,&quot; the behavior associated
with some of the constants is somewhat counter-intuitive.</p>

<p>The behavior associated with the adAffectCurrent value is simple to
understand. Use this constant when you want to affect only the current
record. Things get more complex when explaining the behavior of the
rest of the constants.</p>

<p>Different types of filters exist. The first type is the one that
most programmers traditionally envision&#8212;one such as <i>rs.Filter =
&quot;Country = 'Germany'&quot;</i>. I refer to this type of
filter as string-based because we're setting the Filter property to
a string. As we discussed earlier in the chapter, the Filter property
also accepts an array of bookmarks and any of the visible constants
from FilterGroupEnum. Internally, ADO handles the string-based filters
differently than the other filters.</p>

<p>The adAffectGroup constant affects the currently visible records,
but only if the Recordset's filter property has been set to an
array of bookmarks or to one of the constants in FilterGroupEnum other
than adFilterNone. If you have either no filter or a string-based
filter and you use adAffectGroup as the value in the <i>
AffectRecords</i> parameter, you'll receive a trappable error.</p>

<p>If you use the adAffectAll constant, you'll affect all records
in the Recordset. Sort of. If the Recordset's Filter property is
set to a string-based filter, only the records visible through the
filter will be affected. (Prior to ADO 2.0, adAffectAll affected all
records when a string-based filter was in use, including those not
visible through the filter.) However, if you're using an array of
bookmarks or one of the values from FilterGroupEnum, you'll affect
all records, including those that aren't visible through the
filter. Also, if you're using a hierarchical Recordset, only the
currently visible records will be affected if you use adAffectAll.
I'm not sure why the adAffectAll constant is hidden in the type
library, but it works just fine and in many cases is the default value
for the <i>AffectRecords</i> parameter.</p>

<p>We'll talk about hierarchies in more depth in <A HREF="ch14a.htm">Chapter 14</A>. Until
then, this quick overview of how hierarchies and AffectEnum work should
suffice. Hierarchies contain elements called &quot;chapters.&quot; In a
customers/orders hierarchy, a chapter in the orders level of the
hierarchy represents the orders associated with the current customer.
If you want to affect only the current chapter, use the adAffectAll
constant. But if you want to affect all chapters in the current level
of the hierarchy, use adAffectAllChapters.</p>

<p>Say you've modified all the customers and all the orders in the
hierarchy. If you call <i>UpdateBatch</i> on the orders Recordset and
use adAffectAllChapters, you'll submit pending changes for all
orders&#8212;but you won't submit any of the pending changes in the
customers Recordset. If you use adAffectAll instead of
adAffectAllChapters, <i>UpdateBatch</i> will affect only the orders for
the current customer.</p>

<p>One last note. Even if you're not using a hierarchical
Recordset, adAffectAllChapters might come in handy. If you have a
string-based filter on a normal, nonhierarchical Recordset but you want
to affect all the records rather than only those visible through the
filter, use the adAffectAllChapters constant.</p>

<p>If this seems confusing to you, join the club. It took me a long
time to feel like I understood the behavior associated with each
constant. The behavior is confusing, but it works.</p>
</blockquote></div>
</p>

<A NAME="111"><h2><i>CancelUpdate</i> Method</h2></A>
<p>The <i>CancelUpdate</i> method is similar to the <i>CancelBatch</i>
method in that it's used to cancel changes made to the Recordset.
The <i>CancelUpdate</i> method, however, cancels changes for only the
current record and is designed for use while the record is being
edited. Say you're programmatically adding or modifying a record in
optimistic updating mode and you decide that you no longer want to make
those changes to the record. If you call the <i>CancelUpdate</i> method
prior to calling <i>Update</i> on the Recordset, the changes you've
made will be canceled.</p>

<p>If you find that the <i>CancelUpdate</i> method isn't having the
effect you anticipated, be sure to check the EditMode property prior to
calling <i>CancelUpdate</i>. Some bound controls implicitly call the
<i>Update</i> method on the Recordset, so the <i>CancelUpdate</i>
method can't undo those changes. Contrary to what's stated in
the product documentation, the <i>CancelUpdate</i> method will not
generate an error if the current record has not been edited.</p>

<A NAME="112"><h2><i>Clone</i> Method</h2></A>
<p>There may be times when you want to maintain two separate references
to the same Recordset. For example, you might want to display two
separate grids that contain the same data on the same form at the same
time and allow the user to navigate through the grids separately. The
<i>Clone</i> method is designed to handle this type of scenario.</p>

<p>You can call the <i>Clone</i> method to generate a new Recordset
object variable. The one parameter on the method can be used to set the
LockType of the new Recordset object variable:</p>

<ul>
<p><li> <i><b>LockType</b></i> Controls the LockType
for the new Recordset object. This optional parameter accepts a value
from LockTypeEnum.</li></p>
</ul>



<p>By default, the new Recordset object variable will be created with a
LockType value of adLockUnspecified, meaning the clone will receive the
same value for the LockType property as the value the original
Recordset object variable received. You can also use the <i>
LockType</i> parameter to request that the new Recordset object
variable be read-only by setting the parameter to adLockReadOnly.</p>

<p>This method is available only for Recordsets that support bookmarks.
The bookmarks are interchangeable between a Recordset and its clones.
Attempts to use the <i>Clone</i> method on a Recordset that does not
support bookmarks (forward-only or dynamic cursors) will generate an
error.</p>

<p>Cloned Recordset object variables refer to the same data in memory.
Changes made in one Recordset object variable are visible in other
variables that refer to the same Recordset. When you're done using
a clone of a Recordset, you can call the <i>Close</i> method without
affecting the original Recordset or the other clones.</p>

<A NAME="113"><h2><i>Close</i> Method</h2></A>
<p>Speaking of the <i>Close</i> method&#8230; Calling the <i>Close</i>
method on the Recordset object releases the Recordset's resources.
If you have multiple references to the same Recordset object, the <i>
Close</i> method will close all references to that Recordset unless you
used the <i>Clone</i> method to obtain those references. This is
demonstrated in the following code. When the <i>Close</i> method is
called on the <i>rsOriginal</i> object, <i>rsOriginal</i> and <i>
rsDuplicate</i> are closed, but <i>rsClone</i> remains open.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
rsOriginal.Open strSQL, cnDatabase, adOpenStatic
Set rsDuplicate = rsOriginal
Set rsClone = rsOriginal.Clone
rsOriginal.Close
</pre>
</td></tr></table>
</p>

<p>If you have multiple references to the same Recordset object and
don't want to use the <i>Clone</i> method, don't use the <i>
Close</i> method to release your object variable. Instead Visual Basic
users can simply let the object variable go out of scope or explicitly
set the object variable to Nothing. Setting the last object variable
referencing a Recordset to Nothing will implicitly close the Recordset
object.</p>

<A NAME="114"><h2><i>CompareBookmarks</i> Method</h2></A>
<p>If you have the values of two bookmarks, you can use the <i>
CompareBookmarks</i> method to compare them. This method takes two
parameters&#8212;the bookmarks you're comparing&#8212;and returns a
value from CompareEnum, as described in the table that follows.</p>

<ul>
<p><li> <i><b>Bookmark1</b></i> This parameter accepts
a CompareEnum data type constant. It is the first bookmark to
compare.</li></p>

<p><li> <i><b>Bookmark2</b></i> This parameter accepts
a CompareEnum data type constant and is the second bookmark to
compare.</li></p>
</ul>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th colspan="3">CompareEnum Values  </th></tr>
<tr>
<th><i>Constant</i>  </th>
<th><i>Value</i>  </th>
<th> <i>Description</i> </th></tr>
<tr>
<td valign="top">adCompareLessThan  </td>
<td valign="top">0   </td>
<td valign="top">The first bookmark is before the second.  </td></tr>
<tr>
<td valign="top">adCompareEqual  </td>
<td valign="top">1   </td>
<td valign="top">The bookmarks are equal.  </td></tr>
<tr>
<td valign="top">adCompareGreaterThan  </td>
<td valign="top">2   </td>
<td valign="top">The first bookmark is after the second.  </td></tr>
<tr>
<td valign="top">adCompareNotEqual  </td>
<td valign="top">3  </td>
<td valign="top">The bookmarks are not equal.  </td></tr>
<tr>
<td valign="top">adCompareNotComparable  </td>
<td valign="top">4   </td>
<td valign="top">The bookmarks cannot be compared.  </td></tr>
</table></p>

<p>There are some ground rules for using this method. First, the
Recordset must support bookmarks. Second, you should compare bookmark
values from the same Recordset object or its clone. There is no basis
of comparison for examining bookmarks from different Recordsets, even
if they're two Recordsets based on the same query string. For
example, client-side Recordset bookmarks are usually equal to the
AbsolutePosition property for that record. If you run the same query
twice, there is no guarantee that you'll retrieve the same data:
records might have been added, modified, or deleted between the
execution of your queries. As a result, even if you're looking at
the <i>n</i>th row of each Recordset, you're not guaranteed that
those two rows contain the same data.</p>

<p>I mentioned that client-side Recordsets generally use bookmarks that
correspond to the record number in the Recordset. This allows ADO to
determine which of the two bookmarks appears first in the Recordset if
the two bookmarks are not equal. However, there is no requirement that
bookmarks be ordered by record number. As a result, you might find that
comparing two unequal bookmarks returns adCompareNotEqual, rather than
adCompareGreaterThan or adCompareLessThan.</p>

<p>It is worth repeating that you should not compare bookmarks from
different Recordset objects (unless they're clones of each other),
even if the Recordsets are based on the same query string. If either
bookmark you pass into the <i>CompareBookmarks</i> method does not
correspond to a record in the Recordset object whose <i>
CompareBookmarks</i> method is called, you'll receive a run-time
error. However, if you open two client-side Recordsets based on
different query strings and compare the bookmarks for the initial
record in each Recordset, the <i>CompareBookmarks</i> method will
return adCompareEqual. Why? The bookmarks both contain the value
-1.</p>

<A NAME="115"><h2><i>Delete</i> Method</h2></A>
<p>Use the <i>Delete</i> method to delete records from your Recordset.
The <i>Delete</i> method has one parameter:</p>

<ul>
<p><li> <i><b>AffectRecords</b></i> This parameter
controls which records will be affected by the <i>Delete</i> method. It
takes its value from AffectEnum and is optional.</li></p>
</ul>



<p>As of ADO 2.5, the only value for <i>AffectRecords</i> that I've
been able to use successfully is the default&#8212;adAffectCurrent. (Why
create an optional parameter that accepts no value other than the
default? Your guess is as good as mine.) This feature might be more
thoroughly implemented in a future release. Until then, if you want to
delete more than a single record at a time you can use the <i>
Delete</i> method within a loop.</p>

<p>After you call the <i>Delete</i> method, the deleted record remains
current until you move to the next available record. Unless you're
using client-side batch optimistic updating, the deleted record is no
longer available. Attempting to reference this record will generate an
error.</p>

<p>If you're using client-side batch optimistic updating, the
record is deleted only within the Recordset until you call the <i>
UpdateBatch</i> method. You can locate pending deletions such as these
by saving bookmark values prior to deleting records. You can also use
the Filter property on the Recordset by setting it to
adFilterPendingRecords and searching for records with a Status property
value of adRecDeleted. Once you've located a pending deletion, you
can check the OriginalValue property on each Field object to determine
which record you deleted. (See the section &quot;<A HREF="ch04f.htm#145">ADO Field Object Properties</A>&quot;)</p>

<A NAME="116"><h2><i>Find</i> Method</h2></A>
<p>You can use the <i>Find</i> method on the Recordset to locate a
record based on a search string. This feature works with client-side
and server-side Recordsets, but only if the Recordset supports
bookmarks (static or keyset). If the <i>Find</i> method is called on a
server-side Recordset, ADO walks through the contents of the Recordset
to locate the appropriate record. With client-side Recordsets, ADO
builds an internal index on the field referenced in the search
criteria. This method accepts the following parameters:</p>

<ul>
<p><li> <i><b>Criteria</b></i> This parameter accepts a
string data type. The criteria specifies the field name, value, and
operator used to search your Recordset.</li></p>

<p><li> <i><b>SkipRecords</b></i> This parameter
accepts a long data type. It controls how many records to skip before
beginning your search and is optional.</li></p>

<p><li> <i><b>SearchDirection</b></i> This parameter
takes its value from SearchDirectionEnum and is optional. It controls
the direction in which ADO will search your Recordset.</li></p>

<p><li> <i><b>Start</b></i> This parameter takes a
Variant data type and is optional. It accepts a bookmark to specify
where in your Recordset the search will begin.</li></p>
</ul>



<p>The <i>Criteria</i> parameter is a string&#8212;the search criteria.
You can specify one field and one value in the string. You can compare
the field and the value with these operators: =, &lt;, &gt;, &lt;=,
&gt;=, &lt;&gt;, or LIKE. If you use the LIKE operator, you can use a
wildcard (*, %, or _) either at the end of the string value or at the
beginning and end of the string value. If no records satisfy the
criteria, the Recordset will point to BOF or EOF.</p>

<p>You can use the second parameter, <i>SkipRecords</i>, to specify how
many records you want to skip relative to the current record. This
optional parameter accepts a long value, which defaults to 0, and can
prove handy if you don't want to include the current record in your
search. For example, if you want to loop through all the customers from
Germany, you could use code such as the following:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
strCriteria = &quot;Country = 'Germany'&quot;
rsCustomers.Find strCriteria
Do While Not rsCustomers.EOF
    rsCustomers.Find strCriteria, 1
Loop
</pre>
</td></tr></table>
</p>

<p>Of course, if this was your goal, you could have used the Filter
property instead.</p>

<p>The third parameter, <i>SearchDirection</i>, is also optional and
accepts one of the two SearchDirectionEnum constants shown in the
following table.</p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th colspan="3">SearchDirectionEnum Values  </th></tr>
<tr>
<th><i>Constant</i>  </th>
<th><i>Value</i>  </th>
<th><i>Description</i>  </th></tr>
<tr>
<td valign="top">adSearchForward  </td>
<td valign="top">1   </td>
<td valign="top">Default; searches forward through the Recordset
from the record specified  </td></tr>
<tr>
<td valign="top">adSearchBackward  </td>
<td valign="top">-1   </td>
<td valign="top">Searches backward through the Recordset from the
record specified  </td></tr>
</table></p>


<p>The final parameter on the method, <i>Start</i>, accepts a Variant
and is used to control where the search starts. This optional parameter
can accept a bookmark or one of the BookmarkEnum constants shown in
this next table.</p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th colspan="3">BookmarkEnum Values  </th></tr>
<tr>
<th><i>Constant</i>  </th>
<th><i>Value</i>  </th>
<th><i>Description</i>  </th></tr>
<tr>
<td valign="top">adBookmarkCurrent  </td>
<td valign="top">0   </td>
<td valign="top"> Default; begins the search at the current
record  </td></tr>
<tr>
<td valign="top">adBookmarkFirst  </td>
<td valign="top">1   </td>
<td valign="top">Begins the search at the first record in the
Recordset  </td></tr>
<tr>
<td valign="top">adBookmarkLast  </td>
<td valign="top">2   </td>
<td valign="top">Begins the search at the last record in the
Recordset  </td></tr>
</table></p>


<p>Generally speaking, you'll want to use this parameter if you
have a bookmark value other than the current record at which you want
to begin the search, or if you want the search to begin with the first
or last record in the Recordset.</p>

<p>One final note on the <i>Start</i> parameter. I was surprised to see
that the adBookmarkFirst and adBookmarkLast values in this enumeration
are positive integers. Why? In the discussion of the Bookmark property
on the Recordset, I pointed out that client-side Recordsets use record
numbers to denote their position. So how does the <i>Find</i> method
determine the difference between adBookmarkLast and the bookmark for
the second record in a client-side Recordset? Variants. The value of
the Bookmark property for the second record in a client-side Recordset
is 2, but it's stored as a double (don't ask me why) in a
Variant. The <i>Find</i> method determines the data type of the data
passed into this parameter to determine whether you're handing it a
value from a Bookmark property or a value from BookmarkEnum. I
don't know what made me decide to investigate this, but I found it
interesting and thought I'd pass it along. A tip of the hat to
whoever wrote that ADO code.</p>

<p>The <i>Find</i> method was a welcome addition to ADO (it was added
in ADO 2.0) and contains much of the same functionality of the DAO
Recordset's <i>Find</i> methods. ADO's search functionality,
however, is not as robust as DAO's. Perhaps it will be more
comparable in future versions. But remember that DAO does more than
submit queries and handle the results. Unlike ADO, DAO is also a
database engine that generates the results of Jet queries, which means
it must have some fairly advanced searching routines.</p>

<p>ADO will probably never have the advanced search features of a
database system such as SQL Server, Access, or Oracle, but that's
not one of its primary purposes. If you really need advanced search
capability, write your own code to walk through the contents of the
Recordset to locate the desired record. If you even start to complain
that ADO isn't able to handle your search with the <i>Find</i>
method, imagine the code it takes to parse, analyze, and implement
complex search criteria.</p>

<A NAME="117"><h2><i>GetRows</i> Method</h2></A>
<p>Here's a helpful method that gets a lot less attention than its
RDO and DAO counterparts did. <i>GetRows</i> returns a two-dimensional
Variant array that contains data from your Recordset. Because neither
DAO nor RDO could pass their objects out of process, this method was
used a great deal in multitiered applications. Plus, by storing the
results of your queries in Variant arrays, you had complete control
over how you handled your data&#8212;for example, when you queried your
database and how you updated your data (through action queries or
stored procedures).</p>

<p>This approach is still perfectly valid and extremely powerful in
ADO. If you use precious little of ADO's functionality, your
chances of running into any compatibility problems from one version of
ADO to the next are almost negligible. However, storing your data in
Variants this way isn't sexy. It doesn't make use of
functionality provided in rapid application development (RAD) tools
such as ADO, and it doesn't sell products because there's
little chance you'll use new features. The major drawback to this
approach is that you have to write all your code yourself.</p>

<p>Back to the <i>GetRows</i> method. This method takes three
parameters:</p>

<ul>
<p><li> <i><b>Rows</b></i> This parameter accepts a
GetRowsOptionEnum data type constant and is optional. It specifies how
many rows ADO will place in the Variant array returned by the <i>
GetRows</i> method.</li></p>

<p><li> <i><b>Start</b></i> This parameter accepts a
string or a Variant data type and is optional. It accepts a bookmark
value to control where ADO will begin reading records for the resulting
Variant array.</li></p>

<p><li> <i><b>Fields</b></i>  This optional parameter
accepts a Variant data type. It accepts a Variant array specifying
names of the fields in the Recordset to place in the resulting Variant
array.</li></p>
</ul>

<p>The <i>Rows</i> parameter determines how many records ADO will place
in your Variant array. This parameter takes a GetRowsOptionEnum value
and defaults to adGetRowsRest (-1), which happens to be the only
constant in the data type.</p>

<p>The second parameter, <i>Start</i>, accepts a string or a Variant to
control where ADO should start placing data into your array. You can
pass a bookmark value, adBookmarkFirst, or adBookmarkLast, just as you
can with the <i>Start</i> parameter on the <i>Find</i> method.</p>

<p>You can use the third parameter, <i>Fields</i>, to control which
fields appear in the two-dimensional Variant array that is returned
from this method. The <i>Fields</i> parameter is optional and accepts a
Variant array of field names, similar to the <i>FieldList</i> parameter
of the <i>AddNew</i> method.</p>

<p>The <i>GetRows</i> method on the Recordset object does not require
that the Recordset support bookmarks, unless you use the <i>Start</i>
parameter. If you specify a value for the <i>Start</i> parameter that
you retrieved from the Recordset's Bookmark property, the Recordset
must support bookmarks (static or keyset cursor). If you specify
adBookmarkFirst or adBookmarkLast, the Recordset needs to support only
scrolling (static, keyset, or dynamic cursor).</p>

<p>After you've called the <i>GetRows</i> method, the current
record in the Recordset is the first record not used in the Variant
array. If there are no more records in the Recordset, EOF will be set
to True.</p>

<A NAME="118"><h2><i>GetString</i> Method</h2></A>
<p>The <i>GetString</i> method is similar to the <i>GetRows</i> method
except that it builds a string rather than a Variant array. Although
this method has five parameters (all optional), it's not as complex
as you might think.</p>

<ul>
<p><li> <i><b>StringFormat</b></i> This parameter takes
its value from StringFormatEnum. It specifies the format used to
generate the string.</li></p>

<p><li> <i><b>NumRows</b></i> This parameter accepts a
long data type. It specifies how many records will be placed in the
resulting string.</li></p>

<p><li> <i><b>ColumnDelimiter</b></i> This parameter
accepts a string data type. It specifies the value that ADO will use to
delimit the columns in the resulting string.</li></p>

<p><li> <i><b>RowDelimiter</b></i> This parameter
accepts a string data type. It specifies the value that ADO will use to
delimit the records in the resulting string.</li></p>

<p><li> <i><b>NullExpr</b></i> This parameter accepts a
string data type. It specifies how ADO will represent a Null value in
the resulting string.</li></p>
</ul>



<p>The first parameter, <i>StringFormat</i>, defaults to adClipString
(2). In fact, this is the only available value for the parameter.
Originally, the plan was to add functionality to build HTML table
strings by means of this parameter, but the more thought the
development team gave to this feature, the less appealing it became.
They felt that only a small percentage of users would want to use a
base HTML table with no built-in formatting or font features. If you
want to build a relatively simple HTML table, you can use the <i>
ColumnDelimiter</i> and <i>RowDelimiter</i> parameters. For a more
complex HTML table&#8212;&quot;I want negative balances to appear red,
bold, and italic&quot;&#8212;you'll need to loop through the
Recordset and build the string by hand.</p>

<p>Use the second parameter, <i>NumRows</i>, to control how many
records are used to build your string. This parameter accepts a long
value and defaults to adGetRowsRest (-1).</p>

<p>The third and fourth parameters on the <i>GetString</i> method, <i>
ColumnDelimiter</i> and <i>RowDelimiter</i>, control how the fields and
records are delimited in your string. By default, these parameters are
set to the tab and carriage return, respectively. These defaults are
handy if you want to display the contents of your Recordset in one of
the Visual Basic FlexGrids or in a Microsoft Excel spreadsheet. As just
mentioned, you could build an HTML table by using the HTML table
delimiters in these parameters.</p>

<p>The fifth and final parameter on this method is <i>NullExpr</i>.
Null values don't translate easily to strings, and many programmers
forget this when trying to display the contents of fields on a form.
Null values in your Recordset are converted to the value in the <i>
NullExpr</i> parameter, which defaults to an empty string.</p>

<A NAME="119"><h2><i>Move</i> Method</h2></A>
<p>The <i>Move</i> method moves the cursor from one record to another
within a Recordset. This method uses two parameters:</p>

<ul>
<p><li> <i><b>NumRecords</b></i> This parameter accepts
a long data type. It specifies the number of positions that ADO will
move the current record pointer.</li></p>

<p><li> <i><b>Start</b></i> This optional parameter
accepts a string or a Variant data type that contains a bookmark to
control where the navigation will commence.</li></p>
</ul>



<p>The first parameter, <i>NumRecords</i>, is required and accepts a
long value to determine how many records to move from the current
position. If you specify a negative value for this first parameter, ADO
will move backward that number of records. Note, however, that you
can't specify a negative value if the cursor is forward-only,
unless you remain inside the currently cached records.</p>

<p>If you specify a number that would move the Recordset beyond its
boundaries, the Recordset will be set to BOF or EOF, depending on the
direction you're moving. It's worth mentioning that <i>Move
0</i> in ADO does not behave the same way as it does in RDO. In fact,
calling <i>Move 0</i> in ADO does nothing whatsoever.</p>

<p>The <i>Move</i> method also accepts an optional parameter, <i>
Start</i>, which controls where ADO will begin to move from. You can
use this parameter only if your Recordset supports bookmarks (static or
keyset cursor). This property defaults to adBookmarkCurrent, and you
can set it to adBookmarkFirst, adBookmarkLast, or any valid bookmark
value.</p>

<A NAME="120"><h2><i>MoveFirst</i>, <i>MoveLast</i>, <i>MoveNext</i>, and <i>MovePrevious</i> Methods</h2></A>

<p>The <i>MoveFirst</i> method moves to the first record. <i>
MoveLast</i> moves to the last record. <i>MoveNext</i> moves forward to
the next record in the Recordset, and <i>MovePrevious</i> moves back
one record. If you're using a Recordset that supports only
scrolling forward, calling <i>MoveFirst</i>, <i>MoveLast</i>, or <i>
MovePrevious</i> will generate a run-time error.</p>

<p>If you call the <i>MoveNext</i> method while you're currently
examining the last record in your Recordset, the EOF property will be
set to True. Trying to check the value of any of the fields in your
Recordset while at EOF will generate a run-time error. Similarly, if
you call <i>MovePrevious</i> while examining the first record in your
Recordset, the BOF property will be set to True.</p>

<p>The following code uses the <i>MoveNext</i> method to move through
the Recordset and print the contents of the CustomerID field for all
records:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
strSQL = &quot;SELECT * FROM Customers&quot;
rsCustomers.Open strSQL, cnDatabase, adOpenForwardOnly
Do While Not rsCustomers.EOF
    Debug.Print rsCustomers.Fields(&quot;CustomerID&quot;).Value
    rsCustomers.MoveNext
Loop
</pre>
</td></tr></table>
</p>

<p>If you have changes to a record pending (you've modified the
current record but haven't yet called the <i>Update</i> or <i>
CancelUpdate</i> method), ADO implicitly calls the <i>Update</i> method
to commit those changes when you call one of these <i>Move</i>
methods.</p>

<A NAME="121"><h2><i>NextRecordset</i> Method</h2></A>
<p>Some database systems (such as Oracle and SQL Server) support batch
queries, which allow you to submit multiple query strings at once. You
can then process the results, one set at a time. In ADO, the <i>
NextRecordset</i> method allows you to move from one set of results to
the next set.</p>

<p>The <i>NextRecordset</i> method takes one parameter:</p>

<ul>
<p><li> <i><b>RecordsAffected</b></i> This output
parameter will contain the number of records affected if the query
modifies data in your database. It is a long data type and is
optional.</li></p>
</ul>



<p>If you wanted to execute a number of action queries and retrieve the
number of records affected by each query, you could use code such as
the following:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
strSQL = &quot;DELETE FROM [Order Details] &quot; &amp; _
                &quot;WHERE OrderID = 10251; &quot; &amp; _
         &quot;DELETE FROM Orders WHERE OrderID = 10251&quot;
Set rsData = cnDatabase.Execute(strSQL, _
                                lngRecordsAffected)
MsgBox lngRecordsAffected &amp; &quot; Order Detail(s) deleted.&quot;
Set rsData = rsData.NextRecordset(lngRecordsAffected)
MsgBox lngRecordsAffected &amp; &quot; Order(s) deleted.&quot;
</pre>
</td></tr></table>
</p>

<p>Because these are action queries, the only data returned is the
number of records affected by the query; no records or fields are
returned. If you were to check the State property of the Recordset
object, you'd see a value of adStateClosed, so don't stop
retrieving Recordsets when you receive one with this State value. Test
until the returning Recordset is set to Nothing. Just make sure that
you don't dimension the Recordset in Visual Basic using the keyword
New. With this keyword, every time you check the object variable it
will be set to a new Recordset object if the Recordset was set to
Nothing. For example, look at the following code. The Do While loop in
this code snippet is an infinite loop.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim rsData As ADODB.Recordset

strSQL = &quot;SELECT * FROM Customers; &quot; &amp; _
         &quot;DELETE FROM Customers WHERE 1 = 0; &quot; &amp; _
         &quot;SELECT * FROM Orders&quot;
Set rsData = New ADODB.Recordset
rsData.Open strSQL, cnDatabase, adOpenForwardOnly
Do While Not (rsData Is Nothing)
    Set rsData = rsData.NextRecordset
Loop
</pre>
</td></tr></table>
</p>

<p>In each of the code snippets we've used to demonstrate this
method, we've stored the Recordset object returned from the call to
<i>NextRecordset</i> in the same object variable we used to call <i>
NextRecordset</i>. However, using the same object variable is not
mandatory; you could return the next Recordset into a different
one:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
strSQL = &quot;SELECT * FROM Customers; &quot; &amp; _
         &quot;SELECT * FROM Orders&quot;
rsCustomers.Open strSQL, cnDatabase, adOpenStatic
Set rsOrders = rsCustomers.NextRecordset
</pre>
</td></tr></table>
</p>

<p>If you're using a server-side Recordset, the data for the
initial Recordset is lost as soon as you call <i>NextRecordset</i>.
However, if you're using client-side Recordsets, you can scroll
through the contents of each of these Recordsets. In the previous code
example, the data in the <i>rsCustomers</i> Recordset is still
available after the <i>NextRecordset</i> method is called. You also
cannot pass the initial Recordset out of process and then call the <i>
NextRecordset</i> method in the other process. This functionality might
be available in a subsequent release.</p>

<p>ADO does not parse the query string that you pass to it. It simply
passes this query string along to the OLE DB provider. It's up to
the OLE DB provider and/or database system to parse and process the
query or queries. ADO doesn't actually submit each query in a batch
query separately, but it could in a future release.</p>

<p>The <i>NextRecordset</i> method is not available on client-side
Recordsets when using Remote Data Service (RDS).</p>

<p>It's worth noting that action queries in a batch process or a
stored procedure might return a closed, empty Recordset. SQL Server
users can prevent retrieving unwanted Recordsets by using SET NOCOUNT
ON and SET NOCOUNT OFF to control this behavior. Check your SQL Server
documentation for more information on this feature.</p>

<A NAME="122"><h2><i>Open</i> Method</h2></A>
<p>The <i>Open</i> method is the most powerful and versatile method of
retrieving data from your database. You can set the ActiveConnection,
Source, LockType, and CursorType properties on the Recordset prior to
using the <i>Open</i> method, or you can supply this data in its
parameters, all of which are optional:</p>

<ul>
<p><li> <i><b>Source</b></i> This parameter accepts a
Variant. You can use the <i>Source</i> parameter to specify the query
string or Command object you want to use. If you do use a Command
object in this parameter, be sure to leave the <i>ActiveConnection</i>
parameter on this method blank. Instead, set the ActiveConnection
property on the Command object. This parameter can also contain a table
name, a stored procedure call, a URL, a filename, or a Stream
object.</li></p>

<p><li> <i><b>ActiveConnection</b></i> This parameter
accepts a Variant in the form of a connection string or an open
Connection object, just like the ActiveConnection property.</li></p>

<p><li> <i><b>CursorType</b></i> This parameter accepts
a CursorTypeEnum value. (See &quot;<A HREF="ch04b.htm#86">CursorType Property</A>&quot; for a list of CursorTypeEnum
values.)</li></p>

<p><li> <i><b>LockType</b></i>This parameter accepts a
value from LockTypeEnum. (See &quot;<A HREF="ch04b.htm#96">LockType Property</A>&quot; for a list of LockTypeEnum
values.)</li></p>

<p><li> <i><b>Options</b></i> This parameter accepts a
CommandTypeEnum value and/or a combination of asynchronous
ExecuteOptionEnum constants, as respectively shown in the following two
tables.</li></p>
</ul>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th colspan="3">CommandTypeEnum Values  </th></tr>
<tr>
<th><i>Constant</i>  </th>
<th><i>Value</i>  </th>
<th><i>Description</i>  </th></tr>
<tr>
<td valign="top">adCmdText  </td>
<td valign="top">1   </td>
<td valign="top">ADO will pass the query string as is to the OLE DB
provider.  </td></tr>
<tr>
<td valign="top">adCmdTable  </td>
<td valign="top">2   </td>
<td valign="top">ADO will assume that the query string is the name of a
table and attempt to modify the query string appropriately.  </td></tr>
<tr>
<td valign="top">adCmdStoredProc   </td>
<td valign="top">4   </td>
<td valign="top">ADO will assume that the query string is the name
of a stored procedure and attempt to modify the query string
appropriately.  </td></tr>
<tr>
<td valign="top">adCmdUnknown  </td>
<td valign="top">8   </td>
<td valign="top">ADO will try to execute the query string in a variety
of ways.  </td></tr>
<tr>
<td valign="top">adCmdFile  </td>
<td valign="top">256  </td>
<td valign="top">ADO will open the Recordset from a file.  </td></tr>
<tr>
<td valign="top">adCmdTableDirect  </td>
<td valign="top">512   </td>
<td valign="top">ADO will attempt to use an optional interface
on OLE DB providers to retrieve the contents of the table.  </td></tr>
</table></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th colspan="3">ExecuteOptionEnum Values  </th></tr>
<tr>
<th><i>Constant</i> </th>
<th><i>Value</i>  </th>
<th><i>Description</i>  </th></tr>
<tr>
<td valign="top">adAsyncExecute  </td>
<td valign="top">16   </td>
<td valign="top">ADO will execute the query string
asynchronously.  </td></tr>
<tr>
<td valign="top">adAsyncFetch  </td>
<td valign="top">32   </td>
<td valign="top">ADO will fetch the results of the query
asynchronously.  </td></tr>
<tr>
<td valign="top">adAsyncFetchNonBlocking  </td>
<td valign="top">64   </td>
<td valign="top">ADO will fetch the results of the query
asynchronously without blocking the main thread.  </td></tr>
<tr>
<td valign="top">adExecuteNoRecords  </td>
<td valign="top">128  </td>
<td valign="top">No records are returned from the query. (This
option isn't available on the Recordset object.)  </td></tr>
</table></p>


<p>We've discussed most of these parameters earlier in this chapter
in terms of their use as properties. We'll also talk more about
cursors and updating your database in later chapters. For now,
let's talk about the <i>Options</i> parameter and using values from
CommandTypeEnum and ExecuteOptionEnum. The <i>Options</i> parameter is
a bitmask, so you can use the sum of constants, such as adCmdTable +
adAsyncExecute, as shown in the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
rsCustomers.Open &quot;Customers&quot;, cnNorthwind, _
                 adOpenStatic, adLockReadOnly, _
                 adCmdTable + adAsyncExecute
</pre>
</td></tr></table>
</p>

<p>In an attempt to make ADO friendlier, the concept of a CommandType
was introduced. You can specify a table name or a stored procedure
name, and ADO will try to execute that query string on its own, as well
as trying to retrieve the contents of a table with the same name or
execute a stored procedure of the same name. While this functionality
is helpful for the novice developer, it means that ADO might need to
pass multiple query strings to your OLE DB provider before it finds a
query string that executes successfully.</p>

<p>Although I appreciate this attempt to simplify things, I would never
ask ADO to figure out what type of query I'm executing unless
absolutely necessary. Besides, it's not always as simple as it
sounds. When you pass ADO a table name and specify adCmdTable in the
<i>Options</i> parameter, ADO simply prepends &quot;select * from
&quot; to the query string. If the table you want to query contains a
space in its name, this query will fail if you did not delimit the
table name yourself. This point is illustrated by the following
code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
'This will fail.
rsOrderDetails.Open &quot;Order Details&quot;, cnNorthwind, _
                    adOpenStatic, adLockReadOnly, _ 
                    adCmdTable

'This will succeed.
rsOrderDetails.Open &quot;[Order Details]&quot;, cnNorthwind, _
                    adOpenStatic, adLockReadOnly, _ 
                    adCmdTable
</pre>
</td></tr></table>
</p>

<p>Don't get me wrong&#8212;there are times when I use this
functionality; I just grin (or grouse) and bear it when it doesn't
work the way I'm expecting it to. I suggest using the adCmdText
constant for your CommandType, but I'll admit I do use the
adCmdFile constant when I want to reopen a Recordset that I had
previously persisted to a file:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
rsCustomers.Open &quot;C:\Customers.rst&quot;, Nothing, _
                 adOpenStatic, adLockReadOnly, adCmdFile
</pre>
</td></tr></table>
</p>

<p>We'll talk about this feature more in <A HREF="ch13a.htm">Chapter 13</A>, when we
discuss persistence.</p>

<p>ADO 2.5 allows you to use a Stream object that contains Recordset
data (stored by using the Recordset's <i>Save</i> method) in the
<i>Source</i> parameter.</p>

<p>The other constant that I use from time to time in the <i>
Options</i> parameter is adCmdTableDirect. This command type closely
resembles DAO's table-type Recordset. Some OLE DB providers will
implement an optional feature that can provide better performance when
retrieving all records and columns from a table. If you need to
retrieve the entire contents of a particular table, you might want to
try using this constant and find out whether your OLE DB provider
supports it and whether it will improve the performance of your
application.</p>

<p>You can also use the <i>Options</i> parameter on the <i>
Recordset.Open</i> method to utilize ADO's asynchronous
functionality. If you specify adAsyncExecute, the query will be
executed asynchronously.</p>

<p>The adAsyncFetch and adAsyncFetchNonBlocking options apply to
client-side Recordsets only. Once ADO has retrieved an initial number
of records, the rest of the records are fetched on a background thread.
If you attempt to move to a record that has not been fetched and you
use the adAsyncFetch constant, the main thread will be blocked while
ADO continues to retrieve data. Once that record is available, the main
thread will resume. With the adAsyncFetchNonBlocking constant, if you
move beyond the records that have been fetched, you'll move to EOF
instead and the main thread will not be blocked.</p>

<A NAME="123"><h2><i>Requery</i> Method</h2></A>
<p>The <i>Requery</i> method on the Recordset object reexecutes the
query that created the Recordset object. It has the following
parameter:</p>

<ul>
<p><li> <i><b>Options</b></i> This optional parameter
accepts an ExecuteOptionEnum value. (See the table in &quot;<A HREF="ch04c.htm#122"><i>Open</i> Method</A>&quot; for a list of
ExecuteOptionEnum values.) You can call the <i>Requery</i> method
asynchronously by setting this parameter to adAsyncExecute.</li></p>
</ul>



<p>You can use this method on server-side or client-side Recordsets.
This method is very useful if you want to repeatedly execute the same
parameterized query. Simply change the value of the appropriate
Parameter object or objects, and then call the <i>Requery</i> method on
the Recordset object. We'll talk more about parameterized queries
in <A HREF="ch05a.htm">Chapter 5</A>, when we discuss the Command object.</p>

<p>When you call the <i>Requery</i> method, you're rerunning the
query&#8212;similar to calling the <i>Close</i> and then <i>Open</i>
methods on the Recordset object. Although your data will be fresher
than it was before you called the <i>Requery</i> method, the contents
of your Recordset might have changed dramatically. Changes made by
other users (modifications, insertions, and deletions) will affect your
query. Records that were in your Recordset prior to calling <i>
Requery</i> might not appear in the Recordset after the call. For these
reasons, you should not rely on bookmark values retrieved prior to
calling <i>Requery</i>. In many cases, using a previously retrieved
bookmark for a server-side Recordset will result in a run-time
error.</p>

<A NAME="124"><h2><i>Resync</i> Method</h2></A>
<p>The <i>Resync</i> method is similar to the <i>Requery</i> method:
you use it to refresh the data in your Recordset. It has the following
two parameters:</p>

<ul>
<p><li> <i><b>AffectRecords</b></i> An optional
parameter, it accepts a value from AffectEnum. Use this parameter to
control which records you want to resynchronize. This parameter
defaults to adAffectAll.</li></p>

<p><li> <i><b>ResyncValues</b></i> This parameter is
optional and accepts a value from ResyncEnum. Use this parameter to
control where ADO stores the newly retrieved data. This parameter
defaults to adResyncAllValues.</li></p>
</ul>



<p>The <i>Resync</i> method differs from the <i>Requery</i> method in
that it does not reexecute the query that generated the Recordset
object. Instead, ADO examines the record you want to refresh and
executes a separate query to retrieve the current contents of that
record in the database. For example, if you created your Recordset with
the query</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SELECT CustomerID, CompanyName, BalanceDue FROM Customers
</pre>
</td></tr></table>
</p>

<p>calling the <i>Resync</i> method would cause ADO to execute the
following query for each record, where <i>x</i> is the value of the
CustomerID for each record in the Recordset:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SELECT CustomerID, CompanyName, BalanceDue FROM Customers 
       WHERE CustomerID = <i>x</i>
</pre>
</td></tr></table>
</p>

<p>Since you're not actually reexecuting the query that you
originally submitted to generate the data in your Recordset, new
records that might satisfy the results of your query will not be
retrieved when calling the <i>Resync</i> method.</p>

<p>This method is not available for server-side Recordsets. If you call
the <i>Resync</i> method on a server-side Recordset, you'll
generate a run-time error. Prior to ADO 2.0, calling <i>Resync</i> on a
server-side Recordset did not generate an error; ADO executed the <i>
Requery</i> method instead.</p>

<p>You can use the <i>Resync</i> method only on client-side Recordset
objects that are not marked read-only. If the Recordset is read-only,
the ADO Cursor Engine does not need to retrieve much metadata for your
Recordset, such as which fields constitute the primary key or which
fields are updatable. Without this metadata, ADO cannot create the
queries to retrieve the most up-to-date data for the records in your
Recordset.</p>

<p>You can use the first parameter, <i>AffectRecords</i>, to control which
records you want to resynchronize. By default, this parameter is set to
adAffectAll. For more information on the behavior associated with the
different possible values for the <i>AffectRecords</i> parameter, see
the discussion about the AffectEnum enumeration in the <a href="ch04c.htm#110"><i>CancelBatch</i> Method</a> section.</p>

<p>The second parameter, <i>ResyncValues</i>, is designed to help
manage batch updates that fail as a result of modifications made by
other users. By default, ADO will store the newly retrieved data in the
Value property of the Field objects in your Recordset. If you're
attempting to determine why some batch updates failed, you probably
don't want to overwrite the information you currently have stored
in the Value property. When you specify adResyncUnderlyingValues in the
optional <i>ResyncValues</i> parameter, ADO will store the newly
retrieved data in the UnderlyingValue property of the Field objects
instead of in the Value property. We'll discuss these properties in
more depth as we cover how to handle optimistic updating conflicts in
<A HREF="ch12a.htm">Chapter 12</A>.</p>

<A NAME="125"><h2><i>Save</i> Method</h2></A>
<p>You can call the <i>Save</i> method to save the contents of a
Recordset to a file and reopen it later. This method accepts two
parameters:</p>

<ul>
<p><li> <i><b>Destination</b></i> This is an optional
parameter. It accepts a string containing the filename where you want
to save the recordset or a Stream object.</li></p>

<p><li> <i><b>PersistFormat</b></i> This optional
parameter accepts a value from PersistFormatEnum; it controls the
format for the recordset file. <i>PersistFormat</i> defaults to
adPersistADTG but can be set to adPersistXML as of ADO 2.1.</li></p>
</ul>



<p>The first time you save a recordset, you must specify a filename in
the <i>Destination</i> parameter. Only the records currently visible
will be stored in the file. If you specify a filename that already
exists, you'll generate a run-time error. Once you've opened
your recordset from a file, you can resave its contents to that file
and overwrite the old data by omitting the <i>Destination</i>
parameter.</p>

<p>The <i>Save</i> method was added in ADO 2.0, and the only available
format was adPersistADTG&#8212;the same format used when passing a
Recordset object out of process. As of ADO 2.1, you can also save a
Recordset to an XML file through the adPersistXML constant. Although
the ability to write to an XML file is part of ADO 2.1 and later, the
ability to turn an XML file back into a Recordset is actually
implemented through the Microsoft Internet Explorer XML parser. If you
do not have the parser that is included with Internet Explorer 5 on
your machine, you will not be able to open the Recordset you saved into
an XML file.</p>

<A NAME="126"><h2><i>Seek</i> Method</h2></A>
<p>At the time of this writing, the only OLE DB provider that supports
the <i>Seek</i> method is the Jet 4.0 OLE DB Provider, but only when
used with Jet 4 and Access-formatted databases and server-side
Recordsets with a CommandType of adCmdTableDirect. This method is
similar to the <i>Find</i> method, but the OLE DB provider, rather than
the ADO Cursor Engine, does the searching. To determine whether your
OLE DB provider supports this functionality, use the <i>Supports</i>
method on the Recordset object with the adSeek constant. The <i>
Seek</i> method has two parameters:</p>

<ul>
<p><li> <i><b>KeyValues</b></i> This parameter is
required. It accepts a Variant array of the key values&#8212;one value
per field in the current index. If the index in use is based on a
single field, you can omit the Variant array and simply supply the key
value you want to locate.</li></p>

<p><li> <i><b>SeekOption</b></i> This parameter is
optional and accepts one of the values from SeekEnum shown in the
following table. It defaults to adSeekFirstEQ.</li></p>
</ul>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th colspan="3">SeekEnum Values  </th></tr>
<tr>
<th><i>Constant</i>  </th>
<th><i>Value</i>  </th>
<th><i>Description</i>  </th></tr>
<tr>
<td valign="top">adSeekFirstEQ  </td>
<td valign="top">1   </td>
<td valign="top">Seeks the first key matching the criteria  </td></tr>
<tr>
<td valign="top">adSeekLastEQ  </td>
<td valign="top">2   </td>
<td valign="top">Seeks the last key matching the criteria  </td></tr>
<tr>
<td valign="top">adSeekAfterEQ  </td>
<td valign="top">4   </td>
<td valign="top">Seeks the first key that matches the criteria; if
none are found, seeks the key following the position where the key
would be found  </td></tr>
<tr>
<td valign="top">adSeekAfter  </td>
<td valign="top">8   </td>
<td valign="top">Seeks the key following the key in the criteria  </td></tr>
<tr>
<td valign="top">adSeekBeforeEQ  </td>
<td valign="top">16   </td>
<td valign="top">Seeks the first key that matches the criteria; if
none are found, seeks the key prior to the position where the key would
be found  </td></tr>
<tr>
<td valign="top">adSeekBefore  </td>
<td valign="top">32  </td>
<td valign="top">Seeks the key prior to the key in the criteria  </td></tr>
</table></p>


<p>The code that follows is an example of how to use the <i>Seek</i>
method with an Access 2000 database:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Set rsCustomers = New ADODB.Recordset
rsCustomers.Open &quot;Customers&quot;, cnNorthwind, adOpenStatic, _
                 adLockReadOnly, adCmdTableDirect
rsCustomers.Index = &quot;City&quot;
rsCustomers.MoveFirst
rsCustomers.Seek Array(&quot;London&quot;)
</pre>
</td></tr></table>
</p>

<A NAME="127"><h2><i>Supports</i> Method</h2></A>
<p>You can use the <i>Supports</i> method on the Recordset object to
understand what functionality is available based on your choice of OLE
DB provider, CursorLocation, CursorType, and LockType. It takes one
parameter:</p>

<ul>
<p><li> <i><b>CursorOptions</b></i> This parameter is
required and accepts one of the values from CursorOptionEnum, shown in
this next table.</li></p>
</ul>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th colspan="3">CursorOptionEnum Values  </th></tr>
<tr>
<th><i>Constant</i>  </th>
<th><i>Value</i>  </th>
<th><i>Functionality Your Recordset Supports</i>  </th></tr>
<tr>
<td valign="top">adAddNew  </td>
<td valign="top">16778240  </td>
<td valign="top"><i>AddNew</i> method  </td></tr>
<tr>
<td valign="top">adApproxPosition  </td>
<td valign="top">16384  </td>
<td valign="top">AbsolutePage and AbsolutePosition
properties  </td></tr>
<tr>
<td valign="top">adBookmark  </td>
<td valign="top">8192   </td>
<td valign="top">Bookmark property  </td></tr>
<tr>
<td valign="top">adDelete   </td>
<td valign="top">16779264  </td>
<td valign="top"><i>Delete</i> method  </td></tr>
<tr>
<td valign="top">adFind  </td>
<td valign="top">524288  </td>
<td valign="top"><i>Find</i> method  </td></tr>
<tr>
<td valign="top">adHoldRecords  </td>
<td valign="top">256  </td>
<td valign="top">Very similar to bookmarks  </td></tr>
<tr>
<td valign="top">adIndex  </td>
<td valign="top">8388608  </td>
<td valign="top">Index property  </td></tr>
<tr>
<td valign="top">adMovePrevious  </td>
<td valign="top">512   </td>
<td valign="top"><i>MovePrevious</i>, <i>MoveFirst</i>, <i>
Move</i>, and <i>GetRows</i> methods  </td></tr>
<tr>
<td valign="top">adNotify  </td>
<td valign="top">262144   </td>
<td valign="top">Events  </td></tr>
<tr>
<td valign="top">adResync  </td>
<td valign="top">131072  </td>
<td valign="top"><i>Resync</i> method  </td></tr>
<tr>
<td valign="top">adSeek   </td>
<td valign="top">4194304  </td>
<td valign="top"><i>Seek</i> method  </td></tr>
<tr>
<td valign="top">adUpdate  </td>
<td valign="top">16809984  </td>
<td valign="top"><i>Update</i> method  </td></tr>
<tr>
<td valign="top">adUpdateBatch  </td>
<td valign="top">65536  </td>
<td valign="top"><i>UpdateBatch</i> and <i>CancelBatch</i>
methods  </td></tr>
</table></p>


<p>If you're building an application that allows the user to
generate ad hoc queries, you might want to use the <i>Supports</i>
method to determine which functionality is available in the Recordset
you've just opened.</p>

<p>To be truthful, I don't know the purpose of adHoldRecords. The
documentation implies that you can navigate through the Recordset and
retrieve more data without having to commit pending changes, but the
function returns True on read-only Recordsets when using this
constant.</p>

<A NAME="128"><h2><i>Update</i> Method</h2></A>
<p>Use the <i>Update</i> method to commit changes to the current
record. When you call the <i>Update</i> method, the changes are
submitted to the database as well as to the Recordset unless you're
using batch updates (LockType = adLockBatchOptimistic). In that case,
the changes in the modified records are cached until you call the <i>
UpdateBatch</i> method. The <i>Update</i> method has two optional
parameters:</p>

<ul>
<p><li> <i><b>Fields</b></i> This parameter accepts a
Variant array of field names that you want to update.</li></p>

<p><li> <i><b>Values</b></i> This parameter accepts a
Variant array of values that correspond to the fields you want to
update.</li></p>
</ul>



<p>You can use the <i>Update</i> method in one of two ways. You can
modify the Value property of Field objects and then call the <i>
Update</i> method, or you can call the <i>Update</i> method and use the
optional parameters as shown:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
rsCustomers.Update Array(&quot;CompanyName&quot;, &quot;BalanceDue&quot;), _
                   Array(&quot;New Name&quot;, 100.00)
</pre>
</td></tr></table>
</p>

<p>This code is equivalent to:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
rsCustomers.Fields(&quot;CompanyName&quot;).Value = &quot;New Name&quot;
rsCustomers.Fields(&quot;BalanceDue&quot;).Value = 100.00
rsCustomers.Update
</pre>
</td></tr></table>
</p>

<p>Note that there is no <i>Edit</i> method on the Recordset object. If
you want to modify a record, you can start by modifying the Value
property on the desired Field objects, or you can use the optional
parameters on the <i>Update</i> method as was shown.</p>

<p>If you call the <i>Update</i> method on a client-side Recordset that
is not using batch updates and does not have a connection to the
database, ADO will not generate a run-time error and will mark that
record as if it had successfully updated a database.</p>

<A NAME="129"><h2><i>UpdateBatch</i> Method</h2></A>
<p>If you're using batch updates, call <i>UpdateBatch</i> to submit
the cached changes in the Recordset to your database. This method has
one parameter:</p>

<ul>
<p><li> <i><b>AffectRecords</b></i> This is an optional
parameter that accepts a value from AffectEnum. It defaults to
adAffectAll and determines which records' pending changes you want
to submit to the database.</li></p>
</ul>



<p>You can use the <i>AffectRecords</i> parameter to control which
records' changes will be submitted to the database. (See the
&quot;<A HREF="ch04c.htm#110"><i>CancelBatch</i> Method</A>&quot; section in this chapter for more information on the behavior associated with each of the
AffectEnum values.)</p>

<p>If you call the <i>UpdateBatch</i> method on a client-side Recordset
that doesn't have a connection to the database, ADO will not
generate a run-time error and will mark the applicable records as if
they were successfully updated in a database.</p>

</BODY>
</HTML>






