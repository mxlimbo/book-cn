<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The EX16B Example</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="331"><H1>The EX16B Example</H1></A><P>This second SDI example improves on EX16A in the following ways:
<UL>
<LI>Instead of a single embedded <I>CStudent</I> object, the document now contains a list of <I>CStudent</I> objects. (Now you see the reason for 
using the <I>CStudent</I> class instead of making <I>m_strName </I>and <I>m_nGrade</I> data members of the document.)
<P><LI>Toolbar buttons allow the user to sequence through the list.
<P><LI>The application is structured to allow the addition of extra views. The Edit Clear All command is now routed to the document object, so the document's <I>UpdateAllViews</I> function and the view's <I>OnUpdate</I> function are brought into play.
<P><LI>The student-specific view code is isolated so that the <I>CEx16bView</I> class can later be transformed into a base class that contains only general-purpose code. Derived classes can override selected functions to accommodate lists of application-specific objects.
</UL>
<P>The EX16B window, shown in Figure 16-3, looks a little different from the EX16A window shown in Figure 16-1. The toolbar buttons are enabled only when appropriate. The Next (arrow-down graphic) button, for example, is disabled when we're positioned at the bottom of the list.
<P><A HREF="javascript:fullSize('f16og03x.htm')"> <img src="f16og03.jpg" width=404 height=262 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 16-3.</B> <I>The EX16B program in action.</I>
<!-- /caption -->
<P>The toolbar buttons function as follows.
<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD><B>Button</B></TD><TD><B>Function</B></TD></TR>
<TR><TD><A HREF="javascript:fullSize('G16OG05x.htm')"> <img src="G16OG05.GIF" width=24 height=23 border=0 ALT = "Click to view at full size."> </A></TD><TD>Retrieves the first student record</TD></TR>
<TR><TD><IMG SRC="G16OG06.GIF" width=24 height=23 BORDER=0></TD><TD>Retrieves the last student record</TD></TR>
<TR><TD><IMG SRC="G16OG07.GIF" width=24 height=23 BORDER=0></TD><TD>Retrieves the previous student record</TD></TR>
<TR><TD><IMG SRC="G16OG08.GIF" width=24 height=23 BORDER=0></TD><TD>Retrieves the next student record</TD></TR>
<TR><TD><IMG SRC="G16OG09.GIF" width=24 height=23 BORDER=0></TD><TD>Deletes the current student record</TD></TR>
<TR><TD><IMG SRC="G16OG10.GIF" width=24 height=23 BORDER=0></TD><TD>Inserts a new student record</TD></TR>
</TABLE>
<P>The Clear button in the view window clears the contents of the Name and Grade edit controls. The Clear All command on the Edit menu deletes all the student records in the list and clears the view's edit controls.
<P>This example deviates from the step-by-step format in the previous examples. Because there's now more code, we'll simply list selected code and the resource requirements. In the listing figures, boldface code indicates additional code or other changes that you enter in the output from AppWizard and ClassWizard. The frequent use of <I>TRACE</I> statements lets you follow the program's execution in the debugging window.
<A NAME="332"><H2>Resource Requirements</H2></A><P>The file ex16b.rc defines the application's resources as follows.
<A NAME="333"><H3>Toolbar</H3></A><P>The toolbar (visible in Figure 16-3) was created by erasing the Edit Cut, Copy, and Paste tiles (fourth, fifth, and sixth from the left) and replacing them with six new patterns. The Flip Vertical command (on the Image menu) was used to duplicate some of the tiles. The ex16b.rc file defines the linkage between the command IDs and the toolbar buttons.
<A NAME="334"><H3>Student Menu</H3></A><P>Having menu options that correspond to the new toolbar buttons isn't absolutely necessary. (ClassWizard allows you to map toolbar button commands just as easily as menu commands.) However, most applications for Microsoft Windows have menu options for all commands, so users generally expect them.
<A NAME="335"><H3>Edit Menu</H3></A><P>On the Edit menu, the clipboard menu items are replaced by the Clear All menu item. See step 2 for an illustration of the Edit menu.
<A NAME="336"><H3>The <I>IDD_STUDENT</I> Dialog Template</H3></A><P>The <I>IDD_STUDENT</I> dialog template, shown here, is similar to the EX16A dialog shown in Figure 16-1 except that the Enter pushbutton has been replaced by the Clear pushbutton.
<P><IMG SRC="G16OG11.GIF" width=290 height=168 BORDER=0>
<P>The following IDs identify the controls.
<P><TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD><b>Control</b></TD><TD><b>ID</b></TD></TR>
<TR><TD>Name edit control</TD><TD><I>IDC_NAME</I></TD></TR>
<TR><TD>Grade edit control</TD><TD><I>IDC_GRADE</I></TD></TR>
<TR><TD>Clear pushbutton</TD><TD><I>IDC_CLEAR</I></TD></TR>
</TABLE>
<P>The controls' styles are the same as for the EX16A program.
<A NAME="337"><H2>Code Requirements</H2></A><P>Here's a list of the files and classes in the EX16B example.<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD><B>Header File</B></TD><TD><B>Source Code File</B></TD><TD><B>Classes</B></TD><TD><B>Description</B></TD></TR>
<TR><TD>ex16b.h</TD><TD>ex16b.cpp</TD><TD><I>CEx16bApp</I></TD><TD>Application class 
(from AppWizard)</TD></TR>
<TR><TD>&nbsp;</TD><TD>&nbsp;</TD><TD><I>CAboutDlg</I></TD><TD>About dialog</TD></TR>
<TR><TD>MainFrm.h</TD><TD>MainFrm.cpp</TD><TD><I>CMainFrame</I></TD><TD>SDI main frame</TD></TR>
<TR><TD>StuDoc.h</TD><TD>StuDoc.cpp</TD><TD><I>CStudentDoc</I></TD><TD>Student document</TD></TR>
<TR><TD>StuView.h</TD><TD>StuView.cpp</TD><TD>
<I>CStudentView</I></TD><TD>Student form view (derived from <I>CFormView</I>)</TD></TR>
<TR><TD>Student.h</TD><TD>Student.cpp</TD><TD><I>CStudent</I></TD><TD>Student record (similar to EX16A)</TD></TR>
<TR><TD>StdAfx.h</TD><TD>StdAfx.cpp</TD><TD>Includes the standard precompiled headers</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P>
<A NAME="338"><H3><I>CEx16bApp</I></H3></A><P>The files ex16b.cpp and ex16b.h are standard AppWizard output.
<A NAME="339"><H3><I>CMainFrame</I></H3></A><P>The code for the <I>CMainFrame</I> class in MainFrm.cpp is standard AppWizard output.
<A NAME="340"><H3><I>CStudent</I></H3></A><P>This is the code from EX16A, except for the following line added at the end of Student.h:
<P><PRE><B>typedef CTypedPtrList&lt;CObList, CStudent*&gt; CStudentList;</B></PRE>
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
Use of the MFC template collection classes requires the following statement in StdAfx.h:
<P><PRE><B>#include &lt;afxtempl.h&gt;</B></PRE>
</BLOCKQUOTE></DIV>
<P>
<A NAME="341"><H3><I>CStudentDoc</I></H3></A><P>AppWizard originally generated the <I>CStudentDoc</I> class. Figure 16-4 shows the code used in the EX16B example.<P>

<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>STUDOC.H</B>
<P>
<PRE>// StuDoc.h : interface of the CStudentDoc class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STUDOC_H__4D011047_7E1C_11D0_8FE0_00C04FC2A0C2__INCLUDED_)
#define AFX_STUDOC_H__4D011047_7E1C_11D0_8FE0_00C04FC2A0C2__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

<B>#include &quot;student.h&quot;</B>

class CStudentDoc : public CDocument
{
protected: // create from serialization only
    CStudentDoc();
    DECLARE_DYNCREATE(CStudentDoc)

// Attributes
public:
    <B>CStudentList* GetList() {
        return &amp;m_studentList;
    }</B>

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CStudentDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive&amp; ar);
    virtual void DeleteContents();
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CStudentDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CStudentDoc)
    afx_msg void OnEditClearAll();
    afx_msg void OnUpdateEditClearAll(CCmdUI* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
<B>private:
    CStudentList m_studentList;</B>
};

//////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.

#endif // !defined(AFX_STUDOC_H__4D011047_7E1C_11D0_8FE0_00C04FC2A0C2__INCLUDED_)</PRE>
<P><B>STUDOC.CPP</B>
<P>
<PRE>// StuDoc.cpp : implementation of the CStudentDoc class
//

#include &quot;stdafx.h&quot;
#include &quot;ex16b.h&quot;

#include &quot;StuDoc.h&quot;
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// CStudentDoc

IMPLEMENT_DYNCREATE(CStudentDoc, CDocument)

BEGIN_MESSAGE_MAP(CStudentDoc, CDocument)
    //{{AFX_MSG_MAP(CStudentDoc)
    ON_COMMAND(ID_EDIT_CLEAR_ALL, OnEditClearAll)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CLEAR_ALL, OnUpdateEditClearAll)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
// CStudentDoc construction/destruction

CStudentDoc::CStudentDoc()
{
    <B>TRACE(&quot;Entering CStudentDoc constructor\n&quot;);
#ifdef _DEBUG
    afxDump.SetDepth(1); // Ensure dump of list elements
#endif // _DEBUG</B>
}

CStudentDoc::~CStudentDoc()
{
}

BOOL CStudentDoc::OnNewDocument()
{
    <B>TRACE(&quot;Entering CStudentDoc::OnNewDocument\n&quot;);</B>
    if (!CDocument::OnNewDocument())
        return FALSE;

    // TODO: add reinitialization code here
    // (SDI documents will reuse this document)

    return TRUE;
}
//////////////////////////////////////////////////////////////////////
// CStudentDoc serialization

void CStudentDoc::Serialize(CArchive&amp; ar)
{
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
}

//////////////////////////////////////////////////////////////////////
// CStudentDoc diagnostics

#ifdef _DEBUG
void CStudentDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CStudentDoc::Dump(CDumpContext&amp; dc) const
{
    CDocument::Dump(dc);
    <B>dc &lt;&lt; &quot;\n&quot; &lt;&lt; m_studentList &lt;&lt; &quot;\n&quot;;</B>
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////
// CStudentDoc commands

void CStudentDoc::DeleteContents() 
{
<B>#ifdef _DEBUG
    Dump(afxDump);
#endif
    while (m_studentList.GetHeadPosition()) {
        delete m_studentList.RemoveHead();
    }</B>
}
void CStudentDoc::OnEditClearAll() 
{
    <B>DeleteContents();
    UpdateAllViews(NULL);</B>
}

void CStudentDoc::OnUpdateEditClearAll(CCmdUI* pCmdUI) 
{
    <B>pCmdUI-&gt;Enable(!m_studentList.IsEmpty());</B>
}</PRE>
</TD></TR></TABLE>

<B>Figure 16-4.</B> <I>The </I>CStudentDoc<I> class listing.</I>


<P>

<A NAME="342"><H3>ClassWizard and <I>CStudentDoc</I></H3></A><P>The Edit Clear All command is handled in the document class. The 
following message handlers were added through ClassWizard.
<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD><B>Object ID</B></TD><TD><B>Message</B></TD><TD><B>Member Function</B></TD></TR>
<TR><TD><I>ID_EDIT_CLEAR_ALL</I></TD><TD>COMMAND</TD><TD><I>OnEditClearAll</I></TD></TR>
<TR><TD><I>ID_EDIT_CLEAR_ALL</I></TD><TD>ON_UPDATE_COMMAND_UI</TD><TD><I>OnUpdateEditClearAll</I></TD></TR>
</TABLE>
<P>
<A NAME="343"><H3>Data Members</H3></A><P>The document class provides for an embedded 
<I>CStudentList</I> object, the 
<I>m_studentList</I> data member, which holds pointers to 
<I>CStudent</I> objects. The list 
object is constructed when the <I>CStudentDoc</I> object is constructed, and it 
is destroyed at program exit. <I>CStudentList</I> is a 
<I>typedef</I> for a <I>CTypedPtrList</I> for 
<I>CStudent</I> pointers.
<A NAME="344"><H3>Constructor</H3></A><P>The document constructor sets the depth of the dump context so that a 
dump of the list causes dumps of the individual list elements.
<A NAME="345"><H3><I>GetList</I></H3></A><P>The inline <I>GetList</I> function helps isolate the view from the document. The 
document class must be specific to the type of object in the list&#151;in this case, 
objects of the class <I>CStudent</I>. A generic list view base class, however, can use a 
member function to get a pointer to the list without knowing the name of the list 
object.
<A NAME="346"><H3><I>DeleteContents</I></H3></A><P>The <I>DeleteContents</I> function is a virtual override function that is called by 
other document functions and by the application framework. Its job is to remove 
all student object pointers from the document's list and to delete those 
student objects. An important point to remember here is that SDI document 
objects are reused after they are closed. 
<I>DeleteContents</I> also dumps the student list.
<A NAME="347"><H3><I>Dump</I></H3></A><P>AppWizard generates the <I>Dump</I> function skeleton between the lines 
<I>#ifdef _DEBUG</I> and <I>#endif</I>. Because the 
<I>afxDump</I> depth was set to 1 in the document constructor, all the 
<I>CStudent</I> objects contained in the list are dumped.
<A NAME="348"><H3><I>CStudentView</I></H3></A><P>Figure 16-5 shows the code for the 
<I>CStudentView</I> class. This code will be 
carried over into the next two chapters.

<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>STUVIEW.H</B>
<P>
<PRE>// StuView.h : interface of the CStudentView class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_STUVIEW_H__4D011049_7E1C_11D0_8FE0_00C04FC2A0C2__INCLUDED_)
#define AFX_STUVIEW_H__4D011049_7E1C_11D0_8FE0_00C04FC2A0C2__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

class CStudentView : public CFormView
{
<B>protected:
    POSITION      m_position; // current position in document list
    CStudentList* m_pList;    // copied from document</B>

protected: // create from serialization only
    CStudentView();
    DECLARE_DYNCREATE(CStudentView)

public:
    //{{AFX_DATA(CStudentView)
    enum { IDD = IDD_STUDENT };
    int     m_nGrade;
    CString m_strName;
    //}}AFX_DATA

// Attributes
public:
    CStudentDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CStudentView)
    public:
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    protected:
    virtual void DoDataExchange(CDataExchange* pDX); // DDX/DDV support
    virtual void OnInitialUpdate(); // called first time after construct
    virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CStudentView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:
    <B>virtual void ClearEntry();
    virtual void InsertEntry(POSITION position);
    virtual void GetEntry(POSITION position);</B>

// Generated message map functions
protected:
    //{{AFX_MSG(CStudentView)
    afx_msg void OnClear();
    afx_msg void OnStudentHome();
    afx_msg void OnStudentEnd();
    afx_msg void OnStudentPrev();
    afx_msg void OnStudentNext();
    afx_msg void OnStudentIns();
    afx_msg void OnStudentDel();
    afx_msg void OnUpdateStudentHome(CCmdUI* pCmdUI);
    afx_msg void OnUpdateStudentEnd(CCmdUI* pCmdUI);
    afx_msg void OnUpdateStudentDel(CCmdUI* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in StuView.cpp
inline CStudentDoc* CStudentView::GetDocument()
   { return (CStudentDoc*)m_pDocument; }
#endif

//////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.

#endif // !defined(AFX_STUVIEW_H__4D011049_7E1C_11D0_8FE0_00C04FC2A0C2__INCLUDED_)</PRE>
<P><B>STUVIEW.CPP</B>
<P>
<PRE>// StuView.cpp : implementation of the CStudentView class
//

#include &quot;stdafx.h&quot;
#include &quot;ex16b.h&quot;

#include &quot;StuDoc.h&quot;
#include &quot;StuView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__ ;
#endif

//////////////////////////////////////////////////////////////////////
// CStudentView

IMPLEMENT_DYNCREATE(CStudentView, CFormView)
BEGIN_MESSAGE_MAP(CStudentView, CFormView)
    //{{AFX_MSG_MAP(CStudentView)
    ON_BN_CLICKED(IDC_CLEAR, OnClear)
    ON_COMMAND(ID_STUDENT_HOME, OnStudentHome)
    ON_COMMAND(ID_STUDENT_END, OnStudentEnd)
    ON_COMMAND(ID_STUDENT_PREV, OnStudentPrev)
    ON_COMMAND(ID_STUDENT_NEXT, OnStudentNext)
    ON_COMMAND(ID_STUDENT_INS, OnStudentIns)
    ON_COMMAND(ID_STUDENT_DEL, OnStudentDel)
    ON_UPDATE_COMMAND_UI(ID_STUDENT_HOME, OnUpdateStudentHome)
    ON_UPDATE_COMMAND_UI(ID_STUDENT_END, OnUpdateStudentEnd)
    ON_UPDATE_COMMAND_UI(ID_STUDENT_PREV, OnUpdateStudentHome)
    ON_UPDATE_COMMAND_UI(ID_STUDENT_NEXT, OnUpdateStudentEnd)
    ON_UPDATE_COMMAND_UI(ID_STUDENT_DEL, OnUpdateStudentDel)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
// CStudentView construction/destruction

CStudentView::CStudentView()
    : CFormView(CStudentView::IDD)
{
    <B>TRACE(&quot;Entering CStudentView constructor\n&quot;);</B>
    //{{AFX_DATA_INIT(CStudentView)
    m_nGrade = 0;
    m_strName = _T(&quot;&quot;);
    //}}AFX_DATA_INIT
    <B>m_position = NULL;</B>
}

CStudentView::~CStudentView()
{
}

void CStudentView::DoDataExchange(CDataExchange* pDX)
{
    CFormView::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CStudentView)
    DDX_Text(pDX, IDC_GRADE, m_nGrade);
    DDV_MinMaxInt(pDX, m_nGrade, 0, 100);
    DDX_Text(pDX, IDC_NAME, m_strName);
    DDV_MaxChars(pDX, m_strName, 20);
    //}}AFX_DATA_MAP
}
BOOL CStudentView::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs
    return CFormView::PreCreateWindow(cs);
}

void CStudentView::OnInitialUpdate() 
{
    <B>TRACE(&quot;Entering CStudentView::OnInitialUpdate\n&quot;);
    m_pList = GetDocument()-&gt;GetList();</B>
    CFormView::OnInitialUpdate();
}

//////////////////////////////////////////////////////////////////////
// CStudentView diagnostics

#ifdef _DEBUG
void CStudentView::AssertValid() const
{
    CFormView::AssertValid();
}

void CStudentView::Dump(CDumpContext&amp; dc) const
{
    CFormView::Dump(dc);
}

CStudentDoc* CStudentView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CStudentDoc)));
    return (CStudentDoc*)m_pDocument;
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////
// CStudentView message handlers

void CStudentView::OnClear() 
{
    <B>TRACE(&quot;Entering CStudentView::OnClear\n&quot;);
    ClearEntry();</B>
}

void CStudentView::OnUpdate(CView* pSender, LPARAM lHint,
                            CObject* pHint) 
{
    <B>// called by OnInitialUpdate and by UpdateAllViews
    TRACE(&quot;Entering CStudentView::OnUpdate\n&quot;);
    m_position = m_pList-&gt;GetHeadPosition();
    GetEntry(m_position); // initial data for view</B>
}

void CStudentView::OnStudentHome() 
{
    <B>TRACE(&quot;Entering CStudentView::OnStudentHome\n&quot;);
    // need to deal with list empty condition
    if (!m_pList-&gt;IsEmpty()) {
        m_position = m_pList-&gt;GetHeadPosition();
        GetEntry(m_position);
    }</B>
}

void CStudentView::OnStudentEnd() 
{
    <B>TRACE(&quot;Entering CStudentView::OnStudentEnd\n&quot;);
    if (!m_pList-&gt;IsEmpty()) {
        m_position = m_pList-&gt;GetTailPosition();
        GetEntry(m_position);
    }</B>
}

void CStudentView::OnStudentPrev() 
{
    <B>POSITION pos;
    TRACE(&quot;Entering CStudentView::OnStudentPrev\n&quot;);
    if ((pos = m_position) != NULL) {
        m_pList-&gt;GetPrev(pos);
        if (pos) {
            GetEntry(pos);
      m_position = pos;
        }
    }</B>
}

void CStudentView::OnStudentNext() 
{
    <B>POSITION pos;
    TRACE(&quot;Entering CStudentView::OnStudentNext\n&quot;);
    if ((pos = m_position) != NULL) {
        m_pList-&gt;GetNext(pos);
        if (pos) {
            GetEntry(pos);
            m_position = pos;
        }
    }</B>
}
void CStudentView::OnStudentIns() 
{
    <B>TRACE(&quot;Entering CStudentView::OnStudentIns\n&quot;);
    InsertEntry(m_position);
    GetDocument()-&gt;SetModifiedFlag();
    GetDocument()-&gt;UpdateAllViews(this);</B>
}

void CStudentView::OnStudentDel() 
{
    <B>// deletes current entry and positions to next one or head
    POSITION pos;
    TRACE(&quot;Entering CStudentView::OnStudentDel\n&quot;);
    if ((pos = m_position) != NULL) {
        m_pList-&gt;GetNext(pos);
        if (pos == NULL) {
            pos = m_pList-&gt;GetHeadPosition();
            TRACE(&quot;GetHeadPos = %ld\n&quot;, pos);
            if (pos == m_position) {
                pos = NULL;
            }
        }
        GetEntry(pos);
        CStudent* ps = m_pList-&gt;GetAt(m_position);
        m_pList-&gt;RemoveAt(m_position);
        delete ps;
        m_position = pos;
        GetDocument()-&gt;SetModifiedFlag();
        GetDocument()-&gt;UpdateAllViews(this);
    }</B>
}

void CStudentView::OnUpdateStudentHome(CCmdUI* pCmdUI) 
{
    <B>// called during idle processing and when Student menu drops down
    POSITION pos;

    // enables button if list not empty and not at home already
    pos = m_pList-&gt;GetHeadPosition();
    pCmdUI-&gt;Enable((m_position != NULL) &amp;&amp; (pos != m_position));</B>
}

void CStudentView::OnUpdateStudentEnd(CCmdUI* pCmdUI) 
{
    <B>// called during idle processing and when Student menu drops down
    POSITION pos;

    // enables button if list not empty and not at end already
    pos = m_pList-&gt;GetTailPosition();
    pCmdUI-&gt;Enable((m_position != NULL) &amp;&amp; (pos != m_position));</B>
}

void CStudentView::OnUpdateStudentDel(CCmdUI* pCmdUI) 
{
    <B>// called during idle processing and when Student menu drops down
    pCmdUI-&gt;Enable(m_position != NULL);</B>
}

<B>void CStudentView::GetEntry(POSITION position)
{
    if (position) {
        CStudent* pStudent = m_pList-&gt;GetAt(position);
        m_strName = pStudent-&gt;m_strName;
        m_nGrade = pStudent-&gt;m_nGrade;
    }
    else {
        ClearEntry();
    }
    UpdateData(FALSE);
}

void CStudentView::InsertEntry(POSITION position)
{
    if (UpdateData(TRUE)) {
        // UpdateData returns FALSE if it detects a user error
        CStudent* pStudent = new CStudent;
        pStudent-&gt;m_strName = m_strName;
        pStudent-&gt;m_nGrade = m_nGrade;
        m_position = m_pList-&gt;InsertAfter(m_position, pStudent);
    }
}

void CStudentView::ClearEntry()
{
    m_strName = &quot;&quot;;
    m_nGrade = 0;
    UpdateData(FALSE);
    ((CDialog*) this)-&gt;GotoDlgCtrl(GetDlgItem(IDC_NAME));
}</B></PRE>

</TD></TR></TABLE>
<P><B>Figure 16-5.</B> <I>The </I>CStudentView<I> class listing.</I>


<A NAME="349"><H3>ClassWizard and <I>CStudentView</I></H3></A><P>ClassWizard was used to map the 
<I>CStudentView</I> Clear pushbutton notification message as follows.
<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD><B>Object ID</B></TD><TD><B>Message</B></TD><TD><B>Member Function</B></TD></TR>
<TR><TD><I>IDC_CLEAR</I></TD><TD>BN_CLICKED</TD><TD><I>OnClear</I></TD></TR>
</TABLE>
<P>Because <I>CStudentView</I> is derived from 
<I>CFormView</I>, ClassWizard supports the definition of dialog data members. The variables shown here were added with the Add Variables button.
<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD><B>Control ID</B></TD><TD><B>Member Variable</B></TD><TD><B>Category</B></TD><TD><B>Variable Type</B></TD></TR>
<TR><TD><I>IDC_GRADE</I></TD><TD><I>m_nGrade</I></TD><TD>Value</TD><TD>
<I>int</I></TD></TR>
<TR><TD><I>IDC_NAME</I></TD><TD><I>m_strName</I></TD><TD>Value</TD><TD>
<I>CString</I></TD></TR>
</TABLE>
<P>The minimum value of the <I>m_nGrade</I> data member was set to 0, and its 
maximum value was set to 100. The maximum length of the 
<I>m_strName</I> data member was set to 20 characters.
<P>ClassWizard maps toolbar button commands to their handlers. Here 
are the commands and the handler functions to which they were mapped.
<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD><B>Object ID</B></TD><TD><B>Message</B></TD><TD><B>Member Function</B></TD></TR>
<TR><TD><I>ID_STUDENT_HOME</I></TD><TD>COMMAND</TD><TD><I>OnStudentHome</I></TD></TR>
<TR><TD><I>ID_STUDENT_END</I></TD><TD>COMMAND</TD><TD><I>OnStudentEnd</I></TD></TR>
<TR><TD><I>ID_STUDENT_PREV</I></TD><TD>COMMAND</TD><TD><I>OnStudentPrev</I></TD></TR>
<TR><TD><I>ID_STUDENT_NEXT</I></TD><TD>COMMAND</TD><TD><I>OnStudentNext</I></TD></TR>
<TR><TD><I>ID_STUDENT_INS</I></TD><TD>COMMAND</TD><TD><I>OnStudentIns</I></TD></TR>
<TR><TD><I>ID_STUDENT_DEL</I></TD><TD>COMMAND</TD><TD><I>OnStudentDel</I></TD></TR>
</TABLE>
<P>Each command handler has built-in error checking.
<P>The following update command UI message handlers are called during 
idle processing to update the state of the toolbar buttons and, when the 
Student menu is painted, to update the menu items.<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD><B>Object ID</B></TD><TD><B>Message</B></TD><TD><B>Member Function</B></TD></TR>
<TR><TD><I>ID_STUDENT_HOME</I></TD><TD>UPDATE_COMMAND_UI</TD><TD>
<I>OnUpdateStudentHome</I></TD></TR>
<TR><TD><I>ID_STUDENT_END</I></TD><TD>UPDATE_COMMAND_UI</TD><TD>
<I>OnUpdateStudentEnd</I></TD></TR>
<TR><TD><I>ID_STUDENT_PREV</I></TD><TD>UPDATE_COMMAND_UI</TD><TD>
<I>OnUpdateStudentHome</I></TD></TR>
<TR><TD><I>ID_STUDENT_NEXT</I></TD><TD>UPDATE_COMMAND_UI</TD><TD>
<I>OnUpdateStudentEnd</I></TD></TR>
<TR><TD><I>ID_STUDENT_DEL</I></TD><TD>UPDATE_COMMAND_UI</TD><TD>
<I>OnUpdateCommandDel</I></TD></TR>
</TABLE>
<P>For example, this button,
<P><IMG SRC="G16OG12.GIF" width=24 height=23 BORDER=0>
<P>which retrieves the first student record, is disabled when the list is empty 
and when the <I>m_position</I> variable is already set to the head of the list. The 
Previous button is disabled under the same circumstances, so it uses the same 
update command UI handler. The End and the Next buttons share a handler for 
similar reasons. Because a delay sometimes occurs in calling the update 
command UI functions, the command message handlers must look for error conditions.
<A NAME="350"><H3>Data Members</H3></A><P>The <I>m_position</I> data member is a kind of cursor for the document's 
collection. It contains the position of the 
<I>CStudent</I> object that is currently displayed. 
The <I>m_pList</I> variable provides a quick way to get at the student list in the document.
<A NAME="351"><H3><I>OnInitialUpdate</I></H3></A><P>The virtual <I>OnInitialUpdate</I> function is called when you start the 
application. It sets the view's <I>m_pList</I> data member for subsequent access to the 
document's list object.
<A NAME="352"><H3><I>OnUpdate</I></H3></A><P>The virtual <I>OnUpdate</I> function is called both by the 
<I>OnInitialUpdate</I> function and by the 
<I>CDocument::UpdateAllViews</I> function. It resets the list position 
to the head of the list, and it displays the head entry. In this example, the 
<I>UpdateAllViews</I> function is called only in response to the Edit Clear All command. 
In a multiview application, you might need a different strategy for setting the 
<I>CStudentView m_position</I> variable in response to document updates from another view.
<A NAME="353"><H2>Protected Virtual Functions</H2></A><P>The following three functions are protected virtual functions that deal 
specifically with <I>CStudent</I> objects:
<BLOCKQUOTE><I>GetEntry</I>
<P><I>InsertEntry</I>
<P><I>ClearEntry</I>
</BLOCKQUOTE>
<P>You can transfer these functions to a derived class if you want to isolate the 
general-purpose list-handling features in a base class.
<A NAME="354"><H2>Testing the EX16B Application</H2></A><P>Fill in the student name and grade fields, and then click this button
<P><IMG SRC="G16OG13.GIF" width=24 height=23 BORDER=0>
<P>to insert the entry into the list. Repeat this action several times, using the 
Clear pushbutton to erase the data from the previous entry. When you exit the 
application, the debug output should look similar to this:
<P><PRE>a CStudentDoc at $4116D0
m_strTitle = Untitled
m_strPathName = 
m_bModified = 1
m_pDocTemplate = $4113F1

a CObList at $411624
with 4 elements
    a CStudent at $412770
m_strName = Fisher, Lon
m_nGrade = 67
    a CStudent at $412E80
m_strName = Meyers, Lisa
m_nGrade = 80
    a CStudent at $412880
m_strName = Seghers, John
m_nGrade = 92
    a CStudent at $4128F0
m_strName = Anderson, Bob
m_nGrade = 87</PRE>
</BODY>
</HTML>



