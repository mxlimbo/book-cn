<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>WinInet</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="900"><H1>WinInet</H1></A><P>WinInet is a higher-level API than Winsock, but it works only for HTTP, 
FTP, and gopher <U>client</U> programs in both asynchronous and synchronous modes. 
You can't use it to build servers. The WININET DLL is independent of the 
WINSOCK32 DLL. Microsoft Internet Explorer 3.0 (IE3) uses WinInet, and so 
do ActiveX controls.
<A NAME="901"><H2>WinInet's Advantages over Winsock</H2></A><P>WinInet far surpasses Winsock in the support it gives to a professional-level 
client program. Following are just some of the WinInet benefits:
<UL>
<LI><B>Caching</B>&#151;Just like IE3, your WinInet client program caches 
HTML files and other Internet files. You don't have to do a thing. The 
second time your client requests a particular file, it's loaded from a 
local disk instead of from the Internet.
<P><LI><B>Security</B>&#151;WinInet supports basic authentication, Windows 
NT challenge/response authentication, and the Secure Sockets 
Layer (SSL). Authentication is described in <A HREF="ch35a.htm">Chapter 35</A>.
<P><LI><B>Web proxy access</B>&#151;You enter proxy server information through the Control Panel (click on the Internet icon), and it's stored in 
the Registry. WinInet reads the Registry and uses the proxy server 
when required.
<P><LI><B>Buffered I/O</B>&#151;WinInet's read function doesn't return until it 
can deliver the number of bytes you asked for. (It returns immediately, of course, if the server closes the socket.) Also, you can read 
individual text lines if you need to.
<P><LI><B>Easy API</B>&#151;Status callback functions are available for UI update 
and cancellation. One function, 
<I>CInternetSession::OpenURL</I>, finds the server's IP address, opens a connection, and makes the file ready for reading, all in one call. Some functions even copy Internet files 
directly to and from disk.
<P><LI><B>User friendly</B>&#151;WinInet parses and formats headers for you. If 
a server has moved a file to a new location, it sends back the new 
URL in an HTTP Location header. WinInet seamlessly accesses the 
new server for you. In addition, WinInet puts a file's modified date in 
the request header for you.<P>
</UL>
<A NAME="902"><H2>The MFC WinInet Classes</H2></A><P>WinInet is a modern API available only for Win32. The MFC wrapping is 
quite good, which means we didn't have to write our own WinInet class library. 
Yes, MFC WinInet supports blocking calls in multithreaded programs, and by 
now you know that makes us happy.
<P>The MFC classes closely mirror the underlying WinInet architecture, 
and they add exception processing. These classes are summarized in the sections 
on the following pages.
<A NAME="903"><H3><I>CInternetSession</I></H3></A><P>You need only one <I>CInternetSession</I> object for each thread that accesses 
the Internet. After you have your 
<I>CInternetSession</I> object, you can establish 
HTTP, FTP, or gopher connections or you can open remote files directly by calling 
the <I>OpenURL</I> member function. You can use the 
<I>CInternetSession</I> class directly, or you can derive a class from it in order to support 
<U>status</U> <U>callback</U> functions.
<P>The <I>CInternetSession</I> constructor calls the WinInet 
<I>InternetOpen</I> function, which returns an 
<I>HINTERNET</I> <U>session</U> <U>handle</U> that is stored inside the 
<I>CInternetSession</I> object. This function initializes your application's use of the Win-
Inet library, and the session handle is used internally as a parameter for 
other WinInet calls.
<A NAME="904"><H3><I>CHttpConnection</I></H3></A><P>An object of class <I>CHttpConnection</I> represents a &quot;permanent&quot; HTTP 
connection to a particular host. You know already that 
HTTP doesn't support permanent connections and that FTP doesn't either. (The connections last only 
for the duration of a file transfer.) WinInet gives the appearance of a 
permanent connection because it remembers the host name.
<P>After you have your <I>CInternetSession</I> object, you call the 
<I>GetHttpConnection</I> member function, which returns a pointer to a 
<I>CHttpConnection</I> 
object. (Don't forget to delete this object when you are finished with it.)
<P>The <I>GetHttpConnection</I> member function calls the WinInet 
<I>InternetConnect</I> function, which returns an 
<I>HINTERNET</I> <U>connection</U> <U>handle</U> that 
is stored inside the <I>CHttpConnection</I> object and used for subsequent WinInet calls.
<A NAME="905"><H3><I>CFtpConnection</I>, <I>CGopherConnection</I></H3></A><P>These classes are similar to 
<I>CHttpConnection</I>, but they use the FTP and 
gopher protocols. The <I>CFtpConnection</I> member functions 
<I>GetFile</I> and <I>PutFile</I> allow you to transfer files directly to and from your disk.
<A NAME="906"><H3><I>CInternetFile</I></H3></A><P>With HTTP, FTP, or gopher, your client program reads and writes byte 
streams. The MFC WinInet classes make these byte streams look like ordinary files. 
If you look at the class hierarchy, you'll see that 
<I>CInternetFile</I> is derived from 
<I>CStdioFile</I>, which is derived from 
<I>CFile</I>. Therefore, <I>CInternetFile</I> and its 
derived classes override familiar <I>CFile</I> functions such as 
<I>Read</I> and <I>Write</I>. For FTP files, you use 
<I>CInternetFile</I> objects directly, but for HTTP and gopher files, 
you use objects of the derived classes 
<I>CHttpFile</I> and <I>CGopherFile</I>. You don't 
construct a <I>CInternetFile</I> object directly, but you call 
<I>CFtpConnection::OpenFile</I> to get a 
<I>CInternetFile</I> pointer.
<P>If you have an ordinary <I>CFile</I> object, it has a 32-bit 
<I>HANDLE</I> data member that represents the underlying disk file. A 
<I>CInternetFile</I> object uses the same 
<I>m_hFile</I> data member, but that data member holds a 32-bit 
<U>Internet</U> <U>file</U> <U>handle</U> of type 
<I>HINTERNET</I>, which is not interchangeable with a 
<I>HANDLE</I>. The <I>CInternetFile</I> overridden member functions use this handle to call 
WinInet functions such as <I>InternetReadFile</I> and 
<I>InternetWriteFile</I>.
<A NAME="907"><H3><I>CHttpFile</I></H3></A><P>This Internet file class has member functions that are unique to HTTP files, 
such as <I>AddRequestHeaders</I>, 
<I>SendRequest</I>, and <I>GetFileURL</I>. You don't construct 
a <I>CHttpFile</I> object directly, but you call the 
<I>CHttpConnection::OpenRequest</I> 
function, which calls the WinInet function 
<I>HttpOpenRequest</I> and returns a 
<I>CHttpFile</I> pointer. You can specify a GET or POST request for this call.
<P>Once you have your <I>CHttpFile</I> pointer, you call the 
<I>CHttpFile::SendRequest</I> member function, which actually sends the request to the server. 
Then you call <I>Read</I>.
<A NAME="908"><H3><I>CFtpFileFind</I>, <I>CGopherFileFind</I></H3></A><P>These classes let your client program explore FTP and gopher directories.
<A NAME="909"><H3><I>CInternetException</I></H3></A><P>The MFC WinInet classes throw 
<I>CInternetException</I> objects that your 
program can process with try/catch logic.
<A NAME="910"><H2>Internet Session Status Callbacks</H2></A><P>WinInet and MFC provide callback notifications as a WinInet operation 
progresses, and these status callbacks are available in both synchronous 
(blocking) and asynchronous modes. In synchronous mode (which we're using 
exclusively here), your WinInet calls block even though you have status callbacks enabled.
<P>Callbacks are easy in C++. You simply derive a class and override 
selected virtual functions. The base class for WinInet is 
<I>CInternetSession</I>. Now let's derive a class named 
<I>CCallbackInternetSession</I>:
<P><PRE>class CCallbackInternetSession : public CInternetSession
{
public:
    CCallbackInternetSession( LPCTSTR pstrAgent = NULL, DWORD dwContext = 1,
        DWORD dwAccessType = PRE_CONFIG_INTERNET_ACCESS,
        LPCTSTR pstrProxyName = NULL, LPCTSTR pstrProxyBypass = NULL,
        DWORD dwFlags = 0 ) { EnableStatusCallback() }
protected:
    virtual void OnStatusCallback(DWORD dwContext, DWORD dwInternalStatus,
        LPVOID lpvStatusInformation, DWORD dwStatusInformationLength);
};</PRE>
<P>The only coding that's necessary is a constructor and a single 
overridden function, <I>OnStatusCallback</I>. The constructor calls 
<I>CInternetSession::EnableStatusCallback</I> to enable the status callback feature. Your WinInet client 
program makes its various Internet blocking calls, and when the status 
changes, <I>OnStatusCallback</I> is called. Your overridden function quickly updates the 
UI and returns, and then the Internet operation continues. For 
HTTP, most of the callbacks originate in the 
<I>CHttpFile::SendRequest</I> function.
<P>What kind of events trigger callbacks? A list of the codes passed in 
the <I>dwInternalStatus</I> parameter is shown here.
<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>Code Passed</B></TD><TD VALIGN="TOP"><B>Action Taken</B></TD></TR>
<TR><TD VALIGN="TOP"><I>INTERNET_STATUS_RESOLVING_NAME</I></TD><TD VALIGN="TOP">Looking up the IP 
address of the supplied
name. The name is now in 
<I>lpvStatusInformation</I>.</TD></TR>
<TR><TD VALIGN="TOP"><I>INTERNET_STATUS_NAME_RESOLVED</I></TD><TD VALIGN="TOP">Successfully found the 
IP address. The IP address 
is now in <I>lpvStatusInformation</I>.</TD></TR>
<TR><TD VALIGN="TOP"><I>INTERNET_STATUS_CONNECTING_TO_SERVER</I></TD><TD VALIGN="TOP">Connecting to the socket.</TD></TR>
<TR><TD VALIGN="TOP"><I>INTERNET_STATUS_CONNECTED_TO_SERVER</I></TD><TD VALIGN="TOP">Successfully connected 
to the socket.</TD></TR>
<TR><TD VALIGN="TOP"><I>INTERNET_STATUS_SENDING_REQUEST</I></TD><TD VALIGN="TOP">Send the information 
request to the server.</TD></TR>
<TR><TD VALIGN="TOP"><I>INTERNET_STATUS_REQUEST_SENT</I></TD><TD VALIGN="TOP">Successfully sent the 
information request to the server.</TD></TR>
<TR><TD VALIGN="TOP"><I>INTERNET_STATUS_RECEIVING_RESPONSE</I></TD><TD VALIGN="TOP">Waiting for the server 
to respond to a request.</TD></TR>
<TR><TD VALIGN="TOP"><I>INTERNET_STATUS_RESPONSE_RECEIVED</I></TD><TD VALIGN="TOP">Successfully received 
a response from the server.</TD></TR>
<TR><TD VALIGN="TOP"><I>INTERNET_STATUS_CLOSING_CONNECTION</I></TD><TD VALIGN="TOP">Closing the connection 
to the server.</TD></TR>
<TR><TD VALIGN="TOP"><I>INTERNET_STATUS_CONNECTION_CLOSED</I></TD><TD VALIGN="TOP">Successfully closed 
the connection to the server.</TD></TR>
<TR><TD VALIGN="TOP"><I>INTERNET_STATUS_HANDLE_CREATED</I></TD><TD VALIGN="TOP">Program can now 
close the handle.</TD></TR>
<TR><TD VALIGN="TOP"><I>INTERNET_STATUS_HANDLE_CLOSING</I></TD><TD VALIGN="TOP">Successfully 
terminated this handle value.</TD></TR>
<TR><TD VALIGN="TOP"><I>INTERNET_STATUS_REQUEST_COMPLETE</I></TD><TD VALIGN="TOP">Successfully completed 
the asynchronous operation.</TD></TR>
</TABLE>
<P>You can use your status callback function to interrupt a WinInet 
operation. You could, for example, test for an event set by the main thread when 
the user cancels the operation.
<A NAME="911"><H2>A Simplified WinInet Client Program</H2></A><P>And now for the WinInet equivalent of our Winsock client program that 
implements a blind GET request. Because you're using WinInet in blocking 
mode, you must put the code in a worker thread. That thread is started from a 
command handler in the main thread:
<P><PRE>AfxBeginThread(ClientWinInetThreadProc, GetSafeHwnd());</PRE>
<P>Here's the client thread code:
<P><PRE>CString g_strServerName = &quot;localhost&quot;; // or some other host name
UINT ClientWinInetThreadProc(LPVOID pParam)
{
    CInternetSession session;
    CHttpConnection* pConnection = NULL;
    CHttpFile* pFile1 = NULL;
    char* buffer = new char[MAXBUF];
    UINT nBytesRead = 0;
    try {
        pConnection = session.GetHttpConnection(g_strServerName, 80);
        pFile1 = pConnection-&gt;OpenRequest(1, &quot;/&quot;); // blind GET
        pFile1-&gt;SendRequest();
        nBytesRead = pFile1-&gt;Read(buffer, MAXBUF - 1);
        buffer[nBytesRead] = `\0'; // necessary for message box
        char temp[10];
        if(pFile1-&gt;Read(temp, 10) != 0) {
            // makes caching work if read complete
            AfxMessageBox(&quot;File overran buffer &#151; not cached&quot;);
        }
        AfxMessageBox(buffer);
    }
    catch(CInternetException* e) {
        // Log the exception
        e-&gt;Delete();
    }
    if(pFile1) delete pFile1;
    if(pConnection) delete pConnection;
    delete [] buffer;
    return 0;
}</PRE>
<P>The second <I>Read</I> call needs some explanation. It has two purposes. If 
the first <I>Read</I> doesn't read the whole file, that means that it was longer 
than <I>MAXBUF -1</I>. The second <I>Read</I> will get some bytes, and that lets you 
detect the overflow problem. If the first 
<I>Read</I> reads the whole file, you still need 
the second <I>Read</I> to force WinInet to 
<U>cache</U> the file on your hard disk. Remember that WinInet tries to read all the bytes you ask it to&#151;through the end of 
the file. Even so, you need to read 0 bytes after that.
</BODY>
</HTML>



