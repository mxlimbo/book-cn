<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>An Interface Summary</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="654"><H1><B>An Interface Summary</B></H1></A>
<P>Following is a summary of the important OLE interfaces we'll be using in the remaining examples in this chapter. The function lists are by no means complete, nor are the parameter lists. See MSDN Online Help or Brockschmidt's book for the complete specifications.

<A NAME="655"><H2><B>The <I>IOleObject</I> Interface</B></H2></A>
<P>Embedded components implement this interface. The client site maintains an <I>IOleObject</I> pointer to an embedded object.

<A NAME="656"><H3><B>HRESULT Advise(IAdviseSink*<I> AdvSink</I>, DWORD*<I> pdwConnection</I>);</B></H3></A>
<P>The handler calls this function to establish one of the two advisory connections from the component to the handler. The component usually implements <I>Advise</I> with an OLE advise holder object, which can manage multiple advisory connections.

<A NAME="657"><H3><B>HRESULT Close(DWORD <I>dwSaveOption</I>);</B></H3></A>
<P>The container calls <I>Close</I> to terminate the component application but to leave the object in the loaded state. Containers call this function when the user clicks outside an in-place-active component's window. Components that support in-place activation should clean up and terminate.

<A NAME="658"><H3><B>HRESULT DoVerb(LONG <I>iVerb</I>, &#133;, IOleClientSite* <I>pActiveSite</I>, &#133;);</B></H3></A>
<P>Components support numeric <U>verbs</U> as defined in the Registry. A sound component might support a &quot;Play&quot; verb, for example. Embedded components should support the <I>OLEIVERB_SHOW</I> verb, which instructs the object to show itself for editing or viewing. If the component supports in-place activation, this verb starts the Visual Editing process; otherwise, it starts the component 
program in a window separate from that of its container. The <I>OLEIVERB_OPEN</I> verb causes an in-place-activation-capable component to start in a separate window.


<A NAME="659"><H3><B>HRESULT GetExtent(DWORD <I>dwDrawAspect</I>, SIZEL* <I>pSizel</I>);</B></H3></A>
<P>The component returns the object extent in <I>HIMETRIC</I> dimensions. The container uses these dimensions to size the rectangle for the component's metafile. Sometimes the container uses the extents that are included in the component's metafile picture.


<A NAME="660"><H3><B>HRESULT SetClientSite(IOleClientSite* <I>pClientSite</I>);</B></H3></A>
<P>The container calls <I>SetClientSite</I> to enable the component to store a pointer back to the site in the container.

<A NAME="661"><H3><B>HRESULT SetExtent(DWORD <I>dwDrawAspect</I>, SIZEL* <I>pSizel</I>);</B></H3></A>
<P>Some containers call this function to impose extents on the component.

<A NAME="662"><H3><B>HRESULT SetHostNames(LPCOLESTR <I>szContainerApp</I>, PCOLESTR <I>szContainerObj</I>);</B></H3></A>
<P>The container calls <I>SetHostNames</I> so that the component can display the container program's name in its window caption.

<A NAME="663"><H3><B>HRESULT Unadvise(DWORD* <I>dwConnection</I>);</B></H3></A>
<P>This function terminates the advisory connection set up by <I>Advise</I>.

<A NAME="664"><H2><B>The <I>IViewObject2 </I>Interface</B></H2></A>
<P>Embedded component <U>handlers</U> implement this interface. Handlers are a type of COM component for dealing with certain client-side aspects of linking and embedding. The default handler (the one provided by Microsoft) lives in a DLL named &quot;OLE32.DLL.&quot; The container calls its functions, but the component program itself doesn't implement them. An <I>IViewObject2</I> interface cannot be marshaled across a process boundary because it's associated with a device context.

<A NAME="665"><H3><B>HRESULT Draw(DWORD <I>dwAspect</I>, &#133;, const LPRECTL <I>lprcBounds</I>, &#133;);</B></H3></A>
<P>The container calls this function to draw the component's metafile in a specified rectangle.

<A NAME="666"><H3><B>HRESULT SetAdvise(DWORD <I>dwAspect</I>, &#133;, IAdviseSink* <I>pAdvSink</I>);</B></H3></A>
<P>The container calls <I>SetAdvise</I> to set up the advisory connection to the handler, which in turn sets up the advisory connection to the component.

<A NAME="667"><H2><B>The <I>IOleClientSite</I> Interface</B></H2></A>
<P>Containers implement this interface. There is one client site object per component object.

<A NAME="668"><H3><B>HRESULT GetContainer(IOleContainer** <I>ppContainer</I>);</B></H3></A>
<P>The <I>GetContainer</I> function retrieves a pointer to the container object (document), which can be used to enumerate the container's sites.

<A NAME="669"><H3><B>HRESULT OnShowWindow(BOOL <I>fShow</I>);</B></H3></A>
<P>The component program calls this function when it switches between the running and the loaded (or active) state. When the object is in the loaded state, the container should display a hatched pattern on the embedded object's rectangle.

<A NAME="670"><H3><B>HRESULT SaveObject(void);</B></H3></A>
<P>The component program calls <I>SaveObject</I> when it wants to be saved to its storage. The container calls <I>IPersistStorage::Save</I>.

<A NAME="671"><H2><B>The <I>IAdviseSink </I>Interface</B></H2></A>
<P>Containers implement this interface. Embedded object handlers call its functions in response to component notifications.

<A NAME="672"><H3><B>void OnClose(void);</B></H3></A>
<P>Component programs call this function when they are being terminated.

<A NAME="673"><H3><B>void OnViewChange(DWORD dwAspect, &#133;);</B></H3></A>
<P>The handler calls <I>OnViewChange</I> when the metafile has changed. Because the component program must have been running for this notification to have been sent, the handler can call the component's 
<I>IDataObject::GetData</I> function to get the latest metafile for its cache. The container can then draw this metafile by calling <I>IViewObject2::Draw</I>.

</BODY>
</HTML>



