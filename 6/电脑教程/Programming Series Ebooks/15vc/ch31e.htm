<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The MFC ODBC Classes -- CRecordset and CDatabase</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="770"><H1>The MFC ODBC Classes&#151;<I>CRecordset</I> and <I>CDatabase</I></H1></A><P>With the MFC classes for Windows, you use C++ objects instead of 
window handles and device context handles; with the MFC ODBC classes, you 
use objects instead of connection handles and statement handles. The 
environment handle is stored in a global variable and is not represented by a 
C++ object. The two principal ODBC classes are 
<I>CDatabase</I> and <I>CRecordset</I>. Objects of 
class <I>CDatabase</I> represent ODBC connections to data sources, and objects of 
class <I>CRecordset</I> represent scrollable rowsets. The Visual 
C++ documentation uses the term &quot;recordset&quot; instead of &quot;rowset&quot; to be consistent with Microsoft Visual Basic and Microsoft Access. You seldom derive classes from 
<I>CDatabase</I>, but you generally derive classes from 
<I>CRecordset</I> to match the columns in your database tables.
<P>For the author query in the previous section, you would derive (with 
the help of ClassWizard) a <I>CAuthorSet</I> class from 
<I>CRecordset</I> that had data members for first name, last name, city, state, and zip code. Your program 
would construct a <I>CAuthorSet</I> object (typically embedded in the document) and 
call its inherited <I>Open</I> member function. Using the values of parameters and 
data members, <I>CRecordset::Open</I> constructs and opens a 
<I>CDatabase</I> object; this function issues an SQL<I> SELECT </I>statement and then moves to the 
first record. Your program would then call other 
<I>CRecordset</I> member functions to position the ODBC cursor and exchange data between the database fields and the <I>CAuthorSet</I> data members. When the 
<I>CAuthorSet</I> object is deleted, the recordset is closed and, under certain conditions, the database is closed and deleted. Figure 31-2 shows the relationships between the 
C++ objects and the ODBC components.
<P><A HREF="javascript:fullSize('f31og02x.htm')"> <img src="f31og02.jpg" width=404 height=458 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 31-2.</B> <I>MFC ODBC class database relationships.</I>
<!-- /caption -->
<P>It's important to recognize that the 
<I>CAuthorSet</I> object contains data members that represent only one row in a table, the so-called &quot;current 
record.&quot; The <I>CRecordset</I> class, together with the underlying ODBC rowset code, 
manages the database dynaset or snapshot.
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
It's possible to have several active dynasets or snapshots 
per data source, and you can use multiple data sources within the 
same program.
</BLOCKQUOTE></DIV>
<P>The important <I>CRecordset</I> member functions discussed in this chapter 
are summarized in the table below.
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>Function</B></TD><TD VALIGN="TOP"><B>Description</B></TD></TR>
<TR><TD VALIGN="TOP"><I>Open</I></TD><TD VALIGN="TOP">Opens the recordset</TD></TR>
<TR><TD VALIGN="TOP"><I>AddNew</I></TD><TD VALIGN="TOP">Prepares to add a new record to the table</TD></TR>
<TR><TD VALIGN="TOP"><I>Update</I></TD><TD VALIGN="TOP">Completes an <I>AddNew</I> or 
<I>Edit</I> operation by saving the new or edited data in the data source</TD></TR>
<TR><TD VALIGN="TOP"><I>Delete</I></TD><TD VALIGN="TOP">Deletes the current record from the recordset</TD></TR>
<TR><TD VALIGN="TOP"><I>Edit</I></TD><TD VALIGN="TOP">Prepares to implement changes on the current record</TD></TR>
<TR><TD VALIGN="TOP"><I>IsBOF</I></TD><TD VALIGN="TOP">Determines whether the recordset has been 
positioned before the first record</TD></TR>
<TR><TD VALIGN="TOP"><I>IsEOF</I></TD><TD VALIGN="TOP">Determines whether the recordset has been 
positioned after the last record</TD></TR>
<TR><TD VALIGN="TOP"><I>MoveNext</I></TD><TD VALIGN="TOP">Sets the current record to the next record or to 
the next rowset</TD></TR>
<TR><TD VALIGN="TOP"><I>MoveFirst</I></TD><TD VALIGN="TOP">Sets the current record to the first record in 
the recordset</TD></TR>
<TR><TD VALIGN="TOP"><I>MoveLast</I></TD><TD VALIGN="TOP">Sets the current record to the last record or to 
the last rowset</TD></TR>
<TR><TD VALIGN="TOP"><I>MovePrev</I></TD><TD VALIGN="TOP">Sets the current record to the previous record or 
to the previous rowset</TD></TR>
<TR><TD VALIGN="TOP"><I>GetDefaultConnect</I></TD><TD VALIGN="TOP">Gets the default connect string for the data source 
on which the recordset is based</TD></TR>
<TR><TD VALIGN="TOP"><I>GetDefaultSQL</I></TD><TD VALIGN="TOP">Gets the default SQL string</TD></TR>
<TR><TD VALIGN="TOP"><I>DoFieldExchange</I></TD><TD VALIGN="TOP">Exchanges data between the recordset data fields 
and the corresponding record on the data source</TD></TR>
<TR><TD VALIGN="TOP"><I>GetStatus</I></TD><TD VALIGN="TOP">Gets the index of the current record in the 
recordset and the final count status</TD></TR>
<TR><TD VALIGN="TOP"><I>GetRecordCount</I></TD><TD VALIGN="TOP">Determines the highest-numbered record yet 
encountered as the user moves through the records</TD></TR>
<TR><TD VALIGN="TOP"><I>GetODBCFieldCount</I></TD><TD VALIGN="TOP">Gets the number of fields in the recordset object</TD></TR>
<TR><TD VALIGN="TOP"><I>GetODBCFieldInfo</I></TD><TD VALIGN="TOP">Gets information about the fields in the recordset</TD></TR>
</TABLE>
<P>
<A NAME="771"><H2>Counting the Rows in a Recordset</H2></A><P>It's difficult to know how many records are contained in an ODBC 
recordset. ODBC doesn't provide an accurate count of the rows in a recordset until 
you've read past the end. Until that time, the count returned from the 
<I>CRecordset::GetRecordCount</I> member function is a &quot;high-water mark&quot; that returns 
only the last row accessed by 
<I>CRecordset::MoveNext</I>. The 
<I>CRecordset::GetStatus</I> function returns a 
<I>CRecordsetStatus</I> object, which has a member 
<I>m_bRecordCountFinal</I> that indicates whether the count is final.
<P>The <I>CRecordset::MoveLast</I> function does not register the record count 
for you, even for dynasets. If you want to know how many records are included 
in a recordset, loop through the whole table with 
<I>MoveNext</I> calls. (A faster alternative is to use the COUNT function.) If your program adds or deletes a 
record or if another user adds or deletes a record, the record count is not adjusted.
<A NAME="772"><H2>Processing ODBC Exceptions</H2></A><P>Many MFC ODBC calls don't return an error code but instead throw a 
<I>CDBException</I> object, which contains a string describing the error. Suppose you 
are trying to delete a record from a table in an Access database. Access might 
be enforcing referential integrity rules, which means that you're not allowed 
to delete that row because a row in another table depends on it. If you 
call <I>CRecordset::Delete</I>, you'll see an ODBC error message box that came from 
the MFC base classes.
<P>You certainly appreciate the error message, but now ODBC has &quot;lost 
its place&quot; in the recordset, and there is no longer a current record. Your 
program needs to detect the error so that it won't call functions that depend on a 
current record, such as 
<I>CRecordset::MoveNext</I>. You must handle the exception 
in this way:
<P><PRE>try {
    m_pSet-&gt;Delete();
}
catch(CDBException* e) {
    AfxMessageBox(e-&gt;m_strError);
    e-&gt;Delete();
    m_pSet-&gt;MoveFirst(); // lost our place!
    UpdateData(FALSE);
    return;
}
m_pSet-&gt;MoveNext();</PRE>
</BODY>
</HTML>



