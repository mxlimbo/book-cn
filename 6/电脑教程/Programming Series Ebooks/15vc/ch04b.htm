<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Getting User Input -- Message Map Functions</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="52"><H1>Getting User Input&#151;Message Map Functions</H1></A><P>Your EX03A application from <A HREF="ch03a.htm">Chapter 3</A> did not accept user input (other than the standard Microsoft Windows resizing and window close commands). The window contained menus and a toolbar, but these were not &quot;connected&quot; to 
the view code. The menus and the toolbar won't be discussed until Part III of 
this book because they depend on the frame class, but plenty of other Windows 
input sources will keep you busy until then. Before you can process any Windows 
event, even a mouse click, however, you must learn how to use the MFC message 
map system.
<A NAME="53"><H2>The Message Map</H2></A><P>When the user presses the left mouse button in a view window, Windows sends a message&#151;specifically 
WM_LBUTTONDOWN&#151;to that window. If your program needs to take action in response to WM_LBUTTONDOWN, your view class must have a member function that looks like this:<P>
<PRE>void CMyView::OnLButtonDown(UINT nFlags, CPoint point)
{
    // event processing code here
}
</PRE>
<P>Your class header file must also have the corresponding prototype:<P>
<PRE>afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
</PRE>
<P>The <I>afx</I>_<I>msg</I> notation is a &quot;no-op&quot; that alerts you that this is a prototype for a message map function. Next, your code file needs a message map macro that connects your <I>OnLButtonDown</I> function to the application framework:<P>
<PRE>BEGIN_MESSAGE_MAP(CMyView, CView)
    ON_WM_LBUTTONDOWN() // entry specifically for OnLButtonDown
    // other message map entries
END_MESSAGE_MAP()
</PRE>
<P>Finally, your class header file needs the statement<P>
<PRE>DECLARE_MESSAGE_MAP()
</PRE>
<P>How do you know which function goes with which Windows message? <A HREF="chaaa.htm">Appendix A</A> (and the MFC library online documentation) includes a table that lists all standard Windows messages and corresponding member function prototypes. You can manually code the message-handling functions&#151;indeed, that is still necessary for certain messages. Fortunately, Visual C++ provides a tool, ClassWizard, that automates the coding of most message map functions.
<A NAME="54"><H2>Saving the View's State&#151;Class Data Members</H2></A><P>If your program accepts user input, you'll want the user to have some 
visual feedback. The view's <I>OnDraw</I> function draws an image based on the 
view's current &quot;state,&quot; and user actions can alter that state. In a full-blown MFC application, the document object holds the state of the application, but you're not to that point yet. For now, you'll use two view class <U>data</U> <U>members</U>, <I>m_rectEllipse</I> and <I>m_nColor.</I> The first is an object of class <I>CRect</I>, which holds the current bounding rectangle of an ellipse, and the second is an integer that holds the current ellipse color value.
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0>
<P>By convention, MFC library nonstatic class data member names begin with <I>m_</I>.
</BLOCKQUOTE>
</DIV>
<P>You'll make a message-mapped member function toggle the ellipse color (the view's state) between gray and white. (The toggle is activated by pressing the left mouse button.) The initial values of <I>m_rectEllipse</I> and <I>m_nColor</I> are set in the view's constructor, and the color is changed in the <I>OnLButtonDown</I> member function.<P>
<DIV CLASS=tip>
<BLOCKQUOTE>
<IMG SRC="tip.jpg" width=123 height=18 BORDER=0><P>
Why not use a global variable for the view's state? Because if you did, you'd be in trouble if your application had multiple views. Besides, encapsulating data in objects is a big part of what object-oriented programming is all about.
</BLOCKQUOTE>
</DIV>
<A NAME="55"><H3>Initializing a View Class Data Member</H3></A><P>The most efficient place to initialize a class data member is in the constructor, like this:<P>
<PRE>CMyView::CMyView() : m_rectEllipse(0, 0, 200, 200) {...}
</PRE>
<P>You could initialize <I>m_nColor</I> with the same syntax. Because we're 
using a built-in type (integer), the generated code is the same if you use an 
assignment statement in the constructor body.
<A NAME="56"><H2>Invalid Rectangle Theory</H2></A><P>The <I>OnLButtonDown</I> function could toggle the value of <I>m</I>_<I>nColor</I> all day, but if that's all it did, the <I>OnDraw</I> function wouldn't get called (unless, for 
example, the user resized the view window). The <I>OnLButtonDown</I> function must call the <I>InvalidateRect</I> function (a member function that the view class inherits from <I>CWnd</I>). <I>InvalidateRect</I> triggers a Windows WM_PAINT message, which is mapped in the <I>CView</I> class to call to the virtual <I>OnDraw</I> function. If necessary, <I>OnDraw</I> can access the &quot;invalid rectangle&quot; parameter that was passed to <I>InvalidateRect</I>.
<P>There are two ways to optimize painting in Windows. First of all, you 
must be aware that Windows updates only those pixels that are inside the 
invalid rectangle. Thus, the smaller you make the invalid rectangle (in the 
<I>OnLButtonDown</I> handler, for instance), the quicker it can be repainted. Second, it's a waste of time to execute drawing instructions outside the invalid rectangle. Your <I>OnDraw</I> function could call the <I>CDC</I> member function <I>GetClipBox</I> to determine the invalid rectangle, and then it could avoid drawing objects outside it. Remember that <I>OnDraw</I> is being called not only in response to your <I>InvalidateRect</I> call but also when the user resizes or exposes the window. Thus, <I>OnDraw</I> is responsible for all drawing in a window, and it has to adapt to whatever invalid rectangle it gets.
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<B>For Win32 Programmers</B><P>
<P>The MFC library makes it easy to attach your own <U>state</U> <U>variables</U> to a window through C++ class data members. In Win32 programming, the <I>WNDCLASS</I> members <I>cbClsExtra</I> and <I>cbWndExtra</I> are available for this purpose, but the code for using this mechanism is so complex that developers tend to use global variables instead.
</BLOCKQUOTE>
</DIV>
<P>
<A NAME="57"><H2>The Window's Client Area</H2></A><P>A window has a rectangular <U>client</U> <U>area</U> that excludes the border, caption bar, menu bar, and any docking toolbars. The <I>CWnd</I> member function <I>GetClientRect</I> supplies you with the client-area dimensions. Normally, you're not allowed to draw outside the client area, and most mouse messages are received only when the mouse cursor is in the client area.
<A NAME="58"><H2><I>CRect</I>, <I>CPoint</I>, and <I>CSize</I> Arithmetic</H2></A><P>The <I>CRect</I>, <I>CPoint</I>, and <I>CSize</I> classes are derived from the Windows <I>RECT</I>, <I>POINT</I>, and <I>SIZE</I> structures, and thus they inherit public integer data members as follows:<P>

<TABLE WIDTH="95%" CELLPADDING="5">
<tr><td valign="top"><I>CRect</I></td><td valign="top"><I>left, top, right, bottom</I></td></tr>
<tr><td valign="top"><I>CPoint</I></td><td valign="top"><I>x, y</I></td></tr>
<tr><td valign="top"><I>CSize</I></td><td valign="top"><I>cx, cy</I></td></tr>
</TABLE>
<P>If you look in the <I>Microsoft Foundation</I> <I>Class Reference,</I> you will see that these three classes have a number of overloaded operators. You can, among other things, do the following:
<UL>
<LI>Add a <I>CSize</I> object to a <I>CPoint</I> object
<P><LI>Subtract a <I>CSize</I> object from a <I>CPoint</I> object
<P><LI>Subtract one <I>CPoint</I> object from another, yielding a 
<I>CSize</I> object
<P><LI>Add a <I>CPoint</I> or <I>CSize</I> object to a 
<I>CRect</I> object
<P><LI>Subtract a <I>CPoint</I> or <I>CSize</I> object from a 
<I>CRect</I> object<P>
</UL>
<P>The <I>CRect</I> class has member functions that relate to the <I>CSize</I> and <I>CPoint</I> classes. For example, the <I>TopLeft</I> member function returns a <I>CPoint</I> object, and the <I>Size</I> member function returns a 
<I>CSize</I> object. From this, you can begin to see that a <I>CSize</I> object is the &quot;difference between two <I>CPoint</I> objects&quot; and that you can &quot;bias&quot; a <I>CRect</I> object by a <I>CPoint</I> object.
<A NAME="59"><H2>Is a Point Inside a Rectangle?</H2></A><P>The <I>CRect</I> class has a member function <I>PtInRect</I> that tests a point to see whether it falls inside a rectangle. The second <I>OnLButtonDown</I> parameter (<I>point</I>) is an object of class <I>CPoint</I> that represents the cursor location in the client area of the window. If you want to know whether that point is inside the <I>m_rectEllipse</I> rectangle, you can use <I>PtInRect</I> in this way:<P>
<PRE>if (m_rectEllipse.PtInRect(point)) {
    // point is inside rectangle
}
</PRE>
<P>As you'll soon see, however, this simple logic applies only if you're working in device coordinates (which you are at this stage).
<A NAME="60"><H2>The <I>CRect LPCRECT</I> Operator</H2></A><P>If you read the <I>Microsoft Foundation</I> <I>Class Reference</I> carefully, you will notice that <I>CWnd::InvalidateRect</I> takes an <I>LPCRECT</I> parameter (a pointer to a <I>RECT</I> structure), not a <I>CRect</I> parameter. A <I>CRect</I> parameter is allowed because the <I>CRect</I> class defines an overloaded operator, <I>LPCRECT()</I>, that returns the address of a <I>CRect</I> object, which is equivalent to the address of a <I>RECT</I> object. Thus, the compiler converts <I>CRect</I> arguments to <I>LPCRECT</I> arguments when necessary. You call functions as though they had <I>CRect</I> reference parameters. The view member function code<P>
<PRE>CRect rectClient;
GetClientRect(rectClient);
</PRE>
<P>retrieves the client rectangle coordinates and stores them in <I>rectClient</I>.
<A NAME="61"><H2>Is a Point Inside an Ellipse?</H2></A><P>The EX04A code determines whether the mouse hit is inside the rectangle. If you want to make a better test, you can find out whether the hit is inside the ellipse. To do this, you must construct an object of class <I>CRgn</I> that corresponds to the ellipse and then use the <I>PtInRegion</I> function instead of <I>PtInRect</I>. Here's the code:<P>
<PRE>CRgn rgn;
rgn.CreateEllipticRgnIndirect(m_rectEllipse);
if (rgn.PtInRegion(point)) {
    // point is inside ellipse
}
</PRE>
<P>Note that the <I>CreateEllipticRgnIndirect</I> function is another function 
that takes an <I>LPCRECT</I> parameter. It builds a special region structure within Windows that represents an elliptical region inside a window. That structure is then attached to the C++ <I>CRgn</I> object in your program. (The same type of structure can also represent a polygon.)
<A NAME="62"><H2>The EX04A Example</H2></A><P>In the EX04A example, an ellipse (which happens to be a circle) changes color when the user presses the left mouse button while the mouse cursor is inside the rectangle that bounds the ellipse. You'll use the view class data members to hold the view's state, and you'll use the <I>InvalidateRect</I> function to cause the view to be redrawn.
<P>In the <A HREF="ch03a.htm">Chapter 3</A> example, drawing in the window depended on only one function, <I>OnDraw</I>. The EX04A example requires three customized functions (including the constructor) and two data members. The complete <I>CEx04aView</I> header and source code files are listed in Figure 4-1. (The steps for creating the program are shown after the program listings.) All changes to the original AppWizard and OnLButtonDown ClassWizard output are in boldface.
<P>

<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="63"><H3>EX04AVIEW.H</H3></A>

<PRE>// ex04aView.h : interface of the CEx04aView class
//
///////////////////////////////////////////////////////////////////////

#if !defined(AFX_EX04AVIEW_H__B188BE41_6377_11D0_8FD4_00C04FC2A0C2
__INCLUDED_)
#define AFX_EX04AVIEW_H__B188BE41_6377_11D0_8FD4_00C04FC2A0C2
__INCLUDED_

#if _MFC_VER &gt; 1000
#pragma once
#endif // _MFC_VER &gt; 1000
class CEx04aView : public CView
{
protected: // create from serialization only
    CEx04aView();
    DECLARE_DYNCREATE(CEx04aView)

// Attributes
public:
    CEx04aDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEx04aView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    protected:
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CEx04aView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CEx04aView)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
<B>private:
    int m_nColor;
    CRect m_rectEllipse;</B>
};
#ifndef _DEBUG  // debug version in ex04aView.cpp
inline CEx04aDoc* CEx04aView::GetDocument()
   { return (CEx04aDoc*)m_pDocument; }
#endif

///////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.

#endif // !defined(AFX_EX04AVIEW_H__B188BE41_6377_11D0_8FD4_00C04FC2A0C2__INCLUDED_)
</PRE>
<P>
<A NAME="64"><H3>EX04AVIEW.CPP</H3></A><PRE>// ex04aView.cpp : implementation of the CEx04aView class
//

#include &quot;stdafx.h&quot;
#include &quot;ex04a.h&quot;

#include &quot;ex04aDoc.h&quot;
#include &quot;ex04aView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif

///////////////////////////////////////////////////////////////////////
// CEx04aView

IMPLEMENT_DYNCREATE(CEx04aView, CView)

BEGIN_MESSAGE_MAP(CEx04aView, CView)
    //{{AFX_MSG_MAP(CEx04aView)
    ON_WM_LBUTTONDOWN()
    //}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()
///////////////////////////////////////////////////////////////////////
// CEx04aView construction/destruction

CEx04aView::CEx04aView()<B> : m_rectEllipse(0, 0, 200, 200)</B>
{
<B>    m_nColor = GRAY_BRUSH;</B>
}

CEx04aView::~CEx04aView()
{
}

BOOL CEx04aView::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CView::PreCreateWindow(cs);
}

///////////////////////////////////////////////////////////////////////
// CEx04aView drawing

void CEx04aView::OnDraw(CDC* pDC)
{
<B>    pDC-&gt;SelectStockObject(m_nColor);
    pDC-&gt;Ellipse(m_rectEllipse);</B>
}

///////////////////////////////////////////////////////////////////////
// CEx04aView printing

BOOL CEx04aView::OnPreparePrinting(CPrintInfo* pInfo)
{
    // default preparation
    return DoPreparePrinting(pInfo);
}

void CEx04aView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add extra initialization before printing
}

void CEx04aView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add cleanup after printing
}

///////////////////////////////////////////////////////////////////////
// CEx04aView diagnostics

#ifdef _DEBUG
void CEx04aView::AssertValid() const
{
    CView::AssertValid();
}

void CEx04aView::Dump(CDumpContext&amp; dc) const
{
    CView::Dump(dc);
}

CEx04aDoc* CEx04aView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CEx04aDoc)));
    return (CEx04aDoc*)m_pDocument;
}
#endif //_DEBUG

///////////////////////////////////////////////////////////////////////
// CEx04aView message handlers

void CEx04aView::OnLButtonDown(UINT nFlags, CPoint point) 
{
<B>    if (m_rectEllipse.PtInRect(point)) {
        if (m_nColor == GRAY_BRUSH) {
            m_nColor = WHITE_BRUSH;
        }
        else {
            m_nColor = GRAY_BRUSH;
        }
        InvalidateRect(m_rectEllipse);
    }</B>
}
</PRE>
</TD></TR></TABLE>

<P><B>Figure 4-1.</B> <I>The </I>CEx04aView<I> header and source code files.</I><P>


<A NAME="65"><H2>Using ClassWizard with EX04A</H2></A><P>Look at the following ex04aView.h source code:<P>
<PRE>//{{AFX_MSG(CEx04aView)
afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
//}}AFX_MSG
</PRE>
<P>Now look at the following ex04aView.cpp source code:<P>
<PRE>//{{AFX_MSG_MAP(CEx04aView)
ON_WM_LBUTTONDOWN()
//}}AFX_MSG_MAP
</PRE>
<P>AppWizard generated the funny-looking comment lines for the benefit of ClassWizard. ClassWizard adds message handler prototypes between the <I>AFX</I>_<I>MSG</I> brackets and message map entries between the <I>AFX</I>_<I>MSG</I>_<I>MAP</I> brackets. In addition, ClassWizard generates a skeleton <I>OnLButtonDown</I> member function in ex04aView.cpp, complete with the correct parameter declarations and return type.
<P>Notice how the AppWizard_ClassWizard combination is different from a conventional code generator. You run a conventional code generator only once and then edit the resulting code. You run AppWizard to generate the application only once, but you can run ClassWizard as many times as necessary, and you can edit the code at any time. You're safe as long as you don't alter what's inside the <I>AFX</I>_<I>MSG</I> and <I>AFX</I>_<I>MSG</I>_<I>MAP</I> brackets.
<A NAME="66"><H3>Using AppWizard and ClassWizard Together</H3></A><P>The following steps show how you use AppWizard and ClassWizard together to create this application:
<OL>
<B><LI>Run AppWizard to create EX04A.</B> Use AppWizard to generate an SDI project named EX04A in the \vcpp32\ex04a subdirectory. The options and the default class names are shown here.

<P><img src="G04OG01x.gif" width=413 height=418 border=0> <P>

<B><LI>Add the <I>m</I>_<I>rectEllipse</I> and <I>m_nColor</I> data members to <I>CEx04aView</I>.</B> With the Workspace window set to ClassView, right-click the <I>CEx04aView</I> class, select Add Member Variable, and then insert the following two data members:
<P>
<PRE><B>private:
    CRect m_rectEllipse;
    int m_nColor;</B>
</PRE>
<P>If you prefer, you could type the above code inside the class declaration in the file ex04aView.h.<P>
<B><LI>Use ClassWizard to add a <I>CEx04aView</I> class message handler.</B> 
Choose ClassWizard from the View menu of Visual C++, or right-click inside a source code window and choose ClassWizard from the context menu. When the MFC ClassWizard dialog appears, be sure that the <I>CEx04aView</I> class is selected, as shown in the illustration below. Now click on <I>CEx04aView</I> at the top of the Object IDs list box, and then scroll down past the virtual functions in the Messages list box and double-click on WM_LBUTTONDOWN. The 
<I>OnLButtonDown</I> function name should appear in the Member Functions list box, and the message name should be displayed in bold in the Messages list box. Here's the ClassWizard dialog box.

<P><A HREF="javascript:fullSize('G04OG02x.htm')"> <img src="G04OG02.JPG" width=404 height=290 border=0 ALT = "Click to view at full size."> </A><P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
Instead of using ClassWizard, you can map the function from the Visual C++ WizardBar (shown in <A HREF="ch01c.htm#100">Figure 1-2</A> in Chapter 1).
</BLOCKQUOTE>
</DIV>
<P>
<B><LI>Edit the <I>OnLButtonDown</I> code in ex04aView.cpp.</B> Click the Edit Code button. ClassWizard opens an edit window for ex04aView.cpp in Visual C++ and positions the cursor on the newly generated <I>OnLButtonDown</I> member function. The following boldface code (that you type in) replaces the previous code:
<P>
<PRE>void CEx04aView::OnLButtonDown(UINT nFlags, CPoint point)
{
    <B>if (m_rectEllipse.PtInRect(point)) {
        if (m_nColor 
== GRAY_BRUSH) {
            m_nColor = WHITE_BRUSH;
        }
        else {
            m_nColor = GRAY_BRUSH;
        }
        InvalidateRect(m_rectEllipse);
    }</B>
}
</PRE>
<B><LI>Edit the constructor and the <I>OnDraw</I> function in ex04aView.cpp.</B> The following boldface code (that you type in) replaces the previous code:<P>
<PRE>CEx04aView::CEx04aView() <B>: m_rectEllipse(0, 0, 200, 200)</B>
{
   <B> m_nColor = GRAY_BRUSH;</B>
}
.
.
.
void CEx04aView::OnDraw(CDC* pDC)
{
    <B>pDC-&gt;SelectStockObject(m_nColor);
    pDC-&gt;Ellipse(m_rectEllipse);</B>
}
</PRE>
<P>
<B><LI>Build and run the EX04A program.</B> Choose Build Ex04a.exe from the Build menu, or, on the Build toolbar, click the button shown here.
<P><IMG SRC="g04og03.gif" width=24 height=23 BORDER="0"><P>
<P>Then choose Execute Ex04a.exe from the Build menu. The resulting program responds to presses of the left mouse button by changing the color of the circle in the view window. (Don't press the mouse's left button quickly in succession; Windows interprets this as a double click rather than two single clicks.)<P>
</OL>
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<B>For Win32 Programmers</B><P>
<P>A conventional Windows-based application registers a series of <U>window</U> <U>classes</U> (not the same as C++ classes) and, in the process, assigns a 
unique function, known as a <U>window</U> <U>procedure</U>, to each class. Each time the application calls <I>CreateWindow</I> to create a window, it specifies a window class as a parameter and thus links the newly created window to a 
window procedure function. This function, called each time Windows sends a message to the window, tests the message code that is passed as a parameter and then executes the appropriate code to handle the message.
<P>The MFC application framework has a single window class and window procedure function for most window types. This window procedure function looks up the window handle (passed as a parameter) in the MFC <U>handle</U> <U>map</U> to get the corresponding C++ window object pointer. The window procedure function then uses the MFC <U>runtime</U> <U>class</U> system (see <A HREF="chaba.htm">Appendix B</A>) to determine the C++ class of the window object. Next it locates the handler function in static tables created by the dispatch map functions, and finally it calls the handler function with the correct window object selected.
</BLOCKQUOTE>
</DIV>
<P>
</BODY>
</HTML>



