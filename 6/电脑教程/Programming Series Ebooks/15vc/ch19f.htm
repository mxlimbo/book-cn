<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Template Collection Classes Revisited -- The CArray Class</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="419"><H1>Template Collection Classes Revisited&#151;The <I>CArray</I> Class</H1></A>
<P>In EX16B in <A HREF="ch16a.htm">Chapter 16</A>, you saw the MFC library <I>CTypedPtrList</I> template collection class, which was used to store a list of pointers to <I>CStudent</I> objects. Another collection class, <I>CArray</I>, is appropriate for the next example, EX19B. This class is different from <I>CTypedPtrList</I> in two ways. First, it's an array, with elements accessible by index, just like <I>CStringArray</I> in EX19A. Second, the array holds actual objects, not pointers to objects. In EX19B, the elements are <I>CRect</I> objects. The elements' class does not have to be derived from 
<I>CObject</I>, and indeed, <I>CRect</I> is not.
<P>As in EX16B, a <I>typedef</I> makes the template collection easier to use. We use the statement
<P>
<pre>typedef CArray&lt;CRect, CRect&amp;&gt; CRectArray;</pre>
<P>to define an array class that holds <I>CRect</I> objects and whose functions take <I>CRect</I> reference parameters. (It's cheaper to pass a 32-bit pointer than to copy a 128bit object.) To use the template array, you declare an instance of <I>CRectArray</I> and then you call <I>CArray</I> member functions such as <I>SetSize</I>. You can also use the <I>CArray</I> subscript operator to get and set elements.
<P>The template classes <I>CArray</I>, <I>CList</I>, and <I>CMap</I> are easy to use if the element class is sufficiently simple. The <I>CRect </I>class fits that description because it contains no pointer data members. Each template class uses a global function, <I>SerializeElements</I>, to serialize all the elements in the collection. The default <I>SerializeElements</I> function does a <U>bitwise</U> copy of each element to and from the archive.
<P>If your element class contains pointers or is otherwise complex, you'll need to write your own <I>SerializeElements</I> function. If you wrote this function for the rectangle array (not required), your code would look like this:
<P><PRE>void AFXAPI SerializeElements(CArchive&amp; ar, CRect* pNewRects,
    int nCount)
{
    for (int i = 0; i &lt; nCount; i++, pNewRects++) {
        if (ar.IsStoring()) {
            ar &lt;&lt; *pNewRects;
        }
        else {
            ar &gt;&gt; *pNewRects;
        }
    }
}</PRE>
<P>When the compiler sees this function, it uses the function to replace the <I>SerializeElements</I> function inside the template. This only works, however, if the compiler sees the <I>SerializeElements</I> prototype before it sees the template class declaration.
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
The template classes depend on two other global functions, <I>ConstructElements</I> and <I>DestructElements</I>. Starting with Visual C++ version 4.0, these functions call the element class constructor and destructor for each object. Therefore, there's no real need to replace them.
</BLOCKQUOTE></DIV>
<P>
</BODY>
</HTML>



