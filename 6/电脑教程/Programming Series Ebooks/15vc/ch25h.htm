<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Automation Programming Choices</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="532"><H1><B>Automation Programming Choices</B></H1></A>
<P>Suppose you're writing an Automation component in C++. You've got some choices to make. Do you want an in-process component or an out-of-process component? What kind of user interface do you want? Does the component need a user interface at all? Can users run your EXE component as a stand-alone application? If the component is an EXE, will it be SDI or MDI? Can the user shut down the component program directly?

<P>If your component is a DLL, COM linkage will be more efficient than it would be with an EXE component because no marshaling is required. Most of the time, your in-process Automation components won't have their own user interfaces, except for modal dialog boxes. If you need a component that 
manages its own child window, you should use an ActiveX control, and if you want to use a main frame window, use an out-of-process component. As with any 32-bit DLL, an Automation DLL is mapped into the client's process memory. If two client programs happen to request the same DLL, Windows loads 
and links the DLL twice. Each client is unaware that the other is using the same component.

<P>With an EXE component, however, you must be careful to distinguish between a component program and a component object. When a client calls <I>IClassFactory::CreateInstance</I> to construct a component object, the component's class factory constructs the object, but COM might or might not need to start the component program.

<P>Here are some scenarios:

<ol>
<P><LI>The component's COM-creatable class is programmed to require a new process for each object constructed. In this case, COM starts a new process in response to the second and subsequent 
<I>CreateInstance</I> calls, each of which returns an <I>IDispatch</I> pointer.
<P><LI>Here's a special case of scenario 1 above, specific to MFC applications. The component class is an MFC document class in an SDI application. Each time a client calls <I>CreateInstance</I>, a new component process starts, complete with a document object, a view object, and an SDI main frame window.
<P><LI>The component class is programmed to allow multiple objects in a single process. Each time a client calls <I>CreateInstance</I>, a new component object is constructed. There is only one component 
process, however.
<P><LI>Here's a special case of scenario 3 above, specific to MFC applications. The component class is an MFC document class in an MDI application. There is a single component process with one 
MDI main frame window. Each time a client calls <I>CreateInstance</I>, a new document object is constructed, along with a view object and an MDI child frame window.
</ol>

<P>There's one more interesting case. Suppose a component EXE is running before the client needs it, and then the client decides to access a component object that already exists. You'll see this case with Excel. The user might have Excel running but minimized on the desktop, and the client needs access to Excel's one and only Application object. Here the client calls the COM function <I>GetActiveObject</I>, which provides an interface pointer for an existing component object. If the call fails, the client can create the object with <I>CoCreateInstance</I>.

<P>For component object deletion, normal COM rules apply. Automation objects have reference counts, and they delete themselves when the client calls <I>Release</I> and the reference count goes to 0. In an MDI component, if the Automation object is an MFC document, its destruction causes the 
corresponding MDI child window to close. In an SDI component, the destruction of the document object causes the component process to exit. The client is responsible for calling <I>Release</I> for each 
<I>IDispatch</I> interface before the client exits. For EXE components, COM will intervene if the client exits without releasing an interface, thus allowing the component process to exit. You can't always depend on this intervention, however, so be sure that your client cleans up its interfaces!
<P>With generic COM, a client application often obtains multiple interface pointers for a single component object. Look back at the spaceship example in <A HREF="ch24a.htm">Chapter 24</A>, in which the simulated COM component class had both an <I>IMotion</I> pointer and an <I>IVisual</I> pointer. With Automation, however, there's usually only a single (<I>IDispatch</I>) pointer per object. As in all COM programming, you must be careful to release all your interface pointers. In Excel, for example, 
many properties return an <I>IDispatch</I> pointer to new or existing objects. If you fail to release a pointer to an in-process COM component, the Debug version of the MFC library alerts you with a memory-leak dump when the client program exits.

<A NAME="533"><H2><B>The MFC <I>IDispatch</I> Implementation</B></H2></A>
<P>The component program can implement its <I>IDispatch</I> interface in several ways. The most common of these pass off much of the work to the Windows COM DLLs by calling the COM function 
<I>CreateStdDispatch</I> or by delegating the <I>Invoke</I> call to the <I>ITypeInfo</I> interface, which involves the component's <U>type</U> <U>library</U>. A type library is a table, locatable through the Registry, which allows a client to query the component for the symbolic names of objects, methods, and properties. A client could, for example, contain a browser that allows the user to explore the component's capabilities.

<P>The MFC library supports type libraries, but it doesn't use them in its implementation of <I>IDispatch</I>, which is instead driven by a <U>dispatch</U> <U>map</U>. MFC programs don't call 
<I>CreateStdDispatch </I>at all, nor do they use a type library to implement <I>IDispatch::GetIDsOfNames</I>. This means that you can't use the MFC library if you implement a multilingual Automation component&#151;one that supports English and German property and method names, for example. (<I>CreateStdDispatch</I> doesn't support multilingual components either.)

<P>Later in this chapter you'll learn how a client can use a type library, and you'll see how AppWizard and ClassWizard create and maintain type libraries for you. Once your component has a type library, a client can use it for browsing, independent of the <I>IDispatch</I> implementation.

</BODY>
</HTML>



