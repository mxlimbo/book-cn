<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>MFC DLLs -- Extension vs. Regular</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="477"><H1><B>MFC DLLs&#151;Extension vs. Regular</B></H1></A>
<P>We've been looking at Win32 DLLs that have a 
<I>DllMain</I> function and some exported functions. Now we'll move into the world of the MFC application framework, which adds its own support layer on top of the Win32 basics. AppWizard lets you build two kinds of DLLs with MFC library support: 
<U>extension</U> <U>DLLs</U> and <U>regular</U> 
<U>DLLs</U>. You must understand the differences 
between these two types before you decide which one is best for your needs.

<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
Of course, Visual C++ lets you build a pure Win32 DLL without the MFC library, just as it lets you build a Windows program without the MFC library. This is an MFC-oriented book, however, so we'll ignore the Win32 option here.</BLOCKQUOTE>
</div>

<P>An extension DLL supports a C++ interface. In other words, the DLL 
can export whole classes and the client can construct objects of those classes or derive classes from them. An extension DLL dynamically links to the code in the DLL version of the MFC library. Therefore, an extension DLL requires that your client program be dynamically linked to the MFC library (the AppWizard default) and that both the client program and the extension DLL be synchronized to the same version of the MFC DLLs (mfc42.dll, mfc42d.dll, and so on). Extension DLLs are quite small; you can build a simple extension DLL with a size of 10 KB, which loads quickly.

<P>If you need a DLL that can be loaded by any Win32 programming 
environment (including Visual Basic version 6.0), you should use a regular DLL. A big restriction here is that the regular DLL can export only C-style functions. It can't export C++ classes, member functions, or overloaded functions because every C++ compiler has its own method of decorating names. You can, however, use C++ classes (and MFC library classes, in particular) inside your regular DLL.

<P>When you build an MFC regular DLL, you can choose to statically 
link or dynamically link to the MFC library. If you choose static linking, your 
DLL will include a copy of all the MFC library code it needs and will thus be 
self-contained. A typical Release-build statically linked regular DLL is about 144 KB in size. If you choose dynamic linking, the size drops to about 17 KB but you'll have to ensure that the proper MFC DLLs are present on the target 
machine. That's no problem if the client program is already dynamically linked to the same version of the MFC library.

<P>When you tell AppWizard what kind of DLL or EXE you want, 
compiler <I>#define</I> constants are set as shown in the following table.

<p><table cellpadding=5 width="95%">
<tr><td></td>
<td valign="top"><b>Dynamically Linked to Shared MFC Library</b></td>
<td valign="top"><b>Statically Linked* to MFC Library</b></td></tr>
<tr><td valign="top">Regular DLL</td>
<td valign="top"><I>_AFXDLL</I>, <I>_USRDLL</I></td>
<td valign="top"><I>_USRDLL</I></td></tr>
<tr><td valign="top"><P>Extension DLL</td>
<td valign="top"><I>_AFXEXT</I>, <I>_AFXDLL</I></td>
<td valign="top">unsupported option</td></tr>
<tr><td valign="top">Client EXE</td>
<td valign="top"><I>_AFXDLL</I></td>
<td valign="top">no constants defined</td></tr>
</table>

<P>*      Visual C++ Learning Edition does not support the static linking option.

<P>If you look inside the MFC source code and header files, you'll see a 
ton of <I>#ifdef</I> statements for these constants. This means that the library code is compiled quite differently depending on the kind of project you're producing.

<A NAME="478"><H2><B>The Shared MFC DLLs and the Windows DLLs</B></H2></A>
<P>If you build a Windows Debug target with the shared 
MFC DLL option, your program is dynamically linked to one or more of these (ANSI) MFC DLLs:

<p><table cellpadding=5 width="95%">
<tr><td valign="top">mfc42d.dll</td>
<td valign="top">Core MFC classes</td></tr>
<tr><td valign="top">mfco42d.dll</td>
<td valign="top">ActiveX (OLE) classes</td></tr>
<tr><td valign="top">mfcd42d.dll</td>
<td valign="top">Database classes (ODBC and DAO)</td></tr>
<tr><td valign="top">mfcn42d.dll</td>
<td valign="top">Winsock, WinInet classes</td></tr>
</table>

<P>When you build a Release target, your program is dynamically linked 
to mfc42.dll only. Linkage to these MFC DLLs is implicit via import libraries. 
You might assume implicit linkage to the ActiveX and ODBC DLLs in 
Windows, in which case you would expect all these DLLs to be linked to your 
Release-build client when it loads, regardless of whether it uses ActiveX or ODBC features. However, this is not what happens. Through some creative 
thunking, MFC loads the ActiveX and ODBC DLLs explicitly (by calling 
<I>LoadLibrary</I>) when one of their functions is first called. Your client application thus loads only the DLLs it needs.

<A NAME="479"><H2><B>MFC Extension DLLs&#151;Exporting Classes</B></H2></A>
<P>If your extension DLL contains only exported 
C++ classes, you'll have an easy time building and using it. The steps for building the EX22A example show you how to tell AppWizard that you're building an extension DLL skeleton. That skeleton has only the <I>DllMain</I> function. You simply add your own C++ classes to the project. There's only one special thing you must do. You must add the macro <I>AFX_EXT_CLASS</I> to the class declaration, as shown here:

<P><PRE>class AFX_EXT_CLASS CStudent : public CObject</PRE>

<P>This modification goes into the H file that's part of the DLL project, 
and it also goes into the H file that client programs use. In other words, the H files are exactly the same for both client and DLL. The macro generates 
different code depending on the situation&#151;it exports the class in the DLL and imports the class in the client.

<A NAME="480"><H2><B>The MFC Extension DLL Resource Search Sequence</B></H2></A>
<P>If you build a dynamically linked MFC <U>client</U> application, many of the MFC library's standard resources (error message strings, print preview dialog 
templates, and so on) are stored in the MFC DLLs (mfc42.dll, mfco42.dll, and 
so on), but your application has its own resources too. When you call an 
MFC function such as <I>CString::LoadString</I> or <I>CBitmap::LoadBitmap</I>, the framework steps in and searches first the EXE file's resources and then the MFC DLL's resources.

<P>If your program includes an extension DLL and your EXE needs a 
resource, the search sequence is first the EXE file, then the extension DLL, 
and then the MFC DLLs. If you have a string resource ID, for example, that is 
unique among all resources, the MFC library will find it. If you have duplicate 
string IDs in your EXE file and your extension DLL file, the MFC library loads 
the string in the EXE file.

<P>If the extension DLL loads a resource, the sequence is first the 
extension DLL, then the MFC DLLs, and then the EXE.

<P>You can change the search sequence if you need to. Suppose you want 
your EXE code to search the extension DLL's resources first. Use code such as this:

<P><pre>
HINSTANCE hInstResourceClient = AfxGetResourceHandle();
// Use DLL's instance handle
AfxSetResourceHandle(::GetModuleHandle(&quot;mydllname.dll&quot;));
CString strRes;
strRes.LoadString(IDS_MYSTRING);
// Restore client's instance handle
AfxSetResourceHandle(hInstResourceClient);
</pre>

<P>You can't use <I>AfxGetInstanceHandle</I> instead of 
<I>::GetModuleHandle</I>. In an extension DLL, 
<I>AfxGetInstanceHandle</I> returns the EXE's instance handle, 
not the DLL's handle.

<A NAME="481"><H2><B>The EX22A Example&#151;An MFC Extension DLL</B></H2></A>
<P>This example makes an extension DLL out of the 
<I>CPersistentFrame</I> class you saw in <A HREF="ch15a.htm">Chapter 15</A>. First you'll build the ex22a.dll file, and then you'll use it 
in a test client program, EX22B.

<P>Here are the steps for building the EX22A example:

<ol>
<P><LI><B>Run AppWizard to produce \vcpp32\ex22a\ex22a.</B>
Choose New from Visual C++'s File menu, and then click on the Projects tab as usual. 
Instead of selecting MFC AppWizard (exe), choose MFC AppWizard 
(dll), as shown here.
</ol>

<P><A HREF="javascript:fullSize('g22og01x.htm')"> <img src="g22og01.jpg" width=404 height=288 border=0 ALT = "Click to view at full size."> </A>

<ol>
<P>In this example, only one AppWizard screen appears. Choose MFC 
Extension DLL, as shown here.
</ol>

<P><A HREF="javascript:fullSize('g22og02x.htm')"> <img src="g22og02.jpg" width=404 height=325 border=0 ALT = "Click to view at full size."> </A>

<ol start=2>
<P><LI><B>Examine the ex22a.cpp file.</B> AppWizard generates the following 
code, which includes the <I>DllMain</I> function:

<P><pre>
// ex22a.cpp : Defines the initialization routines for the DLL.
//

#include &quot;stdafx.h&quot;
#include &lt;afxdllx.h&gt;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = _ _FILE_ _;
#endif

static AFX_EXTENSION_MODULE Ex22aDLL = { NULL, NULL };

extern &quot;C&quot; int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    // Remove this if you use lpReserved
    UNREFERENCED_PARAMETER(lpReserved);

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE0(&quot;EX22A.DLL Initializing!\n&quot;);

        // Extension DLL one-time initialization
        if (!AfxInitExtensionModule(Ex22aDLL, hInstance))
            return 0;

        // Insert this DLL into the resource chain

<I>    (generated comment lines deleted)</I>

        new CDynLinkLibrary(Ex22aDLL);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE0(&quot;EX22A.DLL Terminating!\n&quot;);
        // Terminate the library before destructors are called
        AfxTermExtensionModule(Ex22aDLL);
    }
    return 1;   // ok
}
</pre>

<P><LI><B>Insert the <I>CPersistentFrame</I> class into the 
project.</B> Choose Add To Project from the Project menu, and then choose Components And Controls from the submenu. Locate the file Persistent Frame.ogx that you created in <A HREF="ch15a.htm">Chapter 15</A> (or locate the copy on the companion 
CD-ROM). Click the Insert button to insert the class into the current project.
</ol>

<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
If you don't want to use the OGX component, you can copy the files Persist.h and Persist.cpp into your project directory and add them to the project by choosing Add To Project from the Visual C++ Project menu.</blockquote>
</div>

<ol start=4>
<P><LI><B>Edit the persist.h file.</B> Modify the line

<P><pre>
class CPersistentFrame : public CFrameWnd
</pre>

<P>to read

<P><pre>
class <B>AFX_EXT_CLASS</B> CPersistentFrame : public CFrameWnd
</pre>

<P><LI><B>Build the project and copy the DLL file.</B> Copy the file ex22a.dll from the \vcpp32\ex22a\Debug directory to your system directory (\Windows\System or \Winnt\System32).
</ol>

<A NAME="482"><H2><B>The EX22B Example&#151;A DLL Test Client Program</B></H2></A>
<P>This example starts off as a client for ex22a.dll. It imports the 
<I>CPersistentFrame</I> class from the DLL and uses it as a base class for the SDI frame window. 
Later you'll add code to load and test the other sample DLLs in this chapter.

<P>Here are the steps for building the EX22B example:

<ol>
<P><B><LI>Run AppWizard to produce \vcpp32\ex22b\ex22b.</B> This is an ordinary MFC EXE program. Select Single Document. Otherwise, accept the default settings. Be absolutely sure that in Step 5 you accept the As A Shared DLL option.

<P><LI><B>Copy the file persist.h from the 
\vcpp32\ex22a directory.</B>
Note that you're copying the header file, not the CPP file.

<P><LI><B>Change the <I>CMainFrame</I> base class to 
<I>CPersistentFrame </I>as you did in EX15A.</B> Replace all occurrences of 
<I>CFrameWnd</I> with <I>CPersistentFrame</I> in both MainFrm.h and MainFrm.cpp. Also insert the 
following line into MainFrm.h:

<P><B>#include &quot;persist.h&quot;</B>

<P><LI><B>Add the ex22a import library to the linker's input library 
list.</B> Choose Settings from Visual C++'s Project menu. Select All Configurations in the Settings For drop-down list. Then fill in the 
Object/Library Modules control on the Link page as shown below.

<P>You must specify the full pathname for the ex22a.lib file unless 
you have a copy of that file in your project directory.
</ol>

<P><A HREF="javascript:fullSize('g22og03x.htm')"> <img src="g22og03.jpg" width=404 height=260 border=0 ALT = "Click to view at full size."> </A>

<ol start=5>
<P><LI><B>Build and test the EX22B program.</B> If you run the program from 
the debugger and Windows can't find the EX22A DLL, Windows displays 
a message box when EX22B starts. If all goes well, you should have a 
persistent frame application that works exactly like the one in EX15A. 
The only difference is that the 
<I>CPersistentFrame</I> code is in an extension DLL.
</ol>

<A NAME="483"><H2><B>MFC Regular DLLs&#151;The <I>CWinApp</I> Derived Class</B></H2></A>
<P>When AppWizard generates a regular DLL, the <I>DllMain</I> function is inside the framework and you end up with a class derived from <I>CWinApp </I>(and a global object of that class), just as you would with an EXE program. You can get control by overriding <I>CWinApp::InitInstance</I> and 
<I>CWinApp::ExitInstance</I>. Most of the time, you don't bother overriding those functions, though. You simply write the C functions and then export them with the <I>__declspec(dllexport)</I> modifier (or with entries in the project's DEF file).

<A NAME="484"><H2><B>Using the <I>AFX_MANAGE_STATE</I> Macro</B></H2></A>
<P>When mfc42.dll is loaded as part of a process, it stores data in some truly 
global variables. If you call MFC functions from an MFC program or extension DLL, mfc42.dll knows how to set these global variables on behalf of the calling process. If you call into mfc42.dll from a regular MFC DLL, however, the global variables are not synchronized and the effects will be unpredictable. To solve this problem, insert the line

<P><pre>
AFX_MANAGE_STATE(AfxGetStaticModuleState());
</pre>

<P>at the start of all exported functions in your regular DLL. If the MFC code 
is statically linked, the macro will have no effect.

<A NAME="485"><H2><B>The MFC Regular DLL Resource Search Sequence</B></H2></A>
<P>When an EXE links to a regular DLL, resource loading functions inside the 
EXE will load the EXE's own resources. Resource loading functions inside the 
regular DLL will load the DLL's own resources.

<P>If you want your EXE code to load resources from the DLL, you can use <I>AfxSetResourceHandle</I> to temporarily change the resource handle. The code 
will be nearly the same as that shown in &quot;<A HREF="ch22c.htm#480">The MFC Extension DLL Resource Search Sequence</A>.&quot; If you're writing an application that needs to be localized, you can put language-specific strings, dialogs, menus, and so forth in an MFC regular DLL. You might, for example, include the 
modules English.dll, German.dll, and French.dll. Your client program would 
explicitly load the correct DLL and use code such as that in &quot;<A HREF="ch22c.htm#480">The MFC Extension DLL Resource Search Sequence</A>&quot; to load the resources, which would have the same IDs in all the DLLs.

<A NAME="486"><H2><B>The EX22C Example&#151;An MFC Regular DLL</B></H2></A>
<P>This example creates a regular DLL that exports a single square root 
function. First you'll build the ex22c.dll file, and then you'll modify the test client program, EX22B, to test the new DLL.

<P>Here are the steps for building the EX22C example:

<ol>
<P><LI><B>Run AppWizard to produce \vcpp32\ex22c\ex22c.</B> Proceed as you did for EX22A, but accept Regular DLL Using Shared MFC DLL (instead of choosing MFC Extension DLL) from the one and only AppWizard page.

<P><LI><B>Examine the ex22c.cpp file.</B> AppWizard generates the following 
code, which includes a derived <I>CWinApp</I> class:

<P><pre>
// ex22c.cpp : Defines the initialization routines for the DLL.
//

#include &quot;stdafx.h&quot;
#include &quot;ex22c.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = _ _FILE_ _;
#endif

<I>(generated comment lines omitted)</I>

//////////////////////////////////////////////////////////////////////
// CEx22cApp

BEGIN_MESSAGE_MAP(CEx22cApp, CWinApp)
    //{{AFX_MSG_MAP(CEx22cApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
     //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
// CEx22cApp construction

CEx22cApp::CEx22cApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

//////////////////////////////////////////////////////////////////////
// The one and only CEx22cApp object

CEx22cApp theApp;
</pre>

<P><LI><B>Add the code for the exported <I>Ex22cSquareRoot</I> function.</B> It's okay to add this code in the ex22c.cpp file, although you can use a new file if you want to:
<P>
<B><pre>
extern &quot;C&quot; __declspec(dllexport) double Ex22cSquareRoot(double d)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    TRACE(&quot;Entering Ex22cSquareRoot\n&quot;);
    if (d &gt;= 0.0) {
        return sqrt(d);
    }
    AfxMessageBox(&quot;Can't take square root of a negative number.&quot;);
    return 0.0;
}</pre></B>

<P>You can see that there's no problem with the DLL displaying a 
message box or another modal dialog. You'll need to include math.h in the 
file containing this code.

<P><LI><B>Build the project and copy the DLL file.</B> Copy the file ex22c.dll from the \vcpp32\ex22c\Debug directory to your system directory.
</ol>

<A NAME="487"><H2><B>Updating the EX22B Example&#151;Adding Code to Test ex22c.dll</B></H2></A>
<P>When you first built the EX22B program, it linked dynamically to the 
EX22A MFC extension DLL. Now you'll update the project to implicitly link to 
the EX22C MFC regular DLL and to call the DLL's square root function.

<P>Following are the steps for updating the EX22B example.

<ol>
<P><LI><B>Add a new dialog resource and class to \vcpp32\ex22b\ex22b.</B> Use the dialog editor to create the <I>IDD_EX22C</I> template, as shown here.
</ol>

<P><img src="g22og04.gif" width=285 height=179 border="0">

<ol>
<P>Then use ClassWizard to generate a class <I>CTest22cDialog</I>, derived from <I>CDialog</I>. The controls, data members, and message map function are shown in the following table.
</ol>

<P><table cellpadding=5 width="95%">
<tr><td valign="top"><b>Control ID</b></td>
<td valign="top"><b>Type</b></td>
<td valign="top"><b>Data Member</b></td>
<td valign="top">Message Map Function</td></tr>
<tr><td valign="top"><I>IDC_INPUT</I></td>
<td valign="top">edit</td>
<td valign="top"><I>m_dInput</I> (double)</td>
<td valign="top"></td></tr>
<tr><td valign="top"><I>IDC_OUTPUT</I></td>
<td valign="top">edit</td>
<td valign="top"><I>m_dOutput</I> (double)</td>
<td valign="top"></td></tr>
<tr><td valign="top"><I>IDC_COMPUTE</I></td>
<td valign="top">button</td>
<td valign="top"></td>
<td valign="top"><I>OnCompute</I></td></tr>
</table>

<ol start=2>
<P><B><LI>Code the <I>OnCompute</I> function to call the DLL's exported 
function. </B>Edit the ClassWizard-generated function in Test22cDialog.cpp as 
shown here:

<P><pre>
void CTest22cDialog::OnCompute()
{
    <B>UpdateData(TRUE);
    m_dOutput = Ex22cSquareRoot(m_dInput);
    UpdateData(FALSE);</B>
}
</pre>

<P>You'll have to declare the <I>Ex22cSquareRoot</I> function as an imported 
function. Add the following line to the Test22cDialog.h file:

<P><B><pre>
extern &quot;C&quot; __declspec(dllimport) double Ex22cSquareRoot(double d);
</pre></b>

<P><B><LI>Integrate the <I>CTest22cDialog</I> class into the EX22B application. </B> You'll need to add a top-level menu, Test, and an Ex22c DLL option 
with the ID <I>ID_TEST_EX22CDLL</I>. Use ClassWizard to map this option to 
a member function in the <I>CEx22bView</I> class, and then code the handler 
in Ex22bView.cpp as follows:

<P><pre>
void CEx22bView::OnTestEx22cdll()
{
<B>    CTest22cDialog dlg;
    dlg.DoModal();</B>
}
</pre>

<P>Of course, you'll have to add this line to the Ex22bView.cpp file:

<P><B><pre>
#include &quot;Test22cDialog.h&quot;
</pre></b>

<P><B><LI>Add the EX22C import library to the linker's input library list.</B> Choose Settings from Visual C++'s Project menu, and then <U>add</U> <I>\vcpp32\ex22c\Debug\ex22c.lib</I> to the Object/Library Modules control on the Link page. (Use a space to separate the new entry from the existing entry.) Now the program should implicitly link to both the EX22A DLL and the EX22C DLL. As you can see, the client doesn't care whether the DLL is a regular DLL or an extension DLL. You just specify the LIB name to the linker.

<P><B><LI>Build and test the updated EX22B application.</B> Choose Ex22c DLL from the Test menu. Type a number in the Input edit control, and then click the Compute Sqrt button. The result should appear in the Output control.
</ol>

</BODY>
</HTML>



