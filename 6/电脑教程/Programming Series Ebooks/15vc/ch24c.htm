<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The Component Object Model</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="503"><H1><B>The Component Object Model</B></H1></A>
<P>COM is an &quot;industry-standard&quot; software architecture supported by Microsoft, Digital Equipment Corporation, and many other companies. It's by no means the <U>only</U> standard. Indeed, it competes directly against other standards, such as Corba from the Open Software Foundation (OSF). Some people are working to establish interoperability between COM and other architectures, but my guess is that COM will become the leading standard.

<A NAME="504"><H2><B>The Problem That COM Solves</B></H2></A>
<P>The &quot;problem&quot; is that there's no standard way for Windows program modules to communicate with one another. &quot;But,&quot; you say &quot;what about the DLL with its exported functions, Dynamic Data Exchange (DDE), the Windows Clipboard, and the Windows API itself, not to mention legacy standards such as VBX and OLE 1? Aren't they good enough?&quot; Well, no. You can't build an 
object-oriented operating system for the future out of these ad hoc, unrelated standards. With the Component Object Model, however, you can, and that's precisely what Microsoft is doing.

<A NAME="505"><H2><B>The Essence of COM</B></H2></A>
<P>What's wrong with the old standards? A lot. The Windows API has too large a programming &quot;surface area&quot;&#151;more than 350 separate functions. VBXs don't work in the 32-bit world. DDE comes with a complicated system of applications, topics, and items. How you call a DLL is totally application-specific. COM provides a unified, expandable, object-oriented communications protocol 
for Windows that already supports the following features:

<UL>
<p><LI>A standard, language-independent way for a Win32 client EXE to load and call a Win32 DLL

<P><LI>A general-purpose way for one EXE to control another EXE on the same computer (the DDE replacement)

<P><LI>A replacement for the VBX control, called an ActiveX control

<P><LI>A powerful new way for application programs to interact with the operating system

<P><LI>Expansion to accommodate new protocols such as Microsoft's OLE DB database interface

<P><LI>The distributed COM (DCOM) that allows one EXE to communicate with another EXE residing on a different computer, even if the computers use different microprocessor-chip families
</UL>

<P>So what is COM? That's an easier question to ask than to answer. At DevelopMentor (a training facility for software developers), the party line is that &quot;COM is love.&quot; That is, COM is a powerful integrating technology that allows you to mix all sorts of disparate software parts together at runtime. COM allows developers to write software that runs together regardless of issues such as thread-awareness and language choice.

<P>COM is a protocol that connects one software module with another and then drops out of the picture. After the connection is made, the two modules can communicate through a mechanism called an 
<U>interface</U>. Interfaces require no statically or dynamically linked entry points or hard-coded addresses other than the few general-purpose COM functions that start the communication process. An interface (more precisely, a COM interface) is a term that you'll be seeing a lot of. 

<A NAME="506"><H2><B>What Is a COM Interface?</B></H2></A>
<P>Before digging into the topic of interfaces, let's re-examine the nature of inheritance and polymorphism in normal C++. We'll use a planetary-motion simulation (suitable for NASA or Nintendo) to illustrate C++ inheritance and polymorphism. Imagine a spaceship that travels through our solar system 
under the influence of the sun's gravity. In ordinary C++, you could declare a <I>CSpaceship</I> class and write a constructor that sets the spaceship's initial position and acceleration. Then you could write a nonvirtual member function named <I>Fly</I> that implemented Kepler's laws to model the movement of the spaceship from one position to the next&#151;say, over a period of 0.1 second. You could also write a <I>Display</I> function that painted an image of the spaceship in a window. 
The most interesting feature of the <I>CSpaceship</I> class is that the interface of the C++ class (the way the client talks to the class) and the implementation are tightly bound. One of the main goals of COM is to separate a class's interface from its implementation.

<P>If we think of this example within the context of COM, the spaceship code could exist as a separate EXE or DLL (the <U>component</U>), which is a COM module. In COM the simulation manager (the 
<U>client</U> program) can't call <I>Fly</I> or any <I>CSpaceship</I> constructor directly: COM provides only a standard global function to gain access to the spaceship object, and then the client and the object use interfaces to talk to one another. Before we tackle real COM, let's build a COM simulation in which both the component and the client code are statically linked in the same EXE file. For our standard global function, we'll invent a function named <I>GetClassObject. </I>

<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
If you want to map this process back to the way MFC works, you can look at <I>CRuntimeClass,</I> which serves as a class object for <I>CObject</I>-based classes. A class object is a meta-class (either in concept or in form).</blockquote></div>

<P>In this COM simulation, clients will use this global single abstract function (<I>GetClassObject</I>) for objects of a particular class. In real COM, clients would get a class object first and then ask the class object to manufacture the real object in much the same way MFC does dynamic creation. <I>GetClassObject</I>  has the following three parameters: 

<P><pre>
BOOL GetClassObject(int nClsid, int nIid, void** ppvObj);
</pre>

<P>The first <I>GetClassObject</I> parameter, <I>nClsid</I>, is a 32-bit integer that uniquely identifies the <I>CSpaceship</I> class. The second parameter, <I>nIid</I>, is the unique identifier of the interface that we want. The third parameter is a pointer to an interface to the object. Remember that we're going to be dealing with interfaces now, (which are different from classes). As it turns out, a class can have several interfaces, so the last two parameters exist to manage interface 
selection. The function returns <I>TRUE</I> if the call is successful.

<P>Now let's back up to the design of  <I>CSpaceship</I>. We haven't really explained spaceship interfaces yet. A COM interface is a C++ base class (actually, a C++ <I>struct</I>) that declares a group of pure virtual functions. These functions completely control some aspect of derived class behavior. For <I>CSpaceship</I>, let's write an interface named <I>IMotion</I>, which controls the spaceship object's position. For simplicity's sake, we'll declare just two functions, <I>Fly</I> and <I>GetPosition</I>, and we'll keep things uncomplicated by making the position value an integer. The 
<I>Fly</I> function calculates the position of the spaceship, and the <I>GetPosition</I> function returns a reference to the current position. Here are the declarations:

<P><pre>
struct IMotion
{
    virtual void Fly() = 0;
    virtual int&amp; GetPosition() = 0;
};

class CSpaceship : public IMotion
{
protected:
    int m_nPosition;
public:
    CSpaceship() { m_nPosition = 0; }
    void Fly();
    int&amp; GetPosition() { return m_nPosition; }
};
</pre>

<P>The actual code for the spaceship-related functions&#151;including <I>GetClassObject</I>&#151;is located in the component part of the program. The client part calls the <I>GetClassObject</I> function to construct the spaceship and to obtain an <I>IMotion</I> pointer. Both parts have access to the 
<I>IMotion</I> declaration at compile time. Here's how the client calls <I>GetClassObject</I>:

<P><pre>
IMotion* pMot;
GetClassObject(CLSID_CSpaceship, IID_IMotion, (void**) &amp;pMot);
</pre>

<P>Assume for the moment that COM can use the unique integer identifiers <I>CLSID_CSpaceship</I> and 
<I>IID_IMotion</I> to construct a spaceship object instead of some other kind of object. If the call is successful, <I>pMot</I> points to a <I>CSpaceship</I> object that <I>GetClassObject</I> somehow constructs. As you can see, the <I>CSpaceship</I> class implements the <I>Fly</I> and 
<I>GetPosition</I> functions, and our main program can call them for the one particular spaceship object, as shown here:

<P><pre>
int nPos = 50;
pMot-&gt;GetPosition() = nPos;
pMot-&gt;Fly();
nPos = pMot-&gt;GetPosition();
TRACE(&quot;new position = %d\n&quot;, nPos);
</pre>

<P>Now the spaceship is off and flying. We're controlling it entirely through the <I>pMot</I> pointer. Notice that <I>pMot</I> is technically not a pointer to a <I>CSpaceship</I> object. However, in this case, a <I>CSpaceship</I> pointer and an <I>IMotion</I> pointer are the same because <I>CSpaceship</I> is derived from <I>IMotion</I>. You can see how the virtual functions work here: it's classic 
C++ polymorphism.

<P>Let's make things a little more complex by adding a second interface, <I>IVisual</I>, which handles the spaceship's visual representation. One function is enough&#151;<I>Display</I>. Here's the whole base class:

<P><pre>
struct IVisual
{
    virtual void Display() = 0;
};
</pre>

<P>Are you getting the idea that COM wants you to associate functions in groups? You're not imagining it. But why? Well, in your space simulation, you probably want to include other kinds of objects in addition to spaceships. Imagine that the <I>IMotion</I> and <I>IVisual</I> interfaces are being used for other classes. Perhaps a <I>CSun</I> class has an implementation of <I>IVisual</I> but does not have an implementation of <I>IMotion</I>, and perhaps a <I>CSpaceStation</I> class has other 
interfaces as well. If you &quot;published&quot; your <I>IMotion</I> and <I>IVisual</I> interfaces, 
perhaps other space simulation software companies would adopt them.

<P>Think of an interface as a contract between two software modules. The idea is that interface declarations never change. If you want to upgrade your spaceship code, you don't change the 
<I>IMotion</I> or the<I> IVisual</I> interface; rather, you add a new interface, such as <I>ICrew</I>. The existing spaceship clients can continue to run with the old interfaces, and new client programs can use the new <I>ICrew</I> interface as well. These client programs can find out at runtime which 
interfaces a particular spaceship software version supports.

<P>Consider the <I>GetClassObject</I> function as a more powerful alternative to the C++ constructor. With the ordinary constructor, you obtain one object with one batch of member functions. With the 
<I>GetClassObject</I> function, you obtain the object plus your choice of interfaces. As you'll see later, you start with one interface and then use that interface to get other interfaces to the same object.

<P>So how do you program <U>two</U> interfaces for <I>CSpaceship</I>? You could use C++ multiple inheritance, but that wouldn't work if two interfaces had the same member function name. The MFC library uses <U>nested</U> <U>classes</U> instead, so that's what we'll use to illustrate multiple interfaces on the <I>CSpaceship</I> class. Not all C++ programmers are familiar with nested classes, so I'll offer a little help. Here's a first cut at nesting interfaces within the 
<I>CSpaceship</I> class:

<P><pre>
class CSpaceship
{
protected:
    int m_nPosition;
    int m_nAcceleration;
    int m_nColor;
public:
    CSpaceship()
        { m_nPosition = m_nAcceleration = m_nColor = 0; }
    class XMotion : public IMotion
    {
    public:
        XMotion() { }
        virtual void Fly();
        virtual int&amp; GetPosition();
    } m_xMotion;

    class XVisual : public IVisual
    {
    public:
        XVisual() { }
        virtual void Display();
    } m_xVisual;

    friend class XVisual;
    friend class XMotion;
};
</pre>

<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
It might make sense to make <I>m_nAcceleration</I> a data member of <I>XMotion</I> and <I>m_nColor</I> a data member of <I>XVisual</I>. We'll make them data members of <I>CSpaceship</I> because that strategy is more compatible with the MFC macros, as you'll see later.
</blockquote></div>

<P>Notice that the implementations of <I>IMotion</I> and <I>IVisual</I> are contained within the &quot;parent&quot; <I>CSpaceship</I> class. In COM, this parent class is known as the class with <U>object identity</U>. Be aware that <I>m_xMotion</I> and <I>m_xVisual</I> are actually embedded data members of <I>CSpaceship.</I> Indeed, you could have implemented <I>CSpaceship</I> strictly with embedding. Nesting, however, brings to the party two advantages : 1) nested class member functions can access parent class data members without the need for <I>CSpaceship</I> pointer data members, and 2) the nested classes are neatly packaged along with the parent while remaining invisible outside the parent. Look at the code below for the <I>GetPosition</I> member function.

<P><pre>
int&amp; CSpaceship::XMotion::GetPosition()
{
    METHOD_PROLOGUE(CSpaceship, Motion) // makes pThis
    return pThis-&gt;m_nPosition;
}
</pre>

<P>Notice also the double scope resolution operators, which are necessary for nested class member functions. <I>METHOD_PROLOGUE</I> is a one-line MFC macro that uses the C <I>offsetof</I> operator to retrieve the offset used in generating a <I>this</I> pointer to the parent class, <I>pThis</I>. The compiler always knows the offset from the beginning of parent class data to the beginning of nested class data. <I>GetPosition</I> can thus access the <I>CSpaceship</I> data member <I>m_nPosition</I>.

<P>Now suppose you have <U>two</U> interface pointers, <I>pMot</I> and <I>pVis</I>, for a particular 
<I>CSpaceship</I> object. (Don't worry yet about how you got these pointers.) You can call interface member functions in the following manner:

<P><pre>
pMot-&gt;Fly();
pVis-&gt;Display();
</pre>

<P>What's happening under the hood? In C++, each <U>class</U> (at least, each class that has virtual functions and is not an abstract base class) has a virtual function table, which is otherwise known as a <U>vtable</U>. In this example, that means there are vtables for <I>CSpaceship::XMotion</I> and 
<I>CSpaceship::XVisual</I>. For each <U>object</U>, there's a pointer to the object's data, the first element of which is a pointer to the class's vtable. The pointer relationships are shown here.

<P><A HREF="javascript:fullSize('g24og01x.htm')"> <img src="g24og01.jpg" width=404 height=174 border=0 ALT = "Click to view at full size."> </A>

<p><DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0>
<P>Theoretically, it's possible to program COM in C. If you look at the Windows header files, you'll see code such as this:

<P><pre>
#ifdef __cplusplus
        // C++-specific headers
#else
        /* C-specific headers */
#endif
</pre>

<P>In C++, interfaces are declared as C++ <I>structs</I>, often with inheritance; in C, they're declared as C <I>typedef structs</I> with no inheritance. In C++, the compiler generates vtables for your derived classes; in C, you must &quot;roll your own&quot; vtables, and that gets tedious. It's 
important to realize, however, that in neither language do the interface declarations have data members, constructors, or destructors. Therefore, you can't rely on the interface having a virtual 
destructor&#151;but that's not a problem because you never invoke a destructor for an interface.</blockquote></div>

<A NAME="507"><H2><B>The <I>IUnknown</I> Interface and the <I>QueryInterface</I> Member Function</B></H2></A>
<P>Let's get back to the problem of how to obtain your interface pointers in the first place. COM declares a special interface named <I>IUnknown</I> for this purpose. As a matter of fact, all interfaces are derived from <I>IUnknown</I>, which has a pure virtual member function, <I>QueryInterface</I>, that returns an interface pointer based on the interface ID you feed it. 

<P>Once the interface mechanisms are hooked up, the client needs to get an <I>IUnknown</I> interface pointer (at the very least) or a pointer to one of the derived interfaces. Here is the new interface hierarchy, with <I>IUnknown</I> at the top:

<P><pre>
struct IUnknown
{
    virtual BOOL QueryInterface(int nIid, void** ppvObj) = 0;
};

struct IMotion : public IUnknown
{
    virtual void Fly() = 0;
    virtual int&amp; GetPosition() = 0;
};

struct IVisual : public IUnknown
{
    virtual void Display() = 0;
};
</pre>

<P>To satisfy the compiler, we must now add <I>QueryInterface</I> implementations in both 
<I>CSpaceship::XMotion</I> and <I>CSpaceship::XVisual. </I>What do the vtables look like after this is done? For each derived class, the compiler builds a vtable with the base class function pointers on top, as shown here.

<P><A HREF="javascript:fullSize('g24og02x.htm')"> <img src="g24og02.jpg" width=404 height=93 border=0 ALT = "Click to view at full size."> </A>

<P><I>GetClassObject</I> can get the interface pointer for a given <I>CSpaceship</I> object by getting the address of the corresponding embedded object. Here's the code for the <I>QueryInterface</I> function<I> </I>in<I> XMotion</I>:

<P><pre>
BOOL CSpaceship::XMotion::QueryInterface(int nIid,
                                         void** ppvObj)
{
    METHOD_PROLOGUE(CSpaceship, Motion)
    switch (nIid) {
    case IID_IUnknown:
    case IID_IMotion:
        *ppvObj = &amp;pThis-&gt;m_xMotion;
        break;
    case IID_IVisual:
        *ppvObj = &amp;pThis-&gt;m_xVisual;
        break;
    default:
        *ppvObj = NULL;
        return FALSE;
    }
    return TRUE;
}
</pre>

<P>Because <I>IMotion</I> is derived from <I>IUnknown</I>, an <I>IMotion</I> pointer is a valid 
pointer if the caller asks for an <I>IUnknown</I> pointer.

<p><DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0>

<P>The COM standard demands that <I>QueryInterface</I> return exactly the same <I>IUnknown</I> pointer value for <I>IID_IUnknown</I>, no matter which interface pointer you start with. Thus, if two <I>IUnknown</I> pointers match, you can assume that they refer to the same object. <I>IUnknown</I> is sometimes known as the &quot;void*&quot; of COM because it represents the object's identity.</blockquote></div>

<P>Below is a <I>GetClassObject</I> function that uses<I> </I>the address of <I>m_xMotion</I> to obtain the first interface pointer for the newly constructed <I>CSpaceship</I> object:

<P><pre>BOOL GetClassObject(int&amp; nClsid, int&amp; nIid,
                    void** ppvObj)
{
    ASSERT(nClsid == CLSID_CSpaceship); 
    CSpaceship* pObj = new CSpaceship();
    IUnknown* pUnk = &amp;pObj-&gt;m_xMotion;
    return pUnk-&gt;QueryInterface(nIid, ppvObj);
}
</pre>

<P>Now your client program can call <I>QueryInterface</I> to obtain an <I>IVisual</I> pointer, as shown here:

<P><pre>
IMotion* pMot;
IVisual* pVis;
GetClassObject(CLSID_CSpaceship, IID_IMotion, (void**) &amp;pMot);
pMot-&gt;Fly();
pMot-&gt;QueryInterface(IID_IVisual, (void**) &amp;pVis);
pVis-&gt;Display();
</pre>

<P>Notice that the client uses a <I>CSpaceship</I> object, but it <U>never</U> has an actual <I>CSpaceship</I> pointer. Thus, the client cannot directly access <I>CSpaceship</I> data members even if they're public. Notice also that we haven't tried to delete the spaceship object yet&#151;that will come shortly.

<P>There's a special graphical representation for interfaces and COM classes. Interfaces are shown as small circles (or <U>jacks</U>) with lines attached to their class. The <I>IUnknown</I> interface, which every COM class supports, is at the top, and the others are on the left. The <I>CSpaceship</I> class can be represented like this.

<P><img src="g24og03.gif" width=236 height=103 border="0">

<A NAME="508"><H2><B>Reference Counting: The <I>AddRef</I> and <I>Release</I> Functions</B></H2></A>
<P>COM interfaces don't have virtual destructors, so it isn't cool to write code like the following:

<P><pre>
delete pMot;  // pMot is an IMotion pointer; don't do this
</pre>

<P>COM has a strict protocol for deleting objects; the two other <I>IUnknown</I> virtual functions, <I>AddRef</I> and <I>Release</I>, are the key. Each COM class has a data member&#151;<I>m_dwRef</I>, in the MFC library&#151;that keeps track of how many &quot;users&quot; an object has. Each time the component program returns a new interface pointer (as in <I>QueryInterface</I>), the program calls 
<I>AddRef</I>, which increments <I>m_dwRef. </I>When the client program is finished with the pointer, it calls <I>Release</I>. When <I>m_dwRef</I> goes to 0, the object destroys itself. Here's an example of a <I>Release</I> function for the <I>CSpaceship::XMotion</I> class:

<P><pre>
DWORD CSpaceship::XMotion::Release()
{
    METHOD_PROLOGUE(CSpaceship, Motion) // makes pThis
    if (pThis-&gt;m_dwRef == 0)
        return 0;
    if (--pThis-&gt;m_dwRef == 0) {
        delete pThis; // the spaceship object
        return 0;
    }
    return pThis-&gt;m_dwRef;
}
</pre>

<P>In MFC COM-based programs, the object's constructor sets <I>m_dwRef</I> to 1. This means that it isn't necessary to call <I>AddRef</I> after the object is first constructed. A client program should call <I>AddRef</I>, however, if it makes a copy of an interface pointer.

<A NAME="509"><H2><B>Class Factories</B></H2></A>
<P>Object-oriented terminology can get a little fuzzy sometimes. Smalltalk programmers, for example, talk about &quot;objects&quot; the way C++ programmers talk about &quot;classes.&quot; The COM literature often uses the term &quot;component object&quot; to refer to the object plus the code associated with it. COM carries with it the notion of a &quot;class object,&quot; which is sometimes referred to as a &quot;class factory.&quot; To be more accurate, it should probably be called an &quot;object factory.&quot; A COM class object represents the global static area of a specific COM class. Its analog in MFC is the <I>CRuntimeClass</I>. A class object is sometimes called a <U>class</U> <U>factory</U> because it often implements a special COM interface named <I>IClassFactory</I>. This interface, like all interfaces, is derived from <I>IUnknown</I>. <I>IClassFactory</I>'s principal member function is <I>CreateInstance</I>, which in our COM simulation is declared like this:

<P><pre>
virtual BOOL CreateInstance(int&amp; nIid, void** ppvObj) = 0;
</pre>

<P>Why use a class factory? We've already seen that we can't call the target class constructor directly; we have to let the component module decide how to construct objects. The component provides the class factory for this purpose and thus encapsulates the creation step, as it should. Locating and launching component modules&#151;and thus establishing the class factory&#151;is expensive, but constructing objects with <I>CreateInstance</I> is cheap. We can therefore allow a single class factory to create multiple objects.

<P>What does all this mean? It means that we screwed up when we let <I>GetClassObject</I> construct the <I>CSpaceship</I> object directly. We were supposed to construct a class factory object first and then call <I>CreateInstance</I> to cause the class factory (object factory) to construct the actual spaceship object.

<P>Let's properly construct the spaceship simulation. First we declare a new class, <I>CSpaceshipFactory</I>. To avoid complication, we'll derive the class from <I>IClassFactory</I> so that we don't have to deal with nested classes. In addition, we'll add the code that tracks references:

<P><pre>
struct IClassFactory : public IUnknown
{
    virtual BOOL CreateInstance(int&amp; nIid, void** ppvObj) = 0;
};

class CSpaceshipFactory : public IClassFactory
{
private:
    DWORD m_dwRef;
public:
    CSpaceshipFactory() { m_dwRef = 1; }
    // IUnknown functions
    virtual BOOL QueryInterface(int&amp; nIid,
                                void** ppvObj);
    virtual DWORD AddRef();
    virtual DWORD Release();
    // IClassFactory function
    virtual BOOL CreateInstance(int&amp; nIid,
                                void** ppvObj);
};
</pre>

<P>Next we'll write the <I>CreateInstance</I> member function:

<P><pre>
BOOL CSpaceshipFactory::CreateInstance(int&amp; nIid, void** ppvObj)
{
    CSpaceship* pObj = new CSpaceship();
    IUnknown* pUnk = &amp;pObj-&gt;m_xMotion;
    return pUnk-&gt;QueryInterface(nIid, ppvObj);
}
</pre>

<P>Finally, here is the new <I>GetClassObject</I> function, which constructs a class factory object and returns an <I>IClassFactory</I> interface pointer.

<P><pre>
BOOL GetClassObject(int&amp; nClsid, int&amp; nIid,
                    void** ppvObj)
{
    ASSERT(nClsid == CLSID_CSpaceship);
    ASSERT((nIid == IID_IUnknown) || (nIid == IID_IClassFactory));
    CSpaceshipFactory* pObj = new CSpaceshipFactory();
    *ppObj = pObj; // IUnknown* = IClassFactory* = CSpaceship*
}
</pre>

<P>The <I>CSpaceship</I> and <I>CSpaceshipFactory</I> classes work together and share the same class ID. Now the client code looks like this (without error-checking logic):

<P><pre>
IMotion* pMot;
IVisual* pVis;
IClassFactory* pFac;
GetClassObject(CLSID_CSpaceship, IID_IClassFactory, (void**) &amp;pFac);
pFac-&gt;CreateInstance(IID_IMotion, &amp;pMot);
pMot-&gt;QueryInterface(IID_IVisual, (void**) &amp;pVis);
pMot-&gt;Fly();
pVis-&gt;Display();
</pre>

<P>Notice that the <I>CSpaceshipFactory</I> class implements the <I>AddRef</I> and <I>Release</I> functions. It must do this because <I>AddRef</I> and <I>Release</I> are pure virtual functions in the 
<I>IUnknown</I> base class. We'll start using these functions in the next iteration of the program.

<A NAME="510"><H2><B>The <I>CCmdTarget</I> Class</B></H2></A>
<P>We're still a long way from real MFC COM-based code, but we can take one more step in the COM simulation before we switch to the real thing. As you might guess, some code and data can be &quot;factored out&quot; of our spaceship COM classes into a base class. That's exactly what the MFC library does. The base class is <I>CCmdTarget</I>, the standard base class for document and window 
classes. <I>CCmdTarget</I>, in turn, is derived from <I>CObject</I>. We'll use <I>CSimulatedCmdTarget</I> instead, and we won't put too much in it&#151;only the reference-counting logic and the <I>m_dwRef</I> data member. The <I>CSimulatedCmdTarget</I> functions 
<I>ExternalAddRef</I> and <I>ExternalRelease</I> can be called in derived COM classes. Because we're using <I>CSimulatedCmdTarget</I>, we'll bring <I>CSpaceshipFactory</I> in line with <I>CSpaceship</I>, and we'll use a nested class for the <I>IClassFactory</I> interface.

<P>We can also do some factoring out inside our <I>CSpaceship</I> class. The <I>QueryInterface</I> function can be &quot;delegated&quot; from the nested classes to the outer class helper function 
<I>ExternalQueryInterface</I>, which calls <I>ExternalAddRef</I>. Thus, each <I>QueryInterface</I> function increments the reference count, but <I>CreateInstance</I> calls <I>ExternalQueryInterface</I>, followed by a call to <I>ExternalRelease</I>. When the first interface pointer is returned by <I>CreateInstance</I>, the spaceship object has a reference count of 1. A subsequent <I>QueryInterface</I> call increments the count to 2, and in this case, the client must call <I>Release</I> twice to destroy the spaceship object.

<P>One last thing&#151;we'll make the class factory object a global object. That way we won't have to call its constructor. When the client calls <I>Release</I>, there isn't a problem because the class factory's reference count is 2 by the time the client receives it. (The <I>CSpaceshipFactory</I> constructor sets the reference count to 1, and <I>ExternalQueryInterface</I>, called by 
<I>GetClassObject</I>, sets the count to 2.)

<A NAME="511"><H2><B>The EX24A Example&#151;A Simulated COM</B></H2></A>
<P>Figures 24-1, 24-2, 24-3, and 24-4 show code for a working &quot;simulated COM&quot; program, EX24A. This is a Win32 Console Application (without the MFC library) that uses a class factory to construct an object of class <I>CSpaceship</I>, calls its interface functions, and then releases the spaceship. The Interface.h header file, shown in Figure 24-1, contains the <I>CSimulatedCmdTarget</I> base class and the interface declarations that are used by both the client and component programs. The Spaceship.h header file shown in Figure 24-2 contains the spaceship-specific class declarations that are used in the component program. Spaceship.cpp, shown in Figure 24-3, is the component that implements <I>GetClassObject</I>; Client.cpp, shown in Figure 24-4, is the client that calls <I>GetClassObject</I>. What's phony here is that both client and component code are linked within the same ex24a.exe program. Thus, our simulated COM is not required to make the connection at runtime. (You'll see how that's done later in this chapter.)

<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>INTERFACE.H</B>
<P><pre>
// definitions that make our code look like MFC code
#define BOOL   int
#define DWORD  unsigned int
#define TRUE   1
#define FALSE  0
#define TRACE  printf
#define ASSERT assert
//----------definitions and macros-----------------------------------
#define CLSID_CSpaceship    10
#define IID_IUnknown        0
#define IID_IClassFactory   1
#define IID_IMotion         2
#define IID_IVisual         3
// this macro for 16-bit Windows only
#define METHOD_PROLOGUE(theClass, localClass) \
    theClass* pThis = ((theClass*)((char*)(this) - \
    offsetof(theClass, m_x##localClass))); \


BOOL GetClassObject(int nClsid, int nIid, void** ppvObj);

//----------interface declarations-----------------------------------
struct IUnknown
{
    IUnknown() { TRACE(&quot;Entering IUnknown ctor %p\n&quot;, this); }
    virtual BOOL QueryInterface(int nIid, void** ppvObj) = 0;
    virtual DWORD Release() = 0;
    virtual DWORD AddRef() = 0;
};

struct IClassFactory : public IUnknown
{
    IClassFactory()
        { TRACE(&quot;Entering IClassFactory ctor %p\n&quot;, this); }
    virtual BOOL CreateInstance(int nIid, void** ppvObj) = 0;
};

struct IMotion : public IUnknown
{
    IMotion() { TRACE(&quot;Entering IMotion ctor %p\n&quot;, this); }
    virtual void Fly() = 0; // pure
    virtual int&amp; GetPosition() = 0;
};
struct IVisual : public IUnknown
{
    IVisual() { TRACE(&quot;Entering IVisual ctor %p\n&quot;, this); }
    virtual void Display() = 0;
};

class CSimulatedCmdTarget // `simulated' CSimulatedCmdTarget
{
public:
    DWORD m_dwRef;

protected:
    CSimulatedCmdTarget() {
        TRACE(&quot;Entering CSimulatedCmdTarget ctor %p\n&quot;, this);
        m_dwRef = 1; // implied first AddRef
    }
    virtual ~CSimulatedCmdTarget()
        { TRACE(&quot;Entering CSimulatedCmdTarget dtor %p\n&quot;, this); }
    DWORD ExternalRelease() {
    TRACE(&quot;Entering CSimulatedCmdTarget::ExternalRelease--RefCount = \
          %ld\n&quot;, m_dwRef);
        if (m_dwRef == 0)
            return 0;
        if(--m_dwRef == 0L) {
            TRACE(&quot;deleting\n&quot;);
            delete this;
            return 0;
        }
        return m_dwRef;
    }
    DWORD ExternalAddRef() { return ++m_dwRef; }
};
</pre>
</TD></TR></TABLE>
<P><B>Figure 24-1.</B> <I>The Interface.h file.</I>


<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>SPACESHIP.H</B>

<P><pre>
class CSpaceship;

//----------class declarations-----------------------------------------
class CSpaceshipFactory : public CSimulatedCmdTarget
{
public:
    CSpaceshipFactory()
        { TRACE(&quot;Entering CSpaceshipFactory ctor %p\n&quot;, this); }
    ~CSpaceshipFactory()
        { TRACE(&quot;Entering CSpaceshipFactory dtor %p\n&quot;, this); }
    BOOL ExternalQueryInterface(int lRid, void** ppvObj);
    class XClassFactory : public IClassFactory
    {
    public:
        XClassFactory()
            { TRACE(&quot;Entering XClassFactory ctor %p\n&quot;, this); }
        virtual BOOL QueryInterface(int lRid, void** ppvObj);
        virtual DWORD Release();
        virtual DWORD AddRef();
        virtual BOOL CreateInstance(int lRid, void** ppvObj);
    } m_xClassFactory;
    friend class XClassFactory;
};
class CSpaceship : public CSimulatedCmdTarget
{
private:
    int m_nPosition; // We can access these from
                     //  all the interfaces
    int m_nAcceleration;
    int m_nColor;
public:
    CSpaceship() {
        TRACE(&quot;Entering CSpaceship ctor %p\n&quot;, this);
        m_nPosition = 100;
        m_nAcceleration = 101;
        m_nColor = 102;
    }
    ~CSpaceship()
        { TRACE(&quot;Entering CSpaceship dtor %p\n&quot;, this); }
    BOOL ExternalQueryInterface(int lRid, void** ppvObj);
    class XMotion : public IMotion
    {
    public:
        XMotion()
            { TRACE(&quot;Entering XMotion ctor %p\n&quot;, this); }
        virtual BOOL QueryInterface(int lRid, void** ppvObj);
        virtual DWORD Release();
        virtual DWORD AddRef();
        virtual void Fly();
        virtual int&amp; GetPosition();
    } m_xMotion;
    
class XVisual : public IVisual
    {
    public:
        XVisual() { TRACE(&quot;Entering XVisual ctor\n&quot;); }
        virtual BOOL QueryInterface(int lRid, void** ppvObj);
        virtual DWORD Release();
        virtual DWORD AddRef();
        virtual void Display();
    } m_xVisual;

    friend class XVisual;  // These must be at the bottom!
    friend class XMotion;
    friend class CSpaceshipFactory::XClassFactory;
};
</pre>
</TD></TR></TABLE>
<P><B>Figure 24-2.</B> <I>The Spaceship.h file.</I>



<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>SPACESHIP.CPP</B>

<P><pre>
#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt; // for offsetof in METHOD_PROLOGUE
#include &lt;ASSERT.h&gt;
#include &quot;Interface.h&quot;
#include &quot;Spaceship.h&quot;

CSpaceshipFactory g_factory;

//----------member functions-----------------------------------------
BOOL CSpaceshipFactory::ExternalQueryInterface(int nIid,
                                               void** ppvObj) {
    TRACE(&quot;Entering CSpaceshipFactory::ExternalQueryInterface--nIid =  \
          %d\n&quot;, nIid);
    switch (nIid) {
    case IID_IUnknown:
    case IID_IClassFactory:
        *ppvObj = &amp;m_xClassFactory;
        break;
    default:
        *ppvObj = NULL;
        return FALSE;
    }
    ExternalAddRef();
    return TRUE;
}                               
BOOL CSpaceshipFactory::XClassFactory::QueryInterface(int nIid,
                                                      void** ppvObj) {
    TRACE(&quot;Entering CSpaceshipFactory::XClassFactory::\
           QueryInterface--nIid = %d\n&quot;, nIid);
    METHOD_PROLOGUE(CSpaceshipFactory, ClassFactory) // makes pThis
    return pThis-&gt;
    ExternalQueryInterface(nIid, ppvObj); // delegate to
                                          //  CSpaceshipFactory
}                               

BOOL CSpaceshipFactory::XClassFactory::CreateInstance(int nIid,
                                                      void** ppvObj) {
    TRACE(&quot;Entering CSpaceshipFactory::XClassFactory::CreateInstance\n&quot;);
    METHOD_PROLOGUE(CSpaceshipFactory, ClassFactory) // makes pThis
    CSpaceship* pObj = new CSpaceship();
    if (pObj-&gt;ExternalQueryInterface(nIid, ppvObj)) {
        pObj-&gt;ExternalRelease(); // balance reference count
        return TRUE;
    }
    return FALSE;
}

DWORD CSpaceshipFactory::XClassFactory::Release() {
    TRACE(&quot;Entering CSpaceshipFactory::XClassFactory::Release\n&quot;);
    METHOD_PROLOGUE(CSpaceshipFactory, ClassFactory) // makes pThis
    return pThis-&gt;ExternalRelease(); // delegate to CSimulatedCmdTarget
}

DWORD CSpaceshipFactory::XClassFactory::AddRef() {
    TRACE(&quot;Entering CSpaceshipFactory::XClassFactory::AddRef\n&quot;);
    METHOD_PROLOGUE(CSpaceshipFactory, ClassFactory) // makes pThis
    return pThis-&gt;ExternalAddRef(); // delegate to CSimulatedCmdTarget
}

BOOL CSpaceship::ExternalQueryInterface(int nIid, void** ppvObj) {
    TRACE(&quot;Entering CSpaceship::ExternalQueryInterface--nIid = 
           %d\n&quot;, nIid);
    switch (nIid) {
    case IID_IUnknown:
    case IID_IMotion:
        *ppvObj = &amp;m_xMotion; // Both IMotion and IVisual are derived
        break;                //  from IUnknown, so either pointer will do
    case IID_IVisual:
        *ppvObj = &amp;m_xVisual;
        break;
    default:
        *ppvObj = NULL;
        return FALSE;
    }
    ExternalAddRef();
    return TRUE;
}

BOOL CSpaceship::XMotion::QueryInterface(int nIid, void** ppvObj) {
    TRACE(&quot;Entering CSpaceship::XMotion::QueryInterface--nIid =  \ 
           %d\n&quot;, nIid);
    METHOD_PROLOGUE(CSpaceship, Motion) // makes pThis
    return pThis-&gt;ExternalQueryInterface(nIid, ppvObj); // delegate to
                                                        //  CSpaceship
} 

DWORD CSpaceship::XMotion::Release() {
    TRACE(&quot;Entering CSpaceship::XMotion::Release\n&quot;);
    METHOD_PROLOGUE(CSpaceship, Motion) // makes pThis
    return pThis-&gt;ExternalRelease(); // delegate to CSimulatedCmdTarget
}

DWORD CSpaceship::XMotion::AddRef() {
    TRACE(&quot;Entering CSpaceship::XMotion::AddRef\n&quot;);
    METHOD_PROLOGUE(CSpaceship, Motion) // makes pThis
    return pThis-&gt;ExternalAddRef(); // delegate to CSimulatedCmdTarget
}

void CSpaceship::XMotion::Fly() {
    TRACE(&quot;Entering CSpaceship::XMotion::Fly\n&quot;);
    METHOD_PROLOGUE(CSpaceship, Motion) // makes pThis
    TRACE(&quot;this = %p, pThis = %p\n&quot;, this, pThis);
    TRACE(&quot;m_nPosition = %d\n&quot;, pThis-&gt;m_nPosition);
    TRACE(&quot;m_nAcceleration = %d\n&quot;, pThis-&gt;m_nAcceleration);
}

int&amp; CSpaceship::XMotion::GetPosition() {
    TRACE(&quot;Entering CSpaceship::XMotion::GetPosition\n&quot;);
    METHOD_PROLOGUE(CSpaceship, Motion) // makes pThis
    TRACE(&quot;this = %p, pThis = %p\n&quot;, this, pThis);
    TRACE(&quot;m_nPosition = %d\n&quot;, pThis-&gt;m_nPosition);
    TRACE(&quot;m_nAcceleration = %d\n&quot;, pThis-&gt;m_nAcceleration);
    return pThis-&gt;m_nPosition;
}

BOOL CSpaceship::XVisual::QueryInterface(int nIid, void** ppvObj) {
    TRACE(&quot;Entering CSpaceship::XVisual::QueryInterface--nIid =  \
           %d\n&quot;, nIid);
    METHOD_PROLOGUE(CSpaceship, Visual) // makes pThis
    return pThis-&gt;ExternalQueryInterface(nIid, ppvObj); // delegate to
                                                        //  CSpaceship
}

DWORD CSpaceship::XVisual::Release() {
    TRACE(&quot;Entering CSpaceship::XVisual::Release\n&quot;);
    METHOD_PROLOGUE(CSpaceship, Visual) // makes pThis
    return pThis-&gt;ExternalRelease(); // delegate to CSimulatedCmdTarget
}

DWORD CSpaceship::XVisual::AddRef() {
    TRACE(&quot;Entering CSpaceship::XVisual::AddRef\n&quot;);
    METHOD_PROLOGUE(CSpaceship, Visual) // makes pThis
    return pThis-&gt;ExternalAddRef(); // delegate to CSimulatedCmdTarget
}

void CSpaceship::XVisual::Display() {
    TRACE(&quot;Entering CSpaceship::XVisual::Display\n&quot;);
    METHOD_PROLOGUE(CSpaceship, Visual) // makes pThis
    TRACE(&quot;this = %p, pThis = %p\n&quot;, this, pThis);
    TRACE(&quot;m_nPosition = %d\n&quot;, pThis-&gt;m_nPosition);
    TRACE(&quot;m_nColor = %d\n&quot;, pThis-&gt;m_nColor);
}

//----------simulates COM component -----------------------------------
// In real COM, this would be DllGetClassObject, which would be called
//  whenever a client called CoGetClassObject 

BOOL GetClassObject(int nClsid, int nIid, void** ppvObj)
{
    ASSERT(nClsid == CLSID_CSpaceship);
    ASSERT((nIid == IID_IUnknown) || (nIid == IID_IClassFactory));
    return g_factory.ExternalQueryInterface(nIid, ppvObj);
    // Refcount is 2, which prevents accidental deletion
}
</pre>
</TD></TR></TABLE>
<P><B>Figure 24-3.</B> <I>The Spaceship.cpp file.</I>



<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>CLIENT.CPP</B>
<P><pre>
#include &lt;stdio.h&gt;
#include &lt;stddef.h&gt; // for offsetof in METHOD_PROLOGUE
#include &lt;assert.h&gt;
#include &quot;interface.h&quot;


//----------main program-----------------------------------------------
int main() // simulates OLE client program
{
    TRACE(&quot;Entering client main\n&quot;);
    IUnknown* pUnk; // If you declare these void*, you lose type-safety
    IMotion* pMot;
    IVisual* pVis;
    IClassFactory* pClf; 
    
    GetClassObject(CLSID_CSpaceship, IID_IClassFactory,
                  (void**) &amp;pClf); 

    pClf-&gt;CreateInstance(IID_IUnknown, (void**) &amp;pUnk);
    pUnk-&gt;QueryInterface(IID_IMotion, (void**) &amp;pMot); // All three
    pMot-&gt;QueryInterface(IID_IVisual, (void**) &amp;pVis); //  pointers
                                                       //  should work

    TRACE(&quot;main: pUnk = %p, pMot = %p, pDis = %p\n&quot;, pUnk, pMot, pVis);
    
    // Test all the interface virtual functions
    pMot-&gt;Fly();
    int nPos = pMot-&gt;GetPosition();
    TRACE(&quot;nPos = %d\n&quot;, nPos);
    pVis-&gt;Display();

    pClf-&gt;Release();
    pUnk-&gt;Release();
    pMot-&gt;Release();
    pVis-&gt;Release();
    return 0;
}
</pre>
</TD></TR></TABLE>
<P><B>Figure 24-4.</B> <I>The Client.cpp file.</I>


</BODY>
</HTML>



