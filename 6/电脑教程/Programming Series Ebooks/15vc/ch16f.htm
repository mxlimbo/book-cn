<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Diagnostic Dumping</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="319"><H1>Diagnostic Dumping</H1></A><P>The MFC library gives you some useful tools for diagnostic dumping. You enable these tools when you select the Debug target. When you select the Win32 Release target, diagnostic dumping is disabled and the diagnostic code is not linked to your program. All diagnostic output goes to the Debug view in the debugger's Output window.
<P>
<DIV CLASS=tip>
<BLOCKQUOTE>
<IMG SRC="tip.jpg" width=123 height=18 BORDER="0"><P>
To clear diagnostic output from the debugger's Output window, position the cursor in the Output window and click the right mouse button. Then choose Clear from the pop-up menu.
</BLOCKQUOTE></DIV>
<P>
<A NAME="320"><H2>The <I>TRACE</I> Macro</H2></A><P>You've seen the <I>TRACE</I> macro used throughout the preceding examples in this book. <I>TRACE</I> statements are active whenever the constant <I>_DEBUG</I> is defined (when you select the Debug target and when the <I>afxTraceEnabled</I> variable is set to <I>TRUE</I>). <I>TRACE</I> statements work like C language 
<I>printf</I> statements, but they're completely disabled in the release version of the program. Here's a typical <I>TRACE</I> statement:
<P><PRE>int nCount = 9;
CString strDesc(&quot;total&quot;);
TRACE(&quot;Count = %d, Description = %s\n&quot;, nCount, strDesc);</PRE>
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
The <I>TRACE</I> macro takes a variable number of parameters and is thus easy to use. If you look at the MFC source code, you won't see <I>TRACE</I> macros but rather <I>TRACE0</I>, <I>TRACE1</I>, <I>TRACE2</I>, and <I>TRACE3</I> macros. These macros take 0, 1, 2, and 3 parameters, respectively, and are leftovers from the 16-bit environment, where it was necessary to conserve space in the data segment.
</BLOCKQUOTE></DIV>
<A NAME="321"><H2>The <I>afxDump</I> Object</H2></A><P>An alternative to the <I>TRACE</I> statement is more compatible with the C++ language. The MFC <I>afxDump</I> object accepts program variables with a syntax similar to that of <I>cout</I>, the C++ output stream object. You don't need complex formatting 
strings; instead, overloaded operators control the output format. The <I>afxDump</I> output goes to the same destination as the <I>TRACE</I> output, but the <I>afxDump</I> object is defined only in the Debug version of the MFC library. Here is a typical stream-oriented diagnostic statement that produces the same output as the <I>TRACE</I> statement above:
<PRE>int nCount = 9;
CString strDesc(&quot;total&quot;);
#ifdef _DEBUG
    afxDump &lt;&lt; &quot;Count = &quot; &lt;&lt; nCount 
            &lt;&lt; &quot;, Description = &quot; &lt;&lt; strDesc &lt;&lt; &quot;\n&quot;;
#endif // _DEBUG</PRE>
<P>Although both <I>afxDump</I> and <I>cout</I> use the same insertion operator 
(&lt;&lt;), they don't share any code. The <I>cout</I> object is part of the Microsoft Visual C++ iostream library, and <I>afxDump</I> is part of the MFC library. Don't assume that any of the <I>cout</I> formatting capability is available through <I>afxDump</I>.
<P>Classes that aren't derived from <I>CObject</I>, such as <I>CString</I>, <I>CTime</I>, and <I>CRect</I>, contain their own overloaded insertion operators for <I>CDumpContext</I> objects. The <I>CDumpContext</I> class, of which <I>afxDump</I> is an instance, includes the overloaded insertion operators for the native C++ data types (<I>int</I>, <I>double</I>, <I>char*</I>, and so on). The <I>CDumpContext</I> class also contains insertion 
operators for <I>CObject</I> references and pointers, and that's where things get interesting.
<A NAME="322"><H2>The Dump Context and the <I>CObject</I> Class</H2></A><P>If the <I>CDumpContext</I> insertion operator accepts <I>CObject</I> pointers and references, it must also accept pointers and references to derived classes. Consider a trivial class, <I>CAction</I>, that is derived from <I>CObject</I>, as shown here:
<PRE>class CAction : public CObject
{
public:
    int m_nTime;
};</PRE>
<P>What happens when the following statement executes?
<P><PRE>#ifdef _DEBUG
    afxDump &lt;&lt; action; // action is an object of class CAction
#endif // _DEBUG</PRE>
<P>The virtual <I>CObject::Dump</I> function gets called. If you haven't 
overridden <I>Dump</I> for <I>CAction</I>, you don't get much except for the address of the object. If you have overridden <I>Dump</I>, however, you can get the internal state of your object. Here's a <I>CAction::Dump</I> function:
<PRE>#ifdef _DEBUG
void CAction::Dump(CDumpContext&amp; dc) const
{
    CObject::Dump(dc); // Always call base class function
    dc &lt;&lt; &quot;time = &quot; &lt;&lt; 
m_nTime &lt;&lt; &quot;\n&quot;;
}
#endif // _DEBUG</PRE>
<P>The base class (<I>CObject</I>) <I>Dump</I> function prints a line such as this:
<P><PRE>a CObject at $4115D4</PRE>
<P>If you have called the <I>DECLARE_DYNAMIC</I> macro in your <I>CAction</I> class definition and the <I>IMPLEMENT_DYNAMIC</I> macro in your <I>CAction</I> declaration, you will see the name of the class in your dump
<P><PRE>a CAction at $4115D4</PRE>
<P>even if your dump statement looks like this:
<P><PRE>#ifdef _DEBUG
    afxDump &lt;&lt; (CObject&amp;) action;
#endif // _DEBUG</PRE>
<P>The two macros work together to include the MFC library runtime class code in your derived <I>CObject</I> class. With this code in place, your program can 
determine an object's class name at runtime (for the dump, for example) and it can obtain class hierarchy information.
<P>
<DIV CLASS=note>
<BLOCKQUOTE><IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
The (<I>DECLARE_SERIAL</I>, 
<I>IMPLEMENT_SERIAL</I>) and 
(<I>DECLARE_DYNCREATE</I>, 
<I>IMPLEMENT_DYNCREATE</I>) macro pairs provide the same runtime class features as those provided by 
the (<I>DECLARE_DYNAMIC</I>, 
<I>IMPLEMENT_DYNAMIC</I>) macro pair.
</BLOCKQUOTE></DIV>
<A NAME="323"><H2>Automatic Dump of Undeleted Objects</H2></A><P>With the Debug target selected, the application framework dumps all objects that are undeleted when your program exits. This dump is a useful diagnostic aid, but if you want it to be really useful, you must be sure to delete <U>all</U> your objects, even the ones that would normally disappear after the exit. This object cleanup is good programming discipline.
<DIV CLASS=note>
<BLOCKQUOTE><IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
The code that adds debug information to allocated memory blocks is now in the Debug version of the CRT (C runtime) library rather than in the MFC library. If you choose to dynamically link MFC, the MSVCRTD DLL is loaded along with the necessary MFC DLLs. When you add the line
<P><PRE>#define new DEBUG_NEW</PRE>
<P>at the top of a CPP file, the CRT library lists the filename and line number at which the allocations were made. AppWizard puts this line at the top of all the CPP files it generates.
</BLOCKQUOTE></DIV>
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<B>Window Subclassing for Enhanced Data-Entry Control</B><P>
What if you want an edit control (in a dialog or a form view) that accepts only numeric characters? That's easy. You just set the Number style in the control's property sheet. If, however, you want to exclude numeric characters or change the case of alphabetic characters, you must do some programming.
<P>The MFC library provides a convenient way to change the behavior of any standard control, including the edit control. Actually, there are several ways. You can derive your own classes from <I>CEdit</I>, <I>CListBox</I>, and so forth (with their own message handler functions) and then create control objects at runtime. Or you can register a special window class, as a Win32 programmer would do, and integrate it into the project's resource file with a text editor. Neither of these methods, however, allows you to use the dialog editor to position controls in the dialog resource.
<P>The easy way to modify a control's behavior is to use the MFC library's <U>window</U> <U>subclassing</U> feature. You use the dialog editor to position a normal control in a dialog resource, and then you write a new C++ class that contains message handlers for the events that you want to handle yourself. Here are the steps for subclassing an edit control:
<OL>
<LI>With the dialog editor, position an edit control in your dialog resource. Assume that it has the child window ID <I>IDC_EDIT1.</I>
<P>
<LI>Write a new class&#151;for example, <I>CNonNumericEdit</I>&#151;derived from <I>CEdit</I>. Map the WM_CHAR message and write a handler like this:
<P><PRE>void CNonNumericEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if (!isdigit(nChar)) {
        CEdit::OnChar(nChar, nRepCnt, nFlags);
    }
}</PRE><P>
<LI>In your derived dialog or form view class header, declare a data member of class <I>CNonNumericEdit</I> in this way:
<P><PRE>private:
    CNonNumericEdit m_nonNumericEdit;</PRE>
<P>
<LI>If you're working with a dialog class, add the following line to your <I>OnInitDialog</I> override function:

<P><PRE>m_nonNumericEdit.SubclassDlgItem(IDC_EDIT1, this);</PRE>
<LI>   If you're working with a form view class, add the following 
code to your <I>OnInitialUpdate</I> override function:
<PRE><P>if (m_nonNumericEdit.m_hWnd == NULL) {
    m_nonNumericEdit.SubclassDlgItem(IDC_EDIT1, this);
}</PRE>
<P>
</OL>
<P>The<I> CWnd::SubclassDlgItem</I> member function ensures that all messages are routed through the application framework's message dispatch system before being sent to the control's built-in window procedure. This technique is called dynamic <U>subclassing</U> and is explained in more detail in Technical Note 
#14 in the online documentation.
<P>The code in the preceding steps only accepts or rejects a character. If you want to change the value of a character, your handler must call <I>CWnd::DefWindowProc</I>, which bypasses some MFC logic that stores parameter values in thread object data members. Here's a sample handler that converts lowercase characters to uppercase:
<PRE>void CUpperEdit::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    if (islower(nChar)) {
        nChar = toupper(nChar);
    }
    DefWindowProc(WM_CHAR, (WPARAM) nChar,
                  (LPARAM) (nRepCnt | (nFlags &lt;&lt; 16)));
}
</PRE>
<P>You can also use window subclassing to handle reflected messages, which were mentioned in <A HREF="ch06a.htm">Chapter 6</A>. If an MFC window class doesn't map a message from one of its child controls, the framework reflects the message back to the control. Technical Note #62 in the online documentation explains the details.
<P>If you need an edit control with a yellow background, for example, you can derive a class <I>CYellowEdit</I> from <I>CEdit</I> and use ClassWizard to map the =WM_CTLCOLOR message in <I>CYellowEdit</I>. (ClassWizard lists the message name with an equal sign in front to indicate that it is reflected.) The handler code, shown below, is substantially the same as the nonreflected WM_CTLCOLOR handler. (Member variable <I>m_hYellowBrush</I> is defined in the control class's constructor.)
<PRE>HBRUSH CYellowEdit::CtlColor(CDC* pDC, UINT nCtlColor)
{
    pDC-&gt;SetBkColor(RGB(255, 255, 0)); // yellow
    return m_hYellowBrush;
}
</PRE>
<P>
</BLOCKQUOTE></DIV>
</BODY>
</HTML>



