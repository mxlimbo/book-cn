<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>ActiveX Controls vs. Ordinary Windows Controls</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="171"><H1>ActiveX Controls vs. Ordinary Windows Controls</H1></A><P>An ActiveX control is a software module that plugs into your C++ program the same way a Windows control does. At least that's the way it seems at first. 
It's worthwhile here to analyze the similarities and differences between 
ActiveX controls and the controls you already know.
<A NAME="172"><H2>Ordinary Controls&#151;A Frame of Reference</H2></A><P>In <A HREF="ch06a.htm">Chapter 6</A>, you used ordinary Windows controls such as the edit control and the list box, and you saw the Windows common controls that work in much the same way. These controls are all child windows that you use most often in dialogs, and they are represented by MFC classes such as <I>CEdit</I> and <I>CTreeCtrl</I>. The client program is always responsible for the creation of the control's child window.
<P>Ordinary controls send notification command messages (standard Windows messages), such as BN_CLICKED, to the dialog. If you want to perform an action on the control, you call a C++ control class member function, which sends a Windows message to the control. The controls are all windows in their own right. All the MFC control classes are derived from <I>CWnd</I>, so if you want to get the text from an edit control, you call <I>CWnd::GetWindowText</I>. But even that function works by sending a message to the control.
<P>Windows controls are an integral part of Windows, even though the Windows common controls are in a separate DLL. Another species of ordinary control, the so-called <U>custom</U> <U>control</U>, is a programmer-created control that 
acts as an ordinary control in that it sends WM_COMMAND notifications to its parent window and receives user-defined messages. You'll see one of these in <A HREF="ch22a.htm">Chapter 22</A>.
<A NAME="173"><H2>How ActiveX Controls Are Similar to Ordinary Controls</H2></A>
<P>You can consider an ActiveX control to be a child window, just as an 
ordinary control is. If you want to include an ActiveX control in a dialog, you use the dialog editor to place it there, and the identifier for the control turns up in the resource template. If you're creating an ActiveX control on the fly, you call a <I>Create</I> member function for a class that represents the control, usually in the WM_CREATE handler for the parent window. When you want to manipulate an ActiveX control, you call a C++ member function, just as you do for a Windows control. The window that contains a control is called a 
<U>container</U>.
<H2>How ActiveX Controls Are Different from Ordinary Controls&#151;Properties and Methods</H2>
<P>The most prominent ActiveX Controls features are properties and methods. Those C++ member functions that you call to manipulate a control instance all revolve around properties and methods. Properties have symbolic names that are matched to integer indexes. For each property, the control designer assigns a property name, such as BackColor or GridCellEffect, and a property type, such as string, integer, or double. There's even a picture type for bitmaps and icons. The client program can set an individual ActiveX control property by 
specifying the property's integer index and its value. The client can get a property by specifying the index and accepting the appropriate return value. In certain cases, ClassWizard lets you define data members in your client window class that are associated with the properties of the controls the client class contains. The generated Dialog Data Exchange (DDX) code exchanges data between the control properties and the client class data members.
<P>ActiveX Controls methods are like functions. A method has a symbolic name, a set of parameters, and a return value. You call a method by calling a C++ member function of the class that represents the control. A control designer can define any needed methods, such as <I>PreviousYear</I>, <I>LowerControlRods</I>, and so forth.
<P>An ActiveX control doesn't send WM_ notification messages to its container the way ordinary controls do; instead, it &quot;fires events.&quot; An event has a symbolic name and can have an arbitrary sequence of 
parameters&#151;it's really a container function that the control calls. Like ordinary control notification messages, events don't return a value to the ActiveX control. Examples of events are Click, KeyDown, and NewMonth. Events are mapped in your client class just as control notification messages are.
<P>In the MFC world, ActiveX controls act just like child windows, but there's a significant layer of code between the container window and the control window. In fact, the control might not even have a window. When you call <I>Create</I>, the control's window isn't created directly; instead, the control code is loaded and given the command for &quot;in-place activation.&quot; The ActiveX control then creates its own window, which MFC lets you access through a <I>CWnd</I> pointer. It's not a good idea for the client to use the control's <I>hWnd</I> directly, however.
<P>A DLL is used to store one or more ActiveX controls, but the DLL often has an OCX filename extension instead of a DLL extension. Your container program loads the DLLs when it needs them, using sophisticated COM techniques that rely on the Windows Registry. For the time being, simply accept the fact that once you specify an ActiveX control at design time, it will be loaded for you at runtime. Obviously, when you ship a program that requires special ActiveX controls, you'll have to include the OCX files and an appropriate setup program.
</BODY>
</HTML>



