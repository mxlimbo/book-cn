<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Going Further with DIBs</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="230"><H1>Going Further with DIBs</H1></A>
<P>Each new version of Windows offers more DIB programming choices. Both Windows 95 and Microsoft Windows NT 4.0 provide the <I>LoadImage</I> and <I>DrawDibDraw</I> functions, which are useful alternatives to the DIB functions already described. Experiment with these functions to see if they work well in your applications.
<A NAME="231"><H2>The <I>LoadImage</I> Function</H2></A>
<P>The <I>LoadImage</I> function can read a bitmap directly from a disk file, returning a DIB section handle. It can even process OS/2 format DIBs. Suppose 
you wanted to add an <I>ImageLoad</I> member function to <I>CDib</I> that would work like <I>ReadSection</I>. This is the code you would add to cdib.cpp:
<P><PRE>BOOL CDib::ImageLoad(const char* lpszPathName, CDC* pDC)
{
    Empty();
    m_hBitmap = (HBITMAP) ::LoadImage(NULL, lpszPathName, 
        IMAGE_BITMAP, 0, 0, 
        LR_LOADFROMFILE | LR_CREATEDIBSECTION | LR_DEFAULTSIZE);
    DIBSECTION ds;
    VERIFY(::GetObject(m_hBitmap, sizeof(ds), &amp;ds) == sizeof(ds));
    // Allocate memory for BITMAPINFOHEADER
    //  and biggest possible color table
    m_lpBMIH = (LPBITMAPINFOHEADER) new 
        char[sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD)];
    memcpy(m_lpBMIH, &amp;ds.dsBmih, sizeof(BITMAPINFOHEADER));
    TRACE(&quot;CDib::LoadImage, biClrUsed = %d, biClrImportant = %d\n&quot;,
        m_lpBMIH-&gt;biClrUsed, m_lpBMIH-&gt;biClrImportant);
    ComputeMetrics(); // sets m_lpvColorTable
    m_nBmihAlloc = crtAlloc;
    m_lpImage = (LPBYTE) ds.dsBm.bmBits;
    m_nImageAlloc = noAlloc;
    // Retrieve the DIB section's color table
    //  and make a palette from it
    CDC memdc;
    memdc.CreateCompatibleDC(pDC);
    ::SelectObject(memdc.GetSafeHdc(), m_hBitmap);
    UINT nColors = ::GetDIBColorTable(memdc.GetSafeHdc(), 0, 256, 
        (RGBQUAD*) m_lpvColorTable);
    if (nColors != 0) {
        ComputePaletteSize(m_lpBMIH-&gt;biBitCount);
        MakePalette();
    }
    // memdc deleted and bitmap deselected
    return TRUE;
}</PRE>
<P>Note that this function extracts and copies the <I>BITMAPINFOHEADER</I> structure and sets the values of the <I>CDib</I> pointer data members. You must do some work to extract the palette from the DIB section, but the Win32 <I>GetDIBColorTable</I> function gets you started. It's interesting that <I>GetDIBColorTable</I> can't tell you how many palette entries a particular DIB uses. If the DIB uses only 60 entries, for example, <I>GetDIBColorTable</I> generates a 256-entry color table with the last 196 entries set to 0.
<A NAME="232"><H2>The <I>DrawDibDraw</I> Function</H2></A>
<P>Windows includes the Video for Windows (VFW) component, which is supported by Visual C++. The VFW <I>DrawDibDraw</I> function is an alternative to 
<I>StretchDIBits</I>. One advantage of <I>DrawDibDraw</I> is its ability to use dithered colors. Another is its increased speed in drawing a DIB with a bpp value that does not match the current video mode. The main disadvantage is the need to link the VFW code into your process at runtime.
<P>Shown below is a <I>DrawDib</I> member function for the <I>CDib</I> class that calls <I>DrawDibDraw</I>:
<P><PRE>BOOL CDib::DrawDib(CDC* pDC, CPoint origin, CSize size)
{
    if (m_lpBMIH == NULL) return FALSE;
    if (m_hPalette != NULL) {
        ::SelectPalette(pDC-&gt;GetSafeHdc(), m_hPalette, TRUE);
    }
    HDRAWDIB hdd = ::DrawDibOpen();
    CRect rect(origin, size);
    pDC-&gt;LPtoDP(rect); // Convert DIB's rectangle
                       //  to MM_TEXT coordinates
    rect -= pDC-&gt;GetViewportOrg();
    int nMapModeOld = pDC-&gt;SetMapMode(MM_TEXT);
    ::DrawDibDraw(hdd, pDC-&gt;GetSafeHdc(), rect.left, rect.top,
        rect.Width(), rect.Height(), m_lpBMIH, m_lpImage, 0, 0,
        m_lpBMIH-&gt;biWidth, m_lpBMIH-&gt;biHeight, 0);
    pDC-&gt;SetMapMode(nMapModeOld);
    VERIFY(::DrawDibClose(hdd));
    return TRUE;
}</PRE>
Note that <I>DrawDibDraw</I> needs <I>MM_TEXT</I> coordinates and the <I>MM_TEXT</I> mapping mode. Thus, logical coordinates must be converted not to device coordinates but to pixels with the origin at the top left of the scrolling window.
<P>To use <I>DrawDibDraw</I>, your program needs an <I>#include&lt;vfw.h&gt;</I> statement, and you must add vfw32.lib to the list of linker input files. <I>DrawDibDraw</I> might assume the bitmap it draws is in read/write memory, a fact to keep in mind if you map the memory to the BMP file.
</BODY>
</HTML>



