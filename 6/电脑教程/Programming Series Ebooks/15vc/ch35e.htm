<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>A Practical ISAPI Server Extension -- ex35a.dll</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="939"><H1>A Practical ISAPI Server Extension&#151;ex35a.dll</H1></A><P>The weather map server isn't interesting enough to make into a real 
project. You'll probably find the EX35A example more to your taste. It's a real 
Internet commerce application&#151;a pizza-ordering program. Imagine a computer-controlled
pizza oven and a robot arm that selects frozen pizzas. 
(Microsoft Internet Explorer 17.0 is supposed to be able to deliver the hot pizzas 
directly from your clients' monitors, but in the meantime, you'll have to hire 
some delivery drivers.)
<A NAME="940"><H2>The First Step&#151;Getting the Order</H2></A><P>Junior sales trainees are constantly admonished to &quot;get the order.&quot; That's 
certainly necessary in any form of commerce, including the Internet. When 
the hungry customer hyperlinks to your site (by clicking on a picture of a pizza, 
of course), he or she simply downloads an HTML file that looks like this:
<P><PRE>&lt;html&gt;
&lt;head&gt;&lt;title&gt;Inside Visual C++ HTML Form 1&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;&lt;center&gt;Welcome to CyberPizza&lt;/center&gt;&lt;/h1&gt;
&lt;p&gt; Enter your order.
&lt;form action=&quot;scripts/ex35a.dll?ProcessPizzaForm&quot; method=POST&gt;
    &lt;p&gt; Your Name: &lt;input type=&quot;text&quot; name=&quot;name&quot; value=&quot;&quot;&gt;
    &lt;p&gt; Your Address: &lt;input type=&quot;text&quot; name=&quot;address&quot; value=&quot;&quot;&gt;
    &lt;p&gt; Number of Pies: &lt;input type=&quot;text&quot; name=&quot;quantity&quot; value=1&gt;
    &lt;p&gt;Pizza Size:
        &lt;menu&gt;
            &lt;li&gt;&lt;input type=&quot;radio&quot; name=&quot;size&quot; value=8&gt;8-inch
            &lt;li&gt;&lt;input type=&quot;radio&quot; name=&quot;size&quot; value=10&gt;10-inch
            &lt;li&gt;&lt;input type=&quot;radio&quot; name=&quot;size&quot; value=12 checked&gt;12-inch
            &lt;li&gt;&lt;input type=&quot;radio&quot; name=&quot;size&quot; value=14&gt;14-inch
        &lt;/menu&gt;
    &lt;p&gt; Toppings:
    &lt;p&gt;
        &lt;input type=&quot;checkbox&quot; name=&quot;top1&quot; value=&quot;Pepperoni&quot; checked&gt;
            Pepperoni
        &lt;input type=&quot;checkbox&quot; name=&quot;top2&quot; value=&quot;Onions&quot;&gt; Onions
        &lt;input type=&quot;checkbox&quot; name=&quot;top3&quot; value=&quot;Mushrooms&quot;&gt; Mushrooms
        &lt;input type=&quot;checkbox&quot; name=&quot;top4&quot; value=&quot;Sausage&quot;&gt; Sausage
    &lt;p&gt;
        &lt;em&gt;(you can select multiple toppings)&lt;/em&gt;
    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit Order Now&quot;&gt;&lt;input type=&quot;reset&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;&lt;/html&gt;</PRE>
<P>Figure 35-6 shows how the order form appears 
in the browser.
<P><A HREF="javascript:fullSize('f35og06x.htm')"> <img src="f35og06.jpg" width=404 height=503 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 35-6.</B> <I>The CyberPizza order form.</I>
<!-- /caption -->

<P>So far, no ISAPI DLL is involved. When the customer clicks the 
Submit Order Now button, the action begins. Here's what the server sees:
<P><PRE>POST scripts/ex35a.dll?ProcessPizzaForm HTTP/1.0
<I>(request headers)
(blank line)</I>
name=Walter+Sullivan&amp;address=Redmond%2C+WA&amp;quantity=2&amp;size=12&amp;top1=Pepperoni
    &amp;top3=Mushrooms</PRE>
<P>Looks like Walter Sullivan has ordered two 12-inch pepperoni and 
mushroom pizzas. The browser inserts a + sign in place of a space, the 
<I>%2C</I> is a comma, and the <I>&amp;</I> is the parameter separator. Now let's look at the parse map entries in ex35a.cpp:
<P><PRE>ON_PARSE_COMMAND(ProcessPizzaForm, CEx35aExtension,
    ITS_PSTR ITS_PSTR ITS_I4 ITS_PSTR ITS_PSTR ITS_PSTR ITS_PSTR ITS_PSTR)
ON_PARSE_COMMAND_PARAMS(&quot;name address quantity size top1=~ top2=~ top3=~ top4=~&quot;)</PRE>
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<B>Optional Parameters</B>
<P>When you write your parse map statements, you must understand 
the browser's rules for sending parameter values from a form. In the 
EX35A pizza form, the browser always sends parameters for text fields, 
even if the user enters no data. If the user left the Name field blank, 
for example, the browser would send 
<I>name=&amp;</I>. For check box fields, however, it's a different story. The browser sends the check box 
parameter value only if the user checks the box. The parameters associated 
with check boxes are thus defined as 
<U>optional</U> <U>parameters</U>.
<P>If your parse macro for parameters looked like this
<P><PRE>ON_PARSE_COMMAND_PARAMS(&quot;name address quantity size top1 top2 top3 top4&quot;)</PRE>
<P>there would be trouble if the customer didn't check all the 
toppings. The HTTP request would simply fail, and the customer would have 
to search for another pizza site. The =~ symbols in the ex35a.cpp 
code designate the last four parameters as optional, with default values ~. 
If the Toppings option is checked, the form transmits the value; 
otherwise, it transmits a ~ character, which the DLL can test for. 
Optional parameters must be listed last.
</BLOCKQUOTE></DIV>
<P>The DLL's <I>ProcessPizzaForm</I> function reads the parameter values 
and produces an HTML confirmation form, which it sends to the customer. 
Here is part of the function's code:
<P><PRE>        *pCtxt &lt;&lt; &quot;&lt;form action=\&quot;ex35a.dll?ConfirmOrder\&quot; method=POST&gt;&quot;;
        *pCtxt &lt;&lt; &quot;&lt;p&gt;&lt;input type=\&quot;hidden\&quot; name=\&quot;name\&quot; value=\&quot;&quot;;
        *pCtxt &lt;&lt; pstrName &lt;&lt; &quot;\&quot;&gt;&quot;; // xref to original order
        *pCtxt &lt;&lt; &quot;&lt;p&gt;&lt;input type=\&quot;submit\&quot; value=\&quot;Confirm and charge my credit card\&quot;&gt;&quot;;
        *pCtxt &lt;&lt; &quot;&lt;/form&gt;&quot;;
        // Store this order in a disk file or database, referenced by name
    }
    else {
        *pCtxt &lt;&lt; &quot;You forgot to enter name or address. Back up and try again. &quot;;
    }
    EndContent(pCtxt);</PRE>
<P>The resulting browser screen is shown in Figure 35-7.
<P><IMG SRC="f35og07.gif" width=368 height=348 BORDER="0"><P>
<!-- caption -->
<B>Figure 35-7.</B> <I>The pizza confirmation browser screen.</I>
<!-- /caption -->
<P>As you can see, we took a shortcut computing the price. To accept, 
the customer clicks the submit button named Confirm And Charge My Credit Card.
<A NAME="941"><H2>The Second Step&#151;Processing the Confirmation</H2></A><P>When the user clicks the Confirm And Charge My Credit Card button, 
the browser sends a second POST request to the server, specifying that the 
<I>CEx35aExtension::ConfirmOrder</I> function be called. But now you have to solve a 
big problem. Each HTTP connection (request/response) is independent of 
all others. How are you going to link the confirmation request with the 
original order? Although there are different ways to do this, the most common 
approach is to send some text back with the confirmation in a 
<U>hidden</U> <U>input</U> <U>tag</U>. When the confirmation parameter values come back, the server uses the hidden 
text to match the confirmation to the original order, which it has stored 
somewhere on its hard disk.
<P>In the EX35A example, the customer's name is used in the hidden 
field, although it might be safer to use some combination of the name, date, and 
time. Here's the HTML code that 
<I>CEx35aExtension::ProcessPizzaForm</I> sends to 
the customer as part of the confirmation form:
<P><PRE>&lt;input type=&quot;hidden&quot; name=&quot;name&quot; value=&quot;Walter Sullivan&quot;&gt;</PRE>
<P>Here's the code for the 
<I>CEx35aExtension::ConfirmOrder</I> function:
<P><PRE>void CEx35aExtension::ConfirmOrder(CHttpServerContext* pCtxt, 
    LPCTSTR pstrName)
{
    StartContent(pCtxt);
    WriteTitle(pCtxt);
    *pCtxt &lt;&lt; &quot;&lt;p&gt;Our courteous delivery person will arrive within 30 minutes. &quot;;
    *pCtxt &lt;&lt; &quot;&lt;p&gt;Thank you, &quot; &lt;&lt; pstrName &lt;&lt; &quot;, for using CyberPizza. &quot;;
    // Now retrieve the order from disk by name, and then make the pizza.
    //  Be prepared to delete the order after a while if the customer 
    //  doesn't confirm.
    m_cs.Lock(); // gotta be threadsafe
    long int nTotal = ++m_nTotalPizzaOrders;
    m_cs.Unlock();
    *pCtxt &lt;&lt; &quot;&lt;p&gt;Total pizza orders = &quot; &lt;&lt; nTotal;
    EndContent(pCtxt);
}</PRE>
<P>The customer's name comes back in the 
<I>pstrName</I> parameter, and that's what you use to retrieve the original order from disk. The function also keeps track of the total number of orders, using a critical section 
(<I>m_cs</I>) to ensure thread synchronization.
<A NAME="942"><H2>Building and Testing ex35a.dll</H2></A><P>If you have copied the code from the companion CD-ROM, your project 
is located in \vcpp32\ex35a. Building the project adds a DLL to the Debug 
subdirectory. You must copy this DLL to a directory that the server can find 
and copy PizzaForm.html also. You can use the scripts and wwwroot subdirec-
tories already under \Winnt\System32\inetsrv, or you can set up new virtual 
directories.
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
If you make changes to the EX35A DLL in the Visual 
C++ project, be sure to use Internet Service Manager (Figure 
35-1) to turn off the WWW service (because the old DLL stays loaded), copy 
the new DLL to the scripts directory, and then turn the WWW 
service on again. The revised DLL will be loaded as soon as the first 
client requests it.
</BLOCKQUOTE></DIV>
<P>If everything has been installed correctly, you should be able to 
load PizzaForm.html from the browser and then order some pizza. Enjoy!
<A NAME="943"><H2>Debugging the EX35A DLL</H2></A><P>The fact that IIS is a Windows NT service complicates debugging ISAPI 
DLLs. Services normally run as part of the operating system, controlled by the 
service manager database. They have their own window station, and they run on 
their own invisible desktop. This involves some of the murkier parts of Windows 
NT, and not much published information is available.
<P>However, you can use these steps to debug your EX35A DLL (or 
any ISAPI DLL):
<OL>
<LI>Use the Internet Service Manager to stop 
<U>all</U> IIS services.<P>
<LI>Choose Settings from the EX35A project Build menu, and in 
the Project Settings dialog, type in the data as shown.

<P><A HREF="javascript:fullSize('g35og01x.htm')"> <img src="g35og01.jpg" width=404 height=260 border=0 ALT = "Click to view at full size."> </A><P>

<LI>Start User Manager or User Manager For Domains 
(Administrative Tools menu). Choose User Rights from the Policies menu, 
check Show Advanced User Rights, select the right Act As Part Of 
 The Operating System, and add your user group as shown on the 
facing page.<P>
<LI>Repeat step 3 to set the right for Generate Security Audits.<P>
<LI>Log back on to Windows NT to activate the new permission. 
(Don't forget this step.)<P>
<LI>Make sure that the current EX35A DLL file has been copied 
into the scripts directory.<P>
<LI>Start debugging. You can set breakpoints, step through code, 
and see the output of <I>TRACE</I> messages.<P>

<P><IMG SRC="g35og02.gif" width=353 height=241 BORDER="0"><P>
</OL>
</BODY>
</HTML>



