<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Modeless Dialogs</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="158"><H1>Modeless Dialogs</H1></A><P>In the Microsoft Foundation Class (MFC) Library version 6.0, modal and 
modeless dialogs share the same base class, 
<I>CDialog</I>, and they both use a dialog 
resource that you can build with the dialog editor. If you're using a modeless 
dialog with a view, you'll need to know some specialized programming 
techniques.
<A NAME="159"><H2>Creating Modeless Dialogs</H2></A><P>For modal dialogs, you've already learned that you construct a dialog 
object using a <I>CDialog</I> constructor that takes a resource template ID as a 
parameter, and then you display the modal dialog window by calling the 
<I>DoModal</I> member function. The window ceases to exist as soon as 
<I>DoModal</I> returns. Thus, you can construct a modal dialog object on the stack, knowing that the dialog window has been destroyed by the time the C++ dialog object goes out of scope.
<P>Modeless dialogs are more complicated. You start by invoking the 
<I>CDialog</I> default constructor to construct the dialog object, but then to create the 
dialog window you need to call the 
<I>CDialog::Create</I> member function instead of 
<I>DoModal</I>. <I>Create</I> takes the resource ID as a parameter and returns 
immediately with the dialog window still on the screen. You must worry about exactly 
when to construct the dialog object, when to create the dialog window, when to 
destroy the dialog, and when to process user-entered data.
<P>Here's a summary of the differences between creating a modal dialog 
and a modeless dialog.
<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP">&nbsp;</TD><TD VALIGN="TOP"><B>Modal Dialog</B></TD><TD VALIGN="TOP"><B>Modeless Dialog</B></TD></TR>
<TR><TD VALIGN="TOP"><B>Constructor used</B></TD><TD VALIGN="TOP">Constructor with resource ID param</TD><TD VALIGN="TOP"> Default constructor (no params)</TD></TR>
<TR><TD VALIGN="TOP"><B>Function used to create window</B></TD><TD VALIGN="TOP"> <I>DoModal</I></TD><TD VALIGN="TOP"><I>Create</I> with resource ID param</TD></TR>
</TABLE>
<P>
<A NAME="160"><H2>User-Defined Messages</H2></A><P>Suppose you want the modeless dialog window to be destroyed when the 
user clicks the dialog's OK button. This presents a problem. How does the view 
know that the user has clicked the OK button? The dialog could call a view class 
member function directly, but that would &quot;marry&quot; the dialog to a particular view 
class. A better solution is for the dialog to send the view a user-defined message 
as the result of a call to the OK button message-handling function. When the 
view gets the message, it can destroy the dialog window (but not the object). 
This sets the stage for the creation of a new dialog.
<P>You have two options for sending Windows messages: the 
<I>CWnd::SendMessage</I> function or the 
<I>PostMessage</I> function. The former causes an immediate 
call to the message-handling function, and the latter posts a message in the 
Windows message queue. Because there's a slight delay with the 
<I>PostMessage</I> option, it's reasonable to expect that the handler function has returned by the time the view gets the message.
<A NAME="161"><H2>Dialog Ownership</H2></A><P>Now suppose you've accepted the dialog default pop-up style, which means 
that the dialog isn't confined to the view's client area. As far as Windows is 
concerned, the dialog's &quot;owner&quot; is the application's main frame window (introduced 
in <A HREF="ch13a.htm">Chapter 13</A>), not the view. You need to know the dialog's view to send the 
view a message. Therefore, your dialog class must track its own view through a 
data member that the constructor sets. The 
<I>CDialog</I> constructor's <I>pParent</I> 
parameter doesn't have any effect here, so don't bother using it.
<A NAME="162"><H2>A Modeless Dialog Example&#151;EX07A</H2></A><P>We could convert the <A HREF="ch06a.htm">Chapter 6</A> monster dialog to a modeless dialog, but 
starting from scratch with a simpler dialog is easier. Example EX07A uses a dialog 
with one edit control, an OK button, and a Cancel button. As in the <A HREF="ch06a.htm">Chapter 6</A> 
example, pressing the left mouse button while the mouse cursor is inside the view 
window brings up the dialog, but now we have the option of destroying it in response 
to another event&#151;pressing the <U>right</U> mouse button when the mouse cursor is 
inside the view window. We'll allow only one open dialog at a time, so we must be 
sure that a second left button press doesn't bring up a duplicate dialog.
<P>To summarize the upcoming steps, the EX07A view class has a 
single associated dialog object that is constructed on the heap when the view is 
constructed. The dialog window is created and destroyed in response to user 
actions, but the dialog object is not destroyed until the application terminates.
<P>Here are the steps to create the EX07A example:<P>
<OL>
<B><LI>Run AppWizard to produce \vcpp32\ex07a\ex07a.</B> 
Accept all the defaults but two: select Single Document and deselect Printing And 
Print Preview. The options and the default class names are shown here.<P>
</OL>
<P><img src="G07OG01x.gif" width=413 height=418 border=0> <P>
<OL START="2">
<B><LI>Use the dialog editor to create a dialog 
resource.</B> Choose Resource from Visual C++'s Insert menu, and then select Dialog. The dialog 
editor assigns the ID <I>IDD_DIALOG1</I> to the new dialog. Change the dialog 
caption to <I>Modeless Dialog</I>. Accept the default OK and Cancel 
buttons with IDs <I>IDOK</I> and <I>IDCANCEL</I>, and then add a static text control 
and an edit control with the default ID 
<I>IDC_EDIT1</I>. Change the static text control's caption to 
<I>Edit 1</I>. Here is the completed dialog.<P>
</OL>
<P><IMG SRC="G07OG02.GIF" width=285 height=179 BORDER=0><P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
Be sure to select the dialog's Visible property.
</BLOCKQUOTE></DIV>
<P>
<OL START="3">
<B><LI>Use ClassWizard to create the 
<I>CEx07aDialog</I> class.</B> Choose ClassWizard from 
Microsoft Visual C++'s View menu. Fill in the New 
Class dialog as shown here, and then click the OK button.</OL>
<P><IMG SRC="G07OG03.GIF" width=404 height=366 BORDER=0><P>
<OL>
<P>Add the message-handling functions shown next. To add a 
message-handling function, click on an object ID, click on a message, and then 
click the Add Function button. The Add Member Function dialog box 
appears. Edit the function name if necessary, and click the OK button.<P>
</OL><P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>Object ID</B></TD><TD VALIGN="TOP"><B>Message</B></TD><TD VALIGN="TOP"><B>Member Function</B></TD></TR>
<TR><TD VALIGN="TOP"><I>IDCANCEL</I></TD><TD VALIGN="TOP">BN_CLICKED</TD><TD VALIGN="TOP"><I>OnCancel</I></TD></TR>
<TR><TD VALIGN="TOP"><I>IDOK</I></TD><TD VALIGN="TOP">BN_CLICKED</TD><TD VALIGN="TOP"><I>OnOK</I></TD></TR>
</TABLE>
<P>
<OL START="4">
<B><LI>Add a variable to the<I> CEx07aDialog 
</I>class.</B> While in ClassWizard, click on the Member Variables tab, choose the 
<I>IDC_EDIT1</I> control, and then click the Add Variable button to add the 
<I>CString</I> variable <I>m_strEdit1</I>.
<P><B><LI>Edit ex07aDialog.h to add a view pointer and function 
prototypes.</B> Type in the following boldface code in the 
<I>CEx07aDialog</I> class declaration:<P>
<PRE><B>private:
    CView* m_pView;</B>
</PRE><P>Also, add the function prototypes as follows:<P>
<PRE><B>public:
    CEx07aDialog(CView* pView);
    BOOL Create();</B>
</PRE>
<P>
</OL>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
Using the <I>CView</I> class rather than the 
<I>CEx07aView</I> class allows the dialog class to be used with any view class.
</BLOCKQUOTE></DIV>
<OL START="6">
<B><LI>Edit ex07aDialog.h to define the WM_GOODBYE message 
ID.</B> Add the following line of code:<P>
<PRE><B>#define WM_GOODBYE     WM_USER + 5</B></PRE>
<P>The Windows constant WM_USER is the first message ID available 
for user-defined messages. The application framework uses a few of these 
messages, so we'll skip over the first five messages.<P>
</OL>
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
Visual C++ maintains a list of symbol definitions in your project's resource.h file, but the resource editor does not understand constants based on other constants. Don't manually add WM_GOODBYE to resource.h because Visual C++ might delete it.
</BLOCKQUOTE></DIV>
<P>
<OL START="7">
<B><LI>Add the modeless constructor in the file ex07aDialog.cpp.</B> You could modify the existing <I>CEx07aDialog</I> constructor, but if you add a separate one, the dialog class can serve for both modal and modeless dialogs. Add the lines shown below.
<P><PRE><B>CEx07aDialog::CEx07aDialog(CView* pView)  // modeless constructor
{
    m_pView = pView;
}</B>
</PRE><P>You should also add the following line to the AppWizard-generated 
modal constructor:
<P><PRE><B>m_pView = NULL;</B></PRE>
<P>The C++ compiler is clever enough to distinguish between the modeless constructor <I>CEx07aDialog(CView*)</I> and the modal constructor <I>CEx07aDialog(CWnd*)</I>. If the compiler sees an argument of class 
<I>CView</I> or a derived <I>CView</I> class, it generates a call to the modeless constructor. If it sees an argument of class <I>CWnd</I> or another derived <I>CWnd</I> class, it generates a call to the modal constructor.
<P><B><LI>Add the <I>Create</I> function in ex07aDialog.cpp.</B> This derived dialog class <I>Create</I> function calls the base class function with the dialog resource ID as a parameter. Add the following lines:
<P><PRE><B>BOOL CEx07aDialog::Create()
{
    return CDialog::Create(CEx07aDialog::IDD);
}</B>
</PRE>
</OL>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
<I>Create</I> is not a virtual function. You could have chosen a different name if you had wanted to.
</BLOCKQUOTE></DIV>
<OL START="9">
<B><LI>Edit the <I>OnOK</I> and <I>OnCancel</I> functions in ex07aDialog.cpp.</B> These virtual functions generated by ClassWizard are called in response to dialog button clicks. Add the following boldface code:<P>
<PRE>void CEx07aDialog::OnCancel()  <B>// not really a message handler</B>
{
<B>    if (m_pView != NULL) {
        // modeless case -- do not call base class OnCancel
        m_pView-&gt;PostMessage(WM_GOODBYE, IDCANCEL);
    }
    else {
        CDialog::OnCancel(); // modal case
    }</B>
}

void CEx07aDialog::OnOK()      <B>// not really a message handler</B>
{
<B>    if (m_pView != NULL) {
        // modeless case -- do not call base class OnOK
        UpdateData(TRUE);
        m_pView-&gt;PostMessage(WM_GOODBYE, IDOK);
    }
    else {
        CDialog::OnOK(); // modal case
    }</B>
}
</PRE><P>If the dialog is being used as a modeless dialog, it sends the 
user-defined message WM<I>_</I>GOODBYE to the view. We'll worry about handling 
the message later.</OL>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
For a modeless dialog, be sure you do <U>not</U> call the <I>CDialog::OnOK</I> or <I>CDialog::OnCancel</I> function. This means you <U>must</U> override these virtual functions in your derived class; otherwise, using the Esc key, the Enter key, or a button click would result in a call to the base class functions, which call the Windows <I>EndDialog</I> function. <I>EndDialog</I> is appropriate only for modal dialogs. In a modeless dialog, you must call <I>DestroyWindow</I> instead, and if necessary, you must call <I>UpdateData</I> to transfer data from the dialog controls to the class data members.
</BLOCKQUOTE></DIV>
<P>
<OL START="10">
<B><LI>Edit the ex07aView.h header file.</B> You need a data member to hold the dialog pointer:
<P>
<PRE><B>private:
    CEx07aDialog* m_pDlg;</B>
</PRE><P>If you add the forward declaration
<P><PRE><B>class CEx07aDialog;</B></PRE>
<P>at the beginning of ex07aView.h, you won't have to include 
ex07aDialog.h in every module that includes ex07aView.h.
<P><B><LI>Modify the <I>CEx07aView </I>constructor and destructor in the 
file ex07aView.cpp.</B> The <I>CEx07aView</I> class has a data member 
<I>m_pDlg</I> that points to the view's <I>CEx07aDialog</I> object. The view constructor constructs the dialog object on the heap, and the view destructor deletes it. Add the following boldface code:<P>
<PRE>CEx07aView::CEx07aView()
{
<B>    m_pDlg = new CEx07aDialog(this);</B>
}

CEx07aView::~CEx07aView()
{
<B>    delete m_pDlg; // destroys window if not already destroyed</B>
}
</PRE>
<P><B><LI>Add code to the virtual <I>OnDraw</I> function in the ex07aView.cpp file.</B> The <I>CEx07aView OnDraw</I> function (whose skeleton was generated 
by AppWizard) should be coded as follows in order to prompt the user to press the mouse button:
<P><PRE>void CEx07aView::OnDraw(CDC* pDC)
{
<B>    pDC-&gt;TextOut(0, 0, &quot;Press the left mouse button here.&quot;);</B>
}
</PRE><P>
<B><LI>Use ClassWizard to add <I>CEx07aView</I> mouse message handlers.</B> 
Add handlers for the WM_LBUTTONDOWN and WM_RBUTTONDOWN messages. Now edit the code in file ex07aView.cpp as follows:
<P><PRE>void CEx07aView::OnLButtonDown(UINT nFlags, CPoint point)
{
<B>    // creates the dialog if not created already
    if (m_pDlg-&gt;GetSafeHwnd() == 0) {
        m_pDlg-&gt;Create(); // displays the dialog window
    }</B>
}

void CEx07aView::OnRButtonDown(UINT nFlags, CPoint point)
{
<B>    m_pDlg-&gt;DestroyWindow();
    // no problem if window was already destroyed</B>
}
</PRE><P>For most window types except main frame windows, the <I>DestroyWindow</I> function does not destroy the C++ object. We want this behavior because we'll take care of the dialog object's destruction in the view destructor.
<P><B><LI>Add the dialog header include statement to file ex07aView.cpp. </B>
While you're in ex07aView.cpp, add the following dialog header include statement after the view header include statement:<P>
<PRE>#include &quot;ex07aView.h&quot;
<B>#include &quot;ex07aDialog.h&quot;</B>
</PRE>
<P><B><LI>Add your own message code for the WM_GOODBYE message.</B> 
Because ClassWizard does not support user-defined messages, you must write the code yourself. This task makes you appreciate the work ClassWizard does for the other messages.
<P>
<UL>
<LI>In ex07aView.cpp, add the following line after the <I>BEGIN_MESSAGE_MAP</I> statement but outside the <I>AFX_MSG_MAP</I> brackets:<P>
<PRE><B>ON_MESSAGE(WM_GOODBYE, OnGoodbye)</B></PRE><P>
<LI>Also in ex07aView.cpp, add the message handler function itself:
<P><PRE><B>LRESULT CEx07aView::OnGoodbye(WPARAM wParam, LPARAM lParam)
{
    // message received in response to modeless dialog OK
    //  and Cancel buttons
    TRACE(&quot;CEx07aView::OnGoodbye %x, %lx\n&quot;, wParam, lParam);
    TRACE(&quot;Dialog edit1 contents = %s\n&quot;, 
          (const char*) m_pDlg-&gt;m_strEdit1);
    m_pDlg-&gt;DestroyWindow();
    return 0L;
}</B>
</PRE>
<P><LI>In ex07aView.h, add the following function prototype before the <I>DECLARE_MESSAGE_MAP()</I> statement but outside the <I>AFX_ MSG</I> brackets:<P>
<PRE><B>afx_msg LRESULT OnGoodbye(WPARAM wParam, LPARAM lParam);</B></PRE>
<P>
</UL>
<P>With Win32, the <I>wParam</I> and <I>lParam</I> parameters are the usual means of passing message data. In a mouse button down message, for example, 
the mouse <I>x</I> and <I>y</I> coordinates are packed into the <I>lParam</I> value. With the MFC library, message data is passed in more meaningful parameters. The mouse position is passed as a <I>CPoint</I> object. User-defined messages must use <I>wParam</I> and <I>lParam</I>, so you can use these two variables however you want. In this example, we've put the button ID in 
<I>wParam</I>.
<P><B><LI>Build and test the application.</B> Build and run EX07A. Press the 
left mouse button, and then press the right button. (Be sure the mouse cursor is outside the dialog window when you press the right mouse button.) Press the left mouse button again and enter some data, and then click the dialog's OK button. Does the view's <I>TRACE</I> statement correctly list the edit control's contents?
</OL>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
If you use the EX07A view and dialog classes in an MDI application, each MDI child window can have one modeless dialog. When the user closes an MDI child window, the child's modeless dialog is destroyed because the view's destructor calls the dialog destructor, which, in turn, destroys the dialog window.
</BLOCKQUOTE></DIV>
</BODY>
</HTML>



