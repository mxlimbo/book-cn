<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>Introduction to the Abstract Windowing Toolkit</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04c.htm", "ch04e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="138"><H1>Introduction to the Abstract Windowing Toolkit</H1></A>

<p>Let's look at some of the principles behind AWT before looking at an AWT-based solution to our hypothetical programming problem. AWT consists of a set of classes contained within the package <I>java.awt</I>. In this section, we'll study the contents of the <I>java.awt</I> package.

<A NAME="139"><H2>AWT Components and Containers</H2></A>

<p>Many of the classes that make up AWT represent widgets of one type or another. The purposes of classes like <I>Button</I>, <I>Label</I>, <I>Checkbox</I>, and <I>Scrollbar</I> are clear. The hierarchy of these widget classes is shown in Figure 4-2.

<p>The first thing to notice in Figure 4-2 is that the classes making up AWT have a common base class in <I>Component</I>. The abstract class <I>Component</I> defines a set of methods that all AWT components share. For example, all components share the <I>resize()</I> method to resize an object and the <I>setVisible(boolean)</I> method to make an object visible or invisible.

<p>The second thing you might notice from Figure 4-2 is that the AWT component classes break down into two groups. The simple component classes are those along the right side of the figure. These classes represent discrete widgets that might appear on the interface.

<p>The second set of classes is the compound components that extend the abstract class <I>Container</I>. <I>Container</I> classes are classes that can contain components. For example, a <I>Window</I> class might contain multiple <I>Button</I> objects. Thus, the most important method that <I>Component</I> adds is the method <I>add()</I>, which enables a program to add a component to the container. For example, a button can be added to a dialog.

<p><A HREF="javascript:fullSize('F04gh02x.htm')"> <img src="images/F04gh02.JPG" width=404 height=375 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><b>Figure 4-2.</b> <i>The class hierarchy of the Abstract Windowing Toolkit.</I><!-- /caption -->

<p>Several subclasses of <I>Container</I> are of particular note. The class <I>Applet</I> represents an applet that runs within an Internet browser. We'll return to this class in the discussion of applets in Part III.

<A NAME="140"><H3>Frames, dialogs, and panels</H3></A>

<p>The class <I>Frame</I> represents what we as users might call a window. A <I>frame</I> is a window with defined edges, a title bar, and minimize, maximize, and close buttons on the far right side of the title bar. By default, the frame can be resized by dragging any side or corner with the mouse. (The resizing capability can be turned off programmatically.)

<p>The class <I>Dialog</I> represents a window that is similar in appearance to a panel. The distinguishing feature of a dialog is that it can be modal, meaning that mouse and keyboard input is allowed to the dialog box only as long as the dialog box is visible. A panel represents an area of the screen. The class <I>Panel</I> is the simplest concrete implementation of the abstract <I>Container</I> class.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
Remember that you can't create an instance of an abstract class because an abstract class has one or more abstract methods. An abstract method is a method that has been declared but not implemented&#8212;in other words, a method containing no code. A subclass of an abstract class becomes concrete by implementing all of the abstract methods.
</blockquote></div>

<p>Unlike a frame, a panel has no visible borders and no title bar. Since a panel isn't visible, it doesn't really have any properties of its own. This might lead you to wonder, &quot;What good is a panel anyway?&quot;

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
The class <I>Container</I> extends the class <I>Component</I>, which means that a container is a component. A container can therefore be added to a container like any other component. There is one exception: even though <I>Frame</I> extends <I>Component</I>, because of its window-sizing buttons a frame can't be added to a container.
</blockquote></div>

<p>The primary use of a panel is to group components located within another container, such as a frame or dialog. This still doesn't completely address the need for a panel, but before I try to fully answer that question let's look at a simple example of a frame without panels: SimpleFrame.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
The complete code samples from this chapter are located in the Generic Applications folder in the sample files on the companion CD.
</blockquote></div>


<A NAME="141"><H3>A simple frame example</H3></A>

<p><pre>
/**
 * This class demonstrates a simple AWT frame.
 */
import java.awt.*;

public class SimpleFrame extends Frame    
{
    /**
     * The main entry point for the application. 
     */
    public static void main (String[] args)
    {
        SimpleFrame sf = new SimpleFrame();
        sf.init();
    }

    /**
     * Add a few components to the container and
     * make the frame visible.
     */
    public void init()
    {
        // add a few components
        add(new Label(&quot;Enter name:&quot;));
        add(new TextField(10));
        add(new Button(&quot;Submit&quot;));
        
        // now set the size&#8230;
        this.setSize(300, 100);
        
        // and make the results visible
        setVisible(true);
    }
}
</PRE>

<p>Like all the applications we have seen so far in this book, this program was created using the Console Application Wizard. Also, like all Visual J++ applications, this program begins execution with the <I>public</I> <I>main()</I> method. The <I>main()</I> method performs two steps. First it creates an object of class <I>SimpleFrame</I>. It then invokes the <I>init()</I> method of <I>SimpleFrame </I>to populate the frame with components.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
Using an <I>init()</I> method to populate the frame is common because it follows the pattern of an applet, as we'll see in Part III.
</blockquote></div>

<p>The <I>init()</I> method adds three components:

<UL>
<p><li>A label bearing the text &quot;Enter name:&quot;.

<p><li>An edit box into which the user can enter text.

<p><li>A button bearing the label &quot;Submit&quot;.
</UL>

<p>Finally, the <I>SimpleFrame</I> object sets its size to be 300 units wide and 100 units tall. Since display characteristics are somewhat machine-dependent, a unit has never been exactly defined; however, on most platforms, including the PC, it corresponds to a pixel.

<p>The result of this program is shown in Figure 4-3.

<p><IMG SRC="images/F04gh03.JPG" width=300 height=100 BORDER=0>

<p><!-- caption --><b>Figure 4-3.</b> <i>The disappointing results from our first AWT frame.</I><!-- /caption -->

<p>Notice that only the Submit button is visible in the resulting frame. Although the output is disappointing, there are a lot of features present for relatively little code. By extending <I>Frame</I>, <I>SimpleFrame</I> has a title bar, although it doesn't populate the title bar with a title. In addition, <I>SimpleFrame</I> has the three window buttons. The maximize and minimize buttons actually work, but the close button has no effect. This is because the base class <I>Frame</I> knows how to handle maximizing and minimizing the window but doesn't know how you want to terminate your program gracefully.

<A NAME="142"><H2>AWT Layout Managers</H2></A>

<p>In the output from the <I>SimpleFrame</I> object shown in Figure 4-3, only the Submit button is visible. Why is this so?

<p>The problem is that as the program added components to the <I>SimpleFrame</I>, it didn't tell the <I>Frame</I> base class where to put each object. Not knowing any differently, <I>Frame</I> put each object in the middle, one on top of the other. Since the button was the last object to be added, it's the only one visible.

<p>&quot;No problem,&quot; says the experienced Microsoft Visual C++ or Microsoft Visual Basic programmer. &quot;I'll just add a few calls to the <I>setPosition()</I> method to position the components relative to each other in the frame.&quot; However, this doesn't work because AWT has no such method. This seems surprising until you consider that the same Java program is intended to work on different types of machines with different screen resolutions and sizes. Java applets must even be able to run under the control of an Internet browser. Therefore, Java can make no assumptions about the size or resolution of the display.

<A NAME="143"><H3>The border layout manager</H3></A>

<p>Rather than use absolute positioning, Java uses a series of layout managers that position the components relative to each other in the container. All of the layout managers use some form of relative positioning. Instead of using pixel positions to set the absolute position of each component in SimpleFrame, you, for example, place one component to the left of another or put a component on the right side of the frame. With some layout managers, you can divide the available horizontal space, vertical space, or both, evenly between the components.

<p>The default layout manager for the <I>Frame</I> class is <I>BorderLayout</I>. The <I>BorderLayout</I> layout manager attaches components relative to the four borders of the frame. For whatever reason, the founders of Java weren't fond of left and right directions; they named the frame borders West, East, North, and South instead. (They could have just as well used Port, Starboard, Bow, and Stern.) Whatever is left over is called Center (there is no compass direction for where you're at).

<p>The changes to the <I>init()</I> method to utilize the <I>BorderLayout</I> layout manager are shown in the following code.

<p><pre>
public void init()
{
    // add a few components
    add(&quot;West&quot;,   new Label(&quot;Enter name:&quot;));
    add(&quot;Center&quot;, new TextField(10));
    add(&quot;East&quot;,   new Button(&quot;Submit&quot;));

    // now set the size&#8230;
    this.setSize(300, 100);

    // and make the results visible
    setVisible(true);
}
</PRE>

<p>Figure 4-4 shows the results of this version of the <I>init()</I> method.

<P><IMG SRC="images/F04gh04.JPG" width=300 height=100 BORDER=0>

<P><!-- caption --><B>Figure 4-4.</b> <i>The somewhat improved output obtained by using relative placing 
of the components within the frame.</I><!-- /caption -->

<p>While Figure 4-4 is certainly an improvement over its predecessor, this still isn't really what we might want. For example, the <I>TextField</I> object is several rows high even though it can accept only a single line of text. Is there not some way to further improve the appearance of SimpleFrame?

<A NAME="144"><h3>Using panels with the <I>BorderLayout</I> layout manager</h3></A>
<p>To improve the appearance of SimpleFrame, you must understand exactly how the <I>BorderLayout</I> manager works. It takes the following steps:

<OL>
<p><li>It allocates space to the components assigned to the North and South sides of the frame. These objects are stretched horizontally to consume all of the available horizontal space from one side of the frame to the other, and are assigned only as much vertical space as they need.

<p><li>It expands the components assigned to the West and East sides of the frame vertically to fill any remaining vertical space left by the North and South objects. These objects are assigned only as much horizontal space as they need.

<p><li>It expands the Center component to fill any remaining space.
</OL>

<p>The result looks like the diagram shown in Figure 4-5.

<p><IMG SRC="images/F04gh05.JPG" width=370 height=281 BORDER=0>

<p><!-- caption --><b>Figure 4-5.</b> <i>The regions of the </I>BorderLayout <I>layout manager.</I><!-- /caption -->

<p>One improvement over the last version of the <I>init()</I> method would be to bundle the prompt and the input text area into a single line and place this near the top of the frame. We could then put the Submit button at the bottom. Under this scenario, the center would remain empty.

<p>The following version of <I>init()</I> does exactly this through the use of the <I>Panel</I> class:

<p><pre>
public void init()
{
    // add a few components
    // use a panel to combine the label and text field
    // along the top of the display
    Panel panel = new Panel();
    panel.setLayout(new BorderLayout());
    panel.add(&quot;West&quot;,   new Label(&quot;Enter name:&quot;));
    panel.add(&quot;Center&quot;, new TextField());
    add(&quot;North&quot;, panel);
    
    // now put the button at the bottom
    add(&quot;South&quot;, new Button(&quot;Submit&quot;));
    
    // now set the size&#8230;
    this.setSize(300, 100);
    
    // and make the results visible
    setVisible(true);
}
</PRE>

<p>Here you can see that the panel is assigned a <I>BorderLayout</I> object using the <I>setLayout()</I> method. We didn't have to specify the layout for the <I>Frame</I> object because the default layout is already <I>BorderLayout</I>, but the panel receives a different layout by default. The label and text field are then attached to the <I>panel</I> object.

<p>Once the layout manager for the panel has been established, the label is placed on the West side of this invisible panel. All remaining space is allocated to the text field. Once it is completed, the <I>panel</I> object is added to the north side of the frame. The border layout manager of the frame will stretch the panel horizontally to fill the available horizontal space. The vertical size of the panel is set by the space needs of the label and the text field. The Submit button is then placed along the South side of the window. The result is shown in Figure 4-6.

<P><IMG SRC="images/F04gh06.JPG" width=300 height=100 BORDER=0>

<!-- caption --><P><B>Figure 4-6.</b> <i>The improved output resulting from the use of panels to group components.</I><!-- /caption -->

<A NAME="145"><H3>Other layout managers</H3></A>

<p>There are many other Visual J++ layout managers besides the <I>BorderLayout</I> layout manager. For example,the simple <I>FlowLayout</I> manager allocates space from left to right in a row until it runs out of horizontal space, at which point it moves down to the second row and starts allocating horizontal space again.

<p>A complete discussion of layout managers is beyond the scope of this book. In any case, by means of judicious and clever use of panels you can generally achieve the results you want with the <I>BorderLayout</I> manager and perhaps one or two other managers.

<A NAME="146"><H2>AWT Events</H2></A>

<p>By using panels and the <I>BorderLayout </I>manager, we have improved the appearance of SimpleFrame<I>, </I>but the program still doesn't do anything. Neither choosing the Submit button nor clicking the frame's close button has any effect. In this section, I will show you how to modify SimpleFrame to actually do something. This new program, SimpleActiveFrame<I>,</I> terminates when you click the close button or displays the contents of the text field on standard output when you choose the Submit button.

<p><pre>
/**
 * This class demonstrates a simple AWT frame that
 * can respond to a button press. (This application uses
 * the older Java 1.0-style event processing.)
 */
import java.awt.*;

public class SimpleActiveFrame extends Frame    
{
    // name field
    TextField name;
    
    /**
     * The main entry point for the application. 
     */
    public static void main (String[] args)
    {
        SimpleActiveFrame sf = new SimpleActiveFrame();
        sf.init();
    }

    /**
     * Add a few components to the container and
     * make the frame visible.
     */
    public void init()
    {
        // add a few components
        // use a panel to combine the label and text field
        // along the top of the display
        Panel panel = new Panel();
        panel.setLayout(new BorderLayout());
        panel.add(&quot;West&quot;,   new Label(&quot;Enter name:&quot;));
        panel.add(&quot;Center&quot;, name = new TextField());
        add(&quot;North&quot;, panel);
        
        // now put the button at the bottom
        add(&quot;South&quot;, new Button(&quot;Submit&quot;));
        
        // now set the size&#8230;
        this.setSize(300, 100);
        
        // and make the results visible
        setVisible(true);
    }
    
    /**
     * When the Submit button is pressed, the action event
     * will bubble up to the frame. Read the name and
     * display on standard output.
     * 
     * @deprecated
     */
    public boolean action(Event e, Object o)
    {
        // read the text out of the TextField
        String s = name.getText();
        
        // display it on standard output
        System.out.println(&quot;Name = \'&quot; + s + &quot;\'&quot;);
        
        // returning true indicates that we've handled
        // the event successfully
        return true;       
    }

    /**
     * Events are always passed to handleEvent() first.
     * Action events get passed on to action() by default.
     * Other events are either handled or ignored by default.
     * Here, we handle the WINDOW_DESTROY event, which is otherwise
     * ignored.
     * 
     * @deprecated
     */
    public boolean handleEvent(Event e)
    {
        // if this is a WINDOW_DESTROY event&#8230;
        if (e.id == Event.WINDOW_DESTROY)
        {
            // terminate the program
            System.exit(0);

        }
        return super.handleEvent(e);
    }
}
</PRE>

<p>The only difference between the <I>SimpleActiveFrame</I> class and its predecessor<I> SimpleFrame</I> is the addition of the two methods <I>action()</I> and <I>handleEvent()</I>. The <I>action()</I> method handles the clicking of the Submit button and <I>handleEvent()</I> handles the <I>WINDOW_DESTROY</I> event, which occurs when the user clicks the window's close button.

<A NAME="147"><H3>What's an event?</H3></A>

<p>An event is an object that is generated when something happens. For example, if the user clicks a button, the VM generates a button click event. When the user presses a key, the VM generates two events: one for the key going down and another for the key going up. Through these events, the VM communicates to the program what is going on in the outside world.

<P>All events extend the class <I>Event</I>. This base class contains basic information, like a reference to the object that originated the event and the type id of the event. A reference to the type id is generally useful for window events; <I>Event</I> contains a list of possible ids. For mouse events, the <I>Event</I> class records the position of the mouse at the time of an event such as the button down or button up event. There is also a time in the <I>Event</I> class, but this does not refer to the time of day or the time of year; you can use this time only to compare two events to determine which occurred first or how far apart in time the two events were.

<P>As events occur, the VM creates an <I>Event</I> object and passes it to the <I>Component.handleEvent()</I> method.

<DIV CLASS="NOTE">
<BLOCKQUOTE>
<B>NOTE</B>
<HR>Visual J++ applications have a Windows message dispatch loop, just like a Visual C++ program does; however, this loop is hidden from the Visual J++ programmer by the Java event mechanism. Windows messages get turned into <I>Event</I> objects which are processed as described here. The Visual J++ programmer does have access to the idle loop processing by means of WFC, as we will see in <A HREF="ch10a.htm">Chapter 10</A>.
</BLOCKQUOTE>
</DIV>

<p>The <I>Component.handleEvent()</I> method ignores all events. This method is overridden in superior classes, such as <I>Frame</I>, to handle whatever events they can. For example, the <I>Frame.handleEvent()</I> method knows how to handle the <I>WINDOW_MINIMIZE</I> and <I>WINDOW_MAXIMIZE</I> events<I>.</I>

<p>The <I>Frame.handleEvent()</I> method does not know how to handle the <I>WINDOW_DESTROY</I> event; <I>SimpleActiveFrame </I>must override <I>handleEvent()</I> to provide such processing. If the id of the <I>Event </I>object passed to <I>SimpleActiveFrame.handleEvent()</I> is <I>Event</I>.<I>WINDOW_DESTROY</I>, then <I>SimpleActiveFrame.handleEvent()</I> calls <I>System.exit()</I> to terminate the program. For other <I>Event </I>ids, <I>SimpleActiveFrame.handleEvent()</I> passes the <I>Event </I>object to <I>super.handleEvent()</I>. This allows the base class to continue to provide whatever default processing it is capable of.

<P>
<DIV class="CAUTION">
<BLOCKQUOTE>
<p><B>CAUTION</B>
<HR>
If you override <I>handleEvent()</I>, be sure to pass any events you do not handle on to <I>super.handleEvent()</I> for processing.</BLOCKQUOTE> </DIV>


<p>Notice that the return type of <I>handleEvent()</I> is <I>boolean</I>. A <I>true</I> return value indicates that the event has been processed and does not require any further processing. The <I>SimpleActiveFrame.handleEvent()</I> method includes a <I>return</I> <I>true</I> statement even though control will never return from the <I>exit()</I> call. This serves no purpose other than instructional.

<A NAME="148"><H3>What's an action?</H3></A>

<p>There is a certain class of events called action events. An <I>action event</I> is an event resulting from some action by the user. For example, a button click is an action event.

<P>Like all events, action events first get passed to the <I>handleEvent()</I> method. If they are not processed there, action events then get passed on to the <I>Component.action() </I>method. Like the <I>handleEvent()</I> method, the <I>action()</I> method can be overridden to process the event. For example, in SimpleActiveFrame we could have extended <I>Button</I> into a new class, say <I>SubmitButton</I>, with its own <I>action()</I> method. This method would automatically get invoked whenever that button was clicked.

<p>It isn't necessary to create a new subclass for every AWT object you create, however. The default processing for <I>Component.action()</I> is to pass the event to the <I>action()</I> method of the parent component, so you can handle all action events in the frame if you prefer. The <I>SimpleActiveFrame.action()</I> method reads the text from the text field using the <I>getText()</I> method and passes the text on to <I>println()</I> to be output to standard output. This output appears in the DOS window from which the application was started.

<p>
<div class="note">
<blockquote>
<b>NOTE</b><hr>
There are reasons why you might not want to handle action events in the frame. Depending on your design, it might be cleaner to put the action event handler in a <I>SubmitButton</I> class so that all submit processing is in one place.
</blockquote>
</div>

<p>The only real difference between the <I>action()</I> method and the <I>handleEvent()</I> method is that the <I>action()</I> method has fewer events to deal with. For example, since SimpleActiveFrame has only one component, the Submit button, we were able to assume that the action event originated from the button component.

<A NAME="149"><H3>Why the warnings?</H3></A>

<p>You might notice that when you compile SimpleActiveFrame several warnings appear in the task list indicating that <I>handleEvent()</I> and <I>action()</I> have been &quot;deprecated.&quot; This means that in one of the base classes these methods have been flagged with the <I>@deprecated</I> pragma. (In fact, I have even flagged both methods with the <I>@deprecated</I> pragma in this class just to show you how it's done.)

<P>Flagging a method as deprecated indicates that although the method works now, the designers of Visual J++ might remove that method from future versions of the class library. The <I>action()</I> and <I>handleEvent()</I> methods are deprecated because Java 1.1 introduced a new event-handling approach. I have presented the version 1.0 event-handling approach here because it is so pervasive in the Java community that all Java programmers need to be familiar with it for the foreseeable future.

<P>I will present Java 1.1 event handling in <A HREF="ch05a.htm">Chapter 5</A>, where we can contrast it with WFC event handling.

</BODY>
</HTML>




