<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>The TreeView Control</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch08b.htm", "ch08d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="246"><H1>The TreeView Control</H1></A>

<p>Like the ListView control, TreeView is another control that you are already 
familiar with. Open Windows Explorer; the list of directories in the left pane is a tree 
view. Another example is the Properties window for the Microsoft Visual J++ 
Forms 
Designer.

<p>The ListView control is ideal for displaying large amounts of data along 
with descriptive information. However, it can't display the hierarchical nature of 
some information, and this is where the TreeView control comes in. The ability to 
display hierarchical information makes a tree view the preferred means of displaying 
directory information.

<p>The following TreeViewDemo program creates a 
<I>TreeView</I> object to display the hierarchy of a given directory. The
program populates the tree view with each 
file in the directory. Subdirectory branches are populated with the
subdirectory's contents.

<A NAME="247"><H2>The Forms Designer Work</H2></A>

<p>There isn't much design work to this particular demo. Create a new Windows 
application in the conventional way, and name this project TreeViewDemo. In the 
Forms Designer, add a TreeView control from the Toolbox to the form 
<I>Form1</I>. You will need to rename the new control to 
<I>treeView</I>, but most of the other properties in the 
Properties window are already set correctly.

<p>Add a single-line edit control along the bottom of the form. Change its 
name to <I>edit</I>. Resize the form so that it is considerably taller than it is wide, and then 
resize the TreeView and Edit controls so that they fill most of the form. Anchor the 
TreeView control to all four sides of the form. Anchor the Edit control to the left, right, and 
bottom sides, but not to the top. This will ensure that the Edit control continues to 
hug the bottom edge if the user resizes the form.

<p>Figure 8-6 shows the resulting form in the Forms Designer window and 
the properties for the TreeView control.

<p><A HREF="javascript:fullSize('F08gh06x.htm')"> <img src="images/F08gh06.JPG" width=404 height=329 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><b>Figure 8-6.</b> <i>The Forms Designer work for the TreeViewDemo
application is fairly simple.</i><!-- /caption -->

<A NAME="248"><H2>The Code</H2></A>

<p>Writing the code for the TreeViewDemo application is considerably more 
complicated than creating the form. The problem lies in the fact that each
node that represents 
a subdirectory of the current directory must be able to be expanded. Any 
subdirectories within that subdirectory must also be expandable, and so on
until the application has built a maze of branches with each branch reaching
down into the farthest subdirectory.

<p>Before I show the<I> </I>source code, let me present a programming technique 
called recursion that helps simplify this problem.

<A NAME="249"><H3>Recursion</H3></A>

<p>Consider for a moment the following problem of calculating the factorial of a 
number. The factorial of N is equal to N * factorial 
(N-1). The factorial of 0 is 1. Knowing this, I could write a 
<I>factorial()</I> function as follows. (I'm not saying this is the best 
way to implement a factorial; it is merely one way.)

<p><pre>
public static int factorial(int N)
{
    // handle the known case
    if (N == 0)
    {
        return 1;
    }

    // call yourself to calculate the factorial
    return N * factorial(N - 1);
}
</PRE>

<p>At first glance, it would appear that by calling itself this function generates 
an infinite loop, but consider for a second how this function works. Suppose a 
program calls <I>factorial(5)</I>. Since 5 is not equal to 0, the function would calculate 5 
* <I>factorial(4)</I>, and <I>factorial(4)</I> would then call 
<I>factorial(3)</I>. This process would be repeated 
until eventually <I>factorial(1)</I> calculated 
<I>1 </I>* <I>factorial(0)</I>. At this point, 
<I>factorial(0)</I> would return a 1, which would allow the 
<I>factorial(1)</I> calculation to continue and return 
a 1 to allow the <I>factorial(2)</I> calculation to proceed, and so forth. This approach 
of having a function call itself is called 
<I>recursion</I>.

<A NAME="250"><H3>Applying recursion to TreeViewDemo</H3></A>

<p>Although the problem of expanding the base node of the tree is very different 
from calculating a factorial, it is similar in one respect. Once a node for a new 
subdirectory has been added, the entire process of creating a list of entries representing the 
contents of that subdirectory must be duplicated. After the new node has been 
added for the subdirectory, the problem from that point onward is 
<I>exactly</I> the same as the problem of adding the first directory. That being the case, the easiest approach 
to solving this problem is for the function to call itself recursively.

<p>Let's see how recursion works to create a tree view. The source code for 
TreeViewDemo appears as follows:

<p><pre>
import com.ms.wfc.app.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;
import com.ms.wfc.html.*;

import com.ms.wfc.io.*;
import com.ms.wfc.util.*;

/**
 * Demonstrate the TreeView class by adding a node for each file in
 * the specified directory. Expand subdirectories to include their 
 * files as well.
 */
public class Form1 extends Form
{
    public Form1(String[] args)
    {
        // Required for Visual J++ Form Designer support
        initForm();

        // expand the specified node
        String initialPath = File.getCurrentDirectory();
        if (args.length == 1)
        {
            initialPath = args[0];
        }
        treeView.addNode(expandTreeNode(&quot;&quot;, initialPath));
    }
    
    /**
     * Expand the directory dirName within path.
     */
    TreeNode expandTreeNode(String path, String dirName)
    {
        // create a node with that directory name
        TreeNode node = new TreeNode(dirName);

        // combine the path with the directory name
        path = File.combine(path, dirName);
        
        // now create two lists containing the contents of the
        // directory pointed to by path
        List dirList = new List();
        List fileList= new List();
        createSortedLists(path, dirList, fileList);
        
        // add the directories&#8230;
        addDirsToNode(path, node, dirList);
        
        // then add the files
        addFilesToNode(node, fileList);
        
        return node;
    }

    /**
     * Add a list of directories to the node pointed to by path.
     */
    void addDirsToNode(String path, TreeNode node, List list)
    {
        // iterate through the list of directories
        IEnumerator itemEnumerator = list.getItemEnumerator();
        while (itemEnumerator.hasMoreItems())
        {
            // get the directory name from the list item
            String dirName = (String)itemEnumerator.nextItem();
 
            // now add a new node with that name; expand the
            // node to include the contents of the directory as well
            node.addNode(expandTreeNode(path, dirName));
        }
    }

    /**
     * Add the list of file names to the specified node.
     */
    void addFilesToNode(TreeNode node, List list)
    {
        // iterate through the list
        IEnumerator itemEnumerator = list.getItemEnumerator();
        while (itemEnumerator.hasMoreItems())
        {
            // add each file name to the node
            String fileName = (String)itemEnumerator.nextItem();
            node.addNode(new TreeNode(fileName));
        }
    }

    /**
     * Put each of the elements of path into either the dirList
     * or the fileList and then sort both.
     */
    void createSortedLists(String   path,
                           List     dirList,
                           List     fileList)
    {
        // create a FileEnumerator in order to iterate through the
        // current path
        FileEnumerator fe = 
                 new FileEnumerator(File.combine(path, &quot;*.*&quot;));
        for(;fe.hasMoreFiles(); fe.getNextFile())
        {
            String fileName = fe.getName();
            
            // ignore the &quot;.&quot; and &quot;..&quot; directories
            if (fileName.equals(&quot;.&quot;) ||
                fileName.equals(&quot;..&quot;))
            {
                continue;
            }

            // if this is a directory&#8230;
            if (File.isDirectory(File.combine(path, fileName)))
            {
                // then add it to the directory list;&#8230;
                dirList.addItem(fileName);
            }
            else
            {
                // otherwise, add it to the file list
                fileList.addItem(fileName);
            }
        }
        
        // now sort the lists
        dirList.sort(new FileNameComparer());
        fileList.sort(new FileNameComparer());
    }
 
    /**
     * Implement the IComparer interface to support List.sort().
     */
    class FileNameComparer implements IComparer
    {
        /**
         * Compare o1 to o2; return -1, 0, or 1.
         */
        public int compare(Object o1, Object o2)
        {
            String f1 = (String)o1;
            String f2 = (String)o2;

            return StringSorter.compare(f1, f2,
              StringSorter.STRINGSORT | StringSorter.IGNORECASE);
        }
    }

    .
    .
    .


    /**
     * Invoked when a node in the TreeView is selected.
     */
    private void treeView_afterSelect(Object source, TreeViewEvent e)
    {
        TreeNode node = treeView.getSelectedNode();
        String fileName = node.getText();
        edit.setText(fileName);
    }

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
    Container components = new Container();
    TreeView treeView = new TreeView();
    Edit edit = new Edit();

    private void initForm()
    {
        // &#8230;generated by Forms Designer&#8230;
    }

    /**
     * The main entry point for the application. 
     *
     * @param args Array of parameters passed to the application
     * via the command line.
     */
    public static void main(String args[])
    {
        Application.run(new Form1(args));
    }
}
</PRE>

<p>As always, <I>main()</I> creates an object of class 
<I>Form1</I>. This time I added the <I>args</I> argument to the 
<I>Form1</I> constructor to give the user the option of viewing a 
directory other than the current directory. After the standard call to 
<I>initForm()</I>, <I>Form1()</I> creates a string variable 
<I>initialPath</I> setting it equal to the argument passed to 
the program, if there is one, or the current directory. 
<I>Form1()</I> then creates a directory node at that directory by calling 
<I>expandTreeNode()</I> and attaches the node to 
the <I>treeView</I> object.

<P>The <I>expandTreeNode()</I> method creates an object of class 
<I>TreeNode </I>to represent the current directory. Much like the 
<I>ListView </I>object, you do not attach normal 
components like a <I>String</I> object directly to a 
<I>TreeView </I>object. You must first wrap the 
<I>String </I>in a tree node, and then you attach the tree node to the tree view. Unlike the list 
view, however, you can also attach a tree node to another tree node. This capability 
gives the tree view its hierarchical affect.

<P>Once the tree node for the current directory has been created, the 
<I>expandTreeNode()</I> method calls 
<I>createSortedLists()</I> to create two lists, one of all the 
subdirectories in the current directory and the other containing the names of all the files.

<P>The <I>createSortedLists()</I> method is similar to the 
<I>addFilesToListView()</I> method in the previous example in that it iterates through the contents of the specified 
directory. Every file it finds (other than the two directories &quot;.&quot; and &quot;..&quot;, which it 
ignores) are placed into one of two <I>List </I>objects. If the file represents a directory, it is 
placed in the <I>dirList</I> object. If it is not a directory, the name is placed in the 
<I>fileList</I> object. Both lists are then sorted. This approach of maintaining two lists makes 
<I>createSortedLists()</I> slightly more complicated than its 
<I>addFilesToListView()</I> predecessor. However, it avoids the need to iterate through the directory twice, once for 
the subdirectories and again for the non-subdirectories.

<P>Once <I>expandTreeNode()</I> has captured the contents of the current directory 
in the two lists and sorted them, it adds the contents of the directory list to the 
current node by calling the <I>addDirsToNode()</I> method and adds the contents of the file list 
by calling <I>addFilesToNode()</I>. Since the latter is the easier of the 
two, let's consider it first.

<P>The <I>addFilesToNode()</I> method starts by creating an 
<I>itemEnumerator </I>interface for the file list. It uses 
<I>itemEnumerator </I>to iterate through the list until 
<I>hasMoreItems()</I> returns false. The call to 
<I>nextItem()</I> returns the current file name string and 
moves the iterator to the next member in the list. A 
<I>TreeNode </I>object is built to contain the file name returned from 
<I>nextItem()</I>, and then the <I>TreeNode </I>object is added to the 
parent node by calling <I>addNode()</I>.

<P>The <I>addDirsToNode()</I> method begins in much the same way, by creating 
and using an <I>itemEnumerator </I>interface to iterate through the list of subdirectory 
names. Rather than simply create a <I>TreeNode 
</I>object to add to the parent node, however, 
this method calls the <I>expandTreeNode()</I> method to add a new directory node, passing 
it the name of the subdirectory and the path to the current parent node.

<P>As you know already, <I>expandTreeNode()</I> continues the process by 
generating a list of all of the files in that subdirectory. Each of the subdirectories of that 
subdirectory is then passed to 
<I>expandTreeNode()</I> in turn. In this way, the program 
uses <I>expandTreeNode()</I> to recursively burrow deeper and deeper into the hierarchy 
of subdirectories until it eventually reaches the end: the subdirectories that contain 
only files and no further subdirectories.

<P>I added one event handler function to TreeViewDemo. The 
<I>afterSelect </I>event occurs after the user has selected a tree node. To select a tree node, the user 
clicks the plus sign in front of the node name. In this case, 
the <I>treeView_afterSelect()</I> method retrieves the currently selected node and displays the file name associated with this node 
in the edit window at the bottom of the form.

<P>Figure 8-7 shows the results of executing TreeViewDemo on my 
\TEMP directory. As you can see, the directories are listed first. Those nodes that
have subnodes are listed with small plus signs. Clicking a plus sign causes the
node to expand and show the subnodes within.
 
<P><img src="images/F08gh07.JPG" width=267 height=437 border="0">
<P><!-- caption --><B>Figure 8-7.</b> <i>The results of executing the TreeViewDemo on my 
\TEMP directory.</I>
<!-- /caption -->

</BODY>
</HTML>




