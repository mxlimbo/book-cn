<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>The HelloWorld1 Project</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch01a.htm", "ch01c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="65"><H1>The HelloWorld1 Project</H1></A>

<p>It seems almost obligatory that the first application in any programming book be 
the famous &quot;Hello, world&quot; program, so let's begin there.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
For those of you who are familiar with Java, the &quot;Hello, world&quot; application will already be well known. This application is still a useful exercise for you because we will use it to explore many features of the Visual J++ 6 environment.
</blockquote></div>

<P><DIV CLASS="sidebar"><BLOCKQUOTE>
<P><B>What's a Console Application?</B>

<p>The simplest type of application is the console application. Console applications have no windows to deal with; they are designed to be run from the DOS command line. This might be the command line of an MS-DOS window 
in Windows or of DOS by itself. The output of a console application is simply spit directly back to the same command line.

<p>You can run a console application under Windows by 
double-clicking the file. This brings up an MS-DOS window within which the console 
application runs.

<p><div class="tip"><blockquote>
<B>TIP</B><hr>
Everything I've said here about MS-DOS windows running in Microsoft Windows applies equally well to the UNIX prompt running under Motif.
</blockquote></div>

<p>Although console applications are not very exciting, they're the preferred type of application to use when you're concentrating on performing a function&#8212;like calculating pi to the nth digit&#8212;and you don't particularly care about attractive output. This type of application is useful for many of the simple utilities you write for your own benefit.
</BLOCKQUOTE></DIV>

<A NAME="66"><H2>Creating a Console Application Project</H2></A>

<p>In the Microsoft Development Environment (MDE), choose New Project from the File menu. This opens the New Project dialog box. A <I>project</I> is a collection of source files, which together build a program.

<p>The New Project dialog box lists two options: Visual J++ Projects and Visual Studio. In the Visual J++ Projects folder, choose the Applications folder and then choose Console Application. Change the project name from Project1 to HelloWorld1. The HelloWorld1 project will be stored in a subfolder with the same name as the project.

<p>The default is for Visual J++ to create the HelloWorld1 folder as a subfolder of \\MyDocuments\VisualStudio. Personally, I think this is a crazy place to put 
application folders. I create a separate Java folder to store all my applications and applets. (I also have one for Microsoft Visual C++ and one for Visual Basic.) Do as you 
like, but for this first project I chose Browse in the dialog box and hung my new project subdirectory off the folder c:\user\Visual J++ Programs\Generic Applications. My results are shown in Figure 1-1.

<p>Once you've renamed the project and placed it in the folder of your choice, choose Open. (You can also double-click Console Application.) This causes Visual J++ to build the HelloWorld1 project.

<p><A HREF="javascript:fullSize('f01gh01x.htm')"> <img src="images/f01gh01.jpg" width=404 height=249 border=0 ALT="Click to view at full size."> </A>

<p>
<!-- caption --><b>Figure 1-1.</b> <i>The New Project dialog box showing the application choices, project name, and project folder.</I><!-- /caption -->

<A NAME="67"><H2>Project Explorer</H2></A>

<p>To look at the results of our work, open Project Explorer. Project Explorer is to projects what Windows Explorer is to files and Microsoft Internet Explorer is to the Internet: a view into the contents of the project.

<p>The most straightforward way to open Project Explorer is to choose Project Explorer from the View menu. There might also be a button on the toolbar that does the same thing. (I say <I>might</I> because you can customize the toolbars to include any buttons that you want. We'll talk about customizing toolbars later in this chapter.)

<p>You can view the files in your HelloWorld1 project by clicking the plus sign next to the project name (just like viewing folders in Windows Explorer). The results are shown in Figure 1-2.

<p><IMG SRC="images/f01gh02.jpg" width=228 height=200 BORDER="0">

<p>
<!-- caption --><b>Figure 1-2.</b> <i>The Project Explorer view of our first project.</I><!-- /caption -->

<p>Project Explorer in Visual J++ 6 looks similar to the project view in version 1.1. The major difference is that Project Explorer refers to something called the HelloWorld1 solution and lists it as having one project.

<A NAME="68"><H3>What's a solution (other than something mixed in a liquid)?</H3></A>

<p>Visual J++ 6 organizes projects into groups called solutions.

<p><div class="note"><BLOCKQUOTE>
<B>NOTE</B>
<hr>A <I>solution</I> is a group of projects. Visual 
C++ 6 and Visual Basic 6 support almost the same functionality but call it a <I>workspace</I>.
</blockquote></div>

<p>Grouping projects in this way enables you to perform the same operation on all of the projects at once with a single command. For example, choosing Build on the Build menu rebuilds all projects in the solution.

<p>Even though they are grouped together, projects retain their identity within the solution. For example, projects are deployed independently. Thus, if your 
solution has a Project1 and a Project2, rebuilding the solution might generate two executable files, Project1.exe and Project2.exe. Projects also have their own properties, so 
one project might generate an application while another generates an applet.

<p>For now, we will limit ourselves to single-project solutions.

<A NAME="69"><H2>The HelloWorld1 Project Source Code</H2></A>

<p>Within the HelloWorld1 project is a single Java file, Class1.java. Double-click this file in Project Explorer to view the source code file the Console Application Wizard 
created for us when we opened the new project.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
All examples for this chapter are located in the Generic Applications subfolder on the book's companion CD.
</blockquote></div>

<p>The following code shows the contents of Class1.java. I've added one line (shown in boldface) to convert the project into the &quot;Hello, world&quot; application.

<p><pre>
/**
 * This class can take a variable number of parameters on the command
 * line. Program execution begins with the main() method. The class
 * constructor is not invoked unless an object of type 'Class1'
 * created in the main() method.
 */
public class Class1
{
    /**
     * The main entry point for the application. 
     *
     * @param args Array of parameters passed to the application
     * via the command line.
     */
    public static void main (String[] args)
    {
        // TODO: Add initialization code here
<B>        System.out.println(&quot;Hello, world&quot;);</B>
    }
}
</PRE>

<p>As you can see, the Console Application Wizard constructs an empty class definition with comments. Notice that the comments are somewhat unusual: they begin with a <I>/**</I> rather than the normal /*. Also notice the appearance of 
<I>* @param</I> in the middle of the comments.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
The comments preceded by /** are generally called &quot;Javadoc comments&quot; after the Sun Microsystems, Inc. utility Javadoc, which uses these 
comments to automatically generate class documentation. Visual J++ 6 has extended this concept into a powerful, dynamic feature described later in this chapter in the &quot;Statement Completion&quot; section.
</blockquote></div>

<p>Program execution begins with the <I>public static</I> method <I>main().</I>

<p><div class="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>The<I> public</I> keyword makes the method visible to other classes, and the <I>static</I> keyword enables the method to be invoked without an object.
</blockquote></div>

<p>In the line of code I've added, <I>System</I> is a global object that retains information about the environment in which the program resides. One of the <I>System</I> object's data members is the static member <I>out</I> that points to standard output, normally the command line. The <I>out</I> data member is of class <I>PrintStream</I>. This class has a method <I>println()</I>, which prints whatever string is passed to it followed by a newline character.

<P><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>Under C++, the syntax for accessing <I>out</I> would have been something like <I>System::out</I>; however, Java does not use the <I>::</I> symbol, preferring instead to stick with the single dot.
</blockquote></div>

<p>To compile HelloWorld1, choose Build from the Build menu. If the program compiles properly, the phrase &quot;Solution update succeeded&quot; appears in the status bar.

<p>To run the program, you have four options:

<OL>
<P><LI>In the Visual J++ user interface, you can choose Start from the Debug menu.
<P><LI>In Windows Explorer, you can double-click HelloWorld1.exe.
<P><LI>In an MS-DOS window, you can go to the directory containing HelloWorld1.exe and type <I>HelloWorld1</I> at the command line.
<P><LI>Select Run from the Windows Start menu. Type  <I>HelloWorld1</I> preceded by the full path to the .EXE file, and choose OK.
</OL>

<p>Any of these four techniques generate the &quot;Hello, world&quot; output.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
When running the program using option 1, option 2, or option 4, Windows immediately opens an MS-DOS window in which to run the application. When the program terminates, Windows quickly closes the window. Thus, for a short program like this one, the window might not stay open long enough for 
you to read the output. There are ways around this problem, several of which we'll visit later on in this chapter. In the meantime, either take my word for it that the output is there or use option 3 to run the program.
</blockquote></div>

<A NAME="70"><H2>The Microsoft Developer Environment 6</H2></A>

<p>Before continuing with more challenging applications, let's use the simple 
HelloWorld1 application as a way to introduce the MDE, the user interface for Visual 
J++. We've already seen a bit of Project Explorer and the Text editor, but even here 
there are a few additional features to point out. To look at these features, open the 
HelloWorld1 application in Visual J++.

<A NAME="71"><H3>The Multiple Document Interface and the Single Document Interface</H3></A>

<p>Two fundamentally different modes are available for the MDE. In Multiple 
Document Interface (MDI) mode, the MDE acts as a single desktop upon which all other 
windows, such as Project Explorer and the Text editor, reside. In this mode, you 
can't see Windows applications behind the MDE desktop and MDE windows can't 
leave the MDE desktop. This is the mode under which previous versions of Visual 
J++ operated.

<p>In Single Document Interface (SDI) mode, there is no MDE desktop. Rather, 
the menus, taskbar, and status bar form one window, Project Explorer resides in 
another window, and each Text editor occupies its own window. In this mode, the 
MDE windows appear on the Windows desktop in front of whatever applications 
might be executing in the background.

<p>At first, SDI mode is disconcerting since the different windows seem to have 
a tenuous connection to each other and to the menu bar. SDI mode is especially 
confusing if you happen to run Visual J++ twice. When you do that, you really have 
no idea which windows belong to which MDE. However, once you get used to it, 
SDI will probably become your preferred style.

<p>You can change from SDI to MDI and back again. To do so, choose Options from the Tools menu, expand the Environment branch and choose General, and 
select or deselect SDI Environment. You'll have to close and then reopen Visual J++ before the change will take effect.

<A NAME="72"><H3>Docking windows</H3></A>

<p>Another feature of the MDE is docking windows. A window is <I>docked</I> when it is firmly attached to another window, generally to its edge. Docking applies only in MDI 
mode. By default, all windows&#8212;except the Text editor&#8212;have docking set on.

<p>Docking windows takes some getting used to; learning a few basics will help. First, if you place a dockable window near another dockable window (especially 
near the menu or toolbars), the MDE automatically snaps them together, issuing an 
audible snapping sound to confirm the action.

<p>You can try to undock the window by dragging it away; however, the window is likely to simply redock in some other configuration. A better alternative is to 
double-click the title bar, which automatically undocks the window and keeps it 
undocked. Now you are free to move the window wherever you like. Double-clicking the 
title bar again throws the window back to its previous docked position.

<p>If you're like me and don't like docking windows next to each other, you can right-click the title bar to disable the docking feature and leave it undocked. Before you do that, however, I want to show you one other docking mode that I find fits my personality very well.

<p>Sometimes a window will disappear as soon as you disable docking. Usually this is because the window is just barely outside the parent window. Before you give the window up for lost, click the maximize button on the MDE title bar and look for it, usually along the bottom of the screen. If you still can't find it, you can reenable docking for the window you're looking for by choosing the window in the Window menu and then selecting Dockable from the Window menu.

<p>In addition to docking windows next to each other, the MDE supports docking windows on top of each other. It's a little tricky to get the first two windows to dock in this mode; you basically want to drag two similarly sized windows directly on top of each other. Once you do, the top window will reappear within a window with a tab attached. The back window is hidden except for its tab, which appears immediately beside the top window's tab.

<p>To add another window to the tabbed group, follow these steps:

<OL>
<P><LI>Make the window visible by choosing View from the Edit menu and selecting the appropriate option.
<P><LI>Use the mouse pointer to grab the window by the title bar.
<P><LI>Drag the window to the tab labels.
</OL>

<p>Step 3 isn't obvious. Your first instinct might be to drag the window on top of the tabbed window group; however, this simply docks the window to the window pair.

<p>My preference is to dock all MDE windows (except for Text editor windows) to the single tabbed window, as shown in Figure 1-3. Notice that I have 
widened the tabbed window to the point where each tab label is completely visible. As I shrink the window, the MDE truncates the labels more and more until it 
eventually removes them.

<p><A HREF="javascript:fullSize('f01gh03x.htm')"> <img src="images/f01gh03.jpg" width=404 height=373 border=0 ALT="Click to view at full size."> </A>

<p>
<!-- caption --><b>Figure 1-3.</b> <i>A tabbed window containing most of the MDE development windows.</I><!-- /caption -->

<A NAME="73"><H3>The Text editor</H3></A>

<p>The most important window the programmer uses is the Text editor; this 
window contains the Java source code.

<p><B>Color coding</B>

<p>View the Class1.java source file in the Text editor and one thing jumps out at 
you right away. (If you've closed the Text editor, double-click Class1.java in 
Project Explorer to reopen it.) The Text editor color codes the different statement types, using green for comments, blue for keywords, and black for executable statements.

<p><B>Indentation settings</B>

<p>As you type, the Text editor can help you to implement a consistent indentation style. Depending on what style settings you have selected, the editor automatically indents statements and aligns open and close braces. To adjust these features, choose Options on the Tools menu and under the Text Editor branch choose Java Format.

<p><B>Smart editor</B>

<p>The Text editor also checks syntax as you type. As soon as it detects a syntax 
error, it places a squiggled red line underneath the offending statement, as shown in Figure 1-4. (This is similar to the way Microsoft Word underlines misspelled words.) You can disable syntax error checking by choosing Java Tasks under Text Editor in the Options dialog box.

<p><A HREF="javascript:fullSize('f01gh04x.htm')"> <img src="images/f01gh04.jpg" width=404 height=156 border=0 ALT="Click to view at full size."> </A>

<p>
<!-- caption --><b>Figure 1-4.</b> <i>Smart editor syntax checking.</I><!-- /caption -->

<p><B>Statement Completion</B>

<p>The final feature of the Text editor I'll point out is the automatic object browser, called the Auto List Members feature. As soon as you enter a dot (&quot;.&quot;) after either a class or an object name, Auto List Members drops down a list of all the possible entries. For example, Figure 1-5 shows the Text editor after you have entered the dot following the word <I>System</I>.

<p><A HREF="javascript:fullSize('f01gh05x.htm')"> <img src="images/f01gh05.jpg" width=404 height=235 border=0 ALT="Click to view at full size."> </A>

<p>
<!-- caption --><b>Figure 1-5.</b> <i>The Text editor's Auto List Members feature.</I><!-- /caption -->

<p>Members marked with a brick that has racing stripes (this brick is 
colored magenta on a color display) represent member methods and functions. Two 
racing bricks represent a method or function with more than one implementation. 
Members marked with a brick that doesn't have racing stripes (this brick is colored teal) represent data members.

<p>That process repeats itself upon entering the dot after <I>System.out</I>. After you select the <I>println()</I> method from the list, the Parameter Information feature displays the method arguments as shown in Figure 1-6. Here you can see that I paged down through a list of the 10 <I>println()</I> methods defined for the <I>PrintStream</I> class (the class of <I>out</I>) until I found the one I wanted, in this case the fourth one in the list. This version of the <I>println()</I> method takes a <I>String</I> and returns a <I>void</I> (that is, 
nothing). The parameter information continues to display until I type the close parenthesis.

<p><A HREF="javascript:fullSize('f01gh06x.htm')"> <img src="images/f01gh06.jpg" width=404 height=235 border=0 ALT="Click to view at full size."> </A>

<p>
<!-- caption --><b>Figure 1-6.</b> <i>Method arguments displayed in the Text editor.</I><!-- /caption -->

<p>The Statement Completion feature, which includes the Auto List Members 
and the Parameter Information features, extends to functions you write. As soon as you save your source file, the Text editor adds any methods you have created to the Auto List Members list. If you include /**-style Javadoc comments in front of your functions, the comments appear along with the method name. In addition, as you begin to enter the arguments to the method in the Text editor, the comments following the Javadoc <I>@param</I> appear.

<p>Statement Completion, which includes the Auto List Members and the Parameter Information features, drastically reduces the number of trips you take to the Visual J++ documentation. Java is a small language with a very large class library that is made even larger by the addition of WFC. Being prompted by lists of available data members and methods, along with their arguments, is a great help in programming with Java and WFC.

<A NAME="74"><H3>The Object Browser</H3></A>

<p>Oddly enough, once the Statement Completion list has closed there appears to 
be no way to make it reappear, short of deleting the dot and retyping it. Another 
path to the same functionality is the Object Browser.

<p>To use the Object Browser, you choose Other Windows from the View menu and pick Object Browser from the list. When you type <I>System</I> in the filter box at the top of the browser window and press Enter, the Object Browser searches 
through all members of all packages and returns every class that contains a reference to the word <I>System</I>. Notice that a number of the entries it finds are not what we're looking for. Nonetheless, the correct <I>System</I> class was in the list.

<p>When you select the <I>System</I> class under java.lang, its members are 
displayed in the members pane. Select the object that we're looking for, 
<I>out</I>, and a full description of the object is displayed at the bottom of the Object Browser, as shown in Figure 1-7.

<p><IMG SRC="images/f01gh07.jpg" width=244 height=455 BORDER="0">

<p>
<!-- caption --><b>Figure 1-7.</b> <i>The Object Browser enables you to look for and get detailed class information.</I><!-- /caption -->

<A NAME="75"><H3>The Task List</H3></A>

<p>The Task List window is another extension of the Text editor. The MDE searches 
the comments in Java source files that you are editing for particular keywords. For example, the various wizards put the phrase <I>TODO:</I> in places where they think you need to add code to complete your program.

<p>When the environment finds these keywords, it adds them to the Task List. 
Thus, the Task List is an ongoing list of what is left to be done. Figure 1-8 shows the Task List items for our HelloWorld1 application.

<p><A HREF="javascript:fullSize('f01gh08x.htm')"> <img src="images/f01gh08.jpg" width=404 height=141 border=0 ALT="Click to view at full size."> </A>

<p>
<!-- caption --><b>Figure 1-8.</b> <i>The Task List resulting from the HelloWorld1 application, showing one task left to be done.</I><!-- /caption -->

<p>Double-clicking the <I>TODO</I> item takes you to the proper line within the 
Java source code. (Notice that the <I>TODO</I> shown in Figure 1-8 was left only because I did not edit it out when I added the <I>println()</I> code.)

<p>The Task List contains more than just <I>TODO</I> entries. You are free to add your own entries to the list of comment keywords that the environment is searching for. Compiler errors are added to the Task List as well. In addition, you can display the different types of entries in the Task List independently by right-clicking the Task List window and selecting the type of task you would like to see.

<p>(I don't know if it's just me, but I find the name of the Task List confusing. 
I keep expecting to see a list of the tasks executing under the operating system 
rather than the tasks left for me to do.)

<A NAME="76"><H3>Toolbar customization</H3></A>

<p>In Visual J++, you can customize a toolbar and create new toolbars. To customize a toolbar, first make sure that the toolbar you want to edit is visible by choosing Toolbars from the View menu and selecting the toolbars you want to see. (You can also deselect the toolbars you don't want to see.)

<p>To edit a toolbar, choose Toolbars on the View menu and then select 
Customize. Once the Customize dialog box appears, the toolbars are in edit mode and you can get rid of a tool by simply dragging it off the toolbar. To add a tool to a toolbar, select the Commands tab and find the menu command you want to add. If the command has an icon, drag it from the dialog box to where you want it on the toolbar as shown in Figure 1-9.

<p><IMG SRC="images/f01gh09.jpg" width=372 height=337 BORDER="0">

<p>
<!-- caption --><b>Figure 1-9.</b> <i>Preparing to add the Insert/Remove Breakpoint tool to the Standard toolbar.</I><!-- /caption -->

<p>If the menu command you want to put on a toolbar doesn't have an icon 
associated with it, you can add it to the toolbar anyway. For example, the Close 
command on the File menu doesn't have an icon. Dragging this command to the toolbar produces the not-so-pleasing result shown in Figure 1-10. (Notice the word &quot;Close&quot; between the disk-like icons.)

<p>You can assign a tool an icon from a list of standard icons. With the 
Customize dialog box still open, click the Close tool with the right mouse button. This will display a list of properties that you can set for the icon. Select Change Button Image and a list of standard icons that you can use is displayed. Select the one that appeals to you the most. Figure 1-11 shows my selection.

<p><A HREF="javascript:fullSize('f01gh10x.htm')"> <img src="images/f01gh10.jpg" width=404 height=303 border=0 ALT="Click to view at full size."> </A>

<p>
<!-- caption --><b>Figure 1-10.</b> <i>Adding the Close command initially results in the command's name being on the toolbar.</i><!-- /caption -->

<p><A HREF="javascript:fullSize('f01gh11x.htm')"> <img src="images/f01gh11.jpg" width=404 height=303 border=0 ALT="Click to view at full size."> </A>

<p>
<!-- caption --><b>Figure 1-11.</b> <i>Selecting an icon for the Close command that was added to the Standard toolbar.</I><!-- /caption -->

<p>Once you've selected an image, both the command name and the image 
appear on the toolbar. You might leave it that way for awhile, until you've 
become accustomed to what the image stands for. Eventually you'll want to reclaim the precious toolbar territory by getting rid of the word. To do so, open the Customize dialog box again, right-click the tool, and select Default Style. This will remove the command label, leaving only the icon.

<p>On a toolbar, groups of tools are separated by vertical chisel lines. To add 
a chisel line, you right-click the icon that is to the right of where you want the chisel line. From the drop-down menu, select Begin a Group.

<p>Each of the toolbars can be edited independently. However, my preference 
is to edit one toolbar (generally the Standard toolbar), add all of the tools I find most useful, and leave it visible all the time.

</BODY>
</HTML>




