<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>Freehand Drawing on the Screen</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch09a.htm", "ch09c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="266"><H1>Freehand Drawing on the Screen</H1></A>

<p>Occasionally you will be called upon to write an application that enables the 
user to draw figures freehand. This type of application provides the simplest 
introduction to the use of the <I>Graphics</I> class.

<A NAME="267"><H2>Connecting the Dots</H2></A>

<p>The simplest of all the freehand drawing applications is one we'll call 
ConnectTheDots. In this application, the user is free to click the mouse anywhere within the form. 
With every click of the left mouse button, the ConnectTheDots application draws a 
line between the current position of the mouse pointer and the position of the 
mouse pointer at every previous mouse click. Clicking the right mouse button clears 
the screen to allow the user to start over. Even a simple application such as this 
allows the user to generate some interesting patterns.

<A NAME="268"><H3>The Forms Designer work</H3></A>

<p>Since this application doesn't make use of any Toolbox components, there's 
almost no Forms Designer work to be done. Create the Windows application as you 
would any other Microsoft Visual J++ 6 Windows application, and give it the name 
ConnectTheDots. Change the form's <I>text </I>property to 
<I>Connect the Dots: Click mouse</I>. Then switch the Properties window over to the active properties to add a 
<I>mouseDown</I> event handler and a <I>paint</I> event handler.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
The <I>paint</I> event is only defined for the 
<I>Form</I> class. You can't use the <I>paint</I> event to draw into any other WFC controls.
</blockquote></div>

<A NAME="269"><H3>The code</H3></A>

<p>The code for ConnectTheDots is shown here:

<p><pre>
import com.ms.wfc.app.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;
import com.ms.wfc.html.*;

import com.ms.wfc.util.*;

public class Form1 extends Form
{
    public Form1()
    {
        // Required for Visual J++ Form Designer support
        initForm();
    }

    .
    .
    .

    /**
     * If the left mouse button is pressed, add the point
     * to the draw list. If the right button is pressed, 
     * clear the list.
     */
    List points = new List();
    private void Form1_mouseDown(Object source, MouseEvent e)
    {
        if ((e.button &amp; MouseButton.LEFT) != 0)
        {
            Point mouseLoc = new Point(e.x, e.y);
            points.addItem(mouseLoc);
        }
        if ((e.button &amp; MouseButton.RIGHT) != 0)
        {
            points.setSize(0);
        }
        
        invalidate();
    }

    /**
     * Handle repaints of the form by drawing lines
     * between each of the mouse points in the draw list.
     */
    private void Form1_paint(Object source, PaintEvent e)
    {
        // first draw the kaleidoscope
        Graphics g = e.graphics;
        int length = points.getSize();
        for (int i = 0; i &lt; length; i++)
        {
            for (int j = 0; j &lt; i; j++)
            {
                Point p1 = (Point)points.getItem(i);
                Point p2 = (Point)points.getItem(j);
                
                g.drawLine(p1, p2);
            }
        }
    }

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
    Container components = new Container();

    private void initForm()
    {
        // &#8230;created by the Forms Designer&#8230;
    }

    /**
     * The main entry point for the application. 
     * &#8230;
     */
    public static void main(String args[])
    {
        Application.run(new Form1());
    }
}
</PRE>

<p>Other than the <I>initForm()</I> method, which simply sets the title for the form 
and assigns the two event handlers, the program consists almost entirely of the two 
event handlers, <I>Form1_mouseDown()</I> and 
<I>Form1_paint().</I>

<A NAME="270"><h3>The <I>mouseDown</I> event handler code</h3></A>
<p>The program invokes the method 
<I>Form1_mouseDown()</I> when the user clicks 
either mouse button while the mouse pointer is anywhere in the form. The method 
receives a <I>MouseEvent</I> that contains the location of the mouse within the form at the time 
the mouse button was pressed, and that contains a 
<I>button</I> variable indicating which mouse button was pressed. This variable 
<I>button</I> consists of an OR combination of the 
fields <I>LEFT</I>, <I>MIDDLE</I>, and 
<I>RIGHT</I> of the enumeration class 
<I>MouseButton</I>. Thus, if<I> </I>the<I> 
MouseButton.LEFT</I> bit is set in 
<I>e.button,</I> the left mouse button was clicked. 
(More accurately, if the <I>MouseButton.LEFT</I> button bit is set, the left mouse button was 
clicked or was being held down at the same time that some other mouse button was 
clicked. The distinction isn't important for most applications.)

<P>If<I> Form1_mouseDown()</I> determines that the left mouse button was clicked, 
the method creates a <I>Point</I> object to store the mouse location and adds the object to a 
list of mouse locations called <I>points</I>. If it was the right mouse button that was 
pressed, <I>Form1_mouseDown()</I> clears out the list of mouse locations by setting the size of 
<I>points</I> to 0. This gives the user a way to start over. Either way, 
<I>Form1_mouseDown()</I> finishes by calling the method 
<I>invalidate() </I>to display the results.

<A NAME="271"><h3>What's <I>invalidate()</I>?</h3></A>
<p>Calling the <I>invalidate()</I> method tells WFC that the 
<I>Form</I> object's display is now invalid and must be repainted.
WFC asks the object to repaint itself by generating 
a paint event, which is handled in this program by 
<I>Form1_paint()</I>. The paint event is WFC's way of asking the
application to re-create the window.

<div class="note"><blockquote><b>NOTE</b><hr>Even beginning Microsoft Visual C++ programmers will 
recognize the <I>invalidate()</I> method immediately. The only difference
between the way 
Visual J++ 6 and other Microsoft Visual Studio languages handle the 
invalidation is that under Visual J++, the paint request is processed by means of an 
event to the form. Experienced Microsoft Windows programmers will probably want 
to skip over the following explanation of the paint event code.</blockquote></div>


<p>There are a lot of other ways besides mouse clicks that the display might 
become invalid. When the window of some other application obscures the 
window of your application, for example, Windows loses the information contained
in the obscured portion. If that portion of the window later becomes visible, the 
window is invalid and your application needs to redraw it. Or, the user might have 
minimized the form and now requests that it be displayed. Even simply resizing the 
form to make it larger results in a display that is at least partially invalid and needs 
to be re-created by the application.

<p><div class="sidebar"><blockquote>
<p><b>ISN'T THE INVALIDATE-PAINT MECHANISM OVERLY COMPLICATED?</b><hr>
This mechanism of generating a paint event whenever the window needs 
refreshing seems overly-complicated. Isn't there some other approach to 
refreshing the display? In fact, there is.

<p>The problem we have to deal with is that when an application's 
window is obscured on the screen, Windows loses some information. To avoid this, 
rather than write to the real screen, our application could write to a virtual screen 
that is maintained by the operating system. In this virtual world, each window 
would be maintained individually on its own virtual screen. In this virtual world, 
the application's window would never be overwritten by some other window 
because it would always be separate.

<p>The operating system would have to combine these virtual screens 
onto the single, real screen that the user sees. If a window were minimized, it 
would be the job of the operating system to figure out which pieces of which 
virtual windows would be needed to properly update the real screen.

<p>Microsoft Windows doesn't use the virtual screen approach, 
however. Why?

<p>There are several problems with the virtual screen proposal. The first 
issue is that it requires large amounts of memory. Each virtual screen must 
be maintained in RAM that, for speed reasons, can't be swapped to disk. 
Modern, high-resolution, multicolor screen displays can each consume 2 MB of
memory or more. Today, when memory is cheap, this isn't much of a problem; 
but Windows was designed in an era when memory was more expensive. 
(Many people don't remember that the earliest versions of Windows were 
designed so that, together with the applications, a total of 640 KB of memory was 
used.) Even today, it seems wasteful to consume 16 MB or more of nonswappable 
RAM just to maintain windows that aren't even visible.

<p>A second problem is performance. This copying of potentially 
large amounts of memory could result in slow display performance. Consider, 
for example, the most common case of an application writing to a completely 
visible window. Using the virtual screen scenario, Windows would have to 
write every pixel twice: first when the application wrote to the virtual screen, and 
again when the operating system copied the window from there to the real 
screen. With the approach that Windows uses, a window need only be written 
once to the real screen.

<p>Finally, there is the issue of scheduling. Windows gives the paint 
event the lowest event priority (other than the idle event, which we'll discuss in 
the next chapter). If the application receives any other event notification, that 
event will occur before the paint event. This type of scheduling avoids needless 
repaints, which would be much harder to avoid using the virtual screen method.

<p>For example, maximizing the size of Microsoft Internet Explorer not 
only displays images or parts of images that might not previously have been 
visible on the display, it also causes the browser to reformat text to fully utilize the 
additional display area. Windows doesn't repaint the browser window until 
all updates caused by the resizing have been processed. Using the virtual 
screen method, it would be very difficult to avoid updating the real screen from 
the virtual screen multiple times and thereby wasting CPU cycles.
</blockquote></div>

<A NAME="272"><H3>The paint event code</H3></A>

<p>The <I>Form1_paint()</I> method is fairly simple. The first thing that all 
<I>paint()</I> methods must do is retrieve the 
<I>Graphics</I> object from the <I>PaintEvent</I> object. This 
done, <I>Form1_paint()</I> looks at the list of mouse down locations saved in the 
<I>points </I>variable. If this list is empty, which it will be when the program is first displayed, the 
method does nothing.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
One of the most common mistakes programmers make in writing 
paint event methods is this: they forget that the operating system sends a paint 
event to the application as soon as the 
<I>Form1</I> constructor finishes, which is long 
before the user generates the first input event.
</blockquote></div>

<p>If the <I>points</I> variable's list isn't empty, the 
<I>Form1_paint()</I> method iterates through each point in the list, using the 
<I>Graphics.drawLine()</I> method to draw a line between each pair of points in the list. Figure 9-1 shows the 
ConnectTheDots program display after the user selected four points in a somewhat
square pattern. Figure 9-2 shows just one of the interesting combinations the
user can create with a small number of points.

<p><img src="images/F09gh01.JPG" width=297 height=275 border="0">
<p><!-- caption --><B>Figure 9-1.</b> <i>The ConnectTheDots display with
four points.</I><!-- /caption -->

<p><img src="images/F09gh02.JPG" width=275 height=255 border="0">
<p><!-- caption --><b>Figure 9-2.</b> <i>The ConnectTheDots program generating an
interesting display with as few as eight points.</i><!-- /caption -->

<A NAME="273"><h3>What's a <I>Graphics</I> object?</h3></A>
<p>The <I>Graphics</I> object is the Visual J++ interface between the application and the 
display hardware. The <I>Graphics</I> object defines numerous draw methods, which 
the application uses to draw on the screen.

<div class="note"><blockquote><b>NOTE</b><hr>
The Visual J++ <I>Graphics</I> object corresponds to the Microsoft Foundation
Classes (MFC) <I>HDC</I> class, which is known as the device context.
</blockquote></div>

<p>It's the responsibility of the <I>Graphics</I> object to handle differences 
between different types of hardware. Thus, your application doesn't need to worry about 
the screen resolution or the number of colors that a particular system can support. If 
a video card contains special hardware to increase display performance, the 
<I>Graphics </I>object also handles this hardware.

<p>In addition, it's the job of the 
<I>Graphics</I> object to know where your 
application's window is being displayed on the screen. All coordinates that you supply in 
your application are relative to the upper-left corner of the window. The 
<I>Graphics</I> object also makes sure that the application doesn't draw outside of its window. The 
<I>Graphics</I> object maintains the integrity of the window's display.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
Most, if not all, of the graphics display chores are not actually 
performed by the <I>Graphics</I> object. Instead, most of these chores are actually handled 
by Windows or one of its device drivers, but this detail is unimportant. To Visual 
J++ programmers, the <I>Graphics</I> object is the only interface to the Windows 
device context and the display API.
</blockquote></div>

<A NAME="274"><H2>The FreeDraw Application</H2></A>

<p>The ConnectTheDots application can generate interesting displays with a 
relatively small amount of code, but it doesn't represent a very useful application. The 
following FreeDraw application, which allows the user to generate freehand drawings, 
is much more useful.

<p>FreeDraw allows the user to draw varied patterns with the mouse. Each 
pattern (which I'll refer to as a <I>squiggle</I>) begins with the user dragging the mouse 
pointer with the left mouse button pressed and terminates with the user releasing the 
mouse button. Once the squiggle has been generated, the user can modify its color and 
width by means of menu commands. When the user starts a new squiggle, he or she 
can't change previous squiggles. Right-clicking the mouse erases all stored squiggles, 
effectively erasing the slate.

<A NAME="275"><H3>The Forms Designer work</H3></A>

<p>To create FreeDraw, begin by creating a standard Visual J++ Windows 
application. Set the <I>text</I> property of the form to 
<I>FreeDraw,</I> to match the application name.

<p>Add a main menu to the form. Add two main menu items; label the first 
<I>Color</I> and the second <I>Width</I>. Add to the Color menu item several submenu items 
labeled with the names of some of the fields of the 
<I>Color</I> class, for example <I>BLACK</I>, 
<I>AQUA</I>, and <I>GREEN</I>. Create submenu items under the Width menu with labels 
indicating various line widths in pixels: <I>1</I>, 
<I>2</I>, <I>4</I>, and <I>8</I>.

<A NAME="276"><h3>The <I>Squiggle</I> class code</h3></A>
<p>As is often the case, the code for the main program is made easier by creating a 
helper class. The <I>Squiggle</I> class describes a squiggle on the screen. The Squiggle.java 
file contains the following code:

<p><pre>
import com.ms.wfc.ui.*;
import com.ms.wfc.util.*;

public class Squiggle
{
    // two fundamental drawing properties
    Color color;
    int   width;

    // a pen containing the selected properties
    Pen   pen;
 
    // the points in this squiggle
    List  points = new List();

    /**
     * Create a black squiggle with no points.
     */
    public Squiggle()
    {
        // set the initial color and width
        color = Color.BLACK;
        width = 1;
        
        // convert the properties into a pen
        calcPen();
        
        // make sure the list is empty
        points.setSize(0);
    }
 
    /**
     * Set the color of the squiggle.
     */
    public void setColor(Color color)
    {
        this.color = color;
        calcPen();
    }
 
    /**
     * Set the width of the squiggle.
     */
    public void setWidth(int width)
    {
        this.width = width;
        calcPen();
    }
    
    /**
     * Add a point to the squiggle.
     */
    public void addPoint(int x, int y)
    {
        points.addItem(new Point(x, y));
    }
    
    /**
     * Create a solid pen with the specified width and color.
     */
    private void calcPen()
    {
        pen = new Pen(color, PenStyle.SOLID, width);
    }

    /**
     * Return the current Pen for this squiggle.
     */
    public Pen getPen()
    {
        return pen;
    }
    
    /**
     * Return the number of points in this squiggle.
     */    
    int getSize()
    {
        return points.getSize();
    }
    
    /**
     * Return a point in this squiggle list.
     */
    Point getPoint(int index)
    {
        return (Point)points.getItem(index);
    }
}
</PRE>

<p>A squiggle consists of a list of points representing mouse pointer locations 
and a <I>Pen</I> object to use in drawing between these points. The list is maintained in an 
object of type <I>List</I> called <I>points</I>. The 
<I>Pen</I> object is named <I>pen</I>. For our purposes, 
<I>Pen</I> has only the properties of color and width. (There are other properties that you can 
set for a <I>Pen</I> object.) The <I>color</I> variable stores the 
<I>color </I>property setting, and the 
<I>width</I> variable stores the <I>width </I>property setting.

<p>The constructor for <I>Squiggle</I> creates a black 
<I>pen</I> object one pixel wide and an empty list. The next methods, 
<I>setColor()</I> and <I>setWidth()</I>, allow the application 
to change the pen object's properties. Both of these methods call the private 
method <I>calcPen()</I> to reflect the new color and width in a newly created 
<I>pen</I>. The method <I>addPoint(x, y) </I>creates a 
<I>Point</I> object from the x and y coordinates that are 
passed to the method as parameters. The method then adds this 
<I>Point</I> object to the list of points.

<p>The <I>Squiggle</I> class provides query functions, such as 
<I>getPen()</I> to return the current <I>pen </I>object, 
<I>getSize()</I> to return the size of the list, and 
<I>getPoint(i)</I> to return the <I>Point</I> object at index 
<I>i</I> in the <I>points</I> list.

<A NAME="277"><H3>The FreeDraw code</H3></A>

<p>The remaining FreeDraw code is retained in the 
Form1<I>.</I>java source file:

<p><pre>
import com.ms.wfc.app.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;
import com.ms.wfc.html.*;

import com.ms.wfc.util.*;
import java.lang.reflect.*;

public class Form1 extends Form
{
    public Form1()
    {
        // Required for Visual J++ Form Designer support
        initForm();
    }

    /**
     * Handle the mouse down event by creating a current list.
     */
    List oldLists = new List();
    Squiggle currentList = null;
    private void Form1_mouseDown(Object source, MouseEvent e)
    {
        // if left mouse button&#8230;
        if ((e.button &amp; MouseButton.LEFT) != 0)
        {
            // create a new squiggle list; 
            // if there is an old one, add it to the
            // list of lists
            if (currentList != null)
            {
                oldLists.addItem(currentList);
            }
            currentList = new Squiggle();
        }
        
        // if right mouse button&#8230;
        if ((e.button &amp; MouseButton.RIGHT) != 0)
        {
            // start over
            currentList = null;
            oldLists.setSize(0);
            invalidate();
        }
    }

    /**
     * Handle the mouse move event by adding the current
     * mouse pointer location to the current squiggle.
     */
    private void Form1_mouseMove(Object source, MouseEvent e)
    {
        // if right mouse button is not down, ignore it
        if ((e.button &amp; MouseButton.LEFT) == 0)
        {
            return;
        }
        
        // now record the current mouse pointer position
        currentList.addPoint(e.x, e.y);
        
        // and repaint the screen
        invalidate();
    }

    /**
     * Handle the repaint event.
     */
    private void Form1_paint(Object source, PaintEvent e)
    {
        // paint the current squiggle
        Graphics g = e.graphics;
        if (currentList != null)
        {
            drawList(g, currentList);
        }
        
        // now paint the previous squiggles as well
        IEnumerator ie = oldLists.getItemEnumerator();
        while(ie.hasMoreItems())
        {
            Squiggle list = (Squiggle)ie.nextItem();
            drawList(g, list);
        }
    }

    /**
     * Draw squiggle by connecting the dots.
     */
    static void drawList(Graphics g, Squiggle list)
    {
        g.setPen(list.getPen());
        int length = list.getSize() - 1;
        for(int i = 0; i &lt; length; i++)
        {
            g.drawLine(list.getPoint(i), list.getPoint(i + 1));
        }
    }
    
    private void colorItem_click(Object source, Event e)
    {
        try
        {
            // read the menu item's label&#8230;
            MenuItem mi = (MenuItem)source;
            String s = mi.getText();
            
            // convert that to one of the fields in Color&#8230;
            Class c = Color.class;
            Field f = c.getField(s);
            Color color = (Color)f.get(null);
            
            // and set the current squiggle's color
            currentList.setColor(color);
            invalidate();
        }
        catch(Exception ex)
        {
        }
    }
    
    private void widthItem_click(Object source, Event e)
    {
        // read the menu item's label&#8230;
        MenuItem mi = (MenuItem)source;
        String s = mi.getText();
        
        // convert that to a number&#8230;
        int width = Integer.parseInt(s);
        
        // and set the width
        currentList.setWidth(width);
        invalidate();
    }

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
    Container components = new Container();
    MainMenu mainMenu1 = new MainMenu();
    MenuItem menuItem12 = new MenuItem();
    MenuItem menuItem11 = new MenuItem();
    MenuItem menuItem4 = new MenuItem();
    MenuItem menuItem5 = new MenuItem();
    MenuItem menuItem6 = new MenuItem();
    MenuItem menuItem7 = new MenuItem();
    MenuItem menuItem8 = new MenuItem();
    MenuItem menuItem9 = new MenuItem();
    MenuItem menuItem10 = new MenuItem();

    private void initForm()
    {
        // &#8230;created by the Forms Designer&#8230;
    }

    /**
     * The main entry point for the application. 
     * &#8230;
     */
    public static void main(String args[])
    {
        Application.run(new Form1());
    }
}
</PRE>

<p>The <I>Form1</I> class maintains two data members. The current squiggle is 
maintained in a field named <I>currentList</I>. This is the 
<I>Squiggle</I> object that the user is currently creating or has just created. This is the only squiggle whose color and 
width can be modified. The variable 
<I>oldLists</I> consists of a list of the previously 
drawn squiggles.

<p>The method <I>Form1_mouseDown()</I> is essentially two methods in one. If the 
user presses the left mouse button, the method adds the current squiggle&#8212;if there is 
one&#8212;to the list of old squiggles before creating a new current squiggle. When the 
right mouse button is pressed, the method zeros the 
<I>currentList</I> pointer to remove the current squiggle and then zeros out the old squiggle list by calling 
<I>oldLists.setSize(0)</I>. The call to 
<I>invalidate()</I> repaints the form with the lists removed, thereby clearing 
the window.

<p>The <I>Form1_mouseMove()</I> method handles the mouse drag event by adding 
the current mouse pointer location to the current squiggle. The call to 
<I>invalidate()</I> repaints the display with the new mouse pointer location added.

<p>The repaint method <I>Form1_paint()</I> first draws the 
<I>currentList </I>object by calling the local method 
<I>drawList()</I>. It then iterates through the list of older 
squiggles, drawing each using <I>drawList()</I>.

<p>The method <I>drawList()</I> draws a squiggle. It begins by getting the pen 
stored in the <I>Squiggle</I> object and using that pen's settings to set the pen in the 
<I>Graphics</I> object. It then uses a <I>for</I> loop to iterate through the points contained in the 
<I>Squiggle</I> object, calling 
<I>Graphics.drawLine()</I> to draw a line between each stored mouse 
pointer location (<I>i</I>) and the next (<I>i + 
1</I>). Since the mouse pointer locations stored by 
the <I>mouseMove()</I> method are relatively close together, 
<I>drawList()</I> provides a relatively smooth-looking curve, especially with some of the wider pens.

<p>The <I>colorItem_click()</I> method handles the click event for each of the Color 
menu items. This method uses Java's language reflection capability (discussed in 
<A HREF="ch06a.htm">Chapter 6</A>) to find the static member of the 
<I>Color</I> object with the same name as the menu 
item. It calls <I>setColor()</I> to establish this color as the color of the current squiggle 
before calling <I>invalidate()</I> to make the new color visible by repainting the screen. 
(Remember to attach <I>colorItem_click()</I> as the click event for all the Color submenu items.)

<p>The <I>widthItem_click()</I> method uses a similar approach in handling the 
Width menu items. The label on the menu item is converted from a string into a 
number using the <I>Integer.parsetInt()</I> method. This integer value is used to adjust the pen 
width of the current squiggle by calling 
<I>setWidth()</I>. The call to <I>invalidate()</I> makes the 
change visible. (Remember to attach 
<I>widthItem_click()</I> as the click event for all the 
Width submenu items.)

<p>Figure 9-3 shows an image drawn with FreeDraw.

<P><img src="images/F09gh03.JPG" width=290 height=285 border="0">
<P><!-- caption --><B>Figure 9-3.</b> <i>A figure drawn with FreeDraw, showing the highways
in and around my hometown.</I><!-- /caption -->

</BODY>
</HTML>




