<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>Drawing Text</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch09b.htm", "ch09d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="278"><H1>Drawing Text</H1></A>

<p>Just as you might find yourself with the need to draw arbitrary shapes to forms, 
be they handwritten or not, you might also be called upon to output text. 
Presenting output text to the user in a WFC component environment is easy. You just place 
an Edit or RichEdit control somewhere on the form, mark it single or multiline, and 
you're ready to write to it whatever text you want. In an environment ruled by the 
<I>Graphics</I> object and the paint event, displaying this text means drawing the text on 
the window. Drawing text is a little harder than simply writing it.

<A NAME="279"><H2>Drawing a Single Line</H2></A>

<p>As long as all you are trying to do is draw a simple line of text, using a single 
font all written at one time, the problem isn't too difficult. It's still useful to divide 
this application up into the task of drawing a single line and the task of drawing 
multiple lines.

<A NAME="280"><H3>Drawing in a fixed location</H3></A>

<p>The following simple program, HelloWorld, draws a single line of 
text&#8212;&quot;Hello, world&quot;&#8212;in a fixed location on the form. In the Forms Designer, set the form's 
title to match the name of the program and set 
<I>Form1_paint()</I> to handle the form's paint event.
The remaining code appears as follows:

<p><pre>
import com.ms.wfc.app.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;
import com.ms.wfc.html.*;

public class Form1 extends Form
{
    public Form1()
    {
        // Required for Visual J++ Form Designer support
        initForm();
    }

    private void Form1_paint(Object source, PaintEvent e)
    {
        Graphics g = e.graphics;
        
        g.drawString(&quot;Hello, world&quot;, 80, 40);
    }

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
    Container components = new Container();

    private void initForm()
    {
        // &#8230;created by the Forms Designer&#8230;
    }

    /**
     * The main entry point for the application. 
     * &#8230;
     */
    public static void main(String args[])
    {
        Application.run(new Form1());
    }
}
</PRE>

<p>This program is very simple. Each time the paint event is generated, 
the <I>Form1_paint()</I> method invokes the <I>drawString(String, x, 
y)</I> method to draw the string &quot;Hello, world&quot;. The upper left corner of the string is 80 pixels from the left edge 
of the form's drawing area (the x offset), and 40 pixels from the top (the y offset). 
This is demonstrated in the edited output from the program shown in Figure 9-4.

<P><img src="images/F09gh04.JPG" width=301 height=138 border="0">
<P><!-- caption --><B>Figure 9-4.</b> <i>The edited &quot;Hello, world&quot; output, showing the meaning of the 
x and y offsets.</I><!-- /caption -->

<A NAME="281"><H3>Drawing in a variable location</H3></A>

<p>If you look closely at Figure 9-4, you'll notice that the &quot;Hello, world&quot; string 
appears approximately in the center of the form window and is appropriately sized for 
that window. This was no accident; I resized the window to make this so. 
However, suppose we want the text to be centered in the display window and be 
appropriately sized no matter what size the window is.

<p>The following additions to 
HelloWorld<I>.</I>java do exactly that.

<p><pre>
import com.ms.wfc.app.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;
import com.ms.wfc.html.*;

public class Form1 extends Form
{
    public Form1()
    {
        // Required for Visual J++ Form Designer support
        initForm();
    }

 <B>String outString = &quot;Hello, world&quot;;
    Point  center    = new Point();
    Point  offset    = new Point();
    Point  outOffset = new Point();</B>
    private void Form1_paint(Object source, PaintEvent e)
    {
        Graphics g = e.graphics;
        
     <B>// calculate the proper position for the string
        // based on the size of the form and the
        // size of the string in the current font--
        // calculate the center of the form
        Rectangle formSize = this.getDisplayRect();
        center.x = formSize.width  / 2;
        center.y = formSize.height / 2;
        
        // to center the string, back up half the length
        // of the string and half of its height
        Point stringSize   = g.getTextSize(outString);
        offset.x = stringSize.x / 2;
        offset.y = stringSize.y / 2;
        
        // now output the string at the center
        // minus the offset
        outOffset.x = center.x - offset.x;
        outOffset.y = center.y - offset.y;</B>
        g.drawString(<B>outString, outOffset</B>);
    }
    <B>
    private void Form1_resize(Object source, Event e)
    {
        // find the size of the display area of the form
        Rectangle size = this.getDisplayRect();
        
        // get a font size that's about 1/3
        // the vertical size of the form
        int fontHeight = size.height / 3;
        Font oldFont = this.getFont();
        Font newFont = new Font(oldFont, 
                                fontHeight, 
                                FontSize.PIXELS);
        
        // make this new font (if there is one) the default
        // font for the form
        if (newFont != null)
        {
            this.setFont(newFont);
        }
    }</B>

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
    Container components = new Container();

    private void initForm()
    {
        // &#8230;created by the Forms Designer&#8230;
    }

    /**
     * The main entry point for the application. 
     * &#8230;
     */
    public static void main(String args[])
    {
        Application.run(new Form1());
    }
}
</PRE>

<p>From the Forms Designer, we set the 
<I>Form1_resize()</I> method to handle the form's resize event. This method's job is to create a font that is proportional in size to the window. To do this, 
<I>Form1_resize()</I> first calls 
<I>getDisplayRect()</I> to find out how big the form's display area is. It then creates 
<I>newFont,</I> which is like the old font 
in every way except that its height is one-third the height of the form's display 
area. (One-third was chosen after a very short trial of different values and isn't based on 
any human response data. In other words, pick whatever size factor you 
prefer.) <I>Form1_resize()</I> then sets this new font to be the default font for the form.

<p>The added code in the <I>Form1_paint()</I> method makes that method 
considerably more complicated than the previous version was. It must calculate the x and 
y offsets to use in displaying the string, based on the size of the form's displayable 
area and the size of the string in the current font.

<p><I>Form1_paint() </I>starts by getting the form's displayable area. It then 
calculates the coordinates of the center of the screen by dividing the height and width by 
2. The result is stored in the variable 
<I>center</I>.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
You might wonder why most of the local variables of 
<I>Form1_paint()</I> are created as data members of the class even though they are only used locally 
to the method. Methods such as 
<I>Form1_paint()</I> are called often, and they need 
to execute as fast as possible. Allocating variables such as 
<I>center</I> once at the beginning of the program and reusing them, rather than reallocating and 
then abandoning them every time the method is called, can save a 
considerable amount of execution time.
</blockquote></div>

<p>The <I>Form1_paint()</I> method must then find out how large the &quot;Hello, 
world&quot; string is in the current font. Fortunately, the 
<I>Graphics</I> class provides just such a method in 
<I>getTextSize()</I>. Given a string, this method returns a 
<I>Point</I> representing the height and width (in pixels) of the string in the current font. Since we want the center 
of the string to align with the center of the display area, 
<I>Form1_paint()</I> must divide this 
<I>stringSize</I> value by 2 as well. The result is stored in 
<I>offset</I>.

<p>Subtracting <I>offset</I> from <I>center</I> gives the coordinates of where 
<I>Form1_paint()</I> should draw the string so that it's correctly centered both vertically and 
horizontally. Figure 9-5 demonstrates graphically how this works.

<P><img src="images/F09gh05.JPG" width=356 height=247 border="0">
<P><!-- caption --><B>Figure 9-5.</b> <i>A diagram demonstrating the offsets that 
</I>Form1_paint()<I> uses to center 
the &quot;Hello, world&quot; text in the form window.</I><!-- /caption -->

<P>Figures 9-6 and 9-7 show the output of this program with various window 
sizes. These figures demonstrate that both the font sizing and centering algorithms 
work as desired.

<P><img src="images/F09gh06.JPG" width=196 height=75 border="0">
<P><!-- caption --><B>Figure 9-6.</b> <i>A small form window results in a small font.</I><!-- /caption -->

<P><img src="images/F09gh07.JPG" width=401 height=235 border="0">
<P><!-- caption --><B>Figure 9-7.</b> <i>A large form window results in a large, heavy font that is
still centered.</I><!-- /caption -->

<p><div class="sidebar"><blockquote>
<p><b>ISN'T THERE AN EASIER WAY TO POSITION TEXT?</b><hr>
<P>When drawing text, you'll often be tempted to take this shortcut: &quot;There are 
10 characters in my output string and each character is 
<I>x</I> pixels wide, therefore the string is 10 times 
<I>x</I> pixels wide.&quot; Unfortunately, this logic doesn't work.

<P>The problem with this solution lies in one of its assumptions. In 
general, each character isn't <I>x</I> pixels wide. Most fonts are called proportional 
fonts, meaning each character has a different width. By just reading this page, it 
should be obvious to you that capital W is given considerably more space than 
lower- case i. Other characters fall somewhere in between.

<P>This being true, how does the 
<I>Graphics.getTextSize()</I> method calculate the width of a given string? Each font provides a table that lists the width of 
each character. The <I>getTextSize()</I> method iterates through the string you give it, 
adding up the widths of each character until it arrives at the width of the entire string.

<P>There are a few fonts in which all characters are allocated the same 
width. These fonts are called monospace or nonproportional fonts and include 
such fonts as Courier. Monospace fonts are used in applications where you want 
the characters from different rows to line up in columns; most commonly this is 
in code listings. (Look closely at the code listings in this book and you'll 
notice that the characters from different rows align.)

<P>Both proportional fonts and monospace fonts allocate the same 
amount of vertical space to each character. This isn't to say that the character uses 
the entire vertical space. Clearly, a capital letter uses more space than a little 
letter such as an a. However, we as readers really want the bottoms of characters 
on the same row to line up across the page. (Characters that have descenders, 
like g, p, q, and y, represent a special case).

<P>Thus, whether the font is monospace or proportional, we can still 
calculate the vertical offset by multiplying the number of lines times the vertical 
size of a single line.
</blockquote></div>

<A NAME="282"><H2>Drawing Multiple Lines</H2></A>

<p>You'll often be called upon to draw multiple lines of text. There are two cases 
that arise. The simpler case is that of drawing multiple rows of left-justified text. A 
more complicated case involves drawing multiple columns.

<A NAME="283"><H3>Left-justified text</H3></A>

<p>Drawing multiple rows of left-justified text is just a matter of keeping straight 
what line you're drawing to and how tall your font is. Let me use a previous 
example program to demonstrate.

<p>In the ConnectTheDots program presented at the beginning of this chapter, 
it would be interesting to display the coordinates of each dot. The information 
the application needs to draw in ANSI text from the coordinates of the dots is 
available in the <I>paints</I> list already. The following modifications, shown in boldface, to 
the <I>Form1_paint()</I> method in ConnectTheDots is therefore all that's needed to 
implement this change.

<p><pre>
/**
 * Handle repaints of the form by drawing lines
 * between each of the mouse points in the draw list<B>
 * and drawing the coordinates of the mouse points as
 * text.</B>
 */
private void Form1_paint(Object source, PaintEvent e)
{
    // first draw the kaleidoscope
    Graphics g = e.graphics;
    int length = points.getSize();
    for (int i = 0; i &lt; length; i++)
    {
        for (int j = 0; j &lt; i; j++)
        {
            Point p1 = (Point)points.getItem(i);
            Point p2 = (Point)points.getItem(j);
                
            g.drawLine(p1, p2);
        }
    }
    
 <B>// now output the coordinates of the points as text:
    // get the height of the current font
    String s = &quot;Number of points = &quot; + length;
    Point size = g.getTextSize(s);
    int height = size.y;
        
    // loop through the points stored in the list, drawing
    // each as a String;
    // start at vertical offset 10 and increment by the 
    // font height plus 2 every line thereafter
    int y = 10;
    g.drawString(s, 10, y);
    for (int k = 0; k &lt; length; k++)
    {
        Point p = (Point)points.getItem(k);
        y += (height + 2);
        g.drawString(p.toString(), 10, y);
    }</B>
}
</PRE>

<p>The kaleidoscope section of 
<I>Form1_paint()</I> is unchanged from the earlier 
version. We have added a section to draw, in text format, the coordinates stored in 
the <I>points</I> list. This section begins by constructing a string 
<I>s</I> consisting of the phrase &quot;Number of points = x&quot; where x is the number of members in 
<I>points</I>. The method then uses the 
<I>Graphics.getTextSize()</I> method to find the height of this string. This 
value is stored in the variable <I>height</I>.

<p>Since <I>Form1_paint()</I> doesn't change fonts, it makes the assumption that 
the height of this line is the same as the height of every subsequent line. (See the 
previous sidebar &quot;Isn't There an Easier Way to Position Text?&quot;.)

<p>Once this height has been captured, 
<I>Form1_paint()</I> displays the string at 
location {10, 10}. It then iterates through the list 
<I>points</I> calling <I>getItem()</I> to return 
each subsequent <I>Point</I> object. At each pass through the list, 
<I>Form1_paint()</I> increments the vertical offset 
<I>y</I> by <I>height + 2</I>, which is the height of a line in the current font plus 
a small increment of 2, to increase the interline spacing to improve the 
appearance. Finally, the method outputs the 
<I>Point</I> object in <I>String</I> format at the calculated 
vertical offset. Using the same horizontal offset of 10 ensures that all the lines are 
left-justified.

<p>Figure 9-8 demonstrates the result of this addition to ConnectTheDots.

<p><img src="images/F09gh08.JPG" width=320 height=240 border="0">
<P><!-- caption --><B>Figure 9-8.</b> <i>Additions to 
</I>Form1_paint()<I> result in the textual display of 
the </I>mouseDown<I> points.</I><!-- /caption -->

<A NAME="284"><H3>Concatenating text</H3></A>

<p>Occasionally the programmer is asked to concatenate two strings on the 
display. Obviously the easiest approach is to concatenate the strings before drawing 
them; however, in some cases this isn't possible.

<p>To demonstrate how to approach such problems, let's add one more level 
of complexity to the ConnectTheDots program. Clearly, if the user clicks many dots, 
the vertical string of text will eventually trail off the bottom of the window. To avoid 
this, suppose we make the restriction that each column of text should contain no 
more than six rows. The coordinates of the seventh point should appear on the first 
row but begin a new column. Rather than align the second column at a specific 
location as we did with the first column, however, we want the seventh string to 
display immediately to the right of the first string.

<p>The following update to <I>Form1_paint()</I>, again shown in boldface, 
implements this new requirement. (By the way, I'm not suggesting that this is the best 
solution, but merely that this solution demonstrates how to concatenate strings on the display.)

<p><pre>
/**
 * Handle repaints of the form by drawing lines
 * between each of the mouse points in the draw list
 * and drawing the coordinates of the mouse points as
 * text.
 */<B>
int[] horizontalOffset = new int[6];</B>
private void Form1_paint(Object source, PaintEvent e)
{
    // first draw the kaleidoscope
    Graphics g = e.graphics;
    int length = points.getSize();
    for (int i = 0; i &lt; length; i++)
    {
        for (int j = 0; j &lt; i; j++)
        {
            Point p1 = (Point)points.getItem(i);
            Point p2 = (Point)points.getItem(j);
                
            g.drawLine(p1, p2);
        }
    }
        
 <B>// clear out the horizontal offset of each row --
    // start the first row 10 pixels from the left edge
    int maxRows = horizontalOffset.length;
    for (int i = 0; i &lt; maxRows; i++)
    {
        horizontalOffset[i] = 10;
    }</B>
 
    // now output the coordinates of the points as text;
    // get the height of the current font
    String s = &quot;Number of points = &quot; + length;
    Point size = g.getTextSize(s);
    int height = size.y;<B>
    g.drawString(s, 10, 10);</B>
        
    // loop through the points stored in the list, drawing
    // each as a String;
    // start at an initial vertical offset just beyond
    // the first string, an index of 0 and a rowNumber of 0
 <B>int initialVO = 15 + height;
    for (int k = 0, rowNumber = 0, verticalOffset = initialVO;
         k &lt; length;
         k++, rowNumber++, verticalOffset += (height + 2))
    {
        // if the row number exceeds the maximum number of rows&#8230;
        if (rowNumber &gt;= maxRows)
        {
            // then reset the row number and vertical offset
            rowNumber = 0;
            verticalOffset = initialVO;
        }
            
        // get the point, and convert it to a string
        Point p = (Point)points.getItem(k);
        s = p.toString();
            
        // draw the string at the proper horizontal and
        // vertical offsets for this row
        g.drawString(s, 
                     horizontalOffset[rowNumber],
                     verticalOffset);
            
        // update the horizontal offset by the width of this
        // string so the next column will appear in the proper
        // place
        horizontalOffset[rowNumber] += g.getTextSize(s).x;
    }</B>
}
</PRE>

<p>This new version of <I>Form1_paint()</I> maintains an array of six integers 
named <I>horizonalOffset</I>, representing the current horizontal offset of each row. Before 
beginning calculations, the method initializes each member of the 
<I>horizontalOffset</I> array to <I>10</I>. This will force each row to begin 10 pixels from the left edge of the display.

<p>Before beginning to display the <I>Point</I> objects stored in the 
<I>points</I> list, <I>Form1_paint()</I> calculates an initial vertical offset and stores it in the variable 
<I>initialVO</I>. This will become the offset of the first row.

<p>The method then enters the same <I>for</I> loop as before, this time initializing 
the <I>rowNumber</I> to <I>0</I>, the current 
<I>verticalOffset</I> to <I>initialVO,</I> and the index 
<I>k</I> to <I>0</I>. Within the <I>for</I> loop, the program tests whether the 
<I>rowNumber</I> exceeds the maximum number of rows, in our case 6. If it does, the program resets the 
<I>rowNumber</I> to <I>0</I> and resets the 
<I>verticalOffset</I> back to the initial vertical offset, 
<I>initialVO</I>. This has the 
effect of moving output to the top row of the next column.

<p>Once the program has determined the proper row and column to begin the 
next string, it retrieves the correct <I>Point</I> object from the 
<I>points</I> list and converts it to a text 
<I>String</I> as before. The program then draws the string beginning at the 
calculated horizontal and vertical offsets.

<p>Before repeating the loop, the program increments the 
<I>horizontalOffset</I> of this <I>rowNumber</I> by the length in pixels of the current string. The repeat clause of the 
<I>for</I> loop increments the <I>rowNumber</I> by one, the 
<I>verticalOffset</I> by the height of a row (plus 2), and the index 
<I>k</I> by one.

<p>As you can see, the key addition to this program is the array 
<I>horizontalOffset</I>. If you consider just one row, say row 0, 
<I>horizontalOffset[0]</I> starts off with the 
value 10. After drawing the first string, 
<I>horizontalOffset[0]</I> is equal to 10 plus the length 
of the first string in pixels. This value is used as the initial horizontal displacement 
for the seventh string. After drawing the seventh string, 
<I>horizontalOffset[0]</I> is equal to 10 plus the length of the first string plus the length of the seventh string. This 
cycle repeats for column after column. The results can be seen in Figure 9-9.

<p><A HREF="javascript:fullSize('F09gh09x.htm')"> <img src="images/F09gh09.JPG" width=404 height=147 border=0 ALT="Click to view at full size."> </A>
<P><!-- caption --><B>Figure 9-9.</b> <i>The multicolumn version of ConnectTheDots, demonstrating 
the results of using </I>getTextSize()<I> to concatenate strings on the display.</I><!-- /caption -->

</BODY>
</HTML>




