<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>Animation</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch15b.htm", "ch15d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="532"><H1>Animation</H1></A>

<p>You will find many uses for multithreading in Java applets; however, by far the 
most popular use is applet animation. There are two distinct types of animation. When 
most people think of animation, they think of moving video images; however, this is 
only one type of animation. Animation created by the applet is just as important.

<A NAME="533"><H2>Applet-Generated Animation: The JigglingText Applet</H2></A>

<p>Some applets generate data that the applet uses to update the appearance of 
the display. Let's call this type of animation 
<I>applet-generated</I> animation.

<p>In a way, the MultiThreadApplet prime number generator presented 
previously is a type of applet-generated animation; however, the data generated by 
MultiThreadApplet is simply displayed in a text field. In true applet-generated 
animation, the data created by the applet is used to update the graphic display.

<A NAME="534"><H3>The problem</H3></A>

<p>To demonstrate the concept of applet-generated animation, let's consider the 
simple example of an applet that displays a string of text in which the characters 
randomly wiggle about.

<A NAME="535"><H3>The setup work</H3></A>

<p>Create an empty project named JigglingText. To this project, add a class and an 
HTML file of the same name.

<A NAME="536"><H3>The code</H3></A>

<p>Update the JigglingText.java file to look as follows:

<p><pre>
import java.applet.Applet;
import java.awt.*;
import java.util.*;

/**
 * Demonstrate applet-generated animation by displaying a
 * string in the applet window and &quot;jiggling&quot; the characters.
 */
public class JigglingText extends Applet implements Runnable
{
    // random number generator that generates a sequence
    // of random bytes
    Random random = new Random();
    byte[] randomJiggle;
    
    // the input string broken down into characters
    char[] chars;
    int length;
    
    // the offset of the string in the display window
    Dimension stringOffset;
    
    // the average offset to each character
    int[] charOffsets;
    
    // the font information
    int fontHeight;
    int fontWidth;
    int stringWidth;
    
    // the thread generating the repaint calls
    Thread thread;
    
    /**
     * Set up the display.
     */
    public void init()
    {
        String display = this.getParameter(&quot;string&quot;);
        if (display == null)
        {
            display = &quot;Default String&quot;;
        }
        
        length = display.length();
        chars = new char[length];
        display.getChars(0, length, chars, 0);
        
        // now allocate a number of random offsets
        randomJiggle = new byte[length];
        for(int i = 0; i &lt; length; i++)
        {
            randomJiggle[i] = 0;
        }
        
        // allocate a nice font
        this.setFont(new Font(&quot;Arial&quot;, Font.PLAIN, 18));
        
        // calculate font information
        Font f = this.getFont();
        fontHeight = f.getSize();
        fontWidth  = (2 * fontHeight) / 3;
        stringWidth= length * fontWidth;

        // from this, calculate the string offset
        stringOffset = this.getSize();
        stringOffset.height = (stringOffset.height - fontHeight) / 2;
        stringOffset.width  = (stringOffset.width  -  stringWidth) / 2;

        // now calculate the offset of each character
        charOffsets = new int[length];
        for (int i = 0; i &lt; length; i++)
        {
            charOffsets[i] = fontWidth * i;
        }
    }
    
    /**
     * If a refresh thread doesn't already exist, start a new one.
     */
    public void start()
    {
        if (thread == null)
        {
            // begin a thread to update the offsets
            thread = new Thread(this);
            thread.start();
        }
    }
    
    /**
     * If the refresh thread is running, stop it.
     */
    public void stop()
    {
        if (thread != null)
        {
            thread.stop();
            thread = null;
        }
    }

    /**
     * Execute the refresh thread by calculating a random sequence
     * of bytes and using this to update the character string.
     */
    public void run()
    {
        try
        {
            while(true)
            {
                // recalculate random numbers for character position
                random.nextBytes(randomJiggle);
        
                // now repaint the applet display
                repaint();
                
                // wait for a small period
                Thread.sleep(200);
            }
        }
        catch(Exception e)
        {
        }
    }

    /**
     * Display the character string while shifting the character
     * positions slightly.
     */
    public void paint(Graphics g)
    {
        // now paint the string a character at a time
        for (int i = 0; i &lt; length; i++)
        {
            // calculate the character offset
            int charOffset;
            charOffset = stringOffset.width + charOffsets[i];
            charOffset+= (fontWidth * randomJiggle[i]) / 256;
    
            // display each character at its position
            g.drawChars(chars, i, 1, charOffset, stringOffset.height);
        }
    }
}
</PRE>

<p>Like all applet classes, the class 
<I>JigglingText</I> extends the class 
<I>Applet</I>. Unlike most applets, 
<I>JigglingText</I> also implements the 
<I>Runnable</I> interface. Implementing 
<I>Runnable</I> will allow <I>JigglingText</I> to be used as the basis for a new thread.

<p>The <I>init()</I> method begins by reading the parameter 
<I>string</I> from the HTML file. If this parameter exists, it's stored in the string variable 
<I>display</I>. If it doesn't exist, the string 
<I>Default String</I> is stored in <I>display. 
</I>The <I>display</I> string is then converted into 
an array of characters. (As you'll see, the 
<I>paint()</I> method will require such an array 
rather than a character string.)

<p>The <I>init()</I> method then allocates an array of bytes the same length as the 
input string. The <I>randomJiggle</I> array is initialized to all zeroes. This array will 
eventually contain the randomly calculated &quot;jiggle factors.&quot;

<p>After applying an attractive font, <I>init()</I> calculates a series of font variables. 
The font height is easily calculated. Calculating the font width is difficult, because the 
width of each character is different. Experience with different ratios shows that using 
two-thirds of the font height as an average character width generates good results. 
The total <I>stringWidth</I> value is calculated as the 
<I>fontWidth</I> value times the number 
of characters in the string. (The 
<I>stringLength()</I> method can't be used without a 
<I>Graphics</I> object.)

<p>The <I>init()</I> method uses the calculated font sizes along with the size of the 
applet window to calculate the proper offset of the 
<I>display</I> string that is stored in 
<I>stringOffset</I>, an object of type 
<I>Dimension</I>. In addition, the offset of each character in the 
<I>display</I> string is stored in the integer array 
<I>charOffsets</I>. This completes the initialization 
of the data members that <I>paint()</I> will need to implement the jiggling display.

<p>The <I>start()</I> method creates a <I>Thread</I> object from the current 
<I>JigglingText</I> applet object. The call to 
<I>thread.start()</I> creates a new thread, which begins execution 
with the method <I>run()</I>. As with many animation applets, 
<I>run()</I> executes a loop that calculates some variable values that are required to support the 
<I>paint()</I> method, and then invokes 
<I>repaint()</I> to force a repaint of the applet window. In this case, 
<I>run()</I> calls <I>Random.nextBytes()</I>, which fills the array 
<I>randomJiggle</I> with a series of randomly chosen byte values. The call to 
<I>sleep()</I> gives the <I>paint()</I> method a chance to do 
its job and gives the user a chance to view the results.

<p>It's the <I>paint()</I> method that actually displays the jiggling string. This 
method loops through each character in the 
<I>chars</I> array of characters to be displayed. For 
each character, <I>paint()</I> calculates a character offset by first adding the character offset 
within the string to the offset of the string within the applet window. A small additional 
factor is then added to the character offset. This factor is based on both the average 
<I>fontWidth</I> value and the <I>randomJiggle</I> factor calculated in the 
<I>run()</I> method. In no case is this factor greater than one half the 
<I>fontWidth </I>value.

<p>Finally, the character at offset <I>i</I> within the character array representing the 
input string is drawn at the calculated offset. The 
<I>paint()</I> method continues by drawing the next character in the array. The 
<I>paint()</I> method terminates when all of the characters in the string have been drawn.

<A NAME="537"><H3>The HTML file</H3></A>

<p>To test the JigglingText applet, update the HTML file so it looks as follows:

<p><pre>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META NAME=&quot;GENERATOR&quot; Content=&quot;Microsoft Visual Studio 6.0&quot;&gt;
&lt;TITLE&gt;&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;

&lt;OBJECT CODE=&quot;JigglingText.class&quot;
        HEIGHT=100
        WIDTH=300 VIEWASTEXT&gt;
&lt;PARAM name=&quot;string&quot; value=&quot;Display String&quot;&gt;
&lt;/OBJECT&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<p>The parameter <I>string</I> causes the message &quot;Display String&quot; to be displayed in 
the applet window.

<A NAME="538"><H3>The result</H3></A>

<p>The results of executing the JigglingText applet with JigglingText.htm are 
shown in Figure 15-2.

<p><img src="images/f15gh02x.jpg" width=420 height=274 border=0> 

<p><!-- caption --><B>Figure 15-2.</b> <i>The JigglingText applet displays a string of characters that jiggle 
about on the display.</I><!-- /caption -->

<A NAME="539"><H2>Loading a Single Image</H2></A>

<p>Image animation occurs when the applet replays in rapid succession a series 
of images. Of course, before these images can be displayed they must be 
transferred to the applet. This transfer process is called 
<I>image loading</I>. Before we tackle the problem of loading multiple images, let's build an applet that loads a single image.

<p>Applets understand two different types of images: the GIF (pronounced as 
either giff with a hard &quot;g,&quot; or jiff, like the peanut butter) format and the JPEG 
(universally pronounced jay-peg) format. Each of these formats has its advantages. 
GIF files give better color rendition when the number of different colors is small. 
JPEG files are smaller, but they take longer to decompress.

<p>The <I>Applet</I> class contains the method <I>getImage(url, 
imageName)</I>, where <I>url</I> is normally equal to the applet code base (the path to the applet's .class files) 
and <I>imageName</I> is the name of the individual image file to load. (This method 
assumes that the image is in the same directory as the .class file.)

<p>Judging from its name, you might assume that 
<I>getImage()</I> loads an image, but this isn't the case. The 
<I>getImage()</I> method only registers the image to be loaded 
by the applet. The image isn't loaded until it's needed. Since the loading of an image 
is a time-consuming process, the Java library provides an 
<I>ImageObserver</I> interface for this task. An object of a class that implements 
<I>ImageObserver</I> can monitor the loading of an image while the applet continues executing.

<p>To demonstrate this principle, let's create a small applet that loads and 
displays an image of a magnifying glass. (The GIF images used in this section were 
extracted from FindFile.avi, which is on the Visual J++ 6 CD in the 
\Common\Graphics\AVIs folder.)

<A NAME="540"><H3>The DisplayImage applet</H3></A>

<p>The DisplayImage applet displays a single GIF file in the applet window. Begin 
by creating an empty DisplayImage project. Populate the project with a 
DisplayImage.java file and a DisplayImage.htm file. Update the HTML file to load 
the DisplayImage.class file.

<p>The code for the <I>DisplayImage</I> class appears as follows:

<p><pre>
import java.applet.Applet;
import java.awt.*;
import java.net.URL;
import java.awt.image.*;

/**
 * This applet displays a single image file find01.gif.
 */
public class DisplayImage extends Applet 
{
    // the size of the window
    Dimension windowSize;

    // the find01 image information
    Image image;
    int   imageHeight = 0;
    int   imageWidth = 0;
    boolean imageError = false;
    
    // use the following image observer to determine
    // when the image load operation is complete
    ImageObserver observer = new Observer();

    /**
     * Set up the image to be loaded by the new
     * thread.
     */
    public void init()
    {
        // set the background color to white
        this.setBackground(Color.white);
        
        // first calculate the size of the applet window
        windowSize = this.getSize();
        
        // get the image
        URL url = this.getCodeBase();
        image = this.getImage(url, &quot;find01.gif&quot;);
    }

    class Observer implements ImageObserver
    {
        public boolean imageUpdate(Image dummy,
                                   int status,
                                   int x, int y,
                                   int width, int height)
        {
            boolean returnVal = true;
            
            if ((status &amp; ImageObserver.HEIGHT) != 0)
            {
                imageHeight = height;
            }
            if ((status &amp; ImageObserver.WIDTH) != 0)
            {
                imageWidth = width;
            }
            if ((status &amp; ImageObserver.ALLBITS) ==
                 ImageObserver.ALLBITS)
            {
                returnVal = false;
            }
            
            if ((status &amp; ImageObserver.ABORT) != 0)
            {
                imageError = true;
                returnVal = false;
            }
            
            repaint();
            return returnVal;
        }
    }

    /**
     * If the image has been loaded, display it;
     * otherwise, display an error message.
     */
    Dimension offset = new Dimension();
    public void paint(Graphics g)
    {
        // if an image error has occurred&#8230;
        if (imageError)
        {
            // output an error message
            String s = &quot;Image load failed&quot;;
            FontMetrics fm = g.getFontMetrics();
            offset.width = (windowSize.width - fm.stringWidth(s))/2;
            offset.height= windowSize.height/2;
            
            g.drawString(s, offset.width, offset.height);
            return;
        }
        
        // draw the image in the middle of the applet window
        g.drawImage(image,
                    (windowSize.width - imageWidth)/2,
                    (windowSize.height - imageHeight)/2,
                    observer);
    }
}
</PRE>

<p>As the <I>DisplayImage</I> class is constructed, the image height and width are 
set to zero. In addition, the <I>imageError</I> flag is set to 
<I>false</I>. This flag will be set to <I>true</I> 
if the image load process is aborted with an error. In addition, the 
<I>DisplayImage</I> constructor creates an instance of the 
<I>Observer </I>class. Looking ahead in the code, you 
can see that <I>Observer</I> is an inner class that implements the 
<I>ImageObserver</I> interface. I'll explain the significance of this shortly.

<p>The <I>init()</I> method begins by setting the background of the applet to white 
so it blends with the browser background. The method continues by retrieving 
the window size used by the <I>paint()</I> method. Finally, the 
<I>init()</I> method creates an 
<I>Image</I> object from the file find01.gif,<I> 
</I>which is located at the same URL that the DisplayImage.class file came from. Remember that creating the image object 
doesn't cause the image to be loaded.

<p>The <I>paint()</I> method begins by checking to see if an image load error has 
occurred. If it has, <I>paint()</I> displays the message &quot;Image load failed&quot; in the middle 
of the applet window, and makes no further attempts to load the image.

<p>If no image load error has occurred, the 
<I>paint()</I> method continues by calling the 
<I>drawImage()</I> method to draw the image contained in the 
<I>Image</I> object in 
the middle of the applet window. Initially no image is available; however, 
the <I>drawImage()</I> call starts the image-loading process. In addition to passing the x 
and y coordinates at which to draw the image, 
<I>paint()</I> passes the <I>observer</I> object, 
which implements <I>ImageObserver</I>, to 
<I>drawImage()</I>. The image loader uses the 
<I>observer </I>object to inform the DisplayImage applet of the status of the image as it's being loaded.

<p>The internal class <I>Observer</I> has one method: 
<I>imageUpdate()</I>. The applet calls this method whenever there is a change in the image status. The 
<I>status</I> argument contains a bit pattern indicating for which values the image status is known. 
For example, the image width is one of the first values retrieved from the image. As 
soon as the <I>ImageObserver.WIDTH</I> flag is set, 
<I>imageUpdate()</I> can save the <I>imageWidth 
</I>value. The call to <I>repaint()</I> at the bottom of the 
<I>imageUpdate()</I> method forces <I>paint()</I> to draw the portion of the image that is already loaded. The 
<I>imageUpdate()</I> method returns <I>true</I> to indicate that the image load operation should continue.

<p>The image load operation is complete when the 
<I>status</I> argument's <I>ALLBITS </I>bit is set. When this happens, 
<I>imageUpdate()</I> returns <I>false</I> to indicate that the 
image loader should stop loading the image. Similarly, if the 
<I>ABORT</I> bit is set, a fatal error has occurred, indicating that the image load operation should be halted.

<p>The result of executing the DisplayImage applet is shown in Figure 15-3. 
What isn't obvious from this static display is that the image display is repainted 
continuously from top to bottom as the image information is loaded.


<p><img src="images/f15gh03x.jpg" width=422 height=275 border=0> 

<p><!-- caption --><B>Figure 15-3.</b> <i>The DisplayImage applet displays the single image contained 
in find01.gif.</I><!-- /caption -->

<A NAME="541"><H2>Loading Multiple Images</H2></A>

<p>Most people, when they think of animation, think of image animation.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
With the advent of multiple-frame GIF files, image animation in 
applets is a lot less important than it used to be. A multiple-frame GIF file allows 
simple image sequences to be displayed within an HTML file without resorting to 
applet animation.
</blockquote></div>

<p>Although there are variations in how image animation applets work, all 
image animation applets begin by loading a series of images. The applet then displays 
these images in sequence within the applet window, pausing between each image. If 
the pause is sufficiently small, the user's eye perceives the image sequence as 
smooth motion. (This is the same principle used in movie or television films.)

<p>Images used in applets are normally loaded from the server. If the connec-
tion to the server is over a LAN, as would be the case with an intranet, the server 
connection is of sufficient speed that the image download times for a 
reasonable 
number of images are not significant. However, when you are downloading 
images using a modem, the connections to the server are slow enough that if an image 
is large or if there are a great number of images, the image download time 
becomes unacceptable to the user.

<p>(For applications involving a fixed customer base, it might be possible to 
store the images on the client computer. Loading images from the client is much faster 
than over a modem or a LAN; however, the applet will need to be trusted. See 
Chapter 14, <A HREF="ch14a.htm">Applets</A>, for a discussion of applet I/O.)

<p>The <I>ImageObserver</I> interface is great for loading a single image. When it 
is loading the numerous images required to perform image animation, however, 
the <I>ImageObserver</I> interface quickly becomes unwieldy. To track the load process 
of multiple images, use the class 

<I>MediaTracker</I>. The following applet demonstrates 
the <I>MediaTracker </I>class.

<A NAME="542"><H3>The ImageAnimation applet</H3></A>

<p>To begin writing the ImageAnimation applet, create an empty project and add 
the files ImageAnimation<I>.</I>java and ImageAnimation.htm. Create a sequence of frames 
that together make up an animated sequence. I chose the full sequence of 23 frames 
from the FindFile.avi file that is contained on the Visual J++ 6 CD. Since this file 
contains so many images, I stored them in the subdirectory 
<I>images</I>.

<p>Update the <I>ImageAnimation</I> class as follows:

<p><pre>
import java.applet.Applet;
import java.awt.*;
import java.net.URL;

/**
 * The following class performs animation by flipping rapidly
 * through the images/Findxx frames, where xx is 01 through 23.
 */
public class ImageAnimation extends Applet implements Runnable
{
    // define the image file base name and the number of
    // images in the animation sequence
    final static String BASENAME = &quot;Find&quot;;
    final static int NUMFRAMES = 23;
    
    // define the media tracker used to load the images
    MediaTracker mt;
    boolean imagesLoaded;
    boolean imageLoadError;
    
    // the following thread both loads the images (using
    // the media tracker) and prompts the paint() method
    // to cycle through the images
    Thread replayThread = null;
    
    // the images themselves
    Image[] images = new Image[NUMFRAMES];

    // the image number and position of the image
    int imageNumber = 0;
    int imageX = 0;
    int imageY = 0;

    /**
     * Create the media tracker, and load the images into it.
     */
    public void init()
    {
        // create a media tracker to track the loading of
        // images
        mt = new MediaTracker(this);
        
        // now add the images to the media tracker
        String imageRoot = &quot;Images/&quot; + BASENAME;
        URL url = this.getDocumentBase();
        
        for(int i = 0; i &lt; NUMFRAMES; i++)
        {
            // create the image names find01, find02, and so on
            int imageNum = i + 1;
            String imageName = new String(imageRoot);
            if (imageNum &lt; 10)
            {
                imageName += &quot;0&quot;;
            }
            imageName += imageNum;
            imageName += &quot;.gif&quot;;
            
            // create an image object from that name
            images[i] = this.getImage(url, imageName);
            
            // now add each image name to the MediaTracker
            mt.addImage(images[i], 1);
        }
    }

    /**
     * Start the image display process.
     */
    public void start()
    {
        if (replayThread == null)
        {
            // start the replay thread
            replayThread = new Thread(this);
            replayThread.start();
        }
    }

    /**
     * Stop the image display process.
     */
    public void stop()
    {
        if (replayThread != null)
        {
            replayThread.stop();
            replayThread = null;
        }
    }

    /**
     * Load the images stored in the MediaTracker and
     * then prompt paint() to display them rapidly.
     */
    public void run()
    {
        // initialize variables
        imagesLoaded = false;
        
        // start loading the images
        try
        {
            mt.waitForAll();
        }
        catch(Exception e)
        {
            return;
        }
        imagesLoaded = true;
        
        // get the status of the image load - if not complete
        // there was a load error
        imageLoadError = false;
        if (mt.isErrorAny())
        {
            imageLoadError = true;
            repaint();
            return;
        }
        
        // now that the images are loaded, calculate
        // the proper display offset
        Dimension size = this.getSize();
        int width = images[0].getWidth(null);
        int height= images[0].getHeight(null);
        imageX = (size.width - width) / 2;
        imageY = (size.height- height)/ 2;
        
        // prompt paint() to sequence through the images
        try
        {
            while(true)
            {
                Thread.sleep(200);
                repaint();
            }
        }
        catch(Exception e)
        {
        }
    }
        
    /**
     * Display the images.
     */    
    public void paint(Graphics g)
    {
        // interpret the load flags
        if (imageLoadError)
        {
            g.drawString(&quot;Image load error&quot;, 10, 20);
            return;
        }
        if (!imagesLoaded)
        {
            g.drawString(&quot;Images loading&#8230;&quot;, 10, 20);
            return;
        }

        // draw each image from 0 through 22 repeatedly
        g.drawImage(images[imageNumber++],
                    imageX,
                    imageY,
                    null);
        if (imageNumber &gt;= NUMFRAMES)
        {
            imageNumber = 0;
        }
    }
}
</PRE>

<p>The<I> ImageAnimation</I> class implements the 
<I>Runnable</I> interface in order to be able to spawn a background thread, which we'll see the importance of shortly.

<p>The <I>init()</I> method begins by creating a 
<I>MediaTracker</I> object <I>mt</I>. The 
<I>for</I> loop within <I>init()</I> creates the name of each of the 
<I>Find</I> files in turn: 
<I>images/Find01.gif</I>, followed by 
<I>images/Find02.gif</I>, and so forth. Each of these file names, along 
with the URL of the HTML file, is passed to the 
<I>getImage()</I> method. The resulting image is stored in the 
<I>images</I> array. In addition, each image is added to the 
<I>MediaTracker</I>.

<p>The <I>start()</I> method creates and then starts a new thread out of the 
<I>ImageAnimation</I> object.

<p>The <I>run()</I> method, which is executed within the new thread, begins by 
calling <I>waitForAll()</I>. This method of 
<I>MediaTracker</I> doesn't return to the caller until all images have been loaded. Once loaded, 
<I>run()</I> sets the <I>imagesLoaded</I> flag to 
<I>true</I>. The media tracker monitors the load process. If an error arises, the media tracker 
sets an error flag that <I>run()</I> queries by calling 
<I>isErrorAny()</I>. If no error occurs, <I>run()</I> calculates the size of the applet window and the 
size of the images. (We are assuming all images are the same size.) Using this size 
information, <I>run()</I> calculates the offset to display the images centered within the 
frame. The <I>run()</I> method then sits in a loop, pausing for a fifth of a second (200 
milliseconds) and then forcing a repaint of the applet window.

<p>The <I>paint()</I> method first checks the 
<I>imageLoadError</I> and <I>imagesLoaded</I> 
flags. If either is set, <I>paint()</I> displays a message and returns. If not, 
<I>paint()</I> draws the image at index 
<I>imageNumber</I> from the <I>images</I> image array, and increments the 
<I>imageNumber </I>value. As soon as the 
<I>imageNumber</I> value is incremented to 23, 
<I>paint()</I> resets the number back to zero.

<p>The 200 millisecond delay between repaints, together with the drawing of 
the sequence of images in <I>paint()</I>, creates the animation effect. A static 
representation of the result is shown in Figure 15-4.


<p><A HREF="javascript:fullSize('f15gh04x.htm')"> <img src="images/f15gh04.jpg" width=404 height=259 border=0 ALT="Click to view at full size."> </A>
<p><!-- caption --><B>Figure 15-4.</b> <i>ImageAnimation repaints the same sequence of images rapidly 
to generate an animation effect.</I><!-- /caption -->

<A NAME="543"><H3>ImageAnimation without the flicker</H3></A>

<p>What you can't see in Figure 15-4 is the animation effect. You also can't 
see that the image within the applet display flickers. At a frame rate of five frames 
per second, the flicker is barely noticeable. If you increase the rate to 10 frames 
per second, depending on your machine the flicker might become so bad that the 
animation is barely visible.

<p>The reason for the flicker lies in the way that 
<I>paint()</I> works. During the repaint sequence, the browser calls the 
<I>update() </I>method. This method first clears the 
applet window to remove whatever was displayed there during the previous repaint. 
Once the window has been cleared, <I>update()</I> calls 
<I>paint()</I> to update the window with the new information.

<p>For normal operations, this sequence is fine. However, when the applet 
window is being updated rapidly, the time between each window repaint becomes 
longer than the time it takes to repaint the window. When the applet reaches this point, 
the window is blank longer than it's painted.

<p>The reason that <I>update()</I> clears the screen doesn't apply to our 
ImageAnimation routine. There is no reason to clear the applet window when the next image 
will completely overwrite the current image. To avoid the unnecessary window 
clearing, we can override the Visual J++ 
<I>update()</I> method with a new version of <I>update() 
</I>that calls <I>paint()</I> without first clearing the applet window.

<p>The new version of ImageAnimation, ImageAnimationA, is identical to its 
predecessor, except for the addition of the 
<I>update()</I> method and some minor changes to the 
<I>paint()</I> method, which are shown here.

<p><pre>
    /**
      * Normally the update() method clears the applet window before
      * calling paint(); in this version, just call paint()--it reduces
      * flicker considerably.
      */
     public void update(Graphics g)
     {
         paint(g);
     }
    
     /**
      * Display the images.
      */    
     boolean imageFirstPass = true;
     public void paint(Graphics g)
     {
         // interpret the load flags
         if (imageLoadError)
         {
             g.drawString(&quot;Image load error&quot;, 10, 20);
             return;
         } 
         if (!imagesLoaded)
         {
             g.drawString(&quot;Images loading&#8230;&quot;, 10, 20);
             return;
         }
        
         // if this is the first time an image is to be drawn&#8230;
         if (imageFirstPass)
         {
             // clear the applet window (this is necessary
             // because update() is no longer doing it)
             g.clearRect(0, 0, getSize().width, getSize().height);
             imageFirstPass = false;
         }

         // draw each image from 0 through 22 repeatedly
         g.drawImage(images[imageNumber++],
                     imageX,
                     imageY,
                     null);
         if (imageNumber &gt;= NUMFRAMES)
         {
             imageNumber = 0;
         }
     }
</PRE>

<p>This new version of <I>paint()</I> adds the call to 
<I>Graphics.clearRect()</I> before displaying the first image. The 
<I>clearRect()</I> method clears some portion of the 
window&#8212;in this case, the entire window. This removes any text written there earlier by 
<I>drawString()</I>. Clearing the window would normally be handled by the 
<I>update()</I> method; however, since this new version of 
<I>update()</I> doesn't clear the window, 
<I>paint()</I> must.

</BODY>
</HTML>




