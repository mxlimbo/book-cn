<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Getting Input from the Mouse</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch03a.htm", "ch03c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="68"><H1>Getting Input from the Mouse</H1></A>

<P>Windows uses a number of different messages&#8212;more than 20 in all&#8212;to report 
input events involving the mouse. These messages fall into two rather broad 
categories: client-area mouse messages, which report events that occur in a window's client 
area, and nonclient-area mouse messages, which pertain to events in a window's 
nonclient area. An &quot;event&quot; can be any of the following:</P>

<UL>
<P><LI>
The press or release of a mouse button
</LI></P>

<P><LI>
The double click of a mouse button
</LI></P>

<P><LI>
The movement of the mouse
</LI></P>
</UL>

<P>You'll typically ignore events in the nonclient area of your window and 
allow Windows to handle them. If your program processes mouse input, it's 
client-area mouse messages you'll probably be concerned with.</P>

<A NAME="69"><H2>Client-Area Mouse Messages</H2></A>

<P>Windows reports mouse events in a window's client area using the messages 
shown in the following table.</P>


<P><B>Client-Area Mouse Messages</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Message</I></th>
<th valign="top"><I>Sent When</I></th>
</tr>
<tr>
<td valign="top">WM_LBUTTONDOWN</td>     
<td valign="top">The left mouse button is pressed.</td> 
</tr>
<tr>
<td valign="top">WM_LBUTTONUP</td>      
<td valign="top">The left mouse button is released.</td> 
</tr>
<tr>
<td valign="top">WM_LBUTTONDBLCLK</td>      
<td valign="top">The left mouse button is double-clicked.</td> 
</tr>
<tr>
<td valign="top">WM_MBUTTONDOWN</td>      
<td valign="top">The middle mouse button is pressed.</td> 
</tr>
<tr>
<td valign="top">WM_MBUTTONUP</td>      
<td valign="top">The middle mouse button is released.</td> 
</tr>
<tr>
<td valign="top">WM_MBUTTONDBLCLK</td>      
<td valign="top">The middle mouse button is double-clicked.</td> 
</tr>
<tr>
<td valign="top">WM_RBUTTONDOWN</td>      
<td valign="top">The right mouse button is pressed.</td> 
</tr>
<tr>
<td valign="top">WM_RBUTTONUP</td>      
<td valign="top">The right mouse button is released.</td> 
</tr>
<tr>
<td valign="top">WM_RBUTTONDBLCLK</td>      
<td valign="top">The right mouse button is double-clicked.</td> 
</tr>
<tr>
<td valign="top">WM_MOUSEMOVE</td>      
<td valign="top">The cursor is moved over the window's client area.</td> 
</tr></table></p>

<P>Messages that begin with WM_LBUTTON pertain to the left mouse 
button, WM_MBUTTON messages to the middle mouse button, and WM_RBUTTON 
messages to the right mouse button. An application won't receive WM_MBUTTON messages 
if the mouse has only two buttons. (This rule has one important exception: mice 
that have mouse wheels. Mouse wheels are discussed later in this chapter.) An 
application won't receive WM_RBUTTON messages if the mouse has just one button. 
The vast majority of PCs running Windows have two-button mice, so it's reasonably 
safe to assume that the right mouse button exists. However, if you'd like to be certain 
(or if you'd like to determine whether there is a third button, too), you can use the 
Windows <I>::GetSystemMetrics</I> API function:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
int nButtonCount = ::GetSystemMetrics (SM_CMOUSEBUTTONS);
</pre>
</td></tr></table>

<P>The return value is the number of mouse buttons, or it is 0 in the unlikely event that a mouse is not installed.</P>

<P>WM_<I>x</I>BUTTONDOWN and WM_<I>x</I>BUTTONUP messages report button 
presses and releases. A WM_LBUTTONDOWN message is normally followed by a 
WM_LBUTTONUP message, but don't count on that being the case. Mouse messages go to 
the window under the cursor (the Windows term for the mouse pointer), so if the 
user clicks the left mouse button over a window's client area and then moves the 
cursor outside the window before releasing the button, the window receives a 
WM_LBUTTONDOWN message but not a WM_LBUTTONUP message. Many programs react 
only to button-down messages and ignore button-up messages, in which case the 
pairing of the two isn't important. If pairing is essential, a program can &quot;capture&quot; the 
mouse on receipt of a button-down message and release it when a button-up message 
arrives. In between, all mouse messages, even those pertaining to events outside the 
window, are directed to the window that performed the capture. This ensures that a 
button-up message is received no matter where the cursor is when the button is 
released. Mouse capturing is discussed later in this chapter.</P>

<P>When two clicks of the same button occur within a very short period of 
time, the second button-down message is replaced by a 
WM_<I>x</I>BUTTONDBLCLK message. Significantly, this happens only if the window's WNDCLASS includes the class 
style CS_DBLCLKS. The default WNDCLASS that MFC registers for frame windows has 
this style, so frame windows receive double-click messages by default. For a 
CS_DBLCLKS-style window, two rapid clicks of the left mouse button over the window's client 
area produce the following sequence of messages:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
WM_LBUTTONDOWN
WM_LBUTTONUP
WM_LBUTTONDBLCLK
WM_LBUTTONUP
</pre>
</td></tr></table>

<P>If the window is not registered to be notified of double clicks, however, the 
same two button clicks produce the following sequence of messages:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
WM_LBUTTONDOWN
WM_LBUTTONUP
WM_LBUTTONDOWN
WM_LBUTTONUP
</pre>
</td></tr></table>

<P>How your application responds to these messages&#8212;or whether it responds 
to them at all&#8212;is up to you. You should, however, steer away from having clicks 
and double clicks of the same mouse button carry out two unrelated tasks. A 
double-click message is always preceded by a single-click message, so the actions that 
generate the two messages are not easily divorced. Applications that process single and 
double clicks of the same button typically select an object on the first click and take 
some action upon that object on the second click. When you double-click a folder in 
the right pane of the Windows Explorer, for example, the first click selects the folder 
and the second click opens it.</P>

<P>WM_MOUSEMOVE messages report that the cursor has moved within the 
window's client area. As the mouse is moved, the window under the cursor receives 
a flurry of WM_MOUSEMOVE messages reporting the latest cursor position. 
Windows has an interesting way of delivering WM_MOUSEMOVE messages that prevents 
slow applications from being overwhelmed by messages reporting every position in 
the cursor's path. Rather than stuff a WM_MOUSEMOVE message into the message 
queue each time the mouse is moved, Windows simply sets a flag in an internal data 
structure. The next time the application retrieves a message, Windows, seeing that the 
flag is set, manufactures a WM_MOUSEMOVE message with the current cursor 
coordinates. Therefore, an application receives WM_MOUSEMOVE messages only as often as it 
can handle them. If the cursor is moved very slowly, every point in its journey is 
reported unless the application is busy doing other things. But if the cursor is whisked very 
rapidly across the screen, most applications receive only a handful of 
WM_MOUSEMOVE messages.</P>

<P>In an MFC program, message-map entries route mouse messages to class 
member functions that are provided to handle those messages. The following table 
lists the message-map macros and message handler names for client-area mouse messages.</P>

<P><B>Message-Map Macros and Message Handlers for Client-Area Mouse Messages</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Message</I></th>    
<th valign="top"><I>Message-Map Macro</I></th>
<th valign="top"><I>Handling Function</I></th>
</tr>
<tr>
<td valign="top">WM_LBUTTONDOWN</td>     
<td valign="top">ON_WM_LBUTTONDOWN</td>       
<td valign="top"><I>OnLButtonDown</I></td>  
</tr>
<tr>
<td valign="top">WM_LBUTTONUP</td>       
<td valign="top">ON_WM_LBUTTONUP</td>       
<td valign="top"><I>OnLButtonUp</I></td>  
</tr>
<tr>
<td valign="top">WM_LBUTTONDBLCLK</td>      
<td valign="top">ON_WM_LBUTTONDBLCLK</td>       
<td valign="top"><I>OnLButtonDblClk</I></td>  
</tr>
<tr>
<td valign="top">WM_MBUTTONDOWN</td>       
<td valign="top">ON_WM_MBUTTONDOWN</td>       
<td valign="top"><I>OnMButtonDown</I></td>  
</tr>
<tr>
<td valign="top">WM_MBUTTONUP</td>       
<td valign="top">ON_WM_MBUTTONUP</td>       
<td valign="top"><I>OnMButtonUp</I></td>  
</tr>
<tr>
<td valign="top">WM_MBUTTONDBLCLK</td>       
<td valign="top">ON_WM_MBUTTONDBLCLK</td>       
<td valign="top"><I>OnMButtonDblClk</I></td>  
</tr>
<tr>
<td valign="top">WM_RBUTTONDOWN</td>       
<td valign="top">ON_WM_RBUTTONDOWN</td>       
<td valign="top"><I>OnRButtonDown</I></td>  
</tr>
<tr>
<td valign="top">WM_RBUTTONUP</td>       
<td valign="top">ON_WM_RBUTTONUP</td>       
<td valign="top"><I>OnRButtonUp</I></td>  
</tr>
<tr>
<td valign="top">WM_RBUTTONDBLCLK</td>       
<td valign="top">ON_WM_RBUTTONDBLCLK</td>       
<td valign="top"><I>OnRButtonDblClk</I></td>  
</tr>
<tr>
<td valign="top">WM_MOUSEMOVE</td>       
<td valign="top">ON_WM_MOUSEMOVE</td>       
<td valign="top"><I>OnMouseMove</I></td>  
</tr></table></p>

<P><I>OnLButtonDown</I> and other client-area mouse message handlers are 
prototyped as follows:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
afx_msg void On<I>MsgName</I> (UINT nFlags, CPoint point)
</pre>
</td></tr></table>

<P><I>point</I> identifies the location of the cursor. In 
WM_<I>x</I>BUTTONDOWN and WM_<I>x</I>BUTTONDBLCLK messages, 
<I>point</I> specifies the location of the cursor when the 
button was pressed. In WM_<I>x</I>BUTTONUP messages, 
<I>point</I> specifies the location of the cursor when the button was released. And in WM_MOUSEMOVE messages, 
<I>point</I> specifies the latest cursor position. In all cases, positions are reported in device 
coordinates relative to the upper left corner of the window's client area. A 
WM_LBUTTONDOWN message with <I>point.x</I> equal to 32 and 
<I>point.y</I> equal to 64 means the left mouse 
button was clicked 32 pixels to the right of and 64 pixels below the client area's upper 
left corner. If necessary, these coordinates can be converted to logical coordinates using MFC's <I>CDC::DPtoLP</I> function.</P>

<P>The <I>nFlags</I> parameter specifies the state of the mouse buttons and of the 
Shift and Ctrl keys at the time the message was generated. You can find out from this 
parameter whether a particular button or key is up or down by testing for the bit flags 
listed in the following table.</P>

<P><B>The <I>nFlags</I> Parameter</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Mask</I></th>     
<th valign="top"><I>Meaning If Set</I></th>
</tr>
<tr>
<td valign="top">MK_LBUTTON</td>     
<td valign="top">The left mouse button is pressed.</td>
</tr>
<tr>
<td valign="top">MK_MBUTTON</td>     
<td valign="top">The middle mouse button is pressed.</td>
</tr>
<tr>
<td valign="top">MK_RBUTTON</td>     
<td valign="top">The right mouse button is pressed.</td>
</tr>
<tr>
<td valign="top">MK_CONTROL</td>     
<td valign="top">The Ctrl key is pressed.</td>
</tr>
<tr>
<td valign="top">MK_SHIFT</td>     
<td valign="top">The Shift key is pressed.</td>
</tr></table></p>

<P>The expression</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
nFlags &amp; MK_LBUTTON
</pre>
</td></tr></table>

<P>is nonzero if and only if the left mouse button is pressed, while</p>

<table cellpadding=5 width="95%"><tr><td>
<pre>
nFlags &amp; MK_CONTROL
</pre>
</td></tr></table>

<P>is nonzero if the Ctrl key was held down when the event occurred. Some 
programs respond differently to mouse events if the Shift or Ctrl key is held down. For 
example, a drawing program might constrain the user to drawing only horizontal or 
vertical lines if the Ctrl key is pressed as the mouse is moved by checking the 
MK_CONTROL bit in the <I>nFlags</I> parameter accompanying WM_MOUSEMOVE messages. At the 
conclusion of a drag-and-drop operation, the Windows shell interprets the 
MK_CONTROL bit to mean that the objects involved in the drop should be copied rather than moved.</P>

<A NAME="70"><H2>The TicTac Application</H2></A>

<P>To show how easy it is to process mouse messages, let's look at a sample 
application that takes input from the mouse. TicTac, whose output is shown in Figure 3-1, is 
a tic-tac-toe program that responds to three types of client-area mouse events: left 
button clicks, right button clicks, and left button double clicks. Clicking the left mouse 
button over an empty square places an X in that square. Clicking the right mouse 
button places an O in an empty square. (The program prevents cheating by making 
sure that Xs and Os are alternated.) Double-clicking the left mouse button over the 
thick black lines that separate the squares clears the playing grid and starts a new 
game. After each X or O is placed, the program checks to see if there's a winner or the game 
has been played to a draw. A draw is declared when all nine squares are filled 
and neither player has managed to claim three squares in a row horizontally, 
vertically, or diagonally.</P>

<P>
<img src="images/F03mg01.GIF" width=358 height=377 border="0">
</p><p>
<!-- CAPTION --><B>Figure 3-1.</B> <I>The TicTac window.</I><!-- /CAPTION -->
</p>

<P>In addition to providing a hands-on demonstration of mouse-message 
processing, TicTac also introduces some handy new MFC functions such as 
<I>CWnd::MessageBox</I>, which displays a message box window, and 
<I>CRect::PtInRect</I>, which quickly tells you whether a point lies inside a rectangle represented by a 
<I>CRect</I> object. TicTac's source code appears in Figure 3-2.</P>

<p><B>Figure 3-2.</B> <I>The TicTac application.</I></p>

<table cellpadding=5 width="95%"><tr><td>
<A NAME="71"><H3>TicTac.h</H3></A>
<pre>
#define EX 1
#define OH 2

class CMyApp : public CWinApp
{
public:
    virtual BOOL InitInstance ();
};

class CMainWindow : public CWnd
{
protected:
    static const CRect m_rcSquares[9];  // Grid coordinates
    int m_nGameGrid[9];                 // Grid contents
    int m_nNextChar;                    // Next character (EX or OH)
    int GetRectID (CPoint point);
    void DrawBoard (CDC* pDC);
    void DrawX (CDC* pDC, int nPos);
    void DrawO (CDC* pDC, int nPos);
    void ResetGame ();
    void CheckForGameOver ();
    int IsWinner ();
    BOOL IsDraw ();

public:
    CMainWindow ();

protected:
    virtual void PostNcDestroy ();

    afx_msg void OnPaint ();
    afx_msg void OnLButtonDown (UINT nFlags, CPoint point);
    afx_msg void OnLButtonDblClk (UINT nFlags, CPoint point);
    afx_msg void OnRButtonDown (UINT nFlags, CPoint point);

    DECLARE_MESSAGE_MAP ()
};
</pre>
</td></tr></table>

<p>
<table cellpadding=5 width="95%"><tr><td>
<B>TicTac.cpp</B>
<pre>
#include &lt;afxwin.h&gt;
#include &quot;TicTac.h&quot;

CMyApp myApp;

/////////////////////////////////////////////////////////////////////////
// CMyApp member functions

BOOL CMyApp::InitInstance ()
{
    m_pMainWnd = new CMainWindow;
    m_pMainWnd-&gt;ShowWindow (m_nCmdShow);
    m_pMainWnd-&gt;UpdateWindow ();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////
// CMainWindow message map and member functions

BEGIN_MESSAGE_MAP (CMainWindow, CWnd)
    ON_WM_PAINT ()
    ON_WM_LBUTTONDOWN ()
    ON_WM_LBUTTONDBLCLK ()
    ON_WM_RBUTTONDOWN ()
END_MESSAGE_MAP ()

const CRect CMainWindow::m_rcSquares[9] = {
    CRect ( 16,  16, 112, 112),
    CRect (128,  16, 224, 112),
    CRect (240,  16, 336, 112),
    CRect ( 16, 128, 112, 224),
    CRect (128, 128, 224, 224),
    CRect (240, 128, 336, 224),
    CRect ( 16, 240, 112, 336),
    CRect (128, 240, 224, 336),
    CRect (240, 240, 336, 336)
};

CMainWindow::CMainWindow ()
{
    m_nNextChar = EX;
    ::ZeroMemory (m_nGameGrid, 9 * sizeof (int));

    //
    // Register a WNDCLASS.
    //
    CString strWndClass = AfxRegisterWndClass (
        CS_DBLCLKS,                                     // Class style
        AfxGetApp ()-&gt;LoadStandardCursor (IDC_ARROW),   // Class cursor
        (HBRUSH) (COLOR_3DFACE + 1),                    // Background brush
        AfxGetApp ()-&gt;LoadStandardIcon (IDI_WINLOGO)    // Class icon
    );

    //
    // Create a window.
    //
    CreateEx (0, strWndClass, _T (&quot;Tic-Tac-Toe&quot;),
        WS_OVERLAPPED | WS_SYSMENU | WS_CAPTION | WS_MINIMIZEBOX,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL);

    //
    // Size the window.
    //
    CRect rect (0, 0, 352, 352);
    CalcWindowRect (&amp;rect);
    SetWindowPos (NULL, 0, 0, rect.Width (), rect.Height (),
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW);
}

void CMainWindow::PostNcDestroy ()
{
    delete this;
}

void CMainWindow::OnPaint ()
{
    CPaintDC dc (this);
    DrawBoard (&amp;dc);    
}

void CMainWindow::OnLButtonDown (UINT nFlags, CPoint point)
{
    //
    // Do nothing if it's O's turn, if the click occurred outside the
    // tic-tac-toe grid, or if a nonempty square was clicked.
    //
    if (m_nNextChar != EX)
        return;

    int nPos = GetRectID (point);
    if ((nPos == -1) || (m_nGameGrid[nPos] != 0))
        return;

    //
    // Add an X to the game grid and toggle m_nNextChar.
    //
    m_nGameGrid[nPos] = EX;
    m_nNextChar = OH;

    //
    // Draw an X on the screen and see if either player has won.
    //
    CClientDC dc (this);
    DrawX (&amp;dc, nPos);
    CheckForGameOver ();
}

void CMainWindow::OnRButtonDown (UINT nFlags, CPoint point)
{
    //
    // Do nothing if it's X's turn, if the click occurred outside the
    // tic-tac-toe grid, or if a nonempty square was clicked.
    //
    if (m_nNextChar != OH)
        return;

    int nPos = GetRectID (point);
    if ((nPos == -1) || (m_nGameGrid[nPos] != 0))
        return;

    //
    // Add an O to the game grid and toggle m_nNextChar.
    //
    m_nGameGrid[nPos] = OH;
    m_nNextChar = EX;

    //
    // Draw an O on the screen and see if either player has won.
    //
    CClientDC dc (this);
    DrawO (&amp;dc, nPos);
    CheckForGameOver ();
}

void CMainWindow::OnLButtonDblClk (UINT nFlags, CPoint point)
{
    //
    // Reset the game if one of the thick black lines defining the game
    // grid is double-clicked with the left mouse button.
    //
    CClientDC dc (this);
    if (dc.GetPixel (point) == RGB (0, 0, 0))
        ResetGame ();
}

int CMainWindow::GetRectID (CPoint point)
{
    //
    // Hit-test each of the grid's nine squares and return a rectangle ID
    // (0-8) if (point.x, point.y) lies inside a square.
    //
    for (int i=0; i&lt;9; i++) {
        if (m_rcSquares[i].PtInRect (point))
            return i;
    }
    return -1;
}

void CMainWindow::DrawBoard (CDC* pDC)
{
    //
    // Draw the lines that define the tic-tac-toe grid.
    //
    CPen pen (PS_SOLID, 16, RGB (0, 0, 0));
    CPen* pOldPen = pDC-&gt;SelectObject (&amp;pen);

    pDC-&gt;MoveTo (120, 16);
    pDC-&gt;LineTo (120, 336);

    pDC-&gt;MoveTo (232, 16);
    pDC-&gt;LineTo (232, 336);

    pDC-&gt;MoveTo (16, 120);
    pDC-&gt;LineTo (336, 120);

    pDC-&gt;MoveTo (16, 232);
    pDC-&gt;LineTo (336, 232);

    //
    // Draw the Xs and Os.
    //
    for (int i=0; i&lt;9; i++) {
        if (m_nGameGrid[i] == EX)
            DrawX (pDC, i);
        else if (m_nGameGrid[i] == OH)
            DrawO (pDC, i);
    }
    pDC-&gt;SelectObject (pOldPen);
}

void CMainWindow::DrawX (CDC* pDC, int nPos)
{
    CPen pen (PS_SOLID, 16, RGB (255, 0, 0));
    CPen* pOldPen = pDC-&gt;SelectObject (&amp;pen);

    CRect rect = m_rcSquares[nPos];
    rect.DeflateRect (16, 16);
    pDC-&gt;MoveTo (rect.left, rect.top);
    pDC-&gt;LineTo (rect.right, rect.bottom);
    pDC-&gt;MoveTo (rect.left, rect.bottom);
    pDC-&gt;LineTo (rect.right, rect.top);

    pDC-&gt;SelectObject (pOldPen);
}
void CMainWindow::DrawO (CDC* pDC, int nPos)
{
    CPen pen (PS_SOLID, 16, RGB (0, 0, 255));
    CPen* pOldPen = pDC-&gt;SelectObject (&amp;pen);
    pDC-&gt;SelectStockObject (NULL_BRUSH);

    CRect rect = m_rcSquares[nPos];
    rect.DeflateRect (16, 16);
    pDC-&gt;Ellipse (rect);

    pDC-&gt;SelectObject (pOldPen);
}

void CMainWindow::CheckForGameOver ()
{
    int nWinner;

    //
    // If the grid contains three consecutive Xs or Os, declare a winner
    // and start a new game.
    //
    if (nWinner = IsWinner ()) {
        CString string = (nWinner == EX) ?
            _T (&quot;X wins!&quot;) : _T (&quot;O wins!&quot;);
        MessageBox (string, _T (&quot;Game Over&quot;), MB_ICONEXCLAMATION | MB_OK);
        ResetGame ();
    }

    //
    // If the grid is full, declare a draw and start a new game.
    //
    else if (IsDraw ()) {
        MessageBox (_T (&quot;It's a draw!&quot;), _T (&quot;Game Over&quot;),
            MB_ICONEXCLAMATION | MB_OK);
        ResetGame ();
    }
}

int CMainWindow::IsWinner ()
{
    static int nPattern[8][3] = {
        0, 1, 2,
        3, 4, 5,
        6, 7, 8,
        0, 3, 6,
        1, 4, 7,
        2, 5, 8,
        0, 4, 8,
        2, 4, 6
    };

    for (int i=0; i&lt;8; i++) {
        if ((m_nGameGrid[nPattern[i][0]] == EX) &amp;&amp;
            (m_nGameGrid[nPattern[i][1]] == EX) &amp;&amp;
            (m_nGameGrid[nPattern[i][2]] == EX))
            return EX;

        if ((m_nGameGrid[nPattern[i][0]] == OH) &amp;&amp;
            (m_nGameGrid[nPattern[i][1]] == OH) &amp;&amp;
            (m_nGameGrid[nPattern[i][2]] == OH))
            return OH;
    }
    return 0;
}

BOOL CMainWindow::IsDraw ()
{
    for (int i=0; i&lt;9; i++) {
        if (m_nGameGrid[i] == 0)
            return FALSE;
    }
    return TRUE;
}

void CMainWindow::ResetGame ()
{
    m_nNextChar = EX;
    ::ZeroMemory (m_nGameGrid, 9 * sizeof (int));
    Invalidate ();
}
</pre>
</td></tr></table>
</p>

<P>The first step in processing mouse input is to add entries for the messages 
you want to handle to the message map. 
<I>CMainWindow</I>'s message map in TicTac.cpp contains the following message-map entries:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
ON_WM_LBUTTONDOWN ()
ON_WM_LBUTTONDBLCLK ()
ON_WM_RBUTTONDOWN ()
</pre>
</td></tr></table>

<P>These three statements correlate WM_LBUTTONDOWN, WM_LBUTTONDBLCLK, 
and WM_RBUTTONDOWN messages to the 
<I>CMainWindow</I> member functions 
<I>OnLButtonDown</I>, <I>OnLButtonDblClk</I>, and 
<I>OnRButtonDown</I>. When the messages start 
arriving, the fun begins.</P>

<P>The <I>OnLButtonDown</I> handler processes clicks of the left mouse button 
in <I>CMainWindow</I>'s client area. After checking 
<I>m_nNextChar</I> to verify that it's X's turn and not O's (and returning without doing anything if it's not), 
<I>OnLButtonDown</I> calls the protected member function 
<I>GetRectID</I> to determine whether the click 
occurred in one of the nine rectangles corresponding to squares in the tic-tac-toe grid. 
The rectangles' coordinates are stored in the static array of 
<I>CRect</I> objects named 
<I>CMainWindow::m_rcSquares</I>. <I>GetRectID</I> uses a 
<I>for</I> loop to determine whether the cursor location passed to it by the message handler lies inside any of the squares:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
for (int i=0; i&lt;9; i++) {
    if (m_rcSquares[i].PtInRect (point))
        return i;
}
return -1;
</pre>
</td></tr></table>

<P><I>CRect::PtInRect</I> returns a nonzero value if the point passed to it lies within the 
rectangle represented by the <I>CRect</I> object, or 0 if it does not. If 
<I>PtInRect</I> returns nonzero for any of the rectangles in the 
<I>m_rcSquares</I> array, <I>GetRectID</I> returns the 
rectangle ID. The ID is an integer from 0 through 8, with 0 representing the square in the 
upper left corner of the grid, 1 the square to its right, 2 the square in the upper 
right corner, 3 the leftmost square in the second row, and so on. Each square has a 
corresponding element in the <I>m_nGameGrid</I> array, which initially holds all zeros 
representing empty squares. If none of the calls to 
<I>PtInRect</I> returns TRUE, <I>GetRectID</I> 
returns -1 to indicate that the click occurred outside the squares and 
<I>OnLButtonDown</I> ignores the mouse click. If, however, 
<I>GetRectID</I> returns a valid ID and the corresponding 
square is empty, <I>OnLButtonDown</I> records the X in the 
<I>m_nGameGrid</I> array and calls 
<I>CMainWindow::DrawX</I> to draw an X in the square. 
<I>DrawX</I> creates a red pen 16 pixels wide and draws two perpendicular lines oriented at 45-degree angles.</P>

<P><I>OnRButtonDown</I> works in much the same way as 
<I>OnLButtonDown</I>, except that it draws an O instead of an X. The routine that does the drawing is 
<I>CMainWindow::DrawO</I>. Before it draws an O with the 
<I>CDC::Ellipse</I> function, <I>DrawO</I> selects a NULL brush into the device context:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
pDC-&gt;SelectStockObject (NULL_BRUSH);
</pre>
</td></tr></table>

<P>This prevents the interior of the O from being filled with the device context's 
default white brush. (As an alternative, we could have created a brush whose color 
matched the window's background color and selected it into the device context. But 
drawing with a NULL brush is slightly faster because it produces no physical screen 
output.) The O is then drawn with the statements</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CRect rect = m_rcSquares[nPos];
rect.DeflateRect (16, 16);
pDC-&gt;Ellipse (rect);
</pre>
</td></tr></table>

<P>The first statement copies the rectangle representing the grid square to a 
local <I>CRect</I> object named <I>rect</I>; the second uses 
<I>CRect::DeflateRect</I> to &quot;deflate&quot; the rectangle 
by 16 pixels in each direction and form the circle's bounding box; and the third 
draws the circle. The result is a nicely formed O that's centered in the square in which it 
is drawn.</P>

<P>Double-clicking the grid lines separating the squares clears the Xs and Os 
and begins a new game. While this is admittedly a poor way to design a user interface, 
it does provide an excuse to write a double-click handler. (A better solution would 
be a push button control with the words <I>New Game 
</I>stamped on it or a New Game menu item, but since we haven't covered menus and controls yet, the perfect user 
interface will just have to wait.) Left mouse button double clicks are processed 
by <I>CMainWindow::OnLButtonDblClk</I>, which contains these simple statements:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CClientDC dc (this);
if (dc.GetPixel (point) == RGB (0, 0, 0))
    ResetGame ();
</pre>
</td></tr></table>

<P>To determine whether the double click occurred over the thick black strokes 
separating the squares in the playing grid, 
<I>OnLButtonDblClk</I> calls <I>CDC::GetPixel</I> to 
get the color of the pixel under the cursor and compares it to black (RGB (0, 0, 0)). 
If there's a match, <I>ResetGame</I> is called to reset the game. Otherwise, 
<I>OnLButtonDblClk</I> returns and the double click is ignored. Testing the color of the pixel under the 
cursor is an effective technique for hit-testing irregularly shaped areas, but be wary 
of using nonprimary colors that a display driver is likely to dither. Pure black (RGB 
(0, 0, 0)) and pure white (RGB (255, 255, 255)) are supported on every PC that 
runs Windows, so you can safely assume that neither of these colors will be dithered.</P>

<P>To be consistent with published user interface guidelines, applications 
should not use the right mouse button to carry out application-specific tasks as TicTac 
does. Instead, they should respond to right mouse clicks by popping up context 
menus. When a WM_RBUTTONUP message is passed to the system for default 
processing, Windows places a WM_CONTEXTMENU message in the message queue. You'll 
learn more about this feature of the operating system in the next chapter.</P>

<A NAME="72"><H3>Message Boxes</H3></A>

<P>Before returning, TicTac's <I>OnLButtonDown</I> and 
<I>OnRButtonDown</I> handlers call 
<I>CMainWindow::CheckForGameOver</I> to find out if the game has been won or played to 
a draw. If either player has managed to align three Xs or Os in a row or if no 
empty squares remain, <I>CheckForGameOver</I> calls 
<I>CMainWindow</I>'s <I>MessageBox</I> function to display a message box announcing the outcome, as shown in Figure 3-3. 
<I>MessageBox</I> is a function that all window classes inherit from 
<I>CWnd</I>. It is an extraordinarily useful
tool to have at your disposal because it provides a one-step means for displaying 
a message on the screen and optionally obtaining a response.</P>

<P>
<img src="images/F03mg03.GIF" width=110 height=119 border="0">
</p><p>
<!-- CAPTION --><B>Figure 3-3.</B> <I>A Windows message box.</I><!-- /CAPTION -->
</p>

<P><I>CWnd::MessageBox</I> is prototyped as follows:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
int MessageBox (LPCTSTR lpszText, LPCTSTR lpszCaption = NULL,
    UINT nType = MB_OK)
</pre>
</td></tr></table>

<P><I>lpszText</I> specifies the text in the body of the message box, 
<I>lpszCaption</I> specifies the caption for the message box's title bar, and 
<I>nType</I> contains one or more bit flags defining the message box's style. The return value identifies the button that was 
clicked to dismiss the message box. 
<I>lpszText</I> and <I>lpszCaption</I> can be 
<I>CString</I> objects or pointers to conventional text strings. (Because the 
<I>CString</I> class overloads the LPCTSTR 
operator, you can always pass a <I>CString</I> to a function that accepts an LPCTSTR data 
type.) A NULL <I>lpszCaption</I> value displays the caption &quot;Error&quot; in the title bar.</P>

<P>The simplest use for <I>MessageBox</I> is to display a message and pause until 
the user clicks the message box's OK button:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
MessageBox (_T (&quot;Click OK to continue&quot;), _T (&quot;My Application&quot;));
</pre>
</td></tr></table>

<P>Accepting the default value for <I>nType</I> (MB_OK) means the message box will have 
an OK button but no other buttons. Consequently, the only possible return value is 
IDOK. But if you want to use a message box to ask the user whether to save a file 
before exiting the application, you can use the MB_YESNOCANCEL style:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
MessageBox (_T (&quot;Your document contains unsaved data. Save it?&quot;),
    _T (&quot;My Application&quot;), MB_YESNOCANCEL);
</pre>
</td></tr></table>

<P>Now the message box contains three buttons&#8212;Yes, No, and Cancel&#8212;and the 
value returned from the <I>MessageBox</I> function is IDYES, IDNO, or IDCANCEL. The 
program can then test the return value and save the data before closing (IDYES), close 
without saving (IDNO), or return to the application without shutting down 
(IDCANCEL). The table below lists the six message box types and the 
corresponding return values, with the default push button&#8212;the one that's &quot;clicked&quot; if the 
user presses the Enter key&#8212;highlighted in boldface type.</P>

<P><B>Message Box Types</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Type</I></th>
<th valign="top"><I>Buttons</I></th>
<th valign="top"><I>Possible Return Codes</I></th>
</tr>
<tr>
<td valign="top">MB_ABORTRETRYIGNORE</td>     
<td valign="top"><B>Abort</B>, Retry, Ignore</td>     
<td valign="top">IDABORT, IDRETRY, IDIGNORE</td>
</tr>
<tr>
<td valign="top">MB_OK</td>     
<td valign="top"><B>OK</B></td>     
<td valign="top">IDOK</td>
</tr>
<tr>
<td valign="top">MB_OKCANCEL</td>     
<td valign="top"><B>OK</B>, Cancel</td>     
<td valign="top">IDOK, IDCANCEL</td>
</tr>
<tr>
<td valign="top">MB_RETRYCANCEL</td>     
<td valign="top"><B>Retry</B>, Cancel</td>     
<td valign="top">IDRETRY, IDCANCEL</td>
</tr>
<tr>
<td valign="top">MB_YESNO</td>     
<td valign="top"><B>Yes</B>, No</td>     
<td valign="top">IDYES, IDNO</td>
</tr>
<tr>
<td valign="top">MB_YESNOCANCEL</td>     
<td valign="top"><B>Yes</B>, No, Cancel</td>     
<td valign="top">IDYES, IDNO, IDCANCEL</td>
</tr></table></p>

<P>In message boxes with multiple buttons, the first (leftmost) button is 
normally the default push button. You can make the second or third button the default by 
ORing MB_DEFBUTTON2 or MB_DEFBUTTON3 into the value that specifies the 
message box type. The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
MessageBox (_T (&quot;Your document contains unsaved data. Save it?&quot;),
    _T (&quot;My Application&quot;), MB_YESNOCANCEL &#166; MB_DEFBUTTON3);
</pre>
</td></tr></table>

<P>displays the same message box as before but makes Cancel the default action.</P>

<P>By default, message boxes are application modal, which means the 
application that called the <I>MessageBox</I> function is disabled until the message box is 
dismissed. You can add MB_SYSTEMMODAL to the 
<I>nType</I> parameter and make the message box system modal. In 16-bit Windows, system-modal means that input to 
<I>all</I> applications is suspended until the message box is dismissed. In the Win32 environment, 
Windows makes the message box a topmost window that stays on top of other windows, but 
the user is still free to switch to other applications. System-modal message boxes 
should be used only for serious errors that demand immediate attention.</P>

<P>You can add an artistic touch to your message boxes by using MB_ICON 
identifiers. MB_ICONINFORMATION displays a small text balloon with an &quot;i&quot; for 
&quot;information&quot; in it in the upper left corner of the message box. The &quot;i&quot; is 
generally used when information is provided to the user but no questions are being 
asked, as in</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
MessageBox (_T (&quot;No errors found. Click OK to continue&quot;),
    _T (&quot;My Application&quot;), MB_ICONINFORMATION &#166; MB_OK);
</pre>
</td></tr></table>

<P>MB_ICONQUESTION displays a question mark instead of an &quot;i&quot; and is normally 
used for queries such as &quot;Save before closing?&quot; MB_ICONSTOP displays a red circle 
with an X and usually indicates that an unrecoverable error has occurred&#8212;for 
example, an out-of-memory error is forcing the program to terminate prematurely. 
Finally, MB_ICONEXCLAMATION displays a yellow triangle containing an exclamation 
mark. (See Figure 3-3.)</P>

<P>MFC provides an alternative to 
<I>CWnd::MessageBox</I> in the form of the global 
<I>AfxMessageBox</I> function. The two are similar, but 
<I>AfxMessageBox</I> can be called from application classes, document classes, and other non-window classes. One 
situation in which <I>AfxMessageBox</I> is irreplaceable is when you want to report an error in 
the application object's <I>InitInstance</I> function. 
<I>MessageBox</I> requires a valid <I>CWnd</I> 
pointer and therefore can't be called until after a window is created. 
<I>AfxMessageBox</I>, on the other hand, can be called at any time.</P>

<A NAME="73"><H3>What? No Frame Window?</H3></A>

<P>TicTac differs from the sample programs in Chapters 1 and 2 in one important 
respect: Rather than using a frame window for its main window, it derives its own window class from <I>CWnd</I>. It's not that a 
<I>CFrameWnd</I> wouldn't work; it's that 
<I>CWnd</I> has everything TicTac needs and more. 
<I>CWnd</I> is the root of all window classes in MFC. 
Depending on what kinds of applications you write, deriving from 
<I>CWnd</I> is something you might need to do often or not at all. Still, it's something every MFC 
programmer should know <I>how</I> to do, and seeing a window class derived from 
<I>CWnd</I> also helps to underscore the point that MFC programs don't have to use frame windows.</P>

<P>Creating your own <I>CWnd</I>-derived window class is simple. For starters, 
you derive the window class from <I>CWnd</I> instead of from 
<I>CFrameWnd</I>. In the BEGIN_MESSAGE_MAP macro, be sure to specify 
<I>CWnd</I>, not <I>CFrameWnd</I>, as the base class. 
Then, in the window's constructor, use 
<I>AfxRegisterWndClass</I> to register a WNDCLASS 
and call <I>CWnd::CreateEx</I> to create the window. Remember the beginning of Chapter 
1, where we looked at the C source code for an SDK-style Windows application? 
Before creating a window, <I>WinMain</I> initialized a WNDCLASS structure with values 
describing the window's class attributes and then called 
<I>::RegisterClass</I> to register the WNDCLASS. Normally you don't register a WNDCLASS in an MFC program 
because MFC registers one for you. Specifying NULL in the first parameter to 
<I>CFrameWnd::Create</I> accepts the default WNDCLASS. When you derive from 
<I>CWnd</I>, however, you must register your own WNDCLASS because 
<I>CWnd::CreateEx</I> does not accept a NULL WNDCLASS name.</P>

<A NAME="74"><H3>The <I>AfxRegisterWndClass</I> Function</H3></A>
<P>MFC makes WNDCLASS registration easy with its global 
<I>AfxRegisterWndClass</I> function. If you use 
<I>::RegisterClass</I> or MFC's 
<I>AfxRegisterClass</I> to register a WNDCLASS, 
you must initialize every field in the WNDCLASS structure. But 
<I>AfxRegisterWndClass</I> fills in most of the fields for you, leaving you to specify values for just the four that MFC 
applications are typically concerned with. 
<I>AfxRegisterWndClass</I> is prototyped as follows:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
LPCTSTR AfxRegisterWndClass (UINT nClassStyle, HCURSOR hCursor = 0,
    HBRUSH hbrBackground = 0, HICON hIcon = 0)
</pre>
</td></tr></table>

<P>The value returned by 
<I>AfxRegisterWndClass</I> is a pointer to a null-terminated 
string containing the WNDCLASS name. Before seeing how TicTac uses 
<I>AfxRegisterWndClass</I>, let's take a closer look at the function itself and the parameters it accepts.</P>

<P><I>nClassStyle</I> specifies the class style, which defines certain behavioral 
characteristics of a window. <I>nClassStyle</I> is a combination of zero or more of the bit flags 
shown in the following table.</P>

<P><B>WNDCLASS Style Flags</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Class Style</I></th>     
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top">CS_BYTEALIGNCLIENT</td>     
<td valign="top">Ensures that a window's client area is always aligned on a byte boundary in the video buffer to speed drawing operations.</td>
</tr>
<tr>
<td valign="top">CS_BYTEALIGNWINDOW</td>     
<td valign="top">Ensures that the window itself is always aligned on a byte boundary in the video buffer to speed moving and resizing operations.</td>
</tr>
<tr>
<td valign="top">CS_CLASSDC</td>     
<td valign="top">Specifies that the window should share a device context with other windows created from the same WNDCLASS.</td>
</tr>
<tr>
<td valign="top">CS_DBLCLKS</td>     
<td valign="top">Specifies that the window should be notified of double clicks with WM_<I>x</I>BUTTONDBLCLK messages.</td>
</tr>
<tr>
<td valign="top">CS_GLOBALCLASS</td>     
<td valign="top">Registers the WNDCLASS globally so that all applications can use it. (By default, only the application that registers a WNDCLASS can create windows from it.) Used primarily for child window controls.</td>
</tr>
<tr>
<td valign="top">CS_HREDRAW</td>     
<td valign="top">Specifies that the entire client area should be invalidated when the window is resized horizontally.</td>
</tr>
<tr>
<td valign="top">CS_NOCLOSE</td>     
<td valign="top">Disables the Close command on the system menu and the close button on the title bar.</td>
</tr>
<tr>
<td valign="top">CS_OWNDC</td>     
<td valign="top">Specifies that each window created from this WNDCLASS should have its own device context. Helpful when optimizing repaint performance because an application doesn't have to reinitialize a private device context each time the device context is acquired.</td>
</tr>
<tr>
<td valign="top">CS_PARENTDC</td>     
<td valign="top">Specifies that a child window should inherit the device context of its parent.</td>
</tr>
<tr>
<td valign="top">CS_SAVEBITS</td>
<td valign="top">Specifies that areas of the screen covered by windows created from this WNDCLASS should be saved in bitmap form for quick repainting. Used primarily for menus and other windows with short life spans.</td>
</tr>
<tr>
<td valign="top">CS_VREDRAW</td>     
<td valign="top">Specifies that the entire client area should be invalidated when the window is resized vertically.</td>
</tr></table></p>

<P>The CS_BYTEALIGNCLIENT and CS_BYTEALIGNWINDOW styles were 
useful back in the days of dumb frame buffers and monochrome video systems, but 
they are largely obsolete today. CS_CLASSDC, CS_OWNDC, and CS_PARENTDC are 
used to implement special handling of device contexts. You'll probably use 
CS_GLOBALCLASS only if you write custom controls to complement list boxes, push buttons, 
and other built-in control types. The CS_HREDRAW and CS_VREDRAW styles 
are useful for creating resizeable windows whose content scales with the window size.</P>

<P><I>hCursor</I> identifies the &quot;class cursor&quot; for windows created from this 
WNDCLASS. When the cursor moves over a window's client area, Windows retrieves the 
class cursor's handle from the window's WNDCLASS and uses it to draw the cursor 
image. You can create custom cursors using an icon editor, or you can use the 
predefined system cursors that Windows provides. 
<I>CWinApp::LoadStandardCursor</I> loads a system cursor. The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
AfxGetApp ()-&gt;LoadStandardCursor (IDC_ARROW);
</pre>
</td></tr></table>

<P>returns the handle of the arrow cursor that most Windows applications use. For a complete list of system cursors, see the documentation for 
<I>CWinApp::LoadStandardCursor</I> or the 
<I>::LoadCursor</I> API function. Generally speaking, only the 
IDC_ARROW, IDC_IBEAM, and IDC_CROSS cursors are useful as class cursors.</P>

<P>The <I>hbrBackground</I> parameter passed to 
<I>AfxRegisterWndClass</I> defines the window's default background color. Specifically, 
<I>hbrBackground</I> identifies the GDI brush that is used to erase the window's interior each time a 
WM_ERASEBKGND message arrives. A window receives a WM_ERASEBKGND message when it 
calls <I>::BeginPaint</I> in response to a WM_PAINT message. If you don't process 
WM_ERASEBKGND messages yourself, Windows processes them for you by retrieving the 
class background brush and using it to fill the window's client area. (You can create 
custom window backgrounds&#8212;for example, backgrounds formed from bitmap 
images&#8212;by processing WM_ERASEBKGND messages yourself and returning a nonzero 
value. The nonzero return prevents Windows from painting the background and 
overwriting what you wrote.) You can either provide a brush handle for 
<I>hbrBackground</I> or specify one of the predefined Windows system colors with the value 1 added to it, 
as in COLOR_WINDOW+1 or COLOR_APPWORKSPACE+1. See the documentation 
for the <I>::GetSysColor</I> API function for a complete list of system colors.</P>

<P>The final <I>AfxRegisterWndClass</I> parameter, 
<I>hIcon</I>, specifies the handle of the icon that Windows uses to represent the application on the desktop, in the 
taskbar, and elsewhere. You can create a custom icon for your application and load it 
with <I>CWinApp::LoadIcon</I>, or you can load a predefined system icon with 
<I>CWinApp::LoadStandardIcon</I>. You can even load icons from other executable files using the 
<I>::ExtractIcon</I> API function.</P>

<P>Here's what the code to register a custom WNDCLASS looks like in TicTac.cpp:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CString strWndClass = AfxRegisterWndClass (
    CS_DBLCLKS,
    AfxGetApp ()-&gt;LoadStandardCursor (IDC_ARROW),
    (HBRUSH) (COLOR_3DFACE + 1),
    AfxGetApp ()-&gt;LoadStandardIcon (IDI_WINLOGO)
);
</pre>
</td></tr></table>

<P>The class style CS_DBLCLKS registers the TicTac window to receive 
double-click messages. IDC_ARROW tells Windows to display the standard arrow when the 
cursor is over the TicTac window, and IDI_WINLOGO is one of the standard icons 
that Windows makes available to all applications. COLOR_3DFACE+1 assigns the 
TicTac window the same background color as push buttons, dialog boxes, and other 
3D display elements. COLOR_3DFACE defaults to light gray, but you can change the 
color by using the system's Display Properties property sheet. Using COLOR_3DFACE 
for the background color gives your window the same 3D look as a dialog box or 
message box <I>and</I> enables it to adapt to changes in the Windows color scheme.</P>

<A NAME="75"><H3><I>AfxRegisterWndClass</I> and Frame Windows</H3></A>
<P>The <I>AfxRegisterWndClass</I> function isn't only for applications that derive 
window classes from <I>CWnd</I>; you can also use it to register custom WNDCLASSes for 
frame windows. The default WNDCLASS that MFC registers for frame windows has the 
following attributes:</P>

<UL>
<P><LI>
<I>nClassStyle</I> = CS_DBLCLKS &#166; CS_HREDRAW &#166; CS_VREDRAW
</LI></P>

<P><LI>
<I>hCursor</I> = The handle of the predefined cursor IDC_ARROW
</LI></P>

<P><LI>
<I>hbrBackground</I> = COLOR_WINDOW+1
</LI></P>

<P><LI>
<I>hIcon</I> = The handle of the icon whose resource ID is 
AFX_IDI_STD_FRAME or AFX_IDI_STD_MDIFRAME, or the system icon ID 
IDI_APPLICATION if no such resource is defined
</LI></P>
</UL>

<P>Suppose you want to create a <I>CFrameWnd</I> frame window that lacks the 
CS_DBLCLKS style, that uses the IDI_WINLOGO icon, and that uses 
COLOR_APPWORKSPACE as its default background color. Here's how to create a frame window that meets these qualifications:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CString strWndClass = AfxRegisterWndClass (
    CS_HREDRAW &#166; CS_VREDRAW,
    AfxGetApp ()-&gt;LoadStandardCursor (IDC_ARROW),
    (HBRUSH) (COLOR_APPWORKSPACE + 1),
    AfxGetApp ()-&gt;LoadStandardIcon (IDI_WINLOGO)
);

Create (strWndClass, _T (&quot;My Frame Window&quot;));
</pre>
</td></tr></table>

<P>These statements replace the</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
Create (NULL, _T (&quot;My Frame Window&quot;));
</pre>
</td></tr></table>

<P>statement that normally appears in a frame window's constructor.</P>

<A NAME="76"><H3>More About the TicTac Window</H3></A>

<P>After registering a WNDCLASS, TicTac creates its main window with a call to 
<I>CWnd::CreateEx</I>:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CreateEx (0, strWndClass, _T (&quot;Tic-Tac-Toe&quot;),
    WS_OVERLAPPED &#166; WS_SYSMENU &#166; WS_CAPTION &#166; WS_MINIMIZEBOX,
    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
    NULL, NULL);
</pre>
</td></tr></table>

<P>The first parameter specifies the extended window style and is a combination of 
zero or more WS_EX flags. TicTac requires no extended window styles, so this 
parameter is 0. The second parameter is the WNDCLASS name returned by 
<I>AfxRegisterWndClass</I>, and the third is the window title. The fourth is the window style. The combination 
of WS_OVERLAPPED, WS_SYSMENU, WS_CAPTION, and WS_MINIMIZEBOX 
creates a window that resembles a WS_OVERLAPPEDWINDOW-style window but lacks 
a maximize button and can't be resized. What is it about the window that makes 
it nonresizeable? Look up the definition of WS_OVERLAPPEDWINDOW in 
Winuser.h (one of several large header files that comes with Visual C++), and you'll see 
something like this:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED &#166; WS_CAPTION &#166; \
    WS_SYSMENU &#166; WS_THICKFRAME &#166; WS_MINIMIZE &#166; WS_MAXIMIZE)
</pre>
</td></tr></table>

<P>The WS_THICKFRAME style adds a resizing border whose edges and corners can 
be grabbed and dragged with the mouse. TicTac's window lacks this style, so the 
user can't resize it.</P>

<P>The next four parameters passed to 
<I>CWnd::CreateEx</I> specify the window's initial position and size. TicTac uses CW_USEDEFAULT for all four so that Windows 
will pick the initial position and size. Yet clearly the TicTac window is not arbitrarily 
sized; it is sized to match the playing grid. But how? The statements following the call 
to <I>CreateEx</I> hold the answer:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CRect rect (0, 0, 352, 352);
CalcWindowRect (&amp;rect);

SetWindowPos (NULL, 0, 0, rect.Width (), rect.Height (),
    SWP_NOZORDER &#166; SWP_NOMOVE &#166; SWP_NOREDRAW);
</pre>
</td></tr></table>

<P>The first of these statements creates a 
<I>CRect</I> object that holds the desired size of 
the window's client area&#8212;352 by 352 pixels. It wouldn't do to pass these values 
directly to <I>CreateEx</I> because 
<I>CreateEx</I>'s sizing parameters specify the size of the 
entire window, not just its client area. Since the sizes of the various elements in the 
window's nonclient area (for example, the height of the title bar) vary with different video 
drivers and display resolutions, we must calculate the size of the window rectangle 
from the client rectangle and then size the window to fit.</P>

<P>MFC's <I>CWnd::CalcWindowRect</I> is the perfect tool for the job. Given a 
pointer to a <I>CRect</I> object containing the coordinates of a window's client area, 
<I>CalcWindowRect</I> calculates the corresponding window rectangle. The width and height of that 
rectangle can then be passed to 
<I>CWnd::SetWindowPos</I> to effect the proper window 
size. The only catch is that <I>CalcWindowRect</I> must be called 
<I>after</I> the window is created so that it can factor in the dimensions of the window's nonclient area.</P>

<A NAME="77"><H3>The <I>PostNcDestroy</I> Function</H3></A>
<P>Something you must consider when you derive your own window class from 
<I>CWnd</I> is that once created, the window object must somehow be deleted. As described 
in Chapter 2, the last message a window receives before it is destroyed is 
WM_NCDESTROY. MFC's <I>CWnd</I> class includes a default 
<I>OnNcDestroy</I> handler that performs some routine cleanup chores and then, as its very last act, calls a virtual function 
named <I>PostNcDestroy</I>. <I>CFrameWnd</I> objects delete themselves when the windows they 
are attached to are destroyed; they do this by overriding 
<I>PostNcDestroy</I> and executing a <I>delete 
this</I> statement. <I>CWnd::PostNcDestroy</I> does not perform a 
<I>delete this</I>, so a class derived from 
<I>CWnd</I> should provide its own version of 
<I>PostNcDestroy</I> that does. TicTac includes a trivial 
<I>PostNcDestroy</I> function that destroys the 
<I>CMainWindow</I> object just before the program terminates:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
void CMainWindow::PostNcDestroy ()
{
    delete this;
}
</pre>
</td></tr></table>

<P>The question of &quot;who deletes it&quot; is something you should think about 
whenever you derive a window class from 
<I>CWnd</I>. One alternative to overriding 
<I>CWnd::PostNcDestroy</I> is to override 
<I>CWinApp::ExitInstance</I> and call 
<I>delete</I> on the pointer stored in 
<I>m_pMainWnd</I>.</P>

<A NAME="78"><H2>Nonclient-Area Mouse Messages</H2></A>

<P>When the mouse is clicked inside or moved over a window's nonclient area, 
Windows sends the window a nonclient-area mouse message. The following table lists 
the nonclient-area mouse messages.</P>

<P><B>Nonclient-Area Mouse Messages</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Message</I></th>     
<th valign="top"><I>Sent When</I></th>
</tr>
<tr>
<td valign="top">WM_NCLBUTTONDOWN</td>     
<td valign="top">The left mouse button is pressed.</td>
</tr>
<tr>
<td valign="top">WM_NCLBUTTONUP</td>     
<td valign="top">The left mouse button is released.</td>
</tr>
<tr>
<td valign="top">WM_NCLBUTTONDBLCLK</td>     
<td valign="top">The left mouse button is double-clicked.</td>
</tr>
<tr>
<td valign="top">WM_NCMBUTTONDOWN</td>     
<td valign="top">The middle mouse button is pressed.</td>
</tr>
<tr>
<td valign="top">WM_NCMBUTTONUP</td>     
<td valign="top">The middle mouse button is released.</td>
</tr>
<tr>
<td valign="top">WM_NCMBUTTONDBLCLK</td>     
<td valign="top">The middle mouse button is double-clicked.</td>
</tr>
<tr>
<td valign="top">WM_NCRBUTTONDOWN</td>     
<td valign="top">The right mouse button is pressed.</td>
</tr>
<tr>
<td valign="top">WM_NCRBUTTONUP</td>     
<td valign="top">The right mouse button is released.</td>
</tr>
<tr>
<td valign="top">WM_NCRBUTTONDBLCLK</td>     
<td valign="top">The right mouse button is double-clicked.</td>
</tr>
<tr>
<td valign="top">WM_NCMOUSEMOVE</td>     
<td valign="top">The cursor is moved over the window's nonclient area.</td>
</tr></table></p>

<P>Notice the parallelism between the client-area mouse messages shown in the 
table below and the nonclient-area mouse messages; the only difference is the 
letters <I>NC </I>in the message ID. Unlike double-click messages in a window's client 
area, WM_NC<I>x</I>BUTTONDBLCLK messages are transmitted regardless of whether the 
window was registered with the CS_DBLCLKS style.</P>

<P>As with client-area mouse messages, message-map entries route messages 
to the appropriate class member functions. The following table lists the 
message-map macros and message handlers for nonclient-area mouse messages.</P>

<P><B>Message-Map Macros and Message Handlers for Nonclient-Area Mouse Messages</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Message</I></th>     
<th valign="top"><I>Message-Map Macro</I></th>     
<th valign="top"><I>Handling Function</I></Th>
</tr>
<tr>
<td valign="top">WM_NCLBUTTONDOWN</td>     
<td valign="top">ON_WM_NCLBUTTONDOWN</td>     
<td valign="top"><I>OnNcLButtonDown</I></td>
</tr>
<tr>
<td valign="top">WM_NCLBUTTONUP</td>     
<td valign="top">ON_WM_NCLBUTTONUP</td>     
<td valign="top"><I>OnNcLButtonUp</I></td>
</tr>
<tr>
<td valign="top">WM_NCLBUTTONDBLCLK</td>     
<td valign="top">ON_WM_NCLBUTTONDBLCLK</td>     
<td valign="top"><I>OnNcLButtonDblClk</I></td>
</tr>
<tr>
<td valign="top">WM_NCMBUTTONDOWN</td>     
<td valign="top">ON_WM_NCMBUTTONDOWN</td>     
<td valign="top"><I>OnNcMButtonDown</I></td>
</tr>
<tr>
<td valign="top">WM_NCMBUTTONUP</td>     
<td valign="top">ON_WM_NCMBUTTONUP</td>     
<td valign="top"><I>OnNcMButtonUp</I></td>
</tr>
<tr>
<td valign="top">WM_NCMBUTTONDBLCLK</td>     
<td valign="top">ON_WM_NCMBUTTONDBLCLK</td>     
<td valign="top"><I>OnNcMButtonDblClk</I></td>
</tr>
<tr>
<td valign="top">WM_NCRBUTTONDOWN</td>     
<td valign="top">ON_WM_NCRBUTTONDOWN</td>     
<td valign="top"><I>OnNcRButtonDown</I></td>
</tr>
<tr>
<td valign="top">WM_NCRBUTTONUP</td>     
<td valign="top">ON_WM_NCRBUTTONUP</td>     
<td valign="top"><I>OnNcRButtonUp</I></td>
</tr>
<tr>
<td valign="top">WM_NCRBUTTONDBLCLK</td>     
<td valign="top">ON_WM_NCRBUTTONDBLCLK</td>     
<td valign="top"><I>OnNcRButtonDblClk</I></td>
</tr>
<tr>
<td valign="top">WM_NCMOUSEMOVE</td>     
<td valign="top">ON_WM_NCMOUSEMOVE</td>     
<td valign="top"><I>OnNcMouseMove</I></td>
</tr></table></p>

<P>Message handlers for nonclient-area mouse messages are prototyped this way:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
afx_msg void On<I>MsgName</I> (UINT nHitTest, CPoint point)

</pre>
</td></tr></table>

<P>Once again, the <I>point</I> parameter specifies the location in the window at which 
the event occurred. But for nonclient-area mouse messages, 
<I>point.x</I> and <I>point.y</I> contain screen coordinates rather than client coordinates. In screen coordinates, (0,0) 
corresponds to the upper left corner of the screen, the positive 
<I>x</I> and <I>y</I> axes point to the right and down, and one unit in any direction equals one pixel. If you want, you 
can convert screen coordinates to client coordinates with 
<I>CWnd::ScreenToClient</I>. The <I>nHitTest</I> parameter contains a hit-test code that identifies where in the 
window's nonclient area the event occurred. Some of the most interesting hit-test codes 
are shown in the following table. You'll find a complete list of hit-test codes in the 
documentation for WM_NCHITTEST or 
<I>CWnd::OnNcHitTest</I>.</P>

<P><B>Commonly Used Hit-Test Codes</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Value</I></th>     
<th valign="top"><I>Corresponding Location</I></th>
</tr>
<tr>
<td valign="top">HTCAPTION</td>     
<td valign="top">The title bar</td>
</tr>
<tr>
<td valign="top">HTCLOSE</td>     
<td valign="top">The close button</td>
</tr>
<tr>
<td valign="top">HTGROWBOX</td>     
<td valign="top">The restore button (same as HTSIZE)</td>
</tr>
<tr>
<td valign="top">HTHSCROLL</td>     
<td valign="top">The window's horizontal scroll bar</td>
</tr>
<tr>
<td valign="top">HTMENU</td>     
<td valign="top">The menu bar</td>
</tr>
<tr>
<td valign="top">HTREDUCE</td>     
<td valign="top">The minimize button</td>
</tr>
<tr>
<td valign="top">HTSIZE</td>     
<td valign="top">The restore button (same as HTGROWBOX)</td>
</tr>
<tr>
<td valign="top">HTSYSMENU</td>     
<td valign="top">The system menu box</td>
</tr>
<tr>
<td valign="top">HTVSCROLL</td>     
<td valign="top">The window's vertical scroll bar</td>
</tr>
<tr>
<td valign="top">HTZOOM</td>     
<td valign="top">The maximize button</td>
</tr></table></p>

<P>Programs don't usually process nonclient-area mouse messages; they 
allow Windows to process them instead. Windows provides appropriate default 
responses that frequently result in still more messages being sent to the window. For 
example, when Windows processes a WM_NCLBUTTONDBLCLK message with a hit-test 
value equal to HTCAPTION, it sends the window a WM_SYSCOMMAND message 
with <I>wParam</I> equal to SC_MAXIMIZE or SC_RESTORE to maximize or unmaximize 
the window. You can prevent double clicks on a title bar from affecting a window 
by including the following message handler in the window class:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
// In CMainWindow's message map
ON_WM_NCLBUTTONDBLCLK ()
  
  <img src="images/grayvellip.JPG" width=3 height=13 border="0">
void CMainWindow::OnNcLButtonDblClk (UINT nHitTest, CPoint point)
{
    if (nHitTest != HTCAPTION)
        CWnd::OnNcLButtonDblClk (nHitTest, point);
}
</pre>
</td></tr></table>

<P>Calling the base class's 
<I>OnNcLButtonDblClk</I> handler passes the message to 
Windows and allows default processing to take place. Returning without calling the base 
class prevents Windows from knowing that the double click occurred. You can use 
other hit-test values to customize the window's response to other nonclient-area 
mouse events.</P>

<A NAME="79"><H2>The WM_NCHITTEST Message</H2></A>

<P>Before a window receives a client-area or nonclient-area mouse message, it 
receives a WM_NCHITTEST message accompanied by the cursor's screen coordinates. 
Most applications don't process WM_NCHITTEST messages, instead electing to let 
Windows process them. When Windows processes a WM_NCHITTEST message, it uses the 
cursor coordinates to determine what part of the window the cursor is over and then 
generates either a client-area or nonclient-area mouse message.</P>

<P>One clever use of an <I>OnNcHitTest</I> handler is for substituting the HTCAPTION 
hit-test code for HTCLIENT, which creates a window that can be dragged by its client area:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
// In CMainWindow's message map
ON_WM_NCHITTEST ()

  <img src="images/grayvellip.JPG" width=3 height=13 border="0">
UINT CMainWindow::OnNcHitTest (CPoint point)
{
    UINT nHitTest = CFrameWnd::OnNcHitTest (point);
    if (nHitTest == HTCLIENT)
        nHitTest = HTCAPTION;
    return nHitTest;
}
</pre>
</td></tr></table>

<P>As this example demonstrates, WM_NCHITTEST messages that you don't process 
yourself should be forwarded to the base class so that other aspects of the program's operation aren't affected.</P>

<A NAME="80"><H2>The WM_MOUSELEAVE and WM_MOUSEHOVER Messages</H2></A>

<P>It's easy to tell when the cursor enters a window or moves over it because the 
window receives WM_MOUSEMOVE messages. The 
<I>::TrackMouseEvent</I> function, which debuted in Windows NT 4.0 and is also supported in Windows 98, makes it 
equally easy to determine when the cursor leaves a window or hovers motionlessly over 
the top of it. With <I>::TrackMouseEvent</I>, an application can register to receive 
WM_MOUSELEAVE messages when the cursor leaves a window and WM_MOUSEHOVER 
messages when the cursor hovers over a window.</P>

<P><I>::TrackMouseEvent</I> accepts just one parameter: a pointer to a 
TRACKMOUSEEVENT structure. The structure is defined this way in Winuser.h:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct tagTRACKMOUSEEVENT {
    DWORD cbSize;
    DWORD dwFlags;
    HWND  hwndTrack;
    DWORD dwHoverTime;
} TRACKMOUSEEVENT;
</pre>
</td></tr></table>

<P><I>cbSize</I> holds the size of the structure. 
<I>dwFlags</I> holds bit flags specifying what the 
caller wants to do: register to receive WM_MOUSELEAVE messages (TME_LEAVE), 
register to receive WM_MOUSEHOVER messages (TME_HOVER), cancel 
WM_MOUSELEAVE and WM_MOUSEHOVER messages (TME_CANCEL), or have the system fill 
the TRACKMOUSEEVENT structure with the current 
<I>::TrackMouseEvent</I> settings (TME_QUERY). 
<I>hwndTrack</I> is the handle of the window for which 
WM_MOUSELEAVE and WM_MOUSEHOVER messages are generated. 
<I>dwHoverTime</I> is the length of time in milliseconds that the cursor must pause before a WM_MOUSEHOVER message 
is sent to the underlying window. You can accept the system default of 400 
milliseconds by setting <I>dwHoverTime</I> equal to HOVER_DEFAULT.</P>

<P>The cursor doesn't have to be perfectly still for the system to generate 
a WM_MOUSEHOVER message. If the cursor stays within a rectangle whose width 
and height equal the values returned by 
<I>::SystemParametersInfo</I> when it's called 
with SPI_GETMOUSEHOVERWIDTH and SPI_GETMOUSEHOVERHEIGHT values, and 
if it stays there for the number of milliseconds returned by 
<I>::SystemParametersInfo</I> when it's called with an SPI_GETMOUSEHOVERTIME value, a WM_MOUSEHOVER 
message ensues. If you want, you can change these parameters by calling 
<I>::SystemParametersInfo</I> with SPI_SETMOUSEHOVERWIDTH, 
SPI_SETMOUSEHOVERHEIGHT, and SPI_SETMOUSEHOVERTIME values.</P>

<P>One of the more interesting aspects of <I>::TrackMouseEvent 
</I>is that its effects are cancelled when a WM_MOUSELEAVE or WM_MOUSEHOVER message is 
generated. This means that if you want to receive these message anytime the cursor exits 
or pauses over a window, you must call 
<I>::TrackMouseEvent</I> again whenever a WM_MOUSELEAVE or WM_MOUSEHOVER message is received. To illustrate, the 
following code snippet writes &quot;Mouse enter,&quot; &quot;Mouse leave,&quot; or &quot;Mouse hover&quot; to the 
debug output window anytime the mouse enters, leaves, or pauses over a 
window. <I>m_bMouseOver</I> is a BOOL 
<I>CMainWindow</I> member variable. It should be set to 
FALSE in the class constructor:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
// In the message map
ON_WM_MOUSEMOVE ()
ON_MESSAGE (WM_MOUSELEAVE, OnMouseLeave)
ON_MESSAGE (WM_MOUSEHOVER, OnMouseHover)

  <img src="images/grayvellip.JPG" width=3 height=13 border="0">
void CMainWindow::OnMouseMove (UINT nFlags, CPoint point)
{
    if (!m_bMouseOver) {
        TRACE (_T (&quot;Mouse enter\n&quot;));
        m_bMouseOver = TRUE;

        TRACKMOUSEEVENT tme;
        tme.cbSize = sizeof (tme);
        tme.dwFlags = TME_HOVER | TME_LEAVE;
        tme.hwndTrack = m_hWnd;
        tme.dwHoverTime = HOVER_DEFAULT;
        ::TrackMouseEvent (&amp;tme);
    }
}

LRESULT CMainWindow::OnMouseLeave (WPARAM wParam, LPARAM lParam)
{
    TRACE (_T (&quot;Mouse leave\n&quot;));
    m_bMouseOver = FALSE;
    return 0;
}

LRESULT CMainWindow::OnMouseHover (WPARAM wParam, LPARAM lParam)
{
    TRACE (_T (&quot;Mouse hover (x=%d, y=%d)\n&quot;),
        LOWORD (lParam), HIWORD (lParam));

    TRACKMOUSEEVENT tme;
    tme.cbSize = sizeof (tme);
    tme.dwFlags = TME_HOVER | TME_LEAVE;
    tme.hwndTrack = m_hWnd;
    tme.dwHoverTime = HOVER_DEFAULT;
    ::TrackMouseEvent (&amp;tme);
    return 0;
}
</pre>
</td></tr></table>

<P>MFC doesn't provide type-specific message-mapping macros for 
WM_MOUSELEAVE and WM_MOUSEHOVER messages, so as this example demonstrates, you 
must use the ON_MESSAGE macro to link these messages to class member functions. 
The <I>lParam</I> value accompanying a WM_MOUSEHOVER message holds the cursor's 
<I>x</I> coordinate in its low word and the cursor's 
<I>y</I> coordinate in its high word. 
<I>wParam</I> is unused. Both <I>wParam</I> and 
<I>lParam</I> are unused in WM_MOUSELEAVE messages.</P>

<P>One final note regarding 
<I>::TrackMouseEvent</I>: In order to use it, you must 
include the following #define in your source code:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
#define _WIN32<I>_</I>WINNT 0x0400
</pre>
</td></tr></table>

<P>Be sure to include this line before the line that #includes Afxwin.h. Otherwise, it 
will have no effect.</P>

<A NAME="81"><H2>The Mouse Wheel</H2></A>

<P>Many of the mice used with Windows today include a wheel that can be used to 
scroll a window without clicking the scroll bar. When the wheel is rolled, the window 
with the input focus receives WM_MOUSEWHEEL messages. MFC's 
<I>CScrollView</I> class provides a default handler for these messages that automatically scrolls the window, 
but if you want mouse wheel messages to scroll a 
non-<I>CScrollView</I> window, you must process WM_MOUSEWHEEL messages yourself.</P>

<P>MFC's ON_WM_MOUSEWHEEL macro maps WM_MOUSEWHEEL messages 
to the message handler <I>OnMouseWheel</I>. 
<I>OnMouseWheel</I> is prototyped like this:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL OnMouseWheel (UINT nFlags, short zDelta, CPoint point)
</pre>
</td></tr></table>

<P>The <I>nFlags</I> and <I>point</I> parameters are identical to those passed to 
<I>OnLButtonDown</I>. <I>zDelta</I> is the distance the wheel was rotated. A 
<I>zDelta</I> equal to WHEEL_DELTA (120) means the wheel was rotated forward one increment, or 
<I>notch</I>, and _WHEEL_DELTA means the wheel was rotated backward one notch. If the wheel is 
rotated forward five notches, the window will receive five WM_MOUSEWHEEL 
messages, each with a <I>zDelta</I> of WHEEL_DELTA. 
<I>OnMouseWheel</I> should return a nonzero value if it scrolled the window, or zero if it did not.</P>

<P>A simple way to respond to a WM_MOUSEWHEEL message is to scroll the 
window one line up (if <I>zDelta</I> is positive) or one line down (if 
<I>zDelta</I> is negative) for every WHEEL_DELTA unit. The recommended approach, however, is slightly 
more involved. First you ask the system for the number of lines that corresponds 
to WHEEL_DELTA units. In Windows NT 4.0 and higher and in Windows 98, you 
can get this value by calling 
<I>::SystemParametersInfo</I> with a first parameter equal 
to SPI_GETWHEELSCROLLLINES. Then you multiply the result by 
<I>zDelta</I> and divide by WHEEL_DELTA to determine how many lines to scroll. You can modify the Accel 
program presented in <a href="ch02a.htm">Chapter 2</a> to respond to WM_MOUSEWHEEL messages in this 
manner by adding the following message-map entry and message handler to 
<I>CMainWindow</I>:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
// In the message map
ON_WM_MOUSEWHEEL ()

  <img src="images/grayvellip.JPG" width=3 height=13 border="0">
BOOL CMainWindow::OnMouseWheel (UINT nFlags, short zDelta, CPoint point)
{
    BOOL bUp = TRUE;
    int nDelta = zDelta;

    if (zDelta &lt; 0) {
        bUp = FALSE;
        nDelta = -nDelta;
    }

    UINT nWheelScrollLines;
    ::SystemParametersInfo (SPI_GETWHEELSCROLLLINES, 0,
        &amp;nWheelScrollLines, 0);

    if (nWheelScrollLines == WHEEL_PAGESCROLL) {
        SendMessage (WM_VSCROLL,
            MAKEWPARAM (bUp ? SB_PAGEUP : SB_PAGEDOWN, 0), 0);
    }
    else {
        int nLines = (nDelta * nWheelScrollLines) / WHEEL_DELTA;
        while (nLines--)
            SendMessage (WM_VSCROLL,
                MAKEWPARAM (bUp ? SB_LINEUP : SB_LINEDOWN, 0), 0);
    }
    return TRUE;
}
</pre>
</td></tr></table>

<P>Dividing <I>zDelta</I> by WHEEL_DELTA ensures that the application won't scroll too 
quickly if, in the future, it's used with a mouse that has a wheel granularity less than 120 
units. WHEEL_PAGESCROLL is a special value that indicates the application should 
simulate a click of the scroll bar shaft&#8212;in other words, perform a page-up or 
page-down. Both WHEEL_DELTA and WHEEL_PAGESCROLL are defined in Winuser.h.</P>

<P>One issue to be aware of regarding this code sample is that it's not 
compatible with Windows 95. Why? Because calling 
<I>::SystemParametersInfo</I> with an SPI_GETWHEELSCROLLLINES value does nothing in Windows 95. If you want to support 
Windows 95, you can either assume that 
<I>::SystemParametersInfo</I> would return 3 (the 
default) or resort to more elaborate means to obtain the user's preference. MFC uses an 
internal function named 
<I>_AfxGetMouseScrollLines</I> to get this value. 
<I>_AfxGetMouseScrollLines</I> is platform-neutral; it uses various methods to attempt to obtain a scroll line count 
and defaults to 3 if none of those methods work. See the MFC source code file 
Viewscrl.cpp if you'd like to mimic that behavior in your code.</P>

<P>If the mouse wheel is clicked rather than rotated, the window under the 
cursor generally receives middle-button mouse messages&#8212;WM_MBUTTONDOWN 
messages when the wheel is pressed, WM_MBUTTONUP messages when the wheel is 
released. (I say &quot;generally&quot; because this is the default behavior; it can be changed through 
the Control Panel.) Some applications respond to wheel clicks in a special way. 
Microsoft Word 97, for example, scrolls the currently displayed document when it 
receives WM_MOUSEMOVE messages with the wheel held down. Knowing that the 
mouse wheel produces middle-button messages, you can customize your applications 
to respond to mouse wheel events any way you see fit.</P>

<A NAME="82"><H2>Capturing the Mouse</H2></A>

<P>One problem that frequently crops up in programs that process mouse messages 
is that the receipt of a button-down message doesn't necessarily mean that a 
button-up message will follow. Suppose you've written a drawing program that saves the 
<I>point</I> parameter passed to 
<I>OnLButtonDown</I> and uses it as an anchor point to draw a 
line whose other endpoint follows the cursor&#8212;an action known as &quot;rubber-banding&quot; 
a line. When a WM_LBUTTONUP message arrives, the application erases the 
rubber-band line and draws a real line in its place. But what happens if the user moves 
the mouse outside the window's client area before releasing the mouse button? The 
application never gets that WM_LBUTTONUP message, so the rubber-band line is 
left hanging in limbo and the real line isn't drawn.</P>

<P>Windows provides an elegant solution to this problem by allowing an 
application to &quot;capture&quot; the mouse upon receiving a button-down message and to 
continue receiving mouse messages no matter where the cursor goes on the screen until 
the button is released or the capture is canceled. (In the Win32 environment, to 
prevent applications from monopolizing the mouse, the system stops sending mouse 
messages to a window that owns the capture if the button is released.) The mouse 
is captured with <I>CWnd::SetCapture</I> and released with 
<I>::ReleaseCapture</I>. Calls to these functions are normally paired in button-down and button-up handlers, as shown here:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
// In CMainWindow's message map
ON_WM_LBUTTONDOWN ()
ON_WM_LBUTTONUP ()

  <img src="images/grayvellip.JPG" width=3 height=13 border="0">
void CMainWindow::OnLButtonDown (UINT nFlags, CPoint point)
{
    SetCapture ();
}

void CMainWindow::OnLButtonUp (UINT nFlags, CPoint point)
{
    ::ReleaseCapture ();
}
</pre>
</td></tr></table>

<P>In between, <I>CMainWindow</I> receives WM_MOUSEMOVE messages that report 
the cursor position even if the cursor leaves it. Client-area mouse messages continue 
to report cursor positions in client coordinates, but coordinates can now go 
negative and can also exceed the dimensions of the window's client area.</P>

<P>A related function, <I>CWnd::GetCapture</I>, returns a 
<I>CWnd</I> pointer to the window that owns the capture. In the Win32 environment, 
<I>GetCapture</I> returns NULL if the mouse is not captured or if it's captured by a window belonging to another 
thread. The most common use of <I>GetCapture</I> is for determining whether your own 
window has captured the mouse. The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
if (GetCapture () == this)
</pre>
</td></tr></table>

<P>is true if and only if the window identified by 
<I>this</I> currently has the mouse captured.</P>

<P>How does capturing the mouse solve the problem with the rubber-banded 
line? By capturing the mouse in response to a WM_LBUTTONDOWN message and 
releasing it when a WM_LBUTTONUP message arrives, you're guaranteed to get 
the WM_LBUTTONUP message when the mouse button is released. The sample 
program in the next section illustrates the practical effect of this technique.</P>

<A NAME="83"><H2>Mouse Capturing in Action</H2></A>

<P>The MouseCap application shown in Figure 3-4 is a rudimentary paint program 
that lets the user draw lines with the mouse. To draw a line, press the left mouse 
button anywhere in the window's client area and drag the cursor with the button held 
down. As the mouse is moved, a thin line is rubber-banded between the anchor point 
and the cursor. When the mouse button is released, the rubber-band line is erased and 
a red line 16 pixels wide is drawn in its place. Because the mouse is captured 
while the button is depressed, rubber-banding works even if the mouse is moved outside 
the window. And no matter where the cursor is when the mouse button is released, 
a red line is drawn between the anchor point and the endpoint. MouseCap's 
source code appears in Figure 3-5.</P>

<P>
<A HREF="javascript:fullSize('F03mg04x.htm')"> <img src="images/F03mg04.JPG" width=404 height=265 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 3-4.</B> <I>The MouseCap window.</I><!-- /CAPTION -->
</p>

<p><B>Figure 3-5.</B> <I>The MouseCap application.</I></p>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="84"><H3>MouseCap.h</H3></A>
<pre>
class CMyApp : public CWinApp
{
public:
    virtual BOOL InitInstance ();
};

class CMainWindow : public CFrameWnd
{
protected:
    BOOL m_bTracking;           // TRUE if rubber banding
    BOOL m_bCaptureEnabled;     // TRUE if capture enabled
    CPoint m_ptFrom;            // &quot;From&quot; point for rubber banding
    CPoint m_ptTo;              // &quot;To&quot; point for rubber banding

    void InvertLine (CDC* pDC, CPoint ptFrom, CPoint ptTo);

public:
    CMainWindow ();

protected:
    afx_msg void OnLButtonDown (UINT nFlags, CPoint point);
    afx_msg void OnLButtonUp (UINT nFlags, CPoint point);
    afx_msg void OnMouseMove (UINT nFlags, CPoint point);
    afx_msg void OnNcLButtonDown (UINT nHitTest, CPoint point);
    DECLARE_MESSAGE_MAP ()
};
</pre>
</td></tr></table>

<p>&nbsp;</p>

<table cellpadding=5 width="95%"><tr><td>
<H3>MouseCap.cpp</H3>
<pre>
#include &lt;afxwin.h&gt;
#include &quot;MouseCap.h&quot;

CMyApp myApp;

/////////////////////////////////////////////////////////////////////////
// CMyApp member functions

BOOL CMyApp::InitInstance ()
{
    m_pMainWnd = new CMainWindow;
    m_pMainWnd-&gt;ShowWindow (m_nCmdShow);

m_pMainWnd-&gt;UpdateWindow ();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////
// CMainWindow message map and member functions

BEGIN_MESSAGE_MAP (CMainWindow, CFrameWnd)
    ON_WM_LBUTTONDOWN ()
    ON_WM_LBUTTONUP ()
    ON_WM_MOUSEMOVE ()
    ON_WM_NCLBUTTONDOWN ()
END_MESSAGE_MAP ()

CMainWindow::CMainWindow ()
{
    m_bTracking = FALSE;
    m_bCaptureEnabled = TRUE;

    //
    // Register a WNDCLASS.
    //

    CString strWndClass = AfxRegisterWndClass (
        0,
        AfxGetApp ()-&gt;LoadStandardCursor (IDC_CROSS),
        (HBRUSH) (COLOR_WINDOW + 1),
        AfxGetApp ()-&gt;LoadStandardIcon (IDI_WINLOGO)
    );

    //
    // Create a window.
    //
    Create (strWndClass, _T (&quot;Mouse Capture Demo (Capture Enabled)&quot;));
}

void CMainWindow::OnLButtonDown (UINT nFlags, CPoint point)
{
    //
    // Record the anchor point and set the tracking flag.
    //
    m_ptFrom = point;
    m_ptTo = point;
    m_bTracking = TRUE;

    //
    // If capture is enabled, capture the mouse.
    //
    if (m_bCaptureEnabled)
        SetCapture ();
}

void CMainWindow::OnMouseMove (UINT nFlags, CPoint point)
{
    //
    // If the mouse is moved while we're &quot;tracking&quot; (that is, while a
    // line is being rubber-banded), erase the old rubber-band line and
    // draw a new one.
    //
    if (m_bTracking) {
        CClientDC dc (this);
        InvertLine (&amp;dc, m_ptFrom, m_ptTo);
        InvertLine (&amp;dc, m_ptFrom, point);
        m_ptTo = point;
    }
}

void CMainWindow::OnLButtonUp (UINT nFlags, CPoint point)
{
    //
    // If the left mouse button is released while we're tracking, release
    // the mouse if it's currently captured, erase the last rubber-band
    // line, and draw a thick red line in its place.
    //
    if (m_bTracking) {
        m_bTracking = FALSE;
        if (GetCapture () == this)
            ::ReleaseCapture ();

        CClientDC dc (this);
        InvertLine (&amp;dc, m_ptFrom, m_ptTo);

        CPen pen (PS_SOLID, 16, RGB (255, 0, 0));
        dc.SelectObject (&amp;pen);

        dc.MoveTo (m_ptFrom);
        dc.LineTo (point);
    }
}
void CMainWindow::OnNcLButtonDown (UINT nHitTest, CPoint point)
{
    //
    // When the window's title bar is clicked with the left mouse button,
    // toggle the capture flag on or off and update the window title.
    //
    if (nHitTest == HTCAPTION) {
        m_bCaptureEnabled = m_bCaptureEnabled ? FALSE : TRUE;
        SetWindowText (m_bCaptureEnabled ?
            _T (&quot;Mouse Capture Demo (Capture Enabled)&quot;) :
            _T (&quot;Mouse Capture Demo (Capture Disabled)&quot;));
    }
    CFrameWnd::OnNcLButtonDown (nHitTest, point);
}


void CMainWindow::InvertLine (CDC* pDC, CPoint ptFrom, CPoint ptTo)
{
    //
    //Invert a line of pixels by drawing a line in the R2_NOT drawing mode.
    //
    int nOldMode = pDC-&gt;SetROP2 (R2_NOT);
    pDC-&gt;MoveTo (ptFrom);
    pDC-&gt;LineTo (ptTo);

    pDC-&gt;SetROP2 (nOldMode);
}
</pre>
</td></tr></table>



<P>Most of the action takes place in the program's 
<I>OnLButtonDown</I>, <I>OnMouseMove</I>, and 
<I>OnLButtonUp</I> handlers. <I>OnLButtonDown</I> starts the drawing process by 
initializing a trio of variables that are members of the 
<I>CMainWindow</I> class:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_ptFrom = point;
m_ptTo = point;
m_bTracking = TRUE;
</pre>
</td></tr></table>

<P><I>m_ptFrom</I> and <I>m_ptTo</I> are the starting and ending points for the rubber-band 
line. <I>m_ptTo</I> is continually updated by the 
<I>OnMouseMove</I> handler as the mouse is moved. 
<I>m_bTracking</I>, which is TRUE when the left button is down and FALSE when it is 
not, is a flag that tells <I>OnMouseMove</I> and 
<I>OnLButtonUp</I> whether a line is being rubber-banded. 
<I>OnLButtonDown</I>'s only other action is to capture the mouse if 
<I>m_bCaptureEnabled</I> is TRUE:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
if (m_bCaptureEnabled)
    SetCapture ();
</pre>
</td></tr></table>

<P><I>m_bCaptureEnabled</I> is initialized to TRUE by 
<I>CMainWindow</I>'s constructor. It is toggled by the window's 
<I>OnNcLButtonDown</I> handler so that you can turn mouse 
capturing on and off and see the effect that mouse capturing has on the program's 
operation. (More on this in a moment.)</P>

<P><I>OnMouseMove</I>'s job is to move the rubber-band line and update 
<I>m_ptTo</I> with the new cursor position whenever the mouse is moved. The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
InvertLine (&amp;dc, m_ptFrom, m_ptTo);
</pre>
</td></tr></table>

<P>erases the previously drawn rubber-band line, and</P>


<table cellpadding=5 width="95%"><tr><td>
<pre>InvertLine (&amp;dc, m_ptFrom, point);
</pre>
</td></tr></table>

<P>draws a new one. <I>InvertLine</I> is a member of 
<I>CMainWindow</I>. It draws a line not by setting each pixel to a certain color, but by inverting the existing pixel colors. 
This ensures that the line can be seen no matter what background it is drawn against 
and that drawing the line again in the same location will erase it by restoring the 
original screen colors. The inversion is accomplished by setting the device context's 
drawing mode to R2_NOT with the statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
int nOldMode = pDC-&gt;SetROP2 (R2_NOT);
</pre>
</td></tr></table>

<P>See <a href="ch02a.htm">Chapter 2</a> for a discussion of R2_NOT and other drawing modes.</P>

<P>When the left mouse button is released, 
<I>CMainWindow::OnLButtonUp</I> is called. After setting 
<I>m_bTracking</I> to FALSE and releasing the mouse, it erases the 
rubber-band line drawn by the last call to 
<I>OnMouseMove</I>:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CClientDC dc (this);
InvertLine (&amp;dc, m_ptFrom, m_ptTo);
</pre>
</td></tr></table>

<P><I>OnLButtonUp</I> then creates a solid red pen 16 pixels wide, selects it into the 
device context, and draws a thick red line:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CPen pen (PS_SOLID, 16, RGB (255, 0, 0));
dc.SelectObject (&amp;pen);

dc.MoveTo (m_ptFrom);
dc.LineTo (point);
</pre>
</td></tr></table>

<P>Its work done, <I>OnLButtonUp</I> returns, and the drawing operation is complete. 
Figure 3-4 above shows what the MouseCap window looks like after a few lines 
have been drawn and as a new line is rubber-banded.</P>

<P>After you've played around with the program a bit, click the title bar to 
activate the <I>OnNcLButtonDown</I> handler and toggle the 
<I>m_bCaptureEnabled</I> flag from TRUE to FALSE. The window title should change from &quot;Mouse Capture Demo 
(Capture Enabled)&quot; to &quot;Mouse Capture Demo (Capture Disabled).&quot; 
<I>OnNcLButtonDown</I> processes left button clicks in the nonclient area and uses 
<I>CWnd::SetWindowText</I> to change the window title if the hit-test code in 
<I>nHitTest</I> is equal to HTCAPTION, indicating that the click occurred in the title bar.</P>

<P>Now draw a few lines with mouse capturing disabled. Observe that if you 
move the mouse outside the window while rubber-banding, the line freezes until the 
mouse reenters the client area, and that if you release the mouse button outside the 
window, the program gets out of sync. The rubber-band line follows the mouse when you 
move it back to the interior of the window (even though the mouse button is no 
longer pressed), and it never gets erased. Click the title bar once again to reenable 
mouse capturing, and the program will revert to its normal self.</P>

<A NAME="85"><H2>The Cursor</H2></A>

<P>Rather than use the arrow-shaped cursor you see in most Windows 
applications, MouseCap uses a crosshair cursor. Arrows and crosshairs are just two of several 
predefined cursor types that Windows places at your disposal, and if none of the 
predefined cursors fits the bill, you can always create your own. As usual, Windows gives 
programmers a great deal of latitude in this area.</P>

<P>First, a bit of background on how cursors work. As you know, every 
window has a corresponding WNDCLASS whose characteristics are defined in a 
WNDCLASS structure. One of the fields of the WNDCLASS structure is 
<I>hCursor</I>, which holds the handle of the class cursor&#8212;the image displayed when the cursor is over a 
window's client area. When the mouse is moved, Windows erases the cursor from its old 
location by redrawing the background behind it. Then it sends the window under 
the cursor a WM_SETCURSOR message containing a hit-test code. The system's 
default response to this message is to call 
<I>::SetCursor</I> to display the class cursor if the 
hit-test code is HTCLIENT or to display an arrow if the hit-test code indicates that the 
cursor is outside the client area. As a result, the cursor is automatically updated as it is 
moved about the screen. When you move the cursor into an edit control, for example, it 
changes into a vertical bar or &quot;I-beam&quot; cursor. This happens because Windows registers a 
special WNDCLASS for edit controls and specifies the I-beam cursor as the class cursor.</P>

<P>It follows that one way to change the cursor's appearance is to register a 
WNDCLASS and specify the desired cursor type as the class cursor. In MouseCap, 
<I>CMainWindow</I>'s constructor registers a WNDCLASS whose class cursor is IDC_CROSS 
and passes the WNDCLASS name to 
<I>CFrameWnd::Create</I>:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CString strWndClass = AfxRegisterWndClass (
    0,
    AfxGetApp ()-&gt;LoadStandardCursor (IDC_CROSS),
    (HBRUSH) (COLOR_WINDOW + 1),
    AfxGetApp ()-&gt;LoadStandardIcon (IDI_WINLOGO)
);

Create (strWndClass, _T (&quot;Mouse Capture Demo (Capture Enabled)&quot;));
</pre>
</td></tr></table>

<P>Windows then displays a crosshair cursor anytime the mouse pointer is positioned 
in <I>CMainWindow</I>'s client area.</P>

<P>A second way to customize the cursor is to call the API function 
<I>::SetCursor</I> in response to WM_SETCURSOR messages. The following 
<I>OnSetCursor</I> function displays the cursor whose handle is stored in 
<I>CMainWindow::m_hCursor</I> when the cursor is over 
<I>CMainWindow</I>'s client area:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
// In CMainWindow's message map
ON_WM_SETCURSOR ()

  <img src="images/grayvellip.JPG" width=3 height=13 border="0">
BOOL CMainWindow::OnSetCursor (CWnd* pWnd, UINT nHitTest,
    UINT message)
{
    if (nHitTest == HTCLIENT) {
        ::SetCursor (m_hCursor);
        return TRUE;
    }
    return CFrameWnd::OnSetCursor (pWnd, nHitTest, message);
}
</pre>
</td></tr></table>

<P>Returning TRUE after calling <I>::SetCursor</I> tells Windows that the cursor has been 
set. WM_SETCURSOR messages generated outside the window's client area are 
passed to the base class so that the default cursor is displayed. The class cursor is 
ignored because <I>OnSetCursor</I> never gives Windows the opportunity to display it.</P>

<P>Why would you want to use <I>OnSetCursor</I> rather than just registering 
<I>m_hCursor</I> as the class cursor? Suppose you want to display an arrow cursor when the cursor is 
in the top half of the window and an I-beam cursor when the cursor is in the 
bottom half. A class cursor won't suffice in this case, but 
<I>OnSetCursor</I> will do the job quite nicely. The following 
<I>OnSetCursor</I> handler sets the cursor to either 
<I>m_hCursorArrow</I> or <I>m_hCursorIBeam</I> when the cursor is in 
<I>CMainWindow</I>'s client area:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL CMainWindow::OnSetCursor (CWnd* pWnd, UINT nHitTest,
    UINT message)
{
    if (nHitTest == HTCLIENT) {
        DWORD dwPos = ::GetMessagePos ();
        CPoint point (LOWORD (dwPos), HIWORD (dwPos));
        ScreenToClient (&amp;point);
        CRect rect;
        GetClientRect (&amp;rect);
        ::SetCursor ((point.y &lt; rect.Height () / 2) ?
            m_hCursorArrow : m_hCursorIBeam);
        return TRUE;
    }
    return CFrameWnd::OnSetCursor (pWnd, nHitTest, message);
}
</pre>
</td></tr></table>

<P><I>::GetMessagePos</I> returns a DWORD value containing the cursor's 
<I>x</I> and <I>y</I> screen coordinates at the moment the WM_SETCURSOR message was retrieved from the 
message queue. <I>CWnd::ScreenToClient</I> converts screen coordinates to client 
coordinates. If the converted point's <I>y</I> coordinate is less than half the height of the window's 
client area, the cursor is set to 
<I>m_hCursorArrow</I>. But if <I>y</I> is greater than or equal to 
half the client area height, the cursor is set to 
<I>m_hCursorIBeam</I> instead. The VisualKB application presented later in this chapter uses a similar technique to change the 
cursor to an I-beam when it enters a rectangle surrounding a text-entry field.</P>

<P>Should the need ever arise, you can hide the cursor with the statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
::ShowCursor (FALSE);
</pre>
</td></tr></table>

<P>and display it again with</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
::ShowCursor (TRUE);
</pre>
</td></tr></table>

<P>Internally, Windows maintains a display count that's incremented each 
time <I>::ShowCursor (TRUE)</I> is called and decremented by each call to 
<I>::ShowCursor (FALSE)</I>. The count is initially set to 0 if a mouse is installed and to -1 if no mouse is 
present, and the cursor is displayed whenever the count is greater than or equal to 0. Thus, 
if you call <I>::ShowCursor (FALSE)</I> twice to hide the cursor, you must call 
<I>::ShowCursor (TRUE)</I> twice to display it again.</P>

<A NAME="86"><H2>The Hourglass Cursor</H2></A>

<P>When an application responds to a message by undertaking a lengthy processing 
task, it's customary to change the cursor to an hourglass to remind the user that the 
application is &quot;busy.&quot; (While a message handler executes, no further messages are 
retrieved from the message queue and the program is frozen to input. In <a href="ch17a.htm">Chapter 17</a>, 
you'll learn about ways to perform background processing tasks while continuing to 
retrieve and dispatch messages.)</P>

<P>Windows provides the hourglass cursor for you; its identifier is IDC_WAIT. 
An easy way to display an hourglass cursor is to declare a 
<I>CWaitCursor</I> variable on the stack, like this:
</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CWaitCursor wait;
</pre>
</td></tr></table>

<P><I>CWaitCursor</I>'s constructor displays an hourglass cursor, and its destructor 
restores the original cursor. If you'd like to restore the cursor before the variable goes out of 
scope, simply call <I>CWaitCursor::Restore</I>:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
wait.Restore ();
</pre>
</td></tr></table>

<P>You should call <I>Restore</I> before taking any action that would allow a 
WM_SETCURSOR message to seep through and destroy the hourglass&#8212;for example, before 
displaying a message box or a dialog box.</P>

<P>You can change the cursor displayed by 
<I>CWaitCursor::CWaitCursor</I> and 
<I>BeginWaitCursor</I> by overriding 
<I>CWinApp</I>'s virtual <I>DoWaitCursor</I> function. Use the 
default implementation of 
<I>CWinApp::DoWaitCursor</I> found in the MFC source code 
file Appui.cpp as a model for your own implementations.</P>

<A NAME="87"><H2>Mouse Miscellanea</H2></A>

<P>As mentioned earlier, calling the 
<I>::GetSystemMetrics</I> API function with an 
SM_CMOUSEBUTTONS argument queries the system for the number of mouse buttons. (There 
is no MFC equivalent to <I>::GetSystemMetrics</I>, so you must call it directly.) The usual 
return value is 1, 2, or 3, but a 0 return means no mouse is attached. You can also find 
out whether a mouse is present by calling 
<I>::GetSystemMetrics</I> this way:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
::GetSystemMetrics (SM_MOUSEPRESENT)
</pre>
</td></tr></table>

<P>The return value is nonzero if there is a mouse attached, 0 if there is not. In the 
early days of Windows, programmers had to consider the possibility that someone 
might be using Windows without a mouse. Today that's rarely a concern, and a program 
that queries the system to determine whether a mouse is present is a rare program indeed.</P>

<P>Other mouse-related <I>::GetSystemMetrics</I> parameters include 
SM_CXDOUBLECLK and SM_CYDOUBLECLK, which specify the maximum horizontal and vertical 
distances (in pixels) that can separate the two halves of a double click, and 
SM_SWAPBUTTON, which returns a nonzero value if the user has swapped the left and right mouse 
buttons using the Control Panel. When the mouse buttons are swapped, the left 
mouse button generates WM_RBUTTON messages and the right mouse button 
generates WM_LBUTTON messages. Generally you don't need to be concerned about this, 
but if for some reason your application wants to be sure that the left mouse button 
<I>really</I> means the left mouse button, it can use 
<I>::GetSystemMetrics</I> to determine whether the buttons have been swapped.</P>

<P>The API functions <I>::SetDoubleClickTime</I> and 
<I>::GetDoubleClickTime</I> enable an application to set and retrieve the mouse double-click time&#8212;the maximum amount 
of time permitted between clicks when a mouse button is double-clicked. The expression</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
::GetDoubleClickTime ()
</pre>
</td></tr></table>

<P>returns the double-click time in milliseconds, while the statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
::SetDoubleClickTime (250);
</pre>
</td></tr></table>

<P>sets the double-click time to 250 milliseconds, or one quarter of a second. When 
the same mouse button is clicked twice in succession, Windows uses both the 
double-click time and the SM_CXDOUBLECLK and SM_CYDOUBLECLK values 
returned by <I>::GetSystemMetrics</I> to determine whether to report the second of the two clicks as 
a double click.</P>

<P>A function that processes mouse messages can determine which, if any, 
mouse buttons are pressed by checking the 
<I>nFlags</I> parameter passed to the message handler. It's also possible to query the state of a mouse button outside a mouse 
message handler by calling <I>::GetKeyState</I> or 
<I>::GetAsyncKeyState</I> with a VK_LBUTTON, VK_MBUTTON, or VK_RBUTTON parameter. 
<I>::GetKeyState</I> should be called only from a keyboard message handler because it returns the state of the specified mouse 
button at the time the keyboard message was generated. 
<I>::GetAsyncKeyState</I> can be called anywhere, anytime. It works in real time, returning the state of the button at 
the moment the function is called. A negative return value from</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
::GetKeyState (VK_LBUTTON)
</pre>
</td></tr></table>

<P>or</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
::GetAsyncKeyState (VK_LBUTTON)
</pre>
</td></tr></table>

<P>indicates that the left mouse button is pressed. Swapping the mouse buttons does 
not affect <I>::GetAsyncKeyState</I>, so if you use this function, you should also use 
<I>::GetSystemMetrics</I> to determine whether the buttons have been swapped. The expression</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
::GetAsyncKeyState (::GetSystemMetrics (SM_SWAPBUTTON) ?
    VK_RBUTTON : VK_LBUTTON)
</pre>
</td></tr></table>

<P>checks the state of the left mouse button asynchronously and automatically 
queries the right mouse button instead if the buttons have been swapped.</P>

<P>Windows provides a pair of API functions named 
<I>::GetCursorPos</I> and <I>::SetCursorPos</I> for getting and setting the cursor position manually. 
<I>::GetCursorPos</I> copies the cursor coordinates to a POINT structure. A related function named 
<I>::GetMessagePos</I> returns a DWORD value containing a pair of 16-bit coordinates specifying where 
the cursor was when the last message was retrieved from the message queue. You 
can extract those coordinates using the Windows LOWORD and HIWORD macros:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
DWORD dwPos = ::GetMessagePos ();
int x = LOWORD (dwPos);
int y = HIWORD (dwPos);
</pre>
</td></tr></table>

<P><I>::GetCursorPos</I> and 
<I>::GetMessagePos</I> both report the cursor position in screen 
coordinates. Screen coordinates can be converted to client coordinates by calling a 
window's <I>ClientToScreen</I> function.</P>

<P>Windows also provides a function named 
<I>::ClipCursor</I> that restricts the cursor to a particular area of the screen. 
<I>::ClipCursor</I> accepts a pointer to a RECT 
structure that describes, in screen coordinates, the clipping rectangle. Since the cursor is 
a global resource shared by all applications, an application that uses 
<I>::ClipCursor</I> must free the cursor by calling</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
::ClipCursor (NULL);
</pre>
</td></tr></table>

<P>before terminating, or else the cursor will remain locked into the clipping 
rectangle indefinitely.</P>

</BODY>
</HTML>




