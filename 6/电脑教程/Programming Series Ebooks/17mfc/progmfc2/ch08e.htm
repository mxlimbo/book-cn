<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Property Sheets</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch08d.htm", "ch08f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="242"><H1>Property Sheets</H1></A>


<P>One feature of Windows that programmers of every stripe will appreciate is 
property sheets&#8212;tabbed dialog boxes containing pages of controls that the user can 
switch among with mouse clicks. Property sheets live in the common controls library 
provided with every copy of Windows. They're something of a chore to program 
using the Windows API, but they're relatively easy to implement in MFC thanks to the 
support provided by the framework. In fact, adding a property sheet to an MFC 
application isn't all that different from adding a dialog box. An MFC application that 
uses property sheets and runs on Windows 95 or later or Windows NT 3.51 or later 
uses the operating system's native property sheet implementation. On other 
platforms, MFC's private implementation is used instead.</P>

<P>The functionality of property sheets is neatly encapsulated in a pair of 
MFC classes named <I>CPropertySheet</I> and 
<I>CPropertyPage</I>. <I>CPropertySheet</I> represents 
the property sheet itself and is derived from 
<I>CWnd</I>. <I>CPropertyPage</I> represents a page 
in a property sheet and is derived from 
<I>CDialog</I>. Both are defined in the header 
file Afxdlgs.h. Like dialog boxes, property sheets can be modal or modeless. <I>CPropertySheet::DoModal</I> creates a modal property sheet, and 
<I>CPropertySheet::Create</I> creates a modeless property sheet.</P>

<P>The general procedure for creating a modal property sheet goes like this:</P>

<OL>
<P><LI>For each page in the property sheet, create a dialog template defining the page's contents and characteristics. Set the dialog title to the title you want to appear on the tab at the top of the property sheet page.</LI></P>

<P><LI>For each page in the property sheet, derive a dialog-like class from <I>CPropertyPage</I> that includes public data members linked to the page's controls via DDX or DDV.</LI></P>

<P>
<LI>Derive a property sheet class from 
<I>CPropertySheet</I>. Instantiate the property sheet class and the property sheet page classes you derived in step 
2. Use <I>CPropertySheet::AddPage</I> to add the pages to the property sheet 
in the order in which you want them to appear.
</LI></P>

<P><LI>Call the property sheet's <I>DoModal</I> function to display it on the screen.</LI></P>
</OL>

<P>To simplify property sheet creation, most MFC programmers declare 
instances of their property sheet page classes inside the derived property sheet class. They 
also write the property sheet class's constructor such that it calls 
<I>AddPage</I> to add the pages to the property sheet. The class declarations for a simple property sheet and its 
pages might look like this:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
class CFirstPage : public CPropertyPage
{
public:
    CFirstPage () : CPropertyPage (IDD_FIRSTPAGE) {};
    // Declare CFirstPage's data members here.

protected:
    virtual void DoDataExchange (CDataExchange*);
};

class CSecondPage : public CPropertyPage
{
public:
    CSecondPage () : CPropertyPage (IDD_SECONDPAGE) {};
    // Declare CSecondPage's data members here.

protected:
    virtual void DoDataExchange (CDataExchange*);
};

class CMyPropertySheet : public CPropertySheet
{
public:
    CFirstPage m_firstPage;         // First page
    CSecondPage m_secondPage;       // Second page

    // Constructor adds the pages automatically.
    CMyPropertySheet (LPCTSTR pszCaption, 
        CWnd* pParentWnd = NULL) :
        CPropertySheet (pszCaption, pParentWnd, 0)
    {
        AddPage (&amp;m_firstPage);
        AddPage (&amp;m_secondPage);
    }
};
</PRE></TD></TR>
</TABLE>
</P>


<P>In this example, <I>CFirstPage</I> represents the first page in the property sheet, 
and <I>CSecondPage</I> represents the second. The associated dialog resources, which are 
referenced in the pages' class constructors, are IDD_FIRSTPAGE and 
IDD_SECONDPAGE. With this infrastructure in place, a modal property sheet featuring the caption 
&quot;Properties&quot; in its title bar can be constructed and displayed with two simple statements:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMyPropertySheet ps (_T (&quot;Properties&quot;));
ps.DoModal ();
</PRE></TD></TR>
</TABLE>
</P>


<P>Like <I>CDialog::DoModal</I>, 
<I>CPropertySheet::DoModal</I> returns IDOK if the property 
sheet was dismissed with the OK button, or IDCANCEL otherwise.</P>

<P>The dialog templates for property sheet pages shouldn't include OK and 
Cancel buttons because the property sheet provides these buttons. A property sheet 
also includes an Apply button and an optional Help button. The Apply button is 
disabled when the property sheet first appears and is enabled when a property 
sheet page calls the <I>SetModified</I> function it inherits from 
<I>CPropertyPage</I> and passes in TRUE. 
<I>SetModified</I> should be called anytime the settings embodied in the 
property sheet are changed&#8212;for example, whenever the text of an edit control is modified 
or a radio button is clicked. To trap clicks of the Apply button, you must include 
an ON_BN_CLICKED handler in the derived property sheet class. The button's ID 
is ID_APPLY_NOW. The click handler should call 
<I>UpdateData</I> with a TRUE parameter to update the active page's member variables and transmit the current property 
values to the property sheet's owner. Afterward, the click handler should disable 
the Apply button by calling <I>SetModified</I> with a FALSE parameter&#8212;once for each of 
the property sheet pages.</P>


<P>Note that the Apply button's ON_BN_CLICKED handler calls 
<I>UpdateData</I> for only the <I>active property sheet 
page</I>&#8212;the one that's currently displayed. That's 
important, because property sheet pages aren't physically created until they are 
activated by the person using the property sheet. Calling 
<I>UpdateData</I> for a property sheet page whose tab hasn't been clicked results in an assertion error from MFC. The 
framework calls <I>UpdateData</I> for the active page when the user switches to another 
page, so when the user clicks the Apply button, the only page whose data members 
need to be updated is the page that's currently active. You can get a pointer to the 
active page with 
<I>CPropertySheet::GetActivePage</I>.</P>


<P>Using DDX and DDV to transfer data between controls and data members 
in property sheet pages and to validate data extracted from the controls is more than 
a matter of convenience; it allows MFC to do much of the dirty work involved in 
property sheet handling. The first time a property sheet page is displayed, for example, 
the page's <I>OnInitDialog</I> function is called. The default implementation of 
<I>OnInitDialog</I> calls <I>UpdateData</I> to initialize the page's controls. If the user then clicks a tab 
to activate another page, the current page's 
<I>OnKillActive</I> function is called and the framework calls 
<I>UpdateData</I> to retrieve and validate the controls' data. Shortly 
thereafter, the newly activated page receives an 
<I>OnSetActive</I> notification and possibly an 
<I>OnInitDialog</I> notification, too. If the user then goes on to click the property 
sheet's OK button, the current page's <I>OnOK</I> handler is called and the framework calls 
<I>UpdateData</I> to retrieve and validate that page's data.</P>

<P>The point is that a property sheet works the way it does because the 
framework provides default implementations of key virtual functions that govern 
the property sheet's behavior. You can customize a property sheet's operation by 
overriding the pages' <I>OnInitDialog</I>, 
<I>OnSetActive</I>, <I>OnKillActive</I>, 
<I>OnOK</I>, and <I>OnCancel</I> functions and performing specialized processing of your own; but if you do, be 
sure to call the equivalent functions in the base class so that the framework can do its 
part. And if you don't use DDX and DDV, you need to override 
<I>all</I> of these functions for every page in the property sheet to ensure that each page's data is handled 
properly. DDX and DDV simplify property sheet usage by letting the framework do the 
bulk of the work.</P>

<A NAME="243"><H2>The PropDemo Application</H2></A>

<P>The PropDemo application shown in Figure 8-11 is similar to DlgDemo1 and 
DlgDemo2, but it uses a property sheet instead of a dialog box to expose 
configuration settings to the user. The property sheet's Size page contains controls for setting 
the size of the ellipse displayed in the view. The Color page contains controls for 
modifying the ellipse's color. The property sheet is modal, so the main window can't 
be reactivated while the property sheet is displayed.</P>

<P>
<A HREF="javascript:fullSize('F08mg11x.htm')"> <img src="images/F08mg11.JPG" width=404 height=318 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 8-11.</B> <I>The PropDemo window and property sheet.</I><!-- /CAPTION -->
</p>

<P>Selected portions of PropDemo's source code are reproduced in Figure 
8-12. <I>CMyPropertySheet</I> represents the property sheet itself, and 
<I>CSizePage</I> and <I>CColorPage</I> represent the property sheet pages. All three classes were derived with 
ClassWizard. Instances of <I>CSizePage</I> and 
<I>CColorPage</I> named <I>m_sizePage</I> and 
<I>m_colorPage</I> are declared in 
<I>CMyPropertySheet</I> so that the page objects will be constructed 
automatically when the property sheet object is constructed. Furthermore, both 
<I>m_sizePage</I> and <I>m_colorPage</I> are declared public so that they can be accessed from outside 
of <I>CMyPropertySheet</I>.
</P>

<P>The property sheet is created by 
<I>CChildView::OnFileProperties</I> when the user selects the Properties command from the File menu. After constructing a 
<I>CMyPropertySheet</I> object on the stack, 
<I>OnFileProperties</I> copies the current settings&#8212;width, 
height, units, and color&#8212;to the corresponding member variables in the property sheet 
page objects:</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMyPropertySheet ps (_T (&quot;Properties&quot;));
ps.m_sizePage.m_nWidth = m_nWidth;
ps.m_sizePage.m_nHeight = m_nHeight;
ps.m_sizePage.m_nUnits = m_nUnits;
ps.m_colorPage.m_nColor = m_nColor;
</PRE></TD></TR>
</TABLE>
</P>


<P><I>OnFileProperties</I> then displays the property sheet by calling 
<I>DoModal</I>. If the property sheet is dismissed with the OK button, the new settings are copied from the 
property sheet pages and <I>Invalidate</I> is called to repaint the view and apply the changes:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
if (ps.DoModal () == IDOK) {
    m_nWidth = ps.m_sizePage.m_nWidth;
    m_nHeight = ps.m_sizePage.m_nHeight;
    m_nUnits = ps.m_sizePage.m_nUnits;
    m_nColor = ps.m_colorPage.m_nColor;
    Invalidate ();
}     
</PRE></TD></TR>
</TABLE>
</P>

<P>Both <I>CSizePage </I>and <I>CColorPage </I>map ON_BN_CLICKED notifications from 
radio buttons and EN_CHANGE notifications from edit controls to a class member 
function named <I>OnChange</I>. <I>OnChange</I> contains just one statement: a call to 
<I>SetModified</I> to enable the property sheet's Apply button. Consequently, any button click in a 
property sheet page, or any change to the text of an edit control, automatically 
enables the Apply button if it isn't already enabled.</P>

<P>When the Apply button is clicked, 
<I>CMyPropertySheet</I>'s <I>OnApply</I> function 
takes control. It first calls <I>UpdateData</I> on the active property sheet page to transfer the 
user's input from the page's controls to its data members. It then initializes an 
ELLPROP structure with the property settings obtained from each page's data members and 
sends a message to the main window containing the structure's address. The main 
window forwards the message to the view, which responds by copying the property 
values to its own data members and calling 
<I>Invalidate</I> to force a repaint. After 
<I>SendMessage</I> returns, <I>OnApply</I> disables the Apply button by calling each property sheet 
page's <I>SetModified</I> function.</P>

<P><B>Figure 8-12.</B> <I>The PropDemo application.</I></P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="244"><H3>MainFrm.h</H3></A>

<PRE>
// MainFrm.h : interface of the CMainFrame class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__9CE2B4A8_9067_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_MAINFRM_H__9CE2B4A8_9067_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#include &quot;ChildView.h&quot;

class CMainFrame : public CFrameWnd
{
    
public:
    CMainFrame();
protected: 
    DECLARE_DYNAMIC(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
        AFX_CMDHANDLERINFO* pHandlerInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif
    CChildView    m_wndView;
// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg void OnSetFocus(CWnd *pOldWnd);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    afx_msg LRESULT OnApply (WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(AFX_MAINFRM_H__9CE2B4A8_9067_11D2_8E53_006008A82731__INCLUDED_)
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="245"><H3>MainFrm.cpp</H3></A>
<PRE>
// MainFrm.cpp : implementation of the CMainFrame class
//

#include &quot;stdafx.h&quot;
#include &quot;PropDemo.h&quot;

#include &quot;MainFrm.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_SETFOCUS()
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
    ON_MESSAGE (WM_USER_APPLY, OnApply)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    cs.dwExStyle &amp;= ~WS_EX_CLIENTEDGE;
    cs.lpszClass = AfxRegisterWndClass(0);
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext&amp; dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
void CMainFrame::OnSetFocus(CWnd* pOldWnd)
{
    // forward focus to the view window
    m_wndView.SetFocus();
}

BOOL CMainFrame::OnCmdMsg(UINT nID, int nCode, void* pExtra,
    AFX_CMDHANDLERINFO* pHandlerInfo)
{
    // let the view have first crack at the command
    if (m_wndView.OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // otherwise, do default handling
    return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}


int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    if (!m_wndView.Create(NULL, NULL, AFX_WS_DEFAULT_VIEW,
        CRect(0, 0, 0, 0), this, AFX_IDW_PANE_FIRST, NULL))
        return -1;

    return 0;
}

LRESULT CMainFrame::OnApply (WPARAM wParam, LPARAM lParam)
{
    m_wndView.SendMessage (WM_USER_APPLY, wParam, lParam);
    return 0;
}
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="246"><H3>ChildView.h</H3></A>
<PRE>
// ChildView.h : interface of the CChildView class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDVIEW_H__9CE2B4AA_9067_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_CHILDVIEW_H__9CE2B4AA_9067_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
///////////////////////////////////////////////////////////////////////////
// CChildView window

class CChildView : public CWnd
{
// Construction
public:
    CChildView();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChildView)
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CChildView();

    // Generated message map functions
protected:
    int m_nUnits;
    int m_nHeight;
    int m_nWidth;
    int m_nColor;
    //{{AFX_MSG(CChildView)
    afx_msg void OnPaint();
    afx_msg void OnFileProperties();
    //}}AFX_MSG
    afx_msg LRESULT OnApply (WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
//!defined(AFX_CHILDVIEW_H__9CE2B4AA_9067_11D2_8E53_006008A82731__INCLUDED_)
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="247"><H3>ChildView.cpp</H3></A>
<PRE>
// ChildView.cpp : implementation of the CChildView class
//

#include &quot;stdafx.h&quot;
#include &quot;PropDemo.h&quot;
#include &quot;ChildView.h&quot;
#include &quot;MyPropertySheet.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CChildView

CChildView::CChildView()
{
    m_nWidth = 4;
    m_nHeight = 2;
    m_nUnits = 0;
    m_nColor = 0;
}

CChildView::~CChildView()
{
}

BEGIN_MESSAGE_MAP(CChildView,CWnd )
    //{{AFX_MSG_MAP(CChildView)
    ON_WM_PAINT()
    ON_COMMAND(ID_FILE_PROPERTIES, OnFileProperties)
    //}}AFX_MSG_MAP
    ON_MESSAGE (WM_USER_APPLY, OnApply)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CChildView message handlers

BOOL CChildView::PreCreateWindow(CREATESTRUCT&amp; cs) 
{
    if (!CWnd::PreCreateWindow(cs))
        return FALSE;

    cs.dwExStyle &#166;= WS_EX_CLIENTEDGE;
    cs.style &amp;= ~WS_BORDER;
    cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW&#166;CS_VREDRAW&#166;CS_DBLCLKS, 
        ::LoadCursor(NULL, IDC_ARROW), HBRUSH(COLOR_WINDOW+1), NULL);

    return TRUE;
}

void CChildView::OnPaint() 
{
    CPaintDC dc(this); // Device context for painting.
    
    CBrush brush (CColorPage::m_clrColors[m_nColor]);
    CBrush* pOldBrush = dc.SelectObject (&amp;brush);

    switch (m_nUnits) {

    case 0: // Inches.
        dc.SetMapMode (MM_LOENGLISH);
        dc.Ellipse (0, 0, m_nWidth * 100, -m_nHeight * 100);
        break;

    case 1: // Centimeters.
        dc.SetMapMode (MM_LOMETRIC);
        dc.Ellipse (0, 0, m_nWidth * 100, -m_nHeight * 100);
        break;

    case 2: // Pixels.
        dc.SetMapMode (MM_TEXT);
        dc.Ellipse (0, 0, m_nWidth, m_nHeight);
        break;
    }
    dc.SelectObject (pOldBrush);
}

void CChildView::OnFileProperties() 
{
    CMyPropertySheet ps (_T (&quot;Properties&quot;));
    ps.m_sizePage.m_nWidth = m_nWidth;
    ps.m_sizePage.m_nHeight = m_nHeight;
    ps.m_sizePage.m_nUnits = m_nUnits;
    ps.m_colorPage.m_nColor = m_nColor;

    if (ps.DoModal () == IDOK) {
        m_nWidth = ps.m_sizePage.m_nWidth;
        m_nHeight = ps.m_sizePage.m_nHeight;
        m_nUnits = ps.m_sizePage.m_nUnits;
        m_nColor = ps.m_colorPage.m_nColor;
        Invalidate ();
    }    
}
LRESULT CChildView::OnApply (WPARAM wParam, LPARAM lParam)
{
    ELLPROP* pep = (ELLPROP*) lParam;
    m_nWidth = pep-&gt;nWidth;
    m_nHeight = pep-&gt;nHeight;
    m_nUnits = pep-&gt;nUnits;
    m_nColor = pep-&gt;nColor;
    Invalidate ();
    return 0;
}
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="248"><H3>MyPropertySheet.h</H3></A>
<PRE>
#if !defined(AFX_MYPROPERTYSHEET_H__418271A3_90D4_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_MYPROPERTYSHEET_H__418271A3_90D4_11D2_8E53_006008A82731__INCLUDED_

#include &quot;SizePage.h&quot;    // Added by ClassView
#include &quot;ColorPage.h&quot;    // Added by ClassView
#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// MyPropertySheet.h : header file
//

///////////////////////////////////////////////////////////////////////////
// CMyPropertySheet

class CMyPropertySheet : public CPropertySheet
{
    DECLARE_DYNAMIC(CMyPropertySheet)

// Construction
public:
    CMyPropertySheet(UINT nIDCaption, CWnd* pParentWnd = NULL, 
        UINT iSelectPage = 0);
    CMyPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, 
        UINT iSelectPage = 0);

// Attributes
public:
    CColorPage m_colorPage;
    CSizePage m_sizePage;

// Operations
public:
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMyPropertySheet)
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMyPropertySheet();

    // Generated message map functions
protected:
    //{{AFX_MSG(CMyPropertySheet)
        // NOTE - the ClassWizard will add and remove
        // member functions here.
    //}}AFX_MSG
    afx_msg void OnApply ();
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(
//  AFX_MYPROPERTYSHEET_H__418271A3_90D4_11D2_8E53_006008A82731__INCLUDED_)
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="249"><H3>MyPropertySheet.cpp</H3></A>
<PRE>
// MyPropertySheet.cpp : implementation file
//

#include &quot;stdafx.h&quot;
#include &quot;PropDemo.h&quot;
#include &quot;MyPropertySheet.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
///////////////////////////////////////////////////////////////////////////
// CMyPropertySheet

IMPLEMENT_DYNAMIC(CMyPropertySheet, CPropertySheet)

CMyPropertySheet::CMyPropertySheet(UINT nIDCaption, CWnd* pParentWnd,
    UINT iSelectPage) : CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
    AddPage (&amp;m_sizePage);
    AddPage (&amp;m_colorPage);
}

CMyPropertySheet::CMyPropertySheet(LPCTSTR pszCaption, CWnd* pParentWnd,
    UINT iSelectPage) : CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
    AddPage (&amp;m_sizePage);
    AddPage (&amp;m_colorPage);
}

CMyPropertySheet::~CMyPropertySheet()
{
}

BEGIN_MESSAGE_MAP(CMyPropertySheet, CPropertySheet)
    //{{AFX_MSG_MAP(CMyPropertySheet)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
    ON_BN_CLICKED (ID_APPLY_NOW, OnApply)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CMyPropertySheet message handlers

void CMyPropertySheet::OnApply ()
{
    GetActivePage ()-&gt;UpdateData (TRUE);

    ELLPROP ep;
    ep.nWidth = m_sizePage.m_nWidth;
    ep.nHeight = m_sizePage.m_nHeight;
    ep.nUnits = m_sizePage.m_nUnits;
    ep.nColor = m_colorPage.m_nColor;

    GetParent ()-&gt;SendMessage (WM_USER_APPLY, 0, (LPARAM) &amp;ep);

    m_sizePage.SetModified (FALSE);
    m_colorPage.SetModified (FALSE);
}
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="250"><H3>SizePage.h</H3></A>
<PRE>
#if !defined(AFX_SIZEPAGE_H__418271A1_90D4_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_SIZEPAGE_H__418271A1_90D4_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// SizePage.h : header file
//

///////////////////////////////////////////////////////////////////////////
// CSizePage dialog

class CSizePage : public CPropertyPage
{
    DECLARE_DYNCREATE(CSizePage)

// Construction
public:
    CSizePage();
    ~CSizePage();

// Dialog Data
    //{{AFX_DATA(CSizePage)
    enum { IDD = IDD_SIZE_PAGE };
    int        m_nWidth;
    int        m_nHeight;
    int        m_nUnits;
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSizePage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CSizePage)
        // NOTE: the ClassWizard will add member functions here
    //}}AFX_MSG
    afx_msg void OnChange ();
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
//!defined(AFX_SIZEPAGE_H__418271A1_90D4_11D2_8E53_006008A82731__INCLUDED_)
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="251"><H3>SizePage.cpp</H3></A>
<PRE>
// SizePage.cpp : implementation file
//

#include &quot;stdafx.h&quot;
#include &quot;PropDemo.h&quot;
#include &quot;SizePage.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CSizePage property page

IMPLEMENT_DYNCREATE(CSizePage, CPropertyPage)

CSizePage::CSizePage() : CPropertyPage(CSizePage::IDD)
{
    //{{AFX_DATA_INIT(CSizePage)
    m_nWidth = 0;
    m_nHeight = 0;
    m_nUnits = -1;
    //}}AFX_DATA_INIT
}

CSizePage::~CSizePage()
{
}

void CSizePage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSizePage)
    DDX_Text(pDX, IDC_WIDTH, m_nWidth);
    DDV_MinMaxInt(pDX, m_nWidth, 1, 128);
    DDX_Text(pDX, IDC_HEIGHT, m_nHeight);
    DDV_MinMaxInt(pDX, m_nHeight, 1, 128);
    DDX_Radio(pDX, IDC_INCHES, m_nUnits);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSizePage, CPropertyPage)
    //{{AFX_MSG_MAP(CSizePage)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
    ON_EN_CHANGE (IDC_WIDTH, OnChange)
    ON_EN_CHANGE (IDC_HEIGHT, OnChange)
    ON_BN_CLICKED (IDC_INCHES, OnChange)
    ON_BN_CLICKED (IDC_CENTIMETERS, OnChange)
    ON_BN_CLICKED (IDC_PIXELS, OnChange)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CSizePage message handlers

void CSizePage::OnChange ()
{
    SetModified (TRUE);
}
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="252"><H3>ColorPage.h</H3></A>
<PRE>
#if !defined(AFX_COLORPAGE_H__418271A2_90D4_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_COLORPAGE_H__418271A2_90D4_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// ColorPage.h : header file
//

///////////////////////////////////////////////////////////////////////////
// CColorPage dialog

class CColorPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CColorPage)

// Construction
public:
    CColorPage();
    ~CColorPage();
    static const COLORREF m_clrColors[3];

// Dialog Data
    //{{AFX_DATA(CColorPage)
    enum { IDD = IDD_COLOR_PAGE };
    int        m_nColor;
    //}}AFX_DATA

// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CColorPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CColorPage)
        // NOTE: the ClassWizard will add member functions here
    //}}AFX_MSG
    afx_msg void OnChange ();
    DECLARE_MESSAGE_MAP()

};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
//defined(AFX_COLORPAGE_H__418271A2_90D4_11D2_8E53_006008A82731__INCLUDED_)
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="253"><H3>ColorPage.cpp</H3></A>
<PRE>
// ColorPage.cpp : implementation file
//

#include &quot;stdafx.h&quot;
#include &quot;PropDemo.h&quot;
#include &quot;ColorPage.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CColorPage property page

IMPLEMENT_DYNCREATE(CColorPage, CPropertyPage)

const COLORREF CColorPage::m_clrColors[3] = {
    RGB (255,   0,   0),    // Red
    RGB (  0, 255,   0),    // Green
    RGB (  0,   0, 255)     // Blue
};

CColorPage::CColorPage() : CPropertyPage(CColorPage::IDD)
{
    //{{AFX_DATA_INIT(CColorPage)
    m_nColor = -1;
    //}}AFX_DATA_INIT
}

CColorPage::~CColorPage()
{
}

void CColorPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CColorPage)
    DDX_Radio(pDX, IDC_RED, m_nColor);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CColorPage, CPropertyPage)
    //{{AFX_MSG_MAP(CColorPage)
        // NOTE: the ClassWizard will add message map macros here
    //}}AFX_MSG_MAP
    ON_BN_CLICKED (IDC_RED, OnChange)
    ON_BN_CLICKED (IDC_GREEN, OnChange)
    ON_BN_CLICKED (IDC_BLUE, OnChange)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CColorPage message handlers

void CColorPage::OnChange ()
{
    SetModified (TRUE);
}
</PRE></TD></TR>
</TABLE>
</P>


</BODY>
</HTML>




