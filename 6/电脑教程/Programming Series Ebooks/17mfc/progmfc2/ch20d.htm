<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>MFC Automation Clients</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch20c.htm", "ch21a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="645"><H1>MFC Automation Clients</H1></A>

<p>MFC vastly simplifies the writing of Automation servers, but what about 
Automation clients? Good news: with a little help from ClassWizard, it's almost as easy to write 
an Automation client with MFC as it is to write it with Visual Basic.
</p>

<p>
The key is a class named <I>COleDispatchDriver</I>, which puts a friendly face on <I>IDispatch</I> pointers exported by running Automation servers. The <I>COleDispatchDriver</I> helper functions <I>InvokeHelper</I>, <I>SetProperty</I>, and <I>GetProperty</I> simplify method and property accesses, but interacting with an Automation object using these functions 
is only slightly better than calling <I>IDispatch::Invoke</I> directly. The real value of <I>COleDispatchDriver</I> lies in creating type-safe classes whose member functions provide easy access to Automation methods and properties. After all, it's easier for a C++ programmer to call a class member function than to call <I>IDispatch::Invoke</I>.
</p>

<p>
To derive a class from <I>COleDispatchDriver</I> that's tailored to a specific Automation server, click ClassWizard's Add Class button, select From A Type Library, and point ClassWizard to the server's type library. ClassWizard will read the type library and generate the new class. Inside that class you'll find member functions for calling the server's methods and get and set functions for accessing its properties. For example, if the server supports a method named <I>Add</I> and a property named <I>Pi</I>, the ClassWizard-generated class will include a member function named 
<I>Add</I> and accessor functions named <I>GetPi</I> and <I>SetPi</I>. If the wrapper class were named <I>CAutoMath</I> and the object's ProgID were &quot;Math.Object,&quot; the object could be instantiated and programmed using statements like these:
</p>

<P>
<table cellpadding=5 width="95%"><tr><td>	
<PRE>CAutoMath math;
math.CreateDispatch (_T (&quot;Math.Object&quot;));
int sum = math.Add (2, 2);
double pi = math.GetPi ();
</PRE>
</td></tr></table>
</P>

<p><I>CreateDispatch</I> uses 
<I>::CoCreateInstance</I> to create the Automation object. It 
caches the object's <I>IDispatch</I> pointer in a member variable named 
<I>m_lpDispatch</I>. Method calls and property accesses performed via 
<I>CAutoMath</I> member functions are translated into 
<I>IDispatch</I> calls to the object by 
<I>InvokeHelper</I> and other 
<I>COleDispatchDriver</I> functions.
</p>

<A NAME="646"><H2>The PieClient Application</H2></A>

<p>Let's close out this chapter with an MFC Automation client. PieClient, a picture of which appears in Figure 20-16 and whose source code appears in Figure 20-17, is a dialog-based application whose main window features edit controls for entering and editing quarterly revenue values. Values entered in the controls are charted by AutoPie. PieClient drives AutoPie via Automation.
</p>

<P>
<A HREF="javascript:fullSize('F20mg16x.htm')"> <img src="images/F20mg16.JPG" width=404 height=308 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 20-16.</B> <I>PieClient acting as an Automation client to AutoPie.</I><!-- /CAPTION -->
</p>

<P>
When started, PieClient calls <I>CreateDispatch</I> on a <I>CAutoPie</I> object named <I>m_autoPie</I> to start the Automation server:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>	
<PRE>BOOL bSuccess = m_autoPie.CreateDispatch (_T (&quot;AutoPie.Application&quot;));
</PRE>
</td></tr></table>
</P>

<p>When its Set button is clicked, PieClient gathers the revenue values from the edit controls and transmits them to the server by writing them to the <I>Chart</I> object's <I>Revenue</I> property:
</p>

<P>
<table cellpadding=5 width="95%"><tr><td>	

<PRE>m_autoChart.SetRevenue (1, GetDlgItemInt (IDC_Q1));
m_autoChart.SetRevenue (2, GetDlgItemInt (IDC_Q2));
m_autoChart.SetRevenue (3, GetDlgItemInt (IDC_Q3));
m_autoChart.SetRevenue (4, GetDlgItemInt (IDC_Q4));
</PRE>
</td></tr></table>
</P>

<p>It then repaints the pie chart by calling the 
<I>Window</I> object's <I>Refresh</I> method:
</p>

<P>
<table cellpadding=5 width="95%"><tr><td>
<PRE>m_autoWindow.Refresh ();
</PRE>
</td></tr></table>
</P>

<p>Conversely, if the Get button is clicked, PieClient reads the property values from the Automation object and displays them in the edit controls.
</p>

<p><I>m_autoChart</I> and <I>m_autoWindow</I> are instances of 
<I>CAutoChart</I> and <I>CAutoWindow</I>. These classes and others&#8212;namely, <I>CAutoPie</I> and <I>CAutoToolbar</I>&#8212;are 
<I>COleDispatchDriver</I> derivatives that ClassWizard created from AutoPie's type library. <I>CAutoPie</I> represents the server's top-level 
<I>Application</I> object. The remaining classes represent the 
<I>Chart</I>, <I>Window</I>, and <I>Toolbar</I> subobjects. 
<I>m_autoPie</I> is initialized by <I>CreateDispatch</I>, but <I>m_autoChart</I> and <I>m_autoWindow</I> must be initialized separately because the corresponding subobjects are automatically created when the server is started. These initializations are performed by passing the 
<I>IDispatch</I> pointers returned by <I>CAutoPie</I>'s <I>GetChart</I> and 
<I>GetWindow</I> functions to <I>AttachDispatch</I>:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>	<PRE>m_autoChart.AttachDispatch (m_autoPie.GetChart ());
m_autoWindow.AttachDispatch (m_autoPie.GetWindow ());
</PRE>
</td></tr></table>
</p>

<p>Because <I>m_autoPie</I>, <I>m_autoChart</I>, and 
<I>m_autoWindow</I> are embedded data members, they're automatically destroyed when the dialog object is destroyed. And 
when a <I>COleDispatchDriver</I>-object is destroyed, the 
<I>IDispatch</I> pointer that it wraps is released by the class destructor. That's why AutoPie closes when PieClient is 
closed. When the last pointer to an MFC Automation server's dispinterface is released, the server obediently shuts itself down.
</p>

<P>
<table cellpadding=5 width="95%"><tr><td>	
<A NAME="647"><H3>PieClient.h</H3></A>
<PRE>// PieClient.h : main header file for the PIECLIENT application
//

#if !defined(
    AFX_PIECLIENT_H__3B5BA32A_3B72_11D2_AC82_006008A8274D__INCLUDED_)
#define AFX_PIECLIENT_H__3B5BA32A_3B72_11D2_AC82_006008A8274D__INCLUDED_
</PRE>
</td></tr></table>
</p><p>
<!-- CAPTION --><B>Figure 20-17.</B> <I>The PieClient program.</I><!-- /CAPTION -->
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<PRE>#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
#ifndef __AFXWIN_H__
    #error include `stdafx.h' before including this file for PCH
#endif

#include &quot;resource.h&quot;        // main symbols

///////////////////////////////////////////////////////////////////////////
// CPieClientApp:
// See PieClient.cpp for the implementation of this class
//

class CPieClientApp : public CWinApp
{
public:
    CPieClientApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CPieClientApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation

    //{{AFX_MSG(CPieClientApp)
       // NOTE - the ClassWizard will add and remove member functions here.
       //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//     AFX_PIECLIENT_H__3B5BA32A_3B72_11D2_AC82_006008A8274D__INCLUDED_)
</PRE>
</td></tr></table>
</p>

<P>

<table cellpadding=5 width="95%"><tr><td>
<A NAME="648"><H3>PieClient.cpp</H3></A>
<PRE>// PieClient.cpp : Defines the class behaviors for the application.
//

#include &quot;stdafx.h&quot;
#include &quot;PieClient.h&quot;
#include &quot;PieClientDlg.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CPieClientApp

BEGIN_MESSAGE_MAP(CPieClientApp, CWinApp)
    //{{AFX_MSG_MAP(CPieClientApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CPieClientApp construction

CPieClientApp::CPieClientApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

///////////////////////////////////////////////////////////////////////////
// The one and only CPieClientApp object

CPieClientApp theApp;

///////////////////////////////////////////////////////////////////////////
// CPieClientApp initialization

BOOL CPieClientApp::InitInstance()
{
    if (!AfxOleInit ()) {
        AfxMessageBox (_T (&quot;AfxOleInit failed&quot;));
        return FALSE;
    }
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

    CPieClientDlg dlg;
    m_pMainWnd = &amp;dlg;
    int nResponse = dlg.DoModal();
    if (nResponse == IDOK)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with OK
    }
    else if (nResponse == IDCANCEL)
    {
        // TODO: Place code here to handle when the dialog is
        //  dismissed with Cancel
    }

    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}
</PRE>
</td></tr></table>
</p>
<P>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="649"><H3>PieClientDlg.h</H3></A>
<PRE>// PieClientDlg.h : header file
//

#if !defined(
    AFX_PIECLIENTDLG_H__3B5BA32C_3B72_11D2_AC82_006008A8274D__INCLUDED_)
#define AFX_PIECLIENTDLG_H__3B5BA32C_3B72_11D2_AC82_006008A8274D__INCLUDED_

#include &quot;autopie.h&quot;    // Added by ClassView
#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

///////////////////////////////////////////////////////////////////////////
// CPieClientDlg dialog

class CPieClientDlg : public CDialog
{
// Construction
public:
    CPieClientDlg(CWnd* pParent = NULL);    // standard constructor

// Dialog Data
    //{{AFX_DATA(CPieClientDlg)
    enum { IDD = IDD_PIECLIENT_DIALOG };
    CButton    m_wndSet;
    CButton    m_wndGet;
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CPieClientDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    CAutoWindow m_autoWindow;
    CAutoChart m_autoChart;
    CAutoPie m_autoPie;
    HICON m_hIcon;

    // Generated message map functions
    //{{AFX_MSG(CPieClientDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    afx_msg void OnGet();
    afx_msg void OnSet();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//     AFX_PIECLIENTDLG_H__3B5BA32C_3B72_11D2_AC82_006008A8274D__INCLUDED_)
</PRE>
</td></tr></table>
</P>
<P>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="650"><H3>PieClientDlg.cpp</H3></A>
<PRE>// PieClientDlg.cpp : implementation file
//

#include &quot;stdafx.h&quot;
#include &quot;PieClient.h&quot;
#include &quot;PieClientDlg.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CPieClientDlg dialog

CPieClientDlg::CPieClientDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CPieClientDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CPieClientDlg)
    //}}AFX_DATA_INIT
    // Note that LoadIcon does not require a subsequent 
    // DestroyIcon in Win32
    m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);
}

void CPieClientDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPieClientDlg)
    DDX_Control(pDX, IDC_SET, m_wndSet);
    DDX_Control(pDX, IDC_GET, m_wndGet);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CPieClientDlg, CDialog)
    //{{AFX_MSG_MAP(CPieClientDlg)
    ON_WM_PAINT()
    ON_WM_QUERYDRAGICON()
    ON_BN_CLICKED(IDC_GET, OnGet)
    ON_BN_CLICKED(IDC_SET, OnSet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CPieClientDlg message handlers

BOOL CPieClientDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    SetIcon(m_hIcon, TRUE);         // Set big icon
    SetIcon(m_hIcon, FALSE);        // Set small icon
    
    //
    // Start the Automation server.
    //
    BOOL bSuccess = m_autoPie.CreateDispatch (_T (&quot;AutoPie.Application&quot;));

    //
    // If CreateDispatch succeeded, initialize the m_autoChart and
    // m_autoWindow data members to represent the Chart and Window
    // subobjects, respectively. Then initialize the controls in
    // the dialog and make the server window visible.
    //
    if (bSuccess) {
        m_autoChart.AttachDispatch (m_autoPie.GetChart ());
        ASSERT (m_autoChart.m_lpDispatch != NULL);
        m_autoWindow.AttachDispatch (m_autoPie.GetWindow ());
        ASSERT (m_autoWindow.m_lpDispatch != NULL);
        OnGet ();
        m_autoWindow.SetVisible (TRUE);
    }

    //
    // If CreateDispatch failed, let the user know about it.
    //
    else {
        MessageBox (_T (&quot;Error launching AutoPie. Run it once to &quot; \
        &quot;register it on this system and then try again.&quot;), _T (&quot;Error&quot;));
        m_wndGet.EnableWindow (FALSE);
        m_wndSet.EnableWindow (FALSE);
    }
    return TRUE;  // return TRUE unless you set the focus to a control
}

void CPieClientDlg::OnPaint() 
{
    if (IsIconic())
    {
        CPaintDC dc(this); // device context for painting

        SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

        // Center icon in client rectangle.
        int cxIcon = GetSystemMetrics(SM_CXICON);
        int cyIcon = GetSystemMetrics(SM_CYICON);
        CRect rect;
        GetClientRect(&amp;rect);
        int x = (rect.Width() - cxIcon + 1) / 2;
        int y = (rect.Height() - cyIcon + 1) / 2;

        // Draw the icon.
        dc.DrawIcon(x, y, m_hIcon);
    }
    else
    {
        CDialog::OnPaint();
    }
}

HCURSOR CPieClientDlg::OnQueryDragIcon()
{
    return (HCURSOR) m_hIcon;
}

void CPieClientDlg::OnGet() 
{
    //
    // Retrieve revenue values from the Automation server and display them.
    //
    SetDlgItemInt (IDC_Q1, m_autoChart.GetRevenue (1));
    SetDlgItemInt (IDC_Q2, m_autoChart.GetRevenue (2));
    SetDlgItemInt (IDC_Q3, m_autoChart.GetRevenue (3));
    SetDlgItemInt (IDC_Q4, m_autoChart.GetRevenue (4));
}

void CPieClientDlg::OnSet() 
{
    //
    // Retrieve the revenue values displayed in the edit controls 
    // and provide them to the Automation server.
    //
    m_autoChart.SetRevenue (1, GetDlgItemInt (IDC_Q1));
    m_autoChart.SetRevenue (2, GetDlgItemInt (IDC_Q2));
    m_autoChart.SetRevenue (3, GetDlgItemInt (IDC_Q3));
    m_autoChart.SetRevenue (4, GetDlgItemInt (IDC_Q4));

    //
    // Repaint the pie chart.
    //
    m_autoWindow.Refresh ();    
}
</pre>
</td></tr></table>
</P>
<P>
<table cellpadding=5 width="95%"><tr><td>	
<A NAME="651"><H3>AutoPie.h</H3></A>
<PRE>// Machine generated IDispatch wrapper class(es) created with ClassWizard
///////////////////////////////////////////////////////////////////////////
// CAutoPie wrapper class

class CAutoPie : public COleDispatchDriver
{
public:
    CAutoPie() {}        // Calls COleDispatchDriver default constructor
    CAutoPie(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    CAutoPie(const CAutoPie&amp; dispatchSrc) : 
        COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    LPDISPATCH GetChart();
    void SetChart(LPDISPATCH);
    LPDISPATCH GetWindow();
    void SetWindow(LPDISPATCH);
    LPDISPATCH GetToolbar();
    void SetToolbar(LPDISPATCH);

// Operations
public:
    void Quit();
};
///////////////////////////////////////////////////////////////////////////
// CAutoChart wrapper class

class CAutoChart : public COleDispatchDriver
{
public:
    CAutoChart() {}        // Calls COleDispatchDriver default constructor
    CAutoChart(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    CAutoChart(const CAutoChart&amp; dispatchSrc) : 
        COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
    BOOL Save(LPCTSTR pszPath);
    long GetRevenue(short nQuarter);
    void SetRevenue(short nQuarter, long nNewValue);
};
///////////////////////////////////////////////////////////////////////////
// CAutoWindow wrapper class

class CAutoWindow : public COleDispatchDriver
{
public:
    CAutoWindow() {}        // Calls COleDispatchDriver default constructor
    CAutoWindow(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    CAutoWindow(const CAutoWindow&amp; dispatchSrc) : 
        COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    BOOL GetVisible();
    void SetVisible(BOOL);

// Operations
public:
    void Refresh();
};
///////////////////////////////////////////////////////////////////////////
// CAutoToolbar wrapper class

class CAutoToolbar : public COleDispatchDriver
{
public:
    CAutoToolbar() {}       // Calls COleDispatchDriver default constructor
    CAutoToolbar(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    CAutoToolbar(const CAutoToolbar&amp; dispatchSrc) : 
        COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    BOOL GetVisible();
    void SetVisible(BOOL);

// Operations
public:
};
</PRE>
</td></tr></table>
</P>
<P>
<table cellpadding=5 width="95%"><tr><td>	
<A NAME="652"><H3>AutoPie.cpp</H3></A>
<PRE>// Machine generated IDispatch wrapper class(es) created with ClassWizard

#include &quot;stdafx.h&quot;
#include &quot;autopie.h&quot;
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CAutoPie properties

LPDISPATCH CAutoPie::GetChart()
{
    LPDISPATCH result;
    GetProperty(0x1, VT_DISPATCH, (void*)&amp;result);
    return result;
}

void CAutoPie::SetChart(LPDISPATCH propVal)
{
    SetProperty(0x1, VT_DISPATCH, propVal);
}

LPDISPATCH CAutoPie::GetWindow()
{
    LPDISPATCH result;
    GetProperty(0x2, VT_DISPATCH, (void*)&amp;result);
    return result;
}

void CAutoPie::SetWindow(LPDISPATCH propVal)
{
    SetProperty(0x2, VT_DISPATCH, propVal);
}

LPDISPATCH CAutoPie::GetToolbar()
{
    LPDISPATCH result;
    GetProperty(0x3, VT_DISPATCH, (void*)&amp;result);
    return result;
}

void CAutoPie::SetToolbar(LPDISPATCH propVal)
{
    SetProperty(0x3, VT_DISPATCH, propVal);
}

///////////////////////////////////////////////////////////////////////////
// CAutoPie operations

void CAutoPie::Quit()
{
    InvokeHelper(0x4, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

///////////////////////////////////////////////////////////////////////////
// CAutoChart properties

///////////////////////////////////////////////////////////////////////////
// CAutoChart operations

BOOL CAutoChart::Save(LPCTSTR pszPath)
{
    BOOL result;
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_BOOL, (void*)&amp;result, parms,
        pszPath);
    return result;
}

long CAutoChart::GetRevenue(short nQuarter)
{
    long result;
    static BYTE parms[] =
        VTS_I2;
    InvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_I4, (void*)&amp;result, parms,
        nQuarter);
    return result;
}

void CAutoChart::SetRevenue(short nQuarter, long nNewValue)
{
    static BYTE parms[] =
        VTS_I2 VTS_I4;
    InvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
        nQuarter, nNewValue);
}

///////////////////////////////////////////////////////////////////////////
// CAutoWindow properties

	BOOL CAutoWindow::GetVisible()
{
    BOOL result;
    GetProperty(0x1, VT_BOOL, (void*)&amp;result);
    return result;
}

void CAutoWindow::SetVisible(BOOL propVal)
{
    SetProperty(0x1, VT_BOOL, propVal);
}

///////////////////////////////////////////////////////////////////////////
// CAutoWindow operations

void CAutoWindow::Refresh()
{
    InvokeHelper(0x2, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

///////////////////////////////////////////////////////////////////////////
// CAutoToolbar properties

BOOL CAutoToolbar::GetVisible()
{
    BOOL result;
    GetProperty(0x1, VT_BOOL, (void*)&amp;result);
    return result;
}

void CAutoToolbar::SetVisible(BOOL propVal)
{
    SetProperty(0x1, VT_BOOL, propVal);
}

///////////////////////////////////////////////////////////////////////////
// CAutoToolbar operations
</PRE>
</td></tr></table>
</P>
<P>
<table cellpadding=5 width="95%"><tr><td>	
<A NAME="653"><H3>Stdafx.h</H3></A>
<PRE>// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__3B5BA32E_3B72_11D2_AC82_006008A8274D__INCLUDED_)
#define AFX_STDAFX_H__3B5BA32E_3B72_11D2_AC82_006008A8274D__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#define VC_EXTRALEAN      // Exclude rarely-used stuff from Windows headers

#include &lt;afxwin.h&gt;       // MFC core and standard components
#include &lt;afxext.h&gt;       // MFC extensions
#include &lt;afxdtctl.h&gt;     // MFC support for Internet Explorer 4 
                          // Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include &lt;afxcmn.h&gt;            // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include &lt;afxdisp.h&gt;

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(AFX_STDAFX_H__3B5BA32E_3B72_11D2_AC82_006008A8274D__INCLUDED_)
</PRE>
</td></tr></table>
</P>
<p>Keep in mind that checking the Automation box in AppWizard makes an 
application an Automation server, not an Automation client. With the Automation option unchecked, however, AppWizard will not add an 
<I>AfxOleInit</I> call to <I>InitInstance</I>, nor will it #include Afxdisp.h in Stdafx.h. Both are necessary for Automation clients, so 
I added them by hand to PieClient. Without these additions, the code will compile just fine, but <I>CreateDispatch</I> will fail every time.
</p>

<A NAME="654"><H2>Connecting to a Running Automation Server</H2></A>

<p>Thanks to ClassWizard-generated wrapper classes and their member functions, accessing an Automation server's methods and properties from a C++ program is almost as easy as accessing them from Visual Basic. But what if you want to connect two or more instances of PieClient to one instance of AutoPie? As it stands now, 
that's not possible because each instance of PieClient calls 
<I>CreateDispatch</I>, which creates a brand new instance of the Automation object.
</p>

<p>
You can modify PieClient and AutoPie to support multiple simultaneous 
connections by adding a few lines of code to each. On the server side, AutoPie needs 
to call the API function 
<I>::RegisterActiveObject</I> to register itself as an active object. 
Here's a modified version of <I>CAutoPieDoc</I>'s constructor that demonstrates how.
</p>

<P>
<table cellpadding=5 width="95%"><tr><td>
	<PRE>CAutoPieDoc::CAutoPieDoc ()
{
    // Wizard-generated code
    EnableAutomation ();
    AfxOleLockApp ();

    // Additional code that registers the running object
    IUnknown* pUnknown;
    GetIDispatch (FALSE)-&gt;
        QueryInterface (IID_IUnknown, (void**) &amp;pUnknown);
    GetIDispatch (FALSE)-&gt;Release (); // Undo the AddRef 
                                      // performed by QueryInterface.
    ::RegisterActiveObject (pUnknown, clsid, ACTIVEOBJECT_WEAK, &amp;m_ulID);
}
</PRE>
</td></tr></table>
</P>

<p>In this example, <I>m_ulID</I> is an unsigned long member variable added to 
<I>CAutoPieDoc</I>. It receives a 32-bit value identifying the entry that 
<I>::RegisterActiveObject</I> added to COM's running object table. 
<I>clsid</I> is the object's CLSID; it's declared in AutoPie.cpp and 
made visible in AutoPieDoc.cpp by adding the statement
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<PRE>extern CLSID clsid;
</PRE>
</td></tr></table>
</p>

<p>to AutoPieDoc.cpp. For this <I>extern</I> statement to compile and link, you must remove the keywords <I>static</I> and <I>const</I> from the variable declaration in AutoPie.cpp.</P>
<P>So that clients won't attempt to connect to an Automation server that is no longer running, a version of AutoPie that registers itself in the running object table 
must unregister itself before it shuts down. The best way to do this is to override <I>OnFinalRelease</I> in <I>CAutoPieDoc</I> and call 
<I>::RevokeActiveObject</I>, as shown here:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
	<PRE>void CAutoPieDoc::OnFinalRelease() 
{
    ::RevokeActiveObject (m_ulID, NULL);    
    CDocument::OnFinalRelease();
}
</PRE>
</td></tr></table>
</p>

<p><I>::RevokeActiveObject</I> does the opposite of 
<I>::RegisterActiveObject</I>: Given a 
registration ID, it removes an object from the running object table. 
<I>OnFinalRelease</I> is a <I>CCmdTarget</I> function that's called just before an MFC COM object self-deletes.
</p>

<p>
The final modification needed to support multiple connections applies to 
the client, not the server. Before calling <I>CreateDispatch</I> to create the Automation object, PieClient should call <I>::GetActiveObject</I> to find out whether the object is already running. The following code connects to an existing object instance if such an instance exists or creates a new instance if it doesn't:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
 <PRE>BOOL bSuccess = FALSE;

CLSID clsid;
if (SUCCEEDED (CLSIDFromProgID (OLESTR (&quot;AutoPie.Application&quot;), &amp;clsid))) {
    IUnknown* pUnknown;
    if (SUCCEEDED (::GetActiveObject (clsid, NULL, &amp;pUnknown))) {
        IDispatch* pDispatch;
        if (SUCCEEDED (pUnknown-&gt;QueryInterface (IID_IDispatch,
            (void**) &amp;pDispatch))) {
            pDispatch-&gt;Release (); // Undo the AddRef performed 
                                   // by QueryInterface.
            m_autoPie.AttachDispatch (pDispatch);
            bSuccess = TRUE;
        }
    }
}

if (!bSuccess)
    bSuccess = m_autoPie.CreateDispatch (_T (&quot;AutoPie.Application&quot;));

if (!bSuccess) {
    // Error: Unable to connect to an existing object instance or
    // launch a new one.
}
</PRE>
</td></tr></table>
</p>

<p>If you apply these modifications to AutoPie and PieClient, you'll find that no matter how many instances of PieClient you start, each will connect to the same Automation object. One drawback to the <I>::RegisterActiveObject</I>/<I>::GetActiveObject</I>
 method is that it's powerless over a network, even though Automation itself works just fine between machines. Attaching multiple clients to an Automation server on another machine requires an altogether different approach to the problem. That, however, is a topic for another day.
</p>
</BODY>
</HTML>




