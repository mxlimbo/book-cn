<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Tree Views</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch10c.htm", "ch10e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="309"><H1>Tree Views</H1></A>

<p>MFC's <I>CTreeView</I> class enables programmers to create views similar to the one featured in the left pane of Windows Explorer. Tree views display treelike structures 
containing items composed of text and images. Items can have subitems, and collections 
of subitems, or <I>subtrees,</I> can be expanded and collapsed to display and hide 
the information contained therein. Tree views are ideal for depicting data that's 
inherently hierarchical, such as the directory structure of a hard disk. If you do even a moderate amount of Windows programming, you'll probably find plenty of uses for tree views.
</p>

<p>
<I>CTreeView</I> is a relatively simple class because it derives most of its 
functionality from the tree view control, which is one of the members of the common 
controls library Microsoft Windows 95 introduced to the world. In MFC, 
<I>CTreeCtrl</I> provides the programmatic interface to tree view controls. A tree view is programmed 
by calling <I>CTreeCtrl</I> functions on the underlying tree view control. The 
<I>CTreeView</I> function <I>GetTreeCtrl</I> returns a 
<I>CTreeCtrl</I> reference to that control. Thus, to 
determine how many items a tree view contains, you don't use a 
<I>CTreeView</I> function; instead, you call 
<I>CTreeCtrl::GetCount</I>, like this:</P>

<p>
<table cellpadding=5 width="95%">
<tr>
<td><pre>
UINT nCount = GetTreeCtrl ().GetCount ();</pre>
</td>
</tr>
</table>
</p>

<p>This paradigm&#8212;call a member function of the view to acquire a reference to 
the corresponding control&#8212;is shared by all of MFC's 
<I>CCtrlView</I>-derived classes.
</p>

<A NAME="310"><H2>Initializing a Tree View</H2></A>

<p>A tree view control supports several special window styles that influence its 
appearance and operation. Six of those styles are available on all systems 
running Windows 95 or later or Microsoft Windows NT 3.51 or later; additional styles 
are available on systems on which Internet Explorer 3.0 is installed, and even more 
styles are supported on systems equipped with Internet Explorer 4.0 or later. (For a 
discussion of the interdependencies between the common controls and Internet 
Explorer, see <a href="ch16a.htm">Chapter 16</a>.) You can apply any of the supported  styles to a tree view by 
ORing them into the <I>style</I> field of the CREATESTRUCT structure passed to 
<I>PreCreateWindow</I>. The six styles available to all tree views are listed in the following table.
</p>

<p><B>Tree View Styles</B></p>
<p><table cellpadding="5" width="95%">

<TR><TH valign="top"><I>Style</i></TH>
<TH valign="top"><i> Description</I></TH></TR>

<TR><TD valign="top">TVS_HASLINES</TD>
<TD valign="top">Adds lines connecting subitems to their parents.</TD></TR>

<TR><TD valign="top">TVS_LINESATROOT</TD>     <TD valign="top">Adds lines connecting items at the top level, or 
root, of the hierarchy. This style is valid only if 
TVS_HASLINES is also specified.</TD></TR>

<TR><TD valign="top">TVS_HASBUTTONS</TD>     <TD valign="top">Adds buttons containing plus or minus signs to 
items that have subitems. Clicking a button expands 
or collapses the associated subtree.</TD></TR>

<TR><TD valign="top">TVS_EDITLABELS </TD>    <TD valign="top">Enables in-place label editing notifications.</TD></TR>

<TR><TD valign="top">TVS_DISABLEDRAGDROP</TD>     <TD valign="top">Disables drag-and-drop notifications.</TD></TR>

<TR><TD valign="top">TVS_SHOWSELALWAYS</TD>    <TD valign="top"> Specifies that the item that's currently selected should always be highlighted. By default, the highlight is removed when the control loses the input focus.</TD></TR>
</table>
</p>

<p>
Each item in a tree view control consists of a text string (also known as a 
<I>label</I>) and optionally an image from an image list. The image list is another of the 
control types introduced in Windows 95. In MFC, image lists are represented by instances 
of the class <I>CImageList</I>. Think of an image list as a collection of like-sized bitmaps 
in which each bitmap is identified by a 0-based index. The statements
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td><pre>
CImageList il;
il.Create (IDB_IMAGES, 16, 1, RGB (255, 0, 255));</pre>
</td>
</tr>
</table>
</p>


<p>create an image list from a bitmap resource (ID=IDB_IMAGES) containing one or 
more images. Each image is 16 pixels wide, as indicated by 
<I>Create</I>'s second parameter. The COLORREF value in the final parameter specifies that magenta is the image lists's 
transparency color. When images from the image list are displayed in a tree view, 
only the nonmagenta pixels will be displayed.</p>
<p>If you want to include images as well as text in a tree view, you must 
create and initialize an image list and use <I>CTreeCtrl::SetImageList 
</I>to assign it to the tree view. If <I>il</I> is a 
<I>CImageList</I> object, the statement
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td><pre>
GetTreeCtrl ().SetImageList (&amp;il, TVSIL_NORMAL);</pre>
</td>
</tr>
</table>
</p>

<p>associates the image list with the control. TVSIL_NORMAL tells the tree view that 
the images in the image list will be used to represent both selected and unselected 
items. You can assign a separate TVSIL_STATE image list to the tree view to represent 
items that assume application-defined states. Note that the image list must not be 
destroyed before the tree view is destroyed; if it is, the images will disappear from the control.</p>
<p><I>CTreeCtrl::InsertItem</I> adds an item to a tree view control. Items are 
identified by HTREEITEM handles, and one of the parameters input to 
<I>InsertItem</I> is the HTREEITEM handle of the item's parent. A subitem is created when an item is added 
to a tree view and parented to another item. Root items&#8212;items in the uppermost level 
of the tree&#8212;are created by specifying TVI_ROOT as the parent. The following 
code sample initializes a tree view with the names of two 1970s rock groups along 
with subtrees listing some of their albums:
</p>
<p>
<table cellpadding=5 width="95%">
<tr>
<td><pre>
// Root items first, with automatic sorting.
HTREEITEM hEagles = GetTreeCtrl ().InsertItem (_T (&quot;Eagles&quot;),
    TVI_ROOT, TVI_SORT);
HTREEITEM hDoobies = GetTreeCtrl ().InsertItem (_T (&quot;Doobie Brothers&quot;),
    TVI_ROOT, TVI_SORT);

// Eagles subitems second (no sorting).
GetTreeCtrl ().InsertItem (_T (&quot;Eagles&quot;), hEagles);
GetTreeCtrl ().InsertItem (_T (&quot;On the Border&quot;), hEagles);
GetTreeCtrl ().InsertItem (_T (&quot;Hotel California&quot;), hEagles);
GetTreeCtrl ().InsertItem (_T (&quot;The Long Run&quot;), hEagles);

// Doobie subitems third (no sorting).
GetTreeCtrl ().InsertItem (_T (&quot;Toulouse Street&quot;), hDoobies);
GetTreeCtrl ().InsertItem (_T (&quot;The Captain and Me&quot;), hDoobies);
GetTreeCtrl ().InsertItem (_T (&quot;Stampede&quot;), hDoobies);
</pre>
</td>
</tr>
</table>
</p>

<p>Passing a TVI_SORT flag to <I>InsertItem</I> automatically sorts items added to the tree 
with respect to other items in the same subtree. The default is TVI_LAST, which 
simply adds the item to the end of the list. You can also specify TVI_FIRST to add an item 
to the head of the list.</p>

<p>That's one way to add items to a tree view control. You also have several 
other options for adding items because 
<I>CTreeCtrl</I> provides four different versions of 
<I>InsertItem</I>. Let's take the example in the previous paragraph a little further and assume 
that you'd like to include images as well as text in the tree view items. Suppose 
you've created an image list that contains two images. Image 0 depicts a guitar, and image 
1 depicts an album cover. You'd like guitars to appear alongside the names of the 
rock groups and album images to appear next to album titles. Here's what the code 
to initialize the control looks like:
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td><pre>
// Add the image list to the control.
GetTreeCtrl ().SetImageList (pImageList, TVSIL_NORMAL);

// Root items first, with automatic sorting
HTREEITEM hEagles = GetTreeCtrl ().InsertItem (_T (&quot;Eagles&quot;),
    0, 0, TVI_ROOT, TVI_SORT);
HTREEITEM hDoobies = GetTreeCtrl ().InsertItem (_T (&quot;Doobie Brothers&quot;),
    0, 0, TVI_ROOT, TVI_SORT);

// Eagles subitems second (no sorting)
GetTreeCtrl ().InsertItem (_T (&quot;Eagles&quot;), 1, 1, hEagles);
GetTreeCtrl ().InsertItem (_T (&quot;On the Border&quot;), 1, 1, hEagles);
GetTreeCtrl ().InsertItem (_T (&quot;Hotel California&quot;), 1, 1, hEagles);
GetTreeCtrl ().InsertItem (_T (&quot;The Long Run&quot;), 1, 1, hEagles);

// Doobie subitems third (no sorting)
GetTreeCtrl ().InsertItem (_T (&quot;Toulouse Street&quot;), 1, 1, hDoobies);
GetTreeCtrl ().InsertItem (_T (&quot;The Captain and Me&quot;), 1, 1, hDoobies);
GetTreeCtrl ().InsertItem (_T (&quot;Stampede&quot;), 1, 1, hDoobies);</pre>
</td>
</tr>
</table>
</p>

<p>The second and third parameters passed to this form of 
<I>InsertItem</I> are image indexes. The first specifies the image the tree view will display when the item isn't 
selected, and the second specifies the image it will display when the item 
<I>is</I> selected. Specifying the same index for both means that the same image will be used to represent 
the item in both states. The tree view control in the left pane of Windows Explorer 
uses an image depicting a closed folder for nonselected folder items and an open 
folder for selected folder items. Thus, if you move the highlight up and down with the 
arrow keys, a folder &quot;opens&quot; when you highlight it and closes when you highlight 
another item.
</p>

<A NAME="311"><H2>Tree View Member Functions and Notifications</H2></A>

<p><I>CTreeCtrl</I> provides a wide range of member functions for manipulating the 
underlying tree view control and acquiring information about its items. 
<I>DeleteItem</I>, for example, removes an item from the control, and 
<I>DeleteAllItems</I> removes all the items. 
<I>Expand</I> expands or collapses a subtree. 
<I>SetItemText</I> changes an item's label; 
<I>GetItemText</I> retrieves it. 
<I>SortChildren</I> sorts the items in a subtree. You name it, and there's 
probably a <I>CTreeCtrl</I> function for doing it.</p>
<p>The key to nearly every one of these functions is an HTREEITEM handle 
identifying the item that's the target of the operation. If you'd like, you can save the 
handles returned by <I>InsertItem</I> in an array or a linked list or some other structure so that 
you can reference them again later. You can retrieve the handle of the selected item 
with <I>CTreeCtrl::GetSelectedItem</I>. And if necessary, you can start with the first item in a 
tree view control and enumerate items one by one using 
<I>GetParentItem</I>, <I>GetChildItem</I>, 
<I>GetNextItem</I>, <I>GetNextSiblingItem</I>, and other 
<I>CTreeCtrl</I> functions.</p>
<p>Once items are added to it, a tree view is capable of processing most user 
input on its own. The user can browse the items in the tree by expanding and 
collapsing branches and can make selections by pointing and clicking. You can add even 
more capabilities to a tree view (or customize its default response to conventional 
input) by processing the notifications shown in the following table. Notifications come 
in the form of WM_NOTIFY messages, and in most cases, 
<I>lParam</I> points to an NM_TREEVIEW structure containing additional information about the event that prompted 
the message. Here are just a few uses for tree view notifications:
</p>


<UL>
<p><LI>Enable in-place label editing so that the user can edit text in a tree view</li></p>

<p><li>Update item text and images dynamically by passing 
LPSTR_TEXTCALL-BACK and I_IMAGECALLBACK parameters to 
<I>InsertItem</I> and processing TVN_GETDISPINFO notifications
</li></p>

<p><li>Customize the control's response to keyboard input by processing 
TVN-_KEYDOWN notifications
</li></p>

<p><li>Support drag-and-drop operations
</li></p>
</ul>

<p>There are more uses (of course!), but this short list should give you an idea of the wide-ranging flexibility of a tree view control.
</p>

<B>Tree View Notifications</B>
<p><table cellpadding="5" width="95%">

<TR><Th valign="top"><i>Notification</i></Th>
<Th valign="top"><i>Sent When</i></Th></TR>

<TR><TD valign="top">TVN_BEGINDRAG</TD>
<TD valign="top"> A drag-and-drop operation is begun with the left mouse 
button. Not sent if the control has the style TVS_DISABLEDRAGDROP.</TD></TR>

<TR><TD valign="top">TVN_BEGINRDRAG</TD>
<TD valign="top"> A drag-and-drop operation is begun with the right mouse 
button. Not sent if the control has the style TVS_DISABLEDRAGDROP.</TD></TR>

<TR><TD valign="top">TVN_BEGINLABELEDIT </TD>
<TD valign="top"> A label editing operation is begun. Sent only if the control has the style TVS_EDITLABELS.</TD></TR>

<TR><TD valign="top">TVN_ENDLABELEDIT </TD>
<TD valign="top"> A label editing operation is completed. Sent only if the control has the style TVS_EDITLABELS.</TD></TR>

<TR><TD valign="top">TVN_GETDISPINFO</TD>
<TD valign="top">The control needs additional information to display an item. Sent 
if the item text is LPSTR_TEXTCALLBACK or the image index 
is I_IMAGECALLBACK.</TD></TR>

<TR><TD valign="top">TVN_DELETEITEM</TD>
<TD valign="top">  An item is deleted.</TD></TR>

<TR><TD valign="top">TVN_ITEMEXPANDED </TD>
<TD valign="top"> A subtree has expanded or collapsed.</TD></TR>

<TR><TD valign="top">TVN_ITEMEXPANDING </TD>
<TD valign="top">A subtree is about to expand or collapse.</TD></TR>

<TR><TD valign="top">TVN_KEYDOWN  </TD>
<TD valign="top">A key is pressed while the control has the input focus.</TD></TR>

<TR><TD valign="top">TVN_SELCHANGED</TD>
<TD valign="top">  The selection has changed.</TD></TR>

<TR><TD valign="top">TVN_SELCHANGING </TD>
<TD valign="top">The selection is about to change.</TD></TR>

<TR><TD valign="top">TVN_SETDISPINFO </TD>
<TD valign="top">The information in a TV_DISPINFO structure needs to be updated.</TD>
</TR>
</table>
</p>
<A NAME="312"><H2>The DriveTree Application</H2></A>

<p>The DriveTree application shown in Figure 10-6 uses a 
<I>CTreeView</I>-derived class named <I>CDriveView 
</I>to provide an interactive view of the host PC's drive and 
directory structure. 
<I>CDriveView::OnInitialUpdate</I> uses 
<I>SetImageList</I> to import an image list containing bitmaps for different drive types and then calls a helper function 
named <I>AddDrives</I> to initialize the drive list. 
<I>AddDrives</I> uses the Win32 <I>::GetLogical-
Drives</I> function to identify the logical drives in the system. For each drive, it 
calls <I>CDriveView::AddDriveItem</I> to add a &quot;drive item&quot;&#8212;a tree view item representing 
a drive&#8212;to the tree's uppermost level. 
<I>::GetLogicalDrives</I> returns a DWORD value 
with &quot;on&quot; bits identifying the valid logical drives, where bit 0 corresponds to drive 
A:, bit 1 to drive B:, and so on. <I>AddDrives</I> needs just a few lines of code to 
enumerate the drives in the system and create a drive item for each. (See Figure 10-7.)
</p>
<p>
<A HREF="javascript:fullSize('F10mg06x.htm')"> <img src="images/F10mg06.JPG" width=404 height=316 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 10-6.</B> <i>The DriveTree window.</I><!-- /CAPTION -->
</p>

<p><i>AddDriveItem</I> uses 
<I>CTreeCtrl::InsertItem</I> to add drive items to the tree. For 
each drive item that it adds, it also adds a &quot;dummy&quot; subitem so that a plus sign will 
appear next to the drive item. To determine a drive's type&#8212;floppy drive, hard disk, and 
so on&#8212;so that it can assign the drive an image from the image list, 
<I>AddDriveItem</I> uses the <I>::GetDriveType</I> API function. Given a string specifying the path to a drive's 
root directory, <I>::GetDriveType</I> returns a UINT value identifying the drive type. The 
possible return values are listed below.
</p>

<p><table cellpadding="5" width="95%">
<TR><TH valign="top"><I>Return Value</i> </TH>
<TH valign="top"> <i>Meaning</I></TH></TR>

<TR><TD valign="top">DRIVE_UNKNOWN </TD>
<TD valign="top"> The drive type is unknown.</TD></TR>

<TR><TD valign="top">DRIVE_NO_ROOT_DIR </TD>
<TD valign="top"> The drive lacks a root directory.</TD></TR>

<TR><TD valign="top">DRIVE_REMOVABLE </TD>
<TD valign="top"> The drive is removable (returned for floppy 
drives and other removable-media drives such as 
Zip drives).</TD></TR>

<TR><TD valign="top">DRIVE_FIXED </TD>
<TD valign="top"> The drive is fixed (returned for hard disks).</TD></TR>

<TR><TD valign="top">DRIVE_REMOTE </TD>
<TD valign="top">The drive is remote (returned for network drives).</TD></TR>

<TR><TD valign="top">DRIVE_CDROM </TD>
<TD valign="top"> The drive is a CD-ROM drive.</TD></TR>

<TR><TD valign="top">DRIVE_RAMDISK</TD>
<TD valign="top"> The drive is a RAM disk.</TD></TR>
</table></p>
<p>

<I>AddDriveItem</I> uses a <I>switch-case</I> block to handle each of the possible return 
values. A series of ILI values defined near the top of DriveView.cpp correlates drive 
types and image indexes.
</p>
<p>
Much of the remaining code in DriveView.cpp is devoted to processing 
TVN_ITEMEXPANDING notifications. For performance reasons, 
<I>CDriveView</I> doesn't initialize itself with items representing every directory on every drive. Instead, it 
adds directory items to a subtree just before the subtree is displayed and removes them when the subtree is collapsed. If a collapsed subtree contains at least one directory, a single child item is inserted so that a plus sign will appear next to the subtree. That child item is never seen because it's deleted before the subtree is expanded and replaced with items representing actual directories. An ON_NOTIFY_REFLECT 
entry in the message map reflects TVN_ITEMEXPANDING notifications so that <I>CDriveView</I> can handle them itself. The notification handler <I>OnItemExpanding</I> either adds items to the subtree or removes them, depending on whether the 
<I>action</I> field of the NM_TREEVIEW structure indicates that the subtree is about to expand or collapse. <I>OnItemExpanding</I> uses the helper function 
<I>AddDirectories</I> to populate a branch of the tree with items. <I>AddDirectories</I>, in turn, uses the 
<I>::FindFirstFile</I> and <I>::FindNextFile</I> functions discussed in <a href="ch06a.htm">Chapter 6</a> to enumerate directories.
</p>

<A NAME="313"><H3>Removing the Document Name from the Title Bar</H3></A>

<p>DriveTree doesn't use its document object at all. Its File menu doesn't include document-handling commands. And it doesn't display a document name in its title bar because it doesn't make sense to display a document name when the application doesn't support the loading and saving of documents. But because MFC 
automatically adds the document name to the title bar, you must take special steps to prevent MFC from inserting a document name.</p>
<p>You'll find the code responsible for removing the document name in the frame window class. 
<I>CMainFrame::PreCreateWindow</I> contains the statement
</p>
<p>
<table cellpadding=5 width="95%">
<tr>
<td><pre>
cs.style &amp;= ~FWS_ADDTOTITLE;</pre>
</td>
</tr>
</table>
</p>

<p>FWS_ADDTOTITLE is a special window style specific to MFC that's included in frame windows by default. Windows that have this style have document names added to their window titles; windows that lack this style don't. By stripping the 
FWS_ADDTOTITLE bit from the window style in <I>PreCreateWindow</I>, <I>CMainFrame</I> prevents the 
framework from modifying its window title. You can use this technique to remove the document name from the title bar of any document/view application.
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<A NAME="314"><H3>MainFrm.h</H3></A>
<pre>
// MainFrm.h : interface of the CMainFrame class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__090B3829_959D_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_MAINFRM_H__090B3829_959D_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

class CMainFrame : public CFrameWnd
{
    
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
       // NOTE - the ClassWizard will add and remove member functions here.
       //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(
//     AFX_MAINFRM_H__090B3829_959D_11D2_8E53_006008A82731__INCLUDED_)
</pre>
</td>
</tr>
</table>
</p>
<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<A NAME="315"><H3>MainFrm.cpp</H3></A>
<pre>
// MainFrm.cpp : implementation of the CMainFrame class
//

#include &quot;stdafx.h&quot;
#include &quot;DriveTree.h&quot;

#include &quot;MainFrm.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;

    cs.style &amp;= ~FWS_ADDTOTITLE;
    return TRUE;
}

//////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext&amp; dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

//////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
</pre>
</td>
</tr>
</table>
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<A NAME="316"><H3>DriveView.h</H3></A>
<pre>
// DriveTreeView.h : interface of the CDriveView class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DRIVETREEVIEW_H__090B382D_959D_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_DRIVETREEVIEW_H__090B382D_959D_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000


class CDriveView : public CTreeView
{
protected: // create from serialization only
    CDriveView();
    DECLARE_DYNCREATE(CDriveView)

// Attributes
public:
    CDriveTreeDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDriveView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    protected:
    virtual void OnInitialUpdate(); // called first time after construct
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CDriveView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:

// Generated message map functions
protected:
    BOOL AddDriveItem (LPCTSTR pszDrive);
    int AddDirectories (HTREEITEM hItem, LPCTSTR pszPath);
    void DeleteAllChildren (HTREEITEM hItem);
    void DeleteFirstChild (HTREEITEM hItem);
    CString GetPathFromItem (HTREEITEM hItem);
    BOOL SetButtonState (HTREEITEM hItem, LPCTSTR pszPath);
    int AddDrives ();
    CImageList m_ilDrives;
    //{{AFX_MSG(CDriveView)
    afx_msg void OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in DriveTreeView.cpp
inline CDriveTreeDoc* CDriveView::GetDocument()
   { return (CDriveTreeDoc*)m_pDocument; }
#endif

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(
//     AFX_DRIVETREEVIEW_H__090B382D_959D_11D2_8E53_006008A82731__INCLUDED_)
</pre>
</td>
</tr>
</table>
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<A NAME="317"><H3>DriveView.cpp</H3></A>
<pre>
// DriveTreeView.cpp : implementation of the CDriveView class
//

#include &quot;stdafx.h&quot;
#include &quot;DriveTree.h&quot;

#include &quot;DriveTreeDoc.h&quot;
#include &quot;DriveView.h&quot;
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Image indexes
#define ILI_HARD_DISK       0
#define ILI_FLOPPY          1
#define ILI_CD_ROM          2
#define ILI_NET_DRIVE       3
#define ILI_CLOSED_FOLDER   4
#define ILI_OPEN_FOLDER     5

//////////////////////////////////////////////////////////////////////
// CDriveView

IMPLEMENT_DYNCREATE(CDriveView, CTreeView)

BEGIN_MESSAGE_MAP(CDriveView, CTreeView)
    //{{AFX_MSG_MAP(CDriveView)
    ON_NOTIFY_REFLECT(TVN_ITEMEXPANDING, OnItemExpanding)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
// CDriveView construction/destruction

CDriveView::CDriveView()
{
}

CDriveView::~CDriveView()
{
}

BOOL CDriveView::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    if (!CTreeView::PreCreateWindow (cs))
        return FALSE;

    cs.style &#166;= TVS_HASLINES &#166; TVS_LINESATROOT &#166; TVS_HASBUTTONS &#166;
        TVS_SHOWSELALWAYS;
    return TRUE;
}

//////////////////////////////////////////////////////////////////////
// CDriveView drawing

void CDriveView::OnDraw(CDC* pDC)
{
    CDriveTreeDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    // TODO: add draw code for native data here
}

void CDriveView::OnInitialUpdate()
{
    CTreeView::OnInitialUpdate();

    //
    // Initialize the image list.
    //
    m_ilDrives.Create (IDB_DRIVEIMAGES, 16, 1, RGB (255, 0, 255));
    GetTreeCtrl ().SetImageList (&amp;m_ilDrives, TVSIL_NORMAL);

    //
    // Populate the tree view with drive items.
    //
    AddDrives ();

    //
    // Show the folders on the current drive.
    //
    TCHAR szPath[MAX_PATH];
    ::GetCurrentDirectory (sizeof (szPath) / sizeof (TCHAR), szPath);
    CString strPath = szPath;
    strPath = strPath.Left (3);

    HTREEITEM hItem = GetTreeCtrl ().GetNextItem (NULL, TVGN_ROOT);
    while (hItem != NULL) {
        if (GetTreeCtrl ().GetItemText (hItem) == strPath)
            break;
        hItem = GetTreeCtrl ().GetNextSiblingItem (hItem);
    }

    if (hItem != NULL) {
        GetTreeCtrl ().Expand (hItem, TVE_EXPAND);
        GetTreeCtrl ().Select (hItem, TVGN_CARET);
    }
}

//////////////////////////////////////////////////////////////////////
// CDriveView diagnostics

#ifdef _DEBUG
void CDriveView::AssertValid() const
{
    CTreeView::AssertValid();
}

void CDriveView::Dump(CDumpContext&amp; dc) const
{
    CTreeView::Dump(dc);
}

CDriveTreeDoc* CDriveView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CDriveTreeDoc)));
    return (CDriveTreeDoc*)m_pDocument;
}
#endif //_DEBUG

//////////////////////////////////////////////////////////////////////
// CDriveView message handlers

int CDriveView::AddDrives()
{
    int nPos = 0;
    int nDrivesAdded = 0;
    CString string = _T (&quot;?:\\&quot;);

    DWORD dwDriveList = ::GetLogicalDrives ();

    while (dwDriveList) {
        if (dwDriveList &amp; 1) {
            string.SetAt (0, _T (`A') + nPos);
            if (AddDriveItem (string))
                nDrivesAdded++;
        }
        dwDriveList &gt;&gt;= 1;
        nPos++;
    }
    return nDrivesAdded;
}

BOOL CDriveView::AddDriveItem(LPCTSTR pszDrive)
{
    CString string;
    HTREEITEM hItem;

    UINT nType = ::GetDriveType (pszDrive);

    switch (nType) {

    case DRIVE_REMOVABLE:
        hItem = GetTreeCtrl ().InsertItem (pszDrive, ILI_FLOPPY,
            ILI_FLOPPY);
        GetTreeCtrl ().InsertItem (_T (&quot;&quot;), ILI_CLOSED_FOLDER,
            ILI_CLOSED_FOLDER, hItem);
        break;

    case DRIVE_FIXED:
    case DRIVE_RAMDISK:
        hItem = GetTreeCtrl ().InsertItem (pszDrive, ILI_HARD_DISK,
            ILI_HARD_DISK);
        SetButtonState (hItem, pszDrive);
        break;

    case DRIVE_REMOTE:
        hItem = GetTreeCtrl ().InsertItem (pszDrive, ILI_NET_DRIVE,
            ILI_NET_DRIVE);
        SetButtonState (hItem, pszDrive);
        break;

    case DRIVE_CDROM:
        hItem = GetTreeCtrl ().InsertItem (pszDrive, ILI_CD_ROM,
            ILI_CD_ROM);
        GetTreeCtrl ().InsertItem (_T (&quot;&quot;), ILI_CLOSED_FOLDER,
            ILI_CLOSED_FOLDER, hItem);
        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL CDriveView::SetButtonState(HTREEITEM hItem, LPCTSTR pszPath)
{
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    BOOL bResult = FALSE;

    CString strPath = pszPath;
    if (strPath.Right (1) != _T (&quot;\\&quot;))
        strPath += _T (&quot;\\&quot;);
    strPath += _T (&quot;*.*&quot;);

    if ((hFind = ::FindFirstFile (strPath, &amp;fd)) == INVALID_HANDLE_VALUE)
        return bResult;

do {
        if (fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {
            CString strComp = (LPCTSTR) &amp;fd.cFileName;
            if ((strComp != _T (&quot;.&quot;)) &amp;&amp; (strComp != _T (&quot;..&quot;))) {
                GetTreeCtrl ().InsertItem (_T (&quot;&quot;), ILI_CLOSED_FOLDER,
                    ILI_CLOSED_FOLDER, hItem);
                bResult = TRUE;
                break;
            }
        }
    } while (::FindNextFile (hFind, &amp;fd));

    ::FindClose (hFind);
    return bResult;
}

void CDriveView::OnItemExpanding(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
    HTREEITEM hItem = pNMTreeView-&gt;itemNew.hItem;
    CString string = GetPathFromItem (hItem);

    *pResult = FALSE;

    if (pNMTreeView-&gt;action == TVE_EXPAND) {
        DeleteFirstChild (hItem);
        if (AddDirectories (hItem, string) == 0)
            *pResult = TRUE;
    }
    else { // pNMTreeView-&gt;action == TVE_COLLAPSE
        DeleteAllChildren (hItem);
        if (GetTreeCtrl ().GetParentItem (hItem) == NULL)
            GetTreeCtrl ().InsertItem (_T (&quot;&quot;), ILI_CLOSED_FOLDER,
                ILI_CLOSED_FOLDER, hItem);
        else
            SetButtonState (hItem, string);
    }
}

CString CDriveView::GetPathFromItem(HTREEITEM hItem)
{
    CString strResult = GetTreeCtrl ().GetItemText (hItem);

    HTREEITEM hParent;
    while ((hParent = GetTreeCtrl ().GetParentItem (hItem)) != NULL) {
        CString string = GetTreeCtrl ().GetItemText (hParent);
        if (string.Right (1) != _T (&quot;\\&quot;))
            string += _T (&quot;\\&quot;);
        strResult = string + strResult;
        hItem = hParent;
    }
    return strResult;
}

void CDriveView::DeleteFirstChild(HTREEITEM hItem)
{
    HTREEITEM hChildItem;
    if ((hChildItem = GetTreeCtrl ().GetChildItem (hItem)) != NULL)
        GetTreeCtrl ().DeleteItem (hChildItem);
}

void CDriveView::DeleteAllChildren(HTREEITEM hItem)
{
    HTREEITEM hChildItem;
    if ((hChildItem = GetTreeCtrl ().GetChildItem (hItem)) == NULL)
        return;

    do {
        HTREEITEM hNextItem =
            GetTreeCtrl ().GetNextSiblingItem (hChildItem);
        GetTreeCtrl ().DeleteItem (hChildItem);
        hChildItem = hNextItem;
    } while (hChildItem != NULL);
}

int CDriveView::AddDirectories(HTREEITEM hItem, LPCTSTR pszPath)
{
    HANDLE hFind;
    WIN32_FIND_DATA fd;
    HTREEITEM hNewItem;

    int nCount = 0;

    CString strPath = pszPath;
    if (strPath.Right (1) != _T (&quot;\\&quot;))
        strPath += _T (&quot;\\&quot;);
    strPath += _T (&quot;*.*&quot;);

    if ((hFind = ::FindFirstFile (strPath, &amp;fd)) == INVALID_HANDLE_VALUE) {
        if (GetTreeCtrl ().GetParentItem (hItem) == NULL)
            GetTreeCtrl ().InsertItem (_T (&quot;&quot;), ILI_CLOSED_FOLDER,
                ILI_CLOSED_FOLDER, hItem);
        return 0;
    }

   do {
        if (fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {
            CString strComp = (LPCTSTR) &amp;fd.cFileName;
            if ((strComp != _T (&quot;.&quot;)) &amp;&amp; (strComp != _T (&quot;..&quot;))) {
                hNewItem =
                    GetTreeCtrl ().InsertItem ((LPCTSTR) &amp;fd.cFileName,
                    ILI_CLOSED_FOLDER, ILI_OPEN_FOLDER, hItem);

                CString strNewPath = pszPath;
                if (strNewPath.Right (1) != _T (&quot;\\&quot;))
                    strNewPath += _T (&quot;\\&quot;);

                strNewPath += (LPCTSTR) &amp;fd.cFileName;
                SetButtonState (hNewItem, strNewPath);
                nCount++;
            }
        }
    } while (::FindNextFile (hFind, &amp;fd));

    ::FindClose (hFind);
    return nCount;
}

</pre>
</td>
</tr>
</table>
</p>


</BODY>
</HTML>




