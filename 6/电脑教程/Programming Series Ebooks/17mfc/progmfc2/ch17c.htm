<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Thread Synchronization</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch17b.htm", "ch17d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="544"><H1>Thread Synchronization</H1></A>

<p>In the real world, you don't usually have the luxury of starting a thread and just letting it run. More often than not, that thread must coordinate its actions with other threads in the application. If two threads share a linked list, for example, accesses to the linked list must be serialized so that both threads don't try to modify it at the same time. Simply letting a thread go off and do its own thing can lead to all sorts of synchronization problems that show up only randomly in testing and that can often be fatal to the application.</p>

<p>Windows supports four types of synchronization objects that can be used to synchronize the actions performed by concurrently running threads:</p>

<ul>
<p><li>Critical sections</li></p>
<p><li>Mutexes</li></p>
<p><li>Events</li></p>
<p><li>Semaphores</li></p>
</ul>

<p>MFC encapsulates these objects in classes named <i>CCriticalSection</i>, <i>CMutex</i>, <i>CEvent</i>, and <i>CSemaphore</i>. It also includes a pair of classes named <i>CSingleLock</i> and <i>CMultiLock</i> that further abstract the interfaces to thread synchronization objects. In the sections that follow, I'll describe how to use these classes to synchronize the actions of concurrently executing threads.</p>

<A NAME="545"><H2>Critical Sections</H2></A>

<p>The simplest type of thread synchronization object is the critical section. Critical sections are used to serialize accesses performed on linked lists, simple variables, structures, and other resources that are shared by two or more threads. The threads must belong to the same process, because critical sections don't work across process boundaries.</p>

<p>The idea behind critical sections is that each thread that requires exclusive access to a resource can lock a critical section before accessing that resource and unlock it when the access is complete. If thread B attempts to lock a critical section that is currently locked by thread A, thread B blocks until the critical section comes free. While blocked, thread B waits in an extremely efficient wait state that consumes no processor time.</p>

<p><i>CCriticalSection::Lock</i> locks a critical section, and <i>CCriticalSection::Unlock</i> unlocks it. Let's say that a document class includes a linked-list data member created from MFC's <i>CList</i> class and that two separate threads use the linked list. One writes to the list, and the other reads from it. To prevent the two threads from accessing the list at exactly the same time, you can protect the list with a critical section. The following example uses a globally declared <i>CCriticalSection</i> object to demonstrate how. (I've used global synchronization objects in the examples to ensure that the objects are equally visible to all the threads in a process, but no, synchronization objects don't have to have global scope.)</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>// Global data
CCriticalSection g_cs;
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
// Thread A
g_cs.Lock ();
// Write to the linked list.
g_cs.Unlock ();
   
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
   
// Thread B
g_cs.Lock ();
// Read from the linked list.
g_cs.Unlock ();
</pre></td>
		</tr>
	</table></p>

<p>Now it's impossible for threads A and B to access the linked list at the same time because both guard the list with the same critical section. The diagram in Figure 17-3 illustrates how the critical section prevents overlapping read and write accesses by serializing the threads' actions.</p>

<p>
<A HREF="javascript:fullSize('F17mg03x.htm')"> <img src="Images/F17mg03.JPG" width=404 height=197 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 17-3.</b> <i>Protecting a shared resource with a critical section.</i><!-- /CAPTION -->
</p>

<p>An alternate form of <i>CCriticalSection::Lock</i> accepts a time-out value, and some MFC documentation states that if you pass <i>Lock</i> a time-out value, it will return if the time-out period expires before the critical section comes free. The documentation is wrong. You can specify a time-out value if you want to, but <i>Lock</i> won't return until the critical section is unlocked.</p>

<p>It's obvious why a linked list should be protected from concurrent thread accesses, but what about simple variables? For example, suppose thread A increments a variable with the statement</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>nVar++;
</pre></td>
		</tr>
	</table></p>

<p>and thread B does something else with the variable. Should <i>nVar</i> be protected with a critical section? In general, yes. What looks to be an atomic operation in a C++ program&#8212;even the application of a simple ++ operator&#8212;might compile into a sequence of several machine instructions. And one thread can preempt another between any two machine instructions. As a rule, it's a good idea to protect any data subject to simultaneous write accesses or simultaneous read and write accesses. A critical section is the perfect tool for the job.</p>

<p>The Win32 API includes a family of functions named <i>::InterlockedIncrement</i>, <i>::InterlockedDecrement</i>, <i>::InterlockedExchange</i>, <i>::InterlockedCompareExchange</i>, and <i>::InterlockedExchangeAdd</i> that you can use to safely operate on 32-bit values without explicitly using synchronization objects. For example, if <i>nVar</i> is a UINT, DWORD, or other 32-bit data type, you can increment it with the statement</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>::InterlockedIncrement (&amp;nVar);
</pre></td>
		</tr>
	</table></p>

<p>and the system will ensure that other accesses to <i>nVar</i> performed using <i>Interlocked</i> functions don't overlap. <i>nVar</i> should be aligned on a 32-bit boundary, or the <i>Interlocked</i> functions might fail on multiprocessor Windows NT systems. Also, <i>::InterlockedCompareExchange</i> and <i>::InterlockedExchangeAdd</i> are supported only in Windows NT 4.0 and higher and Windows 98.</p>

<A NAME="546"><H2>Mutexes</H2></A>

<p><i>Mutex</i> is a contraction of the words <i>mutually</i> and <i>exclusive</i>. Like critical sections, mutexes are used to gain exclusive access to a resource shared by two or more threads. Unlike critical sections, mutexes can be used to synchronize threads running in the same process <i>or</i> in different processes. Critical sections are generally preferred to mutexes for intraprocess thread synchronization needs because critical sections are faster, but if you want to synchronize threads running in two or more different processes, mutexes are the answer.</p>

<p>Suppose two applications use a block of shared memory to exchange data. Inside that shared memory is a linked list that must be protected against concurrent thread accesses. A critical section won't work because it can't reach across process boundaries, but a mutex will do the job nicely. Here's what you do in each process before reading or writing the linked list:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>// Global data
CMutex g_mutex (FALSE, _T (&quot;MyMutex&quot;));

    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">    
   
g_mutex.Lock ();
// Read or write the linked list.
g_mutex.Unlock ();
</pre></td>
		</tr>
	</table></p>

<p>The first parameter passed to the <i>CMutex</i> constructor specifies whether the mutex is initially locked (TRUE) or unlocked (FALSE). The second parameter specifies the mutex's name, which is required if the mutex is used to synchronize threads in two different processes. You pick the name, but both processes must specify the same name so that the two <i>CMutex</i> objects will reference the same mutex object in the Windows kernel. Naturally, <i>Lock</i> blocks on a mutex locked by another thread, and <i>Unlock</i> frees the mutex so that others can lock it.</p>

<p>By default, <i>Lock</i> will wait forever for a mutex to become unlocked. You can build in a fail-safe mechanism by specifying a maximum wait time in milliseconds. In the following example, the thread waits for up to 1 minute before accessing the resource guarded by the mutex.</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>g_mutex.Lock (60000);
// Read or write the linked list.
g_mutex.Unlock ();
</pre></td>
		</tr>
	</table></p>

<p><i>Lock</i>'s return value tells you why the function call returned. A nonzero return means that the mutex came free, and 0 indicates that the time-out period expired first. If <i>Lock</i> returns 0, it's normally prudent not to access the shared resource because doing so could result in an overlapping access. Thus, code that uses <i>Lock</i>'s time-out feature is normally structured like this:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>if (g_mutex.Lock (60000)) {
    // Read or write the linked list.
    g_mutex.Unlock ();
}
</pre></td>
		</tr>
	</table></p>

<p>There is one other difference between mutexes and critical sections. If a thread locks a critical section and terminates without unlocking it, other threads waiting for the critical section to come free will block indefinitely. However, if a thread that locks a mutex fails to unlock it before terminating, the system deems the mutex to be &quot;abandoned&quot; and automatically frees the mutex so that waiting threads can resume.</p>

<A NAME="547"><H2>Events</H2></A>

<p>MFC's <i>CEvent</i> class encapsulates Win32 event objects. An event is little more than a flag in the operating system kernel. At any given time, it can be in either of two states: raised (set) or lowered (reset). A set event is said to be in a signaled state, and a reset event is said to be nonsignaled. <i>CEvent::SetEvent</i> sets an event, and <i>CEvent::ResetEvent</i> resets it. A related function, <i>CEvent::PulseEvent</i>, sets and clears an event in one operation.</p>

<p>Events are sometimes described as &quot;thread triggers.&quot; One thread calls <i>CEvent::Lock</i> to block on an event and wait for it to become set. Another thread sets the event and thereby releases the waiting thread. Setting the event is like pulling a trigger: it unblocks the waiting thread and allows it to resume executing. An event can have one thread or several threads blocking on it, and if your code is properly written, all waiting threads will be released when the event becomes set.</p>

<p>Windows supports two different types of events: autoreset events and manual-reset events. The difference between them is very simple, but the implications are far-reaching. An autoreset event is automatically reset to the nonsignaled state when a thread blocking on it is released. A manual-reset event doesn't reset automatically; it must be reset programmatically. The rules for choosing between autoreset and manual-reset events&#8212;and for using them once you've made your selection&#8212;are as follows:</p>

<ul>
<p><li>If just one thread will be triggered by the event, use an autoreset event and release the waiting thread with <i>SetEvent</i>. There's no need to call <i>ResetEvent</i> because the event is reset automatically the moment the thread is released.</li></p>
<p><li>If two or more threads will be triggered by the event, use a manual-reset event and release all waiting threads with <i>PulseEvent</i>. Once more, you don't need to call <i>ResetEvent</i> because <i>PulseEvent</i> resets the event for you after releasing the threads.</li></p>
</ul>

<p>It's vital to use a manual-reset event to trigger multiple threads. Why? Because an autoreset event would be reset the moment one of the threads was released and would therefore trigger just one thread. It's equally important to use <i>PulseEvent</i> to pull the trigger on a manual-reset event. If you use <i>SetEvent</i> and <i>ResetEvent</i>, you have no guarantee that all waiting threads will be released. <i>PulseEvent</i> not only sets and resets the event, but it also ensures that all threads waiting on the event are released before resetting the event.</p>

<p>An event is created by constructing a <i>CEvent</i> object. <i>CEvent::CEvent</i> accepts four parameters, all of them optional. It's prototyped as follows:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>CEvent (BOOL bInitiallyOwn = FALSE,
    BOOL bManualReset = FALSE, LPCTSTR lpszName = NULL,
    LPSECURITY_ATTRIBUTES lpsaAttribute = NULL)
</pre></td>
		</tr>
	</table></p>

<p>The first parameter, <i>bInitiallyOwn</i>, specifies whether the eventobject is initially signaled (TRUE) or nonsignaled (FALSE). The default is fine in most cases. <i>bManualReset</i> specifies whether the event is a manual-reset event (TRUE) or an autoreset event (FALSE). The third parameter, <i>lpszName</i>, assigns a name to the event object. Like mutexes, events can be used to coordinate threads running in different processes, and for an event to span process boundaries, it must be assigned a name. If the threads that use the event belong to the same process, <i>lpszName</i> should be NULL. The final parameter, <i>lpsaAttribute</i>, is a pointer to a SECURITY_ATTRIBUTES structure describing the object's security attributes. NULL accepts the default security attributes, which are appropriate for most applications.</p>

<p>So how do you use events to synchronize threads? Here's an example involving one thread (thread A) that fills a buffer with data and another thread (thread B) that does something with that data. Assume that thread B must wait for a signal from thread A saying that the buffer is initialized and ready to go. An autoreset event is the perfect tool for the job:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>// Global data
CEvent g_event; // Autoreset, initially nonsignaled
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
// Thread A
InitBuffer (&amp;buffer); // Initialize the buffer.
g_event.SetEvent ();  // Release thread B.
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
// Thread B
g_event.Lock ();      // Wait for the signal.
</pre></td>
		</tr>
	</table></p>

<p>Thread B calls <i>Lock</i> to block on the event object. Thread A calls <i>SetEvent</i> when it's ready to release thread B. Figure 17-4 shows what happens as a result.</p>

<p>
<A HREF="javascript:fullSize('F17mg04x.htm')"> <img src="Images/F17mg04.JPG" width=404 height=161 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 17-4.</b> <i>Triggering a thread with an autoreset event.</i><!-- /CAPTION -->
</p>

<p>The lone parameter passed to <i>Lock</i> specifies how long the caller is willing to wait, in milliseconds. The default is INFINITE, which means wait as long as necessary. A nonzero return value means that <i>Lock</i> returned because the object became signaled; 0 means that the time-out period expired or an error occurred. MFC isn't doing anything fancy here. It's simply recasting the kernel's thread synchronization objects and the API functions that operate on them in a more object-oriented mold.</p>

<p>Autoreset events are fine for triggering single threads, but what if a thread C running in parallel with thread B does something entirely different with the buffered data? You need a manual-reset event to release B and C together because an autoreset event would release one or the other but not both. Here's the code to trigger two or more threads with a manual-reset event:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>// Global data
CEvent g_event (FALSE, TRUE); // Nonsignaled, manual-reset
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
// Thread A
InitBuffer (&amp;buffer);  // Initialize the buffer.
g_event.PulseEvent (); // Release threads B and C.
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
// Thread B
g_event.Lock ();       // Wait for the signal.
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
// Thread C
g_event.Lock ();       // Wait for the signal.
</pre></td>
		</tr>
	</table></p>

<p>Notice that thread A uses <i>PulseEvent</i> to pull the trigger, in accordance with the second of the two rules prescribed above. Figure 17-5 illustrates the effect of using a manual-reset event to trigger two threads.</p>

<p>
<A HREF="javascript:fullSize('F17mg05x.htm')"> <img src="Images/F17mg05.JPG" width=404 height=166 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 17-5.</b> <i>Triggering two threads with a manual-reset event.</i><!-- /CAPTION -->
</p>

<p>To reiterate, use autoreset events and <i>CEvent::SetEvent</i> to release single threads blocking on an event, and use manual-reset events and <i>CEvent::PulseEvent</i> to release multiple threads. Abide by these simple rules and events will serve you capably and reliably.</p>

<p>Sometimes events aren't used as triggers but as primitive signaling mechanisms. For example, maybe thread B wants to know whether thread A has completed some task, but it doesn't want to block if the answer is no. Thread B can check the state of an event without blocking by passing <i>::WaitForSingleObject</i> the event handle and a time-out value of 0. The event handle can be retrieved from a <i>CEvent</i>'s <i>m_hObject</i> data member:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>if (::WaitForSingleObject (g_event.m_hObject, 0) == WAIT_OBJECT_0) {
    // The event is signaled.
}
else {
    // The event is not signaled.
}
</pre></td>
		</tr>
	</table></p>

<p>One caveat to be aware of when using an event in this manner is that if thread B will be checking the event repeatedly until it becomes set, make sure that the event is a manual-reset event and not an autoreset event. Otherwise, the very act of checking the event will reset it.</p>

<A NAME="548"><H2>Semaphores</H2></A>

<p>The fourth and final type of synchronization object is the semaphore. Events, critical sections, and mutexes are &quot;all or nothing&quot; objects in the sense that <i>Lock</i> blocks on them if any other thread has them locked. Semaphores are different. Semaphores maintain resource counts representing the number of resources available. Locking a semaphore decrements its resource count, and unlocking a semaphore increments the resource count. A thread blocks only if it tries to lock a semaphore whose resource count is 0. In that case, the thread blocks until another thread unlocks the semaphore and thereby raises the resource count or until a specified time-out period has elapsed. Semaphores can be used to synchronize threads within a process or threads that belong to different processes.</p>

<p>MFC represents semaphores with instances of the class <i>CSemaphore</i>. The statement</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>CSemaphore g_semaphore (3, 3);
</pre></td>
		</tr>
	</table></p>

<p>constructs a semaphore object that has an initial resource count of 3 (parameter 1) and a maximum resource count of 3 (parameter 2). If the semaphore will be used to synchronize threads in different processes, you should include a third parameter assigning the semaphore a name. An optional fourth parameter points to a SECURITY_ATTRIBUTES structure (default=NULL). Each thread that accesses a resource controlled by a semaphore can do so like this:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>g_semaphore.Lock ();
// Access the shared resource.
g_semaphore.Unlock ();
</pre></td>
		</tr>
	</table></p>

<p>As long as no more than three threads try to access the resource at the same time, <i>Lock</i> won't suspend the thread. But if the semaphore is locked by three threads and a fourth thread calls <i>Lock</i>, that thread will block until one of the other threads calls <i>Unlock</i>. (See Figure 17-6.) To limit the time that <i>Lock</i> will wait for the semaphore's resource count to become nonzero, you can pass a maximum wait time (in milliseconds, as always) to the <i>Lock</i> function.</p>

<p>
<A HREF="javascript:fullSize('F17mg06x.htm')"> <img src="Images/F17mg06.JPG" width=404 height=171 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 17-6.</b> <i>Using a semaphore to guard a shared resource.</i><!-- /CAPTION -->
</p>

<p><i>CSemaphore::Unlock</i> can be used to increment the resource count by more than 1 and also to find out what the resource count was before <i>Unlock</i> was called. For example, suppose the same thread calls <i>Lock</i> twice in succession to lay claim to two resources guarded by a semaphore. Rather than call <i>Unlock</i> twice, the thread can do its unlocking like this:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>LONG lPrevCount;
g_semaphore.Unlock (2, &amp;lPrevCount);
</pre></td>
		</tr>
	</table></p>

<p>There are no functions in either MFC or the API that return a semaphore's resource count other than <i>CSemaphore::Unlock</i> and its API equivalent, <i>::ReleaseSemaphore</i>.</p>

<p>A classic use for semaphores is to allow a group of <i>m</i> threads to share <i>n</i> resources, where <i>m</i> is greater than <i>n</i>. For example, suppose you launch 10 worker threads and charge each with the task of gathering data. Whenever a thread fills a buffer with data, it transmits the data through an open socket, clears the buffer, and starts gathering data again. Now suppose that only three sockets are available at any given time. If you guard the socket pool with a semaphore whose resource count is 3 and code each thread so that it locks the semaphore before claiming a socket, threads will consume no CPU time while they wait for a socket to come free.</p>

<A NAME="549"><h2>The <i>CSingleLock</i> and <i>CMultiLock</i> Classes</h2></A>
<p>MFC includes a pair of classes named <i>CSingleLock</i> and <i>CMultiLock</i> that have <i>Lock</i> and <i>Unlock</i> functions of their own. You can wrap a critical section, mutex, event, or semaphore in a <i>CSingleLock</i> object and use <i>CSingleLock::Lock</i> to apply a lock, as demonstrated here:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>CCriticalSection g_cs;
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
CSingleLock lock (&amp;g_cs); // Wrap it in a CSingleLock.
lock.Lock ();             // Lock the critical section.
</pre></td>
		</tr>
	</table></p>

<p>Is there any advantage to locking a critical section this way instead of calling the <i>CCriticalSection</i> object's <i>Lock</i> function directly? Sometimes, yes. Consider what happens if the following code throws an exception between the calls to <i>Lock</i> and <i>Unlock</i>:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>g_cs.Lock ();
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
g_cs.Unlock ();
</pre></td>
		</tr>
	</table></p>

<p>If an exception occurs, the critical section will remain locked forever because the call to <i>Unlock</i> will be bypassed. But look what happens if you architect your code this way:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>CSingleLock lock (&amp;g_cs);
lock.Lock ();
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
lock.Unlock ();
</pre></td>
		</tr>
	</table></p>

<p>The critical section won't be left permanently locked. Why? Because the <i>CSingleLock</i> object is created on the stack, its destructor is called if an exception is thrown. <i>CSingleLock</i>'s destructor calls <i>Unlock</i> on the contained synchronization object. In other words, <i>CSingleLock</i> is a handy tool for making sure that a locked synchronization object gets unlocked even in the face of inopportune exceptions.</p>

<p><i>CMultiLock</i> is an altogether different animal. By using a <i>CMultiLock</i>, a thread can block on up to 64 synchronization objects at once. And depending on how it calls <i>CMultiLock::Lock</i>, the thread can block until one of the synchronization objects comes free or until <i>all</i> of them come free. The following example demonstrates how a thread can block on two events and one mutex simultaneously. Be aware of the fact that events, mutexes, and semaphores can be wrapped in <I>CMultiLock</I> objects, but critical sections can't.</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>CMutex g_mutex;
CEvent g_event[2];
CSyncObject* g_pObjects[3] = { &amp;g_mutex, &amp;g_event[0], &amp;g_event[1] };
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
// Block until all three objects become signaled.
CMultiLock multiLock (g_pObjects, 3);
multiLock.Lock ();
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
// Block until one of the three objects becomes signaled.
CMultiLock multiLock (g_pObjects, 3);
multiLock.Lock (INFINITE, FALSE);
</pre></td>
		</tr>
	</table></p>

<p><i>CMultiLock::Lock</i> accepts three parameters, all of which are optional. The first specifies a time-out value (default=INFINITE). The second specifies whether the thread should be awakened when one of the synchronization objects becomes unlocked (FALSE) or when all of them come unlocked (TRUE, the default). The third is a <i>wakeup mask</i> that specifies other conditions that will wake up the thread&#8212;for example, WM_PAINT messages or mouse-button messages. The default wakeup mask value of 0 prevents the thread from being awakened for any reason other than that the synchronization object (or objects) came free or the time-out period expired.</p>

<p>If a thread comes unblocked after calling <i>CMultiLock::Lock</i> to block until just one synchronization object becomes signaled, it's very often the case that the thread will need to know which synchronization object became signaled. The answer can be ascertained from <i>Lock</i>'s return value:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>CMutex g_mutex;
CEvent g_event[2];
CSyncObject* g_pObjects[3] = { &amp;g_mutex, &amp;g_event[0], &amp;g_event[1] };
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
CMultiLock multiLock (g_pObjects, 3);
DWORD dwResult = multiLock.Lock (INFINITE, FALSE);
DWORD nIndex = dwResult _ WAIT_OBJECT_0;
if (nIndex == 0) {
    // The mutex became signaled.
}
else if (nIndex == 1) {
    // The first event became signaled.
}
else if (nIndex == 2) {
    // The second event became signaled.
}
</pre></td>
		</tr>
	</table></p>

<p>Be aware that if you pass <i>Lock</i> a time-out value other than INFINITE, you should compare the return value to WAIT_TIMEOUT before subtracting WAIT_OBJECT_0 in case <i>Lock</i> returned because the time-out period expired. Also, if <i>Lock</i> returns because an abandoned mutex became signaled, you must subtract WAIT_ABANDONED_0 from the return value instead of WAIT_OBJECT_0. For further details, consult the documentation for <i>CMultiLock::Lock</i>.</p>

<p>Here's one example of a situation in which <i>CMultiLock</i> can be useful. Suppose three separate threads&#8212;threads A, B, and C&#8212;are working together to prepare data in a buffer. Once the data is ready, thread D transmits the data through a socket 
or writes it to a file. However, thread D can't be called until threads A, B, and C have completed their work. The solution? Create separate event objects to represent threads A, B, and C, and let thread D use a <i>CMultiLock</i> object to block until all three events become signaled. As each thread completes its work, it sets the corresponding event object to the signaled state. Thread D therefore blocks until the last of the three threads signals that it's done.</p>

<A NAME="550"><H2>Writing Thread-Safe Classes</H2></A>

<p>MFC classes are thread-safe at the class level but not at the object level. Translated, this means that it's safe for two threads to access two separate instances of the same class but that problems could result if two threads are allowed to access the same instance at the same time. MFC's designers chose not to make it thread-safe at the object level for performance reasons. The simple act of locking an unlocked critical section can consume hundreds of clock cycles on a Pentium processor. If every access to an object of an MFC class locked a critical section, the performance of single-threaded applications would suffer needlessly.</p>

<p>To illustrate what it means for a class to be thread-safe, think about what might happen if two threads using the same <i>CString</i> object made no attempt to synchronize their actions. Let's say that thread A decides to set the string, whose name is <i>g_strFileName</i>, equal to the text string referenced by <i>pszFile</i>:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>g_strFileName = pszFile;
</pre></td>
		</tr>
	</table></p>

<p>At about the same time, thread B decides to display <i>g_strFileName</i> on the screen by passing it to <i>CDC::TextOut</i>:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>pDC-&gt;TextOut (x, y, g_strFileName);
</pre></td>
		</tr>
	</table></p>

<p>What gets displayed on the screen? The old value of <i>g_strFileName</i> or the new value? Maybe neither. Copying text to a <i>CString</i> object is a multistep operation that involves allocating buffer space to hold the text, performing a <i>memcpy</i> to copy the characters, setting the <i>CString</i> data member that stores the string length equal to the number of characters that were copied, adding a terminating 0 to the end, and so on. If thread B interrupts this process at the wrong moment, there's no telling what state the <i>CString</i> might be in when it's passed to <i>TextOut</i>. The output might be improperly truncated. Or <i>TextOut</i> might display garbage on the screen or cause an access violation.</p>

<p>One way to synchronize access to <i>g_strFileName</i> is to protect it with a critical section, as shown here:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>// Global data
CCriticalSection g_cs;
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
// Thread A
g_cs.Lock ();
g_strFileName = pszFile;
g_cs.Unlock ();
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
// Thread B
g_cs.Lock ();
pDC-&gt;TextOut (x, y, g_strFileName);
g_cs.Unlock ();
</pre></td>
		</tr>
	</table></p>

<p>An alternative approach is to derive a class from <i>CString</i> and make the derived class thread-safe by building in a critical section that's automatically locked anytime an access occurs. Then the object itself ensures that accesses are performed in a thread-safe way, and it's no longer incumbent upon the application that <i>uses</i> the object to synchronize the actions of its threads.</p>

<p>Deriving a class and making it thread-safe is basically a matter of overriding every member function that reads or writes an object's data and wrapping calls to member functions in the base class with calls to lock and unlock a synchronization object that's a member of the derived class. Ditto for thread-safe classes that aren't derived from other classes but are designed from the ground up: add a <i>CCriticalSection</i> or <i>CMutex</i> data member to the class, and lock and unlock the synchronization object before 
and after every access.</p>

<p>It's not always possible to make a class entirely thread-safe. If a thread uses <i>GetBuffer</i> or an LPCTSTR operator to get a pointer to the text of a <i>CString</i>, for example, the <i>CString</i> itself has no control over what the caller does with that pointer. In that case, it's still the responsibility of the thread that uses the <i>CString</i> object to coordinate its accesses with those of other threads.</p>

<p>The point to take home from all of this is that objects are not thread-safe by default. You can use synchronization objects to access other objects in a thread-safe way, and you can develop classes that are inherently thread-safe by controlling access to objects created from those classes. But allowing one thread to read data from an object while another thread modifies the object's data&#8212;or vice versa&#8212;is a recipe for disaster. To make matters worse, errors of this nature often show up randomly in testing. You might run the application 1,000 times and never experience the debilitating effects of an overlapping access. But as sure as the possibility exists, someone using your application will experience a dual access that occurs at the worst possible moment and brings the entire application (and possibly the operating system, too) crashing to the ground.</p>

<A NAME="551"><H2>The ImageEdit Application</H2></A>

<p>The ImageEdit application shown in Figure 17-7 is an enhanced version of <a href="ch15a.htm">Chapter 15</a>'s Vista application, one that uses a separate thread to perform a complex image processing task in the background. When you select Convert To Gray Scale from the Effects menu, ImageEdit scans the current bitmap pixel by pixel, converts each pixel to a shade of gray, and adjusts the color palette to display an accurate gray-scale rendition of the original color image. The conversion function is an ideal candidate for a worker thread because it can take anywhere from a few seconds to several minutes to run, depending on the size of the bitmap, the speed of the CPU, and other factors. The code that performs the conversion is far from optimal; in fact, its speed could be improved by a factor of 10 or more if it were rewritten to operate directly on the bitmap's bits rather than to call <i>CDC::GetPixel</i> and <i>CDC::SetPixel</i> on every pixel. But for demonstration purposes, it's fine. And using <i>CDC</i> pixel functions to get and set pixel colors allows us to do in about 20 lines of code what could easily require several hundred if we rewrote ImageEdit to process raw bitmap data.</p>

<p>
<A HREF="javascript:fullSize('F17mg07x.htm')"> <img src="Images/F17mg07.JPG" width=404 height=314 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 17-7.</b> <i>The ImageEdit window.</i><!-- /CAPTION -->
</p>


<p>The bulk of ImageEdit's source code is reproduced in Figure 17-8. I wanted to show a multithreaded document/view application in this chapter because there are certain issues unique to writing multithreaded document/view programs that don't come up in multithreaded SDK applications or in multithreaded MFC applications that don't use documents and views. For example, it's not unusual for a document object to launch a worker thread to process the document's data. But how can a background thread let the document object know that processing is complete? It can't post a message to the document because a document isn't a window. It's a bad idea for the document to block on an event waiting for the thread to complete its mission, because doing so would block the application's primary thread and effectively suspend the message loop. Yet the document usually needs to know when the thread is finished so that it can update its views. The question is, How?</p>

<p><b>Figure 17-8.</b> <i>The ImageEdit application.</I></P>
<p><table cellpadding="5" width="95%">
<tr><td>
<A NAME="552"><H3>MainFrm.h</H3></A>
<pre>// MainFrm.h : interface of the CMainFrame class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(
    AFX_MAINFRM_H__9D77AEE8_AA14_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_MAINFRM_H__9D77AEE8_AA14_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

class CMainFrame : public CFrameWnd
{
    
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:  // control bar embedded members
    CSpecialStatusBar m_wndStatusBar;

// Generated message map functions protected:
    int m_nPercentDone;
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg BOOL OnQueryNewPalette();
    afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
    //}}AFX_MSG
    afx_msg LRESULT OnUpdateImageStats (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnThreadUpdate (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnThreadFinished (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnThreadAborted (WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(AFX_MAINFRM_H__9D77AEE8_AA14_11D2_8E53_006008A82731__INCLUDED_)
</pre></td>
		</tr>
	</table></p>


<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<A NAME="553"><H3>MainFrm.cpp</H3></A>
<pre>// MainFrm.cpp : implementation of the CMainFrame class
//

#include &quot;stdafx.h&quot;
#include &quot;ImageEdit.h&quot;
#include &quot;ImageEditDoc.h&quot;
#include &quot;SpecialStatusBar.h&quot;
#include &quot;MainFrm.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)

    ON_WM_CREATE()
    ON_WM_QUERYNEWPALETTE()
    ON_WM_PALETTECHANGED()
    //}}AFX_MSG_MAP
    ON_MESSAGE (WM_USER_UPDATE_STATS, OnUpdateImageStats)
    ON_MESSAGE (WM_USER_THREAD_UPDATE, OnThreadUpdate)
    ON_MESSAGE (WM_USER_THREAD_FINISHED, OnThreadFinished)
    ON_MESSAGE (WM_USER_THREAD_ABORTED, OnThreadAborted)
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,
    ID_SEPARATOR,
    ID_SEPARATOR
};

///////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    m_nPercentDone = -1;
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    if (!m_wndStatusBar.Create(this))
    {
        TRACE0(&quot;Failed to create status bar\n&quot;);
        return -1;      // fail to create
    }
    return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext&amp; dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

BOOL CMainFrame::OnQueryNewPalette() 
{
    CDocument* pDoc = GetActiveDocument ();
    if (pDoc != NULL)
        GetActiveDocument ()-&gt;UpdateAllViews (NULL);
    return TRUE;
}

void CMainFrame::OnPaletteChanged(CWnd* pFocusWnd) 
{
    if (pFocusWnd != this) {
        CDocument* pDoc = GetActiveDocument ();
        if (pDoc != NULL)
            GetActiveDocument ()-&gt;UpdateAllViews (NULL);
    }
}

LRESULT CMainFrame::OnUpdateImageStats (WPARAM wParam, LPARAM lParam)
{
    m_wndStatusBar.SetImageStats ((LPCTSTR) lParam);
    return 0;
}

LRESULT CMainFrame::OnThreadUpdate (WPARAM wParam, LPARAM lParam)
{
    int nPercentDone = ((int) wParam * 100) / (int) lParam;
    if (nPercentDone != m_nPercentDone) {
        m_wndStatusBar.SetProgress (nPercentDone);
        m_nPercentDone = nPercentDone;
    }
    return 0;
}

LRESULT CMainFrame::OnThreadFinished (WPARAM wParam, LPARAM lParam)
{
    CImageEditDoc* pDoc = (CImageEditDoc*) GetActiveDocument ();
    if (pDoc != NULL) {
        pDoc-&gt;ThreadFinished ();
        m_wndStatusBar.SetProgress (0);
        m_nPercentDone = -1;
    }
    return 0;
}

LRESULT CMainFrame::OnThreadAborted (WPARAM wParam, LPARAM lParam)
{
    CImageEditDoc* pDoc = (CImageEditDoc*) GetActiveDocument ();
    if (pDoc != NULL) {
        pDoc-&gt;ThreadAborted ();
        m_wndStatusBar.SetProgress (0);
        m_nPercentDone = -1;
    }
    return 0;
}
</pre></td>
		</tr>
	</table></p>


<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<A NAME="554"><H3>ImageEditDoc.h</H3></A>
<pre>// ImageEditDoc.h : interface of the CImageEditDoc class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(
    AFX_IMAGEEDITDOC_H__9D77AEEA_AA14_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_IMAGEEDITDOC_H__9D77AEEA_AA14_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
UINT ThreadFunc (LPVOID pParam);
LOGPALETTE* CreateGrayScale ();

class CImageEditDoc : public CDocument
{
protected: // create from serialization only
    CImageEditDoc();
    DECLARE_DYNCREATE(CImageEditDoc)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CImageEditDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    virtual void DeleteContents();
    //}}AFX_VIRTUAL

// Implementation
public:
    void ThreadAborted();
    void ThreadFinished();
    CPalette* GetPalette();
    CBitmap* GetBitmap();
    virtual ~CImageEditDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:

// Generated message map functions
protected:
    CCriticalSection m_cs;
    CEvent m_event;
    HANDLE m_hThread;
    BOOL m_bWorking;
    CPalette m_palette;
    CBitmap m_bitmap;
    //{{AFX_MSG(CImageEditDoc)
    afx_msg void OnGrayScale();
    afx_msg void OnUpdateGrayScale(CCmdUI* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//     AFX_IMAGEEDITDOC_H__9D77AEEA_AA14_11D2_8E53_006008A82731__INCLUDED_)
</pre></td>
		</tr>
	</table></p>


<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<A NAME="555"><H3>ImageEditDoc.cpp</H3></A>
<pre>// ImageEditDoc.cpp : implementation of the CImageEditDoc class
//

#include &quot;stdafx.h&quot;
#include &quot;ImageEdit.h&quot;

#include &quot;ImageEditDoc.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CImageEditDoc

IMPLEMENT_DYNCREATE(CImageEditDoc, CDocument)

BEGIN_MESSAGE_MAP(CImageEditDoc, CDocument)
    //{{AFX_MSG_MAP(CImageEditDoc)
    ON_COMMAND(ID_EFFECTS_GRAY_SCALE, OnGrayScale)
    ON_UPDATE_COMMAND_UI(ID_EFFECTS_GRAY_SCALE, OnUpdateGrayScale)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()
///////////////////////////////////////////////////////////////////////////
// CImageEditDoc construction/destruction

CImageEditDoc::CImageEditDoc() :
    m_event (FALSE, TRUE) // Manual-reset event, initially unowned
{
    m_hThread = NULL;
    m_bWorking = FALSE;
}

CImageEditDoc::~CImageEditDoc()
{
}

BOOL CImageEditDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CImageEditDoc diagnostics

#ifdef _DEBUG
void CImageEditDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CImageEditDoc::Dump(CDumpContext&amp; dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CImageEditDoc commands

BOOL CImageEditDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
    //
    // Return now if an image is being processed.
    //

    if (m_bWorking) {
        AfxMessageBox (_T (&quot;You can't open an image while another is &quot; \
            &quot;being converted&quot;));
        return FALSE;
    }

    //
    // Let the base class do its thing.
    //
    if (!CDocument::OnOpenDocument (lpszPathName))
        return FALSE;

    //
    // Open the file and create a DIB section from its contents.
    //
    HBITMAP hBitmap = (HBITMAP) ::LoadImage (NULL, lpszPathName,
        IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE &#339; LR_CREATEDIBSECTION);

    if (hBitmap == NULL) {
        CString string;
        string.Format (_T (&quot;%s does not contain a DIB&quot;), lpszPathName);
        AfxMessageBox (string);
        return FALSE;
    }

    m_bitmap.Attach (hBitmap);

    //
    // Return now if this device doesn't support palettes.
    //
    CClientDC dc (NULL);
    if ((dc.GetDeviceCaps (RASTERCAPS) &amp; RC_PALETTE) == 0)
        return TRUE;

    //
    // Create a palette to go with the DIB section.
    //
    if ((HBITMAP) m_bitmap != NULL) {
        DIBSECTION ds;
        m_bitmap.GetObject (sizeof (DIBSECTION), &amp;ds);

        int nColors;
        if (ds.dsBmih.biClrUsed != 0)
            nColors = ds.dsBmih.biClrUsed;
        else
            nColors = 1 &lt;&lt; ds.dsBmih.biBitCount;

        //
        // Create a halftone palette if the DIB section contains more
        // than 256 colors.
        //
        if (nColors &gt; 256)
            m_palette.CreateHalftonePalette (&amp;dc);

        //
        // Create a custom palette from the DIB section's color table
        // if the number of colors is 256 or less.
        //
        else {
            RGBQUAD* pRGB = new RGBQUAD[nColors];

            CDC memDC;
            memDC.CreateCompatibleDC (&amp;dc);
            CBitmap* pOldBitmap = memDC.SelectObject (&amp;m_bitmap);
            ::GetDIBColorTable ((HDC) memDC, 0, nColors, pRGB);
            memDC.SelectObject (pOldBitmap);

            UINT nSize = sizeof (LOGPALETTE) +
                (sizeof (PALETTEENTRY) * (nColors - 1));
            LOGPALETTE* pLP = (LOGPALETTE*) new BYTE[nSize];

            pLP-&gt;palVersion = 0x300;
            pLP-&gt;palNumEntries = nColors;

            for (int i=0; i&lt;nColors; i++) {
                pLP-&gt;palPalEntry[i].peRed = pRGB[i].rgbRed;
                pLP-&gt;palPalEntry[i].peGreen = pRGB[i].rgbGreen;
                pLP-&gt;palPalEntry[i].peBlue = pRGB[i].rgbBlue;
                pLP-&gt;palPalEntry[i].peFlags = 0;
            }

            m_palette.CreatePalette (pLP);
            delete[] pLP;
            delete[] pRGB;
        }
    }
    return TRUE;
}

void CImageEditDoc::DeleteContents() 
{
    if ((HBITMAP) m_bitmap != NULL)
        m_bitmap.DeleteObject ();

    if ((HPALETTE) m_palette != NULL)
        m_palette.DeleteObject ();
    
    CDocument::DeleteContents();
}

CBitmap* CImageEditDoc::GetBitmap()
{
    return ((HBITMAP) m_bitmap == NULL) ? NULL : &amp;m_bitmap;
}

CPalette* CImageEditDoc::GetPalette()
{
    return ((HPALETTE) m_palette == NULL) ? NULL : &amp;m_palette;
}

void CImageEditDoc::ThreadFinished()
{
    ASSERT (m_hThread != NULL);
    ::WaitForSingleObject (m_hThread, INFINITE);
    ::CloseHandle (m_hThread);
    m_hThread = NULL;
    m_bWorking = FALSE;

    //
    // Replace the current palette with a gray scale palette.
    //
    if ((HPALETTE) m_palette != NULL) {
        m_palette.DeleteObject ();
        LOGPALETTE* pLP = CreateGrayScale ();
        m_palette.CreatePalette (pLP);
        delete[] pLP;
    }

    //
    // Tell the view to repaint.
    //
    UpdateAllViews (NULL);
}

void CImageEditDoc::ThreadAborted()
{
    ASSERT (m_hThread != NULL);
    ::WaitForSingleObject (m_hThread, INFINITE);
    ::CloseHandle (m_hThread);
    m_hThread = NULL;
    m_bWorking = FALSE;
}

void CImageEditDoc::OnGrayScale() 
{
    if (!m_bWorking) {
        m_bWorking = TRUE;
        m_event.ResetEvent ();

        //
        // Package data to pass to the image processing thread.
        //
        THREADPARMS* ptp = new THREADPARMS;
        ptp-&gt;pWnd = AfxGetMainWnd ();
        ptp-&gt;pBitmap = &amp;m_bitmap;
        ptp-&gt;pPalette = &amp;m_palette;
        ptp-&gt;pCriticalSection = &amp;m_cs;
        ptp-&gt;pEvent = &amp;m_event;

        //
        // Start the image processing thread and duplicate its handle.
        //
        CWinThread* pThread = AfxBeginThread (ThreadFunc, ptp,
            THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);

        ::DuplicateHandle (GetCurrentProcess (),
            pThread-&gt;m_hThread, GetCurrentProcess (), &amp;m_hThread,
            0, FALSE, DUPLICATE_SAME_ACCESS);

        pThread-&gt;ResumeThread ();
    }
    else
        //
        // Kill the image processing thread.
        //
        m_event.SetEvent ();
}

void CImageEditDoc::OnUpdateGrayScale(CCmdUI* pCmdUI) 
{
    if (m_bWorking) {
        pCmdUI-&gt;SetText (_T (&quot;Stop &amp;Gray Scale Conversion&quot;));
        pCmdUI-&gt;Enable ();
    }
    else {
        pCmdUI-&gt;SetText (_T (&quot;Convert to &amp;Gray Scale&quot;));
        pCmdUI-&gt;Enable ((HBITMAP) m_bitmap != NULL);
    }
}

/////////////////////////////////////////////////////////////////////////
// Thread function and other globals

UINT ThreadFunc (LPVOID pParam)
{
    THREADPARMS* ptp = (THREADPARMS*) pParam;
    CWnd* pWnd = ptp-&gt;pWnd;
    CBitmap* pBitmap = ptp-&gt;pBitmap;
    CPalette* pPalette = ptp-&gt;pPalette;
    CCriticalSection* pCriticalSection = ptp-&gt;pCriticalSection;
    CEvent* pKillEvent = ptp-&gt;pEvent;
    delete ptp;

    DIBSECTION ds;
    pBitmap-&gt;GetObject (sizeof (DIBSECTION), &amp;ds);
    int nWidth = ds.dsBm.bmWidth;
    int nHeight = ds.dsBm.bmHeight;

    //
    // Initialize one memory DC (memDC2) to hold a color copy of the
    // image and another memory DC (memDC1) to hold a gray scale copy.
    //
    CClientDC dc (pWnd);
    CBitmap bitmap1, bitmap2;
    bitmap1.CreateCompatibleBitmap (&amp;dc, nWidth, nHeight);
    bitmap2.CreateCompatibleBitmap (&amp;dc, nWidth, nHeight);

    CDC memDC1, memDC2;
    memDC1.CreateCompatibleDC (&amp;dc);
    memDC2.CreateCompatibleDC (&amp;dc);
    CBitmap* pOldBitmap1 = memDC1.SelectObject (&amp;bitmap1);
    CBitmap* pOldBitmap2 = memDC2.SelectObject (&amp;bitmap2);

    CPalette* pOldPalette1 = NULL;
    CPalette* pOldPalette2 = NULL;
    CPalette grayPalette;

    if (pPalette-&gt;m_hObject != NULL) {
        LOGPALETTE* pLP = CreateGrayScale ();
        grayPalette.CreatePalette (pLP);
        delete[] pLP;

        pOldPalette1 = memDC1.SelectPalette (&amp;grayPalette, FALSE);
        pOldPalette2 = memDC2.SelectPalette (pPalette, FALSE);
        memDC1.RealizePalette ();
        memDC2.RealizePalette ();
    }

    //
    // Copy the bitmap to memDC2.
    //
    CDC memDC3;
    memDC3.CreateCompatibleDC (&amp;dc);
    pCriticalSection-&gt;Lock ();
    CBitmap* pOldBitmap3 = memDC3.SelectObject (pBitmap);
    memDC2.BitBlt (0, 0, nWidth, nHeight, &amp;memDC3, 0, 0, SRCCOPY);
    memDC3.SelectObject (pOldBitmap3);
    pCriticalSection-&gt;Unlock ();

    //
    // Convert the colors in memDC2 to shades of gray in memDC1.
    //
    int x, y;
    COLORREF crColor;
    BYTE grayLevel;

    for (y=0; y&lt;nHeight; y++) {
        for (x=0; x&lt;nWidth; x++) {
            crColor = memDC2.GetPixel (x, y);
            grayLevel = (BYTE)
                (((((UINT) GetRValue (crColor)) * 30) +
                (((UINT) GetGValue (crColor)) * 59) +
                (((UINT) GetBValue (crColor)) * 11)) / 100);
            memDC1.SetPixel (x, y,
                PALETTERGB (grayLevel, grayLevel, grayLevel));
        }

        //
        // Kill the thread if the pKillEvent event is signaled.
        //
        if (::WaitForSingleObject (pKillEvent-&gt;m_hObject, 0) ==
            WAIT_OBJECT_0) {

            memDC1.SelectObject (pOldBitmap1);
            memDC2.SelectObject (pOldBitmap2);

            if (pPalette-&gt;m_hObject != NULL) {
                memDC1.SelectPalette (pOldPalette1, FALSE);
                memDC2.SelectPalette (pOldPalette2, FALSE);
            }
            pWnd-&gt;PostMessage (WM_USER_THREAD_ABORTED, y + 1, 0);
            return (UINT) -1;
        }
        pWnd-&gt;SendMessage (WM_USER_THREAD_UPDATE, y + 1, nHeight);
    }

    //
    // Copy the gray scale image over the original bitmap.
    //
    CPalette* pOldPalette3 = NULL;
    if (pPalette-&gt;m_hObject != NULL) {
        pOldPalette3 = memDC3.SelectPalette (&amp;grayPalette, FALSE);
        memDC3.RealizePalette ();
    }
    pCriticalSection-&gt;Lock ();
    pOldBitmap3 = memDC3.SelectObject (pBitmap);
    memDC3.BitBlt (0, 0, nWidth, nHeight, &amp;memDC1, 0, 0, SRCCOPY);
    memDC3.SelectObject (pOldBitmap3);
    pCriticalSection-&gt;Unlock ();

    //
    // Clean up the memory DCs.
    //
    memDC1.SelectObject (pOldBitmap1);
    memDC2.SelectObject (pOldBitmap2);

    if (pPalette-&gt;m_hObject != NULL) {
        memDC1.SelectPalette (pOldPalette1, FALSE);
        memDC2.SelectPalette (pOldPalette2, FALSE);
        memDC3.SelectPalette (pOldPalette3, FALSE);
    }

    //
    // Tell the frame window we're done.
    //
    pWnd-&gt;PostMessage (WM_USER_THREAD_FINISHED, 0, 0);
    return 0;
}

LOGPALETTE* CreateGrayScale ()
{
    UINT nSize = sizeof (LOGPALETTE) + (sizeof (PALETTEENTRY) * 63);
    LOGPALETTE* pLP = (LOGPALETTE*) new BYTE[nSize];

    pLP-&gt;palVersion = 0x300;
    pLP-&gt;palNumEntries = 64;

    for (int i=0; i&lt;64; i++) {
        pLP-&gt;palPalEntry[i].peRed = i * 4;
        pLP-&gt;palPalEntry[i].peGreen = i * 4;
        pLP-&gt;palPalEntry[i].peBlue = i * 4;
        pLP-&gt;palPalEntry[i].peFlags = 0;
    }
    return pLP;
}
</pre></td>
		</tr>
	</table></p>


<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<A NAME="556"><H3>ImageEditView.h</H3></A>
<pre>// ImageEditView.h : interface of the CImageEditView class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(
    AFX_IMAGEEDITVIEW_H__9D77AEEC_AA14_11D2_8E53_006008A82731__INCLUDED_)
#define 
    AFX_IMAGEEDITVIEW_H__9D77AEEC_AA14_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000


class CImageEditView : public CScrollView
{
protected: // create from serialization only
    CImageEditView();
    DECLARE_DYNCREATE(CImageEditView)

// Attributes
public:
    CImageEditDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CImageEditView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    protected:
    virtual void OnInitialUpdate(); // called first time after construct
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CImageEditView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CImageEditView)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in ImageEditView.cpp
inline CImageEditDoc* CImageEditView::GetDocument()
   { return (CImageEditDoc*)m_pDocument; }
#endif

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//    AFX_IMAGEEDITVIEW_H__9D77AEEC_AA14_11D2_8E53_006008A82731__INCLUDED_)
</pre></td>
		</tr>
	</table></p>


<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<A NAME="557"><H3>ImageEditView.cpp</H3></A>
<pre>// ImageEditView.cpp : implementation of the CImageEditView class
//

#include &quot;stdafx.h&quot;
#include &quot;ImageEdit.h&quot;

#include &quot;ImageEditDoc.h&quot;
#include &quot;ImageEditView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CImageEditView

IMPLEMENT_DYNCREATE(CImageEditView, CScrollView)

BEGIN_MESSAGE_MAP(CImageEditView, CScrollView)
    //{{AFX_MSG_MAP(CImageEditView)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CImageEditView construction/destruction

CImageEditView::CImageEditView()
{
}

CImageEditView::~CImageEditView()
{
}

BOOL CImageEditView::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    return CScrollView::PreCreateWindow(cs);
}

///////////////////////////////////////////////////////////////////////////
// CImageEditView drawing

void CImageEditView::OnDraw(CDC* pDC)
{
    CImageEditDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    CBitmap* pBitmap = pDoc-&gt;GetBitmap ();

    if (pBitmap != NULL) {
        CPalette* pOldPalette;
        CPalette* pPalette = pDoc-&gt;GetPalette ();

        if (pPalette != NULL) {
            pOldPalette = pDC-&gt;SelectPalette (pPalette, FALSE);
            pDC-&gt;RealizePalette ();
        }

        DIBSECTION ds;
        pBitmap-&gt;GetObject (sizeof (DIBSECTION), &amp;ds);

        CDC memDC;
        memDC.CreateCompatibleDC (pDC);
        CBitmap* pOldBitmap = memDC.SelectObject (pBitmap);

        pDC-&gt;BitBlt (0, 0, ds.dsBm.bmWidth, ds.dsBm.bmHeight, &amp;memDC,
            0, 0, SRCCOPY);

        memDC.SelectObject (pOldBitmap);

        if (pPalette != NULL)
            pDC-&gt;SelectPalette (pOldPalette, FALSE);
    }
}

void CImageEditView::OnInitialUpdate()
{
    CScrollView::OnInitialUpdate ();

    CString string;
    CSize sizeTotal;
    CBitmap* pBitmap = GetDocument ()-&gt;GetBitmap ();


    //
    // If a bitmap is loaded, set the view size equal to the bitmap size.
    // Otherwise, set the view's width and height to 0.
    //
    if (pBitmap != NULL) {
        DIBSECTION ds;
        pBitmap-&gt;GetObject (sizeof (DIBSECTION), &amp;ds);
        sizeTotal.cx = ds.dsBm.bmWidth;
        sizeTotal.cy = ds.dsBm.bmHeight;
        string.Format (_T (&quot;\t%d x %d, %d bpp&quot;), ds.dsBm.bmWidth,
            ds.dsBm.bmHeight, ds.dsBmih.biBitCount);
    }
    else {
        sizeTotal.cx = sizeTotal.cy = 0;
        string.Empty ();
    }

    AfxGetMainWnd ()-&gt;SendMessage (WM_USER_UPDATE_STATS, 0,
        (LPARAM) (LPCTSTR) string);
    SetScrollSizes (MM_TEXT, sizeTotal);
}

///////////////////////////////////////////////////////////////////////////
// CImageEditView diagnostics

#ifdef _DEBUG
void CImageEditView::AssertValid() const
{
    CScrollView::AssertValid();
}

void CImageEditView::Dump(CDumpContext&amp; dc) const
{
    CScrollView::Dump(dc);
}

CImageEditDoc* CImageEditView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CImageEditDoc)));
    return (CImageEditDoc*)m_pDocument;
}
#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CImageEditView message handlers
</pre></td>
		</tr>
	</table></p>


<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<A NAME="558"><H3>SpecialStatusBar.h</H3></A>
<pre>// SpecialStatusBar.h: interface for the CSpecialStatusBar class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(
   AFX_SPECIALSTATUSBAR_H__4BA7D301_AA24_11D2_8E53_006008A82731__INCLUDED_)
#define 
   AFX_SPECIALSTATUSBAR_H__4BA7D301_AA24_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

class CSpecialStatusBar : public CStatusBar  
{
public:
    void SetProgress (int nPercent);
    void SetImageStats(LPCTSTR pszStats);
    CSpecialStatusBar();
    virtual ~CSpecialStatusBar();

protected:
    CProgressCtrl m_wndProgress;
    afx_msg int OnCreate (LPCREATESTRUCT lpcs);
    afx_msg void OnSize (UINT nType, int cx, int cy);
    DECLARE_MESSAGE_MAP ()
};

#endif 
// !defined(
// AFX_SPECIALSTATUSBAR_H__4BA7D301_AA24_11D2_8E53_006008A82731__INCLUDED_)
</pre></td>
		</tr>
	</table></p>


<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<A NAME="559"><H3>SpecialStatusBar.cpp</H3></A>
<pre>// SpecialStatusBar.cpp: implementation of the CSpecialStatusBar class.
//
//////////////////////////////////////////////////////////////////////

#include &quot;stdafx.h&quot;
#include &quot;ImageEdit.h&quot;
#include &quot;SpecialStatusBar.h&quot;
#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CSpecialStatusBar, CStatusBar)
    ON_WM_CREATE ()
    ON_WM_SIZE ()
END_MESSAGE_MAP()

CSpecialStatusBar::CSpecialStatusBar()
{
}

CSpecialStatusBar::~CSpecialStatusBar()
{
}

int CSpecialStatusBar::OnCreate (LPCREATESTRUCT lpcs)
{
    static UINT nIndicators[] =
    {
        ID_SEPARATOR,
        ID_SEPARATOR,
        ID_SEPARATOR
    };

    if (CStatusBar::OnCreate (lpcs) == -1)
        return -1;

    //
    // Add panes to the status bar.
    //
    SetIndicators (nIndicators, sizeof (nIndicators) / sizeof (UINT));

    //
    // Size the status bar panes.
    //
    TEXTMETRIC tm;
    CClientDC dc (this);
    CFont* pFont = GetFont ();

    CFont* pOldFont = dc.SelectObject (pFont);
    dc.GetTextMetrics (&amp;tm);
    dc.SelectObject (pOldFont);

    int cxWidth;
    UINT nID, nStyle;
    GetPaneInfo (1, nID, nStyle, cxWidth);
    SetPaneInfo (1, nID, nStyle, tm.tmAveCharWidth * 24);
    GetPaneInfo (2, nID, nStyle, cxWidth);
    SetPaneInfo (2, nID, SBPS_NOBORDERS, tm.tmAveCharWidth * 24);

    //
    // Place a progress control in the rightmost pane.
    //
    CRect rect;
    GetItemRect (2, &amp;rect);
    m_wndProgress.Create (WS_CHILD &#339; WS_VISIBLE &#339; PBS_SMOOTH, 
        rect, this, -1);
    m_wndProgress.SetRange (0, 100);
    m_wndProgress.SetPos (0);
    return 0;
}

void CSpecialStatusBar::OnSize (UINT nType, int cx, int cy)
{
    CStatusBar::OnSize (nType, cx, cy);

    //
    // Resize the rightmost pane to fit the resized status bar.
    //
    CRect rect;
    GetItemRect (2, &amp;rect);
    m_wndProgress.SetWindowPos (NULL, rect.left, rect.top,
        rect.Width (), rect.Height (), SWP_NOZORDER);
}

void CSpecialStatusBar::SetImageStats(LPCTSTR pszStats)
{
    SetPaneText (1, pszStats, TRUE);
}

void CSpecialStatusBar::SetProgress(int nPercent)
{
    ASSERT (nPercent &gt;= 0 &amp;&amp; nPercent &lt;= 100);
    m_wndProgress.SetPos (nPercent);
}
</pre></td>
		</tr>
	</table></p>

<p>ImageEdit demonstrates a practical solution to the problem of how a worker thread can let a document object know when it's finished. When Convert To Gray Scale is selected from the Effects menu, the document's <i>OnGrayScale</i> function launches a background thread that executes the <i>ThreadFunc</i> function. <i>ThreadFunc</i> processes the bitmap and posts a WM_USER_THREAD_FINISHED message to the application's frame window just before it terminates. The frame window, in turn, calls the document's <i>ThreadFinished</i> function to notify the document that the image has been converted, and <i>ThreadFinished</i> calls <i>UpdateAllViews</i>.</p>

<p>Posting a message to the frame window and having it call down to the document object is <i>not</i> the same as having the thread function call a function in the document object directly because the <i>PostMessage</i> call performs a virtual transfer of control to the primary thread. If <i>ThreadFunc</i> called the document object itself, <i>UpdateAllViews</i> would be called in the context of the background thread and would fail.</p>

<p>For good measure, <i>ThreadFunc</i> sends a WM_USER_THREAD_UPDATE message to the main window each time it finishes converting another line in the bitmap. The frame window responds by updating a progress control embedded in the status bar, so the user is never left wondering when the gray-scale image will appear. WM_USER_THREAD_UPDATE messages are sent rather than posted to make sure that the progress control is updated in real time. If WM_USER_THREAD_UPDATE messages were posted rather than sent, the background thread might post messages faster than the main window could process them on fast CPUs.</p>

<p>ImageEdit uses two thread synchronization objects: a <i>CEvent</i> object named <i>m_event</i> and a <i>CCriticalSection</i> object named <i>m_cs</i>. Both are members of the document class, and both are passed by address to the thread function in a THREADPARMS structure. The event object is used to terminate the worker thread if the user stops a gray-scale conversion midstream by selecting the Stop Gray Scale Conversion command from the Effects menu. To kill the thread, the primary thread sets the event to the signaled state:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>m_event.SetEvent ();
</pre></td>
		</tr>
	</table></p>

<p>Upon completion of each scan line, the conversion routine inside <i>ThreadFunc</i> checks the event object and terminates the thread if the event is signaled:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>if (::WaitForSingleObject (pKillEvent-&gt;m_hObject, 0) ==
    WAIT_OBJECT_0) {
    
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    
    pWnd-&gt;PostMessage (WM_USER_THREAD_ABORTED, y + 1, 0);
    return (UINT) -1;
}
</pre></td>
		</tr>
	</table></p>

<p>The WM_USER_THREAD_ABORTED message alerts the frame window that the thread has been aborted. The frame window notifies the document by calling <i>CImageEditDoc::ThreadAborted</i>, and <i>ThreadAborted</i> blocks on the thread handle just in case the thread hasn't quite terminated. Then it resets an internal flag indicating that the thread is no longer running.</p>

<p>The critical section prevents the application's two threads from trying to select the bitmap into a device context at the same time. The primary thread selects the bitmap into a device context when the view needs updating; the background thread selects the bitmap into a memory device context once when a gray-scale conversion begins and again when it ends. A bitmap can be selected into only one device context at a time, so if either thread tries to select the bitmap into a device context while the other has it selected into a device context, one of the threads will fail. (Palettes, on the other hand, can be selected into several device contexts concurrently, and <i>ThreadFunc</i> takes advantage of that fact when it performs a gray-scale conversion on a palettized device.) The odds that the two threads will try to select the bitmap at the same time are small, but the use of a critical section ensures that the code executed between calls to <i>SelectObject</i> won't be interrupted by a call to <i>SelectObject</i> from another thread. The bitmap doesn't stay selected into a device context for any appreciable length of time, so neither thread should have to wait long if the critical section is locked.</p>

<p>ImageEdit also demonstrates how to place a progress control in a status bar. ImageEdit's status bar is an instance of <i>CSpecialStatusBar</i>, which I derived from <i>CStatusBar</i>. <i>CSpecialStatusBar::OnCreate</i> adds three panes to the status bar. Then it creates a progress control and positions the control to exactly fit the rightmost pane. Because the sizes and positions of a status bar's panes can change when the status bar is resized, <i>CSpecialStatusBar</i> also includes an <i>OnSize</i> handler that adjusts the progress control to the rightmost pane. The result is a progress control that looks like an ordinary status bar pane until you begin stepping it with <i>CProgressCtrl::SetPos</i>.</p>

</BODY>
</HTML>




