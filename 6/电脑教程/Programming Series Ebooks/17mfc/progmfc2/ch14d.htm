<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Idle Processing</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch14c.htm", "ch15a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="444"><H1>Idle Processing</H1></A>

<P>Because MFC's application class, <I>CWinApp</I>, provides the message loop that 
retrieves and dispatches messages, it's a simple matter for <I>CWinApp</I> to call a function in your application when no messages are waiting to be processed. If you look at the 
source code for the <I>CWinThread::Run</I> function that gets called by 
<I>WinMain</I> to start the message loop, you'll see something that looks like this:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
BOOL bIdle = TRUE;
LONG lIdleCount = 0;

for (;;)
{
     while (bIdle &amp;&amp;
         !::PeekMessage(&amp;m_msgCur, NULL, NULL, NULL, PM_NOREMOVE))
    {
         if (!OnIdle(lIdleCount++))
            bIdle = FALSE;
    }

    do
    {
        if (!PumpMessage())
            return ExitInstance();

        if (IsIdleMessage(&amp;m_msgCur))
        {
            bIdle = TRUE;
            lIdleCount = 0;
        }

    } while (::PeekMessage(&amp;m_msgCur, NULL, NULL, NULL, PM_NOREMOVE));
}
</PRE>
</td></tr></table></p>

<P>Before it calls <I>PumpMessage</I> to retrieve and dispatch a message, 
<I>Run</I> calls <I>::PeekMessage</I> with a PM_NOREMOVE flag to check the message queue. If a 
message is waiting, <I>::PeekMessage</I> copies it to an MSG structure and returns a nonzero value 
but doesn't remove the message from the queue. If no messages are waiting, 
<I>::PeekMessage</I> returns 0. Unlike 
<I>::GetMessage</I>, <I>::PeekMessage</I> doesn't wait for a message to appear 
in the message queue before returning; it returns immediately. If 
<I>::PeekMessage</I> returns nonzero, indicating that messages are waiting to be processed, 
<I>CWinThread::Run</I> enters a <I>do-while</I> loop that calls 
<I>CWinThread::PumpMessage</I> repeatedly to retrieve and dispatch the messages. But if 
<I>::PeekMessage</I> returns 0 and the <I>bIdle</I> flag is set, <I>CWinThread::Run</I> calls a member function named 
<I>OnIdle</I> to give the application an opportunity to perform idle processing. Because 
<I>OnIdle</I> is a virtual function and because <I>CWinApp</I> is derived from <I>CWinThread</I>, a derived application class can 
hook into the idle loop by replacing <I>CWinApp::OnIdle</I> with an <I>OnIdle</I> function of its own.</p>

<P>Back in the days of Windows 3.<I>x,</I> when applications were inherently 
single-threaded, <I>OnIdle</I> was the perfect place to perform background processing tasks 
such as print spooling and garbage collecting. In 32-bit Windows, 
<I>CWinApp::OnIdle</I>'s usefulness is greatly diminished because low-priority tasks can be performed more 
efficiently in background threads of execution. <I>OnIdle</I> still has legitimate uses, however. MFC uses it to update toolbar buttons and other always-visible user interface 
objects by calling update handlers registered in the message map. It also takes advantage 
of times when the application isn't busy processing messages by deleting 
temporary objects created by functions such as 
<I>CWnd::FromHandle</I> and <I>CWnd::GetMenu</I>.</P>

<P>When you call <I>FromHandle</I> to convert a window handle into a 
<I>CWnd</I> pointer, MFC consults an internal table called a 
<I>handle map</I> that correlates <I>CWnd</I> objects 
and window handles. If it finds the handle it's looking for, MFC returns a pointer to 
the corresponding <I>CWnd</I> object. If the window handle doesn't appear in the handle 
map because a corresponding <I>CWnd</I> doesn't exist, however, 
<I>FromHandle</I> creates a temporary <I>CWnd</I> object and returns its address to the caller. The next time 
<I>OnIdle</I> is called (which doesn't occur until after the message handler that called 
<I>FromHandle</I> returns), MFC cleans up by deleting the temporary 
<I>CWnd</I> object. That's why the documentation for some MFC functions warns that returned pointers might be temporary 
and &quot;should not be stored for later use.&quot; What that really means is that an object 
referenced by one of these temporary pointers isn't guaranteed to exist outside the 
scope of the current message handler because, once that handler returns, 
<I>OnIdle</I> is liable to be called&#8212;and the object deleted&#8212;at any moment.</P>

<A NAME="445"><H2>Using <I>OnIdle</I></H2></A>
<P>An MFC application can enact its own idle-processing regimen by overriding the 
virtual <I>OnIdle</I> function that it inherits from 
<I>CWinApp</I>. <I>OnIdle</I> is prototyped as follows:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
virtual BOOL OnIdle (LONG lCount)
</PRE>
</td></tr></table></p>

<P><I>lCount</I> is a 32-bit value that specifies the number of times 
<I>OnIdle</I> has been called since the last message was processed. The count continually increases until the 
message loop in <I>CWinThread::Run</I> calls <I>PumpMessage</I> to retrieve and dispatch 
another message. The count is then reset to 0 and starts again. WM_PAINT 
messages, WM_SYSTIMER messages, and certain mouse messages don't cause 
<I>lCount</I> to be reset. (WM_SYSTIMER is an undocumented message Windows uses internally.) 
<I>lCount</I> can be used as a rough measure of the time elapsed since the last message or of 
the length of time the application has been idle. If you have two background tasks 
you'd like to perform during idle time, one that's high priority and another that's low, 
you can use <I>lCount</I> to determine when to execute each task. For example, you 
might perform the high-priority task each time <I>lCount</I> reaches 10 and the low-priority task when 
<I>lCount</I> hits 100 or even 1,000.</P>

<P>If you could log the calls to an application's <I>OnIdle</I> function without slowing it down, you'd find that 1,000 is not all that high a number. Typically, 
<I>OnIdle</I> is called 100 or more times per second when the message queue is empty, so a 
low-priority background task that kicks off when <I>lCount</I> reaches 1,000 is typically executed 
when the mouse and keyboard are idle for a few seconds. A high-priority task that 
begins when <I>lCount</I> reaches 10 is executed much more often because the count 
frequently reaches or exceeds 10, even when the message loop is relatively busy. Idle 
processing should be carried out as quickly as possible because message traffic is 
blocked until <I>OnIdle</I> returns.</P>

<p>The value that <I>OnIdle</I> returns determines whether <I>OnIdle</I> will be called again. If 
<I>OnIdle</I> returns a nonzero value, it's called again if the message queue is still 
empty. If <I>OnIdle</I> returns 0, however, further calls are suspended until another message 
finds its way into the message queue and the idle state is reentered after the message 
is dispatched. The mechanism that makes this work is the 
<I>bIdle</I> flag in <I>CWinThread::Run</I>, which is initially set to TRUE but is set to FALSE if 
<I>OnIdle</I> returns FALSE. The <I>while</I> loop that calls 
<I>OnIdle</I> tests the value of <I>bIdle</I> at the beginning of each iteration 
and falls through if <I>bIdle</I> is FALSE. <I>bIdle</I> is set to TRUE again when a message shows 
up in the message queue and <I>PumpMessage</I> is called. As a practical matter, you can 
save a few CPU cycles by returning FALSE from <I>OnIdle</I> if your background processing is complete for the moment and you don't want 
<I>OnIdle</I> to be called again until the flow of messages resumes. Be careful, however, not to return FALSE before the 
framework has finished its most recent spate of idle-processing chores and thus deprive it of 
the idle time it needs.</P>

<P>The cardinal rule to follow when using <I>OnIdle</I> is to call the base class version of 
<I>OnIdle</I> from the overridden version. The following <I>OnIdle</I> override demonstrates the proper technique. The base class's 
<I>OnIdle</I> function is called first, and after the call returns, the application performs its own idle processing:</P>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
BOOL CMyApp::OnIdle (LONG lCount)
{
    CWinApp::OnIdle (lCount);
    DoIdleWork (); // Do custom idle processing.
    return TRUE;
}
</PRE>
</td></tr></table></p>

<P>It turns out that the framework does its processing when 
<I>lCount</I> is 0 and 1. Therefore, an even better approach is to accord higher priority to the framework's 
<I>OnIdle</I> handler by delaying the start of your own idle processing until 
<I>lCount</I> reaches a value of 2 or higher:</P>


<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
BOOL CMyApp::OnIdle (LONG lCount)
{
    CWinApp::OnIdle (lCount);
    if (lCount == 2)
        DoIdleWork (); // Do custom idle processing.
    return TRUE;
}
</PRE>
</td></tr></table></p>

<P>You can see for yourself what MFC does during idle time by examining the 
source code for <I>CWinThread::OnIdle</I> in Thrdcore.cpp and 
<I>CWinApp::OnIdle</I> in Appcore.cpp.</P>

<P>Because the <I>OnIdle</I> implementations in the previous paragraph always 
returns TRUE, calls to <I>OnIdle</I> will continue unabated even if both you and the 
framework are finished with <I>OnIdle</I> for the time being. The following 
<I>OnIdle</I> override reduces overhead by returning FALSE when both MFC's idle processing and the 
application's idle processing are complete:</P>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
BOOL CMyApp::OnIdle (LONG lCount)
{
    BOOL bContinue = CWinApp::OnIdle (lCount);
    if (lCount == 2)
        DoIdleWork (); // Do custom idle processing.
    return (bContinue &#339;&#339; lCount &lt; 2);
}
</PRE>
</td></tr></table></p>

<P>The fact that application-specific idle processing isn't started until 
<I>lCount</I> equals 2 means that the framework won't be deprived of the idle time it needs if the 
application's <I>OnIdle</I> function returns FALSE.</P>

<P>It's important to perform idle processing as quickly as possible to avoid 
adversely impacting the application's responsiveness. If necessary, break up large 
<I>OnIdle</I> tasks into smaller, more manageable pieces and process one piece at a time in 
successive calls to <I>OnIdle</I>. The following <I>OnIdle</I> function begins its work when 
<I>lCount</I> reaches 2 and continues responding to <I>OnIdle</I> calls until <I>DoIdleWork</I> returns 0:</P>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
BOOL CMyApp::OnIdle (LONG lCount)
{
    BOOL bMFCContinue = CWinApp::OnIdle (lCount);
    BOOL bAppContinue = TRUE;
    if (lCount &gt;= 2)
        bAppContinue = DoIdleWork (); // Do custom idle processing.
    return (bMFCContinue &#339;&#339; bAppContinue);
}
</PRE>
</td></tr></table></p>

<P>Because <I>DoIdleWork</I>'s return value is also used as 
<I>OnIdle</I>'s return value, <I>OnIdle</I> will cease to be called once 
<I>DoIdleWork</I> has completed its appointed task.</P>

<A NAME="446"><H2>Idle Processing vs. Multithreading</H2></A>

<P>In <a href="ch17a.htm">Chapter 17</a>, you'll learn about another way to perform background tasks that 
involves multiple threads of execution. Multithreading is a powerful programming 
paradigm that's ideal for performing two or more tasks in parallel. It's also scalable: on 
a multiprocessor system containing <I>n</I> CPUs, Windows NT and Windows 2000 will 
execute up to <I>n</I> threads concurrently by scheduling each to run on a different 
processor. (Windows 95 and Windows 98, by contrast, force all threads to share a 
single CPU, even on multiprocessor systems.)</P>

<P>Given the robust multithreading support in 32-bit Windows, it's reasonable 
to ask when, if at all, you should use idle processing in lieu of multithreading. Here 
are two answers:</P>

<UL>
<P><LI>When you have background tasks to perform that must execute in the application's primary thread. User interface_related tasks tend to be very thread-sensitive. That's one reason why MFC performs user interface updates in the primary thread.</li></p>
<P><LI>When you have background tasks to perform and the application that you're writing must work in 16-bit Windows as well as in 32-bit Windows. Multithreading is not supported in 16-bit Windows.</li></p>
</UL>

<p>In these situations, performing background tasks in <I>OnIdle</I> makes a lot of sense. Under any other circumstances, multithreading is in all likelihood the proper solution.</P>

</BODY>
</HTML>




