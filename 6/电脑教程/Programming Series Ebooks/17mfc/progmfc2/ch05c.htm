<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Lists</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch05b.htm", "ch05d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="153"><H1>Lists</H1></A>

<P>The <I>InsertAt</I> and <I>RemoveAt</I> functions make it easy to add items to an array and 
to take them away. But the ease with which items are inserted and removed comes at 
a cost: when items are inserted or removed in the middle of an array, items higher 
in the array must be shifted upward or downward in memory. The performance 
penalty incurred when manipulating large arrays in this manner can be quite expensive.</P>

<P>A classic solution to the problem of maintaining ordered lists that support 
fast item insertion and removal is the linked list. A 
<I>linked list</I> is a collection of items that contain pointers to other items. In a singly linked list, each item contains a pointer 
to the next item in the list. Moving forward through a singly linked list is fast 
because moving to the next item is a simple matter of extracting that item's address from 
the current item. To support fast forward and backward traversal, many lists are 
doubly linked&#8212;that is, each item contains a pointer to the previous item in the list as well 
as to the next item. Given the address of the first item in the list (the 
<I>head</I>), it's a simple matter to enumerate the items in the list using code like this:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
item* pItem = GetHead ();
while (pItem != NULL)
    pItem = pItem-&gt;pNextItem;
</pre>
</TD></TR></TABLE>
</P>
	
<P>Conversely, given the address of the final item in the list (the 
<I>tail</I>), a doubly linked list can be traversed in reverse order, like this:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
item* pItem = GetTail ();
while (pItem != NULL)
    pItem = pItem-&gt;pPrevItem;
</pre>
</TD></TR></TABLE>
</P>
	
<P>These examples assume that the list doesn't wrap around on itself&#8212;that is, that 
the <I>pNextItem</I> pointer in the final item and the 
<I>pPrevItem</I> pointer in the first item are 
equal to NULL. Some linked lists form a circular chain of items by connecting the first 
and last items.</P>

<P>How do linked lists solve the problem of fast item insertion and removal? 
Inserting an item midway through the list doesn't require any items to be shifted upward 
in memory; it simply requires that the pointers stored in the items before and after 
the insertion point be adjusted to reference the new item. Removing an item is 
equally efficient, requiring nothing more than the adjustment of two pointers. Compare 
this to inserting an item into the middle of an array, which could require a 
<I>memcpy</I> involving tens, hundreds, or perhaps thousands of items to make room for one 
new item, and the benefits should be obvious.</P>
<P>Nearly every programmer has, at some point in his or her career, 
implemented a linked list. Everyone should do it once, but no one should have to do it more 
than once. Fortunately, many class libraries, including MFC, provide canned 
implementations of linked lists. As an MFC programmer, you can sleep well tonight knowing 
that you'll probably never have to write a linked list from scratch again.</P>

<A NAME="154"><H2>The MFC List Classes</H2></A>

<P>The MFC template class <I>CList</I> implements a generic linked list that can be 
customized to work with any data type. MFC also provides the following 
nontemplatized list classes to deal with specific data types. These classes are provided primarily 
for compatibility with older versions of MFC and aren't used very often in modern 
MFC applications.</P>

<P><b>Type-Specific MFC List Classes</b></P>

<P>
<table valign="top" cellpadding=5 width="95%">
<tr><th valign="top"><I>Class Name</I></th>
<th valign="top"><I>Data Type</I></th>
</tr>
<tr>
<td valign="top"><I>CObList</I></td>
<td valign="top"><I>CObject</I> pointers</td>
</tr>
<tr>
<td valign="top"><I>CPtrList</I></td>
<td valign="top">void pointers</td>
</tr>
<tr>
<td valign="top"><I>CStringList</I></td>
<td valign="top"><I>CStrings</I></td>
</tr>
</table>
</P>

<P>MFC lists are doubly linked for fast forward and backward traversal. 
Positions in the list are identified by abstract values called POSITIONs. For a list, a 
POSITION is actually a pointer to a <I>CNode</I> data structure representing one item in the list. 
<I>CNode</I> contains three fields: a pointer to the next 
<I>CNode</I> structure in the list, a pointer to 
the previous <I>CNode</I> structure, and a pointer to the item data. Insertions at the head 
of the list, the tail, or at a specified POSITION are fast and efficient. Lists can also 
be searched, but because searches are performed by traversing the list sequentially 
and examining its items one by one, they can be time-consuming if the list is long.</P>

<P>I'll use <I>CStringList</I> to demonstrate how the list classes are used, but keep in 
mind that the principles demonstrated here apply to the other list classes as well. 
The following example creates a <I>CStringList</I> object and adds 10 strings to it:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
// Schools of the Southeastern Conference
const TCHAR szSchools[][20] = {
    _T (&quot;Alabama&quot;),
    _T (&quot;Arkansas&quot;),
    _T (&quot;Florida&quot;),
    _T (&quot;Georgia&quot;),
    _T (&quot;Kentucky&quot;),
    _T (&quot;Mississippi&quot;),
    _T (&quot;Mississippi State&quot;),
    _T (&quot;South Carolina&quot;),
    _T (&quot;Tennessee&quot;),
    _T (&quot;Vanderbilt&quot;),
};

CStringList list;
for (int i=0; i&lt;10; i++)
    list.AddTail (szSchools[i]);
</pre>
</TD></TR></TABLE>
</P>
	
	
<P>The <I>AddTail</I> function adds an item (or all the items in another linked list) to the 
end of the list. To add items to the head of the list, use the 
<I>AddHead</I> function instead. Removing an item from the head or tail is as simple as calling 
<I>RemoveHead</I> or <I>RemoveTail</I>. The 
<I>RemoveAll</I> function removes all the items in one fell swoop.</P>

<P>Each time a string is added to a 
<I>CStringList</I>, MFC copies the string to a 
<I>CString</I> and stores it in the corresponding 
<I>CNode</I> structure. Therefore, it's perfectly 
acceptable to allow the strings that you initialize a list with to go out of scope once the 
list is built.</P>

<P>Once a list is created, you can iterate through it forward and backward 
using the <I>GetNext</I> and <I>GetPrev</I> functions. Both accept a POSITION value identifying 
the current position in the list and return the item at that position. Each also updates 
the POSITION value to reference the next or previous item. You can retrieve the 
POSITION of the first or last item in the list with 
<I>GetHeadPosition</I> or <I>GetTailPosition</I>. 
The following statements enumerate the items in the list from first to last, writing 
each string retrieved from the list to the debug output window using MFC's TRACE macro:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
POSITION pos = list.GetHeadPosition ();
while (pos != NULL) {
    CString string = list.GetNext (pos);
    TRACE (_T (&quot;%s\n&quot;), string);
}
</pre>
</TD></TR></TABLE>
</P>

<P>Walking the list backward is equally simple:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
POSITION pos = list.GetTailPosition ();
while (pos != NULL) {
    CString string = list.GetPrev (pos);
    TRACE (_T (&quot;%s\n&quot;), string);
}
</pre>
</TD></TR></TABLE>
</P>

<P>If you simply want to retrieve the first or last item in the list, you can use the 
list's <I>GetHead</I> or <I>GetTail</I> function. Neither requires a POSITION value as input 
because the position is implied in the call.</P>

<P>Given a POSITION value <I>pos</I> identifying a particular item, you can use the 
list's <I>At</I> functions to retrieve, modify, or delete the item:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CString string = list.GetAt (pos);       // Retrieve the item.
list.SetAt (pos, _T (&quot;Florida State&quot;));  // Change it.
list.RemoveAt (pos);                     // Delete it.
</pre>
</TD></TR></TABLE>
</P>

<P>You can also use <I>InsertBefore</I> or 
<I>InsertAfter</I> to insert items into the list:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
list.InsertBefore (pos, _T (&quot;Florida State&quot;));  // Insert at pos.
list.InsertAfter (pos, _T (&quot;Florida State&quot;));   // Insert after pos.
</pre>
</TD></TR></TABLE>
</P>

<P>Because of the nature of linked lists, insertions and removals performed this 
way are fast.</P>


<P>MFC's list classes include two member functions that you can use to 
perform searches. <I>FindIndex</I> accepts a 0-based index and returns the POSITION of the 
item at the corresponding location in the list. 
<I>Find</I> searches the list for an item matching an input you specify and returns its POSITION. For string lists, 
<I>Find</I> compares strings. For pointer lists, it compares pointers; it does 
<I>not</I> dereference the pointers and compare the items that they point to. Searching a string list for &quot;Tennessee&quot; requires 
just one function call:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
POSITION pos = list.Find (_T (&quot;Tennessee&quot;));
</pre>
</TD></TR></TABLE>
</P>

<P>By default, <I>Find</I> searches the list from beginning to end. If you'd like, you can 
specify an alternate starting point in the function's second parameter. But be aware that 
if the item you're looking for occurs before the starting POSITION, 
<I>Find</I> won't find it because searches don't wrap around to the beginning of the list.</P>

<P>You can find out how many elements a list contains with the 
<I>GetCount</I> function. If <I>GetCount</I> returns 0, the list is empty. A quick way to test for an empty list is 
to call <I>IsEmpty</I>.</P>

<A NAME="155"><H2>Creating Type-Safe List Classes with <I>CList</I></H2></A>
<P>You can create type-safe list classes for the data types of your choice from MFC's 
<I>CList</I> class. Here's an example involving a linked list of 
<I>CPoint</I> objects:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CList&lt;CPoint, CPoint&amp;&gt; list;

// Populate the list.
for (int i=0; i&lt;10; i++)
    list.AddTail (CPoint (i*10, 0));

// Enumerate the items in the list.
POSITION pos = list.GetHeadPosition ();
while (pos != NULL) {
    CPoint point = list.GetNext (pos);
    TRACE (_T (&quot;x=%d, y=%d\n&quot;), point.x, point.y);
}
</pre>
</TD></TR></TABLE>
</P>

<P>As with <I>CArray</I>, the first template parameter specifies the data type 
(<I>CPoint</I> objects) and the second specifies how items are passed in parameter lists (by reference).</P>

<P>If you use classes rather than primitive data types in a 
<I>CList</I> and you call the list's <I>Find</I> function, your code won't compile unless one of the following 
conditions is true:</P>

<UL>
<P><LI>     The class has an overloaded == operator that performs a comparison to 
a like object.</LI></P> 

<P><LI>     You override the template function 
<I>CompareElements</I> with a type-specific version that compares two instances of the class.</LI></P> 
</UL>

 <P>The first method&#8212;overloading the == operator&#8212;is the more common of 
the two and has already been done for you in MFC classes such as 
<I>CPoint</I> and <I>CString</I>. If you write a class yourself, you must do the operator overloading. Here's a 
modified version of <I>CPoint3D</I> that overloads the comparison operator for 
compatibility with <I>CList::Find</I>:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
class CPoint3D
{
public:
    CPoint3D ()
    {
        x = y = z = 0;
    }
    CPoint3D (int xPos, int yPos, int zPos)
    {
        x = xPos;
        y = yPos;
        z = zPos;
    }
    operator== (CPoint3D point) const
    {
        return (x == point.x &amp;&amp; y == point.y &amp;&amp; z == point.z);
    }
    int x, y, z;
};
</pre>
</TD></TR></TABLE>
</P>

<P>The alternative to overloading the comparison operator is to override the 
global <I>CompareElements</I> function, as demonstrated here:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
class CPoint3D
{
public:
    CPoint3D ()
    {
        x = y = z = 0;
    }
    CPoint3D (int xPos, int yPos, int zPos)
    {
        x = xPos;
        y = yPos;
        z = zPos;
    }
    // Note: No operator==
    int x, y, z;
};

BOOL AFXAPI CompareElements (const CPoint3D* p1, const CPoint3D* p2)
{
    return (p1-&gt;x == p2-&gt;x &amp;&amp; p1-&gt;y == p2-&gt;y &amp;&amp; p1-&gt;z == p2-&gt;z);
}
</pre>
</TD></TR></TABLE>
</P>

<P>Overriding <I>CompareElements</I> eliminates the need for operator overloading 
because the default implementation of 
<I>CompareElements</I>, which is called by 
<I>CList::Find</I>, compares items using the comparison operator. If you override 
<I>CompareElements</I> and don't use == in the override, you don't need to overload the 
== operator either.</P>

</BODY>
</HTML>




