<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Printing Tips and Tricks</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch13d.htm", "ch14a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="419"><H1>Printing Tips and Tricks</H1></A>

<P>Here are a few tips, tricks, and answers to frequently asked questions to help you write better printing code and resolve problems that aren't addressed in this chapter's sample programs.</P>

<A NAME="420"><H2>Using the Print Dialog's Selection Button</H2></A>

<P>The Print dialog that MFC displays before printing begins includes a Selection radio button that the user can click to print the current selection rather than the entire document or a range of pages. By default, the button is disabled. You can enable it by adding the following statement to <I>OnPreparePrinting</I> just before the call to <I>DoPreparePrinting</I>:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<PRE>
pInfo-&gt;m_pPD-&gt;m_pd.Flags &amp;= ~PD_NOSELECTION;
</PRE>
</TD></TR></TABLE>
</P>

<P>To select the radio button after it's enabled, add this statement as well:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<PRE>
pInfo-&gt;m_pPD-&gt;m_pd.Flags &#166;= PD_SELECTION;
</PRE>
</TD></TR></TABLE>
</P>

<P>The <I>m_pPD</I> data member of the <I>CPrintInfo</I> structure passed to <I>OnPreparePrinting</I> points to the <I>CPrintDialog</I> object that <I>DoPreparePrinting</I> uses to display the Print dialog box. <I>CPrintDialog::m_pd</I> holds a reference to the PRINTDLG structure the dialog is based on, and PRINTDLG's <I>Flags</I> field holds bit flags that define the dialog box's properties. Removing the PD_NOSELECTION flag added by <I>CPrintInfo</I>'s constructor enables the Selection button, and adding a PD_SELECTION flag selects the button. If <I>DoPreparePrinting</I> returns a nonzero value, indicating that the dialog was dismissed with the OK button, you can find out whether the Selection button was selected by calling <I>CPrintDialog::PrintSelection</I>. A nonzero return value means the button was selected; 0 means it wasn't:</P>


<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<PRE>
if (pInfo-&gt;m_pPD-&gt;PrintSelection ()) {
    // Print the current selection.
}
</PRE>
</TD></TR></TABLE>
</P>

<P>You can call<I> PrintSelection</I> and other <I>CPrintDialog</I> functions that return information about settings entered in a Print or Print Setup dialog through the <I>pInfo</I> parameter passed to <I>OnPreparePrinting</I> after <I>DoPreparePrinting</I> returns. You can also call them through the <I>pInfo</I> parameter passed to <I>OnBeginPrinting</I> and other <I>CView</I> print overridables.</P>

<P>You can use <I>CPrintInfo::m_pPD</I> in other ways to modify the appearance and behavior of the Print dialog that <I>DoPreparePrinting</I> displays. Refer to the documentation that accompanies Visual C++ for more information about PRINTDLG and its data members.</P>

<A NAME="421"><H2>Assume Nothing&#8212;And Test Thoroughly!</H2></A>

<P>When you send output to the printed page, it's generally a mistake to assume anything about the printable area of the pages you'll be printing. Even if you know you're printing to, say, an 8&#189;-by-11-inch page, the printable page area will differ for different printers. The printable page area can even differ for the same printer and the same paper size depending on which printer driver is being used, and the horizontal and vertical dimensions of the printable page area will be switched if the user opts to print in landscape rather than portrait mode. Rather than assume you have a given amount of space to work with, do as HexDump does and call <I>GetDeviceCaps</I> through the <I>CDC</I> pointer provided to <I>CView</I> print functions to determine the printable page area each time you print, or use <I>CPrintInfo</I>::<I>m_rectDraw</I> in your <I>OnPrint</I> function. This simple precaution will enable your printing code to work with any printer Windows can throw at it and will greatly reduce the number of problem reports you receive from users.</P>

<P>As you've already learned, calling <I>GetDeviceCaps</I> with HORZRES and VERTRES parameters returns the horizontal and vertical dimensions of the printable page area. You can pass the following values to <I>GetDeviceCaps</I> to get more information about a printer or other hardcopy device:</P>

<P>
<table valign="top" cellpadding=5 width="95%">
<tr><th valign="top"><I>Value</I></th>
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top">HORZRES</td>
<td valign="top">Returns the width of the printable page area in pixels.</td>
</tr>
<tr>
<td valign="top">VERTRES</td>
<td valign="top">Returns the height of the printable page area in pixels.</td>
</tr>
<tr>
<td valign="top">HORSIZE</td>
<td valign="top">Returns the width of the printable page area 
in millimeters.</td>
</tr>
<tr>
<td valign="top">VERTSIZE</td>
<td valign="top">Returns the height of the printable page area 
in millimeters.</td>
</tr>
<tr>
<td valign="top">LOGPIXELSX</td>
<td valign="top">Returns the number of pixels per inch in the 
horizontal direction (300 for a 300-dpi printer).</td>
</tr>
<tr>
<td valign="top">LOGPIXELSY</td>
<td valign="top">Returns the number of pixels per inch in the 
vertical direction (300 for a 300-dpi printer).</td>
</tr>
<tr>
<td valign="top">PHYSICALWIDTH</td>
<td valign="top">Returns the page width in pixels (2,550 for an 
8&#189;-by-11-inch page on a 300-dpi printer).</td>
</tr>
<tr>
<td valign="top">PHYSICALHEIGHT</td>
<td valign="top">Returns the page height in pixels (3,300 for an 
8&#189;-by-11-inch page on a 300-dpi printer).</td>
</tr>
<tr>
<td valign="top">PHYSICALOFFSETX</td>
<td valign="top">Returns the distance in pixels from the left side 
of the page to the beginning of the page's 
printable area.</td>
</tr>
<tr>
<td valign="top">PHYSICALOFFSETY</td>
<td valign="top">Returns the distance in pixels from the top of 
the page to the beginning of the page's printable area.</td>
</tr>
<tr>
<td valign="top">TECHNOLOGY</td>
<td valign="top">Returns a value that identifies the type of 
output device the DC pertains to. The most common
return values are DT_RASDISPLAY for screens, DT_RASPRINTER for printers, and DT_PLOTTER
for plotters.</td>
</tr>
<tr>
<td valign="top">RASTERCAPS</td>
<td valign="top">Returns a series of bit flags identifying the level 
of GDI support provided by the printer driver. For 
example, an RC_BITBLT flag indicates that the 
printer supports <I>BitBlt</I>s, and RC_STRETCHBLT indicates 
that the printer supports <I>StretchBlt</I>s.</td>
</tr>
<tr>
<td valign="top">NUMCOLORS</td>
<td valign="top">Returns the number of colors the printer 
supports. The return value is 2 for black-and-white printers.</td>
</tr>
</table>
</P>
     
<P>You've already seen one use for the <I>GetDeviceCaps</I> NUMCOLORS parameter: to detect when a black-and-white printer is being used so that you draw print previews in shades of gray. The PHYSICALOFFSETX and PHYSICALOFFSETY parameters are useful for setting margin widths based on information the user enters in a Page Setup dialog. (MFC's <I>CWinApp::OnFilePrintSetup</I> function displays a Print Setup dialog instead of a Page Setup dialog, but you can display a Page Setup dialog yourself using MFC's <I>CPageSetupDialog</I> class.) If the user wants 1-inch margins on the left side of the page, for example, you can subtract the PHYSICALOFFSETX value returned by <I>GetDeviceCaps</I> from the number of pixels printed per inch (LOGPIXELSX) to compute the <I>x</I> offset from the left of the printable page area where printing should begin. If the printer driver returns accurate information, the resulting margin will fall within a few pixels of being exactly 1 inch. You can use the HORZRES, VERTRES, LOGPIXELSX, LOGPIXELSY, PHYSICALWIDTH, PHYSICALHEIGHT, PHYSICALOFFSETX, and PHYSICALOFFSETY values to characterize the printable area of a page and pinpoint exactly where on the page the printable area lies.</P>

<P>If you're concerned about the occasional hardcopy device that won't draw bitmaps, you can find out whether <I>CDC::BitBlt</I> and <I>CDC::StretchBlt</I> are supported by calling <I>GetDeviceCaps</I> with a RASTERCAPS parameter and checking the return flags. For the most part, only vector devices such as plotters don't support the GDI's <I>Blt</I> functions. If the driver for a raster device doesn't support blitting directly, the GDI will compensate by doing the blitting itself. You can determine outright whether printed output is destined for a plotter by calling <I>GetDeviceCaps</I> with a TECHNOLOGY parameter and checking to see if the return value equals DT_PLOTTER.</P>

<P>When you use a number of different printers to test an application that prints, you'll find that printer drivers are maddeningly inconsistent in the information they report and the output they produce. For example, some printer drivers return the same values for PHYSICALWIDTH and PHYSICALHEIGHT as they return for HORZRES and VERTRES. And sometimes an ordinary GDI function such as <I>CDC::TextOut</I> will work fine on hundreds of printers but will fail on one particular model because of a driver bug. Other times, a GDI function won't fail outright but will behave differently on different printers. I once ran across a printer driver that defaulted to the TRANSPARENT background mode even though other drivers for the same family of printers correctly set the device context's default background mode to OPAQUE. Printer drivers are notoriously flaky, so you need to anticipate problems and test as thoroughly as you can on as many printers as possible. The more ambitious your program's printing needs, the more likely that driver quirks will require you to write workarounds for problems that crop up only on certain printers.</P>

<A NAME="422"><H2>Adding Default Pagination Support</H2></A>

<P>HexDump calls <I>CPrintInfo::SetMaxPage</I> from <I>OnBeginPrinting</I> rather than from <I>OnPreparePrinting</I> because the pagination process relies on the printable page area and <I>OnBeginPrinting</I> is the first virtual <I>CView</I> function that's called with a pointer to a printer DC. Because the maximum page number isn't set until after <I>OnPreparePrinting</I> returns, the From box in the Print dialog is filled in (with a 1) but the To box isn't. Some users might think it incongruous that an application can correctly paginate a document for print preview but can't fill in the maximum page number in a dialog box. In addition to displaying the maximum page number correctly, many commercial applications display page breaks outside print preview and &quot;Page <I>mm</I> of <I>nn</I>&quot; strings in status bars. How do these applications know how the document will be paginated when they don't know what printer the document will be printed on or what the page orientation will be?</P>

<P>The answer is that they don't know for sure, so they make their best guess based on the properties of the default printer. The following code snippet initializes a <I>CSize</I> object with the pixel dimensions of the printable page area on the default printer or the last printer that the user selected in Print Setup. You can call it from <I>OnPreparePrinting</I> or elsewhere to compute a page count or to get the information you need to provide other forms of default pagination support:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<PRE>
CSize size;
CPrintInfo pi;
if (AfxGetApp ()-&gt;GetPrinterDeviceDefaults (&amp;pi.m_pPD-&gt;m_pd)) {
    HDC hDC = pi.m_pPD-&gt;m_pd.hDC;
    if (hDC == NULL)
        hDC = pi.m_pPD-&gt;CreatePrinterDC ();
    if (hDC != NULL) {
        CDC dc;
        dc.Attach (hDC);
        size.cx = dc.GetDeviceCaps (VERTRES);
        size.cy = dc.GetDeviceCaps (HORZRES);
        ::DeleteDC (dc.Detach ());
    }
}
</PRE>
</TD></TR></TABLE>
</P>

<P><I>CWinApp::GetPrinterDeviceDefaults</I> initializes a PRINTDLG structure with values describing the default printing configuration. A 0 return means that the function failed, which usually indicates that no printers are installed or that a default printer hasn't been designated. <I>CPrintInfo::CreatePrinterDC</I> creates a device context handle from the information in the PRINTDLG structure encapsulated in a <I>CPrintInfo</I> object. With the device context in hand, it's a simple matter to wrap it in a <I>CDC</I> object and use <I>CDC::GetDeviceCaps</I> to measure the printable page area.</P>

<A NAME="423"><H2>Enumerating Printers</H2></A>

<P>Sometimes it's useful to be able to build a list of all the printers available so that the user can select a printer outside a Print or Print Setup dialog box. The following routine uses the Win32 <I>::EnumPrinters</I> function to enumerate the printers currently installed and adds an entry for each to the combo box pointed to by <I>pComboBox</I>.</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<PRE>
#include &lt;winspool.h&gt;
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
DWORD dwSize, dwPrinters;
::EnumPrinters (PRINTER_ENUM_LOCAL, NULL, 5,
    NULL, 0, &amp;dwSize, &amp;dwPrinters); 

BYTE* pBuffer = new BYTE[dwSize];

::EnumPrinters (PRINTER_ENUM_LOCAL, NULL, 5,
    pBuffer, dwSize, &amp;dwSize, &amp;dwPrinters); 

if (dwPrinters != 0) {
    PRINTER_INFO_5* pPrnInfo = (PRINTER_INFO_5*) pBuffer;
    for (UINT i=0; i&lt;dwPrinters; i++) {
        pComboBox-&gt;AddString (pPrnInfo-&gt;pPrinterName);
        pPrnInfo++;
    }
}

delete[] pBuffer;
</PRE>
</TD></TR></TABLE>
</P>

<P>The first call to <I>::EnumPrinters</I> retrieves the amount of buffer space needed to hold an array of PRINTER_INFO_5 structures describing individual printers. The second call to <I>::EnumPrinters</I> initializes the buffer pointed to by <I>pBuffer</I> with an array of PRINTER_INFO_5 structures. On return, <I>dwPrinters</I> holds a count of the printers enumerated (which equals the count of PRINTER_INFO_5 structures copied to the buffer), and each structure's <I>pPrinterName</I> field holds a pointer to a zero-delimited string containing the device name of the associated printer. Enumerating printers with PRINTER_INFO_5 structures is fast because no remote calls are required; all information needed to fill the buffer is obtained from the registry. For fast printer enumerations in Windows NT or Windows 2000, use PRINTER_INFO_4 structures instead.</P>

<P>If a printer is selected from the combo box and you want to create a device context for it, you can pass the device name copied from the PRINTER_INFO_5 structure to <I>CDC::CreateDC</I> as follows:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<PRE>
CString strPrinterName;
int nIndex = pComboBox-&gt;GetCurSel ();
pComboBox-&gt;GetLBText (nIndex, strPrinterName);

CDC dc;
dc.CreateDC (NULL, strPrinterName, NULL, NULL);
</PRE>
</TD></TR></TABLE>
</P>

<P>You can use the resulting <I>CDC</I> object just like the <I>CDC</I> objects whose addresses are passed to <I>OnBeginPrinting</I> and other <I>CView</I> print functions.</P>

</BODY>
</HTML>




