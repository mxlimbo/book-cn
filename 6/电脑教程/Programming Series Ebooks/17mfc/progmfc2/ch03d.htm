<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>The VisualKB Application</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch03c.htm", "ch04a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="96"><H1>The VisualKB Application</H1></A>

<P>Let's put together everything we've learned in this chapter by developing a 
sample application that accepts text input from the keyboard, displays the text in a 
window, and lets the user perform simple text-editing functions that include moving the 
caret with the arrow keys and the mouse. For educational purposes, let's add a 
scrolling display of the keyboard messages that the program receives and the 
parameters bundled with those messages, similar to the KEYLOOK program featured in 
Charles Petzold's <I>Programming Windows</I>. In addition to providing a hands-on lesson in 
mouse and keyboard handling, the program, which I've called VisualKB, demonstrates 
some techniques for handling proportionally spaced text. VisualKB also provides a 
handy tool for examining the stream of messages coming from the keyboard and 
experimenting to see what messages result from specific keystrokes and key combinations.</P>

<P>Figure 3-7 shows how VisualKB looks right after it's started and the letters 
&quot;MFC&quot; are typed. The typed characters appear in the text-entry rectangle (the &quot;text box&quot;) 
at the top of the window, and keyboard messages are displayed in the rectangle 
below (the &quot;message list&quot;). The first and final messages were generated when the Shift 
key was pressed and released. In between, you see the WM_KEYDOWN, WM_CHAR, 
and WM_KEYUP messages generated by the M, F, and C keystrokes. To the right of 
each message name, VisualKB displays the message parameters. &quot;Char&quot; is the virtual 
key code or character code passed to the message handler in 
<I>nChar</I>. &quot;Rep&quot; is the repeat count in 
<I>nRepCnt</I>. &quot;Scan&quot; is the OEM scan code stored in bits 0 through 7 of the 
<I>nFlags</I> parameter, and &quot;Ext,&quot; &quot;Con,&quot; &quot;Prv,&quot; and &quot;Tran&quot; represent the extended key flag, 
context code, previous key state, and transition state values. VisualKB also 
displays WM_SYSKEYDOWN, WM_SYSCHAR, and WM_SYSKEYUP messages, which you 
can verify by pressing an Alt key combination such as Alt-S.</P>

<P>
<A HREF="javascript:fullSize('F03mg07x.htm')"> <img src="images/F03mg07.JPG" width=404 height=287 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 3-7.</B> <I>The VisualKB window after the letters MFC are typed.</I><!-- /CAPTION -->
</p>

<P>Take a moment to play with VisualKB and see what happens when you 
press various keys and combinations of keys. In addition to typing in text, you can use 
the following editing keys:</P>

<UL>
<P><LI>
The left and right arrow keys move the caret one character to the left 
and right. Home and End move the caret to the beginning and end of the 
line. The caret can also be moved with mouse clicks.
</LI></P>

<P><LI>
The Backspace key deletes the character to the left of the caret and 
moves the caret one position to the left.
</LI></P>

<P><LI>
The Esc and Enter keys clear the text and reset the caret to the 
beginning of the line.
</LI></P>
</UL>

<P>Typed characters are entered in overstrike mode, so if the caret isn't at the 
end of the line, the next character you type will replace the character to the right. If 
you type beyond the end of the line (about one character position to the left of the 
far right end of the text box), the text is automatically cleared. I resisted the urge to 
add features such as horizontal scrolling and insert mode to keep the program from 
becoming unnecessarily complicated. Besides, in the real world you can avoid writing a lot 
of the code for a program like this one by using an edit control, which provides 
similar text-entry capabilities and includes support for cutting and pasting, scrolling, and 
much more. Unless you're writing the world's next great word processor, an edit 
control probably has everything you need. Still, it's useful to see how text entry is done 
the hard way, not only because it's instructive but also because you'll get a feel for 
what's happening inside Windows when you start using edit controls.</P>

<P>There is much to be learned from VisualKB's source code, which is 
reproduced in Figure 3-8. The following sections point out a few of the highlights.</P>

<p><B>Figure 3-8.</B> <I>The VisualKB application.</I></p>

<table cellpadding=5 width="95%"><tr><td>
<A NAME="97"><H3>VisualKB.h</H3></A>
<pre>
#define MAX_STRINGS 12

class CMyApp : public CWinApp
{
public:
    virtual BOOL InitInstance ();
};

class CMainWindow : public CWnd
{
protected:
    int m_cxChar;                // Average character width
    int m_cyChar;                // Character height
    int m_cyLine;                // Vertical line spacing in message box
    int m_nTextPos;              // Index of current character in text box
    int m_nTabStops[7];          // Tab stop locations for tabbed output
    int m_nTextLimit;            // Maximum width of text in text box
    int m_nMsgPos;               // Current position in m_strMessages array
    
    HCURSOR m_hCursorArrow;      // Handle of arrow cursor
    HCURSOR m_hCursorIBeam;      // Handle of I-beam cursor

    CPoint m_ptTextOrigin;       // Origin for drawing input text
    CPoint m_ptHeaderOrigin;     // Origin for drawing header text
    CPoint m_ptUpperMsgOrigin;   // Origin of first line in message box
    CPoint m_ptLowerMsgOrigin;   // Origin of last line in message box
    CPoint m_ptCaretPos;         // Current caret position

    CRect m_rcTextBox;           // Coordinates of text box
    CRect m_rcTextBoxBorder;     // Coordinates of text box border
    CRect m_rcMsgBoxBorder;      // Coordinates of message box border
    CRect m_rcScroll;            // Coordinates of scroll rectangle

    CString m_strInputText;                // Input text
    CString m_strMessages[MAX_STRINGS];    // Array of message strings

public:
    CMainWindow ();

protected:
    int GetNearestPos (CPoint point);
    void PositionCaret (CDC* pDC = NULL);
    void DrawInputText (CDC* pDC);
    void ShowMessage (LPCTSTR pszMessage, UINT nChar, UINT nRepCnt,
        UINT nFlags);
    void DrawMessageHeader (CDC* pDC);
    void DrawMessages (CDC* pDC);

protected:
    virtual void PostNcDestroy ();

    afx_msg int OnCreate (LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnPaint ();
    afx_msg void OnSetFocus (CWnd* pWnd);
    afx_msg void OnKillFocus (CWnd* pWnd);
    afx_msg BOOL OnSetCursor (CWnd* pWnd, UINT nHitTest, UINT message);
    afx_msg void OnLButtonDown (UINT nFlags, CPoint point);
    afx_msg void OnKeyDown (UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnKeyUp (UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysKeyDown (UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysKeyUp (UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnChar (UINT nChar, UINT nRepCnt, UINT nFlags);
    afx_msg void OnSysChar (UINT nChar, UINT nRepCnt, UINT nFlags);

    DECLARE_MESSAGE_MAP ()
};
</pre>
</td></tr></table>

<p>&nbsp;</p>

<table cellpadding=5 width="95%"><tr><td>
<H3>VisualKB.cpp</H3>
<pre>
#include &lt;afxwin.h&gt;
#include &quot;VisualKB.h&quot;

CMyApp myApp;

/////////////////////////////////////////////////////////////////////////
// CMyApp member functions

BOOL CMyApp::InitInstance ()
{
    m_pMainWnd = new CMainWindow;
    m_pMainWnd-&gt;ShowWindow (m_nCmdShow);
    m_pMainWnd-&gt;UpdateWindow ();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////
// CMainWindow message map and member functions

BEGIN_MESSAGE_MAP (CMainWindow, CWnd)
    ON_WM_CREATE ()
    ON_WM_PAINT ()
    ON_WM_SETFOCUS ()
    ON_WM_KILLFOCUS ()
    ON_WM_SETCURSOR ()
    ON_WM_LBUTTONDOWN ()
    ON_WM_KEYDOWN ()
    ON_WM_KEYUP ()
    ON_WM_SYSKEYDOWN ()
    ON_WM_SYSKEYUP ()
    ON_WM_CHAR ()
    ON_WM_SYSCHAR ()
END_MESSAGE_MAP ()

CMainWindow::CMainWindow ()
{
    m_nTextPos = 0;
    m_nMsgPos = 0;

    //
    // Load the arrow cursor and the I-beam cursor and save their handles.
    //
    m_hCursorArrow = AfxGetApp ()-&gt;LoadStandardCursor (IDC_ARROW);
    m_hCursorIBeam = AfxGetApp ()-&gt;LoadStandardCursor (IDC_IBEAM);

    //
    // Register a WNDCLASS.
    //
    CString strWndClass = AfxRegisterWndClass (
        0,
        NULL,
        (HBRUSH) (COLOR_3DFACE + 1),
        AfxGetApp ()-&gt;LoadStandardIcon (IDI_WINLOGO)
    );

    //
    // Create a window.
    //
    CreateEx (0, strWndClass, _T (&quot;Visual Keyboard&quot;),
        WS_OVERLAPPED | WS_SYSMENU | WS_CAPTION | WS_MINIMIZEBOX,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL);
}

int CMainWindow::OnCreate (LPCREATESTRUCT lpCreateStruct)
{
    if (CWnd::OnCreate (lpCreateStruct) == -1)
        return -1;
    
    //
    // Initialize member variables whose values are dependent upon screen
    // metrics.
    //
    CClientDC dc (this);

    TEXTMETRIC tm;
    dc.GetTextMetrics (&amp;tm);
    m_cxChar = tm.tmAveCharWidth;
    m_cyChar = tm.tmHeight;
    m_cyLine = tm.tmHeight + tm.tmExternalLeading;

    m_rcTextBoxBorder.SetRect (16, 16, (m_cxChar * 64) + 16,
        ((m_cyChar * 3) / 2) + 16);

    m_rcTextBox = m_rcTextBoxBorder;
    m_rcTextBox.InflateRect (-2, -2);
    
    m_rcMsgBoxBorder.SetRect (16, (m_cyChar * 4) + 16,
        (m_cxChar * 64) + 16, (m_cyLine * MAX_STRINGS) +
        (m_cyChar * 6) + 16);

    m_rcScroll.SetRect (m_cxChar + 16, (m_cyChar * 6) + 16,
        (m_cxChar * 63) + 16, (m_cyLine * MAX_STRINGS) +
        (m_cyChar * 5) + 16);

    m_ptTextOrigin.x = m_cxChar + 16;
    m_ptTextOrigin.y = (m_cyChar / 4) + 16;
    m_ptCaretPos = m_ptTextOrigin;
    m_nTextLimit = (m_cxChar * 63) + 16;

    m_ptHeaderOrigin.x = m_cxChar + 16;
    m_ptHeaderOrigin.y = (m_cyChar * 3) + 16;

    m_ptUpperMsgOrigin.x = m_cxChar + 16;
    m_ptUpperMsgOrigin.y = (m_cyChar * 5) + 16;

    m_ptLowerMsgOrigin.x = m_cxChar + 16;
    m_ptLowerMsgOrigin.y = (m_cyChar * 5) +
        (m_cyLine * (MAX_STRINGS - 1)) + 16;

    m_nTabStops[0] = (m_cxChar * 24) + 16;
    m_nTabStops[1] = (m_cxChar * 30) + 16;
    m_nTabStops[2] = (m_cxChar * 36) + 16;
    m_nTabStops[3] = (m_cxChar * 42) + 16;
    m_nTabStops[4] = (m_cxChar * 46) + 16;
    m_nTabStops[5] = (m_cxChar * 50) + 16;
    m_nTabStops[6] = (m_cxChar * 54) + 16;

    //
    // Size the window.
    //
	
    CRect rect (0, 0, m_rcMsgBoxBorder.right + 16,
        m_rcMsgBoxBorder.bottom + 16);
    CalcWindowRect (&amp;rect);

    SetWindowPos (NULL, 0, 0, rect.Width (), rect.Height (),
        SWP_NOZORDER | SWP_NOMOVE | SWP_NOREDRAW);
    return 0;
}

void CMainWindow::PostNcDestroy ()
{
    delete this;
}

void CMainWindow::OnPaint ()
{
    CPaintDC dc (this);

    //
    // Draw the rectangles surrounding the text box and the message list.
    //
    dc.DrawEdge (m_rcTextBoxBorder, EDGE_SUNKEN, BF_RECT);
    dc.DrawEdge (m_rcMsgBoxBorder, EDGE_SUNKEN, BF_RECT);

    //
    // Draw all the text that appears in the window.
    //
    DrawInputText (&amp;dc);
    DrawMessageHeader (&amp;dc);
    DrawMessages (&amp;dc);
}

void CMainWindow::OnSetFocus (CWnd* pWnd)
{
    //
    // Show the caret when the VisualKB window receives the input focus.
    //
    CreateSolidCaret (max (2, ::GetSystemMetrics (SM_CXBORDER)),
        m_cyChar);
    SetCaretPos (m_ptCaretPos);
    ShowCaret ();
}

void CMainWindow::OnKillFocus (CWnd* pWnd)
{
    //
    // Hide the caret when the VisualKB window loses the input focus.
    //
    HideCaret ();
    m_ptCaretPos = GetCaretPos ();
    ::DestroyCaret ();
}

BOOL CMainWindow::OnSetCursor (CWnd* pWnd, UINT nHitTest, UINT message)
{
    //
    // Change the cursor to an I-beam if it's currently over the text box,
    // or to an arrow if it's positioned anywhere else.
    //
    if (nHitTest == HTCLIENT) {
        DWORD dwPos = ::GetMessagePos ();
        CPoint point (LOWORD (dwPos), HIWORD (dwPos));
        ScreenToClient (&amp;point);
        ::SetCursor (m_rcTextBox.PtInRect (point) ?
            m_hCursorIBeam : m_hCursorArrow);
        return TRUE;
    }
    return CWnd::OnSetCursor (pWnd, nHitTest, message);
}

void CMainWindow::OnLButtonDown (UINT nFlags, CPoint point)

{
    //
    / Move the caret if the text box is clicked with the left mouse button.
    //
    if (m_rcTextBox.PtInRect (point)) {
        m_nTextPos = GetNearestPos (point);
        PositionCaret ();
    }
}

void CMainWindow::OnKeyDown (UINT nChar, UINT nRepCnt, UINT nFlags)
{
    ShowMessage (_T (&quot;WM_KEYDOWN&quot;), nChar, nRepCnt, nFlags);

    //
    // Move the caret when the left, right, Home, or End key is pressed.
    //
    switch (nChar) {
	case VK_LEFT:
            if (m_nTextPos != 0) {
                m_nTextPos--;
                PositionCaret ();
        }
        break;

    case VK_RIGHT:
        if (m_nTextPos != m_strInputText.GetLength ()) {
            m_nTextPos++;
            PositionCaret ();
        }
        break;

    case VK_HOME:
        m_nTextPos = 0;
        PositionCaret ();
        break;

    case VK_END:
        m_nTextPos = m_strInputText.GetLength ();
        PositionCaret ();
        break;
    }
}

void CMainWindow::OnChar (UINT nChar, UINT nRepCnt, UINT nFlags)
{
    ShowMessage (_T (&quot;WM_CHAR&quot;), nChar, nRepCnt, nFlags);

    CClientDC dc (this);

    //
    // Determine which character was just input from the keyboard.
    //
    switch (nChar) {

    case VK_ESCAPE:
    case VK_RETURN:
        m_strInputText.Empty ();
        m_nTextPos = 0;
        break;

    case VK_BACK:
        if (m_nTextPos != 0) {
            m_strInputText = m_strInputText.Left (m_nTextPos - 1) +

             m_strInputText.Right (m_strInputText.GetLength () -
                m_nTextPos);
            m_nTextPos--;
        }
        break;

    default:
        if ((nChar &gt;= 0) &amp;&amp; (nChar &lt;= 31))
            return;

        if (m_nTextPos == m_strInputText.GetLength ()) {
            m_strInputText += nChar;
            m_nTextPos++;
        }
        else
            m_strInputText.SetAt (m_nTextPos++, nChar);

        CSize size = dc.GetTextExtent (m_strInputText,
            m_strInputText.GetLength ());

        if ((m_ptTextOrigin.x + size.cx) &gt; m_nTextLimit) {
            m_strInputText = nChar;
            m_nTextPos = 1;
        }
        break;
    }

    //
    // Update the contents of the text box.
    //
    HideCaret ();
    DrawInputText (&amp;dc);
    PositionCaret (&amp;dc);
    ShowCaret ();
}

void CMainWindow::OnKeyUp (UINT nChar, UINT nRepCnt, UINT nFlags)
{
    ShowMessage (_T (&quot;WM_KEYUP&quot;), nChar, nRepCnt, nFlags);
    CWnd::OnKeyUp (nChar, nRepCnt, nFlags);
}

void CMainWindow::OnSysKeyDown (UINT nChar, UINT nRepCnt, UINT nFlags)
{
    ShowMessage (_T (&quot;WM_SYSKEYDOWN&quot;), nChar, nRepCnt, nFlags);
    CWnd::OnSysKeyDown (nChar, nRepCnt, nFlags);
}
	void CMainWindow::OnSysChar (UINT nChar, UINT nRepCnt, UINT nFlags)
{
    ShowMessage (_T (&quot;WM_SYSCHAR&quot;), nChar, nRepCnt, nFlags);
    CWnd::OnSysChar (nChar, nRepCnt, nFlags);
}

void CMainWindow::OnSysKeyUp (UINT nChar, UINT nRepCnt, UINT nFlags)
{
    ShowMessage (_T (&quot;WM_SYSKEYUP&quot;), nChar, nRepCnt, nFlags);
    CWnd::OnSysKeyUp (nChar, nRepCnt, nFlags);
}

void CMainWindow::PositionCaret (CDC* pDC)
{
    BOOL bRelease = FALSE;

    //
    // Create a device context if pDC is NULL.
    //
    if (pDC == NULL) {
        pDC = GetDC ();
        bRelease = TRUE;
    }

    //
    // Position the caret just right of the character whose 0-based
    // index is stored in m_nTextPos.
    //
    CPoint point = m_ptTextOrigin;
    CString string = m_strInputText.Left (m_nTextPos);
    point.x += (pDC-&gt;GetTextExtent (string, string.GetLength ())).cx;
    SetCaretPos (point);

    //
    // Release the device context if it was created inside this function.
    //
    if (bRelease)
        ReleaseDC (pDC);
}

int CMainWindow::GetNearestPos (CPoint point)
{
    //
    // Return 0 if (point.x, point.y) lies to the left of the text in
    // the text box.
    //
    if (point.x &lt;= m_ptTextOrigin.x)
        return 0;

    //
    // Return the string length if (point.x, point.y) lies to the right
    // of the text in the text box.
    //
    CClientDC dc (this);
    int nLen = m_strInputText.GetLength ();
    if (point.x &gt;= (m_ptTextOrigin.x +
        (dc.GetTextExtent (m_strInputText, nLen)).cx))
        return nLen;

    //
    // Knowing that (point.x, point.y) lies somewhere within the text
    // in the text box, convert the coordinates into a character index.
    //
    int i = 0;
    int nPrevChar = m_ptTextOrigin.x;
    int nNextChar = m_ptTextOrigin.x;

    while (nNextChar &lt; point.x) {
        i++;
        nPrevChar = nNextChar;      
        nNextChar = m_ptTextOrigin.x +
            (dc.GetTextExtent (m_strInputText.Left (i), i)).cx;
    }
    return ((point.x - nPrevChar) &lt; (nNextChar - point.x)) ? i - 1: i;
}

void CMainWindow::DrawInputText (CDC* pDC)
{
    pDC-&gt;ExtTextOut (m_ptTextOrigin.x, m_ptTextOrigin.y,
        ETO_OPAQUE, m_rcTextBox, m_strInputText, NULL);
}

void CMainWindow::ShowMessage (LPCTSTR pszMessage, UINT nChar,
    UINT nRepCnt, UINT nFlags)
{
    //
    // Formulate a message string.
    //
    CString string;
    string.Format (_T (&quot;%s\t %u\t  %u\t  %u\t  %u\t  %u\t  %u\t   %u&quot;),
        pszMessage, nChar, nRepCnt, nFlags &amp; 0xFF,
        (nFlags &gt;&gt; 8) &amp; 0x01,
		(nFlags &gt;&gt; 13) &amp; 0x01,
        (nFlags &gt;&gt; 14) &amp; 0x01,
        (nFlags &gt;&gt; 15) &amp; 0x01);

    //
    // Scroll the other message strings up and validate the scroll
    // rectangle to prevent OnPaint from being called.
    //
    ScrollWindow (0, -m_cyLine, &amp;m_rcScroll);
    ValidateRect (m_rcScroll);

    //
    // Record the new message string and display it in the window.
    //
    CClientDC dc (this);
    dc.SetBkColor ((COLORREF) ::GetSysColor (COLOR_3DFACE));

    m_strMessages[m_nMsgPos] = string;
    dc.TabbedTextOut (m_ptLowerMsgOrigin.x, m_ptLowerMsgOrigin.y,
        m_strMessages[m_nMsgPos], m_strMessages[m_nMsgPos].GetLength (),
        sizeof (m_nTabStops), m_nTabStops, m_ptLowerMsgOrigin.x);

    //
    // Update the array index that specifies where the next message
    // string will be stored.
    //
    if (++m_nMsgPos == MAX_STRINGS)
        m_nMsgPos = 0;  
}

void CMainWindow::DrawMessageHeader (CDC* pDC)
{
    static CString string =
        _T (&quot;Message\tChar\tRep\tScan\tExt\tCon\tPrv\tTran&quot;);

    pDC-&gt;SetBkColor ((COLORREF) ::GetSysColor (COLOR_3DFACE));
    pDC-&gt;TabbedTextOut (m_ptHeaderOrigin.x, m_ptHeaderOrigin.y,
        string, string.GetLength (), sizeof (m_nTabStops), m_nTabStops,
        m_ptHeaderOrigin.x);
}

void CMainWindow::DrawMessages (CDC* pDC)
{
    int nPos = m_nMsgPos;
    pDC-&gt;SetBkColor ((COLORREF) ::GetSysColor (COLOR_3DFACE));

    for (int i=0; i&lt;MAX_STRINGS; i++) {
        pDC-&gt;TabbedTextOut (m_ptUpperMsgOrigin.x,
            m_ptUpperMsgOrigin.y + (m_cyLine * i),
            m_strMessages[nPos], m_strMessages[nPos].GetLength (),
            sizeof (m_nTabStops), m_nTabStops, m_ptUpperMsgOrigin.x);

        if (++nPos == MAX_STRINGS)
            nPos = 0;    
    }
}
</pre>
</td></tr></table>



<A NAME="98"><H2>Handling the Caret</H2></A>

<P><I>CMainWindow</I>'s <I>OnSetFocus</I> and 
<I>OnKillFocus</I> handlers create a caret when 
the VisualKB window receives the input focus and destroy the caret when the focus 
goes away. <I>OnSetFocus</I> sets the caret width to 2 or the SM_CXBORDER value returned 
by <I>::GetSystemMetrics</I>, whichever is greater, so that the caret is visible even on very 
high resolution displays:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
void CMainWindow::OnSetFocus (CWnd* pWnd)
{
    CreateSolidCaret (max (2, ::GetSystemMetrics (SM_CXBORDER)),
        m_cyChar);
    SetCaretPos (m_ptCaretPos);
    ShowCaret ();
}
</pre>
</td></tr></table>

<P><I>OnKillFocus</I> hides the caret, saves the current caret position so that it can be 
restored the next time <I>OnSetFocus</I> is called, and then destroys the caret:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
void CMainWindow::OnKillFocus (CWnd* pWnd)
{
    HideCaret ();
    m_ptCaretPos = GetCaretPos ();
    ::DestroyCaret ();
}
</pre>
</td></tr></table>

<P><I>m_ptCaretPos</I> is initialized with the coordinates of the leftmost character cell 
in <I>CMainWindow::OnCreate</I>. It is reinitialized with the current caret position 
whenever the window loses the input focus. Therefore, the call to 
<I>SetCaretPos</I> in <I>OnSetFocus</I> sets the caret to the beginning of the text box when the program is first activated 
and restores the caret to the position it previously occupied in subsequent invocations.</P>

<P>The <I>OnKeyDown</I> handler moves the caret when the left arrow, right arrow, 
Home key, or End key is pressed. None of these keys generates WM_CHAR messages, 
so VisualKB processes WM_KEYDOWN messages instead. A 
<I>switch-case</I> block executes the appropriate handling routine based on the virtual key code in 
<I>nChar</I>. The handler for the left arrow key (whose virtual key code is VK_LEFT) consists of the 
following statements:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
case VK_LEFT:
    if (m_nTextPos != 0) {
        m_nTextPos&#8212;;
        PositionCaret ();
    }
    break;
</pre>
</td></tr></table>

<P><I>m_nTextPos</I> is the position at which the next character will be inserted into the 
text string. The text string itself is stored in the 
<I>CString</I> object <I>m_strInputText</I>. 
<I>PositionCaret</I> is a protected 
<I>CMainWindow</I> member function that uses 
<I>GetTextExtent</I> to find the pixel position in the text string that corresponds to the character position 
stored in <I>m_nTextPos</I> and then moves the caret to that position with 
<I>SetCaretPos</I>. After checking 
<I>m_nTextPos</I> to make sure it hasn't run out of room to move the caret further 
left, the VK_LEFT handler decrements 
<I>m_nTextPos</I> and calls <I>PositionCaret</I> to move 
the caret. If <I>m_nTextPos</I> is 0, which indicates that the caret is already positioned at 
the left end of the entry field, the keystroke is ignored. The other VK_ handlers are 
similarly straightforward. The VK_END handler, for example, moves the caret to the 
end of the text string with the statements</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_nTextPos = m_strInputText.GetLength ();
PositionCaret ();
</pre>
</td></tr></table>

<P><I>GetLength</I> is a <I>CString</I> member function that returns the number of characters in 
the string. The use of a <I>CString</I> object to hold the text entered into VisualKB makes 
text handling much simpler than it would be if strings were handled simply as arrays 
of characters. For example, all the <I>OnChar</I> handler has to do to add a new character 
to the end of the string is</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_strInputText += nChar;
</pre>
</td></tr></table>

<P>When it comes to string handling, it doesn't get much easier than that. Browse 
through VisualKB.cpp and you'll see several 
<I>CString</I> member functions and operators, 
including <I>CString::Left</I>, which returns a 
<I>CString</I> object containing the string's left 
<I>n</I> characters; <I>CString::Right</I>, which returns the rightmost 
<I>n</I> characters; and <I>CString::Format</I>, 
which performs <I>printf</I>-like string formatting.</P>

<P>It seemed a shame not to have VisualKB do anything with the mouse when 
half of this chapter is devoted to mouse input, so I added an 
<I>OnLButtonDown</I> handler, which allows the caret to be moved with a click of the left mouse button in the 
text box. In addition to adding a nice feature to the program, the 
<I>OnLButtonDown</I> handler also lets us examine a function that takes the point at which a mouse click 
occurred and returns the corresponding character position within a text string. The 
button handler itself is exceedingly simple:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
void CMainWindow::OnLButtonDown (UINT nFlags, CPoint point)
{
    if (m_rcTextBox.PtInRect (point)) {
        m_nTextPos = GetNearestPos (point);
        PositionCaret ();
    }
}
</pre>
</td></tr></table>

<P><I>m_rcTextBox</I> is the rectangle that bounds the text box. After calling 
<I>CRect::PtInRect</I> to determine whether the click occurred inside the rectangle (and returning 
without doing anything if it didn't), 
<I>OnLButtonDown</I> computes a new value for 
<I>m_nTextPos</I> with 
<I>CMainWindow::GetNearestPos</I> and calls 
<I>PositionCaret</I> to reposition the caret. 
<I>GetNearestPos</I> first checks to see if the mouse was clicked to the left of the 
character string and returns 0 for the new character position if it was:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
if (point.x &lt;= m_ptTextOrigin.x)
    return 0;
</pre>
</td></tr></table>

<P><I>m_ptTextOrigin</I> holds the coordinates of the character string's upper left 
corner. <I>GetNearestPos</I> then returns an integer value that equals the string length if the 
mouse was clicked beyond the string's rightmost extent:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CClientDC dc (this);
int nLen = m_strInputText.GetLength ();
if (point.x &gt;= (m_ptTextOrigin.x +
    (dc.GetTextExtent (m_strInputText, nLen)).cx))
    return nLen;
</pre>
</td></tr></table>

<P>The result? If the mouse was clicked inside the text rectangle but to the right of 
the rightmost character, the caret is moved to the end of the string.</P>

<P>If <I>GetNearestPos</I> makes it beyond the <I>return 
nLen</I> statement, we can conclude that the cursor was clicked inside the text box somewhere between the 
character string's left and right extents. 
<I>GetNearestPos</I> next initializes three variables and 
executes a <I>while</I> loop that calls 
<I>GetTextExtent</I> repeatedly until 
<I>nPrevChar</I> and <I>nNextChar</I> hold values that bracket the 
<I>x</I> coordinate of the point at which the click occurred:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
while (nNextChar &lt; point.x) {
    i++;
    nPrevChar = nNextChar;
    nNextChar = m_ptTextOrigin.x +
        (dc.GetTextExtent (m_strInputText.Left (i), i)).cx;
}
</pre>
</td></tr></table>

<P>When the loop falls through, <I>i</I> holds the number of the character position to the 
right of where the click occurred, and <I>i</I>-1 identifies the character position to the left. 
Finding the character position is a simple matter of finding out whether 
<I>point.x</I> is closer to <I>nNextChar</I> or 
<I>nPrevChar</I> and returning <I>i</I> or 
<I>i</I>-1. This is accomplished with the following one-liner:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
return ((point.x - nPrevChar) &lt; (nNextChar - point.x)) ? i - 1: i;
</pre>
</td></tr></table>

<P>That's it; given an arbitrary point in the window's client area, 
<I>GetNearestPos</I> returns a matching character position in the string 
<I>m_strInputText</I>. A small amount of inefficiency is built into this process because the farther to the right the point 
lies, the more times <I>GetTextExtent</I> is called. (The 
<I>while</I> loop starts with the leftmost character in the string and moves right one character at a time until it finds the 
character just to the right of the point at which the click occurred.) A really smart 
implementation of <I>GetNearestPos</I> could do better by using a binary-halving approach, starting 
in the middle of the string and iterating to the left or right by a number of 
characters equal to half the area that hasn't already been covered until it zeroes in on the 
characters to the left and right of the point at which the click occurred. A character 
position in a string 128 characters long could then be located with no more than 8 calls 
to <I>GetTextExtent</I>. The brute force technique employed by 
<I>GetNearestPos</I> could require as many as 127 calls.</P>

<A NAME="99"><H2>Entering and Editing Text</H2></A>

<P>The logic for entering and editing text is found in 
<I>CMainWindow::OnChar</I>. <I>OnChar</I>'s processing strategy can be summarized in this way:</P>

<OL>
<P><LI>
Echo the message to the screen.
</LI></P>

<P><LI>
Modify the text string using the character code in <I>nChar</I>.
</LI></P>

<P><LI>
Draw the modified text string on the screen.
</LI></P>

<P><LI>
Reposition the caret.
</LI></P>
</OL>
	 
<P>Step 1 is accomplished by calling 
<I>CMainWindow::ShowMessage</I>, which is discussed in the next section. How the text string is modified in step 2 depends on 
what the character code in <I>nChar</I> is. If the character is an escape or a return 
(VK_ESCAPE or VK_RETURN), <I>m_strInputText</I> is cleared by a call to 
<I>CString::Empty</I> (another handy member of the 
<I>CString</I> class) and <I>m_nTextPos</I> is set to 0. If the character is a 
backspace (VK_BACK) and <I>m_nTextPos</I> isn't 0, the character at 
<I>m_nTextPos-</I>1 is deleted and 
<I>m_nTextPos</I> is decremented. If the character is any other value between 0 
and 31, inclusive, it is ignored. If <I>nChar</I> represents any other character, it is added 
to <I>m_strInputText</I> at the current character position and 
<I>m_nTextPos</I> is incremented accordingly.</P>

<P>With the character that was just entered now added to 
<I>m_strInputText</I>, <I>OnChar</I> hides the caret and proceeds to step 3. The modified string is output to the 
screen with <I>CMainWindow::DrawInputText</I>, which in turn relies on 
<I>CDC::ExtTextOut</I> to do its text output. 
<I>ExtTextOut</I> is similar to <I>TextOut</I>, but it offers a few options that 
<I>TextOut</I> doesn't. One of those options is an ETO_OPAQUE flag that fills a rectangle 
surrounding the text with the device context's current background color. Repainting the 
entire rectangle erases artifacts left over from the previous text-output operation if the 
string's new width is less than its previous width. The border around the text box (and 
the border around the message list) is drawn with the 
<I>CDC::DrawEdge</I> function, which calls through to the 
<I>::DrawEdge</I> API function. <I>DrawEdge</I> is the easy way to draw 
3D borders that conform to the specifications prescribed in the Windows interface 
guidelines and that automatically adapt to changes in the system colors used for 
highlights and shadows. You can use a related 
<I>CDC</I> function, <I>Draw3dRect</I>, to draw simple 
3D rectangles in your choice of colors.</P>

<P><I>OnChar</I> finishes up by calling 
<I>PositionCaret</I> to reposition the caret using 
the value in <I>m_nTextPos</I> and then 
<I>ShowCaret</I> to redisplay the caret. As an 
experiment, comment out <I>OnChar</I>'s calls to 
<I>HideCaret</I> and <I>ShowCaret</I>, recompile the 
program, and type a few characters into the text-entry field. This simple exercise will make 
clear why it's important to hide the caret before painting text behind it.</P>

<A NAME="100"><H2>Other Points of Interest</H2></A>

<P>As you move the cursor around inside the VisualKB window, notice that it 
changes from an arrow when it's outside the text box to an I-beam when it's inside. 
<I>CMainWindow</I>'s constructor registers a WNDCLASS with a NULL class cursor and 
stores the handles for the system's arrow and I-beam cursors in the member 
variables <I>m_hCursorArrow </I>and 
<I>m_hCursorIBeam</I>. Each time 
<I>CMainWindow</I> receives a WM_SETCURSOR message, its 
<I>OnSetCursor</I> handler checks the current cursor location 
and calls <I>::SetCursor</I> to display the appropriate cursor.</P>

<P>VisualKB echoes keyboard messages to the screen by calling 
<I>CMainWindow::ShowMessage</I> each time a message is received. 
<I>ShowMessage</I> formulates a new output string with help from 
<I>CString::Format</I>, copies the result to the least 
recently used entry in the <I>m_strMessages</I> array, scrolls the message list up one line, and 
calls <I>CDC::TabbedTextOut</I> to display the new message string on the bottom line. 
<I>TabbedTextOut</I> is used in lieu of 
<I>TextOut</I> so that columns will be properly aligned in 
the output. (Without tab characters, it's virtually impossible to get characters in a 
proportionally spaced font to line up in columnar format.) The tab stop settings are 
initialized in <I>OnCreate</I> using values based on the default font's average character 
width and stored in the <I>m_nTabStops</I> array. Message strings are saved in the 
<I>m_strMessages</I> array so the <I>OnPaint</I> handler can repaint the message display when necessary. 
The <I>CMainWindow</I> data member 
<I>m_nMsgPos</I> marks the current position in the 
array&#8212;the index of the array element that the next string will be copied to. 
<I>m_nMsgPos</I> is incremented each time 
<I>ShowMessage</I> is called and wrapped around to 0 when 
it reaches the array limit so that 
<I>m_strMessages</I> can maintain a record of the last 
12 keyboard messages received.</P>

<P>VisualKB's <I>CMainWindow</I> class includes 
<I>OnKeyUp</I>, <I>OnSysKeyDown</I>, 
<I>OnSysKeyUp</I>, and <I>OnSysChar</I> handlers whose only purpose is to echo keyboard messages to 
the screen. Each message handler is careful to call the corresponding message 
handler in the base class before returning, as shown here:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
void CMainWindow::OnSysKeyDown (UINT nChar, UINT nRepCnt, UINT nFlags)
{
       <img src="images/grayvellip.JPG" width=3 height=13 border="0">
    CWnd::OnSysKeyDown (nChar, nRepCnt, nFlags);
}
</pre>
</td></tr></table>

<P>Nonclient-area mouse messages and system keyboard messages are frequently 
catalysts for other messages, so it's important to forward them to the base class to 
permit default processing to take place.</P>

</BODY>
</HTML>




