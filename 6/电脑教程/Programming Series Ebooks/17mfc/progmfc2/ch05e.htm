<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>The Typed Pointer Classes</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch05d.htm", "ch06a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="161"><H1>The Typed Pointer Classes</H1></A>

<P>The MFC collection classes with <I>Ptr</I> and 
<I>Ob</I> in their names (the &quot;Ptr&quot; and &quot;Ob&quot; 
classes) provide convenient implementations of containers that store generic (void) 
pointers and containers that store pointers to MFC objects&#8212;that is, objects created from 
classes derived from <I>CObject</I>. The problem with the 
<I>Ptr</I> and <I>Ob</I> classes is that they're 
<I>too</I> generic. Using them typically requires lots of type casting, which is anathema to 
many C++ programmers and poor programming practice besides.</P>


<P>MFC's <I>typed pointer classes</I>&#8212;a set of three template classes designed to 
handle collections of pointers in a type-safe manner&#8212;offer a convenient solution to the 
problem of storing pointers without compromising type safety. The typed pointer 
classes are listed in the following table.</P>

<P><b>Collection Classes for Pointers</b></P>

<P>
<table valign="top" cellpadding=5 width="95%">
<tr><th valign="top"><I>Class Name</I></th>
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top"><I>CTypedPtrArray</I></td>
<td valign="top">Manages arrays of pointers</td>
</tr>
<tr>
<td valign="top"><I>CTypedPtrList</I></td>
<td valign="top">Manages linked lists of pointers</td>
</tr>
<tr>
<td valign="top"><I>CTypedPtrMap</I></td>
<td valign="top">Manages maps that use pointers as items or keys</td>
</tr>
</table>
</P>
     
<P>Suppose you're writing a drawing program and you've written a class 
named <I>CLine</I> that represents lines drawn on the screen. Each time the user draws a line, 
you create a new <I>CLine</I> object. You need somewhere to store 
<I>CLine</I> pointers, and because you want to be able to add and delete pointers anywhere in the collection 
without incurring a performance hit, you decide to use a linked list. Because you derived 
<I>CLine</I> from <I>CObject</I>, <I>CObList</I> would seem a natural fit.</P>
<P><I>CObList</I> will do the job, but every time you retrieve a 
<I>CLine</I> pointer from the list, you must cast it to 
<I>CLine*</I> because <I>CObList</I> returns 
<I>CObject</I> pointers. <I>CTypedPtrList</I> offers a clean alternative that requires no casting. Here's a code sample that 
demonstrates this point:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CTypedPtrList&lt;CObList, CLine*&gt; list;

// Populate the list.
for (int i=0; i&lt;10; i++) {
    int x = i * 10;
    CLine* pLine = new CLine (x, 0, x, 100);
    list.AddTail (pLine);
}

// Enumerate the items in the list.
POSITION pos = list.GetHeadPosition ();
while (pos != NULL)
    CLine* pLine = list.GetNext (pos); // No casting!
</pre>
</TD></TR></TABLE>
</P>	
	
<P>When you retrieve a <I>CLine</I> pointer with 
<I>GetNext</I>, you get back a <I>CLine</I> pointer 
that requires no casting. That's type safety.</P>

<P><I>CTypedPtrList</I> and the other typed pointer classes work by deriving from 
the class whose name is specified in the first template parameter. Inside the derived 
class are type-safe member functions that wrap the corresponding member functions 
in the base class. You can call any of the functions in the base class or in the 
derived class, but where they overlap, you'll normally use the type-safe versions instead. 
In general, you should use <I>Ob</I> classes as base classes for collections that hold 
pointers to objects derived from <I>CObject</I>, and 
<I>Ptr</I> classes as base classes for collections 
that hold pointers to other types of objects.</P>
<P>As is true of all MFC collection classes that store pointers, deleting pointers 
from an array, a list, or a map doesn't delete the items that the pointers point to. 
Therefore, before emptying a list of <I>CLine</I> pointers, you'll probably find it necessary to 
delete the <I>CLine</I>s, too:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
POSITION pos = list.GetHeadPosition ();
while (pos != NULL)
    delete list.GetNext (pos);
list.RemoveAll ();
</pre>
</TD></TR></TABLE>
</P>

<P>Remember: If you don't delete the <I>CLine</I>s, nobody will. Don't assume that the 
collection classes will delete them for you.</P>

</BODY>
</HTML>




