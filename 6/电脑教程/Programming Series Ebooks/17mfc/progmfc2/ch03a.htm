<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Chapter 3 -- The Mouse and the Keyboard</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch02e.htm", "ch03b.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<P><font size="+3">Chapter 3</font></P>

<A NAME="67"><H1>The Mouse and the Keyboard</H1></A>

<P>If life were like the movies, traditional input devices would have given way long 
ago to speech-recognition units, 3D headsets, and other human-machine interface 
gadgets. At present, however, the two most common input devices remain the 
mouse and the keyboard. Microsoft Windows handles some mouse and keyboard input 
itself, automatically dropping down a menu, for example, when the user clicks an 
item on the menu bar, and sending the application a WM_COMMAND message when 
an item is selected from the menu. It's entirely possible to write a full-featured 
Windows program that processes no mouse or keyboard input directly, but as an 
application developer, you'll eventually discover the need to read input from the mouse and 
keyboard directly. And when you do, you'll need to know about the mouse and 
keyboard interfaces that Windows provides.</P>

<P>Not surprisingly, mouse and keyboard input comes in the form of 
messages. Device drivers process mouse and keyboard interrupts and place the resultant 
event notifications in a systemwide queue known as the 
<I>raw input queue</I>. Entries in the raw input queue have WM_ message identifiers just as conventional messages 
do, but the data in them requires further processing before it is meaningful to an 
application. A dedicated thread owned by the operating system monitors the raw 
input queue and transfers each message that shows up there to the appropriate 
thread message queue. The &quot;cooking&quot; of the message data is performed later, in the 
context of the receiving application, and the message is ultimately retrieved and 
dispatched just as any other message is.</P>

<P>This input model differs from that of 16-bit Windows, which stored mouse 
and keyboard messages in a single systemwide input queue until they were retrieved 
by an application. This arrangement proved to be an Achilles' heel of sorts because 
it meant that an application that failed to dispose of input messages in a timely 
manner could prevent other applications from doing the same. Win32's asynchronous 
input model solves this problem by using the raw input queue as a temporary holding 
buffer and moving input messages to thread message queues at the earliest opportunity. 
(In 32-bit Windows, each thread that calls certain Windows API functions is given its 
own message queue, so a multithreaded application can have not one, but many, 
message queues.) A 32-bit application that goes too long without checking the 
message queue responds sluggishly to user input, but it doesn't affect the responsiveness 
of other applications running on the system.</P>

<P>Learning to respond to mouse and keyboard input in a Windows application 
is largely a matter of learning about which messages to process. This chapter 
introduces mouse and keyboard messages and the various functions, both in MFC and the 
API, that are useful for processing them. We'll apply the concepts presented here to 
the real world by developing three sample applications:</P>

<UL>
<P><LI>
TicTac, a tic-tac-toe game that demonstrates how to respond to mouse clicks
</LI></P>

<P><LI>
MouseCap, a simple drawing program that demonstrates how mouse 
capturing works and how nonclient-area mouse messages are processed
</LI></P>

<P><LI>
VisualKB, a typing program that brings mouse and keyboard 
handlers together under one roof and lists the keyboard messages it receives
</LI></P>
</UL>

<P>We have a lot of ground to cover, so let's get started.</P>

</BODY>
</HTML>




