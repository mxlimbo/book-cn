<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Slider, Spin Button, and ToolTip Controls</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch16b.htm", "ch16d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="496"><H1>Slider, Spin Button, and ToolTip Controls</H1></A>

<P>Now that you're familiar with the general characteristics of the common controls, 
let's look at specifics for a few of the control types. We'll start with sliders, spin 
buttons, and ToolTip controls, which are all relatively simple to program and which are 
also generic enough that they can be put to use in a variety of applications. After 
we've looked at these controls and the corresponding MFC control classes, we'll write 
a sample program that uses a slider control and a pair of spin buttons in a dialog 
box and also uses a ToolTip control to provide context-sensitive help. Rather than use 
a raw <I>CToolTipCtrl</I> to implement the ToolTip control, we'll use 
<I>CToolTipCtrl</I> as a base class for a class of our own and add a pair of handy member functions that correct 
a rather severe deficiency in MFC's ToolTip implementation.</p>

<A NAME="497"><H2>Slider Controls</H2></A>

<P>Slider controls, also known as <I>trackbar 
controls,</I> are similar to the sliding volume controls found on many radios and stereo systems. A slider has a thumb that 
moves like the thumb in a scroll bar. After you create a slider, you set the minimum 
and maximum values representing the extremes of the thumb's travel and optionally 
set the initial thumb position. The user can then reposition the thumb by dragging it 
with the left mouse button or clicking the channel in which the thumb slides. When a 
slider has the input focus, its thumb can also be moved with the arrow keys, the Page 
Up and Page Down keys, and the Home and End keys. A simple function call returns 
an integer representing the thumb position. If desired, you can respond to 
positional changes as the thumb is moved by processing control notifications. Figure 16-2 
shows what a simple slider control looks like. Tick marks denote the positions the 
thumb can assume.</p>

<P>
<img src="images/F16MG02.GIF" width=153 height=40 border=0>
</p><p>
<!-- CAPTION --><B>Figure 16-2.</B> <I>A horizontal slider with tick marks denoting thumb stops.</I><!-- /CAPTION -->
</p>

<P>The table below shows slider-specific control styles. A 
slider can be oriented horizontally or vertically. The default orientation if neither 
TBS_HORZ nor TBS_VERT is specified is horizontal. The TBS_AUTOTICKS style marks 
thumb stops with tick marks. If the slider's range is 0 through 8, TBS_AUTOTICKS 
creates nine tick marks&#8212;one at each end of the slider and seven in between. 
TBS_NOTICKS removes the tick marks altogether, and TBS_NOTHUMB creates a slider that has 
no thumb. If you specify neither TBS_AUTOTICKS nor TBS_NOTICKS, the slider has 
a tick mark at each end but none in between. By default, tick marks are drawn 
below a horizontal slider and to the right of a vertical slider. You can move the tick marks 
to the top or the left by specifying TBS_TOP or TBS_LEFT, or you can use 
TBS_BOTH to create a slider that has tick marks both above and below or to its right and left.</p>

<p><b>Slider Control Styles</b></p>
<p>
<table cellpadding=5 width="95%">
<tr>
<th valign="top"><i>Style</i></th>
<th valign="top"><i>Description</i></th>
</tr><tr>
<td valign="top">TBS_HORZ</td>
<td valign="top">Orients the slider horizontally.</td>
</tr><tr>
<td valign="top">TBS_VERT</td>
<td valign="top">Orients the slider vertically.</td>
</tr><tr>
<td valign="top">TBS_LEFT</td>
<td valign="top">Draws tick marks to the left of a vertical slider.</td>
</tr><tr>
<td valign="top">TBS_RIGHT</td>
<td valign="top">Draws tick marks to the right of a vertical slider.</td>
</tr><tr>
<td valign="top">TBS_TOP</td>
<td valign="top">Draws tick marks above a horizontal slider.</td>
</tr><tr>
<td valign="top">TBS_BOTTOM</td>
<td valign="top">Draws tick marks below a horizontal slider.</td>
</tr><tr>
<td valign="top">TBS_BOTH</td>
<td valign="top">Draws tick marks both above and below a horizontal slider or to the left and right of a vertical slider.</td>
</tr><tr>
<td valign="top">TBS_NOTICKS</td>
<td valign="top">Removes tick marks from the slider.</td>
</tr><tr>
<td valign="top">TBS_AUTOTICKS</td>
<td valign="top">Positions a tick mark at each stop in the slider's range.</td>
</tr><tr>
<td valign="top">TBS_FIXEDLENGTH</td>
<td valign="top">Allows the thumb size to be modified by sending the control a TBM_SETTHUMBLENGTH message.</td>
</tr><tr>
<td valign="top">TBS_NOTHUMB</td>
<td valign="top">Removes the thumb from the slider.</td>
</tr><tr>
<td valign="top">TBS_ENABLESELRANGE</td>
<td valign="top">Widens the slider's channel so that a selection range can be displayed.</td>
</tr><tr>
<td valign="top">TBS_TOOLTIPS*</td>
<td valign="top">Adds a dynamic ToolTip control that moves with the thumb and displays the thumb position. Use <I>CSliderCtrl::SetToolTips</I> to replace the default ToolTip control with one of your own.</td>
</tr>
</table></p>

<P>* Requires Internet Explorer 3.0 or later</p>

<P>MFC represents sliders with the <I>CSliderCtrl</I> class. A slider's range and thumb position are set with <I>CSliderCtrl::SetRange</I> and <I>CSliderCtrl::SetPos</I>. The related <I>CSliderCtrl::GetRange</I> and <I>CSliderCtrl::GetPos</I> functions retrieve range and position information. If <I>m_wndSlider</I> is a <I>CSliderCtrl</I>, the statements</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndSlider.SetRange (0, 8);
m_wndSlider.SetPos (2);
</pre></td></tr></table></p>

<P>set the slider's range to 0 through 8 and its thumb position to 2.</p>

<P>A slider control assigned the style TBS_AUTOTICKS draws tick marks at each incremental thumb position. You can adjust the distance between tick marks with <I>CSliderCtrl::SetTicFreq</I>. The following statement configures a slider control to draw tick marks at every other thumb stop:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndSlider.SetTicFreq (2);
</pre></td></tr></table></p>

<P>To create a slider with tick marks at irregular intervals, omit the TBS_AUTOTICKS style and use <I>CSliderCtrl::SetTic</I> to put tick marks where you want them. The statements</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndSlider.SetRange (0, 8);
m_wndSlider.SetTic (2);
m_wndSlider.SetTic (3);
m_wndSlider.SetTic (6);
m_wndSlider.SetPos (2);
</pre></td></tr></table></p>

<P>place tick marks at 2, 3, and 6 in addition to the ones drawn at 0 and 8.</p>

<p>The TBS_ENABLESELRANGE style creates a slider with a wide channel 
suitable for displaying a selection range. The selection range is set with 
<I>CSliderCtrl::SetSelection</I> and is represented by a bar drawn in the system color COLOR_HIGHLIGHT. The 
statements</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndSlider.SetRange (0, 8);
m_wndSlider.SetSelection (3, 7);
</pre></td></tr></table></p>

<P>set the range to 0 through 8 and the selection to 3 through 7, producing the 
slider seen in Figure 16-3. Setting a selection doesn't limit the thumb's travel; the 
thumb can still be positioned anywhere in the slider range. If you want to limit the 
thumb's travel to the selection range or allow the user to alter the selection, you must 
implement a custom slider control UI. The most practical approach to customizing the 
UI is to derive a class from <I>CSliderCtrl</I> and add message handlers that change the 
way the control responds to presses of the Home, End, Page Up, Page Down, and 
arrow keys and clicks of the left mouse button. To perform default processing on 
selected messages, simply pass those messages to the base class.</p>

<P>
<img src="images/F16MG03.GIF" width=153 height=40 border=0>
</p><p>
<!-- CAPTION --><B>Figure 16-3.</B> <I>A slider with a selection range.</I><!-- /CAPTION -->
</p>

<P>As its thumb is moved, a slider sends its parent WM_HSCROLL or 
WM_VSCROLL messages as a scroll bar does. An 
<I>OnHScroll</I> or <I>OnVScroll</I> handler for a slider 
control receives three parameters: a notification code, an integer specifying the latest 
thumb position, and a <I>CScrollBar</I> pointer that can be cast to a 
<I>CSliderCtrl</I> pointer. The table below shows the nine possible notification codes and the actions 
that generate them. The thumb position passed to 
<I>OnHScroll</I> or <I>OnVScroll</I> is valid only 
when the notification code is TB_THUMBPOSITION or TB_THUMBTRACK. Use 
<I>CSliderCtrl::GetPos</I> to retrieve the thumb position in response to other types of notifications.</p>

<p><b>Slider Notifications</b></p>

<p><table width="95%" cellpadding=5>
<tr>
<th valign="top">Notification</th>
<th valign="top">Sent When</th>
</tr><tr>
<td valign="top">TB_TOP</td>
<td valign="top">The Home key is pressed while the slider has the input focus.</td>
</tr><tr>
<td valign="top">TB_BOTTOM</td>
<td valign="top">The End key is pressed while the slider has the input focus.</td>
</tr><tr>
<td valign="top">TB_LINEDOWN</td>
<td valign="top">The down or right arrow key is pressed while the slider has the input focus.</td>
</tr><tr>
<td valign="top">TB_LINEUP</td>
<td valign="top">The up or left arrow key is pressed while the slider has the input focus.</td>
</tr><tr>
<td valign="top">TB_PAGEDOWN</td>
<td valign="top">The Page Down key is pressed while the slider has the input focus, or the channel is clicked right of the thumb in a horizontal slider or below the thumb in a vertical slider.</td>
</tr><tr>
<td valign="top">TB_PAGEUP</td>
<td valign="top">The Page Up key is pressed while the slider has the input focus, or the channel is clicked left of the thumb in a horizontal slider or above the thumb in a vertical slider.</td>
</tr><tr>
<td valign="top">TB_THUMBTRACK</td>
<td valign="top">The thumb is dragged to a new position with the mouse.</td>
</tr><tr>
<td valign="top">TB_THUMBPOSITION</td>
<td valign="top">The left mouse button is released after the thumb is dragged.</td>
</tr><tr>
<td valign="top">TB_ENDTRACK</td>
<td valign="top">The key or mouse button used to move the thumb to a new position is released.</td>
</tr></table></p>

<P>One use for slider notifications is for dynamically updating an image on the 
screen in response to positional changes. The Settings page of the system's Display 
Properties property sheet, which you can display by right-clicking the desktop and 
selecting Properties from the context menu, processes TB_THUMBTRACK notifications 
from the slider in the Screen Area box and redraws an image of the computer screen 
each time the thumb moves to preview the effect the new setting will have on the desktop.</p>

<P><I>CSliderCtrl</I> provides more than two dozen functions you can use to operate 
on slider controls. Other useful member functions include 
<I>SetPageSize</I>, which sets the number of units the thumb moves when the channel is clicked with the mouse 
or when Page Up or Page Down is pressed; 
<I>GetTic</I>, <I>GetTicPos</I>, 
<I>GetTicArray</I>, and <I>GetNumTicks</I>, which return information about tick marks; and 
<I>ClearSel</I>, which removes a selection range. See the MFC documentation for more information regarding 
these and other <I>CSliderCtrl</I> function members.</p>

<A NAME="498"><H2>Spin Button Controls</H2></A>

<P>Spin button controls, which are also known as 
<I>up-down controls,</I> are small windows containing arrows that point up and down or left and right. Like scroll bars and 
sliders, spin buttons maintain their own ranges and positions. Clicking the up or 
right arrow increments the current position, and clicking the down or left arrow 
decrements it. Spin button controls send their parents notification messages before and after 
each positional change, but often those notifications are ignored because spin buttons 
are capable of doing some extraordinarily useful things on their own.</p>

<P>You can choose from the styles shown in the following table when you 
create a spin button control. UDS_SETBUDDYINT creates a spin button control that 
automatically updates an integer value displayed in a &quot;buddy&quot; control, which is 
typically an edit control or a static text control. When a UDS_SETBUDDYINT-style spin 
button control undergoes a positional change, it converts the integer describing the 
new position into a text string (think 
_<I>itoa</I>) and uses <I>::SetWindowText</I> to display the 
string in its buddy. UDS_SETBUDDYINT makes it trivial to add a set of arrows to an 
edit control so that the user can enter a number by either typing it at the keyboard or 
dialing it in with the mouse.</p>


<p><b>Spin Button Control Styles</b></p>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><i>Style</i></th>
<th valign="top"><i>Description</i></th>
</tr><tr>
<td valign="top">UDS_HORZ</td>
<td valign="top">Orients the arrows horizontally rather than vertically.</td>
</tr><tr>
<td valign="top">UDS_WRAP</td>
<td valign="top">Causes the position to wrap around if it's decremented or incremented beyond the minimum or maximum.</td>
</tr><tr>
<td valign="top">UDS_ARROWKEYS</td>
<td valign="top">Adds a keyboard interface. If a spin button control with this style has the input focus, the up and down arrow keys increment and decrement its position.</td>
</tr><tr>
<td valign="top">UDS_NOTHOUSANDS</td>
<td valign="top">Removes thousands separators so that 1,234,567 is displayed as 1234567.</td>
</tr><tr>
<td valign="top">UDS_SETBUDDYINT</td>
<td valign="top">Creates a spin button control that updates the text of a designated buddy control when the position is incremented or decremented.</td>
</tr><tr>
<td valign="top">UDS_AUTOBUDDY</td>
<td valign="top">Selects the previous control in the <I>z</I>-order as the spin button's buddy.</td>
</tr><tr>
<td valign="top">UDS_ALIGNRIGHT</td>
<td valign="top">Attaches the spin button control to the right inside border of its buddy.</td>
</tr><tr>
<td valign="top">UDS_ALIGNLEFT</td>
<td valign="top">Attaches the spin button control to the left inside border of its buddy.</td>
</tr></table></p>

<P>You can connect a spin button control to its buddy in two ways. You can 
explicitly link the two by calling 
<I>CSpinButtonCtrl::SetBuddy</I> with a 
<I>CWnd</I> pointer identifying the buddy control, or you can specify UDS_AUTOBUDDY when creating 
the spin button control, which automatically selects the previous control in the 
<I>z</I>-order as the spin button's buddy. In a dialog template, the statements</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
EDITTEXT    IDC_EDIT, 60, 80, 40, 14, ES_AUTOHSCROLL
CONTROL     &quot;&quot;, IDC_SPIN, &quot;msctls_updown32&quot;, UDS_SETBUDDYINT &#166;
            UDS_AUTOBUDDY &#166; UDS_ALIGNRIGHT, 0, 0, 0, 0
</pre></td></tr></table></p>

<P>create a single-line edit control and attach a spin button control to its right inside 
border, as shown in Figure 16-4. The edit control is shrunk by the width of the spin 
button control, and the spin button's height is adjusted to match the height of its 
buddy. Consequently, the edit control and the spin button control together occupy the 
same amount of space as the original edit control. Information regarding a spin 
button control's size and position is ignored when UDS_ALIGNLEFT or 
UDS_ALIGNRIGHT is specified.</p>

<p>
<img src="images/F16MG04.GIF" width=71 height=34 border=0>
</p><p>
<!-- CAPTION --><B>Figure 16-4.</B> <I>A spin button control attached to an edit control.</I><!-- /CAPTION -->
</p>

<P>By default, a UDS_SETBUDDYINT spin button control displays numbers 
in decimal format and inserts a thousands separator every third digit. You can 
configure the control to display hexadecimal numbers instead with 
<I>CSpinButtonCtrl::SetBase</I>:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndSpinButton.SetBase (16);
</pre></td></tr></table></p>

<P>Hex numbers are preceded by 0x characters so that it's obvious they are 
hexadecimal. Calling <I>SetBase</I> with a 10 switches output back to decimal format. You can 
remove separators from decimal numbers by specifying UDS_NOTHOUSANDS when 
you create the control; thousands separators are omitted from hex numbers by default.</p>

<P>You set a spin button control's range and position with 
<I>CSpinButtonCtrl::SetRange</I> and 
<I>CSpinButtonCtrl::SetPos</I>. Valid minimums and maximums range from 
 32,767 through 32,767, but the difference between the low and high ends of the 
range can't exceed 32,767. It's legal to specify a maximum that's less than the 
minimum. When you do, the actions of the arrows are reversed. On systems with Internet 
Explorer 4.0 or later installed, spin button controls support 32-bit ranges whose 
minimums and maximums can be set and retrieved with the aptly named 
<I>CSliderCtrl</I> functions <I>SetRange32</I> and 
<I>GetRange32</I>.</p>

<P>Each discrete click of an arrow in a spin button control (or press of an 
arrow key if the control's style includes UDS_ARROWKEYS) increments or decrements 
the position by 1. If you press and hold a button, the increments change to &#177;5 after 
2 seconds and &#177;20 after 5 seconds. You can alter the number of seconds that 
elapse before the incremental value changes and also control the magnitude of the 
changes with <I>CSpinButtonCtrl::SetAccel</I>. 
<I>SetAccel</I> accepts two parameters: a pointer to an 
array of UDACCEL structures and the number of structures in the array. The 
following statements configure a spin button control to increment or decrement the 
position by 1 for the first 2 seconds, 2 for the next 2 seconds, 10 for the next 2 seconds, 
and 100 for the remainder of the time a button is held down:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
UDACCEL uda[4];
uda[0].nSec = 0;
uda[0].nInc = 1;
uda[1].nSec = 2;
uda[1].nInc = 2;
uda[2].nSec = 4;
uda[2].nInc = 10;
uda[3].nSec = 8;
uda[3].nInc = 100;
pSpinButton-&gt;SetAccel (4, uda);
</pre></td></tr></table></p>

<P>Another use for <I>SetAccel</I> is to specify incremental values other than 1. If you'd 
like each button click to increment or decrement the position by 5, call 
<I>SetAccel</I> like this:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
UDACCEL uda;
uda.nSec = 0;
uda.nInc = 5;
pSpinButton-&gt;SetAccel (1, &amp;uda);
</pre></td></tr></table></p>

<P>You can retrieve accelerator values by passing the address of an array of 
UDACCEL structures to <I>CSpinButton::GetAccel</I>. But there's a trick: How do you know how 
many structures to allocate space for? This fact wasn't documented prior to Visual C++ 
6, but calling <I>GetAccel</I> as shown here returns the number of UDACCEL structures in 
the accelerator array:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
UINT nCount = pSpinButton-&gt;GetAccel (0, NULL);
</pre></td></tr></table></p>

<P>Once the count is known, you can allocate a buffer for the array and retrieve it like this:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
UDACCEL* puda = new UDACCEL[nCount];
pSpinButton-&gt;GetAccel (nCount, puda);
// Do something with the array.
delete[] puda;
</pre></td></tr></table></p>

<P>See? Nothing to it when you know the secret.</p>

<p>Before its position is incremented or decremented, a spin button control 
sends its parent a WM_NOTIFY message with a notification code equal to 
UDN_DELTAPOS and an <I>lParam</I> pointing to an NM_UPDOWN structure. Inside the structure are 
integers specifying the current position 
(<I>iPos</I>) and the amount by which the position 
is about to change (<I>iDelta</I>). A UDN_DELTAPOS handler must set 
*<I>pResult</I> to FALSE to allow the change to occur. To purposely prevent an increment or decrement 
operation being carried out, have the handler set 
*<I>pResult</I> to TRUE, and then return TRUE from 
<I>OnNotify</I>. UDN_DELTAPOS notifications are followed by WM_HSCROLL 
or WM_VSCROLL messages (depending on whether the spin button is oriented 
horizontally or vertically) reporting the new position. Clicking the down arrow when 
the control's current position is 8 produces the following sequence of messages.</p>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><i>Message</i></th>
<th valign="top"><i>Notification Code</i></th>
<th valign="top"><i>Parameters</i></th>
</tr><tr>
<td valign="top">WM_NOTIFY</td>
<td valign="top">UDN_DELTAPOS</td>
<td valign="top"><I>iPos</I>=8,<I> iDelta</I>=-1</td>
</tr><tr>
<td valign="top">WM_VSCROLL</td>
<td valign="top">SB_THUMBPOSITION</td>
<td valign="top"><I>nPos</I>=7</td>
</tr><tr>
<td valign="top">WM_VSCROLL</td>
<td valign="top">SB_ENDSCROLL</td>
<td valign="top"><I>nPos</I>=7</td>
</tr></table></p>

<P>If the button is held down for more than a half second or so, several 
UDN_DELTAPOS and SB_THUMBPOSITION notifications are sent in sequence.</p>

<A NAME="499"><H2>ToolTip Controls</H2></A>

<P>A ToolTip is a miniature help-text window that appears when the cursor pauses 
over a &quot;tool&quot; such as a button on a toolbar or a control in a dialog box. A ToolTip 
control is a control that monitors mouse movements and automatically displays a 
ToolTip when the cursor remains motionless over a tool for a predetermined period of 
time. MFC provides a convenient C++ interface to ToolTip controls through the 
<I>CToolTipCtrl</I> class. With 
<I>CToolTipCtrl</I> to help out, it's relatively easy to add ToolTips to controls 
in dialog boxes and implement other forms of interactive help. You simply create 
a ToolTip control and register the tools for which you'd like ToolTips displayed 
and the text of the ToolTips. For the most part, the control does the rest.</p>

<P><I>CToolTipCtrl::Create</I> creates a ToolTip control. (ToolTip controls can also 
be created from dialog templates, but the more common approach is to add a 
<I>CToolTipCtrl</I> data member to the dialog class and call 
<I>Create</I> from <I>OnInitDialog</I> instead.) If 
<I>m_ctlTT</I> is a <I>CToolTipCtrl</I> data member of a window class, the statement</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_ctlTT.Create (this);
</pre></td></tr></table></p>

<P>creates a ToolTip control. 
<I>CToolTipCtrl::Create</I> accepts an optional second 
parameter specifying the control's style. The only two styles supported are 
TTS_ALWAYSTIP and TTS_NOPREFIX. By default, ToolTips appear over active windows only. A 
TTS_ALWAYSTIP-style ToolTip control displays ToolTips over both active and 
inactive windows. TTS_NOPREFIX tells the control not to strip ampersands from ToolTip 
text. The default behavior is to ignore ampersands so that you can use the same text 
strings for menus and ToolTips.</p>

<P>After you create a ToolTip control, the next step is to add tools to it. A tool 
is either another window&#8212;usually a child window control that belongs to the 
ToolTip control's parent&#8212;or a rectangular area of a window. 
<I>CToolTipCtrl::AddTool</I> registers a tool and the ToolTip text that goes with it. One ToolTip control can have any 
number of tools associated with it. The statement</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_ctlTT.AddTool (pWnd, _T (&quot;This is a window&quot;), NULL, 0);
</pre></td></tr></table></p>

<P>assigns the ToolTip text &quot;This is a window&quot; to the window identified by 
<I>pWnd</I>. The second parameter passed to 
<I>AddTool</I> can be a pointer to a text string or the ID of 
a string resource, whichever you prefer. Similarly, the statement</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_ctlTT.AddTool (pWnd, _T (&quot;This is a rectangle&quot;),
    CRect (32, 32, 64, 64), IDT_RECTANGLE);
</pre></td></tr></table></p>

<P>creates a tool from the specified rectangle in 
<I>pWnd</I>'s client area. IDT_RECTANGLE is a nonzero integer that identifies the rectangle and is analogous to a child window 
ID identifying a control.</p>

<P>So far, so good. There's just one problem. A ToolTip control has to be able 
to see the mouse messages a tool receives so that it can monitor mouse events and 
know when to display a ToolTip, but Windows sends mouse messages to the window 
underneath the cursor. In the examples above, it's up to you to forward mouse 
messages going to <I>pWnd</I> to the ToolTip control. If 
<I>pWnd</I> corresponds to a top-level window or a dialog box, forwarding mouse messages is no big deal because you 
can map the relevant mouse messages to handlers in the window class or dialog 
class and relay them to the ToolTip control with 
<I>CToolTipCtrl::RelayEvent</I>. But if 
<I>pWnd</I> points to a child window control or any window other than your own, you have 
to resort to window subclassing or other devices in order to see mouse messages 
going to the window and relay them to the ToolTip control. Late in the beta cycle of 
Windows 95, the operating system architects recognized this problem and gave 
ToolTip controls the ability to do their own subclassing. Unfortunately, this feature has yet 
to be folded into <I>CToolTipCtrl</I>. So to make ToolTips truly easy to use, you must 
customize the <I>CToolTipCtrl</I> class by adding some smarts of your own.</p>

<p>Whenever I use a ToolTip control in an MFC application, I first derive a 
class from <I>CToolTipCtrl</I> named 
<I>CMyToolTipCtrl</I> and add a pair of member functions 
that take advantage of the fact that a ToolTip control can do its own subclassing. 
Here's what the derived class looks like:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
class CMyToolTipCtrl : public CToolTipCtrl
{
public:
    BOOL AddWindowTool (CWnd* pWnd, LPCTSTR pszText);
    BOOL AddRectTool (CWnd* pWnd, LPCTSTR pszText, 
        LPCRECT pRect, UINT nIDTool);
};

BOOL CMyToolTipCtrl::AddWindowTool (CWnd* pWnd, LPCTSTR pszText)
{
    TOOLINFO ti;
    ti.cbSize = sizeof (TOOLINFO);
    ti.uFlags = TTF_IDISHWND &#166; TTF_SUBCLASS;
    ti.hwnd = pWnd-&gt;GetParent ()-&gt;GetSafeHwnd ();
    ti.uId = (UINT) pWnd-&gt;GetSafeHwnd ();
    ti.hinst = AfxGetInstanceHandle ();
    ti.lpszText = (LPTSTR) pszText;

    return (BOOL) SendMessage (TTM_ADDTOOL, 0, (LPARAM) &amp;ti);
}

BOOL CMyToolTipCtrl::AddRectTool (CWnd* pWnd, LPCTSTR pszText,
    LPCRECT lpRect, UINT nIDTool)
{
    TOOLINFO ti;
    ti.cbSize = sizeof (TOOLINFO);
    ti.uFlags = TTF_SUBCLASS;
    ti.hwnd = pWnd-&gt;GetSafeHwnd ();
    ti.uId = nIDTool;
    ti.hinst = AfxGetInstanceHandle ();
    ti.lpszText = (LPTSTR) pszText;
    ::CopyRect (&amp;ti.rect, lpRect);

    return (BOOL) SendMessage (TTM_ADDTOOL, 0, (LPARAM) &amp;ti);
}
</pre></td></tr></table></p>

<P>With this infrastructure in place, creating a tool from a child window 
control&#8212;subclassing and all&#8212;requires just one simple statement:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_ctlTT.AddWindowTool (pWnd, _T (&quot;This is a window&quot;));
</pre></td></tr></table></p>

<P>Creating a tool from a rectangle in a window is equally simple:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_ctlTT.AddRectTool (pWnd, _T (&quot;This is a rectangle&quot;),
    CRect (32, 32, 64, 64), IDT_RECTANGLE);
</pre></td></tr></table></p>

<P>The <I>pWnd</I> parameter passed to 
<I>AddWindowTool</I> identifies the window the 
ToolTip will be applied to. The <I>pWnd</I> parameter passed to 
<I>AddRectTool</I> references the window whose client area contains the rectangle referenced in the third parameter. 
Because of the TTF_SUBCLASS flag passed in the 
<I>uFlags</I> field of the TOOLINFO structure, the ToolTip control will do its own window subclassing and mouse messages 
don't have to be relayed manually.</p>

<A NAME="500"><H3>Dynamic ToolTips</H3></A>

<P>If you specify LPSTR_TEXTCALLBACK for the ToolTip text when you call 
<I>AddTool</I>, <I>AddWindowTool</I>, or 
<I>AddRectTool</I>, the ToolTip control will send a notification to 
its parent requesting a text string before displaying a ToolTip. You can use 
LPSTR_TEXTCALLBACK to create dynamic ToolTips whose text varies from one 
invocation to the next. Text callbacks come in the form of WM_NOTIFY messages with a 
notification code equal to TTN_NEEDTEXT and 
<I>lParam</I> pointing to a structure of type TOOLTIPTEXT. TOOLTIPTEXT is defined as follows:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
typedef struct {
    NMHDR     hdr; 
    LPTSTR    lpszText; 
    char      szText[80]; 
    HINSTANCE hinst; 
    UINT      uFlags; 
} TOOLTIPTEXT;
</pre></td></tr></table></p>

<P>A ToolTip control's parent responds to TTN_NEEDTEXT notifications in one of 
three ways: by copying the address of a text string to the TOOLTIPTEXT structure's 
<I>lpszText</I> field; by copying the text (as many as 80 characters, including the zero 
terminator) directly to the structure's 
<I>szText</I> field; or by copying a string resource ID to 
<I>lpszText</I> and copying the application's instance handle, which an MFC application can 
obtain with <I>AfxGetInstanceHandle</I>, to 
<I>hinst</I>. The <I>idFrom</I> field of the NMHDR structure 
that's nested inside the TOOLTIPTEXT structure contains either a window handle or 
an application-defined tool ID identifying the tool for which text is needed.</p>

<p>The following example demonstrates how to create a dynamic ToolTip for 
a rectangular region of a dialog box. The rectangle's application-defined tool ID 
is IDT_RECTANGLE, and the text displayed in the ToolTip window is the current time:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
// In the message map
ON_NOTIFY (TTN_NEEDTEXT, NULL, OnNeedText)
    <img src="images/grayvellip.JPG" width=3 height=13 border="0">
BOOL CMyDialog::OnInitDialog ()
{
    m_ctlTT.Create (this);
    m_ctlTT.AddRectTool (this, LPSTR_TEXTCALLBACK,
        CRect (0, 0, 32, 32), IDT_RECTANGLE);
    return TRUE;
}

void CMyDialog::OnNeedText (NMHDR* pnmh, LRESULT* pResult)
{
    TOOLTIPTEXT* pttt = (TOOLTIPTEXT*) pnmh;
    if (pttt-&gt;hdr.idFrom == IDT_RECTANGLE) {
        CString string;
        CTime time = CTime::GetCurrentTime ();
        string.Format (_T (&quot;%0.2d:%0.2d:%0.2d&quot;), time.GetHour () % 12,
            time.GetMinute (), time.GetSecond ());
        ::lstrcpy (pttt-&gt;szText, (LPCTSTR) string);
    }
}
</pre></td></tr></table></p>

<P>Notice the NULL child window ID specified in the second parameter to the 
ON_NOTIFY macro in <I>CMyDialog</I>'s message map. This parameter must be NULL 
because <I>CToolTipCtrl::Create</I> registers a NULL child window ID for ToolTip controls.</p>

<p>MFC's <I>CToolTipCtrl</I> class includes an assortment of member functions you 
can use to operate on ToolTip controls. For example, you can use 
<I>GetText</I> to retrieve the text assigned to a tool, 
<I>UpdateTipText</I> to change ToolTip text, 
<I>Activate</I> to activate and deactivate a ToolTip control, and 
<I>SetDelayTime</I> to change the delay time&#8212;the 
number of milliseconds the cursor must remain motionless before a ToolTip is 
displayed. The default delay time is 500 milliseconds.</p>

<A NAME="501"><H2>The GridDemo Application</H2></A>

<P>The GridDemo application, whose source code appears in Figure 16-6, provides 
a practical demonstration of slider controls, spin button controls, and ToolTip 
controls. GridDemo divides a frame window's client area into a grid by drawing 
intersecting horizontal and vertical lines. By default, the grid contains 8 rows and 8 columns 
and grid lines are drawn in a medium shade of gray. You can vary the number of 
rows and columns as well as the darkness of the grid lines by choosing Grid Settings 
from the Options menu and entering the new settings in the dialog box shown in 
Figure 16-5. The slider control selects the line weight, and the values entered into the 
edit controls control the numbers of rows and columns. Valid values range from 2 
through 64; you can type in the numbers or use the arrow buttons. When the cursor 
pauses over the slider or either of the edit controls, a ToolTip window appears with a 
short description of the tool underneath.</p>

<p>
<img src="images/F16mg05.GIF" width=300 height=235 border=0>
</p><p>
<!-- CAPTION --><B>Figure 16-5.</B> <I>GridDemo's Settings dialog box with a ToolTip displayed.</I><!-- /CAPTION -->
</p>

<P><B>Figure 16-6.</B> <I>The GridDemo application.</I></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="502"><H3>ChildView.h</H3></A>
<pre>
// ChildView.h : interface of the CChildView class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(
    AFX_CHILDVIEW_H__A4559BAA_ABE5_11D2_8E53_006008A82731__INCLUDED_)

#define AFX_CHILDVIEW_H__A4559BAA_ABE5_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

///////////////////////////////////////////////////////////////////////////
// CChildView window

class CChildView : public CWnd
{
// Construction
public:
    CChildView();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChildView)
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CChildView();

    // Generated message map functions
protected:
    int m_nWeight;
    int m_cy;
    int m_cx;
    //{{AFX_MSG(CChildView)
    afx_msg void OnPaint();
    afx_msg void OnOptionsGridSettings();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//     AFX_CHILDVIEW_H__A4559BAA_ABE5_11D2_8E53_006008A82731__INCLUDED_)
</pre></td></tr></table></p>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="503"><H3>ChildView.cpp</H3></A>
<pre>
// ChildView.cpp : implementation of the CChildView class
//

#include &quot;stdafx.h&quot;
#include &quot;GridDemo.h&quot;
#include &quot;ChildView.h&quot;
#include &quot;SettingsDialog.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CChildView

CChildView::CChildView()
{
    m_cx = 8;
    m_cy = 8;
    m_nWeight = 4;
}

CChildView::~CChildView()
{
}

BEGIN_MESSAGE_MAP(CChildView,CWnd )
    //{{AFX_MSG_MAP(CChildView)
    ON_WM_PAINT()
    ON_COMMAND(ID_OPTIONS_GRID_SETTINGS, OnOptionsGridSettings)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CChildView message handlers

BOOL CChildView::PreCreateWindow(CREATESTRUCT&amp; cs) 
{
    if (!CWnd::PreCreateWindow(cs))
        return FALSE;

    cs.dwExStyle |= WS_EX_CLIENTEDGE;
    cs.style &amp;= ~WS_BORDER;
    cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW|CS_VREDRAW|CS_DBLCLKS, 
        ::LoadCursor(NULL, IDC_ARROW), HBRUSH(COLOR_WINDOW+1), NULL);

    return TRUE;
}

void CChildView::OnPaint() 
{
    CRect rect;
    GetClientRect (&amp;rect);

    int nShade = m_nWeight * 32;
    if (nShade != 0)
        nShade- -;

    CPaintDC dc (this);
    CPen pen (PS_SOLID, 1, RGB (nShade, nShade, nShade));
    CPen* pOldPen = dc.SelectObject (&amp;pen);

    int x;
    for (int i=1; i&lt;m_cx; i++) {
        x = (rect.Width () * i) / m_cx;
        dc.MoveTo (x, 0);
        dc.LineTo (x, rect.Height ());
    }

    int y;
    for (i=1; i&lt;m_cy; i++) {
        y = (rect.Height () * i) / m_cy;
        dc.MoveTo (0, y);
        dc.LineTo (rect.Width (), y);
    }

    dc.SelectObject (pOldPen);
}

void CChildView::OnOptionsGridSettings() 
{
    CSettingsDialog dlg;

    dlg.m_cx = m_cx;
    dlg.m_cy = m_cy;
    dlg.m_nWeight = m_nWeight;

    if (dlg.DoModal () == IDOK) {
        m_cx = dlg.m_cx;
        m_cy = dlg.m_cy;
        m_nWeight = dlg.m_nWeight;
        Invalidate ();
    }
}
</pre></td></tr></table></p>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="504"><H3>SettingsDialog.h</H3></A>
<pre>
#if !defined(
    AFX_SETTINGSDIALOG_H__A4559BB0_ABE5_11D2_8E53_006008A82731__INCLUDED_)
#define 
    AFX_SETTINGSDIALOG_H__A4559BB0_ABE5_11D2_8E53_006008A82731__INCLUDED_

#include &quot;MyToolTipCtrl.h&quot;    // Added by ClassView
#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// SettingsDialog.h : header file
//

///////////////////////////////////////////////////////////////////////////
// CSettingsDialog dialog

class CSettingsDialog : public CDialog
{
// Construction
public:
    int m_nWeight;
    CSettingsDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(CSettingsDialog)
    enum { IDD = IDD_SETTINGDLG };
    CSpinButtonCtrl    m_wndSpinVert;
    CSpinButtonCtrl    m_wndSpinHorz;
    CSliderCtrl    m_wndSlider;
    int        m_cx;
    int        m_cy;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSettingsDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    CMyToolTipCtrl m_ctlTT;
    // Generated message map functions
    //{{AFX_MSG(CSettingsDialog)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//   AFX_SETTINGSDIALOG_H__A4559BB0_ABE5_11D2_8E53_006008A82731__INCLUDED_)
</pre></td></tr></table></p>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="505"><H3>SettingsDialog.cpp</H3></A>
<pre>
// SettingsDialog.cpp : implementation file
//

#include &quot;stdafx.h&quot;
#include &quot;GridDemo.h&quot;
#include &quot;MyToolTipCtrl.h&quot;
#include &quot;SettingsDialog.h&quot;
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CSettingsDialog dialog

CSettingsDialog::CSettingsDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CSettingsDialog::IDD, pParent)
{
    //{{AFX_DATA_INIT(CSettingsDialog)
    m_cx = 0;
    m_cy = 0;
    //}}AFX_DATA_INIT
}

void CSettingsDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSettingsDialog)
    DDX_Control(pDX, IDC_SPINVERT, m_wndSpinVert);
    DDX_Control(pDX, IDC_SPINHORZ, m_wndSpinHorz);
    DDX_Control(pDX, IDC_SLIDER, m_wndSlider);
    DDX_Text(pDX, IDC_EDITHORZ, m_cx);
    DDX_Text(pDX, IDC_EDITVERT, m_cy);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CSettingsDialog, CDialog)
    //{{AFX_MSG_MAP(CSettingsDialog)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CSettingsDialog message handlers

BOOL CSettingsDialog::OnInitDialog() 
{
    CDialog::OnInitDialog();

    //
    // Initialize the slider control.
    //
    m_wndSlider.SetRange (0, 8);    
    m_wndSlider.SetPos (m_nWeight);

    //
    // Initialize the spin button controls.
    //
    m_wndSpinHorz.SetRange (2, 64);
    m_wndSpinVert.SetRange (2, 64);

    //
    // Create and initialize a tooltip control.
    //
    m_ctlTT.Create (this);
    m_ctlTT.AddWindowTool (GetDlgItem (IDC_SLIDER),
        MAKEINTRESOURCE (IDS_SLIDER));
    m_ctlTT.AddWindowTool (GetDlgItem (IDC_EDITHORZ),
        MAKEINTRESOURCE (IDS_EDITHORZ));
    m_ctlTT.AddWindowTool (GetDlgItem (IDC_EDITVERT),
        MAKEINTRESOURCE (IDS_EDITVERT));
    return TRUE;
}

void CSettingsDialog::OnOK() 
{
    //
    // Read the slider control's thumb position 
    // before dismissing the dialog.
    //
    m_nWeight = m_wndSlider.GetPos ();
    CDialog::OnOK();
}
</pre></td></tr></table></p>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="506"><H3>MyToolTipCtrl.h</H3></A>
<pre>
#if !defined(
    AFX_MYTOOLTIPCTRL_H__A4559BB1_ABE5_11D2_8E53_006008A82731__INCLUDED_)
#define 
    AFX_MYTOOLTIPCTRL_H__A4559BB1_ABE5_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// MyToolTipCtrl.h : header file
//

///////////////////////////////////////////////////////////////////////////
// CMyToolTipCtrl window

class CMyToolTipCtrl : public CToolTipCtrl
{
// Construction
public:
    CMyToolTipCtrl();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMyToolTipCtrl)
    //}}AFX_VIRTUAL

// Implementation
public:
    BOOL AddRectTool (CWnd* pWnd, LPCTSTR pszText, LPCRECT pRect, 
        UINT nIDTool);
    BOOL AddWindowTool (CWnd* pWnd, LPCTSTR pszText);
    virtual ~CMyToolTipCtrl();

    // Generated message map functions
protected:
    //{{AFX_MSG(CMyToolTipCtrl)
       // NOTE - the ClassWizard will add and remove member functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//    AFX_MYTOOLTIPCTRL_H__A4559BB1_ABE5_11D2_8E53_006008A82731__INCLUDED_)
</pre></td></tr></table></p>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="507"><H3>MyToolTipCtrl.cpp</H3></A>
<pre>
// MyToolTipCtrl.cpp : implementation file
//

#include &quot;stdafx.h&quot;
#include &quot;GridDemo.h&quot;
#include &quot;MyToolTipCtrl.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CMyToolTipCtrl

CMyToolTipCtrl::CMyToolTipCtrl()
{
}

CMyToolTipCtrl::~CMyToolTipCtrl()
{
}


BEGIN_MESSAGE_MAP(CMyToolTipCtrl, CToolTipCtrl)
    //{{AFX_MSG_MAP(CMyToolTipCtrl)
        // NOTE - the ClassWizard will add and remove mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CMyToolTipCtrl message handlers

BOOL CMyToolTipCtrl::AddWindowTool(CWnd *pWnd, LPCTSTR pszText)
{
    TOOLINFO ti;
    ti.cbSize = sizeof (TOOLINFO);
    ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
    ti.hwnd = pWnd-&gt;GetParent ()-&gt;GetSafeHwnd ();
    ti.uId = (UINT) pWnd-&gt;GetSafeHwnd ();
    ti.hinst = AfxGetInstanceHandle ();
    ti.lpszText = (LPTSTR) pszText;
    return (BOOL) SendMessage (TTM_ADDTOOL, 0, (LPARAM) &amp;ti);
}

BOOL CMyToolTipCtrl::AddRectTool(CWnd *pWnd, LPCTSTR pszText, 
    LPCRECT pRect, UINT nIDTool)
{
    TOOLINFO ti;
    ti.cbSize = sizeof (TOOLINFO);
    ti.uFlags = TTF_SUBCLASS;
    ti.hwnd = pWnd-&gt;GetSafeHwnd ();
    ti.uId = nIDTool;
    ti.hinst = AfxGetInstanceHandle ();
    ti.lpszText = (LPTSTR) pszText;
    ::CopyRect (&amp;ti.rect, pRect);

    return (BOOL) SendMessage (TTM_ADDTOOL, 0, (LPARAM) &amp;ti);
}
</pre></td></tr></table></p>

<P>The ToolTip control is an instance of <I>CMyToolTipCtrl</I>. Rather than hardcode the ToolTip text into the calls to 
<I>AddWindowTool</I>, I elected to put the text in the application's string table. String 
resources are identified by their resource IDs. In the calls to 
<I>AddWindowTool</I>, IDS_SLIDER, IDS_EDITHORZ, and IDS_EDITVERT are the resource IDs:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_ctlTT.AddWindowTool (GetDlgItem (IDC_SLIDER),
    MAKEINTRESOURCE (IDS_SLIDER));
m_ctlTT.AddWindowTool (GetDlgItem (IDC_EDITHORZ),
    MAKEINTRESOURCE (IDS_EDITHORZ));
m_ctlTT.AddWindowTool (GetDlgItem (IDC_EDITVERT),
    MAKEINTRESOURCE (IDS_EDITVERT));
</pre></td></tr></table></p>

<P>You can see the text associated with these resource IDs by opening the project, 
switching to ResourceView, and viewing the string table.</p>

<p>The slider and spin button controls are part of the dialog template and are 
programmed using <I>CSliderCtrl</I> and 
<I>CSpinButtonCtrl</I> member functions. The slider's 
range and initial position are set in 
<I>OnInitDialog</I>, and the final thumb position is 
retrieved in <I>OnOK</I>. The spin buttons' ranges are also initialized in 
<I>OnInitDialog</I>, but their positions don't have to be explicitly set or retrieved because the edit controls that 
the spin buttons are buddied to are served by Dialog Data Exchange (DDX) and 
Dialog Data Validation (DDV) routines.</p>

<p>Speaking of DDX and DDV: With few exceptions, MFC doesn't provide 
DDX routines to move data between common controls and dialog data members or 
DDV routines to validate input to common controls. When you use only classic controls 
in a dialog, you frequently don't have to override 
<I>OnInitDialog</I> and <I>OnOK</I> because you (or ClassWizard) can populate 
<I>DoDataExchange</I> with statements that transfer 
data between the dialog's member variables and its controls. When you use 
common controls, however, it's up to you to initialize the controls and perform data 
exchanges. That's why 
<I>CSettingsDialog::OnInitDialog</I> contains these statements:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndSlider.SetRange (0, 8);    
m_wndSlider.SetPos (m_nWeight);
    <img src="images/grayvellip.JPG" width=3 height=13 border="0">
m_wndSpinHorz.SetRange (2, 64);
m_wndSpinVert.SetRange (2, 64);
</pre></td></tr></table></p>

<P>And <I>CSettingsDialog::OnOK</I> contains this one:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_nWeight = m_wndSlider.GetPos ();
</pre></td></tr></table></p>

<P>These statements do what DDX would have done had it been supported. 
(Interestingly enough, MFC 6 includes a 
<I>DDX_Slider</I> function that performs DDX on 
slider controls, but it's fatally flawed because it initializes a slider with a position but not 
a range. Try it and you'll see what I mean.)<I> 
m_wndSlider</I> is a <I>CSliderCtrl</I> member 
variable that I added to the dialog class with ClassWizard. 
<I>m_wndSpinHorz</I> and <I>m_wndSpinVert</I> are 
<I>CSpinButtonCtrl</I> member variables; I added them with ClassWizard 
as well. All three are linked to controls in the dialog via 
<I>DDX_Control</I> statements in 
<I>DoDataExchange</I>.</p>

<P>Because GridDemo doesn't create a logical palette with shades of gray 
representing the different line weight settings, the full range of line weights isn't visible 
on 16-color and 256-color video adapters. As an exercise, you might try adding 
palette support by adding a <I>CPalette</I> data member to the frame window and 
using PALETTERGB or PALETTEINDEX colors to draw the grid lines. Refer to Chapter 
15 for more information on GDI palettes and MFC's 
<I>CPalette</I> class.</p>

</BODY>
</HTML>




