<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Putting It All Together: The Widget Application</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch19d.htm", "ch20a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="606"><H1>Putting It All Together: The Widget Application</H1></A>

<P>The application shown in Figure 19-3 demonstrates one way to apply the concepts, principles, and code fragments presented in this chapter to the real world. Widget creates triangular &quot;widgets&quot; of various colors in response to commands on the Insert menu. You can transfer widgets to and from the OLE clipboard using the commands on the Edit menu. Before you can use the Cut and Copy commands, you must select a widget by clicking it. The widget will turn green to indicate that it is in a selected state. You can also move and copy widgets using OLE drag-and-drop. If you hold down the Ctrl key when a drop is performed, the widget is copied; otherwise, it's moved. For a graphical demonstration of OLE drag-and-drop in action, run two instances of Widget side by side and drag widgets back and forth between them.</P>

<P>
<A HREF="javascript:fullSize('F19mg03x.htm')"> <img src="images/F19mg03.JPG" width=404 height=319 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 19-3.</B> <I>The Widget window.</I><!-- /CAPTION -->
</p>

<P>Figure 19-4 shows the pertinent parts of Widget's source code. WidgetView.cpp contains most of the good stuff, including the handlers for the Cut, Copy, and Paste commands. It also contains the overridden versions of <I>OnDragEnter</I>, <I>OnDragOver</I>, <I>OnDragLeave</I>, and <I>OnDrop</I> as well as the code that initiates a drag-and-drop data transfer when the left mouse button is clicked. (See <I>OnLButtonDown</I>.) Widgets are transferred through global memory. Widget registers a private clipboard format for widgets and uses it in calls to <I>COleDataSource::CacheGlobalData</I> and <I>COleDataObject::GetGlobalData</I>. The ID is stored in the application object and retrieved using <I>CWidgetApp::GetClipboardFormat</I>.</P>

<P><B>Figure 19-4.</B> <I>The Widget application.</I></P>

<p><table cellpadding=5 width="95%"><tr><td>
<A NAME="607"><H3>Widget.h</H3></A>
<pre>
// Widget.h : main header file for the WIDGET application
//

#if !defined(AFX_WIDGET_H__02909A45_3F5C_11D2_AC89_006008A8274D__INCLUDED_)
#define AFX_WIDGET_H__02909A45_3F5C_11D2_AC89_006008A8274D__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#ifndef __AFXWIN_H__
    #error include `stdafx.h' before including this file for PCH
#endif

#include &quot;resource.h&quot;       // main symbols

///////////////////////////////////////////////////////////////////////////
// CWidgetApp:
// See Widget.cpp for the implementation of this class
//

class CWidgetApp : public CWinApp
{
public:
    UINT GetClipboardFormat ();
    CWidgetApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWidgetApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation
    //{{AFX_MSG(CWidgetApp)
    afx_msg void OnAppAbout();
       // NOTE - the ClassWizard will add and remove member functions here.
       //    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
protected:
    UINT m_nFormat;
};


///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(AFX_WIDGET_H__02909A45_3F5C_11D2_AC89_006008A8274D__INCLUDED_)
</pre>
</td></tr></table></p>

<p><table cellpadding=5 width="95%"><tr><td>
<A NAME="608"><H3>Widget.cpp</H3></A>
<pre>
// Widget.cpp : Defines the class behaviors for the application.
//

#include &quot;stdafx.h&quot;
#include &quot;Widget.h&quot;

#include &quot;MainFrm.h&quot;
#include &quot;WidgetDoc.h&quot;
#include &quot;WidgetView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CWidgetApp

BEGIN_MESSAGE_MAP(CWidgetApp, CWinApp)
    //{{AFX_MSG_MAP(CWidgetApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CWidgetApp construction

CWidgetApp::CWidgetApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

///////////////////////////////////////////////////////////////////////////
// The one and only CWidgetApp object

CWidgetApp theApp;

///////////////////////////////////////////////////////////////////////////
// CWidgetApp initialization

BOOL CWidgetApp::InitInstance()
{
    if (!AfxOleInit ()) {
        AfxMessageBox (_T (&quot;AfxOleInit failed&quot;));
        return FALSE;
    }

    SetRegistryKey(_T(&quot;Local AppWizard-Generated Applications&quot;));
    LoadStdProfileSettings();  // Load standard INI file 
                               // options (including MRU)

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    CSingleDocTemplate* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,
        RUNTIME_CLASS(CWidgetDoc),
        RUNTIME_CLASS(CMainFrame),       // main SDI frame window
        RUNTIME_CLASS(CWidgetView));
    AddDocTemplate(pDocTemplate);

    // Enable DDE Execute open
    EnableShellOpen();
    RegisterShellFileTypes(TRUE);

    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // The one and only window has been initialized, so show and update it.
    m_pMainWnd-&gt;ShowWindow(SW_SHOW);
    m_pMainWnd-&gt;UpdateWindow();

    // Enable drag/drop open
    m_pMainWnd-&gt;DragAcceptFiles();

    //
    // Register a private clipboard format for widgets.
    //
    m_nFormat = ::RegisterClipboardFormat (_T (&quot;Widget&quot;));
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CWidgetApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

///////////////////////////////////////////////////////////////////////////
// CWidgetApp message handlers

UINT CWidgetApp::GetClipboardFormat()
{
    return m_nFormat;
}
</pre>
</td></tr></table></p>

<p><table cellpadding=5 width="95%"><tr><td>
<A NAME="609"><H3>WidgetDoc.h</H3></A>
<pre>
// WidgetDoc.h : interface of the CWidgetDoc class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(
    AFX_WIDGETDOC_H__02909A4B_3F5C_11D2_AC89_006008A8274D__INCLUDED_)
#define AFX_WIDGETDOC_H__02909A4B_3F5C_11D2_AC89_006008A8274D__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
#include &quot;WidgetObj.h&quot;
typedef CTypedPtrArray&lt;CObArray, CWidget*&gt; CWidgetArray;

class CWidgetDoc : public CDocument
{
protected: // create from serialization only
    CWidgetDoc();
    DECLARE_DYNCREATE(CWidgetDoc)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWidgetDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive&amp; ar);
    virtual void DeleteContents();
    //}}AFX_VIRTUAL

// Implementation
public:
    BOOL RemoveWidget (int nIndex);
    int AddWidget (int x, int y, COLORREF color);
    CWidget* GetWidget (int nIndex);
    int GetWidgetCount ();
    virtual ~CWidgetDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:
    CWidgetArray m_arrWidgets;

// Generated message map functions
protected:
    //{{AFX_MSG(CWidgetDoc)
    afx_msg void OnInsertRedWidget();
    afx_msg void OnInsertBlueWidget();
    afx_msg void OnInsertYellowWidget();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//     AFX_WIDGETDOC_H__02909A4B_3F5C_11D2_AC89_006008A8274D__INCLUDED_)
</pre>
</td></tr></table></p>

<p><table cellpadding=5 width="95%"><tr><td>
<A NAME="610"><H3>WidgetDoc.cpp</H3></A>
<pre>
CWidgetDoc::~CWidgetDoc()
{
}

BOOL CWidgetDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;

    return TRUE;
}



///////////////////////////////////////////////////////////////////////////
// CWidgetDoc serialization

void CWidgetDoc::Serialize(CArchive&amp; ar)
{
    m_arrWidgets.Serialize (ar);
}

///////////////////////////////////////////////////////////////////////////
// CWidgetDoc diagnostics

#ifdef _DEBUG
void CWidgetDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CWidgetDoc::Dump(CDumpContext&amp; dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CWidgetDoc commands

void CWidgetDoc::DeleteContents() 
{
    int i = m_arrWidgets.GetSize ();
    while (i)
        delete m_arrWidgets[--i];
    m_arrWidgets.RemoveAll ();
    CDocument::DeleteContents();
}

int CWidgetDoc::GetWidgetCount()
{
    return m_arrWidgets.GetSize ();
}

CWidget* CWidgetDoc::GetWidget(int nIndex)
{
    if (nIndex &gt;= m_arrWidgets.GetSize ())
        return NULL;
    return (CWidget*) m_arrWidgets[nIndex];
}

int CWidgetDoc::AddWidget(int x, int y, COLORREF color)
{
    int nIndex = -1;
    CWidget* pWidget = NULL;

    try {
        pWidget = new CWidget (x, y, color);
        nIndex = m_arrWidgets.Add (pWidget);    
        SetModifiedFlag ();
    }
    catch (CMemoryException* e) {
        AfxMessageBox (_T (&quot;Out of memory&quot;));
        if (pWidget != NULL)
            delete pWidget;
        e-&gt;Delete ();
        return -1;
    }
    return nIndex;
}

BOOL CWidgetDoc::RemoveWidget(int nIndex)
{
    if (nIndex &gt;= m_arrWidgets.GetSize ())
        return FALSE;

    delete m_arrWidgets[nIndex];
    m_arrWidgets.RemoveAt (nIndex);
    return TRUE;
}

void CWidgetDoc::OnInsertBlueWidget() 
{
    AddWidget (10, 10, RGB (0, 0, 255));
    UpdateAllViews (NULL);
}

void CWidgetDoc::OnInsertRedWidget() 
{
    AddWidget (10, 10, RGB (255, 0, 0));
    UpdateAllViews (NULL);
}

void CWidgetDoc::OnInsertYellowWidget() 
{
    AddWidget (10, 10, RGB (255, 255, 0));
    UpdateAllViews (NULL);
}
</pre>
</td></tr></table></p>

<p><table cellpadding=5 width="95%"><tr><td>
<A NAME="611"><H3>WidgetView.h</H3></A>
<pre>
// WidgetView.h : interface of the CWidgetView class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(
    AFX_WIDGETVIEW_H__02909A4D_3F5C_11D2_AC89_006008A8274D__INCLUDED_)
#define AFX_WIDGETVIEW_H__02909A4D_3F5C_11D2_AC89_006008A8274D__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

typedef struct tagWIDGETINFO {
    int x;                // x coordinate of widget's upper left corner
    int y;                // y coordinate of widget's upper left corner
    int cx;                // Horizontal drag offset
    int cy;                // Vertical drag offset
    COLORREF color;        // The widget's color
} WIDGETINFO;

class CWidgetView : public CScrollView
{
protected: // create from serialization only
    CWidgetView();
    DECLARE_DYNCREATE(CWidgetView)

// Attributes
public:
    CWidgetDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWidgetView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject, 
        DWORD dwKeyState, CPoint point);
    virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject, 
        DWORD dwKeyState, CPoint point);
    virtual void OnDragLeave();
    virtual BOOL OnDrop(COleDataObject* pDataObject, 
        DROPEFFECT dropEffect, CPoint point);
    protected:
    virtual void OnInitialUpdate(); // called first time after construct
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CWidgetView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:
    CWidget* m_pTempWidget;
    CSize m_offset;
    CPoint m_pointLastImage;
    CPoint m_pointLastMsg;
    int m_nSel;
    COleDropTarget m_oleDropTarget;

// Generated message map functions
protected:
    //{{AFX_MSG(CWidgetView)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnEditCut();
    afx_msg void OnEditCopy();
    afx_msg void OnEditPaste();
    afx_msg void OnEditDelete();
    afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnKillFocus(CWnd* pNewWnd);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in WidgetView.cpp
inline CWidgetDoc* CWidgetView::GetDocument()
    { return (CWidgetDoc*)m_pDocument; }
#endif

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//     AFX_WIDGETVIEW_H__02909A4D_3F5C_11D2_AC89_006008A8274D__INCLUDED_)
</pre>
</td></tr></table></p>

<p><table cellpadding=5 width="95%"><tr><td>
<A NAME="612"><H3>WidgetView.cpp</H3></A>
<pre>
// WidgetView.cpp : implementation of the CWidgetView class
//

#include &quot;stdafx.h&quot;
#include &quot;Widget.h&quot;
#include &quot;WidgetDoc.h&quot;
#include &quot;WidgetView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CWidgetView

IMPLEMENT_DYNCREATE(CWidgetView, CScrollView)

BEGIN_MESSAGE_MAP(CWidgetView, CScrollView)
    //{{AFX_MSG_MAP(CWidgetView)
    ON_WM_CREATE()
    ON_WM_LBUTTONDOWN()
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_COMMAND(ID_EDIT_DELETE, OnEditDelete)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
    ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditDelete)
    ON_WM_SETFOCUS()
    ON_WM_KILLFOCUS()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CWidgetView construction/destruction

CWidgetView::CWidgetView()
{
}

CWidgetView::~CWidgetView()
{
}

BOOL CWidgetView::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    return CScrollView::PreCreateWindow(cs);
}
///////////////////////////////////////////////////////////////////////////
// CWidgetView drawing

void CWidgetView::OnDraw(CDC* pDC)
{
    CWidgetDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    int nCount = pDoc-&gt;GetWidgetCount ();
    if (nCount) {
        //
        // Draw all widgets.
        //
        for (int i=0; i&lt;nCount; i++)
            pDoc-&gt;GetWidget (i)-&gt;Draw (pDC);

        //
        // Draw the selected widget if this view has the input focus.
        //
        if (m_nSel != -1 &amp;&amp; CWnd::GetFocus () == this)
            pDoc-&gt;GetWidget (m_nSel)-&gt;DrawSelected (pDC);
    }
}

void CWidgetView::OnInitialUpdate()
{
    CScrollView::OnInitialUpdate();
    SetScrollSizes(MM_TEXT, CSize (1280, 1024));
    m_pTempWidget = NULL;
    m_nSel = -1;
}

///////////////////////////////////////////////////////////////////////////
// CWidgetView diagnostics

#ifdef _DEBUG
void CWidgetView::AssertValid() const
{
    CScrollView::AssertValid();
}

void CWidgetView::Dump(CDumpContext&amp; dc) const
{
    CScrollView::Dump(dc);
}

CWidgetDoc* CWidgetView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CWidgetDoc)));
    return (CWidgetDoc*)m_pDocument;
}
#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CWidgetView message handlers

DROPEFFECT CWidgetView::OnDragEnter(COleDataObject* pDataObject,
    DWORD dwKeyState, CPoint point) 
{
    CScrollView::OnDragEnter(pDataObject, dwKeyState, point);

    //
    // If a widget is available from the drop source, create a temporary
    // widget for drag imaging.
    //
    UINT nFormat = ((CWidgetApp*) AfxGetApp ())-&gt;GetClipboardFormat ();
    HGLOBAL hData = pDataObject-&gt;GetGlobalData (nFormat);

    if (hData != NULL) {
        WIDGETINFO* pWidgetInfo = (WIDGETINFO*) ::GlobalLock (hData);
        int x = point.x - pWidgetInfo-&gt;cx;
        int y = point.y - pWidgetInfo-&gt;cy;
        m_offset.cx = pWidgetInfo-&gt;cx;
        m_offset.cy = pWidgetInfo-&gt;cy;
        COLORREF color = pWidgetInfo-&gt;color;
        ::GlobalUnlock (hData);
        ::GlobalFree (hData);

        m_pTempWidget = new CWidget (x, y, color);
        m_pointLastImage.x = m_pointLastImage.y = -32000;
        m_pointLastMsg = point;

        //
        // Return DROPEFFECT_COPY if the Ctrl key is down, or 
        // DROPEFFECT_MOVE if it is not.
        //
        return (dwKeyState &amp; MK_CONTROL) ?
            DROPEFFECT_COPY : DROPEFFECT_MOVE;
    }
    //
    // The cursor isn't carrying a widget. Indicate that the drop target 
    // will not accept a drop.
    //
    m_pTempWidget = NULL;
    return DROPEFFECT_NONE;
}

DROPEFFECT CWidgetView::OnDragOver(COleDataObject* pDataObject,
    DWORD dwKeyState, CPoint point) 
{
    CScrollView::OnDragOver(pDataObject, dwKeyState, point);

    //
    // Return now if the object being dragged is not a widget.
    //
    if (m_pTempWidget == NULL)
        return DROPEFFECT_NONE;

    //
    // Convert the drag point to logical coordinates.
    //
    CClientDC dc (this);
    OnPrepareDC (&amp;dc);
    dc.DPtoLP (&amp;point);

    //
    // If the cursor has moved, erase the old drag image and 
    // draw a new one.
    //
    if (point != m_pointLastMsg) {
        CPoint pt (point.x - m_offset.cx, point.y - m_offset.cy);
        m_pTempWidget-&gt;DrawDragImage (&amp;dc, m_pointLastImage);
        m_pTempWidget-&gt;DrawDragImage (&amp;dc, pt);
        m_pointLastImage = pt;
        m_pointLastMsg = point;
    }

    //
    // Return DROPEFFECT_COPY if the Ctrl key is down, or DROPEFFECT_MOVE
    // if it is not.
    //
    return (dwKeyState &amp; MK_CONTROL) ?
        DROPEFFECT_COPY : DROPEFFECT_MOVE;
}

void CWidgetView::OnDragLeave() 
{
    CScrollView::OnDragLeave();

    //
    // Erase the last drag image and delete the temporary widget.
    //
    if (m_pTempWidget != NULL) {
        CClientDC dc (this);
        OnPrepareDC (&amp;dc);
        m_pTempWidget-&gt;DrawDragImage (&amp;dc, m_pointLastImage);
        delete m_pTempWidget;
        m_pTempWidget = NULL;
    }
}

BOOL CWidgetView::OnDrop(COleDataObject* pDataObject, 
    DROPEFFECT dropEffect, CPoint point) 
{
    CScrollView::OnDrop(pDataObject, dropEffect, point);

    //
    // Convert the drop point to logical coordinates.
    //
    CClientDC dc (this);
    OnPrepareDC (&amp;dc);
    dc.DPtoLP (&amp;point);

    //
    // Erase the last drag image and delete the temporary widget.
    //
    if (m_pTempWidget != NULL) {
        m_pTempWidget-&gt;DrawDragImage (&amp;dc, m_pointLastImage);
        delete m_pTempWidget;
        m_pTempWidget = NULL;
    }

    //
    // Retrieve the HGLOBAL from the data object and create a widget.
    //
    UINT nFormat = ((CWidgetApp*) AfxGetApp ())-&gt;GetClipboardFormat ();
    HGLOBAL hData = pDataObject-&gt;GetGlobalData (nFormat);

    if (hData != NULL) {
        WIDGETINFO* pWidgetInfo = (WIDGETINFO*) ::GlobalLock (hData);
        int x = point.x - pWidgetInfo-&gt;cx;
        int y = point.y - pWidgetInfo-&gt;cy;
        COLORREF color = pWidgetInfo-&gt;color;
        ::GlobalUnlock (hData);
        ::GlobalFree (hData);

        CWidgetDoc* pDoc = GetDocument ();
        m_nSel = pDoc-&gt;AddWidget (x, y, color);
        pDoc-&gt;UpdateAllViews (NULL);
        return TRUE;
    }
    return FALSE;
}

int CWidgetView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CScrollView::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    m_oleDropTarget.Register (this);    
    return 0;
}

void CWidgetView::OnLButtonDown(UINT nFlags, CPoint point) 
{
    CScrollView::OnLButtonDown(nFlags, point);

    CWidgetDoc* pDoc = GetDocument ();
    int nCount = pDoc-&gt;GetWidgetCount ();

    if (nCount) {
        //
        // Convert the click point to logical coordinates.
        //
        CClientDC dc (this);
        OnPrepareDC (&amp;dc);
        dc.DPtoLP (&amp;point);

        //
        // Find out whether a widget was clicked.
        //
        int i;
        BOOL bHit = FALSE;
        for (i=nCount - 1; i&gt;=0 &amp;&amp; !bHit; i--) {
            CWidget* pWidget = pDoc-&gt;GetWidget (i);
            if (pWidget-&gt;PtInWidget (point)) {
                bHit = TRUE;
            }
        }

        //
        // If no widget was clicked, change the selection to NULL and exit.
        //
        if (!bHit) {
            m_nSel = -1;
            InvalidateRect (NULL, FALSE);
            return;
        }
        //
        // Select the widget that was clicked.
        //
        int nWidgetIndex = i + 1;

        if (m_nSel != nWidgetIndex) {
            m_nSel = nWidgetIndex;
            InvalidateRect (NULL, FALSE);
            UpdateWindow ();
        }

        //
        // Begin a drag-and-drop operation involving the selected widget.
        //
        HANDLE hData = ::GlobalAlloc (GMEM_MOVEABLE, sizeof (WIDGETINFO));

        WIDGETINFO* pWidgetInfo = (WIDGETINFO*) ::GlobalLock (hData);
        CWidget* pWidget = pDoc-&gt;GetWidget (nWidgetIndex);
        ASSERT (pWidget != NULL);
        CRect rect = pWidget-&gt;GetRect ();
        pWidgetInfo-&gt;cx = point.x - rect.left;
        pWidgetInfo-&gt;cy = point.y - rect.top;
        pWidgetInfo-&gt;color = pWidget-&gt;GetColor ();
        ::GlobalUnlock (hData);

        COleDataSource ods;
        UINT nFormat = ((CWidgetApp*) AfxGetApp ())-&gt;GetClipboardFormat ();
        ods.CacheGlobalData (nFormat, hData);

        int nOldSel = m_nSel;
        DROPEFFECT de = ods.DoDragDrop (DROPEFFECT_COPY | DROPEFFECT_MOVE);

        if (de == DROPEFFECT_MOVE) {
            pDoc-&gt;RemoveWidget (nWidgetIndex);
            int nCount = pDoc-&gt;GetWidgetCount ();
            if (nOldSel == m_nSel || nCount == 0)
                m_nSel = -1;
            else if (m_nSel &gt;= nCount)
                m_nSel = nCount - 1;
            pDoc-&gt;UpdateAllViews (NULL);
        }
    }
}

void CWidgetView::OnEditCut() 
{
    if (m_nSel != -1) {
        OnEditCopy ();
        OnEditDelete ();
    }
}

void CWidgetView::OnEditCopy() 
{
    if (m_nSel != -1) {
        //
        // Copy data describing the currently selected widget to a
        // global memory block.
        //
        HANDLE hData = ::GlobalAlloc (GMEM_MOVEABLE, sizeof (WIDGETINFO));

        WIDGETINFO* pWidgetInfo = (WIDGETINFO*) ::GlobalLock (hData);
        CWidgetDoc* pDoc = GetDocument ();
        CWidget* pWidget = pDoc-&gt;GetWidget (m_nSel);
        ASSERT (pWidget != NULL);
        CRect rect = pWidget-&gt;GetRect ();
        pWidgetInfo-&gt;x = rect.left;
        pWidgetInfo-&gt;y = rect.top;
        pWidgetInfo-&gt;color = pWidget-&gt;GetColor ();
        ::GlobalUnlock (hData);

        //
        // Place the widget on the clipboard.
        //
        COleDataSource* pods = new COleDataSource;
        UINT nFormat = ((CWidgetApp*) AfxGetApp ())-&gt;GetClipboardFormat ();
        pods-&gt;CacheGlobalData (nFormat, hData);
        pods-&gt;SetClipboard ();
    }
}

void CWidgetView::OnEditPaste() 
{
    //
    // Create a COleDataObject and attach it to the clipboard.
    //
    COleDataObject odo;
    odo.AttachClipboard ();

    //
    // Retrieve the HGLOBAL from the clipboard and create a widget.
    //
    UINT nFormat = ((CWidgetApp*) AfxGetApp ())-&gt;GetClipboardFormat ();
    HGLOBAL hData = odo.GetGlobalData (nFormat);

    
	if (hData != NULL) {
        WIDGETINFO* pWidgetInfo = (WIDGETINFO*) ::GlobalLock (hData);
        int x = pWidgetInfo-&gt;x;
        int y = pWidgetInfo-&gt;y;
        COLORREF color = pWidgetInfo-&gt;color;
        ::GlobalUnlock (hData);
        ::GlobalFree (hData);

        CWidgetDoc* pDoc = GetDocument ();
        m_nSel = pDoc-&gt;AddWidget (x, y, color);
        pDoc-&gt;UpdateAllViews (NULL);
    }
}

void CWidgetView::OnEditDelete() 
{
    if (m_nSel != -1) {
        CWidgetDoc* pDoc = GetDocument ();
        pDoc-&gt;RemoveWidget (m_nSel);
        m_nSel = -1;
        pDoc-&gt;UpdateAllViews (NULL);
    }    
}

void CWidgetView::OnUpdateEditCut(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable (m_nSel != -1);    
}

void CWidgetView::OnUpdateEditCopy(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable (m_nSel != -1);    
}

void CWidgetView::OnUpdateEditPaste(CCmdUI* pCmdUI) 
{
    UINT nFormat = ((CWidgetApp*) AfxGetApp ())-&gt;GetClipboardFormat ();
    pCmdUI-&gt;Enable (::IsClipboardFormatAvailable (nFormat));    
}

void CWidgetView::OnUpdateEditDelete(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable (m_nSel != -1);    
}

void CWidgetView::OnKillFocus(CWnd* pNewWnd) 
{
    CScrollView::OnKillFocus(pNewWnd);
    InvalidateRect (NULL, FALSE);    
}

void CWidgetView::OnSetFocus(CWnd* pOldWnd) 
{
    CScrollView::OnSetFocus(pOldWnd);
    InvalidateRect (NULL, FALSE);    
}
</pre>
</td></tr></table></p>

<p><table cellpadding=5 width="95%"><tr><td>
<A NAME="613"><H3>WidgetObj.h</H3></A>
<pre>
#if !defined(
    AFX_WIDGETOBJ_H__02909A57_3F5C_11D2_AC89_006008A8274D__INCLUDED_)
#define AFX_WIDGETOBJ_H__02909A57_3F5C_11D2_AC89_006008A8274D__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// WidgetObj.h : header file
//

///////////////////////////////////////////////////////////////////////////
// CWidget command target

class CWidget : public CObject
{
    DECLARE_SERIAL(CWidget)

// Attributes
public:

// Operations
public:
    CWidget();
    CWidget (int x, int y, COLORREF color);
    virtual ~CWidget();
    void DrawSelected (CDC* pDC);
    BOOL PtInWidget (POINT point);
    virtual void DrawDragImage (CDC* pDC, POINT point);
    virtual void Draw (CDC* pDC);
    COLORREF GetColor ();
    CRect GetRect ();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CWidget)
	 //}}AFX_VIRTUAL
    virtual void Serialize (CArchive&amp; ar);

// Implementation
protected:
    COLORREF m_color;
    CRect m_rect;
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//     AFX_WIDGETOBJ_H__02909A57_3F5C_11D2_AC89_006008A8274D__INCLUDED_)
</pre>
</td></tr></table></p>

<p><table cellpadding=5 width="95%"><tr><td>
<A NAME="614"><H3>WidgetObj.cpp</H3></A>
<pre>
// WidgetObj.cpp : implementation file
//

#include &quot;stdafx.h&quot;
#include &quot;Widget.h&quot;
#include &quot;WidgetObj.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CWidget

IMPLEMENT_SERIAL(CWidget, CObject, 1)

CWidget::CWidget()
{
    m_rect = CRect (0, 0, 90, 90);
    m_color = RGB (255, 0, 0);
}
CWidget::CWidget (int x, int y, COLORREF color)
{
    m_rect = CRect (x, y, x + 90, y + 90);
    m_color = color;
}

CWidget::~CWidget()
{
}

///////////////////////////////////////////////////////////////////////////
// CWidget message handlers

CRect CWidget::GetRect()
{
    return m_rect;
}

COLORREF CWidget::GetColor()
{
    return m_color;
}

void CWidget::Serialize (CArchive&amp; ar)
{
    CObject::Serialize (ar);

    if (ar.IsStoring ())
        ar &lt;&lt; m_rect &lt;&lt; m_color;
    else 
        ar &gt;&gt; m_rect &gt;&gt; m_color;
}

void CWidget::Draw(CDC *pDC)
{
    CBrush brush (m_color);
    CBrush* pOldBrush = pDC-&gt;SelectObject (&amp;brush);

    CPoint points[3];
    points[0].x = m_rect.left;
    points[0].y = m_rect.bottom;
    points[1].x = m_rect.left + (m_rect.Width () / 2);
    points[1].y = m_rect.top;
    points[2].x = m_rect.right;
    points[2].y = m_rect.bottom;
    pDC-&gt;Polygon (points, 3);

    pDC-&gt;SelectObject (pOldBrush);
}

void CWidget::DrawSelected(CDC *pDC)
{
    CBrush brush (RGB (0, 255, 0));
    CBrush* pOldBrush = pDC-&gt;SelectObject (&amp;brush);

    CPoint points[3];
    points[0].x = m_rect.left;
    points[0].y = m_rect.bottom;
    points[1].x = m_rect.left + (m_rect.Width () / 2);
    points[1].y = m_rect.top;
    points[2].x = m_rect.right;
    points[2].y = m_rect.bottom;
    pDC-&gt;Polygon (points, 3);

    pDC-&gt;SelectObject (pOldBrush);
}

void CWidget::DrawDragImage(CDC *pDC, POINT point)
{
    int nOldMode = pDC-&gt;SetROP2 (R2_NOT);
    CBrush* pOldBrush = (CBrush*) pDC-&gt;SelectStockObject (NULL_BRUSH);

    CPoint points[3];
    points[0].x = point.x;
    points[0].y = point.y + m_rect.Height ();
    points[1].x = point.x + (m_rect.Width () / 2);
    points[1].y = point.y;
    points[2].x = point.x + m_rect.Width ();
    points[2].y = point.y + m_rect.Height ();
    pDC-&gt;Polygon (points, 3);

    pDC-&gt;SelectObject (pOldBrush);
    pDC-&gt;SetROP2 (nOldMode);
}

BOOL CWidget::PtInWidget(POINT point)
{
    if (!m_rect.PtInRect (point))
        return FALSE;

    int cx = min (point.x - m_rect.left, m_rect.right - point.x);
    return ((m_rect.bottom - point.y) &lt;= (2 * cx));
}
</pre>
</td></tr></table></p>

<P>Widgets are represented by objects of the <I>CWidget</I> class, whose source code is found in WidgetObj.h and WidgetObj.cpp. To derive <I>CWidget</I>, I used ClassWizard to derive from <I>CCmdTarget</I> and then manually edited the source code to change the base class to <I>CObject</I>. I also changed the DYNCREATE macros inserted by ClassWizard into SERIAL macros and overrode <I>CObject::Serialize</I> to make <I>CWidget</I> a serializable class. These tweaks reduced the document's <I>Serialize</I> function to one simple statement:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
m_arrWidgets.Serialize (ar);
</pre>
</td></tr></table></p>

<P><I>m_arrWidgets</I> is the <I>CWidgetDoc</I> member variable that stores <I>CWidget</I> pointers. A <I>CWidget</I> object is created when a command is selected from the Insert menu, when a widget is pasted from the clipboard, and when a widget is dropped over the Widget window.</P>

<P>The <I>CWidget</I> class has a pair of member functions named <I>Draw</I> and <I>DrawSelected</I> that draw a widget to an output device. <I>Draw</I> draws the widget in the unselected state; <I>DrawSelected</I> draws it in the selected state. The view's <I>OnDraw</I> code is a simple loop that retrieves <I>CWidget</I> pointers from the document one by one and asks each widget to draw itself. If the view has the input focus and a widget is currently selected (that is, if <I>CWidgetView::m_nSel</I> != -1), the selected widget is drawn again after all the other widgets are drawn:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
for (int i=0; i&lt;nCount; i++)
    pDoc-&gt;GetWidget (i)-&gt;Draw (pDC);
if (m_nSel != -1 &amp;&amp; CWnd::GetFocus () == this)
    pDoc-&gt;GetWidget (m_nSel)-&gt;DrawSelected (pDC);
	</pre>
</td></tr></table></p>

<P>Drawing the selected widget last ensures that it is always visible on top of the others.</P>

<P>Another <I>CWidget</I> drawing function, <I>DrawDragImage</I>, is used for drag imaging. As you drag a widget across the screen, notice the triangular outline that follows the cursor. That's drag imaging. The operating system shell uses drag images for a similar effect when file system objects are dragged. Because the drop source is responsible for displaying the cursor during a drag-and-drop operation, programmers often assume that the drop source draws drag images by making them part of the cursor. That's generally not true. What really happens is that the drop target (not the drop source) draws the drag image in <I>OnDragOver</I>. For this to work, the drop target has to know what kind of payload the cursor is carrying so that it can draw an outline 
on the screen.</P>

<P>Widget handles drag imaging by creating a temporary widget object in <I>OnDragEnter</I>, caching the pointer in <I>CWidgetView::m_pTempWidget</I>, and calling the object's <I>DrawDragImage</I> function each time <I>OnDragOver</I> is called. Actually, <I>OnDragOver</I> calls <I>DrawDragImage</I> twice: once to erase the old drag image and once to draw a new one. <I>DrawDragImage</I> does its drawing in the R2_NOT drawing mode, so drawing a drag image on top of an old one effectively erases the old drag image. The position of the previous drag image is stored in <I>CWidgetView</I>'s <I>m_pointLastImage</I> data member. The temporary widget is deleted when <I>OnDragLeave</I> or <I>OnDrop</I> is called. This example demonstrates why overriding <I>OnDragLeave</I> is sometimes useful. In this case, <I>OnDragEnter</I> allocates a resource that must be freed even if a drop doesn't occur.</P>

<P>You can see drop target scrolling in action by dragging a widget and pausing within a few pixels of the view's lower or right border. After a brief delay, the view will begin scrolling and will continue scrolling until a drop occurs or the cursor moves away from the border. Drop target scrolling enables you to drop a widget in any part of the view without taking your finger off the mouse button to click a scroll bar. Again, drop target scrolling comes absolutely for free when the drop target is a <I>CScrollView</I>.</P>

<A NAME="615"><H2>The <I>AfxOleInit</I> Function</H2></A>
<P>When I used AppWizard to create the Widget project, I selected none of the OLE options in Step 3. When AppWizard is run this way, the generated source code doesn't include a call to the all-important <I>AfxOleInit</I> function, which initializes the OLE libraries. This function <I>must</I> be called before an MFC application touches COM or OLE in any way. Therefore, I added a call to <I>AfxOleInit</I> to the beginning of the application class's <I>InitInstance</I> function. This meant that I also had to add the statement</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
#include &lt;afxole.h&gt;
</pre>
</td></tr></table></p>

<P>to Stdafx.h. Otherwise, the call to <I>AfxOleInit</I> wouldn't have compiled.</P>

<P>I mention this because if you write an application that uses COM or OLE but you don't select one of the OLE options in AppWizard, you must add the <I>AfxOleInit</I> call and the statement that #includes Afxole.h manually. If you don't, your application will compile just fine, but calls to functions such as <I>COleDataSource::DoDragDrop</I> will fail. I once lost half a day of work wondering why my clipboard code wasn't working when, by all appearances, I had done everything right. Then I realized that I had forgotten to include these crucial statements in my source code. If you write an application and find that calls to <I>DoDragDrop</I> or other OLE functions mysteriously fail, make sure that <I>AfxOleInit</I> is called when the application starts up. You'll save yourself a lot of grief.</P>

</BODY>
</HTML>




