<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Serialization and the CArchive Class</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06b.htm", "ch07a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="168"><H1>Serialization and the <I>CArchive</I> Class</H1></A>
<P>Although MFC's <I>CFile</I> class makes reading and writing file data rather easy, most 
MFC applications don't interact with <I>CFile</I> objects directly. Instead, they do their 
reading and writing through <I>CArchive</I> objects that in turn use 
<I>CFile</I> functions to perform file I/O. MFC overloads the &lt;&lt; and &gt;&gt; operators used with 
<I>CArchive</I> to make serializing data to or from a 
<I>CArchive</I> simple. The most common reason for serializing to or 
from an archive is to save an application's persistent data to disk or to read it back again.</P>

<P>Serialization is an important concept in MFC programming because it is the 
basis for MFC's ability to open and save documents in document/view applications. As 
you'll learn in Chapter 9, when someone using a document/view application selects 
Open or Save from the application's File menu, MFC opens the file for reading or 
writing and passes the application a reference to a 
<I>CArchive</I> object. The application, in turn, serializes its persistent data to or from the archive and, by so doing, saves a 
complete document to disk or reads it back again. A document whose persistent data 
consists entirely of primitive data types or serializable objects can often be serialized with 
just a few lines of code. This is in contrast to the hundreds of lines that might be 
required if the application were to query the user for a file name, open the file, and do all 
the file I/O itself.</P>

<A NAME="169"><H2>Serialization Basics</H2></A>

<P>Assume that a <I>CFile</I> object named 
<I>file</I> represents an open file, that the file was 
opened with write access, and that you want to write a pair of integers named 
<I>a</I> and <I>b</I> to that file. One way to accomplish this is to call 
<I>CFile::Write</I> once for each integer:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
file.Write (&amp;a, sizeof (a));
file.Write (&amp;b, sizeof (b));
</pre>
</TD></TR></TABLE>
</P>

<P>An alternative method is to create a 
<I>CArchive</I> object, associate it with the 
<I>CFile</I> object, and use the &lt;&lt; operator to serialize the integers into the archive:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CArchive ar (&amp;file, CArchive::store);
ar &lt;&lt; a &lt;&lt; b;
</pre>
</TD></TR></TABLE>
</P>

<P><I>CArchive</I> objects can be used for reading, too. Assuming 
<I>file</I> once again represents an open file and that the file is open with read access, the following code 
snippet attaches a <I>CArchive</I> object to the file and reads, or 
<I>deserializes</I>, the integers from the file:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CArchive ar (&amp;file, CArchive::load);
ar &gt;&gt; a &gt;&gt; b;
</pre>
</TD></TR></TABLE>
</P>

<P>MFC allows a wide variety of primitive data types to be serialized this way, 
including BYTEs, WORDs, LONGs, DWORDs, floats, doubles, ints, unsigned ints, shorts, 
and chars.</P>

<P>MFC also overrides the &lt;&lt; and &gt;&gt; operators so that 
<I>CString</I>s and certain other nonprimitive data types represented by MFC classes can be serialized to or from 
an archive. If <I>string</I> is a <I>CString</I> object and 
<I>ar</I> is a <I>CArchive</I> object, writing the string 
to the archive is as simple as this:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
ar &lt;&lt; string;
</pre>
</TD></TR></TABLE>
</P>

<P>Turning the operator around reads the string from the archive:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
ar &gt;&gt; string;
</pre>
</TD></TR></TABLE>
</P>


<P>Classes that can be serialized this way include 
<I>CString</I>, <I>CTime</I>, <I>CTimeSpan</I>, 
<I>COleVariant</I>, <I>COleCurrency</I>, 
<I>COleDateTime</I>, <I>COleDateTimeSpan</I>, 
<I>CSize</I>, <I>CPoint</I>, and <I>CRect</I>. Structures of type SIZE, POINT, and RECT can be serialized, too.</P>

<P>Perhaps the most powerful aspect of MFC's serialization mechanism is the 
fact that you can create serializable classes of your own that work with 
<I>CArchive</I>'s insertion and extraction operators. And you don't have to do any operator overloading 
of your own to make it work. Why? Because MFC overloads the &lt;&lt; and &gt;&gt; 
operators for pointers to instances of classes derived from 
<I>CObject</I>.</P>

<P>To demonstrate, suppose you've written a drawing program that represents 
lines drawn by the user with instances of a class named 
<I>CLine</I>. Also suppose that <I>CLine</I> is a serializable class that derives, either directly or indirectly, from 
<I>CObject</I>. If <I>pLines</I> is an array of 
<I>CLine</I> pointers, <I>nCount</I> is an integer that holds the number of 
pointers in the array, and <I>ar</I> is a 
<I>CArchive</I> object, you could archive each and every 
<I>CLine</I> along with a count of the number of 
<I>CLine</I>s like this:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
ar &lt;&lt; nCount;
for (int i=0; i&lt;nCount; i++)
    ar &lt;&lt; pLines[i];
</pre>
</TD></TR></TABLE>
</P>

<P>Conversely, you could re-create the 
<I>CLine</I>s from the information in the archive 
and initialize <I>pLines</I> with <I>CLine</I> pointers with the statements</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
ar &gt;&gt; nCount;
for (int i=0; i&lt;nCount; i++)
    ar &gt;&gt; pLines[i];
</pre>
</TD></TR></TABLE>
</P>

<P>How do you write serializable classes like 
<I>CLine</I>? It's easy; the next section 
describes how.</P>

<P>If an error occurs as data is serialized to or from an archive, MFC throws 
an exception. The type of exception that's thrown depends on the nature of the 
error. If a serialization request fails because of a lack of memory (for example, if 
there's too little memory to create an instance of an object that's being deserialized from 
an archive), MFC throws a <I>CMemoryException</I>. If a request fails because of a file 
I/O error, MFC throws a <I>CFileException</I>. If any other error occurs, MFC throws a 
<I>CArchiveException</I>. If you'd like, you can supply 
<I>catch</I> handlers for exceptions of these 
types to enact your own special processing regimen if and when errors occur.</P>

<A NAME="170"><H2>Writing Serializable Classes</H2></A>

<P>For an object to support serialization, it must be an instance of a serializable 
class. You can write a serializable class by following these five steps:</P>

<OL>
<P><LI>     Derive the class, either directly or indirectly, from 
<I>CObject</I>.</LI></P>

<P><LI>     Include MFC's DECLARE_SERIAL macro in the class declaration. 
DECLARE_SERIAL accepts just one parameter: your class's name.</LI></P>
<P><LI>     Override the base class's 
<I>Serialize</I> function, and serialize the derived 
class's data members.</LI></P>
<P><LI>     If the derived class doesn't have a default constructor (one that takes 
no arguments), add one. This step is necessary because when an object 
is deserialized, MFC creates it on the fly using the default constructor 
and initializes the object's data members with values retrieved from the archive.</LI></P>
<P><LI>     In the class implementation, include MFC's IMPLEMENT_SERIAL 
macro. The IMPLEMENT_SERIAL macro takes three parameters: the class 
name, the name of the base class, and a schema number. The 
<I>schema number</I> is an integer value that amounts to a version number. You should 
change the schema number any time you modify the class's serialized data 
format. Versioning of serializable classes is discussed in the next section.</LI></P>
</OL>

<P>Suppose you've written a simple class named 
<I>CLine</I> to represent lines. The class has two 
<I>CPoint</I> data members that store the line's endpoints, and you'd like to 
add serialization support. Originally, the class declaration looks like this:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
class CLine
{
protected:
    CPoint m_ptFrom;
    CPoint m_ptTo;

public:
    CLine (CPoint from, CPoint to) { m_ptFrom = from; m_ptTo = to; }
};
</pre>
</TD></TR></TABLE>
</P>

<P>It's easy to make this class serializable. Here's how it looks after serialization 
support is added:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
class CLine : public CObject
{
DECLARE_SERIAL (CLine)

protected:
    CPoint m_ptFrom;
    CPoint m_ptTo;

public:
    CLine () {} // Required!
    CLine (CPoint from, CPoint to) { m_ptFrom = from; m_ptTo = to; }
    void Serialize (CArchive&amp; ar);
};
</pre>
</TD></TR></TABLE>
</P>


<P>The <I>Serialize</I> function looks like this:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
void CLine::Serialize (CArchive&amp; ar)
{
    CObject::Serialize (ar);
    if (ar.IsStoring ())
        ar &lt;&lt; m_ptFrom &lt;&lt; m_ptTo;
    else // Loading, not storing
        ar &gt;&gt; m_ptFrom &gt;&gt; m_ptTo;
}
</pre>
</TD></TR></TABLE>
</P>

<P>And somewhere in the class implementation the statement</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
IMPLEMENT_SERIAL (CLine, CObject, 1)
</pre>
</TD></TR></TABLE>
</P>


<P>appears. With these modifications, the class is fully serializable. The schema 
number is 1, so if you later add a persistent data member to 
<I>CLine</I>, you should bump the schema number up to 2 so that the framework can 
distinguish between <I>CLine</I> objects serialized to disk by different versions of your program. Otherwise, a version 1 
<I>CLine</I> on disk could be read into a version 2 
<I>CLine</I> in memory, with possibly disastrous consequences.</P>

<P>When an instance of this class is asked to serialize or deserialize itself, MFC 
calls the instance's <I>CLine::Serialize</I> function. Before serializing its own data 
members, <I>CLine::Serialize</I> calls 
<I>CObject::Serialize</I> to serialize the base class's data members.
In this example, the base class's <I>Serialize</I> function doesn't do anything, but that 
might not be the case if the class you're writing derives indirectly from 
<I>CObject</I>. After the call to the base class returns, 
<I>CLine::Serialize</I> calls 
<I>CArchive::IsStoring</I> to determine the direction of data flow. A nonzero return means data is being serialized into 
the archive; 0 means data is being serialized out. 
<I>CLine::Serialize</I> uses the return value to decide whether to write to the archive with the &lt;&lt; operator or to read from it 
using the &gt;&gt; operator.</P>
 
<A NAME="171"><H2>Versioning Serializable Classes: Versionable Schemas</H2></A>

<P>When you write a serializable class, MFC uses the schema number that you assign 
to enact a crude form of version control. MFC tags instances of the class with the 
schema number when it writes them to the archive, and when it reads them back, it 
compares the schema number recorded in the archive to the schema number of the objects 
of that type in use within the application. If the two numbers don't match, MFC 
throws a <I>CArchiveException</I> with 
<I>m_cause</I> equal to 
<I>CArchiveException::badSchema</I>. An unhandled exception of this type prompts MFC to display a message box with 
the warning &quot;Unexpected file format.&quot; By incrementing the schema number each 
time you revise an object's serialized storage format, you create an effective 
safeguard against inadvertent attempts to read an old version of an object stored on disk 
into a new version that resides in memory.</P> 

<P>One problem that frequently crops up in applications that use serializable 
classes is one of backward compatibility&#8212;that is, deserializing objects that were created 
with older versions of the application. If an object's persistent storage format changes 
from one version of the application to the next, you'll probably want the new version 
to be able to read both formats. But as soon as MFC sees the mismatched schema 
numbers, it throws an exception. Because of the way MFC is architected, there's no 
good way to handle the exception other than to do as MFC does and abort the 
serialization process.</P> 

<P>That's where versionable schemas come in. A versionable schema is simply 
a schema number that includes a VERSIONABLE_SCHEMA flag. This flag tells MFC 
that the application can handle multiple serialized data formats for a given class. It 
suppresses the <I>CArchiveException</I> and allows an application to respond intelligently 
to different schema numbers. An application that uses versionable schemas can 
provide the backward compatibility that users expect.</P>
 
<P>Writing a serializable class that takes advantage of MFC's versionable 
schema support involves two steps:</P> 
<OL>
<P><LI>   OR the value VERSIONABLE_SCHEMA into the schema number in 
the IMPLEMENT_SERIAL macro.</LI></P>

<P><LI>    Modify the class's 
<I>Serialize</I> function to call 
<I>CArchive::GetObjectSchema</I> when loading an object from an archive and adapt its deserialization 
routine accordingly. <I>GetObjectSchema</I> returns the schema number of the 
object that's about to be deserialized. </LI></P>
</OL>

<P>You need to be aware of a few rules when you use 
<I>GetObjectSchema</I>. First, it should be called only when an object is being deserialized. Second, it should 
be called before any of the object's data members are read from the archive. And 
third, it should be called only once. If called a second time in the context of the same 
call to <I>Serialize</I>, <I>GetObjectSchema</I> returns 
-1.</P>

<P>Let's say that in version 2 of your application, you decide to modify the 
<I>CLine</I> class by adding a member variable to hold a line color. Here's the revised 
class declaration:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
class CLine : public CObject
{
DECLARE_SERIAL (CLine)

protected:
    CPoint m_ptFrom;
    CPoint m_ptTo;
    COLORREF m_clrLine; // Line color (new in version 2)

public:
    CLine () {}
    CLine (CPoint from, CPoint to, COLORREF color)
        { m_ptFrom = from; m_ptTo = to; m_clrLine = color }
    void Serialize (CArchive&amp; ar);
};
</pre>
</TD></TR></TABLE>
</P>

<P>Because the line color is a persistent property (that is, a red line saved to an 
archive should still be red when it is read back), you want to modify 
<I>CLine::Serialize</I> to serialize 
<I>m_clrLine</I> in addition to <I>m_ptFrom</I> and 
<I>m_ptTo</I>. That means you should bump up 
<I>CLine</I>'s schema number to 2. The original class implementation invoked 
MFC's IMPLEMENT_SERIAL macro like this:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
IMPLEMENT_SERIAL (CLine, CObject, 1)
</pre>
</TD></TR></TABLE>
</P>

<P>In the revised class, however, IMPLEMENT_SERIAL should be called like this:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
IMPLEMENT_SERIAL (CLine, CObject, 2 &#166; VERSIONABLE_SCHEMA)
</pre>
</TD></TR></TABLE>
</P>

<P>When the updated program reads a <I>CLine</I> object whose schema number is 1, 
MFC won't throw a <I>CArchive</I> exception because of the VERSIONABLE_SCHEMA flag 
in the schema number. But it will know that the two schemas are different because 
the base schema number was increased from 1 to 2.</P>

<P>You're halfway there. The final step is to modify 
<I>CLine::Serialize</I> so that it deserializes a 
<I>CLine</I> differently depending on the value returned by 
<I>GetObjectSchema</I>. The original 
<I>Serialize</I> function looked like this:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
void CLine::Serialize (CArchive&amp; ar)
{
    CObject::Serialize (ar);
    if (ar.IsStoring ())
        ar &lt;&lt; m_ptFrom &lt;&lt; m_ptTo;
    else // Loading, not storing
        ar &gt;&gt; m_ptFrom &gt;&gt; m_ptTo;
}
</pre>
</TD></TR></TABLE>
</P>

<P>You should implement the new one like this:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
void CLine::Serialize (CArchive&amp; ar)
{
    CObject::Serialize (ar);
    if (ar.IsStoring ())
        ar &lt;&lt; m_ptFrom &lt;&lt; m_ptTo &lt;&lt; m_clrLine;
    else {
        UINT nSchema = ar.GetObjectSchema ();
        switch (nSchema) {
        case 1: // Version 1 CLine
            ar &gt;&gt; m_ptFrom &gt;&gt; m_ptTo;
            m_clrLine = RGB (0, 0, 0); // Default color
            break;
        case 2: // Version 2 CLine
            ar &gt;&gt; m_ptFrom &gt;&gt; m_ptTo &gt;&gt; m_clrLine;
            break;
        default: // Unknown version
            AfxThrowArchiveException (CArchiveException::badSchema);
            break;
        }
    }
}
</pre>
</TD></TR></TABLE>
</P>

<P>See how it works? When a <I>CLine</I> object is written 
<I>to</I> the archive, it's always formatted as a version 2 
<I>CLine</I>. But when a <I>CLine</I> is read 
<I>from</I> the archive, it's treated as a version 1 
<I>CLine</I> or a version 2 <I>CLine</I>, depending on the value returned by 
<I>GetObjectSchema</I>. If the schema number is 1, the object is read the old way and 
<I>m_clrLine</I> is set to a sensible default. If the schema number is 2, all of the object's data members, 
including <I>m_clrLine</I>, are read from the archive. Any other schema number results in a 
<I>CArchiveException</I> indicating that the version number is unrecognized. (If this occurs, 
you're probably dealing with buggy code or a corrupted archive.) If, in the future, you 
revise <I>CLine</I> again, you can bump the schema number up to 3 and add a 
<I>case</I> block for the new schema.</P>

<A NAME="172"><H2>How Serialization Works</H2></A>

<P>Looking under the hood to see what happens when data is serialized to or from 
an archive provides a revealing glimpse into both the operation and the 
architecture of MFC. MFC serializes primitive data types such as ints and DWORDs by 
copying them directly to the archive. To illustrate, here's an excerpt from the MFC 
source code file Arccore.cpp showing how the 
<I>CArchive</I> insertion operator for DWORDs is implemented:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CArchive&amp; CArchive::operator&lt;&lt;(DWORD dw)
{
    if (m_lpBufCur + sizeof(DWORD) &gt; m_lpBufMax)
        Flush();

    if (!(m_nMode &amp; bNoByteSwap))
        _AfxByteSwap(dw, m_lpBufCur);
    else
        *(DWORD*)m_lpBufCur = dw;

    m_lpBufCur += sizeof(DWORD);
    return *this;
}
</pre>
</TD></TR></TABLE>
</P>

<P>For performance reasons, <I>CArchive</I> objects store the data that is written to them 
in an internal buffer. <I>m_lpBufCur</I> points to the current location in that buffer. If the 
buffer is too full to hold another DWORD, it is flushed before the DWORD is copied to 
it. For a <I>CArchive</I> object that's attached to a 
<I>CFile</I>, <I>CArchive::Flush</I> writes the 
current contents of the buffer to the file.</P>

<P><I>CString</I>s, <I>CRect</I>s, and other nonprimitive data types formed from MFC 
classes are serialized differently. MFC serializes a 
<I>CString</I>, for example, by outputting a character count followed by the characters themselves. The writing is done 
with <I>CArchive::Write</I>. Here's an excerpt from Arccore.cpp that shows how a 
<I>CString</I> containing less than 255 characters is serialized:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CArchive&amp; AFXAPI operator&lt;&lt;(CArchive&amp; ar, const CString&amp; string)
{
      <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    if (string.GetData()-&gt;nDataLength &lt; 255)
    {
        ar &lt;&lt; (BYTE)string.GetData()-&gt;nDataLength;
    }
      <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    ar.Write(string.m_pchData,
        string.GetData()-&gt;nDataLength*sizeof(TCHAR));
    return ar;
}
</pre>
</TD></TR></TABLE>
</P>

<P><I>CArchive::Write</I> copies a specified chunk of data to the archive's internal buffer 
and flushes the buffer if necessary to prevent overflows. Incidentally, if a 
<I>CString</I> serialized into an archive with the &lt;&lt; operator contains Unicode characters, MFC writes 
a special 3-byte signature into the archive before the character count. This enables 
MFC to identify a serialized string's character type so that, if necessary, those 
characters can be converted to the format that a client expects when the string is 
deserialized from the archive. In other words, it's perfectly acceptable for a Unicode 
application to serialize a string and for an ANSI application to deserialize it, and vice versa.</P>

<P>The more interesting case is what happens when a 
<I>CObject</I> pointer is serialized into an archive. Here's the relevant code from Afx.inl:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
_AFX_INLINE CArchive&amp; AFXAPI operator&lt;&lt;(CArchive&amp; ar,
    const CObject* pOb)
    { ar.WriteObject(pOb); return ar; }
</pre>
</TD></TR></TABLE>
</P>

<P>As you can see, the &lt;&lt; operator calls 
<I>CArchive::WriteObject</I> and passes it the 
pointer that appears on the right side of the insertion operator&#8212;for example, the 
<I>pLine</I> in</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
ar &lt;&lt; pLine;
</pre>
</TD></TR></TABLE>
</P>

<P><I>WriteObject</I> ultimately calls the object's 
<I>Serialize</I> function to serialize the object's 
data members, but before it does, it writes additional information to the archive that 
identifies the class from which the object was created.</P>

<P>For example, suppose the object being serialized is an instance of 
<I>CLine</I>. The very first time it serializes a 
<I>CLine</I> to the archive, <I>WriteObject</I> inserts a 
<I>new class tag</I>&#8212;a 16-bit integer whose value is 
-1, or 0xFFFF&#8212;into the archive, followed by the 
object's 16-bit schema number, a 16-bit value denoting the number of characters in the 
class name, and finally the class name itself. 
<I>WriteObject</I> then calls the <I>CLine</I>'s 
<I>Serialize</I> function to serialize the 
<I>CLine</I>'s data members.</P>

<P>If a second <I>CLine</I> is written to the archive, 
<I>WriteObject</I> behaves differently. When it writes a new class tag to the archive, 
<I>WriteObject</I> adds the class name to an in-memory 
database (actually, an instance of 
<I>CMapPtrToPtr</I>) and assigns the class a unique identifier that is in reality an index into the database. If no other classes 
have been written to the archive, the first 
<I>CLine</I> written to disk is assigned an index of 
1. When asked to write a second <I>CLine</I> to the archive, 
<I>WriteObject</I> checks the database, sees that 
<I>CLine</I> is already recorded, and instead of writing redundant information 
to the archive, writes a 16-bit value that consists of the class index ORed with an 
<I>old class tag</I> (0x8000). It then calls the 
<I>CLine</I>'s <I>Serialize</I> function as before. Thus, the 
first instance of a class written to an archive is marked with a new class tag, a 
schema number, and a class name; subsequent instances are tagged with 16-bit values 
whose lower 15 bits identify a previously recorded schema number and class name.</P>

<P>Figure 6-2 shows a hex dump of an archive that contains two serialized 
version 1 <I>CLine</I>s. The <I>CLine</I>s were written to the archive with the following code fragment:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
// Create two CLines and initialize an array of pointers.
CLine line1 (CPoint (0, 0), CPoint (50, 50));
CLine line2 (CPoint (50, 50), CPoint (100, 0));
CLine* pLines[2] = { &amp;line1, &amp;line2 };
int nCount = 2;

// Serialize the CLines and the CLine count.
ar &lt;&lt; nCount;
for (int i=0; i&lt;nCount; i++)
    ar &lt;&lt; pLines[i];
</pre>
</TD></TR></TABLE>
</P>

<P>The hex dump is broken down so that each line in the listing represents one 
component of the archive. I've numbered the lines for reference. Line 1 contains the 
object count (2) written to the archive when the statement</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
ar &lt;&lt; nCount;
</pre>
</TD></TR></TABLE>
</P>

<P>was executed. Line 2 contains information written by 
<I>WriteObject</I> defining the <I>CLine</I> class. The first 16-bit value is the new class tag; the second is the class's schema 
number (1); and the third holds the length of the class name (5). The final 5 bytes on line 2
hold the class name (&quot;CLine&quot;). Immediately following the class information, in 
lines 3 through 6, is the first serialized 
<I>CLine</I>: four 32-bit values that specify, in order, 
the <I>x</I> component of the <I>CLine</I>'s 
<I>m_ptFrom</I> data member, the <I>y</I> component of 
<I>m_ptFrom</I>, the <I>x</I> component of 
<I>m_ptTo</I>, and the <I>y</I> component of 
<I>m_ptTo</I>. Similar information for the second 
<I>CLine</I> appears on lines 8 through 11, but in between&#8212;on line 
7&#8212;is a 16-bit tag that identifies the data that follows as a serialized 
<I>CLine</I>. <I>CLine</I>'s class index is 1 because it was the first class added to the archive. The 16-bit value 
0x8001 is the class index ORed with an old class tag.</P>

<P>
<A HREF="javascript:fullSize('F06mg02x.htm')"> <img src="images/F06mg02.JPG" width=404 height=166 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 6-2.</B> <I>Hex dump of an archive containing two CLines.</I><!-- /CAPTION -->
</p>

<P>So far, so good. It's not difficult to understand what goes into the archive. 
Now let's see what happens when the <I>CLine</I>s are read out of the archive.
Assume that the <I>CLine</I>s are deserialized with the following code:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
int nCount;
ar &gt;&gt; nCount;
CLine* pLines = new CLine[nCount];
for (int i=0; i&lt;nCount; i++)
    ar &gt;&gt; pLines[i];
</pre>
</TD></TR></TABLE>
</P>

<P>When the</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
ar &gt;&gt; nCount;
</pre>
</TD></TR></TABLE>
</P>


<P>statement is executed, <I>CArchive</I> reaches into the archive, retrieves 4 bytes, and 
copies them to <I>nCount</I>. That sets the stage for the 
<I>for</I> loop that retrieves <I>CLine</I>s from 
the archive. Each time the</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
ar &gt;&gt; pLines[i];
</pre>
</TD></TR></TABLE>
</P>

<P>statement is executed, the &gt;&gt; operator calls 
<I>CArchive::ReadObject</I> and passes in a NULL pointer. Here's the relevant code in Afx.inl:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
_AFX_INLINE CArchive&amp; AFXAPI operator&gt;&gt;(CArchive&amp; ar, CObject*&amp; pOb)
    { pOb = ar.ReadObject(NULL); return ar; }
_AFX_INLINE CArchive&amp; AFXAPI operator&gt;&gt;(CArchive&amp; ar,
    const CObject*&amp; pOb)
    { pOb = ar.ReadObject(NULL); return ar; }
</pre>
</TD></TR></TABLE>
</P>

<P><I>ReadObject</I> calls another <I>CArchive</I> function named 
<I>ReadClass</I> to determine what kind of object it's about to deserialize. The first time through the loop, 
<I>ReadClass</I> reads one word from the archive, sees that it's a new class tag, and proceeds to read 
the schema number and class name from the archive. 
<I>ReadClass</I> then compares the schema number obtained from the archive to the schema number stored in 
the <I>CRuntimeClass</I> structure associated with the class whose name was just 
retrieved. (The DECLARE_SERIAL and IMPLEMENT_SERIAL macros create a static 
<I>CRuntimeClass</I> structure containing important information about a class, including its name 
and schema number. MFC maintains a linked list of 
<I>CRuntimeClass</I> structures that can be searched to locate run-time information for a particular class.) If the schemas are 
the same, <I>ReadClass</I> returns the 
<I>CRuntimeClass</I> pointer to <I>ReadObject</I>. 
<I>ReadObject</I>, in turn, calls 
<I>CreateObject</I> through the 
<I>CRuntimeClass</I> pointer to create a new 
instance of the class and then calls the object's 
<I>Serialize</I> function to load the data from 
the archive into the object's data members. The pointer to the new class instance 
returned by <I>ReadClass</I> is copied to the location specified by the caller&#8212;in this case, the 
address of <I>pLines</I>[<I>i</I>].</P>

<P>As class information is read from the archive, 
<I>ReadObject</I> builds a class database in memory just as 
<I>WriteObject</I> does. When the second 
<I>CLine</I> is read from the archive, the 0x8001 tag preceding it tells 
<I>ReadClass</I> that it can get the 
<I>CRuntimeClass</I> pointer requested by 
<I>ReadObject</I> from the database.</P>

<P>That's basically what happens during the serialization process if all goes 
well. I've skipped many of the details, including the numerous error checks MFC 
performs and the special treatment given to NULL object pointers and multiple references 
to the same object.</P>

<P>What happens if the schema number read from the archive doesn't match 
the schema number stored in the corresponding 
<I>CRuntimeClass</I>? Enter versionable schemas. MFC first checks for a VERSIONABLE_SCHEMA flag in the schema 
number stored in the <I>CRuntimeClass</I>. If the flag is absent, MFC throws a 
<I>CArchiveException</I>. At that point, the serialization process is over; done; finis. There's 
very little you can do about it other than display an error message, which MFC will do 
for you if you don't catch the exception. If the VERSIONABLE_SCHEMA flag is 
present, however, MFC skips the call to 
<I>AfxThrowArchiveException</I> and stores the 
schema number where the application can retrieve it by calling 
<I>GetObjectSchema</I>. That's why VERSIONABLE_SCHEMA and 
<I>GetObjectSchema</I> are the keys that open the door 
to successful versioning of serializable classes.</P>

<A NAME="173"><H2>Serializing <I>CObjects</I></H2></A>
<P>I'll close this chapter with a word of advice regarding the serialization of 
<I>CObject</I>s. MFC overloads <I>CArchive</I>'s insertion and extraction operators for 
<I>CObject</I> pointers, but not for 
<I>CObject</I>s. That means this will work:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CLine* pLine = new CLine (CPoint (0, 0), CPoint (100, 50));
ar &lt;&lt; pLine;
</pre>
</TD></TR></TABLE>
</P>

<P>But this won't:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CLine line (CPoint (0, 0), CPoint (100, 50));
ar &lt;&lt; line;
</pre>
</TD></TR></TABLE>
</P>

<P>In other words, <I>CObject</I>s can be serialized by pointer but not by value. This 
normally isn't a problem, but it can be troublesome if you write serializable classes that 
use other serializable classes as embedded data members and you want to serialize 
those data members.</P>

<P>One way to serialize <I>CObject</I>s by value instead of by pointer is to do your 
serialization and deserialization like this:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
// Serialize.
CLine line (CPoint (0, 0), CPoint (100, 50));
ar &lt;&lt; &amp;line;

// Deserialize.
CLine* pLine;
ar &gt;&gt; pLine;
CLine line = *pLine; // Assumes CLine has a copy constructor.
delete pLine;
</pre>
</TD></TR></TABLE>
</P>

<P>The more common approach, however, is to call the other class's 
<I>Serialize</I> function directly, as demonstrated here:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
// Serialize.
CLine line (CPoint (0, 0), CPoint (100, 50));
line.Serialize (ar);

// Deserialize.
CLine line;
line.Serialize (ar);
</pre>
</TD></TR></TABLE>
</P>

<P>Although calling <I>Serialize</I> directly is perfectly legal, you should be aware that it 
means doing without versionable schemas for the object that is being serialized. When 
you use the &lt;&lt; operator to serialize an object pointer, MFC writes the object's 
schema number to the archive; when you call 
<I>Serialize</I> directly, it doesn't. If called to 
retrieve the schema number for an object whose schema is not recorded, 
<I>GetObjectSchema</I> will return -1 and the outcome of the deserialization process will depend on 
how gracefully <I>Serialize</I> handles unexpected schema numbers.</P>
</BODY>
</HTML>




