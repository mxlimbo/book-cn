<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>List Views</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch10d.htm", "ch10f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="318"><H1>List Views</H1></A>

<p>List views are similar to tree views in that they 
provide a powerful infrastructure for presenting complex collections of data to 
the user. But whereas tree views are ideal for depicting hierarchical 
relationships, list views are best suited for presenting &quot;flat&quot; 
collections of data, such as lists of file names. 
</p>
<p>
Like items in a tree view, items in a list view can 
include both text and images. In addition, items can have text-only 
<I>subitems</I> containing additional information about the 
associated items. The subitems are visible when the control is in 
&quot;report&quot; mode, which is one of four presentation styles that a list 
view supports. The other presentation styles are large icon mode, small icon 
mode, and list mode. You can see examples of all four presentation styles by 
starting the Windows Explorer and using the View menu to change the view in the 
right pane. The Large Icons command in the View menu corresponds to large icon 
mode, Small Icons corresponds to small icon mode, List corresponds to list mode, 
and Details corresponds to report mode. 
</p>

<A NAME="319"><H2>Initializing a List View</H2></A>

<p>MFC's <I>CListView</I> class is the 
base class for list views. <I>CListView</I> derives most of 
its functionality from list view controls, which, like tree view controls, are 
part of the common controls library. MFC wraps list view controls in the class <I>CListCtrl</I>. To program a list view, you call 
<I>CListView::GetListCtrl</I> to acquire a 
<I>CListCtrl</I> reference to the control that appears inside the list view, 
and then you call <I>CListCtrl</I> functions using the 
returned reference. 
</p>

<p>
When you derive from <I>CListView</I>, you'll almost always override 
<I>PreCreateWindow</I> in the derived class and apply one or more default 
styles to the view. The following table lists the styles that all list views 
support. Additional list view styles are available on systems running Internet 
Explorer 3.0 or later.</p>

<p><B>List View Styles</B></p>

<p><table cellpadding="5" width="95%">
<TR><TH valign="top"><i>Style</i></TH><TH valign="top"><i>Description</i></TH></TR>

<TR><TD valign="top">LVS_ICON </TD>   <TD valign="top">Selects large icon mode.</TD></TR>

<TR><TD valign="top">LVS_SMALLICON</TD>    <TD valign="top"> Selects small icon mode.</TD></TR>

<TR><TD valign="top">LVS_LIST </TD>   <TD valign="top"> Selects list mode.</TD></TR>

<TR><TD valign="top">LVS_REPORT </TD>    <TD valign="top">Selects report mode.</TD></TR>

<TR><TD valign="top">LVS_NOCOLUMNHEADER </TD>   <TD valign="top"> Removes the header control 
            that's normally displayed in report mode.</TD></TR>

<TR><TD valign="top">LVS_NOSORTHEADER </TD>   <TD valign="top"> Disables the LVN_COLUMNCLICK 
            notifications that are sent by default when a column header is 
            clicked in report mode.</TD></TR>

<TR><TD valign="top">LVS_ALIGNLEFT </TD>   <TD valign="top"> Aligns items along the left 
            border in large and small icon mode.</TD></TR>

<TR><TD valign="top">LVS_ALIGNTOP</TD>     <TD valign="top">Aligns items along the top 
            border in large and small icon mode.</TD></TR>

<TR><TD valign="top">LVS_AUTOARRANGE</TD>    <TD valign="top"> Automatically arranges items in 
            rows and columns in large and small icon mode.</TD></TR>

<TR><TD valign="top">LVS_EDITLABELS</TD>     <TD valign="top">Enables in-place label editing 
            notifications.</TD></TR>

<TR><TD valign="top">LVS_NOLABELWRAP </TD>   <TD valign="top"> Restricts labels to single lines 
            in large icon mode.</TD></TR>

<TR><TD valign="top">LVS_NOSCROLL </TD>   <TD valign="top"> Disables scrolling. Scrolling is 
            enabled by default.</TD></TR>

<TR><TD valign="top">LVS_OWNERDRAWFIXED</TD>     <TD valign="top">Specifies that the control's 
            owner will draw the items in response to WM_DRAWITEM messages.</TD></TR>

<TR><TD valign="top">LVS_SHAREIMAGELISTS </TD>   <TD valign="top"> Prevents a list view from 
            automatically deleting the image lists associated with it when the 
            view itself is deleted.</TD></TR>

<TR><TD valign="top">LVS_SINGLESEL </TD>   <TD valign="top"> Disables multiple-selection 
            support.</TD></TR>

<TR><TD valign="top">LVS_SHOWSELALWAYS </TD>  <TD valign="top">Specifies that the selected 
            items should always be highlighted. By default, the highlight is 
            removed when the view loses the input focus.</TD></TR>

<TR><TD valign="top">LVS_SORTASCENDING</TD>    <TD valign="top"> Specifies that items should be 
            sorted in ascending order (for example, A through Z).</TD></TR>

<TR><TD valign="top">LVS_SORTDESCENDING </TD>   <TD valign="top"> Specifies that items should be 
            sorted in descending order (for example, Z through 
A).</TD></TR>
</table>
</p>

<p>
Like a tree view control, a list view control is empty 
when it's first created. Initialization is a five-step process: 
</p>

<ol>
<p>
<li>Create a pair of image lists containing images for 
    the list view items. One image list contains &quot;large&quot; images used 
    in large icon mode; the other contains &quot;small&quot; images used in 
    small icon, list, and report modes. 
    <P></P>

<p>
</p>
<li>
Use <I>CListCtrl::SetImageList</I> to associate the image lists with the list 
    view control. Pass <I>SetImageList</I> an LVSIL_NORMAL 
    flag for the image list containing large images and an LVSIL_SMALL flag for 
    the image list containing small images. 
    <P></P>

<p>
</p>
<li>
Add columns to the list view control with 
<I>CListCtrl::InsertColumn</I>. The leftmost column 
    displays the items added to the control. The columns to the right display 
    subitems and are visible only in report mode. 
    <P></P>

<p>
</p>
<li>
Add items to the control with 
<I>CListCtrl::InsertItem</I>. 
    <P></P>

<p>
</p>
<li>
Assign text strings to the item's subitems with 
<I>CListCtrl::SetItemText</I>. 
    <P></P>
</li>
</ol>

<p>
This procedure isn't as difficult as it sounds. The 
following code fragment initializes a list view with items representing eight of 
the states in the United States. Each item consists of a label and an image. The 
label is the name of a state, and the image presumably shows a thumbnail 
rendition of the state's outline. Each item also contains a pair of subitems: a 
text string naming the state capital and a text string describing the state's 
land area. In report mode, the subitems appear in columns under headers labeled 
&quot;Capital&quot; and &quot;Area (sq. miles).&quot;</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td><pre>
static CString text[8][3] = {
    _T (&quot;Tennessee&quot;),        _T (&quot;Nashville&quot;),    _T (&quot;41,154&quot;),
    _T (&quot;Alabama&quot;),          _T (&quot;Montgomery&quot;),   _T (&quot;50,766&quot;),
    _T (&quot;Mississippi&quot;),      _T (&quot;Jackson&quot;),      _T (&quot;47,234&quot;),
    _T (&quot;Florida&quot;),          _T (&quot;Tallahassee&quot;),  _T (&quot;54,157&quot;),
    _T (&quot;Georgia&quot;),          _T (&quot;Atlanta&quot;),      _T (&quot;58,060&quot;),
    _T (&quot;Kentucky&quot;),         _T (&quot;Frankfort&quot;),    _T (&quot;39,674&quot;),
    _T (&quot;North Carolina&quot;),   _T (&quot;Raleigh&quot;),      _T (&quot;48,843&quot;),
    _T (&quot;South Carolina&quot;),   _T (&quot;Columbia&quot;),     _T (&quot;30,207&quot;)
};

// Assign image lists.
GetListCtrl ().SetImageList (&amp;ilLarge, LVSIL_NORMAL);
GetListCtrl ().SetImageList (&amp;ilSmall, LVSIL_SMALL);

// Add columns.
GetListCtrl ().InsertColumn (0, _T (&quot;State&quot;), LVCFMT_LEFT, 96);
GetListCtrl ().InsertColumn (1, _T (&quot;Capital&quot;), LVCFMT_LEFT, 96);
GetListCtrl ().InsertColumn (2, _T (&quot;Area (sq. miles)&quot;),
    LVCFMT_RIGHT, 96);

// Add items and subitems.
for (int i=0; i&lt;8; i++) {
    GetListCtrl ().InsertItem (i, (LPCTSTR) text[i][0], i);
    GetListCtrl ().SetItemText (i, 1, (LPCTSTR) text[i][1]);
    GetListCtrl ().SetItemText (i, 2, (LPCTSTR) text[i][2]);
}
</pre>
</td>
</tr>
</table>
</p>

<p>
The parameters passed to <I>InsertColumn</I> specify, in order, the column's 0-based index, the label 
that appears at the top of the column, the column's alignment (whether data 
displayed in the column is left justified, right justified, or centered), and 
the column width in pixels. You can base column widths on the widths of 
characters in the control font by using 
<I>CListCtrl::GetStringWidth</I> to convert text strings into pixel counts. 
The parameters passed to <I>InsertItem</I> specify the 
item's 0-based index, the item label, and the index of the corresponding images 
in the image lists. The parameters passed to <I>SetItemText</I> specify the item number, the subitem number, and the 
subitem text, in that order.</p>

<A NAME="320"><H2>Changing the Presentation Style</H2></A>

<p>When a list view is created, its presentation 
style&mdash;LVS_ICON, LVS_SMALLICON, LVS_LIST, or LVS_REPORT&mdash;determines 
whether it starts up in large icon mode, small icon mode, list mode, or report 
mode. The default presentation style is applied in <I>PreCreateWindow</I>. However, you can switch modes on the fly by changing 
the presentation style. The following statement switches a list view to small 
icon mode:</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td><pre>
ModifyStyle (LVS_TYPEMASK, LVS_SMALLICON);</pre>
</td>
</tr>
</table>
</p>

<p>Similarly, this statement switches the view to report 
mode:</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td><pre>
ModifyStyle (LVS_TYPEMASK, LVS_REPORT);</pre>
</td>
</tr>
</table>
</p>

<p><I>ModifyStyle</I> is a <I>CWnd</I> function that's handed down through inheritance to 
<I>CListView</I>. The first parameter passed to 
<I>ModifyStyle</I> specifies the style bits to turn off, and 
the second parameter specifies the style bits to turn on. LVS_TYPEMASK is a mask 
for all four presentation styles.</p>
<p>LVS_ICON, LVS_SMALLICON, LVS_LIST, and LVS_REPORT aren't 
true bit flags, so LVS_TYPEMASK also comes in handy when you query a list view 
to determine its current presentation style. The following code won't work:</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>// Wrong!
DWORD dwStyle = GetStyle ();
if (dwStyle &amp; LVS_ICON)
    // Large icon mode.
else if (dwStyle &amp; LVS_SMALLICON)
    // Small icon mode.
else if (dwStyle &amp; LVS_LIST)
    // List mode.
else if (dwStyle &amp; LVS_REPORT)
    // Report mode.</pre>
</td>
</tr>
</table>
</p>

<p>But this code will: 
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td><pre>
DWORD dwStyle = GetStyle () &amp; LVS_TYPEMASK;
if (dwStyle == LVS_ICON)
    // Large icon mode.
else if (dwStyle == LVS_SMALLICON)
    // Small icon mode.
else if (dwStyle == LVS_LIST)
    // List mode.
else if (dwStyle == LVS_REPORT)
    // Report mode.</pre>
</td>
</tr>
</table>
</p>

<p>This is the proper technique for determining the view 
type before updating menu items or other user interface objects that depend on 
the list view's presentation style.</p>

<A NAME="321"><H2>Sorting in a List View</H2></A>

<p>When a list view that lacks the LVS_NOCOLUMNHEADER style 
switches to report mode, it automatically displays a header control with 
buttonlike &quot;header items&quot; captioning each column. The user can change 
the column widths by dragging the vertical dividers separating the header items. 
(For a nice touch, you can retrieve the column widths with <I>CListCtrl::GetColumnWidth</I> before destroying a list view and save the 
widths in the registry. Restore the column widths the next time the list view is 
created, and the user's column width preferences will be persistent.) Unless a 
list view has the style LVS_NOSORTHEADER, clicking a header item sends an 
LVN_COLUMNCLICK notification to the list view's parent. The message's <I>lParam</I> points to an NM_LISTVIEW structure, and the 
structure's <I>iSubItem</I> field contains a 0-based index 
identifying the column that was clicked. 
</p>

<p>An application's usual response to an LVN_COLUMNCLICK 
notification is to call <I>CListCtrl::SortItems</I> to sort 
the list view items. Great, you say. Now I can create a list view that sorts, 
and I won't have to write the code to do the sorting. You do have to provide a 
callback function that the control's built-in sorting routine can call to 
compare a pair of arbitrarily selected items, but writing a comparison function 
is substantially less work than writing a full-blown bubble sort or quick sort 
routine. And the fact that the comparison function is application-defined means 
that you enjoy complete control over how the items in a list view control are 
lexically ordered. 
</p>

<p>
The bad news is that the comparison function receives 
just three parameters: the 32-bit <I>lParam</I> values of 
the two items being compared and an application-defined <I>lParam</I> value that equals the second parameter passed to <I>SortItems</I>. You can assign an item an <I>lParam</I> value in the call to 
<I>InsertItem</I> or 
in a separate call to 
<I>CListCtrl::SetItemData</I>. Unless 
an application maintains a private copy of each item's data and stores a value 
in <I>lParam</I> that allows the item's data to be 
retrieved, the comparison function can't possibly do its job. It's not difficult 
for an application to allocate its own per-item memory and stuff pointers into 
the items' 
<I>lParam</I>s, but it does complicate matters a 
bit because the memory must be deallocated, too. And an application that stores 
its own item data uses memory inefficiently if it assigns text strings to the 
list view's items and subitems because then the data ends up being stored in 
memory twice. You can avoid such wastefulness by specifying LPSTR_TEXTCALLBACK 
for the item and subitem text and providing text to the list view control in 
response to LVN_GETDISPINFO notifications. But this, too, complicates the 
program logic and means that the infrastructure required to support 
<I>CListCtrl::SortItems</I> isn't as simple as it first 
appears. In just a moment, we'll develop an application that implements sortable 
columns in a list view so that you can see firsthand how it's done. 
</p>

<A NAME="322"><H2>Hit-Testing in a List View</H2></A>

<p>You can respond to mouse clicks in a list view by 
processing NM_CLICK, NM_DBLCLK, NM_RCLICK, and NM_RDBLCLK notifications. Very 
often, the way you respond to these events will depend on what, if anything, was 
under the cursor when the click (or double-click) occurred. You can use 
<I>CListCtrl::HitTest</I> to perform hit-testing on the items 
in a list view. Given the coordinates of a point, 
<I>HitTest</I> returns the index of the item at that point or at -1 if the 
point doesn't correspond to an item.</p>
<p>The following code demonstrates how to process double 
clicks in a list view. The ON_NOTIFY_REFLECT entry in the message map reflects 
NM_DBLCLK notifications back to the list view. The NM_DBLCLK handler echoes the 
name of the item that was double-clicked to the debug output window using MFC's 
TRACE macro:</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td><pre>
// In CMyListView's message map
ON_NOTIFY_REFLECT (NM_DBLCLK, OnDoubleClick)
    <img src="images/grayvellip.JPG" width=3 height=13 border="0">  
void CMyListView::OnDoubleClick (NMHDR* pnmh, LRESULT* pResult)
{
    DWORD dwPos = ::GetMessagePos ();
    CPoint point ((int) LOWORD (dwPos), (int) HIWORD (dwPos));
    GetListCtrl ().ScreenToClient (&amp;point);

    int nIndex;
    if ((nIndex = GetListCtrl ().HitTest (point)) != -1) {
        CString string = GetListCtrl ().GetItemText (nIndex, 0);
        TRACE (_T (&quot;%s was double-clicked\n&quot;), string);
    }
    *pResult = 0;
}
</pre>
</td>
</tr>
</table>
</p>

<p>
NM_DBLCLK notifications don't include cursor 
coordinates, so the cursor position is retrieved with <I>::GetMessagePos</I>. The screen coordinates returned by 
<I>::GetMessagePos</I> are converted into client coordinates local to the 
list view and passed to 
<I>CListCtrl::HitTest</I>. If <I>HitTest</I> returns an item index, the index is used to 
retrieve the item's text. 
</p>

<A NAME="323"><H2>The WinDir Application</H2></A>

<p>The WinDir application pictured in Figure 10-8 is so 
named because its output is reminiscent of the MS-DOS DIR command, albeit in a 
graphical format. It uses a 
<I>CListView</I>-derived class 
named 
<I>CFileView</I> to display a list of all the files 
in a specified directory. You pick the directory by selecting the New Directory 
command from the File menu and entering a path name. After retrieving the path 
name that you entered, WinDir passes the path name to 
<I>CFileView::Refresh</I> to display the directory's contents. You can see 
this for yourself in FileView.cpp, which, along with other parts of WinDir's 
source code, is reproduced in Figure 10-9. 
</p>

<p>
<A HREF="javascript:fullSize('F10mg08x.htm')"> <img src="images/F10mg08.JPG" width=404 height=302 border=0 ALT="Click to view at full size."></A>
</p><p>
<!-- CAPTION --><B>Figure 10-8.</B> <I>The WinDir 
window.</I><!-- /CAPTION --> 
</p>

<p>
Here's a synopsis of how <I>CFileView</I> works. First, 
<I>CFileView::Refresh</I> 
builds a list of file names using 
<I>::FindFirstFile</I> 
and <I>::FindNextFile</I>. For each file that it 
identifies, <I>Refresh</I> adds an item to the list view by 
calling <I>CFileView::AddItem</I>. <I>AddItem</I>, in turn, allocates memory for an ITEMINFO data structure 
(defined in FileView.h); initializes the structure with the file's name, size, 
and date-and-time stamp; and adds an item to the list view whose <I>lParam</I> is the structure's address. Here's how it looks with 
error-checking code removed:</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>ITEMINFO* pItem;
pItem = new ITEMINFO;

pItem-&gt;strFileName = pfd-&gt;cFileName;
pItem-&gt;nFileSizeLow = pfd-&gt;nFileSizeLow;
pItem-&gt;ftLastWriteTime = pfd-&gt;ftLastWriteTime;

LV_ITEM lvi;
lvi.mask = LVIF_TEXT &brvbar; LVIF_IMAGE &brvbar; LVIF_PARAM; 
lvi.iItem = nIndex; 
lvi.iSubItem = 0; 
lvi.iImage = 0;
lvi.pszText = LPSTR_TEXTCALLBACK; 
lvi.lParam = (LPARAM) pItem;

GetListCtrl ().InsertItem (&amp;lvi);</pre>
</td>
</tr>
</table>
</p>

<p>
Notice the LPSTR_TEXTCALLBACK value specified in the 
LV_ITEM structure's 
<I>pszText</I> field. Rather than 
assign the item a text string, 
<I>AddItem</I> tells the 
list view, &quot;Call me back when you need a label for the item.&quot; It's not 
necessary to initialize the subitems because LPSTR_TEXTCALLBACK is the default 
for subitems.</p>

<p><b>Figure 10-9.</b> <i>The WinDir application.</i></p>
<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<A NAME="324"><H3>MainFrm.h</H3></A>
<pre>
// MainFrm.h : interface of the CMainFrame class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__18BD7B7C_95C6_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_MAINFRM_H__18BD7B7C_95C6_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

class CMainFrame : public CFrameWnd
{
    
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
       // NOTE - the ClassWizard will add and remove member functions here.
       //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(AFX_MAINFRM_H__18BD7B7C_95C6_11D2_8E53_006008A82731__INCLUDED_)
</pre>
</td>
</tr>
</table>
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<H3>MainFrm.cpp</H3>
<pre>
// MainFrm.cpp : implementation of the CMainFrame class
//

#include &quot;stdafx.h&quot;
#include &quot;WinDir.h&quot;

#include &quot;MainFrm.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;

    cs.style &amp;= ~FWS_ADDTOTITLE;
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext&amp; dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
</pre>
</td>
</tr>
</table>
</p>


<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<H3>FileView.h</H3>
<pre>
// FileView.h : interface of the CFileView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILEVIEW_H__18BD7B80_95C6_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_FILEVIEW_H__18BD7B80_95C6_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

typedef struct tagITEMINFO {
    CString     strFileName; 
    DWORD       nFileSizeLow; 
    FILETIME    ftLastWriteTime; 
} ITEMINFO;

class CFileView : public CListView
{
protected: // create from serialization only
    CFileView();
    DECLARE_DYNCREATE(CFileView)

// Attributes
public:
    CWinDirDoc* GetDocument();

// Operations
public:
    static int CALLBACK CompareFunc (LPARAM lParam1, LPARAM lParam2,
        LPARAM lParamSort);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CFileView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    protected:
    virtual void OnInitialUpdate(); // called first time after construct
    //}}AFX_VIRTUAL

// Implementation
public:
    int Refresh (LPCTSTR pszPath);
    virtual ~CFileView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:

// Generated message map functions
protected:
    CString m_strPath;
    void FreeItemMemory ();
    BOOL AddItem (int nIndex, WIN32_FIND_DATA* pfd);
    CImageList m_ilSmall;
    CImageList m_ilLarge;
    //{{AFX_MSG(CFileView)
    afx_msg void OnDestroy();
    afx_msg void OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnViewLargeIcons();
    afx_msg void OnViewSmallIcons();
    afx_msg void OnViewList();
    afx_msg void OnViewDetails();
    afx_msg void OnUpdateViewLargeIcons(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewSmallIcons(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewList(CCmdUI* pCmdUI);
    afx_msg void OnUpdateViewDetails(CCmdUI* pCmdUI);
    afx_msg void OnFileNewDirectory();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in FileView.cpp
inline CWinDirDoc* CFileView::GetDocument()
    { return (CWinDirDoc*)m_pDocument; }
#endif

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(
//     AFX_FILEVIEW_H__18BD7B80_95C6_11D2_8E53_006008A82731__INCLUDED_)
</pre>
</td>
</tr>
</table>
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<H3>FileView.cpp</H3>
<pre>
// FileView.cpp : implementation of the CFileView class
//

#include &quot;stdafx.h&quot;
#include &quot;WinDir.h&quot;
#include &quot;PathDialog.h&quot;
#include &quot;WinDirDoc.h&quot;
#include &quot;FileView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CFileView

IMPLEMENT_DYNCREATE(CFileView, CListView)

BEGIN_MESSAGE_MAP(CFileView, CListView)
    //{{AFX_MSG_MAP(CFileView)
    ON_WM_DESTROY()
    ON_NOTIFY_REFLECT(LVN_GETDISPINFO, OnGetDispInfo)
    ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnClick)
    ON_COMMAND(ID_VIEW_LARGE_ICONS, OnViewLargeIcons)
    ON_COMMAND(ID_VIEW_SMALL_ICONS, OnViewSmallIcons)
    ON_COMMAND(ID_VIEW_LIST, OnViewList)
    ON_COMMAND(ID_VIEW_DETAILS, OnViewDetails)
    ON_UPDATE_COMMAND_UI(ID_VIEW_LARGE_ICONS, OnUpdateViewLargeIcons)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SMALL_ICONS, OnUpdateViewSmallIcons)
    ON_UPDATE_COMMAND_UI(ID_VIEW_LIST, OnUpdateViewList)
    ON_UPDATE_COMMAND_UI(ID_VIEW_DETAILS, OnUpdateViewDetails)
    ON_COMMAND(ID_FILE_NEW_DIR, OnFileNewDirectory)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CFileView construction/destruction

CFileView::CFileView()
{
}

CFileView::~CFileView()
{
}

BOOL CFileView::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    if (!CListView::PreCreateWindow (cs))
        return FALSE;

    cs.style &amp;= ~LVS_TYPEMASK;
    cs.style &brvbar;= LVS_REPORT;
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CFileView drawing

void CFileView::OnDraw(CDC* pDC)
{
    CWinDirDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    // TODO: add draw code for native data here
}

void CFileView::OnInitialUpdate()
{
    CListView::OnInitialUpdate();

    //
    // Initialize the image list.
    //
    m_ilLarge.Create (IDB_LARGEDOC, 32, 1, RGB (255, 0, 255));

    m_ilSmall.Create (IDB_SMALLDOC, 16, 1, RGB (255, 0, 255));

    GetListCtrl ().SetImageList (&amp;m_ilLarge, LVSIL_NORMAL);
    GetListCtrl ().SetImageList (&amp;m_ilSmall, LVSIL_SMALL);

    //
    // Add columns to the list view.
    //
    GetListCtrl ().InsertColumn (0, _T (&quot;File Name&quot;), LVCFMT_LEFT, 192);
    GetListCtrl ().InsertColumn (1, _T (&quot;Size&quot;), LVCFMT_RIGHT, 96);
    GetListCtrl ().InsertColumn (2, _T (&quot;Last Modified&quot;), LVCFMT_CENTER, 128);

    //
    // Populate the list view with items.
    //
    TCHAR szPath[MAX_PATH];
    ::GetCurrentDirectory (sizeof (szPath) / sizeof (TCHAR), szPath);
    Refresh (szPath);
}

///////////////////////////////////////////////////////////////////////////
// CFileView diagnostics

#ifdef _DEBUG
void CFileView::AssertValid() const
{
    CListView::AssertValid();
}

void CFileView::Dump(CDumpContext&amp; dc) const
{
    CListView::Dump(dc);
}

CWinDirDoc* CFileView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CWinDirDoc)));
    return (CWinDirDoc*)m_pDocument;
}
#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CFileView message handlers

int CFileView::Refresh(LPCTSTR pszPath)
{
    CString strPath = pszPath;
    if (strPath.Right (1) != _T (&quot;\\&quot;))
        strPath += _T (&quot;\\&quot;);
    strPath += _T (&quot;*.*&quot;);

    HANDLE hFind;
    WIN32_FIND_DATA fd;
    int nCount = 0;

    if ((hFind = ::FindFirstFile (strPath, &amp;fd)) != INVALID_HANDLE_VALUE) {
        //
        // Delete existing items (if any).
        //
        GetListCtrl ().DeleteAllItems ();
    
        //
        // Show the path name in the frame window's title bar.
        //
        TCHAR szFullPath[MAX_PATH];
        ::GetFullPathName (pszPath, sizeof (szFullPath) / sizeof (TCHAR),
            szFullPath, NULL);
        m_strPath = szFullPath;

        CString strTitle = _T (&quot;WinDir - &quot;);
        strTitle += szFullPath;
        AfxGetMainWnd ()-&gt;SetWindowText (strTitle);

        //
        // Add items representing files to the list view.
        //
        if (!(fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY))
            AddItem (nCount++, &amp;fd);

        while (::FindNextFile (hFind, &amp;fd)) {
            if (!(fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY))
                if (!AddItem (nCount++, &amp;fd))
                    break;
        }
        ::FindClose (hFind);
    }
    return nCount;
}

BOOL CFileView::AddItem(int nIndex, WIN32_FIND_DATA *pfd)
{
    //
    // Allocate a new ITEMINFO structure and initialize it with information
    // about the item.
    //
    ITEMINFO* pItem;
    try {
        pItem = new ITEMINFO;
    }
    catch (CMemoryException* e) {
        e-&gt;Delete ();
        return FALSE;
    }

    pItem-&gt;strFileName = pfd-&gt;cFileName;
    pItem-&gt;nFileSizeLow = pfd-&gt;nFileSizeLow;
    pItem-&gt;ftLastWriteTime = pfd-&gt;ftLastWriteTime;

    //
    // Add the item to the list view.
    //
    LV_ITEM lvi;
    lvi.mask = LVIF_TEXT &brvbar; LVIF_IMAGE &brvbar; LVIF_PARAM; 
    lvi.iItem = nIndex; 
    lvi.iSubItem = 0; 
    lvi.iImage = 0;
    lvi.pszText = LPSTR_TEXTCALLBACK; 
    lvi.lParam = (LPARAM) pItem;

    if (GetListCtrl ().InsertItem (&amp;lvi) == -1)
        return FALSE;

    return TRUE;
}

void CFileView::FreeItemMemory()
{
    int nCount = GetListCtrl ().GetItemCount ();
    if (nCount) {
        for (int i=0; i&lt;nCount; i++)
            delete (ITEMINFO*) GetListCtrl ().GetItemData (i);
    }
}

void CFileView::OnDestroy() 
{
    FreeItemMemory ();
    CListView::OnDestroy ();
}

void CFileView::OnGetDispInfo(NMHDR* pNMHDR, LRESULT* pResult) 
{
    CString string;
    LV_DISPINFO* pDispInfo = (LV_DISPINFO*) pNMHDR;

    if (pDispInfo-&gt;item.mask &amp; LVIF_TEXT) {
        ITEMINFO* pItem = (ITEMINFO*) pDispInfo-&gt;item.lParam;

        switch (pDispInfo-&gt;item.iSubItem) {

        case 0: // File name.
            ::lstrcpy (pDispInfo-&gt;item.pszText, pItem-&gt;strFileName);
            break;

        case 1: // File size.
            string.Format (_T (&quot;%u&quot;), pItem-&gt;nFileSizeLow);
            ::lstrcpy (pDispInfo-&gt;item.pszText, string);
            break;

        case 2: // Date and time.
            CTime time (pItem-&gt;ftLastWriteTime);

            BOOL pm = FALSE;
            int nHour = time.GetHour ();
            if (nHour == 0)
                nHour = 12;
            else if (nHour == 12)
                pm = TRUE;
            else if (nHour &gt; 12) {
                nHour -= 12;
                pm = TRUE;
            }

            string.Format (_T (&quot;%d/%0.2d/%0.2d (%d:%0.2d%c)&quot;),
                time.GetMonth (), time.GetDay (), time.GetYear () % 100,
                nHour, time.GetMinute (), pm ? _T (`p') : _T (`a'));
            ::lstrcpy (pDispInfo-&gt;item.pszText, string);
            break;
        }
    }
    *pResult = 0;
}

void CFileView::OnColumnClick(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*) pNMHDR;
    GetListCtrl ().SortItems (CompareFunc, pNMListView-&gt;iSubItem);
    *pResult = 0;
}

int CALLBACK CFileView::CompareFunc (LPARAM lParam1, LPARAM lParam2,
    LPARAM lParamSort)
{
    ITEMINFO* pItem1 = (ITEMINFO*) lParam1;
    ITEMINFO* pItem2 = (ITEMINFO*) lParam2;
    int nResult;

    switch (lParamSort) {

    case 0: // File name.
        nResult = pItem1-&gt;strFileName.CompareNoCase (pItem2-&gt;strFileName);
        break;

    case 1: // File size.
        nResult = pItem1-&gt;nFileSizeLow - pItem2-&gt;nFileSizeLow;
        break;

    case 2: // Date and time.
        nResult = ::CompareFileTime (&amp;pItem1-&gt;ftLastWriteTime,
            &amp;pItem2-&gt;ftLastWriteTime);
        break;
    }
    return nResult;
}

void CFileView::OnViewLargeIcons() 
{
    ModifyStyle (LVS_TYPEMASK, LVS_ICON);
}

void CFileView::OnViewSmallIcons() 
{
    ModifyStyle (LVS_TYPEMASK, LVS_SMALLICON);
}

void CFileView::OnViewList() 
{
    ModifyStyle (LVS_TYPEMASK, LVS_LIST);
}

void CFileView::OnViewDetails() 
{
    ModifyStyle (LVS_TYPEMASK, LVS_REPORT);
}

void CFileView::OnUpdateViewLargeIcons(CCmdUI* pCmdUI) 
{
    DWORD dwCurrentStyle = GetStyle () &amp; LVS_TYPEMASK;
    pCmdUI-&gt;SetRadio (dwCurrentStyle == LVS_ICON);
}

void CFileView::OnUpdateViewSmallIcons(CCmdUI* pCmdUI) 
{
    DWORD dwCurrentStyle = GetStyle () &amp; LVS_TYPEMASK;
    pCmdUI-&gt;SetRadio (dwCurrentStyle == LVS_SMALLICON);
}

void CFileView::OnUpdateViewList(CCmdUI* pCmdUI) 
{
    DWORD dwCurrentStyle = GetStyle () &amp; LVS_TYPEMASK;
    pCmdUI-&gt;SetRadio (dwCurrentStyle == LVS_LIST);
}

void CFileView::OnUpdateViewDetails(CCmdUI* pCmdUI) 
{
    DWORD dwCurrentStyle = GetStyle () &amp; LVS_TYPEMASK;
    pCmdUI-&gt;SetRadio (dwCurrentStyle == LVS_REPORT);
}

void CFileView::OnFileNewDirectory() 
{
    CPathDialog dlg;
    dlg.m_strPath = m_strPath;
    if (dlg.DoModal () == IDOK)
        Refresh (dlg.m_strPath);
}
</pre>
</td>
</tr>
</table>
</p>

<p><I>CFileView</I> uses callbacks for 
item and subitem text so that it can maintain its own item data without forcing 
the control to maintain copies of the data, too. Callbacks come in the form of 
LVN_GETDISPINFO notifications, which <I>CFileView</I> 
reflects to its own 
<I>OnGetDispInfo</I> handler with an 
ON_NOTIFY_REFLECT message-map entry. When <I>OnGetDispInfo</I> is called, 
<I>pNMHDR</I> points to 
an LV_DISPINFO structure. The structure's <I>item.lParam</I> field contains the address of the ITEMINFO structure for 
the item in question, and the <I>item.iSubItem</I> field 
contains the index of the requested subitem. <I>CFileView::OnGetDispInfo</I> formulates a text string from the data stored 
in the ITEMINFO structure's <I>strFileName</I>, <I>nFileSizeLow</I>, or <I>ftLastWriteTime</I> field and copies the result to the address contained 
in the LV_DISPINFO structure's 
<I>item.pszText</I> field. 
The list view then displays the text on the screen. 
</p>

<p>
<I>CFileView</I> maintains its own 
item data so that 
<I>CListCtrl::SortItems</I> can be called 
and 
<I>CFileView::CompareFunc</I> can retrieve any or all 
of an item's data by dereferencing the pointer stored in the item's 
<I>lParam</I>. If the user clicks a column header while the 
list view is in report mode, an ON_NOTIFY_REFLECT entry in the message map 
activates <I>CFileView::OnColumnClick</I>, and 
<I>OnColumnClick</I>, in turn, calls the list view's <I>SortItems</I> function, passing in the index of the column 
that was clicked: 
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td><pre>
GetListCtrl ().SortItems (CompareFunc, pNMListView-&gt;iSubItem); </pre>
</td>
</tr>
</table>
</p>


<p>
<I>CompareFunc</I> is the 
application-defined sorting routine called to compare pairs of items. It's 
declared static because it's a callback function. <I>CompareFunc</I> uses the ITEMINFO pointers passed in <I>lParam1</I> and <I>lParam2</I> to retrieve the data 
for the items it's asked to compare and uses the column index in <I>lParamSort</I> to determine which of the items' subitems to use as the 
basis for the comparison. The entire function requires fewer than 20 lines of 
code:</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>int CALLBACK CFileView::CompareFunc (LPARAM lParam1, LPARAM lParam2,
    LPARAM lParamSort)
{
    ITEMINFO* pItem1 = (ITEMINFO*) lParam1;
    ITEMINFO* pItem2 = (ITEMINFO*) lParam2;
    int nResult;

    switch (lParamSort) {

    case 0: // File name.
        nResult =
            pItem1-&gt;strFileName.CompareNoCase (pItem2-&gt;strFileName);
        break;

    case 1: // File size.
        nResult = pItem1-&gt;nFileSizeLow - pItem2-&gt;nFileSizeLow;
        break;

    case 2: // Date and time.
        nResult = ::CompareFileTime (&amp;pItem1-&gt;ftLastWriteTime,
            &amp;pItem2-&gt;ftLastWriteTime);
        break;
    }
    return nResult;
}
</pre>
</td>
</tr>
</table>
</p>

<p>A negative return value from <I>CompareFunc</I> indicates that item 1 is less than (should come before) 
item 2, 0 means that they're equal, and a positive return value means that item 
1 is greater than item 2. The 
<I>::CompareFileTime</I> API 
function makes it easy to compare dates and times encapsulated in FILETIME 
values. You can also create <I>CTime</I> objects from 
FILETIME values and use &lt;, &gt;, and other operators to compare dates and 
times. 
</p>

<p>
It might not be obvious to you yet, but you just saw why 
a list view with sortable columns must store its own data. The only information <I>CompareFunc</I> receives about the items it's asked to 
compare is the items' 
<I>lParam</I> values. Therefore, <I>lParam</I> has to provide full access to all of an item's 
data. One way to make sure that it does is to store item data in memory 
allocated by the application (in WinDir's case, in ITEMINFO structures allocated 
with <I>new</I>) and to store a pointer to the data in each 
item's own <I>lParam</I>. Storing item data yourself rather 
than converting it to text and handing it over to the list view provides greater 
flexibility in sorting because the data can be stored in binary form. How else 
could you sort the information that appears in <I>CFileView</I>'s Last Modified column? A string sort wouldn't work very 
well because &quot;1/1/96&quot; comes before &quot;9/30/85&quot; even though the 
former represents a later calendar date. But since <I>CFileView</I> stores dates and times in their native FILETIME format, 
sorting is a piece of cake. 
</p>

<p>
A final note concerning <I>CFileView</I> has to do with the method used to delete the ITEMINFO 
structures allocated by <I>AddItem</I>. <I>CFileView::FreeItemMemory</I> deallocates the memory set aside for each 
item by iterating through the items in the list view and calling <I>delete</I> on the pointers stored in the items' <I>lParam</I>s. <I>FreeItemMemory</I> is called by the 
view's WM_DESTROY handler to free the ITEMINFO structures before the application 
shuts down. 
</p>

</BODY>
</HTML>




