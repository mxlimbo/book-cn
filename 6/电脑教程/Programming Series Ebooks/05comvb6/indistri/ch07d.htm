<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="Library.css" TYPE="text/css">
<TITLE>Multithreading in a Form-Based Application</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07c.htm", "ch07e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="111"><H1>Multithreading in a Form-Based Application</H1></A>

<p>As you have seen, it's fairly simple to create a multithreaded out-of-process server using Visual Basic. All you have to do is set the appropriate threading mode before you build an ActiveX EXE project. You can also create a form-based application that uses multiple threads (although this is far more difficult). Thus you can create a secondary thread in a typical Windows application, which allows you to run a task in the background without freezing the user interface. This can make a huge difference in a desktop application in which running certain tasks on the primary thread would lock down the user interface for an unacceptable period of time.

<p>The technique for running a secondary thread requires using a back door to create a second apartment. Although this requires a little trickery, the results are both safe and predictable. If you create a form-based application with an ActiveX EXE project instead of a Standard EXE project, Visual Basic includes built-in support for creating additional apartments. The trick is to make an internal activation request seem as if it's coming from a remote client. As you'll recall from earlier in this chapter, a thread-per-object ActiveX EXE creates a new apartment when an external client makes an activation request. You can trick the ActiveX EXE into thinking that you're a remote client by using Visual Basic's <I>CreateObject</I> function instead of the <I>New </I>operator.

<p>When you create an object in an ActiveX EXE project using the <I>New</I> operator, the Visual Basic run time will attempt to activate the object directly from the server. If the ActiveX EXE contains a local definition of the CLSID, the object is activated in the same apartment of the client that named <I>New</I>. If there's no local implementation for the CLSID, the Visual Basic run time passes the activation request to the SCM. Unlike a call to <I>New</I>, however, a call to <I>CreateObject</I> always results in a call to the SCM. If you pass the ProgID of a local class to the <I>CreateObject</I> function, your server calls the SCM and the SCM responds by calling back into your server's process in the same manner as with any other external activation request. The ActiveX EXE sees an external activation request and creates the object in a new STA.

<p>What happens when you call <I>CreateObject</I> from within your thread-per-object ActiveX EXE project? First a new STA is created in your process and the new object is loaded inside it. Next <I>CreateObject</I> returns an interface reference to the client, which is bound to the object through a proxy/stub layer. Now you have an object in a separate apartment running on a different thread, as shown in Figure 7-10. OK, you've done the easy part. Doing anything meaningful with this new apartment and thread requires significant work.

<p><A HREF="javascript:fullSize('F07wg10x.htm')"> <img src="images/F07wg10.JPG" width=404 height=273 border=0 ALT = "Click to view at full size."> </A>

<p><!-- caption --><B>Figure 7-10.</b> <i>You can create secondary threads in a Visual Basic application with a user interface. You can create a new thread in a thread-per-object ActiveX EXE application by creating an object with the </I>CreateObject <I>function instead of the </I>New <I>operator.</I><!-- /caption -->

<A NAME="112"><H2>A Series of &quot;Gotchas&quot;</H2></A>

<p>The first obstacle that you must face is that you can't run or debug your multithreaded client application in the Visual Basic IDE. The behavior of creating additional STAs can be exhibited only in a compiled EXE. This makes it far more difficult to debug your application. But then again, what could be more reliable in debugging than your old friend the <I>MsgBox </I>statement?

<p>When you create an ActiveX EXE instead of a Standard EXE, you must use <I>Sub Main </I>instead of a startup form. This means that you must use <I>Sub Main </I>to load and show the application's main form. This creates a problem because <I>Sub Main </I>executes whenever a new apartment is created. You must use a programming technique to load and show the main form only during your application's first execution of <I>Sub Main</I>. You can do this by loading an invisible form on application startup. When <I>Sub Main</I> runs, it can search through all loaded windows with a Win32 technique to see whether this form has been loaded. The sample application MTC1.vbp on this book's companion CD demonstrates one way to accomplish this.

<p>The next problem you face is that you can't create additional apartments until the main apartment has been fully initialized. Therefore, you must wait until <I>Sub Main </I>completes before you can create any new objects in separate apartments. <I>Sub Main</I> won't complete until the form you are loading completes its <I>Load</I> method. This means that you can't create objects on separate threads during either of these methods. This isn't overly difficult to overcome, but it's a pain because many of us are used to creating our objects in <I>Sub Main</I> or in the <I>Load </I>event of our main form.

<p>The first nontrivial problem surfaces when you want to run a task on your secondary thread without blocking the primary thread that's responsible for servicing the user interface. Currently COM lets you run method calls only in a synchronous manner. If you make a simple method call from your main form to an object in a different STA, the primary thread will be blocked until the call has completed. This totally defeats the purpose of creating a second thread.

<p>Getting both threads to run at the same time requires an asynchronous method call. A future version of COM+ will modify the RPC layer to support true asynchronous calls. For now, however, all calls in COM are synchronous. A Visual Basic programmer must handcraft a &quot;logical&quot; asynchronous call by using the <I>SetTimer </I>function from the Win32 API. Again, the sample application MTC1.vbp shows how to set up an asynchronous call using this technique.

<p>Finally, after you execute an asynchronous call from the main form to the secondary apartment, you must provide a way for the object to communicate with the main form. The object should notify the form of the task's update status while it's executing and ultimately the success or failure of the task. To do this, you can use either events or callback interfaces, as described in the previous chapter. The steps required for the asynchronous call are shown in Figure 7-11.

<p><img src="images/F07wg11.GIF" width=404 height=272 border="0">

<p><!-- caption --><B>Figure 7-11.</b> <i>Running an asynchronous task is fairly complicated, even after you've created an object in a secondary apartment.</I><!-- /caption -->

</BODY>
</HTML>






