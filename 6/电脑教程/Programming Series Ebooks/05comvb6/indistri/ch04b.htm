<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="Library.css" TYPE="text/css">
<TITLE>The IUnknown Interface</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04a.htm", "ch04c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="44"><h1>The <I>IUnknown </I>Interface</H1></A>
<p>COM has one interface from which all other interfaces derive: <I>IUnknown</I>. Every interface must derive directly from <I>IUnknown </I>or from an interface that has <I>IUnknown </I>at the root of its inheritance chain. <I>IUnknown </I>is at the top of every COM interface hierarchy. This means that the three methods defined in <I>IUnknown </I>are always at the top of any COM-compliant vTable, as shown in Figure 4-1. Any connection to an object is made through an<I> IUnknown</I>-compatible reference.

<p><A HREF="javascript:fullSize('F04wg01x.htm')"> <img src="images/F04wg01.JPG" width=404 height=161 border=0 ALT = "Click to view at full size."> </A>

<p><!-- caption --><B>Figure 4-1.</B> <I>The three methods of the </I>IUnknown <I>interface always appear at the top of a COM-compliant vTable. Any connection to an object guarantees a client the ability to call these methods.</I><!-- /caption -->

<p><i>IUnknown </I>expresses the base behavior of a COM object as opposed to a domain-specific behavior that you experience through a user-defined interface. <I>IUnknown </I>allows every COM object to manage its own lifetime. It also allows a client to query an object to see whether it supports a given interface and to dynamically cast the object to any of the supported interfaces.

<p>Note that Visual Basic programmers are never exposed to <I>IUnknown </I>directly. Visual Basic's mapping layer hides all the code that deals with <I>IUnknown</I>. While you can declare variables of type <I>IUnknown</I>, you can't invoke its methods because they are marked as [restricted] in the type library <I>STDOLE2.TLB</I>. Likewise, on the object side, you never supply implementations for the three methods of <I>IUnknown</I>. Visual Basic takes care of all this for you behind the scenes.

<p>In COM, an object is expected to manage its own lifetime. However, an object needs help to make an informed decision about whether to terminate itself or continue running. The client of an object is responsible for calling <I>AddRef</I> whenever it duplicates an interface reference and for calling <I>Release</I> whenever it drops an existing connection. If all clients live up to their responsibilities, an object can provide a simple implementation of these two methods to properly manage its lifetime. The object maintains a count of connected references and releases itself from memory whenever this count drops to 0.

<p>This model of lifetime management is very different from the way that C and C++ programmers have traditionally dealt with memory allocation. In C and C++, it is common for a client to allocate, use, and then explicitly free memory. The problem with this approach is that it doesn't accommodate multiple clients of a single object. With the reference counting scheme employed by COM, multiple clients can connect to an object. If a client never explicitly deletes an object, it is impossible for one client to delete an object that is currently being used by another client.

<p>C++/COM clients are expected to follow a set of rules for calling <I>AddRef </I>and <I>Release</I>, which are listed in the COM specification. These rules aren't complicated, but they require a fair amount of discipline to follow when you write COM code by hand. The only time that reference counting is really noticeable in a C++/COM application is when it's done incorrectly.

<p>Visual Basic programmers are never responsible for calling <I>AddRef </I>and <I>Release</I>. Consequently, they aren't vulnerable to such bugs. COM+ will address this problem with C++ clients by introducing a universal run-time layer that shields all programmers from calling <I>AddRef </I>and <I>Release </I>explicitly. This will finally give C++ programmers the same benefits that Visual Basic programmers have enjoyed for years.

<A NAME="45"><H2>Visual Basic and Lifetime Management</H2></A>

<p>When you work in Visual Basic, you don't have to worry much about lifetime management. You really need to remember only two rules: Hold the object reference when you want to keep the object alive, and release the reference when you no longer care about the object. Visual Basic handles all calls to <I>IUnknown </I>for you. Take a look at the following example:

<p><pre>
Sub CreateAndUseDog
    Dim Dog As IDog
    Set Dog = New CBeagle &#39; AddRef is called.
    Dim Dog2 As IDog
    Set Dog2 = Dog &#39; AddRef is called.
    Set Dog2 = Nothing &#39; Release is called.
    &#39; Release is called on Dog when reference goes out of scope.
End Sub
</PRE>

<p>This code results in several calls to <I>AddRef </I>and <I>Release</I>. When an object is activated, it experiences an <I>AddRef </I>call. When you create a second reference to the object, the Visual Basic client calls <I>AddRef</I>. If you explicitly set an interface reference to <I>Nothing</I>, Visual Basic calls <I>Release </I>for you. If you don't explicitly set a reference to <I>Nothing</I>, Visual Basic detects when an active reference is going out of scope and calls <I>Release </I>on the object just before dropping the connection.

<p>On the object side, Visual Basic automatically implements <I>AddRef </I>and <I>Release </I>to conduct standard reference counting. A Visual Basic object keeps running as long as active clients remain connected. When the last connection calls <I>Release</I>, the Visual Basic object terminates itself. Once again, there's nothing you can do in Visual Basic to influence how an object manages its lifetime, but it's important to understand how your objects will behave.

<p>One of the trickier aspects of lifetime management involves <I>circular references,</I> such as when object A holds a reference to object B and object B holds a reference to object A. Even after all interested clients have dropped their connections, the objects remain in memory because of the outstanding references they hold on each other. If your design involves circular references, you must make sure that objects go away when they are no longer needed. One common way to prevent circular references from keeping objects alive forever is to create an explicit method in one of the objects that breaks a connection, causing the composite to start breaking down.

<A NAME="46"><h2>The <I>QueryInterface</I> Method</h2></A>
<p>The first and arguably most significant method of <I>IUnknown </I>is <I>QueryInterface</I>, which allows clients to navigate among the various interfaces supported by an object. This act of dynamically casting different interfaces is known as <I>type coercion</I>. A client can also use <I>QueryInterface </I>simply to test whether an object supports a particular interface. The capabilities provided by <I>QueryInterface </I>are essential to COM. Without <I>QueryInterface</I>, COM couldn't achieve polymorphism and run-time type inspection, which are required in an interface-based programming paradigm.

<p>A COM object must implement at least one interface, but it can implement as many as it likes. Objects that implement multiple interfaces must allow clients to navigate among them by calling <I>QueryInterface</I>. A client passes a desired IID when it calls <I>QueryInterface</I>,<I> </I>and the object responds by returning a reference to the interface. If the client asks for an interface that's not supported, the call to <I>QueryInterface </I>will fail. If the call fails, the client can determine that the requested functionality isn't available and thus degrade gracefully.

<p>The Visual Basic run-time layer silently calls <I>QueryInterface </I>when you assign an object to a specific reference type. Take a look at the following example:

<p><pre>
Dim Dog As IDog
Set Dog = New CBeagle
&#39; To get at another interface
Dim WonderDog As IWonderDog
Set WonderDog = Dog &#39; QueryInterface is called.
WonderDog.FetchSlippers
</PRE>

<p>If you have an <I>IDog </I>reference to an object and you want to retrieve an <I>IWonderDog </I>reference, you can simply use the <I>Set </I>statement to cast one interface reference to another. A trappable &quot;Type mismatch&quot; error will occur if the interface is not supported. If the cast is successful, you can use the new interface reference to invoke methods on the object .

<p>Some Visual Basic programmers prefer to blindly cast interface references, as shown in the previous example. If you try to cast to an interface that isn't supported, the Visual Basic run-time layer deals with an unsuccessful call to <I>QueryInterface </I>by raising a trappable run-time error in your code. If there's a chance that the cast will fail, you must be prepared to trap and deal with this error. If you would rather avoid dealing with run-time errors, you can query an object for interface support by using Visual Basic's <I>TypeOf </I>syntax, like this:

<p><pre>
Dim Dog As IDog
Set Dog = New CBeagle
&#39; Test for support before using interface.
If TypeOf Dog Is IWonderDog Then &#39; Call to QueryInterface
    Dim WonderDog As IWonderDog
    Set WonderDog = Dog &#39; Call to QueryInterface
    WonderDog.FetchSlippers
Else
    &#39; Degrade gracefully if interface isn't supported.
End If
</PRE>

<p>A Visual Basic object automatically implements <I>QueryInterface</I>. When you implement one or more user-defined interfaces in a class, Visual Basic provides an implementation of <I>QueryInterface </I>that allows clients to move among interface references. As in the case of <I>AddRef </I>and <I>Release</I>, the Visual Basic implementation of <I>QueryInterface </I>is fairly straightforward, but you can never see it. You have to take it on faith that it works perfectly.

</BODY>
</HTML>






