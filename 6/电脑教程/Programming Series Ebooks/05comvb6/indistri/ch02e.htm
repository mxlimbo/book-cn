<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="Library.css" TYPE="text/css">
<TITLE>Using Interfaces in Your Application Designs</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch02d.htm", "ch03a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="25"><H1>Using Interfaces in Your Application Designs</H1></A>

<p>This chapter has presented a simple application to demonstrate the core concepts of interface-based programming. How can you apply these principles in a real-world application? If you're designing a large application that uses customer objects, you can create a user-defined interface <I>ICustomer </I>and start writing lots of client code against the interface instead of to a concrete <I>CCustomer </I>class. If you create several classes that implement the <I>ICustomer </I>interface, you can achieve the plug-and-play benefits of polymorphism. Different types of customer objects exhibit different behavior, but they're all controlled through the same interface.

<P>From a versioning standpoint, this design lets you improve the behavior of various customer objects by introducing new interfaces into the application. Interfaces such as <I>ICustomer2</I>, <I>ICustomer3</I>, and <I>ICustomer4 </I>let you safely extend the behavior of customer objects. The best part about this approach is that you can revise clients and objects independently. Older clients and objects can use earlier interfaces, while newer clients and objects can communicate through newer interfaces. All of this is made possible through the run-time type inspection of interface support.

<A NAME="26"><H2>Interfaces and COM</H2></A>

<p>The industry has adopted interface-based programming because of the limitations of other common techniques, such as the use of class-based references and implementation inheritance. User-defined interfaces bring a new level of complexity to both application design and programming, but their value is easy to measure in large applications. In a Darwinian sense, interface-based programming makes software more fit for survival. Interfaces make your code easier to reuse, maintain, and extend.

<P>The next chapter presents the internals of COM. As you'll see, COM is based on the following core concepts of interface-based programming:

<UL>
<P><LI><I>COM requires a formal separation of interface and implementation</I>&#8212;that is, it requires that clients communicate with objects exclusively through interface references. This ensures that clients never build dependencies on the classes that serve up objects, which in turn allows COM programmers to revise their object code without worrying about breaking client code.
<P><LI><I>COM clients can get run-time type information from objects</I>. A COM client can always query an object and ask whether it supports a specific interface. If the requested interface isn't supported, the client can discover this and degrade gracefully. This lets programmers revise components and applications independently. Older clients and older objects can work in harmony with newer clients and newer objects. Herein lies the key to versioning in COM.
</UL>

<p>This chapter showed the use of interfaces in a single application. The entire application was written in a single language, and all the source code was sent to a compiler at the same time. COM, on the other hand, must work across binary components. Moreover, COM clients and COM objects can be written in different languages and can run in different processes on different computers. COM must solve many problems at the physical level to achieve the benefits of interface-based programming.
</BODY>
</HTML>






