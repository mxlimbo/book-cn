<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>The Bit-Block Transfer</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="433"><h1>The Bit-Block Transfer</h1></A><P>As I mentioned earlier, you can think of the entire video display as one big bitmap. 
The pixels you see on the screen are represented by bits stored in memory on the video 
display adapter board. Any rectangular area of the video display is also a bitmap, the size 
of which is the number of rows and columns it contains.
<P>Let's begin our journey into the world of bitmaps by copying an image from one 
area of the video display to another. This is a job for the powerful 
<I>BitBlt</I> function.
<P><I>Bitblt</I> (pronounced &quot;bit blit&quot;) stands for &quot;bit-block transfer.&quot; The BLT originated 
as an assembly language instruction that did memory block transfers on the DEC PDP-10. 
The term &quot;bitblt&quot; was first used in graphics in connection with the SmallTalk system 
designed at the Xerox Palo Alto Research Center (PARC). In SmallTalk, all graphics output 
operations are based around the bitblt. Among programmers, &quot;blt&quot; is sometimes used as a 
verb, as in &quot;Then I wrote some code to blt the happy face to the screen and play a wave file.&quot;
<P>The <I>BitBlt</I> function is a pixel mover, or (more vividly) a raster blaster. As you'll 
see, the term &quot;transfer&quot; doesn't entirely do justice to the 
<I>BitBlt</I> function. The function actually performs a bitwise operation on pixels and can result in some interesting effects.

<A NAME="434"><h2>A Simple BitBlt</h2></A><P>The BITBLT program shown in Figure 14-1 uses the 
<I>BitBlt</I> function to copy the program's system menu icon (located in the upper left corner of the program's window) to its 
client area.

<P><B><!-- caption -->Figure 14-1.<!-- /caption --></b> <i>The BITBLT program.</i>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="435"><H3>BITBLT.C</H3></A><pre>
/*---------------------------------------
   BITBLT.C -- BitBlt Demonstration
               (c) Charles Petzold, 1998
  ---------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName [] = TEXT (&quot;BitBlt&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;

     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_INFORMATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;BitBlt Demo&quot;), 
                          WS_OVERLAPPEDWINDOW, 
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;

     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static int  cxClient, cyClient, cxSource, cySource ;
     HDC         hdcClient, hdcWindow ;
     int         x, y ;
     PAINTSTRUCT ps ;
     
     switch (message)
     {
     case WM_CREATE:
          cxSource = GetSystemMetrics (SM_CXSIZEFRAME) +
                     GetSystemMetrics (SM_CXSIZE) ;

          cySource = GetSystemMetrics (SM_CYSIZEFRAME) + 
                     GetSystemMetrics (SM_CYCAPTION) ;
          return 0 ;

     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;

     case WM_PAINT:
          hdcClient = BeginPaint (hwnd, &amp;ps) ;
          hdcWindow = GetWindowDC (hwnd) ;

          for (y = 0 ; y &lt; cyClient ; y += cySource)
          for (x = 0 ; x &lt; cxClient ; x += cxSource)
          {
               BitBlt (hdcClient, x, y, cxSource, cySource,
                       hdcWindow, 0, 0, SRCCOPY) ;
          }

          ReleaseDC (hwnd, hdcWindow) ;
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}

</pre>
</td></tr></table>
<P>But why stop at one <I>BitBlt</I>? In fact, BITBLT fills its client area with multiple 
copies of the system menu icon (which in this case is the IDI_INFORMATION icon commonly 
used in message boxes), as shown in Figure 14-2.
<P><A HREF="javascript:fullSize('F14zg02x.htm')"><IMG SRC="F14zg02.JPG" width=404 height=286 ALIGN="BOTTOM" border=0 ALT="Click to view at full size."></a>
<P><!-- caption --><B>Figure 14-2.</b> <i>The BITBLT display.</I><!-- /caption -->
<P>The <I>BitBlt</I> function transfers pixels from a rectangular area in one device 
context, called the <I>source</I>, to a rectangular area of the same size in another device context, 
called the <I>destination</I>. The function has the following syntax:
<p><pre>
BitBlt (hdcDst, xDst, yDst, cx, cy, hdcSrc, xSrc, ySrc, dwROP) ;
</PRE>
<P>The source and destination device contexts can be the same.
<P>In the BITBLT program, the destination device context is the window's client 
area; the device context handle is obtained from the 
<I>BeginPaint</I> function. The source device context is the application's whole window; this device context handle is obtained 
from <I>GetWindowDC</I>. Obviously, these two device contexts refer to the same physical device 
(the video display). However, the coordinate origins of these two device contexts are different.
<P>The <I>xSrc</I> and <I>ySrc</I> arguments indicate the coordinate position of the upper left 
corner of the source image. In BITBLT, these two arguments are set to 0, indicating that the 
image begins in the upper left corner of the source device context (which is the whole 
window). The <I>cx</I> and <I>cy</I> arguments are the width and height of the image. BITBLT calculates 
these values from information obtained from the 
<I>GetSytemMetrics</I> function.
<P>The <I>xDst</I> and <I>yDst</I> arguments indicate the coordinate position of the upper left 
corner where the image is to be copied. In BITBLT, these two arguments are set to various 
values to copy the image multiple times. For the first 
<I>BitBlt</I> call, these two arguments are set to 0 to copy the image to the upper left corner of the client area.
<P>The last argument to <I>BitBlt</I> is called the 
<I>raster operation</I>. I'll discuss this value shortly.
<P>Notice that <I>BitBlt</I> is transferring pixels from the actual video display memory and 
not some other image of the system menu icon. If you move the BITBLT window so that 
part of the system menu icon is off the screen, and you then adjust the size of the 
BITBLT window to force it to repaint itself, you'll find only part of the system menu icon 
drawn within BITBLT's client area. The 
<I>BitBlt</I> function no longer has access to the entire image.
<P>In the <I>BitBlt</I> function, the source and destination device contexts can be the 
same. You can rewrite BITBLT so that WM_PAINT processing does the following:
<p><pre>
BitBlt (hdcClient, 0, 0, cxSource, cySource, 
        hdcWindow, 0, 0, SRCCOPY) ;

for (y = 0 ; y &lt; cyClient ; y += cySource)
for (x = 0 ; x &lt; cxClient ; x += cxSource)
{
     if (x &gt; 0 || y &gt; 0)
          BitBlt (hdcClient, x, y, cxSource, cySource,
                  hdcClient, 0, 0, SRCCOPY) ;
}
</PRE>
<P>This will usually create the same effect as the BITBLT shown above, except if the 
upper left corner of the client area is obscured in some way.
<P>The most important restriction in <I>BitBlt</I> is that the two device contexts must be 
&quot;compatible.&quot; What this means is that either one or the other must be monochrome, or they 
both must have the same number of bits per pixel. In short, you can't get a hard copy of 
something on the screen by blting it to the printer device context.

<A NAME="436"><h2>Stretching the Bitmap</h2></A><P>In the <I>BitBlt</I> function, the destination image is the same size as the source image 
because the function has only two arguments to indicate the width and height. If you want to 
stretch or compress the size of the image as you copy it, you can use the 
<I>StretchBlt</I> function. <I>StretchBlt</I> has the following syntax:
<p><pre>
StretchBlt (hdcDst, xDst, yDst, cxDst, cyDst, 
            hdcSrc, xSrc, ySrc, cxSrc, cySrc, dwROP) ;
</PRE>
<P>This function adds two arguments. The function now includes separate widths and 
heights of the destination and source. The 
<I>StretchBlt</I> function is demonstrated by the 
STRETCH program, shown in Figure 14-3.

<p><B>Figure 14-3.</b> <I>The STRETCH program.</I> 
<table cellpadding=5 width="95%"><tr><td>
<A NAME="437"><H3>STRETCH.C</H3></A><pre>/*----------------------------------------
 STRETCH.C -- StretchBlt Demonstration
                (c) Charles Petzold, 1998
  ----------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName [] = TEXT (&quot;Stretch&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;

     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_INFORMATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;StretchBlt Demo&quot;), 
                          WS_OVERLAPPEDWINDOW, 
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;

     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static int  cxClient, cyClient, cxSource, cySource ;
     HDC         hdcClient, hdcWindow ;
     PAINTSTRUCT ps ;
     
     switch (message)
     {
     case WM_CREATE:
          cxSource = GetSystemMetrics (SM_CXSIZEFRAME) +
                     GetSystemMetrics (SM_CXSIZE) ;

          cySource = GetSystemMetrics (SM_CYSIZEFRAME) + 
                     GetSystemMetrics (SM_CYCAPTION) ;
          return 0 ;

     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;

     case WM_PAINT:
          hdcClient = BeginPaint (hwnd, &amp;ps) ;
          hdcWindow = GetWindowDC (hwnd) ;

          StretchBlt (hdcClient, 0, 0, cxClient, cyClient,
                      hdcWindow, 0, 0, cxSource, cySource, MERGECOPY) ;

          ReleaseDC (hwnd, hdcWindow) ;
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;

     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>
<P>This program has only one call to the <I>StretchBlt</I> function but uses it to fill the 
entire client area with its system menu icon, as shown in Figure 14-4.
<P><A HREF="javascript:fullSize('F14zg04x.htm')"><IMG SRC="F14zg04.JPG" width=404 height=285 ALIGN="BOTTOM" border=0 ALT="Click to view at full size."></A>
<P><!-- caption --><B>Figure 14-4.</b> <i>The STRETCH display.</I><!-- /caption -->
<P>All the coordinates and sizes in the 
<I>BitBlt</I> and <I>StretchBlt</I> function are based on 
logical units. But what happens when you have two different device contexts in the 
<I>BitBlt</I> function that refer to the same physical device but have different mapping modes? If this is 
so, a call to <I>BitBlt</I> might seem ambiguous: the 
<I>cx</I> and <I>cy</I> arguments are in logical units, 
and they apply to both the rectangle in the source device context and the rectangle in 
the destination device context. All coordinates and sizes must be converted to device 
coordinates before the actual bit transfer. Because the 
<I>cx</I> and <I>cy</I> values are used for both the 
source and destination device contexts, the values must be converted to device units 
(pixels) separately for each device context.
<P>When the source and destination device contexts are the same, or when both 
device contexts use the MM_TEXT mapping mode, then the size of this rectangle in device 
units will be the same in both device contexts. Windows can then do a simple 
pixel-to-pixel transfer. However, when the size of the rectangle in device units is different in the 
two device contexts, Windows turns the job over to the more versatile 
<I>StretchBlt</I> function.
<P><I>StretchBlt</I> also allows you to flip an image vertically or horizontally. If the signs 
of <I>cxSrc</I> and <I>cxDst</I> (when converted to device units) are different, 
<I>StretchBlt</I> creates a mirror image: left becomes right, and right becomes left. You can check this in the 
STRETCH program by changing the <I>xDst</I> argument to 
<I>cxClient</I> and the <I>cxDst</I> argument to 
<I>-cxClient</I>. If <I>cySrc </I>and <I>cyDst 
</I>are different, <I>StretchBlt</I> turns the image upside down. You can 
check this in the STRETCH program by changing the 
<I>yDst</I> argument to <I>cyClient</I> and the 
<I>cyDst</I> argument to <I>-cyClient</I>.

<A NAME="438"><h2>The StretchBlt Mode</h2></A><I>StretchBlt</I> can exhibit some problems related to the inherent difficulties of scaling 
bitmaps. When expanding a bitmap, 
<I>StretchBlt</I> must duplicate rows or columns of pixels. If 
the expansion is not an integral multiple, the process can result in some distortion of the image.
<P>If the destination rectangle is smaller than the source rectangle, 
<I>StretchBlt</I> must shrink an image by combining two or more rows or columns of pixels into a single row or 
column. It does this in one of four ways, depending on the stretching mode attribute in 
the device context. You use the <I>SetStretchBltMode</I>
 function to change this attribute:
<p><pre>
SetStretchBltMode (hdc, iMode) ;
</PRE>
<P>The value of <I>iMode</I> can be one of the following:
<UL>
<p><li><I>BLACKONWHITE</I> or <I>STRETCH_ANDSCANS 
(default)</I>If two or more pixels have to be combined into one pixel, 
<I>StretchBlt</I> performs a logical AND operation on the pixels. The resulting pixel is white only if all the original pixels 
are white, which in practice means that black pixels predominate over white 
pixels. This is good for monochrome bitmaps where the image is primarily 
black against a white background.
<p><li><I>WHITEONBLACK</I> or 
<I>STRETCH_ORSCANS</I> If two or more pixels have to 
be combined into one pixel, <I>StretchBlt</I> performs a logical OR operation. The 
resulting pixel is black only if all the original pixels are black, which means 
that white pixels predominate. This is good for monochrome bitmaps where 
the image is primarily white against a black background.
<p><li><I>COLORONCOLOR</I> or 
<I>STRETCH_DELETESCANS</I><I> StretchBlt</I> simply 
eliminates rows or columns of pixels without doing any logical combination. This is 
often the best approach for color bitmaps.
<p><li><I>HALFTONE</I> or 
<I>STRETCH_HALFTONE</I> Windows calculates an average 
destination color based on the source colors being combined. This is used in 
conjunction with a halftone palette and is demonstrated in <a href="ch16a.htm#520">Chapter 16</a>.
</UL>
<P>Windows also includes a 
<I>GetStretchBltMode</I> function to obtain the current 
stretching mode.


<A NAME="439"><h2>The Raster Operations</h2></A><P>The BITBLT and STRETCH programs simply copy the source bitmap to the 
destination, perhaps stretching it in the process. This is the result of specifying SRCCOPY as the 
last argument to the <I>BitBlt</I> and 
<I>StretchBlt</I> functions. SRCCOPY is only 1 of 256 raster 
operations you can use in these functions. Let's experiment with a few others in the 
STRETCH program and then investigate the raster operations more methodically.
<P>Try replacing SRCCOPY with NOTSRCCOPY. As the name suggests, this raster 
operation inverts the colors of the bitmaps as it is copied. On the client window, all the 
colors will be reversed. Black becomes white, white becomes black, and blue becomes 
yellow. Now try SRCINVERT. You'll get the same effect. Try BLACKNESS. As the name 
suggests, the entire client area is painted black. WHITENESS makes it white.
<P>Now try this: replace the <I>StretchBlt</I> call with the following three statements:
<p><pre>
SelectObject (hdcClient, CreateHatchBrush (HS_DIAGCROSS, RGB (0, 0, 0)));

StretchBlt (hdcClient, 0, 0, cxClient, cyClient,
            hdcWindow, 0, 0, cxSource, cySource, MERGECOPY) ;

DeleteObject (hdcClient, GetStockObject (WHITE_BRUSH)) ;
</PRE>
<P>This time you'll see a hatch brush seemingly superimposed over the image. Just what 
is going on here?
<P>As I mentioned earlier, the <I>BitBlt</I> and 
<I>StretchBlt</I> functions are not simply bit-block 
transfers. The functions actually perform a bitwise operation between the following three images:
<UL>
<p><li><I>Source</I>       The source bitmap, stretched or compressed (if necessary) to be 
the same size as the destination rectangle.
<p><li><I>Destination</I>      The destination rectangle before the 
<I>BitBlt</I> or <I>StretchBlt</I> call.
<p><li><I>Pattern</I>      The current brush selected in the destination device context, 
repeated horizontally and vertically to be the same size as the destination rectangle.
</UL>
<P>The result is copied to the destination rectangle.
<P>The raster operations are conceptually similar to the drawing modes we 
encountered in <a href="ch05a.htm#94">Chapter 5</a>. The drawing modes govern the way in which a graphics object, such as 
a line, is combined with a destination. You'll recall that there were 16 drawing 
modes&#8212;that is, all the unique results obtained when 0s and 1s in the object being drawn were 
combined with 0s and 1s in the destination.
<P>The raster operations used with <I>BitBlt</I> and 
<I>StretchBlt</I> involve a combination of three objects, and this results in 256 raster operations. There are 256 ways to combine a 

source bitmap, a destination bitmap, and a pattern. Fifteen of these raster operations are 
given names&#8212;some of them rather obscure&#8212;defined in WINGDI.H. The others have 
numeric values that are shown in<B> </b> <i>/Platform 
SDK/Graphics and Multimedia Services/GDI/Raster Operation 
Codes/Ternary Raster Operations</I>.
<P>The 15 ROP codes that have names are shown here.

<table cellpadding=5 width="95%">
<tr>
<TD valign="top"> <B><I>Pattern (P):</I></B></td>
<TD valign="top"><b><I>1 1 1 1 0 0 0 0</I></B></td>
<td valign="top"> </td>
<td valign="top"> </td>
<td valign="top"> </td>
</tr>
<tr>
<TD valign="top"> <B><I>Source (S):</I> </B></td>
<TD valign="top"><b><I>1 1 0 0 1 1 0 0 </I></B></td>
<td valign="top"> </td>
<td valign="top"> </td>
<td valign="top"> </td>
</tr>
<tr>
<TD valign="top"> <B><I>Destination (D):</I></B></td>
<TD valign="top"><b><I>1 0 1 0 1 0 1 0</I></B></td>
<TD valign="top"><B><I>Boolean Operation</I></B></td>
<TD valign="top"><B><I>ROP Code</I></B></td>
<TD valign="top"><B><I>Name</I></B></td>
</tr>
<TR>
<TD valign="top">Result:</td>          
<TD valign="top">0 0 0 0 0 0 0 0</td>
<TD valign="top">0</td>
<TD valign="top">0x000042</td>
<TD valign="top">BLACKNESS</td>
</tr>
<TR>
<td valign="top"> </td>
<TD valign="top">0 0 0 1 0 0 0 1</td>  
<TD valign="top">&#126; (S &#166; D)</td>
<TD valign="top">0x1100A6</td>
<TD valign="top">NOTSRCERASE</td>
</tr>
<TR>
<td valign="top"> </td>
<TD valign="top">	 0 0 1 1 0 0 1 1</td>
<TD valign="top">&#126;S</td>
<TD valign="top">0x330008</td>
<TD valign="top">NOTSRCCOPY</td>
</tr>
<TR>
<td valign="top"> </td>
<TD valign="top">   0 1 0 0 0 1 0 0</td>
<TD valign="top">S &#38; &#126;D</td>
<TD valign="top">0x440328</td>
<TD valign="top">SRCERASE</td>
</tr>
<TR>
<td valign="top"> </td>
<TD valign="top">	0 1 0 1 0 1 0 1</td>
<TD valign="top">&#126;D</td>
<TD valign="top">0x550009</td>
<TD valign="top">DSTINVERT</td>
</tr>
<TR>
<td valign="top"> </td>
<TD valign="top">	0 1 0 1 1 0 1 0</td>
<TD valign="top">P &#94; D</td>
<TD valign="top">0x5A0049</td>
<TD valign="top">PATINVERT</td>
</tr>
<TR>
<td valign="top"> </td>
<TD valign="top">     0 1 1 0 0 1 1 0</td>
<TD valign="top">S &#94; D</td>
<TD valign="top">0x660046</td>
<TD valign="top">SRCINVERT</td>
</tr>
<TR>
<td valign="top"> </td>
<TD valign="top">	1 0 0 0 1 0 0 0</td>
<TD valign="top">S &#38; D</td>
<TD valign="top">0x8800C6</td>
<TD valign="top">SRCAND</td>
</tr>
<TR>
<td valign="top"> </td>
<TD valign="top">	 1 0 1 1 1 0 1 1</td>
<TD valign="top">&#126;S &#166; D</td>
<TD valign="top">0xBB0226</td>
<TD valign="top">MERGEPAINT</td>
</tr>
<TR>
<td valign="top"> </td>
<TD valign="top">	1 1 0 0 0 0 0 0</td>
<TD valign="top">P &#38; S</td>
<TD valign="top">0xC000CA</td>
<TD valign="top">MERGECOPY</td>
</tr>
<TR>
<td valign="top"> </td>
<TD valign="top">1 1 0 0 1 1 0 0</td>
<TD valign="top">S</td>
<TD valign="top">0xCC0020</td>
<TD valign="top">SRCCOPY</td>
</TR>
<TR>
<td valign="top"> </td>
<TD valign="top">1 1 1 0 1 1 1 0</td>
<TD valign="top">S &#166; D</td>
<TD valign="top">0xEE0086</td>
<TD valign="top">SRCPAINT</td>
</tr>
<TR>
<td valign="top"> </td>
<TD valign="top">1 1 1 1 0 0 0 0</td>
<TD valign="top">P</td>
<TD valign="top">0xF00021</td>
<TD valign="top">PATCOPY</td>
</tr>
<TR>
<td valign="top"> </td>
<TD valign="top">1 1 1 1 1 0 1 1</td>
<TD valign="top">P &#166; &#126;S &#166; D</td>
<TD valign="top">0xFB0A09</td>
<TD valign="top">PATPAINT</td>
</tr>
<TR>
<td valign="top"> </td>
<TD valign="top">1 1 1 1 1 1 1 1</td>
<TD valign="top">1</td>
<TD valign="top">0xFF0062</td>
<TD valign="top">WHITENESS</td>
</tr>
</TABLE>


<P>This table is important in understanding and using raster operations, so let's spend a 
little time examining it.
<P>In this table, the value in the ROP Code column is the number that is passed as 
the last argument to <I>BitBlt</I> or 
<I>StretchBlt</I>; the names in the Name column are defined 
in WINGDI.H to be those values. The low word of the ROP Code is a number that 
assists the device driver in carrying out the raster operation. The high word is a number 
between 0 and 255. This number is the same as the bit pattern shown in the second 
column, which is the result of a bitwise operation between the pattern, source, and 
destination bits shown at the top. The Boolean Operation column uses C syntax to show how 
the pattern, source, and destination are combined.
<P>To begin understanding this table, it's easiest to assume that you're dealing 
with a monochrome system (1 bit per pixel) in which 0 is black and 1 is white. The result 
of the BLACKNESS operation is all zeros regardless of the source, destination, and 
pattern, so the destination will be colored black. Similarly, WHITENESS always causes the 
destination to be colored white.
<P>Now suppose you use the raster operation PATCOPY. This causes the result bits 
to be the same as the pattern bits. The source and destination bitmaps are ignored. In 
other words, PATCOPY simply copies the current pattern to the destination rectangle.
<P>The PATPAINT raster operation involves a more complex operation. The result is 
equal to a bitwise OR operation between the pattern, the destination, and the inverse of 
the source. When the source bitmap is black (a 0 bit) the result is always white (a 1 bit). 
When the source is white (1), the result is also white if either the pattern or destination is 
white. In other words, the result will be black only if the source is white and both the 
pattern and the destination are black.
<P>A color display uses multiple bits for each pixel. The 
<I>BitBlt</I> and <I>StretchBlt</I> functions perform the bitwise operation between each of these color bits separately. For 
example, if the destination is red and the source is blue, a SRCPAINT raster operation will color 
the destination magenta. Keep in mind that the operations are performed on bits actually 
stored in memory on the video board. How these bits correspond to colors is dependent on 
how the palette of the video board is set up. Windows does this so that these raster 
operations work as you might predict. However, if you change the palette (as discussed in Chapter 
16), raster operations can produce unexpected results.
<P>See the section &quot;<A HREF="ch14e.htm#463">Nonrectangular Bitmap Images</A>&quot; later in this chapter for a 
good application of raster operations.

<A NAME="440"><h2>The Pattern Blt</h2></A><P>Besides <I>BitBlt</I> and <I>StretchBlt</I>, Windows also includes a function called 
<I>PatBlt</I> (&quot;pattern block transfer&quot;). This is the simplest of the three &quot;blt&quot; functions. Unlike 
<I>BitBlt</I> and <I>StretchBlt</I>, it uses only a destination device context. The syntax of 
<I>PatBlt</I> is
<p><pre>
PatBlt (hdc, x, y, cx, cy, dwROP) ;
</PRE>
<P>The <I>x</I>, <I>y</I>, <I>cx</I>, and 
<I>cy</I> arguments are in logical units. The logical point 
(<I>x</I>, <I>y</I>) specifies the upper left corner of a rectangle. The rectangle is 
<I>cx</I> units wide and <I>cy</I> units high. 
This is the rectangular area that <I>PatBlt</I> alters. The logical operation that 
<I>PatBlt</I> performs on the brush and the destination device context is determined by the 
<I>dwROP</I> argument, which is a subset of the ROP codes&#8212;that is, you can use only those ROP codes that do not 
involve a source destination device context. The 16 raster operations supported by 
<I>PatBlt</I> are shown in the table below.

<table cellpadding=5 width="95%">
<tr>
<TD valign="top"> <B><i>Pattern (P):</I></B></td>
<TD valign="top"><b><I>1 1 0 0 </I></B></td>
<TD valign="top"> </td>
<TD valign="top"> </td>
<TD valign="top"> </td>
</tr>
<tr>
<TD valign="top"> <B><I>Destination (D):</I></B></td>
<TD valign="top"><b><I>1 0 1 0 </I></B></td>
<TD valign="top"><B><I>Boolean Operation</I></B></td>
<TD valign="top"><B><I>ROP Code</I></B></td>
<TD valign="top"><b><I>Name</I></B></td>
</tr>
 <TR>
<TD valign="top">Result:</td>         
<TD valign="top">0 0 0 0</td>
<TD valign="top">0</td>     
<TD valign="top">0x000042</td>     
<TD valign="top">BLACKNESS</td>
</tr>
<TR>
<TD valign="top"> </td>
<TD valign="top">0 0 0 1</td>          
<TD valign="top">&#126;(P &#166; D)</td>
<TD valign="top">0x0500A9</td>
<TD valign="top"> </td>    
</tr>
<TR>
<TD valign="top"> </td>
<TD valign="top">0 0 1 0</td>
<TD valign="top">&#126;P &amp; D</td>
<TD valign="top">0x0A0329</td>
<TD valign="top"> </td>
</tr>
<TR>
<TD valign="top"> </td>
<TD valign="top">0 0 1 1</td>
<TD valign="top">&#126;P</td>
<TD valign="top">0x0F0001</td>
<TD valign="top"> </td>
</tr>
<TR>
<TD valign="top"> </td>
 <TD valign="top">0 1 0 0</td>
<TD valign="top">P &amp; &#126;D</td>
<TD valign="top">0x500325</td>
<TD valign="top"> </td>
</tr>
<TR>
<TD valign="top"> </td>
<TD valign="top">0 1 0 1</td>
<TD valign="top">&#126;D</td>
<TD valign="top">0x550009</td>
<TD valign="top">DSTINVERT</td>

</tr>
<TR>
<TD valign="top"> </td>
<TD valign="top">0 1 1 0</td>
<TD valign="top">P &#94; D</td>
<TD valign="top">0x5A0049</td>
<TD valign="top">PATINVERT</td>

</tr>
<TR>
<TD valign="top"> </td>
<TD valign="top">0 1 1 1</td>
<TD valign="top">&#126;(P &amp; D)</td>
<TD valign="top">0x5F00E9</td>
<TD valign="top"> </td>
</tr>
<TR>
<TD valign="top"> </td>
<TD valign="top">1 0 0 0</td>
<TD valign="top">P &#38; D</td>
<TD valign="top">0xA000C9</td>
<TD valign="top"> </td>
</tr>
<TR>
<TD valign="top"> </td>
<TD valign="top">1 0 0 1</td>
<TD valign="top">&#126;(P &#94; D)</td>
<TD valign="top">0xA50065</td>
<TD valign="top"> </td>
</tr>
<TR>
<TD valign="top"> </td>
<TD valign="top">1 0 1 0</td>
<TD valign="top">D</td>
<TD valign="top">0xAA0029</td>
<TD valign="top"> </td>
</tr>
<TR>
<TD valign="top"> </td>
<TD valign="top">1 0 1 1</td>
<TD valign="top">&#126;P &#166; D</td>
<TD valign="top">0xAF0229</td>
<TD valign="top"> </td>
</tr>
<TR>
<TD valign="top"> </td>
<TD valign="top">    1 1 0 0</td>
<TD valign="top">P </td>
<TD valign="top">0xF00021</td>
<TD valign="top">PATCOPY</td>
</tr>
<TR>
<TD valign="top"> </td>
<TD valign="top">   1 1 0 1</td>
<TD valign="top">P &#166; &#126;D</td>
<TD valign="top">0xF50225</td>
<TD valign="top"> </td>
</tr>
<TR>
<TD valign="top"> </td>
<TD valign="top">  1 1 1 0</td>
<TD valign="top">P &#166; D</td>
<TD valign="top">0xFA0089</td>
<TD valign="top"> </td>
</tr>
<TR>
<TD valign="top"> </td>
<TD valign="top">	1 1 1 1</td>
<TD valign="top">1</td>
<TD valign="top">0xFF0062</td>
<TD valign="top">WHITENESS</td>
</tr>
</TABLE>

<P>Some of the more common uses of <I>PatBlt</I> are shown below. If you want to draw 
a black rectangle, you call
<p><pre>
PatBlt (hdc, x, y, cx, cy, BLACKNESS) ;
</PRE>
<P>To draw a white rectangle, use
<p><pre>
PatBlt (hdc, x, y, cx, cy, WHITENESS) ;
</PRE>
<P>The function
<p><pre>
PatBlt (hdc, x, y, cx, cy, DSTINVERT) ;
</PRE>
<P>always inverts the colors of the rectangle. If WHITE_BRUSH is currently selected in 
the device context, the function
<p><pre>
PatBlt (hdc, x, y, cx, cy, PATINVERT) ;
</PRE>
<P>also inverts the rectangle.
<P>You'll recall that the <I>FillRect</I> function fills in a rectangular area with a brush:
<p><pre>
FillRect (hdc, &amp;rect, hBrush) ;
</PRE>
<P>The <I>FillRect</I> function is equivalent to the following code:
<p><pre>
hBrush = SelectObject (hdc, hBrush) ;
PatBlt (hdc, rect.left, rect.top,
             rect.right - rect.left,
             rect.bottom - rect.top, PATCOPY) ;
SelectObject (hdc, hBrush) ;
</PRE>
<P>In fact, this code is what Windows uses to execute the 
<I>FillRect</I> function. When you call
<p><pre>
InvertRect (hdc, &amp;rect) ;
</PRE>
<P>Windows translates it into the function:
<p><pre>
PatBlt (hdc, rect.left, rect.top,
             rect.right - rect.left,
             rect.bottom - rect.top, DSTINVERT) ;
</PRE>
<P>When I introduced the syntax of the 
<I>PatBlt</I> function, I said that the point 
(<I>x</I>, <I>y</I>) specifies the upper left corner of a rectangle and that this rectangle is 
<I>cx</I> units wide and <I>cy</I> units high. The statement is not entirely accurate. 
<I>BitBlt</I>, <I>PatBlt</I>, and 
<I>StretchBlt</I> are the only GDI drawing functions that specify logical rectangular coordinates in terms of a logical 
width and height measured from a single corner. All the other GDI drawing functions that 
use rectangular bounding boxes require that coordinates be specified in terms of an upper 
left corner and a lower right corner. For the MM_TEXT mapping mode, the above 
description of the <I>PatBlt</I> parameters is accurate. For the metric mapping modes, however, it's not. 
If you use positive values of <I>cx</I> and 
<I>cy</I>, the point (<I>x</I>, <I>y</I>) will be the lower left corner of 
the rectangle. If you want (<I>x</I>, <I>y</I>) to be the upper left corner of the rectangle, the 
<I>cy</I> argument must be set to the negative height of the rectangle.
<p>To be more precise, the rectangle that 
<I>PatBlt</I> colors has a logical width given by 
the absolute value of <I>cx</I> and a logical height given by the absolute value of 
<I>cy</I>. These two arguments can be negative. The rectangle is defined by two corners given by the 
logical points (<I>x</I>, <I>y</I>) and (<I>x</I> + 
<I>cx</I>, <I>y</I> + <I>cy</I>). The upper left corner of the rectangle is always 
included in the area that <I>PatBlt</I> modifies. The lower right corner is outside the rectangle. 
Depending on the mapping mode and the signs of the 
<I>cx</I> and <I>cy</I> parameters, the upper left corner 
of this rectangle could be the point (<I>x</I>, 
<I>y</I>) or (<I>x</I>, <I>y</I> + <I>cy</I>) or 
(<I>x</I> + <I>cx</I>, <I>y</I>) or (<I>x</I> + 
<I>cx</I>, <I>y</I> + <I>cy</I>).
<p>If you've set the mapping mode to MM_LOENGLISH and you want to use 
<I>PatBlt</I> on the square inch at the upper left corner of the client area, you can use
<p><pre>
PatBlt (hdc, 0, 0, 100, -100, dwROP) ;
</PRE>
<P>or
<p><pre>
PatBlt (hdc, 0, -100, 100, 100, dwROP) ;
</PRE>
<P>or
<p><pre>
PatBlt (hdc, 100, 0, -100, -100, dwROP) ;
</PRE>
<P>or
<p><pre>
PatBlt (hdc, 100, -100, -100, 100, dwROP) ;
</PRE>
<P>The easiest way to set the correct parameters to 
<I>PatBlt</I> is to set <I>x</I> and <I>y</I> to the 
upper left corner of the rectangle. If your mapping mode defines 
<I>y</I> coordinates as increasing as you move up the display, use a negative value for the 
<I>cy</I> parameter. If your mapping mode defines 
<I>x</I> coordinates as increasing to the left (which is almost unheard 
of), use a negative value for the <I>cx</I> parameter.

</BODY>
</HTML>





