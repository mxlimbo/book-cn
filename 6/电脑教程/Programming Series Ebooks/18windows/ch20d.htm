<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Thread Synchronization</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="728"><h1>Thread Synchronization</h1></A><P>About once a year, the traffic lights at the busy intersection outside my apartment 
window stop working. The result is chaos, and while the cars usually avoid actually hitting 
each other, they often come close.
<P>We might term the intersection of two roads a &quot;critical section.&quot; A southbound 
car and a westbound car cannot pass through an intersection at the same time without 
hitting each other. Depending on the traffic volume, different approaches are taken to solve 
the problem. For light traffic at an intersection with high visibility, drivers can be trusted 
to properly yield. More traffic might require a stop sign, and still heavier traffic would 
require traffic lights. The traffic lights help coordinate the activity of the intersection (as long 
as they work, of course).

<A NAME="729"><h2>The Critical Section</h2></A><P>In a single-tasking operating system, traditional computer programs don't need traffic 
lights to help them coordinate their activities. They run as if they owned the road, which 
they do. There is nothing to interfere with what they do.
<P>Even in a multitasking operating system, most programs seemingly run 
independently of each other. But some problems can arise. For example, two programs could need 
to read from and write to the same file at the same time. In such cases, the operating 
system provides a mechanism of shared files and record locking to help out.
<P>However, in an operating system that supports multithreading, the situation gets 
messy and potentially dangerous. It is not uncommon for two or more threads to share some 
data. For example, one thread could update one or more variables and another thread 
could use those variables. Sometimes this poses a problem, and sometimes it doesn't. (Keep 
in mind that the operating system can switch control from one thread to another 
between machine code instructions only. If only a single integer is being shared among the 
threads, then changes to this variable usually occur in a single instruction and potential 
problems are minimized.)
<P>However, suppose that the threads share several variables or a data structure. 
Often, these multiple variables or the fields of the structure must be consistent among 
themselves. The operating system could interrupt a thread in the middle of updating these 
variables. The thread that uses these variables would then be dealing with inconsistent data.
<P>The result is a collision, and it's not difficult to imagine how an error like this 
could crash the program. What we need are the programming equivalents of traffic lights to 
help coordinate and synchronize the thread traffic. That's the critical section. Basically, a 
critical section is a block of code that should not be interrupted.
<P>There are four functions for using critical sections. To use these functions, you 
must define a critical section object, which is global variable of type CRITICAL_SECTION. 
For example,
<P>CRITICAL_SECTION cs ;
<P>This CRITICAL_SECTION data type is a structure, but the fields are used only internally 
to Windows. This critical section object must first be initialized by one of the threads in 
the program by calling
<P>InitializeCriticalSection (&amp;cs) ;
<P>This creates a critical section object named 
<I>cs</I>. The online documentation for this 
function includes the following warnings: &quot;A critical section object cannot be moved or copied. 
The process must also not modify the object, but must treat it as logically opaque.&quot; This 
can be translated as &quot;Don't mess around with it, and don't even look at it.&quot;
<P>After the critical section object has been initialized, a thread enters a critical 
section by calling
<P>EnterCriticalSection (&amp;cs) ;
<P>At this point, the thread is said to &quot;own&quot; the critical section object. No two threads can 
own the critical section object at the same time. Thus, if another thread has entered a 
critical section, the next thread calling 
<I>EnterCriticalSection</I> with the same critical section 
object will be suspended in the function call. The function will return only when the first 
thread leaves the critical section by calling
<P>LeaveCriticalSection (&amp;cs) ;
<P>At that time, the second thread&#8212;suspended in its call to 
<I>EnterCriticalSection</I>&#8212;will own the critical section and the function call will return, allowing the thread to proceed.
<P>When the critical section object is no longer needed by the program, it can be 
deleted by calling
<P>DeleteCriticalSection (&amp;cs) ;
<P>This frees up any system resources that might have been allocated to maintain the 
critical section object.
<P>This critical section mechanism involves &quot;mutual exclusion,&quot; a term that will 
come up again as we continue to explore thread synchronization. Only one thread can own 
a critical section at any time. Thus, one thread can enter a critical section, set the fields of 
a structure, and exit the critical section. Another thread using the structure would also 
enter a critical section before accessing the fields of the structure and then exit the critical section.
<P>Note that you can define multiple critical section objects&#8212;for example, <I>cs1</I> and 
<I>cs2</I>. If a program has four threads and the first two threads share some data, they can use 
one critical section object, and if the other two threads share some other data, they can use 
a second critical section object.
<P>Also note that you should be careful when using a critical section in your main 
thread. If the secondary thread spends a long time in its own critical section, it could hang the 
main thread for an inordinate amount of time. The secondary thread would probably just 
want to use the critical section to copy the fields of the structure to its own local variables.
<P>One limitation with critical sections is that they can be used for coordinating 
threads within a single process only. But there are cases where you need to coordinate two 
different processes that share a resource (such as shared memory). You can't use 
critical sections for that; instead, you must use something oddly called a &quot;mutex object.&quot; The 
fabricated word &quot;mutex&quot; stands for &quot;mutual exclusion,&quot; and that's precisely the goal here. 
You want to prevent threads of a program from being interrupted while updating or using 
some shared memory or other resources.

</BODY>
</HTML>






