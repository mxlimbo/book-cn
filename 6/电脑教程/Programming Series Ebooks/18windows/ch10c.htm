<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Menus</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="293"><h1>Menus</h1></A>
<p>Do you remember the Monty Python skit about the cheese shop? Here's how it goes: 
A guy comes into a cheese shop and wants a particular type of cheese. The shop doesn't 
have it. So he asks for another type of cheese, and another, and another, and another 
(eventually totaling about 40 types, most of which are quite obscure), and still the answer is 
&quot;No, no, no, no, no.&quot; Ultimately, there's a shooting involved.

<P>This whole unfortunate incident could have been avoided through the use of 
menus. A menu is a list of available options. A menu tells a hungry patron what the kitchen 
can serve up and&#8212;for a Windows program&#8212;tells the user what operations an application 
is capable of performing.

<p>A menu is probably the most important part of the consistent user interface 
that Windows programs offer, and adding a menu to your program is a relatively easy 
part of Windows programming. You define the menu in Developer Studio. Each 
selectable menu item is given a unique ID number. You specify the name of the menu in the 
window class structure. When the user chooses a menu item, Windows sends your 
program a WM_COMMAND message containing that ID.

<p>After discussing menus, I'll conclude this chapter with a section on keyboard 
accelerators, which are key combinations that are used primarily to duplicate menu functions.

<A NAME="294"><h2>Menu Concepts</h2></A>
<p>A window's menu bar is displayed immediately below the caption bar. This menu bar 
is sometimes called a program's &quot;main menu&quot; or the &quot;top-level menu.&quot; Items listed in the 
top-level menu usually invoke drop-down menus, which are also called &quot;popup menus&quot; 
or &quot;submenus.&quot; You can also define multiple nestings of popups: that is, an item on a 
popup menu can invoke another popup menu. Sometimes items in popup menus invoke a 
dialog box for more information. (Dialog boxes are covered in the next chapter.) Most 
parent windows have, to the far left of the caption bar, a display of the program's small 
icon. This icon invokes the system menu, which is really another popup menu.

<p>Menu items in popups can be &quot;checked,&quot; which means that Windows draws a 
small check mark to the left of the menu text. The use of check marks lets the user choose 
different program options from the menu. These options can be mutually exclusive, but 
they don't have to be. Top-level menu items cannot be checked.

<p>Menu items in the top-level menu or in popup menus can be &quot;enabled,&quot; 
&quot;disabled,&quot; or &quot;grayed.&quot; The words &quot;active&quot; and &quot;inactive&quot; are sometimes used synonymously 
with &quot;enabled&quot; and &quot;disabled.&quot; Menu items flagged as enabled or disabled look the same to 
the user, but a grayed menu item is displayed in gray text.

<p>From the perspective of the user, enabled, disabled, and grayed menu items can 
all be &quot;selected&quot; (highlighted). That is, the user can click the mouse on a disabled menu 
item, or move the reverse-video cursor bar to a disabled menu item, or trigger the menu 
item by using the item's key letter. However, from the perspective of your program, 
enabled, disabled, and grayed menu items function differently. Windows sends your program 
a WM_COMMAND message only for enabled menu items. You use disabled and grayed 
menu items for options that are not currently valid. If you want to let the user know the 
option is not valid, make it grayed.

<A NAME="295"><h2>Menu Structure</h2></A>
<p>When you create or change menus in a program, it's useful to think of the top-level 
menu and each popup menu as being separate menus. The top-level menu has a menu 
handle, each popup menu within a top-level menu has its own menu handle, and the system 
menu (which is also a popup) has a menu handle.

<p>Each item in a menu is defined by three characteristics. The first characteristic is 
what appears in the menu. This is either a text string or a bitmap. The second characteristic 
is either an ID number that Windows sends to your program in a WM_COMMAND 
message or the handle to a popup menu that Windows displays when the user chooses that 
menu item. The third characteristic describes the attribute of the menu item, including 
whether the item is disabled, grayed, or checked.

<A NAME="296"><h2>Defining the Menu</h2></A>
<p>To use Developer Studio to add a menu to your program's resource script, select 
Resource from the Insert menu and pick Menu. (But you probably figured that out already.) You 
can then interactively define your menu. Each item in the menu has an associated Menu 
Item Properties dialog box that indicates the item's text string. If the Pop-up box is 
checked, the item invokes a popup menu and no ID is associated with the item. If the Pop-up 
box is not checked, the item generates a WM_COMMAND message with a specified ID. 
These two types of menu items will appear in the resource script as POPUP and 
MENUITEM statements, respectively.

<p>When you type the text for an item in a menu, you can type an ampersand (&amp;) 
to indicate that the following character is to be underlined when Windows displays the 
menu. Such an underlined character is the character Windows searches for when you select a 
menu item using the Alt key. If you don't include an ampersand in the text, no underline 
will appear, and Windows will instead use the first letter of the menu item's text for 
Alt-key searches.

<p>If you select the Grayed option in the Menu Items Properties dialog box, the 
menu item is inactive, its text is grayed, and the item does not generate a WM_COMMAND 
message. If you select the Inactive option, the menu item is inactive and does not generate 
a WM_COMMAND message but its text is displayed normally. The Checked option places 
a check mark next to a menu item. The Separator option causes a horizontal separator 
bar to be drawn on popup menus.

<p>For items in popup menus, you can use the columnar tab character \t in the 
character string. Text following the \t is placed in a new column spaced far enough to the 
right to accommodate the longest text string in the first column of the popup. We'll see 
how this works when we look at keyboard accelerators toward the end of this chapter. A \a 
in the character string right-justifies the text that follows it.

<p>The ID values you specify are the numbers that Windows sends to the window 
procedure in menu messages. The ID values should be unique within a menu. By 
convention, I use identifiers beginning with the letters IDM (&quot;ID for a Menu&quot;).

<A NAME="297"><h2>Referencing the Menu in Your Program</h2></A>
<p>Most Windows applications have only one menu in the resource script. You can give 
the menu a text name that is the same as the name of the program. Programmers often 
use the name of the program as the name of the menu so that the same character string 
can be used for the window class, the name of the program's icon, and the name of the 
menu. The program then makes reference to this menu in the definition of the window class:

<p><pre>
wndclass.lpszMenuName = szAppName ;
</PRE>

<p>Although specifying the menu in the window class is the most common way to 
reference a menu resource, that's not the only way to do it. A Windows application can 
load a menu resource into memory with the 
<I>LoadMenu</I> function, which is similar to the 
<I>LoadIcon</I> and <I>LoadCursor</I> functions described earlier. 
<I>LoadMenu</I> returns a handle to the menu. If you use a name for the menu in the resource script, the statement looks like this:

<p><pre>
hMenu = LoadMenu (hInstance, TEXT (&quot;MyMenu&quot;)) ;
</PRE>

<p>If you use a number, the <I>LoadMenu</I> call takes this form:

<p><pre>
hMenu = LoadMenu (hInstance, MAKEINTRESOURCE (ID_MENU)) ;
</PRE>

<p>You can then specify this menu handle as the ninth parameter to 
<I>CreateWindow</I>:

<p><pre>
hwnd = CreateWindow (TEXT (&quot;MyClass&quot;), TEXT (&quot;Window Caption&quot;),
                     WS_OVERLAPPEDWINDOW,
                     CW_USEDEFAULT, CW_USEDEFAULT,
                     CW_USEDEFAULT, CW_USEDEFAULT,
                     NULL, hMenu, hInstance, NULL) ;
</PRE>

<p>In this case, the menu specified in the 
<I>CreateWindow</I> call overrides any menu 
specified in the window class. You can think of the menu in the window class as being a 
default menu for the windows based on the window class if the ninth parameter to 
<I>CreateWindow</I> is NULL. Therefore, you can use different menus for several windows based on the 
same window class.
You can also have a NULL menu name in the window class and a NULL menu 
handle in the <I>CreateWindow</I> call and assign a menu to a window after the window has 
been created:

<p><pre>
SetMenu (hwnd, hMenu) ;
</PRE>

<p>This form lets you dynamically change a window's menu. We'll see an example of this 
in the NOPOPUPS program, shown later in this chapter.
Any menu that is attached to a window is destroyed when the window is 
destroyed. Any menus not attached to a window should be explicitly destroyed by calls to 
<I>DestroyMenu</I> before the program terminates.

<A NAME="298"><h2>Menus and Messages</h2></A>
<p>Windows usually sends a window procedure several different messages when the 
user selects a menu item. In most cases, your program can ignore many of these messages 
and simply pass them to <I>DefWindowProc</I>. One such message is WM_INITMENU with the 
following parameters:

<table cellpadding=5 width="95%">
<tr><td valign="top"><I>wParam</I>:</td><td valign="top">Handle to main menu</td></tr>
<tr><td valign="top"><I>lParam</I>:</td><td valign="top">0</td></tr>
</table>

<p>The value of <I>wParam</I> is the handle to your main menu even if the user is selecting an 
item from the system menu. Windows programs generally ignore the WM_INITMENU 
message. Although the message exists to give you the opportunity to change the menu before 
an item is chosen, I suspect any changes to the top-level menu at this time would be 
disconcerting to the user.

<p>Your program also receives WM_MENUSELECT messages. A program can 
receive many WM_MENUSELECT messages as the user moves the cursor or mouse among the 
menu items. This is helpful for implementing a status bar that contains a full text description 
of the menu option. The parameters that accompany WM_MENUSELECT are as follows:

<table cellpadding=5 width="95%">
<tr><td valign="top">LOWORD (<I>wParam</I>):</td><td valign="top">Selected item: Menu ID or popup menu index</td></tr>

<tr><td valign="top">HIWORD (<I>wParam</I>):</td><td valign="top">Selection flags</td></tr>
<tr><td valign="top"><I>lParam</I>:</td><td valign="top">Handle to menu containing selected item</td></tr>
</table>

<p>WM_MENUSELECT is a menu-tracking message. The value of 
<I>wParam</I> tells you what item of the menu is currently selected (highlighted). The &quot;selection flags&quot; in the high word 
of <I>wParam</I> can be a combination of the following: MF_GRAYED, MF_DISABLED, MF_

<p>CHECKED, MF_BITMAP, MF_POPUP, MF_HELP, MF_SYSMENU, and 
MF_MOUSESELECT. You may want to use WM_MENUSELECT if you need to change something in the 
client area of your window based on the movement of the highlight among the menu items. 
Most programs pass this message to 
<I>DefWindowProc</I>.

<p>When Windows is ready to display a popup menu, it sends the window 
procedure a WM_INITMENUPOPUP message with the following parameters:

<table cellpadding=5 width="95%">
<tr><td valign="top"><I>wParam</I>:</td><td valign="top">Popup menu handle</td></tr>
<tr><td valign="top">LOWORD (<I>lParam</I>):</td><td valign="top">Popup index</td></tr>
<tr><td valign="top"><p>HIWORD (<I>lParam</I>):</td><td valign="top">1 for system menu, 0 otherwise</td></tr>
</table>

This message is important if you need to enable or disable items in a popup menu 
before it is displayed. For instance, suppose your program can copy text from the clipboard 
using the Paste command on a popup menu. When you receive a 
WM_INITMENUPOPUP message for that popup, you should determine whether the clipboard has text in it. If 
it doesn't, you should gray the Paste menu item. We'll see an example of this in the 
revised POPPAD program shown toward the end of this chapter.

<p>The most important menu message is WM_COMMAND. This message indicates 
that the user has chosen an enabled menu item from your window's menu. You'll recall 
from <a href="ch08a.htm#215">Chapter 8</a> that WM_COMMAND messages also result from child window controls. If 
you happen to use the same ID codes for menus and child window controls, you can 
differentiate between them by examining the value of 
<I>lParam</I>, which will be 0 for a menu item.
<table cellpadding=5 width="95%">
<tr><td valign="top"></td><td valign="top"><b><i>Menus</i></b></td><td valign="top"><b><i>Controls</i></b></td></tr>

<tr><td valign="top">LOWORD (<I>wParam</I>):</td><td valign="top">Menu ID</td><td valign="top">Control ID</td></tr>
<tr><td valign="top">HIWORD (<I>wParam</I>):</td><td valign="top">0</td><td valign="top">Notification code</td></tr>
<tr><td valign="top"><i>lParam</I>:</td><td valign="top">0</td><td valign="top">Child window handle</td></tr>
</table>
<p>The WM_SYSCOMMAND message is similar to the WM_COMMAND message 
except that WM_SYSCOMMAND signals that the user has chosen an enabled menu item from 
the system menu:
<table cellpadding=5 width="95%">
<tr><td valign="top"><I>wParam</I>:</td><td valign="top">Menu ID</td></tr>
<tr><td valign="top"><I>lParam</I>:</td><td valign="top">0</td></tr>
</table>
<p>However, if the WM_SYSCOMMAND message is the result of a mouse click, 
LOWORD (<I>lParam</I>) and HIWORD (<I>lParam</I>) will contain the 
<I>x</I> and <I>y</I> screen coordinates of the 
mouse cursor's location.

<p>For WM_SYSCOMMAND, the menu ID indicates which item on the system menu 
has been chosen. For the predefined system menu items, the bottom four bits should be 
masked out by ANDing with 0xFFF0. The resultant value will be one of the following: 
SC_SIZE, SC_MOVE, SC_MINIMIZE, SC_MAXIMIZE, SC_NEXTWINDOW, SC_PREVWINDOW, SC_CLOSE, SC_VSCROLL, SC_HSCROLL, SC_ARRANGE, SC_RESTORE, and SC_TASKLIST. 
In addition, <I>wParam</I> can be SC_MOUSEMENU or SC_KEYMENU.

<p>If you add menu items to the system menu, the low word of 
<I>wParam</I> will be the menu ID that you define. To avoid conflicts with the predefined menu IDs, use 
values below 0xF000. It is important that you pass normal WM_SYSCOMMAND messages 
to <I>DefWindowProc</I>. If you do not, you'll effectively disable the normal system menu commands.
The final message we'll look at is WM_MENUCHAR, which isn't really a menu 
message at all. Windows sends this message to your window procedure in one of two 
circumstances: if the user presses Alt and a character key that does not correspond to a 
menu item, or, when a popup is displayed, if the user presses a character key that does 
not correspond to an item in the popup. The parameters that accompany the 
WM_MENUCHAR message are as follows:

<table cellpadding=5 width="95%">
<tr><td valign="top">LOWORD (<I>wParam</I>):</td><td valign="top">Character code (ASCII or Unicode)</td></tr>
<tr><td valign="top">HIWORD (<I>wParam</I>):</td><td valign="top">Selection code</td></tr>
<tr><td valign="top"><I>lParam</I>:</td><td valign="top">Handle to menu</td></tr>
</table>

<p>The selection code is:
<UL>

<p><li><I>     0</I>      No popup is displayed.

<p><li><I>     MF_POPUP</I>     Popup is displayed.

<p><li><I>     MF_SYSMENU</I>      System menu popup is displayed.
</UL>

<p>Windows programs usually pass this message to 
<I>DefWindowProc</I>, which normally returns a 0 to Windows, which causes Windows to beep. We'll see a use for the 
WM_MENUCHAR message in the GRAFMENU program shown in <a href="ch14a.htm#426">Chapter 14</a>.

<A NAME="299"><h2>A Sample Program</h2></A>
<p>Let's look at a simple example. The MENUDEMO program, shown in Figure 10-6, has 
five items in the main menu&#8212;File, Edit, Background, Timer, and Help. Each of these items 
has a popup. MENUDEMO does the simplest and most common type of menu 

processing, which involves trapping WM_COMMAND messages and checking the low word of 
<I>wParam</I>.


<p><B>Figure 10-6.</b> <i>The MENUDEMO program.</I>
<TABLE cellpadding=5 width="95%"><TR><TD>

<A NAME="300"><h3>MENUDEMO.C</h3></A>
<p><pre>
/*-----------------------------------------
   MENUDEMO.C -- Menu Demonstration
                 (c) Charles Petzold, 1998
  -----------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;resource.h&quot;

#define ID_TIMER 1

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

TCHAR szAppName[] = TEXT (&quot;MenuDemo&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = szAppName ;
     wndclass.lpszClassName = szAppName ;

     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Menu Demonstration&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static int idColor [5] = { WHITE_BRUSH,  LTGRAY_BRUSH, GRAY_BRUSH,
                                DKGRAY_BRUSH, BLACK_BRUSH } ;
     static int iSelection = IDM_BKGND_WHITE ;
     HMENU      hMenu ;
     
     switch (message)
     {
     case WM_COMMAND:
          hMenu = GetMenu (hwnd) ;
          
          switch (LOWORD (wParam))
          {
          case IDM_FILE_NEW:
          case IDM_FILE_OPEN:
          case IDM_FILE_SAVE:
          case IDM_FILE_SAVE_AS:
               MessageBeep (0) ;
               return 0 ;

          case IDM_APP_EXIT:
               SendMessage (hwnd, WM_CLOSE, 0, 0) ;
               return 0 ;
               
          case IDM_EDIT_UNDO:
          case IDM_EDIT_CUT:
          case IDM_EDIT_COPY:
          case IDM_EDIT_PASTE:
          case IDM_EDIT_CLEAR:
               MessageBeep (0) ;
               return 0 ;
               
          case IDM_BKGND_WHITE:         // Note: Logic below
          case IDM_BKGND_LTGRAY:        //   assumes that IDM_WHITE
          case IDM_BKGND_GRAY:          //   through IDM_BLACK are
          case IDM_BKGND_DKGRAY:        //   consecutive numbers in
          case IDM_BKGND_BLACK:         //   the order shown here.
               
               CheckMenuItem (hMenu, iSelection, MF_UNCHECKED) ;
               iSelection = LOWORD (wParam) ;
               CheckMenuItem (hMenu, iSelection, MF_CHECKED) ;
               
               SetClassLong (hwnd, GCL_HBRBACKGROUND, (LONG) 
                    GetStockObject 
                             (idColor [LOWORD (wParam) - IDM_BKGND_WHITE])) ;
               
               InvalidateRect (hwnd, NULL, TRUE) ;
               return 0 ;
               
          case IDM_TIMER_START:
               if (SetTimer (hwnd, ID_TIMER, 1000, NULL))
               {
                    EnableMenuItem (hMenu, IDM_TIMER_START, MF_GRAYED) ;
                    EnableMenuItem (hMenu, IDM_TIMER_STOP,  MF_ENABLED) ;
               }
               return 0 ;
               
          case IDM_TIMER_STOP:
               KillTimer (hwnd, ID_TIMER) ;
               EnableMenuItem (hMenu, IDM_TIMER_START, MF_ENABLED) ;
               EnableMenuItem (hMenu, IDM_TIMER_STOP,  MF_GRAYED) ;
               return 0 ;

          case IDM_APP_HELP:
               MessageBox (hwnd, TEXT (&quot;Help not yet implemented!&quot;),
                           szAppName, MB_ICONEXCLAMATION | MB_OK) ;
               return 0 ;
               
          case IDM_APP_ABOUT:
               MessageBox (hwnd, TEXT (&quot;Menu Demonstration Program\n&quot;)
                                 TEXT (&quot;(c) Charles Petzold, 1998&quot;),
                           szAppName, MB_ICONINFORMATION | MB_OK) ;
               return 0 ;
          }
          break ;
          
          case WM_TIMER:
               MessageBeep (0) ;
               return 0 ;
               
          case WM_DESTROY:
               PostQuitMessage (0) ;
               return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

<P><TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="301"><h3>MENUDEMO.RC (excerpts)</h3></A>
<p><pre>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;

/////////////////////////////////////////////////////////////////////////////
// Menu

MENUDEMO MENU DISCARDABLE 
BEGIN
    POPUP &quot;&amp;File&quot;
    BEGIN
        MENUITEM &quot;&amp;New&quot;,                        IDM_FILE_NEW
        MENUITEM &quot;&amp;Open&quot;,                       IDM_FILE_OPEN
        MENUITEM &quot;&amp;Save&quot;,                       IDM_FILE_SAVE
        MENUITEM &quot;Save &amp;As...&quot;,                 IDM_FILE_SAVE_AS
        MENUITEM SEPARATOR
        MENUITEM &quot;E&amp;xit&quot;,                       IDM_APP_EXIT
    END
    POPUP &quot;&amp;Edit&quot;
    BEGIN
        MENUITEM &quot;&amp;Undo&quot;,                       IDM_EDIT_UNDO
        MENUITEM SEPARATOR
        MENUITEM &quot;C&amp;ut&quot;,                        IDM_EDIT_CUT
        MENUITEM &quot;&amp;Copy&quot;,                       IDM_EDIT_COPY
        MENUITEM &quot;&amp;Paste&quot;,                      IDM_EDIT_PASTE
        MENUITEM &quot;De&amp;lete&quot;,                     IDM_EDIT_CLEAR
    END
    POPUP &quot;&amp;Background&quot;
    BEGIN
        MENUITEM &quot;&amp;White&quot;,                      IDM_BKGND_WHITE, CHECKED
        MENUITEM &quot;&amp;Light Gray&quot;,                 IDM_BKGND_LTGRAY
        MENUITEM &quot;&amp;Gray&quot;,                       IDM_BKGND_GRAY
        MENUITEM &quot;&amp;Dark Gray&quot;,                  IDM_BKGND_DKGRAY
        MENUITEM &quot;&amp;Black&quot;,                      IDM_BKGND_BLACK
    END
    POPUP &quot;&amp;Timer&quot;
    BEGIN
        MENUITEM &quot;&amp;Start&quot;,                      IDM_TIMER_START
        MENUITEM &quot;S&amp;top&quot;,                       IDM_TIMER_STOP, GRAYED
    END
    POPUP &quot;&amp;Help&quot;
    BEGIN
        MENUITEM &quot;&amp;Help...&quot;,                    IDM_APP_HELP
        MENUITEM &quot;&amp;About MenuDemo...&quot;,          IDM_APP_ABOUT
    END
END
</pre>
</td></tr></table>

<P><TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="302"><h3>RESOURCE.H (excerpts)</h3></A>
<p><pre>
// Microsoft Developer Studio generated include file.
// Used by MenuDemo.rc

#define IDM_FILE_NEW                    40001
#define IDM_FILE_OPEN                   40002
#define IDM_FILE_SAVE                   40003
#define IDM_FILE_SAVE_AS                40004
#define IDM_APP_EXIT                    40005
#define IDM_EDIT_UNDO                   40006
#define IDM_EDIT_CUT                    40007
#define IDM_EDIT_COPY                   40008
#define IDM_EDIT_PASTE                  40009
#define IDM_EDIT_CLEAR                  40010
#define IDM_BKGND_WHITE                 40011
#define IDM_BKGND_LTGRAY                40012
#define IDM_BKGND_GRAY                  40013
#define IDM_BKGND_DKGRAY                40014
#define IDM_BKGND_BLACK                 40015
#define IDM_TIMER_START                 40016
#define IDM_TIMER_STOP                  40017
#define IDM_APP_HELP                    40018
#define IDM_APP_ABOUT                   40019
</pre>
</td></tr></table>

<p>The MENUDEMO.RC resource script should give you hints on defining the menu. 
The menu has a text name of &quot;MenuDemo.&quot; Most items have underlined letters, which 
means you must type an ampersand (&amp;) before the letter. The MENUITEM SEPARATOR 
statement results from checking the Separator box in the Menu Item Properties dialog box. 
Notice that one item in the menu has the Checked option and another has the Grayed 
option. Also, the five items in the Background popup menu should be entered in the order 
shown to ensure that the identifiers are in numeric order; the program relies on this. 
<p>All the 
menu item identifiers are defined in RESOURCE.H.
The MENUDEMO program simply beeps when it receives a WM_COMMAND 
message for most items in the File and Edit popups. The Background popup lists five 
stock brushes that MENUDEMO can use to color the background. In the MENUDEMO.RC 
resource script, the White menu item (with a menu ID of IDM_BKGND_WHITE) is flagged 
as CHECKED, which places a check mark next to the item. In MENUDEMO.C, the value 
of <I>iSelection</I> is initially set to IDM_BKGND_WHITE.

<p>The five brushes on the Background popup menu are mutually exclusive. 
When MENUDEMO.C receives a WM_COMMAND message where 
<I>wParam</I> is one of these five items on the Background popup, it must remove the check mark from the previously 
chosen background color and add a check mark to the new background color. To do this, it 
first gets a handle to its menu:

<p><pre>
hMenu = GetMenu (hwnd) ;
</PRE>

<p>The <I>CheckMenuItem</I> function is used to uncheck the currently checked item:

<p><pre>
CheckMenuItem (hMenu, iSelection, MF_UNCHECKED) ;
</PRE>

<p>The <I>iSelection</I> value is set to the value of 
<I>wParam</I>, and the new background color is checked:

<p><pre>
iSelection = wParam ;
CheckMenuItem (hMenu, iSelection, MF_CHECKED) ;
</PRE>

<p>The background color in the window class is then replaced with the new background 
color, and the window client area is invalidated. Windows erases the window, using the new 
background color.

<p>The Timer popup lists two options&#8212;Start and Stop. Initially, the Stop option is 
grayed (as indicated in the menu definition for the resource script). When you choose the 
Start option, MENUDEMO tries to start a timer and, if successful, grays the Start option and 
makes the Stop option active:

<p><pre>
EnableMenuItem (hMenu, IDM_TIMER_START, MF_GRAYED) ;
EnableMenuItem (hMenu, IDM_TIMER_STOP,  MF_ENABLED) ;
</PRE>

<p>On receipt of a WM_COMMAND message with 
<I>wParam</I> equal to IDM_TIMER_STOP, MENUDEMO kills the timer, activates the Start option, and grays the Stop option:

<p><pre>
EnableMenuItem (hMenu, IDM_TIMER_START, MF_ENABLED) ;
EnableMenuItem (hMenu, IDM_TIMER_STOP,  MF_GRAYED) ;
</PRE>

<p>Notice that it's impossible for MENUDEMO to receive a WM_COMMAND 
message with <I>wParam</I> equal to IDM_TIMER_START while the timer is going. Similarly, it's 
impossible to receive a WM_COMMAND with 
<I>wParam</I> equal to IDM_TIMER_STOP while the timer is not going.
When MENUDEMO receives a WM_COMMAND message with the 
<I>wParam</I> parameter equal to IDM_APP_ABOUT or IDM_APP_HELP, it displays a message box. (In the 
next chapter, we'll change this to a dialog box.)

<p>When MENUDEMO receives a WM_COMMAND message with 
<I>wParam</I> equal to IDM_APP_EXIT, it sends itself a WM_CLOSE message. This is the same message 
that <I>DefWindowProc</I> sends the window procedure when it receives a 
WM_SYSCOMMAND message with <I>wParam</I> equal to SC_CLOSE. We'll examine this more in the POPPAD2 
program shown near the end of this chapter.

<A NAME="303"><h2>Menu Etiquette</h2></A>
<p>The format of the File and Edit popups in MENUDEMO is quite similar to those in 
other Windows programs. One of the objectives of Windows is to provide a user with a 
recognizable interface that does not require relearning basic concepts for each program. It 
certainly helps if the File and Edit menus look the same in every Windows program and 
use the same letters for selection in combination with the Alt key.

<p>Beyond the File and Edit popups, the menus of most Windows programs will 
probably be different. When designing a menu, you should look at existing Windows 
programs and aim for some consistency. Of course, if you think these other programs are wrong 
and you know the right way to do it, nobody's going to stop you. Also keep in mind that 
revising a menu usually requires revising only the resource script and not your program 
code. You can move menu items around at a later time without many problems.

<p>Although your program menu can have MENUITEM statements on the top level, 
these are not typical because they can be too easily chosen by mistake. If you do this, use 
an exclamation point after the text string to indicate that the menu item does not invoke a popup.

<A NAME="304"><h2>Defining a Menu the Hard Way</h2></A>
<p>Defining a menu in a program's resource script is usually the easiest way to add a 
menu in your window, but it's not the only way. You can dispense with the resource script 
and create a menu entirely within your program by using two functions called 
<I>CreateMenu</I> and <I>AppendMenu</I>. After you finish defining the menu, you can pass the menu handle 
to <I>CreateWindow</I> or use <I>SetMenu</I> to set the window's menu.

<p>Here's how it's done. <I>CreateMenu</I> simply returns a handle to a new menu:

<p><pre>
hMenu = CreateMenu () ;
</PRE>

<p>The menu is initially empty. <I>AppendMenu</I> inserts items into the menu. You must obtain 
a different menu handle for the top-level menu item and for each popup. The popups 
are constructed separately; the popup menu handles are then inserted into the top-level 
menu. The code shown in Figure 10-7 creates a menu in this fashion; in fact, it is the same 
menu that I used in the MENUDEMO program. For illustrative simplicity, the code uses ASCII 
character strings.

<p><B>Figure 10-7.</b> <i>C code that creates the same menu as used in the MENUDEMO program but without requiring a resource script file.</I>
<TABLE cellpadding=5 width="95%"><TR><TD>
<p><pre>
hMenu = CreateMenu () ;

hMenuPopup = CreateMenu () ;

AppendMenu (hMenuPopup, MF_STRING,    IDM_FILE_NEW,     &quot;&amp;New&quot;) ;
AppendMenu (hMenuPopup, MF_STRING,    IDM_FILE_OPEN,    &quot;&amp;Open...&quot;) ;
AppendMenu (hMenuPopup, MF_STRING,    IDM_FILE_SAVE,    &quot;&amp;Save&quot;) ;
AppendMenu (hMenuPopup, MF_STRING,    IDM_FILE_SAVE_AS, &quot;Save &amp;As...&quot;) ;
AppendMenu (hMenuPopup, MF_SEPARATOR, 0,                NULL) ;
AppendMenu (hMenuPopup, MF_STRING,    IDM_APP_EXIT,     &quot;E&amp;xit&quot;) ;

AppendMenu (hMenu, MF_POPUP, hMenuPopup, &quot;&amp;File&quot;) ;

hMenuPopup = CreateMenu () ;

AppendMenu (hMenuPopup, MF_STRING,    IDM_EDIT_UNDO,  &quot;&amp;Undo&quot;) ;
AppendMenu (hMenuPopup, MF_SEPARATOR, 0,              NULL) ;
AppendMenu (hMenuPopup, MF_STRING,    IDM_EDIT_CUT,   &quot;Cu&amp;t&quot;) ;
AppendMenu (hMenuPopup, MF_STRING,    IDM_EDIT_COPY,  &quot;&amp;Copy&quot;) ;
AppendMenu (hMenuPopup, MF_STRING,    IDM_EDIT_PASTE, &quot;&amp;Paste&quot;) ;
AppendMenu (hMenuPopup, MF_STRING,    IDM_EDIT_CLEAR, &quot;De&amp;lete&quot;) ;
AppendMenu (hMenu, MF_POPUP, hMenuPopup, &quot;&amp;Edit&quot;) ;

hMenuPopup = CreateMenu () ;

AppendMenu (hMenuPopup, MF_STRING&#166; MF_CHECKED, IDM_BKGND_WHITE,  &quot;&amp;White&quot;) ;
AppendMenu (hMenuPopup, MF_STRING,             IDM_BKGND_LTGRAY, &quot;&amp;Light Gray&quot;);
AppendMenu (hMenuPopup, MF_STRING,             IDM_BKGND_GRAY,   &quot;&amp;Gray&quot;) ;
AppendMenu (hMenuPopup, MF_STRING,             IDM_BKGND_DKGRAY, &quot;&amp;Dark Gray&quot;);
AppendMenu (hMenuPopup, MF_STRING,             IDM_BKGND_BLACK,  &quot;&amp;Black&quot;) ;

AppendMenu (hMenu, MF_POPUP, hMenuPopup, &quot;&amp;Background&quot;) ;

hMenuPopup = CreateMenu () ;

AppendMenu (hMenuPopup, MF_STRING,             IDM_TIMER_START, &quot;&amp;Start&quot;) ;
AppendMenu (hMenuPopup, MF_STRING &#166; MF_GRAYED, IDM_TIMER_STOP,  &quot;S&amp;top&quot;) ;

AppendMenu (hMenu, MF_POPUP, hMenuPopup, &quot;&amp;Timer&quot;) ;

hMenuPopup = CreateMenu () ;

AppendMenu (hMenuPopup, MF_STRING, IDM_HELP_HELP,  &quot;&amp;Help&quot;) ;
AppendMenu (hMenuPopup, MF_STRING, IDM_APP_ABOUT,  &quot;&amp;About MenuDemo...&quot;) ;

AppendMenu (hMenu, MF_POPUP, hMenuPopup, &quot;&amp;Help&quot;) ;
</pre>
</td></tr></table>

<p>I think you'll agree that the resource script menu template is easier and clearer. 
I'm not recommending that you define a menu in this way, only showing that it can be 
done. Certainly you could cut down on the code size substantially by using some arrays of 
structures containing all the menu item character strings, IDs, and flags. But if you do 
that, you might as well take advantage of the third method Windows provides for defining 
a menu. The <I>LoadMenuIndirect</I> function accepts a pointer to a structure of type 
MENUITEMTEMPLATE and returns a handle to a menu. This function is used within Windows 
to construct a menu after loading the normal menu template from a resource script. If 
you're brave, you can try using it yourself.

<A NAME="305"><h2>Floating Popup Menus</h2></A>
<p>You can also make use of menus without having a top-level menu bar. You can 
instead cause a popup menu to appear on top of any part of the screen. One approach is to 
invoke this popup menu in response to a click of the right mouse button. The POPMENU program in Figure 10-8 shows how this is done.


<p><B>Figure 10-8.</b> <i>The POPMENU program.</I>
<TABLE cellpadding=5 width="95%"><TR><TD>

<A NAME="306"><h3>POPMENU.C</h3></A>
<p><pre>
/*----------------------------------------
   POPMENU.C -- Popup Menu Demonstration
                (c) Charles Petzold, 1998
  ----------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;resource.h&quot;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

HINSTANCE hInst ;
TCHAR     szAppName[] = TEXT (&quot;PopMenu&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, szAppName) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hInst = hInstance ;
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Popup Menu Demonstration&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HMENU hMenu ;
     static int   idColor [5] = { WHITE_BRUSH,  LTGRAY_BRUSH, GRAY_BRUSH,
                                  DKGRAY_BRUSH, BLACK_BRUSH } ;
     static int   iSelection = IDM_BKGND_WHITE ;
     POINT        point ;
     
     switch (message)
     {
     case WM_CREATE:
          hMenu = LoadMenu (hInst, szAppName) ;
          hMenu = GetSubMenu (hMenu, 0) ;
          return 0 ;

     case WM_RBUTTONUP:
          point.x = LOWORD (lParam) ;
          point.y = HIWORD (lParam) ;
          ClientToScreen (hwnd, &amp;point) ;
          
          TrackPopupMenu (hMenu, TPM_RIGHTBUTTON, point.x, point.y, 
                          0, hwnd, NULL) ;
          return 0 ;
          
     case WM_COMMAND:
          switch (LOWORD (wParam))
          {
          case IDM_FILE_NEW:
          case IDM_FILE_OPEN:
          case IDM_FILE_SAVE:
          case IDM_FILE_SAVE_AS:
          case IDM_EDIT_UNDO:
          case IDM_EDIT_CUT:
          case IDM_EDIT_COPY:
          case IDM_EDIT_PASTE:
          case IDM_EDIT_CLEAR:
               MessageBeep (0) ;
               return 0 ;
               
          case IDM_BKGND_WHITE:         // Note: Logic below
          case IDM_BKGND_LTGRAY:        //   assumes that IDM_WHITE
          case IDM_BKGND_GRAY:          //   through IDM_BLACK are
          case IDM_BKGND_DKGRAY:        //   consecutive numbers in
          case IDM_BKGND_BLACK:         //   the order shown here.
               
               CheckMenuItem (hMenu, iSelection, MF_UNCHECKED) ;
               iSelection = LOWORD (wParam) ;
               CheckMenuItem (hMenu, iSelection, MF_CHECKED) ;
               
               SetClassLong (hwnd, GCL_HBRBACKGROUND, (LONG) 
                    GetStockObject 
                         (idColor [LOWORD (wParam) - IDM_BKGND_WHITE])) ;
               
               InvalidateRect (hwnd, NULL, TRUE) ;
               return 0 ;
               
          case IDM_APP_ABOUT:
               MessageBox (hwnd, TEXT (&quot;Popup Menu Demonstration Program\n&quot;)
                                 TEXT (&quot;(c) Charles Petzold, 1998&quot;),
                           szAppName, MB_ICONINFORMATION | MB_OK) ;
               return 0 ;
               
          case IDM_APP_EXIT:
               SendMessage (hwnd, WM_CLOSE, 0, 0) ;
               return 0 ;
               
          case IDM_APP_HELP:
               MessageBox (hwnd, TEXT (&quot;Help not yet implemented!&quot;),
                           szAppName, MB_ICONEXCLAMATION | MB_OK) ;
               return 0 ;
          }
          break ;
          
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

<P><TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="307"><h3>POPMENU.RC (excerpts)</h3></A>
<p><pre>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;

/////////////////////////////////////////////////////////////////////////////
// Menu

POPMENU MENU DISCARDABLE 
BEGIN
    POPUP &quot;MyMenu&quot;
    BEGIN
        POPUP &quot;&amp;File&quot;
        BEGIN
            MENUITEM &quot;&amp;New&quot;,                        IDM_FILE_NEW
            MENUITEM &quot;&amp;Open&quot;,                       IDM_FILE_OPEN
            MENUITEM &quot;&amp;Save&quot;,                       IDM_FILE_SAVE
            MENUITEM &quot;Save &amp;As&quot;,                    IDM_FILE_SAVE_AS
            MENUITEM SEPARATOR
            MENUITEM &quot;E&amp;xit&quot;,                       IDM_APP_EXIT
        END
        POPUP &quot;&amp;Edit&quot;
        BEGIN
            MENUITEM &quot;&amp;Undo&quot;,                       IDM_EDIT_UNDO
            MENUITEM SEPARATOR
            MENUITEM &quot;Cu&amp;t&quot;,                        IDM_EDIT_CUT
            MENUITEM &quot;&amp;Copy&quot;,                       IDM_EDIT_COPY
            MENUITEM &quot;&amp;Paste&quot;,                      IDM_EDIT_PASTE
            MENUITEM &quot;De&amp;lete&quot;,                     IDM_EDIT_CLEAR
        END
        POPUP &quot;&amp;Background&quot;
        BEGIN
            MENUITEM &quot;&amp;White&quot;,                      IDM_BKGND_WHITE, CHECKED
            MENUITEM &quot;&amp;Light Gray&quot;,                 IDM_BKGND_LTGRAY
            MENUITEM &quot;&amp;Gray&quot;,                       IDM_BKGND_GRAY
            MENUITEM &quot;&amp;Dark Gray&quot;,                  IDM_BKGND_DKGRAY
            MENUITEM &quot;&amp;Black&quot;,                      IDM_BKGND_BLACK
        END
        POPUP &quot;&amp;Help&quot;
        BEGIN
            MENUITEM &quot;&amp;Help...&quot;,                    IDM_APP_HELP
            MENUITEM &quot;&amp;About PopMenu...&quot;,           IDM_APP_ABOUT
        END
    END
END
</pre>
</td></tr></table>

<P><TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="308"><h3>RESOURCE.H (excerpts)</h3></A>
<p><pre>
// Microsoft Developer Studio generated include file.
// Used by PopMenu.rc

#define IDM_FILE_NEW                    40001
#define IDM_FILE_OPEN                   40002
#define IDM_FILE_SAVE                   40003
#define IDM_FILE_SAVE_AS                40004
#define IDM_APP_EXIT                    40005
#define IDM_EDIT_UNDO                   40006
#define IDM_EDIT_CUT                    40007
#define IDM_EDIT_COPY                   40008
#define IDM_EDIT_PASTE                  40009
#define IDM_EDIT_CLEAR                  40010
#define IDM_BKGND_WHITE                 40011
#define IDM_BKGND_LTGRAY                40012
#define IDM_BKGND_GRAY                  40013
#define IDM_BKGND_DKGRAY                40014
#define IDM_BKGND_BLACK                 40015
#define IDM_APP_HELP                    40016
#define IDM_APP_ABOUT                   40017
</pre>
</td></tr></table>


<p>The POPMENU.RC resource script defines a menu similar to the one in 
MENUDEMO.RC. The difference is that the top-level menu contains only one item&#8212;a 
popup named &quot;MyMenu&quot; that invokes the File, Edit, Background, and Help options. These 
four options will be arranged on the popup menu in a vertical list rather than on the main 
menu in a horizontal list.

<p>During the WM_CREATE message in <I>WndProc</I>, POPMENU obtains a handle to 
the first popup menu&#8212;that is, the popup with the text &quot;MyMenu&quot;:

<p><pre>
hMenu = LoadMenu (hInst, szAppName) ;
hMenu = GetSubMenu (hMenu, 0) ;
</PRE>

<p>During the WM_RBUTTONUP message, POPMENU obtains the position of 
the mouse pointer, converts the position to screen coordinates, and passes the 
coordinates to <I>TrackPopupMenu</I>:

<p><pre>
point.x = LOWORD (lParam) ;
point.y = HIWORD (lParam) ;
ClientToScreen (hwnd, &amp;point) ;

TrackPopupMenu (hMenu, TPM_RIGHTBUTTON, point.x, point.y, 
                0, hwnd, NULL) ;
</PRE>

<p>Windows then displays the popup menu with the items File, Edit, Background, 
and Help. Selecting any of these options causes the nested popup menus to appear to the 
right. The menu functions the same as a normal menu.
<p>If you want to use the same menu for the program's main menu and with 
the <I>TrackPopupMenu</I>, you'll have a bit of a problem because the function requires a 
popup menu handle. A workaround is provided in the Microsoft Knowledge Base article 
ID Q99806.

<A NAME="309"><h2>Using the System Menu</h2></A>
<p>Parent windows created with a style that includes WS_SYSMENU have a system menu 
box at the left of the caption bar. If you like, you can modify this menu by adding your 
own menu commands. In the early days of Windows, programs commonly put the &quot;About&quot; 
menu item on the system menu. While modifying the system menu is not nearly as common 
these days, it remains a quick-and-dirty way to add a menu to a short program without 
defining it in the resource script. The only restriction is this: the ID numbers you use to add 
commands to the system menu must be lower than 0xF000. Otherwise, they will conflict 
with the IDs that Windows uses for the normal system menu commands. And keep in mind 
that when you process WM_SYSCOMMAND messages in your window procedure for these 
new menu items, you must pass the other WM_SYSCOMMAND messages to 
<I>DefWindowProc</I>. If you don't, you'll effectively disable all normal options on the system menu.

<p>The program POORMENU (&quot;Poor Person's Menu&quot;), shown in Figure 10-9, adds 
a separator bar and three commands to the system menu. The last of these commands 
removes the additions.

<p><B>Figure 10-9.</b> <i>The POORMENU program.</I>
<TABLE cellpadding=5 width="95%"><TR><TD>

<A NAME="310"><h3>POORMENU.C</h3></A>
<p><pre>
/*-----------------------------------------
   POORMENU.C -- The Poor Person's Menu
                 (c) Charles Petzold, 1998
  -----------------------------------------*/

#include &lt;windows.h&gt;

#define IDM_SYS_ABOUT   1
#define IDM_SYS_HELP    2
#define IDM_SYS_REMOVE  3

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

static TCHAR szAppName[] = TEXT (&quot;PoorMenu&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HMENU    hMenu ;
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;The Poor-Person's Menu&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     hMenu = GetSystemMenu (hwnd, FALSE) ;
     
     AppendMenu (hMenu, MF_SEPARATOR, 0,           NULL) ;
     AppendMenu (hMenu, MF_STRING, IDM_SYS_ABOUT,  TEXT (&quot;About...&quot;)) ;
     AppendMenu (hMenu, MF_STRING, IDM_SYS_HELP,   TEXT (&quot;Help...&quot;)) ;
     AppendMenu (hMenu, MF_STRING, IDM_SYS_REMOVE, TEXT (&quot;Remove Additions&quot;)) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     switch (message)
     {
     case WM_SYSCOMMAND:
          switch (LOWORD (wParam))
          {
          case IDM_SYS_ABOUT:
               MessageBox (hwnd, TEXT (&quot;A Poor-Person's Menu Program\n&quot;)
                                 TEXT (&quot;(c) Charles Petzold, 1998&quot;),
                           szAppName, MB_OK | MB_ICONINFORMATION) ;
               return 0 ;
               
          case IDM_SYS_HELP:
               MessageBox (hwnd, TEXT (&quot;Help not yet implemented!&quot;),
                           szAppName, MB_OK | MB_ICONEXCLAMATION) ;
               return 0 ;
               
          case IDM_SYS_REMOVE:
               GetSystemMenu (hwnd, TRUE) ;
               return 0 ;
          }
          break ;
          
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

<p>The three menu IDs are defined near the top of POORMENU.C:

<p><pre>
#define IDM_ABOUT   1
#define IDM_HELP    2
#define IDM_REMOVE  3
</PRE>

<p>After the program's window has been created, POORMENU obtains a handle to the 
system menu:

<p><pre>
hMenu = GetSystemMenu (hwnd, FALSE) ;
</PRE>

<p>When you first call <I>GetSystemMenu</I>, you should set the second parameter to FALSE in 
preparation for modifying the menu.

<p>The menu is altered with four <I>AppendMenu</I> calls:

<p><pre>
AppendMenu (hMenu, MF_SEPARATOR, 0,           NULL) ;
AppendMenu (hMenu, MF_STRING, IDM_SYS_ABOUT,  TEXT (&quot;About...&quot;)) ;
AppendMenu (hMenu, MF_STRING, IDM_SYS_HELP,   TEXT (&quot;Help...&quot;)) ;
AppendMenu (hMenu, MF_STRING, IDM_SYS_REMOVE, TEXT (&quot;Remove Additions&quot;));
</PRE>

<p>The first <I>AppendMenu</I> call adds the separator bar. Choosing the Remove Additions 
menu item causes POORMENU to remove these additions, which it accomplishes simply by 
calling <I>GetSystemMenu</I> again with the second parameter set to TRUE:

<p><pre>
GetSystemMenu (hwnd, TRUE) ;
</PRE>

<p>The standard system menu has the options Restore, Move, Size, Minimize, 
Maximize, and Close. These generate WM_SYSCOMMAND messages with 
<I>wParam</I> equal to SC_RESTORE, SC_MOVE, SC_SIZE, SC_MINIMUM, SC_MAXIMUM, and SC_CLOSE. 
Although Windows programs do not normally do so, you can process these messages 
yourself rather than pass them on to 
<I>DefWindowProc</I>. You can also disable or remove 
some of these standard options from the system menu using methods described below. 
The Windows documentation also includes some standard additions to the system menu. 
These use the identifiers SC_NEXTWINDOW, SC_PREVWINDOW, SC_VSCROLL, 
SC_HSCROLL, and SC_ARRANGE. You might find it appropriate to add these commands to the 
system menu in some applications.

<A NAME="311"><h2>Changing the Menu</h2></A>
<p>We've already seen how the <I>AppendMenu</I> function can be used to define a menu 
entirely within a program and to add menu items to the system menu. Prior to Windows 3.0, 
you would have been forced to use the 
<I>ChangeMenu</I> function for this job. 
<I>ChangeMenu</I> was so versatile that it was one of the most complex functions in all of Windows (at least 
at that time). Times have changed. Many other current functions are now more complex 
than <I>ChangeMenu</I> ever was, and 
<I>ChangeMenu</I> has been replaced with five newer functions:
<UL>

<p><li><i>AppendMenu</I> Adds a new item to the end of a menu.

<p><li><i>DeleteMenu</I> Deletes an existing item from a menu and destroys the item.

<p><li><i>InsertMenu</I> Inserts a new item into a menu.

<p><li><i>ModifyMenu</I> Changes an existing menu item.

<p><li><i>RemoveMenu</I> Removes an existing item from a menu.
</UL>

<p>The difference between <I>DeleteMenu</I> and 
<I>RemoveMenu</I> is important if the item is a popup menu. 
<I>DeleteMenu</I> destroys the popup menu&#8212;but 
<I>RemoveMenu</I> does not.

<A NAME="312"><h2>Other Menu Commands</h2></A>
<p>In this section, you'll find some more functions useful for working with menus.

<p>When you change a top-level menu item, the change is not shown until 
Windows redraws the menu bar. You can force this redrawing by calling

<p><pre>
DrawMenuBar (hwnd) ;
</PRE>

<p>Notice that the argument to <I>DrawMenuBar</I> is a handle to the window rather than a 
handle to the menu.

<p>You can obtain the handle to a popup menu using

<p><pre>
hMenuPopup = GetSubMenu (hMenu, iPosition) ;
</PRE>

<p>where <I>iPosition</I> is the index (starting at 0) of the popup within the top-level menu 
indicated by <I>hMenu</I>. You can then use the popup menu handle with other functions (such 
as <I>AppendMenu</I>).

<p>You can obtain the current number of items in a top-level or popup menu by using

<p><pre>
iCount = GetMenuItemCount (hMenu) ;
</PRE>

<p>You can obtain the menu ID for an item in a popup menu from

<p><pre>
id = GetMenuItemID (hMenuPopup, iPosition) ;
</PRE>

<p>where <I>iPosition</I> is the position (starting at 0) of the item within the popup.

<p>In MENUDEMO, you saw how to check or uncheck an item in a popup menu using

<p><pre>
CheckMenuItem (hMenu, id, iCheck) ;
</PRE>

<p>In MENUDEMO, <I>hMenu</I> was the handle to the top-level menu, 
<I>id</I> was the menu ID, and the value of 
<I>iCheck</I> was either MF_CHECKED or MF_UNCHECKED. If 
<I>hMenu</I> is a handle to a popup menu, the 
<I>id</I> parameter can be a positional index rather than a menu ID. If 
an index is more convenient, you include MF_BYPOSITION in the third argument:

<p><pre>
CheckMenuItem (hMenu, iPosition, MF_CHECKED &#166; MF_BYPOSITION) ;
</PRE>

<p>The <I>EnableMenuItem</I> function works similarly to 
<I>CheckMenuItem</I>, except that the third argument is MF_ENABLED, MF_DISABLED, or MF_GRAYED. If you use 
<I>EnableMenuItem</I> on a top-level menu item that has a popup, you must also use the MF_BYPOSITION identifier in the third parameter because the menu item has no menu ID. 
We'll see an example of <I>EnableMenuItem</I> in the POPPAD2 program shown later in this 
chapter. <I>HiliteMenuItem</I> is similar to 
<I>CheckMenuItem</I> and <I>EnableMenuItem</I> but uses MF_HILITE 
and MF_UNHILITE. This highlighting is the reverse video that Windows uses when you 
move among menu items. You do not normally need to use 
<I>HiliteMenuItem</I>.

<p>What else do you need to do with your menu? Have you forgotten what 
character string you used in a menu? You can refresh your memory by calling

<p><pre>
iCharCount = GetMenuString (hMenu, id, pString, iMaxCount, iFlag) ;
</PRE>

<p>The <I>iFlag</I> is either MF_BYCOMMAND (where 
<I>id</I> is a menu ID) or MF_BYPOSITION (where 
<I>id</I> is a positional index). The function copies up to 
<I>iMaxCount</I> characters into <I>pString</I> 
and returns the number of characters copied.

<p>Or perhaps you'd like to know what the current flags of a menu item are:

<p><pre>
iFlags = GetMenuState (hMenu, id, iFlag) ;
</PRE>

<p>Again, <I>iFlag</I> is either MF_BYCOMMAND or MF_BYPOSITION. The 
<I>iFlags</I> parameter is a combination of all the current flags. You can determine the current flags by testing 
against the MF_DISABLED, MF_GRAYED, MF_CHECKED, MF_MENUBREAK, 
MF_MENUBARBREAK, and MF_SEPARATOR identifiers.

<p>Or maybe by this time you're a little fed up with menus. In that case, you'll be 
pleased to know that if you no longer need a menu in your program, you can destroy it:

<p><pre>
DestroyMenu (hMenu) ;
</PRE>

<p>This function invalidates the menu handle.

<A NAME="313"><h2>An Unorthodox Approach to Menus</h2></A>
<p>Now let's step a little off the beaten path. Instead of having drop-down menus in 
your program, how about creating multiple top-level menus without any popups and 
switching between the top-level menus using the 
<I>SetMenu</I> call? Such a menu might remind old-timers of that character-mode classic, Lotus 1-2-3. The NOPOPUPS program, shown 
in Figure 10-10, demonstrates how to do it. This program includes File and Edit items 
similar to those that MENUDEMO uses but displays them as alternate top-level menus.

<p><B>Figure 10-10.</b> <i>The NOPOPUPS program.</I>
<P><TABLE cellpadding=5 width="95%"><TR><TD>

<A NAME="314"><h3>NOPOPUPS.C</h3></A>
<p><pre>
/*-------------------------------------------------
   NOPOPUPS.C -- Demonstrates No-Popup Nested Menu
                 (c) Charles Petzold, 1998
  -------------------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;resource.h&quot;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)

{
     static TCHAR szAppName[] = TEXT (&quot;NoPopUps&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, 
                          TEXT (&quot;No-Popup Nested Menu Demonstration&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HMENU hMenuMain, hMenuEdit, hMenuFile ;
     HINSTANCE    hInstance ;

     switch (message)
     {
     case WM_CREATE:
          hInstance = (HINSTANCE) GetWindowLong (hwnd, GWL_HINSTANCE) ;
          
          hMenuMain = LoadMenu (hInstance, TEXT (&quot;MenuMain&quot;)) ;
          hMenuFile = LoadMenu (hInstance, TEXT (&quot;MenuFile&quot;)) ;
          hMenuEdit = LoadMenu (hInstance, TEXT (&quot;MenuEdit&quot;)) ;
          
          SetMenu (hwnd, hMenuMain) ;
          return 0 ;
          
     case WM_COMMAND:
          switch (LOWORD (wParam))
          {
          case IDM_MAIN:
               SetMenu (hwnd, hMenuMain) ;
               return 0 ;
               
          case IDM_FILE:
               SetMenu (hwnd, hMenuFile) ;
               return 0 ;
               
          case IDM_EDIT:
               SetMenu (hwnd, hMenuEdit) ;
               return 0 ;
               
          case IDM_FILE_NEW:
          case IDM_FILE_OPEN:
          case IDM_FILE_SAVE:
          case IDM_FILE_SAVE_AS:
          case IDM_EDIT_UNDO:
          case IDM_EDIT_CUT:
          case IDM_EDIT_COPY:
          case IDM_EDIT_PASTE:
          case IDM_EDIT_CLEAR:
               MessageBeep (0) ;
               return 0 ;
          }
          break ;
          
     case WM_DESTROY:
          SetMenu (hwnd, hMenuMain) ;
          DestroyMenu (hMenuFile) ;
          DestroyMenu (hMenuEdit) ;
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

<P><TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="315"><h3>NOPOPUPS.RC (excerpts)</h3></A>
<p><pre>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;
/////////////////////////////////////////////////////////////////////////////
// Menu

MENUMAIN MENU DISCARDABLE 
BEGIN
    MENUITEM &quot;MAIN:&quot;,                       0, INACTIVE
    MENUITEM &quot;&amp;File...&quot;,                    IDM_FILE
    MENUITEM &quot;&amp;Edit...&quot;,                    IDM_EDIT
END

MENUFILE MENU DISCARDABLE 
BEGIN
    MENUITEM &quot;FILE:&quot;,                       0, INACTIVE
    MENUITEM &quot;&amp;New&quot;,                        IDM_FILE_NEW
    MENUITEM &quot;&amp;Open...&quot;,                    IDM_FILE_OPEN
    MENUITEM &quot;&amp;Save&quot;,                       IDM_FILE_SAVE
    MENUITEM &quot;Save &amp;As&quot;,                    IDM_FILE_SAVE_AS
    MENUITEM &quot;(&amp;Main)&quot;,                     IDM_MAIN
END

MENUEDIT MENU DISCARDABLE 
BEGIN
    MENUITEM &quot;EDIT:&quot;,                       0, INACTIVE
    MENUITEM &quot;&amp;Undo&quot;,                       IDM_EDIT_UNDO
    MENUITEM &quot;Cu&amp;t&quot;,                        IDM_EDIT_CUT
    MENUITEM &quot;&amp;Copy&quot;,                       IDM_EDIT_COPY
    MENUITEM &quot;&amp;Paste&quot;,                      IDM_EDIT_PASTE
    MENUITEM &quot;De&amp;lete&quot;,                     IDM_EDIT_CLEAR
    MENUITEM &quot;(&amp;Main)&quot;,                     IDM_MAIN
END
</pre>
</td></tr></table>

<P><TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="316"><h3>RESOURCE.H (excerpts)</h3></A>
<p><pre>
// Microsoft Developer Studio generated include file.
// Used by NoPopups.rc
#define IDM_FILE                        40001
#define IDM_EDIT                        40002
#define IDM_FILE_NEW                    40003
#define IDM_FILE_OPEN                   40004
#define IDM_FILE_SAVE                   40005
#define IDM_FILE_SAVE_AS                40006
#define IDM_MAIN                        40007
#define IDM_EDIT_UNDO                   40008
#define IDM_EDIT_CUT                    40009
#define IDM_EDIT_COPY                   40010
#define IDM_EDIT_PASTE                  40011
#define IDM_EDIT_CLEAR                  40012
</pre>
</td></tr></table>

<p>In Microsoft Developer Studio, you create three menus rather than one. You'll 
be selecting Resource from the Insert menu three times. Each menu has a different text 
name. When the window procedure processes the WM_CREATE message, Windows loads 
each menu resource into memory:

<p><pre>
hMenuMain = LoadMenu (hInstance, TEXT (&quot;MenuMain&quot;)) ;
hMenuFile = LoadMenu (hInstance, TEXT (&quot;MenuFile&quot;)) ;
hMenuEdit = LoadMenu (hInstance, TEXT (&quot;MenuEdit&quot;)) ;
</PRE>

<p>Initially, the program displays the main menu:

<p><pre>
SetMenu (hwnd, hMenuMain) ;
</PRE>

<p>The main menu lists the three options using the character strings &quot;MAIN:&quot;, 
&quot;File...&quot;, and &quot;Edit...&quot; However, &quot;MAIN:&quot; is disabled, so it doesn't cause WM_COMMAND 
messages to be sent to the window procedure. The File and Edit menus begin &quot;FILE:&quot; and 
&quot;EDIT:&quot; to identify these as submenus. The last item in each menu is the character string 
&quot;(Main)&quot;; this option indicates a return to the main menu. Switching among these three menus is simple:

<p><pre>
case WM_COMMAND :
     switch (wParam)
     {
     case IDM_MAIN :
          SetMenu (hwnd, hMenuMain) ;
          return 0 ;

     case IDM_FILE :
          SetMenu (hwnd, hMenuFile) ;
          return 0 ;

     case IDM_EDIT :
          SetMenu (hwnd, hMenuEdit) ;
          return 0 ;

<i>[other program lines]</I>
     }
     break ;
</pre>

<p>During the WM_DESTROY message, NOPOPUPS sets the program's menu to the 
Main menu and destroys the File and Edit menus with calls to 
<I>DestroyMenu</I>. The Main menu is destroyed automatically when the window is destroyed.

</BODY>
</HTML>






