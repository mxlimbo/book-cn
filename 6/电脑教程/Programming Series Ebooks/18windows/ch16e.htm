<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>A Library for DIBs</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="574"><h1>A Library for DIBs</h1></A>
<P>It is only now&#8212;after our long journey learning about GDI bitmap objects, the device-independent bitmap, the DIB section, and the Windows Palette Manager&#8212;that we're ready to devise some set of functions that help us in working with bitmaps.

<P>The PACKEDIB files shown earlier illustrate one possible approach: A packed DIB in memory is represented solely by a pointer to it. All the information that a program needs about the DIB can be obtained by functions that access the header information structure. In practice, however, this method has serious performance problems when it comes to &quot;get pixel&quot; and &quot;set pixel&quot; routines. Image-processing tasks routinely require bitmap bits to be accessed, and these functions should ideally be as fast as possible.

<P>A possible C++ solution involves creating a DIB class where a pointer to the packed DIB is just one of several member variables. Other member variables and member functions can help implement fast routines for obtaining and setting pixels in the DIB. However, since I indicated in the first chapter that you'd only need to know C for this particular book, the use of C++ will have to remain a solution for some other book.

<P>Of course, just about anything that can be done in C++ can also be done in C. A good example of this are the multitude of Windows functions that use handles. What does an application program know about a handle other than the fact that it's a numeric value? It knows that the handle references a particular object and that functions for working with the object exist. Obviously, the operating system uses the handle to somehow reference internal information about the object. A handle could be as simple as a pointer to a structure.

<P>For example, suppose there exists a collection of functions that use a handle called an HDIB. What's an HDIB? Well, it might be defined in a header file like so:

<p><pre>
typedef void * HDIB ;
</PRE>

<P>This definition answers the question &quot;What's an HDIB?&quot; with &quot;None of your business!&quot;

<P>In reality, however, an HDIB might be a pointer to a structure that contains not only a pointer to a packed DIB but also some other information:

<p><pre>
typedef struct
{
     BITMAPINFO * pPackedDib ;
     int          cx, cy, cBitsPerPixel, cBytesPerRow ;
     BYTE       * pBits ;
{
DIBSTRUCTURE, * PDIBSTRUCTURE ;
</PRE>

<P>The other five fields of this structure contain information that is derivable from the packed DIB, of course, but the presence of these values in the structure allows them to be accessed more quickly. The various DIB library functions could work with this structure rather than the <I>pPackedDib</I> pointer. A <I>DibGetPixelPointer</I> function could be implemented like so:

<p><pre>
BYTE * DibGetPixelPointer (HDIB hdib, int x, int y)
{
     PDIBSTRUCTURE pdib = hdib ;

     return pdib-&gt;pBits + y * pdib-&gt;cBytesPerRow + 
                             x * pdib-&gt;cBitsPerPixel / 8 ;
}
</PRE>

<P>This is, of course, much faster than a &quot;get pixel&quot; routine that might be implemented in PACKEDIB.C.

<P>While this approach is quite reasonable, I have decided to abandon the packed DIB and instead base my DIB library on the DIB section. This gives us virtually all of the flexibility involved with packed DIBs (that is, being able to manipulate DIB pixel bits in a somewhat device-independent manner) but is also more efficient when running under Windows NT.

<A NAME="575"><h2>The DIBSTRUCT Structure</h2></A>
<P>The DIBHELP.C file&#8212;so named because it provides help for working with DIBs&#8212;is over a thousand lines long and will be shown shortly in several parts. But let's first take a close look at the structure that the DIBHELP functions work with. The structure is defined in DIBHELP.C like so:

<p><pre>
typedef struct
{
     PBYTE    * ppRow ;       // array of row pointers
     int        iSignature ;  // = &quot;Dib &quot;
     HBITMAP    hBitmap ;     // handle returned from CreateDIBSection
     BYTE     * pBits ;       // pointer to bitmap bits
     DIBSECTION ds ;          // DIBSECTION structure
     int        iRShift[3] ;  // right-shift values for color masks
     int        iLShift[3] ;  // left-shift values for color masks
}
DIBSTRUCT, * PDIBSTRUCT ;
</PRE>

<P>Let me skip the first field for now. There's a reason why it's the first field&#8212;it makes some macros easier&#8212;but it'll be easier to understand after I discuss the other fields first.

<P>When this structure is first set up by one of the DIB creation functions in DIBHELP.C, the second field is set to the binary equivalent of the text string &quot;Dib.&quot; This is used as a check of the validity of a pointer to the structure by some of the DIBHELP functions.

<P>The third field&#8212;<I>hBitmap</I>&#8212;is the bitmap handle returned from the <I>CreateDIBSection</I> function. You'll recall that this handle can in many ways be used like the handles to GDI bitmap objects that we encountered in <a href="ch14a.htm#426">Chapter 14</a>. However, the handle returned from <I>CreateDIBSection</I> references a bitmap that remains in a device-independent format until it is rendered on an output device by calls to <I>BitBlt</I> and <I>StretchBlt</I>.

<P>The fourth field of DIBSTRUCT is a pointer to the bitmap bits. This is a value also set by the <I>CreateDIBSection</I> function. You'll recall that the operating system controls this memory block but that an application has access to it. The block is automatically freed when the bitmap handle is deleted.

<P>The fifth field of DIBSTRUCT is a DIBSECTION structure. You'll recall that if you have a bitmap handle returned from <I>CreateDIBSection</I>, you can pass that to the <I>GetObject</I> function to obtain information about the bitmap in the DIBSECTION structure:


<p><pre>
GetObject (hBitmap, sizeof (DIBSECTION), &amp;ds) ;
</PRE>

<P>As a reminder, the DIBSECTION structure is defined in WINGDI.H like so:

<p><pre>
typedef struct tagDIBSECTION {
    BITMAP           dsBm ;
    BITMAPINFOHEADER dsBmih ;
    DWORD            dsBitfields[3] ;     // Color masks
    HANDLE           dshSection ;
    DWORD            dsOffset ;
}
DIBSECTION, * PDIBSECTION ;
</PRE>

<P>The first field is the BITMAP structure that's used with <I>CreateBitmapIndirect</I> to create a bitmap object and used with <I>GetObject</I> to return information about a DDB. The second field is a BITMAPINFOHEADER structure. Regardless of the bitmap information structure passed to the <I>CreateDIBSection</I> function, the DIBSECTION structure will always have a BITMAPINFOHEADER structure and not, for example, a BITMAPCOREHEADER structure. This means that a lot of the functions in DIBHELP.C need not check for OS/2-compatible DIBs when accessing this structure.

<P>You'll recall that for 16-bit and 32-bit DIBs, if the <I>biCompression</I> field of the BITMAPINFOHEADER structure is BI_BITFIELDS, then three mask values normally follow the information header structure. These mask values determine how to convert 16-bit and 32-bit pixel values to RGB colors. The masks are stored in the third field of the DIBSECTION structure.

<P>The final two fields of the DIBSECTION structure refer to a DIB section created with a file-mapping object. DIBHELP does not use this feature of <I>CreateDIBSection</I>, so these fields can be ignored.

<P>Finally, the last two fields of DIBSTRUCT store left and right shift values that are used with the color masks for 16-bit and 32-bit DIBs. These shift values were discussed in <a href="ch15a.htm#473">Chapter 15</a>.

<P>Let's go back to the first field of DIBSTRUCT. As we'll see, when a DIB is first created, this field is set to a pointer that references an array of pointers, each of which points to a row of pixels in the DIB. These pointers allow an even faster method to get at DIB pixel bits and are defined so that the DIB pixel bits can be referenced top row first. The last element of this array&#8212;referencing the bottom row of the DIB image&#8212;will usually be equal to the <I>pBits</I> field of DIBSTRUCT.

<A NAME="576"><h2>The Information Functions</h2></A>
<P>DIBHELP.C begins by defining the DIBSTRUCT structure and then providing a collection of functions that let an application obtain information about the DIB section. The first part of DIBHELP.C is shown in Figure 16-20.



<P><B>Figure 16-20.</b> <i>The first part of the DIBHELP.C file.</I>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="577"><h3>DIBHELP.C (first part)</h3></A>
<P><pre>

/*------------------------------------------
   DIBHELP.C -- DIB Section Helper Routines 
                (c) Charles Petzold, 1998
  ------------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;dibhelp.h&quot;

#define HDIB_SIGNATURE (* (int *) &quot;Dib &quot;)

typedef struct
{
     PBYTE    * ppRow ;            // must be first field for macros!
     int        iSignature ;
     HBITMAP    hBitmap ;
     BYTE     * pBits ;
     DIBSECTION ds ;
     int        iRShift[3] ;
     int        iLShift[3] ;
}
DIBSTRUCT, * PDIBSTRUCT ;

/*---------------------------------------------------------------
   DibIsValid:  Returns TRUE if hdib points to a valid DIBSTRUCT
  ---------------------------------------------------------------*/

BOOL DibIsValid (HDIB hdib)
{
     PDIBSTRUCT pdib = hdib ;

     if (pdib == NULL)
          return FALSE ;

     if (IsBadReadPtr (pdib, sizeof (DIBSTRUCT)))
          return FALSE ;

     if (pdib-&gt;iSignature != HDIB_SIGNATURE)
          return FALSE ;

     return TRUE ;
}

/*-----------------------------------------------------------------------
   DibBitmapHandle:  Returns the handle to the DIB section bitmap object
  -----------------------------------------------------------------------*/

HBITMAP DibBitmapHandle (HDIB hdib)
{
     if (!DibIsValid (hdib))
          return NULL ;
     
     return ((PDIBSTRUCT) hdib)-&gt;hBitmap ;
}

/*-------------------------------------------
   DibWidth:  Returns the bitmap pixel width
  -------------------------------------------*/

int DibWidth (HDIB hdib)
{
     if (!DibIsValid (hdib))
          return 0 ;
     
     return ((PDIBSTRUCT) hdib)-&gt;ds.dsBm.bmWidth ;
}

/*---------------------------------------------
   DibHeight:  Returns the bitmap pixel height
  ---------------------------------------------*/

int DibHeight (HDIB hdib)
{
     if (!DibIsValid (hdib))
          return 0 ; 
     
     return ((PDIBSTRUCT) hdib)-&gt;ds.dsBm.bmHeight ;
}

/*----------------------------------------------------
   DibBitCount:  Returns the number of bits per pixel
  ----------------------------------------------------*/

int DibBitCount (HDIB hdib)
{
     if (!DibIsValid (hdib))
          return 0 ;
     
     return ((PDIBSTRUCT) hdib)-&gt;ds.dsBm.bmBitsPixel ;
}

/*--------------------------------------------------------------
   DibRowLength:  Returns the number of bytes per row of pixels
  --------------------------------------------------------------*/

int DibRowLength (HDIB hdib)
{
     if (!DibIsValid (hdib))
          return 0 ;
     
     return 4 * ((DibWidth (hdib) * DibBitCount (hdib) + 31) / 32) ;
}

/*----------------------------------------------------------------
   DibNumColors:  Returns the number of colors in the color table
  ----------------------------------------------------------------*/

int DibNumColors (HDIB hdib)
{
     PDIBSTRUCT pdib = hdib ;

     if (!DibIsValid (hdib))
          return 0 ;

     if (pdib-&gt;ds.dsBmih.biClrUsed != 0)
     {
          return pdib-&gt;ds.dsBmih.biClrUsed ;
     }
     else if (DibBitCount (hdib) &lt;= 8)
     {
          return 1 &lt;&lt; DibBitCount (hdib) ;
     }
     return 0 ;
}

/*------------------------------------------
   DibMask:  Returns one of the color masks
  ------------------------------------------*/

DWORD DibMask (HDIB hdib, int i)
{
     PDIBSTRUCT pdib = hdib ;

     if (!DibIsValid (hdib) || i &lt; 0 || i &gt; 2)
          return 0 ;
     
     return pdib-&gt;ds.dsBitfields[i] ;
}

/*---------------------------------------------------
   DibRShift:  Returns one of the right-shift values
  ---------------------------------------------------*/

int DibRShift (HDIB hdib, int i)
{
     PDIBSTRUCT pdib = hdib ;

     if (!DibIsValid (hdib) || i &lt; 0 || i &gt; 2)
          return 0 ;
     
     return pdib-&gt;iRShift[i] ;
}

/*--------------------------------------------------
   DibLShift:  Returns one of the left-shift values
  --------------------------------------------------*/

int DibLShift (HDIB hdib, int i)
{
     PDIBSTRUCT pdib = hdib ;

     if (!DibIsValid (hdib) || i &lt; 0 || i &gt; 2)
          return 0 ;
     
     return pdib-&gt;iLShift[i] ;
}

/*---------------------------------------------------------------
   DibCompression:  Returns the value of the biCompression field
  ---------------------------------------------------------------*/
int DibCompression (HDIB hdib)
{
     if (!DibIsValid (hdib))
          return 0 ;

     return ((PDIBSTRUCT) hdib)-&gt;ds.dsBmih.biCompression ;
}

/*--------------------------------------------------------------
   DibIsAddressable:  Returns TRUE if the DIB is not compressed
  --------------------------------------------------------------*/

BOOL DibIsAddressable (HDIB hdib)
{
     int iCompression ;

     if (!DibIsValid (hdib))
          return FALSE ;

     iCompression = DibCompression (hdib) ;

     if (iCompression == BI_RGB || iCompression == BI_BITFIELDS)
         return TRUE ;

     return FALSE ;
}

/*---------------------------------------------------------------------------
   These functions return the sizes of various components of the DIB section
     AS THEY WOULD APPEAR in a packed DIB. These functions aid in converting
     the DIB section to a packed DIB and in saving DIB files.
  ---------------------------------------------------------------------------*/

DWORD DibInfoHeaderSize (HDIB hdib)
{
     if (!DibIsValid (hdib))
          return 0 ;

     return ((PDIBSTRUCT) hdib)-&gt;ds.dsBmih.biSize ;
}

DWORD DibMaskSize (HDIB hdib)
{
     PDIBSTRUCT pdib = hdib ;

     if (!DibIsValid (hdib))
          return 0 ;

     if (pdib-&gt;ds.dsBmih.biCompression == BI_BITFIELDS)
          return 3 * sizeof (DWORD) ;

     return 0 ;
}

DWORD DibColorSize (HDIB hdib)
{
     return DibNumColors (hdib) * sizeof (RGBQUAD) ;
} 

DWORD DibInfoSize (HDIB hdib)
{
     return DibInfoHeaderSize(hdib) + DibMaskSize(hdib) + DibColorSize(hdib) ;
}

DWORD DibBitsSize (HDIB hdib)
{
     PDIBSTRUCT pdib = hdib ;

     if (!DibIsValid (hdib))
          return 0 ;

     if (pdib-&gt;ds.dsBmih.biSizeImage != 0)
     {
          return pdib-&gt;ds.dsBmih.biSizeImage ;
     }
     return DibHeight (hdib) * DibRowLength (hdib) ;
}

DWORD DibTotalSize (HDIB hdib)
{
     return DibInfoSize (hdib) + DibBitsSize (hdib) ;
}

/*----------------------------------------------------------------------
   These functions return pointers to the various components of the DIB 
     section.
  ----------------------------------------------------------------------*/
BITMAPINFOHEADER * DibInfoHeaderPtr (HDIB hdib)
{
     if (!DibIsValid (hdib))
          return NULL ;
     
     return &amp; (((PDIBSTRUCT) hdib)-&gt;ds.dsBmih) ;
}

DWORD * DibMaskPtr (HDIB hdib)
{
     PDIBSTRUCT pdib = hdib ;

     if (!DibIsValid (hdib))
          return 0 ;

     return pdib-&gt;ds.dsBitfields ;
}

void * DibBitsPtr (HDIB hdib)
{
     if (!DibIsValid (hdib))
          return NULL ;
     
     return ((PDIBSTRUCT) hdib)-&gt;pBits ;
}

/*------------------------------------------------------
   DibSetColor:  Obtains entry from the DIB color table
  ------------------------------------------------------*/

BOOL DibGetColor (HDIB hdib, int index, RGBQUAD * prgb)
{
     PDIBSTRUCT pdib = hdib ;
     HDC        hdcMem ;
     int        iReturn ;

     if (!DibIsValid (hdib))
          return 0 ;

     hdcMem = CreateCompatibleDC (NULL) ;
     SelectObject (hdcMem, pdib-&gt;hBitmap) ;
     iReturn = GetDIBColorTable (hdcMem, index, 1, prgb) ;
     DeleteDC (hdcMem) ;

     return iReturn ? TRUE : FALSE ;
}

/*----------------------------------------------------
   DibGetColor:  Sets an entry in the DIB color table
  ----------------------------------------------------*/
 
BOOL DibSetColor (HDIB hdib, int index, RGBQUAD * prgb)
{
     PDIBSTRUCT pdib = hdib ;
     HDC        hdcMem ;
     int        iReturn ;

     if (!DibIsValid (hdib))
          return 0 ;

     hdcMem = CreateCompatibleDC (NULL) ;
     SelectObject (hdcMem, pdib-&gt;hBitmap) ;
     iReturn = SetDIBColorTable (hdcMem, index, 1, prgb) ;
     DeleteDC (hdcMem) ;

     return iReturn ? TRUE : FALSE ;
}
</pre>
</td></tr></table>


<P>Most of the functions in this part of DIBHELP.C are self-explanatory. The <I>DibIsValid</I> function helps keep the whole system fairly bulletproof. The other functions call <I>DibIsValid</I> before attempting to reference information in DIBSTRUCT. All these functions have a first, and usually only, parameter of HDIB, which (as we'll see shortly) is defined in DIBHELP.H as a void pointer. The functions can cast this parameter to a PDIBSTRUCT and then access the fields in the structure.

<P>Note the <I>DibIsAddressable</I> function, which returns a BOOL value. This function could also be called the <I>DibIsNotCompressed</I> function. The return value indicates whether the individual pixels of the DIB can be addressed.

<P>A collection of functions beginning with <I>DibInfoHeaderSize</I> obtain the sizes of various components of the DIB Section <I>as they would appear</I> in a packed DIB. As we shall see, these functions help in converting a DIB section to a packed DIB and in saving DIB files. These are followed by a collection of functions that obtain pointers to the various components of the DIB.

<P>Although DIBHELP.C contains a function named <I>DibInfoHeaderPtr</I> that obtains a pointer to the BITMAPINFOHEADER structure, there is no function that obtains a pointer to the BITMAPINFO structure&#8212;that is, the information structure followed by the DIB color table. That's because when working with DIB sections, applications don't have direct access to a structure of this type. While the BITMAPINFOHEADER structure and the color masks are both available in the DIBSECTION structure, and the pointer to the pixel bits is returned from the <I>CreateDIBSection</I> function, the DIB color table is accessible only indirectly, by calling <I>GetDIBColorTable</I> and <I>SetDIBColorTable</I>. These functions are encapsulated in DIBHELP's <I>DibGetColor</I> and <I>DibSetColor</I> functions.

<P>Later in DIBHELP.C, a file named <I>DibCopyToInfo</I> allocates a pointer to a BITMAPINFO structure and fills it with information, but that's not exactly the same as getting a pointer to an existing structure in memory.

<A NAME="578"><h2>Reading and Writing Pixels</h2></A>
<P>One compelling advantage in maintaining a packed DIB or a DIB section by an application is being able to directly manipulate the pixel bits of the DIB. The second section of DIBHELP.C, shown in Figure 16-21, shows the functions provided for this purpose.



<P><B>Figure 16-21.</b> <i>The second part of the DIBHELP.C file.</I>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="579"><h3>DIBHELP.C (second part)</h3></A>
<P><pre>
/*-----------------------------------------------------------------
   DibPixelPtr:  Returns a pointer to the pixel at position (x, y)
  -----------------------------------------------------------------*/

BYTE * DibPixelPtr (HDIB hdib, int x, int y)
{
     if (!DibIsAddressable (hdib))
          return NULL ;

     if (x &lt; 0 || x &gt;= DibWidth (hdib) || y &lt; 0 || y &gt;= DibHeight (hdib))
          return NULL ;

     return (((PDIBSTRUCT) hdib)-&gt;ppRow)[y] + (x * DibBitCount (hdib) &gt;&gt; 3) ;
}

/*-----------------------------------------------
   DibGetPixel:  Obtains a pixel value at (x, y)
  -----------------------------------------------*/

DWORD DibGetPixel (HDIB hdib, int x, int y)
{
     PBYTE pPixel ;

     if (!(pPixel = DibPixelPtr (hdib, x, y)))
          return 0 ;

     switch (DibBitCount (hdib))
     {
     case  1:  return 0x01 &amp; (* pPixel &gt;&gt; (7 - (x &amp; 7))) ;
     case  4:  return 0x0F &amp; (* pPixel &gt;&gt; (x &amp; 1 ? 0 : 4)) ;
     case  8:  return * pPixel ;
     case 16:  return * (WORD *) pPixel ;
     case 24:  return 0x00FFFFFF &amp; * (DWORD *) pPixel ; 
     case 32:  return * (DWORD *) pPixel ;
     }
     return 0 ;
}

/*--------------------------------------------
   DibSetPixel:  Sets a pixel value at (x, y)
  --------------------------------------------*/

BOOL DibSetPixel (HDIB hdib, int x, int y, DWORD dwPixel)
{
     PBYTE pPixel ;

     if (!(pPixel = DibPixelPtr (hdib, x, y)))
          return FALSE ;

     switch (DibBitCount (hdib))
     {
     case  1:  * pPixel &amp;= ~(1     &lt;&lt; (7 - (x &amp; 7))) ;
               * pPixel |= dwPixel &lt;&lt; (7 - (x &amp; 7)) ;
               break ;

     case  4:  * pPixel &amp;= 0x0F    &lt;&lt; (x &amp; 1 ? 4 : 0) ;
               * pPixel |= dwPixel &lt;&lt; (x &amp; 1 ? 0 : 4) ;
               break ;

     case  8:  * pPixel = (BYTE) dwPixel ;
               break ;

     case 16:  * (WORD *) pPixel = (WORD) dwPixel ;
               break ;

     case 24:  * (RGBTRIPLE *) pPixel = * (RGBTRIPLE *) &amp;dwPixel ; 
               break ;

     case 32:  * (DWORD *) pPixel = dwPixel ;
               break ;
     default:
          return FALSE ;
     }
     return TRUE ;
}

/*------------------------------------------------------
   DibGetPixelColor:  Obtains the pixel color at (x, y)
  ------------------------------------------------------*/

BOOL DibGetPixelColor (HDIB hdib, int x, int y, RGBQUAD * prgb)
{
     DWORD      dwPixel ;
     int        iBitCount ;
     PDIBSTRUCT pdib = hdib ;

          // Get bit count; also use this as a validity check

     if (0 == (iBitCount = DibBitCount (hdib)))
          return FALSE ;

          // Get the pixel value

     dwPixel = DibGetPixel (hdib, x, y) ;

          // If the bit-count is 8 or less, index the color table

     if (iBitCount &lt;= 8)
          return DibGetColor (hdib, (int) dwPixel, prgb) ;

          // If the bit-count is 24, just use the pixel

     else if (iBitCount == 24)
     {
          * (RGBTRIPLE *) prgb = * (RGBTRIPLE *) &amp; dwPixel ;
          prgb-&gt;rgbReserved = 0 ;
     }

          // If the bit-count is 32 and the biCompression field is BI_RGB,
          //   just use the pixel

     else if (iBitCount == 32 &amp;&amp; 
               pdib-&gt;ds.dsBmih.biCompression == BI_RGB)

     {
          * prgb = * (RGBQUAD *) &amp; dwPixel ;
     }

          // Otherwise, use the mask and shift values
          //   (for best performance, don't use DibMask and DibShift functions)
     else
     {
          prgb-&gt;rgbRed   = (BYTE) (((pdib-&gt;ds.dsBitfields[0] &amp; dwPixel) 
                                   &gt;&gt; pdib-&gt;iRShift[0]) &lt;&lt; pdib-&gt;iLShift[0]) ;

          prgb-&gt;rgbGreen = (BYTE) (((pdib-&gt;ds.dsBitfields[1] &amp; dwPixel) 
                                   &gt;&gt; pdib-&gt;iRShift[1]) &lt;&lt; pdib-&gt;iLShift[1]) ;

          prgb-&gt;rgbBlue  = (BYTE) (((pdib-&gt;ds.dsBitfields[2] &amp; dwPixel) 
                                   &gt;&gt; pdib-&gt;iRShift[2]) &lt;&lt; pdib-&gt;iLShift[2]) ;
     }
     return TRUE ;
}

/*---------------------------------------------------
   DibSetPixelColor:  Sets the pixel color at (x, y) 
  ---------------------------------------------------*/

BOOL DibSetPixelColor (HDIB hdib, int x, int y, RGBQUAD * prgb)
{
     DWORD      dwPixel ;
     int        iBitCount ;
     PDIBSTRUCT pdib = hdib ;

          // Don't do this function for DIBs with color tables

     iBitCount = DibBitCount (hdib) ;

     if (iBitCount &lt;= 8)
          return FALSE ;

          // The rest is just the opposite of DibGetPixelColor

     else if (iBitCount == 24)
     {
          * (RGBTRIPLE *) &amp; dwPixel = * (RGBTRIPLE *) prgb ;
          dwPixel &amp;= 0x00FFFFFF ;
     }
     else if (iBitCount == 32 &amp;&amp;
               pdib-&gt;ds.dsBmih.biCompression == BI_RGB)
     {
          * (RGBQUAD *) &amp; dwPixel = * prgb ;
     }

     else
     {
          dwPixel  = (((DWORD) prgb-&gt;rgbRed &gt;&gt; pdib-&gt;iLShift[0]) 
                         &lt;&lt; pdib-&gt;iRShift[0]) ; 

          dwPixel |= (((DWORD) prgb-&gt;rgbGreen &gt;&gt; pdib-&gt;iLShift[1])
                         &lt;&lt; pdib-&gt;iRShift[1]) ; 

          dwPixel |= (((DWORD) prgb-&gt;rgbBlue &gt;&gt; pdib-&gt;iLShift[2])
                         &lt;&lt; pdib-&gt;iRShift[2]) ; 
     }

     DibSetPixel (hdib, x, y, dwPixel) ;
     return TRUE ;
}
</pre>
</td></tr></table>

<P>This section of DIBHELP.C begins with a <I>DibPixelPtr</I> function that obtains a pointer to the byte where a particular pixel is stored (or partially stored). Recall that the <I>ppRow</I> field of the DIBSTRUCT structure is a pointer to the addresses of the rows of pixels in the DIB, beginning with the top row. Thus,

<p><pre>
((PDIBSTRUCT) hdib)-&gt;pprow)[0]
</PRE>

<P>is a pointer to the leftmost pixel of the top row of the DIB and

<p><pre>
(((PDIBSTRUCT) hdib)-&gt;ppRow)[y] + (x * DibBitCount (hdib) &gt;&gt; 3)
</PRE>

<P>is a pointer to the pixel at position (<I>x</I>,<I>y</I>). Notice that the function returns a NULL value if the DIB is not addressable (that is, if it's compressed) or if the <I>x</I> and <I>y</I> parameters to the function are negative or reference an area outside the DIB. This checking slows the function (and any function that relies on <I>DibPixelPtr</I>), but I'll describe some faster routines soon.

<P>The <I>DibGetPixel</I> and <I>DibSetPixel</I> functions that follow in the file make use of <I>DibPixelPtr</I>. For 8-bit, 16-bit, 24-bit, and 32-bit DIBs, these functions need only cast the pointer to the proper data size and access the pixel value. For 1-bit and 4-bit DIBs, some masking and shifting is required.

<P>The <I>DibGetColor</I> function obtains the pixel color as an RGBQUAD structure. For 1bit, 4-bit, and 8-bit DIBs, this involves using the pixel value to get a color from the DIB color table. For 16-bit, 24-bit, and 32-bit DIBs, in general the pixel value must be masked and shifted to derive an RGB color. The <I>DibSetPixel</I> function is opposite, and it allows setting a pixel value from an RGBQUAD structure. This function is defined only for 16-bit, 24-bit, and 32-bit DIBs.

<A NAME="580"><h2>Creating and Converting</h2></A>
<P>The third and final section of DIBHELP, shown in Figure 16-22, shows how DIB sections are created and how they can be converted to and from packed DIBs.



<P><B>Figure 16-22.</b> <i>The third and final part of the DIBHELP.C file.</I>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="581"><h3>DIBHELP.C (third part)</h3></A>
<P><pre>
/*--------------------------------------------------------------
   Calculating shift values from color masks is required by the 
     DibCreateFromInfo function.
  --------------------------------------------------------------*/

static int MaskToRShift (DWORD dwMask)
{
     int iShift ;

     if (dwMask == 0)
          return 0 ;

     for (iShift = 0 ; !(dwMask &amp; 1) ; iShift++)
          dwMask &gt;&gt;= 1 ;

     return iShift ;
}

static int MaskToLShift (DWORD dwMask)
{
     int iShift ;

     if (dwMask == 0)
          return 0 ;

     while (!(dwMask &amp; 1))
          dwMask &gt;&gt;= 1 ;

     for (iShift = 0 ; dwMask &amp; 1 ; iShift++)
          dwMask &gt;&gt;= 1 ;

     return 8 - iShift ;
}

/*-------------------------------------------------------------------------
   DibCreateFromInfo: All DIB creation functions ultimately call this one.
     This function is responsible for calling CreateDIBSection, allocating
     memory for DIBSTRUCT, and setting up the row pointer.
  -------------------------------------------------------------------------*/

HDIB DibCreateFromInfo (BITMAPINFO * pbmi)
{
     BYTE      * pBits ;
     DIBSTRUCT * pdib ;
     HBITMAP     hBitmap ;
     int         i, iRowLength, cy, y ;
     
     hBitmap = CreateDIBSection (NULL, pbmi, DIB_RGB_COLORS, &amp;pBits, NULL, 0) ;

     if (hBitmap == NULL)
          return NULL ;

     if (NULL == (pdib = malloc (sizeof (DIBSTRUCT))))
     {
          DeleteObject (hBitmap) ;
          return NULL ;
     }

     pdib-&gt;iSignature = HDIB_SIGNATURE ;
     pdib-&gt;hBitmap    = hBitmap ;
     pdib-&gt;pBits      = pBits ;

     GetObject (hBitmap, sizeof (DIBSECTION), &amp;pdib-&gt;ds) ;

          // Notice that we can now use the DIB information functions 
          //   defined above.

          // If the compression is BI_BITFIELDS, calculate shifts from masks

     if (DibCompression (pdib) == BI_BITFIELDS)
     {
          for (i = 0 ; i &lt; 3 ; i++)
          {
               pdib-&gt;iLShift[i] = MaskToLShift (pdib-&gt;ds.dsBitfields[i]) ;
               pdib-&gt;iRShift[i] = MaskToRShift (pdib-&gt;ds.dsBitfields[i]) ;
          }
     }

          // If the compression is BI_RGB, but bit-count is 16 or 32,
          //   set the bitfields and the masks

     else if (DibCompression (pdib) == BI_RGB)
     {
          if (DibBitCount (pdib) == 16)
          {
               pdib-&gt;ds.dsBitfields[0] = 0x00007C00 ;
               pdib-&gt;ds.dsBitfields[1] = 0x000003E0 ;
               pdib-&gt;ds.dsBitfields[2] = 0x0000001F ;

               pdib-&gt;iRShift[0] = 10 ;
               pdib-&gt;iRShift[1] =  5 ;
               pdib-&gt;iRShift[2] =  0 ; 

               pdib-&gt;iLShift[0] =  3 ;
               pdib-&gt;iLShift[1] =  3 ;
               pdib-&gt;iLShift[2] =  3 ;
          }
          else if (DibBitCount (pdib) == 24 || DibBitCount (pdib) == 32)
          {
               pdib-&gt;ds.dsBitfields[0] = 0x00FF0000 ;
               pdib-&gt;ds.dsBitfields[1] = 0x0000FF00 ;
               pdib-&gt;ds.dsBitfields[2] = 0x000000FF ;

               pdib-&gt;iRShift[0] = 16 ;
               pdib-&gt;iRShift[1] =  8 ;
               pdib-&gt;iRShift[2] =  0 ; 

               pdib-&gt;iLShift[0] =  0 ;
               pdib-&gt;iLShift[1] =  0 ;
               pdib-&gt;iLShift[2] =  0 ;
          }
     }
          // Allocate an array of pointers to each row in the DIB

     cy = DibHeight (pdib) ;

     if (NULL == (pdib-&gt;ppRow = malloc (cy * sizeof (BYTE *))))
     {
          free (pdib) ;
          DeleteObject (hBitmap) ;
          return NULL ;
     }

          // Initialize them.

     iRowLength = DibRowLength (pdib) ; 
     if (pbmi-&gt;bmiHeader.biHeight &gt; 0)       // ie, bottom up
     {
          for (y = 0 ; y &lt; cy ; y++)
               pdib-&gt;ppRow[y] = pBits + (cy - y - 1) * iRowLength ;
     }
     else                                    // top down
     {
          for (y = 0 ; y &lt; cy ; y++)
               pdib-&gt;ppRow[y] = pBits + y * iRowLength ;
     }
     return pdib ;
}

/*--------------------------------------------------
   DibDelete:  Frees all memory for the DIB section
  --------------------------------------------------*/

BOOL DibDelete (HDIB hdib)
{
     DIBSTRUCT * pdib = hdib ;

     if (!DibIsValid (hdib))
          return FALSE ;

     free (pdib-&gt;ppRow) ;
     DeleteObject (pdib-&gt;hBitmap) ;
     free (pdib) ;
     return TRUE ;
}

/*----------------------------------------------------
   DibCreate: Creates an HDIB from explicit arguments
  ----------------------------------------------------*/ 

HDIB DibCreate (int cx, int cy, int cBits, int cColors)
{
     BITMAPINFO * pbmi ;
     DWORD        dwInfoSize ;
     HDIB         hDib ;
     int          cEntries ;

     if (cx &lt;= 0 || cy &lt;= 0 || 
         ((cBits !=  1) &amp;&amp; (cBits !=  4) &amp;&amp; (cBits !=  8) &amp;&amp; 
          (cBits != 16) &amp;&amp; (cBits != 24) &amp;&amp; (cBits != 32)))

     {
          return NULL ;
     }

     if (cColors != 0)
          cEntries = cColors ;
     else if (cBits &lt;= 8)
          cEntries = 1 &lt;&lt; cBits ;

     dwInfoSize = sizeof (BITMAPINFOHEADER) + (cEntries - 1) * sizeof (RGBQUAD);

     if (NULL == (pbmi = malloc (dwInfoSize)))
     {
          return NULL ;
     }

     ZeroMemory (pbmi, dwInfoSize) ;

     pbmi-&gt;bmiHeader.biSize          = sizeof (BITMAPINFOHEADER) ;
     pbmi-&gt;bmiHeader.biWidth         = cx ;
     pbmi-&gt;bmiHeader.biHeight        = cy ;
     pbmi-&gt;bmiHeader.biPlanes        = 1 ;
     pbmi-&gt;bmiHeader.biBitCount      = cBits ;
     pbmi-&gt;bmiHeader.biCompression   = BI_RGB ;
     pbmi-&gt;bmiHeader.biSizeImage     = 0 ;
     pbmi-&gt;bmiHeader.biXPelsPerMeter = 0 ;
     pbmi-&gt;bmiHeader.biYPelsPerMeter = 0 ;
     pbmi-&gt;bmiHeader.biClrUsed       = cColors ;
     pbmi-&gt;bmiHeader.biClrImportant  = 0 ;

     hDib = DibCreateFromInfo (pbmi) ;
     free (pbmi) ;

     return hDib ;
}

/*--------------------------------------------------
   DibCopyToInfo:  Builds BITMAPINFO structure.
                   Used by DibCopy and DibCopyToDdb
  --------------------------------------------------*/

static BITMAPINFO * DibCopyToInfo (HDIB hdib)
{
     BITMAPINFO * pbmi ;
     int          i, iNumColors ;
     RGBQUAD    * prgb ;
     if (!DibIsValid (hdib))
          return NULL ;

          // Allocate the memory

     if (NULL == (pbmi = malloc (DibInfoSize (hdib))))
          return NULL ;

          // Copy the information header

     CopyMemory (pbmi, DibInfoHeaderPtr (hdib), 
                                        sizeof (BITMAPINFOHEADER));
          
          // Copy the possible color masks

     prgb = (RGBQUAD *) ((BYTE *) pbmi + sizeof (BITMAPINFOHEADER)) ;

     if (DibMaskSize (hdib))
     {
          CopyMemory (prgb, DibMaskPtr (hdib), 3 * sizeof (DWORD)) ;

          prgb = (RGBQUAD *) ((BYTE *) prgb + 3 * sizeof (DWORD)) ;
     }
          // Copy the color table

     iNumColors = DibNumColors (hdib) ;

     for (i = 0 ; i &lt; iNumColors ; i++)
          DibGetColor (hdib, i, prgb + i) ;

     return pbmi ;
}

/*-------------------------------------------------------------------
   DibCopy:  Creates a new DIB section from an existing DIB section,
     possibly swapping the DIB width and height.
  -------------------------------------------------------------------*/

HDIB DibCopy (HDIB hdibSrc, BOOL fRotate)
{
     BITMAPINFO * pbmi ;
     BYTE       * pBitsSrc, * pBitsDst ;
     HDIB         hdibDst ;

     if (!DibIsValid (hdibSrc))
          return NULL ;

     if (NULL == (pbmi = DibCopyToInfo (hdibSrc)))
          return NULL ;

     if (fRotate)
     {
          pbmi-&gt;bmiHeader.biWidth = DibHeight (hdibSrc) ;
          pbmi-&gt;bmiHeader.biHeight = DibWidth (hdibSrc) ;
     }

     hdibDst = DibCreateFromInfo (pbmi) ;
     free (pbmi) ;

     if (hdibDst == NULL)
          return NULL ;

          // Copy the bits

     if (!fRotate)
     {
          pBitsSrc = DibBitsPtr (hdibSrc) ;
          pBitsDst = DibBitsPtr (hdibDst) ;

          CopyMemory (pBitsDst, pBitsSrc, DibBitsSize (hdibSrc)) ;
     }
     return hdibDst ;
}

/*----------------------------------------------------------------------
   DibCopyToPackedDib is generally used for saving DIBs and for 
     transferring DIBs to the clipboard. In the second case, the second 
     argument should be set to TRUE so that the memory is allocated
     with the GMEM_SHARE flag.
  ----------------------------------------------------------------------*/

BITMAPINFO * DibCopyToPackedDib (HDIB hdib, BOOL fUseGlobal)
{
     BITMAPINFO * pPackedDib ;
     BYTE       * pBits ;
     DWORD        dwDibSize ;
     HDC          hdcMem ;
     HGLOBAL      hGlobal ;
     int          iNumColors ;
     PDIBSTRUCT   pdib = hdib ;
     RGBQUAD    * prgb ;

     if (!DibIsValid (hdib))
          return NULL ;
          // Allocate memory for packed DIB

     dwDibSize = DibTotalSize (hdib) ;

     if (fUseGlobal)
     {
          hGlobal = GlobalAlloc (GHND | GMEM_SHARE, dwDibSize) ;
          pPackedDib = GlobalLock (hGlobal) ;
     }
     else
     {
          pPackedDib = malloc (dwDibSize) ;
     }

     if (pPackedDib == NULL) 
          return NULL ;

          // Copy the information header

     CopyMemory (pPackedDib, &amp;pdib-&gt;ds.dsBmih, sizeof (BITMAPINFOHEADER)) ;

     prgb = (RGBQUAD *) ((BYTE *) pPackedDib + sizeof (BITMAPINFOHEADER)) ;

          // Copy the possible color masks

     if (pdib-&gt;ds.dsBmih.biCompression == BI_BITFIELDS)
     {
          CopyMemory (prgb, pdib-&gt;ds.dsBitfields, 3 * sizeof (DWORD)) ;

          prgb = (RGBQUAD *) ((BYTE *) prgb + 3 * sizeof (DWORD)) ;
     }
          // Copy the color table

     if (iNumColors = DibNumColors (hdib))
     {
          hdcMem = CreateCompatibleDC (NULL) ;
          SelectObject (hdcMem, pdib-&gt;hBitmap) ;
          GetDIBColorTable (hdcMem, 0, iNumColors, prgb) ;
          DeleteDC (hdcMem) ;
     }

     pBits = (BYTE *) (prgb + iNumColors) ;

          // Copy the bits

     CopyMemory (pBits, pdib-&gt;pBits, DibBitsSize (pdib)) ;

          // If last argument is TRUE, unlock global memory block and 
          //   cast it to pointer in preparation for return

     if (fUseGlobal)
     {
          GlobalUnlock (hGlobal) ;
          pPackedDib = (BITMAPINFO *) hGlobal ;     
     }
     return pPackedDib ;
}

/*------------------------------------------------------------------
   DibCopyFromPackedDib is generally used for pasting DIBs from the 
     clipboard.
  ------------------------------------------------------------------*/

HDIB DibCopyFromPackedDib (BITMAPINFO * pPackedDib)
{
     BYTE     * pBits ;     
     DWORD      dwInfoSize, dwMaskSize, dwColorSize ;
     int        iBitCount ;
     PDIBSTRUCT pdib ;

          // Get the size of the information header and do validity check
     
     dwInfoSize = pPackedDib-&gt;bmiHeader.biSize ;

     if (dwInfoSize != sizeof (BITMAPCOREHEADER) &amp;&amp;
         dwInfoSize != sizeof (BITMAPINFOHEADER) &amp;&amp;
         dwInfoSize != sizeof (BITMAPV4HEADER) &amp;&amp;
         dwInfoSize != sizeof (BITMAPV5HEADER))
     {
          return NULL ;
     }
          // Get the possible size of the color masks

     if (dwInfoSize == sizeof (BITMAPINFOHEADER) &amp;&amp;
          pPackedDib-&gt;bmiHeader.biCompression == BI_BITFIELDS)
     {
          dwMaskSize = 3 * sizeof (DWORD) ;
     }
     else
     {
          dwMaskSize = 0 ;
     }
          // Get the size of the color table
     if (dwInfoSize == sizeof (BITMAPCOREHEADER))
     {
          iBitCount = ((BITMAPCOREHEADER *) pPackedDib)-&gt;bcBitCount ;

          if (iBitCount &lt;= 8)
          {
               dwColorSize = (1 &lt;&lt; iBitCount) * sizeof (RGBTRIPLE) ;
          }
          else
               dwColorSize = 0 ;
     }
     else           // all non-OS/2 compatible DIBs
     {
          if (pPackedDib-&gt;bmiHeader.biClrUsed &gt; 0)
          {
               dwColorSize = pPackedDib-&gt;bmiHeader.biClrUsed * sizeof (RGBQUAD);
          }
          else if (pPackedDib-&gt;bmiHeader.biBitCount &lt;= 8)
          {
               dwColorSize = (1 &lt;&lt; pPackedDib-&gt;bmiHeader.biBitCount) * 
                                                       sizeof (RGBQUAD) ;
          }
          else
          {
               dwColorSize = 0 ;
          }
     }
          // Finally, get the pointer to the bits in the packed DIB

     pBits = (BYTE *) pPackedDib + dwInfoSize + dwMaskSize + dwColorSize ;

          // Create the HDIB from the packed-DIB pointer

     pdib = DibCreateFromInfo (pPackedDib) ;

          // Copy the pixel bits

     CopyMemory (pdib-&gt;pBits, pBits, DibBitsSize (pdib)) ;

     return pdib ;
}

/*-----------------------------------------------------
   DibFileLoad:  Creates a DIB section from a DIB file
  -----------------------------------------------------*/

HDIB DibFileLoad (const TCHAR * szFileName)
{
     BITMAPFILEHEADER bmfh ;
     BITMAPINFO     * pbmi ;
     BOOL             bSuccess ;
     DWORD            dwInfoSize, dwBitsSize, dwBytesRead ;
     HANDLE           hFile ;
     HDIB             hDib ;

          // Open the file: read access, prohibit write access

     hFile = CreateFile (szFileName, GENERIC_READ, FILE_SHARE_READ, NULL, 
                         OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL) ;

     if (hFile == INVALID_HANDLE_VALUE)
          return NULL ;

          // Read in the BITMAPFILEHEADER

     bSuccess = ReadFile (hFile, &amp;bmfh, sizeof (BITMAPFILEHEADER), 
                          &amp;dwBytesRead, NULL) ;

     if (!bSuccess || (dwBytesRead != sizeof (BITMAPFILEHEADER))         
                   || (bmfh.bfType != * (WORD *) &quot;BM&quot;))
     {
          CloseHandle (hFile) ;
          return NULL ;
     }
          // Allocate memory for the information structure &amp; read it in

     dwInfoSize = bmfh.bfOffBits - sizeof (BITMAPFILEHEADER) ;

     if (NULL == (pbmi = malloc (dwInfoSize)))
     {
          CloseHandle (hFile) ;
          return NULL ;
     }

     bSuccess = ReadFile (hFile, pbmi, dwInfoSize, &amp;dwBytesRead, NULL) ;

     if (!bSuccess || (dwBytesRead != dwInfoSize))
     {
          CloseHandle (hFile) ;
          free (pbmi) ;
          return NULL ;
     }
          // Create the DIB

     hDib = DibCreateFromInfo (pbmi) ;
     free (pbmi) ;

     if (hDib == NULL)
     {
          CloseHandle (hFile) ;
          return NULL ;
     }
          // Read in the bits

     dwBitsSize = bmfh.bfSize - bmfh.bfOffBits ;

     bSuccess = ReadFile (hFile, ((PDIBSTRUCT) hDib)-&gt;pBits, 
                          dwBitsSize, &amp;dwBytesRead, NULL) ;
     CloseHandle (hFile) ;

     if (!bSuccess || (dwBytesRead != dwBitsSize))
     {
          DibDelete (hDib) ;
          return NULL ;
     }
     return hDib ;
}

/*---------------------------------------------
   DibFileSave:  Saves a DIB section to a file
  ---------------------------------------------*/

BOOL DibFileSave (HDIB hdib, const TCHAR * szFileName)
{
     BITMAPFILEHEADER bmfh ;
     BITMAPINFO     * pbmi ;
     BOOL             bSuccess ;
     DWORD            dwTotalSize, dwBytesWritten ;
     HANDLE           hFile ;

     hFile = CreateFile (szFileName, GENERIC_WRITE, 0, NULL,
                         CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL) ;

     if (hFile == INVALID_HANDLE_VALUE)
          return FALSE ;

     dwTotalSize  = DibTotalSize (hdib) ;
     bmfh.bfType      = * (WORD *) &quot;BM&quot; ;
     bmfh.bfSize      = sizeof (BITMAPFILEHEADER) + dwTotalSize ;
     bmfh.bfReserved1 = 0 ;
     bmfh.bfReserved2 = 0 ;
     bmfh.bfOffBits   = bmfh.bfSize - DibBitsSize (hdib) ;

          // Write the BITMAPFILEHEADER

     bSuccess = WriteFile (hFile, &amp;bmfh, sizeof (BITMAPFILEHEADER), 
                           &amp;dwBytesWritten, NULL) ;

     if (!bSuccess || (dwBytesWritten != sizeof (BITMAPFILEHEADER)))
     {
          CloseHandle (hFile) ;
          DeleteFile (szFileName) ;
          return FALSE ;
     }
          // Get entire DIB in packed-DIB format

     if (NULL == (pbmi = DibCopyToPackedDib (hdib, FALSE)))
     {
          CloseHandle (hFile) ;
          DeleteFile (szFileName) ;
          return FALSE ;
     }
          // Write out the packed DIB

     bSuccess = WriteFile (hFile, pbmi, dwTotalSize, &amp;dwBytesWritten, NULL) ;
     CloseHandle (hFile) ;
     free (pbmi) ;

     if (!bSuccess || (dwBytesWritten != dwTotalSize))
     {
          DeleteFile (szFileName) ;
          return FALSE ;
     }
     return TRUE ;
}

/*---------------------------------------------------
   DibCopyToDdb:  For more efficient screen displays
  ---------------------------------------------------*/
HBITMAP DibCopyToDdb (HDIB hdib, HWND hwnd, HPALETTE hPalette)
{
     BITMAPINFO * pbmi ;
     HBITMAP      hBitmap ;
     HDC          hdc ;

     if (!DibIsValid (hdib))
          return NULL ;

     if (NULL == (pbmi = DibCopyToInfo (hdib)))
          return NULL ;

     hdc = GetDC (hwnd) ;

     if (hPalette)
     {
          SelectPalette (hdc, hPalette, FALSE) ;
          RealizePalette (hdc) ;
     }
     
     hBitmap = CreateDIBitmap (hdc, DibInfoHeaderPtr (hdib), CBM_INIT,
                               DibBitsPtr (hdib), pbmi, DIB_RGB_COLORS) ;

     ReleaseDC (hwnd, hdc) ;
     free (pbmi) ;

     return hBitmap ;
}
</pre>
</td></tr></table>

<P>This part of the DIBHELP.C file begins with two little functions that derive left-shift and right-shift values from color masks for 16-bit and 32-bit DIBs. These functions were described in the Color Masking section in <a href="ch15a.htm#473">Chapter 15</a>.

<P>The <I>DibCreateFromInfo</I> function is the only function in DIBHELP that calls <I>CreateDIBSection</I> and allocates memory for the DIBSTRUCT structure. All other creation and copy functions go through this function. The single parameter to <I>DibCreateFromInfo</I> is a pointer to a BITMAPINFO structure. The color table of this structure must exist, but it doesn't necessarily have to be filled with valid values. After calling <I>CreateDIBSection</I>, the function initializes all the fields of the DIBSTRUCT structure. Notice that when setting the values of the <I>ppRow</I> field of the DIBSTRUCT structure (the pointers to the DIB row addresses), separate logic exists for bottom-up and top-down DIBs. The first element of <I>ppRow</I> is always the top row of the DIB.

<P><I>DibDelete</I> deletes the bitmap created in <I>DibCreateFromInfo</I> and also frees the memory allocated in that function.



<P><I>DibCreate</I> is probably a more likely function than <I>DibCreateFromInfo</I> to be called from application programs. The first three arguments provide the pixel width and height and the number of bits per pixel. The last argument can be set to 0 for a color table of default size or to a nonzero value to indicate a smaller color table than would otherwise be implied by the bit count.

<P>The <I>DibCopy</I> function creates a new DIB section from an existing DIB section. It uses the <I>DibCreateInfo</I> function that allocates memory for a BITMAPINFO structure and puts all the data into it. A BOOL argument to the <I>DibCopy</I> function indicates whether the DIB width and height are to be switched around when creating the new DIB section. We'll see a use for this later.

<P>The <I>DibCopyToPackedDib</I> and <I>DibCopyFromPackedDib</I> functions are generally used in conjunction with passing DIBs through the clipboard. The <I>DibFileLoad</I> function creates a DIB section from a DIB file; <I>DibFileSave</I> functions saves to a DIB file.

<P>Finally, the <I>DibCopyToDdb</I> function creates a GDI bitmap object from a DIB. Notice that the function requires handles to the current palette and the program's window. The program's window handle is used for getting a device context into which the palette is selected and realized. Only then can the function make a call to <I>CreateDIBitmap</I>. This was demonstrated in the SHOWDIB7 program earlier in this chapter.

<A NAME="582"><h2>The DIBHELP Header File and Macros</h2></A>
<P>The DIBHELP.H header file is shown in Figure 16-23.



<P><B>Figure 16-23.</b> <i>The DIBHELP.H file.</I><table cellpadding=5 width="95%"><tr><td>
<A NAME="583"><h3>DIBHELP.H</h3></A>
<P><pre>
/*-------------------------------------
   DIBHELP.H header file for DIBHELP.C
  -------------------------------------*/

typedef void * HDIB ;

     // Functions in DIBHELP.C

BOOL DibIsValid (HDIB hdib) ;
HBITMAP DibBitmapHandle (HDIB hdib) ;
int DibWidth (HDIB hdib) ;
int DibHeight (HDIB hdib) ;
int DibBitCount (HDIB hdib) ;
int DibRowLength (HDIB hdib) ;
int DibNumColors (HDIB hdib) ;
DWORD DibMask (HDIB hdib, int i) ;
int DibRShift (HDIB hdib, int i) ;
int DibLShift (HDIB hdib, int i) ;
int DibCompression (HDIB hdib) ;
BOOL DibIsAddressable (HDIB hdib) ;
DWORD DibInfoHeaderSize (HDIB hdib) ;
DWORD DibMaskSize (HDIB hdib) ;
DWORD DibColorSize (HDIB hdib) ;
DWORD DibInfoSize (HDIB hdib) ;
DWORD DibBitsSize (HDIB hdib) ;
DWORD DibTotalSize (HDIB hdib) ;
BITMAPINFOHEADER * DibInfoHeaderPtr (HDIB hdib) ;
DWORD * DibMaskPtr (HDIB hdib) ;
void * DibBitsPtr (HDIB hdib) ;
BOOL DibGetColor (HDIB hdib, int index, RGBQUAD * prgb) ;
BOOL DibSetColor (HDIB hdib, int index, RGBQUAD * prgb) ;
BYTE * DibPixelPtr (HDIB hdib, int x, int y) ;
DWORD DibGetPixel (HDIB hdib, int x, int y) ;
BOOL DibSetPixel (HDIB hdib, int x, int y, DWORD dwPixel) ;
BOOL DibGetPixelColor (HDIB hdib, int x, int y, RGBQUAD * prgb) ;
BOOL DibSetPixelColor (HDIB hdib, int x, int y, RGBQUAD * prgb) ;
HDIB DibCreateFromInfo (BITMAPINFO * pbmi) ;
BOOL DibDelete (HDIB hdib) ;
HDIB DibCreate (int cx, int cy, int cBits, int cColors) ;
HDIB DibCopy (HDIB hdibSrc, BOOL fRotate) ;
BITMAPINFO * DibCopyToPackedDib (HDIB hdib, BOOL fUseGlobal) ;
HDIB DibCopyFromPackedDib (BITMAPINFO * pPackedDib) ;
HDIB DibFileLoad (const TCHAR * szFileName) ;
BOOL DibFileSave (HDIB hdib, const TCHAR * szFileName) ;
HBITMAP DibCopyToDdb (HDIB hdib, HWND hwnd, HPALETTE hPalette) ;
HDIB DibCreateFromDdb (HBITMAP hBitmap) ;

/*-----------------------------------------------
   Quickie no-bounds-checked pixel gets and sets
  -----------------------------------------------*/

#define DibPixelPtr1(hdib, x, y)  (((* (PBYTE **) hdib) [y]) + ((x) &gt;&gt; 3))
#define DibPixelPtr4(hdib, x, y)  (((* (PBYTE **) hdib) [y]) + ((x) &gt;&gt; 1))
#define DibPixelPtr8(hdib, x, y)  (((* (PBYTE **) hdib) [y]) +  (x)      )
#define DibPixelPtr16(hdib, x, y)  \
                        ((WORD *) (((* (PBYTE **) hdib) [y]) +  (x) *  2))

#define DibPixelPtr24(hdib, x, y)  \
                   ((RGBTRIPLE *) (((* (PBYTE **) hdib) [y]) +  (x) *  3))

#define DibPixelPtr32(hdib, x, y)  \
                       ((DWORD *) (((* (PBYTE **) hdib) [y]) +  (x) *  4))

#define DibGetPixel1(hdib, x, y)   \
               (0x01 &amp; (* DibPixelPtr1 (hdib, x, y) &gt;&gt; (7 - ((x) &amp; 7))))

#define DibGetPixel4(hdib, x, y)   \
               (0x0F &amp; (* DibPixelPtr4 (hdib, x, y) &gt;&gt; ((x) &amp; 1 ? 0 : 4)))

#define DibGetPixel8(hdib, x, y)     (* DibPixelPtr8  (hdib, x, y))
#define DibGetPixel16(hdib, x, y)    (* DibPixelPtr16 (hdib, x, y))
#define DibGetPixel24(hdib, x, y)    (* DibPixelPtr24 (hdib, x, y))
#define DibGetPixel32(hdib, x, y)    (* DibPixelPtr32(hdib, x, y))

#define DibSetPixel1(hdib, x, y, p)                                        \
          ((* DibPixelPtr1 (hdib, x, y) &amp;= ~( 1  &lt;&lt; (7 - ((x) &amp; 7)))),     \
           (* DibPixelPtr1 (hdib, x, y) |=  ((p) &lt;&lt; (7 - ((x) &amp; 7)))))

#define DibSetPixel4(hdib, x, y, p)                                        \
          ((* DibPixelPtr4 (hdib, x, y) &amp;= (0x0F &lt;&lt; ((x) &amp; 1 ? 4 : 0))),   \
           (* DibPixelPtr4 (hdib, x, y) |= ((p)  &lt;&lt; ((x) &amp; 1 ? 0 : 4))))

#define DibSetPixel8(hdib, x, y, p)  (* DibPixelPtr8 (hdib, x, y) = p)
#define DibSetPixel16(hdib, x, y, p) (* DibPixelPtr16 (hdib, x, y) = p)
#define DibSetPixel24(hdib, x, y, p) (* DibPixelPtr24 (hdib, x, y) = p)
#define DibSetPixel32(hdib, x, y, p) (* DibPixelPtr32 (hdib, x, y) = p)
</pre>
</td></tr></table>

<P>This header file defines the HDIB handle as a void pointer. An application really shouldn't know about the internal structure of the structure to which HDIB points. The header file also includes declarations of all the functions in DIBHELP.C. And then there are the macros&#8212;the very special macros.

<P>If you look back at the <I>DibPixelPtr</I>, <I>DibGetPixel</I>, and <I>DibSetPixel</I> functions in DIBHELP.C and try to improve their performance, you'll see a couple of possible solutions. First, you can remove all the bulletproofing and trust that an application will not call the function with invalid arguments. You can also remove some of the function calls, such as <I>DibBitCount</I>, and obtain that information directly by using the pointer to the DIBSTRUCT structure instead.

<P>A less obvious way to improve performance is to do away with all the logic involving the number of bits per pixel and have separate functions for each type of DIB&#8212;for example, <I>DibGetPixel1</I>, <I>DibGetPixel4</I>, <I>DibGetPixel8</I>, and so forth. The next optimization is to remove the function call entirely and incorporate the logic in inline functions or macros.

<P>DIBHELP.H takes the macro approach. It provides three sets of macros based on the <I>DibPixelPtr</I>, <I>DibGetPixel</I>, and <I>DibSetPixel</I> functions. These macros are all specific to a particular bit count.

<A NAME="584"><h2>The DIBBLE Program</h2></A>
<P>The DIBBLE program shown in Figure 16-24 puts the DIBHELP functions and macros to work. Although DIBBLE is the longest program in this book, it is really only a crude sampler of some jobs that might be found in simple digital image-processing programs. One obvious improvement to DIBBLE would be to convert it to a multiple document interface (MDI), but we won't learn how to do that until <a href="ch19a.htm#695">Chapter 19</a>.



<P><B>Figure 16-24.</b> <i>The DIBBLE program.</I>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="585"><h3>DIBBLE.C</h3></A>


<P><pre>
/*----------------------------------------
   DIBBLE.C -- Bitmap and Palette Program
               (c) Charles Petzold, 1998
  ----------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;dibhelp.h&quot;
#include &quot;dibpal.h&quot;
#include &quot;dibconv.h&quot;
#include &quot;resource.h&quot;

#define WM_USER_SETSCROLLS    (WM_USER + 1)
#define WM_USER_DELETEDIB     (WM_USER + 2)
#define WM_USER_DELETEPAL     (WM_USER + 3)
#define WM_USER_CREATEPAL     (WM_USER + 4)

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

TCHAR szAppName[] = TEXT (&quot;Dibble&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HACCEL   hAccel ;
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;

     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = szAppName ;
     wndclass.lpszClassName = szAppName ;

     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;), 
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }

     hwnd = CreateWindow (szAppName, szAppName,
                          WS_OVERLAPPEDWINDOW | WM_VSCROLL | WM_HSCROLL,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT, 
                          NULL, NULL, hInstance, NULL) ;

     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;

     hAccel = LoadAccelerators (hInstance, szAppName) ;

     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          if (!TranslateAccelerator (hwnd, hAccel, &amp;msg))
          {
               TranslateMessage (&amp;msg) ;
               DispatchMessage (&amp;msg) ;
          }
     }
     return msg.wParam ;
}

/*-------------------------------------------------------------
   DisplayDib: Displays or prints DIB actual size or stretched 
               depending on menu selection
  -------------------------------------------------------------*/

int DisplayDib (HDC hdc, HBITMAP hBitmap, int x, int y, 
                int cxClient, int cyClient, 
                WORD wShow, BOOL fHalftonePalette)
{
     BITMAP bitmap ;
     HDC    hdcMem ; 
     int    cxBitmap, cyBitmap, iReturn ;
     GetObject (hBitmap, sizeof (BITMAP), &amp;bitmap) ;
     cxBitmap = bitmap.bmWidth ;
     cyBitmap = bitmap.bmHeight ;

     SaveDC (hdc) ;

     if (fHalftonePalette)
          SetStretchBltMode (hdc, HALFTONE) ;
     else
          SetStretchBltMode (hdc, COLORONCOLOR) ;

     hdcMem = CreateCompatibleDC (hdc) ;
     SelectObject (hdcMem, hBitmap) ;

     switch (wShow)
     {
     case IDM_SHOW_NORMAL:
          if (fHalftonePalette)
               iReturn = StretchBlt (hdc,    0, 0, 
                                             min (cxClient, cxBitmap - x), 
                                             min (cyClient, cyBitmap - y), 
                                     hdcMem, x, y, 
                                             min (cxClient, cxBitmap - x), 
                                             min (cyClient, cyBitmap - y), 
                                     SRCCOPY);
          else
               iReturn = BitBlt (hdc,    0, 0, 
                                         min (cxClient, cxBitmap - x), 
                                         min (cyClient, cyBitmap - y),
                                 hdcMem, x, y, SRCCOPY) ;
          break ;
               
     case IDM_SHOW_CENTER:
          if (fHalftonePalette)
               iReturn = StretchBlt (hdc, (cxClient - cxBitmap) / 2,
                                          (cyClient - cyBitmap) / 2, 
                                          cxBitmap, cyBitmap,
                                     hdcMem, 0, 0, cxBitmap, cyBitmap, SRCCOPY);
          else
               iReturn = BitBlt (hdc, (cxClient - cxBitmap) / 2,
                                      (cyClient - cyBitmap) / 2, 
                                      cxBitmap, cyBitmap,
                                 hdcMem, 0, 0, SRCCOPY) ;
          break ;

     case IDM_SHOW_STRETCH:
          iReturn = StretchBlt (hdc,    0, 0, cxClient, cyClient, 
                                hdcMem, 0, 0, cxBitmap, cyBitmap, SRCCOPY) ;
          break ;

     case IDM_SHOW_ISOSTRETCH:
          SetMapMode (hdc, MM_ISOTROPIC) ;
          SetWindowExtEx (hdc, cxBitmap, cyBitmap, NULL) ;
          SetViewportExtEx (hdc, cxClient, cyClient, NULL) ;
          SetWindowOrgEx (hdc, cxBitmap / 2, cyBitmap / 2, NULL) ;
          SetViewportOrgEx (hdc, cxClient / 2, cyClient / 2, NULL) ;

          iReturn = StretchBlt (hdc,    0, 0, cxBitmap, cyBitmap, 
                                hdcMem, 0, 0, cxBitmap, cyBitmap, SRCCOPY) ;
          break ;
     }
     DeleteDC (hdcMem) ;
     RestoreDC (hdc, -1) ;
     return iReturn ;
}

/*--------------------------------------------------------------------
   DibFlipHorizontal: Calls non-optimized DibSetPixel and DibGetPixel
  --------------------------------------------------------------------*/

HDIB DibFlipHorizontal (HDIB hdibSrc)
{
     HDIB hdibDst ;
     int  cx, cy, x, y ;

     if (!DibIsAddressable (hdibSrc))
          return NULL ;

     if (NULL == (hdibDst = DibCopy (hdibSrc, FALSE)))
          return NULL ;

     cx = DibWidth  (hdibSrc) ;
     cy = DibHeight (hdibSrc) ;
     
     for (x = 0 ; x &lt; cx ; x++)
     for (y = 0 ; y &lt; cy ; y++)
     {
          DibSetPixel (hdibDst, x, cy - 1 - y, DibGetPixel (hdibSrc, x, y)) ;
     }

     return hdibDst ;
}

/*---------------------------------------------------------------
   DibRotateRight: Calls optimized DibSetPixelx and DibGetPixelx
  ---------------------------------------------------------------*/

HDIB DibRotateRight (HDIB hdibSrc)
{
     HDIB hdibDst ;
     int  cx, cy, x, y ;

     if (!DibIsAddressable (hdibSrc))
          return NULL ;

     if (NULL == (hdibDst = DibCopy (hdibSrc, TRUE)))
          return NULL ;

     cx = DibWidth (hdibSrc) ;
     cy = DibHeight (hdibSrc) ;

     switch (DibBitCount (hdibSrc))
     {
     case  1:  
          for (x = 0 ; x &lt; cx ; x++)
          for (y = 0 ; y &lt; cy ; y++)
               DibSetPixel1 (hdibDst, cy - y - 1, x, 
                    DibGetPixel1 (hdibSrc, x, y)) ;
          break ;

     case  4:  
          for (x = 0 ; x &lt; cx ; x++)
          for (y = 0 ; y &lt; cy ; y++)
               DibSetPixel4 (hdibDst, cy - y - 1, x, 
                    DibGetPixel4 (hdibSrc, x, y)) ;
          break ;

     case  8:
          for (x = 0 ; x &lt; cx ; x++)
          for (y = 0 ; y &lt; cy ; y++)
               DibSetPixel8 (hdibDst, cy - y - 1, x, 
                    DibGetPixel8 (hdibSrc, x, y)) ;
          break ;

     case 16:  
          for (x = 0 ; x &lt; cx ; x++)
          for (y = 0 ; y &lt; cy ; y++)
               DibSetPixel16 (hdibDst, cy - y - 1, x, 
                    DibGetPixel16 (hdibSrc, x, y)) ;
          break ;

     case 24:
          for (x = 0 ; x &lt; cx ; x++)
          for (y = 0 ; y &lt; cy ; y++)
               DibSetPixel24 (hdibDst, cy - y - 1, x, 
                    DibGetPixel24 (hdibSrc, x, y)) ;
          break ;

     case 32:  
          for (x = 0 ; x &lt; cx ; x++)
          for (y = 0 ; y &lt; cy ; y++)
               DibSetPixel32 (hdibDst, cy - y - 1, x, 
                    DibGetPixel32 (hdibSrc, x, y)) ;
          break ;
     }
     return hdibDst ;
}

/*----------------------------------------------------------
   PaletteMenu: Uncheck and check menu item on palette menu
  ----------------------------------------------------------*/

void PaletteMenu (HMENU hMenu, WORD wItemNew)
{
     static WORD wItem = IDM_PAL_NONE ;

     CheckMenuItem (hMenu, wItem, MF_UNCHECKED) ;
     wItem = wItemNew ;
     CheckMenuItem (hMenu, wItem, MF_CHECKED) ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static BOOL         fHalftonePalette ;
     static DOCINFO      di = { sizeof (DOCINFO), TEXT (&quot;Dibble: Printing&quot;) } ;
     static HBITMAP      hBitmap ;
     static HDIB         hdib ;
     static HMENU        hMenu ;
     static HPALETTE     hPalette ;
     static int          cxClient, cyClient, iVscroll, iHscroll ;
     static OPENFILENAME ofn ;
     static PRINTDLG     printdlg = { sizeof (PRINTDLG) } ;
     static TCHAR        szFileName [MAX_PATH], szTitleName [MAX_PATH] ;
     static TCHAR        szFilter[] = TEXT (&quot;Bitmap Files (*.BMP)\0*.bmp\0&quot;)
                                      TEXT (&quot;All Files (*.*)\0*.*\0\0&quot;) ;
     static TCHAR      * szCompression[] = { 
                           TEXT (&quot;BI_RGB&quot;), TEXT (&quot;BI_RLE8&quot;), TEXT (&quot;BI_RLE4&quot;), 
                           TEXT (&quot;BI_BITFIELDS&quot;), TEXT (&quot;Unknown&quot;) } ;
     static WORD         wShow = IDM_SHOW_NORMAL ;
     BOOL                fSuccess ;
     BYTE              * pGlobal ;
     HDC                 hdc, hdcPrn ;
     HGLOBAL             hGlobal ;
     HDIB                hdibNew ;
     int                 iEnable, cxPage, cyPage, iConvert ;
     PAINTSTRUCT         ps ;
     SCROLLINFO          si ;
     TCHAR               szBuffer [256] ;

     switch (message)
     {
     case WM_CREATE:
         
               // Save the menu handle in a static variable

          hMenu = GetMenu (hwnd) ;

               // Initialize the OPENFILENAME structure for the File Open
               //   and File Save dialog boxes.

          ofn.lStructSize       = sizeof (OPENFILENAME) ;
          ofn.hwndOwner         = hwnd ;
          ofn.hInstance         = NULL ;
          ofn.lpstrFilter       = szFilter ;
          ofn.lpstrCustomFilter = NULL ;
          ofn.nMaxCustFilter    = 0 ;
          ofn.nFilterIndex      = 0 ;
          ofn.lpstrFile         = szFileName ;
          ofn.nMaxFile          = MAX_PATH ;
          ofn.lpstrFileTitle    = szTitleName ;
          ofn.nMaxFileTitle     = MAX_PATH ;
          ofn.lpstrInitialDir   = NULL ;
          ofn.lpstrTitle        = NULL ;
          ofn.Flags             = OFN_OVERWRITEPROMPT ;
          ofn.nFileOffset       = 0 ;
          ofn.nFileExtension    = 0 ;
          ofn.lpstrDefExt       = TEXT (&quot;bmp&quot;) ;
          ofn.lCustData         = 0 ;
          ofn.lpfnHook          = NULL ;
          ofn.lpTemplateName    = NULL ;
          return 0 ;

     case WM_DISPLAYCHANGE:
          SendMessage (hwnd, WM_USER_DELETEPAL, 0, 0) ;
          SendMessage (hwnd, WM_USER_CREATEPAL, TRUE, 0) ;
          return 0 ;

     case WM_SIZE:
               // Save the client area width and height in static variables.

          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;

          wParam = FALSE ;
                                             // fall through

               // WM_USER_SETSCROLLS:  Programmer-defined Message!
               // Set the scroll bars. If the display mode is not normal,
               //   make them invisible. If wParam is TRUE, reset the 
               //   scroll bar position.

     case WM_USER_SETSCROLLS:
          if (hdib == NULL || wShow != IDM_SHOW_NORMAL)
          {
               si.cbSize = sizeof (SCROLLINFO) ;
               si.fMask  = SIF_RANGE ;
               si.nMin   = 0 ;
               si.nMax   = 0 ;
               SetScrollInfo (hwnd, SB_VERT, &amp;si, TRUE) ;
               SetScrollInfo (hwnd, SB_HORZ, &amp;si, TRUE) ;
          }
          else
          {
                    // First the vertical scroll

               si.cbSize = sizeof (SCROLLINFO) ;
               si.fMask  = SIF_ALL ;

               GetScrollInfo (hwnd, SB_VERT, &amp;si) ;
               si.nMin  = 0 ;
               si.nMax  = DibHeight (hdib) ;
               si.nPage = cyClient ;
               if ((BOOL) wParam)
                    si.nPos = 0 ;

               SetScrollInfo (hwnd, SB_VERT, &amp;si, TRUE) ;
               GetScrollInfo (hwnd, SB_VERT, &amp;si) ;

               iVscroll = si.nPos ;

                    // Then the horizontal scroll

               GetScrollInfo (hwnd, SB_HORZ, &amp;si) ;
               si.nMin  = 0 ;
               si.nMax  = DibWidth (hdib) ;
               si.nPage = cxClient ;
          
               if ((BOOL) wParam)
                    si.nPos = 0 ;

               SetScrollInfo (hwnd, SB_HORZ, &amp;si, TRUE) ;
               GetScrollInfo (hwnd, SB_HORZ, &amp;si) ;

               iHscroll = si.nPos ;
          }
          return 0 ;

          // WM_VSCROLL: Vertically scroll the DIB

     case WM_VSCROLL:
          si.cbSize = sizeof (SCROLLINFO) ;
          si.fMask  = SIF_ALL ;
          GetScrollInfo (hwnd, SB_VERT, &amp;si) ;
          
          iVscroll = si.nPos ;

          switch (LOWORD (wParam))
          {
          case SB_LINEUP:      si.nPos -= 1 ;             break ;
          case SB_LINEDOWN:    si.nPos += 1 ;             break ;
          case SB_PAGEUP:      si.nPos -= si.nPage ;      break ;
          case SB_PAGEDOWN:    si.nPos += si.nPage ;      break ;
          case SB_THUMBTRACK:  si.nPos  = si.nTrackPos ;  break ;
          default:                                        break ;
          }

          si.fMask = SIF_POS ;
          SetScrollInfo (hwnd, SB_VERT, &amp;si, TRUE) ;
          GetScrollInfo (hwnd, SB_VERT, &amp;si) ;

          if (si.nPos != iVscroll)
          {
               ScrollWindow (hwnd, 0, iVscroll - si.nPos, NULL, NULL) ;
               iVscroll = si.nPos ;
               UpdateWindow (hwnd) ;
          }
          return 0 ;

          // WM_HSCROLL: Horizontally scroll the DIB

     case WM_HSCROLL:
          si.cbSize = sizeof (SCROLLINFO) ;
          si.fMask  = SIF_ALL ;
          GetScrollInfo (hwnd, SB_HORZ, &amp;si) ;
          
          iHscroll = si.nPos ;

          switch (LOWORD (wParam))
          {
          case SB_LINELEFT:    si.nPos -= 1 ;             break ;
          case SB_LINERIGHT:   si.nPos += 1 ;             break ;
          case SB_PAGELEFT:    si.nPos -= si.nPage ;      break ;
          case SB_PAGERIGHT:   si.nPos += si.nPage ;      break ;
          case SB_THUMBTRACK:  si.nPos  = si.nTrackPos ;  break ;
          default:                                        break ;
          }

          si.fMask = SIF_POS ;
          SetScrollInfo (hwnd, SB_HORZ, &amp;si, TRUE) ;
          GetScrollInfo (hwnd, SB_HORZ, &amp;si) ;

          if (si.nPos != iHscroll)
          {
               ScrollWindow (hwnd, iHscroll - si.nPos, 0, NULL, NULL) ;
               iHscroll = si.nPos ;
               UpdateWindow (hwnd) ;
          }
          return 0 ;

          // WM_INITMENUPOPUP:  Enable or Gray menu items
     case WM_INITMENUPOPUP:
          if (hdib)
               iEnable = MF_ENABLED ;
          else
               iEnable = MF_GRAYED ;

          EnableMenuItem (hMenu, IDM_FILE_SAVE,       iEnable) ;
          EnableMenuItem (hMenu, IDM_FILE_PRINT,      iEnable) ;
          EnableMenuItem (hMenu, IDM_FILE_PROPERTIES, iEnable) ;
          EnableMenuItem (hMenu, IDM_EDIT_CUT,        iEnable) ;
          EnableMenuItem (hMenu, IDM_EDIT_COPY,       iEnable) ;
          EnableMenuItem (hMenu, IDM_EDIT_DELETE,     iEnable) ;

          if (DibIsAddressable (hdib))
               iEnable = MF_ENABLED ;
          else
               iEnable = MF_GRAYED ;

          EnableMenuItem (hMenu, IDM_EDIT_ROTATE,    iEnable) ;
          EnableMenuItem (hMenu, IDM_EDIT_FLIP,      iEnable) ;
          EnableMenuItem (hMenu, IDM_CONVERT_01,     iEnable) ;
          EnableMenuItem (hMenu, IDM_CONVERT_04,     iEnable) ;
          EnableMenuItem (hMenu, IDM_CONVERT_08,     iEnable) ;
          EnableMenuItem (hMenu, IDM_CONVERT_16,     iEnable) ;
          EnableMenuItem (hMenu, IDM_CONVERT_24,     iEnable) ;
          EnableMenuItem (hMenu, IDM_CONVERT_32,     iEnable) ;

          switch (DibBitCount (hdib))
          {
          case  1: EnableMenuItem (hMenu, IDM_CONVERT_01, MF_GRAYED) ; break ;
          case  4: EnableMenuItem (hMenu, IDM_CONVERT_04, MF_GRAYED) ; break ;
          case  8: EnableMenuItem (hMenu, IDM_CONVERT_08, MF_GRAYED) ; break ;
          case 16: EnableMenuItem (hMenu, IDM_CONVERT_16, MF_GRAYED) ; break ;
          case 24: EnableMenuItem (hMenu, IDM_CONVERT_24, MF_GRAYED) ; break ;
          case 32: EnableMenuItem (hMenu, IDM_CONVERT_32, MF_GRAYED) ; break ;
          }

          if (hdib &amp;&amp; DibColorSize (hdib) &gt; 0)
               iEnable = MF_ENABLED ;
          else
               iEnable = MF_GRAYED ;

          EnableMenuItem (hMenu, IDM_PAL_DIBTABLE,    iEnable) ;

          if (DibIsAddressable (hdib) &amp;&amp; DibBitCount (hdib) &gt; 8)
               iEnable = MF_ENABLED ;
          else
               iEnable = MF_GRAYED ;

          EnableMenuItem (hMenu, IDM_PAL_OPT_POP4,   iEnable) ;
          EnableMenuItem (hMenu, IDM_PAL_OPT_POP5,   iEnable) ;
          EnableMenuItem (hMenu, IDM_PAL_OPT_POP6,   iEnable) ;
          EnableMenuItem (hMenu, IDM_PAL_OPT_MEDCUT, iEnable) ;

          EnableMenuItem (hMenu, IDM_EDIT_PASTE, 
               IsClipboardFormatAvailable (CF_DIB) ? MF_ENABLED : MF_GRAYED) ;

          return 0 ;

          // WM_COMMAND:  Process all menu commands.

     case WM_COMMAND:
          iConvert = 0 ;

          switch (LOWORD (wParam))
          {
          case IDM_FILE_OPEN:

                    // Show the File Open dialog box

               if (!GetOpenFileName (&amp;ofn))
                    return 0 ;
               
                    // If there's an existing DIB and palette, delete them

               SendMessage (hwnd, WM_USER_DELETEDIB, 0, 0) ;
               
                    // Load the DIB into memory

               SetCursor (LoadCursor (NULL, IDC_WAIT)) ;
               ShowCursor (TRUE) ;

               hdib = DibFileLoad (szFileName) ;

               ShowCursor (FALSE) ;
               SetCursor (LoadCursor (NULL, IDC_ARROW)) ;

                    // Reset the scroll bars
               SendMessage (hwnd, WM_USER_SETSCROLLS, TRUE, 0) ;

                    // Create the palette and DDB

               SendMessage (hwnd, WM_USER_CREATEPAL, TRUE, 0) ;

               if (!hdib)
               {
                    MessageBox (hwnd, TEXT (&quot;Cannot load DIB file!&quot;), 
                                szAppName, MB_OK | MB_ICONEXCLAMATION) ;
               }
               InvalidateRect (hwnd, NULL, TRUE) ;
               return 0 ;

          case IDM_FILE_SAVE:

                    // Show the File Save dialog box

               if (!GetSaveFileName (&amp;ofn))
                    return 0 ;

                    // Save the DIB to memory

               SetCursor (LoadCursor (NULL, IDC_WAIT)) ;
               ShowCursor (TRUE) ;

               fSuccess = DibFileSave (hdib, szFileName) ;

               ShowCursor (FALSE) ;
               SetCursor (LoadCursor (NULL, IDC_ARROW)) ;

               if (!fSuccess)
                    MessageBox (hwnd, TEXT (&quot;Cannot save DIB file!&quot;),
                                szAppName, MB_OK | MB_ICONEXCLAMATION) ;
               return 0 ;

          case IDM_FILE_PRINT:
               if (!hdib)
                    return 0 ;

                    // Get printer DC

               printdlg.Flags = PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION ;

               if (!PrintDlg (&amp;printdlg))
                    return 0 ;

               if (NULL == (hdcPrn = printdlg.hDC))
               {
                    MessageBox (hwnd, TEXT (&quot;Cannot obtain Printer DC&quot;),
                                szAppName, MB_ICONEXCLAMATION | MB_OK) ;
                    return 0 ;
               }
                    
                    // Check if the printer can print bitmaps

               if (!(RC_BITBLT &amp; GetDeviceCaps (hdcPrn, RASTERCAPS)))
               {
                    DeleteDC (hdcPrn) ;
                    MessageBox (hwnd, TEXT (&quot;Printer cannot print bitmaps&quot;).
                                szAppName, MB_ICONEXCLAMATION | MB_OK) ;
                    return 0 ;

                    // Get size of printable area of page
                    // Check if the printer can print bitmaps
 
               if (!(RC_BITBLT &amp; GetDeviceCaps (hdcPrn, RASTERCAPS)))
               { 
                   DeleteDC (hdcPRN) ;
                   MessageBox (hwnd, TEXT (&quot;Printer cannot print bitmaps&quot;),
                               szAppName, MB_ICONEXCLAMATION | MB_OK) ;
                   return 0 ;
               } 

               cxPage = GetDeviceCaps (hdcPrn, HORZRES) ;
               cyPage = GetDeviceCaps (hdcPrn, VERTRES) ;

               fSuccess = FALSE ;

                    // Send the DIB to the printer

               SetCursor (LoadCursor (NULL, IDC_WAIT)) ;
               ShowCursor (TRUE) ;

               if ((StartDoc (hdcPrn, &amp;di) &gt; 0) &amp;&amp; (StartPage (hdcPrn) &gt; 0))
               {
                    DisplayDib (hdcPrn, DibBitmapHandle (hdib), 0, 0, 
                                cxPage, cyPage, wShow, FALSE) ;
                    
                    if (EndPage (hdcPrn) &gt; 0)
                    {
                         fSuccess = TRUE ;
                         EndDoc (hdcPrn) ;
                    }
               }
               ShowCursor (FALSE) ;
               SetCursor (LoadCursor (NULL, IDC_ARROW)) ;

               DeleteDC (hdcPrn) ;

               if (!fSuccess)
                    MessageBox (hwnd, TEXT (&quot;Could not print bitmap&quot;),
                                szAppName, MB_ICONEXCLAMATION | MB_OK) ;
               return 0 ;

          case IDM_FILE_PROPERTIES:
               if (!hdib)
                    return 0 ;
               wsprintf (szBuffer, TEXT (&quot;Pixel width:\t%i\n&quot;)
                                   TEXT (&quot;Pixel height:\t%i\n&quot;)
                                   TEXT (&quot;Bits per pixel:\t%i\n&quot;)
                                   TEXT (&quot;Number of colors:\t%i\n&quot;)
                                   TEXT (&quot;Compression:\t%s\n&quot;),
                         DibWidth (hdib), DibHeight (hdib),
                         DibBitCount (hdib), DibNumColors (hdib),
                         szCompression [min (3, DibCompression (hdib))]) ;

               MessageBox (hwnd, szBuffer, szAppName, 
                           MB_ICONEXCLAMATION | MB_OK) ;
               return 0 ;

          case IDM_APP_EXIT:
               SendMessage (hwnd, WM_CLOSE, 0, 0) ;
               return 0 ;

          case IDM_EDIT_COPY:
          case IDM_EDIT_CUT:
               if (!(hGlobal = DibCopyToPackedDib (hdib, TRUE)))
                    return 0 ;

               OpenClipboard (hwnd) ;
               EmptyClipboard () ;
               SetClipboardData (CF_DIB, hGlobal) ;
               CloseClipboard () ;

               if (LOWORD (wParam) == IDM_EDIT_COPY)
                    return 0 ;
                                   // fall through for IDM_EDIT_CUT
          case IDM_EDIT_DELETE:
               SendMessage (hwnd, WM_USER_DELETEDIB, 0, 0) ;
               InvalidateRect (hwnd, NULL, TRUE) ;
               return 0 ;

          case IDM_EDIT_PASTE:
               OpenClipboard (hwnd) ;

               hGlobal = GetClipboardData (CF_DIB) ;
               pGlobal = GlobalLock (hGlobal) ;

                    // If there's an existing DIB and palette, delete them
                    // Then convert the packed DIB to an HDIB.

               if (pGlobal)
               {
                    SendMessage (hwnd, WM_USER_DELETEDIB, 0, 0) ;
                    hdib = DibCopyFromPackedDib ((BITMAPINFO *) pGlobal) ;
                    SendMessage (hwnd, WM_USER_CREATEPAL, TRUE, 0) ;
               }

               GlobalUnlock (hGlobal) ;
               CloseClipboard () ;

                    // Reset the scroll bars

               SendMessage (hwnd, WM_USER_SETSCROLLS, TRUE, 0) ;
               InvalidateRect (hwnd, NULL, TRUE) ;
               return 0 ;

          case IDM_EDIT_ROTATE:
               if (hdibNew = DibRotateRight (hdib))
               {
                    DibDelete (hdib) ;
                    DeleteObject (hBitmap) ;
                    hdib = hdibNew ;
                    hBitmap = DibCopyToDdb (hdib, hwnd, hPalette) ;
                    SendMessage (hwnd, WM_USER_SETSCROLLS, TRUE, 0) ;
                    InvalidateRect (hwnd, NULL, TRUE) ;
               }
               else
               {
                    MessageBox (hwnd, TEXT (&quot;Not enough memory&quot;),
                                szAppName, MB_OK | MB_ICONEXCLAMATION) ;
               }
               return 0 ;

          case IDM_EDIT_FLIP:
               if (hdibNew = DibFlipHorizontal (hdib))
               {
                    DibDelete (hdib) ;
                    DeleteObject (hBitmap) ;
                    hdib = hdibNew ;
                    hBitmap = DibCopyToDdb (hdib, hwnd, hPalette) ;
                    InvalidateRect (hwnd, NULL, TRUE) ;
               }
               else
               {
                    MessageBox (hwnd, TEXT (&quot;Not enough memory&quot;),
                                szAppName, MB_OK | MB_ICONEXCLAMATION) ;
               }
               return 0 ;

          case IDM_SHOW_NORMAL:
          case IDM_SHOW_CENTER:
          case IDM_SHOW_STRETCH:
          case IDM_SHOW_ISOSTRETCH:
               CheckMenuItem (hMenu, wShow, MF_UNCHECKED) ;
               wShow = LOWORD (wParam) ;
               CheckMenuItem (hMenu, wShow, MF_CHECKED) ;

               SendMessage (hwnd, WM_USER_SETSCROLLS, FALSE, 0) ;

               InvalidateRect (hwnd, NULL, TRUE) ;
               return 0 ;

          case IDM_CONVERT_32:  iConvert += 8 ;
          case IDM_CONVERT_24:  iConvert += 8 ;   
          case IDM_CONVERT_16:  iConvert += 8 ;
          case IDM_CONVERT_08:  iConvert += 4 ;
          case IDM_CONVERT_04:  iConvert += 3 ;
          case IDM_CONVERT_01:  iConvert += 1 ;
               SetCursor (LoadCursor (NULL, IDC_WAIT)) ;
               ShowCursor (TRUE) ;

               hdibNew = DibConvert (hdib, iConvert) ;

               ShowCursor (FALSE) ;
               SetCursor (LoadCursor (NULL, IDC_ARROW)) ;

               if (hdibNew)
               {
                    SendMessage (hwnd, WM_USER_DELETEDIB, 0, 0) ;
                    hdib = hdibNew ;
                    SendMessage (hwnd, WM_USER_CREATEPAL, TRUE, 0) ;
                    InvalidateRect (hwnd, NULL, TRUE) ;
               }

               else
               {
                    MessageBox (hwnd, TEXT (&quot;Not enough memory&quot;),
                                szAppName, MB_OK | MB_ICONEXCLAMATION) ;
               }
               return 0 ;

          case IDM_APP_ABOUT:
               MessageBox (hwnd, TEXT (&quot;Dibble (c) Charles Petzold, 1998&quot;),
                           szAppName, MB_OK | MB_ICONEXCLAMATION) ;
               return 0 ;
          }
     
               // All the other WM_COMMAND messages are from the palette
               //   items. Any existing palette is deleted, and the cursor
               //   is set to the hourglass.

          SendMessage (hwnd, WM_USER_DELETEPAL, 0, 0) ;
          SetCursor (LoadCursor (NULL, IDC_WAIT)) ;
          ShowCursor (TRUE) ;

               // Notice that all messages for palette items are ended
               //   with break rather than return. This is to allow 
               //   additional processing later on.

          switch (LOWORD (wParam))
          {
          case IDM_PAL_DIBTABLE: 
               hPalette = DibPalDibTable (hdib) ; 
               break ;

          case IDM_PAL_HALFTONE: 
               hdc = GetDC (hwnd) ;

               if (hPalette = CreateHalftonePalette (hdc))
                    fHalftonePalette = TRUE ;

               ReleaseDC (hwnd, hdc) ;
               break ;

          case IDM_PAL_ALLPURPOSE: 
               hPalette = DibPalAllPurpose () ; 
               break ;
          case IDM_PAL_GRAY2:   hPalette = DibPalUniformGrays (  2) ; break ;
          case IDM_PAL_GRAY3:   hPalette = DibPalUniformGrays (  3) ; break ;
          case IDM_PAL_GRAY4:   hPalette = DibPalUniformGrays (  4) ; break ;
          case IDM_PAL_GRAY8:   hPalette = DibPalUniformGrays (  8) ; break ;
          case IDM_PAL_GRAY16:  hPalette = DibPalUniformGrays ( 16) ; break ;
          case IDM_PAL_GRAY32:  hPalette = DibPalUniformGrays ( 32) ; break ;
          case IDM_PAL_GRAY64:  hPalette = DibPalUniformGrays ( 64) ; break ;
          case IDM_PAL_GRAY128: hPalette = DibPalUniformGrays (128) ; break ;
          case IDM_PAL_GRAY256: hPalette = DibPalUniformGrays (256) ; break ;

          case IDM_PAL_RGB222: hPalette = DibPalUniformColors (2,2,2); break;
          case IDM_PAL_RGB333: hPalette = DibPalUniformColors (3,3,3); break;
          case IDM_PAL_RGB444: hPalette = DibPalUniformColors (4,4,4); break;
          case IDM_PAL_RGB555: hPalette = DibPalUniformColors (5,5,5); break;
          case IDM_PAL_RGB666: hPalette = DibPalUniformColors (6,6,6); break;
          case IDM_PAL_RGB775: hPalette = DibPalUniformColors (7,7,5); break;
          case IDM_PAL_RGB757: hPalette = DibPalUniformColors (7,5,7); break;
          case IDM_PAL_RGB577: hPalette = DibPalUniformColors (5,7,7); break;
          case IDM_PAL_RGB884: hPalette = DibPalUniformColors (8,8,4); break;
          case IDM_PAL_RGB848: hPalette = DibPalUniformColors (8,4,8); break;
          case IDM_PAL_RGB488: hPalette = DibPalUniformColors (4,8,8); break;

          case IDM_PAL_OPT_POP4:  
               hPalette = DibPalPopularity (hdib, 4) ;
               break ;

          case IDM_PAL_OPT_POP5:  
               hPalette = DibPalPopularity (hdib, 5) ;
               break ;

          case IDM_PAL_OPT_POP6:  
               hPalette = DibPalPopularity (hdib, 6) ;
               break ;                   

          case IDM_PAL_OPT_MEDCUT:
               hPalette = DibPalMedianCut (hdib, 6) ;
               break ;
          }

               // After processing Palette items from the menu, the cursor
               //   is restored to an arrow, the menu item is checked, and
               //   the window is invalidated.

          hBitmap = DibCopyToDdb (hdib, hwnd, hPalette) ;

          ShowCursor (FALSE) ;
          SetCursor (LoadCursor (NULL, IDC_ARROW)) ;

          if (hPalette)
                PaletteMenu (hMenu, (LOWORD (wParam))) ;

          InvalidateRect (hwnd, NULL, TRUE) ;
          return 0 ;

          // This programmer-defined message deletes an existing DIB 
          //   in preparation for getting a new one.  Invoked during 
          //   File Open command, Edit Paste command, and others.

     case WM_USER_DELETEDIB:
          if (hdib)
          {
               DibDelete (hdib) ;
               hdib = NULL ;
          }
          SendMessage (hwnd, WM_USER_DELETEPAL, 0, 0) ;
          return 0 ;

          // This programmer-defined message deletes an existing palette
          //   in preparation for defining a new one.

     case WM_USER_DELETEPAL:
          if (hPalette)
          {
               DeleteObject (hPalette) ;
               hPalette = NULL ;
               fHalftonePalette = FALSE ;
               PaletteMenu (hMenu, IDM_PAL_NONE) ;
          }
          if (hBitmap)
               DeleteObject (hBitmap) ;

          return 0 ;

          // Programmer-defined message to create a new palette based on 
          //   a new DIB.  If wParam == TRUE, create a DDB as well.

     case WM_USER_CREATEPAL:
          if (hdib)
          {
               hdc = GetDC (hwnd) ;
              if (!(RC_PALETTE &amp; GetDeviceCaps (hdc, RASTERCAPS)))
               {
                    PaletteMenu (hMenu, IDM_PAL_NONE) ;
               }
               else if (hPalette = DibPalDibTable (hdib))
               {
                    PaletteMenu (hMenu, IDM_PAL_DIBTABLE) ;
               }
               else if (hPalette = CreateHalftonePalette (hdc))
               {
                    fHalftonePalette = TRUE ;
                    PaletteMenu (hMenu, IDM_PAL_HALFTONE) ;
               }
               ReleaseDC (hwnd, hdc) ;

               if ((BOOL) wParam)
                    hBitmap = DibCopyToDdb (hdib, hwnd, hPalette) ;
          }
          return 0 ;

     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;

          if (hPalette)
          {
               SelectPalette (hdc, hPalette, FALSE) ;
               RealizePalette (hdc) ;
          }
          if (hBitmap)
          {
               DisplayDib (hdc, 
                           fHalftonePalette ? DibBitmapHandle (hdib) : hBitmap, 
                           iHscroll, iVscroll, 
                           cxClient, cyClient, 
                           wShow, fHalftonePalette) ;
          }
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;

     case WM_QUERYNEWPALETTE:
          if (!hPalette)
               return FALSE ;

          hdc = GetDC (hwnd) ;
          SelectPalette (hdc, hPalette, FALSE) ;
          RealizePalette (hdc) ;
          InvalidateRect (hwnd, NULL, TRUE) ;

          ReleaseDC (hwnd, hdc) ;
          return TRUE ;

     case WM_PALETTECHANGED:
          if (!hPalette || (HWND) wParam == hwnd)
               break ;

          hdc = GetDC (hwnd) ;
          SelectPalette (hdc, hPalette, FALSE) ;
          RealizePalette (hdc) ;
          UpdateColors (hdc) ;

          ReleaseDC (hwnd, hdc) ;
          break ;

     case WM_DESTROY:
          if (hdib)
               DibDelete (hdib) ;

          if (hBitmap)
               DeleteObject (hBitmap) ;

          if (hPalette)
               DeleteObject (hPalette) ;

          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

<table cellpadding=5 width="95%"><tr><td>
<A NAME="586"><h3>DIBBLE.RC (excerpts)</h3></A>
<P><pre>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;
/////////////////////////////////////////////////////////////////////////////
// Menu

DIBBLE MENU DISCARDABLE 
BEGIN
    POPUP &quot;&amp;File&quot;
    BEGIN
        MENUITEM &quot;&amp;Open...\tCtrl+O&quot;,            IDM_FILE_OPEN
        MENUITEM &quot;&amp;Save...\tCtrl+S&quot;,            IDM_FILE_SAVE
        MENUITEM SEPARATOR
        MENUITEM &quot;&amp;Print...\tCtrl+P&quot;,           IDM_FILE_PRINT
        MENUITEM SEPARATOR
        MENUITEM &quot;Propert&amp;ies...&quot;,              IDM_FILE_PROPERTIES
        MENUITEM SEPARATOR
        MENUITEM &quot;E&amp;xit&quot;,                       IDM_APP_EXIT
    END
    POPUP &quot;&amp;Edit&quot;
    BEGIN
        MENUITEM &quot;Cu&amp;t\tCtrl+X&quot;,                IDM_EDIT_CUT
        MENUITEM &quot;&amp;Copy\tCtrl+C&quot;,               IDM_EDIT_COPY
        MENUITEM &quot;&amp;Paste\tCtrl+V&quot;,              IDM_EDIT_PASTE
        MENUITEM &quot;&amp;Delete\tDelete&quot;,             IDM_EDIT_DELETE
        MENUITEM SEPARATOR
        MENUITEM &quot;&amp;Flip&quot;,                       IDM_EDIT_FLIP
        MENUITEM &quot;&amp;Rotate&quot;,                     IDM_EDIT_ROTATE
    END
    POPUP &quot;&amp;Show&quot;
    BEGIN
        MENUITEM &quot;&amp;Actual Size&quot;,                IDM_SHOW_NORMAL, CHECKED
        MENUITEM &quot;&amp;Center&quot;,                     IDM_SHOW_CENTER
        MENUITEM &quot;&amp;Stretch to Window&quot;,          IDM_SHOW_STRETCH
        MENUITEM &quot;Stretch &amp;Isotropically&quot;,      IDM_SHOW_ISOSTRETCH
    END
    POPUP &quot;&amp;Palette&quot;
    BEGIN
        MENUITEM &quot;&amp;None&quot;,                       IDM_PAL_NONE, CHECKED
        MENUITEM &quot;&amp;Dib ColorTable&quot;,             IDM_PAL_DIBTABLE
        MENUITEM &quot;&amp;Halftone&quot;,                   IDM_PAL_HALFTONE
        MENUITEM &quot;&amp;All-Purpose&quot;,                IDM_PAL_ALLPURPOSE
        POPUP &quot;&amp;Gray Shades&quot;
        BEGIN
            MENUITEM &quot;&amp;1. 2 Grays&quot;,                 IDM_PAL_GRAY2
            MENUITEM &quot;&amp;2. 3 Grays&quot;,                 IDM_PAL_GRAY3
            MENUITEM &quot;&amp;3. 4 Grays&quot;,                 IDM_PAL_GRAY4
            MENUITEM &quot;&amp;4. 8 Grays&quot;,                 IDM_PAL_GRAY8
            MENUITEM &quot;&amp;5. 16 Grays&quot;,                IDM_PAL_GRAY16
            MENUITEM &quot;&amp;6. 32 Grays&quot;,                IDM_PAL_GRAY32
            MENUITEM &quot;&amp;7. 64 Grays&quot;,                IDM_PAL_GRAY64
            MENUITEM &quot;&amp;8. 128 Grays&quot;,               IDM_PAL_GRAY128
            MENUITEM &quot;&amp;9. 256 Grays&quot;,               IDM_PAL_GRAY256
        END
        POPUP &quot;&amp;Uniform Colors&quot;

        BEGIN
            MENUITEM &quot;&amp;1. 2R x 2G x 2B (8)&quot;,        IDM_PAL_RGB222
            MENUITEM &quot;&amp;2. 3R x 3G x 3B (27)&quot;,       IDM_PAL_RGB333
            MENUITEM &quot;&amp;3. 4R x 4G x 4B (64)&quot;,       IDM_PAL_RGB444
            MENUITEM &quot;&amp;4. 5R x 5G x 5B (125)&quot;,      IDM_PAL_RGB555
            MENUITEM &quot;&amp;5. 6R x 6G x 6B (216)&quot;,      IDM_PAL_RGB666
            MENUITEM &quot;&amp;6. 7R x 7G x 5B (245)&quot;,      IDM_PAL_RGB775
            MENUITEM &quot;&amp;7. 7R x 5B x 7B (245)&quot;,      IDM_PAL_RGB757
            MENUITEM &quot;&amp;8. 5R x 7G x 7B (245)&quot;,      IDM_PAL_RGB577
            MENUITEM &quot;&amp;9. 8R x 8G x 4B (256)&quot;,      IDM_PAL_RGB884
            MENUITEM &quot;&amp;A. 8R x 4G x 8B (256)&quot;,      IDM_PAL_RGB848
            MENUITEM &quot;&amp;B. 4R x 8G x 8B (256)&quot;,      IDM_PAL_RGB488
        END
        POPUP &quot;&amp;Optimized&quot;
        BEGIN
            MENUITEM &quot;&amp;1. Popularity Algorithm (4 bits)&quot;, IDM_PAL_OPT_POP4
            MENUITEM &quot;&amp;2. Popularity Algorithm (5 bits)&quot;, IDM_PAL_OPT_POP5
            MENUITEM &quot;&amp;3. Popularity Algorithm (6 bits)&quot;, IDM_PAL_OPT_POP6
            MENUITEM &quot;&amp;4. Median Cut Algorithm &quot;,   IDM_PAL_OPT_MEDCUT
        END
    END
    POPUP &quot;Con&amp;vert&quot;
    BEGIN
        MENUITEM &quot;&amp;1. to 1 bit per pixel&quot;,      IDM_CONVERT_01
        MENUITEM &quot;&amp;2. to 4 bits per pixel&quot;,     IDM_CONVERT_04
        MENUITEM &quot;&amp;3. to 8 bits per pixel&quot;,     IDM_CONVERT_08
        MENUITEM &quot;&amp;4. to 16 bits per pixel&quot;,    IDM_CONVERT_16
        MENUITEM &quot;&amp;5. to 24 bits per pixel&quot;,    IDM_CONVERT_24
        MENUITEM &quot;&amp;6. to 32 bits per pixel&quot;,    IDM_CONVERT_32
    END
    POPUP &quot;&amp;Help&quot;
    BEGIN
        MENUITEM &quot;&amp;About&quot;,                      IDM_APP_ABOUT
    END
END

/////////////////////////////////////////////////////////////////////////////
// Accelerator

DIBBLE ACCELERATORS DISCARDABLE 
BEGIN
    &quot;C&quot;,            IDM_EDIT_COPY,          VIRTKEY, CONTROL, NOINVERT
    &quot;O&quot;,            IDM_FILE_OPEN,          VIRTKEY, CONTROL, NOINVERT
    &quot;P&quot;,            IDM_FILE_PRINT,         VIRTKEY, CONTROL, NOINVERT
    &quot;S&quot;,            IDM_FILE_SAVE,          VIRTKEY, CONTROL, NOINVERT
    &quot;V&quot;,            IDM_EDIT_PASTE,         VIRTKEY, CONTROL, NOINVERT
    VK_DELETE,      IDM_EDIT_DELETE,        VIRTKEY, NOINVERT
    &quot;X&quot;,            IDM_EDIT_CUT,           VIRTKEY, CONTROL, NOINVERT
END

#define IDM_FILE_OPEN                   40001
#define IDM_FILE_SAVE                   40002
#define IDM_FILE_PRINT                  40003

<B>RESOURCE.H (excerpts)</B>

// Microsoft Developer Studio generated include file.
// Used by Dibble.rc

#define IDM_FILE_PROPERTIES             40004
#define IDM_APP_EXIT                    40005
#define IDM_EDIT_CUT                    40006
#define IDM_EDIT_COPY                   40007
#define IDM_EDIT_PASTE                  40008
#define IDM_EDIT_DELETE                 40009
#define IDM_EDIT_FLIP                   40010
#define IDM_EDIT_ROTATE                 40011
#define IDM_SHOW_NORMAL                 40012
#define IDM_SHOW_CENTER                 40013
#define IDM_SHOW_STRETCH                40014
#define IDM_SHOW_ISOSTRETCH             40015
#define IDM_PAL_NONE                    40016
#define IDM_PAL_DIBTABLE                40017
#define IDM_PAL_HALFTONE                40018
#define IDM_PAL_ALLPURPOSE              40019
#define IDM_PAL_GRAY2                   40020
#define IDM_PAL_GRAY3                   40021
#define IDM_PAL_GRAY4                   40022
#define IDM_PAL_GRAY8                   40023
#define IDM_PAL_GRAY16                  40024
#define IDM_PAL_GRAY32                  40025
#define IDM_PAL_GRAY64                  40026
#define IDM_PAL_GRAY128                 40027
#define IDM_PAL_GRAY256                 40028
#define IDM_PAL_RGB222                  40029
#define IDM_PAL_RGB333                  40030
#define IDM_PAL_RGB444                  40031
#define IDM_PAL_RGB555                  40032
#define IDM_PAL_RGB666                  40033
#define IDM_PAL_RGB775                  40034
#define IDM_PAL_RGB757                  40035
#define IDM_PAL_RGB577                  40036
#define IDM_PAL_RGB884                  40037
#define IDM_PAL_RGB848                  40038
#define IDM_PAL_RGB488                  40039
#define IDM_PAL_OPT_POP4                40040
#define IDM_PAL_OPT_POP5                40041
#define IDM_PAL_OPT_POP6                40042
#define IDM_PAL_OPT_MEDCUT              40043
#define IDM_CONVERT_01                  40044
#define IDM_CONVERT_04                  40045
#define IDM_CONVERT_08                  40046
#define IDM_CONVERT_16                  40047
#define IDM_CONVERT_24                  40048
#define IDM_CONVERT_32                  40049
#define IDM_APP_ABOUT                   40050
</pre>
</td></tr></table>

<P>DIBBLE uses a couple other files that I'll describe shortly. The DIBCONV files (DIBCONV.C and DIBCONV.H) convert between different formats&#8212;for example, from 24 bits per pixel to 8 bits per pixel. The DIBPAL files (DIBPAL.C and DIBPAL.H) create palettes.

<P>DIBBLE maintains three crucial static variables in <I>WndProc</I>. These are an HDIB handle called <I>hdib</I>, an HPALETTE handle called <I>hPalette</I>, and an HBITMAP handle called <I>hBitmap</I>. The HDIB comes from various functions in DIBHELP; the HPALETTE comes from various functions in DIBPAL or the <I>CreateHalftonePalette</I> function; and the HBITMAP handle comes from the <I>DibCopyToDdb</I> function in DIBHELP.C and helps speed up screen displays, particularly in 256-color video modes. However, this handle must be re-created whenever the program creates a new DIB Section (obviously) and also when the program creates a different palette (not so obviously).

<P>Let's approach DIBBLE functionally rather than sequentially.

<A NAME="587"><h3>File Loading and Saving</h3></A>
<P>DIBBLE can load DIB files and save them in response to WM_COMMAND messages of IDM_FILE_LOAD and IDM_FILE_SAVE. In processing these messages, DIBBLE invokes the common file dialog boxes by calling <I>GetOpenFileName</I> and <I>GetSaveFileName</I>, respectively.

<P>For the File Save menu command, DIBBLE need only call <I>DibFileSave.</I> For the File Open menu command, DIBBLE must first delete the previous HDIB, palette, and bitmap objects. It does this by sending itself a WM_USER_DELETEDIB message, which is processed by calls to <I>DibDelete</I> and <I>DeleteObject</I>. DIBBLE then calls the <I>DibFileLoad</I> function in DIBHELP and sends itself WM_USER_SETSCROLLS and WM_USER_CREATEPAL messages to reset the scroll bars and create a palette. The WM_USER_CREATEPAL message is also the place where the program creates a new DDB from the DIB section.

<A NAME="588"><h3>Displaying, Scrolling, and Printing</h3></A>
<P>DIBBLE's menu allows it to display the DIB in actual size oriented at the top left corner of its client area or centered in the client area, or stretched to fill the client area or as much of the client area as possible while still maintaining the proper aspect ratio. You select which option you want through DIBBLE's Show menu. Note that these are the same four display options available in the SHOWDIB2 program from the last chapter.

<P>During the WM_PAINT message&#8212;and also while processing the File Print command&#8212;DIBBLE calls its <I>DisplayDib</I> function. Notice that <I>DisplayDib</I> uses <I>BitBlt</I> and <I>StretchBlt</I> rather than <I>SetDIBitsToDevice</I> and <I>StretchDIBits</I>. During the WM_PAINT message, the bitmap handle passed to the function is the one created by the <I>DibCopyToDdb</I> function, which is called during the WM_USER_CREATEPAL message. This DDB is compatible with the video device context. When processing the File Print command, DIBBLE calls <I>DisplayDib</I> with the DIB section handle available from <I>DibBitmapHandle</I> function in DIBHELP.C.

<P>Also notice that DIBBLE retains a static BOOL variable named <I>fHalftonePalette</I>, which is set to TRUE if <I>hPalette</I> was obtained from the <I>CreateHalftonePalette</I> function. This forces the <I>DisplayDib</I> function to call <I>StretchBlt</I> rather than <I>BitBlt</I> even if the DIB is being displayed in actual size. The <I>fHalftonePalette</I> variable also causes WM_PAINT processing to pass the DIB section handle to the <I>DisplayDib</I> function rather than the bitmap handle created by the <I>DibCopyToDdb</I> function. The use of the halftone palette was discussed earlier in this chapter and illustrated in the SHOWDIB5 program.

<P>For the first time in any of our sample programs, DIBBLE allows scrolling DIBs in the client area. The scroll bars are shown only when the DIB is displayed in actual size. <I>WndProc</I> simply passes the current position of the scroll bars to the <I>DisplayDib</I> function when processing WM_PAINT.

<A NAME="589"><h3>The Clipboard</h3></A>
<P>For the Cut and Copy menu items, DIBBLE calls the <I>DibCopyToPackedDib</I> function in DIBHELP. This function simply takes all the components of the DIB and puts them in a big memory block.

<P>For the first time in one of the sample programs in this book, DIBBLE pastes a DIB from the clipboard. This involves a call to the <I>DibCopyFromPackedDib</I> function and replaces the HDIB, palette, and bitmap previously stored by the window procedure.

<A NAME="590"><h3>Flipping and Rotating</h3></A>
<P>The Edit menu in DIBBLE contains two additional items beyond the standard Cut, Copy, Paste, and Delete options. These are Flip and Rotate. The Flip option causes the bitmap to be flipped around the horizontal axis&#8212;that is, flipped upside down. The Rotate option causes the bitmap to be rotated 90&#176; clockwise. Both of these functions require accessing all the pixels of the DIB by copying them from one DIB to another. (Because these two functions don't require creating a new palette, the palette is not deleted and recreated.)

<P>The Flip menu option uses the <I>DibFlipHorizontal</I> function, also located in the DIBBLE.C file. This function calls <I>DibCopy</I> to obtain an exact copy of the DIB. It then enters a loop that copies pixels from the original DIB to the new DIB, but the pixels are copied so that the image is flipped upside down. Notice that this function calls <I>DibGetPixel</I> and <I>DibSetPixel</I>. These are the general-purpose (but not quite as fast as we may prefer) functions located in DIBHELP.C.

<P>To illustrate the difference between the <I>DibGetPixel</I> and <I>DibSetPixel</I> functions and the much faster <I>DibGetPixel</I> and <I>DibSetPixel</I> macros in DIBHELP.H, the <I>DibRotateRight</I> function uses the macros. Notice first, however, that this function calls <I>DibCopy</I> with a second argument set to TRUE. This causes <I>DibCopy</I> to flip the width and height of the original DIB to create the new DIB. Also, the pixel bits are not copied by the <I>DibCopy</I> function. The <I>DibRotateRight</I> function, then, has six different loops to copy the pixel bits from the original DIB to the new DIB&#8212;one for each of the different possible DIB pixel widths (1 bit, 4 bit, 8 bit, 16 bit, 24 bit, and 32 bit). There's more code involved, but the function is much faster.

<P>Although it's possible to use the Flip Horizontal and Rotate Right options to mimic Flip Vertical, Rotate Left, and Rotate 180&#176; functions, normally a program would implement all of these options directly. DIBBLE is, of course, just a demonstration program.

<A NAME="591"><h2>Simple Palettes; Optimized Palettes</h2></A>
<P>In DIBBLE you can choose a variety of palettes for displaying DIBs on 256-color video displays. These are all listed on DIBBLE's Palette menu. With the exception of the halftone palette, which is created directly by a Windows function call, all of the functions to create various palettes are provided by the DIBPAL files shown in Figure 16-25.


<P><B>Figure 16-25.</b> <i>The DIBPAL files.</I>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="592"><h3>DIBPAL.H</h3></A>
<P><pre>
/*-----------------------------------
   DIBPAL.H header file for DIBPAL.C
  -----------------------------------*/

HPALETTE DibPalDibTable (HDIB hdib) ;
HPALETTE DibPalAllPurpose (void) ;
HPALETTE DibPalUniformGrays (int iNum) ;
HPALETTE DibPalUniformColors (int iNumR, int iNumG, int iNumB) ;
HPALETTE DibPalVga (void) ;
HPALETTE DibPalPopularity (HDIB hdib, int iRes) ;
HPALETTE DibPalMedianCut (HDIB hdib, int iRes) ;
</pre>
</td></tr></table>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="593"><h3>DIBPAL.C</h3></A>
<P><pre>
/*----------------------------------------
   DIBPAL.C -- Palette-Creation Functions
               (c) Charles Petzold, 1998
  ----------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;dibhelp.h&quot;
#include &quot;dibpal.h&quot;

/*------------------------------------------------------------
   DibPalDibTable: Creates a palette from the DIB color table
  ------------------------------------------------------------*/

HPALETTE DibPalDibTable (HDIB hdib)
{
     HPALETTE     hPalette ;
     int          i, iNum ;
     LOGPALETTE * plp ;
     RGBQUAD      rgb ;

     if (0 == (iNum = DibNumColors (hdib)))
          return NULL ;

     plp = malloc (sizeof (LOGPALETTE) + (iNum - 1) * sizeof (PALETTEENTRY)) ;

     plp-&gt;palVersion    = 0x0300 ;
     plp-&gt;palNumEntries = iNum ;

     for (i = 0 ; i &lt; iNum ; i++)
     {
          DibGetColor (hdib, i, &amp;rgb) ;

          plp-&gt;palPalEntry[i].peRed   = rgb.rgbRed ;
          plp-&gt;palPalEntry[i].peGreen = rgb.rgbGreen ;
          plp-&gt;palPalEntry[i].peBlue  = rgb.rgbBlue ;
          plp-&gt;palPalEntry[i].peFlags = 0 ;
     }
     hPalette = CreatePalette (plp) ;
     free (plp) ;
     return hPalette ;
}
/*------------------------------------------------------------------------
   DibPalAllPurpose: Creates a palette suitable for a wide variety
          of images; the palette has 247 entries, but 15 of them are 
          duplicates or match the standard 20 colors.
  ------------------------------------------------------------------------*/

HPALETTE DibPalAllPurpose (void)
{
     HPALETTE     hPalette ;
     int          i, incr, R, G, B ;
     LOGPALETTE * plp ;

     plp = malloc (sizeof (LOGPALETTE) + 246 * sizeof (PALETTEENTRY)) ;

     plp-&gt;palVersion    = 0x0300 ;
     plp-&gt;palNumEntries = 247 ;

          // The following loop calculates 31 gray shades, but 3 of them
          //        will match the standard 20 colors

     for (i = 0, G = 0, incr = 8 ; G &lt;= 0xFF ; i++, G += incr)
     {
          plp-&gt;palPalEntry[i].peRed   = (BYTE) G ;
          plp-&gt;palPalEntry[i].peGreen = (BYTE) G ;
          plp-&gt;palPalEntry[i].peBlue  = (BYTE) G ;
          plp-&gt;palPalEntry[i].peFlags = 0 ;

          incr = (incr == 9 ? 8 : 9) ;
     }

          // The following loop is responsible for 216 entries, but 8 of 
          //        them will match the standard 20 colors, and another
          //        4 of them will match the gray shades above.

     for (R = 0 ; R &lt;= 0xFF ; R += 0x33)
     for (G = 0 ; G &lt;= 0xFF ; G += 0x33)
     for (B = 0 ; B &lt;= 0xFF ; B += 0x33)
     {
          plp-&gt;palPalEntry[i].peRed   = (BYTE) R ;
          plp-&gt;palPalEntry[i].peGreen = (BYTE) G ;
          plp-&gt;palPalEntry[i].peBlue  = (BYTE) B ;
          plp-&gt;palPalEntry[i].peFlags = 0 ;

          i++ ;
     }

     hPalette = CreatePalette (plp) ;

     free (plp) ;
     return hPalette ;
}

/*------------------------------------------------------------------------
   DibPalUniformGrays:  Creates a palette of iNum grays, uniformly spaced
  ------------------------------------------------------------------------*/

HPALETTE DibPalUniformGrays (int iNum)
{
     HPALETTE     hPalette ;
     int          i ;
     LOGPALETTE * plp ;

     plp = malloc (sizeof (LOGPALETTE) + (iNum - 1) * sizeof (PALETTEENTRY)) ;

     plp-&gt;palVersion    = 0x0300 ;
     plp-&gt;palNumEntries = iNum ;

     for (i = 0 ; i &lt; iNum ; i++)
     {
          plp-&gt;palPalEntry[i].peRed   =
          plp-&gt;palPalEntry[i].peGreen = 
          plp-&gt;palPalEntry[i].peBlue  = (BYTE) (i * 255 / (iNum - 1)) ;
          plp-&gt;palPalEntry[i].peFlags = 0 ;
     }
     hPalette = CreatePalette (plp) ;
     free (plp) ;
     return hPalette ;
}

/*------------------------------------------------------------------------
   DibPalUniformColors: Creates a palette of iNumR x iNumG x iNumB colors
  ------------------------------------------------------------------------*/

HPALETTE DibPalUniformColors (int iNumR, int iNumG, int iNumB)
{
     HPALETTE     hPalette ;
     int          i, iNum, R, G, B ;
     LOGPALETTE * plp ;

     iNum = iNumR * iNumG * iNumB ;

     plp = malloc (sizeof (LOGPALETTE) + (iNum - 1) * sizeof (PALETTEENTRY)) ;

     plp-&gt;palVersion    = 0x0300 ;
     plp-&gt;palNumEntries = iNumR * iNumG * iNumB ;

     i = 0 ;
     for (R = 0 ; R &lt; iNumR ; R++)
     for (G = 0 ; G &lt; iNumG ; G++)
     for (B = 0 ; B &lt; iNumB ; B++)
     {
          plp-&gt;palPalEntry[i].peRed   = (BYTE) (R * 255 / (iNumR - 1)) ;
          plp-&gt;palPalEntry[i].peGreen = (BYTE) (G * 255 / (iNumG - 1)) ;
          plp-&gt;palPalEntry[i].peBlue  = (BYTE) (B * 255 / (iNumB - 1)) ;
          plp-&gt;palPalEntry[i].peFlags = 0 ;

          i++ ;
     }
     hPalette = CreatePalette (plp) ;
     free (plp) ;
     return hPalette ;
}

/*---------------------------------------------------------------
   DibPalVga:  Creates a palette based on standard 16 VGA colors
  ---------------------------------------------------------------*/

HPALETTE DibPalVga (void)
{
     static RGBQUAD rgb [16] = { 0x00, 0x00, 0x00, 0x00,
                                 0x00, 0x00, 0x80, 0x00,
                                 0x00, 0x80, 0x00, 0x00,
                                 0x00, 0x80, 0x80, 0x00,
                                 0x80, 0x00, 0x00, 0x00,
                                 0x80, 0x00, 0x80, 0x00,
                                 0x80, 0x80, 0x00, 0x00,
                                 0x80, 0x80, 0x80, 0x00,
                                 0xC0, 0xC0, 0xC0, 0x00,
                                 0x00, 0x00, 0xFF, 0x00,
                                 0x00, 0xFF, 0x00, 0x00,
                                 0x00, 0xFF, 0xFF, 0x00,
                                 0xFF, 0x00, 0x00, 0x00,
                                 0xFF, 0x00, 0xFF, 0x00,
                                 0xFF, 0xFF, 0x00, 0x00,
                                 0xFF, 0xFF, 0xFF, 0x00 } ;
     HPALETTE       hPalette ;
     int            i ;
     LOGPALETTE   * plp ;

     plp = malloc (sizeof (LOGPALETTE) + 15 * sizeof (PALETTEENTRY)) ;
     plp-&gt;palVersion    = 0x0300 ;
     plp-&gt;palNumEntries = 16 ;

     for (i = 0 ; i &lt; 16 ; i++)
     {
          plp-&gt;palPalEntry[i].peRed   = rgb[i].rgbRed ;
          plp-&gt;palPalEntry[i].peGreen = rgb[i].rgbGreen ;
          plp-&gt;palPalEntry[i].peBlue  = rgb[i].rgbBlue ;
          plp-&gt;palPalEntry[i].peFlags = 0 ;
     }
     hPalette = CreatePalette (plp) ;
     free (plp) ;
     return hPalette ;
}

/*---------------------------------------------
   Macro used in palette optimization routines
  ---------------------------------------------*/

#define PACK_RGB(R,G,B,iRes) ((int) (R) | ((int) (G) &lt;&lt;  (iRes)) |       \
                                          ((int) (B) &lt;&lt; ((iRes) + (iRes))))

/*--------------------------------------------------------------------
   AccumColorCounts: Fills up piCount (indexed by a packed RGB color)
     with counts of pixels of that color.
  --------------------------------------------------------------------*/

static void AccumColorCounts (HDIB hdib, int * piCount, int iRes)
{
     int     x, y, cx, cy ;
     RGBQUAD rgb ;

     cx = DibWidth (hdib) ;
     cy = DibHeight (hdib) ;

     for (y = 0 ; y &lt; cy ; y++)
     for (x = 0 ; x &lt; cx ; x++)
     {
          DibGetPixelColor (hdib, x, y, &amp;rgb) ;

          rgb.rgbRed   &gt;&gt;= (8 - iRes) ;
          rgb.rgbGreen &gt;&gt;= (8 - iRes) ;
          rgb.rgbBlue  &gt;&gt;= (8 - iRes) ;

          ++piCount [PACK_RGB (rgb.rgbRed, rgb.rgbGreen, rgb.rgbBlue, iRes)] ;
     }
}

/*--------------------------------------------------------------
   DibPalPopularity:  Popularity algorithm for optimized colors
  --------------------------------------------------------------*/

HPALETTE DibPalPopularity (HDIB hdib, int iRes)
{
     HPALETTE     hPalette ;
     int          i, iArraySize, iEntry, iCount, iIndex, iMask, R, G, B ;
     int        * piCount ;
     LOGPALETTE * plp ;

          // Validity checks
    
     if (DibBitCount (hdib) &lt; 16)
          return NULL ;

     if (iRes &lt; 3 || iRes &gt; 8)
          return NULL ;

          // Allocate array for counting pixel colors

     iArraySize = 1 &lt;&lt; (3 * iRes) ;
     iMask = (1 &lt;&lt; iRes) - 1 ;

     if (NULL == (piCount = calloc (iArraySize, sizeof (int))))
          return NULL ;

          // Get the color counts

     AccumColorCounts (hdib, piCount, iRes) ;

          // Set up a palette

     plp = malloc (sizeof (LOGPALETTE) + 235 * sizeof (PALETTEENTRY)) ;

     plp-&gt;palVersion = 0x0300 ;

     for (iEntry = 0 ; iEntry &lt; 236 ; iEntry++)
     {
          for (i = 0, iCount = 0 ; i &lt; iArraySize ; i++)
               if (piCount[i] &gt; iCount

               {
                    iCount = piCount[i] ;
                    iIndex = i ;
               }

          if (iCount == 0)
               break ;

          R = (iMask &amp;  iIndex                  ) &lt;&lt; (8 - iRes) ;
          G = (iMask &amp; (iIndex &gt;&gt;         iRes )) &lt;&lt; (8 - iRes) ;
          B = (iMask &amp; (iIndex &gt;&gt; (iRes + iRes))) &lt;&lt; (8 - iRes) ;

          plp-&gt;palPalEntry[iEntry].peRed   = (BYTE) R ; 
          plp-&gt;palPalEntry[iEntry].peGreen = (BYTE) G ; 
          plp-&gt;palPalEntry[iEntry].peBlue  = (BYTE) B ; 
          plp-&gt;palPalEntry[iEntry].peFlags = 0 ;

          piCount [iIndex] = 0 ;
     }
          // On exit from the loop iEntry will be the number of stored entries

     plp-&gt;palNumEntries = iEntry ;

          // Create the palette, clean up, and return the palette handle

     hPalette = CreatePalette (plp) ;

     free (piCount) ;
     free (plp) ;

     return hPalette ;
}

/*-------------------------------------------------------
   Structures used for implementing median cut algorithm
  -------------------------------------------------------*/

typedef struct           // defines dimension of a box
{
     int Rmin, Rmax, Gmin, Gmax, Bmin, Bmax ;
}
MINMAX ;

typedef struct           // for Compare routine for qsort
{
     int     iBoxCount ;
     RGBQUAD rgbBoxAv ;
}

BOXES ;
/*----------------------------
   FindAverageColor: In a box
  ----------------------------*/

static int FindAverageColor (int * piCount, MINMAX mm, 
                             int iRes, RGBQUAD * prgb)
{
     int R, G, B, iR, iG, iB, iTotal, iCount ;

          // Initialize some variables

     iTotal = iR = iG = iB = 0 ;
          
          // Loop through all colors in the box
          
     for (R = mm.Rmin ; R &lt;= mm.Rmax ; R++)
     for (G = mm.Gmin ; G &lt;= mm.Gmax ; G++)
     for (B = mm.Bmin ; B &lt;= mm.Bmax ; B++)
     {
               // Get the number of pixels of that color

          iCount = piCount [PACK_RGB (R, G, B, iRes)] ;

               // Weight the pixel count by the color value

          iR += iCount * R ;
          iG += iCount * G ;
          iB += iCount * B ;

          iTotal += iCount ;
     }
          // Find the average color

     prgb-&gt;rgbRed   = (BYTE) ((iR / iTotal) &lt;&lt; (8 - iRes)) ;
     prgb-&gt;rgbGreen = (BYTE) ((iG / iTotal) &lt;&lt; (8 - iRes)) ;
     prgb-&gt;rgbBlue  = (BYTE) ((iB / iTotal) &lt;&lt; (8 - iRes)) ;

          // Return the total number of pixels in the box
     
     return iTotal ;
}

/*------------------------------
   CutBox:  Divide a box in two
  ------------------------------*/

static void CutBox (int * piCount, int iBoxCount, MINMAX mm,
                    int iRes, int iLevel, BOXES * pboxes, int * piEntry)
{
     int    iCount, R, G, B ;
     MINMAX mmNew ;
     
          // If the box is empty, return 

     if (iBoxCount == 0)
          return ;

          // If the nesting level is 8, or the box is one pixel, we're ready
          //   to find the average color in the box and save it along with
          //   the number of pixels of that color

     if (iLevel == 8 || (mm.Rmin == mm.Rmax &amp;&amp; 
                         mm.Gmin == mm.Gmax &amp;&amp; 
                         mm.Bmin == mm.Bmax))
     {
          pboxes[*piEntry].iBoxCount = 
               FindAverageColor (piCount, mm, iRes, &amp;pboxes[*piEntry].rgbBoxAv) ;

          (*piEntry) ++ ;
     }
          // Otherwise, if blue is the largest side, split it

     else if ((mm.Bmax - mm.Bmin &gt; mm.Rmax - mm.Rmin) &amp;&amp; 
              (mm.Bmax - mm.Bmin &gt; mm.Gmax - mm.Gmin))
     {
               // Initialize a counter and loop through the blue side

          iCount = 0 ;

          for (B = mm.Bmin ; B &lt; mm.Bmax ; B++)
          {
                    // Accumulate all the pixels for each successive blue value

               for (R = mm.Rmin ; R &lt;= mm.Rmax ; R++)
               for (G = mm.Gmin ; G &lt;= mm.Gmax ; G++)
                    iCount += piCount [PACK_RGB (R, G, B, iRes)] ;

                    // If it's more than half the box count, we're there

               if (iCount &gt;= iBoxCount / 2)
                    break ;

                    // If the next blue value will be the max, we're there
               if (B == mm.Bmax - 1)
                    break ;
          }
               // Cut the two split boxes.
               //   The second argument to CutBox is the new box count.
               //   The third argument is the new min and max values.

          mmNew = mm ;
          mmNew.Bmin = mm.Bmin ;
          mmNew.Bmax = B ;

          CutBox (piCount, iCount, mmNew, iRes, iLevel + 1, 
                  pboxes, piEntry) ;

          mmNew.Bmin = B + 1 ;
          mmNew.Bmax = mm.Bmax ;

          CutBox (piCount, iBoxCount - iCount, mmNew, iRes, iLevel + 1,
                  pboxes, piEntry) ;
     }
          // Otherwise, if red is the largest side, split it (just like blue)

     else if (mm.Rmax - mm.Rmin &gt; mm.Gmax - mm.Gmin)
     {
          iCount = 0 ;

          for (R = mm.Rmin ; R &lt; mm.Rmax ; R++)
          {
               for (B = mm.Bmin ; B &lt;= mm.Bmax ; B++)
               for (G = mm.Gmin ; G &lt;= mm.Gmax ; G++)
                    iCount += piCount [PACK_RGB (R, G, B, iRes)] ;

               if (iCount &gt;= iBoxCount / 2)
                    break ;

               if (R == mm.Rmax - 1)
                    break ;
          }
          mmNew = mm ;
          mmNew.Rmin = mm.Rmin ;
          mmNew.Rmax = R ;

          CutBox (piCount, iCount, mmNew, iRes, iLevel + 1, 
                  pboxes, piEntry) ;

          mmNew.Rmin = R + 1 ;
          mmNew.Rmax = mm.Rmax ;

          CutBox (piCount, iBoxCount - iCount, mmNew, iRes, iLevel + 1,
                  pboxes, piEntry) ;
     }
          // Otherwise, split along the green size
     else 
     {
          iCount = 0 ;

          for (G = mm.Gmin ; G &lt; mm.Gmax ; G++)
          {
               for (B = mm.Bmin ; B &lt;= mm.Bmax ; B++)
               for (R = mm.Rmin ; R &lt;= mm.Rmax ; R++)
                    iCount += piCount [PACK_RGB (R, G, B, iRes)] ;

               if (iCount &gt;= iBoxCount / 2)
                    break ;

               if (G == mm.Gmax - 1)
                    break ;
          }
          mmNew = mm ;
          mmNew.Gmin = mm.Gmin ;
          mmNew.Gmax = G ;

          CutBox (piCount, iCount, mmNew, iRes, iLevel + 1, 
                  pboxes, piEntry) ;

          mmNew.Gmin = G + 1 ;
          mmNew.Gmax = mm.Gmax ;

          CutBox (piCount, iBoxCount - iCount, mmNew, iRes, iLevel + 1,
                  pboxes, piEntry) ;
     }
}

/*---------------------------
   Compare routine for qsort
  ---------------------------*/

static int Compare (const BOXES * pbox1, const BOXES * pbox2)
{
     return pbox1-&gt;iBoxCount - pbox2-&gt;iBoxCount ;
}

/*-----------------------------------------------------------------
   DibPalMedianCut:  Creates palette based on median cut algorithm
  -----------------------------------------------------------------*/
HPALETTE DibPalMedianCut (HDIB hdib, int iRes)
{
     BOXES        boxes [256] ;
     HPALETTE     hPalette ;
     int          i, iArraySize, iCount, R, G, B, iTotCount, iDim, iEntry = 0 ;
     int        * piCount ;
     LOGPALETTE * plp ;
     MINMAX       mm ;

          // Validity checks
    
     if (DibBitCount (hdib) &lt; 16)
          return NULL ;

     if (iRes &lt; 3 || iRes &gt; 8)
          return NULL ;

          // Accumulate counts of pixel colors

     iArraySize = 1 &lt;&lt; (3 * iRes) ;

     if (NULL == (piCount = calloc (iArraySize, sizeof (int))))
          return NULL ;

     AccumColorCounts (hdib, piCount, iRes) ;

          // Find the dimensions of the total box

     iDim = 1 &lt;&lt; iRes ;

     mm.Rmin = mm.Gmin = mm.Bmin = iDim - 1 ;
     mm.Rmax = mm.Gmax = mm.Bmax = 0 ;

     iTotCount = 0 ;

     for (R = 0 ; R &lt; iDim ; R++)
     for (G = 0 ; G &lt; iDim ; G++)
     for (B = 0 ; B &lt; iDim ; B++)
          if ((iCount = piCount [PACK_RGB (R, G, B, iRes)]) &gt; 0)
          {
               iTotCount += iCount ;

               if (R &lt; mm.Rmin) mm.Rmin = R ;
               if (G &lt; mm.Gmin) mm.Gmin = G ;
               if (B &lt; mm.Bmin) mm.Bmin = B ;
               if (R &gt; mm.Rmax) mm.Rmax = R ;
               if (G &gt; mm.Gmax) mm.Gmax = G ;
               if (B &gt; mm.Bmax) mm.Bmax = B ;
          }

          // Cut the first box (iterative function).
          //   On return, the boxes structure will have up to 256 RGB values, 
          //        one for each of the boxes, and the number of pixels in
          //        each box.
          //   The iEntry value will indicate the number of non-empty boxes.

     CutBox (piCount, iTotCount, mm, iRes, 0, boxes, &amp;iEntry) ;
     free (piCount) ;

          // Sort the RGB table by the number of pixels for each color

     qsort (boxes, iEntry, sizeof (BOXES), Compare) ;

     plp = malloc (sizeof (LOGPALETTE) + (iEntry - 1) * sizeof (PALETTEENTRY)) ;

     if (plp == NULL)
          return NULL ;

     plp-&gt;palVersion    = 0x0300 ;
     plp-&gt;palNumEntries = iEntry ;

     for (i = 0 ; i &lt; iEntry ; i++)
     {
          plp-&gt;palPalEntry[i].peRed   = boxes[i].rgbBoxAv.rgbRed ;
          plp-&gt;palPalEntry[i].peGreen = boxes[i].rgbBoxAv.rgbGreen ;
          plp-&gt;palPalEntry[i].peBlue  = boxes[i].rgbBoxAv.rgbBlue ;
          plp-&gt;palPalEntry[i].peFlags = 0 ;
     }

     hPalette = CreatePalette (plp) ;

     free (plp) ;
     return hPalette ;
}
</pre>
</td></tr></table>



<P>The first function&#8212;<I>DibPalDibTable&#8212;</I>should look familiar. It creates a palette from the DIB's color table. This is quite similar to the <I>PackedDibCreatePalette</I> function from PACKEDIB.C that was put to use in the SHOWDIB3 program earlier in the chapter. As in SHOWDIB3, this function will work only if the DIB has a color table. It is not useful when attempting to display a 16-bit, 24-bit, or 32-bit DIB under an 8-bit video mode.

<P>By default, when running on 256-color displays, DIBBLE will first try to call <I>DibPalDibTable</I> to create the palette from the DIB color table. If the DIB doesn't have the color table, DIBBLE will call <I>CreateHalftonePalette</I> and set the <I>fHalftonePalette</I> variable to TRUE. All of this logic occurs during the WM_USER_CREATEPAL message.

<P>DIBPAL.C also implements a function named <I>DibPalAllPurpose</I>, which should also look familiar because it is quite similar to the <I>CreateAllPurposePalette</I> function in SHOWDIB4. You can also select this palette from DIBBLE's menu.

<P>One of the interesting aspects about displaying bitmaps in 256-color modes is that you can control exactly what colors Windows uses for displaying the image. If you select and realize a palette, Windows will use the colors in the palette and no others.

<P>For example, you can create a palette solely with shades of gray by using the <I>DibPalUniformGrays</I> function. Using two shades of gray gives you a palette with just 00-00-00 (black) and FF-FF-FF (white). Try this out with some images you have: it provides a high-contrast &quot;chalk and charcoal&quot; effect popular with some photographers. Using 3 shades of gray adds a medium gray to black and white, and using 4 shades of gray adds 2 gray shades.

<P>With 8 shades of gray you will probably see obvious contouring&#8212;irregular patches of the same gray shade where the nearest-color algorithm is obviously working but certainly not with any aesthetic judgment. Moving to 16 gray shades generally improves the image dramatically. The use of 32 gray shades just about eliminates any contouring; 64 gray shades is commonly considered the limit of most display equipment in use today. After this point, the improvements are marginal if evident at all. Going beyond 64 gray shades provides no improvement on devices with a 6-bit color resolution.

<P>So far, the best we've been able to do for displaying 16-bit, 24-bit, or 32-bit color DIBs under 8-bit video modes is to devise an all-purpose palette (trivial for gray-shade images but usually inadequate for color images) or use the halftone palette, which combines an all-purpose color palette with a dithered display.

<P>You'll also notice that when you select an all-purpose palette for a large 16-bit, 24-bit, or 32-bit DIB in an 8-bit color mode, it takes some time for the program to create the GDI bitmap object from the DIB for display purposes. Less time is required when the program creates a DDB from the DIB when no palette is used. (You can also see this difference when comparing the performance of SHOWDIB1 and SHOWDIB4 in displaying large 24-bit DIBs in an 8-bit color mode.) Why is this?

<P>It's the nearest-color search. Normally, when displaying a 24-bit DIB in an 8-bit video mode (or converting a DIB to a DDB), GDI must match each and every pixel in the DIB to one of the static 20 colors. The only way it can do this is by determining which static color is closest to the pixel color. This involves calculating a distance between the pixel and each static color in a three-dimensional RGB color cube. This takes time, particularly when there may be millions of pixels in the DIB image.

<P>When you create a 232-color palette such as the all-purpose palette in DIBBLE and SHOWDIB4, you are effectively increasing the time required for the nearest-color search by more than 11-times! GDI must now search through 232 colors rather than just 20. That's why the whole job of displaying the DIB is slowing down.

<P>The lesson here is to avoid displaying 24-bit (or 16-bit or 32-bit) DIBs in 8-bit video modes. You should convert them to 8-bit DIBs by finding a palette of 256 colors that most closely approximates the range of colors in the DIB image. This is often referred to as an &quot;optimal palette.&quot; A paper by Paul Heckbert entitled &quot;Color Image Quantization for Frame Buffer Displays&quot; that appeared in the July 1982 issue of <I>Computer Graphics</I> was helpful when I was researching this problem.

<A NAME="594"><h3>The Uniform Distribution</h3></A>
<P>The simplest approach to a 256-color palette is choosing a uniform range of RGB color values, similar to the approach in <I>DibPalAllPurpose</I>. The advantage is that you don't need to examine the actual pixels in the DIB. Such a function to create a palette based on uniform ranges of RGB primaries is <I>DibPalCreateUniformColors</I>.

<P>One reasonable distribution involves 8 levels of red and green and 4 levels of blue (to which the eye is less sensitive). The palette is the set of RGB color values with all the possible combinations of red and green values of 0x00, 0x24, 0x49, 0x6D, 0x92, 0xB6, 0xDB, and 0xFF, and blue values of 0x00, 0x55, 0xAA, and 0xFF, for a total of 256 colors. Another possible uniformly distributed palette uses 6 levels of red, green, and blue. This is a palette of all possible combinations of red, green, and blue values of 0x00, 0x33, 0x66, 0x99, 0xCC, and 0xFF. The number of colors in the palette is 6 to the 3rd power, or 216.

<P>These two options and several others are provided by DIBBLE.

<A NAME="595"><h3>The &quot;Popularity&quot; Algorithm</h3></A>
<P>The &quot;popularity&quot; algorithm is a fairly obvious solution to the 256-color palette problem. What you do is plow through all the pixels of the bitmap and find the 256 most common RGB color values. These are the values you use in the palette. This is implemented in DIBPAL's <I>DibPalPopularity</I> function.

<P>However, if you use a whole 24 bits for each color, and if you assume that you'll need integers to count all the colors, your array will occupy 64 megabytes of memory. Moreover, you may find that there are actually no (or few) duplicated 24-bit pixel values in the bitmap and, thus, no most common colors.

<P>To solve this problem, you can use only the most significant <I>n</I> bits of each red, green, and blue value&#8212;for example, 6 bits rather than 8. This makes sense because most color scanners and video display adapters have only a 6-bit resolution. This reduces the array to a more reasonable size of 256-KB count values, or 1 megabyte. Using only 5 bits reduces the total number of possible colors to 32,768. The use of 5 bits usually works better than 6 bits, as you can verify for yourself using DIBBLE and some color images you have.

<A NAME="596"><h3>The &quot;Median Cut&quot; Algorithm</h3></A>
<P>The <I>DibPalMedianCut</I> function in DIBPAL.C implements Paul Heckbert's &quot;median cut&quot; algorithm. It's conceptually quite simple and, while the implementation in code is more difficult than the popularity algorithm, it is well-suited to recursive functions.

<P>Picture the RGB color cube. Each pixel of the image is a point within this cube. Some points might represent multiple pixels in the image. Find the three-dimensional box that encloses all the pixels in the image. Find the longest dimension of this box and cut the box in two parts, each containing an equal number of pixels. For these 2 boxes, do the same thing. Now you have 4 boxes. Cut the 4 boxes into 8, and then into 16, and then 32, 64, 128, and 256.

<P>Now you have 256 boxes, each containing about an equal number of pixels. Average the RGB color values of the pixels in each box, and use the results for the palette.

<P>In reality, the boxes don't usually contain an equal number of pixels. Often, for example, a box containing a single point has many pixels. This happens with black and white. Sometimes a box ends up with no pixels at all. If so, you can chop up more boxes, but I decided not to.

<P>Another optimum palette technique is called &quot;octree quantization.&quot; This technique was discussed by Jeff Prosise in the August 1996 issue of <I>Microsoft Systems Journal</I> (included on the MSDN CDs).

<A NAME="597"><h2>Converting Formats</h2></A>
<P>DIBBLE also allows converting a DIB from one format to another. This makes use of the <I>DibConvert</I> function in the DIBCONV files shown in Figure 16-26.



<P><B>Figure 16-26.</b> <i>The DIBCONV files.</I>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="598"><h3>DIBCONV.H</h3></A>
<P><pre>


/*-------------------------------------
   DIBCONV.H header file for DIBCONV.C
  -------------------------------------*/

HDIB DibConvert (HDIB hdibSrc, int iBitCountDst) ;
</pre>
</td></tr></table>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="599"><h3>DIBCONV.C</h3></A>
<P><pre>
/*-------------------------------------------------------
   DIBCONV.C -- Converts DIBs from one format to another
                (c) Charles Petzold, 1998
  -------------------------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;dibhelp.h&quot;
#include &quot;dibpal.h&quot;
#include &quot;dibconv.h&quot;

HDIB DibConvert (HDIB hdibSrc, int iBitCountDst)
{
     HDIB         hdibDst ;
     HPALETTE     hPalette ;
     int          i, x, y, cx, cy, iBitCountSrc, cColors ;
     PALETTEENTRY pe ;
     RGBQUAD      rgb ;
     WORD         wNumEntries ;

     cx = DibWidth (hdibSrc) ;
     cy = DibHeight (hdibSrc) ;
     iBitCountSrc = DibBitCount (hdibSrc) ;

     if (iBitCountSrc == iBitCountDst)
          return NULL ;

          // DIB with color table to DIB with larger color table:

     if ((iBitCountSrc &lt; iBitCountDst) &amp;&amp; (iBitCountDst &lt;= 8))
     {
          cColors = DibNumColors (hdibSrc) ;
          hdibDst = DibCreate (cx, cy, iBitCountDst, cColors) ;

          for (i = 0 ; i &lt; cColors ; i++)
          {
               DibGetColor (hdibSrc, i, &amp;rgb) ;
               DibSetColor (hdibDst, i, &amp;rgb) ;
          }

          for (x = 0 ; x &lt; cx ; x++)
          for (y = 0 ; y &lt; cy ; y++)
          {
               DibSetPixel (hdibDst, x, y, DibGetPixel (hdibSrc, x, y)) ;
          }
     }
          // Any DIB to DIB with no color table

     else if (iBitCountDst &gt;= 16)
     {
          hdibDst = DibCreate (cx, cy, iBitCountDst, 0) ;

          for (x = 0 ; x &lt; cx ; x++)
          for (y = 0 ; y &lt; cy ; y++)
          {
               DibGetPixelColor (hdibSrc, x, y, &amp;rgb) ;
               DibSetPixelColor (hdibDst, x, y, &amp;rgb) ;
          }
     }
          // DIB with no color table to 8-bit DIB

     else if (iBitCountSrc &gt;= 16 &amp;&amp; iBitCountDst == 8)
     {
          hPalette = DibPalMedianCut (hdibSrc, 6) ;

          GetObject (hPalette, sizeof (WORD), &amp;wNumEntries) ;

          hdibDst = DibCreate (cx, cy, 8, wNumEntries) ;
          
          for (i = 0 ; i &lt; (int) wNumEntries ; i++)
          {
               GetPaletteEntries (hPalette, i, 1, &amp;pe) ;
               rgb.rgbRed   = pe.peRed ;
               rgb.rgbGreen = pe.peGreen ;
               rgb.rgbBlue  = pe.peBlue ;
               rgb.rgbReserved = 0 ;

               DibSetColor (hdibDst, i, &amp;rgb) ;
          }

          for (x = 0 ; x &lt; cx ; x++)
          for (y = 0 ; y &lt; cy ; y++)
          {
               DibGetPixelColor (hdibSrc, x, y, &amp;rgb) ;

               DibSetPixel (hdibDst, x, y,
                    GetNearestPaletteIndex (hPalette, 
                         RGB (rgb.rgbRed, rgb.rgbGreen, rgb.rgbBlue))) ;
          }
          DeleteObject (hPalette) ;
     }
          // Any DIB to monochrome DIB

     else if (iBitCountDst == 1)
     {
          hdibDst = DibCreate (cx, cy, 1, 0) ;
          hPalette = DibPalUniformGrays (2) ;

          for (i = 0 ; i &lt; 2 ; i++)
          {
               GetPaletteEntries (hPalette, i, 1, &amp;pe) ;

               rgb.rgbRed   = pe.peRed ;
               rgb.rgbGreen = pe.peGreen ;
               rgb.rgbBlue  = pe.peBlue ;
               rgb.rgbReserved = 0 ;

               DibSetColor (hdibDst, i, &amp;rgb) ;
          }

          for (x = 0 ; x &lt; cx ; x++)
          for (y = 0 ; y &lt; cy ; y++)
          {
               DibGetPixelColor (hdibSrc, x, y, &amp;rgb) ;

               DibSetPixel (hdibDst, x, y,
                    GetNearestPaletteIndex (hPalette, 
                         RGB (rgb.rgbRed, rgb.rgbGreen, rgb.rgbBlue))) ;
          }
          DeleteObject (hPalette) ;
     }
          // All non-monochrome DIBs to 4-bit DIB

     else if (iBitCountSrc &gt;= 8 &amp;&amp; iBitCountDst == 4)
     {
          hdibDst = DibCreate (cx, cy, 4, 0) ;
          hPalette = DibPalVga () ;

          for (i = 0 ; i &lt; 16 ; i++)
          {
               GetPaletteEntries (hPalette, i, 1, &amp;pe) ;

               rgb.rgbRed   = pe.peRed ;
               rgb.rgbGreen = pe.peGreen ;
               rgb.rgbBlue  = pe.peBlue ;
               rgb.rgbReserved = 0 ;

               DibSetColor (hdibDst, i, &amp;rgb) ;
          }

          for (x = 0 ; x &lt; cx ; x++)
          for (y = 0 ; y &lt; cy ; y++)
          {
               DibGetPixelColor (hdibSrc, x, y, &amp;rgb) ;

               DibSetPixel (hdibDst, x, y,
                    GetNearestPaletteIndex (hPalette, 
                         RGB (rgb.rgbRed, rgb.rgbGreen, rgb.rgbBlue))) ;
          }
          DeleteObject (hPalette) ;
     }
          // Should not be necessary

     else
          hdibDst = NULL ;

     return hdibDst ;
}
</pre>
</td></tr></table>

<P>Several different strategies are required for converting DIBs from one format to another.

<P>To convert a DIB with a color table to another DIB that also has a color table but with a larger pixel width (that is, to convert a 1-bit DIB to a 4-bit or 8-bit DIB, or a 4-bit DIB to an 8-bit DIB), all that needs be done is to create the new DIB by calling <I>DibCreate</I> with the desired bit count but with a number of colors equal to the number of colors in the original DIB. The function then copies the pixel bits and the color table entries.

<P>If the new DIB has no color table (that is, the bit count is 16, 24, or 32), then the DIB needs only to be created in the new format and pixel bits copied from the existing DIB with calls to <I>DibGetPixelColor</I> and <I>DibSetPixelColor</I>.

<P>The next case is probably the most common: The existing DIB does not have a color table (that is, the bit count is 16, 24, or 32) and the new DIB has 8 bits per pixel. In this case, <I>DibConvert</I> calls <I>DibPalMedianCut</I> to create a optimum palette for the image. The color table of the new DIB is set to the RGB values in the palette. The <I>DibGetPixelColor</I> function obtains a pixel color from the existing DIB. This is converted to a pixel value in the 8-bit DIB by a call to <I>GetNearestPaletteIndex</I> and the pixel value is stored in the DIB by calling <I>DibSetPixel</I>.

<P>When a DIB needs to be converted to a monochrome DIB, the new DIB is created with a color table containing two entries&#8212;black and white. Again, the <I>GetNearestPaletteIndex</I> helps convert colors in the existing DIB to a pixel value of 0 or 1. Similarly, when DIBs of 8 color bits or more need to be converted to 4-bit DIBs, the DIB color table is obtained from the <I>DibPalVga</I> function and <I>GetNearestPaletteIndex</I> also helps calculate the pixel values.

<P>Although DIBBLE shows the basics of how an image-processing program might be started, such a program is never quite finished. Always another feature becomes obvious. But now, sadly, we must move on.

</BODY>
</HTML>






