<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>The Edit Class</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="261"><h1>The Edit Class</h1></A>
<p>The edit class is in some ways the simplest predefined window class and in other ways the most complex. When you create a child window using the class name &quot;edit,&quot; you define a rectangle based on the <I>x</I> position, <I>y</I> position, width, and height parameters of the <I>CreateWindow</I> call. This rectangle contains editable text. When the child window control has the input focus, you can type text, move the cursor, select portions of text using either the mouse or the Shift key and a cursor key, delete selected text to the clipboard by pressing Ctrl-X, copy text by pressing Ctrl-C, and insert text from the clipboard by pressing Ctrl-V.

<p>One of the simplest uses of edit controls is for single-line entry fields. But edit controls are not limited to single lines, as I'll demonstrate in the POPPAD1 program shown in Figure 9-7. As we encounter various other topics in this book, the POPPAD program will be enhanced to use menus, dialog boxes (to load and save files), and printing. The final version will be a simple but complete text editor with surprisingly little overhead required in our code.

<p><B>Figure 9-7.</B> <I>The POPPAD1 program.</I>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="262"><H3>POPPAD1.C</h3></A>
<p><pre>
/*----------------------------------------
   POPPAD1.C -- Popup Editor using child window edit box
                (c) Charles Petzold, 1998
  ----------------------------------------*/

#include &lt;windows.h&gt;

#define ID_EDIT     1

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);

TCHAR szAppName[] = TEXT (&quot;PopPad1&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }

     hwnd = CreateWindow (szAppName, szAppName,
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ; 
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HWND hwndEdit ;
     
     switch (message)
     {
     case WM_CREATE :
          hwndEdit = CreateWindow (TEXT (&quot;edit&quot;), NULL,
                         WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL |
                                   WS_BORDER | ES_LEFT | ES_MULTILINE |
                                   ES_AUTOHSCROLL | ES_AUTOVSCROLL,
                         0, 0, 0, 0, hwnd, (HMENU) ID_EDIT,
                         ((LPCREATESTRUCT) lParam) -&gt; hInstance, NULL) ;
          return 0 ;
          
     case WM_SETFOCUS :
          SetFocus (hwndEdit) ;
          return 0 ;
          
     case WM_SIZE : 
          MoveWindow (hwndEdit, 0, 0, LOWORD (lParam), HIWORD (lParam), TRUE) ;
          return 0 ;
          
     case WM_COMMAND :
          if (LOWORD (wParam) == ID_EDIT)
               if (HIWORD (wParam) == EN_ERRSPACE || 
                         HIWORD (wParam) == EN_MAXTEXT)
                    MessageBox (hwnd, TEXT (&quot;Edit control out of space.&quot;),
                                szAppName, MB_OK | MB_ICONSTOP) ;
          return 0 ;
               
     case WM_DESTROY :
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</TD></TR></TABLE> 

<p>POPPAD1 is a multiline editor (without any file I/O just yet) in less than 100 lines of C. (One drawback, however, is that the predefined multiline edit control is limited to 30,000 characters of text.) As you can see, POPPAD1 itself doesn't do very much. The predefined edit control is doing quite a lot. In this form, the program lets you explore what edit controls can do without any help from a program.

<A NAME="263"><h2>The Edit Class Styles</h2></A>
<p>As noted earlier, you create an edit control using &quot;edit&quot; as the window class in the <I>CreateWindow</I> call. The window style is WS_CHILD, plus several options. As in static child window controls, the text in edit controls can be left-justified, right-justified, or centered. You specify this formatting with the window styles ES_LEFT, ES_RIGHT, and ES_CENTER.

<p>By default, an edit control has a single line. You can create a multiline edit control with the window style ES_MULTILINE. For a single-line edit control, you can normally enter text only to the end of the edit control rectangle. To create an edit control that automatically scrolls horizontally, you use the style ES_AUTOHSCROLL. For a multiline edit control, text wordwraps unless you use the ES_AUTOHSCROLL style, in which case you must press the Enter key to start a new line. You can also include vertical scrolling in a multiline edit control by using the style ES_AUTOVSCROLL.

<p>When you include these scrolling styles in multiline edit controls, you might also want to add scroll bars to the edit control. You do so by using the same window style identifiers as for nonchild windows: WS_HSCROLL and WS_VSCROLL. By default, an edit control does not have a border. You can add one by using the style WS_BORDER.

<p>When you select text in an edit control, Windows displays it in reverse video. When the edit control loses the input focus, however, the selected text is no longer highlighted. If you want the selection to be highlighted even when the edit control does not have the input focus, you can use the style ES_NOHIDESEL.

<p>When POPPAD1 creates its edit control, the style is given in the <I>CreateWindow</I> call:

<p><pre>
WS_CHILD &#166; WS_VISIBLE &#166; WS_HSCROLL &#166; WS_VSCROLL &#166;
     WS_BORDER &#166; ES_LEFT &#166; ES_MULTILINE &#166;
     ES_AUTOHSCROLL &#166; ES_AUTOVSCROLL
</PRE>

<p>In POPPAD1, the dimensions of the edit control are later defined by a call to <I>MoveWindow</I> when <I>WndProc</I> receives a WM_SIZE message. The size of the edit control is simply set to the size of the main window:

<p><pre>
MoveWindow (hwndEdit, 0, 0, LOWORD (lParam),
                            HIWORD (lParam), TRUE) ;
</PRE>

<p>For a single-line edit control, the height of the control must accommodate the height of a character. If the edit control has a border (as most do), use 1.5 times the height of a character (including external leading).

<A NAME="264"><h2>Edit Control Notification</h2></A>
<p>Edit controls send WM_COMMAND messages to the parent window procedure. The meanings of the <I>wParam</I> and <I>lParam</I> variables are the same as for button controls:

<P>
<table CELLPADDING="5" WIDTH="95%">
<tr><td VALIGN="top">LOWORD (<I>wParam</I>)</TD>
<td VALIGN="top">Child window ID</TD></tr>
<tr><td VALIGN="top">HIWORD (<I>wParam</I>)</TD>
<td VALIGN="top">Notification code</TD></tr>
<tr><td VALIGN="top"><I>lParam</I></TD>
<td VALIGN="top">Child window handle</TD></tr>
</TABLE>

<p>The notification codes are shown below:

<P>
<table CELLPADDING="5" WIDTH="95%">
<tr><td VALIGN="top">EN_SETFOCUS</TD>
<td VALIGN="top"><I>Edit control has gained the input focus.</I></TD></tr>
<tr><td VALIGN="top">EN_KILLFOCUS</TD>
<td VALIGN="top"><I>Edit control has lost the input focus.</I></TD></tr>
<tr><td VALIGN="top">EN_CHANGE</TD>
<td VALIGN="top"><I>Edit control's contents will change.</I></TD></tr>
<tr><td VALIGN="top">EN_UPDATE</TD>
<td VALIGN="top"><I>Edit control's contents have changed.</I></TD></tr>
<tr><td VALIGN="top">EN_ERRSPACE</TD>
<td VALIGN="top"><I>Edit control has run out of space.</I></TD></tr>
<tr><td VALIGN="top">EN_MAXTEXT</TD>
<td VALIGN="top"><I>Edit control has run out of space on insertion.</I></TD></tr>
<tr><td VALIGN="top">EN_HSCROLL</TD>
<td VALIGN="top"><I>Edit control's horizontal scroll bar has been clicked.</I></TD></tr>
<tr><td VALIGN="top">EN_VSCROLL</TD>
<td VALIGN="top"><I>Edit control's vertical scroll bar has been clicked.</I></TD></tr>
</TABLE>

<P>POPPAD1 traps only EN_ERRSPACE and EN_MAXTEXT notification codes and displays a message box in response.

<A NAME="265"><h2>Using the Edit Controls</h2></A>
<p>If you use several single-line edit controls on the surface of your main window, you'll need to use window subclassing to move the input focus from one control to another. You can accomplish this much as COLORS1 does, by intercepting Tab and Shift-Tab keystrokes. (Another example of window subclassing is shown later in this chapter in the HEAD program.) How you handle the Enter key is up to you. You can use it the same way as the Tab key or as a signal to your program that all the edit fields are ready.

<p>If you want to insert text into an edit field, you can do so by using <I>SetWindowText</I>. Getting text out of an edit control involves <I>GetWindowTextLength</I> and <I>GetWindowText</I>. We'll see examples of these facilities in our later revisions to the POPPAD program.

<A NAME="266"><h2>Messages to an Edit Control</h2></A>
<p>I won't cover all the messages you can send to an edit control using <I>SendMessage</I> because there are quite a few of them, and several will be used in the later POPPAD revisions. Here's a broad overview.

<p>These messages let you cut, copy, or clear the current selection. A user selects the text to be acted upon by using the mouse or the Shift key and a cursor key, thereby highlighting the selected text in the edit control:

<p><pre>
SendMessage (hwndEdit, WM_CUT, 0, 0) ;
SendMessage (hwndEdit, WM_COPY, 0, 0) ;
SendMessage (hwndEdit, WM_CLEAR, 0, 0) ;
</PRE>

<p>WM_CUT removes the current selection from the edit control and sends it to the clipboard. WM_COPY copies the selection to the clipboard but leaves it intact in the edit control. WM_CLEAR deletes the selection from the edit control without passing it to the clipboard.

<p>You can also insert clipboard text into the edit control at the cursor position:

<p><pre>
SendMessage (hwndEdit, WM_PASTE, 0, 0) ;
</PRE>

<p>You can obtain the starting and ending positions of the current selection:

<p><pre>
SendMessage (hwndEdit, EM_GETSEL, (WPARAM) &amp;iStart, 
                                  (LPARAM) &amp;iEnd) ;
</PRE>

<p>The ending position is actually the position of the last selected character plus 1.

<p>You can select text:

<p><pre>
SendMessage (hwndEdit, EM_SETSEL, iStart, iEnd) ;
</PRE>

<p>You can also replace a current selection with other text:

<p><pre>
SendMessage (hwndEdit, EM_REPLACESEL, 0, (LPARAM) szString) ;
</PRE>

<p>For multiline edit controls, you can obtain the number of lines:

<p><pre>
iCount = SendMessage (hwndEdit, EM_GETLINECOUNT, 0, 0) ;
</PRE>

<p>For any particular line, you can obtain an offset from the beginning of the 
edit buffer text:

<p><pre>
iOffset = SendMessage (hwndEdit, EM_LINEINDEX, iLine, 0) ;
</PRE>

<p>Lines are numbered starting at 0. An <I>iLine</I> value of -1 returns the offset of the line containing the cursor. You obtain the length of the line from

<p><pre>
iLength = SendMessage (hwndEdit, EM_LINELENGTH, iLine, 0) ;
</PRE>

<p>and copy the line itself into a buffer using

<p><pre>
iLength = SendMessage (hwndEdit, EM_GETLINE, iLine, (LPARAM) szBuffer) ;
</PRE>

</BODY>
</HTML>






