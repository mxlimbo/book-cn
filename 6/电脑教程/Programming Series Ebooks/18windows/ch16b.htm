<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Using Palettes</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="521"><h1>Using Palettes</h1></A>
<P>Traditionally, a palette is the board that a painter uses to mix colors. The word can also refer to the entire range of colors that an artist uses in creating a painting. In computer graphics, the palette is the range of colors available on a graphics output device such as a video display. The word can also refer to a lookup table on video boards that support 256-color modes.

<A NAME="522"><h2>Video Hardware</h2></A>
<P>The palette lookup table on video boards works something like this:

<P><A HREF="javascript:fullSize('F16zg01x.htm')"><IMG SRC="F16zg01.JPG" width=404 height=141 ALIGN="BOTTOM" BORDER=0 ALT="click here to view full size"></A>

<P>In 8-bit video modes, each pixel has 8 bits. The pixel value addresses a lookup table that contains 256 RGB values. These RGB values can be a full 24 bits wide or can be smaller, typically 18 bits wide (that is, 6 bits for each red, green, and blue primary). The values for each color are input to digital-to-analog converters for the three analog red, green, and blue signals that go to the monitor.

<P>The palette lookup table can generally be loaded with arbitrary values through software, but there are some obstacles for a device-independent windowing interface such as that in Microsoft Windows. First, Windows must provide a software interface so that applications can access the Palette Manager without directly fooling around with the hardware. The second problem is more serious: because all applications are sharing the same video display and running side by side, one application's use of the palette lookup table might interfere with another's.

<P>This is where the Windows Palette Manager (introduced in Windows 3.0) comes into play. Windows reserves 20 of the 256 colors for itself and lets applications change the other 236. (In certain cases, an application can change up to 254 of the 256 colors&#8212;all except black and white&#8212;but this is a bit of a chore.) The 20 colors that Windows reserves for system use, sometimes called the 20 <I>static</I> colors) are shown in Figure 16-1.




<P><table cellpadding=5 width="95%">

<tr><td valign="top"><B><I>Pixel Bits</I></B></td>
<td valign="top"><B><I>RGB Value</I></B></td>
<td valign="top"><B><I>Color Name</I></B></td>
<td valign="top"><B><I>Pixel Bits</I></B></td>
<td valign="top"><B><I>RGB Value</I></B></td>
<td valign="top"><B><I>Color Name</I></B></td></tr>

<tr><td valign="top">00000000</td>
<td valign="top">00 00 00</td>
<td valign="top">Black</td>
<td valign="top">11111111</td>
<td valign="top">FF FF FF</td>
<td valign="top">White</td></tr>

<tr><td valign="top">00000001</td>
<td valign="top">80 00 00</td>
<td valign="top">Dark Red</td>
<td valign="top">11111110</td>
<td valign="top">00 FF FF</td>
<td valign="top">Cyan</td></tr>

<tr><td valign="top">00000010</td>
<td valign="top">00 80 00</td>
<td valign="top">Dark Green</td>
<td valign="top">11111101</td>
<td valign="top">FF 00 FF</td>
<td valign="top">Magenta</td></tr>

<tr><td valign="top">00000011</td>
<td valign="top">80 80 00</td>
<td valign="top">Dark Yellow</td>
<td valign="top">11111100</td>
<td valign="top">00 00 FF</td>
<td valign="top">Blue</td></tr>

<tr><td valign="top">00000100</td>
<td valign="top">00 00 80</td>
<td valign="top">Dark Blue</td>
<td valign="top">11111011</td>
<td valign="top">FF FF 00</td>
<td valign="top">Yellow</td></tr>

<tr><td valign="top">00000101</td>
<td valign="top">80 00 80</td>
<td valign="top">Dark Magenta</td>
<td valign="top">11111010</td>
<td valign="top">00 FF 00</td>
<td valign="top">Green</td></tr>

<tr><td valign="top">00000110</td>
<td valign="top">00 80 80</td>
<td valign="top">Dark Cyan</td>
<td valign="top">11111001</td>
<td valign="top">FF 00 00</td>
<td valign="top">Red</td></tr>

<tr><td valign="top">00000111</td>
<td valign="top">C0 C0 C0</td>
<td valign="top">Light Gray</td>
<td valign="top">11111000</td>
<td valign="top">80 80 80</td>
<td valign="top">Dark Gray</td></tr>

<tr><td valign="top">00001000</td>
<td valign="top">C0 DC C0</td>
<td valign="top">Money Green</td>
<td valign="top">11110111</td>
<td valign="top">A0 A0 A4</td>
<td valign="top">Medium Gray</td></tr>

<tr><td valign="top">00001001</td>
<td valign="top">A6 CA F0</td>
<td valign="top">Sky Blue</td>
<td valign="top">11110110</td>
<td valign="top">FF FB F0</td>
<td valign="top">Cream</td></tr>

</table>
<P><B>Figure 16-1.</b> <i>The 20 reserved colors in 256-color video modes.</I>

<P>When running in 256-color video modes, Windows maintains a &quot;system palette,&quot; which is the same as the hardware palette lookup table on the video board. The default system palette is shown in Figure 16-1. Applications can change the other 236 colors by specifying &quot;logical palettes.&quot; If more than one application is using logical palettes, Windows gives highest priority to the active window. (As you know, the active window is the window that has the highlighted title bar and appears to the foreground of all the other windows.) We'll examine how this works in the context of a simple sample program.

<P>For running the programs shown in the remainder of this chapter, you may want to switch your video board into a 256-color mode. Right click the mouse on the desktop, pick Properties from the menu, and select the Settings tab.


<A NAME="523"><h2>Displaying Gray Shades</h2></A>
<P>The GRAYS1 program shown in Figure 16-2 does <I>not</I> use the Windows Palette Manager but instead tries to normally display 65 shades of gray as a &quot;fountain&quot; of color ranging black to white.


<P><B>Figure 16-2.</b> <i>The GRAYS1 program.</I>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="524"><h3>GRAYS1.C</h3></A>
<P><pre>
/*---------------------------------------
   GRAYS1.C -- Gray Shades
               (c) Charles Petzold, 1998
  ---------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;Grays1&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;

     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;

     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;), 
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Shades of Gray #1&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,             
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static int  cxClient, cyClient ;
     HBRUSH      hBrush ;
     HDC         hdc ;
     int         i ;
     PAINTSTRUCT ps ;
     RECT        rect ;
     
     switch (message)
     {
     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;
          
     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;

               // Draw the fountain of grays

          for (i = 0 ; i &lt; 65 ; i++)
          {
               rect.left   = i * cxClient / 65 ;
               rect.top    = 0 ;
               rect.right  = (i + 1) * cxClient / 65 ;
               rect.bottom = cyClient ;

               hBrush = CreateSolidBrush (RGB (min (255, 4 * i), 
                                               min (255, 4 * i), 
                                               min (255, 4 * i))) ;
               FillRect (hdc, &amp;rect, hBrush) ;
               DeleteObject (hBrush) ;
          }
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;

     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>



<P>During the WM_PAINT message, the program makes 65 calls to the <I>FillRect</I> function, each time with a brush created using a different gray shade. The gray shades are the RGB values (0, 0, 0), (4, 4, 4), (8, 8, 8), and so forth, until the last one, which is (255, 255, 255). That last one is the reason for the <I>min</I> macro in the <I>CreateSolidBrush</I> function.

<P>If you run this program in a 256-color video mode, you'll see 65 shades of gray from black to white, but almost all of them are rendered using dithering. The only pure colors are black, dark gray (128, 128, 128), light gray (192, 192, 192), and white. The other colors are various bit patterns combining these pure colors. If we were displaying lines or text rather than filled areas using these 65 gray shades, Windows would not use dithering and would use only the four pure colors. If we were displaying a bitmap, the image would be approximated using the 20 standard Windows colors, as you can see for yourself by running one of the programs from the last chapter and loading in a color or gray-shade DIB. Windows normally does not use dithering for bitmaps.


<P>The GRAYS2 program shown in Figure 16-3 demonstrates the most important Palette Manager functions and messages with little extraneous code.



<P><B>Figure 16-3.</b> <i>The GRAYS2 program.</I>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="525"><h3>GRAYS2.C</h3></A>
<P><pre>
/*-----------------------------------------------
   GRAYS2.C -- Gray Shades Using Palette Manager
               (c) Charles Petzold, 1998
  -----------------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;Grays2&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;

     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;

     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;), 
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Shades of Gray #2&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,             
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HPALETTE hPalette ;
     static int      cxClient, cyClient ;
     HBRUSH          hBrush ;
     HDC             hdc ;
     int             i ;
     LOGPALETTE    * plp ;
     PAINTSTRUCT     ps ;
     RECT            rect ;
     
     switch (message)
     {
     case WM_CREATE:
               // Set up a LOGPALETTE structure and create a palette

          plp = malloc (sizeof (LOGPALETTE) + 64 * sizeof (PALETTEENTRY)) ;

          plp-&gt;palVersion    = 0x0300 ;
          plp-&gt;palNumEntries = 65 ;

          for (i = 0 ; i &lt; 65 ; i++)
          {
               plp-&gt;palPalEntry[i].peRed   = (BYTE) min (255, 4 * i) ;
               plp-&gt;palPalEntry[i].peGreen = (BYTE) min (255, 4 * i) ;
               plp-&gt;palPalEntry[i].peBlue  = (BYTE) min (255, 4 * i) ;
               plp-&gt;palPalEntry[i].peFlags = 0 ;
          }
          hPalette = CreatePalette (plp) ;
          free (plp) ;
          return 0 ;

     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;

     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;

               // Select and realize the palette in the device context

          SelectPalette (hdc, hPalette, FALSE) ;
          RealizePalette (hdc) ;

               // Draw the fountain of grays

          for (i = 0 ; i &lt; 65 ; i++)
          {
               rect.left   = i * cxClient / 64 ;
               rect.top    = 0 ;
               rect.right  = (i + 1) * cxClient / 64 ;
               rect.bottom = cyClient ;

               hBrush = CreateSolidBrush (PALETTERGB (min (255, 4 * i), 
                                                      min (255, 4 * i), 
                                                      min (255, 4 * i))) ;
               FillRect (hdc, &amp;rect, hBrush) ;
               DeleteObject (hBrush) ;
          }
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;

     case WM_QUERYNEWPALETTE:
          if (!hPalette)
               return FALSE ;

          hdc = GetDC (hwnd) ;
          SelectPalette (hdc, hPalette, FALSE) ;
          RealizePalette (hdc) ;
          InvalidateRect (hwnd, NULL, TRUE) ;

          ReleaseDC (hwnd, hdc) ;
          return TRUE ;

     case WM_PALETTECHANGED:
          if (!hPalette || (HWND) wParam == hwnd)
               break ;

          hdc = GetDC (hwnd) ;
          SelectPalette (hdc, hPalette, FALSE) ;
          RealizePalette (hdc) ;
          UpdateColors (hdc) ;
  
          ReleaseDC (hwnd, hdc) ;
          break ;

     case WM_DESTROY:
          DeleteObject (hPalette) ;
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

<P>Generally the first step in using the Palette Manager is to create a logical palette by calling the <I>CreatePalette</I> function. The logical palette contains all the colors&#8212;or rather, as many as 236 colors&#8212;that the program needs. The GRAYS1 program handles this job during the WM_CREATE message. It initializes the fields of a LOGPALETTE (&quot;logical palette&quot;) structure and passes a pointer to this structure to the <I>CreatePalette</I> function. <I>CreatePalette</I> returns a handle to the logical palette, which is stored in the static variable <I>hPalette</I>.

<P>The LOGPALETTE structure is defined like so:


<p><pre>
typedef struct
{
     WORD         palVersion ;
     WORD         palNumEntries ;
     PALETTEENTRY palPalEntry[1] ;
}
LOGPALETTE, * PLOGPALETTE ;
</PRE>

<P>The first field is always set to 0x0300, indicating Windows 3.0 compatibility, and the second field is set to the number of entries in the palette table. The third field in the LOGPALETTE structure is an array of PALETTEENTRY structures, one for each of the palette entries. The PALETTEENTRY structure is defined like this:

<p><pre>
typedef struct
{
     BYTE peRed ;
     BYTE peGreen ;
     BYTE peBlue ;
     BYTE peFlags ;
}
PALETTEENTRY, * PPALETTEENTRY ;
</PRE>

<P>Each of the PALETTEENTRY structures defines an RGB color value that we want in the palette.

<P>Notice that LOGPALETTE is defined for an array of only one PALETTEENTRY structure. You need to allocate some memory large enough for one LOGPALETTE structure and additional PALETTEENTRY structures. GRAYS2 wants 65 gray shades, so it allocates enough memory for a LOGPALETTE structure and 64 additional PALETTEENTRY structures. It sets the <I>palNumEntries</I> field to 65. GRAYS2 then goes through a loop from 0 through 64, calculates a gray level (which is simply 4 times the loop index, but not greater than 255), and sets the <I>peRed</I>, <I>peGreen</I>, and <I>peBlue</I> fields of the structure to this gray level. The <I>peFlags</I> field is set to 0. The program passes the pointer to this block of memory to <I>CreatePalette</I>, saves the palette handle in a static variable, and then frees the memory.

<P>A logical palette is a GDI object. Programs should delete any logical palettes they create. <I>WndProc</I> takes care of deleting the logical palette during the WM_DESTROY message by calling <I>DeleteObject</I>.

<P>Notice that the logical palette is independent of a device context. Before you can actually make use of it, it must be selected into a device context and &quot;realized.&quot; During the WM_PAINT message, the <I>SelectPalette</I> function selects the logical palette into the device context. This is similar to the <I>SelectObject</I> function except that a third argument is included. Normally this third argument is set to FALSE. If the third argument to <I>SelectPalette</I> is set to TRUE, the palette is always a &quot;background palette,&quot; which means that it gets whatever unused entries still exist in the system palette after all other programs have realized their palettes.

<P>Only one logical palette can be selected into the device context at any time. The function returns the handle of the logical palette previously selected in the device context. You can save this for selecting back into the device context if you wish to.

<P>The <I>RealizePalette</I> function causes Windows to &quot;realize&quot; the logical palette in the device context by mapping the colors to the system palette, which in turn corresponds to the actual physical palette of the video board. The real work goes on during this function call. Windows must determine whether the window calling the function is active or inactive and perhaps notify other windows that the system palette is changing. (We'll see how this notification works shortly.)

<P>You'll recall that GRAYS1 used the RGB macro to specify the color of the solid brush. The RGB macro constructs a 32-bit long integer (known as a COLORREF value) where the upper byte is 0 and the lower 3 bytes are the intensities of red, green, and blue.

<P>A program that uses the Windows Palette Manager can continue to use RGB color values to specify color. However, these RGB color values will <I>not</I> give access to the additional colors in the logical palette. They will have the same effect as if the Palette Manager were not used. To make use of the additional colors in the logical palette, you use the PALETTERGB macro. A &quot;Palette RGB&quot; color is very much like an RGB color except that the high byte of the COLORREF value is set to 2 rather than 0.

<P>Here are the important rules:

<UL>
<p><li>To use a color in your logical palette, specify it using a Palette RGB value or a Palette Index value. (I'll discuss the Palette Index shortly.) Do not use a normal RGB value. If you use a normal RGB value, you will get one of the standard colors and not a color from your logical palette.
<p><li>Do not use Palette RGB values or Palette Index values when you have not selected a palette in your device context.
<p><li>Although you can use a Palette RGB value to specify a color not in the logical palette, the color you get will be selected from the logical palette.
</UL>

<P>For example, during WM_PAINT processing in GRAYS2, after you select and realize the logical palette, if you try to display something in red, it will come out as a shade of gray. You need to use RGB color values to select colors not in the logical palette.

<P>Notice that GRAYS2 never checks to see whether the video display driver actually supports palette management. When running GRAYS2 under video modes that do not support palette management (that is, all video modes that are <I>not</I> 256 colors), GRAYS2 is functionally equivalent to GRAYS1.

<A NAME="526"><h2>The Palette Messages</h2></A>
<P>If multiple Windows programs are using the Palette Manager, the active window gets priority over the palette. The most recently active window gets second priority, and so forth. Whenever a new program becomes active, the Windows Palette Manager usually must reorganize the system palette table.

<P>If a program specifies a color in its logical palette that is identical to one of the 20 reserved colors, Windows will map that logical palette entry to that color. Also, if two or more applications specify the same color in their logical palettes, these applications will share the system palette entry. A program can override this default behavior by specifying the constant PC_NOCOLLAPSE as the <I>peFlags</I> field of the PALETTEENTRY structure. (The other two possible flags are PC_EXPLICIT, which is used to display the system palette, and PC_RESERVED, which is used in palette animation. I'll demonstrate both of these flags later in this chapter.)

<P>To help in organizing the system palette, the Windows Palette Manager includes two messages sent to main windows.

<P>The first is QM_QUERYNEWPALETTE. This message is sent to a main window when it is about to become active. If your program uses the Palette Manager when drawing on your window, it must process this message. GRAYS2 demonstrates how to do so. The program obtains a device context handle, selects the palette into it, calls <I>RealizePalette</I>, and then invalidates the window to generate a WM_PAINT message. The window procedure returns TRUE from this message if it realizes its logical palette and FALSE otherwise.

<P>Whenever the system palette changes as a result of a WM_QUERYNEWPALETTE message, Windows sends the WM_PALETTECHANGED message to all main windows starting with the most active window and proceeding down the window chain. This allows the foreground window to have priority. The <I>wParam</I> value passed to the window procedure is the handle of the active window. A program using the Palette Manager should process this message only if <I>wParam</I> is not equal to the program's window handle.

<P>Generally, any program that uses a customized palette calls <I>SelectPalette</I> and <I>RealizePalette</I> while processing WM_PALETTECHANGED. When subsequent windows call <I>RealizePalette</I> during the message, Windows first checks for matches of RGB colors in the logical palette with RGB colors already loaded in the system palette. If two programs need the same color, the same system palette entry is used for both. Next Windows checks for unused system palette entries. If none exist, the color in the logical palette is mapped to the closest color from the 20 reserved entries.

<P>If you don't care about how the client area looks when your program is inactive, you do not need to process the WM_PALETTECHANGED message. Otherwise, you have two choices. GRAYS2 shows one of them: As when processing the WM_QUERYNEWPALETTE message, it gets a device context, selects the palette into it, and then calls <I>RealizePalette</I>. At this point, it could call <I>InvalidateRect</I> as when processing WM_QUERYNEWPALETTE. Instead, GRAYS2 calls <I>UpdateColors</I>. This function is usually more efficient than repainting the window, and it changes the values of pixels in your window to help preserve the previous colors.

<P>Most programs that use the Palette Manager will have WM_QUERYNEWPALETTE and WM_PALETTECHANGED message processing identical to that shown in GRAYS2.

<A NAME="527"><h2>The Palette Index Approach</h2></A>
<P>The GRAYS3 program shown in Figure 16-4 is very similar to GRAYS2 but uses a macro called PALETTEINDEX instead of PALETTERGB during WM_PAINT processing.



<P><B>Figure 16-4.</b> <i>The GRAYS3 program.</I>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="528"><h3>GRAYS3.C</h3></A>
<P><pre>
/*-----------------------------------------------
   GRAYS3.C -- Gray Shades Using Palette Manager
               (c) Charles Petzold, 1998
  -----------------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;Grays3&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;

     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;), 
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Shades of Gray #3&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,             
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HPALETTE hPalette ;
     static int      cxClient, cyClient ;
     HBRUSH          hBrush ;
     HDC             hdc ;
     int             i ;
     LOGPALETTE    * plp ;
     PAINTSTRUCT     ps ;
     RECT            rect ;
     switch (message)
     {
     case WM_CREATE:
               // Set up a LOGPALETTE structure and create a palette

          plp = malloc (sizeof (LOGPALETTE) + 64 * sizeof (PALETTEENTRY)) ;

          plp-&gt;palVersion    = 0x0300 ;
          plp-&gt;palNumEntries = 65 ;

          for (i = 0 ; i &lt; 65 ; i++)
          {
               plp-&gt;palPalEntry[i].peRed   = (BYTE) min (255, 4 * i) ;
               plp-&gt;palPalEntry[i].peGreen = (BYTE) min (255, 4 * i) ;
               plp-&gt;palPalEntry[i].peBlue  = (BYTE) min (255, 4 * i) ;
               plp-&gt;palPalEntry[i].peFlags = 0 ;
          }
          hPalette = CreatePalette (plp) ;
          free (plp) ;
          return 0 ;

     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;
          
     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;

               // Select and realize the palette in the device context

          SelectPalette (hdc, hPalette, FALSE) ;
          RealizePalette (hdc) ;

               // Draw the fountain of grays

          for (i = 0 ; i &lt; 65 ; i++)
          {
               rect.left   = i * cxClient / 64 ;
               rect.top    = 0 ;
               rect.right  = (i + 1) * cxClient / 64 ;
               rect.bottom = cyClient ;

               hBrush = CreateSolidBrush (PALETTEINDEX (i)) ;
               FillRect (hdc, &amp;rect, hBrush) ;
               DeleteObject (hBrush) ;
          }

          EndPaint (hwnd, &amp;ps) ;
          return 0 ;

     case WM_QUERYNEWPALETTE:
          if (!hPalette)
               return FALSE ;

          hdc = GetDC (hwnd) ;
          SelectPalette (hdc, hPalette, FALSE) ;
          RealizePalette (hdc) ;
          InvalidateRect (hwnd, NULL, FALSE) ;
     
          ReleaseDC (hwnd, hdc) ;
          return TRUE ;

     case WM_PALETTECHANGED:
          if (!hPalette || (HWND) wParam == hwnd)
               break ;

          hdc = GetDC (hwnd) ;
          SelectPalette (hdc, hPalette, FALSE) ;
          RealizePalette (hdc) ;
          UpdateColors (hdc) ;

          ReleaseDC (hwnd, hdc) ;
          break ;

     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

<P>A &quot;Palette Index&quot; color is quite different from the Palette RGB color. The high byte is 1, and the value in the low byte is an index into the logical palette currently selected in the device context. In GRAYS3, the logical palette has 65 entries. The indices for these entries are thus 0 through 64. The value

<p><pre>
PALETTEINDEX (0)

</PRE>

<P>refers to black,

<p><pre>
PALETTEINDEX (32)
</PRE>

<P>refers to medium gray, and

<p><pre>
PALETTEINDEX (64)
</PRE>

<P>refers to white.

<P>Using palette indices is more efficient than using RGB values because Windows does not need to perform a nearest-color search.

<A NAME="529"><h2>Querying the Palette Support</h2></A>
<P>As you can easily verify, the GRAYS2 and GRAYS3 programs run fine when Windows is running under a 16-bit or 24-bit video mode. But in some cases, a Windows application that wishes to use the Palette Manager might want to first determine whether the device driver supports it. You can do this by calling <I>GetDeviceCaps</I> using a device context handle for the video display and the RASTERCAPS parameter. The function returns an integer composed of a series of flags. You can test palette support by performing a bitwise AND between the return value and the constant RC_PALETTE:

<p><pre>
RC_PALETTE &amp; GetDeviceCaps (hdc, RASTERCAPS)
</PRE>

<P>If this value is nonzero, the device driver for the video display supports palette manipulation. In that case, three other important items are also available from <I>GetDeviceCaps</I>. The function call

<p><pre>
GetDeviceCaps (hdc, SIZEPALETTE)
</PRE>

<P>returns the total size of the palette table on the video board. This is the same as the total number of colors that can be simultaneously displayed. Because the Palette Manager is invoked only for video display modes with 8 bits per pixel, this value will be 256.

<P>The function call

<p><pre>
GetDeviceCaps (hdc, NUMRESERVED)
</PRE>

<P>returns the number of colors in the palette table that the device driver reserves for system purposes. This value will be 20. Without invoking the Palette Manager, these are the only pure colors a Windows application can use in a 256-color video mode. To use the other 236 colors, a program must use the Palette Manager functions.

<P>One additional item is also available:

<p><pre>
GetDeviceCaps (hdc, COLORRES)
</PRE>

<P>This value tells you the resolution (in bits) of the RGB color values loaded into the hardware palette table. These are the bits going into the digital-to-analog converters. Some video display adapters use only 6-bit ADCs, so this value would be 18. Others use 8-bit ADCs, so this value would be 24.

<P>It is useful for a Windows program to take a look at this color resolution value and behave accordingly. For example, if the color resolution is 18, it makes no sense for a program to attempt to request 128 shades of gray because only 64 discrete shades of gray are possible. Requesting 128 shades of gray will unnecessarily fill the hardware palette table with redundant entries.

<A NAME="530"><h2>The System Palette</h2></A>
<P>As I've mentioned, the system palette in Windows corresponds directly to the hardware palette lookup table on the video adapter board. (However, the hardware palette lookup table may have a lower color resolution than the system palette.) A program can obtain any or all of the RGB entries in the system palette by calling this function:

<p><pre>
GetSystemPaletteEntries (hdc, uStart, uNum, &amp;pe) ;
</PRE>

<P>This function works only if the video adapter mode supports palette manipulation. The second and third arguments are unsigned integer values that indicate the index of the first palette entry you want and the number of palette entries you want. The last argument is a pointer to a structure of type PALETTEENTRY.

<P>You can use this function in several ways. A program can define one PALETTEENTRY structure like this,

<p><pre>
PALETTEENTRY pe ;
</PRE>

<P>and then call <I>GetSystemPaletteEntries</I> multiple times like so,

<p><pre>
GetSystemPaletteEntries (hdc, i, 1, &amp;pe) ;
</PRE>

<P>with<I> i</I> being from 0 to one less than the value returned from <I>GetDeviceCaps</I> with the SIZEPALETTE index, which will be 255. Or a program can obtain all the system palette entries by defining a pointer to a PALETTEENTRY structure and then allocating a block of memory sufficient to hold as many PALETTEENTRY structures as indicated by the size of the palette.

<P>The <I>GetSystemPaletteEntries</I> function really lets you examine the hardware palette table. The entries in the system palette are in the order of increasing values of pixel bits that are used to denote color in the video display buffer. I'll demonstrate how to do this shortly.

<A NAME="531"><h2>Other Palette Functions</h2></A>
<P>As we saw earlier, a Windows program can change the system palette but only indirectly. The first step is creating a logical palette, which is basically an array of RGB color values that the program wants to use. The <I>CreatePalette</I> function does not cause any change to the system palette or the palette table on the video board. The logical palette must be selected into a device context and realized before anything happens.

<P>A program can query the RGB color values in a logical palette by calling

<p><pre>
GetPaletteEntries (hPalette, uStart, uNum, &amp;pe) ;
</PRE>

<P>You can use this function in the same way you use <I>GetSystemPaletteEntries</I>. But note that the first parameter is a handle to the logical palette rather than a handle to a device context.

<P>A corresponding function lets you change values in the logical palette after it has been created:

<p><pre>
SetPaletteEntries (hPalette, uStart, uNum, &amp;pe) ;
</PRE>

<P>Again, keep in mind that calling this function does not cause any change to the system palette&#8212;even if the palette is currently selected in a device context. This function also cannot change the size of the logical palette. For that, use <I>ResizePalette</I>.

<P>The following function accepts an RGB color reference value as the last argument and returns an index into the logical palette that corresponds to the RGB color value that most closely approximates it:

<p><pre>
iIndex = GetNearestPaletteIndex (hPalette, cr) ;
</PRE>

<P>The second argument is a COLORREF value. If you wish, you can then obtain the actual RGB color value in the logical palette by calling <I>GetPaletteEntries</I>.

<P>Programs that need more than 236 custom colors in 8-bit video modes can call <I>GetSystemPaletteUse</I>. This lets a program set 254 custom colors; the system reserves only black and white. However, the program should do this only when it is maximized to fill the screen, and it should set some system colors to black and white so that title bars and menus and such are still visible.

<A NAME="532"><h2>The Raster-Op Problem</h2></A>
<P>As you know from <a href="ch05a.htm#94">Chapter 5</a>, GDI allows you to draw lines and fill areas by using various &quot;drawing modes&quot; or &quot;raster operations.&quot; You set the drawing mode using <I>SetROP2</I>. The &quot;2&quot; indicates a <I>binary</I> raster operation between two objects; tertiary raster operations are used with <I>BitBlt</I> and similar functions. These raster operations determine how the pixels of the object you're drawing combine with the pixels of the surface. For example, you can draw a line so that the pixels of the line are combined with the pixels of the display using a bitwise exclusive-OR operation.

<P>The raster operations work by performing bitwise operations on pixel bits. Changing the palette can affect how these raster operations work. The raster operations manipulate pixel bits, and these pixel bits might have no relationship to actual colors.

<P>You can see this for yourself by running the GRAYS2 or GRAYS3 program. Drag the top or bottom sizing border across the window. Windows displays the dragged sizing border by using a raster operation that inverts the background pixel bits. The intent is to make the dragged sizing border always visible. But with the GRAYS2 and GRAYS3 programs, you'll probably see various random colors instead. These colors happen to correspond to unused entries in the palette table that result from inverting the pixel bits of the display. The visible color is not being inverted&#8212;only the pixel bits.


<P>As you can see in Figure 16-1, the 20 standard reserved colors are placed at the top and bottom of the system palette so that the results of raster operations are still normal. However, once you begin changing the palette&#8212;and particularly if you take over the reserved colors&#8212;then raster operations of color objects can become meaningless.

<P>The only guarantee you have is that the raster operations will work with black and white. Black is the first entry in the system palette (all pixel bits set to 0), and white is the last entry (all pixel bits set to 1). These entries cannot be changed. If you need to predict the results of raster operations on color objects, you can do so by getting the system palette table and looking at the RGB color values for the various pixel-bit values.

<A NAME="533"><h2>Looking at the System Palette</h2></A>
<P>Programs running under Windows deal with logical palettes; Windows sets up the colors in the system palette to best service all programs using logical palettes. The system palette mirrors the hardware lookup table of the video board. Thus, taking a look at the system palette can help in debugging palette applications.

<P>I'm going to show you three programs that display the contents of the system palette because there are three quite different approaches to this problem.

<P>The SYSPAL1 program is shown in Figure 16-5. This program uses the <I>GetSystemPaletteEntries</I> function that I described above.



<P><B>Figure 16-5.</b> <i>The SYSPAL1 program.</I>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="534"><h3>SYSPAL1.C</h3></A>
<P><pre>
/*----------------------------------------
   SYSPAL1.C -- Displays system palette
                (c) Charles Petzold, 1998
  ----------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

TCHAR szAppName [] = TEXT (&quot;SysPal1&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;System Palette #1&quot;), 
                          WS_OVERLAPPEDWINDOW, 
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     if (!hwnd)
          return 0 ;

     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;

     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

BOOL CheckDisplay (HWND hwnd)
{
     HDC hdc ;
     int iPalSize ;

     hdc = GetDC (hwnd) ;
     iPalSize = GetDeviceCaps (hdc, SIZEPALETTE) ;
     ReleaseDC (hwnd, hdc) ;
     if (iPalSize != 256)
     {
          MessageBox (hwnd, TEXT (&quot;This program requires that the video &quot;)
                            TEXT (&quot;display mode have a 256-color palette.&quot;),
                      szAppName, MB_ICONERROR) ;
          return FALSE ;
     }
     return TRUE ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static int   cxClient, cyClient ;
     static SIZE  sizeChar ;
     HDC          hdc ;
     HPALETTE     hPalette ;
     int          i, x, y ;
     PAINTSTRUCT  ps ;
     PALETTEENTRY pe [256] ;
     TCHAR        szBuffer [16] ;

     switch (message)
     {
     case WM_CREATE:
          if (!CheckDisplay (hwnd))
               return -1 ;

          hdc = GetDC (hwnd) ;
          SelectObject (hdc, GetStockObject (SYSTEM_FIXED_FONT)) ;
          GetTextExtentPoint32 (hdc, TEXT (&quot;FF-FF-FF&quot;), 10, &amp;sizeChar) ;
          ReleaseDC (hwnd, hdc) ;
          return 0 ;
     
     case WM_DISPLAYCHANGE:
          if (!CheckDisplay (hwnd))
               DestroyWindow (hwnd) ;

          return 0 ;

     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;

     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
          SelectObject (hdc, GetStockObject (SYSTEM_FIXED_FONT)) ;

          GetSystemPaletteEntries (hdc, 0, 256, pe) ;

          for (i = 0, x = 0, y = 0 ; i &lt; 256 ; i++)
          {
               wsprintf (szBuffer, TEXT (&quot;%02X-%02X-%02X&quot;),
                         pe[i].peRed, pe[i].peGreen, pe[i].peBlue) ;

               TextOut (hdc, x, y, szBuffer, lstrlen (szBuffer)) ;

               if ((x += sizeChar.cx) + sizeChar.cx &gt; cxClient)
               {
                    x = 0 ;
          
                    if ((y += sizeChar.cy) &gt; cyClient)
                         break ;
               }
          }
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;

     case WM_PALETTECHANGED:
          InvalidateRect (hwnd, NULL, FALSE) ;
          return 0 ;

     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

<P>As with the other programs in the SYSPAL series, SYSPAL1 does not run unless <I>GetDeviceCaps</I> with the SIZEPALETTE argument returns 256.

<P>Notice that SYSPAL1's client area is invalidated whenever it receives a WM_PALETTECHANGED message. During the resultant WM_PAINT message, SYSPAL1 calls <I>GetSystemPaletteEntries</I> with an array of 256 PALETTEENTRY structures. The RGB values are displayed as text strings in the client area. When you run the program, note that the 20 reserved colors are the first 10 and last 10 in the list of RGB values, as indicated by Figure 16-1.


<P>While SYSPAL1 is certainly displaying useful information, it's not quite the same as actually seeing the 256 colors. That's a job for SYSPAL2, shown in Figure 16-6.



<P><B>Figure 16-6.</b> <i>The SYSPAL2 program.</I>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="535"><h3>SYSPAL2.C</h3></A>
<P><pre>
/*----------------------------------------
   SYSPAL2.C -- Displays system palette
                (c) Charles Petzold, 1998
  ----------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

TCHAR szAppName [] = TEXT (&quot;SysPal2&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;

     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;System Palette #2&quot;), 
                          WS_OVERLAPPEDWINDOW, 
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     if (!hwnd)
          return 0 ;

     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;

     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

BOOL CheckDisplay (HWND hwnd)
{
     HDC hdc ;
     int iPalSize ;

     hdc = GetDC (hwnd) ;
     iPalSize = GetDeviceCaps (hdc, SIZEPALETTE) ;
     ReleaseDC (hwnd, hdc) ;

     if (iPalSize != 256)
     {
          MessageBox (hwnd, TEXT (&quot;This program requires that the video &quot;)
                            TEXT (&quot;display mode have a 256-color palette.&quot;),
                      szAppName, MB_ICONERROR) ;
          return FALSE ;
     }
     return TRUE ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HPALETTE hPalette ;
     static int      cxClient, cyClient ;
     HBRUSH          hBrush ;
     HDC             hdc ;
     int             i, x, y ;
     LOGPALETTE    * plp ;
     PAINTSTRUCT     ps ;
     RECT            rect ;
     switch (message)
     {
     case WM_CREATE:
          if (!CheckDisplay (hwnd))
               return -1 ;

          plp = malloc (sizeof (LOGPALETTE) + 255 * sizeof (PALETTEENTRY)) ;

          plp-&gt;palVersion    = 0x0300 ;
          plp-&gt;palNumEntries = 256 ;

          for (i = 0 ; i &lt; 256 ; i++)
          {
               plp-&gt;palPalEntry[i].peRed   = i ;
               plp-&gt;palPalEntry[i].peGreen = 0 ;
               plp-&gt;palPalEntry[i].peBlue  = 0 ;
               plp-&gt;palPalEntry[i].peFlags = PC_EXPLICIT ;
          }
          
          hPalette = CreatePalette (plp) ;
          free (plp) ;          
          return 0 ;
     
     case WM_DISPLAYCHANGE:
          if (!CheckDisplay (hwnd))
               DestroyWindow (hwnd) ;

          return 0 ;

     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;

     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;

          SelectPalette (hdc, hPalette, FALSE) ;
          RealizePalette (hdc) ;

          for (y = 0 ; y &lt; 16 ; y++)
          for (x = 0 ; x &lt; 16 ; x++)
          {
               hBrush = CreateSolidBrush (PALETTEINDEX (16 * y + x)) ;
               SetRect (&amp;rect, x      * cxClient / 16,  y      * cyClient / 16,
                              (x + 1) * cxClient / 16, (y + 1) * cyClient / 16);
               FillRect (hdc, &amp;rect, hBrush) ;
               DeleteObject (hBrush) ;
          }
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;

     case WM_PALETTECHANGED:
          if ((HWND) wParam != hwnd)
               InvalidateRect (hwnd, NULL, FALSE) ;

          return 0 ;

     case WM_DESTROY:
          DeleteObject (hPalette) ;
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

<P>SYSPAL2 creates a logical palette during the WM_CREATE message. But notice that all 256 values in the logical palette are palette indices ranging from 0 to 255 and that the <I>peFlags</I> field is PC_EXPLICIT. The definition of this flag is this: &quot;Specifies that the low-order word of the logical palette entry designates a hardware palette index. This flag allows the application to show the contents of the display device palette.&quot; Thus, this flag is specifically intended for doing what we're trying to do.

<P>During the WM_PAINT message, SYSPAL2 selects this palette into its device context and realizes it. This does not cause any reorganization of the system palette but instead allows the program to specify colors in the system palette by using the PALETTEINDEX macro. SYSPAL2 does this to display 256 rectangles. Again, when you run this program, notice that the first 10 and last 10 colors of the top row and bottom row are the 20 reserved colors shown in Figure 16-1. As you run programs that use their own logical palettes, the display changes.


<P>If you like seeing the colors in SYSPAL2 but would like RGB values as well, run the program in conjunction with the WHATCLR program from <a href="ch08a.htm#215">Chapter 8</a>.

<P>The third version in the SYSPAL series uses a technique that occurred to me only recently&#8212;some seven years after I first started exploring the Windows Palette Manager.

<P>Virtually all the GDI functions specify color&#8212;either directly or indirectly&#8212;as an RGB value. Somewhere deep in GDI this is converted into certain pixel bits that correspond to that color. In some video modes (for example, in 16-bit or 24-bit color mode), this conversion is rather straightforward. In other video modes (4-bit or 8-bit color), this can involve a nearest-color search.


<P>However, there are two GDI functions that let you specify color directly in pixel bits. These two functions used in this way are, of course, highly device-dependent. They are so device-dependent that they can directly display the actual palette lookup table on the video display adapter. These two functions are <I>BitBlt</I> and <I>StretchBlt</I>.

<P>The SYSPAL3 program in Figure 16-7 shows how to use <I>StretchBlt</I> to display the colors in the system palette.



<P><B>Figure 16-7.</b> <i>The SYSPAL3 program.</I>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="536"><h3>SYSPAL3.C</h3></A>
<P><pre>
/*----------------------------------------
   SYSPAL3.C -- Displays system palette
                (c) Charles Petzold, 1998
  ----------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

TCHAR szAppName [] = TEXT (&quot;SysPal3&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;

     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;

      if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }

    hwnd = CreateWindow (szAppName, TEXT (&quot;System Palette #3&quot;), 
                          WS_OVERLAPPEDWINDOW, 
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     if (!hwnd)
          return 0 ;

     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;

     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

BOOL CheckDisplay (HWND hwnd)
{
     HDC hdc ;
     int iPalSize ;

     hdc = GetDC (hwnd) ;

     iPalSize = GetDeviceCaps (hdc, SIZEPALETTE) ;
     ReleaseDC (hwnd, hdc) ;

     if (iPalSize != 256)
     {
          MessageBox (hwnd, TEXT (&quot;This program requires that the video &quot;)
                            TEXT (&quot;display mode have a 256-color palette.&quot;),
                      szAppName, MB_ICONERROR) ;
          return FALSE ;
     }
     return TRUE ;
}
LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HBITMAP hBitmap ;
     static int     cxClient, cyClient ;
     BYTE           bits [256] ;
     HDC            hdc, hdcMem ;
     int            i ;
     PAINTSTRUCT    ps ;

     switch (message)
     {
     case WM_CREATE:
          if (!CheckDisplay (hwnd))
               return -1 ;

          for (i = 0 ; i &lt; 256 ; i++)
               bits [i] = i ;
          
          hBitmap = CreateBitmap (16, 16, 1, 8, &amp;bits) ;
          return 0 ;
                                                        
     case WM_DISPLAYCHANGE:
          if (!CheckDisplay (hwnd))
               DestroyWindow (hwnd) ;

          return 0 ;

     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;

     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;

          hdcMem = CreateCompatibleDC (hdc) ;
          SelectObject (hdcMem, hBitmap) ;

          StretchBlt (hdc,    0, 0, cxClient, cyClient,
                      hdcMem, 0, 0, 16, 16, SRCCOPY) ;

          DeleteDC (hdcMem) ;
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;

     case WM_DESTROY:
          DeleteObject (hBitmap) ;
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

<P>During the WM_CREATE message, SYSPAL3 uses <I>CreateBitmap</I> to create a 16-by-16 bitmap with 8 bits per pixel. The last argument to the function is an array of 256 bytes containing the numbers 0 through 255. These are the 256 possible pixel-bit values. During the WM_PAINT message, the program selects this bitmap into a memory device context and uses <I>StretchBlt</I> to display it to fill the client area. Windows simply transfers the pixel bits in the bitmap to the hardware of the video display, thus allowing these pixel bits to access the 256 entries in the palette lookup table. The program's client area doesn't even need to be invalidated on receipt of the WM_PALETTECHANGED message&#8212;any change to the lookup table is immediately reflected in SYSPAL3's display.

</BODY>
</HTML>





