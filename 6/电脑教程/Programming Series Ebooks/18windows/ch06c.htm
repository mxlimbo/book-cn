<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Keystroke Messages</TITLE>
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="150"><h1>Keystroke Messages</h1></A>
<p>When you press a key, Windows places either a WM_KEYDOWN or WM_SYSKEYDOWN message in the message queue of the window with the input focus. When you release a key, Windows places either a WM_KEYUP or WM_SYSKEYUP message in the message queue.

<table cellpadding=5 width="95%">
<tr><td valign="top"></td>
<td valign="top"><b><i>Key Pressed</i></b></td>
<td valign="top"><b><i>Key Released</i></b></td></tr>

<tr><td valign="top">Nonsystem Keystroke:</td>
<td valign="top">WM_KEYDOWN</td> <td valign="top">WM_KEYUP</td></tr>

<tr><td valign="top">System Keystroke:</td>
<td valign="top">WM_SYSKEYDOWN</td><td valign="top">WM_SYSKEYUP</td></tr>
</table>

<p>Usually the up and down messages occur in pairs. However, if you hold down a key so that the typematic (autorepeat) action takes over, Windows sends the window procedure a series of WM_KEYDOWN (or WM_SYSKEYDOWN) messages and a single WM_KEYUP (or WM_SYSKEYUP) message when the key is finally released. Like all queued messages, keystroke messages are time-stamped. You can retrieve the relative time a key was pressed or released by calling <I>GetMessageTime</I>.

<A NAME="151"><h2>System and Nonsystem Keystrokes</h2></A>
<p>The &quot;SYS&quot; in WM_SYSKEYDOWN and WM_SYSKEYUP stands for &quot;system&quot; and refers to keystrokes that are more important to Windows than to Windows applications. The WM_SYSKEYDOWN and WM_SYSKEYUP messages are usually generated for keys typed in combination with the Alt key. These keystrokes invoke options on the program's menu or system menu, or they are used for system functions such as switching the active window (Alt-Tab or Alt-Esc) or for system menu accelerators (Alt in combination with a function key such as Alt-F4 to close an application). Programs usually ignore the WM_SYSKEYUP and WM_SYSKEYDOWN messages and pass them to <I>DefWindowProc</I>. Because Windows takes care of all the Alt-key logic, you really have no need to trap these messages. Your window procedure will eventually receive other messages concerning the result of these keystrokes (such as a menu selection). If you want to include code in your window procedure to trap the system keystroke messages (as we will do in the KEYVIEW1 and KEYVIEW2 programs shown later in this chapter), pass the messages to <I>DefWindowProc</I> after you process them so that Windows can still use them for their intended purposes.

<p>But think about this for a moment. Almost everything that affects your program's window passes through your window procedure first. Windows does something with the message only if you pass the message to <I>DefWindowProc</I>. For instance, if you add the lines

<p><pre>
case WM_SYSKEYDOWN:
case WM_SYSKEYUP:
case WM_SYSCHAR:
     return 0 ;
</PRE>

<p>to a window procedure, you effectively disable all Alt-key operations when your program's main window has the input focus. (I'll discuss the WM_SYSCHAR message later in this chapter.) This includes Alt-Tab, Alt-Esc, and menu operations. Although I doubt you would want to do this, I trust you sense the power inherent in the window procedure.

<p>The WM_KEYDOWN and WM_KEYUP messages are usually generated for keys that are pressed and released without the Alt key. Your program can use or discard these keystroke messages. Windows doesn't care about them.

<p>For all four keystroke messages, <I>wParam</I> is a virtual key code that identifies the key being pressed or released and <I>lParam</I> contains other data pertaining to the keystroke.

<A NAME="152"><h2>Virtual Key Codes</h2></A>
<p>The virtual key code is stored in the <I>wParam</I> parameter of the WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, and WM_SYSKEYUP messages. This code identifies the key being pressed or released.

<p>Ah, that ubiquitous word &quot;virtual.&quot; Don't you love it? It's supposed to refer to something that exists in the mind rather than in the real world, but only veteran programmers of DOS assembly language applications might figure out why the key codes so essential to Windows keyboard processing are considered virtual rather than real.

<p>To old-time programmers, the <I>real</I> keyboard codes are generated by the hardware of the physical keyboard. These are referred to in the Windows documentation as <I>scan codes</I>. On IBM compatibles, a scan code of 16 is the Q key, 17 is the W key, 18 is E, 19 is R, 20 is T, 21 is Y, and so on. You get the idea&#8212;the scan codes are based on the physical layout of the keyboard. The developers of Windows considered these scan codes too device-dependent. They thus attempted to treat the keyboard in a device-independent manner by defining the so-called virtual key codes. Some of these virtual key codes cannot be generated on IBM compatibles but may be found on other manufacturer's keyboards, or perhaps on keyboards of the future.

<p>The virtual key codes you use most often have names beginning with VK_ defined in the WINUSER.H header file. The tables below show these names along with the numeric values (in both decimal and hexadecimal) and the IBM-compatible keyboard key that corresponds to the virtual key. The tables also indicate whether these keys are required for Windows to run properly. The tables show the virtual key codes in numeric order.

<p>Three of the first four virtual key codes refer to mouse buttons:

<table cellpadding=5 width="95%">

<tr>
<td valign="top"><b><i>Decimal</i></b></td>
<td valign="top"><b><i>Hex</i></b></td>
<td valign="top"><b><i>WINUSER.H Identifier</i></b></td>
<td valign="top"><b><i>Required?</i></b></td>
<td valign="top"><b><i>IBM-Compatible Keyboard</i></b></td>
</tr>

<tr>
<td valign="top">1</td>
<td valign="top">01</td>
<td valign="top">VK_LBUTTON</td>
<td valign="top"> </td>
<td valign="top">Mouse Left Button</td>
</tr>

<tr>
<td valign="top">2</td>
<td valign="top">02</td>
<td valign="top">VK_RBUTTON</td>
<td valign="top"> </td>
<td valign="top">Mouse Right Button</td>
</tr>

<tr>
<td valign="top">3</td>
<td valign="top">03</td>
<td valign="top">VK_CANCEL</td>
<td valign="top">X</td>
<td valign="top">Ctrl-Break</td>
</tr>

<tr><td valign="top">4</td>
<td valign="top">04</td>
<td valign="top">VK_MBUTTON</td>
<td valign="top"> </td>
<td valign="top">Mouse Middle Button</td>
</tr>
</table>

<p>You will never get these mouse button codes in the keyboard messages. They are found in mouse messages, as we'll see in the next chapter. The VK_CANCEL code is the only virtual key code that involves pressing two keys at once (Ctrl-Break). Windows applications generally do not use this key.

<p>Several of the following keys&#8212;Backspace, Tab, Enter, Escape, and Spacebar&#8212;are commonly used by Windows programs. However, Windows programs generally use character messages (rather than keystroke messages) to process these keys.

<table cellpadding=5 width="95%">
            
<tr><td valign="top"><i><b>Decimal</b></i></td>
<td valign="top"><i><b>Hex</b></i></td>
<td valign="top"><i><b>WINUSER.H Identifier</b></i></td>
<td valign="top"><b><i>Required?</i></b></td>
<td valign="top"><b><i>IBM-Compatible Keyboard</i></b></td></tr>

<tr>
<td valign="top">8</td>
<td valign="top">08</td>
<td valign="top">VK_BACK</td>
<td valign="top">X</td>
<td valign="top">Backspace</td>
</tr>

<tr>
<td valign="top">9</td>
<td valign="top">09</td>
<td valign="top">VK_TAB</td>
<td valign="top">X</td>
<td valign="top">Tab</td>
</tr>

<tr>
<td valign="top">12</td>
<td valign="top">0C</td>
<td valign="top">VK_CLEAR</td>
<td valign="top"> </td>
<td valign="top">Numeric keyboard 5 with Num Lock OFF</td>
</tr> 
                         
<tr>
<td valign="top">13</td>
<td valign="top">0D</td>
<td valign="top">VK_RETURN</td>
<td valign="top">X</td>
<td valign="top">Enter (either one)</td>
</tr>

<tr>
<td valign="top">16</td>
<td valign="top">10</td>
<td valign="top">VK_SHIFT</td>
<td valign="top">X</td>
<td valign="top">Shift (either one)</td>
</tr>

<tr><td valign="top">17</td>
<td valign="top">11</td>
<td valign="top">VK_CONTROL</td>
<td valign="top">X</td>
<td valign="top">Ctrl (either one)</td>
</tr>

<tr>
<td valign="top">18</td>
<td valign="top">12</td>
<td valign="top">VK_MENU</td>
<td valign="top">X</td>
<td valign="top">Alt (either one)</td>
</tr>

<tr>
<td valign="top">19</td>
<td valign="top">13</td>
<td valign="top">VK_PAUSE</td>
<td valign="top"> </td>
<td valign="top">Pause</td>
</tr> 

<tr>
<td valign="top">20</td>
<td valign="top">14</td>
<td valign="top">VK_CAPITAL</td>
<td valign="top">X</td>
<td valign="top">Caps Lock</td>
</tr>

<tr><td valign="top">27</td>
<td valign="top">1B</td>
<td valign="top">VK_ESCAPE</td>
<td valign="top">X</td>
<td valign="top">Esc</td>
</tr>

<tr>
<td valign="top">32</td>
<td valign="top">20</td>
<td valign="top">VK_SPACE</td>
<td valign="top">X</td>
<td valign="top">Spacebar</td>
</tr>
</table>

<p>Also, Windows programs usually do not need to monitor the status of the Shift, Ctrl, or Alt keys.

<p>The first eight codes listed in the following table are perhaps the most commonly used virtual key codes along with VK_INSERT and VK_DELETE:

<table cellpadding=5 width="95%">

<tr>
<td valign="top"><i><b>Decimal</b></i></td>
<td valign="top"><i><b>Hex</b></i></td>
<td valign="top"><i><b>WINUSER.H Identifier</b></i></td>
<td valign="top"><b><i>Required?</i></b></td>
<td valign="top"><b><i>IBM-Compatible Keyboard</i></b></td>
</tr>
<tr>
<td valign="top">33</td>
<td valign="top">21</td>
<td valign="top">VK_PRIOR</td>
<td valign="top">X</td>
<td valign="top">Page Up</td>
</tr>

<tr>
<td valign="top">34</td>
<td valign="top">22</td>
<td valign="top">VK_NEXT</td>
<td valign="top">X</td>
<td valign="top">Page Down</td>
</tr>

<tr>
<td valign="top">35</td>
<td valign="top">23</td>
<td valign="top">VK_END</td>
<td valign="top">X</td>
<td valign="top">End</td>
</tr>

<tr>
<td valign="top">36</td>
<td valign="top">24</td>
<td valign="top">VK_HOME</td>
<td valign="top">X</td>
<td valign="top">Home</td>
</tr>

<tr>
<td valign="top">37</td>
<td valign="top">25</td>
<td valign="top">VK_LEFT</td>
<td valign="top">X</td>
<td valign="top">Left Arrow</td>
</tr>

<tr>
<td valign="top">38</td>
<td valign="top">26</td>
<td valign="top">VK_UP</td>
<td valign="top">X</td>
<td valign="top">Up Arrow</td>
</tr>

<tr>
<td valign="top">39</td>
<td valign="top">27</td>
<td valign="top">VK_RIGHT</td>
<td valign="top">X</td>
<td valign="top">Right Arrow</td>
</tr>

<tr>
<td valign="top">40</td>
<td valign="top">28</td>
<td valign="top">VK_DOWN</td>
<td valign="top">X</td>
<td valign="top">Down Arrow</td>
</tr>

<tr>
<td valign="top">41</td>
<td valign="top">29</td>
<td valign="top">VK_SELECT</td>
<td valign="top"> </td>
<td valign="top"> </td>
</tr>          

<tr>
<td valign="top">42</td>
<td valign="top">2A</td>
<td valign="top">VK_PRINT</td>
<td valign="top"> </td>
<td valign="top"> </td>
</tr>          

<tr>
<td valign="top">43</td>
<td valign="top">2B</td>
<td valign="top">VK_EXECUTE</td>
<td valign="top"> </td>
<td valign="top"> </td>
</tr>          

<tr>
<td valign="top">44</td>
<td valign="top">2C</td>
<td valign="top">VK_SNAPSHOT</td>
<td valign="top"> </td>
<td valign="top">Print Screen</td>
</tr>

<tr>
<td valign="top">45</td>
<td valign="top">2D</td>
<td valign="top">VK_INSERT</td>
<td valign="top">X</td>
<td valign="top">Insert</td>
</tr>

<tr>
<td valign="top">46</td>
<td valign="top">2E</td>
<td valign="top">VK_DELETE</td>
<td valign="top">X</td>
<td valign="top">Delete</td>
</tr>

<tr>
<td valign="top">47</td>
<td valign="top">2F</td>
<td valign="top">VK_HELP</td>
<td valign="top"> </td>
<td valign="top"> </td>
</tr>          
</table>

<p>Notice that many of the names (such as VK_PRIOR and VK_NEXT) are unfortunately quite different from the labels on the keys and also not consistent with the identifiers used in scroll bars. The Print Screen key is largely ignored by Windows applications. Windows itself responds to the key by storing a bitmap copy of the video display into the clipboard. VK_SELECT, VK_PRINT, VK_EXECUTE, and VK_HELP might be found on a hypothetical keyboard that few of us have ever seen.

<p>Windows also includes virtual key codes for the letter keys and number keys on the main keyboard. (The number pad is handled separately.)

<table cellpadding=5 width="95%">
<tr>
<td valign="top"><i><b>Decimal</b></i></td>
<td valign="top"><i><b>Hex</b></i></td>
<td valign="top"><i><b>WINUSER.H Identifier</b></i></td>
<td valign="top"><b><i>Required?</i></b></td>
<td valign="top"><b><i>IBM-Compatible Keyboard</i></b></td>
</tr>

<tr>
<td valign="top">48_57</td>
<td valign="top">30_39</td>
<td valign="top">None</td>
<td valign="top">X</td>
<td valign="top">0 through 9 on main keyboard</td>
</tr> 
                         
<tr>
<td valign="top">65_90</td>
<td valign="top">41_5A</td>
<td valign="top">None</td>
<td valign="top">X</td>
<td valign="top">A through Z</td>
</tr>
</table>

<p>Notice that the virtual key codes are the ASCII codes for the numbers and letters. Windows programs almost never use these virtual key codes; instead, the programs rely on character messages for ASCII characters.

<p>The following keys are generated from the Microsoft Natural Keyboard and compatibles:

<table cellpadding=5 width="95%">
<tr>
<td valign="top"><i><b>Decimal</b></i></td>
<td valign="top"><i><b>Hex</b></i></td>
<td valign="top"><i><b>WINUSER.H Identifier</b></i></td>
<td valign="top"><b><i>Required?</i></b></td>
<td valign="top"><b><i>IBM-Compatible Keyboard</i></b></td>
</tr>

<tr>
<td valign="top">91</td>
<td valign="top">5B</td>
<td valign="top">VK_LWIN</td>
<td valign="top"> </td>
<td valign="top">Left Windows key</td>
</tr>

<tr>
<td valign="top">92</td>
<td valign="top">5C</td>
<td valign="top">VK_RWIN</td>
<td valign="top"> </td>
<td valign="top">Right Windows key</td>
</tr>

<tr>
<td valign="top">93</td>
<td valign="top">5D</td>
<td valign="top">VK_APPS</td>
<td valign="top"> </td>
<td valign="top">Applications key</td>
</tr>
</table>

<p>The VK_LWIN and VK_RWIN keys are handled by Windows to open the Start menu or (in older versions) to launch the Task Manager. Together, they can log on or off Windows (in Microsoft Windows NT only), or log on or off a network (in Windows for Workgroups). Applications can process the application key by displaying help information or shortcuts.

<p>The following codes are for the keys on the numeric keypad (if present):

<table cellpadding=5 width="95%">
<tr>
<td valign="top"><i><b>Decimal</b></i></td>
<td valign="top"><i><b>Hex</b></i></td>
<td valign="top"><i><b>WINUSER.H Identifier</b></i></td>
<td valign="top"><b><i>Required?</i></b></td>
<td valign="top"><b><i>IBM-Compatible Keyboard</i></b></td>
</tr>

<tr>
<td valign="top">96-105</td>
<td valign="top">60-69</td>
<td valign="top">VK_NUMPAD0 through VK_NUMPAD9</td>
<td valign="top"> </td>
<td valign="top">Numeric keypad 0 through 9 with Num Lock ON</td>
</tr>
                         
<tr>
<td valign="top">106</td>
<td valign="top">6A</td>
<td valign="top">VK_MULTIPLY</td>
<td valign="top"> </td>
<td valign="top">Numeric keypad *</td>
</tr>

<tr>
<td valign="top">107</td>
<td valign="top">6B</td>
<td valign="top">VK_ADD</td>
<td valign="top"> </td>
<td valign="top">Numeric keypad +</td>
</tr>

<tr>
<td valign="top">108</td>
<td valign="top">6C</td>
<td valign="top">VK_SEPARATOR</td>
<td valign="top"> </td>
<td valign="top"> </td>
</tr>          

<tr>
<td valign="top">109</td>
<td valign="top">6D</td>
<td valign="top">VK_SUBTRACT</td>
<td valign="top"> </td>
<td valign="top">Numeric keypad-</td>
</tr> 

<tr>
<td valign="top">110</td>
<td valign="top">6E</td>
<td valign="top">VK_DECIMAL</td>
<td valign="top"> </td>
<td valign="top">Numeric keypad .</td>
</tr>

<tr>
<td valign="top">111</td>
<td valign="top">6F</td>
<td valign="top">VK_DIVIDE</td>
<td valign="top"> </td>
<td valign="top">Numeric keypad /</td>
</tr>
</table>

<p>Finally, although most keyboards have 12 function keys, Windows requires only 10 but has numeric identifiers for 24. Again, programs generally use the function keys as keyboard accelerators so they usually don't process the keystrokes in this table:

<table cellpadding=5 width="95%">
<tr>
<td valign="top"><i><b>Decimal</b></i></td>
<td valign="top"><i><b>Hex</b></i></td>
<td valign="top"><i><b>WINUSER.H Identifier</b></i></td>
<td valign="top"><b><i>Required?</i></b></td>
<td valign="top"><b><i>IBM-Compatible Keyboard</i></b></td>
</tr>

<tr>
<td valign="top">112-121</td>
<td valign="top">70-79</td>
<td valign="top">VK_F1 through VK_F10</td>
<td valign="top">X</td>
<td valign="top">Function keys F1 through F10</td>
</tr>
                         
<tr>
<td valign="top">122-135</td>
<td valign="top">7A-87</td>
<td valign="top">VK_F11 through VK_F24</td>
<td valign="top"> </td>
<td valign="top">Function keys F11 through F24</td>
</tr> 
                         
<tr>
<td valign="top">144</td>
<td valign="top">90</td>
<td valign="top">VK_NUMLOCK</td>
<td valign="top"> </td>
<td valign="top">Num Lock</td>
</tr>

<tr>
<td valign="top">145</td>
<td valign="top">91</td>
<td valign="top">VK_SCROLL</td>
<td valign="top"> </td>
<td valign="top">Scroll Lock</td>
</tr>
</table>

<p>Some other virtual key codes are defined, but they are reserved for keys specific to nonstandard keyboards or for keys most commonly found on mainframe terminals. Check <I>/Platform SDK/User Interface Services/User Input/Virtual-Key Codes</I> for a complete list.

<A NAME="153"><h2>The <I>lParam</I> Information</h2></A>
<p>In the four keystroke messages (WM_KEYDOWN, WM_KEYUP, WM_SYSKEYDOWN, and WM_SYSKEYUP), the <I>wParam</I> message parameter contains the virtual key code as described above, and the <I>lParam</I> message parameter contains other information useful in understanding the keystroke. The 32 bits of <I>lParam</I> are divided into six fields as shown in Figure 6-1.

<p><A HREF="javascript:fullSize('F06zg01x.htm')"><img src="F06zg01.JPG" width=404 height=177 ALIGN="BOTTOM" border=0 ALT="Click to view at full size."></a>

<p><!-- caption --><B>Figure 6-1.</B> <I>The six keystroke-message fields of the </I>lParam<I> variable.</I><!-- /caption -->

<A NAME="154"><h3>Repeat Count</h3></A>
<p>The repeat count is the number of keystrokes represented by the message. In most cases, this will be set to 1. However, if a key is held down and your window procedure is not fast enough to process key-down messages at the typematic rate (which you can set in the Keyboard applet in the Control Panel), Windows combines several WM_KEYDOWN or WM_SYSKEYDOWN messages into a single message and increases the Repeat Count field accordingly. The Repeat Count is always 1 for a WM_KEYUP or WM_SYSKEYUP message.

<p>Because a Repeat Count greater than 1 indicates that typematic keystrokes are occurring faster than your program can process them, you may want to ignore the Repeat Count when processing the keyboard messages. Almost everyone has had the experience of &quot;overscrolling&quot; a word-processing document or spreadsheet because extra keystrokes have accumulated. If your program ignores the Repeat Count in cases where your program spends some time processing each keystroke, you can eliminate this problem. However, in other cases you will want to use the Repeat Count. You may want to try using the programs both ways and see which feels the most natural.

<A NAME="155"><h3>OEM Scan Code</h3></A>
<p>The OEM Scan Code is the code generated by the hardware of the keyboard. This is familiar to middle-aged assembly language programmers as the value obtained from the ROM BIOS services of PC compatibles. (OEM refers to the Original Equipment Manufacturer of the PC and in this context is synonymous with &quot;IBM Standard.&quot;) We don't need this stuff anymore. Windows programs can almost always ignore the OEM Scan Code except when dependent on the physical layout of the keyboard, such as the KBMIDI program in <a href="ch22a.htm#747">Chapter 22</a>.

<A NAME="156"><h3>Extended Key Flag</h3></A>
<p>The Extended Key Flag is 1 if the keystroke results from one of the additional keys on the IBM enhanced keyboard. (The enhanced keyboard has 101 or 102 keys. Function keys are across the top. Cursor movement keys are separate from the numeric keypad, but the numeric keypad also duplicates the cursor movement keys.) This flag is set to 1 for the Alt and Ctrl keys at the right of the keyboard, the cursor movement keys (including Insert and Delete) that are not part of the numeric keypad, the slash (/) and Enter keys on the numeric keypad, and the Num Lock key. Windows programs generally ignore the Extended Key Flag.

<A NAME="157"><h3>Context Code</h3></A>

<p>The Context Code is 1 if the Alt key is depressed during the keystroke. This bit will always be 1 for the WM_SYSKEYUP and WM_SYSKEYDOWN messages and 0 for the WM_KEYUP and WM_KEYDOWN messages, with two exceptions:

<ul>

<p><li>If the active window is minimized, it does not have the input focus. All keystrokes generate WM_SYSKEYUP and WM_SYSKEYDOWN messages. If the Alt key is not pressed, the Context Code field is set to 0. Windows uses WM_SYSKEYUP and WM_SYSKEYDOWN messages so that a minimized active window doesn't process these keystrokes.

<p><li>On some foreign-language keyboards, certain characters are generated by combining Shift, Ctrl, or Alt with another key. In these cases, the Context Code is set to 1 but the messages are not system keystroke messages.

</UL>

<A NAME="158"><h3>Previous Key State</h3></A>
<p>The Previous Key State is 0 if the key was previously up and 1 if the key was previously down. It is always set to 1 for a WM_KEYUP or WM_SYSKEYUP message, but it can be 0 or 1 for a WM_KEYDOWN or WM_SYSKEYDOWN message. A 1 indicates second and subsequent messages that are the result of typematic repeats.

<A NAME="159"><h3>Transition State</h3></A>
<p>The Transition State is 0 if the key is being pressed and 1 if the key is being released. The field is set to 0 for a WM_KEYDOWN or WM_SYSKEYDOWN message and to 1 for a WM_KEYUP or WM_SYSKEYUP message.

<A NAME="160"><h2>Shift States</h2></A>
<p>When you process a keystroke message, you may need to know whether any of the shift keys (Shift, Ctrl, and Alt) or toggle keys (Caps Lock, Num Lock, and Scroll Lock) are pressed. You can obtain this information by calling the <I>GetKeyState</I> function. For instance:

<p><pre>
iState = GetKeyState (VK_SHIFT) ;
</PRE>

<p>The <I>iState</I> variable will be negative (that is, the high bit is set) if the Shift key is down. The value returned from

<p><pre>
iState = GetKeyState (VK_CAPITAL) ;
</PRE>

<p>has the low bit set if the Caps Lock key is toggled on. This bit will agree with the little light on the keyboard.

<p>Generally, you'll use <I>GetKeyState</I> with the virtual key codes VK_SHIFT, VK_CONTROL, and VK_MENU (which you'll recall indicates the Alt key). You can also use the following identifiers with <I>GetKeyState</I> to determine if the left or right Shift, Ctrl, or Alt keys are pressed: VK_LSHIFT, VK_RSHIFT, VK_LCONTROL, VK_RCONTROL, VK_LMENU, VK_RMENU. These identifiers are used <I>only</I> with <I>GetKeyState</I> and <I>GetAsyncKeyState</I> (described below).

<p>You can also obtain the state of the mouse buttons using the virtual key codes VK_LBUTTON, VK_RBUTTON, and VK_MBUTTON. However, most Windows programs that need to monitor a combination of mouse buttons and keystrokes usually do it the other way around&#8212;by checking keystrokes when they receive a mouse message. In fact, shift-state information is conveniently included in the mouse messages, as we'll see in the next chapter.

<p>Be careful with <I>GetKeyState</I>. It is not a real-time keyboard status check. Rather, it reflects the keyboard status up to and including the current message being processed. For the most part, this is exactly what you want. If you need to determine if the user typed Shift-Tab, you can call <I>GetKeyState</I> with the VK_SHIFT parameter while processing the WM_KEYDOWN message for the Tab key. If the return value of <I>GetKeyState</I> is negative, you know that the Shift key was pressed <I>before</I> the Tab key. And it doesn't matter if the Shift key has already been released by the time you get around to processing the Tab key. You know that the Shift key was down when Tab was pressed.

<p><I>GetKeyState</I> does not let you retrieve keyboard information independent of normal keyboard messages. For instance, you may feel a need to hold up processing in your window procedure until the user presses the F1 function key:

<p><pre>
while (GetKeyState (VK_F1) &gt;= 0) ;    // WRONG !!!
</PRE>

<p>Don't do it! This is guaranteed to hang your program (unless, of course, the WM_KEYDOWN message for F1 was retrieved from the message queue before you executed the statement). If you really need to know the current real-time state of a key, you can use <I>GetAsyncKeyState</I>.

<A NAME="161"><h2>Using Keystroke Messages</h2></A>
<p>A Windows program gets information about each and every keystroke that occurs while the program is running. This is certainly helpful. However, most Windows programs ignore all but a few keystroke messages. The WM_SYSKEYDOWN and WM_SYSKEYUP messages are for Windows system functions, and you don't need to look at them. If you process WM_KEYDOWN messages, you can usually also ignore WM_KEYUP messages.

<p>Windows programs generally use WM_KEYDOWN messages for keystrokes that do not generate characters. Although you may think that it's possible to use keystroke messages in combination with shift-state information to translate keystroke messages into characters, don't do it. You'll have problems with non-English keyboards. For example, if you get a WM_KEYDOWN message with <I>wParam</I> equal to 0x33, you know the user pressed the 3 key. So far, so good. If you use <I>GetKeyState</I> and find out that the Shift key is down, you might assume that the user is typing a pound sign (#). Not necessarily. A British user is typing another type of pound sign, the one that looks like this: &#163;.

<p>The WM_KEYDOWN messages are most useful for the cursor movement keys, the function keys, Insert, and Delete. However, Insert, Delete, and the function keys often appear as menu accelerators. Because Windows translates menu accelerators into menu command messages, you don't have to process the keystrokes themselves.

<p>It was common for pre-Windows applications for MS-DOS to use the function keys extensively in combination with the Shift, Ctrl, and Alt keys. You can do something similar in your Windows programs (indeed, Microsoft Word uses the function keys extensively as command short cuts), but it's not really recommended. If you want to use the function keys, they should duplicate menu commands. One objective in Windows is to provide a user interface that doesn't require memorization or consultation of complex command charts.

<p>So, it comes down to this: Most of the time, you will process WM_KEYDOWN messages only for cursor movement keys, and sometimes for Insert and Delete. When you use these keys, you can check the Shift-key and Ctrl-key states through <I>GetKeyState</I>. Windows programs often use the Shift key in combination with the cursor keys to extend a selection in (for instance) a word-processing document. The Ctrl key is often used to alter the meaning of the cursor key. For example, Ctrl in combination with the Right Arrow key might mean to move the cursor one word to the right.

<p>One of the best ways to determine how to use the keyboard in your application is to examine how the keyboard is used in existing popular Windows programs. If you don't like those definitions, you are free to do something different. But keep in mind that doing so might be detrimental to a user's ability to learn your program quickly.

<A NAME="162"><h2>Enhancing SYSMETS for the Keyboard</h2></A>
<p>The three versions of the SYSMETS program in <a href="ch04a.htm#62">Chapter 4</a> were written without any knowledge of the keyboard. We were able to scroll the text only by using the mouse on the scroll bars. Now that we know how to process keystroke messages, let's add a keyboard interface to the program. This is obviously a job for cursor movement keys. We'll use most of these keys (Home, End, Page Up, Page Down, Up Arrow, and Down Arrow) for vertical scrolling. The Left Arrow and Right Arrow keys can take care of the less important horizontal scrolling.

<p>One obvious way to create a keyboard interface is to add some WM_KEYDOWN logic to the window procedure that parallels and essentially duplicates all the WM_VSCROLL and WM_HSCROLL logic. However, this is unwise, because if we ever wanted to change the scroll bar logic we'd have to make the same changes in WM_KEYDOWN.

<p>Wouldn't it be better to simply translate each of these WM_KEYDOWN messages into an equivalent WM_VSCROLL or WM_HSCROLL message? Then we could perhaps fool <I>WndProc</I> into thinking that it's getting a scroll bar message, perhaps by sending a phony message to the window procedure.


<p>Windows lets you do this. The function is named <I>SendMessage</I>, and it takes the same parameters as those passed to the window procedure:

<p><pre>
SendMessage (hwnd, message, wParam, lParam) ;
</PRE>

<p>When you call <I>SendMessage</I>, Windows calls the window procedure whose window handle is <I>hwnd</I>, passing to it these four function arguments. When the window procedure has completed processing the message, Windows returns control to the next statement following the <I>SendMessage</I> call. The window procedure you send the message to could be the same window procedure, another window procedure in the same program, or even a window procedure in another application.

<p>Here's how we might use <I>SendMessage</I> for processing WM_KEYDOWN codes in the SYSMETS program:

<p><pre>
case WM_KEYDOWN:
     switch (wParam)
     {
     case VK_HOME:
          SendMessage (hwnd, WM_VSCROLL, SB_TOP, 0) ;
          break ;

     case VK_END:
          SendMessage (hwnd, WM_VSCROLL, SB_BOTTOM, 0) ;
          break ;

     case VK_PRIOR:
          SendMessage (hwnd, WM_VSCROLL, SB_PAGEUP, 0) ;
          break ;
</PRE>

<p>And so forth. You get the general idea. Our goal was to add a keyboard interface to the scroll bars, and that's exactly what we've done. We've made the cursor movement keys duplicate scroll bar logic by actually sending the window procedure a scroll bar message. Now you can see why I included SB_TOP and SB_BOTTOM processing for WM_VSCROLL messages in the SYSMETS3 program. It wasn't used then, but it's used now for processing the Home and End keys. The SYSMETS4 program, shown in Figure 6-2, incorporates these changes. You'll also need the SYSMETS.H file from <a href="ch04a.htm#62">Chapter 4</a> to compile this program.

<p><B>Figure 6-2.</B> <I>The SYSMETS4 program.</I>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="163"><H3>SYSMETS4.C</H3></A>
<pre>

/*----------------------------------------------------
   SYSMETS4.C -- System Metrics Display Program No. 4
                 (c) Charles Petzold, 1998
  ----------------------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;sysmets.h&quot;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;SysMets4&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;Program requires Windows NT!&quot;), 
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Get System Metrics No. 4&quot;),
                          WS_OVERLAPPEDWINDOW | WS_VSCROLL | WS_HSCROLL,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}
LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static int  cxChar, cxCaps, cyChar, cxClient, cyClient, iMaxWidth ;
     HDC         hdc ;
     int         i, x, y, iVertPos, iHorzPos, iPaintBeg, iPaintEnd ;
     PAINTSTRUCT ps ;
     SCROLLINFO  si ;
     TCHAR       szBuffer[10] ;
     TEXTMETRIC  tm ;
     
     switch (message)
     {
     case WM_CREATE:
          hdc = GetDC (hwnd) ;
          
          GetTextMetrics (hdc, &amp;tm) ;
          cxChar = tm.tmAveCharWidth ;
          cxCaps = (tm.tmPitchAndFamily &amp; 1 ? 3 : 2) * cxChar / 2 ;
          cyChar = tm.tmHeight + tm.tmExternalLeading ;
          
          ReleaseDC (hwnd, hdc) ;

               // Save the width of the three columns
          
          iMaxWidth = 40 * cxChar + 22 * cxCaps ;
          return 0 ;
          
     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;

               // Set vertical scroll bar range and page size

          si.cbSize = sizeof (si) ;
          si.fMask  = SIF_RANGE | SIF_PAGE ;
          si.nMin   = 0 ;
          si.nMax   = NUMLINES - 1 ;
          si.nPage  = cyClient / cyChar ;
          SetScrollInfo (hwnd, SB_VERT, &amp;si, TRUE) ;

               // Set horizontal scroll bar range and page size

          si.cbSize = sizeof (si) ;
          si.fMask  = SIF_RANGE | SIF_PAGE ;
          si.nMin   = 0 ;
          si.nMax   = 2 + iMaxWidth / cxChar ;
          si.nPage  = cxClient / cxChar ;
          SetScrollInfo (hwnd, SB_HORZ, &amp;si, TRUE) ;
          return 0 ;
          
     case WM_VSCROLL:
               // Get all the vertical scroll bar information

          si.cbSize = sizeof (si) ;
          si.fMask  = SIF_ALL ;
          GetScrollInfo (hwnd, SB_VERT, &amp;si) ;

               // Save the position for comparison later on

          iVertPos = si.nPos ;

          switch (LOWORD (wParam))
          {
          case SB_TOP:
               si.nPos = si.nMin ;
               break ;
               
          case SB_BOTTOM:
               si.nPos = si.nMax ;
               break ;
               
          case SB_LINEUP:
               si.nPos -= 1 ;
               break ;
               
          case SB_LINEDOWN:
               si.nPos += 1 ;
               break ;
               
          case SB_PAGEUP:
               si.nPos -= si.nPage ;
               break ;
               
          case SB_PAGEDOWN:
               si.nPos += si.nPage ;
               break ;
               
          case SB_THUMBTRACK:
               si.nPos = si.nTrackPos ;
               break ;
               
          default:
               break ;         
          }

               // Set the position and then retrieve it.  Due to adjustments
               //   by Windows it might not be the same as the value set.

          si.fMask = SIF_POS ;
          SetScrollInfo (hwnd, SB_VERT, &amp;si, TRUE) ;
          GetScrollInfo (hwnd, SB_VERT, &amp;si) ;

               // If the position has changed, scroll the window and update it

          if (si.nPos != iVertPos)
          {                    
               ScrollWindow (hwnd, 0, cyChar * (iVertPos - si.nPos), 
                                   NULL, NULL) ;
               UpdateWindow (hwnd) ;
          }
          return 0 ;
          
     case WM_HSCROLL:
               // Get all the vertical scroll bar information

          si.cbSize = sizeof (si) ;
          si.fMask  = SIF_ALL ;

               // Save the position for comparison later on

          GetScrollInfo (hwnd, SB_HORZ, &amp;si) ;
          iHorzPos = si.nPos ;

          switch (LOWORD (wParam))
          {
          case SB_LINELEFT:
               si.nPos -= 1 ;
               break ;
               
          case SB_LINERIGHT:
               si.nPos += 1 ;
               break ;
               
          case SB_PAGELEFT:
               si.nPos -= si.nPage ;
               break ;
               
          case SB_PAGERIGHT:
               si.nPos += si.nPage ;
               break ;
               
          case SB_THUMBPOSITION:
               si.nPos = si.nTrackPos ;
               break ;
               
          default:
               break ;
          }
               // Set the position and then retrieve it.  Due to adjustments
               //   by Windows it might not be the same as the value set.

          si.fMask = SIF_POS ;
          SetScrollInfo (hwnd, SB_HORZ, &amp;si, TRUE) ;
          GetScrollInfo (hwnd, SB_HORZ, &amp;si) ;
          
               // If the position has changed, scroll the window 

          if (si.nPos != iHorzPos)
          {
               ScrollWindow (hwnd, cxChar * (iHorzPos - si.nPos), 0, 
                             NULL, NULL) ;
          }
          return 0 ;

     case WM_KEYDOWN:
          switch (wParam)
          {
          case VK_HOME:
               SendMessage (hwnd, WM_VSCROLL, SB_TOP, 0) ;
               break ;
               
          case VK_END:
               SendMessage (hwnd, WM_VSCROLL, SB_BOTTOM, 0) ;
               break ;
               
          case VK_PRIOR:
               SendMessage (hwnd, WM_VSCROLL, SB_PAGEUP, 0) ;
               break ;
               
          case VK_NEXT:
               SendMessage (hwnd, WM_VSCROLL, SB_PAGEDOWN, 0) ;
               break ;
               
          case VK_UP:
               SendMessage (hwnd, WM_VSCROLL, SB_LINEUP, 0) ;
               break ;

          case VK_DOWN:
               SendMessage (hwnd, WM_VSCROLL, SB_LINEDOWN, 0) ;
               break ;
               
          case VK_LEFT:
               SendMessage (hwnd, WM_HSCROLL, SB_PAGEUP, 0) ;
               break ;
               
          case VK_RIGHT:
               SendMessage (hwnd, WM_HSCROLL, SB_PAGEDOWN, 0) ;
               break ;
          }
          return 0 ;

     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;

               // Get vertical scroll bar position

          si.cbSize = sizeof (si) ;
          si.fMask  = SIF_POS ;
          GetScrollInfo (hwnd, SB_VERT, &amp;si) ;
          iVertPos = si.nPos ;

               // Get horizontal scroll bar position

          GetScrollInfo (hwnd, SB_HORZ, &amp;si) ;
          iHorzPos = si.nPos ;

               // Find painting limits

          iPaintBeg = max (0, iVertPos + ps.rcPaint.top / cyChar) ;
          iPaintEnd = min (NUMLINES - 1,
                           iVertPos + ps.rcPaint.bottom / cyChar) ;
          
          for (i = iPaintBeg ; i &lt;= iPaintEnd ; i++)
          {
               x = cxChar * (1 - iHorzPos) ;
               y = cyChar * (i - iVertPos) ;
               
               TextOut (hdc, x, y,
                        sysmetrics[i].szLabel,
                        lstrlen (sysmetrics[i].szLabel)) ;
               
               TextOut (hdc, x + 22 * cxCaps, y,
                        sysmetrics[i].szDesc,
                        lstrlen (sysmetrics[i].szDesc)) ;
               
               SetTextAlign (hdc, TA_RIGHT | TA_TOP) ;
               
               TextOut (hdc, x + 22 * cxCaps + 40 * cxChar, y, szBuffer,
                        wsprintf (szBuffer, TEXT (&quot;%5d&quot;),
                             GetSystemMetrics (sysmetrics[i].iIndex))) ;
               
               SetTextAlign (hdc, TA_LEFT | TA_TOP) ;
          }

          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

</BODY>
</HTML>





