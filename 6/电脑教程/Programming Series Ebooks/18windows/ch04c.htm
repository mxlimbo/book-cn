<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>An Introduction to GDI</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="66"><H1>An Introduction to GDI</H1></A>
<p>To paint the client area of your window, you use Windows' Graphics Device Interface (GDI) functions. Windows provides several GDI functions for writing text strings to the client area of the window. We've already encountered the <I>DrawText</I> function in the last chapter, but the most commonly used text output function is undoubtedly <I>TextOut</I>. This function has the following format:

<p><pre>
TextOut (hdc, x, y, psText, iLength) ;
</PRE>

<p><I>TextOut</I> writes a character string to the client area of the window. The <I>psText</I> argument is a pointer to the character string, and <I>iLength</I> is the length of the string in characters. The <I>x</I> and <I>y</I> arguments define the starting position of the character string in the client area. (More details soon on how these work.) The <I>hdc</I> argument is a &quot;handle to a device context,&quot; and it is an important part of GDI. Virtually every GDI function requires this handle as the first argument to the function.

<A NAME="67"><h2>The Device Context</h2></A>
<p>A handle, you'll recall, is simply a number that Windows uses for internal reference to an object. You obtain the handle from Windows and then use the handle in other functions. The device context handle is your window's passport to the GDI functions. With that device context handle you are free to paint your client area and make it as beautiful or as ugly as you like.

<p>The device context (also called simply the &quot;DC&quot;) is really just a data structure maintained internally by GDI. A device context is associated with a particular display device, such as a video display or a printer. For a video display, a device context is usually associated with a particular window on the display.

<p>Some of the values in the device context are graphics &quot;attributes.&quot; These attributes define some particulars of how GDI drawing functions work. With <I>TextOut</I>, for instance, the attributes of the device context determine the color of the text, the color of the text background, how the x-coordinate and y-coordinate in the <I>TextOut</I> function are mapped to the client area of the window, and what font Windows uses when displaying the text.

<p>When a program needs to paint, it must first obtain a handle to a device context. When you obtain this handle, Windows fills the internal device context structure with default attribute values. As you'll see in later chapters, you can change these defaults by calling various GDI functions. Other GDI functions let you obtain the current values of these attributes. Then, of course, there are still other GDI functions that let you actually paint the client area of the window.

<p>After a program has finished painting its client area, it should release the device context handle. When a program releases the handle, the handle is no longer valid and must not be used. The program should obtain the handle and release the handle during the processing of a single message. Except for a device context created with a call to <I>CreateDC</I> (a function I won't discuss in this chapter), you should not keep a device context handle around from one message to another.

<p>Windows applications generally use two methods for getting a device context handle in preparation for painting the screen.

<A NAME="68"><h2>Getting a Device Context Handle: Method One</h2></A>
<p>You use this method when you process WM_PAINT messages. Two functions are involved: <I>BeginPaint</I> and <I>EndPaint</I>. These two functions require the handle to the window, which is passed to the window procedure as an argument, and the address of a structure variable of type PAINTSTRUCT, which is defined in the WINUSER.H header file. Windows programmers usually name this structure variable <I>ps</I> and define it within the window procedure like so:

<p><pre>
PAINTSTRUCT ps ;
</PRE>

<p>While processing a WM_PAINT message, the window procedure first calls <I>BeginPaint</I>. The <I>BeginPaint</I> function generally causes the background of the invalid region to be erased in preparation for painting. The function also fills in the fields of the <I>ps</I> structure. The value returned from <I>BeginPaint</I> is the device context handle. This is commonly saved in a variable named <I>hdc</I>. You define this variable in your window procedure like so:

<p><pre>
HDC hdc ;
</PRE>

<p>The HDC data type is defined as a 32-bit unsigned integer. The program may then use GDI functions, such as <I>TextOut</I>, that require the handle to the device context. A call to <I>EndPaint</I> releases the device context handle.

<p>Typically, processing of the WM_PAINT message looks like this:

<p><pre>
case WM_PAINT:
     hdc = BeginPaint (hwnd, &amp;ps) ;
          <I>[use GDI functions]</I>
     EndPaint (hwnd, &amp;ps) ;
     return 0 ;
</PRE>

<p>The window procedure must call <I>BeginPaint</I> and <I>EndPaint</I> as a pair while processing the WM_PAINT message. If a window procedure does not process WM_PAINT messages, it must pass the WM_PAINT message to <I>DefWindowProc</I>, which is the default window procedure located in Windows. <I>DefWindowProc</I> processes WM_PAINT messages with the following code:

<p><pre>
case WM_PAINT:
     BeginPaint (hwnd, &amp;ps) ;
     EndPaint (hwnd, &amp;ps) ;
     return 0 ;
</PRE>

<p>The sequence of <I>BeginPaint</I> and <I>EndPaint</I> calls with nothing in between validates the previously invalid region.

<p>But don't do this:

<p><pre>
case WM_PAINT:
     return 0 ;   // WRONG !!!
</PRE>

<p>Windows places a WM_PAINT message in the message queue because part of the client area is invalid. Unless you call <I>BeginPaint</I> and <I>EndPaint</I> (or <I>ValidateRect</I>), Windows will not validate that area. Instead, Windows will send you another WM_PAINT message, and another, and another, and another&#8230;.

<A NAME="69"><h2>The Paint Information Structure</h2></A>
<p>Earlier I mentioned a &quot;paint information structure&quot; that Windows maintains for each window. That's what PAINTSTRUCT is. The structure is defined as follows:

<p><pre>
typedef struct tagPAINTSTRUCT
{
     HDC       hdc ;
     BOOL      fErase ;
     RECT      rcPaint ;
     BOOL      fRestore ;
     BOOL      fIncUpdate ;
     BYTE      rgbReserved[32] ;
} PAINTSTRUCT ;
</PRE>

<p>Windows fills in the fields of this structure when your program calls <I>BeginPaint</I>. Your program can use only the first three fields. The others are used internally by Windows. The <I>hdc</I> field is the handle to the device context. In a redundancy typical of Windows, the value returned from <I>BeginPaint</I> is also this device context handle. In most cases, <I>fErase</I> will be flagged FALSE (0), meaning that Windows has already erased the background of the invalid rectangle. This happens earlier in the <I>BeginPaint</I> function. (If you want to do some customized background erasing in your window procedure, you can process the WM_ERASEBKGND message.) Windows erases the background using the brush specified in the <I>hbrBackground</I> field of the WNDCLASS structure that you use when registering the window class during <I>WinMain</I> initialization. Many Windows programs specify a white brush for the window background. This is indicated when the program sets up the fields of the window class structure with a statement like this:

<p><pre>
wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
</PRE>

<p>However, if your program invalidates a rectangle of the client area by calling <I>InvalidateRect</I>, the last argument of the function specifies whether you want the background erased. If this argument is FALSE (that is, 0), Windows will not erase the background and the <I>fErase</I> field of the PAINTSTRUCT structure will be TRUE (nonzero) after you call <I>BeginPaint</I>.

<p>The <I>rcPaint</I> field of the PAINTSTRUCT structure is a structure of type RECT. As you learned in <a href="ch03a.htm#38">Chapter 3</a>, the RECT structure defines a rectangle with four fields named <I>left</I>, <I>top</I>, <I>right</I>, and <I>bottom</I>. The <I>rcPaint</I> field in the PAINTSTRUCT structure defines the boundaries of the invalid rectangle, as shown in Figure 4-1. The values are in units of pixels relative to the upper left corner of the client area. The invalid rectangle is the area that you should repaint.

<p><img src="F04zg01.JPG" width=404 height=297 ALIGN="BOTTOM">

<p><!-- caption --><B>Figure 4-1.</B> <I>The boundaries of the invalid rectangle.</I><!-- /caption -->


<p>The <I>rcPaint</I> rectangle in PAINTSTRUCT is not only the invalid rectangle; it is also a &quot;clipping&quot; rectangle. This means that Windows restricts painting to within the clipping rectangle. More precisely, if the invalid region is not rectangular, Windows restricts painting to within that region.

<p>To paint outside the update rectangle while processing WM_PAINT messages, you can make this call:

<p><pre>
InvalidateRect (hwnd, NULL, TRUE) ;
</PRE>

<p>before calling <I>BeginPaint</I>. This invalidates the entire client area and causes <I>BeginPaint</I> to erase the background. A FALSE value in the last argument will not erase the background. Whatever was there will stay.

<p>It is usually most convenient for a Windows program to simply repaint the entire client area whenever it receives a WM_PAINT message, regardless of the <I>rcPaint</I> structure. For example, if part of the display output in the client area includes a circle but only part of the circle falls within the invalid rectangle, it makes little sense to draw only the invalid part of the circle. Draw the whole circle. When you use the device context handle returned from <I>BeginPaint</I>, Windows will not paint outside the <I>rcPaint</I> rectangle anyway.

<p>In the HELLOWIN program in <a href="ch02a.htm#18">Chapter 2</a>, we didn't care about invalid rectangles when processing the WM_PAINT message. If the area where the text was displayed happened to be within the invalid rectangle, <I>DrawText</I> restored it. If not, then at some point during processing of the <I>DrawText</I> call Windows determined it didn't need to write anything on the display. But this determination takes time. A programmer concerned about performance and speed (and that includes all of us, I hope) will want to use the invalid rectangle during processing of the WM_PAINT message to avoid unnecessary GDI calls. This is particularly important if painting requires accessing disk files such as bitmaps.

<A NAME="70"><h2>Getting a Device Context Handle: Method Two</h2></A>
<p>Although it is best to structure your program so that you can update the entire client area during the WM_PAINT message, you may also find it useful to paint part of the client area while processing messages other than WM_PAINT. Or you may need a device context handle for other purposes, such as obtaining information about the device context.

<p>To get a handle to the device context of the client area of the window, you call <I>GetDC</I> to obtain the handle and <I>ReleaseDC</I> after you're done with it:


<p><pre>
hdc = GetDC (hwnd) ;
<I>[use GDI functions]</I>
ReleaseDC (hwnd, hdc) ;
</PRE>

<p>Like <I>BeginPaint</I> and <I>EndPaint</I>, the <I>GetDC</I> and <I>ReleaseDC</I> functions should be called in pairs. When you call <I>GetDC</I> while processing a message, you should call <I>ReleaseDC</I> before you exit the window procedure. Do not call <I>GetDC</I> in one message and <I>ReleaseDC</I> in another.

<p>Unlike the device context handle returned from <I>BeginPaint</I>, the device context handle returned from <I>GetDC</I> has a clipping rectangle equal to the entire client area. You can paint on any part of the client area, not merely on the invalid rectangle (if indeed there is an invalid rectangle). Unlike <I>BeginPaint</I>, <I>GetDC</I> does not validate any invalid regions. If you need to validate the entire client area, you can call

<p><pre>
ValidateRect (hwnd, NULL) ;
</PRE>

<p>Generally, you'll use the <I>GetDC</I> and <I>ReleaseDC</I> calls in response to keyboard messages (such as in a word processing program) or mouse messages (such as in a drawing program). This allows the program to draw on the client area in prompt reaction to the user's keyboard or mouse input without deliberately invalidating part of the client area to generate WM_PAINT messages. However, even if you paint during messages other than WM_PAINT, your program must still accumulate enough information to be able to update the display whenever you do receive a WM_PAINT message.

<p>A function similar to <I>GetDC</I> is <I>GetWindowDC</I>. While <I>GetDC</I> returns a device context handle for writing on the client area of the window, <I>GetWindowDC</I> returns a device context handle that lets you write on the entire window. For example, your program can use the device context handle returned from <I>GetWindowDC</I> to write on the window's title bar. However, your program would also have to process WM_NCPAINT (&quot;nonclient paint&quot;) messages as well.


<A NAME="71"><h2><I>TextOut</I>: The Details</h2></A>
<p><I>TextOut</I> is the most common GDI function for displaying text. Its syntax is

<p><pre>
TextOut (hdc, x, y, psText, iLength) ;
</PRE>

<p>Let's examine this function in more detail.

<p>The first argument is the handle to the device context&#8212;either the <I>hdc</I> value returned from <I>GetDC</I> or the <I>hdc</I> value returned from <I>BeginPaint</I> during processing of a WM_PAINT message.

<p>The attributes of the device context control the characteristics of this displayed text. For instance, one attribute of the device context specifies the text color. The default color (we discover with some degree of comfort) is black. The default device context also defines a text background color, and this is white. When a program writes text to the display, Windows uses this background color to fill in the rectangular space surrounding each character, called the &quot;character box.&quot;

<p>The text background color is not the same background you set when defining the window class. The background in the window class is a brush&#8212;which is a pattern that may or may not be a pure color&#8212;that Windows uses to erase the client area. It is not part of the device context structure. When defining the window class structure, most Windows applications use WHITE_BRUSH so that the default text background color in the default device context is the same color as the brush Windows uses to erase the background of the client area.

<p>The <I>psText</I> argument is a pointer to a character string, and <I>iLength</I> is the number of characters in the string. If <I>psText</I> points to a Unicode character string, then the number of bytes in the string is double the <I>iLength</I> value. The string should not contain any ASCII control characters such as carriage returns, linefeeds, tabs, or backspaces. Windows displays these control characters as boxes or solid blocks. <I>TextOut</I> does not recognize a zero byte (or for Unicode, a zero short integer) as denoting the end of a string. The function uses the <I>iLength</I> argument to determine the string's length.

<p>The <I>x</I> and <I>y</I> arguments to <I>TextOut</I> define the starting point of the character string within the client area. The <I>x</I> value is the horizontal position; the <I>y</I> value is the vertical position. The upper left corner of the first character is positioned at the coordinate point (<I>x</I>, <I>y</I>). In the default device context, the origin (that is, the point where <I>x</I> and <I>y</I> both equal 0) is the upper left corner of the client area. If you use zero values for <I>x</I> and <I>y</I> in <I>TextOut</I>, the character string starts flush against the upper left corner of the client area.

<p>When you read the documentation of a GDI drawing function such as <I>TextOut</I>, you'll find that the coordinates passed to the function are usually documented as &quot;logical coordinates.&quot; What this means exactly we'll examine in more detail in <a href="ch05a.htm#94">Chapter 5</a>. For now, be aware that Windows has a variety of &quot;mapping modes&quot; that govern how the logical coordinates specified in GDI drawing functions are translated to the physical pixel coordinates of the display. The mapping mode is defined in the device context. The default mapping mode is called MM_TEXT (using the identifier defined in the WINGDI.H header file). Under the MM_TEXT mapping mode, logical units are the same as physical units, which are pixels, relative to the upper left corner of the client area. Values of <I>x</I> increase as you move to the right in the client area, and values of <I>y</I> increase as you move down in the client area. (See Figure 4-2.) The MM_TEXT coordinate system is identical to the coordinate system that Windows uses to define the invalid rectangle in the PAINTSTRUCT structure. (Things are not quite as convenient with the other mapping modes, however.)

<p><img src="F04zg02.JPG" width=404 height=303 ALIGN="BOTTOM">

<p><!-- caption --><B>Figure 4-2.</B> <I>The x-coordinate and y-coordinate in the MM_TEXT mapping mode.</I><!-- /caption -->


<p>The device context also defines a clipping region. As you've seen, the default clipping region is the entire client area for a device context handle obtained from <I>GetDC</I> and the invalid region for the device context handle obtained from <I>BeginPaint</I>. When you call <I>TextOut</I>, Windows will not display any part of the character string that lies outside the clipping region. If a character is partly within the clipping region, Windows displays only the portion of the character inside the region. Writing outside the client area of your window isn't easy to do, so don't worry about doing it inadvertently.

<A NAME="72"><h2>The System Font</h2></A>
<p>The device context also defines the font that Windows uses when you call <I>TextOut</I> to display text. The default is a font called the &quot;system font&quot; or (using the identifier in the WINGDI.H header file) SYSTEM_FONT. The system font is the font that Windows uses by default for text strings in title bars, menus, and dialog boxes.

<p>In the early days of Windows, the system font was a fixed-pitch font, which means that all the characters had the same width, much like a typewriter. However, beginning with Windows 3.0, the system font became a variable-pitch font, which means that different characters have different widths. A &quot;W&quot; is wider than an &quot;i&quot;, for example. It has been well established by studies in reading that text printed with variable-pitch fonts is more readable than fixed-pitch font texts. It seems to have something to do with the letters being closer together, allowing the eyes and mind to more clearly see entire words rather than individual letters. As you might imagine, the change from fixed-pitch fonts to variable-pitch fonts broke a lot of early Windows code and required that programmers learn some new techniques for working with text.

<p>The system font is a &quot;raster font,&quot; which means that the characters are defined as blocks of pixels. (In <a href="ch17a.htm#600">Chapter 17</a>, we'll work with TrueType fonts, which are defined by scaleable outlines.) To a certain extent, the size of the characters in the system font is based on the size of the video display. The system font is designed to allow at least 25 lines of 80-character text to fit on the screen.

<A NAME="73"><h2>The Size of a Character</h2></A>
<p>To display multiple lines of text by using the <I>TextOut</I> function, you need to know the dimensions of characters in the font. You can space successive lines of text based on the height of the characters, and you can space columns of text across the client area based on the average width of the characters.

<p>What is the height and average width of characters in the system font? Well, I'm not going to tell you. Or rather, I <I>can't</I> tell you. Or rather, I could tell you, but I might be wrong. The problem is that it all depends on the pixel size of the video display. Windows requires a minimum display size of 640 by 480, but many users prefer 800 by 600 or 1024 by 768. In addition, for these larger display sizes, Windows allows the user to select different sized system fonts.


<p>Just as a program can determine information about the sizes (or &quot;metrics&quot;) of user interface items by calling the <I>GetSystemMetrics</I> function, a program can determine font sizes by calling <I>GetTextMetrics</I>. <I>GetTextMetrics</I> requires a handle to a device context because it returns information about the font currently selected in the device context. Windows copies the various values of text metrics into a structure of type TEXTMETRIC defined in WINGDI.H. The TEXTMETRIC structure has 20 fields, but we're interested in only the first seven:

<p><pre>
typedef struct tagTEXTMETRIC
{
     LONG tmHeight ; 
     LONG tmAscent ; 
     LONG tmDescent ;  
     LONG tmInternalLeading ; 
     LONG tmExternalLeading ; 
     LONG tmAveCharWidth ; 
     LONG tmMaxCharWidth ; 
<I>          [other structure fields]</I>
}
TEXTMETRIC, * PTEXTMETRIC ;
</PRE>

<p>The values of these fields are in units that depend on the mapping mode currently selected for the device context. In the default device context, this mapping mode is MM_TEXT, so the dimensions are in units of pixels.

<p>To use the <I>GetTextMetrics</I> function, you first need to define a structure variable, commonly called <I>tm</I>:

<p><pre>
TEXTMETRIC tm ;
</PRE>

<p>When you need to determine the text metrics, you get a handle to a device context and call <I>GetTextMetrics</I>:

<p><pre>
hdc = GetDC (hwnd) ;
GetTextMetrics (hdc, &amp;tm) ;
ReleaseDC (hwnd, hdc) ;
</PRE>

<p>You can then examine the values in the text metric structure and probably save a few of them for future use.

<A NAME="74"><h2>Text Metrics: The Details</h2></A>
<p>The TEXTMETRIC structure provides various types of information about the font currently selected in the device context. However, the vertical size of a font is defined by only five fields of the structure, four of which are shown in Figure 4-3.

<p><A HREF="javascript:fullSize('F04zg03x.htm')"><img src="F04zg03.JPG" width=404 height=248 ALIGN="BOTTOM" border=0 ALT="Click to view at full size."></a>

<p><!-- caption --><B>Figure 4-3.</B> <I>Four values defining vertical character sizes in a font.</I><!-- /caption -->

<p>The most important value is <I>tmHeight</I>, which is the sum of <I>tmAscent</I> and <I>tmDescent</I>. These two values represent the maximum vertical extents of characters in the font above and below the baseline. The term &quot;leading&quot; refers to space that a printer inserts between lines of text. In the TEXTMETRIC structure, internal leading is included in <I>tmAscent</I> (and thus in <I>tmHeight</I>) and is often the space in which accent marks appear. The <I>tmInternalLeading</I> field could be set to 0, in which case accented letters are made a little shorter so that the accent marks fit within the ascent of the character.

<p>The TEXTMETRIC structure also includes a field named <I>tmExternalLeading</I>, which is not included in the <I>tmHeight</I> value. This is an amount of space that the designer of the font suggests be added between successive rows of displayed text. You can accept or reject the font designer's suggestion for including external leading when spacing lines of text. In the system fonts that I've encountered recently, <I>tmExternalLeading</I> has been zero, which is why I didn't include it in Figure 4-3. (Despite my vow not to tell you the dimensions of a system font, Figure 4-3 is accurate for the system font that Windows uses by default for a 640 by 480 display.)

<p>The TEXTMETRIC structure contains two fields that describe character widths: the <I>tmAveCharWidth</I> field is a weighted average of lowercase characters, and <I>tmMaxCharWidth</I> is the width of the widest character in the font. For a fixed-pitch font, these values are the same. (For the font illustrated in Figure 4-3, these values are 7 and 14, respectively.)

<p>The sample programs in this chapter will require another character width&#8212;the average width of uppercase letters. You can calculate this fairly accurately as 150% of <I>tmAveCharWidth</I>.

<p>It's important to realize that the dimensions of a system font are dependent on the pixel size of the video display on which Windows runs and, in some cases, on the system font size the user has selected. Windows provides a device-independent graphics interface, but you have to help. Don't write your Windows programs so that they guess at character dimensions. Don't hard-code any values. Use the <I>GetTextMetrics</I> function to obtain this information.

<A NAME="75"><h2>Formatting Text</h2></A>
<p>Because the dimensions of the system font do not change during a Windows session, you need to call <I>GetTextMetrics</I> only once when your program executes. A good place to make this call is while processing the WM_CREATE message in the window procedure. The WM_CREATE message is the first message the window procedure receives. Windows calls your window procedure with a WM_CREATE message when you call <I>CreateWindow</I> in <I>WinMain</I>.

<p>Suppose you're writing a Windows program that displays several lines of text running down the client area. You'll want to obtain values for the character width and height. Within the window procedure you can define two variables to save the average character width (<I>cxChar</I>) and the total character height (<I>cyChar</I>):

<p><pre>
static int cxChar, cyChar ;
</PRE>

<p>The prefix <I>c</I> added to the variables names stands for &quot;count,&quot; and in this case means a count of (or number of) pixels. In combination with <I>x</I> or <I>y</I>, the prefix refers to a width or height. These variables are defined as <I>static</I> because they must be valid when the window procedure processes other messages, such as WM_PAINT. Or you can define the variables globally outside of any function.

<p>Here's the WM_CREATE code to obtain the width and height of characters in the system font:

<p><pre>
case WM_CREATE:
     hdc = GetDC (hwnd) ;

     GetTextMetrics (hdc, &amp;tm) ;
     cxChar = tm.tmAveCharWidth ;
     cyChar = tm.tmHeight + tm.tmExternalLeading ;

     ReleaseDC (hwnd, hdc) ;
     return 0 ;
</PRE>

<p>Notice that I've included the <I>tmExternalLeading</I> field in the calculation of <I>cyChar</I>. Even though this field is 0 in the system fonts I've seen lately, it should be included if it's ever nonzero because it makes for more readable line spacing. Each successive line of text is displayed <I>cyChar</I> pixels further down the window.

<p>You'll often find it necessary to display formatted numbers as well as simple character strings. As I discussed in <a href="ch02a.htm#18">Chapter 2</a>, you can't use the traditional tool for this job (the beloved <I>printf</I> function), but you can use <I>sprintf</I> and the Windows version of <I>sprintf</I>, <I>wsprintf</I>. These functions work just like <I>printf</I> except that they put the formatted string into a character string. You can then use <I>TextOut</I> to write the string to the display. Very conveniently, the value returned from <I>sprintf</I> and <I>wsprintf</I> is the length of the string. You can pass that value to <I>TextOut</I> as the <I>iLength</I> argument. This code shows a typical <I>wsprintf</I> and <I>TextOut</I> combination:

<p><pre>
int   iLength ;
TCHAR szBuffer [40] ;
<I>[ other program lines ]</I>
iLength = wsprintf (szBuffer, TEXT (&quot;The sum of %i and %i is %i&quot;),
                    iA, iB, iA + iB) ;
TextOut (hdc, x, y, szBuffer, iLength) ;
</PRE>

<p>For something as simple as this, you could dispense with the <I>iLength</I> definition and combine the two statements into one:

<p><pre>
TextOut (hdc, x, y, szBuffer,
         wsprintf (szBuffer, TEXT (&quot;The sum of %i and %i is %i&quot;),
                   iA, iB, iA + iB)) ; 
</PRE>

<p>It ain't pretty, but it works.

<A NAME="76"><h2>Putting It All Together</h2></A>
<p>Now we seem to have everything we need to write a simple program that displays multiple lines of text on the screen. We know how to get a handle to a device context during the WM_PAINT message, how to use the <I>TextOut</I> function, and how to space text based on the size of a single character. The only thing left for us to do is to display something interesting.

<p>In the previous chapter, we took a little peek at the interesting information available from the Windows <I>GetSystemMetrics</I> function. The function returns information about the size of various graphical items in Windows, such as icons, cursors, title bars, and scroll bars. These sizes vary with the display adapter and driver. <I>GetSystemMetrics</I> is an important function for achieving device-independent graphical output in your program.

<p>The function requires a single argument called an &quot;index.&quot; The index is one of 75 integer identifiers defined in the Windows header files. (The number of identifiers has increased with each release of Windows; the programmer's documentation in Windows 1.0 listed only 26 of them.) <I>GetSystemMetrics</I> returns an integer, usually the size of the item specified in the argument.

<p>Let's write a program that displays some of the information available from the <I>GetSystemMetrics</I> calls in a simple one-line-per-item format. Working with this information is easier if we create a header file that defines an array of structures containing both the Windows header-file identifiers for the <I>GetSystemMetrics</I> index and the text we want to display for each value returned from the call. This header file is called SYSMETS.H and is shown in Figure 4-4.

<P><B>Figure 4-4.</B> <I>The SYSMETS.H file.</I>
<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="77"><H3>SYSMETS.H</H3></A>
<p><pre>
/*-----------------------------------------------
   SYSMETS.H -- System metrics display structure
  -----------------------------------------------*/

#define NUMLINES ((int) (sizeof sysmetrics / sizeof sysmetrics [0]))

struct
{
     int     iIndex ;
     TCHAR * szLabel ;
     TCHAR * szDesc ;
}
sysmetrics [] =
{
     SM_CXSCREEN,             TEXT (&quot;SM_CXSCREEN&quot;),              
                              TEXT (&quot;Screen width in pixels&quot;),
     SM_CYSCREEN,             TEXT (&quot;SM_CYSCREEN&quot;),              
                              TEXT (&quot;Screen height in pixels&quot;),
     SM_CXVSCROLL,            TEXT (&quot;SM_CXVSCROLL&quot;),             
                              TEXT (&quot;Vertical scroll width&quot;),
     SM_CYHSCROLL,            TEXT (&quot;SM_CYHSCROLL&quot;),             
                              TEXT (&quot;Horizontal scroll height&quot;),
     SM_CYCAPTION,            TEXT (&quot;SM_CYCAPTION&quot;),             
                              TEXT (&quot;Caption bar height&quot;),
     SM_CXBORDER,             TEXT (&quot;SM_CXBORDER&quot;),              
                              TEXT (&quot;Window border width&quot;),
     SM_CYBORDER,             TEXT (&quot;SM_CYBORDER&quot;),              
                              TEXT (&quot;Window border height&quot;),
     SM_CXFIXEDFRAME,         TEXT (&quot;SM_CXFIXEDFRAME&quot;),          
                              TEXT (&quot;Dialog window frame width&quot;),
     SM_CYFIXEDFRAME,         TEXT (&quot;SM_CYFIXEDFRAME&quot;),          
                              TEXT (&quot;Dialog window frame height&quot;),
     SM_CYVTHUMB,             TEXT (&quot;SM_CYVTHUMB&quot;),              
                              TEXT (&quot;Vertical scroll thumb height&quot;),
     SM_CXHTHUMB,             TEXT (&quot;SM_CXHTHUMB&quot;),              
                              TEXT (&quot;Horizontal scroll thumb width&quot;),
     SM_CXICON,               TEXT (&quot;SM_CXICON&quot;),                
                              TEXT (&quot;Icon width&quot;),
     SM_CYICON,               TEXT (&quot;SM_CYICON&quot;),                
                              TEXT (&quot;Icon height&quot;),
     SM_CXCURSOR,             TEXT (&quot;SM_CXCURSOR&quot;),              
                              TEXT (&quot;Cursor width&quot;),
     SM_CYCURSOR,             TEXT (&quot;SM_CYCURSOR&quot;),              
                              TEXT (&quot;Cursor height&quot;),
     SM_CYMENU,               TEXT (&quot;SM_CYMENU&quot;),                
                              TEXT (&quot;Menu bar height&quot;),
     SM_CXFULLSCREEN,         TEXT (&quot;SM_CXFULLSCREEN&quot;),          
                              TEXT (&quot;Full screen client area width&quot;),
     SM_CYFULLSCREEN,         TEXT (&quot;SM_CYFULLSCREEN&quot;),          
                              TEXT (&quot;Full screen client area height&quot;),
     SM_CYKANJIWINDOW,        TEXT (&quot;SM_CYKANJIWINDOW&quot;),         
                              TEXT (&quot;Kanji window height&quot;),
     SM_MOUSEPRESENT,         TEXT (&quot;SM_MOUSEPRESENT&quot;),          
                              TEXT (&quot;Mouse present flag&quot;),
     SM_CYVSCROLL,            TEXT (&quot;SM_CYVSCROLL&quot;),             
                              TEXT (&quot;Vertical scroll arrow height&quot;),
     SM_CXHSCROLL,            TEXT (&quot;SM_CXHSCROLL&quot;),             
                              TEXT (&quot;Horizontal scroll arrow width&quot;),
     SM_DEBUG,                TEXT (&quot;SM_DEBUG&quot;),                 
                              TEXT (&quot;Debug version flag&quot;),
     SM_SWAPBUTTON,           TEXT (&quot;SM_SWAPBUTTON&quot;),            
                              TEXT (&quot;Mouse buttons swapped flag&quot;),
     SM_CXMIN,                TEXT (&quot;SM_CXMIN&quot;),                 
                              TEXT (&quot;Minimum window width&quot;),
     SM_CYMIN,                TEXT (&quot;SM_CYMIN&quot;),                 
                              TEXT (&quot;Minimum window height&quot;),
     SM_CXSIZE,               TEXT (&quot;SM_CXSIZE&quot;),                
                              TEXT (&quot;Min/Max/Close button width&quot;),
     SM_CYSIZE,               TEXT (&quot;SM_CYSIZE&quot;),                
                              TEXT (&quot;Min/Max/Close button height&quot;),
     SM_CXSIZEFRAME,          TEXT (&quot;SM_CXSIZEFRAME&quot;),           
                              TEXT (&quot;Window sizing frame width&quot;),
     SM_CYSIZEFRAME,          TEXT (&quot;SM_CYSIZEFRAME&quot;),           
                              TEXT (&quot;Window sizing frame height&quot;),
     SM_CXMINTRACK,           TEXT (&quot;SM_CXMINTRACK&quot;),            
                              TEXT (&quot;Minimum window tracking width&quot;),
     SM_CYMINTRACK,           TEXT (&quot;SM_CYMINTRACK&quot;),            
                              TEXT (&quot;Minimum window tracking height&quot;),
     SM_CXDOUBLECLK,          TEXT (&quot;SM_CXDOUBLECLK&quot;),           
                              TEXT (&quot;Double click x tolerance&quot;),
     SM_CYDOUBLECLK,          TEXT (&quot;SM_CYDOUBLECLK&quot;),           
                              TEXT (&quot;Double click y tolerance&quot;),
     SM_CXICONSPACING,        TEXT (&quot;SM_CXICONSPACING&quot;),         
                              TEXT (&quot;Horizontal icon spacing&quot;),
     SM_CYICONSPACING,        TEXT (&quot;SM_CYICONSPACING&quot;),         
                              TEXT (&quot;Vertical icon spacing&quot;),
     SM_MENUDROPALIGNMENT,    TEXT (&quot;SM_MENUDROPALIGNMENT&quot;),     
                              TEXT (&quot;Left or right menu drop&quot;),
     SM_PENWINDOWS,           TEXT (&quot;SM_PENWINDOWS&quot;),            
                              TEXT (&quot;Pen extensions installed&quot;),
     SM_DBCSENABLED,          TEXT (&quot;SM_DBCSENABLED&quot;),           
                              TEXT (&quot;Double-Byte Char Set enabled&quot;),
     SM_CMOUSEBUTTONS,        TEXT (&quot;SM_CMOUSEBUTTONS&quot;),         
                              TEXT (&quot;Number of mouse buttons&quot;),
     SM_SECURE,               TEXT (&quot;SM_SECURE&quot;),                
                              TEXT (&quot;Security present flag&quot;),
     SM_CXEDGE,               TEXT (&quot;SM_CXEDGE&quot;),                
                              TEXT (&quot;3-D border width&quot;),
     SM_CYEDGE,               TEXT (&quot;SM_CYEDGE&quot;),                
                              TEXT (&quot;3-D border height&quot;),
     SM_CXMINSPACING,         TEXT (&quot;SM_CXMINSPACING&quot;),          
                              TEXT (&quot;Minimized window spacing width&quot;),
     SM_CYMINSPACING,         TEXT (&quot;SM_CYMINSPACING&quot;),          
                              TEXT (&quot;Minimized window spacing height&quot;),
     SM_CXSMICON,             TEXT (&quot;SM_CXSMICON&quot;),              
                              TEXT (&quot;Small icon width&quot;),
     SM_CYSMICON,             TEXT (&quot;SM_CYSMICON&quot;),              
                              TEXT (&quot;Small icon height&quot;),
     SM_CYSMCAPTION,          TEXT (&quot;SM_CYSMCAPTION&quot;),           
                              TEXT (&quot;Small caption height&quot;),
     SM_CXSMSIZE,             TEXT (&quot;SM_CXSMSIZE&quot;),              
                              TEXT (&quot;Small caption button width&quot;),
     SM_CYSMSIZE,             TEXT (&quot;SM_CYSMSIZE&quot;),              
                              TEXT (&quot;Small caption button height&quot;),
     SM_CXMENUSIZE,           TEXT (&quot;SM_CXMENUSIZE&quot;),            
                              TEXT (&quot;Menu bar button width&quot;),
     SM_CYMENUSIZE,           TEXT (&quot;SM_CYMENUSIZE&quot;),            
                              TEXT (&quot;Menu bar button height&quot;),
     SM_ARRANGE,              TEXT (&quot;SM_ARRANGE&quot;),               
                              TEXT (&quot;How minimized windows arranged&quot;),
     SM_CXMINIMIZED,          TEXT (&quot;SM_CXMINIMIZED&quot;),           
                              TEXT (&quot;Minimized window width&quot;),
     SM_CYMINIMIZED,          TEXT (&quot;SM_CYMINIMIZED&quot;),           
                              TEXT (&quot;Minimized window height&quot;),
     SM_CXMAXTRACK,           TEXT (&quot;SM_CXMAXTRACK&quot;),            
                              TEXT (&quot;Maximum draggable width&quot;),
     SM_CYMAXTRACK,           TEXT (&quot;SM_CYMAXTRACK&quot;),            
                              TEXT (&quot;Maximum draggable height&quot;),
     SM_CXMAXIMIZED,          TEXT (&quot;SM_CXMAXIMIZED&quot;),           
                              TEXT (&quot;Width of maximized window&quot;),
     SM_CYMAXIMIZED,          TEXT (&quot;SM_CYMAXIMIZED&quot;),           
                              TEXT (&quot;Height of maximized window&quot;),
     SM_NETWORK,              TEXT (&quot;SM_NETWORK&quot;),               
                              TEXT (&quot;Network present flag&quot;),
     SM_CLEANBOOT,            TEXT (&quot;SM_CLEANBOOT&quot;),             
                              TEXT (&quot;How system was booted&quot;),
     SM_CXDRAG,               TEXT (&quot;SM_CXDRAG&quot;),                
                              TEXT (&quot;Avoid drag x tolerance&quot;),
     SM_CYDRAG,               TEXT (&quot;SM_CYDRAG&quot;),                
                              TEXT (&quot;Avoid drag y tolerance&quot;),
     SM_SHOWSOUNDS,           TEXT (&quot;SM_SHOWSOUNDS&quot;),            
                              TEXT (&quot;Present sounds visually&quot;),
     SM_CXMENUCHECK,          TEXT (&quot;SM_CXMENUCHECK&quot;),           
                              TEXT (&quot;Menu check-mark width&quot;),
     SM_CYMENUCHECK,          TEXT (&quot;SM_CYMENUCHECK&quot;),           
                              TEXT (&quot;Menu check-mark height&quot;),
     SM_SLOWMACHINE,          TEXT (&quot;SM_SLOWMACHINE&quot;),           
                              TEXT (&quot;Slow processor flag&quot;),
     SM_MIDEASTENABLED,       TEXT (&quot;SM_MIDEASTENABLED&quot;),        
                              TEXT (&quot;Hebrew and Arabic enabled flag&quot;),
     SM_MOUSEWHEELPRESENT,    TEXT (&quot;SM_MOUSEWHEELPRESENT&quot;),     
                              TEXT (&quot;Mouse wheel present flag&quot;),
     SM_XVIRTUALSCREEN,       TEXT (&quot;SM_XVIRTUALSCREEN&quot;),        
                              TEXT (&quot;Virtual screen x origin&quot;),
     SM_YVIRTUALSCREEN,       TEXT (&quot;SM_YVIRTUALSCREEN&quot;),        
                              TEXT (&quot;Virtual screen y origin&quot;),
     SM_CXVIRTUALSCREEN,      TEXT (&quot;SM_CXVIRTUALSCREEN&quot;),       
                              TEXT (&quot;Virtual screen width&quot;),
     SM_CYVIRTUALSCREEN,      TEXT (&quot;SM_CYVIRTUALSCREEN&quot;),       
                              TEXT (&quot;Virtual screen height&quot;),
     SM_CMONITORS,            TEXT (&quot;SM_CMONITORS&quot;),             
                              TEXT (&quot;Number of monitors&quot;),
     SM_SAMEDISPLAYFORMAT,    TEXT (&quot;SM_SAMEDISPLAYFORMAT&quot;),     
                              TEXT (&quot;Same color format flag&quot;)
} ;
</pre>
</TD></TR></TABLE> 

<p>The program that displays this information is called SYSMETS1. The SYSMETS1.C source code file is shown in Figure 4-5. Most of the code should look familiar by now. The code in <I>WinMain</I> is virtually identical to that in HELLOWIN, and much of the code in <I>WndProc</I> has already been discussed.

<p><B>Figure 4-5.</B> <I>SYSMETS1.C.</I>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="78"><H3>SYSMETS1.C</H3></A>
<p><pre>
/*----------------------------------------------------
   SYSMETS1.C -- System Metrics Display Program No. 1
                 (c) Charles Petzold, 1998
  ----------------------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;sysmets.h&quot;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;SysMets1&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;

     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;

     if (!RegisterClass (&amp;wndclass))  
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;), 
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }

     hwnd = CreateWindow (szAppName, TEXT (&quot;Get System Metrics No. 1&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     while (GetMessage (&amp;msg, NULL, 0, 0))
          {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
          }
     return msg.wParam ;
     }

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static int  cxChar, cxCaps, cyChar ;
     HDC         hdc ;
     int         i ;
     PAINTSTRUCT ps ;
     TCHAR       szBuffer [10] ;
     TEXTMETRIC  tm ;

     switch (message)
     {
     case WM_CREATE:
          hdc = GetDC (hwnd) ;

          GetTextMetrics (hdc, &amp;tm) ;
          cxChar = tm.tmAveCharWidth ;
          cxCaps = (tm.tmPitchAndFamily &amp; 1 ? 3 : 2) * cxChar / 2 ;
          cyChar = tm.tmHeight + tm.tmExternalLeading ;

          ReleaseDC (hwnd, hdc) ;
          return 0 ;

     case WM_PAINT :
          hdc = BeginPaint (hwnd, &amp;ps) ;

          for (i = 0 ; i &lt; NUMLINES ; i++)
          {
               TextOut (hdc, 0, cyChar * i,                      
                        sysmetrics[i].szLabel,
                        lstrlen (sysmetrics[i].szLabel)) ;

               TextOut (hdc, 22 * cxCaps, cyChar * i,      
                        sysmetrics[i].szDesc,
                        lstrlen (sysmetrics[i].szDesc)) ;

               SetTextAlign (hdc, TA_RIGHT | TA_TOP) ;

               TextOut (hdc, 22 * cxCaps + 40 * cxChar, cyChar * i, szBuffer,
                        wsprintf (szBuffer, TEXT (&quot;%5d&quot;),
                                  GetSystemMetrics (sysmetrics[i].iIndex))) ;

               SetTextAlign (hdc, TA_LEFT | TA_TOP) ;
          }
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
     case WM_DESTROY :
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</TD></TR></TABLE>

<p>Figure 4-6 shows SYSMETS1 running on a standard VGA. As you can see from the first two lines in the program's client area, the screen width is 640 pixels and the screen height is 480 pixels. These two values, as well as many of the other values shown by the program, may be different for different types of video displays.

<p><img src="F04zg06.JPG" width=404 height=303 ALIGN="BOTTOM">

<p><!-- caption --><B>Figure 4-6.</B> <I>The SYSMETS1 display.</I><!-- /caption -->

<A NAME="79"><h2>The SYSMETS1.C Window Procedure</h2></A>
<p>The <I>WndProc</I> window procedure in the SYSMETS1.C program processes three messages: WM_CREATE, WM_PAINT, and WM_DESTROY. The WM_DESTROY message is processed in the same way as the HELLOWIN program in <a href="ch03a.htm#38">Chapter 3</a>.

<p>The WM_CREATE message is the first message the window procedure receives. Windows generates the message when the <I>CreateWindow</I> function creates the window. During the WM_CREATE message, SYSMETS1 obtains a device context for the window by calling <I>GetDC</I> and gets the text metrics for the default system font by calling <I>GetTextMetrics</I>. SYSMETS1 saves the average character width in <I>cxChar</I> and the total height of the characters (including external leading) in <I>cyChar</I>.

<p>SYSMETS1 also saves an average width of uppercase letters in the static variable <I>cxCaps</I>. For a fixed-pitch font, <I>cxCaps</I> would equal <I>cxChar</I>. For a variable-width font, <I>cxCaps</I> is set to 150 percent of <I>cxChar</I>. The low bit of the <I>tmPitchAndFamily</I> field in the TEXTMETRIC structure is 1 for a variable-width font and 0 for a fixed-pitch font. SYSMETS1 uses this bit to calculate <I>cxCaps</I> from <I>cxChar</I>:


<p><pre>
cxCaps = (tm.tmPitchAndFamily &amp; 1 ? 3 : 2) * cxChar / 2 ;
</PRE>

<p>SYSMETS1 does all window painting during the WM_PAINT message. As normal, the window procedure first obtains a handle to the device context by calling <I>BeginPaint</I>. A <I>for</I> statement loops through all the lines of the <I>sysmetrics</I> structure defined in SYSMETS.H. The three columns of text are displayed with three <I>TextOut</I> function calls. In each case, the third argument to <I>TextOut</I> (that is, the <I>y</I> starting position) is set to

<p><pre>
cyChar * i
</PRE>

<p>This argument indicates the pixel position of the top of the character string relative to the top of the client area.

<p>The first <I>TextOut</I> statement displays the uppercase identifiers in the first of the three columns. The second argument to <I>TextOut</I> is 0 to begin the text at the left edge of the client area. The text is obtained from the <I>szLabel</I> field of the <I>sysmetrics</I> structure. I use the Windows function <I>lstrlen</I> to calculate the length of the string, which is required as the last argument to <I>TextOut</I>.

<p>The second <I>TextOut</I> statement displays the description of the system metrics value. These descriptions are stored in the <I>szDesc</I> field of the <I>sysmetrics</I> structure. In this case, the second argument to <I>TextOut</I> is set to

<p><pre>
22 * cxCaps
</PRE>

<p>The longest uppercase identifier displayed in the first column is 20 characters, so the second column must begin at least 20 &#215; <I>cxCaps</I> to the right of the beginning of the first column of text. I use 22 to add a little extra space between the columns.

<p>The third <I>TextOut</I> statement displays the numeric values obtained from the <I>GetSystemMetrics</I> function. The variable-width font makes formatting a column of right-justified numbers a little tricky. Fortunately, in all variable-width fonts used today, the digits from 0 through 9 all have the same width. Otherwise, displaying columns of numbers would be monstrous. However, the width of the digits is greater than the width of a space. Numbers can be one or more digits wide, so different numbers can begin at different horizontal positions.

<p>Wouldn't it be easier if we could display a column of right-justified numbers by specifying the horizontal pixel position where the number ends rather than begins? This is what the <I>SetTextAlign</I> function lets us do (among other things). After SYSMETS1 calls

<p><pre>
SetTextAlign (hdc, TA_RIGHT | TA_TOP) ;
</PRE>

<p>Windows will interpret the coordinates passed to subsequent <I>TextOut</I> functions as specifying the top-right corner of the text string rather than the top-left corner.

<p>The <I>TextOut</I> function to display the column of numbers has its second argument set to

<p><pre>
22 * cxCaps + 40 * cxChar
</PRE>

<p>The 40 &#215; <I>cxChar</I> value accommodates the width of the second column and the width of the third column. Following the <I>TextOut</I> function, another call to <I>SetTextAlign</I> sets things back to normal for the next time through the loop.

<A NAME="80"><h2>Not Enough Room</h2></A>
<p>One nasty little problem exists with the SYSMETS1 program: Unless you have a gigantic, big-screen, high-resolution video adapter, you can't see many of the lines in the system metrics lists. If you make the window narrower, you can't even see the values.

<p>SYSMETS1 is not aware of this problem. Otherwise we might have included a message box that said, &quot;Sorry!&quot; It's not aware of the problem because the program doesn't even know how large its client area is. It begins displaying the text at the top of the window and relies on Windows to clip everything that drifts beyond the bottom of the client area.

<p>Clearly, this is not desirable. Our first job in solving this problem is to determine how much of the program's output can actually fit within the client area.

<A NAME="81"><h2>The Size of the Client Area</h2></A>
<p>If you experiment with existing Windows applications, you'll find that window sizes can vary widely. If a window is maximized, the client area occupies nearly the entire video display. The dimensions of a maximized client area are, in fact, available from the <I>GetSystemMetrics</I> call by using arguments of SM_CXFULLSCREEN and SM_CYFULLSCREEN (assuming that the window has only a title bar and no menu). The minimum size of a window can be quite small&#8212;sometimes almost nonexistent&#8212;virtually eliminating the client area.

<p>In the last chapter, we used the <I>GetClientRect</I> function for determining the dimensions of the client area. There's nothing really wrong with this function, but it's a bit inefficient to call it every time you need to use this information. A much better method for determining the size of a window's client is to process the WM_SIZE message within your window procedure. Windows sends a WM_SIZE message to a window procedure whenever the size of the window changes. The <I>lParam</I> variable passed to the window procedure contains the width of the client area in the low word and the height in the high word. To save these dimensions, you'll want to define two static variables in your window procedure:

<p><pre>
static int cxClient, cyClient ;
</PRE>

<p>Like <I>cxChar</I> and <I>cyChar</I>, these variables are defined as static because they are set while processing one message and used while processing another message. You handle the WM_SIZE method like so:

<p><pre>
case WM_SIZE:
    cxClient = LOWORD (lParam) ;
    cyClient = HIWORD (lParam) ;
    return 0 ;
</PRE>

<p>You'll see code like this in virtually every Windows program. LOWORD and HIWORD are macros that are defined in the Windows header file WINDEF.H. If you're curious, the definitions of these macros look like this:

<p><pre>
#define LOWORD(l) ((WORD)(l))
#define HIWORD(l) ((WORD)(((DWORD)(l) &gt;&gt; 16) &amp; 0xFFFF))
</PRE>

<p>The two macros return WORD values&#8212;that is, 16-bit unsigned short integers that range from 0 through 0xFFFF. Typically you'll store these values in 32-bit signed integers. That doesn't involve any conversion problems and makes the values easier to use in any calculations you may later need.

<p>In many Windows programs, a WM_SIZE message will eventually be followed by a WM_PAINT message. How do we know this? Because when we define the window class we specify the class style as

<p><pre>
CS_HREDRAW | CS_VREDRAW
</PRE>

<p>This class style tells Windows to force a repaint if either the horizontal or vertical size changes.

<p>You can calculate the number of full lines of text displayable within the client area with the formula:

<p><pre>
cyClient / cyChar
</PRE>

<p>This can be 0 if the height of the client area is too small to display a full character. Similarly, the approximate number of lowercase characters you can display horizontally within the client area is equal to

<p><pre>
cxClient / cxChar
</PRE>

<p>If you determine <I>cxChar</I> and <I>cyChar</I> during the WM_CREATE message, don't worry about dividing by 0 in these calculations. Your window procedure receives a WM_CREATE message when <I>WinMain</I> calls <I>CreateWindow</I>. The first WM_SIZE message comes a little later, when <I>WinMain</I> calls <I>ShowWindow</I>, at which point <I>cxChar</I> and <I>cyChar</I> have already been assigned positive nonzero values.

<p>Knowing the size of the window's client area is the first step in providing a way for the user to move the text within the client area if the client area is not large enough to hold everything. If you're familiar with other Windows-based applications that have similar requirements, you probably know what we need: this is a job for those wonderful inventions known as scroll bars.

</BODY>
</HTML>





