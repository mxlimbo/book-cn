<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Character Messages</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="164"><h1>Character Messages</h1></A>
Earlier in this chapter, I discussed the idea of translating keystroke messages into character messages by taking shift-state information into account. I warned you that shift-state information is not enough: you also need to know about country-dependent keyboard configurations. For this reason, you should not attempt to translate keystroke messages into character codes yourself. Instead, Windows does it for you. You've seen this code before:

<p><pre>
while (GetMessage (&amp;msg, NULL, 0, 0))
{
     TranslateMessage (&amp;msg) ;
     DispatchMessage (&amp;msg) ;
}
</PRE>

<p>This is a typical message loop that appears in <I>WinMain</I>. The <I>GetMessage</I> function fills in the <I>msg</I> structure fields with the next message from the queue. <I>DispatchMessage</I> calls the appropriate window procedure with this message.

<p>Between these two functions is <I>TranslateMessage</I>, which takes on the responsibility of translating keystroke messages to character messages. If the keystroke message is WM_KEYDOWN or WM_SYSKEYDOWN, and if the keystroke in combination with the shift state produces a character, <I>TranslateMessage</I> places a character message in the message queue. This character message will be the next message that <I>GetMessage</I> retrieves from the queue after the keystroke message.


<A NAME="165"><h2>The Four Character Messages</h2></A>
There are four character messages:

<table cellpadding=5 width="95%">
<tr>
<td valign="top"> </td>
<td valign="top"><b><i>Characters</i></b></td>
<td valign="top"><b><i>Dead Characters</i></b></td>
</tr>

<tr>
<td valign="top">Nonsystem Characters:</td>
<td valign="top">WM_CHAR</td>
<td valign="top">WM_DEADCHAR</td>
</tr>

<tr>
<td valign="top">System Characters:</td>
<td valign="top">WM_SYSCHAR</td>
<td valign="top">WM_SYSDEADCHAR</td>
</tr>
</table>

<p>The WM_CHAR and WM_DEADCHAR messages are derived from WM_KEYDOWN messages. The WM_SYSCHAR and WM_SYSDEADCHAR messages are derived from WM_SYSKEYDOWN messages. (I'll discuss what a dead character is shortly.)

<p>Here's the good news: In most cases, your Windows program can process the WM_CHAR message while ignoring the other three character messages. The <I>lParam</I> parameter that accompanies the four character messages is the same as the <I>lParam</I> parameter for the keystroke message that generated the character code message. However, the <I>wParam</I> parameter is not a virtual key code. Instead, it is an ANSI or Unicode character code.

<p>These character messages are the first messages we've encountered that deliver text to the window procedure. They're not the only ones. Other messages are accompanied by entire zero-terminated text strings. How does the window procedure know whether this character data is 8-bit ANSI or 16-bit Unicode? It's simple: Any window procedure associated with a window class that you register with <I>RegisterClassA</I> (the ANSI version of <I>RegisterClass</I>) gets messages that contain ANSI character codes. Messages to window procedures that were registered with <I>RegisterClassW</I> (the wide-character version of <I>RegisterClass</I>) come with Unicode character codes. If your program registers its window class using <I>RegisterClass</I>, that's really <I>RegisterClassW</I> if the UNICODE identifier was defined and <I>RegisterClassA</I> otherwise.

<p>Unless you're explicitly doing mixed coding of ANSI and Unicode functions and window procedures, the character code delivered with the WM_CHAR message (and the three other character messages) is

<p><pre>
(TCHAR) wParam
</PRE>

<p>The same window procedure might be used with two window classes, one registered with <I>RegisterClassA</I> and the other registered with <I>RegisterClassW</I>. This means that the window procedure might get some messages with ANSI character codes and some messages with Unicode character codes. If your window procedure needs help to sort things out, it can call

<p><pre>
fUnicode = IsWindowUnicode (hwnd) ;
</PRE>

<p>The <I>fUnicode</I> variable will be TRUE if the window procedure for <I>hwnd</I> gets Unicode messages, which means the window is based on a window class that was registered with <I>RegisterClassW</I>.

<A NAME="166"><h2>Message Ordering</h2></A>
<p>Because the character messages are generated by the <I>TranslateMessage</I> function from WM_KEYDOWN and WM_SYSKEYDOWN messages, the character messages are delivered to your window procedure sandwiched between keystroke messages. For instance, if Caps Lock is not toggled on and you press and release the A key, the window procedure receives the following three messages:

<table cellpadding=5 width="95%">
<tr>
<td valign="top"><i><b>Message</b></i></td>
<td valign="top"><i><b>Key or Code</b></i></td>
</tr>

<tr>
<td valign="top">WM_KEYDOWN</td>
<td valign="top">Virtual key code for `A' (0x41)</td>
</tr>

<tr>
<td valign="top">WM_CHAR</td>
<td valign="top">Character code for `a' (0x61)</td>
</tr>

<tr>
<td valign="top">WM_KEYUP</td>
<td valign="top">Virtual key code for `A' (0x41)</td>
</tr>
</table>

<p>If you type an uppercase A by pressing the Shift key, pressing the A key, releasing the A key, and then releasing the Shift key, the window procedure receives five messages:

<table cellpadding=5 width="95%">

<tr>
<td valign="top"><i><b>Message</b></i></td>
<td valign="top"><i><b>Key or Code</b></i></td>
</tr>

<tr>
<td valign="top">WM_KEYDOWN</td>
<td valign="top">Virtual key code VK_SHIFT (0x10)</td>
</tr>

<tr>
<td valign="top">WM_KEYDOWN</td>
<td valign="top">Virtual key code for `A' (0x41)</td>
</tr>

<tr>
<td valign="top">WM_CHAR</td>
<td valign="top">Character code for `A' (0x41)</td>
</tr>

<tr>
<td valign="top">WM_KEYUP</td>
<td valign="top">Virtual key code for `A' (0x41)</td>
</tr>

<tr>
<td valign="top">WM_KEYUP</td>
<td valign="top">Virtual key code VK_SHIFT (0x10)</td>
</tr>
</table>
<p>The Shift key by itself does not generate a character message.

<p>If you hold down the A key so that the typematic action generates keystrokes, you'll get a character message for each WM_KEYDOWN message:

<table cellpadding=5 width="95%">

<tr>
<td valign="top"><i><b>Message</b></i></td>
<td valign="top"><i><b>Key or Code</b></i></td>
</tr>

<tr>
<td valign="top">WM_KEYDOWN</td>
<td valign="top">Virtual key code for `A' (0x41)</td>
</tr>

<tr>
<td valign="top">WM_CHAR</td>
<td valign="top">Character code for `a' (0x61)</td>
</tr>

<tr>
<td valign="top">WM_KEYDOWN</td>
<td valign="top">Virtual key code for `A' (0x41)</td>
</tr>

<tr>
<td valign="top">WM_CHAR</td>
<td valign="top">Character code for `a' (0x61)</td>
</tr>

<tr>
<td valign="top">WM_KEYDOWN</td>
<td valign="top">Virtual key code for `A' (0x41)</td>
</tr>

<tr>
<td valign="top">WM_CHAR</td>
<td valign="top">Character code for `a' (0x61)</td>
</tr>

<tr>
<td valign="top">WM_KEYDOWN</td>
<td valign="top">Virtual key code for `A' (0x41)</td>
</tr>

<tr>
<td valign="top">WM_CHAR</td>
<td valign="top">Character code for `a' (0x61)</td>
</tr>

<tr>
<td valign="top">WM_KEYUP</td>
<td valign="top">Virtual key code for `A' (0x41)</td>
</tr>
</table>

<p>If some of the WM_KEYDOWN messages have a Repeat Count greater than 1, the corresponding WM_CHAR message will have the same Repeat Count.

<p>The Ctrl Key in combination with a letter key generates ASCII control characters from 0x01 (Ctrl-A) through 0x1A (Ctrl-Z). Several of these control codes are also generated by the keys shown in the following table:

<table cellpadding=5 width="95%">
<tr><td valign="top"><i><b>Key</b></i></td>
<td valign="top"><i><b>Character Code</b></i></td>
<td valign="top"><i><b>Duplicated by</b></i></td>
<td valign="top"><b><i>ANSI C Escape</i></b></td></tr>

<tr>
<td valign="top">Backspace</td>
<td valign="top">0x08</td>
<td valign="top">Ctrl-H</td>
<td valign="top">\b</td>
</tr>

<tr>
<td valign="top">Tab</td>
<td valign="top">0x09</td>
<td valign="top">Ctrl-I</td>
<td valign="top">\t</td>
</tr>

<tr>
<td valign="top">Ctrl-Enter</td>
<td valign="top">0x0A</td>
<td valign="top">Ctrl-J</td>
<td valign="top">\n</td>
</tr>

<tr>
<td valign="top">Enter</td>
<td valign="top">0x0D</td>
<td valign="top">Ctrl-M</td>
<td valign="top">\r</td>
</tr>

<tr>
<td valign="top">Esc</td>
<td valign="top">0x1B</td>
<td valign="top">Ctrl-[</td>
<td valign="top"> </td>
</tr>
</table>

<p>The rightmost column shows the escape code defined in ANSI C to represent the character codes for these keys.

<p>Windows programs sometimes use the Ctrl key in combination with letter keys for menu accelerators (which I'll discuss in <a href="ch10a.htm#279">Chapter 10</a>). In this case, the letter keys are not translated into character messages.

<A NAME="167"><h2>Control Character Processing</h2></A>
<p>The basic rule for processing keystroke and character messages is this: If you need to read keyboard character input in your window, you process the WM_CHAR message. If you need to read the cursor keys, function keys, Delete, Insert, Shift, Ctrl, and Alt, you process the WM_KEYDOWN message.

<p>But what about the Tab key? Or Enter or Backspace or Escape? Traditionally, these keys generate ASCII control characters, as shown in the preceding table. But in Windows they also generate virtual key codes. Should these keys be processed during WM_CHAR processing or WM_KEYDOWN processing?


<p>After a decade of considering this issue (and looking back over Windows code I've written over the years), I seem to prefer treating the Tab, Enter, Backspace, and Escape keys as control characters rather than as virtual keys. My WM_CHAR processing often looks something like this:

<p><pre>
case WM_CHAR:
     <I>[other program lines]</I>
     switch (wParam)
     {
     case `\b':          // backspace
<I>          [other program line</I>
          break ;
     case `\t':          // tab
          <I>[other program lines]</I>
          break ;

     case `\n':          // linefeed
          <I>[other program lines]</I>
          break ;

     case `\r':          // carriage return
          <I>[other program lines]</I>
          break ;

     default:            // character codes
          <I>[other program lines]</I>
          break ;
     }
     return 0 ;
</PRE>


<A NAME="168"><h2>Dead-Character Messages</h2></A>
<p>Windows programs can usually ignore WM_DEADCHAR and WM_SYSDEADCHAR messages, but you should definitely know what dead characters are and how they work.

<p>On some non-U.S. English keyboards, certain keys are defined to add a diacritic to a letter. These are called &quot;dead keys&quot; because they don't generate characters by themselves. For instance, when a German keyboard is installed, the key that is in the same position as the +/= key on a U.S. keyboard is a dead key for the grave accent (`) when shifted and the acute accent (&#180;) when unshifted.

<p>When a user presses this dead key, your window procedure receives a WM_DEADCHAR message with <I>wParam</I> equal to ASCII or Unicode code for the diacritic by itself. When the user then presses a letter key that can be written with this diacritic (for instance, the A key), the window procedure receives a WM_CHAR message where <I>wParam</I> is the ANSI code for the letter `a' with the diacritic.

<p>Thus, your program does not have to process the WM_DEADCHAR message because the WM_CHAR message gives the program all the information it needs. The Windows logic even has built-in error handling: If the dead key is followed by a letter that can't take a diacritic (such as `s'), the window procedure receives two WM_CHAR messages in a row&#8212;the first with <I>wParam</I> equal to the ASCII code for the diacritic by itself (the same <I>wParam</I> value delivered with the WM_DEADCHAR message) and the second with <I>wParam</I> equal to the ASCII code for the letter `s'.

<p>Of course, the best way to get a feel for this is to see it in action. You need to load a foreign keyboard that uses dead keys, such as the German keyboard that I described earlier. You do this in the Control Panel by selecting Keyboard and then the Language tab. Then you need an application that shows you the details of every keyboard message a program can receive. That's the KEYVIEW1 program coming up next.

</BODY>
</HTML>






