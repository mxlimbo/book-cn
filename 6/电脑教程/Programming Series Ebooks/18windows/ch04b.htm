<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Painting and Repainting</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="63"><h1>Painting and Repainting</h1></A>
<p>In character-mode environments, programs can generally write to any part of the video display. What the program puts on the display will stay there and not mysteriously disappear. The program can then discard the information needed to re-create the screen display.

<p>In Windows, you can draw text and graphics only in the client area of your window, and you cannot be assured that what you put will remain there until your program specifically writes over it. For instance, the user may move another program's window on the screen so that it partially covers your application's window. Windows will not attempt to save the area of your window that the other program covers. When the program is moved away, Windows will request that your program repaint this portion of your client area.

<p>Windows is a message-driven system. Windows informs applications of various events by posting messages in the application's message queue or sending messages to the appropriate window procedure. Windows informs a window procedure that part of the window's client area needs painting by posting a WM_PAINT message.



<A NAME="64"><h2>The WM_PAINT Message</h2></A>
<p>Most Windows programs call the function <I>UpdateWindow</I> during initialization in <I>WinMain</I> shortly before entering the message loop. Windows takes this opportunity to send the window procedure its first WM_PAINT message. This message informs the window procedure that the client area must be painted. Thereafter, that window procedure should be ready at almost any time to process additional WM_PAINT messages and even to repaint the entire client area of the window if necessary. A window procedure receives a WM_PAINT message whenever one of the following events occurs:

<ul>

<p><li> A previously hidden area of the window is brought into view when a user moves a window or uncovers a window.

<p><li> The user resizes the window (if the window class style has the CS_HREDRAW and CW_VREDRAW bits set).

<p><li> The program uses the <I>ScrollWindow</I> or <I>ScrollDC</I> function to scroll part of its client area.

<p><li> The program uses the <I>InvalidateRect</I> or <I>InvalidateRgn</I> function to explicitly generate a WM_PAINT message.
</UL>

<p>In some cases when part of the client area is temporarily written over, Windows attempts to save an area of the display and restore it later. This is not always successful. Windows may sometimes post a WM_PAINT message when:

<ul>

<p><li> Windows removes a dialog box or message box that was overlaying part of the window.

<p><li> A menu is pulled down and then released.

<p><li> A tool tip is displayed.
</UL>

<p>In a few cases, Windows always saves the area of the display it overwrites and then restores it. This is the case whenever:

<p><ul>

<li> The mouse cursor is moved across the client area.

<p><li> An icon is dragged across the client area.
</UL>

<p>Dealing with WM_PAINT message requires that you alter the way you think about how you write to the video display. Your program should be structured so that it accumulates all the information necessary to paint the client area but paints only &quot;on demand&quot;&#8212;when Windows sends the window procedure a WM_PAINT message. If your program needs to update its client area at some other time, it can force Windows to generate this WM_PAINT message. This may seem a roundabout method of displaying something on the screen, but the structure of your program will benefit from it.

<A NAME="65"><h2>Valid and Invalid Rectangles</h2></A>
<p>Although a window procedure should be prepared to update the entire client area whenever it receives a WM_PAINT message, it often needs to update only a smaller area, most often a rectangular area within the client area. This is most obvious when a dialog box overlies part of the client area. Repainting is required only for the rectangular area uncovered when the dialog box is removed.

<p>That area is known as an &quot;invalid region&quot; or &quot;update region.&quot; The presence of an invalid region in a client area is what prompts Windows to place a WM_PAINT message in the application's message queue. Your window procedure receives a WM_PAINT message only if part of your client area is invalid.

<p>Windows internally maintains a &quot;paint information structure&quot; for each window. This structure contains, among other information, the coordinates of the smallest rectangle that encompasses the invalid region. This is known as the &quot;invalid rectangle.&quot; If another region of the client area becomes invalid before the window procedure processes a pending WM_PAINT message, Windows calculates a new invalid region (and a new invalid rectangle) that encompasses both areas and stores this updated information in the paint information structure. Windows does not place multiple WM_PAINT messages in the message queue.

<p>A window procedure can invalidate a rectangle in its own client area by calling <I>InvalidateRect</I>. If the message queue already contains a WM_PAINT message, Windows calculates a new invalid rectangle. Otherwise, it places a WM_PAINT message in the message queue. A window procedure can obtain the coordinates of the invalid rectangle when it receives a WM_PAINT message (as we'll see later in this chapter). It can also obtain these coordinates at any other time by calling <I>GetUpdateRect</I>.

<p>After the window procedure calls <I>BeginPaint</I> during the WM_PAINT message, the entire client area is validated. A program can also validate any rectangular area within the client area by calling the <I>ValidateRect</I> function. If this call has the effect of validating the entire invalid area, then any WM_PAINT message currently in the queue is removed.

</BODY>
</HTML>






