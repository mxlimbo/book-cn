<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>The GDI Mapping Mode</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="125"><h1>The GDI Mapping Mode</h1></A>
<p>Up until now, all the sample programs have been drawing in units of pixels relative to the upper left corner of the client area. This is the default, but it's not your only choice. One device context attribute that affects virtually all the drawing you do on the client area is the &quot;mapping mode.&quot; Four other device context attributes&#8212;the window origin, the viewport origin, the window extents, and the viewport extents&#8212;are closely related to the mapping mode attribute.

<p>Most of the GDI drawing functions require coordinate values or sizes. For instance, this is the <I>TextOut</I> function:

<p><pre>
TextOut (hdc, x, y, psText, iLength) ;
</pre>

<p>The <I>x</I> and <I>y</I> arguments indicate the starting position of the text. The <I>x</I> argument is the position on the horizontal axis, and the <I>y</I> argument is the position on the vertical axis. Often the notation (<I>x,y</I>) is used to indicate this point.

<p>In <I>TextOut</I>, as in virtually all GDI functions, these coordinate values are &quot;logical units.&quot; Windows must translate the logical units into &quot;device units,&quot; or pixels. This translation is governed by the mapping mode, the window and viewport origins, and the window and viewport extents. The mapping mode also implies an orientation of the <I>x</I>-axis and the <I>y</I>-axis; that is, it determines whether values of <I>x</I> increase as you move toward the left or right side of the display and whether values of <I>y</I> increase as you move up or down the display.

<p>Windows defines eight mapping modes. These are listed in the following table using the identifiers defined in WINGDI.H.

<p><table width="95%" cellpadding="5" valign="TOP">
<tr>
<td valign=top></td><td valign=top></td>
<td colspan=2><b><i><u>Increasing Value</u></i></b></td>
</tr>
<tr>
<td valign=top><b><i>Mapping Mode</i></b></td>
<td valign=top><b><i>Logical Unit</i></b></td>
<td valign=top><b><i></I>x<I>-axis</i></b></td>     
<td valign=top><b><i></I>y<I>-axis</I></B></td>
</tr>
<tr>
<td valign=top>MM_TEXT</td>
<td valign=top>Pixel</td>
<td valign=top>Right</td>
<td valign=top>Down</td>
</tr>
<tr>
<td valign=top>MM_LOMETRIC</td>
<td valign=top>0.1 mm</td>
<td valign=top>Right</td>
<td valign=top>Up</td>
</tr>
<tr>
<td valign=top>MM_HIMETRIC</td>
<td valign=top>0.01 mm</td>
<td valign=top>Right</td>
<td valign=top>Up</td>
</tr>
<tr>
<td valign=top>MM_LOENGLISH</td>
<td valign=top>0.01 in.</td>
<td valign=top>Right</td>
<td valign=top>Up</td>
</tr>
<tr>
<td valign=top>MM_HIENGLISH</td>
<td valign=top>0.001 in.</td>
<td valign=top>Right</td>
<td valign=top>Up</td>
</tr>
<tr>
<td valign=top>MM_TWIPS</td>
<td valign=top>1/1440 in.</td>
<td valign=top>Right</td>
<td valign=top>Up</td>
</tr>
<tr>
<td valign=top>MM_ISOTROPIC</td>
<td valign=top>Arbitrary (<I>x</I> = <I>y</I>)</td>
<td valign=top>Selectable</td>
<td valign=top>Selectable</td>
</tr>
<tr>
<td valign=top>MM_ANISOTROPIC </td>
<td valign=top>Arbitrary (<I>x</I> !=<I>y</I>)</td>
<td valign=top>Selectable</td>
<td valign=top>Selectable</td>
</tr>
</table>

<p>The words METRIC and ENGLISH refer to popular systems of measurement; LO and HI are &quot;low&quot; and &quot;high&quot; and refer to precision. &quot;Twip&quot; is a fabricated word meaning &quot;twentieth of a point.&quot; I mentioned earlier that a point is a unit of measurement in typography that is approximately 1/72 inch but that is often assumed in graphics programming to be exactly 1/72 inch. A &quot;twip&quot; is 1/20 point and hence 1/1440 inch. &quot;Isotropic&quot; and &quot;anisotropic&quot; are actually real words, meaning &quot;identical in all directions&quot; and &quot;not isotropic,&quot; respectively.

<p>You can set the mapping mode by using

<p><pre>
SetMapMode (hdc, iMapMode) ;
</pre>

<p>where <I>iMapMode</I> is one of the eight mapping mode identifiers. You can obtain the current mapping mode by calling

<p><pre>
iMapMode = GetMapMode (hdc) ;
</pre>

<p>The default mapping mode is MM_TEXT. In this mapping mode, logical units are the same as physical units, which allows us (or, depending on your perspective, forces us) to work directly in units of pixels. In a <I>TextOut</I> call that looks like this:

<p><pre>
TextOut (hdc, 8, 16, TEXT (&quot;Hello&quot;), 5) ;
</pre>

<p>the text begins 8 pixels from the left of the client area and 16 pixels from the top.

<p>If the mapping mode is set to MM_LOENGLISH like so,

<p><pre>
SetMapMode (hdc, MM_LOENGLISH) ;
</pre>

<p>logical units are in terms of hundredths of an inch. Now the <I>TextOut</I> call might look like this:

<p><pre>
TextOut (hdc, 50, -100, TEXT (&quot;Hello&quot;), 5) ;
</pre>

<p>The text begins 0.5 inch from the left and 1 inch from the top of the client area. (The reason for the negative sign in front of the y-coordinate will soon become clear when I discuss the mapping modes in more detail.) Other mapping modes allow programs to specify coordinates in terms of millimeters, a point size, or an arbitrarily scaled axis.

<p>If you feel comfortable working in units of pixels, you don't need to use any mapping modes except the default MM_TEXT mode. If you need to display an image in inch or millimeter dimensions, you can obtain the information you need from <I>GetDeviceCaps</I> and do your own scaling. The other mapping modes are simply a convenient way to avoid doing your own scaling.

<p>Although the coordinates you specify in GDI functions are 32-bit values, only Windows NT can handle all 32 bits. In Windows 98, coordinates are limited to 16 bits and thus may range only from -32,768 to 32,767. Some Windows functions that use coordinates for the starting point and ending point of a rectangle also require that the width and height of the rectangle be 32,767 or less.


<A NAME="126"><h2>Device Coordinates and Logical Coordinates</h2></A>
<p>You may ask: if I use the MM_LOENGLISH mapping mode, will I start getting WM_SIZE messages in terms of hundredths of an inch? Absolutely not. Windows continues to use device coordinates for all messages (such as WM_MOVE, WM_SIZE, and WM_MOUSEMOVE), for all non-GDI functions, and even for some GDI functions. Think of it this way: the mapping mode is an attribute of the device context, so the only time the mapping mode comes into play is when you use GDI functions that require a handle to the device context as one of the arguments. <I>GetSystemMetrics</I> is not a GDI function, so it will continue to return sizes in device units, which are pixels. And although <I>GetDeviceCaps</I> is a GDI function that requires a handle to a device context, Windows continues to return device units for the HORZRES and VERTRES indexes, because one of the purposes of this function is to provide a program with the size of the device in pixels.

<p>However, the values in the TEXTMETRIC structure that you obtain from the <I>GetTextMetrics</I> call are in terms of logical units. If the mapping mode is MM_LOENGLISH at the time the call is made, <I>GetTextMetrics</I> provides character widths and heights in terms of hundredths of an inch. To make things easy on yourself, when you call <I>GetTextMetrics</I> for information about the height and width of characters, the mapping mode should be set to the same mapping mode that you'll be using when you draw text based on these sizes.


<A NAME="127"><h2>The Device Coordinate Systems</h2></A>
<p>Windows maps logical coordinates that are specified in GDI functions to device coordinates. Before we discuss the logical coordinate system used with the various mapping modes, let's examine the different device coordinate systems that Windows defines for the video display. Although we have been working mostly within the client area of our window, Windows uses two other device coordinate systems at various times. In all device coordinate systems, units are expressed in terms of pixels. Values on the horizontal <I>x</I>-axis increase from left to right, and values on the vertical <I>y</I>-axis increase from top to bottom.

<p>When we use the entire screen, we are working in terms of &quot;screen coordinates.&quot; The upper left corner of the screen is the point (0, 0). Screen coordinates are used in the WM_MOVE message (for nonchild windows) and in the following Windows functions: <I>CreateWindow</I> and <I>MoveWindow</I> (for nonchild windows), <I>GetMessagePos</I>, <I>GetCursorPos</I>, <I>SetCursorPos</I>, <I>GetWindowRect</I>, and <I>WindowFromPoint</I>. (This is not a complete list.) These are generally either functions that don't have a window associated with them (such as the two cursor functions) or functions that must move or find a window based on a screen point. If you use <I>CreateDC</I> with a &quot;DISPLAY&quot; argument to obtain a device context for the entire screen, logical coordinates in GDI calls will be mapped to screen coordinates by default.

<p>&quot;Whole-window coordinates&quot; refer to a program's entire application window, including the title bar, menu, scroll bars, and border. For a common application window, the point (0, 0) is the upper left corner of the sizing border. Whole-window coordinates are rare in Windows, but if you obtain a device context from <I>GetWindowDC</I>, logical coordinates in GDI functions will be mapped to whole-window coordinates by default.

<p>The third device coordinate system&#8212;the one we've been working with the most&#8212;uses &quot;client area coordinates.&quot; The point (0, 0) is the upper left corner of the client area. When you obtain a device context using <I>GetDC</I> or <I>BeginPaint</I>, logical coordinates in GDI functions will be translated to client-area coordinates by default.

<p>You can convert client-area coordinates to screen coordinates and vice versa using the functions <I>ClientToScreen</I> and <I>ScreenToClient</I>. You can also obtain the position and size of the whole window in terms of screen coordinates using the <I>GetWindowRect</I> functions. These three functions provide enough information to translate from any one device coordinate system to the other.


<A NAME="128"><h2>The Viewport and the Window</h2></A>
<p>The mapping mode defines how Windows maps logical coordinates that are specified in GDI functions to device coordinates, where the particular device coordinate system depends on the function you use to obtain the device context. To continue this discussion of the mapping mode, we need some additional terminology. The mapping mode is said to define the mapping of the &quot;window&quot; (logical coordinates) to the &quot;viewport&quot; (device coordinates).

<p>The use of these two terms is unfortunate. In other graphics interface systems, the viewport often implies a clipping region. And in Windows, the term &quot;window&quot; has a very specific meaning to describe the area that a program occupies on the screen. We'll have to put aside our preconceptions of these terms during this discussion.

<p>The viewport is specified in terms of device coordinates (pixels). Most often the viewport is the same as the client area, but it can also refer to whole-window coordinates or screen coordinates if you've obtained a device context from <I>GetWindowDC</I> or <I>CreateDC</I>. The point (0, 0) is the upper left corner of the client area (or the whole window or the screen). Values of <I>x</I> increase to the right, and values of <I>y</I> increase going down.

<p>The window is specified in terms of logical coordinates, which might be pixels, millimeters, inches, or any other unit you want. You specify logical window coordinates in the GDI drawing functions.

<p>But in a very real sense, the viewport and the window are just mathematical constructs. For all mapping modes, Windows translates window (logical) coordinates to viewport (device) coordinates by the use of two formulas,

<p><pre>
<I>                                  xViewExt
xViewport = (xWindow - xWinOrg) &#215; ________ + xViewOrg
                                  xWinExt
     

                                  yViewExt
yViewport = (yWindow - yWinOrg) &#215; ________  + yViewOrg
                                  yWinExt</I>
</pre>

<p>where (<I>xWindow</I>, <I>yWindow</I>) is a logical point to be translated and (<I>xViewport</I>, <I>yViewport</I>) is the translated point in device coordinates, most likely client-area coordinates.

<p>These formulas use two points that specify an &quot;origin&quot; of the window and the viewport. The point (<I>xWinOrg</I>, <I>yWinOrg</I>) is the window origin in logical coordinates; the point (<I>xViewOrg</I>, <I>yViewOrg</I>) is the viewport origin in device coordinates. By default, these two points are set to (0, 0), but you can change them. The formulas imply that the logical point (<I>xWinOrg</I>, <I>yWinOrg</I>) is always mapped to the device point (<I>xViewOrg</I>, <I>yViewOrg</I>). If the window and viewport origins are left at their default (0, 0) values, the formulas simplify to

<p><pre>
<I>                      xViewExt
xViewport = xWindow &#215; ________
                      xWinExt

                      yViewExt
yViewport = yWindow &#215; ________
                      yWinExt</I>
</pre>

<p>The formulas also include two points that specify &quot;extents&quot;: the point (<I>xWinExt</I>, <I>yWinExt</I>) is the window extent in logical coordinates; (<I>xViewExt</I>, <I>yViewExt</I>) is the viewport extent in device coordinates. In most mapping modes, the extents are implied by the mapping mode and cannot be changed. Each extent means nothing by itself, but the ratio of the viewport extent to the window extent is a scaling factor for converting logical units to device units.

<p>For example, when you set the MM_LOENGLISH mapping mode, Windows sets <I>xViewExt</I> to be a certain number of pixels and <I>xWinExt</I> to be the length in hundredths of an inch occupied by <I>xViewExt</I> pixels. The ratio gives you pixels per hundredths of an inch. The scaling factors are expressed as ratios of integers rather than floating point values for performance reasons.

<p>The extents can be negative. This implies that values on the logical <I>x</I>-axis don't necessarily have to increase to the right and that values on the logical <I>y</I>-axis don't necessarily have to increase going down.

<p>Windows can also translate from viewport (device) coordinates to window (logical) coordinates:

<p><pre>
<I>                                   xWinExt
xWindow = (xViewport - xViewOrg) &#215; ________ + xWinOrg
                                   xViewExt

                                   yWinExt
yWindow = (yViewport - yViewOrg) &#215; ________ + yWinOrg
                                   yViewExt</I>
</pre>

<p>Windows provides two functions that let you convert between device points to logical points in a program. The following function converts device points to logical points:

<p><pre>
DPtoLP (hdc, pPoints, iNumber) ;
</pre>

<p>The variable <I>pPoints</I> is a pointer to an array of POINT structures, and <I>iNumber</I> is the number of points to be converted. For example, you'll find this function useful for converting the size of the client area obtained from <I>GetClientRect</I> (which is always in terms of device units) to logical coordinates:

<p><pre>
GetClientRect (hwnd, &amp;rect) ;
DPtoLP (hdc, (PPOINT) &amp;rect, 2) ;
</pre>

<p>This function converts logical points to device points:

<p><pre>
LPtoDP (hdc, pPoints, iNumber) ;
</pre>

<A NAME="129"><h2>Working with MM_TEXT</h2></A>
<p>For the MM_TEXT mapping mode, the default origins and extents are shown below.

<table width="95%" cellpadding="5" valign="TOP">
<tr>
<td valign=top><B><I>Window origin:</I></B></td>
<td valign=top>(0, 0)</td>
<td valign=top>Can be changed</td>
</tr>
<tr>
<td valign=top><B><I>Viewport origin:</I></B></td>
<td valign=top>(0, 0)</td>
<td valign=top>Can be changed</td>
</tr>
<tr>
<td valign=top><B><I>Window extent:</I></B></td>
<td valign=top>(1, 1)</td>
<td valign=top>Cannot be changed</td>
</tr>
<tr>
<td valign=top><B><I>Viewport extent:</I></B></td>
<td valign=top>(1, 1)</td>
<td valign=top>Cannot be changed</td>
</tr>
</table>

<p>The ratio of the viewport extent to the window extent is 1, so no scaling is performed between logical coordinates and device coordinates. The formulas to convert from window coordinates to viewport coordinates shown earlier reduce to these:

<p><pre>
<I>xViewport = xWindow - xWinOrg + xViewOrg
yViewport = yWindow - yWinOrg + yViewOrg</I>
</pre>

<p>This is a &quot;text&quot; mapping mode not because it is most suitable for text but because of the orientation of the axes. In most languages, text is read from left to right and top to bottom, and MM_TEXT defines values on the axes to increase the same way:

<p><img src="G05zg02.jpg" width=189 height=126 border="0">

<p>Windows provides the functions <I>SetViewportOrgEx</I> and <I>SetWindowOrgEx</I> for changing the viewport and window origins. These functions have the effect of shifting the axes so that the logical point (0, 0) no longer refers to the upper left corner. Generally, you'll use either <I>SetViewportOrgEx</I> or <I>SetWindowOrgEx</I> but not both.

<p>Here's how the functions work: If you change the viewport origin to (<I>xViewOrg</I>, <I>yViewOrg</I>), the logical point (0, 0) will be mapped to the device point (<I>xViewOrg</I>, <I>yViewOrg</I>). If you change the window origin to (<I>xWinOrg</I>, <I>yWinOrg</I>), the logical point (<I>xWinOrg</I>, <I>yWinOrg</I>) will be mapped to the device point (0, 0), which is the upper left corner. Regardless of any changes you make to the window and viewport origins, the device point (0, 0) is always the upper left corner of the client area.

<p>For instance, suppose your client area is <I>cxClient</I> pixels wide and <I>cyClient</I> pixels high. If you want to define the logical point (0, 0) to be the center of the client area, you can do so by calling

<p><pre>
SetViewportOrgEx (hdc, cxClient / 2, cyClient / 2, NULL) ;
</pre>

<p>The arguments to <I>SetViewportOrgEx</I> are always in terms of device units. The logical point (0, 0) will now be mapped to the device point (<I>cxClient / 2</I>, <I>cyClient / 2</I>). Now you can use your client area as if it had the coordinate system shown below.

<p><img src="G05zg03.jpg" width=189 height=126 border="0">

<p>The logical <I>x</I>-axis ranges from <I>-cxClient/2</I> to <I>+cxClient/2</I>, and the logical <I>y</I>-axis ranges from <I>-cyClient/2</I> to <I>+cyClient/2</I>. The lower right corner of the client area is the logical point (<I>cxClient/2</I>, <I>cyClient/2</I>). If you want to display text starting at the upper left corner of the client area, which is the device point (0, 0), you need to use negative coordinates:

<p><pre>
TextOut (hdc, -cxClient / 2, -cyClient / 2, &quot;Hello&quot;, 5) ;
</pre>

<p>You can achieve the same result with <I>SetWindowOrgEx</I> as you did when you used <I>SetViewportOrgEx</I>:

<p><pre>
SetWindowOrgEx (hdc, -cxClient / 2, -cyClient / 2, NULL) ;
</pre>

<p>The arguments to <I>SetWindowOrgEx</I> are always in terms of logical units. After this call, the logical point (<I>-cxClient / 2</I>, <I>-cyClient / 2</I>) is mapped to the device point (0, 0), the upper left corner of the client area.

<p>What you probably don't want to do (unless you know what's going to happen) is to use both function calls together:

<p><pre>
SetViewportOrgEx (hdc, cxClient / 2, cyClient / 2, NULL) ;
SetWindowOrgEx (hdc, -cxClient / 2, -cyClient / 2, NULL) ;
</pre>

<p>This means that the logical point (<I>-cxClient/2</I>, <I>-cyClient/2</I>) is mapped to the device point (<I>cxClient/2</I>, <I>cyClient/2</I>), giving you a coordinate system that looks like this:

<p><img src="G05zg04.jpg" width=189 height=126 border="0">

<p>You can obtain the current viewport and window origins from these functions:

<p><pre>
GetViewportOrgEx (hdc, &amp;pt) ;
GetWindowOrgEx (hdc, &amp;pt) ;
</pre>

<p>where <I>pt</I> is a POINT structure. The values returned from <I>GetViewportOrgEx</I> are in device coordinates; the values returned from <I>GetWindowOrgEx</I> are in logical coordinates.

<p>You might want to change the viewport or window origin to shift display output within the client area of your window&#8212;for instance, in response to scroll bar input from the user. For example, in the SYSMETS2 program in <a href="ch04a.htm#62">Chapter 4</a>, we used the <I>iVscrollPos</I> value (the current position of the vertical scroll bar) to adjust the y-coordinates of the display output:

<p><pre>
case WM_PAINT:
     hdc = BeginPaint (hwnd, &amp;ps) ;
     
     for (i = 0 ; i &lt; NUMLINES ; i++)
     {
          y = cyChar * (i - iVscrollPos) ;
<I>          [display text]     </I>
     }
     EndPaint (hwnd, &amp;ps) ;
     return 0 ;
</pre>

<p>We can achieve the same result using <I>SetWindowOrgEx</I>:

<p><pre>
case WM_PAINT:
     hdc = BeginPaint (hwnd, &amp;ps) ;

     SetWindowOrgEx (hdc, 0, cyChar * iVscrollPos) ;

     for (i = 0 ; i &lt; NUMLINES ; i++)
     {
          y = cyChar * i ;
<I>          [display text]</I>
     }
     EndPaint (hwnd, &amp;ps) ;
     return 0 ;
</pre>

<p>Now the calculation of the y-coordinate for the <I>TextOut</I> functions doesn't require the <I>iVscrollPos</I> value. This means that you can put the text output calls in a separate function and not have to pass the <I>iVscrollPos</I> value to the function, because the display is adjusted by changing the window origin.

<p>If you have some experience working with rectangular (or Cartesian) coordinate systems, moving the logical point (0, 0) to the center of the client area as we did earlier may have seemed a reasonable action. However, there's a slight problem with the MM_TEXT mapping mode. Usually a Cartesian coordinate system defines values on the <I>y</I>-axis as increasing as you move up the axis, whereas MM_TEXT defines the values to increase as you move down the axis. In this sense, MM_TEXT is an oddity, and the next five mapping modes do it correctly.

<A NAME="130"><h2>The Metric Mapping Modes</h2></A>
<p>Windows includes five mapping modes that express logical coordinates in physical measurements. Because logical coordinates on the <I>x</I>-axis and <I>y</I>-axis are mapped to identical physical units, these mapping modes help you to draw round circles and square squares, even on a device that does not feature square pixels.

<p>The five metric mapping modes are arranged below in order of lowest precision to highest precision. The two columns at the right show the size of the logical units in terms of inches (in.) and millimeters (mm.) for comparison.

<table width="95%" cellpadding="5" valign="TOP"><p>
<tr>
<td valign=top><b><i>Mapping Mode</i></b></td>
<td valign=top><b><i>Logical Unit</i></b></td>
<td valign=top><b><i>Inch</i></b></td>
<td valign=top><b><i>Millimeter</i></b></td>
</tr>
<tr><td valign=top>MM_LOENGLISH </td>
<td valign=top>0.01 in.</td>
<td valign=top>0.01</td>
<td valign=top>0.254</td>
</tr>
<tr>
<td valign=top>MM_LOMETRIC</td>
<td valign=top>0.1 mm.</td>
<td valign=top>0.00394</td>
<td valign=top>0.1</td>
</tr>
<tr>
<td valign=top>MM_HIENGLISH</td>
<td valign=top>0.001 in.</td>
<td valign=top>0.001</td>
<td valign=top>0.0254</td>
</tr>
<tr>
<td valign=top>MM_TWIPS</td>
<td valign=top>1/1400 in.</td>
<td valign=top>0.000694</td>
<td valign=top>0.0176</td>
</tr>
<tr>
<td valign=top>MM_HIMETRIC</td>
<td valign=top>0.01 mm.</td>
<td valign=top>0.000394</td>
<td valign=top>0.01</td>
</tr>
</table>
<p>The default window and viewport origins and extents are
<p>
<table width="95%" cellpadding="5" valign="TOP">
<tr>
<td valign=top>Window origin:</td>
<td valign=top>(0, 0)</td>
<td valign=top>Can be changed</td>
</tr>
<tr>
<td valign=top>Viewport origin:</td>
<td valign=top>(0, 0)</td>
<td valign=top>Can be changed</td>
</tr>
<tr>
<td valign=top>Window extent:</td>
<td valign=top>(?, ?)</td>
<td valign=top>Cannot be changed</td>
</tr>
<tr>
<td valign=top>Viewport extent:</td>
<td valign=top>(?, ?)</td>
<td valign=top>Cannot be changed</td>
</tr>
</table>

<p>The question marks indicate that the window and viewport extents depend on the mapping mode and the resolution of the device. As I mentioned earlier, the extents aren't important by themselves but take on meaning when expressed as ratios. Here are the translation formulas again:

<p><pre>
<I>                                  xViewExt
xViewport = (xWindow </I>-<I> xWinOrg) &#215; ________ + xViewOrg 
                                  xWinExt

                                  yViewExt
yViewport = (yWindow </I>-<I> yWinOrg) &#215; ________ + yViewOrg
                                  yWinExt</I>

</pre>For MM_LOENGLISH, for example, Windows calculates the extents to be the following:

<p><PRE><I>     
xViewExt/xWinExt = number of horizontal pixels in 0.01 in.

<p>-yViewExt/yWinExt = negative number of vertical pixels in 0.01 in.
</I>
</pre>

<p>Windows uses information available from <I>GetDeviceCaps</I> to set these extents. This is somewhat different in Windows 98 and Windows NT.

<p>First, here's how it works in Windows 98: Suppose you have used the Display applet of the Control Panel to select a 96 dpi system font. <I>GetDeviceCaps</I> will return a value of 96 for both the LOGPIXELSX and LOGPIXELSY indexes. Windows uses these values for the viewport extents and sets the viewport and window extents as shown in the following table.

<p><table width="95%" cellpadding="5" valign="TOP">
<tr>
<td valign=top><b><i>Mapping Mode</i></b></td>
<td valign=top><b><i>Viewport Extents (</I>x<I>, </I>y<I>)</i></b></td>
<td valign=top><b><i>Window Extents (</I>x<I>, </I>y<I>)</i></b></td>
</tr>

<tr>
<td valign=top>MM_LOMETRIC </td>
<td valign=top> (96, 96)</td>
<td valign=top>(254, <I>-</I>254)</td>
</tr>

<tr><td valign=top>MM_HIMETRIC</td>
<td valign=top>(96, 96)</td>
<td valign=top>(2540, <I>-</I>2540)</td>
</tr>

<tr>
<td valign=top>MM_LOENGLISH</td>
<td valign=top>(96, 96)</td>
<td valign=top>(100, <I>-</I>100)</td>
</tr>

<tr>
<td valign=top>MM_HIENGLISH </td>
<td valign=top>(96, 96)</td>
<td valign=top>(1000, <I>-</I>1000)</td>
</tr>

<tr>
<td valign=top>MM_TWIPS  </td>
<td valign=top>(96, 96)</td>
<td valign=top>(1440, <I>-</I>1440)</td>
</tr>
</table>

<p>Thus, for MM_LOENGLISH, the ratio 96 divided by 100 is the number of pixels in 0.01 inches. For MM_LOMETRIC, the ratio 96 divided by 254 is the number of pixels in 0.1 millimeters.

<p>Windows NT uses a different approach to set the viewport and window extents (an approach actually consistent with earlier 16-bit versions of Windows). The viewport extents are based on the pixel dimensions of the screen. This is information obtained from <I>GetDeviceCaps</I> using the HORZRES and VERTRES indexes. The window extents are based on the assumed size of the display, which <I>GetDeviceCaps</I> returns when you use the HORZSIZE and VERTSIZE indexes. As I mentioned earlier, these values are commonly 320 and 240 millimeters. If you've set the pixel dimensions of your display to 1024 by 768, here are the values of the viewport and window extents that Windows NT reports.

<p>
<table width="95%" cellpadding="5" valign="TOP">
<tr>
<td valign=top><b><i>Mapping Mode</i></b></td>
<td valign=top><b><i>Viewport Extents (</I>x<I>, </I>y<I>)</i></b></td>
<td valign=top><b><i>Window Extents (</I>x<I>, </I>y<I>)</i></b></td>
</tr>

<tr>
<td valign=top>MM_LOMETRIC</td>
<td valign=top>(1024, <I>-</I>768)</td>
<td valign="top">(3200, 2400)</td>
</tr>

<tr>
<td valign=top>MM_HIMETRIC</td>
<td valign=top>(1024, <I>-</I>768)</td>

<td valign=top>(32000, 24000)</td>
</tr>

<tr>
<td valign=top>MM_LOENGLISH</td>
<td valign=top>(1024, <I>-</I>768)</td>
<td valign=top>(1260, 945)</td>
</tr>

<tr>
<td valign=top>MM_HIENGLISH</td>
<td valign=top>(1024, <I>-</I>768)</td>
<td valign=top>(12598, 9449)</td>
</tr>

<tr>
<td valign=top>MM_TWIPS</td>
<td valign=top>(1024, <I>-</I>768)</td>
<td valign=top>(18142, 13606)</td>
</tr>
</table>

<p>These window extents represent the number of logical units encompassing the full width and height of the display. A 320-millimeters wide screen is also 1260 MM_LOENGLISH units or 12.6 inches (320 divided by 25.4 millimeters per inch).

<p>Those negative signs in front of the <I>y</I> extents change the orientation of the axis. For these five mapping modes, <I>y</I> values increase as you move up the device. However, notice that the default window and viewport origins are both (0, 0). This has an interesting implication. When you first change to one of these five mapping modes, the coordinate system looks like the graph below.

<p><img src="G05zg05.GIF" width=189 height=126 border="0">

<p>The only way you can display anything in the client area is to use negative values of <I>y</I>. For instance, this code,

<p><pre>
SetMapMode (hdc, MM_LOENGLISH) ;
TextOut (hdc, 100, -100, &quot;Hello&quot;, 5) ;
</pre>

<p>displays the text one inch from the top and left edges of the client area.

<p>To preserve your sanity, you'll probably want to avoid this. One solution is to set the logical (0, 0) point to the lower left corner of the client area. Assuming that <I>cyClient</I> is the height of the client area in pixels, you can do this by calling <I>SetViewportOrgEx</I>:

<p><pre>
SetViewportOrgEx (hdc, 0, cyClient, NULL) ;
</pre>

<p>Now the coordinate system looks like this:

<p><img src="G05zg06.GIF" width=189 height=126 border="0">

<p>This is the upper right quadrant of a rectangular coordinate system.

<p>Alternatively, you can set the logical (0, 0) point to the center of the client area:

<p><pre>
SetViewportOrgEx (hdc, cxClient / 2, cyClient / 2, NULL) ;
</pre>

<p>The coordinate system looks like this:

<p><img src="G05zg07.GIF" width=189 height=126 border="0">

<p>Now we have a real four-quadrant Cartesian coordinate system with equal logical units on the <I>x</I>-axis and <I>y</I>-axis in terms of inches, millimeters, or twips.

<p>You can also use the <I>SetWindowOrgEx</I> function to change the logical (0, 0) point, but the task is a little more difficult because the arguments to <I>SetWindowOrgEx</I> have to be in logical coordinates. You would first need to convert (<I>cxClient</I>, <I>cyClient</I>) to a logical coordinate using the <I>DPtoLP</I> function. Assuming that the variable <I>pt</I> is a structure of type POINT, this code changes the logical (0, 0) point to the center of the client area:

<p><pre>
pt.x = cxClient ;
pt.y = cyClient ;
DptoLP (hdc, &amp;pt, 1) ;
SetWindowOrgEx (hdc, -pt.x / 2, -pt.y / 2, NULL) ;
</pre>

<A NAME="131"><h2>The &quot;Roll Your Own&quot; Mapping Modes</h2></A>
<p>The two remaining mapping modes are named MM_ISOTROPIC and MM_ANISOTROPIC. These are the only two mapping modes for which Windows lets you change the viewport and window extents, which means that you can change the scaling factor that Windows uses to translate logical and device coordinates. The word <I>isotropic</I> means &quot;equal in all directions&quot;; <I>anisotropic</I> is the opposite&#8212;&quot;not equal.&quot; Like the metric mapping modes shown earlier, MM_ISOTROPIC uses equally scaled axes. Logical units on the <I>x</I>-axis have the same physical dimensions as logical units on the <I>y</I>-axis. This helps when you need to create images that retain the correct aspect ratio regardless of the aspect ratio of the display device.

<p>The difference between MM_ISOTROPIC and the metric mapping modes is that with MM_ISOTROPIC you can control the physical size of the logical unit. If you want, you can adjust the size of the logical unit based on the client area. This lets you draw images that are always contained within the client area, shrinking and expanding appropriately. The two clock programs in <a href="ch08a.htm#215">Chapter 8</a> have isotropic images. As you size the window, the clocks are resized appropriately.

<p>A Windows program can handle the resizing of an image entirely through adjusting the window and viewport extents. The program can then use the same logical units in the drawing functions regardless of the size of the window.

<p>Sometimes MM_TEXT and the metric mapping modes are called &quot;fully constrained&quot; mapping modes. This means that you cannot change the window and viewport extents and the way Windows scales logical coordinates to device coordinates. MM_ISOTROPIC is a &quot;partly constrained&quot; mapping mode. Windows allows you to change the window and viewport extents, but it adjusts them so that <I>x</I> and <I>y</I> logical units represent the same physical dimensions. The MM_ANISOTROPIC mapping mode is &quot;unconstrained.&quot; You can change the window and viewport extents, and Windows doesn't adjust the values.

<A NAME="132"><h3>The MM_ISOTROPIC Mapping Mode</h3></A>

<p>The MM_ISOTROPIC mapping mode is ideal for using arbitrarily scaled axes while preserving equal logical units on the two axes. Rectangles with equal logical widths and heights are displayed as squares, and ellipses with equal logical widths and heights are displayed as circles.

<p>When you first set the mapping mode to MM_ISOTROPIC, Windows uses the same window and viewport extents that it uses with MM_LOMETRIC. (Don't rely on this fact, however.) The difference is that you can now change the extents to suit your preferences by calling <I>SetWindowExtEx</I> and <I>SetViewportExtEx</I>. Windows will then adjust the extents so that the logical units on both axes represent equal physical distances.

<p>Generally, you'll use arguments to <I>SetWindowExtEx</I> with the desired logical size of the logical windows, and arguments to <I>SetViewportExtEx</I> with the actual height and width of the client area. When Windows adjusts these extents, it has to fit the logical window within the physical viewport, which can result in a section of the client area falling outside the logical window. You should call <I>SetWindowExtEx</I> before you call <I>SetViewportExtEx</I> to make the most efficient use of space in the client area.

<p>For example, suppose you want a traditional one-quadrant virtual coordinate system where (0, 0) is at the lower left corner of the client area and the logical width and height ranges from 0 to 32,767. You want the <I>x</I> and <I>y</I> units to have the same physical dimensions. Here's what you need to do:

<p><pre>
SetMapMode (hdc, MM_ISOTROPIC) ;
SetWindowExtEx (hdc, 32767, 32767, NULL) ;
SetViewportExtEx (hdc, cxClient, -cyClient, NULL) ;
SetViewportOrgEx (hdc, 0, cyClient, NULL) ;
</pre>

<p>If you then obtain the window and viewport extents using <I>GetWindowExtEx</I> and <I>GetViewportExtEx</I>, you'll find that they are not the values you specified. Windows has adjusted the extents based on the aspect ratio of the display device so that logical units on the two axes represent the same physical dimensions.

<p>If the client area is wider than it is high (in physical dimensions), Windows adjusts the <I>x</I> extents so that the logical window is narrower than the client-area viewport. The logical window will be positioned at the left of the client area:

<p><img src="G05zg08.GIF" width=300 height=126 border="0">

<p>Windows 98 will actually not allow you to display anything in the right side of the client area because it is limited to 16-bit signed coordinates. Windows NT uses a full 32-bits for coordinates, and you would be able to display something over in the right side.

<p>If the client area is higher than it is wide (in physical dimensions), Windows 
adjust the <I>y</I> extents. The logical window will be positioned at the bottom of the client area:

<p><img src="G05zg09.GIF" width=136 height=231 border="0">

<p>Windows 98 will not allow you to display anything at the top of the client area.

<p>If you prefer that the logical window always be positioned at the left and top of the client area, you can change the code to the following:

<p><pre>
SetMapMode (MM_ISOTROPIC) ;
SetWindowExtEx (hdc, 32767, 32767, NULL) ;
SetViewportExtEx (hdc, cxClient, -cyClient, NULL) ;
SetWindowOrgEx (hdc, 0, 32767, NULL) ;
</pre>

<p>In the <I>SetWindowOrgEx</I> call, we're saying that we want the logical point (0, 32767) to be mapped to the device point (0, 0). Now, if the client area is higher than it is wide, the coordinates are arranged like this:

<p><img src="G05zg10.GIF" width=136 height=231 border="0">

<p>For a clock program, you might want to use a four-quadrant Cartesian coordinate system with arbitrarily scaled axes in four directions in which the logical point (0, 0) is in the center of the client area. If you want each axis to range from 0 to 1000 (for instance), you use this code:

<p><pre>
SetMapMode (hdc, MM_ISOTROPIC) ;
SetWindowExtEx (hdc, 1000, 1000, NULL) ;
SetViewportExtEx (hdc, cxClient / 2, -cyClient / 2, NULL) ;
SetViewportOrgEx (hdc, cxClient / 2, cyClient / 2, NULL) ;
</pre>

<p>The logical coordinates look like this if the client area is wider than it is high:

<p><img src="G05zg11.GIF" width=231 height=136 ALIGN="BOTTOM">

<p>The logical coordinates are also centered if the client area is higher than it is wide, as shown below.

<p><img src="G05zg12.GIF" width=136 height=231 ALIGN="BOTTOM">

<p>Keep in mind that no clipping is implied in window or viewport extents. When calling GDI functions, you are still free to use logical <I>x</I> and <I>y</I> values less than <I>-</I>1000 and greater than +1000. Depending on the shape of the client area, these points might or might not be visible.

<p>With the MM_ISOTROPIC mapping mode, you can make logical units larger than pixels. For instance, suppose you want a mapping mode with the point (0, 0) at the upper left corner of the display and values of <I>y</I> increasing as you move down (like MM_TEXT) but with logical coordinates in sixteenths of an inch. Here's one way to do it:

<p><pre>
SetMapMode (hdc, MM_ISOTROPIC) ;
SetWindowExtEx (hdc, 16, 16, NULL) ;
SetViewportExtEx (hdc, GetDeviceCaps (hdc, LOGPIXELSX),
                       GetDeviceCaps (hdc, LOGPIXELSY), NULL) ;
</pre>

<p>The arguments to the <I>SetWindowExtEx</I> function indicate the number of logical units in one inch. The arguments to the <I>SetViewportExtEx</I> function indicate the number of physical units (pixels) in one inch.

<p>However, this approach would <I>not</I> be consistent with the metric mapping modes in Windows NT. These mapping modes use the pixel size and metric size of the display. To be consistent with the metric mapping modes, you can use this code:

<p><pre>
SetMapMode (hdc, MM_ISOTROPIC) ;
SetWindowExtEx (hdc, 160 * GetDeviceCaps (hdc, HORZSIZE) / 254,
                     160 * GetDeviceCaps (hdc, VERTSIZE) / 254, NULL) ;
SetViewportExtEx (hdc, GetDeviceCaps (hdc, HORZRES),
                       GetDeviceCaps (hdc, VERTRES), NULL) ;
</pre>

<p>In this code, the viewport extents are set to the pixel dimensions of the entire screen. The window extents are set to the assumed dimension of the screen in units of sixteenths of an inch. <I>GetDeviceCaps</I> with the HORZRES and VERTRES indexes return the dimensions of the device in millimeters. If we were working with floating-point numbers, we would convert the millimeters to inches by dividing by 25.4 and then convert inches to sixteenths of an inch by multiplying by 16. However, because we're working with integers, we must multiply by 160 and divide by 254.

<p>Of course, such a coordinate system makes logical units much larger than physical units. Everything you draw on the device will have coordinate values that map to an increment of 1/16 inch. You cannot draw two horizontal lines that are 1/32 inch apart because that would require a fractional logical coordinate.
<A NAME="133"><h3>MM_ANISOTROPIC: Stretching the Image to Fit</h3></A>
<p>When you set the viewport and window extents in the MM_ISOTROPIC mapping mode, Windows adjusts the values so that logical units on the two axes have the same physical dimensions. In the MM_ANISOTROPIC mapping mode, Windows makes no adjustments to the values you set. This means that MM_ANISOTROPIC does not necessarily maintain the correct aspect ratio.

<p>One way you can use MM_ANISOTROPIC is to have arbitrary coordinates for the client area, as we did with MM_ISOTROPIC. This code sets the point (0, 0) at the lower left corner of the client area with the <I>x</I> and <I>y</I> axes ranging from 0 to 32,767:

<p><pre>
SetMapMode (hdc, MM_ANISOTROPIC) ;
SetWindowExtEx (hdc, 32767, 32767, NULL) ;
SetViewportExtEx (hdc, cxClient, -cyClient, NULL) ;
SetViewportOrgEx (hdc, 0, cyClient, NULL) ;
</pre>

<p>With MM_ISOTROPIC, similar code caused part of the client area to be beyond the range of the axes. With MM_ANISOTROPIC, the upper right corner of the client area is always the point (32767, 32767), regardless of its dimensions. If the client area is not square, logical <I>x</I> and <I>y</I> units will have different physical dimensions.

<p>In the previous section on the MM_ISOTROPIC mapping mode, I discussed how you might draw a round clock in the client area where the <I>x</I> and <I>y</I> axes ranged from -1000 to 1000. You can do something similar with MM_ANISOTROPIC:

<p><pre>
SetMapMode (hdc, MM_ANISOTROPIC) ;
SetWindowExtEx (hdc, 1000, 1000, NULL) ;
SetViewportExtEx (hdc, cxClient / 2, -cyClient / 2, NULL) ;
SetViewportOrgEx (hdc, cxClient / 2, cyClient / 2, NULL) ;
</pre>

<p>The difference with MM_ANISOTROPIC is that in general the clock would be drawn as an ellipse rather than a circle.

<p>Another way to use MM_ANISOTROPIC is to set <I>x</I> and <I>y</I> units to fixed but unequal values. For instance, if you have a program that displays only text, you may want to set coarse coordinates based on the height and width of a single character:

<p><pre>
SetMapMode (hdc, MM_ANISOTROPIC) ;
SetWindowExtEx (hdc, 1, 1, NULL) ;
SetViewportExtEx (hdc, cxChar, cyChar, NULL) ;
</pre>

<p>Of course, I've assumed that <I>cxChar</I> and <I>cyChar</I> are the width and height of characters in that font. Now you can specify coordinates in terms of character rows and columns. For instance, the following statement displays text three characters from the left and two character rows from the top of the client area:

<p><pre>
TextOut (hdc, 3, 2, TEXT (&quot;Hello&quot;), 5) ;
</pre>

<p>This might be more appropriate if you're using a fixed-point font, as in the upcoming WHATSIZE program.

<p>When you first set the MM_ANISOTROPIC mapping mode, it always inherits the extents of the previously set mapping mode. This can be very convenient. One way of thinking about MM_ANISTROPIC is that it &quot;unlocks&quot; the extents; that is, it allows you to change the extents of an otherwise fully-constrained mapping mode. For instance, suppose you want to use the MM_LOENGLISH mapping mode because you want logical units to be 0.01 inch. But you don't want the values along the <I>y</I>-axis to increase as you move up the screen&#8212;you prefer the MM_TEXT orientation, where <I>y</I> values increase moving down. Here's the code:

<p><pre>
SIZE size ;
<I>[other program lines]</I>
SetMapMode (hdc, MM_LOENGLISH) ;
SetMapMode (hdc, MM_ANISOTROPIC) ;
GetViewportExtEx (hdc, &amp;size) ;
SetViewportExtEx (hdc, size.cx, -size.cy, NULL) ;
</pre>

<p>We first set the mapping mode to MM_LOENGLISH. Then we liberate the extents by setting the mapping mode to MM_ANISOTROPIC. The <I>GetViewportExtEx</I> function obtains the viewport extents in a SIZE structure. Then we call <I>SetViewportExtEx</I> with the extents, except that the <I>y</I> extent is made negative.


<A NAME="134"><h2>The WHATSIZE Program</h2></A>
<p>A little Windows history: The first how-to-program-for-Windows article appeared in the December 1986 issue of <I>Microsoft Systems Journal</I>. The sample program in that article was called WSZ (&quot;what size&quot;), and it displayed the size of a client area in pixels, inches, and millimeters. A simplified version of that program is WHATSIZE, shown in Figure 5-24. The program shows the dimensions of the window's client area in terms of the five metric mapping modes.



<p><B>Figure 5-24.</B> <I>The WHATSIZE program.</I>
<table width="95%" cellpadding="5" valign="TOP">
<tr><td valign=top><A NAME="135"><h3>WHATSIZE.C</h3></A>
<p><pre>
/*-----------------------------------------
   WHATSIZE.C -- What Size is the Window?
                 (c) Charles Petzold, 1998
  -----------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;WhatSize&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;

     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;What Size is the Window?&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}
void Show (HWND hwnd, HDC hdc, int xText, int yText, int iMapMode,
           TCHAR * szMapMode)
{
     TCHAR szBuffer [60] ;
     RECT  rect ;
     
     SaveDC (hdc) ;
     
     SetMapMode (hdc, iMapMode) ;
     GetClientRect (hwnd, &amp;rect) ;
     DPtoLP (hdc, (PPOINT) &amp;rect, 2) ;
     
     RestoreDC (hdc, -1) ;
     
     TextOut (hdc, xText, yText, szBuffer,
              wsprintf (szBuffer, TEXT (&quot;%-20s %7d %7d %7d %7d&quot;), szMapMode,
              rect.left, rect.right, rect.top, rect.bottom)) ;
}  

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static TCHAR szHeading [] =
          TEXT (&quot;Mapping Mode            Left   Right     Top  Bottom&quot;) ;
     static TCHAR szUndLine [] = 
          TEXT (&quot;------------            ----   -----     ---  ------&quot;) ;
     static int   cxChar, cyChar ;
     HDC          hdc ;
     PAINTSTRUCT  ps ;
     TEXTMETRIC   tm ;
     
     switch (message)
     {
     case WM_CREATE:
          hdc = GetDC (hwnd) ;
          SelectObject (hdc, GetStockObject (SYSTEM_FIXED_FONT)) ;
          
          GetTextMetrics (hdc, &amp;tm) ;
          cxChar = tm.tmAveCharWidth ;
          cyChar = tm.tmHeight + tm.tmExternalLeading ;
          
          ReleaseDC (hwnd, hdc) ;
          return 0 ;
          
     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
          SelectObject (hdc, GetStockObject (SYSTEM_FIXED_FONT)) ;

          SetMapMode (hdc, MM_ANISOTROPIC) ;
          SetWindowExtEx (hdc, 1, 1, NULL) ;
          SetViewportExtEx (hdc, cxChar, cyChar, NULL) ;
          
          TextOut (hdc, 1, 1, szHeading, lstrlen (szHeading)) ;
          TextOut (hdc, 1, 2, szUndLine, lstrlen (szUndLine)) ;
          
          Show (hwnd, hdc, 1, 3, MM_TEXT,      TEXT (&quot;TEXT (pixels)&quot;)) ;
          Show (hwnd, hdc, 1, 4, MM_LOMETRIC,  TEXT (&quot;LOMETRIC (.1 mm)&quot;)) ;
          Show (hwnd, hdc, 1, 5, MM_HIMETRIC,  TEXT (&quot;HIMETRIC (.01 mm)&quot;)) ;
          Show (hwnd, hdc, 1, 6, MM_LOENGLISH, TEXT (&quot;LOENGLISH (.01 in)&quot;)) ;
          Show (hwnd, hdc, 1, 7, MM_HIENGLISH, TEXT (&quot;HIENGLISH (.001 in)&quot;)) ;
          Show (hwnd, hdc, 1, 8, MM_TWIPS,     TEXT (&quot;TWIPS (1/1440 in)&quot;)) ;
          
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</PRE></td></tr>
</table>

<p>For ease in displaying the information using the <I>TextOut</I> function, WHATSIZE uses a fixed-pitch font. Switching to a fixed-pitch font (which was the default prior to Windows 3.0) involves this simple statement:

<p><pre>
SelectObject (hdc, GetStockObject (SYSTEM_FIXED_FONT)) ;
</pre>

<p>These are the same two functions used for selecting stock pens and brushes. WHATSIZE also uses the MM_ANISTROPIC mapping mode with logical units set to character dimensions, as shown earlier.

<p>When WHATSIZE needs to obtain the size of the client area for one of the six mapping modes, it saves the current device context, sets a new mapping mode, obtains the client-area coordinates, converts them to logical coordinates, and then restores the original mapping mode before displaying the information. This code is in WHATSIZE's <I>Show</I> function:

<p><pre>
SaveDC (hdc) ;
SetMapMode (hdc, iMapMode) ;
GetClientRect (hwnd, &amp;rect) ;
DptoLP (hdc, (PPOINT) &amp;rect, 2) ;
RestoreDC (hdc, -1) ;
</pre>

<p>Figure 5-25 shows a typical display from WHATSIZE.

<p><A HREF="javascript:fullSize('F05zg25x.htm')"> <img src="F05zg25.JPG" width=404 height=303 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 5-25.</B> <I>A typical WHATSIZE display.</I><!-- /caption -->

</BODY>
</HTML>






