<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Waveform Audio</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="756"><h1>Waveform Audio</h1></A>
<P>Waveform audio is the most utilized multimedia feature of Windows. The waveform audio facilities can capture sounds coming through a microphone, turn them into numbers, and store them in memory or on disk in waveform files with the extension .WAV. The sounds can then be played back.

<A NAME="757"><h2>Sound and Waveforms</h2></A>
<P>Before plunging into the waveform audio API, it's important to have an understanding of the physics and perception of sound and the process by which sounds can get in and out of our computers.

<P>Sound is vibration. The human body perceives sound as it changes the air pressure on our eardrums. A microphone can pick up these vibrations and translate them into electrical currents. Similarly, electrical currents can be sent to amplifiers and speakers for rendering back into sound. In traditional analog forms of sound storage (such as audio tape and the phonograph record) these vibrations are stored as magnetic pulses or contoured grooves. When a sound is translated into an electrical current, it can be represented by a waveform that shows vibrations over time. The most natural form of vibration is represented by the sine wave, one cycle of which was shown earlier in this book in Figure 5-7.

<P>The sine wave has two parameters&#8212;amplitude (that is, the maximum amplitude over the course of one cycle) and frequency. We perceive amplitude as loudness and frequency as pitch. Human ears are generally said to be sensitive to sine waves ranging from low-pitched sounds at 20 Hz (cycles per second) to high-pitched sounds at 20,000 Hz, although sensitivity to these higher sounds degrades with age.

<P>Human perception of frequency is logarithmic rather than linear. That is, we perceive the frequency change from 20 Hz to 40 Hz to be the same as the frequency change from 40 Hz to 80 Hz. In music, this doubling of frequency defines the octave. Thus, the human ear is sensitive to about 10 octaves of sound. The range of a piano is a little over 7 octaves, from 27.5 Hz to 4186 Hz.

<P>Although sine waves represent the most natural form of vibration, sine waves rarely occur in nature in pure forms. Moreover, pure sine waves are not very interesting sounds. Most sounds are much more complex.

<P>Any periodic waveform (that is, a waveform that repeats itself) can be decomposed into multiple sine waves whose frequency relationships are in integer multiples. This is called a Fourier series, named after the French mathematician and physicist Jean Baptiste Joseph Fourier (1768&#8211;1830). The frequency of periodicity is known as the fundamental. The other sine waves in the series have frequencies that are 2, 3, 4 (and so forth) times the frequency of the fundamental. These are called overtones. The fundamental is also called the first harmonic. The first overtone is the second harmonic, and so forth.

<P>The relative intensities of the sine wave harmonics give each periodic waveform a unique sound. This is known as &quot;timbre,&quot; and it's what makes a trumpet sound like a trumpet and a piano sound like a piano.

<P>At one time it was believed that electronically synthesizing musical instruments required merely that sounds be broken down into harmonics and reconstructed with multiple sine waves. However, it turned out that real-world sounds are not quite so simple. Waveforms representing real-world sounds are never strictly periodic. Relative intensities of harmonics are different over the range of a musical instrument and the harmonics change with time as each note is played. In particular, the beginning of a note played on a musical instrument&#8212;called the attack&#8212;can be quite complex and is vital to our perception of timbre.

<P>Due to the increase in digital storage capabilities in recent years, it has become possible to store sounds directly in a digital form without any complex deconstruction.

<A NAME="758"><h2>Pulse Code Modulation</h2></A>
<P>Computers work with numbers, so to get sounds into our computers, it is necessary to devise a mechanism to convert sound to numbers and back again from numbers to sound.

<P>The most common method of doing this without compressing data is called &quot;pulse code modulation&quot; (PCM). PCM is used on compact discs, digital audio tapes, and in Windows. Pulse code modulation is a fancy term for a conceptually simple process.

<P>With pulse code modulation, a waveform is sampled at a constant periodic rate, usually some tens of thousands of times per second. For each sample, the amplitude of the waveform is measured. The hardware that does the job of converting an amplitude into a number is an analog-to-digital converter (ADC). Similarly, numbers can be converted back into electrical waveforms using a digital-to-analog converter (DAC). What comes out is not exactly what goes in. The resultant waveform has sharp edges that are high-frequency components. For this reason, playback hardware generally includes a low-pass filter following the digital-to-analog converter. This filter removes the high frequencies and smooths out the resultant waveform. On the input side, a low-pass filter comes before the ADC.

<P>Pulse code modulation has two parameters: the sample rate, or how many times per second you measure the waveform amplitude, and the sample size, or the number of bits you use to store the amplitude level. As you might expect, the faster the sampling rate and the larger the sample size, the better the reproduction of the original sound. However, there is a point where any improvements to the sampling rate and sample size are overkill because they go beyond the resolution of human perception. On the other hand, making the sampling rate and sample size too low can cause problems in accurately reproducing music and other sounds.

<A NAME="759"><h2>The Sampling Rate</h2></A>
<P>The sampling rate determines the maximum frequency of sound that can be digitized and stored. In particular, the sampling rate must be twice the highest frequency of sampled sound. This is known as the &quot;Nyquist Frequency,&quot; named after Harry Nyquist, an engineer who did research in the 1930s into sampling processes.

<P>When a sine wave is sampled with too low a sampling rate, the resultant waveform has a lower frequency than the original. This is known as an alias. To avoid the problem of aliases, a low-pass filter is used on the input side to block all frequencies greater than half the sampling rate. On the output side, the rough edges of the waveform produced by the digital-to-analog converter are actually overtones composed of frequencies greater than half the sampling rate. Thus, a low-pass filter on the output side also blocks all frequencies greater than half the sampling rate.

<P>The sampling rate used on audio CDs is 44,100 samples per second, or 44.1 kHz. The origin of this peculiar number is as follows:

<P>The human ear can hear up to 20 kHz, so to capture the entire audio range that can be heard by humans, a sampling rate of 40 kHz is required. However, because low-pass filters have a roll-off effect, the sampling rate should be about 10 percent higher than that. Now we're up to 44 kHz. Just in case we want to record digital audio along with video, the sampling rate should be an integral multiple of the American and European television frame rates, which are 30 Hz and 25 Hz respectively. That pushes the sampling rate up to 44.1 kHz.

<P>The compact disc sampling rate of 44.1 kHz produces a lot of data and might be overkill for some applications, such as recording voice rather than music. Halving the sampling rate to 22.05 kHz reduces the upper range of reproducible sound by one octave to 10 kHz. Halving it again to 11.025 kHz gives us a frequency range to 5 kHz. Sampling rates of 44.1 kHz, 22.05 kHz, and 11.025 kHz, as well as 8 kHz, are the standards commonly supported by waveform audio devices.

<P>You might think that a sampling rate of 11.025 kHz is adequate for recording a piano because the highest frequency of a piano is 4186 Hz. However, 4186 Hz is the highest <I>fundamental</I> of a piano. Cutting off all sine waves above 5000 Hz reduces the overtones that can be reproduced and will not accurately capture and reproduce the piano sound.

<A NAME="760"><h2>The Sample Size</h2></A>
<P>The second parameter in pulse code modulation is the sample size measured in bits. The sample size determines the difference between the softest sound and loudest sound that can be recorded and played back. This is known as the dynamic range.

<P>Sound intensity is the square of the waveform amplitude (that is, the composite of the maximum amplitudes that each sine wave reaches over the course of one cycle). As is the case with frequency, human perception of sound intensity is logarithmic.

<P>The difference in intensity between two sounds is measured in bels (named after Alexander Graham Bell, the inventor of the telephone) and decibels (dB). A bel is a tenfold increase in sound intensity. One dB is one tenth of a bel in equal multiplicative steps. Hence, one dB is an increase in sound intensity of 1.26 (that is, the 10th root of 10), or an increase in waveform amplitude of 1.12 (the 20th root of 10). A decibel is about the lowest increase in sound intensity that the ear can perceive. The difference in intensity between sounds at the threshold of hearing and sounds at the threshold of pain is about 100 dB.

<P>You can calculate the dynamic range in decibels between two sounds with the following formula:

<P><IMG SRC="G22zg01.GIF" width=153 height=60 ALIGN="BOTTOM">

<P>where <I>A<SUB>1</SUB></I> and <I>A<SUB>2</SUB></I> are the amplitudes of the two sounds. With a sample size of 1 bit, the dynamic range is zero, because only one amplitude is possible.

<P>With a sample size of 8 bits, the ratio of the largest amplitude to the smallest amplitude is 256. Thus, the dynamic range is

<P><IMG SRC="G22zg02.GIF" width=151 height=28 ALIGN="BOTTOM">

<P>or 48 decibels. A 48-dB dynamic range is about the difference between a quiet room and a power lawn mower. Doubling the sample size to 16 bits yields a dynamic range of

<P><IMG SRC="G22zg03.GIF" width=173 height=28 ALIGN="BOTTOM">

<P>or 96 decibels. This is very nearly the difference between the threshold of hearing and the threshold of pain and is considered just about ideal for the reproduction of music.

<P>Both 8-bit and 16-bit sample sizes are supported under Windows. When storing 8-bit samples, the samples are treated as unsigned bytes. Silence would be stored as a string of 0x80 values. The 16-bit samples are treated as signed integers, so silence would be stored as a string of zeros.

<P>To calculate the storage space required for uncompressed audio, multiply the duration of the sound in seconds by the sampling rate. Double that if you're using 16-bit samples rather than 8-bit samples. Double that again if you're recording in stereo. For example, an hour of CD-quality sound (or 3600 seconds at 44,100 samples per second with 2 bytes per sample in stereo) requires 635 megabytes, not coincidentally very close to the storage capability of CD&#8211;ROM.

<A NAME="761"><h2>Generating Sine Waves in Software</h2></A>
<P>For our first exercise in waveform audio, we're not going to save sounds to files or play back recorded sounds. We're going to use the low-level waveform audio APIs (that is, the functions beginning with the prefix <I>waveOut</I>) to create an audio sine wave generator called SINEWAVE. This program generates sine waves from 20 Hz (the bottom of human perception) to 5,000 Hz (two octaves short of the top of human perception) in 1 Hz increments.

<P>As you know, the standard C run-time library includes a function called <I>sin</I> that returns the sine of an angle given in radians. (Two &#960; (2 times pi) radians equals 360 degrees.) The <I>sin</I> function returns a value ranging from &#8211;1 to 1. (We used this function in another program called SINEWAVE way back in <a href="ch05a.htm#94">Chapter 5</a>.) Thus, it should be easy to use the <I>sin</I> function to generate sine wave data to output to the waveform audio hardware. Basically, you fill a buffer up with data representing the waveform (in this case, a sine wave) and pass it to the API. (It's a little more complicated than that, but I'll get to the details shortly.) When the waveform audio hardware finishes playing the buffer, you pass it a second buffer, and so forth.

<P>When first considering this problem (and not knowing anything about PCM), you might think it reasonable to divide one cycle of the sine wave into a fixed number of samples&#8212;for example, 360. For a 20-Hz sine wave, you output 7200 samples every second. For a 200-Hz sine wave, you output 72,000 samples per second. That might work, but it's not the way to do it. For a 5000-Hz sine wave, you'd need to output 1,800,000 samples per second, which would surely tax the DAC! Moreover, for the higher frequencies, this is much more precision than is needed.

<P>With pulse code modulation, the sample rate is a constant. Let's assume the sample rate is 11,025 Hz because that's what I use in the SINEWAVE program. If you wish to generate a sine wave of 2,756.25 Hz (exactly one-quarter the sample rate), each cycle of the sine wave is just 4 samples. For a sine wave of 25 Hz, each cycle requires 441 samples. In general, the number of samples per cycle is the sample rate divided by the desired sine wave frequency. Once you know the number of samples per cycle, you can divide 2&#960; (2 times pi) radians by that number and use the <I>sin</I> function to get the samples for one cycle. Then just repeat the samples for one cycle over and over again to create a continuous waveform.


<P>The problem is the number of samples per cycle may well be fractional, so this approach won't work well either. You'd get a discontinuity at the end of each cycle.

<P>The key to making this work correctly is to maintain a static &quot;phase angle&quot; variable. This angle is initialized at 0. The first sample is the sine of 0 degrees. The phase angle is then incremented by 2&#960; (2 times pi) times the frequency, divided by the sample rate. Use this phase angle for the second sample, and continue in this way. Whenever the phase angle gets above 2&#960; (2 times pi) radians, subtract 2&#960; (2 times pi) radians from it. But don't ever reinitialize it to 0.

<P>For example, suppose you want to generate a sine wave of 1000 Hz with a sample rate of 11,025 Hz. That's about 11 samples per cycle. The phase angles&#8212;and here I'll give them in degrees to make this a little more comprehensible&#8212;for approximately the first cycle and a half are 0, 32.65, 65.31, 97.96, 130.61, 163.27, 195.92, 228.57, 261.22, 293.88, 326.53, 359.18, 31.84, 64.49, 97.14, 129.80, 162.45, 195.10, and so forth. The waveform data you put in the buffer are the sines of these angles, scaled to the number of bits per sample. When creating the data for a subsequent buffer, you keep incrementing the last phase angle value without reinitializing it to zero.

<P>A function called <I>FillBuffer</I> that does this&#8212;along with the rest of the SINEWAVE program&#8212;is shown in Figure 22-2.

<P><B>Figure 22-2.</b> <i>The SINEWAVE program.     </I>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="762"><h3>SINEWAVE.C</h3></A>
<P><pre>
/*------------------------------------------------------
   SINEWAVE.C -- Multimedia Windows Sine Wave Generator
                 (c) Charles Petzold, 1998
  ------------------------------------------------------*/

#include &lt;windows.h&gt;
#include &lt;math.h&gt;
#include &quot;resource.h&quot;

#define SAMPLE_RATE     11025
#define FREQ_MIN           20
#define FREQ_MAX         5000
#define FREQ_INIT         440
#define OUT_BUFFER_SIZE  4096
#define PI                  3.14159

BOOL CALLBACK DlgProc (HWND, UINT, WPARAM, LPARAM) ;

TCHAR szAppName [] = TEXT (&quot;SineWave&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     if (-1 == DialogBox (hInstance, szAppName, NULL, DlgProc))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
     }
     return 0 ;
}

VOID FillBuffer (PBYTE pBuffer, int iFreq)
{
     static double fAngle ;
     int           i ;

     for (i = 0 ; i &lt; OUT_BUFFER_SIZE ; i++)
     {
          pBuffer [i] = (BYTE) (127 + 127 * sin (fAngle)) ;

          fAngle += 2 * PI * iFreq / SAMPLE_RATE ;

          if (fAngle &gt; 2 * PI)

               fAngle -= 2 * PI ;
     }
}

BOOL CALLBACK DlgProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static BOOL         bShutOff, bClosing ;
     static HWAVEOUT     hWaveOut ;
     static HWND         hwndScroll ;
     static int          iFreq = FREQ_INIT ;
     static PBYTE        pBuffer1, pBuffer2 ;
     static PWAVEHDR     pWaveHdr1, pWaveHdr2 ;
     static WAVEFORMATEX waveformat ;
     int                 iDummy ;
     
     switch (message)
     {
     case WM_INITDIALOG:
          hwndScroll = GetDlgItem (hwnd, IDC_SCROLL) ;
          SetScrollRange (hwndScroll, SB_CTL, FREQ_MIN, FREQ_MAX, FALSE) ;
          SetScrollPos   (hwndScroll, SB_CTL, FREQ_INIT, TRUE) ;
          SetDlgItemInt  (hwnd, IDC_TEXT, FREQ_INIT, FALSE) ;
          
          return TRUE ;
          
     case WM_HSCROLL:
          switch (LOWORD (wParam))
          {
          case SB_LINELEFT:  iFreq -=  1 ;  break ;
          case SB_LINERIGHT: iFreq +=  1 ;  break ;
          case SB_PAGELEFT:  iFreq /=  2 ;  break ;
          case SB_PAGERIGHT: iFreq *=  2 ;  break ;
               
          case SB_THUMBTRACK:
               iFreq = HIWORD (wParam) ;
               break ;
               
          case SB_TOP:
               GetScrollRange (hwndScroll, SB_CTL, &amp;iFreq, &amp;iDummy) ;
               break ;
               
          case SB_BOTTOM:
               GetScrollRange (hwndScroll, SB_CTL, &amp;iDummy, &amp;iFreq) ;
               break ;
          }
          
          iFreq = max (FREQ_MIN, min (FREQ_MAX, iFreq)) ;

          SetScrollPos (hwndScroll, SB_CTL, iFreq, TRUE) ;
          SetDlgItemInt (hwnd, IDC_TEXT, iFreq, FALSE) ;
          return TRUE ;
          
     case WM_COMMAND:
          switch (LOWORD (wParam))
          {
          case IDC_ONOFF:
                    // If turning on waveform, hWaveOut is NULL
               
               if (hWaveOut == NULL)
               {
                         // Allocate memory for 2 headers and 2 buffers

                    pWaveHdr1 = malloc (sizeof (WAVEHDR)) ;
                    pWaveHdr2 = malloc (sizeof (WAVEHDR)) ;
                    pBuffer1  = malloc (OUT_BUFFER_SIZE) ;
                    pBuffer2  = malloc (OUT_BUFFER_SIZE) ;

                    if (!pWaveHdr1 || !pWaveHdr2 || !pBuffer1 || !pBuffer2)
                    {
                         if (!pWaveHdr1) free (pWaveHdr1) ;
                         if (!pWaveHdr2) free (pWaveHdr2) ;
                         if (!pBuffer1)  free (pBuffer1) ;
                         if (!pBuffer2)  free (pBuffer2) ;

                         MessageBeep (MB_ICONEXCLAMATION) ;
                         MessageBox (hwnd, TEXT (&quot;Error allocating memory!&quot;),
                                     szAppName, MB_ICONEXCLAMATION | MB_OK) ;
                         return TRUE ;
                    }

                         // Variable to indicate Off button pressed

                    bShutOff = FALSE ;
                         
                         // Open waveform audio for output
                         
                    waveformat.wFormatTag      = WAVE_FORMAT_PCM ;
                    waveformat.nChannels       = 1 ;
                    waveformat.nSamplesPerSec  = SAMPLE_RATE ;
                    waveformat.nAvgBytesPerSec = SAMPLE_RATE ;
                    waveformat.nBlockAlign     = 1 ;
                    waveformat.wBitsPerSample  = 8 ;
                    waveformat.cbSize          = 0 ;
                         
                    if (waveOutOpen (&amp;hWaveOut, WAVE_MAPPER, &amp;waveformat,
                                     (DWORD) hwnd, 0, CALLBACK_WINDOW)
                              != MMSYSERR_NOERROR)
                    {
                         free (pWaveHdr1) ;
                         free (pWaveHdr2) ;
                         free (pBuffer1) ;
                         free (pBuffer2) ;

                         hWaveOut = NULL ;
                         MessageBeep (MB_ICONEXCLAMATION) ;
                         MessageBox (hwnd, 
                              TEXT (&quot;Error opening waveform audio device!&quot;),
                              szAppName, MB_ICONEXCLAMATION | MB_OK) ;
                         return TRUE ;
                    }

                         // Set up headers and prepare them

                    pWaveHdr1-&gt;lpData          = pBuffer1 ;
                    pWaveHdr1-&gt;dwBufferLength  = OUT_BUFFER_SIZE ;
                    pWaveHdr1-&gt;dwBytesRecorded = 0 ;
                    pWaveHdr1-&gt;dwUser          = 0 ;
                    pWaveHdr1-&gt;dwFlags         = 0 ;
                    pWaveHdr1-&gt;dwLoops         = 1 ;
                    pWaveHdr1-&gt;lpNext          = NULL ;
                    pWaveHdr1-&gt;reserved        = 0 ;
                    
                    waveOutPrepareHeader (hWaveOut, pWaveHdr1, 
                                          sizeof (WAVEHDR)) ;

                    pWaveHdr2-&gt;lpData          = pBuffer2 ;
                    pWaveHdr2-&gt;dwBufferLength  = OUT_BUFFER_SIZE ;
                    pWaveHdr2-&gt;dwBytesRecorded = 0 ;
                    pWaveHdr2-&gt;dwUser          = 0 ;
                    pWaveHdr2-&gt;dwFlags         = 0 ;
                    pWaveHdr2-&gt;dwLoops         = 1 ;
                    pWaveHdr2-&gt;lpNext          = NULL ;
                    pWaveHdr2-&gt;reserved        = 0 ;
                    
                    waveOutPrepareHeader (hWaveOut, pWaveHdr2,
                                          sizeof (WAVEHDR)) ;
               }
                    // If turning off waveform, reset waveform audio
               else
               {
                    bShutOff = TRUE ;

                    waveOutReset (hWaveOut) ;
               }
               return TRUE ;
          }
          break ;

               // Message generated from waveOutOpen call
               
     case MM_WOM_OPEN:
          SetDlgItemText (hwnd, IDC_ONOFF, TEXT (&quot;Turn Off&quot;)) ;

               // Send two buffers to waveform output device
                    
          FillBuffer (pBuffer1, iFreq) ;
          waveOutWrite (hWaveOut, pWaveHdr1, sizeof (WAVEHDR)) ;
                    
          FillBuffer (pBuffer2, iFreq) ;
          waveOutWrite (hWaveOut, pWaveHdr2, sizeof (WAVEHDR)) ;
          return TRUE ;

               // Message generated when a buffer is finished
                    
     case MM_WOM_DONE:
          if (bShutOff)
          {
               waveOutClose (hWaveOut) ;
               return TRUE ;
          }

               // Fill and send out a new buffer

          FillBuffer (((PWAVEHDR) lParam)-&gt;lpData, iFreq) ;
          waveOutWrite (hWaveOut, (PWAVEHDR) lParam, sizeof (WAVEHDR)) ;
          return TRUE ;
          
     case MM_WOM_CLOSE:
          waveOutUnprepareHeader (hWaveOut, pWaveHdr1, sizeof (WAVEHDR)) ;
          waveOutUnprepareHeader (hWaveOut, pWaveHdr2, sizeof (WAVEHDR)) ;

          free (pWaveHdr1) ;
          free (pWaveHdr2) ;
          free (pBuffer1) ;
          free (pBuffer2) ;

          hWaveOut = NULL ;
          SetDlgItemText (hwnd, IDC_ONOFF, TEXT (&quot;Turn On&quot;)) ;
          
          if (bClosing)
           
    EndDialog (hwnd, 0) ;
          
          return TRUE ;
          
     case WM_SYSCOMMAND:
          switch (wParam)
          {
          case SC_CLOSE:
               if (hWaveOut != NULL)
               {
                    bShutOff = TRUE ;
                    bClosing = TRUE ;
                    
                    waveOutReset (hWaveOut) ;
               }
               else
                    EndDialog (hwnd, 0) ;
               
               return TRUE ;
          }
          break ;
     }
     return FALSE ;
}
</pre>
</td></tr></table>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="763"><h3>SINEWAVE.RC (excerpts)</h3></A>
<P><pre>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;

/////////////////////////////////////////////////////////////////////////////
// Dialog

SINEWAVE DIALOG DISCARDABLE  100, 100, 200, 50
STYLE WS_MINIMIZEBOX | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION &quot;Sine Wave Generator&quot;
FONT 8, &quot;MS Sans Serif&quot;
BEGIN
    SCROLLBAR       IDC_SCROLL,8,8,150,12
    RTEXT           &quot;440&quot;,IDC_TEXT,160,10,20,8
    LTEXT           &quot;Hz&quot;,IDC_STATIC,182,10,12,8
    PUSHBUTTON      &quot;Turn On&quot;,IDC_ONOFF,80,28,40,14
END
</pre>
</td></tr></table>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="764"><h3>RESOURCE.H (excerpts)</h3></A>
<P><pre>
// Microsoft Developer Studio generated include file.
// Used by SineWave.rc

#define IDC_STATIC                      -1
#define IDC_SCROLL                      1000
#define IDC_TEXT                        1001
#define IDC_ONOFF                       1002
</pre>
</td></tr></table>

<P>Note that the OUT_BUFFER_SIZE, SAMPLE_RATE, and PI identifiers used in the <I>FillBuffer</I> routine are defined at the top of the program. The <I>iFreq</I> argument to <I>FillBuffer</I> is the desired frequency in Hz. Notice that the result of the <I>sin</I> function is scaled to range between 0 and 254. For each sample, the <I>fAngle</I> argument to the <I>sin</I> function is increased by 2&#960; (2 times pi) radians times the desired frequency divided by the sample rate.

<P>SINEWAVE's window contains three controls: a horizontal scroll bar used for selecting the frequency, a static text field that indicates the currently selected frequency, and a push button labeled &quot;Turn On.&quot; When you press the button, you should hear a sine wave from the speakers connected to your sound board and the button text will change to &quot;Turn Off.&quot; You can change the frequency by moving the scroll bar with the keyboard or mouse. To turn off the sound, push the button again.

<P>The SINEWAVE code initializes the scroll bar so that the minimum frequency is 20 Hz and the maximum frequency is 5000 Hz during the WM_INITDIALOG message. Initially, the scroll bar is set to 440 Hz. In musical terms, this is the A above middle C, the note used for tuning an orchestra. <I>DlgProc</I> alters the static variable <I>iFreq</I> on receipt of WM_HSCROLL messages. Notice that Page Left and Page Right cause <I>DlgProc</I> to decrease or increase the frequency by one octave.

<P>When <I>DlgProc</I> receives a WM_COMMAND message from the button, it first allocates 4 blocks of memory&#8212;2 for WAVEHDR structures, discussed shortly, and two for buffers, called <I>pBuffer1</I> and <I>pBuffer2</I>, to hold the waveform data.

<P>SINEWAVE opens the waveform audio device for output by calling the <I>waveOutOpen</I> function, which uses the following arguments:

<P><pre>
waveOutOpen (&amp;hWaveOut, wDeviceID, &amp;waveformat, dwCallBack,
             dwCallBackData, dwFlags) ;
</pre>

<P>You set the first argument to point to a variable of type HWAVEOUT (&quot;handle to waveform audio output&quot;). On return from the function, this variable will be set to a handle used in subsequent waveform output calls.

<P>The second argument to <I>waveOutOpen</I> is a device ID. This allows the function to be used on machines that have multiple sound boards installed. The argument can range from 0 to one less than the number of waveform output devices installed in the system. You can get the number of waveform output devices by calling <I>waveOutGetNumDevs</I> and find out about each of them by calling <I>waveOutGetDevCaps</I>. If you wish to avoid this device interrogation, you can use the constant WAVE_MAPPER (defined as equalling &#8211;1) to select the device the user as indicated as the Preferred Device in the Audio tab of the Multimedia applet of the Control Panel. Or the system could select another device if the preferred device can't handle what you need to do and another device can.

<P>The third argument is a pointer to a WAVEFORMATEX structure. (More about this shortly.) The fourth argument is either a window handle or a pointer to a callback function in a dynamic-link library. This argument indicates the window or callback function that receives the waveform output messages. If you use a callback function, you can specify program-defined data in the fifth argument. The <I>dwFlags</I> argument can be set to either CALLBACK_WINDOW or CALLBACK_FUNCTION to indicate what the fourth argument is. You can also use the flag WAVE_FORMAT_QUERY to check whether the device can be opened without actually opening it. A few other flags are available.

<P>The third argument to <I>waveOutOpen</I> is defined as a pointer to a structure of type WAVEFORMATEX, defined in MMSYSTEM.H as shown below:

<P><pre>typedef struct waveformat_tag
{
     WORD  wFormatTag ;        // waveform format = WAVE_FORMAT_PCM
     WORD  nChannels ;         // number of channels = 1 or 2
     DWORD nSamplesPerSec ;    // sample rate
     DWORD nAvgBytesPerSec ;   // bytes per second
     WORD  nBlockAlign ;       // block alignment
     WORD  wBitsPerSample ;    // bits per samples = 8 or 16
     WORD  cbSize ;            // 0 for PCM
}
WAVEFORMATEX, * PWAVEFORMATEX ;
</pre>

<P>This is the structure you use to specify the sample rate (<I>nSamplesPerSec</I>), the sample size (<I>wBitsPerSample</I>), and whether you want monophonic or stereophonic sound (<I>nChannels</I>). Some of the information in this structure may seem redundant, but the structure is designed for sampling methods other than PCM, in which case the last field is set to a nonzero value and other information follows.

<P>For PCM, set <I>nBlockAlign</I> field to the product of <I>nChannels</I> and <I>wBitsPerSample</I>, divided by 8. This is the total number of bytes per sample. Set the <I>nAvgBytesPerSec</I> field to the product of <I>nSamplesPerSec</I> and <I>nBlockAlign</I>.

<P>SINEWAVE initializes the fields of the WAVEFORMATEX structure and calls <I>waveOutOpen</I> like this:

<P><pre>
waveOutOpen (&amp;hWaveOut, WAVE_MAPPER, &amp;waveformat, 
             (DWORD) hwnd, 0, CALLBACK_WINDOW)
</pre>

<P>The <I>waveOutOpen</I> function returns MMSYSERR_NOERROR(defined as 0) if the function is successful and a nonzero error code otherwise. If <I>waveOutOpen</I> returns nonzero, SINEWAVE cleans up and displays a message box indicating an error.

<P>Now that the device is open, SINEWAVE continues by initializing the fields of the two WAVEHDR structures, which are used to pass buffers through the API. WAVEHDR is defined like so:

<P><pre>
typedef struct wavehdr_tag
{
    LPSTR lpData;                    // pointer to data buffer
    DWORD dwBufferLength;            // length of data buffer
    DWORD dwBytesRecorded;           // used for recorded
    DWORD dwUser;                    // for program use
    DWORD dwFlags;                   // flags
    DWORD dwLoops;                   // number of repetitions
    struct wavehdr_tag FAR *lpNext;  // reserved
    DWORD reserved;                  // reserved
} 
WAVEHDR, *PWAVEHDR ;
</pre>

<P>SINEWAVE sets the <I>lpData</I> field to the address at the buffer that will contain the data, <I>dwBufferLength</I> to the size of this buffer, and <I>dwLoops</I> to 1. All other fields can be set to 0 or NULL. If you want to play a repeated loop of sound, you can specify that with the <I>dwFlags</I> and <I>dwLoops</I> fields.

<P>Next SINEWAVE calls <I>waveOutPrepareHeader</I> for the two headers. Calling this function prevents the structure and buffer from being swapped to disk.

<P>So far, all of this preparation has been in response to the button click to turn on the sound. But a message is waiting in the program's message queue. Because we specified in <I>waveOutOpen</I> that we wish to use a window procedure for receiving waveform output messages, the <I>waveOutOpen</I> function posted a MM_WOM_OPEN message to the program's message queue. The <I>wParam</I> message parameter is set to the waveform output handle. To process the MM_WOM_OPEN message, SINEWAVE twice calls <I>FillBuffer</I> to fill the <I>pBuffer</I> buffer with sinewave data. SINEWAVE then passes the two WAVEHDR structures to <I>waveOutWrite</I>. This is the function that actually starts the sound playing by passing the data to the waveform output hardware.

<P>When the waveform hardware is finished playing the data passed to it in the <I>waveOutWrite</I> function, the window is posted an MM_WOM_DONE message. The <I>wParam</I> parameter is the waveform output handle, and <I>lParam</I> is a pointer to the WAVEHDR structure. SINEWAVE processes this message by calculating new values for the buffer and resubmitting the buffer by calling <I>waveOutWrite</I>.

<P>SINEWAVE could have been written using just one WAVEHDR structure and one buffer. However, there would be a slight delay between the time the waveform hardware finished playing the data and the program processed the MM_WOM_DONE message to submit a new buffer. The &quot;double-buffering&quot; technique that SINEWAVE uses prevents gaps in the sound.

<P>When the user clicks the &quot;Turn Off&quot; button to turn off the sound, <I>DlgProc</I> receives another WM_COMMAND message. For this message, <I>DlgProc</I> sets the <I>bShutOff</I> variable to TRUE and calls <I>waveOutReset</I>. The <I>waveOutReset</I> function stops sound processing and generates a MM_WOM_DONE message. When <I>bShutOff</I> is TRUE, SINEWAVE processes MM_WOM_DONE by calling <I>waveOutClose</I>. This in turn generates an MM_WOM_CLOSE message. Processing of MM_WOM_CLOSE mostly involves cleaning up. SINEWAVE calls <I>waveOutUnprepareHeader</I> for the two WAVEHDR structures, frees all the memory blocks, and sets the text of the button back to &quot;Turn On.&quot;

<P>If the waveform hardware is still playing a buffer, calling <I>waveOutClose</I> by itself will have no effect. You must call <I>waveOutReset</I> first to halt the playing and to generate an MM_WOM_DONE message. <I>DlgProc</I> also processes the WM_SYSCOMMAND message when <I>wParam</I> is SC_CLOSE. This results from the user selecting &quot;Close&quot; from the system menu. If waveform audio is still playing, <I>DlgProc</I> calls <I>waveOutReset</I>. Regardless, <I>EndDialog</I> is eventually called to close the dialog box and end the program.

<A NAME="765"><h2>A Digital Sound Recorder</h2></A>
<P>Windows includes a program called Sound Recorder that lets you digitally record and playback sounds. The program shown in Figure 22-3 (RECORD1) is not quite as sophisticated as Sound Recorder because it doesn't do any file I/O or allow sound editing. However, it does show the basics of using the low-level waveform audio API for both recording and playing back sounds.

<P><B>Figure 22-3.</b> <i>The RECORD1 program.</I>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="766"><h3>RECORD1.C</h3></A>
<P><pre>
/*----------------------------------------
   RECORD1.C -- Waveform Audio Recorder
                (c) Charles Petzold, 1998
  ----------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;resource.h&quot;

#define INP_BUFFER_SIZE 16384

BOOL CALLBACK DlgProc (HWND, UINT, WPARAM, LPARAM) ;

TCHAR szAppName [] = TEXT (&quot;Record1&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     if (-1 == DialogBox (hInstance, TEXT (&quot;Record&quot;), NULL, DlgProc))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
     }

     return 0 ;
}

void ReverseMemory (BYTE * pBuffer, int iLength)
{
     BYTE b ;
     int  i ;
     
     for (i = 0 ; i &lt; iLength / 2 ; i++)
     {
          b = pBuffer [i] ;
          pBuffer [i] = pBuffer [iLength - i - 1] ;
          pBuffer [iLength - i - 1] = b ;
     }
}

BOOL CALLBACK DlgProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static BOOL         bRecording, bPlaying, bReverse, bPaused,
                         bEnding, bTerminating ;
     static DWORD        dwDataLength, dwRepetitions = 1 ;
     static HWAVEIN      hWaveIn ;
     static HWAVEOUT     hWaveOut ;
     static PBYTE        pBuffer1, pBuffer2, pSaveBuffer, pNewBuffer ;
     static PWAVEHDR     pWaveHdr1, pWaveHdr2 ;
     static TCHAR        szOpenError[] = TEXT (&quot;Error opening waveform audio!&quot;);
     static TCHAR        szMemError [] = TEXT (&quot;Error allocating memory!&quot;) ;
     static WAVEFORMATEX waveform ;
     
     switch (message)
     {
     case WM_INITDIALOG:
               // Allocate memory for wave header
          
          pWaveHdr1 = malloc (sizeof (WAVEHDR)) ;
          pWaveHdr2 = malloc (sizeof (WAVEHDR)) ;
          
               // Allocate memory for save buffer
          
          pSaveBuffer = malloc (1) ;
          return TRUE ;
          
     case WM_COMMAND:
          switch (LOWORD (wParam))
          {
          case IDC_RECORD_BEG:
                    // Allocate buffer memory

               pBuffer1 = malloc (INP_BUFFER_SIZE) ;
               pBuffer2 = malloc (INP_BUFFER_SIZE) ;
               
               if (!pBuffer1 || !pBuffer2)
               {
                    if (pBuffer1) free (pBuffer1) ;
                    if (pBuffer2) free (pBuffer2) ;

                    MessageBeep (MB_ICONEXCLAMATION) ;
                    MessageBox (hwnd, szMemError, szAppName,
                                      MB_ICONEXCLAMATION | MB_OK) ;
                    return TRUE ;
               }
               
                    // Open waveform audio for input
               
               waveform.wFormatTag      = WAVE_FORMAT_PCM ;
               waveform.nChannels       = 1 ;
               waveform.nSamplesPerSec  = 11025 ;
               waveform.nAvgBytesPerSec = 11025 ;
               waveform.nBlockAlign     = 1 ;
               waveform.wBitsPerSample  = 8 ;
               waveform.cbSize          = 0 ;
               
               if (waveInOpen (&amp;hWaveIn, WAVE_MAPPER, &amp;waveform, 
                               (DWORD) hwnd, 0, CALLBACK_WINDOW))
               {
                    free (pBuffer1) ;
                    free (pBuffer2) ;
                    MessageBeep (MB_ICONEXCLAMATION) ;
                    MessageBox (hwnd, szOpenError, szAppName,
                                      MB_ICONEXCLAMATION | MB_OK) ;
               }
                    // Set up headers and prepare them
               
               pWaveHdr1-&gt;lpData          = pBuffer1 ;
               pWaveHdr1-&gt;dwBufferLength  = INP_BUFFER_SIZE ;
               pWaveHdr1-&gt;dwBytesRecorded = 0 ;
               pWaveHdr1-&gt;dwUser          = 0 ;
               pWaveHdr1-&gt;dwFlags         = 0 ;
               pWaveHdr1-&gt;dwLoops         = 1 ;
               pWaveHdr1-&gt;lpNext          = NULL ;
               pWaveHdr1-&gt;reserved        = 0 ;
               waveInPrepareHeader (hWaveIn, pWaveHdr1, sizeof (WAVEHDR)) ;
          
               pWaveHdr2-&gt;lpData          = pBuffer2 ;
               pWaveHdr2-&gt;dwBufferLength  = INP_BUFFER_SIZE ;
               pWaveHdr2-&gt;dwBytesRecorded = 0 ;
               pWaveHdr2-&gt;dwUser          = 0 ;
               pWaveHdr2-&gt;dwFlags         = 0 ;
               pWaveHdr2-&gt;dwLoops         = 1 ;
               pWaveHdr2-&gt;lpNext          = NULL ;
               pWaveHdr2-&gt;reserved        = 0 ;
          
               waveInPrepareHeader (hWaveIn, pWaveHdr2, sizeof (WAVEHDR)) ;
               return TRUE ;
               
          case IDC_RECORD_END:
                    // Reset input to return last buffer
               
               bEnding = TRUE ;
               waveInReset (hWaveIn) ;
               return TRUE ;
               
          case IDC_PLAY_BEG:
                    // Open waveform audio for output
               
               waveform.wFormatTag      = WAVE_FORMAT_PCM ;
               waveform.nChannels       = 1 ;
               waveform.nSamplesPerSec  = 11025 ;
               waveform.nAvgBytesPerSec = 11025 ;
               waveform.nBlockAlign     = 1 ;
               waveform.wBitsPerSample  = 8 ;
               waveform.cbSize          = 0 ;
               
               if (waveOutOpen (&amp;hWaveOut, WAVE_MAPPER, &amp;waveform, 
                                (DWORD) hwnd, 0, CALLBACK_WINDOW))
               {
                    MessageBeep (MB_ICONEXCLAMATION) ;
                    MessageBox (hwnd, szOpenError, szAppName,
                         MB_ICONEXCLAMATION | MB_OK) ;
               }
               return TRUE ;
               
          case IDC_PLAY_PAUSE:
                    // Pause or restart output
               
               if (!bPaused)
               {
                    waveOutPause (hWaveOut) ;
                    SetDlgItemText (hwnd, IDC_PLAY_PAUSE, TEXT (&quot;Resume&quot;)) ;
                    bPaused = TRUE ;
               }
               else
               {
                    waveOutRestart (hWaveOut) ;
                    SetDlgItemText (hwnd, IDC_PLAY_PAUSE, TEXT (&quot;Pause&quot;)) ;
                    bPaused = FALSE ;
               }
               return TRUE ;
               
          case IDC_PLAY_END:
                    // Reset output for close preparation
               
               bEnding = TRUE ;
               waveOutReset (hWaveOut) ;
               return TRUE ;
               
          case IDC_PLAY_REV:
                    // Reverse save buffer and play
               
               bReverse = TRUE ;
               ReverseMemory (pSaveBuffer, dwDataLength) ;
               
               SendMessage (hwnd, WM_COMMAND, IDC_PLAY_BEG, 0) ;
               return TRUE ;
               
          case IDC_PLAY_REP:
                    // Set infinite repetitions and play
               
               dwRepetitions = -1 ;
               SendMessage (hwnd, WM_COMMAND, IDC_PLAY_BEG, 0) ;
               return TRUE ;
               
          case IDC_PLAY_SPEED:
                    // Open waveform audio for fast output
               
               waveform.wFormatTag      = WAVE_FORMAT_PCM ;
               waveform.nChannels       = 1 ;
               waveform.nSamplesPerSec  = 22050 ;
               waveform.nAvgBytesPerSec = 22050 ;
               waveform.nBlockAlign     = 1 ;
               waveform.wBitsPerSample  = 8 ;
               waveform.cbSize          = 0 ;
               if (waveOutOpen (&amp;hWaveOut, 0, &amp;waveform, (DWORD) hwnd, 0,
                                           CALLBACK_WINDOW))
               {
                    MessageBeep (MB_ICONEXCLAMATION) ;
                    MessageBox (hwnd, szOpenError, szAppName,
                                      MB_ICONEXCLAMATION | MB_OK) ;
               }
               return TRUE ;
          }
          break ;
               
     case MM_WIM_OPEN:
               // Shrink down the save buffer
          
          pSaveBuffer = realloc (pSaveBuffer, 1) ;
          
               // Enable and disable buttons
          
          EnableWindow (GetDlgItem (hwnd, IDC_RECORD_BEG), FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_RECORD_END), TRUE)  ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_BEG),   FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_PAUSE), FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_END),   FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_REV),   FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_REP),   FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_SPEED), FALSE) ;
          SetFocus (GetDlgItem (hwnd, IDC_RECORD_END)) ;

               // Add the buffers
          
          waveInAddBuffer (hWaveIn, pWaveHdr1, sizeof (WAVEHDR)) ;
          waveInAddBuffer (hWaveIn, pWaveHdr2, sizeof (WAVEHDR)) ;
          
               // Begin sampling
          
          bRecording = TRUE ;
          bEnding = FALSE ;
          dwDataLength = 0 ;
          waveInStart (hWaveIn) ;
          return TRUE ;
          
     case MM_WIM_DATA:
         
               // Reallocate save buffer memory
          
          pNewBuffer = realloc (pSaveBuffer, dwDataLength +
                                   ((PWAVEHDR) lParam)-&gt;dwBytesRecorded) ;
          
          if (pNewBuffer == NULL)
          {
               waveInClose (hWaveIn) ;
               MessageBeep (MB_ICONEXCLAMATION) ;
               MessageBox (hwnd, szMemError, szAppName,
                                 MB_ICONEXCLAMATION | MB_OK) ;
               return TRUE ;
          }
          
          pSaveBuffer = pNewBuffer ;
          CopyMemory (pSaveBuffer + dwDataLength, ((PWAVEHDR) lParam)-&gt;lpData,
                         ((PWAVEHDR) lParam)-&gt;dwBytesRecorded) ;
          
          dwDataLength += ((PWAVEHDR) lParam)-&gt;dwBytesRecorded ;
          
          if (bEnding)
          {
               waveInClose (hWaveIn) ;
               return TRUE ;
          }
          
               // Send out a new buffer
          
          waveInAddBuffer (hWaveIn, (PWAVEHDR) lParam, sizeof (WAVEHDR)) ;
          return TRUE ;
          
     case MM_WIM_CLOSE:
               // Free the buffer memory

          waveInUnprepareHeader (hWaveIn, pWaveHdr1, sizeof (WAVEHDR)) ;
          waveInUnprepareHeader (hWaveIn, pWaveHdr2, sizeof (WAVEHDR)) ;

          free (pBuffer1) ;
          free (pBuffer2) ;
          
               // Enable and disable buttons
          
          EnableWindow (GetDlgItem (hwnd, IDC_RECORD_BEG), TRUE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_RECORD_END), FALSE) ;
          SetFocus (GetDlgItem (hwnd, IDC_RECORD_BEG)) ;
          
          if (dwDataLength &gt; 0)
          {
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_BEG),   TRUE)  ;
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_PAUSE), FALSE) ;
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_END),   FALSE) ;
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_REP),   TRUE)  ;
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_REV),   TRUE)  ;
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_SPEED), TRUE)  ;
               SetFocus (GetDlgItem (hwnd, IDC_PLAY_BEG)) ;
          }
          bRecording = FALSE ;
          
          if (bTerminating)
               SendMessage (hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L) ;
          
          return TRUE ;
          
     case MM_WOM_OPEN:
               // Enable and disable buttons
          
          EnableWindow (GetDlgItem (hwnd, IDC_RECORD_BEG), FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_RECORD_END), FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_BEG),   FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_PAUSE), TRUE)  ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_END),   TRUE)  ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_REP),   FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_REV),   FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_SPEED), FALSE) ;
          SetFocus (GetDlgItem (hwnd, IDC_PLAY_END)) ;
          
               // Set up header
          
          pWaveHdr1-&gt;lpData          = pSaveBuffer ;
          pWaveHdr1-&gt;dwBufferLength  = dwDataLength ;
          pWaveHdr1-&gt;dwBytesRecorded = 0 ;
          pWaveHdr1-&gt;dwUser          = 0 ;
          pWaveHdr1-&gt;dwFlags         = WHDR_BEGINLOOP | WHDR_ENDLOOP ;
          pWaveHdr1-&gt;dwLoops         = dwRepetitions ;
          pWaveHdr1-&gt;lpNext          = NULL ;
          pWaveHdr1-&gt;reserved        = 0 ;
          
               // Prepare and write
          
          waveOutPrepareHeader (hWaveOut, pWaveHdr1, sizeof (WAVEHDR)) ;
          waveOutWrite (hWaveOut, pWaveHdr1, sizeof (WAVEHDR)) ;
          
          bEnding = FALSE ;
          bPlaying = TRUE ;
          return TRUE ;
          
     case MM_WOM_DONE:
          waveOutUnprepareHeader (hWaveOut, pWaveHdr1, sizeof (WAVEHDR)) ;
          waveOutClose (hWaveOut) ;
          return TRUE ;
          
     case MM_WOM_CLOSE:
               // Enable and disable buttons
          
          EnableWindow (GetDlgItem (hwnd, IDC_RECORD_BEG), TRUE)  ;
          EnableWindow (GetDlgItem (hwnd, IDC_RECORD_END), TRUE)  ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_BEG),   TRUE)  ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_PAUSE), FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_END),   FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_REV),   TRUE)  ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_REP),   TRUE)  ;
          EnableWindow (GetDlgItem (hwnd, IDC_PLAY_SPEED), TRUE)  ;
          SetFocus (GetDlgItem (hwnd, IDC_PLAY_BEG)) ;
          
          SetDlgItemText (hwnd, IDC_PLAY_PAUSE, TEXT (&quot;Pause&quot;)) ;
          bPaused = FALSE ;
          dwRepetitions = 1 ;
          bPlaying = FALSE ;
          
          if (bReverse)
          {
               ReverseMemory (pSaveBuffer, dwDataLength) ;
               bReverse = FALSE ;
          }
          
          if (bTerminating)
               SendMessage (hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L) ;
          
          return TRUE ;
          
     case WM_SYSCOMMAND:
          switch (LOWORD (wParam))
          {
          case SC_CLOSE:
               if (bRecording)
               {
                    bTerminating = TRUE ;
                    bEnding = TRUE ;
                    waveInReset (hWaveIn) ;
                    return TRUE ;
               }
               if (bPlaying)
               {
                    bTerminating = TRUE ;
                    bEnding = TRUE ;
                    waveOutReset (hWaveOut) ;
                    return TRUE ;
               }
               
               free (pWaveHdr1) ;
               free (pWaveHdr2) ;
               free (pSaveBuffer) ;
               EndDialog (hwnd, 0) ;
               return TRUE ;
          }
          break ;
     }
     return FALSE ;
}
</pre>
</td></tr></table>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="767"><h3>RECORD.RC (excerpts)</h3></A>
<P><pre>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;

/////////////////////////////////////////////////////////////////////////////
// Dialog

RECORD DIALOG DISCARDABLE  100, 100, 152, 74
STYLE WS_MINIMIZEBOX | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION &quot;Waveform Audio Recorder&quot;
FONT 8, &quot;MS Sans Serif&quot;
BEGIN
    PUSHBUTTON      &quot;Record&quot;,IDC_RECORD_BEG,28,8,40,14
    PUSHBUTTON      &quot;End&quot;,IDC_RECORD_END,76,8,40,14,WS_DISABLED
    PUSHBUTTON      &quot;Play&quot;,IDC_PLAY_BEG,8,30,40,14,WS_DISABLED
    PUSHBUTTON      &quot;Pause&quot;,IDC_PLAY_PAUSE,56,30,40,14,WS_DISABLED
    PUSHBUTTON      &quot;End&quot;,IDC_PLAY_END,104,30,40,14,WS_DISABLED
    PUSHBUTTON      &quot;Reverse&quot;,IDC_PLAY_REV,8,52,40,14,WS_DISABLED
    PUSHBUTTON      &quot;Repeat&quot;,IDC_PLAY_REP,56,52,40,14,WS_DISABLED
    PUSHBUTTON      &quot;Speedup&quot;,IDC_PLAY_SPEED,104,52,40,14,WS_DISABLED
END
</pre>
</td></tr></table>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="768"><h3>RESOURCE.H (excerpts)</h3></A>
<P>
<pre>
// Microsoft Developer Studio generated include file.
// Used by Record.rc

#define IDC_RECORD_BEG                  1000
#define IDC_RECORD_END                  1001
#define IDC_PLAY_BEG                    1002
#define IDC_PLAY_PAUSE                  1003
#define IDC_PLAY_END                    1004
#define IDC_PLAY_REV                    1005
#define IDC_PLAY_REP                    1006
#define IDC_PLAY_SPEED                  1007
</pre>
</td></tr></table>

<P>The RECORD.RC and RESOURCE.H files will also be used in the RECORD2 
and RECORD3 programs.

<P>The RECORD1 window has eight push buttons. When you first run RECORD1, only the Record button is enabled. When you press Record, you can begin recording. The Record button becomes disabled, and the End button is enabled. Press End to stop recording. At this point, the Play, Reverse, Repeat, and Speedup buttons also become enabled. Pressing any of these buttons plays back the sound: Play plays it normally, Reverse plays it in reverse, Repeat causes the sound to be repeated indefinitely (like with a tape loop), and Speedup plays the sound back twice as fast. You can end playback by pressing the second End button, or you can pause the playback by pressing Pause. When pressed, the Pause button changes into a Resume button to resume playing back the sound. If you record another sound, it replaces the existing sound in memory.

<P>At any time, the only buttons that are enabled are those that perform valid operations. This requires a lot of calls to <I>EnableWindow</I> in the RECORD1 source code, but the program doesn't have to check if a particular push-button operation is valid. Of course, it also makes the operation of the program more intuitive.

<P>RECORD1 takes a number of shortcuts to simplify the code. First, if multiple waveform audio hardware devices are installed, RECORD1 uses the default one. Second, the program records and plays back at the standard 11.025 kHz sampling rate with an 8-bit sample size regardless of whether a higher sampling rate or sample size is available. The only exception is for the speed-up function, where RECORD1 plays back the sound at the 22.050 kHz sampling rate, thus playing it twice as fast and an octave higher in frequency.

<P>Recording a sound involves opening the waveform audio hardware for input and passing buffers to the API to receive the sound data.

<P>RECORD1 maintains several memory blocks. Three of these blocks are very small, at least initially, and are allocated during the WM_INITDIALOG message in <I>DlgProc</I>. The program allocates two WAVEHDR structures pointed to by <I>pWaveHdr1</I> and <I>pWaveHdr2</I>. These structures are used to pass buffers to the waveform APIs. The <I>pSaveBuffer</I> pointer points to a buffer for storing the complete recorded sound; this is initially allocated as a 1-byte block. Later on, during recording, the buffer is increased in size to accommodate all the sound data. (If you record for a long period of time, RECORD1 recovers gracefully when it runs out of memory during recording, and lets you play back that portion of the sound successfully stored.) I'll refer to this buffer as the &quot;save buffer&quot; because it is used to save the accumulated sound data. Two more memory blocks, 16K in size and pointed to by <I>pBuffer1</I> and <I>pBuffer2</I>, are allocated during recording to receive sound data. These buffers are freed when recording is complete.

<P>Each of the eight buttons generates a WM_COMMAND message to <I>DlgProc</I>, the dialog procedure for REPORT1's window. Initially, only the Record button is enabled. Pressing this generates a WM_COMMAND message with <I>wParam</I> equal to IDC_RECORD_BEG. To process this message, RECORD1 allocates the two 16K buffers for receiving sound data, initializes the fields of a WAVEFORMATEX structure and passes it to the <I>waveInOpen</I> function, and sets up the two WAVEHDR structures.

<P>The <I>waveInOpen</I> function generates an MM_WIM_OPEN message. During this message, RECORD1 shrinks the save buffer down to 1 byte in preparation for receiving data. (Of course, the first time you record something, the save buffer is already 1 byte in length, but during subsequent recordings, it could be much larger.) During the MM_WIM_OPEN message, RECORD1 also enables and disables the appropriate push buttons. Next, the program passes the two WAVEHDR structures and buffers to the API using <I>waveInAddBuffer</I>. Some flags are set, and recording begins with a call to <I>waveInStart</I>.

<P>At a sampling rate of 11.025 kHz with an 8-bit sample size, the 16K buffer will be filled in approximately 1.5 seconds. At that time, RECORD1 receives an MM_WIM_DATA message. In response to this message, the program call reallocates the save buffer based on the <I>dwDataLength</I> variable and the <I>dwBytesRecorded</I> field of the WAVEHDR structure. If the reallocation fails, RECORD1 calls <I>waveInClose</I> to stop recording.

<P>If the reallocation is successful, RECORD1 copies the data from the 16K buffer into the save buffer. It then calls <I>waveInAddBuffer</I> again. This process continues until RECORD1 runs out of memory for the save buffer or the user presses the End button.

<P>The End button generates a WM_COMMAND message with <I>wParam</I> equal to IDC_RECORD_END. Processing this message is simple. RECORD1 sets the <I>bEnding</I> flag to TRUE and calls <I>waveInReset</I>. The <I>waveInReset</I> function causes recording to stop and generates an MM_WIM_DATA message containing a partially filled buffer. RECORD1 responds to this final MM_WIM_DATA message normally, except that it closes the waveform input device by calling <I>waveInClose</I>.

<P>The <I>waveInClose</I> message generates an MM_WIM_CLOSE message. RECORD1 responds to this message by freeing the 16K input buffers and enabling and disabling the appropriate push buttons. In particular, if the save buffer contains data, which it almost always will unless the first reallocation fails, then the play buttons are enabled.

<P>After recording a sound, the save buffer contains the total accumulated sound data. When the user selects the Play button, <I>DlgProc</I> receives a WM_COMMAND message with <I>wParam</I> equal to IDC_PLAY_BEG. The program responds by initializing the fields of a WAVEFORMATEX structure and calling <I>waveOutOpen</I>.

<P>The <I>waveOutOpen</I> call again generates an MM_WOM_OPEN message. During this message, RECORD1 enables and disables the appropriate push buttons (allowing only Pause and End), initializes the fields of the WAVEHDR structure with the save buffer, prepares it by calling <I>waveOutPrepareHeader</I>, and begins playing it with a call to <I>waveOutWrite</I>.

<P>Normally, the sound will continue until all the data in the buffer has been played. At that time, an MM_WOM_DONE message is generated. If there are additional buffers to be played, a program can pass them out to the API at that time. RECORD1 plays only one big buffer, so the program simply unprepares the header and calls <I>waveOutClose</I>. The <I>waveOutClose</I> function generates an MM_WOM_CLOSE message. During this message, RECORD1 enables and disables the appropriate buttons, allowing the sound to be played again or a new sound to be recorded.

<P>I've also included a second End button so that the user can stop playing the sound at any time before the save buffer has completed. This End button generates a WM_COMMAND message with <I>wParam</I> equal to IDC_PLAY_END, and the program responds by calling <I>waveOutReset</I>. This function generates an MM_WOM_DONE message that is processed normally.

<P>RECORD1's window also includes a Pause button. Processing this button is easy. The first time it's pushed, RECORD1 calls <I>waveOutPause</I> to halt the sound and sets the text in the Pause button to Resume. Pressing the Resume button starts the playback going again by a call to <I>waveOutRestart</I>.

<P>To make the program just a little more interesting, I've also included buttons labeled &quot;Reverse,&quot; &quot;Repeat,&quot; and &quot;Speedup.&quot; These buttons generate WM_COMMAND messages with <I>wParam</I> values equal to IDC_PLAY_REV, IDC_PLAY_REP, and IDC_PLAY_SPEED.

<P>Playing the sound in reverse involves reversing the order of the bytes in the save buffer and playing the sound normally. RECORD1 includes a small function named <I>ReverseMemory</I> to reverse the bytes. It calls this function during the WM_COMMAND message before playing the block and again at the end of the MM_WOM_CLOSE message to restore it to normal.

<P>The Repeat button plays the sound over and over again. This is not complicated because the API includes a provision for repeating a sound. It involves setting the <I>dwLoops</I> field in the WAVEHDR structure to the number of repetitions and setting the <I>dwFlags</I> field to WHDR_BEGINLOOP for the beginning buffer in the loop and to WHDR_ENDLOOP for the end buffer. Because RECORD1 uses only one buffer for playing the sound, these two flags are combined in the <I>dwFlags</I> field.

<P>Playing the sound twice as fast is also quite easy. When initializing the fields of the WAVEFORMATEX structure in preparation for opening waveform audio for output, the <I>nSamplesPerSec</I> and <I>nAvgBytesPerSec</I> fields are set to 22050 rather than 11025.

<A NAME="769"><h2>The MCI Alternative</h2></A>
<P>You may find, as I do, that RECORD1 seems inordinately complex. It is particularly tricky to deal with the interaction between the waveform audio function calls and the messages they generate, and then in the midst of all this, to deal with possible memory shortages as well. But maybe that's why it's called the &quot;low-level&quot; interface. As I noted earlier in this chapter, Windows also includes the high-level Media Control Interface.

<P>For waveform audio, the primary differences between the low-level interface and MCI is that MCI records sound data to a waveform file and plays back the sound by reading the file. This makes it difficult to perform the &quot;special effects&quot; that RECORD1 implements because you'd have to read in the file, manipulate it, and write it back out before playing the sound. This is a typical versatility vs. ease-of-use trade-off. The low-level interface gives you flexibility, but MCI (for the most part) is easier.

<P>MCI is implemented in two different but related forms. The first form uses messages and data structures to send commands to multimedia devices and receive information from them. The second form uses ASCII text strings. The text-based interface was originally created to allow multimedia devices to be controlled from simple scripting languages. But it also provides very easy interactive control, as was demonstrated in the TESTMCI program shown earlier in this chapter.

<P>The RECORD2 program shown in Figure 22-4 uses the message and data structure form of MCI to implement another digital audio recorder and player. Although it uses the same dialog box template as RECORD1, it does not implement the three special effects buttons.

<P><B>Figure 22-4.</b> <i>The RECORD2 program.     </I>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="770"><h3>RECORD2.C</h3></A>
<P><pre>
/*----------------------------------------
   RECORD2.C -- Waveform Audio Recorder
                (c) Charles Petzold, 1998
------------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;..\\record1\\resource.h&quot;

BOOL CALLBACK DlgProc (HWND, UINT, WPARAM, LPARAM) ;

TCHAR szAppName [] = TEXT (&quot;Record2&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     if (-1 == DialogBox (hInstance, TEXT (&quot;Record&quot;), NULL, DlgProc))

      {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
     }
     return 0 ;
}

void ShowError (HWND hwnd, DWORD dwError)
{
     TCHAR szErrorStr [1024] ;
     
     mciGetErrorString (dwError, szErrorStr, 
                        sizeof (szErrorStr) / sizeof (TCHAR)) ;
     MessageBeep (MB_ICONEXCLAMATION) ;
     MessageBox (hwnd, szErrorStr, szAppName, MB_OK | MB_ICONEXCLAMATION) ;
}

BOOL CALLBACK DlgProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static BOOL       bRecording, bPlaying, bPaused ;
     static TCHAR      szFileName[] = TEXT (&quot;record2.wav&quot;) ;
     static WORD       wDeviceID ;
     DWORD             dwError ;
     MCI_GENERIC_PARMS mciGeneric ;
     MCI_OPEN_PARMS    mciOpen ;
     MCI_PLAY_PARMS    mciPlay ;
     MCI_RECORD_PARMS  mciRecord ;
     MCI_SAVE_PARMS    mciSave ;
     
     switch (message)
     {
     case WM_COMMAND:
          switch (wParam)
          {
          case IDC_RECORD_BEG:
                    // Delete existing waveform file
               
               DeleteFile (szFileName) ;
               
                    // Open waveform audio
               
               mciOpen.dwCallback       = 0 ;
               mciOpen.wDeviceID        = 0 ;
               mciOpen.lpstrDeviceType  = TEXT (&quot;waveaudio&quot;) ;
               mciOpen.lpstrElementName = TEXT (&quot;&quot;) ; 
               mciOpen.lpstrAlias       = NULL ;
               dwError = mciSendCommand (0, MCI_OPEN, 
                                   MCI_WAIT | MCI_OPEN_TYPE | MCI_OPEN_ELEMENT,
                                   (DWORD) (LPMCI_OPEN_PARMS) &amp;mciOpen) ;
               if (dwError != 0)
               {
                    ShowError (hwnd, dwError) ;
                    return TRUE ;
               }
                    // Save the Device ID
               
               wDeviceID = mciOpen.wDeviceID ;
               
                    // Begin recording
               
               mciRecord.dwCallback = (DWORD) hwnd ;
               mciRecord.dwFrom     = 0 ;
               mciRecord.dwTo       = 0 ;
               
               mciSendCommand (wDeviceID, MCI_RECORD, MCI_NOTIFY,
                               (DWORD) (LPMCI_RECORD_PARMS) &amp;mciRecord) ;
               
                    // Enable and disable buttons
               
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_BEG), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_END), TRUE) ;
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_BEG),   FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_PAUSE), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_END),   FALSE);
               SetFocus (GetDlgItem (hwnd, IDC_RECORD_END)) ;
               
               bRecording = TRUE ;
               return TRUE ;
               
          case IDC_RECORD_END:
                    // Stop recording
               
               mciGeneric.dwCallback = 0 ;
               
               mciSendCommand (wDeviceID, MCI_STOP, MCI_WAIT,
                               (DWORD) (LPMCI_GENERIC_PARMS) &amp;mciGeneric) ;
               
                    // Save the file

               mciSave.dwCallback = 0 ;
               mciSave.lpfilename = szFileName ;
               

               mciSendCommand (wDeviceID, MCI_SAVE, MCI_WAIT | MCI_SAVE_FILE,
                               (DWORD) (LPMCI_SAVE_PARMS) &amp;mciSave) ;
               
                    // Close the waveform device
               
               mciSendCommand (wDeviceID, MCI_CLOSE, MCI_WAIT,
                               (DWORD) (LPMCI_GENERIC_PARMS) &amp;mciGeneric) ;
               
                    // Enable and disable buttons
               
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_BEG), TRUE) ;
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_END), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_BEG),   TRUE) ;
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_PAUSE), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_END),   FALSE);
               SetFocus (GetDlgItem (hwnd, IDC_PLAY_BEG)) ;
               
               bRecording = FALSE ;
               return TRUE ;
               
          case IDC_PLAY_BEG:
                    // Open waveform audio
               
               mciOpen.dwCallback       = 0 ;
               mciOpen.wDeviceID        = 0 ;
               mciOpen.lpstrDeviceType  = NULL ;
               mciOpen.lpstrElementName = szFileName ;
               mciOpen.lpstrAlias       = NULL ;
               
               dwError = mciSendCommand (0, MCI_OPEN,
                                         MCI_WAIT | MCI_OPEN_ELEMENT,
                                         (DWORD) (LPMCI_OPEN_PARMS) &amp;mciOpen) ;
               
               if (dwError != 0)
               {
                    ShowError (hwnd, dwError) ;
                    return TRUE ;
               }
                    // Save the Device ID
               
               wDeviceID = mciOpen.wDeviceID ;
               
                    // Begin playing
               
               mciPlay.dwCallback = (DWORD) hwnd ;
               mciPlay.dwFrom     = 0 ;
               mciPlay.dwTo       = 0 ;
               
               mciSendCommand (wDeviceID, MCI_PLAY, MCI_NOTIFY,
                               (DWORD) (LPMCI_PLAY_PARMS) &amp;mciPlay) ;
               
                    // Enable and disable buttons
               
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_BEG), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_END), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_BEG),   FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_PAUSE), TRUE) ;
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_END),   TRUE) ;
               SetFocus (GetDlgItem (hwnd, IDC_PLAY_END)) ;
               
               bPlaying = TRUE ;
               return TRUE ;
               
          case IDC_PLAY_PAUSE:
               if (!bPaused)
                         // Pause the play
               {
                    mciGeneric.dwCallback = 0 ;
                    
                    mciSendCommand (wDeviceID, MCI_PAUSE, MCI_WAIT,
                                    (DWORD) (LPMCI_GENERIC_PARMS) &amp; mciGeneric);
                    
                    SetDlgItemText (hwnd, IDC_PLAY_PAUSE, TEXT (&quot;Resume&quot;)) ;
                    bPaused = TRUE ;
               }
               else
                         // Begin playing again
               {
                    mciPlay.dwCallback = (DWORD) hwnd ;
                    mciPlay.dwFrom     = 0 ;
                    mciPlay.dwTo       = 0 ;
                    
                    mciSendCommand (wDeviceID, MCI_PLAY, MCI_NOTIFY,
                                    (DWORD) (LPMCI_PLAY_PARMS) &amp;mciPlay) ;
                    
                    SetDlgItemText (hwnd, IDC_PLAY_PAUSE, TEXT (&quot;Pause&quot;)) ;
                    bPaused = FALSE ;
               }
               
               return TRUE ;
               
          case IDC_PLAY_END:
                    // Stop and close
               
               mciGeneric.dwCallback = 0 ;
               
               mciSendCommand (wDeviceID, MCI_STOP, MCI_WAIT,
                               (DWORD) (LPMCI_GENERIC_PARMS) &amp;mciGeneric) ;
               
               mciSendCommand (wDeviceID, MCI_CLOSE, MCI_WAIT,
                               (DWORD) (LPMCI_GENERIC_PARMS) &amp;mciGeneric) ;
               
                    // Enable and disable buttons
               
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_BEG), TRUE) ;
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_END), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_BEG),   TRUE) ;
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_PAUSE), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_END),   FALSE);
               SetFocus (GetDlgItem (hwnd, IDC_PLAY_BEG)) ;
               
               bPlaying = FALSE ;
               bPaused  = FALSE ;
               return TRUE ;
          }
          break ;
               
     case MM_MCINOTIFY:
          switch (wParam)
          {
          case MCI_NOTIFY_SUCCESSFUL:
               if (bPlaying)
                    SendMessage (hwnd, WM_COMMAND, IDC_PLAY_END, 0) ;
               
               if (bRecording)
                    SendMessage (hwnd, WM_COMMAND, IDC_RECORD_END, 0);
               
               return TRUE ;
          }
          break ;
     
     case WM_SYSCOMMAND:
          switch (wParam)
          {
          case SC_CLOSE:
               if (bRecording)
                    SendMessage (hwnd, WM_COMMAND, IDC_RECORD_END, 0L) ;
               if (bPlaying)
                    SendMessage (hwnd, WM_COMMAND, IDC_PLAY_END, 0L) ;
               
               EndDialog (hwnd, 0) ;
               return TRUE ;
          }
          break ;
     }
     return FALSE ;
}
</pre>
</td></tr></table>

<P>RECORD2 uses only two MCI function calls, the most important being this one:

<P><pre>
error = mciSendCommand (wDeviceID, message, dwFlags, dwParam)
</pre>

<P>The first argument is a numeric identification number for the device. You use this ID number much like a handle. You obtain the ID when you open the device, and then you use it in subsequent <I>mciSendCommand</I> calls. The second argument is a constant beginning with the prefix MCI. These are called MCI command messages, and RECORD2 demonstrates seven of them: MCI_OPEN, MCI_RECORD, MCI_STOP, MCI_SAVE, MCI_PLAY, MCI_PAUSE, and MCI_CLOSE.

<P>The <I>dwFlags</I> argument is generally composed of zero or more bit flag constants combined with the C bit-wise OR operator. These generally indicate various options. Some options are specific to particular command messages, and some are common to all messages. The <I>dwParam</I> argument is generally a long pointer to a data structure that indicates options and obtains information from the device. Many of the MCI messages are associated with data structures unique to the message.

<P>The <I>mciSendCommand</I> function returns zero if the function is successful and an error code otherwise. To report this error to the user, you can obtain a text string that describes the error:

<P><pre>
mciGetErrorString (error, szBuffer, dwLength)
</pre>

<P>This is the same function used in the TESTMCI program.

<P>When the user presses the Record button, RECORD2's window procedure receives a WM_COMMAND message with <I>wParam</I> equal to IDC_RECORD_BEG. RECORD2 begins by opening the device. This involves setting the fields of an MCI_OPEN_PARMS structure and calling <I>mciSendCommand</I> with the MCI_OPEN command message. For recording, the <I>lpstrDeviceType</I> field is set to the string &quot;waveaudio&quot; to indicate the device type. The <I>lpstrElementName</I> field is set to a zero-length string. The MCI driver uses a default sampling rate and sample size, but you can change that using the MCI_SET command. During recording, the sound data is stored on the hard disk in a temporary file and is ultimately transferred to a standard waveform file. I'll discuss the format of waveform files later in this chapter. For playing back the sound, MCI uses the sampling rate and sample size defined in the waveform file.

<P>If RECORD2 cannot open a device, it uses <I>mciGetErrorString</I> and <I>MessageBox</I> to tell the user what the problem is. Otherwise, on return from the <I>mciSendCommand</I> call, the <I>wDeviceID</I> field of the MCI_OPEN_PARMS structure contains the device ID used in subsequent calls.

<P>To begin recording, RECORD2 calls <I>mciSendCommand</I> with the MCI_RECORD command message and the MCI_WAVE_RECORD_PARMS data structure. Optionally, you can set the <I>dwFrom</I> and <I>dwTo</I> fields of this structure (and use bit flags that indicate these fields are set) to insert a sound into an existing waveform file, the name of which would be specified in the <I>lpstrElementName</I> field of the MCI_OPEN_PARMS structure. By default, any new sound is inserted at the beginning of an existing file.

<P>RECORD2 sets the <I>dwCallback</I> field of the MCI_WAVE_RECORD_PARMS to the program's window handle and includes the MCI_NOTIFY flag in the <I>mciSendCommand</I> call. This causes a notification message to be sent to the window procedure when recording has been completed. I'll discuss this notification message shortly.

<P>When done recording, you press the first End button to stop. This generates a WM_COMMAND message with <I>wParam</I> equal to IDC_RECORD_END. The window procedure responds by calling <I>mciSendCommand</I> three times: The MCI_STOP command message stops recording, the MCI_SAVE command message transfers the sound data from the temporary file to the file specified in an MCI_SAVE_PARMS structure (&quot;record2.wav&quot;), and the MCI_CLOSE command message deletes any temporary files or memory blocks that might have been created and closes the device.

<P>For playback, the <I>lpstrElementName</I> of the MCI_OPEN_PARMS structure field is set to the filename &quot;record2.wav&quot;. The MCI_OPEN_ELEMENT flag included in the third argument to <I>mciSendCommand</I> indicates that the <I>lpstrElementName</I> field is a valid filename. MCI knows from the filename extension .WAV that you wish to open a waveform audio device. If multiple waveform hardware is present, it opens the first device. (It's also possible to use something other than the first waveform device by setting the <I>lpstrDeviceType</I> field of the MCI_OPEN_PARMS structure.)

<P>Playing involves an <I>mciSendCommand</I> call with the MCI_PLAY command message and an MCI_PLAY_PARMS structure. Any part of the file can be played, but RECORD2 chooses to play it all.

<P>RECORD2 also includes a Pause button for pausing the playback of a sound file. This button generates a WM_COMMAND message with <I>wParam</I> equal to IDC_PLAY_PAUSE. The program responds by calling <I>mciSendCommand</I> with the MCI_PAUSE command message and an MCI_GENERIC_PARMS structure. The MCI_GENERIC_PARMS structure is used for any message that requires no information except an optional window handle for notification. If the playback is already paused, the button resumes play by calling <I>mciSendCommand</I> again with the MCI_PLAY command message.

<P>Playback can also be terminated by pressing the second End button. This generates a WM_COMMAND message with <I>wParam</I> equal to IDC_PLAY_END. The window procedure responds by calling <I>mciSendCommand</I> twice, first with the MCI_STOP command message and then with the MCI_CLOSE command message.

<P>Now here's a problem: Although you can manually terminate playback by pressing the End button, you may want to play the entire sound file. How does the program know when the file has completed? That is the job of the MCI notification message.

<P>When calling <I>mciSendCommand</I> with the MCI_RECORD and MCI_PLAY messages, RECORD2 includes the MCI_NOTIFY flag and sets the <I>dwCallback</I> field of the data structure to the program's window handle. This causes a notification message, called MM_MCINOTIFY, to be posted to the window procedure under certain circumstances. The <I>wParam</I> message parameter is a status code, and <I>lParam</I> is the device ID.

<P>You'll receive an MM_MCINOTIFY message with <I>wParam</I> equal to MCI_NOTIFY_ABORTED when <I>mciSendCommand</I> is called with the MCI_STOP or MCI_PAUSE command messages. This happens when you press the Pause button or either of the two End buttons. RECORD2 can ignore this case because it already properly handles these buttons. During playback, you'll receive an MM_MCINOTIFY message with <I>wParam</I> equal to MCI_NOTIFY_SUCCESSFUL when the sound file has completed. To handle this case, the window procedure sends itself a WM_COMMAND message with <I>wParam</I> equal to IDC_PLAY_END to simulate the user pressing the End button. The window procedure then responds normally by stopping the play and closing the device.

<P>During recording, you'll receive an MM_MCINOTIFY message with <I>wParam</I> equal to MCI_NOTIFY_SUCCESSFUL when you run out of hard disk space for storing the temporary sound file. (I wouldn't exactly call this a &quot;successful&quot; completion, but that's what happens.) The window procedure responds by sending itself a WM_COMMAND message with <I>wParam</I> equal to IDC_RECORD_END. The window procedure stops recording, saves the file, and closes the device, as is normal.

<A NAME="771"><h2>The MCI Command String Approach</h2></A>
<P>At one time, the Windows multimedia interface included a function called <I>mciExecute</I>, with the following syntax:

<P><pre>
bSuccess = mciExecute (szCommand) ;
</pre>

<P>The only argument was the MCI command string. The function returned a Boolean value&#8212;nonzero if the function is successful and zero if not. The <I>mciExecute</I> function was functionally equivalent to calling <I>mciSendString</I> (the string-based MCI function used in TESTMCI) with NULL or zero for the last three arguments and then <I>mciGetErrorString</I> and <I>MessageBox</I> if an error occurred.

<P>Although <I>mciExecute</I> is no longer part of the API, I've included such a function in the RECORD3 version of the digital tape recorder and player. This is shown in Figure 22-5. Like RECORD2, the program uses the RECORD.RC resource script and RESOURCE.H from RECORD1.

<P><B>Figure 22-5.</b> <i>The RECORD3 program.</I>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="772"><h3>RECORD3.C</h3></A>
<P><pre>
/*----------------------------------------
   RECORD3.C -- Waveform Audio Recorder
                (c) Charles Petzold, 1998
  ----------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;..\\record1\\resource.h&quot;

BOOL CALLBACK DlgProc (HWND, UINT, WPARAM, LPARAM) ;

TCHAR szAppName [] = TEXT (&quot;Record3&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     if (-1 == DialogBox (hInstance, TEXT (&quot;Record&quot;), NULL, DlgProc))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
     }
     return 0 ;
}

BOOL mciExecute (LPCTSTR szCommand)
{
     MCIERROR error ;
     TCHAR    szErrorStr [1024] ;

     if (error = mciSendString (szCommand, NULL, 0, NULL))
     {
          mciGetErrorString (error, szErrorStr, 
                             sizeof (szErrorStr) / sizeof (TCHAR)) ;
          MessageBeep (MB_ICONEXCLAMATION) ;
          MessageBox (NULL, szErrorStr, TEXT (&quot;MCI Error&quot;), 
                      MB_OK | MB_ICONEXCLAMATION) ;
     }
     return error == 0 ;
}

BOOL CALLBACK DlgProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static BOOL bRecording, bPlaying, bPaused ;
     
     switch (message)

     {
     case WM_COMMAND:
          switch (wParam)
          {
          case IDC_RECORD_BEG:
                    // Delete existing waveform file
               
               DeleteFile (TEXT (&quot;record3.wav&quot;)) ;
               
                    // Open waveform audio and record
               
               if (!mciExecute (TEXT (&quot;open new type waveaudio alias mysound&quot;)))
                    return TRUE ;
               
               mciExecute (TEXT (&quot;record mysound&quot;)) ;
               
                    // Enable and disable buttons
               
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_BEG), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_END), TRUE) ;
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_BEG),   FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_PAUSE), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_END),   FALSE);
               SetFocus (GetDlgItem (hwnd, IDC_RECORD_END)) ;
               
               bRecording = TRUE ;
               return TRUE ;
               
          case IDC_RECORD_END:
                    // Stop, save, and close recording
               
               mciExecute (TEXT (&quot;stop mysound&quot;)) ;
               mciExecute (TEXT (&quot;save mysound record3.wav&quot;)) ;
               mciExecute (TEXT (&quot;close mysound&quot;)) ;
               
                    // Enable and disable buttons
               
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_BEG), TRUE) ;
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_END), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_BEG),   TRUE) ;
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_PAUSE), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_END),   FALSE);
               SetFocus (GetDlgItem (hwnd, IDC_PLAY_BEG)) ;
               
               bRecording = FALSE ;
               return TRUE ;
               
          case IDC_PLAY_BEG:
                    // Open waveform audio and play
               
               if (!mciExecute (TEXT (&quot;open record3.wav alias mysound&quot;)))
                    return TRUE ;
               
               mciExecute (TEXT (&quot;play mysound&quot;)) ;
               
                    // Enable and disable buttons
               
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_BEG), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_END), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_BEG),   FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_PAUSE), TRUE) ;
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_END),   TRUE) ;
               SetFocus (GetDlgItem (hwnd, IDC_PLAY_END)) ;
               
               bPlaying = TRUE ;
               return TRUE ;
               
          case IDC_PLAY_PAUSE:
               if (!bPaused)
                         // Pause the play
               {
                    mciExecute (TEXT (&quot;pause mysound&quot;)) ;
                    SetDlgItemText (hwnd, IDC_PLAY_PAUSE, TEXT (&quot;Resume&quot;)) ;
                    bPaused = TRUE ;
               }
               else
                         // Begin playing again
               {
                    mciExecute (TEXT (&quot;play mysound&quot;)) ;
                    SetDlgItemText (hwnd, IDC_PLAY_PAUSE, TEXT (&quot;Pause&quot;)) ;
                    bPaused = FALSE ;
               }
               
               return TRUE ;
               
          case IDC_PLAY_END:
                    // Stop and close
               
               mciExecute (TEXT (&quot;stop mysound&quot;)) ;
               mciExecute (TEXT (&quot;close mysound&quot;)) ;
               
                    // Enable and disable buttons
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_BEG), TRUE) ;
               EnableWindow (GetDlgItem (hwnd, IDC_RECORD_END), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_BEG),   TRUE) ;
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_PAUSE), FALSE);
               EnableWindow (GetDlgItem (hwnd, IDC_PLAY_END),   FALSE);
               SetFocus (GetDlgItem (hwnd, IDC_PLAY_BEG)) ;
               
               bPlaying = FALSE ;
               bPaused  = FALSE ;
               return TRUE ;
          }
          break ;
     
     case WM_SYSCOMMAND:
          switch (wParam)
          {
          case SC_CLOSE:
               if (bRecording)
                    SendMessage (hwnd, WM_COMMAND, IDC_RECORD_END, 0L);
               
               if (bPlaying)
                    SendMessage (hwnd, WM_COMMAND, IDC_PLAY_END, 0L) ;
               
               EndDialog (hwnd, 0) ;
               return TRUE ;
          }
          break ;
     }
     return FALSE ;
}
</pre>
</td></tr></table>

<P>When you begin exploring the message-based and the text-based interfaces to MCI, you'll find that they correspond closely. It's easy to guess that MCI translates the command strings into the corresponding command messages and data structures. RECORD3 could use the MM_MCINOTIFY messages like RECORD2, but it chooses not to&#8212;an implication of the <I>mciExecute</I> function. The drawback of this is that the program doesn't know when it's finished playing the waveform file. Therefore, the buttons do not automatically change state. You must manually press the End button so that the program will know that it's ready to record or play again.

<P>Notice the use of the <I>alias</I> keyword in the MCI <I>open</I> command. This allows all the subsequent MCI commands to refer to the device using the alias name.

<A NAME="773"><h2>The Waveform Audio File Format</h2></A>
<P>If you take a look at uncompressed (that is, PCM) .WAV files under a hexadecimal dump program, you'll find they have a format as shown in Figure 22-6.

<P><TABLE cellpadding="5" width="95%">
<tr>
<td valign="top"><B><I>Offset</I></B></td>
<td valign="top"><B><I>Bytes</I></B></td>
<td valign="top"><B><I>Data</I></B></td>
</tr>
<tr>
<td valign="top">0000</td>
<td valign="top">4</td>
<td valign="top">&quot;RIFF&quot;</td>
</tr>
<tr>
<td valign="top"><P>0004</td>
<td valign="top">4</td>
<td valign="top">size of waveform chunk (file size minus 8)</td>
</tr>
<tr>
<td valign="top">0008</td>
<td valign="top">4</td>
<td valign="top">&quot;WAVE&quot;</td>
</tr>
<tr>
<td valign="top">000C</td>
<td valign="top">4</td>
<td valign="top">&quot;fmt &quot;</td>
</tr>
<tr>
<td valign="top">0010</td>
<td valign="top">4</td>
<td valign="top">size of format chunk (16 bytes)</td>
</tr>
<tr>
<td valign="top">0014</td>
<td valign="top">2</td>
<td valign="top">wf.wFormatTag = WAVE_FORMAT_PCM = 1</td>
</tr>
<tr>
<td valign="top">0016</td>
<td valign="top">2</td>
<td valign="top">wf.nChannels</td>
</tr>
<tr>
<td valign="top">0018</td>
<td valign="top">4</td>
<td valign="top">wf.nSamplesPerSec</td>
</tr>
<tr>
<td valign="top">001C</td>
<td valign="top">4</td>
<td valign="top">wf.nAvgBytesPerSec</td>
</tr>
<tr>
<td valign="top">0020</td>
<td valign="top">2</td>
<td valign="top">wf.nBlockAlign</td>
</tr>
<tr>
<td valign="top">0022</td>
<td valign="top">2</td>
<td valign="top">wf.wBitsPerSample</td>
</tr>
<tr>
<td valign="top">0024</td>
<td valign="top">4</td>
<td valign="top">&quot;data&quot;</td>
</tr>
<tr>
<td valign="top">0028</td>
<td valign="top">4</td>
<td valign="top">size of waveform data</td>
</tr>
<tr>
<td valign="top">002C</td>
<td valign="top"></td>
<td valign="top">waveform data</td>
</tr>
</table>

<P><B>Figure 22-6. </b> <i>The .WAV file format.</I>

<P>This format is an example of a more extensive format known as RIFF (Resource Interchange File Format). RIFF was intended to be the all-encompassing format for multimedia data files. It is a tagged file format, where the file consists of &quot;chunks&quot; of data that are identified by a preceding 4-character ASCII name and a 4-byte (32-bit) chunk size. The value of the chunk size does not include the 8 bytes required for the chunk name and size.

<P>A waveform audio file begins with the text string &quot;RIFF&quot;, which identifies it as a RIFF file. This is followed by a 32-bit chunk size, which is the size of the remainder of the file, or the file size less 8 bytes.

<P>The chunk data begins with the text string &quot;WAVE&quot;, which identifies it as a waveform audio chunk. This is followed by the text string &quot;fmt&quot;&#8212;notice the blank to make this a 4-character string&#8212;which identifies a sub-chunk containing the format of the waveform audio data. The &quot;fmt &quot; string is followed by the size of the format information, in this case 16 bytes. The format information is the first 16 bytes of the WAVEFORMATEX structure, or, as it was defined originally, a PCMWAVEFORMAT structure that includes a WAVEFORMAT structure.

<P>The <I>nChannels</I> field is either 1 or 2, for monaural or stereo sound. The <I>nSamplesPerSec</I> field is the number of samples per second; the standard values are 11025, 22050, and 44100 samples per second. The <I>nAvgBytesPerSec</I> field is the sample rate in samples per second times the number of channels times the size of each sample in bits, divided by 8 and rounded up. The standard sample sizes are 8 and 16 bits. The <I>nBlockAlign</I> field is the number of channels times the sample size in bits, divided by 8 and rounded up. Finally, the format concludes with a <I>wBitsPerSample</I> field, which is the number of channels times the sample size in bits.

<P>The format information is followed by the text string &quot;data&quot;, followed by a 32-bit data size, followed by the waveform data itself. The data are simply the consecutive samples in the same format as that used in the low-level waveform audio facilities. If the sample size is 8 bits or less, each sample consists of 1 byte for monaural or 2 bytes for stereo. If the sample size is between 9 and 16 bits, each sample is 2 bytes for monaural or 4 bytes for stereo. For stereo waveform data, each sample consists of the left value followed by the right value.

<P>For sample sizes of 8 bits or less, the sample byte is interpreted as an unsigned value. For example, for an 8-bit sample size, silence is equivalent to a string of 0x80 bytes. For sample sizes of 9 bits or more, the sample is interpreted as a signed value, and silence is equivalent to a string of 0 values.

<P>One of the important rules for reading tagged files is to ignore chunks you're not prepared to deal with. Although a waveform audio file requires &quot;fmt &quot; and &quot;data&quot; sub-chunks (in that order), it can also contain other sub-chunks. In particular, a waveform audio file might contain a sub-chunk labeled &quot;INFO&quot;, and sub-sub-chunks within that sub-chunk that provide information about the waveform audio file.

<A NAME="774"><h2>Experimenting with Additive Synthesis</h2></A>
<P>For many years&#8212;going back to Pythagoras at least&#8212;people have attempted to analyze musical tones. At first it seems very simple, but then it gets complex. Bear with me if I repeat a little of what I've already said about sound.

<P>Musical tones, except for some percussive sounds, have a particular pitch or frequency. This frequency can range across the spectrum of human perception, from 20 Hz to 20,000 Hz. The notes of a piano, for example, have a frequency range between 27.5 Hz to 4186 Hz. Another characteristic of musical tones is volume or loudness. This corresponds to the overall amplitude of the waveform producing the tone. A change in loudness is measured in decibels. So far, so good.

<P>And then there is an unwieldy thing called &quot;timbre.&quot; Very simply, timbre is that quality of sound that lets us distinguish between a piano and a violin and a trumpet all playing the same pitch at the same volume.

<P>The French mathematician Fourier discovered that any periodic waveform&#8212;no matter how complex&#8212;can be represented by a sum of sine waves whose frequencies are integral multiples of a fundamental frequency. The fundamental, also called the first harmonic, is the frequency of periodicity of the waveform. The first overtone, also called the second harmonic, has a frequency twice the fundamental; the second overtone, or third harmonic, has a frequency three times the fundamental, and so forth. The relative amplitudes of the harmonics governs the shape of the waveform.

<P>For example, a square wave can be represented as a sum of sine waves where the amplitudes of the even harmonics (that is, 2, 4, 6, etc) are zero and the amplitudes of the odd harmonics (1, 3, 5, etc) are in the proportions 1, 1/3, 1/5, and so forth. In a sawtooth wave, all harmonics are present and the amplitudes are in the proportions 1, 1/2, 1/3, 1/4, and so forth.

<P>To the German scientist Hermann Helmholtz (1821_1894), this was the key in understanding timbre. In his classic book <I>On the Sensations of Tone</I> (1885, republished by Dover Press in 1954), Helmholtz posited that the ear and brain break down complex tones into their component sine waves and that the relative intensities of these sine waves is what we perceive as timbre. Unfortunately, it proved to be not quite that simple.

<P>Electronic music synthesizers came to widespread public attention in 1968 with the release of Wendy Carlos's album <I>Switched on Bach</I>. The synthesizers available at that time (such as the Moog) were analog synthesizers. Such synthesizers use analog circuitry to generate various audio waveforms such as square waves, triangle waves, and sawtooth waves. To make these waveforms sound more like real musical instruments, they are subjected to some changes over the course of a single note. The overall amplitude of the waveform is shaped by an &quot;envelope.&quot; When a note begins, the amplitude begins at zero and rises, usually very quickly. This is known as the attack. The amplitude then remains constant as the note is held. This is known as the sustain. The amplitude then falls to zero when the note ends; this is known as the release.

<P>The waveforms are also put through filters that attenuate some of the harmonics and turn the simple waveforms into something more complex and musically interesting. The cut-off frequencies of these filters can be controlled by an envelope so that the harmonic content of the sound changes over the course of the note.

<P>Because these synthesizers begin with harmonically rich waveform, and some of the harmonics are attenuated using filters, this form of synthesis is known as &quot;subtractive synthesis.&quot;

<P>Even while working with subtractive synthesis, many people involved in electronic music saw additive synthesis as the next big thing.

<P>In additive synthesis you begin with a number of sine wave generators tuned in integral multiples so that each sine wave corresponds to a harmonic. The amplitude of each harmonic can be controlled independently by an envelope. Additive synthesis is not practical using analog circuitry because you'd need somewhere between 8 and 24 sine wave generators for a single note and the relative frequencies of these sine wave generators would have to track each other precisely. Analog waveform generators are notoriously unstable and prone to frequency drift.

<P>However, for digital synthesizers (which can generate waveforms digitally using lookup tables) and computer-generated waveforms, frequency drift is not a problem and additive synthesis becomes feasible. So here's the general idea: You record a real musical tone and break it down into harmonics using Fourier analysis. You can then determine the relative strength of each harmonic and regenerate the sound digitally using multiple sine waves.

<P>When people began experimenting with applying Fourier analysis on real musical tones and generating these tones from multiple sine waves, they discovered that timbre is not quite as simple as Helmholtz believed.

<P>The big problem is that the harmonics of real musical tones are not in strict integral relationships. Indeed, the term &quot;harmonic&quot; is not even appropriate for real musical tones. The various sine wave components are inharmonic and more correctly called &quot;partials.&quot;

<P>It was discovered that the inharmonicity among the partials of real musical tones is vital in making the tone sound &quot;real.&quot; Strict harmonicity yields an &quot;electronic&quot; sound. Each partial changes in both amplitude <I>and frequency</I> over the course of a single note. The relative frequency and amplitude relationships among the partials is different for different pitches and intensities from the same instrument. The most complex part of a real musical tone occurs during the attack portion of the note, when there is much inharmonicity. It was discovered that this complex attack portion of the note was vital in the human perception of timbre.

<P>In short, the sound of real musical instruments is more complex than anyone imagined. The idea of analyzing musical tones and coming up with relatively few simple envelopes for controlling the amplitudes and frequencies of the partials was clearly not practical.

<P>Some analyses of real musical sounds were published in early issues (1977 and 1978) of the <I>Computer Music Journal</I> (at the time published by People's Computer Company and now published by the MIT Press). The three-part series &quot;Lexicon of Analyzed Tones&quot; was written by James A. Moorer, John Grey, and John Strawn, and it showed the amplitude and frequency graphs of partials of a single note (less than half a second long) played on a violin, oboe, clarinet, and trumpet. The note used was the E flat above middle C. Twenty partials are used for the violin, 21 for the oboe and clarinet, and 12 for the trumpet. In particular, Volume II, Number 2 (September 1978) of the <I>Computer Music Journal</I> contains numerical line-segment approximations for the various frequency and amplitude envelopes for the oboe, clarinet, and trumpet.

<P>So, with the waveform support in Windows, it is fairly simple to type these numbers into a program, generate multiple sine wave samples for each partial, add them up, and send the samples out to the waveform audio sound board, thereby reproducing the sounds originally recorded over 20 years ago. The ADDSYNTH (&quot;additive synthesis&quot;) program is shown in Figure 22-7.

<P><B>Figure 22-7.</b> <i>The ADDSYNTH Program.</I>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="775"><h3>ADDSYNTH.C</h3></A>
<P><pre>
/*---------------------------------------------------
   ADDSYNTH.C -- Additive Synthesis Sound Generation
                 (c) Charles Petzold, 1998
  ---------------------------------------------------*/

#include &lt;windows.h&gt;
#include &lt;math.h&gt;
#include &quot;addsynth.h&quot;
#include &quot;resource.h&quot;

#define ID_TIMER             1
#define SAMPLE_RATE      22050
#define MAX_PARTIALS        21
#define PI             3.14159

BOOL CALLBACK DlgProc (HWND, UINT, WPARAM, LPARAM) ;

TCHAR szAppName [] = TEXT (&quot;AddSynth&quot;) ;

// Sine wave generator
// -------------------

double SineGenerator (double dFreq, double * pdAngle)
{
     double dAmp ;
     
     dAmp = sin (* pdAngle) ;
     * pdAngle += 2 * PI * dFreq / SAMPLE_RATE ;
     
     if (* pdAngle &gt;= 2 * PI)
          * pdAngle -= 2 * PI ;
     
     return dAmp ;
}

// Fill a buffer with composite waveform
// -------------------------------------

VOID FillBuffer (INS ins, PBYTE pBuffer, int iNumSamples)
{
     static double dAngle [MAX_PARTIALS] ;
     double        dAmp, dFrq, dComp, dFrac ;
     int           i, iPrt, iMsecTime, iCompMaxAmp, iMaxAmp, iSmp ;

          // Calculate the composite maximum amplitude
     
     iCompMaxAmp = 0 ;
     
     for (iPrt = 0 ; iPrt &lt; ins.iNumPartials ; iPrt++)
     {
          iMaxAmp = 0 ;
          
          for (i = 0 ; i &lt; ins.pprt[iPrt].iNumAmp ; i++)
               iMaxAmp = max (iMaxAmp, ins.pprt[iPrt].pEnvAmp[i].iValue) ;
          
          iCompMaxAmp += iMaxAmp ;
     }
     
          // Loop through each sample
     
     for (iSmp = 0 ; iSmp &lt; iNumSamples ; iSmp++)
     {
          dComp = 0 ;
          iMsecTime = (int) (1000 * iSmp / SAMPLE_RATE) ;
          
               // Loop through each partial
          
          for (iPrt = 0 ; iPrt &lt; ins.iNumPartials ; iPrt++)
          {
               dAmp = 0 ;
               dFrq = 0 ;
               
               for (i = 0 ; i &lt; ins.pprt[iPrt].iNumAmp - 1 ; i++)
               {
                    if (iMsecTime &gt;= ins.pprt[iPrt].pEnvAmp[i  ].iTime &amp;&amp;
                         iMsecTime &lt;= ins.pprt[iPrt].pEnvAmp[i+1].iTime)
                    {
                         dFrac = (double) (iMsecTime -
                              ins.pprt[iPrt].pEnvAmp[i  ].iTime) /
                              (ins.pprt[iPrt].pEnvAmp[i+1].iTime -
                              ins.pprt[iPrt].pEnvAmp[i  ].iTime) ;
                         
                         dAmp = dFrac  * ins.pprt[iPrt].pEnvAmp[i+1].iValue +
                              (1-dFrac) * ins.pprt[iPrt].pEnvAmp[i  ].iValue ;
                         
                         break ;
                    }
               }
               
               for (i = 0 ; i &lt; ins.pprt[iPrt].iNumFrq - 1 ; i++)
               {
                    if (iMsecTime &gt;= ins.pprt[iPrt].pEnvFrq[i  ].iTime &amp;&amp;
                         iMsecTime &lt;= ins.pprt[iPrt].pEnvFrq[i+1].iTime)
                    {
                         dFrac = (double) (iMsecTime -
                              ins.pprt[iPrt].pEnvFrq[i  ].iTime) /
                              (ins.pprt[iPrt].pEnvFrq[i+1].iTime -
                              ins.pprt[iPrt].pEnvFrq[i  ].iTime) ;
                         
                         dFrq = dFrac  * ins.pprt[iPrt].pEnvFrq[i+1].iValue +
                              (1-dFrac) * ins.pprt[iPrt].pEnvFrq[i  ].iValue ;
                         
                         break ;
                    }
               }
               dComp += dAmp * SineGenerator (dFrq, dAngle + iPrt) ;
          }
          pBuffer[iSmp] = (BYTE) (127 + 127 * dComp / iCompMaxAmp) ;
     }
}

// Make a waveform file
// --------------------

BOOL MakeWaveFile (INS ins, TCHAR * szFileName)
{
     DWORD        dwWritten ;
     HANDLE       hFile ;
     int          iChunkSize, iPcmSize, iNumSamples ;
     PBYTE        pBuffer ;
     WAVEFORMATEX waveform ;

     hFile = CreateFile (szFileName, GENERIC_WRITE, 0, NULL,
                         CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL) ;
 
     if (hFile == NULL)
          return FALSE ;
     
     iNumSamples = ((long) ins.iMsecTime * SAMPLE_RATE / 1000 + 1) / 2 * 2 ;
     iPcmSize    = sizeof (PCMWAVEFORMAT) ;
     iChunkSize  = 12 + iPcmSize + 8 + iNumSamples ;
     
     if (NULL == (pBuffer = malloc (iNumSamples)))
     {
          CloseHandle (hFile) ;
          return FALSE ;
     }
     
     FillBuffer (ins, pBuffer, iNumSamples) ;
     
     waveform.wFormatTag      = WAVE_FORMAT_PCM ;
     waveform.nChannels       = 1 ;
     waveform.nSamplesPerSec  = SAMPLE_RATE ;
     waveform.nAvgBytesPerSec = SAMPLE_RATE ;
     waveform.nBlockAlign     = 1 ;
     waveform.wBitsPerSample  = 8 ;
     waveform.cbSize          = 0 ;
     
     WriteFile (hFile, &quot;RIFF&quot;,       4, &amp;dwWritten, NULL) ;
     WriteFile (hFile, &amp;iChunkSize,  4, &amp;dwWritten, NULL) ;
     WriteFile (hFile, &quot;WAVEfmt &quot;,   8, &amp;dwWritten, NULL) ;
     WriteFile (hFile, &amp;iPcmSize,    4, &amp;dwWritten, NULL) ;
     WriteFile (hFile, &amp;waveform, sizeof (WAVEFORMATEX) - 2, &amp;dwWritten, NULL) ;
     WriteFile (hFile, &quot;data&quot;,       4, &amp;dwWritten, NULL) ;
     WriteFile (hFile, &amp;iNumSamples, 4, &amp;dwWritten, NULL) ;
     WriteFile (hFile, pBuffer,      iNumSamples,  &amp;dwWritten, NULL) ;
     
     CloseHandle (hFile) ;
     free (pBuffer) ;
     
     if ((int) dwWritten != iNumSamples)
     {
          DeleteFile (szFileName) ;
          return FALSE ;
     }
     return TRUE ;
}

void TestAndCreateFile (HWND hwnd, INS ins, TCHAR * szFileName, int idButton)
{
     TCHAR szMessage [64] ;
     
     if (-1 != GetFileAttributes (szFileName))
          EnableWindow (GetDlgItem (hwnd, idButton), TRUE) ;
     else
     {
          if (MakeWaveFile (ins, szFileName))
               EnableWindow (GetDlgItem (hwnd, idButton), TRUE) ;
          else
          {
               wsprintf (szMessage, TEXT (&quot;Could not create %x.&quot;), szFileName) ;
               MessageBeep (MB_ICONEXCLAMATION) ;
               MessageBox (hwnd, szMessage, szAppName,
                                 MB_OK | MB_ICONEXCLAMATION) ;
          }
     }
}

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     if (-1 == DialogBox (hInstance, szAppName, NULL, DlgProc))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
     }
     return 0 ;
}

BOOL CALLBACK DlgProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static TCHAR * szTrum = TEXT (&quot;Trumpet.wav&quot;) ;
     static TCHAR * szOboe = TEXT (&quot;Oboe.wav&quot;) ;
     static TCHAR * szClar = TEXT (&quot;Clarinet.wav&quot;) ;
     
     switch (message)
     {
     case WM_INITDIALOG:
          SetTimer (hwnd, ID_TIMER, 1, NULL) ;
          return TRUE ;
          
     case WM_TIMER:
          KillTimer (hwnd, ID_TIMER) ;
          SetCursor (LoadCursor (NULL, IDC_WAIT)) ;
          ShowCursor (TRUE) ;
          
          TestAndCreateFile (hwnd, insTrum, szTrum, IDC_TRUMPET) ;
          TestAndCreateFile (hwnd, insOboe, szOboe, IDC_OBOE) ;
          TestAndCreateFile (hwnd, insClar, szClar, IDC_CLARINET) ;
          
          SetDlgItemText (hwnd, IDC_TEXT, TEXT (&quot; &quot;)) ;
          SetFocus (GetDlgItem (hwnd, IDC_TRUMPET)) ;
          
          ShowCursor (FALSE) ;
          SetCursor (LoadCursor (NULL, IDC_ARROW)) ;
          return TRUE ;
     case WM_COMMAND:
          switch (LOWORD (wParam))
          {
          case IDC_TRUMPET:
               PlaySound (szTrum, NULL, SND_FILENAME | SND_SYNC) ;
               return TRUE ;
               
          case IDC_OBOE:
               PlaySound (szOboe, NULL, SND_FILENAME | SND_SYNC) ;
               return TRUE ;
               
          case IDC_CLARINET:
               PlaySound (szClar, NULL, SND_FILENAME |SND_SYNC) ;
               return TRUE ;
          }
          break ;
          
     case WM_SYSCOMMAND:
          switch (LOWORD (wParam))
          {
          case SC_CLOSE:
               EndDialog (hwnd, 0) ;
               return TRUE ;
          }
          break ;
     }
     return FALSE ;
}
</pre>
</td></tr></table>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="776"><h3>ADDSYNTH.RC (excerpts)</h3></A>
<P><pre>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;

/////////////////////////////////////////////////////////////////////////////
// Dialog

ADDSYNTH DIALOG DISCARDABLE  100, 100, 176, 49
STYLE WS_MINIMIZEBOX | WS_CAPTION | WS_SYSMENU
CAPTION &quot;Additive Synthesis&quot;
FONT 8, &quot;MS Sans Serif&quot;
BEGIN
    PUSHBUTTON      &quot;Trumpet&quot;,IDC_TRUMPET,8,8,48,16
    PUSHBUTTON      &quot;Oboe&quot;,IDC_OBOE,64,8,48,16
    PUSHBUTTON      &quot;Clarinet&quot;,IDC_CLARINET,120,8,48,16
    LTEXT           &quot;Preparing Data...&quot;,IDC_TEXT,8,32,100,8
END
</pre>
</td></tr></table>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="777"><h3>RESOURCE.H (excerpts)</h3></A>
<P><pre>
// Microsoft Developer Studio generated include file.
// Used by AddSynth.rc

#define IDC_TRUMPET                     1000
#define IDC_OBOE                        1001
#define IDC_CLARINET                    1002
#define IDC_TEXT                        1003
</pre>
</td></tr></table>

<P>An additional file called ADDSYNTH.H is not shown here because it contains several hundred lines of boring stuff. You'll find it on the companion disc for this book. At the beginning of ADDSYNTH.H, I define three structures used for storing the envelope data. Each amplitude and frequency envelope is stored as an array of structures of type ENV. These are number pairs that consist of a time in milliseconds followed by an amplitude value (in an arbitrary scale) or a frequency (in cycles per second). These arrays are of variable length, ranging from 6 to 14 values. Straight lines are assumed to connect the amplitude and frequency values.

<P>Each instrument consists of a collection of partials (12 for the trumpet and 21 each for the oboe and clarinet) stored as an array of structures of type PRT. The PRT structure stores the number of points in the amplitude and frequency envelopes and a pointer to the ENV array. The INS structure contains the total time of the tone in milliseconds, the number of partials, and a pointer to the PRT array that stores the partials.

<P>ADDSYNTH has three push buttons labeled &quot;Trumpet,&quot; &quot;Oboe,&quot; and &quot;Clarinet.&quot; PCs are not yet quite fast enough to do all the additive synthesis calculations in real time, so the first time you run ADDSYNTH, these buttons will be disabled until the program calculates the samples and creates the TRUMPET.WAV, OBOE.WAV, and CLARINET.WAV sound files. The push buttons are then enabled and you can play the three sounds by using the <I>PlaySound</I> function. The next time you run the program, it will check for the existence of the waveform files and won't need to recreate them.

<P>Most of the work is done in ADDSYNTH's <I>FillBuffer</I> function. <I>FillBuffer</I> begins by calculating the total composite maximum amplitude. It does this by looping through the partials for the instrument to find the maximum amplitude for each partial and then adding the maximum amplitudes all together. This value is later used to scale the samples to an 8-bit sample size.

<P><I>FillBuffer</I> then proceeds to calculate a value for each sample. Each sample corresponds to a millisecond time value that depends on the sample rate. (Actually, at a 22.05 kHz sample rate, every 22 samples correspond to the same millisecond time value.) <I>FillBuffer</I> then loops through the partials. For both the frequency and amplitude, it finds the envelope line segment corresponding to the millisecond time value and performs a linear interpolation.

<P>The frequency value is passed to the <I>SineGenerator</I> function, together with a phase angle value. As I discussed earlier in this chapter, digitally generating sine waves requires a phase angle value to be maintained and incremented based on the frequency value. On return from the <I>SineGenerator</I> function, the sine value is multiplied by the amplitude for the partial and accumulated. After all the partials for a sample are added together, the sample is scaled to the size of a byte.

<A NAME="778"><h2>Waking Up to Waveform Audio</h2></A>
<P>WAKEUP, which you'll find in Figure 22-8, is one of of those programs where the source code files don't look quite complete. The program's window looks like a dialog box, but there's no resource script (we already know how to do that), and the program uses what seems to be a waveform file, but there's no such file on the disk. However, the program packs quite a wallop: The sound it plays is loud and quite annoying. WAKEUP is my alarm clock, and it definitely works in waking me up.

<P><B>Figure 22-8.</b> <i>The WAKEUP program.     </I>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="779"><h3>WAKEUP.C</h3></A>
<P><pre>
/*---------------------------------------
   WAKEUP.C -- Alarm Clock Program
               (c) Charles Petzold, 1998
  ---------------------------------------*/

#include &lt;windows.h&gt;
#include &lt;commctrl.h&gt;

     // ID values for 3 child windows

#define ID_TIMEPICK 0
#define ID_CHECKBOX 1
#define ID_PUSHBTN  2

     // Timer ID

#define ID_TIMER    1

     // Number of 100-nanosecond increments (ie FILETIME ticks) in an hour

#define FTTICKSPERHOUR (60 * 60 * (LONGLONG) 10000000)

     // Defines and structure for waveform &quot;file&quot;

#define SAMPRATE  11025
#define NUMSAMPS  (3 * SAMPRATE)
#define HALFSAMPS (NUMSAMPS / 2) 

typedef struct
{
     char  chRiff[4] ;
     DWORD dwRiffSize ;
     char  chWave[4] ;
     char  chFmt [4] ;
     DWORD dwFmtSize ;
     PCMWAVEFORMAT pwf ;
     char  chData[4] ;
     DWORD dwDataSize ;
     BYTE  byData[0] ;
}
WAVEFORM ;

     // The window proc and the subclass proc

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;
LRESULT CALLBACK SubProc (HWND, UINT, WPARAM, LPARAM) ;

     // Original window procedure addresses for the subclassed windows

WNDPROC SubbedProc [3] ;

     // The current child window with the input focus

HWND hwndFocus ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInst,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName [] = TEXT (&quot;WakeUp&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;

     wndclass.style         = 0 ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) (1 + COLOR_BTNFACE) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;

     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }

     hwnd = CreateWindow (szAppName, szAppName,
                          WS_OVERLAPPED | WS_CAPTION | 
                                          WS_SYSMENU | WS_MINIMIZEBOX,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;

     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HWND          hwndDTP, hwndCheck, hwndPush ;
     static WAVEFORM      waveform = { &quot;RIFF&quot;, NUMSAMPS + 0x24, &quot;WAVE&quot;, &quot;fmt &quot;, 
                                       sizeof (PCMWAVEFORMAT), 1, 1, SAMPRATE, 
                                       SAMPRATE, 1, 8, &quot;data&quot;, NUMSAMPS } ;
     static WAVEFORM    * pwaveform ;
     FILETIME             ft ;
     HINSTANCE            hInstance ;
     INITCOMMONCONTROLSEX icex ;
     int                  i, cxChar, cyChar ;
     LARGE_INTEGER        li ;
     SYSTEMTIME           st ;
     switch (message)
     {
     case WM_CREATE:
               // Some initialization stuff

          hInstance = (HINSTANCE) GetWindowLong (hwnd, GWL_HINSTANCE) ;

          icex.dwSize = sizeof (icex) ;
          icex.dwICC  = ICC_DATE_CLASSES ;
          InitCommonControlsEx (&amp;icex) ;

               // Create the waveform file with alternating square waves

          pwaveform = malloc (sizeof (WAVEFORM) + NUMSAMPS) ;
          * pwaveform = waveform ;

          for (i = 0 ; i &lt; HALFSAMPS ; i++)
               if (i % 600 &lt; 300)
                    if (i % 16 &lt; 8)
                         pwaveform-&gt;byData[i] = 25 ;
                    else
                         pwaveform-&gt;byData[i] = 230 ;
               else
                    if (i % 8 &lt; 4)
                         pwaveform-&gt;byData[i] = 25 ;
                    else
                         pwaveform-&gt;byData[i] = 230 ;

               // Get character size and set a fixed window size.

          cxChar = LOWORD (GetDialogBaseUnits ()) ;
          cyChar = HIWORD (GetDialogBaseUnits ()) ;

          SetWindowPos (hwnd, NULL, 0, 0, 
                        42 * cxChar, 
                        10 * cyChar / 3 + 2 * GetSystemMetrics (SM_CYBORDER) +
                                              GetSystemMetrics (SM_CYCAPTION),
                        SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE) ; 

               // Create the three child windows

          hwndDTP = CreateWindow (DATETIMEPICK_CLASS, TEXT (&quot;&quot;), 
                         WS_BORDER | WS_CHILD | WS_VISIBLE | DTS_TIMEFORMAT,
                         2 * cxChar, cyChar, 12 * cxChar, 4 * cyChar / 3, 
                         hwnd, (HMENU) ID_TIMEPICK, hInstance, NULL) ;
          hwndCheck = CreateWindow (TEXT (&quot;Button&quot;), TEXT (&quot;Set Alarm&quot;),
                         WS_CHILD | WS_VISIBLE | BS_AUTOCHECKBOX,
                         16 * cxChar, cyChar, 12 * cxChar, 4 * cyChar / 3,
                         hwnd, (HMENU) ID_CHECKBOX, hInstance, NULL) ;

          hwndPush = CreateWindow (TEXT (&quot;Button&quot;), TEXT (&quot;Turn Off&quot;),
                         WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON | WS_DISABLED,
                         28 * cxChar, cyChar, 12 * cxChar, 4 * cyChar / 3,
                         hwnd, (HMENU) ID_PUSHBTN, hInstance, NULL) ;

          hwndFocus = hwndDTP ;

               // Subclass the three child windows

          SubbedProc [ID_TIMEPICK] = (WNDPROC) 
                         SetWindowLong (hwndDTP, GWL_WNDPROC, (LONG) SubProc) ;
          SubbedProc [ID_CHECKBOX] = (WNDPROC) 
                         SetWindowLong (hwndCheck, GWL_WNDPROC, (LONG) SubProc);
          SubbedProc [ID_PUSHBTN] = (WNDPROC) 
                         SetWindowLong (hwndPush, GWL_WNDPROC, (LONG) SubProc) ;
          
               // Set the date and time picker control to the current time
               // plus 9 hours, rounded down to next lowest hour
          
          GetLocalTime (&amp;st) ;
          SystemTimeToFileTime (&amp;st, &amp;ft) ;
          li = * (LARGE_INTEGER *) &amp;ft ;
          li.QuadPart += 9 * FTTICKSPERHOUR ; 
          ft = * (FILETIME *) &amp;li ;
          FileTimeToSystemTime (&amp;ft, &amp;st) ;
          st.wMinute = st.wSecond = st.wMilliseconds = 0 ;
          SendMessage (hwndDTP, DTM_SETSYSTEMTIME, 0, (LPARAM) &amp;st) ;
          return 0 ;

     case WM_SETFOCUS:
          SetFocus (hwndFocus) ;
          return 0 ;

     case WM_COMMAND:
          switch (LOWORD (wParam))      // control ID
          {
          case ID_CHECKBOX:
               
                    // When the user checks the &quot;Set Alarm&quot; button, get the 
                    // time in the date and time control and subtract from 
                    // it the current PC time.
               if (SendMessage (hwndCheck, BM_GETCHECK, 0, 0))
               {
                    SendMessage (hwndDTP, DTM_GETSYSTEMTIME, 0, (LPARAM) &amp;st) ;
                    SystemTimeToFileTime (&amp;st, &amp;ft) ;
                    li = * (LARGE_INTEGER *) &amp;ft ;

                    GetLocalTime (&amp;st) ;
                    SystemTimeToFileTime (&amp;st, &amp;ft) ;
                    li.QuadPart -= ((LARGE_INTEGER *) &amp;ft)-&gt;QuadPart ;

                         // Make sure the time is between 0 and 24 hours!
                         // These little adjustments let us completely ignore
                         // the date part of the SYSTEMTIME structures.

                    while (li.QuadPart &lt; 0)
                         li.QuadPart += 24 * FTTICKSPERHOUR ;

                    li.QuadPart %= 24 * FTTICKSPERHOUR ;

                         // Set a one-shot timer! (See you in the morning.)

                    SetTimer (hwnd, ID_TIMER, (int) (li.QuadPart / 10000), 0) ;
               }
                    // If button is being unchecked, kill the timer.

               else
                    KillTimer (hwnd, ID_TIMER) ;

               return 0 ;

               // The &quot;Turn Off&quot; button turns off the ringing alarm, and also
               // unchecks the &quot;Set Alarm&quot; button and disables itself.

          case ID_PUSHBTN:
               PlaySound (NULL, NULL, 0) ;
               SendMessage (hwndCheck, BM_SETCHECK, 0, 0) ;
               EnableWindow (hwndDTP, TRUE) ;
               EnableWindow (hwndCheck, TRUE) ;
               EnableWindow (hwndPush, FALSE) ;
               SetFocus (hwndDTP) ;
               return 0 ;
          }
          return 0 ;

               // The WM_NOTIFY message comes from the date and time picker.
               // If the user has checked &quot;Set Alarm&quot; and then gone back to 
               // change the alarm time, there might be a discrepancy between
               // the displayed time and the one-shot timer. So, the program
               // unchecks &quot;Set Alarm&quot; and kills any outstanding timer.

     case WM_NOTIFY:
          switch (wParam)          // control ID
          {
          case ID_TIMEPICK:
               switch (((NMHDR *) lParam)-&gt;code)       // notification code
               {
               case DTN_DATETIMECHANGE:
                    if (SendMessage (hwndCheck, BM_GETCHECK, 0, 0))
                    {
                         KillTimer (hwnd, ID_TIMER) ;
                         SendMessage (hwndCheck, BM_SETCHECK, 0, 0) ;
                    }
                    return 0 ;
               }
          }
          return 0 ;

          // The WM_COMMAND message comes from the two buttons. 

     case WM_TIMER:

               // When the timer message comes, kill the timer (because we only
               // want a one-shot) and start the annoying alarm noise going.

          KillTimer (hwnd, ID_TIMER) ;
          PlaySound ((PTSTR) pwaveform,  NULL, 
                     SND_MEMORY | SND_LOOP | SND_ASYNC);

               // Let the sleepy user turn off the timer by slapping the 
               // space bar. If the window is minimized, it's restored; then it's
               // brought to the forefront; then the pushbutton is enabled and
               // given the input focus.

          EnableWindow (hwndDTP, FALSE) ;
          EnableWindow (hwndCheck, FALSE) ;
          EnableWindow (hwndPush, TRUE) ;

          hwndFocus = hwndPush ;
          ShowWindow (hwnd, SW_RESTORE) ;
          SetForegroundWindow (hwnd) ;
          return 0 ;

          // Clean up if the alarm is ringing or the timer is still set.
     case WM_DESTROY:
          free (pwaveform) ;

          if (IsWindowEnabled (hwndPush))
               PlaySound (NULL, NULL, 0) ;

          if (SendMessage (hwndCheck, BM_GETCHECK, 0, 0))
               KillTimer (hwnd, ID_TIMER) ;

          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}

LRESULT CALLBACK SubProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     int idNext, id = GetWindowLong (hwnd, GWL_ID) ;
         
     switch (message)
     {
     case WM_CHAR:
          if (wParam == `\t')
          {
               idNext = id ;

               do
                    idNext = (idNext + 
                         (GetKeyState (VK_SHIFT) &lt; 0 ? 2 : 1)) % 3 ;
               while (!IsWindowEnabled (GetDlgItem (GetParent (hwnd), idNext)));

               SetFocus (GetDlgItem (GetParent (hwnd), idNext)) ;
               return 0 ;
          }
          break ;

     case WM_SETFOCUS:
          hwndFocus = hwnd ;
          break ;
     }
     return CallWindowProc (SubbedProc [id], hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

<P>The waveform that WAKEUP uses is just two square waves, but they are alternated very quickly. The actual waveform is calculated during <I>WndProc</I>'s WM_CREATE message. The entire waveform file is stored in memory; a pointer to this memory block is passed to the <I>PlaySound</I> function, which uses the SND_MEMORY, SND_LOOP, and SND_ASYNC arguments.

<P>WAKEUP uses a common control called the Date-Time Picker. This control takes care of logic to allow the user to select a particular date and time. (WAKEUP uses only the time feature.) A program can get and set this time using the SYSTEMTIME structure used in obtaining and setting the PC's own clock. To see how versatile the Date-Time Picker really is, try creating the window without any DTS style flags.

<P>Notice the logic at the end of the WM_CREATE message: the program assumes that you run it soon before going to bed and that you want to wake up in 8 hours from the next stroke of the hour.

<P>Now obviously you could obtain the current time in a SYSTEMTIME structure from the <I>GetLocalTime</I> function and increment the time &quot;manually.&quot; But in the general case this calculation involves checking for a resultant hour greater than 24, which means you'll have to increment the day field, and then that might involve incrementing the month (so you have to have logic for the number of days in each month and a leap year check), and finally you might have to increment the year.

<P>Instead, the recommended method (from <I>/Platform SDK/Windows Base Services/General Library Time/Time Reference/Time Structures/SYSTEMTIME</I>) is to convert the SYSTEMTIME to a FILETIME structure (using <I>SystemTimeToFileTime</I>), cast the FILETIME structure to a LARGE_INTEGER structure, perform the calculations on the large integer, cast back to a FILETIME structure, and then convert back to a SYSTEMTIME structure (using <I>FileTimeToSystemTime</I>).

<P>The FILETIME structure, as its name implies, is used to get and set the time that a file was last modified. The structure looks like this:

<P><pre>
type struct _FILETIME       // ft
{
     DWORD dwLowDateTime ;
     DWORD dwHighDateTime ;
}
FILETIME ;
</pre>

<P>These two fields together express a 64-bit value that indicates the number of 100-nanosecond intervals from January 1, 1601.

<P>The Microsoft C/C++ compiler supports 64-bit integers as a nonstandard extension to ANSI C. The data type is <I>__int64</I>. You can do all the normal arithmetic operations on <I>__int64</I> types, and some run-time library functions support them. The Windows WINNT.H header file defines the following:

<P><pre>
typedef __int64 LONGLONG ;
typedef unsigned __int64 DWORDLONG ;
</pre>

<P>In Windows, this sometimes called a &quot;quad word&quot; or, more commonly, a &quot;large integer.&quot; There's also a union defined:

<P><pre>
typedef union _LARGE_INTEGER
{
     struct
     {
          DWORD LowPart ;
          LONG  HighPart ;
     } ;
     LONGLONG QuadPart ;
}
LARGE_INTEGER ; 
</pre>

<P>This is all documented in <I>/Platform SDK/Windows Base Services/General Library/Large Integer Operations</I>. The union lets you work with the large integer either as two 32-bit quantities or as a 64-bit quantity.

</BODY>
</HTML>






