<HTML>
<HEAD>
<TITLE>Working with Numbers</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch05b.htm", "ch05d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="166"><h1>Working with Numbers</h1></A>
<p>Visual Basic offers a rich assortment of math operators and functions. Most of 
these operators are <I>polymorphic</I> in the sense that they work equally well with 
arguments of any type, including Integer, Long, Single, Double, Date, and Currency. 
Depending on the particular operator or function, the Visual Basic compiler can decide 
to convert the operands to a more suitable data type. However, this is the 
language's job, and you don't have to worry because everything is done automatically for you. </p>

<A NAME="167"><h2>Math Operators</h2></A>
<p>As you know, Visual Basic supports all four math operators. When combining 
two values of different types, Visual Basic automatically applies the 
<I>data coercion </I>and converts the simpler type to the more comprehensive one (for example, Integer 
to Long or Single to Double). Interestingly, the division operator 
(/) always converts both its operands to Double, which can cause some unexpected overhead. If 
you're dividing an Integer or Long number by another Integer or Long number and you 
aren't interested in the decimal part of the quotient, you should use the integer 
division operator (\), which executes faster:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim a As Long, b As Long, result As Long
result = a / b          ' Floating point division
result = a \ b          ' This is about 4 times faster.
</pre>
</td></tr>
</table></p>

<p>Visual Basic also supports the exponentiation operator (^), which raises 
a number to an exponent. In this case, the result is always of type Double, even if 
you're raising an integer number to an integer exponent. In general, the ^ operator is 
relatively slow, and for small integer exponents you might decide to use a chain 
of multiplication operations instead:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim x As Double, result As Double 
x = 1.2345
result = x ^ 3
result = x * x * x      ' This is about 20 times faster.
</pre>
</td></tr>
</table></p>

<p>The MOD operator extracts the remainder of a division between integer 
values. It's often used to test whether a number is an exact multiple of another number. 
This operator is very efficient but has a limitation: It converts its operands to Long 
and therefore can't be used with arbitrarily large values. It also truncates any decimal 
part. Here's a function that works with any Double value:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Function FPMod(ByVal Number As Double, ByVal divisor As Double) As Double
    ' Note: this differs from MOD when Number is negative.
    FPMod = Number - Int(Number / divisor) * divisor
End Function
</pre>
</td></tr>
</table></p>

<p>Several other functions are often useful when you're working with numbers:</p>

<UL>
<p><li><I>Abs </I>returns the absolute value of its argument.</li></p>

<p><li><I>Sgn </I>returns -1, 0, or +1 if the argument is negative, zero, or positive, respectively.</li></p>

<p><li><I>Sqr</I> returns the square root of a number.</li></p>

<p><li><I>Exp</I> raises <I>e</I> (the base of natural logarithms) to the power passed in the argument.</li></p>

<p><li><I>Log </I>returns the natural logarithm of its argument. You can evaluate a decimal logarithm using the following function:</li></p>
 
<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Function Log10(Number As Double) As Double 
    Log10 = Log(Number) / 2.30258509299405

End Function
</pre>
</td></tr>
</table></p>
</UL>

<A NAME="168"><h2>Comparison Operators</h2></A>
<p>Visual Basic supports six comparison operators, which can be applied to both 
numeric and string operands:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
=   &lt;   &lt;=   &gt;   &gt;=   &lt;&gt;
</pre>
</td></tr>
</table></p>

<p>These operators are often used in <I>If</I> blocks, but you should keep in mind 
that they aren't conceptually different from any other math operators, in the sense that 
they accept two operands and deliver a result. Such a result can be False (0) or 
True (-1). You can sometimes exploit this fact to write more concise code, as in the following:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' The following lines are equivalent.
If x &gt; y Then x = x _ 1
x = x + (x &gt; y)
</pre>
</td></tr>
</table></p>

<p><div class="caution"><blockquote><b>CAUTION</b><hr>
You should always be careful when using the = operator on 
Single and Double values because Visual Basic often introduces small rounding 
errors when operating on floating-point numbers. For example, look at this code:

<p><table><tr><td>
<pre>
Dim d As Double, i As Integer

For i = 1 To 10: d = d + 0.1: Next

Print d, (d = 1)        ' Displays &quot;1  False&quot; !!!
</pre>
</td></tr>
</table></p>

<p>The preceding result seems absurd because the variable appears to contain 
the correct value, but the test (<I>d </I>=<I> 
1</I>) returns False. You shouldn't rely on what 
Visual Basic shows you in a <I>Print </I>statement because it always rounds decimal 
numbers. In fact, the actual value of the <I>d 
</I>variable is slightly less than 1, the 
exact difference being 1.11022302462516E-16 (a number with 15 zeros after the 
decimal separator), but this is enough to make the equality test fail. Therefore, 
my recommendation is that you never use the = on floating-point numbers. 
Here's a better approach:</p>

<p><table><tr><td>
<pre>
' &quot;equal&quot; up to 10th decimal digit
Function AlmostEqual(x, y) As Boolean
    AlmostEqual = (Abs(x - y) &lt;= 0.0000000001)

End Function
</pre>
</td></tr>
</table></p>
</blockquote></div></p>

<A NAME="169"><h2>Boolean and Bit-Wise Operators</h2></A>
<p>Visual Basic for Applications supports a few Boolean operators, which are 
especially useful for combining multiple Boolean subexpressions. The operators used 
most frequently are AND, OR, XOR, and NOT. For example, the following code 
uses Boolean operators to determine the signs of two variables:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
If (x &gt; 0) And (y &gt; 0) Then
    ' Both X and Y are positive.
ElseIf (x = 0) Or (y = 0) Then
    ' Either X or Y (or both) are zero.
ElseIf (x &gt; 0) Xor (y &gt; 0) Then
    ' Either X or Y (but not both of them) are positive.
ElseIf Not (x &gt; 0) Then
    ' X is not positive.
End If
</pre>
</td></tr>
</table></p>

<p>Remember that these operators are actually <I>bit-wise 
</I>operators, in that they act on each individual bit of their operands. In practice, this can make a difference if 
the operands aren't Boolean values (that is, they have a value different from 
-1 and 0). You can use the AND operator to test one or more bits of a number:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
If (number And 1) Then Print &quot;Bit 0 is set (number is an odd value)&quot;
If (number And 6) = 6 Then Print &quot;Both bits 1 and 2 are set&quot;
If (number And 6) Then Print &quot;Either bits 1 and 2, or both, are set&quot;
</pre>
</td></tr>
</table></p>

<p>You usually use the OR operator to set one or more bits:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
number = number Or 4          ' Set bit 2. 
number = number Or (8 + 1)    ' Set bits 3 and 0.
</pre>
</td></tr>
</table></p>

<p>To reset one or more bits, you combine the AND and 
NOT operators:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Number = number And Not 4     ' Reset bit 2.
</pre>
</td></tr>
</table></p>

<p>Finally you use the XOR operator to flip the state of one or more bits:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Number = number Xor 2         ' Flip the state of bit 1.
</pre>
</td></tr>
</table></p>

<p>If you don't know at compile time which bit should be set, reset, or 
flipped, you can use the exponentiation operator, as in the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Number = Number Or (2 ^ N)    ' Set Nth bit (N in range 0-30).
</pre>
</td></tr>
</table></p>

<p>This approach has two defects: It raises an overflow error if 
<I>N = 31</I>, and it's highly inefficient because it relies on a floating-point operation. You can solve both 
problems with the following function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Function Power2(ByVal exponent As Long) As Long
    Static result(0 To 31) As Long, i As Integer
    ' Evaluate all powers of 2 only once.
    If result(0) = 0 Then
        result(0) = 1
        For i = 1 To 30
            result(i) = result(i - 1) * 2
        Next
        result(31) = &amp;H80000000        ' This is a special value. 
    End If
    Power2 = result(exponent)
End Function
</pre>
</td></tr>
</table>
</p>

<A NAME="170"><h2>Rounding and Truncating</h2></A>
<p>The <I>Int</I> function truncates a number to the integer value equal or lower than its 
argument. This is different from just saying &quot;truncates the decimal part of a 
number.&quot; The difference becomes apparent if the argument is negative:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Print Int(1.2)             ' Displays &quot;1&quot;
Print Int(-1.2)            ' Displays &quot;-2&quot;
</pre>
</td></tr>
</table></p>

<p> The function that actually truncates the decimal part of a number is 
<I>Fix</I>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Print Fix(1.2)             ' Displays &quot;1&quot;
Print Fix(-1.2)            ' Displays &quot;-1&quot;
</pre>
</td></tr>
</table></p>

<p><img src="images/new.jpg" width=102 height=87 border=0></p>

<p>Visual Basic 6 introduces a new math function, 
<I>Round</I>, which lets you round a decimal number to the number of digits you want (or to the nearest integer, if 
the second argument is omitted):</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Print Round(1.45)          ' Displays &quot;1&quot;
Print Round(1.55)          ' Displays &quot;2&quot;
Print Round(1.23456, 4)    ' Displays &quot;1.2346&quot;
</pre>
</td></tr>
</table></p>

<p><I>Round</I> has an undocumented quirk: When the fractional part is exactly 0.5, 
it rounds up if the integer portion is an odd number and rounds down if it's even:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Print Round(1.5), Round(2.5)   ' Both display &quot;2&quot;.
</pre>
</td></tr>
</table></p>

<p>This behavior is necessary so that you can avoid introducing errors when 
you're doing statistical evaluations, and it shouldn't be considered a bug.</p>

<p>When rounding, you sometimes need to determine the nearest integer 
higher or equal to the argument, but Visual Basic lacks such a function. You can remedy 
this problem with this short routine:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Function Ceiling(number As Double) As Long
    Ceiling = -Int(-number)
End Function
</pre>
</td></tr>
</table>
</p>

<A NAME="171"><h2>Converting Among Different Numeric Bases</h2></A>
<p>VBA supports numeric constants in decimal, hexadecimal, and octal systems:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
value = &amp;H1234       ' The value 4660 as a hexadecimal constant
value = &amp;O11064      ' The same value as octal constant
</pre>
</td></tr>
</table></p>

<p>You can convert any hexadecimal or octal string into its decimal value 
using the <I>Val</I> function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' If Text1 holds a hexadecimal value
value = Val(&quot;&amp;H&quot; &amp; Text1.Text)
</pre>
</td></tr>
</table></p>

<p>You do the opposite conversion&#8212;from decimal to hexadecimal or 
octal&#8212;using the <I>Hex</I> and <I>Oct 
</I>functions:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Text1.Text = Hex$(value)
</pre>
</td></tr>
</table></p>

<p>Oddly, Visual Basic doesn't include a function that converts to and from 
binary numbers, which are by far more common than octal values. You can achieve 
these conversions using a pair of functions, which build on the 
<I>Power2</I> function seen in the section &quot;<A HREF="ch05c.htm#169">Boolean and Bit-Wise Operators</A>&quot; earlier in this chapter:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Convert from decimal to binary.
Function Bin(ByVal value As Long) As String
    Dim result As String, exponent As Integer
    ' This is faster than creating the string by appending chars.
    result = String$(32, &quot;0&quot;)
    Do
        If value And Power2(exponent) Then
            ' We found a bit that is set, clear it.
            Mid$(result, 32 - exponent, 1) = &quot;1&quot;
            value = value Xor Power2(exponent)
        End If
        exponent = exponent + 1
    Loop While value
    Bin = Mid$(result, 33 - exponent)  ' Drop leading zeros.
End Function

' Convert from binary to decimal.
Function BinToDec(value As String) As Long
    Dim result As Long, i As Integer, exponent As Integer
    For i = Len(value) To 1 Step -1
        Select Case Asc(Mid$(value, i, 1))
            Case 48      ' &quot;0&quot;, do nothing.
            Case 49      ' &quot;1&quot;, add the corresponding power of 2.
                result = result + Power2(exponent)
            Case Else
                Err.Raise 5  ' Invalid procedure call or argument
        End Select
        exponent = exponent + 1
    Next
    BinToDec = result
End Function
</pre>
</td></tr>
</table>
</p>

<A NAME="172"><h2>Format Options for Numbers</h2></A>
<p>All versions of the VBA language include the 
<I>Format</I> function, which is a powerful tool that meets most of your formatting requirements. Its syntax is rather complex:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
result = Format(Expression, [Format], _
    [FirstDayOfWeek As VbDayOfWeek = vbSunday], _
    [FirstWeekOfYear As VbFirstWeekOfYear = vbFirstJan1]) 
</pre>
</td></tr>
</table></p>

<p>Fortunately, the first two arguments are sufficient for all your tasks unless 
you're formatting dates, which I'll talk about later in this chapter. Right now I'll 
summarize the <I>Format </I>function's many capabilities when formatting numeric values, although 
I suggest that you have a look at Visual Basic documentation for more details.</p>

<p>When formatting numbers, the <I>Format</I> function supports both 
<I>named formats</I> and <I>custom formats</I>. 
Named<I> </I>formats include the following strings: 
<I>General Number</I> (no special formatting, use the scientific notation if needed), 
<I>Currency</I> (currency symbol, thousand separator and two decimal digits), 
<I>Fixed</I> (two decimal digits), <I>Standard</I> (thousand separator and two decimal digits), 
<I>Percent</I> (a percentage, with the <I>%</I> symbol appended), 
<I>Scientific</I> (scientific notation), 
<I>Yes/No</I>, <I>True/False</I>, <I>On/Off</I> 
(False or Off if 0, True or On otherwise). 
<I>Format</I> is a <I>locale-aware </I>function and 
automatically uses the currency symbol, the thousand separator, and the decimal 
separator that are appropriate to the current locale.</p>

<p>If a named format doesn't do the job, you can create your own custom 
format using a format string made up of special characters. (For a detailed list and 
the meaning of such formatting characters, see the Visual Basic documentation.)</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Decimal and thousand separators. (Format rounds its result.)
Print Format(1234.567, &quot;#,##0.00&quot;)   ' &quot;1,234.57&quot;
' Percentage values
Print Format(0.234, &quot;#.#%&quot;)          ' &quot;23.4%&quot;
' Scientific notation
Print Format(12345.67, &quot;#.###E+&quot;)    ' &quot;1.235E+4&quot;
Print Format(12345.67, &quot;#.###E-&quot;)    ' &quot;1.235E4&quot;
</pre>
</td></tr>
</table></p>

<p>A great feature of the <I>Format</I> function is its ability to apply different 
format strings if the number is positive, negative, 0, or Null. You use the semicolon as 
the delimiter of the section in the custom format string. (You can specify one, two, 
three, or four different sections.)</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Two decimal digits for positive numbers, enclose negative numbers within
' a pair of parentheses, use a blank for zero, and &quot;N/A&quot; for Null values.
Print Format(number, &quot;##,###.00;(##,###.00); ;N/A&quot;)
</pre>
</td></tr>
</table></p>

<p><img src="images/new.jpg" width=102 height=87 border=0></p>

<p>Visual Basic 6 has introduced three new formatting functions for 
numbers&#8212;namely <I>FormatNumber</I>, 
<I>FormatPercent</I>, and <I>FormatCurrency</I>&#8212;that have 
been borrowed from VBScript. (Three more 
functions&#8212;<I>FormatDate</I>, <I>MonthName</I>, 
and <I>WeekdayName</I>&#8212;are explained in the section &quot;Working with Dates,&quot; later in 
this chapter.) These new functions duplicate the capabilities of the more powerful, 
all-in-one <I>Format </I>workhorse, but their syntax is more intuitive, as you can see in 
the code below.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
result = FormatNumber(expr, [DecDigits], [InclLeadingDigit], _
    [UseParens], [GroupDigits] )
result = FormatPercent(expr, [DecDigits], [InclLeadingDigit], _
    [UseParens], [GroupDigits] )
result = FormatCurrency(expr, [DecDigits], [InclLeadingDigit], _
    [UseParens], [,GroupDigits] )
</pre>
</td></tr>
</table></p>

<p>In all cases, <I>DecDigits </I>is the number of decimal digits you want (2 is the 
default); <I>InclLeadingDigit </I>tells whether numbers in the range 
[-1,1] are displayed with a leading 0; <I>UseParens 
</I>specifies whether negative numbers are enclosed in 
parentheses; <I>GroupDigits </I>tells whether a thousand separator should be used. The last 
three optional arguments can each be one of the following values: 0-vbFalse, 
-1-vbTrue, or -2-vbUseDefault (the default setting for the user's locale). If you omit a 
value, vbUseDefault is assumed by default.</p>

<A NAME="173"><h2>Random Numbers</h2></A>
<p>At times, you need to generate one or more random values. Among the types 
of software for which you need to do this, games come to mind, but this ability is 
also useful in business applications that include simulations. Visual Basic offers only 
one statement and one function for generating random values. You initialize the seed 
of the internal random number generators using the 
<I>Randomize</I> statement. You can pass it a number that will be used as a seed; otherwise, Visual Basic automatically 
uses the value returned by the <I>Timer</I> function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Randomize 10
</pre>
</td></tr>
</table></p>

<p>The <I>Rnd</I> function returns a random value each time you call it. The 
returned value is always less than 1 and greater than or equal to 0, so you need to scale 
the result to get a number in the range you want:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Simple computerized dice
Randomize
For i = 1 To 10
    Print Int(Rnd * 6) + 1
Next
</pre>
</td></tr>
</table></p>

<p>At times, you might want to repeat the same sequence of random 
numbers, especially when debugging your code. It might seem that you can obtain this 
behavior by calling the <I>Randomize</I> statement with the same seed, but this isn't so. Instead, 
as counterintuitive as it may seem, to repeat the same random sequence you call 
the <I>Rnd</I> function with a negative argument:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
dummy = Rnd(-1)            ' Initialize the seed. (No Randomize is needed!)
For i = 1 To 10            ' This loop will always deliver the same
    Print Int(Rnd * 6) + 1 ' sequence of random numbers.
Next
</pre>
</td></tr>
</table></p>

<p>You can also reread the random number that you have just generated by 
passing 0 as an argument to <I>Rnd</I>.</p>

<p>A common task when you're dealing with random numbers is the 
generation of a casual permutation of the numbers in a given range: for example, this might 
be useful for shuffling a deck of cards in a game. Here's a simple and efficient 
routine that returns an array of all Long numbers in the range of 
<I>first </I>and <I>last</I>, in random order:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Function RandomArray(first As Long, last As Long) As Long()
    Dim i As Long, j As Long, temp As Long
    ReDim result(first To last) As Long
    ' Initialize the array.
    For i = first To last: result(i) = i: Next
    ' Now shuffle it.
    For i = last To first Step -1
        ' Generate a random number in the proper range.
        j = Rnd * (last - first + 1) + first
        ' Swap the two items.
        temp = result(i): result(i) = result(j): result(j) = temp
    Next
    RandomArray = result
End Function
</pre>
</td></tr>
</table>
</p>

</BODY>
</HTML>





