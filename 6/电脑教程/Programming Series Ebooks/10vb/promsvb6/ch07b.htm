<HTML>
<HEAD>
<TITLE>Events</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07a.htm", "ch07c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="268"><h1>Events</h1></A>
<p>Until Visual Basic 4, the term <I>class events</I> could refer only to the internal <I>Class_Initialize</I> and <I>Class_Terminate</I> events that the Visual Basic runtime fires when an object is created and destroyed. In versions 5 and 6, however, classes are able to raise events to the outside, exactly as controls and forms can. This ability dramatically increases the potential of class modules, making it possible to integrate them more tightly in applications while continuing to consider them separate and reusable modules.</p>

<A NAME="269"><h2>Events and Code Reusability</h2></A>
<p>Before showing how a class module can expose events to the outside and how the client code can trap them, let me explain why events are so important for code reuse. The ability to create a piece of code that can be recycled <I>as is </I>in other projects is too tantalizing to leave any programmer indifferent to the possibility. To illustrate the concept, I'll describe an imaginary class module whose primary job is copying a series of files and optionally informing the caller about the progress of the operation (so that the caller code can display a progress bar or a message on the status bar for the user). Without events, we have two possible ways to implement this code, both of which are clearly unsatisfactory:</p>

<UL>
<p><li>You split the class module into several (related) methods. For instance, you create a <I>ParseFileSpec</I> method that receives the file specification (such as C:\Word\*.doc) and returns a list of files, and you also create a <I>CopyFile </I>method that copies one file at a time. In this case, the client doesn't need a notification because it governs the entire process and calls each method in turn. Unfortunately, this means writing more code on the client side, which diminishes the class's usability. For more complex jobs, this approach is absolutely inappropriate.</li></p>

<p><li>You create a more intelligent class module, which performs its chores internally but at the same time calls back the client when it needs to notify the client that something has occurred. This works better, but you need to solve a problem: How exactly does the class call back its client? Does it invoke a procedure with a given name? This would force you to include this procedure even if you aren't actually interested in a notification; otherwise, the compiler wouldn't run the code. A second, more serious problem is what happens if your application uses the same class in two or more distinct circumstances. Each instance of the class will clearly call back the same procedure, so the client code would have to figure out which instance has called it. And if the caller code is a class itself, that would break its self-containment. Again, we need a better approach. (Note: More advanced <I>callback techniques </I>are available to Visual Basic programmers, and I'll describe them in <a href="ch16a.htm">Chapter 16</a>. They aren't as simple as depicted in this paragraph.)</li></p>
</UL>
 
<p>Finally events made their appearance and offered the best solution so far to the dilemma:</p>

<UL>
<p><li>You can create a class as described in the previous point, but when the time comes for a notification the class simply <I>raises </I>an event. The client code might not be listening to this specific event, but the class will continue with its copy operation and return from the method only when all files have been copied (unless of course you also provide clients with a mechanism to stop the process). This approach permits you to keep the structure of the client as simple as possible because it doesn't need to implement an event procedure for all the possible events raised by the class. This is similar to what happens when you place a TextBox control on a form and then decide to respond to just one or two of the many events that the control raises.</li></p>
</UL>
 
<A NAME="270"><h2>Syntax for Events</h2></A>
<p>Implementing events in a class module and using them in a client module is a straightforward process, which consists of just a few logical, easy steps. Figure 7-1 shows how the implementation works. I'm using as an example the hypothetical CFileOp class, which copies multiple files, as I described previously.</p>

<p>
<A HREF="javascript:fullSize('F07ph01x.htm')"> <img src="images/F07ph01.JPG" width=404 height=245 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 7-1.</B> <i>Implementing events in a class module.</i><!--/caption-->
</p>

<A NAME="271"><h3>Declaring an event</h3></A>
<p>To expose an event to its clients, a class must include an <I>Event</I> statement in its declaration section. This statement serves to inform the outside world about the event's name as well as its arguments. For example, the CFileOp class might expose this event:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Event FileCopyComplete(File As String, DestPath As String)
</pre>
</td></tr>
</table></p>

<p>There's nothing special about the syntax of arguments, and you can in fact declare arguments of any type supported by Visual Basic, including objects, collections, and <I>Enum</I> values.</p>

<A NAME="272"><h3>Raising an event</h3></A>
<p>When the time comes for the class to raise an event, it executes a <I>RaiseEvent </I>statement, which specifies both the event name and its actual arguments. Again, this isn't conceptually different from calling a procedure, and you'll also find that Microsoft IntelliSense can give you a hand in both selecting the event name and the values for its arguments. In the CFileOp class, you could therefore write something like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>RaiseEvent FileCopyComplete &quot;c:\bootlog.txt&quot;, &quot;c:\backup&quot;
</pre>
</td></tr>
</table></p>

<p>This is all you need to do in the class module. Now let's see what the client code does.</p>

<A NAME="273"><h3>Declaring the object in the client module</h3></A>
<p>If you're writing code in a form or a class module and you want to receive events from an object, you must declare a reference to that object in the declaration section of the module, using the <I>WithEvents</I> keyword:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' You can use Public, Private, or Dim, as needed.
Dim WithEvents FOP As CFileOp
</pre>
</td></tr>
</table></p>

<p>You should be aware of a few facts about the <I>WithEvents</I> clause:</p>

<UL>
<p><li>It can appear only in the declaration section of a module and can't be local to a procedure. It can be used in any type of module except for standard BAS modules.</li></p>

<p><li>It can't be used with the <I>New</I> keyword; in other words, you can't create auto-instancing object variables if you also use <I>WithEvents</I>. Instead, you must declare and create the instance as a separate step, as in this code:</li></p>
 
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_Load()
    Set FOP = New CFileOp
End Sub
</pre>
</td></tr>
</table></p>

<p><li>You can't declare an array of object variables in a <I>WithEvents</I> clause.</li></p>

<p><li><I>WithEvents</I> doesn't work with generic object variables.</li></p>
</UL>
 
<A NAME="274"><h3>Trapping the event</h3></A>
<p>At this point, Visual Basic has all the information it needs to respond to events raised by the object. In fact, if you look at the list portion of the leftmost combo box at the top of the code editor window, you'll see that the variable you have declared using <I>WithEvents</I> appears in the list, together with all the controls already on the form. Select it and move to the rightmost combo box control to choose the event that interests you. (In this example, there's only one such event.) As it happens for events coming from controls, Visual Basic automatically creates the procedure template for you, and all you have to do is fill it with some meaningful code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Fop_FileCopyComplete(File As String, DestPath As String)
    MsgBox &quot;File &quot; &amp; File &amp; &quot; has been copied to &quot; &amp; DestPath
End Sub
</pre>
</td></tr>
</table></p>

<A NAME="275"><h2>A First, Complete Sample Application</h2></A>
<p>Now that all syntax details have been explained, it's time to complete the CFileOp class, which is able to copy one or multiple files and provide feedback to the caller. As you'll see shortly, this initial sample program provides us with the playground for more complex and interesting programming techniques based on events.</p>

<A NAME="276"><h3>The CFileOp class module</h3></A>
<p>Let's create a class module and name it CFileOp. This class exposes a few properties that allow the client to decide which files should be copied (<I>FileSpec</I>, <I>Path</I>, and <I>Attributes</I> properties) and a method that starts the actual copy process. As I indicated, the class also exposes a <I>FileCopyComplete</I> event:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The CFileOp class module
Event FileCopyComplete(File As String, DestPath As String)
Private m_FileSpec As String
Private m_Filenames As Collection
Private m_Attributes As VbFileAttribute

Property Get FileSpec() As String
    FileSpec = m_FileSpec
End Property
Property Let FileSpec(ByVal newValue As String)
    ' Reset the internal Collection if a new file specification is given.
    If m_FileSpec &lt;&gt; newValue Then
        m_FileSpec = newValue
        Set m_Filenames = Nothing
    End If
End Property

Property Get Path() As String
    Path = GetPath(m_FileSpec)
End Property
Property Let Path(ByVal newValue As String)
    ' Get current file specification, and then substitute just the path.
    FileSpec = MakeFilename(newValue, GetFileName(FileSpec))
End Property

Property Get Attributes() As VbFileAttribute
    Attributes = m_Attributes
End Property
Property Let Attributes(ByVal newValue As VbFileAttribute)
    ' Reset the internal Collection only if a new value is given.
    If m_Attributes &lt;&gt; newValue Then
        m_Attributes = newValue
        Set m_Filenames = Nothing
    End If
End Property

' Holds the list of all the files that match FileSpec,
' plus any other file added by the client code (read-only property)
Property Get Filenames() As Collection
    ' Build the file list &quot;on demand&quot;, and only if necessary.
    If m_Filenames Is Nothing Then ParseFileSpec
    Set Filenames = m_Filenames
End Property

' Parses a file specification and attributes and adds
' the resulting filename to the internal m_Filenames Collection
Sub ParseFileSpec(Optional FileSpec As Variant, _
    Optional Attributes As VbFileAttribute)
    Dim file As String, Path As String
    ' Provide a default for arguments.
    If IsMissing(FileSpec) Then
        ' In this case, we need a file specification.
        If Me.FileSpec = &quot;&quot; Then Err.Raise 1001, , &quot;FileSpec undefined&quot;
        FileSpec = Me.FileSpec
        Attributes = Me.Attributes
    End If

    ' Create the internal Collection if necessary.
    If m_Filenames Is Nothing Then Set m_Filenames = New Collection
    Path = GetPath(FileSpec)
    file = Dir$(FileSpec, Attributes)
    Do While Len(file)
        m_Filenames.Add MakeFilename(Path, file)
        file = Dir$
    Loop
End Sub

Sub Copy(DestPath As String)
    Dim var As Variant, file As String, dest As String
    On Error Resume Next
    For Each var In Filenames
        file = var
        dest = MakeFilename(DestPath, GetFileName(file))
        FileCopy file, dest
        If Err = 0 Then
            RaiseEvent FileCopyComplete(file, DestPath)
        Else
            Err.Clear
        End If
    Next
End Sub

' Support routines that parse a filename. They are used internally
' but are also exposed as Public for convenience.
Sub SplitFilename(ByVal CompleteName As String, Path As String, _
    file As String, Optional Extension As Variant)
    Dim i As Integer
    ' Assume there isn't any embedded path.
    Path = &quot;&quot;: file = CompleteName
    ' Backward search for a path delimiter
    For i = Len(file) To 1 Step -1
        If Mid$(file, i, 1) = &quot;.&quot; And Not IsMissing(Extension) Then
            ' We have found an extension, and the caller asked for it.
            Extension = Mid$(file, i + 1)
            file = Left$(file, i - 1)
        ElseIf InStr(&quot;:\&quot;, Mid$(file, i, 1)) Then
            ' Paths don't have a trailing backslash.
            Path = Left$(file, i)
            If Right$(Path, 1) = &quot;\&quot; Then Path = Left$(Path, i - 1)
            file = Mid$(file, i + 1)
            Exit For
        End If
    Next
End Sub

Function GetPath(ByVal CompleteFileName As String) As String
    SplitFilename CompleteFileName, GetPath, &quot;&quot;
End Function

Function GetFileName(ByVal CompleteFileName As String) As String
    SplitFilename CompleteFileName, &quot;&quot;, GetFileName
End Function

Function MakeFilename(ByVal Path As String, ByVal FileName As String, _
    Optional Extension As String) As String
    Dim result As String
    If Path &lt;&gt; &quot;&quot; Then
        ' Path might include a trailing backslash.
        result = Path &amp; IIf(Right$(Path, 1) &lt;&gt; &quot;\&quot;, &quot;\&quot;, &quot;&quot;)
    End If
    result = result &amp; FileName
    If Extension &lt;&gt; &quot;&quot; Then
        ' Extension might include a dot.
        result = result &amp; IIf(Left$(Extension, 1) = &quot;.&quot;, &quot;.&quot;, &quot;&quot;) _
            &amp; Extension
    End If
    MakeFilename = result
End Function
</pre>
</td></tr>
</table></p>

<p>The structure of the class should be self-evident, so I'll just explain a few minor details. When you assign a value to either the <I>FileSpec</I> or the <I>Attributes</I> property, the class resets an internal <I>m_Filenames</I> Collection variable. When eventually the <I>Filenames </I>Public property is referenced&#8212;from outside or inside the class module&#8212;the corresponding <I>Property Get</I> procedure checks whether the file list should be rebuilt, and if so, it invokes the <I>ParseFileSpec</I> method. This method could have been made Private to the class module, but keeping it Public adds some flexibility, as I'll show in the &quot;<A HREF="ch07b.htm#279">Filtering Input Data</A>&quot; section, later in this chapter. At this point, everything is ready for the <I>Copy</I> method, which requires only the <I>DestPath</I> argument to learn where files are to be copied and which can raise a <I>FileCopyComplete </I>event back in the client code. All the other functions&#8212;<I>SplitFilename</I>, <I>GetPath</I>, <I>GetFilename</I>, and so on&#8212;are support routines used for parsing filenames and paths. They're also exposed as Public methods, however, because they can be useful to the client code as well.</p>

<A NAME="277"><h3>The client form module</h3></A>
<p>Add a form module to your project, and add a few controls, as depicted in Figure 7-2:</p>

<p>
<A HREF="javascript:fullSize('F07ph02x.htm')"> <img src="images/F07ph02.JPG" width=404 height=221 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 7-2.</B> <i>The preliminary version of the CFileOp sample application at design time.</i><!--/caption-->
</p>

<p>Use the following code to help you decide what names to use for your controls. (Or you can just load the demonstration program from the companion CD). I've used self-explanatory names for controls, so you shouldn't have problems understanding the function of each one of them. This is the code in the form module:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The client Form1 module
Dim WithEvents Fop As CFileOp

Private Sub Form_Load()
    ' WithEvents objects can't be auto-instancing.
    Set Fop = New CFileOp
End Sub

Private Sub cmdParse_Click()
    Dim file As Variant
    InitFOP
    lstFiles.Clear
    For Each file In Fop.Filenames
        lstFiles.AddItem file
    Next
    picStatus.Cls
    picStatus.Print &quot;Found &quot; &amp; Fop.Filenames.count &amp; &quot; files.&quot;;
End Sub

Private Sub cmdCopy_Click()
    InitFOP
    Fop.Copy txtDestPath.Text
End Sub

' A useful routine shared by many procedures in the form
Private Sub InitFOP()
    Fop.FileSpec = txtFilespec
    Fop.Attributes = IIf(chkHidden, vbHidden, 0) + _
        IIf(chkSystem, vbSystem, 0)
End Sub

' Trapping events from CFileOp class
Private Sub Fop_FileCopyComplete(File As String, DestPath As String)
    picStatus.Cls
    picStatus.Print &quot;Copied file &quot; &amp; File &amp; &quot; ==&gt; &quot; &amp; DestPath;
End Sub
</pre>
</td></tr>
</table></p>

<p>To get a taste of how events actually work, there's nothing that beats a trace session. Set some breakpoints, type some reasonable paths for the source and destination, click on the Parse or Copy button (be careful not to overwrite the files you need!), and press F8 to see the code come alive before your eyes.</p>

<A NAME="278"><h2>Improving the Sample Application</h2></A>
<p>In its simplicity, the CFileOp class module is a good piece of code that can be extensively improved with the addition of many new features. What's more important from our standpoint is that most of these additions demonstrate compelling new techniques you can implement with events.</p>

<A NAME="279"><h3>Filtering input data</h3></A>
<p>In its first version, the CFileOp class simply parses the value assigned to the <I>FileSpec</I> property and builds the list of the files to be copied, taking into account the value of the <I>Attributes</I> property. Unfortunately, the client code has no way to filter out particular files, for example, temporary or backup files or files with specific names. Thanks to the flexibility offered by events, however, you can add this capability in just a matter of seconds. You only have to add a new event declaration to the class:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the declaration section of the CFileOp class module
Event Parsing(file As String, Cancel As Boolean)
</pre>
</td></tr>
</table></p>

<p>and add a few lines (shown here in boldface) inside the <I>ParseFileSpec</I> routine:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>        ' ... inside the ParseFileSpec routine
<B>        Dim Cancel As Boolean</B>
        Do While Len(file)
<B>            Cancel = False
            RaiseEvent Parsing(file, Cancel)
            If Not Cancel Then </B>
                m_Filenames.Add MakeFilename(Path, file)
<B>            End If</B>
            file = Dir$
        Loop
</pre>
</td></tr>
</table></p>

<p>Taking advantage of the new event in the client code is even easier. Let's say that you want to exclude temporary files from the copy process. All you have to do is trap the <I>Parsing </I>event and set its <I>Cancel </I>parameter to True when the class is about to copy a file you aren't interested in, as this code demonstrates:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the client form module
Private Sub Fop_Parsing(file As String, Cancel As Boolean)
    Dim ext As String
    ' GetExtension is a handy method exposed by CFileOp.
    ext = LCase$(Fop.GetExtension(file))
    If ext = &quot;tmp&quot; Or ext = &quot;$$$&quot; Or ext = &quot;bak&quot; Then Cancel = True
End Sub
</pre>
</td></tr>
</table></p>

<p><div class="sidebar"><blockquote>
<b>Handling Multiple File Specifications</b>

<p>This doesn't have to do with events, but I just want to demonstrate how a carefully designed structure of your class module can simplify your work when you want to extend its features. Because the class exposes the <I>ParseFileSpec</I> routine as a Public method, nothing prevents the client code from calling it directly&#8212;instead of indirectly through the <I>FileSpec</I> property&#8212;to add unrelated filenames, with or without wildcards:</p>

<p><table><tr><td>
<pre>' Prepare to copy EXE files, using the standard FileSpec property.
Fop.FileSpec = &quot;C:\Windows\*.exe&quot;
' But also copy all executable files from another directory.
Fop.ParseFileSpec &quot;C:\Windows\System\*.Exe&quot;, vbHidden
Fop.ParseFileSpec &quot;C:\Windows\System\*.Com&quot;, vbHidden
</pre>
</td></tr>
</table></p>

<p>The great advantage of this approach is that the <I>CFileOp</I> class module will always raise a <I>Parsing</I> event in your client code, which has, therefore, an opportunity to filter out filenames, regardless of how they were added to the internal list. Another example of flexible design is offered by the ability to have the <I>ParseFileSpec</I> routine search for multiple file specifications. The routine doesn't directly depend on module-level variables, so you can easily add a few lines (shown here in boldface) to turn it into a powerful recursive routine:</p>

<p><table><tr><td>
<pre>        ' Create the internal Collection if necessary.
        If m_Filenames Is Nothing Then Set m_Filenames = New Collection
<B>        ' Support for semicolon delimited multiple file specifications
        Dim MultiSpecs() As String, i As Integer
        If InStr(FileSpec, &quot;;&quot;) Then
            MultiSpecs = Split(FileSpec, &quot;;&quot;)
            For i = LBound(MultiSpecs) To UBound(MultiSpecs)
                ' Recursive call to this routine
                ParseFileSpec MultiSpecs(i)
            Next
            Exit Sub
        End If</B>
        Path = GetPath(FileSpec)
        ' And so on....
</pre>
</td></tr>
</table></p>

<p>Because the <I>FileSpec</I> property internally uses the <I>ParseFileSpec</I> routine, it automatically inherits the ability to accept multiple semicolon-delimited file specifications. The class module provided on the companion CD is based on this technique.</p>
</blockquote></div></p>

<A NAME="280"><h3>Prenotification events</h3></A>
<p>So far, you have seen that the <I>FileCopyComplete</I> event is raised immediately after the copy operation because it's intended to give the client code a clue that something has occurred inside the class module. A more flexible class would envision the capability for the client to intervene even <I>before </I>the operation takes place. In other words, what you need is a <I>WillCopyFile</I> event:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Enum ActionConstants
    foContinue = 1
    foSkip
    foAbort
End Enum
Event WillCopyFile(file As String, DestPath As String, _
    Action As ActionConstants)
</pre>
</td></tr>
</table></p>

<p>I could have used a standard Boolean <I>Cancel</I> argument, but an enumerated value adds a lot of flexibility. You raise a <I>WillCopyFile</I> event in the <I>Copy</I> method, just before doing the actual copy. Here's the revised procedure, with added or modified statements showed in boldface:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub Copy(DestPath As String)
    Dim var As Variant, file As String, dest As String
<B>    Dim Action As ActionConstants</B>
    On Error Resume Next
    For Each var In Filenames
        file = var
        dest = MakeFilename(DestPath, GetFileName(file))
<B>        Action = foContinue
        RaiseEvent WillCopyFile(file, dest, Action)
        If Action = foAbort Then Exit Sub
        If Action = foContinue Then</B>
            FileCopy file, dest
            If Err = 0 Then
                <B>RaiseEvent FileCopyComplete(file, GetPath(dest))</B>
            Else
                Err.Clear
            End If
<B>        End If</B>
    Next
End Sub
</pre>
</td></tr>
</table></p>

<p>To take advantage of this new event, the client form module has been enriched with a Confirm CheckBox control that, if selected, gives the user control over the copy process. Thanks to the <I>WillCopyFile</I> event, you can implement this new feature with just a handful of statements:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Fop_WillCopyFile(File As String, DestPath As String, _
    Action As ActionConstants)
    ' Exit if user isn't interested in file-by-file confirmation.
    If chkConfirm = vbUnchecked Then Exit Sub
    Dim ok As Integer
    ok = MsgBox(&quot;Copying file &quot; &amp; File &amp; &quot; to &quot; &amp; DestPath &amp; vbCr _
        &amp; &quot;Click YES to proceed, NO to skip, CANCEL to abort&quot;, _
        vbYesNoCancel + vbInformation)
    Select Case ok
        Case vbYes: Action = foContinue
        Case vbNo: Action = foSkip
        Case vbCancel: Action = foAbort
    End Select
End Sub
</pre>
</td></tr>
</table></p>

<p>You can use the mechanism of prenotification events to much greater effect than just as a means for allowing or preventing the completion of a given process. In fact, a significant point of these types of events is that most or all their arguments are passed by reference and can therefore be altered by the caller. This is similar to what you usually do with the <I>KeyAscii</I> argument passed to the <I>KeyPress</I> event procedure of a standard control. For example, you might decide that all BAK files should be copied to a different directory:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>        ' Inside the WillCopyFile event procedure (in the client)...
        If LCase$(Fop.GetExtension(file)) = &quot;bak&quot; Then
            DestPath = &quot;C:\Backup&quot;
        End If
</pre>
</td></tr>
</table></p>

<A NAME="281"><h3>Notifying clients of error conditions</h3></A>
<p>In most cases, the best means for a class to return an error to the client is by using the standard <I>Err.Raise</I> method. This allows the client to get a definitive confirmation that something went wrong and that appropriate steps must be taken. However, when a class communicates with its clients through events, you can explore a few alternatives to the <I>Err.Raise</I> method. For example, if the CFileOp class isn't able to copy a particular file, should the entire copy process be terminated? Needless to say, only the client code knows the answer, so the right thing to do is to ask it&#8212;by means of an event, of course:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Event Error(OpName As String, File As String, File2 As String, _
    ErrCode As Integer, ErrMessage As String, Action As ActionConstants)
</pre>
</td></tr>
</table></p>

<p>You see that I've added a generic <I>OpName </I>argument so that the same <I>Error</I> event can be shared by all the methods in the class module. Adding support for this new event in the <I>Copy</I> method requires little effort:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Inside the Copy method in the CFileOp class module...
FileCopy File, dest
If Err = 0 Then
    RaiseEvent FileCopyComplete(File, DestPath)
Else
<B>    Dim ErrCode As Integer, ErrMessage As String
    ErrCode = Err.Number: ErrMessage = Err.Description
    RaiseEvent Error(&quot;Copy&quot;, File, DestPath, ErrCode, _
        ErrMessage, Action)
    ' Report the error to the client if user aborted the process.
    If Action = foAbort Then
        ' You need to cancel error handling, otherwise the Err.Raise
        ' method won't return the control to the client.
        On Error GoTo 0           
        Err.Raise ErrCode, , ErrMessage
    End If</B>
Err.Clear
End If
</pre>
</td></tr>
</table></p>

<p>The client now has the ability to trap errors and decide what to do with them. For example, an &quot;Error 76 - Path not found&quot; means that either the source or the destination isn't valid, so there isn't any point in continuing the operation:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Fop_Error(OpName As String, File As String, File2 As String, _
    ErrCode As Integer, ErrMessage As String, Action As ActionConstants)
    If ErrCode = 76 Then
        MsgBox ErrMessage, vbCritical
        Action = foAbort
    End If
End Sub
</pre>
</td></tr>
</table></p>

<p>This code doesn't test the <I>OpName</I> argument: This is an intentional omission because the same code can manage errors raised by all methods in the class. Also note that the class passes both <I>ErrCode</I> and <I>ErrMessage</I> by reference, and the client can, for example, modify them at will:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>    ' Use a custom error scheme for this client.
    If OpName = &quot;Copy&quot; Then 
        ErrCode = ErrCode + 1000: ErrMessage = &quot;Unable to Copy&quot;
    ElseIf OpName = &quot;Move&quot; Then
        ErrCode = ErrCode + 2000: ErrMessage = &quot;Unable to Move&quot;
    End If
    Action = foAbort
</pre>
</td></tr>
</table></p>

<A NAME="282"><h3>Notifying clients of progress</h3></A>
<p>The task of notifying the user about the progress of a process is among the most common uses for events. In a sense, each prenotification and postnotification event can be considered a signal that the process is active, so it could seem that a separate <I>Progress</I> event is superfluous. But you can offer your clients better service if you also expose an event that clients can use to inform the user about the progress of a task, for example using a progress bar that shows the percentage of the job accomplished. The trick is to raise this event only when the actual percentage changes so that you don't force the client to continuously update the user interface without any real reason to do so:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Event ProgressPercent(Percent As Integer)
</pre>
</td></tr>
</table></p>

<p>After writing some classes that expose the <I>ProgressPercent</I> event, you realize that you can put most of the logic for this event in a generic procedure, which can be reused in all your class modules:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub CheckProgressPercent(Optional NewValue As Variant, _
    Optional MaxValue As Variant)
    Static Value As Variant, Limit As Variant
    Static LastPercent As Integer
    Dim CurrValue As Variant, CurrPercent As Integer
    If Not IsMissing(MaxValue) Then
        Limit = MaxValue
        If IsMissing(NewValue) Then Err.Raise 9998, , _
            &quot;NewValue can't be omitted in the first call&quot;
        Value = NewValue
    Else
        If IsEmpty(Limit) Then Err.Raise 9999, , &quot;Not initialized!&quot;
        Value = Value + IIf(IsMissing(NewValue), 1, NewValue)
    End If
    CurrPercent = (Value * 100) \ Limit
    If CurrPercent &lt;&gt; LastPercent Or Not IsMissing(MaxValue) Then
        LastPercent = CurrPercent
        RaiseEvent ProgressPercent(CurrPercent)
    End If
End Sub
</pre>
</td></tr>
</table></p>


<p>The structure of the <I>CheckProgressPercent 
</I>routine is somewhat contorted because it has to account for many possible default values of its 
arguments. You can call it with two, one, or no arguments. You call it with two arguments when you want to reset 
its internal counters <I>Value </I>and 
<I>Limit</I>. You call it with just one argument when you 
simply want to increment <I>Value</I>. Finally, you call it with no arguments when you 
increment <I>Value </I>by 1 (a case so common that it deserves a courtesy treatment). This 
flexible scheme simplifies how the routine is invoked by the methods in the class, and in 
most cases you just need two statements to fire the 
<I>Progress</I> event at the right time:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the Copy method 
On Error Resume Next
<B>CheckProgressPercent 0, Filenames.Count     ' Reset internal counters.</B>
For Each var In Filenames
<B>    CheckProgressPercent                    ' Increment by 1.
    </B>File = var
    ...
</pre>
</td></tr>
</table></p>


<p>The <I>CheckProgressPercent</I> routine is optimized and raises a 
<I>ProgressPercent</I> event only when the percentage actually changes. This allows you to write code 
in the client without worrying about tracing the changes yourself:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Fop_ProgressPercent(Percent As Integer)
    ShowProgress picStatus, Percent
End Sub

' A reusable routine that prints to a generic PictureBox
Private Sub ShowProgress(pic As PictureBox, Percent As Integer, _
    Optional Color As Long = vbBlue)
    pic.Cls
    pic.Line (0, 0)-(pic.ScaleWidth * Percent / 100, _
        pic.ScaleHeight), Color, BF
    pic.CurrentX = (pic.ScaleWidth - pic.TextWidth(CStr(Percent) _
        &amp; &quot; %&quot;)) / 2
    pic.CurrentY = (pic.ScaleHeight - pic.TextHeight(&quot;%&quot;)) / 2
    pic.Print CStr(Percent) &amp; &quot; %&quot;;
End Sub
</pre>
</td></tr>
</table></p>

<p>The CFileOp class that you'll find on the companion CD includes many other improvements, such as the support for <I>Move </I>and <I>Delete </I>commands, and the inclusion of a <I>Parsing </I>event that lets the client filter out specific files during the parsing process. (See Figure 7-3.)</p>

<p>
<A HREF="javascript:fullSize('F07ph03x.htm')"> <img src="images/F07ph03.JPG" width=404 height=296 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 7-3.</B> <i>This version of the CFileOp demonstration program supports multiple filespecs, wildcards, additional file commands, a progress bar with a percentage indicator, and full control of individual file operations.</i><!--/caption-->
</p>

<A NAME="283"><h2>Multicasting</h2></A>
<p>Now that I have shown you several ways to exploit events in your own classes in hopes of piquing your interest, I admit that I've reserved the best news for the grand finale (of this section about events, at least). In fact, what I've purposefully left out is that the event mechanism on which <I>WithEvents</I> is based is compatible with COM and with all the events raised by Visual Basic's own forms and controls.</p>

<p>This mechanism is also known as <I>event multicasting</I>. This term means that an object can raise events in all the client modules containing a <I>WithEvents</I> variable that points to that object. This might seem to be a negligible detail until you see how far-reaching its consequences are.</p>

<p>As you all know, a form module is always able to trap events from its own controls. Before multicasting, trapping controls' events in the parent form's module was the best thing a programmer could do. Well, it probably is <I>still </I>the best thing that you can do with events, but surely it isn't the only one. In fact, you can declare an explicit object variable, let it point to a particular control, and use it to trap that control's events. The multicasting mechanism ensures that the variable receives the event notification <I>wherever it is declared</I>! This means that you can move the variable to another module in the program (or to another form, or class, or actually anything but a standard BAS module) and still react to all the events raised by the control.</p>

<A NAME="284"><h3>A class for validating TextBox controls</h3></A>
<p>Let's see what this means to us, mere Visual Basic programmers. To show multicasting in action, you just need a very simple CTextBxN class module, whose only purpose is to reject any nondigit keys from a TextBox control:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Public WithEvents TextBox As TextBox

Private Sub TextBox_KeyPress(KeyAscii As Integer)
    Select Case KeyAscii
        Case 0 To 31                   ' Accept control chars.
        Case 48 To 57                  ' Accept digits.
        Case Else
            KeyAscii = 0               ' Reject anything else.
    End Select
End Sub
</pre>
</td></tr>
</table></p>


<p>To test drive this class, create a form, place a TextBox control on it, and add this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim Amount As CTextBxN
Private Sub Form_Load()
    Set Amount = New CTextBxN
    Set Amount.TextBox = Text1
End Sub
</pre>
</td></tr>
</table></p>


<p>Run the program, and try to type a nondigit key in Text1. After a few attempts, you'll realize that the CTextBxN class is trapping all the <I>KeyPress</I> events raised from Text1 and processing the validation code on behalf of the Form1 module. Seems interesting, eh? The real power of this technique becomes apparent when you have other numerical fields on your form, for example, a new Text2 control that holds a percentage value:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim Amount As CTextBxN<B>, Percentage As CTextBxN</B>
Private Sub Form_Load()
    Set Amount = New CTextBxN
    Set Amount.TextBox = Text1
<B>    Set Percentage = New CTextBxN
    Set Percentage.TextBox = Text2</B>
End Sub
</pre>
</td></tr>
</table></p>

<p>Instead of creating distinct event procedures in the parent form module, each one validating the keys going to a distinct TextBox control, you've encapsulated the validation logic in the CTextBxN class once, and you're now reusing it over and over again. And you can do it for all the fields in Form1, as well as for any number of fields in any form of your application (not to mention all the future applications that you'll write from now on). This is <I>reusable </I>code!</p>

<A NAME="285"><h3>Improving the CTextBxN class</h3></A>
<p>The benefits of multicasting shouldn't make you forget that CTextBxN is a regular class module, which can be improved with properties and methods. Just as an example, let's add three new properties that make the class more useful: <I>IsDecimal</I> is a Boolean property that, if True, allows decimal values; <I>FormatMask</I> is a string used to format the number when the focus leaves the control; and <I>SelectOnEntry</I> is a Boolean property that states whether the current value should be highlighted when the control gets the focus. Here's the new version of the class:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Public WithEvents TextBox As TextBox
<B>Public IsDecimal As Boolean
Public FormatMask As String
Public SelectOnEntry As Boolean</B>

Private Sub TextBox_KeyPress(KeyAscii As Integer)
    Select Case KeyAscii
        Case 0 To 31                   ' Accept control chars.
        Case 48 To 57                  ' Accept digits.
<B>        Case Asc(Format$(0.1, &quot;.&quot;))    ' Accept the Decimal separator.
            If Not IsDecimal Then KeyAscii = 0</B>
        Case Else
            KeyAscii = 0               ' Reject anything else.
    End Select
End Sub

<B>Private Sub TextBox_GotFocus()
    TextBox.Text = FilterNumber(TextBox.Text, True)
    If SelectOnEntry Then 
        TextBox.SelStart = 0
        TextBox.SelLength = Len(TextBox.Text)
    End If
End Sub

Private Sub TextBox_LostFocus()
    If Len(FormatMask) Then 
        TextBox.Text = Format$(TextBox.Text, FormatMask)
    End If
End Sub</B>
' Code for FilterNumber is omitted. (See <a href="ch03a.htm">Chapter 3</a>.)
</pre>
</td></tr>
</table></p>

<p>Using the new properties is a pleasure. Just set them in the <I>Form_Load</I> procedure and then enjoy your smarter TextBox controls:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the Form_Load event procedure
Amount.FormatMask = &quot;#,###,###&quot;
Amount.SelectOnEntry = True
Percentage.FormatMask = &quot;0.00&quot;
Percentage.IsDecimal = True
Percentage.SelectOnEntry = True
</pre>
</td></tr>
</table></p>

<A NAME="286"><h3>Send custom events to the container</h3></A>
<p>Because CTextBxN is a regular class module, it can even declare and raise its own custom events. This ability is really interesting: The class &quot;steals&quot; controls' events from the original form but then sends the form other events. This permits a degree of sophistication that couldn't be possible otherwise. To demonstrate this concept in action, I'll show you how to add to the class full support for validation against <I>Min</I> and <I>Max</I> properties. In a regular program, validation is performed in the <I>Validate</I> event on the parent form. (See <a href="ch03a.htm">Chapter 3</a>.) But now you can trap that event and preprocess it against your new custom properties:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the CTextsBxN class module
Event ValidateError(Cancel As Boolean)
Public Min As Variant, Max As Variant

Private Sub TextBox_Validate(Cancel As Boolean)
    If Not IsEmpty(Min) Then
        If CDbl(TextBox.Text) &lt; Min Then RaiseEvent ValidateError(Cancel)
    End If
    If Not IsEmpty(Max) Then
        If CDbl(TextBox.Text) &gt; Max Then RaiseEvent ValidateError(Cancel)
    End If
End Sub
</pre>
</td></tr>
</table></p>

<p>If the class detects a potential out-of-range error, it just raises a <I>ValidationError</I> in the original form, passing the <I>Cancel</I> argument by reference. In the client form module, you can therefore decide whether you actually want to abort the shift focus, exactly as you would do under normal circumstances:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Now Percentage must be declared using WithEvents.
Dim <B>WithEvents </B>Percentage As CTextBxN
Private Sub Form_Load()
    ' ...
    <B>Percentage.Min = 0
    Percentage.Max = 100</B>
End Sub
' ...
<B>Private Sub Percentage_ValidateError(Cancel As Boolean)
    MsgBox &quot;Invalid Percentage Value&quot;, vbExclamation
    Cancel = True
End Sub</B>
</pre>
</td></tr>
</table></p>

<p>Alternatively, you could set <I>Cancel </I>to True in the class module and give the client code an opportunity to reset it to False. These are just details. The important point is that you're now in complete control of what happens inside the control, and you're doing that with a minimum amount of code on the form itself because most of the logic is encapsulated in the class module.</p>

<A NAME="287"><h3>Trapping events from multiple controls</h3></A>
<p>Now that you know how you can have a class module trap events from a control, you can extend the technique to multiple controls as well. For example, you can trap events from a TextBox control and a tiny ScrollBar control beside it to simulate those fancy spin buttons that are so trendy in many Windows applications. Or you can rework the scrollable form example in <a href="ch03a.htm">Chapter 3</a> and build a CScrollForm class module that traps events from a form and its two companion scroll bars. Instead of rehashing such simple tasks, I prefer to focus on something new and more interesting. In the following example, I'll show you how easily you can create <I>calculated fields</I> using multicasting. This example is a bit more complex, but I'm sure that in the end you'll be glad to have spent some time on it.</p>

<p>The CTextBoxCalc class module I built is able to trap the <I>Change</I> event from up to five distinct TextBox controls (the <I>independent </I>fields) and use this capability to update the contents of another Textbox on the form (the <I>dependent </I>field) without any intervention from the main program. To create a generic calculated field, I needed to devise a way for the client code to specify the expression that must be reevaluated each time one of the independent controls raises a <I>Change</I> event. To this end, the class exposes a <I>SetExpression </I>method that accepts an array of parameters. Each parameter can be a reference to a control, a number, or a string that represents one of the four math operators. Look, for example, at the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Example of client code that uses the CTextBoxCalc class
' txtTax and txtGrandTotal depend on txtAmount and txtPercent.
Dim Tax As New CTextBoxCalc, GrandTotal As New CTextBoxCalc
' Link the class to the control on which the result is to be displayed.
Set Tax.TextBox = txtTax
' Set the expression &quot;Amount * Percent / 100&quot;.
Tax.SetExpression txtAmount, &quot;*&quot;, txtPercent, &quot;/&quot;, 100
' Create a GrandTotal calculated field, equal to &quot;Amount + Tax&quot;.
Set GrandTotal.TextBox = txtGrandTotal
GrandTotal.SetExpression txtAmount, &quot;+&quot;, txtTax
</pre>
</td></tr>
</table></p>

<p>The intricacy of the CTextBoxCalc class derives mostly from the need to parse the arguments passed to the <I>SetExpression</I> method. I kept this intricacy to a minimum and renounced sophisticated features such as allowing different priorities among operators, bracketed subexpressions, and functions. This leaves the four math operators, which are evaluated in a strict left-to-right order. (For example, &quot;2+3*4&quot; evaluates to 20 instead of 14.) On the other hand, the complete class module has just 80 lines of code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The complete source code for CTextBoxCalc class
Public TextBox As TextBox
Public FormatMask As String
' We can trap events from max 5 TextBox controls.
Private WithEvents Text1 As TextBox
Private WithEvents Text2 As TextBox
Private WithEvents Text3 As TextBox
Private WithEvents Text4 As TextBox
Private WithEvents Text5 As TextBox
' Here we store the arguments passed to SetExpression.
Dim expression() As Variant

Sub SetExpression(ParamArray args() As Variant)
    Dim i As Integer, n As Integer
    ReDim expression(LBound(args) To UBound(args)) As Variant
    For i = LBound(args) To UBound(args)
        If IsObject(args(i)) Then
            ' Objects must be stored as such, using Set.
            Set expression(i) = args(i)
            If TypeName(args(i)) = &quot;TextBox&quot; Then
                n = n + 1
                If n = 1 Then Set Text1 = args(i)
                If n = 2 Then Set Text2 = args(i)
                If n = 3 Then Set Text3 = args(i)
                If n = 4 Then Set Text4 = args(i)
                If n = 5 Then Set Text5 = args(i)
            End If
        Else
            ' Store number and strings without the Set keyword.
            expression(i) = args(i)
        End If
    Next
End Sub

' Here we actually evaluate the result.
Sub EvalExpression()
    Dim i As Integer, opcode As Variant
    Dim value As Variant, operand As Variant
    On Error GoTo Error_Handler
    For i = LBound(expression) To UBound(expression)
        If Not IsObject(expression(i)) And VarType(expression(i)) _
            = vbString Then
                opcode = expression(i)
        Else
            ' This works with numbers and Text (default) properties alike.
            operand = CDbl(expression(i))
            Select Case opcode
                Case Empty: value = operand
                Case &quot;+&quot;: value = value + operand
                Case &quot;-&quot;: value = value - operand
                Case &quot;*&quot;: value = value * operand
                Case &quot;/&quot;: value = value / operand
            End Select
            opcode = Empty
        End If
    Next
    If Len(FormatMask) Then value = Format$(value, FormatMask)
    TextBox.Text = value
    Exit Sub
Error_Handler:
    TextBox.Text = &quot;&quot;
End Sub

' Here we trap events from the independent fields.
Private Sub Text1_Change()
    EvalExpression
End Sub
' ... Text2-Text5 Change procedures .... (omitted)
</pre>
</td></tr>
</table></p>

<p>The class can trap events from a maximum of five TextBox independent controls, but the expression could refer to just one or two of them. This is OK: If a <I>WithEvents</I> variable isn't assigned and remains Nothing, it simply stays inert and never raises events in the class. It isn't useful but doesn't do any harm either.</p>

<p>To get an idea of the potential of this class, run the demonstration program on the companion CD and see how you can grow a spreadsheet-like form that accepts data in a couple of fields and automatically updates the other two fields. (See Figure 7-4 for an example of how that might work.) The same application demonstrates both the CTextBxN and the CTextBoxCalc classes.</p>

<p>
<img src="images/F07ph04x.gif" width=409 height=276 border=0>
</p><p>
<!--caption--><B>Figure 7-4.</B> <i>You can create smart forms that contain live calculated fields by using reusable external class modules exclusively.</i><!--/caption-->
</p>

<A NAME="288"><h3>The pitfalls of multicasting</h3></A>
<p>Exploiting the event multicasting features in your application is among the best favors you can do yourself. Before you get too carried away, though, you should be aware that there are a few problems with this technique.</p>

<UL>
<p><li>The <I>WithEvents</I> keyword doesn't work with arrays of object variables. This makes it difficult to create extremely generic routines. For example, in the CTextBoxCalc class we had to set a limit of five external TextBox controls&#8212;the variables <I>Text1 </I>through <I>Text5 </I>in the class&#8212;because it wasn't possible to create an array of objects. This problem has a solution, but it isn't simple and you won't see it until the &quot;Data-Driven Form&quot; section in <a href="ch09a.htm">Chapter 9</a>.</li></p>

<p><li>You have absolutely no control over the order in which events are dispatched to <I>WithEvents</I> variables. In general, you should avoid having the same event served in two distinct places in your code&#8212;for example, a <I>KeyPress </I>event for a control trapped both in the form and in an external class. If you can't avoid it, at least ensure that your code will work in whatever order the events arrive. (This order is random, so one or two attempts won't be enough to prove the correctness of your approach.)</li></p>

<p><li>There's an undocumented bug in how Visual Basic implements the <I>WithEvents </I>keyword: you can't use <I>WithEvents</I> with controls that belong to a control array:</li></p>
 
<p><table width="95%" cellpadding="5"><tr><td>
<PRE>
Dim WithEvents TextBox As TextBox
Private Sub Form_Load()
    ' Raises a Type Mismatch run-time error.
    Set TextBox = Text1(0)
End Sub
</PRE>
</td></tr></table></p>

<p>This bug prevents you from dynamically creating a new control from a control array and then trapping its events using multicasting. Unfortunately, there isn't any known solution to this problem. Curiously, this bug doesn't manifest itself if the control you're assigning to a <I>WithEvents</I> variable is an ActiveX control authored in Visual Basic.</p>
</ul>

</BODY>
</HTML>





