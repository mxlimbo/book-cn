<HTML>
<HEAD>
<TITLE>Procedures</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04d.htm", "ch05a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="146"><h1>Procedures</h1></A>
<p>Visual Basic modules are made of a declaration section&#8212;in which you declare 
types, constants, and variables used in the module&#8212;plus a collection of procedures. 
These can be of type Sub or Function, depending on whether they return a value to the 
caller. They can also be Property procedures, but we won't discuss those until <a href="ch06a.htm">Chapter 6</a>. Each procedure has a unique name, a scope, a list of expected arguments, 
and&#8212;if it's a function&#8212;a return value.
</p>

<A NAME="147"><h2>Scope</h2></A>
<p>The scope of a procedure can be Private, Public, or Friend. A 
Private procedure can be invoked only from within the module in which it's defined. A 
Public procedure can be invoked from outside the module. If the module is itself Public (a module 
whose <I>Instancing</I> property isn't 1-Private, contained in a project whose type isn't 
Standard EXE), the procedure can be called from outside the current program through 
COM. Since Public is the default scope attribute for procedures, you can always omit it:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Public function that provides access to a control on a form.
Function GetTotal() As Currency
    GetTotal = CCur(txtTotal.Text)
End Function
</pre>
</td></tr>
</table></p>

<p>If the scope isn't Public, you must specify it explicitly:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' All event procedures are Private. 
Private Sub Form_Load()
    txtTotal.Text = &quot;&quot;
End Sub
</pre>
</td></tr>
</table></p>

<p>The scope of a Friend procedure is halfway between Private and Public: 
Such a procedure can be called from anywhere in the current project, but not from 
outside it. This difference becomes important only if you're within a project of a type 
other than Standard EXE, one that therefore exposes its classes to other applications in 
the form of COM components. I'll talk about COM components in depth in <a href="ch16a.htm">Chapter 16</a>, but here we need to anticipate some key concepts.
</p>

<p>To understand how a Friend procedure can be useful, imagine the 
following scenario: You have a Public class module that shows a dialog box and asks the 
user for his or her name and password. It also exposes a 
<I>GetPassword</I> function so that another module in the project can validate the password and enable or disable 
specific functions for that particular user. Should you declare this function as Private? 
No, because it could be invoked from another module. Should the function 
be Public? No, because that would enable a malicious programmer to query your class 
module from outside the project and steal users' passwords. (For the sake of simplicity, 
let's assume that getting a reference to your class isn't a problem.) In this case, the 
best choice is to make the function a Friend.</p>

<p>
<A HREF="javascript:fullSize('G04ph03x.htm')"> <img src="images/G04ph03.JPG" width=404 height=305 border=0 ALT = "Click to view at full size."> </A>
</p>

<p>If you're within a Standard EXE project, or within a Private class in any type 
of project, Friend and Public attributes are equivalent because the procedure can't 
be called from the outside anyway.
</p>

<A NAME="148"><h2>Parameter Lists and Return Values</h2></A>
<p>Both Sub and Function procedures can accept arguments. Functions also return 
a value. Setting a reasonable list of expected parameters and a return value is the 
key to making your procedure more useful. You can pass a procedure any simple 
data type supported by Visual Basic, including Integer, Boolean, Long, Byte, Single, 
Double, Currency, Date, String, and Variant. You can also declare your parameter an 
Object, a Collection, a class defined in your program, or external to it (for example, a 
Dictionary object). Finally you can pass an array of any of the previously mentioned 
types. The same is true for the return type too, which can be of any simple type 
supported by Visual Basic, including arrays&#8212;a new Visual Basic 6 feature.
</p>

<p>You should be aware that an <I>argument </I>is the value passed to a 
procedure, whereas a <I>parameter </I>is the value received by it. Both words refer to the same 
actual value, and the most appropriate term depends on the direction from which 
you're looking at the value: the caller code sees arguments, and the called procedure 
sees parameters. In this section, the words <I>argument 
</I>and <I>parameter </I>are used somewhat interchangeably except where ambiguity would arise.
</p>

<A NAME="149"><h3>Passing by value or by reference</h3></A>
<p>An argument can be passed by value (using the 
<I>ByVal</I> keyword) or by reference 
(using the <I>ByRef</I> keyword or by omitting any qualifier). Arguments passed by reference 
can be modified by the called procedure, and the modified value can be read back 
by the caller. Conversely, changes to arguments passed by value are never 
propagated back to the caller. The rule you should stick to 
is<I> always pass by reference</I> <I>those arguments that must be modified by the procedure, and pass by value all 
the</I> <I>others.</I> This approach minimizes the risk of accidentally modifying the value of a 
variable passed to the method. Let me explain this concept with an example:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Z is incorrectly declared ByRef.
Sub DrawPoint(ByVal X As Long, ByVal Y As Long, Z As Long)
    ' Keep arguments positive.
    If X &lt; 0 Then X = 0
    If Y &lt; 0 Then Y = 0
    If Z &lt; 0 Then Z = 0      ' Probable cause of bugs !!!
    ' ...
End Sub
</pre>
</td></tr>
</table></p>

<p>This procedure modifies its parameters to make them fit their valid range; if 
a parameter is passed using <I>ByRef</I>, as Z is in the previous example, these changes 
are propagated to the calling code. This type of bug can be undetected for some 
time, especially if in most cases you call the procedure using constants or expressions. 
The fact that your code works in these situations can convince you that the procedure 
is correct and lull you into a false sense of security:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' This works. (Argument is a constant.)
DrawPoint 10, 20, 40           
' This works too. (Argument is an expression.)
DrawPoint x * 2, y * 2, z * 2  
' This works but modifies Z if it's negative.
DrawPoint x, y, z
</pre>
</td></tr>
</table></p>

<p>Declaring a parameter using <I>ByVal</I> offers another benefit: you can call the 
procedure passing a variable or an expression of any type and let Visual Basic do 
the data type conversion for you. Conversely, if a parameter is declared 
<I>ByRef</I> and you pass a variable, their types must match:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Assuming that x,y,z aren't Long variables 
' (for example, they are either Single or Double)
DrawPoint x, y, 100   ' This works, Visual Basic does the conversion.
DrawPoint x, y, z     ' This doesn't. (ByRef argument type mismatch.)
</pre>
</td></tr>
</table></p>

<p>There is one exception to the above rule, though: If a procedure exposes a 
<I>ByRef</I> Variant parameter, you can pass really anything to it. You  can exploit this feature 
to write procedures that aren't specific to a particular data type, as you can see in 
the code below.
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Swap values of any type.
Sub Swap(first As Variant, second As Variant)
    Dim temp As Variant
    temp = first: first = second: second = temp
End Sub
</pre>
</td></tr>
</table></p>

<p>There's another, subtler reason for using the 
<I>ByVal </I>keyword whenever possible. When a procedure can access the same memory location by means of two or 
more different names&#8212;for instance, a global variable or a module-level variable that's 
also passed as an argument&#8212;that variable is said to be 
<I>aliased </I>within that procedure. The problem with aliased variables is that they prevent the Visual Basic compiler 
from generating optimized code that holds variables' values inside CPU registers when 
it would otherwise be possible to do so. When all variables are passed to 
procedures and methods by value, it isn't possible for the routine to modify a global value 
through one of its parameters, and the compiler can produce better code. If you're sure 
that all the procedures in your program adhere to this restriction, the native 
compiler can safely optimize your code. To inform Visual Basic that there aren't any 
aliased variables in your program, open the Project-Properties dialog box, switch to the 
Compile tab, click on the Advanced Optimizations button, and tick the Assume No 
Aliasing check box in the dialog box that appears, as you can see in Figure 4-2.
</p>

<p>
<A HREF="javascript:fullSize('F04ph02x.htm')"> <img src="images/F04ph02.JPG" width=404 height=267 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 4-2.</B> <i>The Advanced Optimizations dialog box.</i><!--/caption-->
</p>

<A NAME="150"><h3>Passing user-defined types</h3></A>
<p>You might have noticed that I didn't mention UDT structures among the data 
types that can be passed to a procedure or returned from a function. In fact, you can't 
always pass such structures as an argument to a procedure. Consider these cases:
</p>

<UL>

<p><li> If a UDT structure is declared as Private to a module, it can be passed 
and returned only by Private procedures inside that module.
</li></p>

<p><li> If the UDT structure is defined as Public in a standard BAS module, it 
can be used as an argument for Private and Friend procedures defined in 
any type of module in the current project. It can also be used as an 
argument in Public procedures defined in any BAS module of the application, 
but not in other types of modules (including forms).
</li></p>


<p>
<img src="images/new.jpg" width=102 height=87 border="0">
</p>

<p><li> If you want to write a Public procedure that accepts a UDT argument 
in a module other than a BAS module, you must place a Public Type 
definition in a Public class module&#8212;that is, a module whose 
<I>Instancing</I> property is different from 1-Private. (You can't therefore place the 
declaration in form modules, because they are always Private.) Since you must 
define the UDT structure in a Public class, you can do that only within 
project types other than Standard EXE projects.
</li></p>
</ul>
 


<p>You can't even declare a Public UDT structure in a class module that isn't 
Public itself. This prevents you from declaring a Public UDT in a Standard EXE 
project in any modules except standard BAS modules.
</p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>If you're creating a Microsoft ActiveX EXE project, you should 
be aware that you can exchange UDT values across processes only if you 
have DCOM98 (on Windows 9x systems) or Service Pack 4 (on Windows NT 4.0 
systems). If you don't, when Visual Basic tries to pass a UDT value to another 
process an error 458 is raised (&quot;Variable uses an Automation Type not 
supported in Visual Basic&quot;). You need these operating system updates on both your 
own and your users' machines.

<p>Note that this isn't an issue when working with an ActiveX DLL 
project because it shares the same address space as its caller, so UDTs can be 
passed without the intervention of COM.
</p>
</blockquote></div>
</p>

<A NAME="151"><h3>Passing Private types</h3></A>
<p>There are restrictions when passing Private objects to a procedure, where a 
<I>private object</I> is defined in your application but not visible outside it. Private objects are 
those defined by classes whose <I>Instancing</I> property is set to 1-Private, or objects 
exposed by the Visual Basic library, including forms, controls, and objects such as App, 
Clipboard, Screen, and Printer. In general, you can neither include such private 
objects among the arguments of a procedure nor use them as the return value of a 
function if the procedure can be called from another application through COM. This 
restriction makes perfect sense. COM arbitrates the exchange of information between 
the application that provides the object and the programs that use it. COM is able to 
deal with all the basic data types supported by Visual Basic and with all the Public 
objects defined by any program in the Windows environment. On the other hand, 
COM is unable to pass information in a format that is defined within a program, such as 
a Private class, as you can see in the code snippet below.
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Visual Basic won't compile the following lines
' if this procedure is located in a Public class.
Public Sub ClearField(frm As Form) 
...
End Sub
</pre>
</td></tr>
</table></p>

<p>This restriction isn't enforced if the method is declared as Private or 
Friend because such a method can't be invoked from another application through COM 
and can be called only by another module of the current application. In this case, 
there's no point in limiting the data types that can be passed to the method, and in fact 
the Visual Basic compiler doesn't complain if a Private data type appears among 
the arguments or if it is the return value of a method.
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' This is compiled without problems, even within a Public class.
Friend Sub ClearField(frm As Form) 
...
End Sub
</pre>
</td></tr>
</table></p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
There's an easy workaround for the limitation on passing Private 
objects to a procedure, though. Just declare the argument or the return 
value using As Object or As Variant: in this case, the compiler can't know 
which object will be actually passed at run time and won't flag the line as an error. 
While this technique works, you should at least be aware that Microsoft strongly 
discourages it and has publicly stated that it might not work in future versions 
of the language. Forewarned is forearmed.
</blockquote></div>
</p>

<A NAME="152"><h3>The <I>Optional</I> keyword</h3></A>
<p>Visual Basic 4 introduced the ability to include optional parameters in the 
parameter list of procedures and methods. Optional parameters must always come after 
regular (required) parameters. Visual Basic 4 supports only optional parameters of 
Variant type and permits testing for whether a parameter is actually passed by means 
of the <I>IsMissing</I> function:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' A public method of a form.
Sub PrintData1(text As String, Optional color As Variant)
    If IsMissing(color) Then color = vbWhite
    ForeColor = color
    Print text
End Sub
</pre>
</td></tr>
</table></p>

<p>Be very careful when you use the 
<I>IsMissing</I> function because if you assign a value to a missing parameter, this function returns False from that point on. 
Study this code excerpt, and see why it doesn't work as expected:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub PrintData2(text As String, Optional color As Variant)
    Dim saveColor As Long
    If IsMissing(color) Then 
        Form1.FontTransparent = False
        color = vbWhite
    End If
    Form1.ForeColor = color
    Form1.Print text
    If IsMissing(color) Then 
        ' Next statement will be never executed!
        Form1.FontTransparent = False
    End If
End Sub
</pre>
</td></tr>
</table></p>

<p>Visual Basic 5 has added the ability to use optional arguments of any 
type&#8212;not just Variant&#8212;and to set their default values right in the parameter list. The 
<I>PrintData1</I> routine can be rewritten more concisely under Visual Basic 5 and 6 as follows:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub PrintData3(text As String, Optional color As Long = vbWhite)
    Form1.ForeColor = color
    Form1.Print text
End Sub
</pre>
</td></tr>
</table></p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>If an optional argument is of a type other than Variant, the 
<I>IsMissing</I> function always returns False. This behavior can cause many subtle errors, 
as in the following code:

<p><table><tr><td>
<pre>Sub PrintData4(text As String, Optional color As Long)
    If IsMissing(color) Then
        ' The next line will never be executed!
        Form1.FontTransparent = False
    End If
    ' ...
End Sub
</pre>
</td></tr></table>
</p>

</blockquote></div></p>

<p>When a non-Variant optional parameter isn't initialized to a specific default 
value in the parameter list, the procedure receives a zero value, an empty string, or 
Nothing, depending on the type of the parameter. The only data types that can't be 
used with the Optional keyword are UDT structures.
</p>

<p>Optional arguments are very handy for writing flexible procedures, but 
contrary to what some programmers believe, they don't produce more efficient code. 
The (wrong) assumption is: Since the calling code doesn't have to push the missing 
values on the stack, fewer CPU statements are executed and the program runs 
faster. Unfortunately, this isn't true. When an optional argument is omitted, Visual Basic 
actually pushes a special &quot;missing&quot; value on the stack. So there's no real speed 
advantage in omitting an optional argument.
</p>

<p>The &quot;missing&quot; magic value used by Visual Basic compiler is Error 
value &amp;H80020004. The <I>IsMissing</I> function does nothing but test the Variant and return 
True if it contains this value. Incidentally, this explains why the 
<I>IsMissing</I> function always returns False with any data type different from Variant: Only a Variant variable 
can hold an Error value. You can't directly create this special value because the 
<I>CVErr</I> function accepts only values in the range 0 through 65,535. But you can use the 
following trick:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Always call this function without any argument.
Function MissingValue(Optional DontPassThis As Variant) As Variant
    MissingValue = DontPassThis
End Function
</pre>
</td></tr>
</table></p>

<A NAME="153"><h3>Named arguments</h3></A>
<p>While Optional arguments are a great addition to the VBA language, they surely 
tend to reduce the readability of your code. Take this statement as an example:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Err.Raise 999, , , &quot;Value out range&quot;
</pre>
</td></tr>
</table></p>

<p>It appears as if the programmer is raising a custom error; unfortunately, 
there are too many commas, and the <I>Value out of 
range</I> string falls in the <I>HelpFile</I> 
field. How many developers can spot this kind of error just by browsing their source 
code? Fortunately, you can reduce this adverse effect of optional parameters by using 
named arguments when calling the procedure. Here's how you can correctly rewrite 
the previous statement:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Err.Raise Number:=999, Description:=&quot;Value out of range&quot;
</pre>
</td></tr>
</table></p>

<p>Named arguments let you alter the order in which arguments appear in the 
line that invokes the procedure, but they don't allow you to omit an argument that 
isn't optional. All the procedures that you create in Visual Basic automatically 
support named arguments. For instance, if you have the following routine:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub Init(Optional Name As String, Optional DeptID As Integer, _
    Optional Salary As Currency)
    ' ...
End Sub
</pre>
</td></tr>
</table></p>

<p>you can call it as follows:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Init Name:=&quot;Roscoe Powell&quot;, Salary:=80000
</pre>
</td></tr>
</table></p>

<A NAME="154"><h3>The <I>ParamArray</I> keyword</h3></A>
<p>You can implement a routine that accepts any number of arguments using 
the <I>ParamArray</I> keyword:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function Sum(ParamArray args() As Variant) As Double
    Dim i As Integer
    ' All ParamArrays are zero-based.
    For i = 0 To UBound(args)
        Sum = Sum + args(i)
    Next
End Function
</pre>
</td></tr>
</table></p>

<p>You call the <I>Sum</I> function as follows:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Print Sum(10, 30, 20)  ' Displays &quot;60&quot;
</pre>
</td></tr>
</table></p>

<p>A few simple rules dictate how the 
<I>ParamArray</I> keyword should be used:</p>

<UL>

<p><li> There can be only one <I>ParamArray</I> keyword, and it must be at the 
end of the parameter list.
</li></p>

<p><li> The array declared by the 
<I>ParamArray</I> keyword can only be of the Variant type.
</li></p>

<p><li> No <I>Optional</I> parameter can precede the 
<I>ParamArray</I> keyword.
</li></p>
</ul>
 


<p>The <I>ParamArray</I> keyword can be an invaluable aid in creating truly 
generic functions. For instance, you can build a function that returns the maximum of 
any number of values:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function Max(first As Variant, ParamArray args() As Variant) As Variant
    Dim i As Integer
    Max = first
    For i = 0 To UBound(args)
        If args(i) &gt; Max Then Max = args(i)
    Next
End Function
</pre>
</td></tr>
</table></p>

<p>Note that there's one required argument in the previous procedure because 
it doesn't make sense to evaluate the maximum of 0 values. Even though it isn't 
documented, you can use the <I>IsMissing</I> function on the 
<I>args() </I>parameter. Thus, you have two ways to exit the function if no optional values were passed to the routine:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The documented way
If LBound(args) &gt; UBound(args) Then Exit Function
' The undocumented way is more concise and readable
If IsMissing(args) Then Exit Function
</pre>
</td></tr>
</table></p>

<p>The <I>ParamArray</I> keyword can be coupled with the ability to return arrays. 
For example, while the <I>Array</I> function lets you build Variant arrays on the fly, VBA 
doesn't offer a similar function for building other 
types of arrays. Here's how you can remedy this problem:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function ArrayLong(ParamArray args() As Variant) As Long()
    Dim numEls As Long, i As Long
    numEls = UBound(args) _ LBound(args) + 1
    If numEls &lt;= 0 Then Err.Raise 5     ' Invalid procedure call
    ReDim result(0 To numEls - 1) As Long
    For i = 0 To numEls _ 1
        result(i) = args(i)
    Next
    ArrayLong = result
End Function
</pre>
</td></tr>
</table></p>

<p>One last note about the <I>ParamArray</I> keyword: If you want to get the best 
performances, stay clear of it. It forces you to use Variant parameters, which are 
the slowest data type supported by Visual Basic. If you need to use optional 
arguments, use non-Variant Optional parameters, which are much faster.
</p>

<A NAME="155"><h2>Error Handling</h2></A>
<p>Error handling is an important feature of the Visual Basic language and is closely 
related to the structure of your procedures. Visual Basic offers three statements 
that give you control over what happens when an error occurs during the execution 
of your code:</p>

<UL>

<p><li> The <I>On Error Resume Next</I> statement tells Visual Basic to ignore any 
error. When an error actually occurs, Visual Basic proceeds with 
executing the next statement. You can test the error code using the 
<I>Err</I> function, or you can ignore it completely.
</li></p>

<p><li> The <I>On Error Goto 
</I>&lt;<I>label</I>&gt;<B><I> </I></B>statement tells Visual Basic that any error 
will cause a jump to the named label, which must be located in the 
same procedure in which this statement appears. You can use the same 
label name in different procedures because a label's scope is the procedure, 
not the module.
</li></p>

<p><li> The <I>On Error Goto 0</I> statement tells Visual Basic to cancel the effect of 
any active <I>On Error Resume Next</I> or <I>On Error 
Goto</I> &lt;<I>label</I>&gt; statement. When an error occurs, Visual Basic behaves as if error trapping is disabled.
</li></p>
</ul>
 


<p>Selecting one form of error trapping or another depends on your 
programming style and the requirements of the specific routine, so no rule can be provided 
that's valid in every case. All the <I>On Error 
</I>statements clear the current error code.
</p>

<A NAME="156"><h3>The <I>On Error Goto &lt;label&gt; </I>statement</h3></A>
<p>When you're dealing with files, the <I>On Error 
Goto</I> &lt;<I>label</I>&gt; statement is often a 
better choice because in this case there are so many things that can go wrong, and you 
don't want to test the <I>Err</I> code after every statement. The same concept applies to 
intensive math routines that are subject to multiple errors, such as division by 0, 
overflow, and illegal arguments in function calls. In most cases, when an error occurs in 
these routines, the best you can do is exit right away and report the error to the calling code.
</p>

<p>On the other hand, there are many cases when the &quot;error&quot; isn't a fatal 
error. Suppose that you want your user to insert a given disk in drive A, but you want 
to give him or her another chance if the disk isn't the one you were expecting 
instead of aborting the whole procedure when the user inserts a wrong disk. Here's a 
reusable procedure that lets you check whether a drive contains a disk with a given 
label and prompts the user to insert a disk if the drive is empty:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function CheckDisk(ByVal Drive As String, VolumeLabel As String)_
    As Boolean
    Dim saveDir As String, answer As Integer
    On Error GoTo Error_Handler
    Drive = Left$(Drive, 1)
    ' Save the current drive for restoring later.
    saveDir = CurDir$
    ' Next statement is likely to fire an error.
    ' Check the drive specified in the parameter.
    ChDrive Drive
    ' Return True if the label matches, False otherwise.
    CheckDisk = (StrComp(Dir$(Drive &amp; &quot;:\*.*&quot;, vbVolume), _
        VolumeLabel, vbTextCompare) = 0)
    ' Restore the original current drive.
    ChDrive saveDir
    Exit Function
Error_Handler:
    ' If error is Device Unavailable or Disk Not Ready, and it's a disk,
    ' give the user the chance to insert the diskette in the drive.
    If (Err = 68 Or Err = 71) And InStr(1, &quot;AB&quot;, Drive, _
        vbTextCompare) Then
        answer = MsgBox(&quot;Please enter a diskette in drive &quot; &amp; Drive, _
            vbExclamation + vbRetryCancel)
        ' Retry the ChDir statement, or exit returning False.
        If answer = vbRetry Then Resume
    Else
        ' In all other cases, return the error to the calling program.
        Err.Raise Err.Number, Err.Source, Err.Description
    End If
End Function
</pre>
</td></tr>
</table></p>

<p>You can exit from an error routine in at least five ways:</p>

<UL>

<p><li> You can execute a <I>Resume</I> statement to retry the line of code that 
caused the error.
</li></p>

<p><li> You can execute a <I>Resume Next</I><B> 
</B>statement to resume execution in the procedure body at the line immediately after the one that caused the error.
</li></p>

<p><li> You can execute a <I>Resume 
</I>&lt;<I>line</I>&gt; statement to resume execution at a 
given line in the procedure body; 
&lt;<I>line</I>&gt;<I> </I>can be a line number or label name.
</li></p>

<p><li> You can report the error to the calling routine by executing an 
<I>Err.Raise</I> method.
</li></p>

<p><li> You can exit the procedure by executing an 
<I>Exit Sub</I> or <I>Exit Function</I> statement or by letting the execution flow into the <I>End Sub</I> or <I>End Function</I> directive. In both cases, the calling procedure receives a zero error code.
</li></p>
</ul>
 


<A NAME="157"><h3>The <I>On Error Resume Next</I> statement</h3></A>
<p>The <I>On Error Resume Next</I> statement is most useful when you don't expect 
many errors or when you don't need to trap all of them. In some cases, you can use 
this approach when the exception can be safely ignored, as in the following example:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Hide all controls in Form1.
Dim ctrl As Control
' Not all controls support the Visible property (Timers don't).
On Error Resume Next
For Each ctrl In Form1.Controls
    Ctrl.Visible = False
Next
</pre>
</td></tr>
</table></p>

<p>If you want to test an error condition, you must do it immediately after 
each statement that could cause an error. Or you can test the 
<I>Err</I> function at the end of a group of statements. In fact, if any statement raises an error, Visual Basic doesn't 
reset the <I>Err</I> value until the programmer does it explicitly with an 
<I>Err.Clear</I> method.
</p>

<p>If an error occurs while there's an active <I>On Error Resume 
Next</I> statement, the execution continues with the next statement in the procedure, 
<I>whichever the next statement is</I>. This feature permits you to test attributes of controls and objects in 
ways that would be impossible otherwise:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Hide all visible controls on Form1, and then restore
' their visibility.
Dim ctrl As Control, visibleControls As New Collection
On Error Resume Next
For Each ctrl In Form1.Controls
    If ctrl.Visible = False Then
        ' This control doesn't support the Visible property
        ' or it is already hidden: in either case, don't do anything.
    Else
        ' Remember that this is a visible control, and then hide it.
        visibleControls.Add ctrl
        ctrl.Visible = False
    End If
Next
' Do whatever you need to do (omitted), and
' then correctly restore the original controls' Visible property.
For Each ctrl In visibleControls
    ctrl.Visible = True
Next
</pre>
</td></tr>
</table></p>

<p>This unorthodox way to use <I>On Error Resume 
Next</I> is a powerful weapon in the hands of expert Visual Basic programmers, but it tends to obscure the logic 
behind your code. My suggestion is to resort to this technique only if it's impossible 
or impractical to follow other approaches, and&#8212;above 
all&#8212;to add exhaustive comments to your code so that it's clear exactly what you're doing and why.
</p>

<p>When a procedure that contains an <I>On Error Resume Next 
</I>statement exits, the calling code sees the code of the last error that occurred inside the procedure. 
Compare this behavior with procedures containing an 
<I>On Error Goto &lt;label&gt; </I>statement, which always clears the error code when the control returns to the calling code.
</p>

<A NAME="158"><h3>Unhandled errors</h3></A>
<p>So far, we've seen what happens when an error fires in a procedure that is 
protected with an <I>On Error Resume Next</I> or 
<I>On Error Goto</I> &lt;line&gt;<I> </I>statement. When either 
one of these statements is currently active (when it hasn't been cancelled by a 
subsequent <I>On Error Goto 0</I> statement), the procedure is said to have an 
<I>active error handler</I>. However, not all procedures are so well written, and in many cases you must 
consider exactly what happens when Visual Basic fires an error that you aren't 
prepared to deal with. (These are also known as 
<I>unanticipated errors.</I>)</p>

<UL>

<p><li> If the procedure has been called by another procedure, Visual Basic 
immediately terminates the current procedure and reports the error to 
the calling procedure, at the line that called the now-terminated 
procedure. If the calling procedure has an active error handler, it deals with the 
error locally (as if the error actually occurred there); otherwise, it 
exits immediately and reports the error to the procedure that called it, and 
so on until Visual Basic finds a pending procedure on the procedure 
stack that has an active error handler.
</li></p>

<p><li> If no procedure on the procedure stack has an active error handler, 
Visual Basic has no code to notify of the error, so it immediately stops 
the program with an error. If you are within the IDE, you can now spot 
the original statement that produced the error so that you can modify the 
code right away and restart the program. If the error occurred in a 
compiled EXE program, the application terminates with a fatal error.
</li></p>

<p><li> It's important to remember that all event procedures&#8212;such as 
<I>Form_Load</I> or <I>Command1_Click</I>&#8212;aren't generally called by code in your 
application; instead, they're called by the Visual Basic runtime file. So if an error 
occurs in those event procedures, there's no code to which to delegate the 
error and the application always terminates with a fatal error. Keep this in 
mind when distributing your <I>On Error</I> statements, and never omit them in 
event procedures unless you're 100 percent sure that they can never raise an error.
</li></p>
</ul>
 


<p><div class="note"><blockquote><b>NOTE</b><hr>
Any error that occurs while processing the code in an error handler 
is treated by Visual Basic as an unanticipated error and is subject to all the 
rules you've seen so far. This explains why you can execute an 
<I>Err.Raise</I> method within an error handling routine and be sure that the error will be passed to 
the calling procedure.
</blockquote></div>
</p>

<p>Here's an example that summarizes what I have said so far. Just add a 
<I>Command1</I> button to a form, and then enter the following code:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Command1_Click()
    ' Comment next line to see what happens when an event
    ' procedure isn't protected against unanticipated errors.
    On Error GoTo Error_Handler
    Print EvalExpression(1)
    Print EvalExpression(0)
    Print EvalExpression(-1)
    Exit Sub
Error_Handler:
    Print &quot;Result unavailable&quot;
    Resume Next
End Sub

Function EvalExpression(n As Double) As Double
    On Error GoTo Error_Handler
    EvalExpression = 1 + SquareRootReciprocal(n)
    Exit Function
Error_Handler:
    If Err = 11 Then
        ' If Division by zero, return -1 (no need to Resume).
        EvalExpression = -1
    Else
        ' Notify the caller that an error occurred.
        Err.Raise Err.Number, Err.Source, Err.Description
    End If
End Function

Function SquareRootReciprocal(n As Double) As Double
    ' This might cause a Division By Zero error (Err = 11) or
    ' an Invalid Procedure Call or Argument (Err = 5).
    SquareRootReciprocal = 1 / Sqr(n)
End Function
</pre>
</td></tr>
</table></p>

<p>Run the program, and click on the button. You should see this output:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>2
-1
Result Unavailable
</pre>
</td></tr>
</table></p>

<p>Then comment out the <I>On Error</I> statement in the 
<I>Command1_Click</I> procedure to watch what happens when an event procedure isn't completely protected by an error handler.
</p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>
Not all run-time errors are trappable. The most notable 
exception is error 28&#8212;&quot;Out of stack space.&quot; When this error occurs, the application 
always comes to a fatal end. But since all 32-bit Visual Basic applications have 
about 1 MB of available stack space, the probability that you incur this error is 
quite small. When this happens, odds are that you are performing some wild 
recursion: In other words, you're caught in a sequence of procedures that call 
themselves in an endless loop. This is a typical logic programming error that should 
usually be fixed before you compile the program, so I don't consider the inability to 
trap the &quot;Out of stack space&quot; error at run time a serious problem.
</blockquote></div>
</p>

<A NAME="159"><h3>The Err object</h3></A>
<p>Visual Basic automatically associates several useful pieces of information with any 
error that it fires, and it gives you the ability to do the same when you raise a custom 
error. This capability is provided through the Err object, which exposes six 
properties and two methods. The most important property is 
<I>Number</I>, the numeric error code. This is the default property for this object, so you can use either 
<I>Err</I> or <I>Err.Number</I> in your code, which permits backward compatibility to be maintained with 
older versions of Visual Basic, and even QuickBasic.
</p>

<p>The <I>Source</I> property is automatically filled with a string that states where 
the error occurred. If an error occurs in a standard or form module, Visual Basic sets 
this property to the name of the project (for example, 
<I>Project1</I>); if an error occurs in a class module, Visual Basic sets this property to the complete name of the class 
(for example, <I>Project1.Class1</I>). You can test this property to understand whether the 
error is internal or external to your application, and you can modify it before you 
notify the calling code of the error.
</p>

<p>The <I>Description</I> property is also automatically filled with a string that 
describes the error that just occurred (for example, &quot;Division by Zero&quot;). In most cases, this 
string is more descriptive than the mere error code number. You can modify it in code 
before notifying the caller about the error. The 
<I>HelpFile</I> and <I>HelpContext</I><B> 
</B>properties are filled by Visual Basic with information about which page in a help file contains an 
additional description of the error, how to handle it, and so on. Each native Visual 
Basic error corresponds to a page in Visual Basic's own help file. If you write libraries 
for other developers, you should devise a custom error numbering scheme and 
associate each custom error code with a page in a help file that you provide to your 
customers. This is rarely needed with business applications. Finally, the 
<I>LastDllError</I> is a read-only property that is set by Visual Basic when an error occurs during 
the processing of an API routine and isn't useful in any other case.
</p>

<p>The <I>Raise</I> method raises an error and optionally assigns a value to all the 
properties seen above. Its syntax is the following:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Err.Raise Number, [Source], [Description], [HelpFile], [HelpContext])
</pre>
</td></tr>
</table></p>

<p>All arguments are optional except the first one. For more readable code, 
use named arguments, as in this line:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Err.Raise Number:=1001, Description:=&quot;Customer Not Found&quot;
</pre>
</td></tr>
</table></p>

<p>The <I>Clear</I> method resets all the properties in one operation.
</p>

<p>Visual Basic's Err object is compatible with the COM mechanism of 
notifying error codes and information among different processes. The importance of this 
feature will become apparent in <a href="ch16a.htm">Chapter 16</a>.
</p>

<A NAME="160"><h3>Error handling inside the Visual Basic IDE</h3></A>
<p>So far, I've described what happens when an error occurs in a compiled 
application. When the code is executed inside the IDE, however, Visual Basic behaves in a 
slightly different way in an attempt to simplify your debugging chores. More precisely, 
the IDE can behave differently according to the settings found in the General tab of 
the Options dialog box from the Tools menu, which you can see in Figure 4-3. Here 
are the possibilities:</p>

<UL>

<p><li> Break On All Errors: All errors stop execution as soon as they occur; 
this setting enables the programmer to see exactly which errors are 
raised before they're reported to the calling code.
</li></p>

<p><li> Break In Class Module: All errors in class modules stop execution as 
soon as they occur and before they're returned to the calling code. Class 
modules might need this special treatment because the calling code could 
be located in another process if the class is Public. This is the default 
setting for handling errors in the IDE.
</li></p>

<p><li> Break On Unhandled Errors: Errors stop execution only if they 
aren't handled anywhere in the program. This setting exactly mimics what 
happens in a compiled application, but during the test phase it might 
hide what really goes on inside your code. For this reason, you should 
choose this mode only if you know for sure that all errors are processed 
correctly. If you set this mode in an application that works like a COM 
component and provides classes to the outside, no error will ever be trapped in 
the application's code because such applications always have a caller to 
transmit the error to.
</li></p>
</ul>
 


<p>The settings in the Options dialog box shown in Figure 4-3 are the 
default settings for the Visual Basic environment and are persistent throughout your 
sessions. If you want to change the error-handling mode of the current environment 
without affecting the general setting, right-click inside the code window and select one of 
the commands in the Toggle submenu, shown in Figure 4-4. This approach is 
usually faster and lets you work with multiple instances of the IDE, each one with a 
different error-handling mode.
</p>

<p>
<img src="images/F04ph03x.gif" width=418 height=354 border=0>
</p><p>
<!--caption--><B>Figure 4-3.</B> <i>The General tab in the Options dialog box.</i><!--/caption-->
</p>

<p>
<img src="images/F04ph04.GIF" width=338 height=332 border="0">
<p>
<!--caption--><B>Figure 4-4.</B> <i>The Toggle pop-up menu in the Code Editor.</i><!--/caption-->


<p>You've finally reached the end of this chapter devoted to Visual Basic data types, 
and you're now aware of a few subtleties that aren't clearly documented in the 
language manuals. Now you're ready to inspect the many functions that VBA gives you 
to process these data types.
</p>
</BODY>
</HTML>





