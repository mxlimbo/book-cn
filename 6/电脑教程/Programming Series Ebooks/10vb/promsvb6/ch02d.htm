<HTML>
<HEAD>
<TITLE>Common Events</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch02c.htm", "ch02e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="40"><h1>Common Events</h1></A>

<p>In addition to common properties and methods, Visual Basic 6 forms and 
controls support common events. In this section, we'll describe these events in some detail.</p>

<A NAME="41"><h2>The <I>Click</I> and <I>DblClick</I> Events</h2></A>

<p>A <I>Click</I> event occurs when the user left-clicks on a control, whereas the 
<I>DblClick</I> event occurs&#8212;you guessed it&#8212;when he or she double-clicks on the control using the 
left mouse button. But don't be fooled by this apparent simplicity because the 
<I>Click</I> event can occur under different circumstances as well. For example, whenever a 
CheckBox or an OptionButton control's <I>Value</I> property changes through code, Visual Basic 
fires a <I>Click</I> event, exactly as if the user had clicked on it. This behavior is useful 
because it lets you deal with the two different cases in a uniform way. ListBox and 
ComboBox controls also fire <I>Click</I> events whenever their 
<I>ListIndex</I> properties change.</p>

<p><I>Click</I> and <I>DblClick</I> events don't pass arguments to the program, and 
therefore you can't count on these events to tell you where the mouse cursor is. To get 
this information, you must trap the 
<I>MouseDown</I> event instead, about which I'll say 
more later in this chapter. Also notice that when you double-click on a control, it 
receives both the <I>Click</I> and the 
<I>DblClick</I> events. This makes it difficult to distinguish 
single clicks from double-clicks because when Visual Basic calls your 
<I>Click</I> event procedure you don't know whether it will later call the 
<I>DblClick</I> procedure. At any rate, you should avoid assigning different functions to click and double-click actions 
on the same control because it tends to confuse the user.</p>

<P><div class="TIP"><blockquote>
<B>TIP</B><HR>
While you shouldn't assign separate effects to click and double-click 
actions on the same control, here's a simple method to work around the 
problem of finding out what the user actually did:

<p><table><tr><td>
<PRE>
' A module-level variable
Dim isClick As Boolean

Private Sub Form_Click()
    Dim t As Single
    isClick = True
    ' Wait for the second click for half a second.
    t = Timer
    Do
        DoEvents
        ' If the DblClick procedure canceled this event, 
        ' bail out.
        If Not isClick Then Exit Sub
        ' The next test accounts for clicks just before midnight.
    Loop Until Timer &gt; t + .5 Or Timer &lt; t
    ' Do your single-click processing here.
    ...
End Sub

Private Sub Form_DblClick()
    ' Cancel any pending click.
    isClick = False
    ' Do your double-click processing here.
    ...
End Sub
</PRE>
</td></tr></table></p>
</blockquote></div></p>

<A NAME="42"><h2>The <I>Change</I> Event</h2></A>

<p>The <I>Change</I> event is the simplest event offered by Visual Basic: Whenever the 
contents of a control change, Visual Basic fires a 
<I>Change</I> event. Unfortunately, this simple scheme hasn't been consistently followed in the Visual Basic architecture. As I 
explained in the previous section, when you click on CheckBox and OptionButton controls, 
they fire a <I>Click</I> event (rather than a 
<I>Change</I> event). Fortunately, this inconsistency 
isn't a serious one.</p>

<p>TextBox and ComboBox controls raise a 
<I>Change</I> event when the user types something in the editable area of the control. (But be careful, the ComboBox 
control raises a <I>Click</I> event when the user 
<I>selects</I> an item from the list portion rather 
than types in a box.) Both scroll bar controls raise the 
<I>Change</I> event when the user clicks on either arrows or moves the scroll boxes. The 
<I>Change</I> event is also supported by the PictureBox, DriveListBox, and DirListBox controls.</p>

<p>The <I>Change</I> event also fires when the contents of the control are 
changed through code. This behavior often leads to some inefficiencies in the program. 
For instance, many programmers initialize the 
<I>Text</I> properties of all TextBox controls in the form's 
<I>Load </I>event, thus firing many <I>Change</I> events that tend to slow down 
the loading process.</p>

<A NAME="43"><h2>The <I>GotFocus </I>and <I>LostFocus</I> Events</h2></A>

<p>These events are conceptually very simple: 
<I>GotFocus</I> fires when a control receives the input focus, and 
<I>LostFocus</I> fires when the input focus leaves it and passes 
to another control. At first glance, these events seem ideal for implementing a sort 
of validation mechanism&#8212;that is, a piece of code that checks the contents of a 
field and notifies the user if the input value isn't correct as soon as he or she moves 
the focus to another control. In practice, the sequence of these events is subject to 
several factors, including the presence of 
<I>MsgBox</I> and <I>DoEvents</I> statements. 
Fortunately, Visual Basic 6 has introduced the new 
<I>Validate</I> event, which elegantly solves 
the problem of field validation. (See the &quot;<a href="ch03b.htm#73">The 
<I>CausesValidation</I> Property and the 
<I>Validate </I>Event</a>&quot; section in Chapter 3 for more details.)</p>

<p>Finally, note that forms support both 
<I>GotFocus</I> and <I>LostFocus</I> events, but 
these events are raised only when the form doesn't contain any control that can 
receive the input focus, either because all of the controls are invisible or the 
<I>TabStop</I> property for each of them is set to False.</p>

<A NAME="44"><H2>The <I>KeyPress</I>, <I>KeyDown</I>, and <I>KeyUp</I> Events</H2></A>
<p>These events fire whenever the end user presses a key while a control has the 
input focus. The exact sequence is as follows: <I>KeyDown 
</I>(the users presses the key), <I>KeyPress</I> (Visual Basic translates the key into an ANSI numeric code), and 
<I>KeyUp</I> (the user releases the key). Only keys that correspond to control keys 
(Ctrl+<I>x</I>, BackSpace, Enter, and Escape) and printable characters activate the 
<I>KeyPress</I> event. For all other keys&#8212;including arrow keys, function keys, 
Alt+<I>x</I> key combinations, and so on&#8212;this 
event doesn't fire and only the <I>KeyDown</I> and 
<I>KeyUp</I> events are raised.</p>

<p>The <I>KeyPress</I> event is the simplest of the three. It's passed the ANSI code of 
the key that has been pressed by the user, so you often need to convert it to a string 
using the <I>Chr$()</I> function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Text1_KeyPress(KeyAscii As Integer)
    MsgBox &quot;User pressed &quot; &amp; Chr$(KeyAscii)
End Sub
</pre>
</td></tr>
</table></p>


<p>If you modify the <I>KeyAscii</I> parameter, your changes affect how the 
program interprets the key. You can also &quot;eat&quot; a key by setting this parameter to 0, as 
shown in the code below.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Text1_KeyPress(KeyAscii As Integer)
    ' Convert all keys to uppercase, and reject blanks.
    KeyAscii = Asc(UCase$(Chr$(KeyAscii)
    If KeyAscii = Asc(&quot; &quot;) Then KeyAscii = 0 
End Sub
</pre>
</td></tr>
</table></p>


<p>The <I>KeyDown</I> and <I>KeyUp</I> events receive two parameters, 
<I>KeyCode </I>and <I>Shift</I>. 
The former is the code of the pressed key, the latter is an Integer value that reports 
the state of the Ctrl, Shift, and Alt keys; because this value is bit-coded, you have 
to use the AND operator to extract the relevant information:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Text1_KeyDown(KeyCode As Integer, Shift As Integer)
    If Shift And vbShiftMask Then
        ' Shift key pressed
    End If
    If Shift And vbCtrlMask Then
        ' Ctrl key pressed
    End If
    If Shift And vbAltMask Then
        ' Alt key pressed
    End If
    ' ... 
End Sub
</pre>
</td></tr>
</table></p>


<p>The <I>KeyCode</I> parameter tells which physical key has been pressed, and 
it's therefore different from the <I>KeyAscii </I>parameter received by the 
<I>KeyPress</I> event. You usually test this value using a symbolic constant, as in the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Text1_KeyDown(KeyCode As Integer, Shift As Integer)
    ' If user presses Ctrl+F2, replace the contents
    ' of the control with the current date. 
    If KeyCode = vbKeyF2 And Shift = vbCtrlMask Then
        Text1.Text = Date$
    End If
End Sub
</pre>
</td></tr>
</table></p>


<p>In contrast to what you can do with the <I>KeyPress 
</I>event, you can't alter the program's behavior if you assign a different value to the 
<I>KeyCode</I> parameter.</p>

<p>You should note that <I>KeyPress</I>, 
<I>KeyDown</I>, and <I>KeyUp</I> events might pose 
special problems during the debugging phase. In fact, if you place a breakpoint inside 
a <I>KeyDown</I> event procedure, the target control will never receive a notification 
that a key has been pressed and the 
<I>KeyPress</I> and <I>KeyUp</I> events will never fire. 
Similarly, if you enter break mode when Visual Basic is executing the 
<I>KeyPress</I> event procedure, the target control will receive the key but the 
<I>KeyUp</I> event will never fire.</p>

<P><div class="TIP"><blockquote>
<B>TIP</B><HR>
While you can't edit the 
<I>KeyCode</I> parameter and let the modified 
value affect the program, here's a trick that, in most cases, lets you discard an 
unwanted key in TextBox controls:

<p><table><tr><td>
<PRE>
Private Sub Text1_KeyDown(KeyCode As Integer, Shift As Integer)
    If KeyCode = vbKeyDelete Then
        ' Make the control read-only; this actually
        ' discards the key.
        Text1.Locked = True
    End If
End Sub

Private Sub Text1_KeyUp(KeyCode As Integer, Shift As Integer)
    ' Restore normal operation.
    Text1.Locked = False
End Sub
</PRE>
</td></tr></table></p>
</blockquote></div></p>

<p>The <I>KeyDown</I>, <I>KeyPress</I>, and 
<I>KeyUp</I> events are received only by the control 
that has the input focus when the key is pressed. This circumstance, however, makes 
it difficult to create <I>form-level key 
handlers,</I> that is, code routines that monitor 
keys pressed in any control on the form. For example, suppose that you want to offer 
your users the ability to clear the current field by pressing the F7 key. You don't want 
to write the same piece of code in the 
<I>KeyDown</I> event procedure for each and every control on your form, and fortunately you don't have to. In fact, you only have 
to set the form's <I>KeyPreview</I> property to True (either at design time or at run time, 
in the <I>Form_Load</I> procedure, for example) and then write this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_KeyDown(KeyCode As Integer, Shift As Integer)
    If KeyCode = vbKeyF7 Then
        ' An error handler is necessary because we can't be sure
        ' that the active control actually supports the Text
        ' property.
        On Error Resume Next
        ActiveControl.Text = &quot;&quot;
    End If
End Sub
</pre>
</td></tr>
</table></p>


<p>If the form's <I>KeyPreview</I> property is set to True, the Form object receives 
all keyboard-related events before they're sent to the control that currently has the 
input focus. Use the form's <I>ActiveControl</I> property if you need to act on the control 
with the input focus, as in the previous code snippet.</p>

<A NAME="45"><H2>The <I>MouseDown</I>, <I>MouseUp</I>, and <I>MouseMove</I> Events</H2></A>
<p>These events fire when the mouse is clicked, released, or moved on a 
control, respectively. All of them receive the same set of parameters: the state of 
mouse buttons, the state of Shift/Ctrl/Alt keys, and the 
<I>x-</I> and <I>y</I>-coordinates of the mouse 
cursor. The coordinates are always relative to the upper left corner of the control or the 
form. Following Figure 2-6 is a code sample that displays the status and position of 
the mouse on a Label control and creates a log in the Immediate window. You can 
see the results of running this code in Figure 2-6.</p>

<p>
<A HREF="javascript:fullSize('F02ph06x.htm')"> <img src="images/F02ph06.JPG" width=404 height=303 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 2-6.</B> <i>Monitor mouse state using the MouseDown, MouseMove, and MouseUp events. Note the negative y value when the cursor is outside the form's client area.</i><!--/caption-->
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_MouseDown(Button As Integer, _
    Shift As Integer, X As Single, Y As Single)
    ShowMouseState Button, Shift, X, Y
End Sub

Private Sub Form_MouseMove(Button As Integer, _
    Shift As Integer, X As Single, Y As Single)
    ShowMouseState Button, Shift, X, Y
End Sub
Private Sub Form_MouseUp(Button As Integer, _
    Shift As Integer, X As Single, Y As Single)
    ShowMouseState Button, Shift, X, Y
End Sub

Private Sub ShowMouseState (Button As Integer, _
    Shift As Integer, X As Single, Y As Single)
    Dim descr As String
    descr = Space$(20)
    If Button And vbLeftButton Then Mid$(descr, 1, 1) = &quot;L&quot;
    If Button And vbRightButton Then Mid$(descr, 3, 1) = &quot;R&quot;
    If Button And vbMiddleButton Then Mid$(descr, 2, 1) = &quot;M&quot;
    If Shift And vbShiftMask Then Mid$(descr, 5, 5) = &quot;Shift&quot;
    If Shift And vbCtrlMask Then Mid$(descr, 11, 4) = &quot;Ctrl&quot;
    If Shift And vbAltMask Then Mid$(descr, 16, 3) = &quot;Alt&quot;
    descr = &quot;(&quot; &amp; X &amp; &quot;, &quot; &amp; Y &amp; &quot;) &quot; &amp; descr
    Label1.Caption = descr
    Debug.Print descr
End Sub
</pre>
</td></tr>
</table></p>


<p>While writing code for mouse events, you should be aware of a few 
implementation details as well as some pitfalls in using these events. Keep in mind the 
following points:</p>
<UL>

<p><li>The <I>x</I> and <I>y</I> values are relative to the 
<I>client area </I>of the form or the control, not to its external border; for a form object, the coordinates (0,0) 
correspond to the pixel in the upper left corner below the title bar or the 
menu bar (if there is one). When you move the mouse cursor outside the 
form area, the values of coordinates might become negative or exceed 
the height and width of the client area.</li></p>

<p><li>When you press a mouse button over a form or a control and then 
move the mouse outside its client area while keeping the button pressed, 
the original control continues to receive mouse events. In this case, the 
mouse is said to be <I>captured </I>by the control: the capture state terminates 
only when you release the mouse button. All the 
<I>MouseMove</I> and <I>MouseUp</I> events fired in the meantime might receive negative values for the 
<I>x</I> and <I>y</I> parameters or values that exceed the object's width or height, respectively.</li></p>

<p><li><I>     MouseDown</I> and <I>MouseUp</I> events are raised any time the user presses 
or releases a button. For example, if the user presses the left button and 
then the right button (without releasing the left button), the control 
receives two <I>MouseDown</I> events and eventually two 
<I>MouseUp</I> events.</li></p>

<p><li>The <I>Button</I> parameter passed to 
<I>MouseDown</I> and <I>MouseUp</I> events reports which button has just been pressed and released, respectively. 
Conversely, the <I>MouseMove</I> event receives the current state of all (two or three) 
mouse buttons.</li></p>

<p><li>When the user releases the only button being pressed, Visual Basic 
fires a <I>MouseUp</I> event and then a 
<I>MouseMove</I> event, even if the mouse hasn't moved. This detail is what makes the previous code example work 
correctly after a button release: The current status is updated by the extra 
<I>MouseMove</I> event, not by the <I>MouseUp</I> event, as you probably expected. Note, 
however, that this additional <I>MouseMove</I> event doesn't fire when you press 
two buttons and then release only one of them.</li></p>
</UL>
 
<p>It's interesting to see how <I>MouseDown</I>, 
<I>MouseUp</I>, and <I>MouseMove</I> events relate to 
<I>Click</I> and <I>DblClick</I> events:</p>
<UL>

<p><li>A <I>Click</I> event occurs after a <I>MouseDown &#8230; 
MouseUp</I> sequence and before the extra 
<I>MouseMove</I> event.</li></p>

<p><li>When the user double-clicks on a control, the complete event 
sequence is as follows: <I>MouseDown</I>, 
<I>MouseUp</I>, <I>Click</I>, <I>MouseMove</I>, 
<I>DblClick</I>, <I>MouseUp</I>, <I>MouseMove</I>. Note that the second 
<I>MouseDown</I> event isn't generated.</li></p>

<p><li>If the control is clicked and then the mouse is moved outside its client 
area, the <I>Click </I>event is never raised. However, if you double-click a control 
and then you move the mouse outside its client area, the complete 
event sequence occurs. This behavior reflects how controls work under 
Windows and shouldn't be considered a bug.</li></p>
</UL>
 
</BODY>
</HTML>





