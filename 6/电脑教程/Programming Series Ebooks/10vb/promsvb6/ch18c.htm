<HTML>
<HEAD>
<TITLE>Data Consumer Classes</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch18b.htm", "ch18d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="892"><h1>Data Consumer Classes</h1></A>
<p>
<img src="images/new.jpg" width=102 height=87 border=0>
</p>

<p>A <I>data consumer</I> is a class or a component that binds itself to a data source. There are two types of data consumer objects: simple consumer and complex consumer. A simple consumer class or component binds one or more of its properties to the current row in the data source and so resembles an ActiveX control with multiple bindable properties. A complex consumer can bind its properties to multiple rows in the data source and resembles a grid control.</p>

<A NAME="893"><h2>Simple Data Consumers</h2></A>
<p>When you're transferring data from sources to consumers, consumers are passive entities. The object that actively moves data from the source to the consumer and back is the BindingCollection object.</p>

<A NAME="894"><h3>The BindingCollection object</h3></A>
<p>To create a BindingCollection object, you need to reference the Microsoft Data Binding Collection library in the References dialog box. The BindingCollection's most important members are the <I>DataSource </I>property and the <I>Add </I>method. To set up a connection between a data source and a data consumer, you need to assign the data source object to the BindingCollection's <I>DataSource </I>property and then call the <I>Add </I>method for each data consumer that must be linked to the source. The complete syntax for the <I>Add </I>method follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Add(BoundObj, PropertyName, DataField, [DataFormat], [Key]) As Binding
</pre>
</td></tr></table></p>

<p><I>BoundObj </I>is the data consumer object, <I>PropertyName </I>is the name of the property in the data consumer that's bound to a field of the data source, <I>DataField</I> is the name of the field in the source, <I>DataFormat </I>is an optional StdDataFormat object that affects how data is formatted during the transfer to and from the consumer, and <I>Key </I>is the key of the new Binding object in the collection. You can call multiple <I>Add </I>methods to bind multiple consumers or multiple properties of the same consumer.</p>

<p>A common data source is the ADO Recordset object, but you can also use a DataEnvironment object, an OLE DB Simple Provider, and any data source class or component that you've defined in code. The following code shows how you can bind two TextBox controls to fields of a database table through an ADO Recordset:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Const DBPath = &quot;C:\Program Files\Microsoft Visual Studio\Vb98\NWind.mdb&quot;
Dim cn As New ADODB.Connection, rs As New ADODB.Recordset 
Dim bndcol As New BindingCollection

' Open the Recordset.
cn.Open &quot;Provider=Microsoft.Jet.OLEDB.3.51;Data Source=&quot; &amp; DBPATH
rs.Open &quot;Employees&quot;, cn, adOpenStatic, adLockReadOnly 
' Use the Bindingcollection object to bind two TextBox controls to the
' FirstName and LastName fields of the Employees table.
Set bndcol.DataSource = rs
bndcol.Add txtFirstName, &quot;Text&quot;, &quot;FirstName&quot;, , &quot;FirstName&quot;
bndcol.Add txtLastName, &quot;Text&quot;, &quot;LastName&quot;, , &quot;LastName&quot;
</pre>
</td></tr></table></p>

<p>You can control how data is formatted in the consumer by defining a StdDataFormat object, setting its <I>Type </I>and <I>Format </I>properties, and then passing it as the fourth argument of a BindingCollection's <I>Add </I>method, as the code below demonstrates.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim DateFormat As New StdDataFormat
DateFormat.Type = fmtCustom
DateFormat.Format = &quot;mmmm dd, yyyy&quot;
' One StdDataFormat object can serve multiple consumers.
bndcol.Add txtBirthDate, &quot;Text&quot;, &quot;BirthDate&quot;, DateFormat, &quot;BirthDate&quot;
bndcol.Add txtHireDate, &quot;Text&quot;, &quot;HireDate&quot;, DateFormat, &quot;HireDate&quot;
</pre>
</td></tr></table></p>

<p>If the data source exposes multiple DataMember objects, as is the case for DataEnvironment objects, you select which one is bound to data consumers by using the BindingCollection's <I>DataMember</I> property, exactly as you do when you bind controls to an ADO Data control.</p>

<p>The BindingCollection object exposes a few other properties and methods that give you more control over the binding process. The <I>UpdateMode </I>enumerated property determines when data is updated in the data source: For the default value, 1vbUpdateWhenPropertyChanges, the source is updated as soon as a property's value changes, whereas the value 2-vbUpdateWhenRowChanges causes the updates to the source only when the record pointer moves to another record. When the value is 0vbUsePropertyAttributes, the decision when to update the source depends on the state of the Update Immediate option in the Procedure Attributes dialog box.</p>

<p>Each time you execute an <I>Add </I>method, you actually add a Binding object to the collection. You can later query the Binding object's properties to acquire information about the binding process. Each Binding object exposes the following properties: <I>Object</I> (a reference to the bound data consumer), <I>PropertyName</I> (the name of the bound property), <I>DataField </I>(the field in the source), <I>DataChanged </I>(True if data in the consumer has been changed), <I>DataFormat </I>(the StdDataFormat object used to format data), and <I>Key </I>(the key of the Binding object in the collection). For example, you can determine whether the value in a consumer has changed by executing the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim bind As Binding, changed As Boolean
For Each bind in bndcol
    changed = changed Or bndcol.DataChanged
Next
If changed Then Debug.Print &quot;Data has been changed&quot;
</pre>
</td></tr></table></p>

<p>If you assigned a key to a Binding object, you can directly read and modify its properties:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Set the ForeColor of the TextBox control bound to the HireDate field.
bndcol(&quot;HireDate&quot;).Object.ForeColor = vbRed
</pre>
</td></tr></table></p>

<p>The <I>UpdateControls</I> method of the BindingCollection object updates all the consumers with values from the current row in the data source and resets the <I>DataChanged </I>properties of all Binding objects to False.</p>

<p>Finally, you can trap any error that occurs in the binding mechanism by using the BindingCollection's <I>Error </I>event. To trap this event from a BindingCollection object, you must have declared it using a <I>WithEvents</I> clause:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim WithEvents bndcol As BindingCollection

Private Sub bndcol_Error(ByVal Error As Long, ByVal Description As String,_
    ByVal Binding As MSBind.Binding, fCancelDisplay As Boolean)
    ' Deal here with binding errors.
End Sub
</pre>
</td></tr></table></p>

<p><I>Error </I>is the error code, <I>Description </I>is the error description, <I>Binding</I> is the Binding object that caused the error, and <I>fCancelDisplay</I> is a Boolean argument that you can set to False if you don't want to display the standard error message.</p>

<p><div class="caution"><blockquote><b>CAUTION</b><hr>
When binding a property of a control to a field in the data source, you should ensure that the control correctly sends the necessary notification to the binding mechanism when the property changes. For example, you can bind the <I>Caption </I>property of a Label or Frame control to a data source, but if you then change the value of the <I>Caption </I>property through code the control doesn't inform the source that the data has changed. Consequently, the new value isn't written to the database. In this case, you must force the notification yourself by using the BindingCollection object's <I>DataChanged </I>property.
</blockquote></div></p>

<A NAME="895"><h3>Data consumer classes and components</h3></A>
<p>To create a simple data consumer class, you only need to set the <I>DataBindingBehavior </I>attribute of the class to the value 1-vbSimpleBound in the Properties window. This setting adds two new methods that you can use from within the class module: <I>PropertyChange </I>and <I>CanPropertyChange</I>.</p>

<p>Implementing a simple data consumer class or component is similar to creating an ActiveX control that can be bound to a data source. In the <I>Property Let</I> procedures of all the bound properties, you must make sure that a property value can change by invoking the <I>CanPropertyChange </I>function. Then you call the <I>PropertyChange </I>method to inform the binding mechanism that the value has indeed changed. (Be aware that the <I>CanPropertyChange </I>method always returns True in Visual Basic, as I explained in the &quot;<A HREF="ch17d.htm#858"><I>PropertyChanged</I> and <I>CanPropertyChange</I> Methods</A>&quot; section of Chapter 17.) The following code is taken from the demonstration program on the companion CD and shows how the sample CEmployee data consumer class implements its <I>FirstName </I>property:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the CEmployee class module
Dim m_FirstName As String

Property Get FirstName() As String
    FirstName = m_FirstName
End Property

Property Let FirstName(ByVal newValue As String)
    If newValue &lt;&gt; m_FirstName Then
        If CanPropertyChange(&quot;FirstName&quot;) Then
            m_FirstName = newValue
            PropertyChanged &quot;FirstName&quot;
        End If
    End If
End Property
</pre>
</td></tr></table></p>

<p>You bind the properties of a data consumer class to the fields in a data source using a BindingCollection object. The binding operation can be performed in the client form or module (as you saw in the previous section) or inside the data consumer class itself. The latter solution is usually preferable because it encapsulates the code in the class and prevents it from being scattered in all its clients. If you follow this approach, you must provide a method that lets clients pass a data source to the class: This can be a data source class, an ADO Data control or Recordset, or a DataEnvironment object. The class can use this reference as an argument to the <I>DataSource </I>property of an internal BindingCollection object:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the CEmployee class module
Private bndcol As New BindingCollection

Property Get DataSource() As Object
    Set DataSource = bndcol.DataSource
End Property

Property Set DataSource(ByVal newValue As Object)
    Set bndcol = New BindingCollection
    Set bndcol.DataSource = newValue
    bndcol.Add Me, &quot;FirstName&quot;, &quot;FirstName&quot;, , &quot;FirstName&quot;
    bndcol.Add Me, &quot;LastName&quot;, &quot;LastName&quot;, , &quot;LastName&quot;
    bndcol.Add Me, &quot;BirthDate&quot;, &quot;BirthDate&quot;, , &quot;BirthDate&quot;
End Property
</pre>
</td></tr></table></p>

<p>The following code shows how a client form can bind the CEmployee class to a Recordset:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim cn As New ADODB.Connection, rs As New ADODB.Recordset
Dim employee As New CEmployee
cn.Open &quot;Provider=Microsoft.Jet.OLEDB.3.51;&quot; _
    &amp; &quot;Data Source=&quot;C:\Program Files\Microsoft Visual Studio\Vb98\NWind.mdb&quot;
rs.Open &quot;Employees&quot;, cn, adOpenKeyset, adLockOptimistic
Set employee.DataSource = rs
</pre>
</td></tr></table></p>

<p>When the program modifies a value of a bound property in the data consumer class, the corresponding field in the data source is updated, provided that the data source is updatable. But the precise moment the field is updated depends on the <I>UpdateMode </I>setting of the BindingCollection object. If <I>UpdateMode</I> is 2vbUpdateWhenRowChanges, the data source is updated only when another record becomes the current record, whereas if the setting is 1vbUpdateWhenPropertyChanges the Recordset is updated immediately. If you set <I>UpdateMode </I>= 0-vbUsePropertyAttributes, the data source is updated immediately only if the property is marked with the <I>Update Immediately</I> attribute in the Procedure Attributes dialog box.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>Even if the data source is an ADO Recordset linked to a database, updating the data source doesn't mean that the database is immediately updated, but only that the new value is assigned to the Field's <I>Value </I>property. A way to force the update of the underlying database is to execute the Recordset's <I>Move </I>method using 0 as the argument. This doesn't actually move the record pointer but flushes to the database the current contents of the Fields collection. Oddly, the Recordset's <I>Update </I>method doesn't work in this situation.
</blockquote></div></p>

<p>Here's another peculiarity in the implementation of this feature: The setting 0vbUpdateWhenPropertyChanges doesn't seem to work as the documentation states, and it doesn't immediately update the value in the Recordset. The only way to update the Recordset when a property changes is by using the setting 0vbUsePropertyAttributes and ticking the Update Immediate check box in the Procedure Attributes dialog box.</p>

<A NAME="896"><h2>Complex Data Consumers</h2></A>
<p>Building a complex data consumer is slightly more difficult than building a simple data consumer. The reason for the additional difficulty is mostly the lack of good and complete documentation sources. The first step in creating a complex data consumer class is to set the <I>DataBindingBehavior </I>to the value 2-vbComplexBound. Alternatively, you can select the Complex Data Consumer template from the template gallery when you create a new class module. In both cases, you'll find that a couple of properties&#8212;<I>DataMember </I>and <I>DataSource&#8212;</I>have been added to the class module:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Public Property Get DataSource() As DataSource
End Property
Public Property Set DataSource(ByVal objDataSource As DataSource)
End Property

Public Property Get DataMember() As DataMember
End Property
Public Property Let DataMember(ByVal DataMember As DataMember)
End Property
</pre>
</td></tr></table></p>

<p>When you set <I>DataBindingBehavior</I> to 2-vbComplexBound in a UserControl module, Visual Basic doesn't create the templates for these two properties for you&#8212;you must do it manually.</p>

<p>ActiveX controls that work as complex data consumers are typically gridlike controls. They expose the <I>DataMember </I>and <I>DataSource </I>properties, but unlike ActiveX controls that behave as simple data consumers, these properties aren't Extender properties. You can't count on the automatic binding mechanism that you can specify in the Procedure Attributes dialog box, and you must implement these two properties all by yourself.</p>

<p>Now you need to add a few type libraries in the References dialog box. When you're building a complex data consumer, you need the Microsoft Data Sources Interfaces (Msdatsrc.tlb), the Microsoft Data Binding Collection (msbind.dll), and, of course, the Microsoft ActiveX Data Objects 2.0 (or 2.1) Library. The first of these libraries exposes the DataSource interface, which is supported by all the objects that can work as data sources, such as the ADO Recordset, the ADO Data control, and the DataEnvironment object.</p>

<p>On the companion CD, you'll find the complete source code for the ProductGrid ActiveX control, shown in Figure 18-4. This ActiveX control builds on a ListView control to give you a custom view of the Products table of the NWind.mdb database. I used the ActiveX Control Interface Wizard to create most of the properties and events of this control, such as <I>Font</I>, <I>BackColor</I>, <I>ForeColor</I>, <I>CheckBoxes</I>, <I>FullRowSelection</I>, and all the mouse and keyboards events. The only routines I had to write manually are those that implement the binding mechanism. The declaration section of the ProductGrid module contains the following private variables:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private WithEvents rs As ADODB.Recordset
Private bndcol As New BindingCollection
Private m_DataMember As String
</pre>
</td></tr></table></p>

<p>Implementing the <I>DataMember </I>property is as easy as creating a wrapper around the private <I>m_DataMember </I>string variable:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Public Property Get DataMember() As String
    DataMember = m_DataMember
End Property
Public Property Let DataMember(ByVal newValue As String)
    m_DataMember = newValue
End Property 
</pre>
</td></tr></table></p>

<p>The <I>Property Let DataSource </I>procedure is where the binding process actually takes place. This procedure is called when the class or the control is bound to its data source. The binding can be done explicitly via code, or it can be done implicitly at form loading if you set the <I>DataSource </I>property in the Properties window of an ActiveX control that works as a complex data consumer. This is the implementation of the <I>DataSource </I>property for the CustomerGrid control:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Public Property Get DataSource() As DataSource
    ' Simply delegate to the Recordset's DataMember property.
    If Not (rs Is Nothing) Then
        Set DataSource = rs.DataSource
    End If
End Property

Public Property Set DataSource(ByVal newValue As DataSource)
    If Not Ambient.UserMode Then Exit Property
    If Not (rs Is Nothing) Then
        ' If the new value equals the old one, exit right now.
        If rs.DataSource Is newValue Then Exit Property
        If (newValue Is Nothing) Then
            ' The Recordset is being closed. (The program is shutting
            ' down.)  Flush the current record.
            Select Case rs.LockType
                Case adLockBatchOptimistic
                    rs.UpdateBatch
                Case adLockOptimistic, adLockPessimistic
                    rs.Update
                Case Else
            End Select
        End If
    End If
    If Not (newValue Is Nothing) Then
        Set rs = New ADODB.Recordset     ' Re-create the Recordset.
        rs.DataMember = m_DataMember
        Set rs.DataSource = newValue
        Refresh                          ' Reload all data.
    End If
End Property
</pre>
</td></tr></table></p>

<p>
<A HREF="javascript:fullSize('F18ph04x.htm')"> <img src="images/F18ph04.JPG" width=404 height=218 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 18-4.</B> <I>The grid on this form is an instance of the ProductGrid ActiveX control.</i><!--/caption-->
</p>

<p>Notice that the previous routines don't include any reference to the UserControl's constituent controls. In fact, you can reuse them in nearly every class or component without changing a single line of code. The code specific to each particular component is located in the <I>Refresh </I>method:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub Refresh()
    ' Exit if in design mode.
    If Not Ambient.UserMode Then Exit Sub    
    ' Clear the ListView, and exit if the Recordset is empty or closed.
    ListView1.ListItems.Clear
    If rs Is Nothing Then Exit Sub
    If rs.State &lt;&gt; adStateOpen Then Exit Sub
    ' Move to the first record, but remember the current position.
    Dim Bookmark As Variant, FldName As Variant
    Bookmark = rs.Bookmark
    rs.MoveFirst
    
    ' Load the data from the Recordset into the ListView.
    Do Until rs.EOF
        With ListView1.ListItems.Add(, , rs(&quot;ProductName&quot;))
            .ListSubItems.Add , , rs(&quot;UnitPrice&quot;)
            .ListSubItems.Add , , rs(&quot;UnitsInStock&quot;)
            .ListSubItems.Add , , rs(&quot;UnitsOnOrder&quot;)
            ' Remember the Bookmark of this record.
            .Tag = rs.Bookmark
        End With
        rs.MoveNext
    Loop
    ' Restore the pointer to the current record.
    rs.Bookmark = Bookmark
    
    ' Bind the properties to the Recordset.
    Set bndcol = New BindingCollection
    bndcol.DataMember = m_DataMember
    Set bndcol.DataSource = rs
    For Each FldName In Array(&quot;ProductName&quot;, &quot;UnitPrice&quot;, &quot;UnitsInStock&quot;, _
        &quot;UnitsOnOrder&quot;)
        bndcol.Add Me, FldName, FldName
    Next
End Sub
</pre>
</td></tr></table></p>

<p>This is a rather simple implementation of a data-aware grid ActiveX control based on the ListView common control. A more sophisticated control would probably avoid loading the entire Recordset all at once in the ListView and would instead exploit a buffering algorithm to improve performance and reduce memory consumption.</p>

<p>A complex data consumer has to do a couple of things to meet the user's expectations. First, it should change the current record when the user clicks on another grid row. Second, it should highlight a record when it becomes the current record. In the ProductGrid control, the first goal is met by code in the ListView's <I>ItemClick </I>event; this code exploits the fact that the control stores the value of the <I>Bookmark </I>property for each record in the Recordset in the <I>Tag </I>property of all the ItemList elements:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub ListView1_ItemClick(ByVal Item As MSComctlLib.ListItem)
    rs.Bookmark = Item.Tag
End Sub
</pre>
</td></tr></table></p>

<p>To highlight a different row in the ListView control when it becomes the current record, you need to write code in the Recordset's <I>MoveComplete </I>event:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub rs_MoveComplete(ByVal adReason As ADODB.EventReasonEnum, _
    ByVal pError As ADODB.Error, adStatus As ADODB.EventStatusEnum, _
    ByVal pRecordset As ADODB.Recordset)
    Dim Item As ListItem
    ' Exit if in a BOF or EOF condition.
    If rs.EOF Or rs.BOF Then Exit Sub
    ' Highlight the item corresponding to the current record.
    For Each Item In ListView1.ListItems
        If Item.Tag = rs.Bookmark Then
            Set ListView1.SelectedItem = Item
            Exit For
        End If
    Next
    ' Ensure that the item is visible.
    If Not (ListView1.SelectedItem Is Nothing) Then
        ListView1.SelectedItem.EnsureVisible
    End If
    ListView1.Refresh
End Sub
</pre>
</td></tr></table></p>

<p>The source code for the demonstration program exploits a technique that avoids running the code in the <I>MoveComplete</I> event procedure if the move was caused by an action inside the UserControl (in which case, the control already knows which row in the grid should be highlighted).</p>

<p>You can use the ProductGrid ActiveX control exactly as you would use a DataGrid or another data-aware grid control. I found, however, that the binding mechanism still has some rough edges. For example, if you refresh an ADO Data control, a complex data consumer authored in Visual Basic doesn't seem to get any notification. Therefore, if you need to change one or more properties in an ADO Data control and then execute its <I>Refresh </I>method, you also have to reassign the ADO Data control to the <I>DataSource </I>property of the ProductGrid control:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Adodc1.ConnectionString = &quot;Provider=Microsoft.Jet.OLEDB.3.51;&quot; _
    &amp; &quot;Data Source=C:\Program Files\Microsoft VisualStudio\Vb98\NWind.mdb&quot; 
Adodc1.Refresh
Set ProductGrid1.DataSource = Adodc1
</pre>
</td></tr></table></p>

</BODY>
</HTML>





