<HTML>
<HEAD>
<TITLE>Scrollbar Controls</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch03f.htm", "ch03h.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="96"><h1>Scrollbar Controls</h1></A>

<p>The HScrollBar and the VScrollBar controls are perfectly identical, apart from 
their different orientation. After you place an instance of such a control on a form, you 
have to worry about only a few properties: 
<I>Min</I> and <I>Max</I> represent the valid range of 
values, <I>SmallChange</I> is the variation in value you get when clicking on the scroll bar's 
arrows, and <I>LargeChange</I> is the variation you get when you click on either side 
of the scroll bar indicator. The default initial value for those two properties is 1, but 
you'll probably have to change <I>LargeChange</I> to a higher value. For example, if you 
have a scroll bar that lets you browse a portion of text, 
<I>SmallChange</I> should be 1 (you scroll one line at a time) and 
<I>LargeChange</I> should be set to match the number of 
visible text lines in the window.</P>

<p>The most important run-time property is 
<I>Value</I>, which always returns the relative position of the indicator on the scroll bar. By default, the 
<I>Min</I> value corresponds to the leftmost or upper end of the control:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Move the indicator near the top (or left) arrow.
VScroll1.Value = VScroll1.Min
' Move the indicator near the bottom (or right) arrow.
VScroll1.Value = VScroll1.Max
</pre>
</td></tr>
</table>
</P>


<p>While this setting is almost always OK for horizontal scroll bars, you 
might sometimes need to reverse the behavior of vertical scroll bars so that the zero is 
near the bottom of your form. This arrangement is often desirable if you want to use 
a vertical scroll bar as a sort of slider. You obtain this behavior by simply inverting 
the values in the <I>Min</I> and <I>Max </I>properties. (In other words, it's perfectly legal for 
<I>Min</I> to be greater than <I>Max</I>.)</P>

<p>There are two key events for scrollbar controls: the 
<I>Change</I> event fires when you click on the scroll bar arrows or when you drag the indicator; the 
<I>Scroll</I> event fires while you drag the indicator. The reason for these two distinct possibilities 
is mostly historical. First versions of Visual Basic supported only the 
<I>Change </I>event, and when developers realized that it wasn't possible to have continuous feedback 
when users dragged the indicator, Microsoft engineers added a new event instead of extending the <I>Change</I> event. In this way, old applications could be recompiled without unexpected changes in their behavior. At any rate, this means that you must often trap two distinct events:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Show the current scroll bar's value. 
Private VScroll1_Change()
    Label1.Caption = VScroll1.Value
End Sub
Private VScroll1_Scroll()
    Label1.Caption = VScroll1.Value
End Sub
</pre>
</td></tr>
</table>
</P>


<p>The example shown in Figure 3-13 uses three VScrollBar controls as sliders 
to control the individual RGB (red, green, blue) components of a color. The three 
scroll bars have their <I>Min</I> property set to 255 and their 
<I>Max </I>property set to 0, while their 
<I>SmallChange</I> is 1 and <I>LargeChange</I> is 16. This example is also a moderately 
useful program in itself because you can select a color and then copy its numeric value 
to the clipboard and paste it in your application's code as a decimal value, a 
hexadecimal value, or an RGB function.</P>

<p>
<img src="images/F03ph13.GIF" width=396 height=294 border="0">
<p>
<!--caption--><B>Figure 3-13.</B> <i>Use scrollbar controls to visually create colors.</i><!--/caption-->


<P>Scrollbar controls can receive the input focus, and in fact they support both 
the <I>TabIndex</I> and <I>TabStop</I> properties. If you don't want the user to accidentally 
move the input focus on a scrollbar control when he or she presses the Tab key, you 
must explicitly set its <I>TabStop</I> property to False. When a scrollbar control has the 
focus, you can move the indicator using the Left, Right, Up, Down, PgUp, PgDn, Home, 
and End keys. For example, you can take advantage of this behavior to create a 
read-only TextBox control with a numeric value that can be edited only through a tiny 
companion scroll bar. This scroll bar appears to the user as a sort of spin button, as 
you can see in Figure 3-14. To make the trick work, you need to 
write just a few lines of code:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Text1_GotFocus()
    ' Pass the focus to the scroll bar.
    VScroll1.SetFocus
End Sub
Private Sub VScroll1_Change()
    ' Scroll bar controls the text box value.
    Text1.Text = VScroll1.Value
End Sub
</pre>
</td></tr>
</table>
</P>


<p>
<img src="images/F03ph14.GIF" width=235 height=161 border="0">
</p><p>
<B>Figure 3-14.</B> <i>You don't need external ActiveX controls to create functional spin buttons.</i>
</p>

<P>Scrollbar controls are even more useful for building scrolling forms, like the 
one displayed in Figure 3-15. To be certain, scrolling forms aren't the 
most ergonomic type of user interface you can offer to your customers: If you have 
that many fields in a form, you should consider using a Tab control, child forms, or 
some other custom interface. Sometimes, however, you badly need scrollable forms, and 
in this situation you are on your own because Visual Basic forms don't support scrolling.</P>
<P>Fortunately, it doesn't take long to convert a regular form into a scrollable 
one. You need a couple of scrollbar controls, plus a PictureBox control that you use 
as the container for all the controls on the form, and a filler control&#8212;a 
CommandButton, for example&#8212;that you place in the bottom-right corner of the form when it 
displays the two scroll bars. The secret to creating scrollable forms is that you don't move 
all the child controls one by one. Instead, you place all the controls in the 
PictureBox control (named <I>picCanvas </I>in the following code), and you move it when the 
user acts on the scroll bar:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub MoveCanvas()
    picCanvas.Move -HScroll1.Value, -VScroll1.Value
End Sub
</pre>
</td></tr>
</table>
</P>


<p>In other words, to uncover the portion of the form near the right border, 
you assign a negative value to the PictureBox's 
<I>Left</I> property, and to display the portion near the form's bottom border you set its 
<I>Top</I> property to a negative value. It's 
really that simple. You do this by calling the 
<I>MoveCanvas</I> procedure from within the scroll bars' 
<I>Change</I> and <I>Scroll</I> events. Of course, it's critical that you write code in 
the <I>Form_Resize</I> event, which makes a scroll bar appear and disappear as the form 
is resized, and that you assign consistent values to 
<I>Max </I>properties of the scrollbar controls:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' size of scrollbars in twips
Const SB_WIDTH = 300    ' width of vertical scrollbars
Const SB_HEIGHT = 300   ' height of horizontal scrollbars

Private Sub Form_Resize()
    ' Resize the scroll bars along the form.
    HScroll1.Move 0, ScaleHeight - SB_HEIGHT, ScaleWidth - SB_WIDTH
    VScroll1.Move ScaleWidth - SB_WIDTH, 0, SB_WIDTH, _
        ScaleHeight - SB_HEIGHT
    cmdFiller.Move ScaleWidth - SB_WIDTH, ScaleHeight - SB_HEIGHT, _
        SB_WIDTH, SB_HEIGHT

    ' Put these controls on top.
    HScroll1.ZOrder 
    VScroll1.ZOrder
    cmdFiller.ZOrder
    picCanvas.BorderStyle = 0

    ' A click on the arrow moves one pixel.
    HScroll1.SmallChange = ScaleX(1, vbPixels, vbTwips)
    VScroll1.SmallChange = ScaleY(1, vbPixels, vbTwips)
    ' A click on the scroll bar moves 16 pixels.
    HScroll1.LargeChange = HScroll1.SmallChange * 16
    VScroll1.LargeChange = VScroll1.SmallChange * 16

    ' If the form is larger than the picCanvas picture box,
    ' we don't need to show the corresponding scroll bar.
    If ScaleWidth &lt; picCanvas.Width + SB_WIDTH Then
        HScroll1.Visible = True
        HScroll1.Max = picCanvas.Width + SB_WIDTH - ScaleWidth
    Else
        HScroll1.Value = 0
        HScroll1.Visible = False
    End If
    If ScaleHeight &lt; picCanvas.Height + SB_HEIGHT Then
        VScroll1.Visible = True
        VScroll1.Max = picCanvas.Height + SB_HEIGHT - ScaleHeight
    Else
        VScroll1.Value = 0
        VScroll1.Visible = False
    End If
    ' Make the filler control visible only if necessary.
    cmdFiller.Visible = (HScroll1.Visible Or VScroll1.Visible)
    MoveCanvas
End Sub
</pre>
</td></tr>
</table>
</P>


<p>Working with scrollable forms at design time isn't comfortable. I suggest 
that you work with a maximized form and with the PictureBox control sized as large 
as possible. When you're finished with the form interface, resize the PictureBox 
control to the smallest area that contains all the controls, and then reset the 
form's <I>WindowState</I> property to 0-Normal.</P>

<p>
<A HREF="javascript:fullSize('F03ph15x.htm')"> <img src="images/F03ph15.JPG" width=404 height=370 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 3-15.</B> <i>Scrollable forms.</i><!--/caption-->
</p>

</BODY>
</HTML>





