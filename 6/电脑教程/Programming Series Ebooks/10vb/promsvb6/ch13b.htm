<HTML>
<HEAD>
<TITLE>The Connection Object</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch13a.htm", "ch13c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="549"><h1>The Connection Object</h1></A>
<p>The ADO Connection object represents an open connection to a data source. This data source might be a database, an ODBC source, or any other source for which an OLE DB provider exists. The Connection object lets you specify all the necessary parameters&#8212;for example, the server and the database names, the user's name and password, and the timeout&#8212;before opening the data source. Connection objects are also important because they serve as containers for transactions. Each connection belongs to a given client application and is closed only when you explicitly close it, when you set the object variable to Nothing, or when your application ends.</p>

<A NAME="550"><h2>Properties</h2></A>
<p>The Connection object doesn't expose many properties. Rather than list each property individually, I've grouped them according to their purposes: Preparing for the connection, managing transactions, and determining the state of the connection and what version of ADO is running.</p>

<A NAME="551"><h3>Preparing for the connection</h3></A>
<p>A group of properties lets you specify which database should be open and in which mode. All these properties can be written to before the connection is opened, but they become read-only after the connection has been established. The <I>Provider </I>property is the name of the OLE DB provider for the connection&#8212;for example, &quot;SQLOLEDB&quot; for the Microsoft SQL Server OLE DB Provider. If you leave this property unassigned, the default MSDASQL provider is used which is the OLE DB Provider for ODBC Drivers, a sort of bridge that permits you to connect to almost any relational database on earth even if an OLE DB provider hasn't been developed for it yet (provided that an ODBC driver exists for that database, of course). MSDASQL is also known by the code name &quot;Kagera.&quot;</p>

<p>Instead of assigning a value to the <I>Provider </I>property, you can pass the provider's name in the <I>ConnectionString </I>property together with other parameters the OLE DB provider expects. For example, this connection string opens the Biblio.mdb database:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim cn As New ADODB.Connection
cn.ConnectionString = &quot;Provider=Microsoft.Jet.OLEDB.3.51;&quot; _
    &amp; &quot;Data Source=C:\Microsoft Visual Studio\Vb98\Biblio.mdb&quot;
</pre>
</td></tr></table></p>

<p>The following connection string opens the Pubs SQL Server database on a server named &quot;ServerNT&quot;. (The connection string also contains the user's name and password.)

<p><table cellpadding=5 width="95%"><tr><td>
<pre>cn.ConnectionString = &quot;Provider=SQLOLEDB;Server=ServerNT;&quot; _
    &amp; &quot;User ID=MyID;Password=MyPWD;Data Source=Pubs&quot;
</pre>
</td></tr></table></p>

<p>You shouldn't specify the provider name in the <I>ConnectionString</I> property and the <I>Provider</I> property at the same time because the results are unpredictable.</p>

<p>A simple way to build a connection string is to drop an ADO Data control on a form, open its property pages, select the Use Connection String option, and click on the Build button. A new dialog box appears, in which you can select the provider, the user name, the user password, and all the provider-dependent dynamic properties, as shown in Figure 13-3. When you've finished, the complete string connection appears in the General tab of the Properties dialog box.</p>

<p>Mastering the syntax for specifying the <I>ConnectionString </I>property can be difficult because the string can include many different arguments in the form <I>argname=value</I>. This task is made more complex by the fact that when you're connecting to an ODBC source, the <I>ConnectionString </I>property also supports ODBC attributes that can coexist with newer OLE DB attributes. Table 13-1 lists a few of the most common attributes that you can specify in this string.</p>

<p><B>Table 13-1.</B> <i>Some of the arguments you can use in the 
ConnectionString property.</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Argument</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top"><I>Data Source</I></td>
<td valign="top">The name of the SQL Server or the name of the MDB database to which you want to connect. When connecting to an ODBC source, this argument can also be the name of a Data Source Name (DSN).</td>
</tr>
<tr>
<td valign="top"><I>DSN</I></td>
<td valign="top">An ODBC source name registered on the current machine; this argument can replace the <I>Data Source</I> argument.</td>
</tr>
<tr>
<td valign="top"><I>Filename</I></td>
<td valign="top">A file that contains information about the connection; this argument can be an ODBC DSN file or a Microsoft Data Link (UDL) file.</td>
</tr>
<tr>
<td valign="top"><I>Initial Catalog</I></td>
<td valign="top">The name of the default database. When connecting to an ODBC source, you can also use the <I>Database</I> argument.</td>
</tr>
<tr>
<td valign="top"><I>Password</I></td>
<td valign="top">The user's password. When connecting to an ODBC source, you can use the <I>PWD</I> argument. You don't need to pass your user ID and password if you're connecting to SQL Server and you use integrated security.</td>
</tr>
<tr>
<td valign="top"><I>Persist Security Info</I></td>
<td valign="top">True if ADO stores the user ID and the password in the data link.</td>
</tr>
<tr>
<td valign="top"><I>Provider</I></td>
<td valign="top">The name of the OLE DB provider; the default value is MSDASQL, the provider for ODBC sources.</td>
</tr>
<tr>
<td valign="top"><I>User ID</i></td>
<td valign="top">The user's name. When connecting to an ODBC source, you can use the UID argument instead.</td>
</tr>
</table></p>

<p>The <I>DefaultDatabase </I>property is the name of the default database for the connection. Many ADO dialog boxes refer to this property with the name Initial Catalog. This property isn't available until the connection has been opened, and it's read-only afterward.</p>

<p>The Connection object exposes two properties that let you tailor your application to the speed of the network and the database server. The <I>ConnectionTimeout</I> property specifies the number of seconds that ADO will wait before raising a timeout error when trying to establish a connection. (The default value is 15 seconds.) The <I>CommandTimeout </I>property specifies the number of seconds that ADO waits for a database command or a query to complete. (The default is 30 seconds.) This value is used for all the queries performed on the Connection object only; it isn't inherited by a Command object that uses the same connection. (A Command object is affected only by its own <I>CommandTimeout </I>property.)</p>

<p>
<A HREF="javascript:fullSize('F13ph03x.htm')"> <img src="images/F13ph03.JPG" width=404 height=297 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 13-3.</B> <i>You can interactively create a connection string using the custom property pages of an ADO Data control. The All page gathers all the custom properties exposed by the selected OLE DB provider (SQLOLEDB in this case).</i><!--/caption-->
</p>

<p>The <I>CursorLocation </I>property specifies whether a cursor is to be created, and if so, where. The possible values for this property are 2-adUseServer for server-side or driver-supplied cursors and 3-adUseClient for client-side cursors, including dissociated Recordsets. (Dissociated Recordsets are those that aren't associated with an active Connection object.)</p>

<p>The <I>Mode </I>property indicates the permissions on the connection. It can take a  value from the following list:</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">1-adModeRead</td>
<td valign="top">Allows read-only data access</td>
</tr>
<tr>
<td valign="top">2-adModeWrite</td>
<td valign="top">Allows write-only data access</td>
</tr>
<tr>
<td valign="top">3-adModeReadWrite</td>
<td valign="top">Allows both read and write data access</td>
</tr>
<tr>
<td valign="top">4-adModeShareDenyRead</td>
<td valign="top">Prevents other clients from opening a connection with read permissions</td>
</tr>
<tr>
<td valign="top">8-adModeShareDenyWrite</td>
<td valign="top">Prevents other clients from opening a connection with write permissions</td>
</tr>
<tr>
<td valign="top">12-adModeShareExclusive</td>
<td valign="top">Prevents other clients from opening a connection to the same data source</td>
</tr>
<tr>
<td valign="top">16-adModeShareDenyNone</td>
<td valign="top">Allows other clients to open a connection with any permissions</td>
</tr>
</table></p>

<p>If you don't assign a value to this property, it defaults to 0-adModeUnknown. You can write to this property only when the connection is closed; on an open connection, this property is read-only.</p>

<A NAME="552"><h3>Managing transactions</h3></A>
<p>The <I>IsolationLevel</I> property affects how transactions are executed in the connection. This is a bit-field property that can be the sum of one or more of the following values:</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">&amp;H10-adXactChaos</td>
<td valign="top">You can't overwrite pending changes from more highly isolated transactions.</td>
</tr>
<tr>
<td valign="top">&amp;H100-adXactBrowse</td>
<td valign="top">You can view changes in other transactions even before they are committed.</td>
</tr>
<tr>
<td valign="top">&amp;H1000-adXactCursorStability</td>
<td valign="top">You can't view changes in other transactions until they have been committed.</td>
</tr>
<tr>
<td valign="top">&amp;H10000-adXactRepeatableRead</td>
<td valign="top">You can't see changes in other transactions, but you will see them if you repeat the query.</td>
</tr>
<tr>
<td valign="top">&amp;H100000-adXactIsolated</td>
<td valign="top">Transactions are isolated from other transactions.</td>
</tr>
<tr>
<td valign="top">-1-adXactUnspecified</td>
<td valign="top">The isolation level can't be determined.</td>
</tr>
</table></p>

<p>The <I>IsolationLevel </I>property is read/write, but any change you make to its value will take effect only when the next <I>BeginTrans</I> method is issued. Providers don't necessarily support all the isolation levels listed previously: If you request an unsupported isolation level, the provider usually enforces the next greater level.</p>

<p>The <I>Attributes </I>property contains two bits that affect what happens when a transaction is committed or rolled back. The bit &amp;H20000-adXactCommitRetaining automatically starts a new transaction after every <I>CommitTrans </I>method, and the bit &amp;H40000-adXactAbortRetaining starts a new transaction after every <I>RollbackTrans </I>method. Not all providers allow you to automatically start a new transaction after every <I>CommitTrans </I>and <I>RollbackTrans </I>method, however.</p>

<A NAME="553"><h3>Testing the state and the version</h3></A>
<p>The <I>State </I>property is a read-only, bit-field property that reports the current state of the connection. It can be the sum of one or more of the following values:</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">0-adStateClosed</td>
<td valign="top">The connection is closed.</td>
</tr>
<tr>
<td valign="top">1-adStateOpen</td>
<td valign="top">The connection is open.</td>
</tr>
<tr>
<td valign="top">2-adStateConnecting</td>
<td valign="top">The connection is being opened.</td>
</tr>
<tr>
<td valign="top">4-adStateExecuting</td>
<td valign="top">The connection is executing a command.</td>
</tr>
<tr>
<td valign="top">8-adStateFetching</td>
<td valign="top">A Recordset is being retrieved.</td>
</tr>
</table></p>

<p>You should query this property when you aren't sure about a Connection object's state because when the object is closed or is fetching data, many of its properties aren't usable.</p>

<p>The last property of the Connection object, <I>Version</I>, returns a read-only string that identifies the version of ADO in use. For example, under ADO 2.0, this property returns &quot;2.0.&quot;</p>

<A NAME="554"><h2>Methods</h2></A>
<p>The methods of the Connection object let you do four things: open a connection, run a command, manage transactions on the active connection, and determine the structure of the database tables.</p>

<A NAME="555"><h3>Establishing the connection</h3></A>
<p>The most important method of the Connection object is <I>Open</I>, which establishes the connection. Its syntax is as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Open [ConnectionString], [UserID], [Password], [Options]
</pre>
</td></tr></table></p>

<p>The first argument has the same meaning as the <I>ConnectionString</I> property, <I>UserID </I>is the user's login name, and <I>Password </I>is the user's password. If <I>Options </I>is set to 16-adAsyncConnect, the connection is opened in asynchronous mode and it won't be available until the <I>ConnectComplete </I>event fires. All arguments are optional, but if you pass the <I>UserID </I>and <I>Password </I>arguments, you shouldn't specify them also in the <I>ConnectionString </I>argument or property. For example, the following statement opens an asynchronous connection to the Pubs database of SQL Server and specifies the &quot;sa&quot; user name with a blank password:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim cn As New ADODB.Connection
cn.Open &quot;Provider=SQLOLEDB;Data Source=MyServer;Initial Catalog=Pubs;&quot; _
    &amp; &quot;User ID=sa;Password=;&quot;, , , adAsyncConnect
</pre>
</td></tr></table></p>

<p>You close an open connection using the <I>Close </I>method, which takes no arguments.</p>

<A NAME="556"><h3>Executing database commands and queries</h3></A>
<p>The <I>Execute </I>method performs an action query or a select query on the connection. The syntax of this method depends on the type of the action; if you're executing an action that doesn't return a Recordset (for example, an INSERT, UPDATE, or DELETE SQL statement), this is the correct syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Execute CommandText, [RecordsAffected], [Options]
</pre>
</td></tr></table></p>

<p><I>CommandText </I>is the name of a stored procedure, a table, or the text of an SQL query. <I>RecordsAffected</I> is a Long variable that receives the number of records that have been affected by the command. <I>Options </I>is an enumerated value that indicates how the string in <I>CommandText </I>should be interpreted and can be one of the following constants:</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">1-adCmdText</td>
<td valign="top">The text of an SQL query</td>
</tr>
<tr>
<td valign="top">2-adCmdTable</td>
<td valign="top">A database table</td>
</tr>
<tr>
<td valign="top">4-adCmdStoredProc</td>
<td valign="top">A stored procedure</td>
</tr>
<tr>
<td valign="top">8-adCmdUnknown</td>
<td valign="top">Unspecified; the provider will determine the correct type</td>
</tr>
<tr>
<td valign="top">512-adCmdTableDirect</td>
<td valign="top">A database table that should be opened directly (an operation that you should avoid on SQL Server databases)</td>
</tr>
</table></p>

<p>If you pass the value adCmdUnknown or omit the <I>Options </I>argument, the OLE DB provider is usually able to find out the type of the operation, but at the expense of some overhead. For this reason, you should always pass a correct value in this argument.</p>

<p>If you're executing a command that returns a Recordset, the syntax of the <I>Execute </I>method is slightly different:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Execute(CommandText, [RecordsAffected], [Options]) As Recordset
</pre>
</td></tr></table></p>

<p>You should assign the result of this method to a Recordset object so that you can later browse the results. The <I>Execute </I>command can create Recordset objects with default settings only&#8212;that is, read-only, forward-only Recordsets with the cache size equal to 1.</p>

<p>You can perform asynchronous commands by adding the 16-adAsyncExecute constant to the <I>Options </I>argument. You might also decide to populate the Recordset asynchronously by adding the value 32-adAsyncFetch. Whether or not you've specified an asynchronous option, an <I>ExecuteComplete </I>event is raised in your code when the <I>Execute </I>command completes.</p>

<p>You can cancel an asynchronous operation any time by issuing the <I>Cancel </I>method. This method doesn't take any arguments. You never need to specify which operation you want to cancel because only one asynchronous operation can be active on a given connection.</p>

<A NAME="557"><h3>Starting and committing transactions</h3></A>
<p>The <I>BeginTrans</I>, <I>CommitTrans</I>,<I> </I>and <I>RollbackTrans </I>methods let you control when a transaction begins and ends. You start a transaction by issuing a <I>BeginTrans </I>method:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>level = cn.BeginTrans
</pre>
</td></tr></table></p>

<p>This method returns the transaction level: 1 for top-level transactions that aren't nested in any other transactions, 2 for transactions nested in a top-level transaction, and so on. The <I>BeginTrans</I>, <I>CommitTrans</I>, and <I>RollbackTrans </I>methods all return an error if the provider doesn't support transactions. You can find out if the provider supports transactions by checking whether the Connection object exposes a custom property named <I>Transaction DDL</I>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>On Error Resume Next
value = cn.Properties(&quot;Transaction DDL&quot;) 
If Err = 0 Then
    level = cn.BeginTrans
    If level = 1 Then
        MsgBox &quot;A top-level transaction has been initiated&quot;
    Else
        MsgBox &quot;A nested transaction has been initiated&quot;
    End If
Else
    MsgBox &quot;This provider doesn't support transactions&quot;
End If
</pre>
</td></tr>
</table></p>

<p>The <I>CommitTrans </I>method commits the current transaction&#8212;that is, it makes all the changes in the database permanent. Conversely, the <I>RollbackTrans </I>method rolls back the current transaction, thus undoing all changes that the code performed while the transaction was active. You can be certain that a <I>CommitTrans </I>method permanently writes data to the database only if the transaction is a top-level transaction: In all other cases, the current transaction is nested in another transaction that could be rolled back.</p>

<p>The value of the <I>Attributes </I>property affects what happens when you commit or roll back a transaction. If the <I>Attributes </I>property has the adXactCommitRetaining bit set, the provider automatically starts a new transaction immediately after a <I>CommitTrans </I>method; if the <I>Attributes</I> property has the adXactAbortRetaining bit set, the provider starts a new transaction after every <I>RollbackTrans </I>method.</p>

<A NAME="558"><h3>Determining the structure of database tables</h3></A>
<p>The only method I haven't described yet is <I>OpenSchema</I>. This method queries a data source and returns a Recordset that contains information on its structure (table names, field names, and so on). I don't expect that you'll use this method often, however, because ADO 2.1 specifications extend the ADO object model with items that let you get information about the structure of a data source using a less cryptic object-oriented approach, as I explain at the end of this chapter. If you do use this method, be aware of a bug: It doesn't work with server-side Recordsets, which unfortunately are the default in ADO. Therefore, if you use the <I>OpenSchema </I>method, remember to set the Connection's <I>CursorLocation </I>property to adUseClient before opening a Recordset.</p>

<A NAME="559"><h2>Events</h2></A>
<p>The Connection object exposes nine events. Not all the events have the same syntax, but a few patterns do recur, and it makes more sense to describe the patterns than to examine each event individually.</p>

<p>Most ADO events are grouped in pairs. For example, the Connection object exposes the <I>WillConnect </I>and <I>ConnectComplete</I> events, which fire immediately before and immediately after a connection is established, respectively. Another pair, <I>WillExecute </I>and <I>ExecuteComplete</I>, lets you run code immediately before a command is executed on the connection and immediately after it has completed. The key to these <I>Will</I>xxxx and xxxx<I>Complete </I>events is the <I>adStatus </I>parameter.</p>

<p>On entry to a <I>Will</I>xxxx event, this parameter can be 1-adStatusOK (no errors), 2-adStatusErrorsOccurred (an error has occurred), or 3-adStatusCantDeny (no errors, and the operation can't be canceled). Your event procedure can modify the value of the <I>adStatus</I> parameter to 4-adStatusCancel if you want to cancel the operation or 5-adStatusUnwantedEvent if you don't want to receive the event from the ADO object any longer. You can't use the adStatusCancel value if the event procedure receives <I>adStatus </I>equal to adStatusCantDeny.</p>

<p>The same status values are used for xxxx<I>Complete</I> events, but in this case, the operation has already been completed so you can't set <I>adStatus </I>to adStatusCancel. Even if you cancel an operation in the <I>Will</I>xxxx event, the corresponding xxxx<I>Complete</I> event will fire, but it will receive the value adStatusCancel in <I>adStatus</I>. When you cancel an operation, the program receives error 3712, &quot;Operation canceled by the user,&quot; even if you reset the Errors collection or the <I>adStatus </I>argument while inside the xxxx<I>Complete</I> event procedure.</p>

<p>You'll see that many ADO events receive in their last parameter a pointer to the object that's raising the event. This argument is never necessary in Visual Basic: Because you can trap only events coming from individual objects, you must already have a reference to the object itself. In other languages&#8212;for example, Microsoft Visual C++&#8212;you can write event procedures that trap events raised from multiple objects, in which case the object reference is necessary to figure out where the event comes from.</p>

<A NAME="560"><h3>Connection events</h3></A>
<p>Let's take a quick look at the events of the Connection object. The <I>WillConnect </I>event fires when an <I>Open </I>method has been attempted on the connection. It receives the four arguments passed to the <I>Open </I>method plus the <I>adStatus </I>parameter and a pointer to the Connection object itself:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cn_WillConnect(ConnectionString As String, UserID As String, _
    Password As String, Options As Long, _
    adStatus As ADODB.EventStatusEnum, _
    ByVal pConnection As ADODB.Connection)
</pre>
</td></tr></table></p>

<p>You can use this method to modify the connection string, the user ID, or the password on the fly. When a connect operation is completed&#8212;whether or not it succeeded&#8212;the Connection object raises a <I>ConnectComplete </I>event, which receives an Error object and the ubiquitous <I>adStatus </I>parameter:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cn_ConnectComplete(ByVal pError As ADODB.error, _
    adStatus As ADODB.EventStatusEnum, _
    ByVal pConnection As ADODB.Connection)
</pre>
</td></tr></table></p>

<p>The Connection object also exposes the <I>Disconnect </I>event, which (obviously) fires when the connection is closed:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cn_Disconnect(adStatus As ADODB.EventStatusEnum, _
    pConnection As Connection)
</pre>
</td></tr></table></p>

<p>Setting the <I>adStatus </I>parameter to adStatusUnwantedEvent has no effect on <I>ConnectComplete </I>and <I>Disconnect </I>events.</p>

<A NAME="561"><h3>Execution events</h3></A>
<p>The <I>WillExecute </I>event fires before any command is attempted on the connection:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cn_WillExecute(Source As String, _
    CursorType As ADODB.CursorTypeEnum, LockType As ADODB.LockTypeEnum, _
    Options As Long, adStatus As ADODB.EventStatusEnum, _
    ByVal pCommand As ADODB.Command, _
    ByVal pRecordset As ADODB.Recordset, _
    ByVal pConnection As ADODB.Connection)
</pre>
</td></tr></table></p>

<p><I>Source </I>is an SQL string or the name of a stored procedure. <I>CursorType </I>identifies the type of cursor. (For more information about the <I>CursorType </I>property of the Recordset object, see the &quot;<A HREF="ch13c.htm#568">Working with Cursors</A>&quot; section later in this chapter.) <I>LockType </I>is the type of lock to be enforced on the returned Recordset. (See the <I>LockType</I> property of the Recordset object.) <I>Options </I>corresponds to the argument with the same name that was passed to the <I>Execute</I> method. If the command won't return a Recordset, then <I>CursorType </I>and <I>LockType </I>parameters are set to -1. Because all these parameters are passed by reference, you can modify them if you want to. The last three arguments are pointers to the Connection, Command, and Recordset objects that are the source of the event. The <I>pConnection</I> parameter always points to the active Connection object. This event fires whenever a Connection's <I>Execute</I> method, a Command's <I>Execute </I>method, or a Recordset's <I>Open </I>method is attempted.</p>

<p>The <I>ExecuteComplete</I> event fires when the execution of a stored procedure or an SQL query comes to an end:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cn_ExecuteComplete(ByVal RecordsAffected As Long, _
    ByVal pError As ADODB.error, adStatus As ADODB.EventStatusEnum, _
    ByVal pCommand As ADODB.Command, ByVal pRecordset As ADODB.Recordset, _
    ByVal pConnection As ADODB.Connection)
</pre>
</td></tr>
</table></p>

<p><I>RecordsAffected </I>is the number of records that have been affected by the operation (the same value that is returned in the <I>Execute </I>method's second argument). <I>pError </I>and <I>adStatus </I>have the usual meanings. The last three parameters are pointers to the objects that are raising the event.</p>

<A NAME="562"><h3>Transaction events</h3></A>
<p>The <I>BeginTransComplete </I>event fires when a <I>BeginTrans </I>method has completed its execution. The first parameter contains the value that is about to be returned to the program&#8212;that is, the level of the transaction just initiated. The meanings of all the other arguments should be self-explanatory.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cn_BeginTransComplete(ByVal TransactionLevel As Long, _
    ByVal pError As ADODB.error, adStatus As ADODB.EventStatusEnum, _
    ByVal pConnection As ADODB.Connection)
</pre>
</td></tr></table></p>

<p>The syntax of the <I>CommitTransComplete</I> and <I>RollbackTransComplete</I> events is similar to that of <I>BeginTransComplete</I>, but no information about the transaction level is passed to the event:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cn_CommitTransComplete(ByVal pError As ADODB.error, adStatus _
    As ADODB.EventStatusEnum, ByVal pConnection As ADODB.Connection)

Private Sub cn_RollbackTransComplete(ByVal pError As ADODB.error, adStatus 
    As ADODB.EventStatusEnum, ByVal pConnection As ADODB.Connection)
</pre>
</td></tr></table></p>

<A NAME="563"><h3>Other events</h3></A>
<p>The only other event exposed by the Connection object is <I>InfoMessage</I>. This event fires when the database engine sends a message or a warning or when a stored procedure executes a PRINT or RAISERROR SQL statement:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cn_InfoMessage(ByVal pError As ADODB.error, adStatus As _
    ADODB.EventStatusEnum, ByVal pConnection As ADODB.Connection)
</pre>
</td></tr></table></p>

<p>In most cases, you'll want to test the <I>pError </I>parameter or examine the elements in the Errors collection to understand what exactly happened.</p>

<A NAME="564"><h2>The Errors Collection</h2></A>
<p>The Connection object exposes the <I>Errors </I>property, which returns a collection of all the errors that have occurred on the connection itself. More precisely, each time an error occurs, the Errors collection is cleared and then filled with the errors raised by all the layers that sit between your program and the data source, including the ODBC driver (if you're using the MSDASQL OLE DB Provider) and the database engine itself. You can examine all the items in this collection to find out where the error originated and how the layers have interpreted it. You won't find ADO errors&#8212;for example, the errors that occur when you pass an invalid value to an ADO property or method&#8212;in this collection, because those errors are considered to be regular Visual Basic errors and should be managed by a standard error-trapping handler.</p>

<p>Each Error object in the collection exposes several properties that let you understand what exactly went wrong. The <I>Number</I>,<I> Description</I>, <I>HelpFile</I>, and <I>HelpContext </I>properties have the same meanings as they do in the Visual Basic Error object. The <I>Source </I>property is especially important if you want to track down where the error occurred. The <I>SQLState</I> and <I>NativeError </I>properties return information about errors in SQL data sources. An ODBC source returns errors as defined in the ODBC 3 specifications.</p>

<p>ADO clears the Errors collection when the code executes the <I>Clear </I>method. ADO clears the Errors collection of the Connection object, however, only when an error actually occurs. For this reason, you might find it convenient to manually clear the collection before invoking methods of the Connection object that can potentially raise errors.</p>

</BODY>
</HTML>





