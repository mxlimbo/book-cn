<HTML>
<HEAD>
<TITLE>TextBox Controls</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch03a.htm", "ch03c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="69"><h1>TextBox Controls</h1></A>

<p>TextBox controls offer a natural way for users to enter a value in your program. 
For this reason, they tend to be the most frequently used controls in the majority 
of Windows applications. TextBox controls, which have a great many properties 
and events, are also among the most complex intrinsic controls. In this section, I 
guide you through the most useful properties of TextBox controls and show how to 
solve some of the problems that you're likely to encounter.</p>

<p>After you place a TextBox control on a form, you must set a few basic 
properties. The first thing I do as soon as I create a new TextBox control is clear its 
<I>Text</I>property. If this is a multiline field, I also set the 
<I>MultiLine</I>property to True.</p>

<p>You can set the <I>Alignment</I> property of TextBox controls to left align, right 
align, or center the contents of the control. Right-aligned TextBox controls are 
especially useful when you're displaying numeric values. But you should be aware of the 
following quirk: while this property always works correctly when the 
<I>Multiline</I> property is set to True, it works with single-line controls only under Microsoft Windows 
98, Microsoft Windows NT 4 with Service Pack 3, or later versions. Under previous 
versions of Windows 9<I>x</I> or Windows NT, no error is raised but single-line TextBox 
controls ignore the <I>Alignment</I> property and always align their contents to the left.</p>

<p>You can prevent the user from changing the contents of a TextBox control 
by setting its <I>Locked</I>property to True. You usually do this if the control contains the 
result of a calculation or displays a field taken from a database opened in read-only 
mode. In most cases, you can achieve the same result using a Label control with a 
border and white background, but a locked TextBox control also permits your users to 
copy the value to the Clipboard and scroll through it if it's too large for the field's width.</p>

<p>If you're dealing with a numeric field, you probably want to set a limit on 
the number of characters that the user can enter in the field. You can do it very 
easily using the <I>MaxLength </I>property. A 0 value (the default) means that you can enter 
any number of characters; any positive value 
<I>N</I> enforces a limit to the length of the 
field's contents to be <I>N</I> characters long.</p>

<p>If you're creating password fields, you should set the 
<I>PasswordChar</I> property to a character string, typically an asterisk. In this case, your program can read and 
modify the contents of this TextBox control as usual, but users see only a row of asterisks.</p>

<P><DIV CLASS="CAUTION"><BLOCKQUOTE><B>CAUTION</B><HR>
Password-protected TextBox controls effectively disable the 
Ctrl+X and Ctrl+C keyboard shortcuts, so malicious users can't steal a password 
entered by another user. If, however, your application includes an Edit menu 
with all the usual clipboard commands, it's up to you to disable the Copy and Cut 
commands when the focus is on a password-protected field.
</blockquote></div></P>

<p>You can set other properties for a better appearance of the control&#8212;the 
<I>Font</I> property, for example. In addition, you can set the 
<I>ToolTipText</I> property to help users understand what the TextBox control is for. You can also make borderless 
TextBox controls by setting their 
<I>BorderStyle</I> property to 0-None, but controls like these 
don't appear frequently in Windows applications. In general, you can't do much else 
with a TextBox control at design time. The most interesting things can be done 
only through code.</P>

<A NAME="70"><h2>Run-Time Properties</h2></A>

<p>The <I>Text</I> property is the one you'll reference most often in code, and 
conveniently it's the default property for the TextBox control. Three other frequently used 
properties are these:</P>
<UL>

<p><li> The <I>SelStart </I>property sets or returns the position of the blinking 
<I>caret</I> (the insertion point where the text you type appears). Note that the 
blinking cursor inside TextBox and other controls is named 
<I>caret</I>, to distinguish it from the <I>cursor 
</I>(which is implicitly the mouse cursor). When the caret 
is at the beginning of the contents of the TextBox control, 
<I>SelStart</I> returns 0; when it's at the end of the string typed by the user, 
<I>SelStart</I> returns the value <I>Len(Text)</I>. You can modify the 
<I>SelStart </I>property to programmatically move the caret.</li></p>

<p><li> The <I>SelLength </I>property returns the number of characters in the portion 
of text that has been highlighted by the user, or it returns 0 if there's 
no highlighted text. You can assign a nonzero value to this property to 
programmatically select text from code. Interestingly, you can assign to 
this property a value larger than the current text's length without raising a 
run-time error.</li></p>

<p><li> The <I>SelText</I> property sets or returns the portion of the text that's 
currently selected, or it returns an empty string if no text is highlighted. Use it 
to directly retrieve the highlighted text without having to query 
<I>Text</I>, <I>SelStart</I>, and <I>SelLength</I> properties. What's even more interesting is that you 
can assign a new value to this property, thus replacing the current 
selection with your own. If no text is currently selected, your string is simply 
inserted at the current caret position.</li></p>
</UL>
 
<P><DIV CLASS="TIP"><BLOCKQUOTE><B>TIP</B><HR>
When you want to append text to a TextBox control, you should use 
the following code (instead of using the concatenation operator) to reduce 
flickering and improve performance:

<P><TABLE><TR><TD>
<PRE>
Text1.SelStart = Len(Text1.Text)
Text1.SelText = StringToBeAdded
</PRE></TD></TR></TABLE></P>
</blockquote></div></P>

<p>One of the typical operations you could find yourself performing with 
these properties is selecting the entire contents of a TextBox control. You often do it 
when the caret enters the field so that the user can quickly override the existing value 
with a new one, or start editing it by pressing any arrow key:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Text1_GotFocus()
    Text1.SelStart = 0 
    ' A very high value always does the trick.
    Text1.SelLength = 9999
End Sub
</pre>
</td></tr>
</table>
</P>

<p>Always set the <I>SelStart</I> property first and then the 
<I>SelLength</I> or <I>SelText</I> properties. When you assign a new value to the 
<I>SelStart</I> property, the other two are automatically reset to 0 and an empty string respectively, thus overriding your 
previous settings.</P>

<A NAME="71"><h2>Trapping Keyboard Activity</h2></A>

<p>TextBox controls support <I>KeyDown</I>, 
<I>KeyPress</I>, and <I>KeyUp</I> standard events, 
which <a href="ch02a.htm">Chapter 2</a> covered. One thing that you will often do is prevent the user from 
entering invalid keys. A typical example of where this safeguard is needed is a 
numeric field, for which you need to filter out all nondigit keys:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Text1_KeyPress(KeyAscii As Integer)
    Select Case KeyAscii
        Case Is &lt; 32               ' Control keys are OK.
        Case 48 To 57              ' This is a digit.
        Case Else                  ' Reject any other key.
            KeyAscii = 0
    End Select
End Sub
</pre>
</td></tr>
</table>
</P>

<p>You should never reject keys whose ANSI code is less than 32, a group 
that includes important keys such as Backspace, Escape, Tab, and Enter. Also note that 
a few control keys will make your TextBox beep if it doesn't know what to do 
with them&#8212;for example, a single-line TextBox control doesn't know what to do with 
an Enter key.</P>


<P><DIV CLASS="CAUTION"><BLOCKQUOTE><B>CAUTION</B><HR>Don't assume that the 
<I>KeyPress</I> event will trap all control keys 
under all conditions. For example, the 
<I>KeyPress</I> event can process the Enter key 
only if there's no CommandButton control on the form whose 
<I>Default</I> property is set to True. If the form has a default push button, the effect of pressing the 
Enter key is clicking on that button. Similarly, no Escape key goes through this 
event if there's a Cancel button on the form. Finally, the Tab control key is trapped 
by a <I>KeyPress</I> event only if there isn't any other control on the form whose 
<I>TabStop </I>property is True.
</blockquote></div></P>

<p>You can use the <I>KeyDown</I> event procedure to allow users to increase 
and decrease the current value using Up and Down arrow keys, as you see here:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Text1_KeyDown(KeyCode As Integer, Shift As Integer)
    Select Case KeyCode
        Case vbKeyUp
            Text1.Text = CDbl(Text1.Text) + 1
        Case vbKeyDown
            Text1.Text = CDbl(Text1.Text)  -1
    End Select
End Sub
</pre>
</td></tr>
</table>
</P>

<p><div class="note"><blockquote><b>NOTE</b><hr>
There's a bug in the implementation of TextBox ready-only 
controls. When the <I>Locked</I> property is set to True, the Ctrl+C key combination 
doesn't correctly copy the selected text to the Clipboard, and you must manually 
implement this capability by writing code in the 
<I>KeyPress</I> event procedure.
</blockquote></div></P>

<A NAME="72"><h2>Validation Routines for Numbers</h2></A>

<p>Although trapping invalid keys in the 
<I>KeyPress</I> or <I>KeyDown</I> event procedures 
seems a great idea at first, when you throw your application to inexperienced users you 
soon realize that there are many ways for them to enter invalid data. Depending on 
what you do with this data, your application can come to an abrupt end with a 
run-time error or&#8212;much worse&#8212;it can appear to work correctly while it delivers bogus 
results. What you really need is a bullet-proof method to trap invalid values.</P>

<p>Before I offer you a decent solution to the problem, let me explain why 
you can't rely solely on trapping invalid keys for your validation chores. What if the 
user pastes an invalid value from the clipboard? Well, you might say, let's trap the 
Ctrl+V and Shift+Ins key combinations to prevent the user from doing that! 
Unfortunately, Visual Basic's TextBox controls offer a default edit menu that lets users perform 
any clipboard operation by simply right-clicking on them. Fortunately, there's a 
way around this problem: Instead of trapping a key 
<I>before </I>it gets to the TextBox control, you trap its effect in the 
<I>Change</I> event and reject it if it doesn't pass your test. 
But this makes the structure of the code a little more complex than you might anticipate:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Form-level variables
Dim saveText As String
Dim saveSelStart As Long

Private Sub Text1_GotFocus()
    ' Save values when the control gets the focus.
    saveText = Text1.Text
    saveSelStart = Text1.SelStart
End Sub

Private Sub Text1_Change()
    ' Avoid nested calls.
    Static nestedCall As Boolean
    If nestedCall Then Exit Sub

    ' Test the control's value here.
    If IsNumeric(Text1.Text) Then
        ' If value is OK, save values.
        saveText = Text1.Text
        saveSelStart = Text1.SelStart
    Else
        ' Prepare to handle a nested call. 
        nestedCall = True
        Text1.Text = saveText
        nestedCall = False
        Text1.SelStart = saveSelStart
    End If
End Sub

Private Sub Text1_KeyUp(KeyCode As Integer, Shift As Integer)
    saveSelStart = Text1.SelStart
End Sub
Private Sub Text1_MouseDown(Button As Integer, _
    Shift As Integer, X As Single, Y As Single)
    saveSelStart = Text1.SelStart
End Sub
Private Sub Text1_MouseMove(Button As Integer, _
    Shift As Integer, X As Single, Y As Single)
    saveSelStart = Text1.SelStart
End Sub
</pre>
</td></tr>
</table>
</P>

<p>If the control's value doesn't pass your tests in the 
<I>Chang</I>e event procedure, you must restore its previous valid value; this action recursively fires a 
<I>Change</I> event, and you must prepare yourself to neutralize this nested call. You might wonder 
why you also need to trap the <I>KeyUp</I>, 
<I>MouseDown</I>, and <I>MouseMove</I> events: The 
reason is that you always need to keep track of the last valid position for the insertion 
point because the end user could move it using arrow keys or the mouse.</P>
<P>The preceding code snippet uses the 
<I>IsNumeric</I> function to trap invalid data. You should be aware that this function isn't robust enough for most 
real-world applications. For example, the 
<I>IsNumeric</I> function incorrectly considers these 
strings as valid numbers:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>123,,,123
345-
$1234     ' What if it isn't a currency field?
2.4E10    ' What if I don't want to support scientific notation?
</pre>
</td></tr>
</table>
</P>

<p>To cope with this issue, I have prepared an alternative function, which you 
can modify for your particular purposes. (For instance, you can add support for a 
currency symbol or the comma as the decimal separator.) Note that this function 
always returns True when it's passed a null string, so you might need to perform 
additional tests if the user isn't allowed to leave the field blank:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function CheckNumeric(text As String, DecValue As Boolean) As Boolean
    Dim i As Integer
    For i = 1 To Len(text)
        Select Case Mid$(text, i, 1)
            Case &quot;0&quot; To &quot;9&quot;
            Case &quot;-&quot;, &quot;+&quot;
                ' Minus/plus signs are only allowed as leading chars.
                If i &gt; 1 Then Exit Function
            Case &quot;.&quot;
                ' Exit if decimal values not allowed.
                If Not DecValue Then Exit Function
                ' Only one decimal separator is allowed.
                If InStr(text, &quot;.&quot;) &lt; i Then Exit Function
            Case Else
                ' Reject all other characters.
                Exit Function
        End Select
    Next
    CheckNumeric = True
End Function
</pre>
</td></tr>
</table>
</P>

<p>If your TextBox controls are expected to contain other types of data, you 
might be tempted to reuse the same validation framework I showed you 
previously&#8212;including all the code in the 
<I>GotFocus</I>, <I>Change</I>, <I>KeyUp</I>, 
<I>MouseDown</I>, and <I>MouseMove </I>event procedures&#8212;and replace only the call to 
<I>IsNumeric</I> with a call to your custom validation routine. Things aren't as simple as they appear at first, however. 
Say that you have a date field: Can you use the 
<I>IsDate</I> function to validate it from within the 
<I>Change</I> event? The answer is, of course, no. In fact, as you enter the first digit 
of your date value, <I>IsDate</I> returns False and the routine therefore prevents you 
from entering the remaining characters, and so preventing you from entering 
<I>any</I> value.</P>
<P>This example explains why a <I>key-level</I> validation isn't always the best 
answer to your validation needs. For this reason, most Visual Basic programmers prefer 
to rely on <I>field-level </I>validation and test the values only when the user moves the 
input focus to another field in the form. I explain field-level validation in the next section.</P>

<A NAME="73"><H2>The <I>CausesValidation</I> Property and the <I>Validate</I> Event</H2></A>
<p>
<img src="images/new.jpg" width=102 height=87 border="0">
</p>

<p>Visual Basic 6 has finally come up with a solution for most of the validation 
issues that have afflicted Visual Basic developers for years. As you'll see in a moment, 
the Visual Basic 6 approach is simple and clean; it really astonishes me that it took 
six language versions to deliver such a lifesaver. The keys to the new validation 
features are the <I>Validate</I> event and the 
<I>CausesValidation</I> property. They work together 
as follows: When the input focus leaves a control, Visual Basic checks the 
<I>CausesValidation</I> property of the control that is about to receive the focus. If this 
property is True, Visual Basic fires the 
<I>Validate</I> event in the control that's about to lose 
the focus, thus giving the programmer a chance to validate its contents and, if 
necessary, cancel the focus shift.</P>

<p>Let's try a practical example. Imagine that you have five controls on a form: 
a required field (a TextBox control, txtRequired, that can't contain an empty string), 
a numeric field, txtNumeric, that expects a value in the range 1 through 1000, and 
three push buttons: OK, Cancel, and Help. (See Figure 3-1.) You don't want to 
perform validation if the user presses the Cancel or Help buttons, so you set their 
<I>CausesValidation</I> properties to False. The default value for this property is True, so you 
don't have to modify it for the other controls. Run the sample program on the 
companion CD, type something in the required TextBox, and then move to the second 
field. Because the second field's 
<I>CausesValidation</I> property is True, Visual Basic fires 
a <I>Validate</I> event in the first TextBox control:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub txtRequired_Validate(Cancel As Boolean)
    ' Check that field is not empty.
    If txtRequired.Text = &quot;&quot; Then
        MsgBox &quot;Please enter something here&quot;, vbExclamation
        Cancel = True
    End If
End Sub
</pre>
</td></tr>
</table>
</P>

<p>If the <I>Cancel</I> parameter is set to True, Visual Basic cancels the user's action 
and takes the input focus back on the txtRequired control: No other 
<I>GotFocus</I> and <I>LostFocus</I> events are generated. On the other hand, if you typed something in the 
required field, the focus will now be on the second field (the numeric text box). Try 
clicking on the Help or Cancel buttons: No 
<I>Validate</I> event will fire this time because you 
set the <I>CausesValidation</I> property for each of these controls to False. Instead, click 
on the OK button to execute the <I>Validate</I> event of the numeric field, where you can 
check it for invalid characters and valid range.</P>

<p>
<A HREF="javascript:fullSize('F03ph01x.htm')"> <img src="images/F03ph01.JPG" width=404 height=263 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 3-1.</B> <i>A demonstration program that lets you experiment with the new Visual Basic Validate features.</i><!--/caption-->
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub txtNumeric_Validate(Cancel As Boolean)
    If Not IsNumeric(txtNumeric.Text) Then
        Cancel = True
    ElseIf CDbl(txtNumeric.Text) &lt; 1 Or CDbl(txtNumeric.Text) &gt; 1000 Then
        Cancel = True
    End If
    If Cancel Then
        MsgBox &quot;Please enter a number in range [1-1000]&quot;, vbExclamation
    End If
End Sub
</pre>
</td></tr>
</table>
</P>

<p>In some circumstances, you might want to programmatically validate the 
control that has the focus without waiting for the user to move the input focus. You 
can do it with the form's 
<I>ValidateControls</I> method, which forces the 
<I>Validate </I>event of the control that has the input focus. Typically, you do it when the user closes the form:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_QueryUnload(Cancel As Integer, UnloadMode As Integer)
    ' You can't close this form without validating the current field.
    If UnloadMode = vbFormControlMenu Then
        On Error Resume Next
        ValidateControls
        If Err = 380 Then
            ' The current field failed validation.
            Cancel = True
        End If
    End If
End Sub
</pre>
</td></tr>
</table>
</P>

<p>Checking the <I>UnloadMode</I> parameter is important; otherwise, your 
application will mistakenly execute a 
<I>ValidateControls</I> method when the user clicks on the 
Cancel button. Note that <I>ValidateControls</I> returns an error 380 if Cancel was set in the 
<I>Validate</I> event procedure of the control that had the focus.</P>

<P><DIV CLASS="CAUTION"><BLOCKQUOTE><B>CAUTION</B><HR>Visual Basic 6's validation scheme has two flaws, though. If 
your form has a CommandButton whose <I>Default 
</I>property is set to True, pressing the Enter key while the input focus is on another control results in a click 
on the CommandButton control but doesn't fire a 
<I>Validate </I>event, even if the <I>CausesValidation 
</I>property of the CommandButton control is set to True. The 
only way to solve this problem is to invoke the 
<I>ValidateControls </I>method from within the default CommandButton control's 
<I>Click </I>event procedure.
<P>The second flaw is that the <I>Validate</I> event doesn't fire when you're 
moving the focus from a control whose 
<I>CausesValidation</I> property is False, even if the control that receives the focus has its 
<I>CausesValidation</I> property set to True.</P>
</BLOCKQUOTE></DIV></P>

<P>The new Visual Basic 6 validation mechanism is simple and can be 
implemented with little effort. But it isn't the magic answer to all your validation needs. In fact, 
this technique can only enforce <I>field-level 
</I>validation; it does nothing for <I>record-level 
</I>validation. In other words, it ensures that one particular field is correct, not that all 
fields in the form contain valid data. To see what I mean, run the demonstration 
program, enter a string in the first field, and press Alt+F4 to close the form. Your code 
won't raise an error, even if the second field doesn't contain a valid number! 
Fortunately, it doesn't take much to create a generic routine that forces each control on the 
form to validate itself:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_QueryUnload(Cancel As Integer, UnloadMode As Integer)
    ' You can't close this form without validating all the fields on it.
    If UnloadMode = vbFormControlMenu Then
        On Error Resume Next
        Dim ctrl As Control
        ' Give the focus to each control on the form, and then
        ' validate it.
        For Each ctrl In Controls
            Err.Clear
            ctrl.SetFocus
            If Err = 0 Then
                ' Don't validate controls that can't receive input focus.
                ValidateControls
                If Err = 380 Then
                    ' Validation failed, refuse to close.
                    Cancel = True: Exit Sub
                End If
            End If
        Next
    End If
End Sub
</pre>
</td></tr>
</table>
</P>

<p>The <I>CausesValidation</I> property and the 
<I>Validate</I> event are shared by all the intrinsic controls that are able to get the focus as well as by most external 
ActiveX controls, even those not specifically written for Visual Basic. This is possible 
because they are <I>extender features,</I> provided by the Visual Basic runtime to all the 
controls placed on a form's surface.</P>

<P><DIV CLASS="TIP"><BLOCKQUOTE><B>TIP</B><HR>One Visual Basic operator has great potential when it comes time to 
validate complex strings but is neglected by most Visual Basic developers. Let's 
say you have a product code that consists of two uppercase characters followed 
by exactly three digits. You might think that you need some complex string 
functions to validate such a string until you try the 
<I>Like</I> operator, as follows:<P>
If &quot;AX123&quot; Like &quot;[A-Z][A-Z]###&quot; Then Print &quot;OK&quot;
</P><P>See <a href="ch05a.htm">Chapter 5</a> for more information about the <I>Like</I> operator.</P>
</BLOCKQUOTE></DIV></P>



<A NAME="74"><h2>Auto-Tabbing Fields</h2></A>

<p>Users aren't usually delighted to spend all their time at the keyboard. Your job as 
a programmer is to make their jobs easier, and so you should strive to streamline 
their everyday work as much as possible. One way to apply this concept is to provide 
them with <I>auto-tabbing </I>fields, which are fields that automatically advance users to the 
next field in the Tab order as soon as they enter a valid value. Most often, 
auto-tabbing fields are those TextBox controls whose 
<I>MaxLength</I> property has been assigned a non-null value. Implementing such an auto-tabbing field in Visual Basic is straightforward:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Text1_Change()
    If Len(Text1.Text) = Text1.MaxLength Then SendKeys &quot;{Tab}&quot;
End Sub
</pre>
</td></tr>
</table>
</P>

<p>The trick, as you see, is to have your program provide the Tab key on 
behalf of your user. In some cases, this simple approach doesn't work&#8212;for example, 
when you paste a long string into the field. You might want to write code that works 
around this and other shortcomings. Auto-tabbing is a nice feature but not vital to the 
application, so whether you write a workaround or not isn't a real problem in most cases.</P>

<A NAME="75"><h2>Formatting Text</h2></A>

<p>Many business applications let you enter data in one format and then display it 
in another. For example, numeric values can be formatted with thousand separators 
and a fixed number of decimal digits. Currency values might have a $ symbol (or 
whatever your national currency symbol is) automatically inserted. Phone numbers 
can be formatted with dashes to split into groups of digits. Credit-card numbers can 
be made more readable with embedded spaces. Dates can be shown in 
<I>long-date</I> format (&quot;September 10, 1999&quot;). And so on.</P>

<P>The <I>LostFocus</I> event is an ideal occasion to format the contents of a 
TextBox control as soon as the input focus leaves it. In most cases, you can perform all 
your formatting chores using the <I>Format</I> function. For example, you can add 
thousand separators to a numeric value in the txtNumber control using this code:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub txtNumber_LostFocus()
    On Error Resume Next
    txtNumber.Text = Format(CDbl(txtNumber.Text), _
        &quot;#,###,###,##0.######&quot;)
End Sub
</pre>
</td></tr>
</table>
</P>


<p>When the field regains the focus, you'll want to get rid of those thousand 
separators. You can do it easily using the 
<I>CDbl</I> function:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub txtNumber_GotFocus()
    ' On Error is necessary to account for empty fields.
    On Error Resume Next
    txtNumber.Text = CDbl(txtNumber.Text)
End Sub
</pre>
</td></tr>
</table>
</P>


<p>In some cases, however, formatting and unformatting a value isn't that 
simple. For example, you can format a Currency value to add parentheses around 
negative numbers, but there's no built-in Visual Basic function able to return a string 
formatted in that way to its original condition. Fear not, because nothing prevents you 
from creating your own formatting and unformatting routines. I have built two 
general-purpose routines for you to consider.</P>
<P>The <I>FilterString</I> routine filters out all unwanted characters in a string:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function FilterString(Text As String, validChars As String) As String
    Dim i As Long, result As String
    For i = 1 To Len(Text)
        If InStr(validChars, Mid$(Text, i, 1)) Then
            result = result &amp; Mid$(Text, i, 1)
        End If
    Next
    FilterString = result
End Function
</pre>
</td></tr>
</table>
</P>


<p><I>FilterNumber </I>builds on 
<I>FilterString</I> to strip down all formatting characters in 
a number and can also trim trailing decimal zeros:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function FilterNumber(Text As String, TrimZeros As Boolean) As String
    Dim decSep As String, i As Long, result As String
    ' Retrieve the decimal separator symbol.
    decSep = Format$(0.1, &quot;.&quot;)
    ' Use FilterString for most of the work.
    result = FilterString(Text, decSep &amp; &quot;-0123456789&quot;)
    ' Do the following only if there is a decimal part and the
    ' user requested that nonsignificant digits be trimmed.
    If TrimZeros And InStr(Text, decSep) &gt; 0 Then
        For i = Len(result) To 1 Step -1
            Select Case Mid$(result, i, 1)
                Case decSep
                    result = Left$(result, i - 1)
                    Exit For
                Case &quot;0&quot;
                    result = Left$(result, i - 1)
                Case Else
                    Exit For
            End Select
        Next
    End If
    FilterNumber = result
End Function
</pre>
</td></tr>
</table>
</P>


<p>The feature I like most in <I>FilterNumber</I> is that it's 
<I>locale-independent.</I> It works equally well on both sides of the Atlantic ocean (and on other continents, as 
well.) Instead of hard-coding the decimal separator character in the code, the routine 
determines it on the fly, using the Visual Basic for Applications (VBA) 
<I>Format</I> function. Start thinking internationally now, and you won't have a nervous breakdown 
when you have to localize your applications in German, French, and Japanese.</P>

<P><DIV CLASS="TIP"><BLOCKQUOTE><B>TIP</B><HR>The 
<I>Format</I> function lets you retrieve many locale-dependent 
characters and separators.

<p><table><tr><td><PRE>
Format$(0.1, &quot;.&quot;)                           ' Decimal separator
Format$(1, &quot;,&quot;)                             ' Thousand separator
Mid$(Format(#1/1/99#, &quot;short date&quot;), 2, 1)  ' Date separator
</pre></td></tr></table>
</P>
<p>You can also determine whether the system uses dates in &quot;mm/dd/yy&quot;
(U.S.) format or &quot;dd/mm/yy&quot; (European) format, using this code:</P>
<p><table><tr><td><PRE>
If Left$(Format$(&quot;12/31/1999&quot;, &quot;short date&quot;), 2) = 12 Then
    ' mm/dd/yy format

Else
    ' dd/mm/yyyy format

End If
</pre></td></tr></table>
</P>
<P>There's no direct way to determine the currency symbol, but you can 
derive it by analyzing the result of this function:</P>
<p><table><tr><td><PRE>
Format$(0, &quot;currency&quot;)                      ' Returns &quot;$0.00&quot; in US
</pre></td></tr></table>
</P>
<P>It isn't difficult to write a routine that internally uses the information I've 
just given you to extract the currency symbol as well as its default position 
(before or after the number) and the default number of decimal digits in currency values. Remember, in some countries the currency symbol is actually a string of two or more characters.</P>
</BLOCKQUOTE></DIV></P>

<P>To illustrate these concepts in action, I've built a simple demonstration 
program that shows how you can format numbers, currency values, dates, phone 
numbers, and credit-card numbers when exiting a field, and how you can remove that 
formatting from the result when the input focus reenters the TextBox control. Figure 
3-2 shows the formatted results.</P>

<p>
<A HREF="javascript:fullSize('F03PH02x.htm')"> <img src="images/F03PH02.JPG" width=404 height=441 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 3-2.</B> <i>Formatting and unformatting the contents of TextBox controls makes for more professional-looking applications. </i><!--/caption-->
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub txtNumber_GotFocus()
    ' Filter out nondigit chars and trailing zeros.
    On Error Resume Next
    txtNumber.Text = FilterNumber(txtNumber.Text, True)
End Sub
Private Sub txtNumber_LostFocus()
    ' Format as a number, grouping thousand digits.
    On Error Resume Next
    txtNumber.Text = Format(CDbl(txtNumber.Text), _
        &quot;#,###,###,##0.######&quot;)
End Sub

Private Sub txtCurrency_GotFocus()
    ' Filter out nondigit chars and trailing zeros.
    ' Restore standard text color.
    On Error Resume Next
    txtCurrency.Text = FilterNumber(txtCurrency.Text, True)
    txtCurrency.ForeColor = vbWindowText
End Sub
Private Sub txtCurrency_LostFocus()
    On Error Resume Next
    ' Show negative values as red text.
    If CDbl(txtCurrency.Text) &lt; 0 Then txtCurrency.ForeColor = vbRed
    ' Format currency, but don't use parentheses for negative numbers.
    ' (FormatCurrency is a new VB6 string function.)
    txtCurrency.Text = FormatCurrency(txtCurrency.Text, , , vbFalse)
End Sub

Private Sub txtDate_GotFocus()
    ' Prepare to edit in short-date format.
    On Error Resume Next
    txtDate.Text = Format$(CDate(txtDate.Text), &quot;short date&quot;)
End Sub
Private Sub txtDate_LostFocus()
    ' Convert to long-date format upon exit.
    On Error Resume Next
    txtDate.Text = Format$(CDate(txtDate.Text), &quot;d MMMM yyyy&quot;)
End Sub

Private Sub txtPhone_GotFocus()
    ' Trim embedded dashes.
    txtPhone.Text = FilterString(txtPhone.Text, &quot;0123456789&quot;)
End Sub
Private Sub txtPhone_LostFocus()
    ' Add dashes if necessary.
    txtPhone.Text = FormatPhoneNumber(txtPhone.Text)
End Sub

Private Sub txtCreditCard_GotFocus()
    ' Trim embedded spaces.
    txtCreditCard.Text = FilterNumber(txtCreditCard.Text, True)
End Sub
Private Sub txtCreditCard_LostFocus()
    ' Add spaces if necessary.
    txtCreditCard.Text = FormatCreditCard(txtCreditCard.Text)
End Sub
</pre>
</td></tr>
</table>
</P>


<p>Instead of inserting the code that formats phone numbers and credit-card 
numbers right in the <I>LostFocus </I>event procedures, I built two distinct routines, which 
can be more easily reused in other applications, as shown in the code 	below.</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function FormatPhoneNumber(Text As String) As String
    Dim tmp As String
    If Text &lt;&gt; &quot;&quot; Then
        ' First get rid of all embedded dashes, if any.
        tmp = FilterString(Text, &quot;0123456789&quot;)
        ' Then reinsert them in the correct position.
        If Len(tmp) &lt;= 7 Then
            FormatPhoneNumber = Format$(tmp, &quot;!@@@-@@@@&quot;)
        Else
            FormatPhoneNumber = Format$(tmp, &quot;!@@@-@@@-@@@@&quot;)
        End If
    End If
End Function

Function FormatCreditCard(Text As String) As String
    Dim tmp As String
    If Text &lt;&gt; &quot;&quot; Then
        ' First get rid of all embedded spaces, if any.
        tmp = FilterNumber(Text, False)
        ' Then reinsert them in the correct position.
        FormatCreditCard = Format$(tmp, &quot;!@@@@ @@@@ @@@@ @@@@&quot;)
    End If
End Function
</pre>
</td></tr>
</table>
</P>


<p>Unfortunately, there isn't any way to create locale-independent routines that 
can format any phone number anywhere in the world. But by grouping all your 
formatting routines in one module, you can considerably speed up your work if and 
when it's time to convert your code for another locale. <a href="ch05a.htm">Chapter 5</a> covers the 
<I>Format</I> function in greater detail.</p>

<A NAME="76"><h2>Multiline TextBox Controls</h2></A>

<p>You create multiline TextBox controls by setting the 
<I>MultiLine</I> property to True and the 
<I>ScrollBars</I> property to 2-Vertical or 3-Both. A vertical scroll bar causes the 
contents of the control to automatically wrap when a line is too long for the 
control's width, so this setting is most useful when you're creating memo fields or simple 
word processor-like programs. If you have both a vertical and a horizontal scroll bar, 
the TextBox control behaves more like a programmer's editor, and longer lines 
simply extend beyond the right border. I've never found a decent use for the other 
settings of the <I>ScrollBars</I> property (0-None and 1-Horizontal) in a multiline TextBox 
control. Visual Basic ignores the 
<I>ScrollBars</I> property if <I>MultiLine</I> is False.</p>
<p>Both these properties are read-only at run time, which means that you 
can't alternate between a regular and a multiline text box, or between a word 
processor-like multiline field (<I>ScrollBars</I> = 2-Vertical) and an editorlike field 
(<I>ScrollBars</I> = 3-Both). To tell the whole truth, Visual Basic's support for multiline TextBox controls 
leaves much to be desired. You can do very little with such controls at run time, except 
to retrieve and set their <I>Text</I> properties. When you read the contents of a 
multiline TextBox control, it's up to you to determine where each line of text starts and 
ends. You do this with a loop that searches for carriage return (CR) and line feed (LF) 
pairs, or even more easily using the new <I>Split 
</I>string function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Print the lines of text in Text1, labeling them with their line numbers.
Dim lines() As String, i As Integer
lines() = Split(Text1.Text, vbCrLf)
For i = 0 To UBound(lines)
    Print (i + 1) &amp; &quot;: &quot; &amp; lines(i)
Next
</pre>
</td></tr>
</table>
</P>


<p>The support offered by Visual Basic for multiline TextBox controls ends 
here. The language doesn't offer any means for learning such vital information as at 
which point each line of text wraps, which are the first visible line and the first 
visible column, which line and column the caret is on, and so on. Moreover, you have 
no means of programmatically scrolling through a multiline text box. 
The solutions to these problems require Microsoft Windows API programming, which I'll explain 
in the <a href="chaaa.htm">Appendix</a>. In my opinion, however, Visual Basic should offer these features 
as built-in properties and methods.</p>

<p>You should account for two minor issues when including one or more 
multiline TextBox controls on your forms. When you enter code in a word processor or 
an editor, you expect that the Enter key will add a newline character (more precisely, 
a CR-LF character pair) and that the Tab key will insert a tab character and move 
the caret accordingly. Visual Basic supports these keys, but because both of them 
have special meaning to Windows the support is limited: The Enter key adds a CR-LF 
pair only if there isn't a default push button on the form, and the Tab key inserts a 
tab character only if there aren't other controls on the form whose 
<I>TabStop </I>property is set to True. In many circumstances, these requirements can't be met, and some 
of your users will find your user interface annoying. If you can't avoid this problem, 
at least add a reminder to your users that they can add new lines using the 
Ctrl+Enter key combination and insert tab characters using the Ctrl+Tab key combination. 
Another possible approach is to set the 
<I>TabStop</I> property to False for all the controls 
in the form in the multiline TextBox's <I>GotFocus 
</I>event and to restore the original values in the 
<I>LostFocus</I> event procedure.</p>

</BODY>
</HTML>




