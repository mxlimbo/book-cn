<HTML>
<HEAD>
<TITLE>The Recordset Object</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch13b.htm", "ch13d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="565"><h1>The Recordset Object</h1></A>
<p>The Recordset object contains all the data that you read from a database or that you're about to send to it. A Recordset can include several rows and columns of data. Each row is a record, and each column is a field in the record. You can access only one row at a time, the so-called current row or current record. You navigate through a Recordset by changing the current record.</p>

<p>ADO Recordset objects are much more versatile than their DAO and RDO counterparts. For example, you can create an ADO Recordset object yourself, without being connected to a database. Or you can retrieve a Recordset from a database, close the connection, modify the data in the Recordset, and finally reestablish the connection to send all your updates to the server. (These optimistic batch updates were possible in RDO but not in DAO.) You can even save an ADO Recordset to a disk file so that you can restore it later.</p>

<p>The ADO Workbench application provided on the companion CD lets you play with the many properties of the Recordset object. You can also execute its methods and see which events fire. The application decodes the meaning of all the symbolic constants exposed by the ADODB library, as shown in Figure 13-4.</p>

<p>
<A HREF="javascript:fullSize('F13ph04x.htm')"> <img src="images/F13ph04.JPG" width=404 height=295 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 13-4.</B> <i>You can use the ADO Workbench application to look at a Recordset's properties, execute its methods, and see its events fire; other windows let you browse the Fields collection and the actual contents of the records.</i><!--/caption-->
</p>

<A NAME="566"><h2>Properties</h2></A>
<p>The Recordset object is the richest object in the ADO object model in terms of properties. Again, I'll group the properties according to their functionality rather than by name.</p>

<A NAME="567"><h3>Setting the Recordset's source</h3></A>
<p>The most significant property of the Recordset object is probably the <I>Source </I>property, which holds the name of the table, the name of the stored procedure, or the text of the SQL query used to populate the Recordset. This property is declared as Variant, which permits you to assign a Command object to it. If you assign a Command object to this property, it returns the contents of the <I>CommandText</I> property of the Command object, not a reference to the Command object itself. The <I>Source</I> property is read/write for closed Recordset objects and read-only after the Recordset has been opened. Here's an example of the <I>Source </I>property:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Edit this constant to match your directory structure.
Const DBPATH = &quot;C:\Program Files\Microsoft Visual Studio\Vb98\NWind.mdb&quot;
Dim cn As New ADODB.Connection, rs As New ADODB.Recordset
cn.Open &quot;Provider=Microsoft.Jet.OLEDB.3.51;Data Source=&quot; &amp; DBPATH
rs.Source = &quot;Employees&quot;
rs.Open , cn
</pre>
</td></tr></table></p>

<p>You can make your code more concise if you pass the value of this property as the first argument of the <I>Open </I>method:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>rs.Open &quot;Employees&quot;, cn
</pre>
</td></tr></table></p>

<p>When you assign an ADO Command object to the <I>Source </I>property, you can later retrieve a reference to this object through the <I>ActiveCommand </I>property.</p>

<p>To open a Recordset, you must associate it with an existing connection. You can explicitly create this Connection object and assign it to the <I>ActiveConnection </I>property, or you can create it implicitly by assigning a connection string to the <I>ActiveConnection </I>property:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Edit this constant to match your directory structure.
Const DBPATH = &quot;C:Program Files\Microsoft Visual Studio\VB98\NWind.mdb&quot;

' First method: explicit Connection object
cn.Open &quot;Provider=Microsoft.Jet.OLEDB.3.51;Data Source=&quot; &amp; DBPATH_
Set rs.ActiveConnection = cn
rs.Source = &quot;Employees&quot;
rs.Open

' Second method: implicit Connection object
rs.ActiveConnection = &quot;Provider=Microsoft.Jet.OLEDB.3.51;&quot; _
    &amp; &quot;Data Source= &quot; &amp; DBPATH
rs.Source = &quot;Employees&quot;
rs.Open
</pre>
</td></tr></table></p>

<p>When you create an implicit Connection object, you can later reference it through the <I>ActiveConnection </I>property (for example, to access the Connection's Errors collection). The <I>ActiveConnection </I>property is read-only after the record has been opened or when a Command object has been assigned to the <I>ActiveCommand </I>property.</p>

<p>Yet another way to select the location from which the Recordset should retrieve its data is with the <I>DataSource </I>and <I>DataMember </I>properties. For example, you can link a Recordset object to an ADO Data control by using the following statement:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Set rs.DataSource = Adodc1
</pre>
</td></tr></table></p>

<p>You don't need to set any other property, nor do you have to call the <I>Open </I>method (which in fact raises an error). If the data source is a DataEnvironment object, you also need to assign a valid string to the <I>DataMember </I>property; otherwise, an error will occur when setting the <I>DataSource </I>property.</p>

<p>The Recordset's <I>State </I>property returns the current state of the Recordset as a set of bits that can be tested individually:</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">0-adStateClosed</td>
<td valign="top">The Recordset is closed.</td>
</tr>
<tr>
<td valign="top">1-adStateOpen</td>
<td valign="top">The Recordset is open.</td>
</tr>
<tr>
<td valign="top">2-adStateConnecting</td>
<td valign="top">The Recordset is connecting.</td>
</tr>
<tr>
<td valign="top">4-adStateExecuting</td>
<td valign="top">The Recordset is executing a command.</td>
</tr>
<tr>
<td valign="top">8-adStateFetching</td>
<td valign="top">The rows of the Recordset are being fetched.</td>
</tr>
</table></p>

<p>The last three values apply only when the Recordset object is executing an asynchronous method.</p>

<A NAME="568"><h3>Working with cursors</h3></A>
<p>A cursor is a set of records that represent the results of a query. Cursors can contain the actual data or just pointers to records in the database, but the mechanism that retrieves the data is transparent to the programmer. You can specify where the cursor should be created (on the client or on the server workstation), the cursor type, and the locking option.</p>

<p>The <I>CursorLocation </I>property specifies where the cursor is to be created. This property can have one of two values: 2-adUseServer or 3-adUseClient. The value of this property is inherited from the Connection object and can be changed only for closed Recordsets. When you're working with the OLE DB Provider for ODBC Drivers and for SQL Server, the default cursor is a forward-only cursor created on the server. (This type of cursor is also the most efficient.) You need to switch to client-side cursors if you want to create dissociated Recordsets and use an optimistic batch update strategy. Client-side cursors are often a good choice when you have a DataGrid control or another complex control that is bound to the Recordset. In all other cases, server-side cursors are often preferable because they offer better performance and additional cursor types.</p>

<p>The <I>CursorType </I>property tells which type of cursor should be created and is one of the following constants: 0-adOpenForwardOnly, 1-adOpenKeyset, 2-adOpenDynamic, or 3-adOpenStatic. Server-side cursors support all these options, whereas client-side cursors support only 3-adOpenStatic. But if you use a different setting for a client-side cursor, a static cursor is automatically created without raising an error.</p>

<p>A forward-only cursor is the default for server-side cursors and is available only for server-side cursors. As I just mentioned, this type of cursor is the most efficient, especially if you set <I>LockType </I>= adReadOnly and <I>CacheSize </I>= 1. Many programmers and authors refer to this last type of cursor as a &quot;noncursor.&quot; In <I>The</I> <I>Hitchhiker's Guide to Visual Basic and SQL Server</I>, William R. Vaughn defines this as a &quot;fire-hose&quot; cursor, to emphasize how fast it is at tossing data to the client application. You don't have to do anything special to use this cursor (or noncursor) because it's the default for ADO. You can navigate a forward-only Recordset only by using the <I>MoveNext </I>method. If you want to get the best performance for an application that needs to update records, you should do all your updates through SQL commands or stored procedures.</p>

<p>Dynamic cursors consist of a set of bookmarks to the actual data in the data source. Any time the client requests a record, ADO uses the bookmark to read the current value, which means that the application always reads the latest value stored by other users. Dynamic cursors are automatically updated when other users add or delete a record or change any record already in the Recordset. Not surprisingly, these cursors are the most expensive cursors in terms of performance and LAN traffic because any time you move to another record a trip to the server is required to retrieve the current values. You can always update data and perform all kinds of navigational methods on dynamic Recordsets, including using bookmarks if the provider supports them. This type of cursor is available only as server-side cursors.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
Microsoft Jet Engine doesn't support dynamic cursors, so if you attempt to open dynamic cursors with the Jet OLE DB Provider you always get a keyset.
</blockquote></div></p>

<p>Keyset cursors are similar to dynamic cursors, but they don't include records added by other users. (Changes other users have made to records in the Recordset are visible, though.) You can read and modify all the records in the cursor, but you get an error if you access a record that another user has deleted. The keyset cursor is available only as a server-side cursor.</p>

<p>Static cursors create a fully scrollable snapshot of all the records identified by the <I>Source </I>property, and they are the only type possible for client-side cursors. Because a static cursor is actually a copy of the data coming from the database, changes that other users make aren't visible. Whereas these cursors are less efficient than forward-only cursors and increase the workload on the computer where they reside, their performance is reasonable and they're a good choice, especially when the Recordset doesn't include too many records. A static cursor is usually the best choice for retrieving data from a stored procedure. Depending on the provider and on other settings, this Recordset can even be updatable. You should create client-side static cursors only when the client workstation has enough memory.</p>

<p>The <I>MaxRecords </I>property sets a limit to the number of records that will be returned in the Recordset when you're working with a cursor. The default value is 0, which means that all records will be returned. This property can be written to when the Recordset is closed and is read-only when the Recordset is open.</p>

<p>The <I>CacheSize</I> property sets and returns the number of records that ADO will cache locally when working with cursors. You can adjust the value of this property to fine-tune your application, trading memory for performance. You can assign a new value to this property at any moment, but if the Recordset is already open, the new setting will be used only when ADO needs to fill the local cache&#8212;that is, when you move the pointer to the current record to point to a record that isn't in the cache.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
Most programmers like cursors&#8212;especially dynamic and keyset cursors&#8212;because they're so powerful and versatile. Unfortunately, cursors are often the worst choice in terms of performance, resources, and scalability. You should use cursors only when you're working with small Recordsets or when you're using bound controls. (Bound controls need cursors to support backward and forward navigation.) When you employ cursors, remember to build the <I>Source </I>property so that you reduce the number of rows fetched and to use a WHERE clause that exploits one or more indexes. Another effective technique to improve the performance of your application is to execute a <I>MoveLast </I>method to quickly populate the Recordset and release any lock on the data source as soon as possible.
</blockquote></div></p>

<A NAME="569"><h3>Working with concurrency</h3></A>
<p>All multiuser databases enforce some type of locking strategy. Locks are necessary to prevent multiple users from performing changes on the same record at the same moment, which would probably result in an inconsistent database. Locks are extremely expensive in terms of scalability; when a lock is enforced on a record being modified by a user, no other user can access the same record. Depending on how you write your applications, a lock can significantly degrade performance and can even cause fatal errors if you don't implement a good lock-resolving strategy.</p>

<p>The <I>LockType </I>property indicates which type of lock should be enforced on the data in the database. This enumerated property can be assigned one of the following values: 1-adLockReadOnly, 2-adLockPessimistic<I>, </I>3-adLockOptimistic<I>,</I> and 4-adLockBatchOptimistic.</p>

<p>The default value for this property is adLockReadOnly, which creates nonupdatable Recordsets. This is the most efficient option because it doesn't impose a write lock on data. It's also the best choice as far as scalability is concerned. Again, a good strategy is to rely on forward-only, read-only noncursors (the default in ADO) when reading data and to do all updates through SQL statements or stored procedures.</p>

<p>When you're using pessimistic locking, ADO tries to lock the record as soon as you enter edit mode, which occurs when you modify one field in the Recordset. It releases the lock only when you issue an <I>Update </I>method or move to another record. While a record is locked, no other user can access it for writing, which severely reduces the potential for the scalability of the application. For this reason, you should <I>never </I>use pessimistic locking when the user interface of your application lets the user freely navigate in the Recordset (unless you want to block all users when any one of them takes a coffee break!). Pessimistic locking is available only for server-side cursors.</p>

<p>Optimistic locking scales up better than pessimistic locking does, but it requires more attention from the programmer. With optimistic locking, ADO locks the current record only while it's being updated, which usually takes a small amount of time.</p>

<p>Optimistic batch locking is a special mode that's available only for client-side static cursors. In optimistic batch locking, you download all the data on the client machine, let the user perform all the necessary changes (including adding and deleting records), and then resubmit all the changes in one single operation. If you decided to go with client-side cursors, optimistic batch locking is the most efficient mode because it reduces network traffic. However, you'll need to implement a strategy for handling conflicts (for example, when two users update the same record), which won't be a trivial task.</p>

<p>For more information about the various types of locking, read the &quot;<A HREF="ch14c.htm#629">Locking Issues</A>&quot; section in Chapter 14.</p>

<A NAME="570"><h3>Reading and modifying fields' values</h3></A>
<p>The ultimate purpose in opening a Recordset is to read the values of its rows and columns and possibly to modify them. Recordsets allow you to read and write only the values in the current record, so you need to navigate through the Recordset to access all the records you're interested in.</p>

<p>You can read the values of the fields of the current record through the Fields collection. You can specify which field you're interested in by passing a numeric index or the name of the field:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Print the names and values of all the fields in the Recordset.
Dim i As Integer
For i = 0 To rs.Fields.Count _ 1    ' The Fields collection is zero-based.
    Print rs.Fields(i).Name &amp; &quot; = &quot; &amp; rs.Fields(i).Value
Next
</pre>
</td></tr></table></p>

<p>You can also use the <I>For Each</I> statement to iterate on all the fields. You can omit the <I>Value </I>property because it's the default property for the Field object.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim fld As ADODB.Field
For Each fld In rs.Fields
    Print fld.Name &amp; &quot; = &quot; &amp; fld
Next
</pre>
</td></tr></table></p>

<p>Unlike DAO and RDO, ADO doesn't support an <I>Edit </I>method, and you can start updating one or more fields of the current record simply by assigning new values to the Field object you want to modify. Moreover, you don't need to explicitly issue an <I>Update </I>method because ADO will automatically execute it for you when you move to another record in the Recordset. These features simplify the structure of the code that reads and updates all the records in a Recordset:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Convert the contents of the LastName field to uppercase.
rs.MoveFirst
Do Until rs.EOF
    rs(&quot;LastName&quot;) = UCase$(rs(&quot;LastName&quot;))
    rs.MoveNext
Loop
</pre>
</td></tr></table></p>

<p>You can determine the editing status of a Recordset by querying its <I>EditMode </I>property, which returns one of the following values:</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">0-adEditNone</td>
<td valign="top">No editing operation is in progress.</td>
</tr>
<tr>
<td valign="top">1-adEditInProgress</td>
<td valign="top">One or more fields have been modified, but 
new values haven't been saved yet.</td>
</tr>
<tr>
<td valign="top">2-adEditAdd</td>
<td valign="top">A new record has been added, but it hasn't 
been saved to the database yet.</td>
</tr>
<tr>
<td valign="top">3-adEditDelete</td>
<td valign="top">The current record has been deleted.</td>
</tr>
</table></p>

<A NAME="571"><h3>Setting and retrieving the position in the Recordset</h3></A>
<p>A number of properties help you understand where you are in the Recordset so that you can enable or disable certain operations or set bookmarks to quickly return to a record you've visited previously. The property in this group that you'll probably use most frequently is <I>EOF</I>, which returns True when the pointer to the current record is positioned after the end of the Recordset. You typically use this property when looping on all the records in the Recordset:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Count all employees hired before January 1, 1994.
rs.MoveFirst
Do Until rs.EOF
    If rs(&quot;HireDate&quot;) &lt; #1/1/1994# then count = count + 1
    rs.MoveNext
Loop
</pre>
</td></tr></table></p>

<p><I>BOF </I>is a similar property. It returns True when the record pointer is positioned before the beginning of the Recordset. It's often crucial to know the values of <I>EOF </I>and <I>BOF </I>properties: When either one returns True, most of the Recordset's methods and properties return an error because there's no current record. For example, you can't retrieve a Field's value if the current record is before the beginning or after the end of the Recordset. If both <I>BOF</I> and <I>EOF</I> properties are True, the Recordset is empty.</p>

<p>The <I>Bookmark </I>property lets you retrieve a Variant value that identifies the current record; you can later move back to this record simply by reassigning the same value to the <I>Bookmark </I>property, as this code demonstrates:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim mark As Variant
mark = rs.Bookmark              ' Remember where you are.
rs.MoveLast                     ' Move to the last record.
rs(&quot;HireDate&quot;) = #12/10/1994#   ' Assign a new value to the HireDate field.
rs.Bookmark = mark              ' Return to the marked record.
</pre>
</td></tr></table></p>

<p>ADO bookmarks are stored internally as Double values. Even if they are numeric values, you shouldn't assume that you can compare them as if they were numbers. The only arithmetic operation that makes sense with bookmarks is a test for equality, as in the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Print the names of the employees who were hired on the same
' day as (or later than) the employee whose record is current in the Recordset.
Dim mark As Double, curHireDate As Date
mark = rs.Bookmark: curHireDate = rs(&quot;HireDate&quot;)
rs.MoveFirst
Do Until rs.EOF
    If rs.Bookmark &lt;&gt; mark Then
        ' Don't consider the current employee.
        If rs(&quot;HireDate&quot;) &gt;= curHireDate Then Print rs(&quot;LastName&quot;)
    End If
    rs.MoveNext
Loop
' Move the record pointer back to the record that was current.
rs.Bookmark = mark
</pre>
</td></tr></table></p>

<p>Moreover, bookmarks can be compared for equality only if they come from the same Recordset object or from a clone Recordset. (See the description of the <I>Clone</I> method later in this chapter.) In all other cases, you shouldn't compare the <I>Bookmark </I>properties of two distinct Recordset objects, even if they are pointing to the same rowset in the same database. For more information about comparing bookmarks, see the description of the <I>CompareBookmarks </I>method in the section &quot;<A HREF="ch13c.htm#578">Navigating the Recordset</A>,&quot; later in this chapter.</p>

<p>The <I>RecordCount </I>read-only property returns the number of records in the Recordset. Depending on the database engine, the provider, and the type of Recordset, this property can also return -1. This property isn't supported by forward-only Recordsets, for example. If the property is supported, reading its value forces ADO to perform an implicit <I>MoveLast </I>method, so this operation can add a lot of overhead if used with large Recordsets.</p>

<p>The <I>AbsolutePosition </I>property sets or returns a Long value that corresponds to the ordinal position of the current record in the Recordset. (The first record returns 1; the last record returns RecordCount.) It can also return one of the following values: -1-adPosUnknown (position is unknown), -2-adPosBOF (BOF condition), or -3-adPosEOF (EOF condition).</p>

<p>You should never use this property in place of the record number or, worse, instead of the <I>Bookmark</I> property because the <I>AbsolutePosition</I> property varies when records are added to or removed from the Recordset. The most reasonable way to use this property is when you want to provide a scroll bar or a Slider control that lets the user quickly move in the Recordset. In this case, you should set the scroll bar's <I>Min </I>property to 1 and its <I>Max </I>property to <I>rs.RecordCount</I> and then add this code in the scroll bar's <I>Change </I>or <I>Scroll </I>event procedure:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub HScrollBar1_Change()
    On Error Resume Next
    rs.AbsolutePosition = HScrollBar1.Value
End Sub
</pre>
</td></tr></table></p>

<p>Remember that a scroll bar's <I>Max </I>value can't be higher than 32,767; if you have to deal with more records than that, you should either scale that value or use a Slider control.</p>

<p>Each Recordset is subdivided into pages, and each page can contain a fixed number of records (except the last page, which can be filled only partially). The <I>PageSize </I>property returns the number of records in each page, whereas the <I>PageCount </I>property returns the number of pages in the Recordset. The <I>AbsolutePage </I>property sets or returns the page number of the current record. This property is conceptually similar to the <I>AbsolutePosition</I> property (and supports the same negative values to indicate unknown, BOF, and EOF conditions), but it works with page numbers instead of record numbers. It's most useful when you're implementing advanced strategies to buffer records being read from the database.</p>

<A NAME="572"><h3>Sorting and filtering records</h3></A>
<p>You can sort the records in a Recordset by assigning a field list to the <I>Sort </I>property, as in the following example:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Sort the Recordset on the LastName and FirstName fields.
rs.Sort = &quot;LastName, FirstName&quot;
</pre>
</td></tr></table></p>

<p>The first field name is the primary sort key, the second field name is the secondary sort key, and so on. By default, records are sorted in ascending order for the selected keys; however, you can opt for descending order by using the <I>DESC </I>qualifier:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Sort in descending order on the HireDate field. (The employees hired
' most recently should be listed first.) 
rs.Sort = &quot;HireDate DESC&quot;
</pre>
</td></tr></table></p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
The documentation incorrectly states that you should use the <I>ASCENDING</I> and <I>DESCENDING</I> qualifiers. It turns out, however, that they cause an error 3001. This bug will probably be fixed in a future version of ADO.
</blockquote></div></p>

<p>This property doesn't affect the order of the records in the data source, but it does affect the order of the records in the Recordset. You can restore the original order by assigning an empty string to this property. I found out that the <I>Sort </I>method works only with client-side static cursors, at least with the OLE DB providers for ODBC, Microsoft Jet, and SQL Server. If you sort on fields that aren't indexed, ADO creates a temporary index for them and deletes the index when you close the Recordset or assign an empty string to the <I>Sort </I>property.</p>

<p>You can filter the records in a Recordset by using the <I>Filter </I>property. You can assign three types of values to this property: an SQL query string, an array of bookmarks, or a constant that indicates which records should appear in the Recordset. The most intuitive way to use this property is to assign it an SQL string. This string is similar to the WHERE clause of a SELECT command, but you have to omit the WHERE. A few examples are shown below.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Filter out all employees hired before January 1, 1994.
rs.Filter = &quot;HireDate &gt;= #1/1/1994#&quot;
' Include only employees born in the 1960s.
rs.Filter = &quot;birthdate &gt;= #1/1/1960# AND birthdate &lt; #1/1/1970#&quot;
' Filter in only employees whose last names start with the letter C.
rs.Filter = &quot;LastName LIKE 'C*'&quot;
</pre>
</td></tr></table></p>

<p>You can use the comparison operators (&lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt;) and the LIKE operator, which supports the * and % wildcards but only at the end of the string argument. You can connect simpler statements using AND and OR logical operators, but you can't perform other operations (such as string concatenations). You can group simpler expressions using parentheses. If a field name contains spaces, you must enclose the name within square brackets. You can use the <I>Filter </I>property in this way with server-side cursors if the provider supports filtering; in all other cases, you should use client-side cursors. Because ADO performs the filtering, you should stick to ADO syntax rules; for example, date values must be enclosed in # symbols, strings must be enclosed in single quotes, and quotes embedded in a string must be doubled. (Here's a brief tip: Use the <I>Replace </I>function to prepare the string quickly.)</p>

<p>If you want to filter a group of records that can't be specified using a simple SQL string, you can pass an array of bookmarks to the <I>Filter </I>property:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Filter out those employees who were hired when they were over age 35.
ReDim marks(1 To 100) As Variant
Dim count As Long
' Prepare an array of bookmarks. (Assume that 100 bookmarks are enough.)
Do Until rs.EOF
    If Year(rs(&quot;HireDate&quot;)) - Year(rs(&quot;BirthDate&quot;)) &gt; 35 Then
        count = count + 1
        marks(count) = rs.Bookmark
    End If
    rs.MoveNext
Loop
' Enforce the new filter using the array of bookmarks.
ReDim Preserve marks(1 To count) As Variant
rs.Filter = marks
</pre>
</td></tr></table></p>

<p>Finally, you can assign the <I>Filter </I>property one of these enumerated constants:</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">0-adFilterNone</td>
<td valign="top">Remove the current filter (same as assigning an empty string).</td>
</tr>
<tr>
<td valign="top">1-adFilterPendingRecords</td>
<td valign="top">In batch update mode, view only records that have been modified but not sent to the server yet.</td>
</tr>
<tr>
<td valign="top">2-adFilterAffectedRecords</td>
<td valign="top">View records affected by the most recent <I>Delete</I>, <I>Resync</I>, <I>UpdateBatch</I>, or <I>CancelBatch </I>method.</td>
</tr>
<tr>
<td valign="top">3-adFilterFetchedRecords</td>
<td valign="top">View only the records in the local cache.</td>
</tr>
<tr>
<td valign="top">5-adFilterConflictingRecords</td>
<td valign="top">In batch update mode, view only the records that failed to be committed to the server.</td>
</tr>
</table></p>

<p>Setting the <I>Filter </I>property to the value 2-adFilterAffectedRecords is the only way to see the records that have been deleted.</p>

<A NAME="573"><h3>Other properties</h3></A>
<p>The <I>MarshalOption </I>property affects how you send back rows to the server. It can be assigned two enumerated constants: 0-adMarshalAll (ADO sends all the rows to the server, which is the default) or 1-adMarshalModifiedOnly (ADO sends only the records that have been modified). This property is available only on client-side ADOR Recordsets, which are described in the &quot;<A HREF="ch19f.htm#967">Remote Data Services</A>&quot; section in Chapter 19.</p>

<p>The <I>Status </I>property is a bit-field value that returns the status of the current record after a batch update operation or another bulk operation has completed. You can test its individual bits using the enumerated properties listed in Table 13-2.</p>

<p>The only Recordset property I haven't yet described is <I>StayInSync</I>, which applies to the child Recordsets of a hierarchical Recordset object. To understand what this property does, you must consider that hierarchical Recordsets expose Field objects that contain child Recordset objects. By default, ADO automatically updates these child Recordsets when the record pointer of the parent Recordset moves to another record. This default behavior is what you want in the vast majority of cases, but at times you'd like to save the contents of a child Recordset for later; and in a sense, you want to detach it from its parent Recordset. Well, you can separate the parent and child Recordsets by setting the child Recordset's <I>StayInSync </I>property to False. Another way to reach the same result is to use the <I>Clone </I>method to create a copy of the child Recordset: If you use this method, the cloned Recordset won't be updated when the parent Recordset moves to another record. For more information, see the section &quot;<a href="ch14d.htm#658">Heirarchical Recordsets</a>&quot; in Chapter 14.</p>

<A NAME="574"><h2>Methods</h2></A>
<p>The Recordset object exposes several methods. Again, I'll describe them in groups, according to their purpose.</p>

<p><B>Table 13-2.</B> <i>The constants to use when testing the 
Status property.</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Constant</i></th>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">adRecOK</td>
<td valign="top">0</td>
<td valign="top">The record was successfully updated.</td>
</tr>
<tr>
<td valign="top">adRecNew</td>
<td valign="top">1</td>
<td valign="top">The record is new.</td>
</tr>
<tr>
<td valign="top">adRecModified</td>
<td valign="top">2</td>
<td valign="top">The record was modified.</td>
</tr>
<tr>
<td valign="top">adRecDeleted</td>
<td valign="top">4</td>
<td valign="top">The record was deleted.</td>
</tr>
<tr>
<td valign="top">adRecUnmodified</td>
<td valign="top">8</td>
<td valign="top">The record wasn't modified.</td>
</tr>
<tr>
<td valign="top">adRecInvalid</td>
<td valign="top">&amp;H10</td>
<td valign="top">The record wasn't saved because 
its bookmark is invalid.</td>
</tr>
<tr>
<td valign="top">adRecMultipleChanges</td>
<td valign="top">&amp;H40</td>
<td valign="top">The record wasn't saved because 
it would affect multiple records.</td>
</tr>
<tr>
<td valign="top">adRecPendingChanges</td>
<td valign="top">&amp;H80</td>
<td valign="top">The record wasn't changed 
because it refers to a pending insert.</td>
</tr>
<tr>
<td valign="top">adRecCanceled</td>
<td valign="top">&amp;H100</td>
<td valign="top">The record wasn't saved because 
the operation was canceled.</td>
</tr>
<tr>
<td valign="top">adRecCantRelease</td>
<td valign="top">&amp;H400</td>
<td valign="top">The record wasn't saved because 
of existing record locks.</td>
</tr>
<tr>
<td valign="top">adRecConcurrencyViolation</td>
<td valign="top">&amp;H800</td>
<td valign="top">The record wasn't saved because 
optimistic concurrency was in use.</td>
</tr>
<tr>
<td valign="top">adRecIntegrityViolation</td>
<td valign="top">&amp;H1000</td>
<td valign="top">The record wasn't saved because 
it would violate integrity constraints.</td>
</tr>
<tr>
<td valign="top">adRecMaxChangesExceeded</td>
<td valign="top">&amp;H2000</td>
<td valign="top">The record wasn't saved 
because there were too many pending changes.</td>
</tr>
<tr>
<td valign="top">adRecObjectOpen</td>
<td valign="top">&amp;H4000</td>
<td valign="top">The record wasn't saved because of 
a conflict with an open storage object.</td>
</tr>
<tr>
<td valign="top">adRecOutOfMemory</td>
<td valign="top">&amp;H8000</td>
<td valign="top">The record wasn't saved because 
of an out-of-memory error.</td>
</tr>
<tr>
<td valign="top">adRecPermissionDenied</td>
<td valign="top">&amp;H10000</td>
<td valign="top">The record wasn't saved because 
the user had insufficient permissions.</td>
</tr>
<tr>
<td valign="top">adRecSchemaViolation</td>
<td valign="top">&amp;H20000</td>
<td valign="top">The record wasn't saved because 
it doesn't match the structure of the database.</td>
</tr>
<tr>
<td valign="top">adRecDBDeleted</td>
<td valign="top">&amp;H40000</td>
<td valign="top">The record had already been 
deleted from the database.</td>
</tr>
</table></p>

<A NAME="575"><h3>Opening and closing the Recordset</h3></A>
<p>If you want to read the data in a Recordset, you must open it first, which you do with the <I>Open </I>method:

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Open [Source], [ActiveConnection], [CursorType], [LockType], [Options]
</pre>
</td></tr></table></p>

<p>The arguments of the <I>Open </I>method have the same meaning as the properties with the same names: <I>Source </I>is the name of a table or a stored procedure, an SQL query, or a reference to an ADO Command object; <I>ActiveConnection </I>is a reference to an ADO Connection object or to a connection string that identifies the provider and the data source; <I>CursorType </I>specifies which type of cursor you want to create (forward-only, static, keyset, or dynamic); and <I>LockType </I>is the type of locking you want to enforce (read-only, pessimistic, optimistic, or optimistic batch). <I>Options </I>is the only argument that doesn't correspond to a <I>Recordset</I> property: It explains to ADO what you're passing in the <I>Source </I>argument and can be one of the following enumerated constants:</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">1-adCmdText</td>
<td valign="top">Textual SQL query</td>
</tr>
<tr>
<td valign="top">2-adCmdTable</td>
<td valign="top">Database table</td>
</tr>
<tr>
<td valign="top">4-adCmdStoredProc</td>
<td valign="top">Stored procedure</td>
</tr>
<tr>
<td valign="top">8-adCmdUnknown</td>
<td valign="top">Unspecified; the provider will determine the 
correct type</td>
</tr>
<tr>
<td valign="top">256-adCmdFile</td>
<td valign="top">A persistent Recordset</td>
</tr>
<tr>
<td valign="top">512-adCmdTableDirect</td>
<td valign="top">A database table opened directly</td>
</tr>
</table></p>

<p>Even if in most cases the provider can understand what the source of the Recordset is without your help, you can often speed up the <I>Open</I> method by assigning a correct value to this argument.</p>

<p>All these arguments are optional. However, ADO can't open the Recordset if you don't provide enough information. For example, you can omit the <I>Source </I>argument if you've assigned a value to the <I>Source </I>property, and you can omit the <I>ActiveConnection</I> argument if you've assigned a value to the <I>ActiveConnection</I> property or if you're using an ADO Command object as the source for this Recordset (in which case the <I>ActiveConnection </I>argument is inherited from that Command object). If you omit the third or fourth argument, by default, the <I>Open </I>method creates a forward-only, read-only Recordset, which is the most efficient Recordset type that ADO supports. You can't specify the cursor position in the <I>Open</I> method, and if you want to create a client-side cursor, you must assign the adUseClient constant to the <I>CursorLocation </I>property before opening the Recordset. Below are a few examples that show the <I>Open </I>method in action.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Edit this constant to match your directory structure.
Const DBPATH = &quot;C:\Program Files\Microsoft Visual Studio\VB98\NWind.mdb&quot;
' All the following examples use these variables.
Dim cn As New ADODB.Connection, rs As New ADODB.Recordset
Dim connString As String, sql As String
connString = &quot;Provider=Microsoft.Jet.OLEDB.3.51;Data Source=&quot; &amp; DBPATH

' Open the Recordset using an existing Connection object.
cn.Open connString
rs.Open &quot;Employees&quot;, cn, adOpenStatic, adLockReadOnly, adCmdTable

' Open the Recordset using a Connection object created on the fly.
' This creates a forward-only, read-only Recordset.
rs.Open &quot;Employees&quot;, connString, , , adCmdTable
' After the Recordset has been opened, you can query the properties
' of the implicit Connection object.
Print &quot;Current Connection String = &quot; &amp; rs.ActiveConnection.ConnectionString

' Select only the employees who were born in the 1960s or later.
sql = &quot;SELECT * FROM Employees WHERE BirthDate &gt;= #1/1/1960#&quot;
rs.Open sql, connString, , , adCmdText
</pre>
</td></tr></table></p>

<p>You can also open a record that you previously saved to a disk file using the <I>Save </I>method: In this case, the first argument of the <I>Open </I>method is the complete name and path of the file, and you should pass the adCmdFile constant to the 
<I>Options </I>argument.</p>

<p>The <I>Options </I>argument supports two more constants for asynchronous operations. The value 16-adAsyncExecute executes the query asynchronously: The control goes back to the application immediately, and ADO continues to populate the Recordset until the local cache is filled with data. The value 32-adAsyncFetch tells ADO that after filling the local cache with data, it should fetch the remaining records asynchronously. When all the records have been retrieved, ADO fires a <I>FetchComplete </I>event.</p>

<p>You can cancel an asynchronous operation at any moment by issuing a <I>Cancel </I>method. If no asynchronous operations are pending, this method does nothing and no error is raised.</p>

<p>When you're done with a Recordset, you should close it using its <I>Close </I>method. This method doesn't take any argument. ADO automatically closes a Recordset when no more variables are pointing to it. When a Recordset is closed, ADO releases all the locks and the memory allocated to its cursor (if it has one). You can't close a Recordset if an edit operation is in progress (that is, if you modified the value of one or more fields and haven't committed the changes). You can reopen a closed Recordset by using the same or different values for its <I>Source</I>, <I>CursorType</I>, <I>MaxRecords</I>, <I>CursorPosition</I>, and <I>LockType </I>properties. (These properties are read-only while the Recordset is open.)</p>

<p>You can create a Recordset also by using the <I>Clone </I>method to create a copy of an existing Recordset:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim rs2 As ADODB.Recordset
Set rs2 = rs.Clone(LockType)
</pre>
</td></tr></table></p>

<p>The optional <I>LockType </I>argument tells which type of lock you want to enforce on the new Recordset. The cloned record can be opened only with the same lock type as the original record has (in this case, you just omit the argument) or in read-only mode (you pass the adLockReadOnly constant). Cloning a Recordset is more efficient than creating another Recordset against the same data source. Any modified value in one Recordset is immediately visible to all its clones regardless of their cursor type, but all the Recordsets in the group can be scrolled and closed independently from one another. If you issue a <I>Requery </I>method against the original Recordset, its clones aren't synchronized any longer. (The opposite isn't true, however: If you <I>Requery </I>the clones, they are still synchronized with the original Recordset.) Keep in mind that only Recordsets that support bookmarks can be cloned and that you can compare bookmarks defined in a Recordset and its clones.</p>

<A NAME="576"><h3>Refreshing the Recordset</h3></A>
<p>ADO offers two methods for repopulating a Recordset without closing and reopening it. The <I>Requery </I>method reexecutes the Recordset query. This method is especially useful with parameterized queries against an SQL Server database when you aren't using a Command object because it tells ADO to reuse the temporary stored procedure that SQL Server created when the Recordset was opened the first time. The <I>Requery </I>method accepts the adAsyncExecute option to run the query asynchronously. When the query completes, a <I>RecordsetChangeComplete </I>event fires. The <I>Requery</I> method lets you reexecute the query, but you can't modify any property that affects the type of the cursor (<I>CursorType</I>, <I>CursorLocation</I>, <I>LockType</I>, and so on) because these properties are read-only when the Recordset is open. To change these properties, you must close and then reopen the Recordset.</p>

<p>The <I>Resync </I>method refreshes the Recordset from the underlying database without actually reexecuting the query. Its syntax is as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Resync [AffectRecords], [ResyncValues]
</pre>
</td></tr></table></p>

<p><I>AffectRecords </I>tells which records should be refreshed and can be one of the following constants:</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">1-adAffectCurrent</td>
<td valign="top">Refreshes the current record only</td>
</tr>
<tr>
<td valign="top">2-adAffectGroup</td>
<td valign="top">Refreshes the records that satisfy the current 
<I>Filter </I>property, which should have been assigned one of 
the supported enumerated constants</td>
</tr>
<tr>
<td valign="top">3-adAffectAll</td>
<td valign="top">Refreshes the entire Recordset (the default)</td>
</tr>
</table></p>

<p><I>ResyncValues </I>can be one of the following values:</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">1-adResyncUnderlyingValues</td>
<td valign="top">Reads the most recent values 
from the database and puts them in the <I>UnderlyingValue 
</I>properties of the Field objects</td>
</tr>
<tr>
<td valign="top">2-adResyncAllValues</td>
<td valign="top">Reads the most recent values and 
puts them in the <I>Value </I>properties of the 
Field objects (the default)</td>
</tr>
</table></p>

<p>The effect of these two options is completely different: adResyncUnderlyingValues preserves the old data and doesn't cancel pending changes; adResyncAllValues cancels pending changes (as if a <I>CancelBatch</I> method had been issued).</p>

<p>Because the <I>Resync </I>method doesn't reexecute the query, you'll never see new records added by other users in the meantime. This method is especially useful with forward-only or static cursors when you want to be sure you're working with the most recent values. Any conflict during the resynchronization process&#8212;for example, another user has deleted a record&#8212;fills the Errors collection with one or more warnings. When using client-side cursors, this method is available only for updatable Recordsets.</p>

<A NAME="577"><h3>Retrieving data</h3></A>
<p>To read the values of the current record, you simply query the Fields collection as shown here:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Print employee's first and last name.
Print rs.Fields(&quot;FirstName&quot;).Value, rs.Fields(&quot;LastName&quot;).Value
</pre>
</td></tr></table></p>

<p>Because <I>Fields </I>is the default property for the Recordset object, you can omit it and access the field simply by using its name or its index. Similarly, you can drop the <I>Value </I>property because it's the default member of the Field object:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Print rs(&quot;FirstName&quot;), rs(&quot;LastName&quot;)
</pre>
</td></tr></table></p>

<p>You display the values of all the fields in the current record by iterating on the Fields collection. You can use the Field's index in a <I>For&#8230;Next </I>loop or a Field object variable in a <I>For Each&#8230;Next </I>loop:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The first method uses a regular For&#8230;Next loop.
For i = 0 To rs.Fields.Count _ 1
    Print rs.Fields(i).Name &amp; &quot; = &quot; &amp; rs(i)
Next

' The second method uses a For Each&#8230;Next loop.
Dim fld As ADODB.Field
For Each fld In rs.Fields
    Print fld.Name &amp; &quot; = &quot; &amp; fld.Value
Next
</pre>
</td></tr></table></p>

<p>ADO also offers more efficient ways to retrieve data. The <I>GetRows </I>method returns a two-dimensional array of Variants, where each column corresponds to a record in the Recordset and each row corresponds to a field in the record. This method has the following syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>varArray = rs.GetRows([Rows], [Start], [Fields])
</pre>
</td></tr></table></p>

<p><I>Rows </I>is the number of records you want to read; use -1 or omit this argument if you want to retrieve all the records in the Recordset. <I>Start</I> is a bookmark that indicates the first record to be read; it can also be one of the following enumerated constants: 0-adBookmarkCurrent (the current record), 1-adBookmarkFirst (the first record), or 2-adBookmarkLast (the last record).</p>

<I>Fields </I>is an optional array of field names that serves to restrict the quantity of data to read. (You can also specify a single field name, a single field index, or an array of field indexes.) When you set <I>Rows</I> to a value less than the number of records in the Recordset, the first unread record becomes the current record. If you omit the <I>Rows</I> argument or set it to -1-adGetRowsRest or to a value greater than the number of records still unread, the <I>GetRows</I> method reads all the records and leaves the Recordset in the EOF condition, without raising any error.</p>

<p>When processing the data in the target Variant array, you should remember that data is stored somewhat counterintuitively: The first subscript in the array identifies the Recordset's field (which is usually thought of as a column), and the second subscript identifies the Recordset's record (which is usually thought of as a row). Here's an example that loads three fields from all the records in the Recordset:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim values As Variant, fldIndex As Integer, recIndex As Integer
values = rs.GetRows(, , Array(&quot;LastName&quot;, &quot;FirstName&quot;, &quot;BirthDate&quot;))
For recIndex = 0 To UBound(values, 2)
    For fldIndex = 0 To UBound(values)
        Print values(fldIndex, recIndex),
    Next
    Print
Next
</pre>
</td></tr></table></p>

<p>The <I>GetRows </I>method is usually noticeably faster than an explicit loop that reads one record at a time, but if you use this method you must ensure that the Recordset doesn't contain too many records; otherwise, you can easily fill up all your physical memory with a very large Variant array. For the same reason, be careful not to include any BLOB (Binary Large Object) or CLOB (Character Large Object) fields in the field list; if you do, your application will almost surely bomb, especially with larger Recordsets. Finally, keep in mind that the Variant array returned by this method is zero-based; the number of returned records is <I>UBound(values,2)+1</I>, and the number of returned fields is <I>UBound(value, 1)+1</I>.</p>

<p>The <I>GetString </I>method is similar to <I>GetRows</I>, but it returns multiple records as a single string. <I>GetString</I> has the following syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>GetString([Format], [NumRows], [ColDelimiter], [RowDelimiter], [NullExpr])
</pre>
</td></tr></table></p>

<p><I>Format </I>is the format for the result. <I>GetString </I>potentially supports more formats, but the only format currently supported is 2-adClipString, so you don't really have any choice. <I>NumRows </I>is the number of rows to retrieve. (Use -1 or omit this argument to read all the remaining records.) <I>ColDelimiter</I> is the delimiter character for the columns. (The default is the Tab character.) <I>RowDelimiter</I> is the delimiter character for the records. (The default is the carriage return.) <I>NullExpr </I>is the string to be used for Null fields. (The default is the empty string.) The documentation states that the last three arguments can be used only if <I>Format </I>= adClipString, but this warning doesn't make much sense because, as I just mentioned, this format is the only one currently supported. Here's an example that uses the <I>GetString </I>method to export data in a semicolon-delimited text file:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim i As Long
Open &quot;datafile.txt&quot; For Output As #1
For i = 0 To rs.Fields.Count _ 1          ' Export field names.
    If i &gt; 0 Then Print #1, &quot;;&quot;;
    Print #1, rs.Fields(i).Name;
Next
Print #1, &quot;&quot;
rs.MoveFirst                              ' Export data.
Print #1, rs.GetString(, , &quot;;&quot;, vbCrLf);  ' Don't add an extra CR-LF here.
Close #1
</pre>
</td></tr></table></p>

<p>The <I>GetString </I>method doesn't permit you to export only a subset of the fields, nor does it permit you to modify the order of the exported fields. If you need these additional capabilities, you should use the <I>GetRows </I>method and build the result string yourself.</p>

<A NAME="578"><h3>Navigating the Recordset</h3></A>
<p>When you open a Recordset, the current record pointer points to the first record unless the Recordset is empty (in which case, both the <I>BOF </I>and <I>EOF </I>properties return True). To read and modify values in another record, you must make that record the current record, which you usually do by executing one of the <I>Move</I>xxxx methods exposed by the Recordset object. <I>MoveFirst</I> moves to the first record in the Recordset, <I>MoveLast </I>moves to the last record, <I>MovePrevious </I>moves to the previous record, and <I>MoveNext </I>moves to the next record. You typically provide users with four buttons that let them navigate the Recordset. Executing a <I>MovePrevious </I>method when <I>BOF </I>is True or executing a <I>MoveNext </I>method when <I>EOF </I>is True raises an error; therefore, you have to trap these conditions before moving to the previous or next record:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cmdFirst_Click()
    rs.MoveFirst
End Sub

Private Sub cmdPrevious_Click()
    If Not rs.BOF Then rs.MovePrevious
End Sub

Private Sub cmdNext_Click()
    If Not rs.EOF Then rs.MoveNext
End Sub

Private Sub cmdLast_Click()
    rs.MoveLast
End Sub
</pre>
</td></tr></table></p>

<p>The <I>MoveFirst </I>and <I>MoveNext </I>methods are commonly used in loops that iterate on all the records in the Recordset, as shown in the following example:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>rs.MoveFirst
Do Until rs.EOF
    total = total + rs(&quot;UnitsInStock&quot;) * rs(&quot;UnitPrice&quot;)
    rs.MoveNext
Loop
Print &quot;Total of UnitsInStock * UnitPrice = &quot; &amp; total
</pre>
</td></tr>
</table></p>

<p>ADO also supports a generic <I>Move </I>method, whose syntax is:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Move NumRecords, [Start]
</pre>
</td></tr>
</table></p>

<p><I>NumRecords </I>is a Long value that specifies the number of records to skip toward the end (if positive) or the beginning (if negative) of the Recordset. The move is relative to the record identified by the <I>Start </I>argument, which can be a bookmark value or one of the following enumerated constants:</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">0-adBookmarkCurrent</td>
<td valign="top">The current record</td>
</tr>
<tr>
<td valign="top">1-adBookmarkFirst</td>
<td valign="top">The first record in the Recordset</td>
</tr>
<tr>
<td valign="top">2-adBookmarkLast</td>
<td valign="top">The last record in the Recordset</td>
</tr>
</table></p>

<p>As you can see below, the <I>Move </I>method embodies the functionality of the four <I>Move</I>xxxx methods I've described previously.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>rs.Move 0, adBookmarkFirst           ' Same as MoveFirst
rs.Move _1                           ' Same as MovePrevious
rs.Move 1                            ' Same as MoveNext
rs.Move 0, adBookmarkLast            ' Same as MoveLast
rs.Move 10, adBookmarkFirst          ' Move to the tenth record.
rs.Move -1, adBookmarkLast            ' Move to the next to the last record.
rs.Move 0                            ' Refresh the current record.
</pre>
</td></tr></table></p>

<p>If you specify a negative offset that points to a record before the first record, the <I>BOF </I>property becomes True and no error is raised. Similarly, if you specify a positive offset that points to a record after the last record, the <I>EOF </I>property is set to True and no error is raised. Interestingly, you can specify a negative offset even with forward-only Recordsets: If the target record is still in the local cache, no error occurs. (You can't use <I>MovePrevious </I>with forward-only Recordsets, regardless of whether the previous record is in the cache.)</p>

<p>You can also navigate a Recordset using the <I>Bookmark </I>and <I>AbsolutePosition </I>properties. ADO also provides a <I>CompareBookmarks</I> method that lets you compare bookmarks coming from the same Recordset or from a cloned Recordset. This method has the following syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>result = CompareBookmarks(Bookmark1, Bookmark2)
</pre>
</td></tr></table></p>

<p><I>result </I>can receive one of these values:</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">0-adCompareLessThan</td>
<td valign="top">The first bookmark refers to a record that precedes the record the second bookmark refers to.</td>
</tr>
<tr>
<td valign="top">1-adCompareEqual</td>
<td valign="top">The two bookmarks point to the same record.</td>
</tr>
<tr>
<td valign="top">2-adCompareGreaterThan</td>
<td valign="top">The first bookmark refers to a record that follows the record the second bookmark refers to.</td>
</tr>
<tr>
<td valign="top">3-adCompareNotEqual</td>
<td valign="top">The two bookmarks refer to different records, but the provider can't determine which one comes first.</td>
</tr>
<tr>
<td valign="top">4-adCompareNotComparable</td>
<td valign="top">The bookmarks can't be compared.</td>
</tr>
</table></p>

<A NAME="579"><h3>Updating, inserting, and deleting records</h3></A>
<p>ADO differs from DAO and RDO in that the <I>Update </I>method isn't really necessary: All you have to do to modify a record is assign a new value to one or more Field objects and then move to another record. The ADO <I>Update </I>method supports the capability to update multiple fields at once, using the following syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Update [fields] [, values]
</pre>
</td></tr></table></p>

<p><I>fields </I>is a Variant containing a single field name, a field index, or an array of field names or indexes. <I>values </I>is a Variant containing a single value or an array of values. These arguments are optional, but you can't omit just one of the two: If provided, they must contain the same number of arguments. The following example demonstrates how you can update multiple fields using this syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Update four fields in one operation.
rs.Update Array(&quot;FirstName&quot;, &quot;LastName&quot;, &quot;BirthDate&quot;, &quot;HireDate&quot;), _
    Array(&quot;John&quot;, &quot;Smith&quot;, #1/1/1961#, #12/3/1994#)
</pre>
</td></tr></table></p>

<p>Because an update operation is automatically performed if one or more fields in the current record have been modified, ADO provides the <I>CancelUpdate</I> method to cancel such changes and leave the current record unmodified. You can use the <I>Update </I>and <I>CancelUpdate </I>methods together to offer the user a chance to confirm or cancel changes to the current record:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>If rs.EditMode = adEditInProgress Then
    If MsgBox(&quot;Do you want to commit changes?&quot;, vbYesNo) = vbYes Then
        rs.Update
    Else
        rs.CancelUpdate
    End If
End If
</pre>
</td></tr></table></p>

<p>You can add new records to the Recordset with the <I>AddNew </I>method. This method is similar to the <I>Update </I>method in that it supports two syntax forms, with or without arguments. If you don't pass an argument, you create a new record at the end of the Recordset and you're supposed to assign values to its fields using the Fields collection:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>rs.AddNew
rs(&quot;FirstName&quot;) = &quot;Robert&quot;
rs(&quot;LastName&quot;) = &quot;Doe
rs(&quot;BirthDate&quot;) = #2/5/1955#
rs.Update
</pre>
</td></tr></table></p>

<p>You don't need an explicit <I>Update</I> method after an <I>AddNew </I>method&#8212;any <I>Move</I>xxxx method will do. In the second syntax form, you pass the <I>AddNew</I> method a list of fields and a list of values; in this case, no update is necessary because values are immediately committed to the database:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' This statement has the same effect as the previous code snippet.
rs.AddNew Array(&quot;FirstName&quot;, &quot;LastName&quot;, &quot;BirthDate&quot;), _
    Array(&quot;Robert&quot;, &quot;Doe&quot;, #2/5/1955#)
</pre>
</td></tr></table></p>

<p>After you commit changes with an <I>Update </I>method, the record you've just added becomes the current record. If you issue a second <I>AddNew </I>method, you commit changes automatically to the record added just before, as if you had executed a <I>Move</I>xxxx method. Depending on the type of cursor, it's possible that the record you've added doesn't appear in the Recordset immediately and that you'll have to execute a <I>Requery </I>method to see it.</p>

<p>You can delete the current record by executing the <I>Delete </I>method. This method accepts an optional argument:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>rs.Delete [AffectRecords]
</pre>
</td></tr></table></p>

<p>If <I>AffectRecords </I>is 1-adAffectCurrent or is omitted, only the current record is deleted. When you delete a record, it's still the current record but it can't be accessed any longer, so you'd better move on to another record:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>rs.Delete
rs.MoveNext
If rs.EOF Then rs.MoveLast
</pre>
</td></tr></table></p>

<p>You can delete a group of records by assigning an enumerated constant to the <I>Filter </I>property and then issuing a <I>Delete </I>method with the <I>AffectRecords </I>argument set to 2-adAffectGroup:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' After a batch update attempt, delete all the records that failed
' to be transferred to the server.
rs.Filter = adFilterConflictingRecords
rs.Delete adAffectGroup
rs.Filter = adFilterNone        ' Remove the filter.
</pre>
</td></tr></table></p>

<p>You should nest your delete operations in a transaction if you want to give your users the chance to undelete them.</p>

<A NAME="580"><h3>Finding records</h3></A>
<p>The <I>Find </I>method provides a simple way to move to a record in the Recordset that matches search criteria. This method has the following syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Find Criteria, [SkipRecords], [SearchDirection], [Start]
</pre>
</td></tr></table></p>

<p><I>Criteria </I>is a string that contains the search condition, which consists of a field name followed by an operator and a value. The supported operators are = (equal), &lt; (less than), &gt; (greater than), and LIKE (pattern matching). The value can be a string enclosed by single quotes, a number, or a date value enclosed by # characters. <I>SkipRecord </I>is an optional number that indicates how many records should be skipped before starting the search: Positive values skip forward (toward the end of the Recordset), and negative values skip backward (toward the beginning of the Recordset). <I>SearchDirection </I>indicates the direction in which the search must proceed; you can use the values 1-adSearchForward (the default) or -1-adSearchBackward. <I>Start</I> is an optional bookmark that specifies the record from which the search should begin. (The default is the current record.)</p>

<p>In most cases, you can omit all the arguments except the first one, which results in a search that starts from the current record (included) and goes toward the end of the database. If the search is successful, the record that matches the search criteria becomes the current record; if the search fails, the current record is past the last record in the Recordset (or before the first record, if <I>Search </I>= adSearchBackward). Passing a nonzero value to the <I>SkipRecord </I>argument is necessary when you want to restart the search after you've found a match, as the following code snippet demonstrates:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Search all the employees who were hired after January 1, 1994.
rs.MoveFirst
rs.Find &quot;HireDate &gt; #1/1/1994#&quot;
Do Until rs.EOF
    Print rs(&quot;LastName&quot;), rs(&quot;BirthDate&quot;), rs(&quot;HireDate&quot;)
    ' Search the next record that meets the criteria, but skip the current one. 
    rs.Find &quot;HireDate &gt; #1/1/1994#&quot;, 1
Loop
</pre>
</td></tr></table></p>

<p>The LIKE operator accepts two wildcard symbols: * (asterisk) matches zero or more characters, and _ (underscore) matches exactly one character. Comparisons aren't case sensitive and aren't affected by the <I>Option Compare </I>directive. Here are a few examples:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>rs.Find &quot;FirstName LIKE 'J*'&quot;    ' Matches &quot;Joe&quot; and &quot;John&quot;.
rs.Find &quot;FirstName LIKE 'J__'&quot;   ' Matches &quot;Joe&quot; but not &quot;John&quot;.
rs.Find &quot;FirstName LIKE '*A*'&quot;   ' Matches &quot;Anne&quot;, &quot;Deborah&quot;, and &quot;Maria&quot;.
rs.Find &quot;FirstName LIKE '*A'&quot;    ' This gives an error: a bug?
</pre>
</td></tr></table></p>

<A NAME="581"><h3>Updating records in batch mode</h3></A>
<p>If you open a Recordset with the adLockBatchOptimistic option, all the rules stated so far about record updating are void. When working with optimistic batch updates, you're actually working with a cursor on the client workstation. You can read it even if the connection with the server doesn't exist anymore, and you can modify it without committing the changes to the server (not immediately at least). In optimistic batch mode, the implicit or explicit <I>Update </I>method affects only the local cursor, not the real database. This helps keep the network traffic to a minimum and greatly improves overall performance.</p>

<p>When you're ready to commit the changes to the database on the server, you issue an <I>UpdateBatch </I>method, which has the following syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>UpdateBatch [AffectRecords]
</pre>
</td></tr>
</table></p>

<p>You should assign the <I>AffectRecords </I>argument one of the constants listed below.</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">1-adAffectCurrent</td>
<td valign="top">Updates only the current record</td>
</tr>
<tr>
<td valign="top">2-adAffectGroup</td>
<td valign="top">Updates all the modified records that satisfy the current <I>Filter</I> property, which must have been assigned one of the supported enumerated constants</td>
</tr>
<tr>
<td valign="top">3-adAffectAll</td>
<td valign="top">Updates all modified records in the Recordset (the default)</td>
</tr>
<tr>
<td valign="top">4-adAffectAllChapters</td>
<td valign="top">Updates all the chapters in a hierarchical Recordset</td>
</tr>
</table></p>

<p>The adAffectAll setting is hidden in the ADODB type library. If you issue the <I>UpdateBatch </I>method while in edit mode, ADO commits the changes to the current record and then proceeds with the batch update.</p>

<p>The Visual Basic documentation states that if there is a conflict and one or more records can't be successfully updated, ADO fills the Errors collection with warnings but doesn't raise an error in the application. ADO raises an error only if all the records fail to update. Some tests prove, however, that when there is one conflicting record, the error &amp;H80040E38, &quot;Errors occurred,&quot; is returned to the application. You can then set the <I>Filter</I> property to the adFilterConflictingRecords value to see which records weren't updated successfully.</p>

<p>You can cancel a batch update using the <I>CancelBatch </I>method, which has the following syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>CancelBatch [AffectRecords]
</pre>
</td></tr></table></p>

<p><I>AffectRecords </I>has the same meaning here as it has with the <I>UpdateBatch </I>method. If the Recordset hasn't been opened with the adLockBatchOptimistic option, any value other than 1-adAffectCurrent raises an error. If you're in edit mode, the <I>CancelBatch </I>method cancels the updates to the current record first and then cancels the changes to the records affected by the <I>AffectRecords </I>argument. After a <I>CancelBatch </I>method is completed, the current record position might be undetermined, so you should use the <I>Move</I>xxxx method or the <I>Bookmark </I>property to move to a valid record.</p>

<p>When performing batch update operations on the client machine, you don't need to keep the connection to the database active. In fact, you can set the Recordset's <I>ActiveConnection </I>property to Nothing, close the companion Connection object, let your user browse and update the data, and then reestablish the connection when he or she is ready to post the updates to the database. For more information about batch updates, see the section &quot;<a href="ch14c.htm#631">Optimistic Client-Batch Updates</a>&quot; in Chapter 14.</p>

<A NAME="582"><h3>Implementing persistent Recordsets</h3></A>
<p>One of the most intriguing features of the ADO Recordset object is that you can save it to a regular disk file and then reopen it when necessary. This feature is advantageous in many situations&#8212;for example, when you're performing batch updates or when you want to postpone the processing of a Recordset. You don't even need to reopen the Recordset with the same application that saved it. For example, you can save a Recordset to a file and later process it with a report application that sends the output to a printer during off hours. The key to this capability is the <I>Save </I>method, which has the following syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Save [FileName], [PersistFormat]
</pre>
</td></tr></table></p>

<p>The first argument is the name of the file in which the Recordset should be saved, and the second argument is the format in which the Recordset should be saved. ADO 2.0 supports only the Advanced Data TableGram (ADTG), so you should specify the constant 0-adPersistADTG or omit the argument. Although the syntax of the <I>Save </I>method is rather intuitive, it includes some subtle details that you must account for when you're working with persistent Recordsets:</p>

<UL>
<p><li>In general, persistent Recordsets should use client-side cursors, so you should change the value of the <I>CursorLocation </I>property, whose default value is adUseServer. Some providers might support this capability with server-side cursors, however.</li></p>

<p><li>You need to specify the filename only the first time you save the Recordset to a file; in all subsequent saves, you must omit the first argument if you want to save to the same data file. If you don't omit the argument, a run-time error occurs.</li></p>

<p><li>An error occurs if the file already exists, so you should test for its existence before issuing the <I>Save </I>method and manually delete it if necessary.</li></p>

<p><li><I>Save </I>doesn't close the Recordset, so you can continue to work with it and save the most recent changes by issuing additional <I>Save </I>methods without the <I>FileName </I>argument. The file is closed only when the Recordset is also closed; in the meantime, other applications can read the file but can't write to it.</li></p>

<p><li>After you've saved to a file, you can specify a different filename to save to a different file; however, this operation doesn't close the original file. Both files remain open until the Recordset is closed.</li></p>

<p><li>If the <I>Filter </I>property is in effect, only the records that are currently visible are saved. This feature is useful for postponing the processing of records that failed to be committed to the database during a batch update operation.</li></p>

<p><li>If the <I>Sort</I> property isn't an empty string, the records will be saved in the sorted order.</li></p>

<p><li>If the <I>Save </I>method is issued while an asynchronous operation is in progress, the method doesn't return until the asynchronous operation is completed.</li></p>

<p><li>After a <I>Save </I>operation, the current record will be the first record in the Recordset.</li></p>
</UL>

<p>When opening a persistent Recordset, you should use the adCmdFile value in the <I>Option </I>argument of the <I>Open </I>method:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Save a Recordset to a file, and then close both the file
' and the Recordset.
rs.Save &quot;C:\datafile.rec&quot;, adPersistADTG
rs.Close
'...
' Reopen the persistent Recordset.
rs.Open &quot;C:\datafile.rec&quot;, , , , adCmdFile
</pre>
</td></tr></table></p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
Because the ADTG is a binary format, you can't easily edit a Recordset that has been saved in this format. The ADODB type library already includes the hidden constant 1-adPersistXML, even though this constant isn't supported in ADO 2.0. The good news is that ADO 2.1 fully supports Recordset persistence in XML format; this option is tantalizing because XML is a text-based format, and so you can edit the saved file using an editor.
</blockquote></div></p>

<A NAME="583"><h3>Managing multiple Recordsets</h3></A>
<p>ADO Recordsets support multiple queries in the <I>Source </I>property or in the <I>Source </I>argument of the <I>Open</I> method if the provider also supports multiple queries. You specify multiple SELECT queries, or even SQL action queries, by using the semicolon as a separator, as shown here:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>rs.Open &quot;SELECT * FROM Employees;SELECT * FROM Customers&quot;
</pre>
</td></tr></table></p>

<p>When the <I>Open </I>method completes its execution, the Recordset object contains all the records from the first query, and you can process these records as you would with a regular Recordset. When you're done with the records, you can retrieve them from the second query using the <I>NextRecordset </I>method:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim RecordsAffected As Long
Set rs = rs.NextRecordset(RecordsAffected)
</pre>
</td></tr></table></p>

<p>The argument is optional; if specified, it should be a Long variable. This variable receives the number of records that have been affected by the current operation (which might also be an SQL command that doesn't return a Recordset). Although the syntax permits you to assign the result of the <I>NextResult </I>method to another Recordset variable, as of this writing, no provider supports this functionality and the original contents of the Recordset are always discarded. If this functionality becomes available, it will be possible to assign each Recordset object to a distinct object variable and process all the Recordsets simultaneously.</p>

<p>Here are a few details to be aware of when you're working with multiple Recordsets:</p>

<UL>
<p><li>Each query is executed only when the <I>NextRecordset </I>method requests it; therefore, if you close the Recordset before processing all the pending commands, the corresponding queries or action commands are never executed.</li></p>

<p><li>If a row-returning query doesn't return any record, the resulting Recordset is empty. You can test this condition by checking whether both the <I>BOF </I>and <I>EOF </I>properties return True.</li></p>

<p><li>If the pending SQL command doesn't return any row, the resulting Recordset will be closed. You can test this condition with the <I>State </I>property.</li></p>

<p><li>When no more commands are pending, the <I>NextRecordset </I>method returns Nothing.</li></p>

<p><li>You can't call the <I>NextResult </I>method if an edit operation is in progress; to avoid errors, you should issue an <I>Update </I>or <I>CancelUpdate </I>method first.</li></p>

<p><li>If one or more of the SQL commands or queries require parameters, you should fill the Parameters collection with all the required parameter values, and they should be in the order expected by the commands or queries.</li></p>

<p><li>The provider must support multiple queries. For example, the provider for Microsoft Jet databases doesn't support them. The providers for SQL Server seem to support this functionality only with static client-side cursors or with server-side &quot;cursorless&quot; Recordsets.</li></p>
</UL>

<p>Here's an example of a code framework that you can use when working with multiple Recordsets:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim RecordsAffected As Long
rs.Open
Do 
    If rs Is Nothing Then 
        ' No more Recordsets, so exit.
        Exit Do 
    ElseIf (rs.State And adStateOpen) = 0 Then
        ' It was a non-row-returning SQL command.
        ...
    Else
        ' Process the Recordset here.
        ...
    End If
    Set rs.NextRecordset(RecordsAffected)
Loop
</pre>
</td></tr></table></p>

<A NAME="584"><h3>Testing for features</h3></A>
<p>Not all types of Recordsets support all the features that I've described so far. Instead of having you guess which features are supported and which aren't, the ADO Recordset object exposes the <I>Supports </I>method, which accepts a bit-field argument and returns True only if the Recordset supports all the features indicated in the argument. For example, you can test whether the Recordset supports bookmarks using the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>If rs.Supports(adBookmark) Then currBookmark = rs.Bookmark
</pre>
</td></tr></table></p>

<p>The argument to the <I>Supports </I>method can include one or more of the constants listed in Table 13-3. You don't need to issue multiple <I>Supports </I>methods if you want to test multiple features:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>If rs.Supports(adAddNew Or adDelete Or adFind) Then
    ' The Recordset supports the AddNew, Delete, and Find methods.
End If
</pre>
</td></tr></table></p>

<p>Don't forget that if this method returns True you're only sure that ADO supports the requested operation, not that the OLE DB provider necessarily supports it under all circumstances.</p>

<B>Table 13-3.</B> <i>The arguments for the Supports method.</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Constant</i></th>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">adHoldRecords</td>
<td valign="top">&amp;H100</td>
<td valign="top">Support for reading more records or changing the next retrieve position without committing pending changes</td>
</tr>
<tr>
<td valign="top">adMovePrevious</td>
<td valign="top">&amp;H200</td>
<td valign="top">Support for the <I>MoveFirst</I> and <I>MovePrevious</I> methods and for <I>Move </I>and <I>GetRows </I>with backward moves</td>
</tr>
<tr>
<td valign="top">adBookmark</td>
<td valign="top">&amp;H2000</td>
<td valign="top">Support for the <I>Bookmark </I>property</td>
</tr>
<tr>
<td valign="top">adApproxPosition</td>
<td valign="top">&amp;H4000</td>
<td valign="top">Support for the <I>AbsolutePosition </I>and <I>AbsolutePage </I>properties</td>
</tr>
<tr>
<td valign="top">adUpdateBatch</td>
<td valign="top">&amp;H10000</td>
<td valign="top">Support for the <I>UpdateBatch </I>and <I>CancelBatch </I>methods</td>
</tr>
<tr>
<td valign="top">adResync</td>
<td valign="top">&amp;H20000</td>
<td valign="top">Support for the <I>Resync </I>method</td>
</tr>
<tr>
<td valign="top">adNotify</td>
<td valign="top">&amp;H40000</td>
<td valign="top">Support for notifications</td>
</tr>
<tr>
<td valign="top">adFind</td>
<td valign="top">&amp;H80000</td>
<td valign="top">Support for the <I>Find </I>method</td>
</tr>
<tr>
<td valign="top">adAddNew</td>
<td valign="top">&amp;H1000400</td>
<td valign="top">Support for the <I>AddNew </I>method</td>
</tr>
<tr>
<td valign="top">adDelete</td>
<td valign="top">&amp;H1000800</td>
<td valign="top">Support for the <I>Delete </I>method</td>
</tr>
<tr>
<td valign="top">adUpdate</td>
<td valign="top">&amp;H1008000</td>
<td valign="top">Support for the <I>Update </I>method</td>
</tr>
</table></p>

<A NAME="585"><h2>Events</h2></A>
<p>The ADO Recordset object exposes 11 events. These events allow you to take complete control of what's happening behind the scenes. By writing code for these events, you can leverage asynchronous queries, trap the instant when a field or a record is modified, and even add data when the user reaches the end of the Recordset. The ADO Workbench application is especially helpful when watching events because it automatically converts all the enumerated constants to their symbolic names.</p>

<A NAME="586"><h3>Data retrieval events</h3></A>
<p>The <I>FetchProgress </I>event is fired periodically during a lengthy asynchronous operation. You can use it to show the user a progress bar that indicates the percentage of records retrieved:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub rs_FetchProgress(ByVal Progress As Long, _
    ByVal MaxProgress As Long, adStatus As ADODB.EventStatusEnum, _
    ByVal pRecordset As ADODB.Recordset)
</pre>
</td></tr></table></p>

<p>The <I>Progress </I>parameter is the number of records retrieved so far. <I>MaxProgress </I>is the total number of expected records. <I>adStatus</I> is the usual status parameter. <I>pRecordset </I>is a reference to the Recordset object that is raising the event. (In Visual Basic, you never need to use this argument because you already have a reference to the Recordset.)</p>

<p>When the retrieval of records is completed, ADO fires a <I>FetchComplete</I> event. If the <I>adStatus </I>parameter is equal to adStatusErrorsOccurred, you can query the error through the <I>pError </I>parameter:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub rs_FetchComplete(ByVal pError As ADODB.error, _
    adStatus As ADODB.EventStatusEnum, _
    ByVal pRecordset As ADODB.Recordset)
End Sub
</pre>
</td></tr></table></p>

<A NAME="587"><h3>Navigation events</h3></A>
<p>Each time the current record changes, a <I>WillMove </I>event fires, soon followed by a <I>MoveComplete </I>event, as you can see in the code below.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub rs_WillMove(ByVal adReason As ADODB.EventReasonEnum, _
    adStatus As ADODB.EventStatusEnum, _
    ByVal pRecordset As ADODB.Recordset)
</pre>
</td></tr></table></p>

<p>The <I>adReason </I>parameter tells why this event has been fired. It can be one of the constants listed in Table 13-4. Unless <I>adStatus </I>is set to adStatusCantDeny<I>,</I> you can cancel the operation by assigning the value adStatusCancel to <I>adStatus</I>.</p>

<p>When the move operation has completed (or when it has been canceled), a <I>MoveComplete </I>event fires:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub rs_MoveComplete(ByVal adReason As ADODB.EventReasonEnum, _
    ByVal pError As ADODB.error, adStatus As ADODB.EventStatusEnum, _
    ByVal pRecordset As ADODB.Recordset)
</pre>
</td></tr></table></p>

<p>The <I>adReason </I>and <I>adStatus </I>parameters have the same meanings as they have in the <I>WillMove </I>event: If <I>adStatus </I>is equal to adStatusErrorOccurred, the <I>pError </I>object contains information about the error; otherwise, <I>pError </I>is Nothing. You can cancel further notifications by setting <I>adStatus </I>to adStatusUnwantedEvent.</p>

<p><B>Table 13-4.</B> <i>The values of the adReason parameter in Recordset's events.</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Constant</i></th>
</tr>
<tr>
<td valign="top">1</td>
<td valign="top">adRsnAddNew</td>
</tr>
<tr>
<td valign="top">2</td>
<td valign="top">adRsnDelete</td>
</tr>
<tr>
<td valign="top">3</td>
<td valign="top">adRsnUpdate</td>
</tr>
<tr>
<td valign="top">4</td>
<td valign="top">adRsnUndoUpdate</td>
</tr>
<tr>
<td valign="top">5</td>
<td valign="top">adRsnUndoAddNew</td>
</tr>
<tr>
<td valign="top">6</td>
<td valign="top">adRsnUndoDelete</td>
</tr>
<tr>
<td valign="top">7</td>
<td valign="top">adRsnRequery</td>
</tr>
<tr>
<td valign="top">8</td>
<td valign="top">adRsnResynch</td>
</tr>
<tr>
<td valign="top">9</td>
<td valign="top">adRsnClose</td>
</tr>
<tr>
<td valign="top">10</td>
<td valign="top">adRsnMove</td>
</tr>
<tr>
<td valign="top">11</td>
<td valign="top">adRsnFirstChange</td>
</tr>
<tr>
<td valign="top">12</td>
<td valign="top">adRsnMoveFirst</td>
</tr>
<tr>
<td valign="top">13</td>
<td valign="top">adRsnMoveNext</td>
</tr>
<tr>
<td valign="top">14</td>
<td valign="top">adRsnMovePrevious</td>
</tr>
<tr>
<td valign="top">15</td>
<td valign="top">adRsnMoveLast</td>
</tr>
</table></p>

<p>When the program attempts to move past the end of the Recordset, possibly as a result of a <I>MoveNext </I>method, an <I>EndOfRecordset </I>error fires:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub rs_EndOfRecordset(fMoreData As Boolean, _
    adStatus As ADODB.EventStatusEnum, _
    ByVal pRecordset As ADODB.Recordset)
</pre>
</td></tr></table></p>

<p>ADO lets you add new records to the Recordset when this event fires. If you want to take advantage of this opportunity, just execute an <I>AddNew </I>method, fill the Fields collection with data, and then set the <I>fMoreData </I>parameter to True to let ADO know that you've added new records. As usual, you can cancel the operation that caused the move by setting the <I>adStatus</I> parameter to adStatusCancel, unless the <I>adStatus </I>parameter contains the value adStatusCantDeny.</p>

<A NAME="588"><h3>Update events</h3></A>
<p>Any time ADO is about to modify one or more fields in a Recordset, it fires the <I>WillChangeField </I>event:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub rs_WillChangeField(ByVal cFields As Long, _
    ByVal Fields As Variant, adStatus As ADODB.EventStatusEnum, _
    ByVal pRecordset As ADODB.Recordset)
</pre>
</td></tr></table></p>

<p><I>cFields </I>is the number of fields that are about to be modified, and <I>Fields </I>is an array of Variants that contains one or more Field objects with pending changes. You can set <I>adStatus </I>to adStatusCancel to cancel the pending update operation, unless it contains the adStatusCantDeny value.</p>

<p>When the update operation is completed, ADO fires a <I>FieldChangeComplete </I>event, which receives the same parameters plus the pError object that lets you investigate any error raised in the meantime (if <I>adStatus </I>is equal to adStatusErrorOccurred):</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub rs_FieldChangeComplete(ByVal cFields As Long, _
    ByVal Fields As Variant, ByVal pError As ADODB.error, _
    adStatus As ADODB.EventStatusEnum, _
    ByVal pRecordset As ADODB.Recordset)
</pre>
</td></tr></table></p>

<p>When one or more records are about to change, ADO fires a <I>WillChangeRecord </I>event:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub rs_WillChangeRecord(ByVal adReason As ADODB.EventReasonEnum, _
    ByVal cRecords As Long, adStatus As ADODB.EventStatusEnum, _
    ByVal pRecordset As ADODB.Recordset)
</pre>
</td></tr></table></p>

<p><I>adReason </I>is one of the enumerated constants listed in Table 13-4, <I>cRecords </I>is the number of records that are going to be modified, and <I>adStatus </I>is the parameter that you can set to adStatusCancel to cancel the operation (unless the <I>adStatus</I> parameter contains the adStatusCantDeny value).</p>

<p>When the update operation is completed, ADO fires a <I>RecordChangeComplete </I>event:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub rs_RecordChangeComplete( _
    ByVal adReason As ADODB.EventReasonEnum, ByVal cRecords As Long, _
    ByVal pError As ADODB.error, adStatus As ADODB.EventStatusEnum, _
    ByVal pRecordset As ADODB.Recordset)
</pre>
</td></tr></table></p>

<p>All the parameters have the same meanings as they do in the <I>WillChangeRecord </I>event. If <I>adStatus </I>is adStatusErrorOccurred, you can query the <I>pError </I>object to find out what went wrong, and you can reject further notifications by setting <I>adStatus </I>to adStatusUnwantedEvent. These two events can occur because of an <I>Update</I>, <I>UpdateBatch</I>, <I>Delete</I>, <I>CancelUpdate</I>, <I>CancelBatch</I>, or <I>AddNew </I>method. During this event, the <I>Filter </I>property is set to the value adFilterAffectedRecords and you can't change it.</p>

<p>Whenever ADO is about to perform an operation that's going to change the contents of the Recordset as a whole&#8212;such as <I>Open</I>, <I>Requery</I>, and <I>Resync </I>methods&#8212;a <I>WillChangeRecordset </I>event fires:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub rs_WillChangeRecordset( _
    ByVal adReason As ADODB.EventReasonEnum,
    adStatus As ADODB.EventStatusEnum, _
    ByVal pRecordset As ADODB.Recordset)
</pre>
</td></tr></table></p>

<p><I>adReason</I> is one of the constants listed in Table 13-4, and <I>adStatus </I>has the usual meaning. If this parameter isn't equal to adStatusCantDeny, you can cancel the operation by setting it to the value adStatusCancel.</p>

<p>When the update operation is complete, ADO fires a <I>RecordsetChangeComplete </I>event:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub rs_RecordsetChangeComplete( _
    ByVal adReason As ADODB.EventReasonEnum, _
    ByVal pError As ADODB.error, _
    adStatus As ADODB.EventStatusEnum, ByVal pRecordset As ADODB.Recordset)
</pre>
</td></tr></table></p>

<p>The parameters here mean the same as they do in the <I>WillChangeRecordset </I>event. One undocumented behavior you should keep in mind is that with a forward-only Recordset, the <I>WillChangeRecordset</I> and <I>RecordsetChangeComplete</I> events also fire whenever you execute the <I>MoveNext </I>method because you're working with a cursorless Recordset; each time you move to another record, ADO re-creates the Recordset object. In general, with any Recordset that doesn't support bookmarks, these events fire whenever the local cache has to be refilled (with a frequency that therefore depends on the <I>CacheSize </I>property).</p>

</BODY>
</HTML>





