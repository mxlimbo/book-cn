<HTML>
<HEAD>
<TITLE>MDI Forms</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch09b.htm", "ch09d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="391"><h1>MDI Forms</h1></A>

<p>MDI stands for Multiple Document Interface and is the type of user interface 
used by most of the applications in the Microsoft Office suite, including Microsoft 
Word, Microsoft Excel, and Microsoft PowerPoint. Many applications lend themselves 
to implementation via an MDI user interface. Whenever you have an application 
that should be able to deal with multiple documents at the same time, an MDI 
interface is probably the best choice.
</p>

<A NAME="392"><h2>MDI Applications</h2></A>

<p>Building Visual Basic MDI applications is simple, as long as you know how to 
make the best use of a few features of the language. You begin developing an MDI 
application by adding an MDIForm module to the current project. An MDIForm 
module is similar to a regular Form module, with just a few peculiarities:
</p>

<UL>
<p><li> You can have only one MDIForm module in each project; after you 
add one MDI module to the current project, the Add MDIForm command 
in the Project menu is disabled, as is the corresponding icon on the 
main toolbar.
</li></p>
<p><li> You can't place most controls directly on an MDIForm surface. More 
specifically, you can create only menus, invisible controls (such as 
Timer and CommonDialog controls), and controls that support the 
<I>Align</I> property (such as PictureBox, Toolbar, and StatusBar controls). The only 
way to show any other control on an MDIForm object is to place it inside 
a container control, typically a PictureBox control.
</li></p>
<p><li> You can't display text or graphics on an MDIForm surface. Again, you 
need to place a PictureBox control and display text or graphics inside it.
</li></p>
</UL>
 
<A NAME="393"><h3>MDI child forms</h3></A>

<p>An MDIForm object contains one or more child forms. To create such child 
forms, you add a regular form to the project and set its 
<I>MDIChild</I> property to True. When you do this, the form's icon in the Project Explorer window changes, as shown 
in Figure 9-11. You don't have to specify which MDI form this form is a child of 
because there can be only one MDIForm module per project.
</p>
<p>An MDI child form can't be displayed outside its parent MDIForm. If an 
MDI child form is the startup form for an application, its parent MDI form is 
automatically loaded and displayed before the child form becomes visible. Apart from the 
startup form, all instances of the MDI child form are created using the 
<I>New</I> keyword:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Inside the MDIForm module
Private Sub mnuFileNew_Click()
    Dim frmDoc As New frmDocument
    frmDoc.Show
End Sub
</pre>
</td></tr>
</table>
</p>
<p>MDIForm modules support an additional property, 
<I>AutoShowChildren</I>. When this property is True (the default value), an MDI child form is displayed inside 
its parent MDI form as soon as you load the parent. In other words, you can't load 
an MDI child form and keep it hidden unless you set this property to False.
</p>
<p>MDI child forms have other peculiarities as well. For example, they don't 
display menu bars as regular forms do: If you add one or more top-level menus to 
an MDI child form, when the form becomes active its menu bar replaces the MDI 
parent form's menu bar. For this reason, it's customary for MDI child forms not to 
include a menu; you define menus only for the main MDIForm module.
</p>
<p>
<A HREF="javascript:fullSize('f09ph11x.htm')"> <img src="images/f09ph11.JPG" width=404 height=303 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-11.</B> <i>The MDI Notepad application at design time.</i><!--/caption-->
</p>

<P>When a menu command is invoked in the MDIForm module, you 
normally apply it to the MDI child form that's currently active, which you do through 
the <I>ActiveForm</I> property. For example, here's how you execute the Close command 
on the File menu:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the MDI parent form
Private Sub mnuFileClose_Click()
    ' Close the active form, if there is one.
    If Not (ActiveForm Is Nothing) Then Unload ActiveForm
End Sub
</pre>
</td></tr>
</table>
</p>
<p>You should always check for an 
<I>ActiveForm</I> because it's possible that no 
MDI child form is currently open, in which case 
<I>ActiveForm</I> returns Nothing. (It doesn't return a reference to the MDIForm itself, as you might expect.) If your MDI 
application supports different kinds of child forms, you often need to figure out which 
form is the active form, as in the code below.
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub mnuFilePrint_Click()
    If TypeOf ActiveForm Is frmDocument Then
        ' Print the contents of a TextBox control.
        Printer.Print ActiveForm.txtEditor.Text
        Printer.EndDoc
    ElseIf TypeOf ActiveForm Is frmImageViewer Then
        ' Print the contents of a PictureBox control.
        Printer.PaintPicture ActiveForm.picImage.Picture, 0, 0
        Printer.EndDoc
    End If
End Sub
</pre>
</td></tr>
</table>
</p>

<A NAME="394"><h3>The Window menu</h3></A>

<p>MDIForm modules support an additional method that's not exposed by regular 
forms: the <I>Arrange</I> method. This method provides a quick way to programmatically 
arrange all the child forms in an MDI application. You can tile all child forms horizontally 
or vertically, you can arrange them in a cascading fashion, or you can line up all 
the minimized forms in an orderly fashion near the bottom of the MDI parent form. 
To this purpose, you usually create a Window menu with four commands: Tile 
Horizontally, Tile Vertically, Cascade, and Arrange Icons. This is the code behind 
these menu items:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub mnuTileHorizontally_Click()
    Arrange vbTileHorizontal
End Sub
Private Sub mnuTileVertically_Click()
    Arrange vbTileVertical
End Sub
Private Sub mnuCascade_Click()
    Arrange vbCascade
End Sub
Private Sub mnuArrangeIcons_Click()
    Arrange vbArrangeIcons
End Sub
</pre>
</td></tr>
</table>
</p>
<p>It's also customary for the Window menu to include a list of all open MDI 
child forms and to let the user quickly switch to any one of them with a click of the 
mouse. (See Figure 9-12.) Visual Basic makes it simple to add this feature to your MDI 
applications: You only have to tick the WindowList option in the Menu Editor for 
the top-level Window menu. Alternatively, you can create a submenu with the list of 
all open windows by ticking the WindowList option for a lower level menu item. In 
any case, only one menu item can have this option ticked.
</p>
<p>
<A HREF="javascript:fullSize('f09ph12x.htm')"> <img src="images/f09ph12.JPG" width=404 height=276 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-12.</B> <i>The Window menu lets you tile and arrange all MDI child windows and quickly switch to any one of them with a click of the mouse.</i><!--/caption-->
</p>

<A NAME="395"><h3>Adding properties to MDI child forms</h3></A>

<p>In Visual Basic 3, writing MDI applications wasn't particularly easy because you 
had to keep track of the status of each MDI child form using an array of UDTs, and it 
was up to you to update this array whenever an MDI child form was created or 
closed. Things are much simpler in Visual Basic 4 and later versions because each form 
can support custom properties and you can store the data right in MDI child form 
modules without the need for a global array of UDTs.
</p>
<p>Typically, all MDI child forms support at least two custom properties, 
<I>Filename</I> and <I>IsDirty</I> (of course, actual names can be different). The 
<I>Filename</I> property stores the name of the data file from where data was loaded, whereas 
<I>IsDirty</I> is a Boolean flag that tells whether data was modified by the user. Here's how these 
properties are implemented in the MDI Notepad sample program:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Inside the frmDocument MDI child form
Public IsDirty As Boolean
Private m_FileName As String

Property Get Filename() As String
    Filename = m_FileName
End Property
Property Let Filename(ByVal newValue As String)
    m_FileName = newValue
    ' Show the filename on the form's Caption.
    Caption = IIf(newValue = &quot;&quot;, &quot;Untitled&quot;, newValue)
End Property

Private Sub txtEditor_Change()
    IsDirty = True
End Sub
</pre>
</td></tr>
</table>
</p>
<p>You need the <I>IsDirty</I> property so that you can ask the user if he or she 
wants to save modified data when closing the form. This is done in the MDI child 
form's <I>Unload </I>event procedure:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_Unload(Cancel As Integer)
    Dim answer As Integer
    If IsDirty Then
        answer = MsgBox(&quot;This document has been modified. &quot; &amp; vbCr _
            &amp; &quot;Do you want to save it?&quot;, vbYesNoCancel + vbInformation)
        Select Case answer
            Case vbNo
                ' The form will unload without saving data.
            Case vbYes
                ' Delegate to a procedure in the main MDI form.
                frmMainMDI.SaveToFile Filename
            Case vbCancel
                ' Refuse to unload the form.
                Cancel = True
        End Select
    End If
End Sub
</pre>
</td></tr>
</table>
</p>


<A NAME="396"><h2>Polymorphic MDI Containers</h2></A>

<p>The MDI Notepad application described in the previous section is perfectly 
functional, but it can't be regarded as a good example of object-oriented design. In fact, 
the MDIForm object breaks the encapsulation of MDI child forms because it 
directly accesses the properties of the txtEditor control. This might appear to be a minor 
defect, but you know that good encapsulation is the key to reusable, easily 
maintainable, bug-free software. I'll demonstrate this concept by offering an alternate way 
to design an MDI application.
</p>

<A NAME="397"><h3>Defining the parent-child interface</h3></A>

<p>If you don't want the parent MDI form to directly access controls on its child 
forms, the solution is to define an interface through which the two forms can talk to 
one another. For example, instead of loading and saving text by manipulating the txtEditor's 
properties, the parent MDI form should ask the child form to load or save a given 
file. Similarly, instead of directly cutting, copying, and pasting data on the txtEditor 
control, the parent MDI form should invoke a method in the child form that does 
the job. The parent MDI form should also query the MDI child form to learn which 
commands should be made available in the Edit menu.
</p>
<p>After playing for a while with MDI projects, I came up with a simple 
interface that's generic enough to fit many MDI applications. In addition to the usual 
<I>Filename</I> and <I>IsDirty</I> properties, this interface includes properties such as 
<I>IsEmpty</I> (True if the MDI child form doesn't contain any data), 
<I>CanSave</I>,<I> CanCut</I>,<I> CanCopy</I>, 
<I>CanPaste</I>, and <I>CanPrint</I>, as well as methods such as 
<I>Cut</I>,<I> Copy</I>,<I> Paste</I>, 
<I>PrintDoc</I>, <I>LoadFile</I>,<I> 
SaveFile</I>,<I> </I>and<I> AskFilename</I> (which uses a 
<I>FileOpen</I> or <I>FileSave</I> common dialog). This 
interface permits you to rewrite the MDI Notepad application without breaking the 
encapsulation of MDI child forms. For example, this is the code that implements the Save 
As command on the File menu in the MDI parent form:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub mnuFileSaveAs_Click()
    ' Ask the document to show a common dialog, and
    ' then save the file with the name selected by the user.
    On Error Resume Next
    ActiveForm.SaveFile ActiveForm.AskFilename(True)
End Sub
</pre>
</td></tr>
</table>
</p>
<p>And this is how the MDI child form implements the 
<I>PrintDoc</I> method:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub PrintDoc()
    Printer.NewPage
    Printer.Print txtEditor.Text
    Printer.EndDoc
End Sub
</pre>
</td></tr>
</table>
</p>
<p>As usual, the complete source code of this new version of the application 
is available on the companion CD. You'll notice that the overall amount of code is 
slightly larger than the original MDI Notepad application. But this new structure has 
several benefits, which will be apparent in a moment.
</p>
<p><div class="note"><blockquote><b>NOTE</b><hr>
In this sample program, I defined a set of properties and methods. 
Then I added them to the primary interface of the frmDocument MDI child form. 
Because the frmMain MDI parent form accesses all its child forms through 
the <I>ActiveForm</I> property, properties and methods of this interface are 
accessed through late binding, which means that you must protect each reference with 
an <I>On Error</I> statement. For a more robust implementation, define a secondary 
interface as an abstract class and implement it in each MDI child form module.
</blockquote></div></p>

<A NAME="398"><H3>Changing the client form's implementation</H3></A>
<p>Because this new version of the MDI parent form never breaks the encapsulation 
of the MDI child forms, you're free to change the implementation of MDI child 
forms without affecting the rest of the application. For example, you can turn the 
Notepad-like program into an MDI image viewer application. In this case, the MDI child 
form hosts a PictureBox control, so you have to modify the implementation of all 
the properties and methods of the interface used for the parent-child communication. 
For example, the <I>PrintDoc</I> method is now implemented as follows:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub PrintDoc()
    Printer.NewPage
    Printer.PaintPicture picBitmap.Picture, 0, 0
    Printer.EndDoc
End Sub
</pre>
</td></tr>
</table>
</p>
<p>Surprisingly, you need to modify fewer than 20 lines of code to morph the 
MDI Notepad application into an image viewer application. But the most interesting 
detail is that you <I>don't need to modify one single line of code in the frmMain 
module</I>. In other words, you have created a reusable, polymorphic MDI parent form!
</p>
<p>Alternatively, if you're willing to slightly modify the parent MDI form's 
code, you can have the same MDI container work for different types of child forms at 
the same time. Figure 9-13 shows this new version of the sample MDI application, 
which hosts text documents and images at the same time. You can add new types of 
child forms or expand the interface to take additional properties and methods into account.
</p>
<p>
<A HREF="javascript:fullSize('f09ph13x.htm')"> <img src="images/f09ph13.JPG" width=404 height=272 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-13.</B> <i>You can reuse the frmMain.frm generic MDI form with different child forms, for example, mini word processors and image viewers.</i><!--/caption-->
</p>
<A NAME="399"><H2>The Application Wizard</H2></A>
<p>
<img src="images/new.jpg" width=102 height=87 border="0"></p>
</p>
<p>Visual Basic 6 comes with a revamped Application Wizard, which is more 
flexible than the one provided with Visual Basic 5 and is tightly integrated with the 
Toolbar Wizard and the Form Wizard.
</p>
<p>The Application Wizard is automatically installed by the Visual Basic 
setup procedure, so you just need to make it available in the Add-In menu by selecting 
it in the Add-In Manager window. When you run the wizard, you can choose 
from among MDI, SDI (Single Document Interface, applications based on standard 
forms), and Windows Explorer-like applications, as you can see in Figure 9-14.
</p>
<p>If you select the MDI option, you're asked to configure your menus 
(Figure 9-15): this tool is so simple to use and so intuitive that you'll probably wish you could 
have it when you're working with the standard Menu Editor.
</p>

<p>
<A HREF="javascript:fullSize('f09ph14x.htm')"> <img src="images/f09ph14.JPG" width=404 height=297 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-14.</B> <i>The Application Wizard: Choosing the interface.</i><!--/caption-->
</p>

<p>
<A HREF="javascript:fullSize('f09ph15x.htm')"> <img src="images/f09ph15.JPG" width=404 height=297 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-15.</B> <i>The Application Wizard: Selecting menus.</i><!--/caption-->
</p>

<P>In the next step, you configure the program's toolbar (Figure 9-16) using 
an embedded wizard. This slick tool is also available outside the Application 
Wizard, and you'll find it in the Add-In menu under the name Toolbar Wizard.
</p>
<p>In subsequent steps, the Application Wizard asks you whether you want 
to use resource files and whether you want to add an item in the Help menu that 
points to your Web site. You can then select additional forms to be added to the 
project (Figure 9-17), choosing among four standard forms and any form templates you 
have defined previously. Finally, you can create any number of data-bound forms: in 
this case, the wizard calls the Data Form wizard, which I illustrated in <a href="ch08a.htm">Chapter 8</a>. In 
the last step, you can decide to save all the current settings to a configuration file 
so that the next time you run the Application Wizard you can speed up the 
process even more.
</p>
<p>
<A HREF="javascript:fullSize('f09ph16x.htm')"> <img src="images/f09ph16.JPG" width=404 height=297 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-16.</B> <i>The Application Wizard: Customizing the toolbar.</i><!--/caption-->
</p>

<p>
<A HREF="javascript:fullSize('f09ph17x.htm')"> <img src="images/f09ph17.JPG" width=404 height=297 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-17.</B> <i>The Application Wizard: Selecting additional forms.</i><!--/caption-->
</p>

<p>While the code delivered by the Application Wizard is a good starting point 
for building your own MDI application, in my opinion it leaves much to be desired. 
The MDI application created by the wizard uses a sample MDI child form that hosts 
a RichTextBox control to build a simple word processor-like application. On 
some occasions, however, the buttons on the toolbar don't work as they should, and 
the code for setting up all common dialogs isn't properly implemented, just to name 
a few shortcomings. Unfortunately, you have no control over the code generated 
by the wizard, so each time you run the wizard you must fix the resulting code by hand.
</p>

</BODY>
</HTML>





