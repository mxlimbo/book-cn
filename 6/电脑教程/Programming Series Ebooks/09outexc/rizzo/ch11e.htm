<HTML>
<HEAD>
<TITLE>Helpdesk Application</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch11d.htm", "ch11f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="365"><H1>Helpdesk Application</H1></A>

<P>Now that we know how to successfully log on to the Exchange Server, let's 
take a look at our first sample application, the Helpdesk application. The 
Helpdesk application is a web-based application that allows users to submit new help 
requests. Help technicians can, in turn, use their web browser to view and answer 
help requests as well as schedule meetings with the users to go on site to solve 
their problems. This application allows the technicians to use different views for 
the help tickets stored in the system so that they can quickly see who the ticket is 
from, when it was sent, and its status. (A help ticket for the Helpdesk application 
is shown in Figure 11-2.) When browsing help tickets, the technicians are 
presented with machine-configuration information from a Microsoft Access 
97 database, making it easier for them to track down whether the issue is 
related to hardware, software, or a user error.</p>

<P>
<A HREF="javascript:fullSize('f11oh02x.htm')"> <img src="images/f11oh02.JPG" width=404 height=320 border=0 ALT="Click to view at full size."> </A>
</P><P>
<!-- CAPTION --><B>Figure 11-2</B> <I>A help ticket in the Helpdesk application. This is the Dynamic HTML version of the application.</I><!-- /CAPTION -->
</p>

<P>This application is the most complex of all the sample applications in 
this book, but the code for it is easy to follow and shows you how to use many 
of the objects in the CDO library. There are actually two versions of the 
application on the companion CD. The version you use depends on the web 
browser you want to target. One version implements a user interface for the 
helpdesk tickets by using Dynamic HTML (DHTML). The other version uses 
HTML tables. A screen from the non-DHTML version is shown in Figure 11-3.</p>

<P>
<A HREF="javascript:fullSize('f11oh03x.htm')"> <img src="images/f11oh03.JPG" width=404 height=302 border=0 ALT="Click to view at full size."> </A>
</P><P>
<!-- CAPTION --><B>Figure 11-3</B> <I>The non-DHTML version of a help ticket.</I><!-- /CAPTION -->
</p>

<A NAME="366"><H2>Setting Up the Helpdesk Application</H2></A>

<P>Before you can install the application, you must have a Windows NT 4.0 
Server and a client with certain software installed. Table 11-1 outlines the 
installation requirements.</p>

<P>To use the Helpdesk application, you will need to have some e-mail 
users. You can either select currently set up e-mail users or add new ones using 
the Exchange Administrator program. Be sure to fill in the directory 
information for your users; this information should include their office locations, 
phone numbers, titles, and departments. The Helpdesk application dynamically 
retrieves this information using the CDO library. If the information is not 
available in the directory, the application will display the text &quot;None specified&quot; 
for these fields.</p>

<P>To install the application, copy the Helpdesk folder from the 
companion CD to your web server where you want to run the application. If you are 
going to use a browser that does not support DHTML, such as Internet 
Explorer 3.0, copy the three .asp files from the nondhtml subfolder to the Helpdesk 
folder, overwriting the current files. These files will replace the DHTML versions 
of the Helpdesk with the HTML versions.</p>

<P><B>Table 11-1</b> <i>Installation Requirements for the Helpdesk Application</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th>Required Software</th>
<th>Installation Notes</th>
</tr><tr>
<td valign="top">Exchange Server 5.5 SP1 with Outlook Web Access</td>
<td valign="top"></td>
</tr><tr>
<td valign="top">IIS 3.0 or higher with Active Server Pages</td>
<td valign="top">IIS 4.0 is recommended.</td>
</tr><tr>
<td valign="top">CDO library (cdo.dll)<br>CDO Rendering library (cdohtml.dll)</td>
<td valign="top">Exchange Server 5.5 SP1 installs CDO library 1.21 and CDO Rendering library 1.21. Outlook 98 installs CDO library 1.21.</td>
</tr><tr>
<td valign="top">ActiveX Data Objects</td>
<td valign="top">IIS 4.0 installs ADO 1.5.<br> Visual Basic 6.0 installs ADO 2.0.<br>For more information on ADO, consult <I>http://www.microsoft. com/data/.</I></td>
</tr><tr>
<td valign="top">Access 97 (optional)</td>
<td valign="top">Install Access 97 if you want to utilize the database access feature.</td>
</tr><tr>
<td valign="top"><B><I>For the client:</I></B><br>A web browser<br>Outlook 98</td>
<td valign="top">For the web browser, Microsoft Internet Explorer 4.0 is recommended. You can run the client software on the same machine or on a separate machine.</td>
</tr>
</table></p>

<p>Start the IIS administration program. The user interface you see 
depends on what version of IIS you have. Create a virtual directory that points to 
the location where you copied the help desk files, and name the virtual 
directory <I>helpdesk</I>. Make sure you enable the Execute permissions option for the 
virtual directory or you will receive an HTTP error when attempting to access 
the application. You will be able to use the following URL to access your help 
desk: <I>http://</I>yourservername<I>/helpdesk.</I></p>

<P>Included with the helpdesk files on the companion CD is a sample 
Access 97 database (smsdata.mdb) that allows the application to query for system 
information about the current user. To use this database, you must set up a 
system DSN for it on the server machine by using the ODBC Data Source 
Administrator in the Control Panel. Point the system DSN at the smsdata.mdb file, 
and name the DSN <I>Helpdesk</I>. Make sure that the read-only flag is unchecked for 
the smsdata.mdb file. Open smsdata.mdb in Access and edit the Userid fields 
for all three tables to reflect the display names of the users you have in Exchange.</p>

<P><DIV CLASS="NOTE"><BLOCKQUOTE><B>NOTE</B><HR>
Files copied from CDs have their read-only flags set. 
When setting up the applications included with this book, be aware that 
you may need to clear this read-only flag after copying files from the 
companion CD.
</BLOCKQUOTE></DIV></P>

<P>Launch Microsoft Outlook. (You can launch it on any machine because 
you are going to create a public folder that will contain the help tickets for the 
application. The only requirement is that the Exchange Server with which the 
IIS server is communicating can access the public folder you create.) Create a 
new public folder under All Public Folders. Name the folder 
<I>Helpdesk</I>, and select Task Items as the default item type for the folder.</p>

<P><DIV CLASS="NOTE"><BLOCKQUOTE><B>NOTE</B><HR>
You must install the Helpdesk folder under All Public 
Folders or the application will not work. If you cannot install the 
application there, you can modify the code contained in the 
Helpdesk application so that it looks for the folder in another location, or 
you can retrieve the folder by using its EntryID.
</BLOCKQUOTE></DIV></P>

<P>Among the helpdesk files, you will find a file named helpdesk.fdm. 
This file is a form definition file that will be used to import the correct fields 
needed by the Helpdesk application. In this case, the form is a Help Request task 
form with multiple custom fields.</p>

<P>To install the Help Request form, you need to import this file in to 
the Helpdesk public folder. To do this, right-click on the Helpdesk public 
folder and select Properties. Click on the Forms tab, and click Manage to display 
the Forms Manager, as shown in Figure 11-4.</p>

<P>In the Forms Manager dialog box, click Install to display the Open 
dialog box. Select the All Files option from the Files Of Type drop-down list 
so that Outlook does not search only for files with a .cfg extension. Locate 
and double-click on the helpdesk.fdm file to display the Form Properties dialog 
box. Click Cancel, and then click Close and OK. When you have the Helpdesk 
public folder selected, you should see a new option on the Actions menu named 
New Helpdesk Request.</p>

<P>You will need to create some views in the Outlook client so that these 
views are available to the web browser client. This is one of the powerful features 
of CDO. These views will include some of the custom fields from the Help 
Request form just installed. Using the Define Views dialog box and the information 
in Table 11-2, create the Helpdesk, From, and Status views for the Helpdesk 
public folder. (For information about creating views, see the section titled 
&quot;<A HREF="ch02c.htm#55">Views</A>&quot; in Chapter 4.)</p>

<P>
<A HREF="javascript:fullSize('f11oh04x.htm')"> <img src="images/f11oh04.JPG" width=404 height=263 border=0 ALT="Click to view at full size."> </A>
</P><P>
<!-- CAPTION --><B>Figure 11-4</B> <I>The Forms Manager dialog box.</I><!-- /CAPTION -->
</p>

<P><B>Table 11-2</B> <i>Information for Creating Helpdesk, From, and Status Views</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th>View Name</th>
<th>Type</th>
<th>Fields</th>
<th>Group By</th>
</tr>
<tr>
<td valign="top">Helpdesk</td>
<td valign="top">Table</td>
<td valign="top">Flag, From User (select from Help Request form) Received, Subject (select from All Mail Fields)</td>
<td valign="top">None</td>
</tr>
<tr>
<td valign="top">From</td>
<td valign="top">Table</td>
<td valign="top">Flag (select from Help Request form) Received, Subject (select from All Mail Fields)</td>
<td valign="top">From User, in ascending order</td>
</tr>
<tr>
<td valign="top">Status</td>
<td valign="top">Table</td>
<td valign="top">From User (select from Help Request form) Received, Subject (select from All Mail Fields)</td>
<td valign="top">Flag, in ascending order</td>
</tr>
</table></p>
              
<p>Using the Properties dialog box in Outlook for the Helpdesk public 
folder, set the permissions for your users. Give regular users who will submit help 
tickets Create Items permission. Give technicians who can submit, view, and 
resolve help tickets Create Items and Read Items permissions. Figure 11-5 shows 
a sample permissions setup for the Helpdesk folder. As you will see, the 
application checks the permissions of the current user for the Helpdesk folder to 
determine whether the user is a technician or just a regular user. If you do not 
give yourself at least Read Items permissions, you will not be able to see the 
menu option View Current Help Tickets in the Helpdesk application.</p>

<P>
<A HREF="javascript:fullSize('f11oh05x.htm')"> <img src="images/f11oh05.JPG" width=404 height=278 border=0 ALT="Click to view at full size."> </A>
</P><P>
<!-- CAPTION --><B>Figure 11-5</B> <I>The Permissions tab of the Properties dialog box for the Helpdesk public folder. Regular users have Create Items permissions, and technicians have Create Items and Read Items permissions.</I><!-- /CAPTION -->
</p>

<P>You're finished setting up the application. Try connecting your 
browser to <I>http://</I>yourservername<I>/helpdesk</I> to access the application.</p>

<A NAME="367"><H2>Helpdesk CDO Session Considerations</H2></A>

<P>You need to be aware of certain issues when building ASP-based 
applications with CDO, like the Helpdesk application. Recall from <A HREF="ch08a.htm">Chapter 8</A> that the 
ASP Session object, which is created when a new user connects to your web 
application, maintains the user state for web applications. ASP, in turn, runs 
the <I>Session_OnStart</I> subroutine in the Global.asa file. When a user's session 
times out or the user abandons the session, ASP runs the 
<I>Session_OnEnd</I> subroutine in the Global.asa file. This might seem simple enough, but the most 
common problem developers run into with CDO applications is not putting in the 
correct code in the <I>Session_OnStart</I> and <I>Session_OnEnd</I> subroutines in the 
Global.asa. If you do not put the correct code in these subroutines, you could get an 
ASP 0115 error, which indicates that a trappable error has occurred in an 
external object. Your ASP application will cease working until you restart the web 
server. To help you better understand what you need to do as a CDO developer, 
and to help you avoid this error in your application, let me explain in more 
detail exactly what happens when a user logs on and off an Exchange Server in a 
CDO ASP application. I'll do this by showing you the Global.asa file from the 
Helpdesk application:</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
&lt;SCRIPT LANGUAGE=VBScript RUNAT=Server&gt; 
Sub Application_OnStart
    On Error Resume Next
    Set objRenderApp = Server.CreateObject(&quot;AMHTML.Application&quot;)
    If Err = 0 Then
        Set Application(&quot;RenderApplication&quot;) = objRenderApp
    Else
        Application(&quot;startupFatal&quot;) = Err.Number
        Application(&quot;startupFatalDescription&quot;) = _
            &quot;Failed to create application object&lt;br&gt;&quot; &amp; _
            Err.Description
    End If
    Application(&quot;hImp&quot;) = 0
    'Load the configuration information from the Registry
    objRenderApp.LoadConfiguration 1, _
        &quot;HKEY_LOCAL_MACHINE\System\CurrentControlSet\&quot; &amp; _
        &quot;Services\MSExchangeWeb\Parameters&quot;
    Application(&quot;ServerName&quot;) = objRenderApp.ConfigParameter(&quot;Server&quot;)
    Err.Clear
End Sub 

Sub Application_OnEnd
    Set Application(&quot;RenderApplication&quot;) = Nothing
End Sub

Sub Session_OnStart
    On Error Resume Next
    'This is a handle to the security context. 
    'It will be set to the correct value when a
    'CDO session is created.
    Session(&quot;hImp&quot;) = 0
    Set Session(&quot;AMSession&quot;) = Nothing
End Sub 

'While calling the Session_onEnd event, IIS doesn't call us in
'the right security context.
'Workaround: current security context is stored in Session
'object and then gets restored in Session_onEnd event handler.
'
'All CDO and CDO Rendering library objects stored in the
'Session object need to be explicitly set to Nothing between
'the two objRenderApp.Impersonate calls below
Sub Session_OnEnd
    On Error Resume Next
    set objRenderApp = Application(&quot;RenderApplication&quot;)
    fRevert = FALSE
    hImp = Session(&quot;hImp&quot;)
    If Not IsEmpty(hImp) Then
        fRevert = objRenderApp.Impersonate(hImp)
    End If
    'Do our cleanup. Set all CDO and CDOHTML objects inside
    'the session to Nothing.
    'The CDO session is a little special because we need to do
    'the Logoff on it.
    Set objOMSession = Session(&quot;AMSession&quot;)
    If Not objOMSession Is Nothing Then
        Set Session(&quot;AMSession&quot;) = Nothing
        objOMSession.Logoff
        Set objOMSession = Nothing
    End If
    If (fRevert) Then
        objRenderApp.Impersonate(0)
    End If
End Sub 
&lt;/SCRIPT&gt;
</PRE></TD></TR></TABLE></P>

<P>When the first user connects to the application, the 
<I>Application_OnStart</I> subroutine is run only once. As you can see in the code, the first step is to 
create a new CDO rendering application from the CDO Rendering library. The 
ProgID for the CDO rendering application is AMHTML.Application. The 
rendering application is stored in an application-level variable so that you avoid 
creating multiple AMHTML objects. Your application will perform better if you 
create the AMHTML object once and then use it throughout all user sessions.</p>

<P><DIV CLASS="NOTE"><BLOCKQUOTE><B>NOTE</B><HR>
CDO was formerly named Active Messaging, so you 
will see both CDO and AM used throughout the CDO library. 
Consider any objects that are prefixed with AM to be CDO objects.
</BLOCKQUOTE></DIV></P>

<P>The <I>Application_OnStart</I> subroutine initializes some variables and 
then uses a method on the CDO rendering application object to retrieve the 
name of the Exchange Server from the web server's Registry. This method 
allows portability of the code. You don't have to hard-code the name of the 
Exchange Server; the Helpdesk application pulls the information from the Registry.</p>

<P>After the first user connects and 
<I>Application_OnStart</I> is finished running, ASP runs the 
<I>Session_OnStart</I> subroutine for all users. 
<I>Session_OnStart</I> clears a session variable named 
<I>hImp</I>. This <I>hImp</I> variable is a handle to the 
security context for the current user. Remember that when a user first browses a 
web page in IIS, she is running in the security context of the 
IUSR_<I>servername</I> account. While this account is useful for browsing web pages anonymously, it 
is not useful for accessing Exchange Server objects and information because it 
has no implicit permissions on Exchange Server objects. So when building an 
authenticated CDO application, you need to force IIS to challenge the current 
user for the user's Microsoft Windows NT credentials. IIS and CDO can use 
the Windows NT security context for that user to attempt a logon to the 
Exchange Server. The following code, taken from the Logon.inc file of the 
Helpdesk application, checks the HTTP variables to make sure that the current user 
is authenticated by the web server using the user's Windows NT credentials. 
In the Helpdesk application, this section of code is called by every ASP page, 
just in case the ASP session of the user has timed out.</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
Public Function BAuthenticateUser
    On Error Resume Next
    'Response.Write( &quot;In BAuthenticateUser&lt;br&gt;&quot;)
    BAuthenticateUser = False
    bstrAT = Request.ServerVariables(&quot;AUTH_TYPE&quot;)
    If InStr(1, &quot;_BasicNTLM&quot;, bstrAT, vbTextCompare) &lt; 2 Then
        Response.Buffer = TRUE
        Response.Status = (&quot;401 Unauthorized&quot;)
        Response.AddHeader &quot;WWW.Authenticate&quot;, &quot;Basic&quot;
        Response.End
    Else
        BAuthenticateUser = True
    End If
End Function
</PRE></TD></TR></TABLE></P>

<P>This function searches the AUTH_TYPE server variable to see 
whether either Basic or NTLM is contained anywhere in the string. If either is not, 
the user is unauthenticated and the script sends back a &quot;401 Unauthorized&quot; 
response and a header which will force the browser to challenge the user for credentials.</p>

<p>Once authenticated, the security context of the user must be saved as 
a <I>Session</I> variable. You must save this security context because IIS uses 
multiple threads of execution and you cannot be guaranteed that the thread that 
tries to destroy the session when the user logs off will be the same thread used 
to create the session. In the <I>Session_OnEnd</I> subroutine, the script checks to 
see whether <I>hImp</I> is not empty, implying it is a valid handle. If 
<I>hImp</I> is not empty, <I>hImp</I> is used to specify the Windows NT security context to impersonate. 
Once the CDO and CDO Rendering objects are set to Nothing and the session 
is logged off, the CDO Rendering application object reverts from the 
authenticated thread to the unauthenticated thread by calling the 
<I>Impersonate</I> method, with <I>0</I> as the parameter.</p>

<p>As we step through the Helpdesk application, you will see that every 
page in the application checks to see whether the ASP session, and therefore 
the CDO session, has been abandoned or has timed out. If the session has 
been abandoned or has timed out, the application redirects the user to the 
logon page so that he can restart his ASP and CDO sessions. Figure 11-6 shows 
the logon page.</p>

<P>
<A HREF="javascript:fullSize('f11oh06x.htm')"> <img src="images/f11oh06.JPG" width=404 height=320 border=0 ALT="Click to view at full size."> </A>
</P><P>
<!-- CAPTION --><B>Figure 11-6</B> <I>The logon page for the Helpdesk application.</I><!-- /CAPTION -->
</p>

<A NAME="368"><H2>Logging On to the Helpdesk</H2></A>

<P>You've seen that both the Global.asa and the Logon.inc files help to 
authenticate users and maintain sessions. We have not yet discussed, however, how you 
actually use the <I>Logon</I> method of the CDO Session object in the Helpdesk 
application to create a valid session with the Exchange Server. The 
<I>Logon</I> method must be called before you attempt to access any other CDO objects. The script 
that implements user logons is contained in the Logon.inc file, shown here:</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
&lt;%
'logon.inc.  VBScript methods to create and check an 
'ActiveMessaging session

'============================
'ReportError
' 
'============================
Function ReportError( bstrContext)
    ReportError= False
    If Err.Number &lt;&gt; 0 Then
        Response.Write( &quot;Error: &quot; &amp; bstrContext &amp; &quot; : &quot; &amp; _
            Err.Number &amp; &quot;: &quot; &amp; Err.Description &amp; &quot;&lt;br&gt;&quot;)
        Err.Clear
        ReportError= True
    End If
End Function

'============================
'BAuthenticateUser
'Ensures user is authenticated. Note that this implies that 
'Basic authentication is enabled on the IIS server.
'============================
Public Function BAuthenticateUser
    On Error Resume Next
    'Response.Write( &quot;In BAuthenticateUser&lt;br&gt;&quot;)
    BAuthenticateUser = False
    bstrAT = Request.ServerVariables(&quot;AUTH_TYPE&quot;)
    If InStr(1, &quot;_BasicNTLM&quot;, bstrAT, vbTextCompare) &lt; 2 Then
        Response.Buffer = TRUE
        Response.Status = (&quot;401 Unauthorized&quot;)
        Response.AddHeader &quot;WWW.Authenticate&quot;, &quot;Basic&quot;
        Response.End
    Else
        BAuthenticateUser = True
    End If
End Function

'============================
'CheckAMSession
' 
'Checks for and returns the AM session in the Session object. 
'If not found, calls NoSession().
'Call this before emitting any HTML or any redirects, 
'authentication, etc.
'Returns True if session exists or can be created.
'============================
Public Function CheckAMSession()
    On Error Resume Next
    'Response.Write( &quot;In GetSession&lt;br&gt;&quot;)
    Dim amSession
    CheckAMSession= False
    Set amSession= Session( &quot;AMSession&quot;)
    If amSession Is Nothing Then
        NoSession
        amSession= Session( &quot;AMSession&quot;)
    End If
    If Not amSession Is Nothing Then
        CheckAMSession= true
    End If
End Function

'============================
'NoSession
' 
'Called when the AM session cannot be found. 
'Either creates a session or gets more info from the user. 
'Returns only if the session was created.
' 
'============================
Sub NoSession()
    On Error Resume Next
    Dim bstrMailbox
    Dim bstrServer
    Dim bstrProfileInfo
    Dim objAMSession1
    Dim objRenderApp
    Dim objInbox
    bstrServer = Application(&quot;ServerName&quot;)
    if Session(&quot;mailbox&quot;) is Nothing then
        bstrMailbox = Request.QueryString(&quot;Contact_Email&quot;)
    else
        bstrMailbox = Session(&quot;mailbox&quot;)
    end if
    'Must be authenticated to successfully log on
    BAuthenticateUser
    Err.Clear
    Set objAMSession1 = Server.CreateObject(&quot;MAPI.Session&quot;)
    If Not ReportError( &quot;create MAPI.Session&quot;) Then
        set objRenderApp = Application( &quot;RenderApplication&quot; )
        'Construct the ActiveMessaging profile from server 
        'and mailbox name
        bstrProfileInfo = bstrServer + vbLF + bstrMailbox
        Err.Clear
        objAMSession1.Logon &quot;&quot;, &quot;&quot;, False, True, 0, True, _
            bstrProfileInfo 
        If Not ReportError( &quot;CDO Logon&quot;) Then
        'To ensure that we are really logged on, we need to 
        'try retrieving
        'some data
            Err.Clear
            Set objInbox = objAMSession1.Inbox
            'If ReportError( &quot;Get Inbox&quot;) Then
            'The logon is no good. We'll do a little
            'cleanup here.
            If err.number &lt;&gt; 0 then 
                objAMSession1.Logoff
                Set objAMSession1 = Nothing
                %&gt;
                &lt;META HTTP-EQUIV=&quot;REFRESH&quot; CONTENT=&quot;0; 
                URL=email.asp&quot;; TARGET=&quot;_top&quot;&gt;
                &lt;%
                'response.redirect &quot;default.htm&quot;
            End If
            'This will be retrieved in CheckSession.
            'Note that if the logon failed, this is set to 'Nothing'.
            Set Session(&quot;AMSession&quot;) = objAMSession1
            'Need this to re-create the proper security context
            'in Session_OnEnd.
            Session(&quot;hImp&quot;) = objRenderApp.ImpID
        End If    'objAMSession1.Logon
    End If   'Server.CreateObject()
End Sub
</PRE></TD></TR></TABLE></P>

<P>The first function called on every ASP page in the Helpdesk application 
is the <I>CheckAMSession</I> function, which checks to see whether the user already 
has a valid CDO Session object with the Exchange Server. If this function does 
not find a valid object, it calls the 
<I>NoSession</I> subroutine to log the user on to CDO.</p>

<p>In the <I>NoSession</I> subroutine, the variable 
<I>bstrServer</I> is set to the Exchange Server name, which is pulled from the Registry in the Global.asa file. 
(Again, retrieving the Exchange Server name from the Registry allows the 
portability of the code to any web server and any Exchange Server.) The script then 
checks to see whether the ASP Session variable named 
<I>mailbox</I> contains a valid mailbox alias name. If this variable is empty, the script attempts to grab the 
mailbox name from the URL that was passed to the web server by the logon screen 
of the application.</p>

<p>The <I>BAuthenticateUser</I> function is called to ensure that the user is 
logged on to Windows NT correctly before the code attempts the CDO Session 
<I>Logon</I> method. After the CDO object is created, its 
<I>Logon</I> method is called. The variable 
<I>bstrProfileInfo</I> is set so that CDO can dynamically create a profile for 
the user. The script calls the <I>Logon</I> method, and if that method returns no 
errors, the script tries to retrieve the Inbox for the user. You should follow similar 
steps in your applications because the 
<I>Logon</I> method can return successfully when called with dynamic profiles, even when the server or mailbox name is not 
valid. If you do not try to retrieve information from the server directly and 
assume the Session object is valid because the method returned successfully, you 
will run into many problems.</p>

<p>If the code cannot retrieve the user's Inbox successfully, the code logs 
off and redirects the user to the logon page. If the code can retrieve the Inbox, 
it stores the handle to the security context for this user in the 
<I>hImp</I> session variable.</p>

<A NAME="369"><H2>Accessing Folders in the Helpdesk</H2></A>

<P>You don't have much of a Helpdesk application if your users can't enter 
information and your technicians can't retrieve information. This Helpdesk 
application uses a public folder to store and retrieve information about ticket 
status. CDO provides access to public folders through its InfoStores collection, 
which contains all the different stores or databases that CDO can access. For 
example, with the InfoStores collection, you can access not only public folders and 
server-based mailboxes, but also personal folders stored in .pst files or offline 
replicated folders stored in .ost files. Of course, to enable CDO to access some of 
these infostores, you must run your CDO application on the client machine. 
Figure 11-7 shows the InfoStores collection with some of its child objects.</p>

<P>
<A HREF="javascript:fullSize('F11oh07x.htm')"> <img src="images/F11oh07.JPG" width=404 height=440 border=0 ALT="Click to view at full size."> </A>
</P><P>
<!-- CAPTION --><B>Figure 11-7</B> <I>The InfoStores collection in CDO. This collection is used to access data stored in Exchange Server.</I><!-- /CAPTION -->
</p>

<P>In the Helpdesk application, the InfoStores collection is used to find 
the public folder store. The following code from default.asp uses a For...Each 
statement to loop through the InfoStores collection and retrieve each store in 
the collection. Each store is checked to see whether the store name corresponds 
to the public folder store. If a corresponding store name is found, the 
For...Each statement is exited.</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
Set objInfoStoresColl = objOMSession.InfoStores
for each objInfoStore in objInfoStoresColl
    If objInfoStore.Name = &quot;Public Folders&quot; Then
        exit for
    end if
next
</PRE></TD></TR></TABLE></P>

<P>Now that the application has the correct infostore, the correct set of 
folders needs to be accessed in that infostore. The InfoStore object in CDO has 
a RootFolder property that returns a Folder object representing the root of 
all the folders. For your mailbox and public folder stores, the RootFolder 
property returns a Folder object named IPM_Subtree. By using that Folder 
object, you can traverse through all folders in your mailbox or top-level public 
folders. However, note one caveat with this property: you cannot use the 
RootFolder property to access public folders if your application is running as a Windows 
NT service. Instead, you need to use the Fields collection on the InfoStores 
object with the specific property tag 
PR_IPM_PUBLIC_FOLDERS_ENTRYID (&amp;H66310102). Once you retrieve the EntryID for the root public folder 
from the Fields collection, you can use the 
<I>GetFolder</I> method to actually retrieve the root Public Folder. (An EntryID is like a GUID in that it uniquely 
identifies the folder in the Exchange Server database.) After retrieving the root folder, 
you can then use the Folders collection of the root public folder to retrieve the 
root folder's subfolders. The following code, taken from default.asp, shows the 
<I>GetFolder</I> method in action. It retrieves the folders in the public folder tree, 
and then recurses the top-level folders as it searches for the Helpdesk folder.</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
'This is the EntryID for the root public folder
bstrPublicRootID = objInfoStore.Fields.Item( &amp;H66310102 ).Value

Set myrootfolder = objOMSession.GetFolder(bstrPublicRootID, _
    objInfoStore.ID)
'Now get the Folders collection below the root
Set myfoldercollect = myrootfolder.Folders
Set recursefolder = myfoldercollect.GetFirst()
'Recurse it until we get the folder we are looking for
While recursefolder.Name &lt;&gt; &quot;Helpdesk&quot;
    Set recursefolder = myfoldercollect.GetNext()
Wend
set objFolder = recursefolder
set Session(&quot;HelpdeskFolder&quot;) = recursefolder
Session(&quot;InfoStoreID&quot;) = objInfoStore.ID
</PRE></TD></TR></TABLE></P>

<P>Once the code finds the Helpdesk folder, it stores the CDO Folder 
object that corresponds to the Helpdesk folder as well as the unique identifier for 
the public folder<B> </B>InfoStore object because, from a performance standpoint, 
recursing the InfoStores and Folders collection in every ASP page in the Helpdesk 
application to find this information is expensive. Since we now have this 
information available across the entire session, the other pages use the Session 
object for the folder whenever access to the Helpdesk folder is required.</p>

<A NAME="370"><H2>Implementing Helpdesk Folder Security</H2></A>

<P>When a user logs on to the Helpdesk application, the options displayed 
depend on the user's folder permissions. For example, if a user accesses the 
application and she has only Create Items permission for the Helpdesk folder, the ASP 
will display only the Submit A Helpdesk Ticket and Logoff options, as shown 
in Figure 11-8. However, if a technician who has Read Items and Create 
Items permissions for the Helpdesk folder logs on to the application, the ASP 
will display an additional menu option&#8212;View Current Help Tickets, as shown 
in Figure 11-9.</p>

<p>
<A HREF="javascript:fullSize('f11oh08x.htm')"> <img src="images/f11oh08.JPG" width=404 height=320 border=0 ALT="Click to view at full size."> </A>
</P><P>
<!-- CAPTION --><B>Figure 11-8</B> <I>The Helpdesk Menu page, where the user who has logged on has Create Items permissions for the Helpdesk folder.</I><!-- /CAPTION -->
</p>

<p>This functionality is implemented in CDO by using the Fields 
collection on the Folder object. The Fields collection, a common collection across 
many of the objects in CDO, allows you to access specific properties stored for 
an object that CDO does not have an explicit object or property for. With the 
Fields collection, you can pass in a unique identifier that corresponds to the 
properties you want to retrieve. In the next section of Helpdesk code, which is 
from the default.asp file, we pass in the unique identifier for the MAPI 
property ActMsgPR_ACCESS (&amp;H0FF4003), which contains a bitmask of flags 
corresponding to the user's permissions level for the current Folder object. The 
code then performs a logical AND on the returned value from the Fields 
collection by using the known bitmask of the MAPI_ACCESS_READ permission. If 
the result does not equal zero, the user can read items in the folder, and the 
ASP displays the View Current Help Tickets link in the helpdesk menu.</p>

<P>
<A HREF="javascript:fullSize('f11oh09x.htm')"> <img src="images/f11oh09.JPG" width=404 height=320 border=0 ALT="Click to view at full size."> </A>
</P><P>
<!-- CAPTION --><B>Figure 11-9</B> <I>The Helpdesk Menu page, where the user logged on is a technician and has Create Items and Read Items permissions for the Helpdesk folder.</I><!-- /CAPTION -->
</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
&lt;h2&gt;Please choose an option:&lt;/h2&gt;
&lt;a href=&quot;default1.asp&quot;&gt;Submit a helpdesk ticket&lt;/a&gt;&lt;P&gt;

&lt;%
'Check permissions on the folder to see whether the user has
'read access. If the user does, the user must be a technician, 
'so display the ability to view help tickets.
nAccess = objFolder.Fields.Item(ActMsgPR_ACCESS)
bCanPost = nAccess And MAPI_ACCESS_READ
If bCanPost &lt;&gt; 0 then
%&gt;
&lt;a href=&quot;render.asp&quot;&gt;View current help tickets&lt;/a&gt;
&lt;% end if %&gt;
&lt;P&gt;
&lt;a href=&quot;logoff.asp&quot;&gt;Logoff&lt;/a&gt;
</PRE></TD></TR></TABLE></P>

<P>You can pass many types of identifiers to the Fields collection. The 
Helpdesk application does not use the CdoPR_CONTAINER_CLASS 
(&amp;H3613001E) property, but I point it out to you because it demonstrates the type of 
information you can access through the Fields collection on CDO objects. It 
contains the message class of the default type of item contained in the folder. For 
example, if in Outlook you set the default item type for a Public Folder as contacts, 
the CdoPR_CONTAINER_CLASS property will contain 
<I>IPF.Contact</I>. How do you change the default item type in a folder programmatically through CDO? 
By using the Fields collection on a folder and this property, as shown in the 
next bit of sample code, the code changes the default item type of a folder to 
tasks. The code uses the InfoStores collection to retrieve the mailbox of the user. 
It then retrieves the root folder of the mailbox by using the RootFolder 
property. From that root folder, it retrieves the contacts folder in the mailbox. The 
next line of code uses the Fields collection on the folder to set a property that 
corresponds to the default item type for the folder. Finally, to make the default 
item-type change permanent, the <I>Update</I> method of the Folder object is 
called, committing the changes to the disk memory.</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
Set oStore = oSession.InfoStores(&quot;Mailbox - Thomas Rizzo (Exchange)&quot;)
Set oFolder = oStore.RootFolder.Folders(&quot;Contacts&quot;)
MsgBox &quot;Before Update: &quot; &amp; oFolder.Fields(&amp;H3613001E)
oFolder.Fields(&amp;H3613001E) = &quot;IPF.Tasks&quot;
oFolder.Update
MsgBox &quot;After Update: &quot; &amp; oFolder.Fields(&amp;H3613001E)
</PRE></TD></TR></TABLE></P>

<P><DIV CLASS="NOTE"><BLOCKQUOTE><B>NOTE</B><HR>
For the most complete list of the identifiers you can 
use with the Fields collection in your applications, refer to the 
cdo.chm on the companion CD. On the Contents tab, look under the 
Appendixes section for the MAPI Property Tags document.
</BLOCKQUOTE></DIV></P>

<A NAME="371"><H2>Retrieving User Directory Information</H2></A>

<P>If the user clicks on the Submit A Helpdesk Ticket option on the helpdesk 
menu, the file default1.asp is called. This ASP file displays a help request form, 
which is shown in Figure 11-10.</p>

<p>As you can see in Figure 11-10, some information about the user is 
already entered in the help request form. This information is dynamically pulled 
from the Exchange Server directory to help users save time when filling out 
requests. The enabling technology for this dynamic lookup involves primarily two 
CDO objects, the Recipient object and the AddressEntry object. A diagram 
illustrating the hierarchy of these two objects is shown in Figure 11-11.</p>

<p>
<A HREF="javascript:fullSize('f11oh10x.htm')"> <img src="images/f11oh10.JPG" width=404 height=301 border=0 ALT="Click to view at full size."> </A>
</P><P>
<!-- CAPTION --><B>Figure 11-10</B> <I>The help request form allows users to post information to the Helpdesk application.</I><!-- /CAPTION -->
</p>

<p>
<A HREF="javascript:fullSize('F11oh11x.htm')"> <img src="images/F11oh11.JPG" width=404 height=286 border=0 ALT="Click to view at full size."> </A>
</P><P>
<!-- CAPTION --><B>Figure 11-11</B> <I>The Recipients collection and Recipient object in CDO.</I><!-- /CAPTION -->
</p>

<P>The Recipient object represents a recipient of a message. You might 
be wondering why a Recipient object is used to retrieve directory information 
from Exchange Server. There are two primary reasons for this. The first is that 
CDO does not explicitly support querying for directory information without 
first retrieving the AddressEntry object for the desired user. The second is that 
adding the name of the user to a message as a Recipient, and then using the 
<I>Resolve</I> method of the Recipient object, is probably the easiest way to retrieve 
the AddressEntry object for a particular user. After resolving the name, you can 
call the AddressEntry property on the resolved Recipient object to retrieve 
the corresponding AddressEntry object. Just make sure you destroy the 
temporary objects you created for the Message and Recipient objects. The 
AddressEntries collection and AddressEntry object in CDO are shown in Figure 11-12.</p>

<P>
<A HREF="javascript:fullSize('F11oh12x.htm')"> <img src="images/F11oh12.JPG" width=404 height=271 border=0 ALT="Click to view at full size."> </A>
</P><P>
<!-- CAPTION --><B>Figure 11-12</B> <I>The AddressEntries collection and AddressEntry object in CDO.</I><!-- /CAPTION -->
</p>

<P>The AddressEntry object contains the directory and address information 
for a user in the Exchange Server system. You can use the built-in properties of 
this object to access the e-mail address information for a particular user, but to 
access directory information (department, office location, and phone number), you 
must use the Fields collection of the AddressEntry object with MAPI property tags. 
The code sample below, which is taken from 
default1.asp, shows you how the Helpdesk application implements directory lookup for users.</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
Set objmessage = objOMSession.Outbox.Messages.Add
'Create the recipient
Set objonerecip = objmessage.Recipients.Add
'Retrieve the e-mail address from the previous HTML form
objonerecip.Name = Session(&quot;mailbox&quot;)
'Resolve the name against the Exchange Server directory
objonerecip.Resolve
'Get the address entry so that we can pull out template info
Set myaddentry = objonerecip.AddressEntry
Set myfields = myaddentry.Fields
'The numbers in parens are the hard-coded IDs for dept, title, etc.
Set mydept = myfields.Item(974651422).value
set mytitle = myfields.Item(974585886).value
set myworkphone = myfields.Item(973602846).value
set myoffice = myfields.Item(974716958).value
if mydept = &quot;&quot; then
    mydept = &quot;None specified&quot;
end if
if mytitle = &quot;&quot; then
    mytitle = &quot;None specified&quot;
end if
if myworkphone = &quot;&quot; then
    myworkphone = &quot;None specified&quot;
end if
if myoffice = &quot;&quot; then
    myoffice = &quot;None specified&quot;
end if
set objmessage = Nothing
set objonerecip = Nothing
</PRE></TD></TR></TABLE></P>

<P>First this code adds a new message to the Outbox of the user by 
calling the <I>Add</I> method on the Outbox folder. Then the code adds a new 
Recipient object to the message. Since the ASP session contains the display name of the 
current user, this value is passed in as the Name property for the recipient. The 
code then calls the <I>Resolve</I> method on the Recipient object to make CDO 
check for ambiguous names in the directory. Once the user is resolved, the 
AddressEntry object for the user is retrieved using the AddressEntry property of 
the Recipient object.</p>

<p>From there, the Fields collection of the AddressEntry object is 
retrieved. The code then uses some MAPI property identifiers to retrieve specific 
information from the directory. If the information is unavailable in the directory, 
the code specifies that the value for the variables be &quot;None specified&quot;. To make 
sure that the temporary Message and Recipient objects are released from 
memory, the code sets both objects to Nothing.</p>

<A NAME="372"><H2>Posting Information in the Helpdesk</H2></A>

<P>Once the user fills in the helpdesk ticket information, such as a problem 
description, the user clicks the Post Now button on the HTML form. The action of 
this HTML form sends the user information to another ASP file named 
posthelp.asp. Posthelp.asp uses the CDO library to post this information to the 
Helpdesk public folder by creating a new Message object in the folder. The hierarchy 
for the Message object and its parent collection the Messages collection is 
shown in Figure 11-13.</p>

<p>

<A HREF="javascript:fullSize('F11oh13x.htm')"> <img src="images/F11oh13.JPG" width=404 height=200 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><B>Figure 11-13</B> <I>The Messages collection and Message object in CDO.</I><!-- /caption -->
</p>

<p>The Messages collection is accessed by calling the Messages property 
on a Folder object. The Messages collection consists of Message objects, 
which you can manipulate to change items in folders or to create new items. To 
add a new message to a folder, you use the 
<I>Add</I> method of the Messages collection&#8212;essentially, it adds a new item to the collection. The type of message 
created depends on which folder you are calling the 
<I>Add</I> method in. For example, if you call the 
<I>Add</I> method in your Inbox, CDO will return a new 
Message object. If you call the <I>Add</I> method in your Calendar folder, CDO will 
return a new AppointmentItem object.</p>

<P>After adding a new item to the collection, you can set the properties for 
the item and then call the <I>Send</I> or 
<I>Update</I> method, depending on the type of 
item you created. If you used the <I>Add</I> method in your Outbox, you would call the 
<I>Send</I> method, because e-mail messages are created in the Outbox. In the 
Helpdesk application, the script calls the 
<I>Update</I> method because the application does 
not e-mail new help tickets into the folder but rather posts them into the folder. 
The following script from posthelp.asp posts the information from the HTML 
form into the public folder:</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
set objFolder = Session(&quot;HelpdeskFolder&quot;)
set recursefolder = objFolder
'Add a new message to the public folder
Set oMessage = recursefolder.Messages.Add 
'Set the message properties
oMessage.Subject = Request(&quot;Subject&quot;)
oMessage.Sent = True    
oMessage.Unread = True
oMessage.TimeSent = Now
oMessage.TimeReceived = Now
oMessage.Type = &quot;IPM.Task.Help Request&quot;
oMessage.Importance = Request(&quot;Priority&quot;)
oMessage.Fields.Add &quot;From User&quot;, 8, Request.Form(&quot;Contact_Email&quot;)
oMessage.Fields.Add &quot;Description&quot;, 8, Request(&quot;Description&quot;)
oMessage.Fields.Add &quot;Problem Type&quot;, 8, Request(&quot;Type&quot;)
oMessage.Fields.Add &quot;Product&quot;, 8, Request(&quot;Product&quot;)
oMessage.Fields.Add &quot;Phone&quot;, 8, Request(&quot;Phone&quot;)
oMessage.Fields.Add &quot;User Location&quot;, 8, Request(&quot;Location&quot;)
oMessage.Fields.Add &quot;Flag&quot;, 8, &quot;Opened&quot;
'Set the conversation properties
oMessage.ConversationTopic = oMessage.Subject
oMessage.ConversationIndex = objOMSession.CreateConversationIndex
'Post the message
oMessage.Submitted = FALSE
oMessage.Update 
Set oMessage = Nothing
</PRE></TD></TR></TABLE></P>

<P>As you can see in the code, some properties on the new Message 
object, such as the Sent, Unread, TimeSent, TimeReceived, and Submitted 
properties, are explicitly set. These properties need to be set because when you post an 
item into a public folder as the Helpdesk does, the underlying messaging system 
does not set these properties for you. They must be set before calling the 
<I>Update</I> method on the Message object for posted items.</p>

<p>The Sent property is a Boolean that determines whether the message 
has been sent through the system. Since we are posting information directly 
into the folder, we need to set this property explicitly to True before calling 
the <I>Update</I> method. The Submitted property is also a Boolean that needs to be 
set to True before calling the <I>Update</I> method. The Submitted property 
determines whether the item has been submitted into the messaging subsystem.</p>

<p>The TimeReceived and TimeSent properties contain dates that tell the 
user when the message was received by the folder and when the user sent the 
messages. You should set both of these properties to the current date and time 
before posting the item into the folder. The easiest way to do this is assign them to 
the value returned by the <I>Now</I> function.</p>

<p>The Unread property is a Boolean that represents whether the current 
user has read the item. This property is not set for you automatically by CDO 
when posting an item to a public folder. For this reason, you must set this 
property to False before posting your item into the public folder.</p>

<p>Now that we have set the required properties to successfully post a 
message into a public folder, we can use some of the other properties on the 
Message object to implement the functionality of our application. Notice in the 
script that the Type property is set to IPM.Task.Help Request. The Type 
property corresponds to the message class of the item. By setting this property to a 
custom message class, Outlook and Outlook Web Access users can use a 
custom form that handles that message class to open up the item in the folder.</p>

<p>The Importance property in the script is set to the importance 
established by the user in the Priority drop-down list in the HTML form. This property 
has three possible values: CdoLow (0), CdoNormal (1), and CdoHigh 
(2<I>)</I>. Setting Importance in CDO has the same effect as adding the exclamation point 
icon or the down arrow icon to an e-mail message in Outlook.</p>

<p>The Subject property is set to whatever the user types in the Problem 
text box of the helpdesk form. It is rendered as a hyperlink later in the 
application so that from their web browser, technicians can click on a specific problem 
and drill down to the specifics about the help ticket and the user who submitted it.</p>

<p>The Fields collection on the Message object is used in the script to 
add custom fields to the item programmatically&#8212;a powerful technique, 
because any items you create in CDO can use it. These custom properties, or 
fields, are then accessible from Outlook. Since the Exchange Server database is 
a semistructured database, you can even change or add new properties to 
the items in a folder without worrying about breaking a schema. This means 
that in your application, every item and its properties can hold different data. 
Your application can dynamically add new properties to items depending on 
the input of the user.</p>

<P><div class="sidebar">
<BLOCKQUOTE>
<B>Semistructured Databases</B>
<P>Exchange Server is a semistructured database, as compared to 
Microsoft SQL Server, which is completely structured. With SQL Server, you 
need to define your schema before you can start adding data, and the 
schema is usually fixed. With Exchange Server, every message can be 
different. For example, one message might have 0 attachments and another 
might have 15 attachments. Exchange Server is designed to efficiently 
handle this varying data.</p>
</BLOCKQUOTE></DIV></P>

<P>The way you add new custom properties to an item is by using the 
<I>Add</I> method of the Fields collection. This is the syntax for the 
<I>Add</I> method:</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
Set <I>objField</I> = <I>objFieldsColl</I>.Add (<I>Name</I>, <I>Class</I> [, <I>Value</I>] [, <I>PropsetID</I>])
</PRE></TD></TR></TABLE></P>

<P>Passing the last two parameters to this method and setting the value 
returned by this method are optional. You can see in the preceding script that the 
code does not set an object variable to the return value of this function.</p>

<P>The first parameter the <I>Add</I> method takes is the name of the custom 
property. This name is limited to 120 characters, and if you attempt to exceed 
this limit, CDO will return an error. The second parameter is the class, or data 
type, that you want to store in the property. The 
<I>class</I> parameter should pass one of the following identifiers: vbArray (8192), vbBlob (65), vbBoolean 
(11), vbCurrency (6), vbDataObject (13), vbDate (7), vbDouble (5), vbEmpty 
(0), vbInteger (2), vbLong (3), vbNull (1) vbSingle (4), vbString (8), or 
vbVariant (12). The most common data type you will use in your applications is 
vbString (8). As you can see in the Helpdesk script, all custom properties on the 
posted item use the string data type.</p>

<P>The third parameter, which is optional, is the value for the property. 
Usually you want to pass this parameter to the method so that you do not have to 
write extra code to initialize the custom property with the value.</p>

<P>The fourth and final parameter is the 
<I>PropsetID</I>. The <I>PropsetID</I> is a GUID that uniquely identifies the MAPI property set to which the custom field 
should belong. In your applications, you will almost always use the default property 
set, which is assumed if you omit the 
<I>PropsetID</I> parameter. Only if you are developing a custom MAPI application that uses its own property sets will you 
ever need to set <I>PropsetID</I>.</p>

<P>In addition to adding new custom properties, the script sets 
the ConversationTopic and ConversationIndex properties for the help ticket 
before posting it into the folder. These properties are used by both CDO and 
Outlook to allow you to create threaded views of information in your folders. Since 
your users might want to create these types of views in your applications, you 
should set these properties in your code.</p>

<P>The ConversationTopic property is a string that describes the subject of 
the conversation. All the items in the same conversation have the same property 
value, and since ConversationTopic corresponds to the overall subject of the 
conversation, the most logical value for it is the Subject property of your message.</p>

<P>The ConversationIndex property is a hexadecimal string that 
represents the relationship between items in the same conversation. This property is 
used by CDO and Outlook to determine which items are replies to other items 
and how to thread these items in a view. Since you do not want multiple 
messages with the same index, CDO provides a method for you to generate unique 
conversation index values&#8212;the 
<I>CreateConversationIndex</I> method on the CDO Session object. As you can see in the Helpdesk code, all you need to do is 
call <I>CreateConversationIndex</I> and assign its value to the ConversationIndex 
property for your item.</p>

<P>After setting all these properties, the script calls the 
<I>Update</I> method on the Message object, and a new helpdesk ticket is created in the folder. If you do not call the <I>Update</I> method, CDO will not commit your changes to 
the public folder.</p>

<A NAME="373"><H2>Rendering the List of Helpdesk Tickets</H2></A>

<P>When creating a web application, one of the hardest aspects to design is the 
user interface. You have to worry about using HTML tables to line up content, 
and you have to make sure that these tables have the correct format and 
spacing to appear properly in a browser. The beauty of CDO is that you do not 
have to worry about the user interface. The CDO library has a companion 
library, named the CDO Rendering library, that provides objects that 
automatically convert Exchange Server information to an HTML format in a preset 
layout. Figure 11-14 shows the relationships among the 
objects and collections of the CDO Rendering library.</p>

<P>
<A HREF="javascript:fullSize('F11oh14x.htm')"> <img src="images/F11oh14.JPG" width=404 height=322 border=0 ALT="Click to view at full size."> </A>
</p><P>
<!-- caption --><B>Figure 11-14</B> <I>CDO Rendering object library.</I><!-- /caption -->
</p>

<P>The CDO Rendering library can not only render simple types of 
information such as your Inbox, but it can also leverage any custom table views you 
create in Outlook. For example, you could use the CDO Rendering library to 
render your Inbox as HTML, grouped by who sent you the message. The CDO 
Rendering library provides this functionality with a minimal amount of coding, 
as you will see. Plus, the formats that the library uses to render information 
to HTML is customizable, so if you want to change the color or the font of 
items that meet particular criteria or contain particular properties, you can easily 
do this by using the Rendering objects. Figure 11-15 shows an HTML view 
of Helpdesk tickets in a folder, created using the CDO Rendering library.</p>

<P>
<A HREF="javascript:fullSize('F11oh15x.htm')"> <img src="images/f11oh15.JPG" width=404 height=339 border=0 ALT="Click to view at full size."> </A>
</p><P>
<!-- caption --><B>Figure 11-15</B> <I>An HTML view of the current Helpdesk tickets in the folder. This was created using the CDO Rendering library.</I><!-- /caption -->
</p>

<P>Similar to the Session object in the CDO library, the 
RenderingApplication object of the CDO Rendering library is the parent object from which all 
other objects in the library are derived. To create a RenderingApplication object, 
you need to use the <I>CreateObject</I> method and pass the ProgID of the CDO 
Rendering library, which is AMHTML.Application. In the Helpdesk 
application, the RenderingApplication object is created in the Global.asa file and given 
application scope in ASP so that all sessions in the Helpdesk application can 
create individual objects from the global RenderingApplication object. This is a 
good practice to use in your CDO ASP applications.</p>

<P>The RenderingApplication object contains a number of properties that 
you can set, such as the code page or virtual root, that can be used throughout 
all the rendering objects created from RenderingApplication. When you first 
create your RenderingApplication object, most of the properties on the object 
will be filled in with default values. Most of these default values do not need to 
be changed unless you are developing completely customized applications 
that cannot use the defaults.</p>

<P>The most important property and the two most important methods of 
the RenderingApplication object to learn about are the ConfigParameter 
property, the <I>CreateRenderer</I> method, and the 
<I>LoadConfiguration</I> method. This property and these methods will be used in almost all of your ASP CDO applications. 
The <I>LoadConfiguration</I> method and the ConfigParameter property work 
together to tell the CDO Rendering library where to pull configuration 
information from&#8212;such as the Registry or the Exchange Server directory. This 
location information is used to retrieve specific configuration data from the selected 
data source. In the Global.asa for the Helpdesk application, the name of the 
Exchange Server that CDO communicates with is retrieved by using the 
<I>LoadConfiguration</I> method and the ConfigParameter property. The ConfigParameter property 
can retrieve other types of configuration parameters, such as whether 
anonymous access is enabled on the Exchange Server, the organization and site names 
for the Exchange Server directory, and whether the HTTP protocol is even 
enabled on the Exchange Server.</p>

<P>The <I>CreateRenderer</I> method creates a new rendering object, which is 
attached to the current RenderingApplication object. This method takes an 
integer argument that specifies the type of rendering object to create. The 
values for this integer parameter can be either CdoClassContainerRenderer (3) 
or CdoClassObjectRenderer (2). In your applications, use the object renderer 
to render only specific properties on items, such as the subject or the text of 
the item. You should use the container renderer to render rows of information, 
such as all the messages in a folder.</p>

<P>In the render.asp file for the Helpdesk application, the following script 
first gets the global RenderingApplication object and then calls the 
<I>CreateRenderer</I> method to create a container renderer. The application uses a container 
renderer to display all the items in the Helpdesk folder rather than specific properties 
on a specific item.</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
'Create Rendering Application
set objRenderApp = Application(&quot;RenderApplication&quot;)
'Create Container Renderer id=3
Set objrenderer = objRenderApp.CreateRenderer(3)
</PRE></TD></TR></TABLE></P>

<P>The application then sets the DataSource property for the container 
renderer to the Messages collection in the Helpdesk folder. With any type of 
rendering object, you need to set the DataSource property because it tells the 
rendering object what data to actually convert to HTML. The container renderer 
can accept an AddressEntries, a Folders, a Messages, or a Recipients collection 
as its data source.</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
Set oMsgCol = objFolder.Messages
'Set the data source for the Rendering object to the 
'helpdesk public folder
    objrenderer.DataSource = oMsgCol
</PRE></TD></TR></TABLE></P>

<P>The next step in the code figures out whether the application passed 
along a custom Outlook view name with the query string. If it did, the script uses 
that custom view name as the default view for the Rendering object. This is an 
important point. You can use custom Outlook views as views in your 
Rendering objects. This means that you do not have to create views on the fly in your 
CDO applications, but can instead create views in Outlook and then leverage 
those views in your application. The Rendering object will support views that 
contain sorting, grouping, and filtering&#8212;support that will save you many hours of 
coding custom views.</p>

<p>If the application did not pass a view name with the query string, the 
default view named Helpdesk is used to render the tickets in the folder, as shown in 
the following code:</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
'Get the requested view from the query string
requestedview = Request.QueryString(&quot;view&quot;)
'Get the Folder Views collection
set objviews = objrenderer.views    
'If there is no selected view, set it to Helpdesk view 
'created in Outlook
if requestedview = &quot;&quot; then 
    requestedview = &quot;Helpdesk&quot;
end if
'Search the Views collection until you find the view
i=1
While objviews.item(i).Name &lt;&gt; requestedview
    i=i+1
Wend
set objview = objviews.Item(i)
</PRE></TD></TR></TABLE></P>

<P>The next step in setting up the container renderer is to enable a 
hyperlink on a field in the view so that technicians can click on the hyperlink to 
retrieve the information contained in the ticket. If you do not include this step in 
your CDO applications, the rendering objects will return HTML without any 
clickable links. To create hyperlinks, we must first select the column in the view for 
which we want to create the hyperlink. In the Helpdesk application, the third 
column in the view is always used to create the hyperlink. The way you access the 
third column is by using the Columns collection and the Column object of 
the TableView object that is represented by the custom Outlook view. The 
Column object has a property called RenderUsing that allows you to specify the 
HTML code to use when rendering that specific column. You specify not only 
the HTML but also substitution tokens within percent signs in the 
RenderUsing property, which CDO will replace with actual values when rendering the 
information to the web browser. The two most common substitution tokens you 
will use are %obj% and %value%.</p>

<p>Use the %obj% token when you want to place the unique identifier 
for the item as a string in your HTML. This token is used in the Helpdesk 
application so that the hyperlink on the third column passes the unique 
identifier for the ticket to the next ASP file, framemsg.asp. Use the %value% token 
when you want to place the actual value of the property into the HTML 
returned by the rendering object. The Helpdesk application uses this token to 
display the actual third column property value in the view. For the Helpdesk view, 
this property value is the subject of the message. The following code shows 
you how to use both these substitution tokens as well as the RenderUsing 
property and Column object:</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
set objcolumns = objview.Columns
set objcolumn = objcolumns.Item(3)
'Change the column renderer so that it renders the subject field 
'as an ahref with the entry ID of the message
objcolumn.RenderUsing = _
    &quot;&lt;a href='framemsg.asp?entryid=%obj%'&gt;%value%&lt;/a&gt;&quot;
</PRE></TD></TR></TABLE></P>

<P>The final step in enabling the container renderer is to set the 
CurrentView property as the custom view just modified by the application. To do this, 
the application sets the CurrentView property equal to the TableView object we 
just modified, as shown in the following code.</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
'Set the current view equal to the view just selected
objrenderer.CurrentView = objview
</PRE></TD></TR></TABLE></P>

<P>To actually render the information to HTML and return it to the 
browser, you must call the <I>Render</I> method on your ContainerRenderer object. 
The <I>Render</I> method takes four parameters. The first parameter is a Long data 
type that determines the style that the data should be rendered in. This 
parameter has two possible values&#8212;CdoFolderContents (1) and CdoFolderHierarchy (2):</p>

<UL>
<P><LI>CdoFolderContents is used to render the actual contents of the 
data source and not the child objects.</li></p>

<P><LI>CdoFolderHierarchy is used to render child folders for a Folders 
collection. If you wanted to build an HTML page that displays a 
folder hierarchy for users to scroll through, you would use the 
CdoFolderHierarchy style.</li></p>
</UL>

 <P>The second parameter, which is optional, also takes a Long and specifies 
the page number at which rendering should begin. In the CDO Rendering 
library, you can have CDO automatically break up the content of a data source into 
data pages so that when the HTML is rendered by the library, the length of 
the resulting HTML table is not massive. By default, CDO will break the content 
at every 25 rows in the HTML table. CDO does this to enhance the 
performance of your application as well as make it easier for your users to read the 
information. You can change the default number of rows rendered by setting 
the RowsPerPage property on the ContainerRenderer object.</p>

<p>The third parameter is for internal use only by the CDO Rendering 
library. You should always pass <I>0</I> as the value to it. The final parameter is the 
Active Server Response object to which you want to send the HTML output from 
the <I>Render</I> method. This parameter should always be 
<I>Response</I> if you want to render the information to the browser.</p>

<P>When you have large amounts of information to render, you should 
be aware that CDO does not automatically generate a way to navigate rows 
on multiple pages nor will it tell you that there are multiple pages of 
information you need to render. Therefore, in your application, you must provide 
navigation elements if more rows exist in the table than were set for the 
RowsPerPage property. You also must remember which page the user is currently 
rendering as well as the total number of pages. If the number of help tickets exceeds 
the RowsPerPage property, the render.asp file for the Helpdesk application 
will display graphical navigation arrows as well as text indicating the current 
page of information. When a user clicks on the Next Page or the Previous Page 
arrows, the current page variable is either incremented or decremented, and this 
value is sent with the query string. The ASP script retrieves the value and renders 
the correct content on the page. If there are no previous or next pages, the 
graphical navigation elements are not displayed. The following code from 
render.asp handles viewing help tickets on multiple pages:</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
'Calculate total number of pages
intMessageCount = oMsgCol.Count
numrows = objrenderer.RowsPerPage
intPages = (intMessageCount - 1) \ numrows     
intPages = intPages + 1

intCurPage = CInt(Request.QueryString(&quot;curpage&quot;))
if intCurPage &gt; intPages or intCurPage &lt; 1 then
    'Initialize it
    intCurPage = 1
elseif intMessageCount &lt; 1 then
    intCurPage = 1
end if

&lt;% if intCurPage &lt;&gt; 1 then %&gt;
&lt;a href=
&quot;render.asp?view=&lt;%=requestedview%&gt;&amp;curpage=&lt;%=intCurPage-1%&gt;&quot;&gt;
&lt;img src = &quot;left.gif&quot; Align=&quot;Middle&quot; border=0 Alt=&quot;Previous Page&quot;&gt;&lt;/a&gt;
&lt;% end if %&gt;
&amp;nbsp Page &lt;%=intCurPage%&gt; of &lt;%=intPages%&gt;&amp;nbsp
&lt;% if intCurPage &lt;&gt; intPages then %&gt;
&lt;a href=&quot;render.asp?view=&lt;% response.write requestedview %&gt;
&amp;curpage=&lt;%=intCurPage+1%&gt;&quot;&gt;
&lt;img src = &quot;right.gif&quot; Align=&quot;Middle&quot; border=0 Alt=&quot;Next Page&quot;&gt;&lt;/a&gt;
&lt;% end if %&gt;
&lt;table border=&quot;0&quot; width=&quot;65%&quot;&gt;
    &lt;tr&gt;
        &lt;td&gt;&lt;% objRenderer.Render 1,intCurPage,0,Response %&gt;&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;
</PRE></TD></TR></TABLE></P>

<P>Notice how you can easily calculate the total number of pages you 
need to render to completely show all the information in your application. Take 
the number of messages minus 1, integer divide that number by the number of 
rows per page set for the ContainerRenderer object, and then add 1 to that 
value. Therefore, if the number of messages is less than or equal to the number 
of rows per page, the integer division will return 0. This value will be incremented 
by 1, indicating there is one page of information.</p>

<A NAME="374"><H2>Rendering the Actual Helpdesk Ticket</H2></A>

<P>When the technician clicks on one of the hyperlinks in the rendered list of 
helpdesk tickets, the application calls another ASP file, message.asp, to render 
the actual ticket for the technician, as shown in Figure 11-16. The technician 
can then view a number of different items for the ticket, resolve the ticket, or 
schedule a meeting with the customer who submitted the ticket.</p>

<p>The Helpdesk application uses DHTML to simplify navigating 
information contained in a ticket. It also uses ADO and queries an Access database 
to pull out the relevant information about the user's machine. This portion of 
the application shows you how you can combine CDO and ADO to make rich 
web applications that access information from two types of data sources: 
Exchange Server and an ODBC database.</p>

<p>
<A HREF="javascript:fullSize('F11oh16x.htm')"> <img src="images/f11oh16.JPG" width=404 height=301 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><B>Figure 11-16</B> <I>The DHTML version of a helpdesk ticket rendered when a technician clicks on a hyperlink from a list of tickets.</I><!-- /caption -->
</p>

<p>In the code for the help ticket page, the entryID of the help ticket link 
that the user clicked on is retrieved from the Request.QueryString collection. 
The script then calls the <I>GetMessage</I> method of the CDO Session object to 
retrieve the message from the Exchange Server database. The 
<I>GetMessage</I> method is an easy and fast way to retrieve information from Exchange Server if you know 
the unique entryID for the desired message. If you do not know the entryID, 
you will need to search the folder where the message is stored or use a 
MessageFilter object to filter out only your message. The MessageFilter object is discussed 
in the <a href="ch11f.htm#378">Calendar of Events Application</a> later in this chapter.</p>

<P>The script then sets the Unread property of the message to False and 
calls the <I>Update</I> method of the Message object to save that property back to 
the database. Since CDO does not automatically update the Unread property 
for you, you must provide this functionality. After the code sets Unread, when 
the technician goes back to the table of tickets in the folder, the code displays 
all messages read by the technician as nonbold tickets. This functionality of 
not bolding read messages is automatically provided to you by the Rendering 
objects and ultimately makes your application easier to use. Also, the 
Exchange Server database maintains a per-user Unread property so that each 
technician will receive different read and unread messages in the folder according to 
what each has actually read. The VBScript code for this functionality is shown here:</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
'Get the entry ID for the message from the query string
set objMessageID = Request.QueryString(&quot;entryid&quot;)
'Get the message by its ID
set oMessage = objOMSession.GetMessage(objMessageID, _
    Session(&quot;InfoStoreID&quot;))
'Set the message as read
oMessage.Unread = FALSE
'Update the message in the folder
oMessage.Update
</PRE></TD></TR></TABLE></P>

<P>The application then pulls out the status of the ticket, either Opened 
or Done, and also the name of the user who submitted the ticket. An ADO 
Connection object is created, and a connection to the Access database is 
established by the application. In ADO, you can specify values for the 
<I>Open</I> method on the Connection object to determine which OLE DB data source you want to 
open. In this case, the DSN name <I>Helpdesk</I>, which we created earlier on the 
machine, is passed as the parameter for the 
<I>Open</I> method. After establishing a 
connection, three queries are executed against three database tables to figure out the 
machine configuration for the current user. This is accomplished by using the name 
of the user retrieved from the Helpdesk ticket. These queries use the 
<I>Execute</I> method of the ADO Connection object. This information is then used later in 
the form. The following code shows the ADO connection and queries. (For 
more information about ADO and its object library, you should visit the Microsoft 
web site at <I><a href="http://www.microsoft.com/data" target="_window2">http://www.microsoft.com/data</a></I>.)</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
'Start the ADO Connection
on error resume next
Set Conn = Server.CreateObject(&quot;ADODB.Connection&quot;)
Conn.Open &quot;Helpdesk&quot;
Set RS = Conn.Execute( _
    &quot;Select SystemChipType, SystemChipSpeed, SystemChipCount, &quot; &amp; _
    &quot;SystemOS, SystemRAM FROM tblMachine &quot; &amp; _
    &quot;WHERE Userid like '&quot; &amp; objuser &amp; &quot;';&quot;)
Set RSIP = Conn.Execute( _
    &quot;Select CompName, IPAddress FROM tblNetwork &quot; &amp; _
    &quot;WHERE Userid like '&quot; &amp; objuser &amp; &quot;';&quot;)
Set RSSoft = Conn.Execute( _
    &quot;Select SoftwareName, SoftwareVersion FROM tblSoftware &quot; &amp; _
    &quot;WHERE Userid like '&quot; &amp; objuser &amp;&quot;';&quot;)
</PRE></TD></TR></TABLE></P>

<P>The script retrieves the user information from the Exchange Server 
directory and stores it in variables. (You saw this code earlier when submitting 
a Helpdesk ticket.) Then the body of the actual ticket is displayed using 
DHTML. The DHTML code includes some JavaScript to allow the user to 
dynamically expand or collapse the different sections of the Helpdesk ticket, such as 
system information or the description of the problem.</p>

<A NAME="375"><H2>Creating the Calendar Information</H2></A>

<P>The one interesting section in the body of the HTML is the drop-down 
section of calendaring information, shown in Figure 11-17. This drop-down section 
allows technicians to view the free/busy information for the user and for 
themselves. By providing the free/busy information at the bottom of the help 
ticket page, a technician can quickly find time slots that are open for both the 
technician and the user.</p>

<P><DIV CLASS="NOTE"><BLOCKQUOTE><B>NOTE</B><HR>
To obtain up-to-the-minute calendar information for a 
user on the Help Request page, it might be necessary to adjust the 
calendar settings in Outlook. By default, Outlook updates the 
calendar free/busy information on the server every 15 minutes. You can 
decrease this time in Outlook by choosing Options from the Tools menu, 
clicking Calendar Options, and then clicking Free/Busy Options.
</BLOCKQUOTE></DIV></P>

<P>
<A HREF="javascript:fullSize('F11oh17x.htm')"> <img src="images/f11oh17.JPG" width=404 height=300 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><B>Figure 11-17</B> <I>The Helpdesk ticket showing the calendar information.</I><!-- /caption -->
</p>

<p>This calendar information is created by using the calendaring 
functionality of the CDO library. The code for the drop-down section is shown here:</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
&lt;%
bcGrayM = &quot;#c0c0c0&quot; 'gray
bcGrayD = &quot;#909090&quot;
buildmonth = Request.QueryString(&quot;m&quot;)
buildday = Request.QueryString(&quot;d&quot;)
buildyear = Request.QueryString(&quot;y&quot;)
builddate = buildmonth &amp; &quot;/&quot; &amp; buildday &amp; &quot;/&quot; &amp; buildyear
dtCurrentDay =  DateValue(builddate)
arrBGColors= _
    Array(bcGrayM, &quot;#99ccff&quot;, &quot;#0000ff&quot;, &quot;#940080&quot;, &quot;#ff0000&quot;)
Dim MeetingPlanner(2)
%&gt;
&lt;B&gt;&lt;FONT STYLE=&quot;ARIAL NARROW&quot; SIZE=3&gt;&lt;SPAN style=&quot;cursor:hand&quot; 
CLASS=ex TITLE=&quot;Calendar Information&quot; 
ID=&quot;CalInfo&quot; onclick=&quot;checkExpand()&quot; myArrow=4&gt;Calendar Information
&lt;/SPAN&gt;&lt;/FONT&gt;&lt;/B&gt;
&lt;IMG WIDTH=15 HEIGHT=13 SRC=&quot;addarrow.gif&quot; ID=&quot;imgArrow4&quot;&gt;&lt;P&gt;

&lt;TABLE ID = &quot;CalInfoChild&quot; style=&quot;display:none&quot; BORDER = 0&gt;
&lt;TR&gt;
&lt;td nowrap=nowrap width=&quot;355&quot; align=&quot;right&quot;&gt;
&lt;A href=&quot;message.asp?entryid=&lt;%response.write objMessageID%&gt;
&amp;m=&lt;%=Month(dtCurrentDay-1)%&gt;&amp;d=&lt;%=Day(dtCurrentDay-1)%&gt;
&amp;y=&lt;%=Year(dtCurrentDay-1)%&gt;&quot; target=&quot;main&quot;&gt;
&lt;img src=&quot;left.gif&quot; border=0 alt=&quot;Previous Day&quot;&gt;&lt;/a&gt;&lt;/td&gt;
&lt;td nowrap=nowrap width=&quot;10&quot;&gt;&lt;/TD&gt;
&lt;td nowrap=nowrap border=0&gt;&lt;i&gt;&lt;b&gt;
&lt;%=MonthName(Month(dtCurrentDay)) &amp; &quot; &quot; &amp; Day(dtCurrentDay) &amp; _
&quot;, &quot; &amp; Year(dtCurrentDay)%&gt;&lt;/b&gt;&lt;/i&gt;&lt;/TD&gt;
&lt;td nowrap=nowrap border=0 width=&quot;10&quot;&gt;&lt;/td&gt;
&lt;td nowrap=nowrap width=&quot;20&quot; align=&quot;right&quot;&gt;
&lt;A href=&quot;message.asp?entryid=&lt;%response.write objMessageID%&gt;
&amp;m=&lt;%=Month(dtCurrentDay+1)%&gt;&amp;d=&lt;%=Day(dtCurrentDay+1)%&gt;
&amp;y=&lt;%=Year(dtCurrentDay+1)%&gt;&quot; target=&quot;main&quot;&gt;
&lt;img src=&quot;right.gif&quot; border=0 alt=&quot;Next Day&quot;&gt;&lt;/a&gt;&lt;/td&gt;
&lt;/Table&gt;

&lt;table ID = &quot;CalInfoChild2&quot; style=&quot;display:none&quot; cols=50 
bordercolor=#FFFFFF border=1 cellspacing=0 cellpadding=0&gt;
&lt;tr&gt;
&lt;td nowrap=nowrap width=&quot;102&quot;&gt;
&lt;td colspan=2&gt;&amp;nbsp;&lt;/td&gt;
&lt;% For idx = 0 to 23 %&gt;
&lt;td bordercolor=#000000 colspan=2 align=left width=&quot;24&quot;&gt;
&lt;font size=-2%&gt;&amp;nbsp;&lt;%= CStr((((idx + 11) Mod 12) + 1))%&gt;
&lt;/font&gt;&lt;/td&gt;
&lt;% Next %&gt;
&lt;/tr&gt;
&lt;/TABLE&gt;
&lt;%
'Loop from 3 to 4
for x = 3 to 4
    if x = 3 then
        set objRecip = objOMSession.CurrentUser
    else
        set objRecip = objonerecip
    end if
    'Initialize the string
    aFB = &quot;&quot;
    aFB = objRecip.GetFreeBusy( dtCurrentDay, dtCurrentDay+1, _
        30, true)
    szFreeBusy = aFB
%&gt;
    &lt;table ID = &quot;CalInfoChild&lt;%=x%&gt;&quot; style=&quot;display:none&quot; Border=0&gt;
    &lt;tr bordercolor=#000000&gt;
    &lt;td nowrap=nowrap bgcolor=&quot;#ffffff&quot; width=&quot;100&quot;&gt;&lt;font size=-1&gt;
    &lt;%= objRecip.Name %&gt;&lt;br&gt;&lt;/font&gt;&lt;/td&gt;
&lt;%
    if Len(szFreeBusy) = 0 then
%&gt;
        &lt;TD&gt;&lt;font size=2&gt;Free/Busy Information is not available
        &lt;/font&gt;&lt;/TD&gt;
&lt;%
    else
        For idy = 1 to 48
            sCell= Mid( szFreeBusy, idy, 1)
%&gt;
            &lt;td bgcolor=&lt;%= arrBGColors(CInt(sCell)) %&gt; width=&quot;9&quot;&gt;
            &amp;nbsp;&lt;/td&gt;
&lt;%
        Next
    end if 
Next
%&gt;
&lt;/table&gt;
&lt;TABLE ID=&quot;CalInfoChild5&quot; style=&quot;display:none&quot; border=0&gt;
&lt;TR&gt;
&lt;td nowrap=nowrap width=&quot;100&quot;&gt;&lt;b&gt;Legend:&lt;/b&gt;&lt;/TD&gt;
&lt;TD bgcolor=&lt;%= arrBGColors(1) %&gt;&gt;&amp;nbsp;&amp;nbsp;&lt;/TD&gt;
&lt;TD&gt; Tentative &lt;/TD&gt;
&lt;TD bgcolor=&lt;%= arrBGColors(2) %&gt;&gt;&amp;nbsp;&amp;nbsp;&lt;/TD&gt;
&lt;TD&gt; Busy &lt;/TD&gt;
&lt;TD bgcolor=&lt;%= arrBGColors(3) %&gt;&gt;&amp;nbsp;&amp;nbsp;&lt;/TD&gt;
&lt;TD&gt; Out of Office &lt;/TD&gt;
&lt;/TABLE&gt;
</PRE></TD></TR></TABLE></P>

<P>First the code tries to retrieve, from the query string, the day, the 
month, and the year values passed by the application. When the user first clicks on 
a hyperlink from the list of Helpdesk tickets, these date values are filled with 
the current day, month, and year from the web server machine. The code then 
builds a date from the values, such as 10/12/1998. This is done so that the 
string containing the date value can be used as a parameter to the 
<I>DateValue</I> function in VBScript. This function will return a Variant of the subtype Date so that 
we can use it in the rest of the code.</p>

<p>The application then builds an array of information. This array, 
named <I>arrBGColors</I>,<I> </I>comprises background colors used to render the free/busy 
information to the web browser. These colors correspond to the Outlook colors 
for rendering calendar information, such as blue for busy slots, light blue for 
tentative slots, and purple for out-of-office slots in the calendar. You'll 
understand why we place these colors into an array when we look at the 
<I>GetFreeBusy</I> method in CDO, and see how the values are returned from this method and parsed 
by the application.</p>

<p>The next step in the code is to render the navigation elements to move 
to the previous or next day in the calendar and also to print out the current 
day the technician is viewing. The navigation elements to move to the next 
and previous days are implemented using hyperlinks, which pass the next or 
previous date, broken up into day, month, and year, across the query string 
to message.asp. To retrieve the day, month, and year from the 
<I>dtCurrentDay </I>variable, which has the form 12/31/1998, the VBScript functions 
<I>Day</I>, <I>Month</I>, and <I>Year</I> are used.</p>

<p>The code then uses a For...Next loop from 0 through 23 to draw a 
table that creates the time values across the top of the free/busy information. 
Starting at 12 am, this code draws table elements until 11:30 
pm the same day. Adding 11 to the current index of the loop, using the Mod operator to return 
the remainder when divided by 12, and then adding 1 to that value produces 
the correct identifiers for the time slots. The code uses the 
<I>CStr </I>function to convert the number returned by the formula to a string value.</p>

<p>The next portion of the code uses the calendaring features of CDO. 
Figure 11-18 shows some of the calendar-related objects in the CDO library. 
The CDO library provides extensive support for building calendaring 
applications: the Helpdesk application shows how to use the 
<I>GetFreeBusy</I> method and the meeting request functionality of CDO, and the Calendar of Events 
application, which we'll examine later in this chapter, shows appointment filtering and 
rendering of calendars using the Rendering library.</p>

<p>
<A HREF="javascript:fullSize('F11oh18x.htm')"> <img src="images/F11oh18.JPG" width=404 height=380 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><B>Figure 11-18</B> <I>The calendar-related objects of the CDO library.</I><!-- /caption -->
</p>

<p>A For...Next loop is used to loop through the code twice. The loop 
starts at the number 3 and continues through the number 4. The loop does not 
start at the number 1 because the index of the loop is used to create unique 
DIV elements in the HTML code so that the JavaScript 
<I>checkExpand</I> function can find the tables using them. Since this code is fairly generic, you can use it in 
other applications that render tens or hundreds of blocks of free/busy 
information for users rather than blocks for only two users. All you need to do is change 
the ending point of the loop and pass in the targeted users' free/busy 
information as an array of names.</p>

<p>The code uses the <I>GetFreeBusy</I> method of the CDO Recipient object 
to return the free/busy calendaring information for the current user, which is 
retrieved using the CurrentUser property on the CDO Session object, and the 
name of the person who submitted the Helpdesk ticket, which is stored in the 
Recipient object named objonerecip. The 
<I>GetFreeBusy</I> method in CDO is exactly the same as the 
<I>GetFreeBusy</I> method in the Outlook object library. You need to 
pass the four parameters below 
to this method.</p>

<UL>
<P><LI>The start time of the first slot you want to retrieve.</li></p>

<P><LI>The end time of the last slot you want to retrieve.</li></p>

<P><LI>The interval, in minutes, of each of the slots.</li></p>

<P><LI>A Boolean specifying whether you want to have CDO return full 
formatting for the slots. Full formatting will inform you of the 
exact nature of busy slots: CdoFree (0), CdoTenative (1), CdoBusy (2), 
or CdoOutOfOffice (3). If you do not enable full formatting, 
CDO will return 0 for free and 1 for busy.</li></p>
</UL>

 <P>For <I>GetFreeBusy</I>, CDO will return the most committed value in the 
time slots. This means that if a user has overlapping appointments in the slot and 
one is tentative and the other is out-of-office, CDO will return the 
out-of-office value. CDO will not return &quot;free&quot; for time slots unless the entire time slot 
is free. Be careful when working with free/busy information far beyond the 
current date. By default, free/busy information is published only two months 
past the current date. If you query beyond the published information for 
free/busy, CDO will return free slots even though the user might have appointments 
during those slots. You can ask your Outlook users to change the number of 
months to a maximum of 12 months past the current date for free/busy information 
if you need longer term information. They can change this number of months 
in Outlook by selecting Options from the Tools menu, clicking Calendar 
Options, and clicking Free/Busy Options.</p>

<P>The return value for this method returns a string of numbers that 
correspond to the free/busy status of the user for all the time slots you specified. 
Your code must then parse the string and make a graphical representation of 
this information in your application.</p>

<P>The Helpdesk application parses this string by first looking at the 
length to make sure it's not zero, which would mean there is no free/busy 
information for the user. It then uses a For...Next loop and the VBScript 
<I>Mid</I> function to retrieve each character from the string and display the free/busy status 
for the user in an HTML table. Notice in the code that the value from the 
retrieved free/busy status interval is used as an index for the 
<I>arrBGColors</I> array of colors we created earlier: CdoFree (0) will display light gray, CdoTentative (1) will 
display light blue, CdoBusy(2) will display blue, and CdoOutOfOffice (3) 
will display purple. The For...Next loop ranges from 1 through 48 because we 
specified 30 minutes as the interval for the time slots in the call to the 
<I>GetFreeBusy</I> method. If you calculate the number of 30-minute intervals from 12 
am to 11:30 pm, the result turns out to be 48.</p>

<A NAME="376"><H2>Creating a Meeting with the User</H2></A>

<P>Once a technician finds time slots in the Calendar Information section of 
a helpdesk ticket that are open for both the technician and the user, the 
technician can schedule a meeting with the user to troubleshoot on site. The technician 
can schedule a meeting by first typing the date and the time for the appointment 
in the text boxes provided at the top of the help ticket, as shown in Figure 11-19.</p>

<P>
<A HREF="javascript:fullSize('F11oh19x.htm')"> <img src="images/f11oh19.JPG" width=404 height=148 border=0 ALT="Click to view at full size."> </A>
</p><P>
<!-- caption --><B>Figure 11-19</B> <I>The Helpdesk ticket with the date and time for an appointment filled in. Technicians can automatically schedule meetings with users to troubleshoot their machines on site.</I><!-- /caption -->
</p>

<P>When a technician types in a date and a time and then clicks Create 
Appointment, createcal.asp is called by the application to create the actual 
meeting request, as shown in this code:</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
&lt;%
'Convert the passed-in date to a vbDate
set querydate = Request.Form(&quot;Date&quot;)
apptdate = CDate(querydate)
set querytime = Request.Form(&quot;Time&quot;)
appttime = TimeValue(querytime)
compdatime = apptdate &amp; &quot; &quot; &amp; appttime
compdatime = CDate(compdatime)

'Add a new message to the user's calendar
Set calfolder = objOMSession.GetDefaultFolder(0)
set CalRequest = calfolder.messages.add

'Set the message properties
CalRequest.Subject = oMessage.Subject
CalRequest.StartTime = compdatime
CalRequest.EndTime = DateAdd(&quot;n&quot;, 90, CalRequest.StartTime)
CalRequest.Location = myoffice
CalRequest.ResponseRequested = TRUE
set meetingrecip = CalRequest.Recipients.Add
meetingrecip.Name = objUser
meetingrecip.Resolve
CalRequest.ReminderSet = True
CalRequest.ReminderMinutesBeforeStart = 30
CalRequest.MeetingStatus = 1
CalRequest.Send
if err.number = 0 then
    response.write &quot;&lt;SCRIPT LANGUAGE = 'JavaScript'&gt;&quot;
    response.write 
        &quot;window.alert('Meeting successfully created!');&quot;
    response.write &quot;&lt;/SCRIPT&gt;&quot;
else
    response.write &quot;&lt;SCRIPT LANGUAGE = 'JavaScript'&gt;&quot;
    response.write &quot;window.alert('Error: &quot; &amp; err.number &amp; &quot; &quot; &amp;
        err.description &amp;&quot;');&quot;
    response.write &quot;&lt;/SCRIPT&gt;&quot;
end if
%&gt;
</PRE></TD></TR></TABLE></P>

<P>First the code converts the passed-in date to a Date and the passed-in 
time to a Date. Then it combines the two and converts the results to a Date so 
that the date can be passed to the CDO property StartTime to indicate the start 
time of the appointment. The code uses the 
<I>GetDefaultFolder</I> method of the CDO Session object to retrieve the calendar folder of the technician. The 
<I>GetDefaultFolder</I> method in CDO is similar to the 
<I>GetDefaultFolder</I> method in the Outlook object library, but be careful when using them because the values for the 
constants that represent the folders are different in the two libraries.</p>

<p>By using the <I>Add</I> method on the Messages collection in the calendar 
folder, CDO automatically adds a new AppointmentItem object to the collection. 
The code then sets the properties for this new AppointmentItem object to turn 
it into a MeetingItem object, which will be sent to the user.</p>

<P>To create a meeting request in CDO, you need to set some specific 
properties on the AppointmentItem object to turn it into a MeetingItem object. 
First you need to add some recipients to the inherited Message object by creating 
a Recipient object in the Recipients collection. In the Helpdesk, the name of 
the person who submitted the helpdesk ticket is added and resolved against the 
address book as a recipient for the MeetingItem object.</p>

<P>Then you need to set the MeetingStatus property to CdoMeeting (1) 
for the AppointmentItem object you created. By setting this property, the 
current user, who is the technician, is set as the meeting organizer in the 
Organizer property. The MeetingStatus property can take other values as well:</p>

<UL>
<P><LI>CdoNonMeeting (0) is the default and tells CDO that the 
appointment being organized is a regular appointment and does not 
represent a meeting.</li></p>

<P><LI>CdoMeetingCanceled (5) indicates that the meeting organizer 
has canceled the meeting.</li></p>
</UL>

 <P>Although the capability to cancel a meeting is not used in the 
Helpdesk application, here is some information about it. When canceling a meeting, 
call the <I>Send </I>method again on the object to send the cancellation to all 
attendees. Also, make sure you set the object that holds the meeting to Nothing. If 
you are the organizer of the canceled meeting and Outlook is the main calendar 
store for your users, you also need to call the 
<I>Delete</I> method on the Message object that is the parent of the MeetingItem object you just canceled. If you do 
not do this, you might get unexpected results when working in the future with 
the folder and its contents.</p>

<P>You should also set the ResponseRequested property. This property 
takes a Boolean that tells CDO whether the meeting organizer wants responses to 
the meeting request. You should set this property to False only if you want to 
send out FYI meeting requests, which adds the item in a user's calendar, but do 
not need to track whether the user has accepted or rejected the item. For 
example, you would set the property to False if you sent out meeting requests for all 
the holidays in a year but did not actually care which holidays your users 
decided to take off.</p>

<P>The preceding script sets some general properties for the appointment 
item such as the Subject, which is the problem contained in the ticket. It also 
sets the StartTime and EndTime properties of the appointment so that the 
EndTime is 90 minutes after the StartTime. The Location property is set to the 
office location for the user, which is pulled from the Exchange Server directory. 
The ReminderSet and ReminderMinutesBeforeStart properties are also set to 
True and 30 minutes before the appointment starts to make sure both parties are 
aware that they need to meet.</p>

<P>The final step when you create any meeting request is to call the 
<I>Send</I> method on the MeetingItem object, which sends the request to the 
recipients you invited to the meeting. If any of the properties you set are incorrect or 
empty, CDO will return an error after calling 
<I>Send</I>. For this reason, the code checks the Err object in VBScript. Depending on whether or not an error 
occurred, the JavaScript client code will display a success message or an error 
message. Figure 11-20 shows the success message. If a property is 
empty, such as the Office property for an Exchange user, the error message &quot;Error: 
448 Named argument not found&quot; is displayed.</p>

<P>
<img src="images/f11oh20.GIF" width=215 height=119 border=0>
</p><P>
<!-- caption --><B>Figure 11-20</B> <I>A JavaScript alert box indicating that the technician successfully created a meeting with the user in the helpdesk ticket.</I><!-- /caption -->
</p>

<P>After the meeting request is sent, the user can use any client to accept 
or decline the meeting request. You can even send meeting requests to users 
over the Internet, and as long as they are using Outlook or Outlook Web Access, 
they can view and accept or decline meeting requests. You will not, however, be 
able to view the free/busy information of users on different systems. Figure 
11-21 shows the scheduled meeting in the user's Outlook calendar.</p>

<P>
<A HREF="javascript:fullSize('F11oh21x.htm')"> <img src="images/f11oh21.JPG" width=404 height=313 border=0 ALT="Click to view at full size."> </A>
</p><P>
<!-- caption --><B>Figure 11-21</B> <I>A meeting scheduled by a technician using the Helpdesk application.</I><!-- /caption -->
</p>

<A NAME="377"><H2>Resolving the Helpdesk Ticket</H2></A>

<P>The technician can mark a helpdesk ticket as resolved. Resolving a helpdesk 
ticket consists of setting the status of the ticket as Done and sending an e-mail 
message to the user who submitted the ticket explaining that the issue has 
been resolved. The code that resolves the helpdesk ticket is resolved.asp. This 
code shows you how to update fields on a message and also how to send e-mail 
messages using the CDO library:</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
&lt;%
if InStr(Request.Form(&quot;Action&quot;), &quot;Resol&quot;) then
    set objFolder = Session(&quot;HelpdeskFolder&quot;)
    set recursefolder = objFolder

    set objMessageID = Request.QueryString(&quot;entryid&quot;)
    set oMessage = objOMSession.GetMessage(objMessageID, _
        Session(&quot;InfoStoreID&quot;))
    'Retrieve the message flag and set it
    set msgstatus = oMessage.Fields(&quot;Flag&quot;)
    msgstatusid = msgstatus.ID
    oMessage.Fields(msgstatusid) = &quot;Done&quot;
    oMessage.Update

    'Send a resolved message to the user stating that the 
    'problem was resolved
    Set objNewMsg = objOMSession.outbox.messages.add
    objNewMsg.Text = &quot;Your problem: &quot; &amp; oMessage.Subject &amp; _
        &quot; was resolved on &quot; &amp; Now &amp; chr(10) &amp; chr(10) &amp; _
        &quot;Please see the helpdesk FAQ at &quot; &amp; _
        &quot;http://exserver/faq/ for commonly asked questions.&quot; 
    objNewMsg.Subject = &quot;Resolved: &quot; &amp; oMessage.Subject
    Set objonerecip = objNewMsg.recipients.add
    objonerecip.Name = oMessage.Fields(&quot;From User&quot;)
    objonerecip.Resolve
    'Send the message without showing a dialog box
    objNewMsg.Send showDialog=False 
end if
%&gt;
</PRE></TD></TR></TABLE></P>

<P>The script retrieves the helpdesk ticket from the folder. Then it uses 
the <I>Add</I> method on the Messages collection to add a new message to the 
Outbox of the technician. The script sets the message text by using the Text 
property of the Message object. The Text property can contain only plain text. It 
does not support formatted text.</p>

<p>The code then sets the Subject of the message and adds recipients to 
the Recipients collection. The recipient for this message is the user who 
submitted the ticket. The code uses the 
<I>Resolve</I> method of the Message object to make 
sure that there are no ambiguous recipients on the message. Finally, it calls the 
<I>Send</I> method to send the message to the user. Figure 11-22 shows a sample of the e-mail received by the user.</p>

<p>
<A HREF="javascript:fullSize('F11oh22x.htm')"> <img src="images/f11oh22.JPG" width=404 height=234 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><B>Figure 11-22</B> <I>An e-mail message, sent to the user by the technician, indicating the problem has been solved.</I><!-- /caption -->
</p>

</BODY>
</HTML>




