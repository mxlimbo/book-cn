<HTML>
<head>
<link rel="STYLESHEET" type="text/css" href="Progie5.css">
<TITLE>IDocHostUIHandler</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch09a.htm">[Previous]</A> <A HREF="ch09c.htm">[Next]</A><P>

<A NAME="216"><H1><i>IDocHostUIHandler</i></H1></A>
<p>If you want to have power over user interface features such as menus, 
toolbars, scrollbars, context menus, and 3-D borders in an application that is hosting 
the WebBrowser control, simply implement the 
<I>IDocHostUIHandler</I> interface. Each time the WebBrowser control loads a new Web page, the MSHTML component calls 
the <I>QueryInterface</I> method of its host and asks for the 
<I>IDocHostUIHandler</I> interface.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Remember that the WebBrowser control hosts the MSHTML 
component, as you learned in <A HREF="ch06a.htm">Chapter 6</A>. 
</blockquote></div>
</p>

<p>During certain points in the execution of your application, MSHTML will 
call methods of your <I>IDocHostUIHandler</I> implementation to enable you to 
control some of the WebBrowser control's user interface features. Table 9-1 lists all 
the <I>IDocHostUIHandler </I>methods, some of which correspond to methods of standard 
COM interfaces. Your implementation of these methods is called from their default 
implementations in the MSHTML component, which is hosted in the WebBrowser control.</p>

<p><b>Table 9-1.</b> <i>Methods of the </I>IDocHostUIHandler<I> Interface</i></p>

<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>Methods</i></th>
<th><i>Description</i></th>
</tr>

<tr>
<td valign="top"><I>EnableModeless</I></td>
<td valign="top">Called from the MSHTML implementation 
of <I>IOleInPlaceActiveObject::EnableModeless</I>. This 
method 
enables or disables modeless dialog boxes when the 
container creates or destroys a modal dialog box.</td>
</tr>

<tr>
<td valign="top"><I>FilterDataObject</I></td>
<td valign="top">Called on the host application by MSHTML to allow 
the host to replace MSHTML's data object. This method 
allows the host to block certain clipboard formats or 
support additional clipboard formats.</td>
</tr>

<tr>
<td valign="top"><I>GetDropTarget</I></td>
<td valign="top">Called by MSHTML when it is being used as a drop target 
to allow the host to supply an alternative implementation 
of the <I>IDropTarget </I>interface.</td>
</tr>

<tr>
<td valign="top"><I>GetExternal</I></td>
<td valign="top">Called by MSHTML to obtain the host's 
<I>IDispatch</I> interface. Internet Explorer calls this method when script on a 
Web page attempts to access methods or properties of the 
hosting application. (More on this shortly.)</td>
</tr>

<tr>
<td valign="top"><I>GetHostInfo</I></td>
<td valign="top">Called by MSHTML to retrieve the user interface 
capabilities of the WebBrowser host application.</td>
</tr>

<tr>
<td valign="top"><I>GetOptionKeyPath</I></td>
<td valign="top">Returns the Registry key under which MSHTML stores 
user preferences.</td>
</tr>

<tr>
<td valign="top"><I>HideUI</I></td>
<td valign="top">Called when MSHTML removes its menus and toolbars.</td>
</tr>

<tr>
<td valign="top"><I>OnDocWindowActivate</I></td>
<td valign="top">Called from the MSHTML implementation 
of<I> 
IOleInPlaceActiveObject::OnDocWindowActivate</I> when 
the document window is being activated or deactivated.</td>
</tr>

<tr>
<td valign="top"><I>OnFrameWindowActivate</I></td>
<td valign="top">Called from the MSHTML implementation 
of <I>IOleInPlaceActiveObject::OnFrameWindowActivate</I>
 when the top-level frame window is being activated 
or deactivated.</td>
</tr>

<tr>
<td valign="top"><I>ResizeBorder</I></td>
<td valign="top">Called from the MSHTML implementation 
of <I>IOleInPlaceActiveObject::ResizeBorder</I> when the border 
is being resized.</td>
</tr>

<tr>
<td valign="top"><I>ShowContextMenu</I></td>
<td valign="top">Called when MSHTML is about to show its context 
menu. You can cancel the context menu or show your own, 
as you'll see shortly.</td>
</tr>

<tr>
<td valign="top"><I>ShowUI</I></td>
<td valign="top">Allows the host application to replace MSHTML menus 
and toolbars, which are typically displayed only if you are 
hosting the MSHTML component directly.</td>
</tr>

<tr>
<td valign="top"><I>TranslateAccelerator</I></td>
<td valign="top">Called from the MSHTML implementation 
of<I> 
IOleInPlaceActiveObject::TranslateAccelerator</I> 
or <I>IOleControlSite::TranslateAccelerator</I> when the user 
presses an accelerator key or key combination, such as 
Backspace, Ctrl-F, or F1, while focus is set to the HTML 
document window.</td>
</tr>

<tr>
<td valign="top"><I>TranslateUrl</I></td>
<td valign="top">Called by MSHTML to give the host an opportunity 
to modify the URL to be loaded. Unless you are hosting 
the MSHTML component directly, this method might not be 
useful to you when you are hosting the WebBrowser 
control. When hosting the WebBrowser, you can use 
the <I>BeforeNavigate2</I> event, as you did in <A HREF="ch07a.htm">Chapter 7</A>.</td>
</tr>

<tr>
<td valign="top"><I>UpdateUI</I></td>
<td valign="top">Called by MSHTML to notify the host that the 
command state has changed.</td>
</tr>
</table>
</p>

<p>Let's take a look at the methods I've found to be the most important to 
customers: <I>GetHostInfo</I>, 
<I>ShowContextMenu</I>, 
<I>TranslateAccelerator</I>, and 
<I>GetExternal</I>. I'll discuss 
<I>GetExternal</I> in the context of extending the DHTML Object Model.</p>

<A NAME="217"><H2><I>GetHostInfo</I></H2></A>
<p>The <I>GetHostInfo </I>method is called whenever a new Web page is loaded. 
<I>GetHostInfo</I> is the primary method used to manage the user interface of the WebBrowser 
control. It receives a pointer to a 
<I>DOCHOSTUIINFO</I> structure, which has the 
following definition as declared in the 
mshtmhst.h<I> </I>header file:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>typedef struct _DOCHOSTUIINFO
   {
   ULONG cbSize;
   DWORD dwFlags;
   DWORD dwDoubleClick;
   OLECHAR __RPC_FAR *pchHostCss;
   OLECHAR __RPC_FAR *pchHostNS;
   }   DOCHOSTUIINFO;
</PRE>
</td></tr></table></p>

<p>You must first set the first data member of the 
<I>DOCHOSTUIINFO</I> structure, <I>cbSize</I>, to the size of the structure. Then, to control the user interface, fill in the 
second data member, <I>dwFlags</I>,<I> </I>with certain flags that specify the hosting 
application's user interface capabilities. These flags enable and disable the 3-D border, 
scrollbars, script, and a lot more. The following 
<I>DOCHOSTUIFLAG</I> enumeration defines the flags that can be used to specify which user interface features to enable or disable. 
Table 9-2 also describes these flags.</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>
typedef 
enum tagDOCHOSTUIFLAG
   {   DOCHOSTUIFLAG_DIALOG   = 0x1,
   DOCHOSTUIFLAG_DISABLE_HELP_MENU   = 0x2,
   DOCHOSTUIFLAG_NO3DBORDER   = 0x4,
   DOCHOSTUIFLAG_SCROLL_NO   = 0x8,
   DOCHOSTUIFLAG_DISABLE_SCRIPT_INACTIVE   = 0x10,
   DOCHOSTUIFLAG_OPENNEWWIN   = 0x20,
   DOCHOSTUIFLAG_DISABLE_OFFSCREEN   = 0x40,
   DOCHOSTUIFLAG_FLAT_SCROLLBAR   = 0x80,
   DOCHOSTUIFLAG_DIV_BLOCKDEFAULT   = 0x100,
   DOCHOSTUIFLAG_ACTIVATE_CLIENTHIT_ONLY   = 0x200,
   DOCHOSTUIFLAG_OVERRIDEBEHAVIORFACTORY   = 0x400,
   DOCHOSTUIFLAG_CODEPAGELINKEDFONTS   = 0x800,
   DOCHOSTUIFLAG_URL_ENCODING_DISABLE_UTF8   = 0x1000,
   DOCHOSTUIFLAG_URL_ENCODING_ENABLE_UTF8   = 0x2000
   }   DOCHOSTUIFLAG;
</PRE>
</td></tr></table></p>

<p><b>Table 9-2.</b> <i>Flags Defined in the </I>DOCHOSTUIFLAG <I>Enumeration</i></p>

<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIFLAG_DIALOG</I></td>
<td valign="top">The MSHTML component disables 
text selection, enabling the application that is hosting the WebBrowser control 
to act like a dialog.</td>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIFLAG_DISABLE_HELP_MENU</I></td>
<td valign="top">The MSHTML component will not 
add the Help menu item to the container's menu.</td>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIFLAG_NO3DBORDER</I></td>
<td valign="top">MSHTML will not use 3-D borders.</td>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIFLAG_SCROLL_NO</I></td>
<td valign="top">MSHTML will not use scrollbars.</td>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIFLAG_DISABLE_SCRIPT_INACTIVE</I></td>
<td valign="top">MSHTML does not execute any 
script when loading pages.</td>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIFLAG_OPENNEWWIN</I></td>
<td valign="top">MSHTML opens a Web page in a 
new window when a link is clicked rather than loading it into the same 
browser window.</td>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIFLAG_DISABLE_OFFSCREEN</I></td>
<td valign="top">This flag has not been implemented.</td>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIFLAG_FLAT_SCROLLBAR</I></td>
<td valign="top">The document will have flat 
scrollbars instead of 3-D scrollbars.</td>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIFLAG_DIV_BLOCKDEFAULT</I></td>
<td valign="top">MSHTML inserts &lt;DIV&gt; tags if a 
return is entered in edit mode. Without this flag, the &lt;P&gt; tag is used.</td>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIFLAG_ACTIVATE_CLIENTHIT_ONLY</I>  </td>   
<td valign="top">MSHTML becomes UI-active only if the mouse is clicked on the client 
area of the window. It will not become 
UI-active if the mouse is clicked on a nonclient area such as a scrollbar.</td>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIFLAG_OVERRIDEBEHAVIORFACTORY</I></td>
<td valign="top">MSHTML asks the host application 
before a behavior is obtained from a URL specified on the page.</td>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIFLAG_CODEPAGELINKEDFONTS</I></td>
<td valign="top">The <I>CODEPAGELINKEDFONTS</I> flag provides font selection capability 
for Microsoft Outlook Express. If this flag is enabled, the displayed characters 
are inspected to determine whether the current font supports the code 
page. (This flag assumes that the user is using Microsoft Outlook Express 4 
and Internet Explorer 5.)</td>
</tr>


<tr>
<td valign="top"><I>DOCHOSTUIFLAG_URL_ENCODING_DISABLE_UTF8</I></td>
<td valign="top">The <I>DISABLE_UTF8</I> flag controls how non-native URLs are transmitted 
over the Internet. Non-native URLs contain characters that are outside the 
multibyte encoding of the URL. If this flag is 
set, the URL is sent to the server without using UTF-8 encoding.</td>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIFLAG_URL_ENCODING_ENABLE_UTF8</I></td>
<td valign="top">The <I>ENABLE_UTF8 </I>flag controls how non-native URLs are transmitted 
over the Internet. Non-native URLs contain characters that are outside the 
multibyte encoding of the URL. If this flag is 
set, URLs are sent to the server using UTF-8 encoding.</td>
</tr>
</table>
</p>

<p>The third data member of the 
<I>DOCHOSTUIINFO</I> structure, 
<I>dwDoubleClick</I>,<I> </I>indicates which action should occur in response to a double-click event. The 
values that you can specify for this data member are contained in the 
<I>DOCHOSTUIDBLCLK</I> enumeration, as shown here and described in Table 9-3:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>typedef enum tagDOCHOSTUIDBLCLK {
   DOCHOSTUIDBLCLK_DEFAULT         = 0,
   DOCHOSTUIDBLCLK_SHOWPROPERTIES  = 1,
   DOCHOSTUIDBLCLK_SHOWCODE        = 2
} DOCHOSTUIDBLCLK ;
</PRE>
</td></tr></table></p>

<p><b>Table 9-3.</b> <i>Flags Defined in the </I>DOCHOSTUIDBLCLK<I> Enumeration</i></p>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIDBLCLK_DEFAULT</I></td>
<td valign="top">Performs the default action</td>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIDBLCLK_SHOWPROPERTIES</I></td>
<td valign="top">Shows the item's properties</td>
</tr>

<tr>
<td valign="top"><I>DOCHOSTUIDBLCLK_SHOWCODE</I></td>
<td valign="top">Shows the page's source</td>
</tr>
</table>
</p>

<p>The <I>DOCHOSTUIINFO</I> structure's final two data members are 
<I>pchHostCss</I> and <I>pchHostNS</I>. The 
<I>pchHostCss</I> data member allows the host application to supply 
rules for cascading style sheets (CSS) that will affect the page contained in the 
WebBrowser. The CSS rules then get filtered down through the CSS inheritance chain on the 
page depending on what the page says is allowed to be overridden. The 
<I>pchHostNS</I> data member allows the host to supply a namespace declaration for custom tags on 
the Web page. (For more information about these two data members, refer to the 
MSDN Online Web Workshop.)</p>

<p>Now that you understand the 
<I>DOCHOSTUIINFO</I> structure's data members, 
look at the following code. It shows a typical implementation of the 
<I>GetHostInfo </I>method:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHOD(GetHostInfo)(DOCHOSTUIINFO FAR *pInfo)
{
   pInfo-&gt;cbSize  = sizeof(DOCHOSTUIINFO);

   // Turn off the 3-D border and scrollbar.
   pInfo-&gt;dwFlags |= DOCHOSTUIFLAG_NO3DBORDER|DOCHOSTUIFLAG_SCROLL_NO;

   return S_OK;
}
</PRE>
</td></tr></table></p>

<A NAME="218"><H2><I>ShowContextMenu </I></H2></A>
<p>Remember the customer I told you about at the beginning of this chapter who 
didn't want to allow her users to view the source code of her Web pages? She was 
hosting the WebBrowser control in her application but wasn't offering a View Source 
menu item. The only way her users could view the source of her Web pages was by 
right-clicking on the Web page and choosing View Source from the WebBrowser's 
context menu.</p>

<p>To work around this user-access problem in an application that is hosting 
the WebBrowser control and that has implemented the 
<I>IDocHostUIHandler</I> interface, you can use the 
<I>ShowContextMenu</I> method. The MSHTML component calls 
the <I>ShowContextMenu</I> method any time a context menu will be displayed. Your 
application can choose not to display the default context menu by returning 
<I>S_OK</I> from your implementation of 
<I>ShowContextMenu</I>. (The context menu that is displayed 
when you right-click in the document window is actually created by the MSHTML 
component. Returning <I>S_OK </I>from your implementation of 
<I>ShowContextMenu</I> tells MSHTML not to show the default context menu.) You can also display your own context 
menu at this point, if you want to. The following code demonstrates how to turn off 
the default context menu by using the <I>ShowContextMenu 
</I>method:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHOD(ShowContextMenu)(DWORD dwID, 
                           POINT FAR* ppt,
                           IUnknown FAR*  pcmdtReserved,
                           IDispatch FAR* pdispReserved)
{
   if (m_bEnableCtxMenus)
      return S_FALSE;      // Show context menus.
   else
      return S_OK;         // Do not show context menus.
}
</PRE>
</td></tr></table></p>

<p>As an alternative, you can show your own context menu instead of the 
default context menu that the MSHTML component displays. The following code, which 
is included on the companion CD in the folder \Samples\Chap09\AtlBrowser, 
implements a context menu that replaces the default. (The AtlBrowser example is 
also included in this folder. AtlBrowser is a WebBrowser control host that we will 
discuss in detail in the section titled &quot;<A HREF="ch09b.htm#221">AtlBrowser</A>&quot;)</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHOD(ShowContextMenu)(DWORD dwID, POINT FAR* ppt, 
                           IUnknown FAR* pcmdtReserved,
                           IDispatch FAR* pdispReserved)
{
   ATLTRACE(&quot;IDocHostUIHandler::ShowContextMenu\n&quot;);

   if (m_bEnableCtxMenus)
      return S_FALSE;      // Show standard context menus.
   else
   {
      IOleWindow* pWnd = NULL;
      HRESULT hr = pcmdtReserved-&gt;QueryInterface(IID_IOleWindow,
                                                 (void**) &amp;pWnd);

      if (SUCCEEDED(hr))
      {
         HWND hwnd;

         if (SUCCEEDED(pWnd-&gt;GetWindow(&amp;hwnd)))
         {
            HMENU menu = ::CreatePopupMenu();
            ::AppendMenu(menu, MF_STRING, IDM_SAVEPICTURE,
                         &quot;&amp;Save Picture As...&quot; );
            ::AppendMenu(menu, MF_STRING, IDM_SAVEBACKGROUND,
                         &quot;Save &amp;Background As...&quot; );
            
            long myRetVal = ::TrackPopupMenu(menu, 
                          TPM_RIGHTBUTTON | TPM_LEFTALIGN | TPM_RETURNCMD, 
                          ppt-&gt;x, ppt-&gt;y, NULL, hwnd, NULL);

            // Send the command to the browser.
            //
            LRESULT myResult = ::SendMessage(hwnd, WM_COMMAND,
                                             myRetVal, NULL);
         }

         pWnd-&gt;Release();
      }
   }

   return S_OK; // We've shown our own context menu.
}
</PRE>
</td></tr></table></p>

<p>Test the code by compiling and running AtlBrowser. Then deselect the 
Context Menus menu item on the UI Control menu, and right-click on an image or on 
the background of the application to show the customized context menu. You can 
see the Save Picture As and Save Background As context menu items on the 
customized context menu.</p>

<p>When creating your own context menu, the 
<I>ShowContextMenu</I> method's<I> </I>input parameters are helpful. The first parameter, 
<I>dwID</I>,<I> </I>is the ID of the context menu to 
be displayed. The values for this ID are defined in the mshtmhst.h header file, as follows:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>#define CONTEXT_MENU_DEFAULT        0
#define CONTEXT_MENU_IMAGE          1
#define CONTEXT_MENU_CONTROL        2
#define CONTEXT_MENU_TABLE          3
// in browse mode
#define CONTEXT_MENU_TEXTSELECT     4
#define CONTEXT_MENU_ANCHOR         5
#define CONTEXT_MENU_UNKNOWN        6
</PRE>
</td></tr></table></p>

<p>The second parameter, <I>ppt</I>,<I> </I>is a 
<I>POINT</I> structure that contains the 
<I>x-</I>coordinate and <I>y-</I>coordinate for the context menu. The third parameter, 
<I>pcmdtReserved</I>, is a pointer to an <I>IOleCommandTarget 
</I>interface that can be used to query command 
status and execute commands on this object. The preceding code uses this pointer to 
query for the <I>IOleWindow </I>implementation of the WebBrowser. The fourth 
parameter, <I>pdispReserved</I>,<I> </I>is a pointer to the 
<I>IDispatch </I>of the element that was right-clicked 
to display a context menu. (For Internet Explorer 4, the value of this parameter 
was always <I>NULL</I>.)</p>

<p>Notice that the code on page 364 uses two of the menu items that are 
on the default context menu&#8212;Save Picture As and Save Background As. You can 
use many of the default context menu items by specifying their IDs when 
creating your own menu items. When these items are selected from the context menu, 
the default Internet Explorer implementation of these items will be invoked. This 
code specifies <I>IDM_SAVEPICTURE</I> and <I>IDM_SAVEBACKGROUND 
</I>to add these items to the context menu. You can find these and other menu IDs in the mshtmcid.h header file.</p>

<A NAME="219"><H2><I>TranslateAccelerator</I></H2></A>
<p>Another method of the <I>IDocHostUIHandler </I>interface helped my customer solve 
her other problem. Remember, I mentioned that besides viewing her source code, 
users were able to press Ctrl-O to execute the Open dialog box and then type in a 
URL, which caused a new instance of the Internet Explorer window to open. Users 
could also start a new instance of Internet Explorer by pressing Ctrl-N.</p>

<p>Here's where the <I>TranslateAccelerator</I> method comes to the rescue. This 
method is called from MSHTML's implementation of 
<I>IOleInPlaceActiveObject::TranslateAccelerator</I>
 or <I>IOleControl::TranslateAccelerator</I>. By using your implementation 
of <I>IDocHostUIHandler::TranslateAccelerator</I>, you can turn off all accelerator keys or 
just specific ones that you choose. To turn off all accelerator keys, simply return 
<I>S_OK</I> from the <I>TranslateAccelerator</I> method, like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, 
                                const GUID FAR* pguidCmdGroup,
                                DWORD nCmdID)
{
   if (m_vbEnableAllAccels == VARIANT_TRUE)
      return S_FALSE;
   else
      return S_OK;
}
</PRE>
</td></tr></table></p>

<p>The same technique applies if you want to turn off a specific accelerator 
key. When your implementation of 
<I>TranslateAccelerator</I> is called, you check the 
<I>LPMSG </I>structure that you receive to determine whether the user pressed the accelerator 
key that you want to block. If <I>TranslateAccelerator 
</I>was called in response to a key that you want to block, you just return 
<I>S_OK</I>. The following code turns off specific 
accelerator keys:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHOD(TranslateAccelerator)(LPMSG lpMsg, 
                                const GUID FAR* pguidCmdGroup,
                                DWORD nCmdID)
{
      //
      // If accelerators are turned on, return S_FALSE
      // so that Internet Explorer 5 will perform its 
      // default behavior. Check the accelerator to see whether 
      // it is in the list of accelerators that are turned off. 
      // Return S_OK if the accelerator is in the list.
      //
      if (m_vbEnableAllAccels == VARIANT_TRUE 
         || (GetKeyState(VK_CONTROL) &gt;= 0
         &amp;&amp; GetKeyState(VK_SHIFT) &gt;= 0 &amp;&amp; GetKeyState(VK_MENU) &gt;= 0))
      {
         // Ignore WM_CHAR. The wParam for WM_CHAR is the ASCII code 
         // for the character. We want only virtual key codes.
         //
         if (lpMsg-&gt;message != WM_CHAR
            &amp;&amp; AcceleratorDisabled(lpMsg-&gt;wParam))
         {
            return S_OK;
         }

         return S_FALSE;
      }

      return S_OK;
}

bool CWBCustomizer::AcceleratorDisabled(short nKeyCode)
{
   short nVirtExtKey = 0;

   //
   // Get the virtual key that is pressed to pass it to FindAccelerator.
   //
   if (GetKeyState(VK_CONTROL) &lt; 0)
      nVirtExtKey = VK_CONTROL;
   else if (GetKeyState(VK_MENU) &lt; 0)
      nVirtExtKey = VK_MENU;
   else if (GetKeyState(VK_SHIFT) &lt; 0)
      nVirtExtKey = VK_SHIFT;

   list&lt;ACCELERATOR&gt;::iterator it = FindAccelerator
                                      (nKeyCode, nVirtExtKey);
   if (it != m_disabledAccelerators.end())
   {
      //
      // The accelerator is disabled if it is found in the list
      // AND if no virtual key is present for the accelerator in the
      // list and the Ctrl, Alt, or Shift keys are not pressed
      // OR the virtual key is present and that virtual key is pressed. 
      //
      if ((!it-&gt;nVirtExtKey &amp;&amp; GetKeyState(VK_CONTROL) &gt;= 0
           &amp;&amp; GetKeyState(VK_MENU) &gt;= 0 &amp;&amp; GetKeyState(VK_SHIFT) &gt;= 0)
           || GetKeyState(it-&gt;nVirtExtKey) &lt; 0)
      {
         return true;
      }
   }

   return false;
}

list&lt;CWBCustomizer::ACCELERATOR&gt;::iterator
CWBCustomizer::FindAccelerator(short nKeyCode, short nVirtExtKey)
{
   list&lt;ACCELERATOR&gt;::iterator it;

   // Search the list for the accelerator.
   for (it = m_disabledAccelerators.begin();
        it != m_disabledAccelerators.end(); ++it)
   {
      //
      // If the key code is found in the list, check to see
      // whether the virtual key code matches the one passed in to this 
      // function.
      //
      if (it-&gt;nKeyCode == nKeyCode &amp;&amp; it-&gt;nVirtExtKey == nVirtExtKey)
         break;
   }

   return it;
}
</PRE>
</td></tr></table></p>

<p>This code comes from the <I>WBCustomizer</I> object example that you'll 
encounter in the &quot;<A HREF="ch09c.htm#222"><I>ICustomDoc</I></A>&quot;<comments> section of this chapter. (You can find all code for 
<I>WBCustomizer</I> on the companion CD in the folder 
\Samples\Chap09\WBCustomizer.) In 
<I>WBCustomizer</I>, the Standard Template Library (STL) list class maintains a list of all disabled 
accelerator keys. When <I>TranslateAccelerator</I> is called, the code searches the list of 
disabled accelerator keys for the key or keys that were pressed. If those keys are 
found in the list, <I>TranslateAccelerator</I> returns 
<I>S_OK</I> to disable them. If those keys aren't found in the list, 
<I>TranslateAccelerator </I>returns <I>S_FALSE</I>.</p>

<A NAME="220"><H2>Extending the DHTML Object Model </H2></A>

<p>Besides allowing you to manage the WebBrowser control's user interface, 
the <I>IDocHostUIHandler</I> interface lets you extend the DHTML Object Model so that 
you can access methods and properties of the WebBrowser host application from 
within script on a Web page. For example, if you have a method in the host 
application named <I>SayHello</I>, you can call it from a Web page that is loaded by your 
application, like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>&lt;SCRIPT LANGUAGE=&quot;VBScript&quot;&gt;
   Sub Window_onLoad
      window.external.SayHello
   End Sub
&lt;/SCRIPT&gt;
</PRE>
</td></tr></table></p>

<p>When the WebBrowser control encounters a call to 
<I>window.external.SayHello</I>, it tries to resolve the 
<I>SayHello </I>method by performing a few steps. First it calls 
the <I>IDocHostUIHandler::GetExternal</I> method implemented in your host application to 
get a pointer to your application's implementation of the 
<I>IDispatch </I>interface. Then the WebBrowser control calls your 
<I>IDispatch::GetIDsOfNames</I> method to retrieve 
the dispatch ID (DISPID) of the <I>SayHello</I> method. Finally it calls your 
<I>IDispatch::Invoke</I> method and passes it the dispatch ID of 
<I>SayHello</I>.</p>

<p>In your implementation of <I>Invoke</I>, you simply handle the 
<I>DISPID</I> for the <I>SayHello</I> method. When you receive this 
<I>DISPID</I>, you can do whatever you want, such as call the 
<I>SayHello</I> method. The following code implements 
<I>GetExternal </I>and <I>Invoke</I>. (This code also comes from the 
AtlBrowser<I> </I>sample, which we'll look at in more detail shortly.)  Because 
AtlBrowser<I> </I>is implemented by using ATL and 
inherits from <I>IDispatchImpl</I>, ATL implements the 
<I>GetIDsOfNames </I>method for you, so you need to implement only 
<I>GetExternal</I> and override <I>Invoke</I>:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHOD(GetExternal)(IDispatch** ppDispatch)
{
   *ppDispatch = this;
   return S_OK;
}

STDMETHODIMP CAtlBrCon::Invoke(DISPID dispidMember, REFIID riid, 
                               LCID lcid, WORD wFlags, 
                               DISPPARAMS* pDispParams,
                               VARIANT* pvarResult, EXCEPINFO* pExcepInfo,
                               UINT* puArgErr)
{
   switch (dispidMember)
   {
      case DISPID_SAYHELLO:
         SayHello();

      default:
         return DISP_E_MEMBERNOTFOUND;
   }

   return S_OK;
}
</PRE>
</td></tr></table></p>

<p>To see this code in action, compile and run<I> 
</I>AtlBrowser and navigate to the AtlBrowser.htm. When you click the Say Hello button, Internet Explorer invokes 
the <I>SayHello</I> method, which displays a message box such as the one shown in Figure 9-1.</p>

<p>
<A HREF="javascript:fullSize('F09II01x.htm')"> <img src="images/F09II01.JPG" width=404 height=275 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><B>Figure 9-1.</B> <I>AtlBrowser after navigating to AtlBrowser.htm and clicking the Say Hello button.</I><!-- /caption -->
</p>

<A NAME="221"><H2>AtlBrowser</H2></A>

<p>The AtlBrowser example demonstrates how to implement the advanced 
hosting interfaces, including extending the DHTML Object Model, as I just showed 
you.<I> </I>AtlBrowser<I> </I>also implements the 
<I>IDocHostUIHandler </I>interface.</p>

<p>AtlBrowser<I> </I>is a WebBrowser control host that is built by using ATL, but it 
doesn't use the new ATL control hosting classes. AtlBrowser hosts the WebBrowser 
control using plain vanilla C++ and uses ATL for certain features such as message maps 
and smart pointers. To implement 
<I>IDocHostUIHandler</I>, AtlBrowser<I> </I>contains a class 
named <I>CAtlBrCon</I>, which implements the container for the WebBrowser control. To 
implement <I>IDocHostUIHandler</I>,<I> CAtlBrCon 
</I>simply inherits from the interface, contains an 
entry for the interface in its COM map, and implements all the methods 
of <I>IDocHostUIHandler</I>. (You'll see how to implement this interface by using the 
ATL control hosting classes.)</p>

<p>Some of the <I>IDocHostUIHandler </I>methods implemented in 
<I>CAtlBrCon </I>just return <I>E_NOTIMPL </I>by using the ATLTRACENOTIMPL macro. This macro prints a 
trace message in debug mode and returns 
<I>E_NOTIMPL</I> to indicate that the method isn't implemented. In release mode, 
<I>E_NOTIMPL </I>is returned, but no trace message 
is printed.</p>

<p>To enable users to change certain user interface features of the WebBrowser 
on the fly&#8212;such as 3-D borders, scrollbars, and context menus&#8212;AtlBrowser contains 
a menu named UI Control. The Context Menus menu item is implemented by 
using 
<I>IDocHostUIHandler::ShowContextMenu</I>,<I> </I>as shown here:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHOD(ShowContextMenu)(DWORD dwID, POINT FAR* ppt,
                           IUnknown FAR* pcmdtReserved,
                           IDispatch FAR* pdispReserved)
{
   ATLTRACE(&quot;IDocHostUIHandler::ShowContextMenu\n&quot;);

   if (m_bEnableCtxMenus)
      return S_FALSE;      // Show context menus.
   else
      return S_OK;         // Do not show context menus.
}
</PRE>
</td></tr></table></p>

<p>In this code, <I>m_bEnableCtxMenus </I>is a data member of the 
<I>CAtlBrCon</I> class that is set to the current state of the context menus: on 
(<I>TRUE</I>) or off (<I>FALSE</I>). When you click the Context Menus menu item, you toggle the value of this data member, 
which effectively toggles the state of the context menus. In the 
<I>ShowContextMenu </I>method shown in the preceding code, if context menus are on, 
<I>S_FALSE </I>is returned. If context menus are off, 
<I>S_OK </I>is returned.</p>

<p>Most of the remaining menu items on the UI Control menu are 
implemented by using the <I>IDocHostUIHandler::GetHostInfo 
</I>method. (One of the menu items on the UI Control menu, Use AtlBrowser Help, is implemented by using 
the <I>IDocHostShowUI</I> interface.) A data member of the 
<I>CAtlBrCon </I>class is used to maintain the status of each user interface item on this menu. When you select or 
deselect one of these menu items, the 
<I>DOCHOSTUIINFO</I> value corresponding to that 
user interface menu item is either added to or removed from this data member. For 
example, if you wanted to turn off scrollbars on the fly, you would deselect the 
Scrollbars menu item. The <I>DOCHOSTUIINFO </I>value, which specifies that no scrollbars 
should be used, is then added to this data member, as in the following code:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>LRESULT CAtlBrCon::OnUIFlag(WORD, WORD wID, HWND, BOOL&amp;)
{
   // Is the menu item checked?
   BOOL bIsChecked = (::GetMenuState(m_hMenu, wID,
                      MF_BYCOMMAND) == MF_CHECKED) ? TRUE : FALSE;

   bIsChecked = !bIsChecked;

   //
   // If the menu item is not checked, add its corresponding UI flag
   // to the DWORD that holds the Download Control constants.
   // To add it, OR it to the current value.  To remove it,
   // XOR it if it is not 0.  (XOR'ing something with 0 results
   // in that something.  For example, 128 ^ 0 = 128.)
   // 
   //
   switch(wID)
   {
   case ID_UICONTROL_SCROLLBARS:
      m_dwDocHostUIFlags = bIsChecked ?
                           (m_dwDocHostUIFlags ^ DOCHOSTUIFLAG_SCROLL_NO)
                         : (m_dwDocHostUIFlags | DOCHOSTUIFLAG_SCROLL_NO);
      break;

   default:
      return 0;
   }

   //
   // Navigate to the current URL so that the 
   // change takes effect.
   //
   CComBSTR bstrURL;
   CComVariant vtEmpty;

   m_spWebBrowser-&gt;get_LocationURL(&amp;bstrURL);
   m_spWebBrowser-&gt;Navigate(bstrURL, &amp;vtEmpty, &amp;vtEmpty,
                            &amp;vtEmpty, &amp;vtEmpty);

   ::CheckMenuItem(m_hMenu, wID, bIsChecked ? MF_CHECKED : MF_UNCHECKED);
   return 0;
}
</PRE>
</td></tr></table></p>

<p>The <I>OnUIFlag </I>method is called when one of the menu items on the UI 
Control menu is selected. (<I>OnUIFlag</I> is linked to these menu items using the COMMAND_RANGE_HANDLER<I> </I>macro.) When this method is called, the current checked state 
of the menu item is determined and then reversed. In other words, if the item was 
already checked when you selected it, it is then unchecked, and vice versa.</p>

<p>If you check the Scrollbars menu item by selecting it from the menu, 
meaning that you want scrollbars to be displayed, the 
<I>DOCHOSTUIFLAG_SCROLL_NO </I>value is XOR'ed to the 
<I>m_dwDocHostUIFlags</I> data member. Consequently, 
the value  <I>DOCHOSTUIFLAG_SCROLL_NO </I>is removed from the data member. If you 
uncheck the Scrollbars menu item, the <I>DOCHOSTUIFLAG_SCROLL_NO 
</I>value is OR'ed to the <I>m_dwDocHostUIFlags 
</I>data member. The <I>DOCHOSTUIFLAG_SCROLL_NO 
</I>value is then added to the <I>m_dwDocHostUIFlags 
</I>data member.</p>

<p>Notice that the code calls 
<I>IWebBrowser2::Navigate</I> after setting the 
<I>m_dwDocHostUIFlags</I> data member to force the change made to the scroll bar to 
take effect. The reason for calling 
<I>IWebBrowser2::Navigate</I> is that these user 
interface features can be set only in the <I>IDocHostUIHandler::GetHostInfo 
</I>method, and this method is called by the 
MSHTML<I> </I>component only when you first navigate to a 
page. Remember, MSHTML is created and destroyed each time you navigate to a 
new Web page.</p>

<p>To force a new instance of MSHTML to be created to load the new user 
interface settings, you must call 
<I>IWebBrowser2::Navigate</I>. Merely refreshing the page 
by using <I>IWebBrowser2::Refresh</I> won't do the trick: you must re-navigate to the 
page. If you won't be changing your application's user interface features on the fly, 
which is typically the case, you can just set these features one time in your 
implementation of 
<I>IDocHostUIHandler::GetHostInfo</I>.</p>

<p>Each time you navigate to a Web page, the MSHTML component calls 
your implementation of 
<I>IDocHostUIHandler::GetHostInfo</I>. In this method, you specify 
the user interface features of your application by setting the 
<I>dwFlags</I> member of the <I>DOCHOSTUIINFO </I>structure that is passed to this method by pointer. In 
AtlBrowser, we simply set the <I>dwFlags </I>data member to the 
<I>m_dwDocHostUIFlags </I>data member of the <I>CAtlBrCon 
</I>class.</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHOD(GetHostInfo)(DOCHOSTUIINFO FAR *pInfo)
{
   ATLTRACE(_T(&quot;IDocHostUIHandler::GetHostInfo&quot;));

   pInfo-&gt;cbSize  = sizeof(DOCHOSTUIINFO);
   pInfo-&gt;dwFlags = m_dwDocHostUIFlags;
   pInfo-&gt;dwDoubleClick = DOCHOSTUIDBLCLK_DEFAULT; 

   return S_OK;
}
</PRE>
</td></tr></table></p>

</BODY>
</HTML>






