<HTML>
<head>
<link rel="STYLESHEET" type="text/css" href="Progie5.css">
<TITLE>Keystroke Problems</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="chaaa.htm">[Previous]</A> <A HREF="chaac.htm">[Next]</A><P>

<A NAME="285"><H1>Keystroke Problems</H1></A>

<P>When hosting the WebBrowser control in MFC, ATL, or standard C++ 
applications, you might run into trouble with certain accelerator keys such as Backspace, 
Delete, and Tab. Problems usually occur when users type into intrinsic controls such 
as text boxes that reside on Web pages loaded by the WebBrowser control. Why? 
Because the intrinsic controls on a Web page don't automatically receive the 
messages generated by these accelerator keys. When the WebBrowser control receives 
an accelerator key message, it doesn't automatically pass it to child controls on a 
Web page. You must somehow alert the WebBrowser control to pass these messages 
to the intrinsic controls on your Web page.</P>

<P>Invariably, the solution is the same whether you're hosting the 
WebBrowser control in MFC, ATL, or standard C++ applications: call the 
<I>TranslateAccelerator</I> method of the 
<I>IOleInPlaceActiveObject</I> interface that is implemented by the 
WebBrowser control. Where and how to call this method, however, isn't always clear. 
In this section, I'll discuss the proper time and place to call 
<I>TranslateAccelerator</I> to work around keystroke problems.</P>

<A NAME="286"><H2>MFC</H2></A>

<P>As you know, you can create three types of applications in MFC: dialog-based, 
single document interface (SDI), and multiple document interface (MDI). The way 
you handle the keystroke problem depends on whether you are hosting the 
WebBrowser control in a dialog-based application or in an SDI or MDI application.</P>

<A NAME="287"><H3>MFC dialog-based applications</H3></A>

<P>When you host the WebBrowser control in an MFC dialog-based application, 
the <I>TranslateAccelerator</I> method is automatically called for you, so you won't 
encounter keystroke problems. However, you need to understand how MFC works 
when you are hosting the WebBrowser control in a dialog-based application to help 
you diagnose and solve keystroke problems that you might run into when hosting 
the control in an MFC SDI or MDI application.</P>

<P>In an MFC application, MFC manages the Windows message pump for you. In a dialog-based application in particular, the <I>IsDialogMessage</I> method is called in the message pump. One of the tasks performed by the <I>IsDialogMessage</I> method is calling <I>TranslateAccelerator</I> for any control in the dialog. <I>IsDialogMessage </I>passes to the <I>TranslateAccelerator </I>method the <I>MSG</I> structure that was received from a call to the <I>GetMessage</I> function in the message pump.</P>

<P>MFC manages the message pump by creating an instance of a class 
named <I>COccManager</I>, which manages all the OLE controls in the dialog. The 
<I>IsDialogMessage</I> method is a member of the 
<I>COccManager </I>class.</P>
<P>The <I>IsDialogMessage</I> method gets a handle to the window that has the 
focus. If this window is a control, the 
<I>TranslateAccelerator</I> method is called on 
that control to give it a chance to process the message. If this window isn't a 
control, <I>IsDialogMessage </I>keeps calling the 
<I>GetParent</I> method until it finds an 
ActiveX control or until it reaches the top-level parent. If it finds a control, it 
calls <I>TranslateAccelerator</I> on that control.</P>

<A NAME="288"><H3>MFC SDI and MDI applications</H3></A>

<P>You will typically encounter keystroke problems in MFC SDI and MDI 
applications because the <I>IsDialogMessage</I> method isn't called automatically as it is in 
dialog-based applications. Hence, you'll have to call 
<I>IsDialogMessage</I> yourself to fix keystroke problems. But where do you call it?</P>
<P>In the message pump, MFC gives your application a chance to process a 
message before the message is processed by the default window procedure. To 
allow you to process a message, MFC calls the 
<I>PreTranslateMessage</I> method,<I> </I>which is 
a virtual method of the <I>CWnd</I> class. If you implement 
<I>PreTranslateMessage</I> in any of your 
<I>CWnd</I>-derived classes, MFC will call it automatically.</P>

<P><DIV CLASS="NOTE"><BLOCKQUOTE><B>NOTE</B><HR>
<I>CWinApp</I> also has a 
<I>PreTranslateMessage</I> method. You can 
override it in the <I>CWinApp</I>-derived class for your application.
</BLOCKQUOTE></DIV></P>

<P>An MFC SDI or MDI application typically has a view class that derives 
from <I>CView</I>. In turn,<I> CView</I> derives from 
<I>CWnd</I>. If you implement 
<I>PreTranslateMessage</I> in your view class, MFC will call your implementation of 
<I>PreTranslateMessage</I> through the wonders of polymorphism. To solve the keystroke problems in an MFC SDI 
or MDI application, you just need to call 
<I>IsDialogMessage</I> from within 
<I>PreTranslateMessage</I>, as shown in the following code. Knowledge Base article Q165074 
explains this solution in detail.</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>BOOL CMyView::PreTranslateMessage(MSG* pMsg)
{
   if (IsDialogMessage(pMsg))
      return TRUE;
   else
      return CWnd::PreTranslateMessage(pMsg);
}
</PRE>
</td></tr></table></p>
<P>But sometimes this solution doesn't work. Suppose you have an application 
that resembles Microsoft Internet Explorer in that it has an edit box that can be used 
for entering a URL. If the focus is set to that edit box, each time the user presses 
Tab, the focus will shift around in the application window but will never move to 
controls on the Web page inside the WebBrowser control window. The desired 
behavior would be for the focus to shift from control to control in your application as 
well as in the WebBrowser window.</P>
<P>To make the desired Tab functionality work, you might have to pass the 
Tab key-related message directly to the WebBrowser control by calling 
<I>TranslateAccelerator</I> in the <I>PreTranslateMessage 
</I>method for your <I>CMainFrame </I>class. The following code shows how to perform this call. In this code, 
<I>ID_URL_NAME</I> is the resource ID of an edit box used for entering a URL in the application.</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>BOOL CMainFrame::PreTranslateMessage(MSG* pMsg) 
{
   if (pMsg-&gt;message == WM_KEYDOWN)
   {
      if (!(::IsChild(m_wndToolBar.GetDlgItem
            (ID_URL_NAME)-&gt;GetSafeHwnd(), pMsg-&gt;hwnd))
          || pMsg-&gt;wParam == VK_TAB)
      {
         LPDISPATCH lpDispatch = NULL;

         lpDispatch = ((CMyView*)
                       GetActiveView())-&gt;m_webBrowser.GetDocument();

         ASSERT(lpDispatch);

         // Query the IDispatch interface for the 
         // IOleInPlaceActiveObject interface.
         //
         IOleInPlaceActiveObject* pIOIPAO = NULL;

         lpDispatch-&gt;QueryInterface(IID_IOleInPlaceActiveObject, 
                                    (void**)&amp;pIOIPAO);
         lpDispatch-&gt;Release();

         ASSERT(pIOIPAO);

         // Pass the keydown message to 
         // IOleInPlaceActiveObject::TranslateAccelerator.
         //
         HRESULT hr = pIOIPAO-&gt;TranslateAccelerator(pMsg);              
         pIOIPAO-&gt;Release();

         // TranslateAccelerator will return S_FALSE if it
         // doesn't process the message.
         //
         if (S_OK == hr)
            return TRUE;
       }
    }

    return CFrameWnd::PreTranslateMessage(pMsg);
 }
</PRE>
</td></tr></table></p>
<P>This code can also fix problems with other accelerator keys such as Backspace 
and Delete, though such keystroke problems seldom affect these keys.</P>

<P><DIV CLASS="NOTE"><BLOCKQUOTE><B>NOTE</B><HR>
If you are hosting the WebBrowser control in a DLL, calling 
<I>TranslateAccelerator</I> is a bit more involved. Refer to the Knowledge Base article 
Q175502 for more information.
</BLOCKQUOTE></DIV></P>

<A NAME="289"><H2>ATL and Standard C++</H2></A>

<P>When you host the WebBrowser control in an ATL application or an 
application using standard C++, solving keystroke problems can be rather simple. You just 
need to query the WebBrowser control for the 
<I>IOleInPlaceActiveObject</I> interface, and call its 
<I>TranslateAccelerator</I> method. Typically, you call 
<I>TranslateAccelerator</I> in your handler function for the 
<I>WM_KEYDOWN</I> message. The following ATL code shows 
you how to call the <I>TranslateAccelerator</I> method to fix the keystroke problems:</P>
<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>// WM_KEYDOWN handler method
//
LRESULT CMyClass::OnKeydown(UINT uMsg, WPARAM wParam, LPARAM lParam,
                            BOOL&amp; bHandled)
{
   // m_spWebBrowser is a data member of type IWebBrowser2.
   // Using CComQIPtr in this way queries m_spWebBrowser
   // for the IOleInPlaceActiveObject interface, which is
   // then stored in the pIOIPAO variable.
   //
   CComQIPtr&lt;IOleInPlaceActiveObject,
             &amp;IID_IOleInPlaceActiveObject&gt; pIOIPAO(m_spWebBrowser);

   HRESULT hr = S_FALSE;

   if (pIOIPAO)
   {
      MSG msg;
      msg.message = uMsg;
      msg.wParam = wParam;
      msg.lParam = lParam;

      hr = pIOIPAO-&gt;TranslateAccelerator(&amp;msg);   
   }

   return hr;
}
</PRE>
</td></tr></table></p>
<P>This standard C++ code also demonstrates how to call the 
<I>TranslateAccelerator</I> method to fix the keystroke problems:</P>
<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>// WM_KEYDOWN handler method
//
LRESULT CMyClass::OnKeydown(UINT uMsg, WPARAM wParam, LPARAM lParam,
                            BOOL&amp; bHandled)
{
   IOleInPlaceActiveObject* pIOIPAO;

   HRESULT hr = m_pWebBrowser-&gt;QueryInterface(IID_IWebBrowser2,
                                              (void**)&amp;pIOIPAO);

   if (SUCCEEDED(hr))
   {
      MSG msg;
      msg.message = uMsg;
      msg.wParam = wParam;
      msg.lParam = lParam;

      hr = pIOIPAO-&gt;TranslateAccelerator(&amp;msg);   
      pIOIPAO-&gt;Release();
   }

   return hr;
}
</PRE>
</td></tr></table></p>
<P>Sometimes your application won't automatically be sent 
<I>WM_KEYDOWN</I> messages for accelerator keys. When it isn't, you must send 
<I>WM_KEYDOWN</I> to your window manually. The following message pump sends all keyboard messages to 
your application's window:</P>
<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>while (GetMessage(&amp;msg, NULL, 0, 0))
{
   TranslateMessage(&amp;msg);

   // Send all keyboard messages to the window of your
   // application. hwndApp is the window handle of
   // your application.
   //
   if (msg.message &gt;= WM_KEYFIRST &amp;&amp; msg.message &lt;= WM_KEYLAST)
      ::SendMessage(hwndApp, msg.message, msg.wParam, msg.lParam);
         
   DispatchMessage(&amp;msg);
}
</PRE>
</td></tr></table></p>

<A NAME="290"><H2>Win32 SDK Modal Dialog</H2></A>

<P>It would be nice if you could create Win32 SDK dialogs by using one of the 
following Win32 API dialog box functions:<I> 
DialogBox</I>,<I> DialogBoxIndirect</I>,<I> 
DialogBoxIndirectParam</I>, or 
<I>DialogBoxParam</I>. These functions are especially helpful 
when you're creating modal dialogs because they handle the message pump for your 
application. However, using them creates a dilemma when you're trying to fix 
keystroke problems&#8212;where do you put the call to 
<I>TranslateAccelerator</I>? I don't recommend that you use the Win32 dialog box functions to create your modal dialog that 
hosts the WebBrowser control. Let's look at why.</P>

<P>When the focus is set to a control on a dialog, the control is sent the 
<I>WB_
GETDLGCODE </I>message. Typically, a control responds to this message by 
returning <I>DLGC_WANTALLKEYS</I>. Then the control is given a chance to handle all keys the 
user entered.</P>

<P>The WebBrowser control, however, responds to the 
<I>WM_GETDLGCODE </I>message by returning <I>DLGC_WANTARROWS | 
DLGC_WANTCHARS</I>. Therefore, it won't handle certain keys such as Tab and Delete. To work around this, you need to 
have control of the message pump so that you can call 
<I>TranslateAccelerator</I> (as I explained earlier). To control the message pump, you should create the dialog 
window yourself.</P>

<P><DIV CLASS="NOTE"><BLOCKQUOTE><B>NOTE</B><HR>
You can use MFC or ATL to create a Win32 dialog. In addition, if 
you need a modal dialog that just displays a Web page, you can use the 
<I>showModalDialog</I> method provided by Internet Explorer.
</BLOCKQUOTE></DIV></P>

<P>If you don't want to fix your keystroke problems by creating the dialog 
window manually, you have one other option: a Windows hook. By using a 
Windows hook, you can retrieve all keyboard messages for the current thread and then 
call <I>TranslateAccelerator </I>so that accelerator keys will be processed.</P>
<P>But this approach has one problem. When the focus is on the 
WebBrowser control and you attempt to change the focus between controls on the Web page 
by pressing Tab, the focus will never leave the WebBrowser window. You can tab 
between controls on the Web page or between controls in your application, but 
you can't do both.</P>
<P>Follow these four steps to set up a Windows hook to work around the 
keystroke problems in a Win32 SDK dialog:</P>
<OL>
<P><LI>Declare the hook procedure in your header file.</LI></P>
<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>static LRESULT CALLBACK GetMsgHookProc(int nCode, WPARAM wParam, 
                                       LPARAM lParam);</PRE>
</TD></TR></TABLE></P>

<P><LI>During initialization, set the hook procedure by calling 
<I>SetWindowsHookEx</I>. Also, make sure to save the returned hook handle so that you can 
unhook the hook procedure when your application is shutting down or when 
you no longer need it.</LI></P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>// Declare this global handle in 
// one of your project files.
//
HHOOK g_hook;

// Place this code inside an initialization 
// method in your implementation file (.cpp).
//
g_hook = SetWindowsHookEx(WH_GETMESSAGE, GetMsgHookProc,
                          NULL, GetCurrentThreadId());
</PRE>
</TD></TR></TABLE></P>
<P><LI>Implement the hook procedure, and call 
<I>TranslateAccelerator</I>.</LI></P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>LRESULT CALLBACK CYourClass::GetMsgHookProc(int nCode, WPARAM wParam,
                                            LPARAM lParam)
{
   LPCKFSEARCH pThis = (LPCKFSEARCH)GetWindowLong(hwndMain, DWL_USER);
   if (pThis &amp;&amp; nCode &gt;= 0)
   {
      MSG* pMsg = (MSG*)lParam;

      // m_pOleInPlaceActObj is an IoleInPlaceActiveObject  
      // data member of the view class that is initialized
      // after the WebBrowser control is loaded.

      if (pThis-&gt;m_pOleInPlaceActObj)
         pThis-&gt;m_pOleInPlaceActObj-&gt;TranslateAccelerator(pMsg);
      // This next bit of code causes the tab to work in the
      // WebBrowser window. If you don't implement this code, tabbing
      // will happen only in the dialog.  You can tab either in
      // the dialog or in the WebBrowser window, but not in both.
     

      if (pMsg-&gt;wParam == VK_TAB)
         ZeroMemory(pMsg, sizeof(MSG));
   }

   return CallNextHookEx(g_hook, nCode, wParam, lParam);
}
</PRE>
</TD></TR></TABLE></P>
<P><LI>When your application is shutting down or when you no longer need 
the hook, unhook the hook procedure by using this code:</LI></P>
<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>UnhookWindowsHookEx(g_hook);</PRE>
</TD></TR></TABLE></P>
</OL>

<A NAME="291"><H2>Band Objects</H2></A>

<P>When hosting the WebBrowser control in band objects&#8212;Explorer Bars 
(Explorer bands and Comm bands) and Desk bands&#8212;fixing keystroke problems is a little 
more complicated than merely calling 
<I>TranslateAccelerator</I>; you not only have to call 
this method, but you must also deal with focus issues. The WebBrowser control has 
to know that your band object currently has the focus; otherwise, the accelerator 
keys won't be processed. You must perform a number of tasks to make the 
accelerator keys work correctly.</P>

<P>Don't forget to implement the 
<I>IOleControlSite</I> interface when hosting a WebBrowser control in a band object, just as you would when hosting 
the WebBrowser control in a standard application. Implementing 
<I>IOleControlSite</I> is extremely important, as its 
<I>OnFocus</I> method is called when the focus is set to 
the WebBrowser control. When <I>OnFocus</I> is called, you must query the 
WebBrowser control for the <I>IInputObjectSite</I> interface and call its 
<I>OnFocusChangeIS</I> method, which tells the WebBrowser control that your band object now has the focus.</P>
<P>The following code demonstrates how to call the 
<I>OnFocusChangeIS</I> method if you are hosting the WebBrowser control in an Explorer Bar. (This code is from 
the WebBand sample that I showed you in <A HREF="ch10a.htm">Chapter 10</A>.) Note that in this code, 
<I>m_pSite</I> is a data member of type 
<I>IInputObjectSite</I>,<I> </I>which was retrieved from the 
WebBrowser control in the Explorer Bar's 
<I>IObjectWithSite::SetSite</I> method. Also note that the 
Explorer Bar has to implement the 
<I>IInputObject</I> interface.</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHODIMP CWBExplorerBar::OnFocus(BOOL fGotFocus)
{
   if (m_pSite)
      m_pSite-&gt;OnFocusChangeIS(static_cast&lt;IInputObject*&gt;(this),
                               fGotFocus);
   return S_OK;
}
</PRE>
</td></tr></table></p>
<P>Now whenever a key is pressed, three actions occur. First, the Explorer 
Bar's <I>IInputObject::HasFocusIO</I> method is called to see whether the Explorer Bar 
currently has the focus. The Explorer Bar's implementation of 
<I>IInputObject::HasFocusIO</I> should determine whether the WebBrowser control that the Explorer Bar is hosting has 
the focus or any of the WebBrowser control's children have the focus. The 
<I>HasFocusIO </I>method should return <I>S_OK</I> if the WebBrowser control or one of its children has 
the focus, or <I>S_FALSE</I> otherwise. Here's the code for 
<I>HasFocusIO</I>:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHODIMP CWBExplorerBar::HasFocusIO(void)
{
   HWND hwnd = GetFocus();
   HWND hwndTmp = m_hwndWB;  // HWND of the WebBrowser control

   // See whether the focus has been set to any of the children.
   //
   while (hwnd &amp;&amp; hwndTmp)
   {
      if (hwnd == hwndTmp)
         return S_OK;

      hwndTmp = ::GetWindow(hwndTmp, GW_CHILD);
   }

   return S_FALSE;
}
</PRE>
</td></tr></table></p>
<P>Second, the Explorer Bar's 
<I>IInputObject::UIActivateIO</I> method is called to 
tell the Explorer Bar that it is being activated. The Explorer Bar's implementation of 
this method either UI-activates, or in-place activates, the WebBrowser control, 
depending on the value of one of the 
<I>IInputObject::UIActivateIO</I> method's input 
values: <I>fActivate</I>. Note that in the next code sample, 
<I>m_pIOleObject</I> is a pointer to an instance of 
<I>IOleObject</I> that was retrieved from the WebBrowser control in the 
<I>SetSite</I> method of the Explorer Bar.</P>
<P><table cellpadding=5 width="95%"><TR><TD>

<PRE>STDMETHODIMP CWBExplorerBar::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
   _ASSERT(m_pIOleObject);

   HRESULT hr = E_FAIL;

   if (m_pIOleObject)
   {
      RECT  rc;
      GetClientRect(m_hwndParent, &amp;rc);

      //
      // If the Explorer Bar is being activated, we must UI-activate 
      // the WebBrowser control for all accelerators to work.
      //
      if (fActivate)
      {
         hr = m_pIOleObject-&gt;DoVerb(OLEIVERB_UIACTIVATE, lpMsg,
                                    this, 0, _hwndParent, &amp;rc);
      }
      else
      {
         hr = m_pIOleObject-&gt;DoVerb(OLEIVERB_INPLACEACTIVATE, lpMsg,
                                    this, 0, _hwndParent, &amp;rc);
      }
    }

   return hr;
}
</PRE>
</td></tr></table></p>
<P>Third, the Explorer Bar's 
<I>IInputObject</I>::<I>TranslateAcceleratorIO 
</I>method is called. Here the Explorer Bar passes the keystroke message to the hosted WebBrowser 
control by calling 
<I>IOleInPlaceActiveObject</I>::<I>TranslateAccelerator</I>
. Calling <I>TranslateAccelerator </I>causes accelerator keys such as the Backspace key and the Delete key to be 
processed by the WebBrowser control.</P>
<P><table cellpadding=5 width="95%"><TR><TD>

<PRE>STDMETHODIMP CWBExplorerBar::TranslateAcceleratorIO(LPMSG pMsg)
{
   LPDISPATCH pDisp = NULL;
   IOleInPlaceActiveObject* pIOIPAO;
   HRESULT hr = S_FALSE;

   //
   // Send accelerator messages to the WebBrowser control
   // so that keys such as Backspace and Delete will work correctly.
   // Note that s_ denotes a static data member.
   //
   hr = s_pWebBrowserOC-&gt;get_Application(&amp;pDisp);

   if (SUCCEEDED(hr))
   {
      hr = pDisp-&gt;QueryInterface(IID_IOleInPlaceActiveObject, 
                                 (LPVOID*)&amp;pIOIPAO);
      pDisp-&gt;Release();

      if (SUCCEEDED(hr))
      {
         hr = pIOIPAO-&gt;TranslateAccelerator(pMsg);
         pIOIPAO-&gt;Release();
      }
   }

   return hr;
}
</PRE>
</td></tr></table></p>
<P>You might find the preceding discussion and associated code a little 
confusing at first. To better understand how band objects work, refer to <A HREF="ch10a.htm">Chapter 10</A>.</P>

</BODY>
</HTML>





