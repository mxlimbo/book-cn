<HTML>
<head>
<link rel="STYLESHEET" type="text/css" href="Progie5.css">
<TITLE>Automating Internet Explorer</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch06d.htm">[Previous]</A> <A HREF="ch06f.htm">[Next]</A><P>

<A NAME="169"><H1>Automating Internet Explorer</H1></A>

<P>Automating Internet Explorer opens a world of possibilities for developing 
Web-based applications. It allows you to customize Internet Explorer to fit your needs 
without having to create a full-blown application by using Visual Basic or Visual C++. 
Automation offers other advantages as well: you can change Internet Explorer's user 
interface by using the methods and properties of its interfaces; you can provide 
user interface features such as browser bars that you can't easily provide when 
hosting the WebBrowser control; and you can control navigation.</p>
<p>Automating Internet Explorer is easy. You create a simple application that 
starts an instance of the browser. Then you control Internet Explorer in the same way 
you control the WebBrowser control&#8212;by using the <I>IWebBrowser2</I> interface. I'll show you how easily you can automate Internet Explorer by using Visual Basic and Visual C++.</P>

<p><div class="note"><blockquote><b>NOTE</b><HR>The term <I>automation</I> in its truest sense refers to controlling a COM object by using its automation interface&#8212;<I>IDispatch</I>. But developers who write applications to control Internet Explorer use the terminology <I>automating Internet Explorer</I>, even though controlling the browser in this way that might not involve using the <I>IDispatch </I>interface directly.</blockquote></div></p>

<A NAME="170"><H2>Using Visual Basic</H2></A>

<P>You've already seen how to create a fully functional Visual Basic Web browser 
application in five minutes by using the WebBrowser control. You can build a fully 
functional Visual Basic application that automates Internet Explorer in about the 
same amount of time. Let's build one now.</P>
<P>Start Visual Basic and choose Standard EXE from the New Project dialog 
box. Then choose References from the Project menu. The References dialog box, shown in Figure 6-19, will be displayed.</P>

<P>
<A HREF="javascript:fullSize('F06ii19x.htm')"> <img src="images/F06ii19.JPG" width=404 height=321 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 6-19.</B> <I>References dialog box.</I><!-- /caption -->
</P>

<P>Scroll down in the list box, check the Microsoft Internet Controls check 
box, and click OK (just as you did in the Components dialog box when hosting the 
WebBrowser control). Now add a command button to the form, name it <I>btnStart</I>, and change the caption to <I>Start IE5</I>. Then double-click the command button so that you can add code to the event handler for the <I>Click </I>event of this button.</p>

<P>When a user clicks the Start IE5 button, you want your application to start a new instance of Internet Explorer 5. The code to make this happen is pretty straightforward. First create a global variable of type <I>InternetExplorer</I>. (This is the <I>InternetExplorer</I> object that I told you about earlier in this chapter in the section entitled &quot;<A HREF="ch06c.htm#157">The WebBrowser Control and Internet Explorer</A>.&quot;) Name this variable <I>InternetExplorer1</I>.</p>

<P>Now, in the event handler for the <I>Click </I>event of <I>btnStart</I>, add code to create a new instance of Internet Explorer if an instance hasn't previously been created. You can use either the <I>CreateObject</I> Visual Basic function or the <I>New </I>keyword. But because you can't perform certain tasks with an object created by a call to <I>CreateObject</I>, such as handling events, you should create the <I>InternetExplorer </I>object by using the <I>New</I> keyword, like this:</p>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
Set InternetExplorer1 = New InternetExplorer
</PRE>
</td></tr></table></p>

<P>This code creates a new instance of Internet Explorer, but the instance is hidden. To make this instance visible, set the <I>Visible </I>property to <I>True</I>, as shown below.</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
InternetExplorer1.Visible = True
</PRE>
</td></tr></table></p>

<P>Now you need to navigate to a Web page in this new instance of Internet Explorer. You can do this by calling the <I>Navigate</I> method of the <I>InternetExplorer</I> object, like this:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
InternetExplorer1.Navigate &quot;http://www.microsoft.com/&quot;
</PRE>
</td></tr></table></p>

<P>At this point, the entire Visual Basic source code that automates Internet 
Explorer for this application should look like this:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
Option Explicit
Dim InternetExplorer1 As InternetExplorer

Private Sub btnStart_Click()
   ' Only create a new instance of Internet Explorer
   ' if one hasn't already been created.
   '
   If Not InternetExplorer1 Is Nothing Then
      Exit Sub
   End If

   Set InternetExplorer1 = New InternetExplorer
   
   ' Make Internet Explorer visible and navigate
   ' to Microsoft's home page.
   '
   InternetExplorer1.Visible = True
   InternetExplorer1.Navigate &quot;http://www.microsoft.com/&quot;
End Sub

Private Sub Form_Load()
   Set InternetExplorer1 = Nothing
End Sub
</PRE>
</td></tr></table></p>

<P>Go ahead and run your application. Then click the Start IE5 button to run 
the application and watch Internet Explorer fly! A new instance of Internet Explorer 
will be started that navigates to Microsoft's home page. That wasn't too difficult, was 
it? Now let's add some really cool features to the application that allow you to 
control the instance of Internet Explorer that you create.</P>

<P>First save your project as VbAutoIE.vbp, and save your form as 
VbAutoIE.frm. Then add some controls to your form, as shown in Figure 6-20. These controls 
will allow you to show or hide the different user interface features of Internet 
Explorer such as the address bar, menu bar, status bar, and toolbar. You'll also be able to 
add text to the status bar.</p>

<p>
<A HREF="javascript:fullSize('F06ii20x.htm')"> <img src="images/F06ii20.JPG" width=404 height=297 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><B>Figure 6-20.</B> <I>Visual Basic form with controls to customize the Internet Explorer user interface.</I><!-- /caption -->
</p>

<p>Now set the properties of each of these controls, as shown in Table 6-8. For 
the Option Buttons control, create four control arrays of option buttons. Each array 
should contain one Hide and one Show option button, as shown in Figure 6-20. Set the 
captions of all the top option buttons to <I>Hide </I>and all the bottom option buttons to <I>Show</I>.</p>

<p><b>Table 6-8.</b> <i>Control Properties for a Visual Basic Program Automating Internet Explorer</i></p>

<p><table cellpadding=5 width="95%">

<tr><th><i>Control</i></th><th><i>Properties</i></th></tr>
<tr><td valign="top">Frame1-4</td><td valign="top">Captions = &quot;<i>AddressBar</i>&quot;, &quot;<i>MenuBar</i>&quot;, &quot;<i>StatusBar</i> &quot;, and &quot;<i>ToolBar</i>&quot;, respectively</td></tr>

<tr><td valign="top">Hide Option Buttons</td>     
<td valign="top">Caption = &quot;<i>Hide</i>&quot;; Index = <I>0</I>; Value = <I>False</I>; Names = <I>optAddrBar</I>, <I>optMenuBar</I>, <I>optStatusBar</I>, and <I>optToolBar</I>, respectively</td></tr>

<tr><td valign="top">Show Option Buttons</td>     
<td valign="top">Caption = &quot;<i>Show</i>&quot;; Index = <I>1</I>; Value = 
<I>True</I>; Names = <I>optAddrBar</I>, <I>optMenuBar</I>, 
<I>optStatusBar</I>, and <I>optToolBar</I>, respectively</td></tr>

<tr><td valign="top">Label</td><td valign="top">Caption = &quot;<i>Status Text</i>&quot;</td></tr>

<tr><td valign="top">TextBox</td>     
<td valign="top">Name = <I>txtStatusText</I>. Remove the default text for the <I>Text </I>property</td></tr>

<tr><td valign="top">CommandButton</td>     
<td valign="top">Caption = &quot;<i>Change</i>&quot;; Name = <I>btnChange</I></td></tr>
</table></p>

<p>Now add code to use the properties of the <I>InternetExplorer</I> object to control the browser's user interface features. Take a look at Listing 6-1 to see the Visual 
Basic code that implements the functions of the controls in the table.</p>

<p><B>Listing 6-1.</B> </p>

<P><table cellpadding=5 width="95%">
<TR><TD>
<A NAME="171"><H3>VbAutoIE.bas</H3></A>
<PRE>
Option Explicit
Dim InternetExplorer1 As InternetExplorer
Const HideBar = 0
Const ShowBar = 1
Private Sub btnChange_Click()
   On Error Resume Next
   InternetExplorer1.StatusText = txtStatusText.Text
End Sub

Private Sub btnStart_Click()
   ' Only create a new instance of Internet Explorer
   ' if one hasn't already been created.
   '
   If Not InternetExplorer1 Is Nothing Then
      Exit Sub
   End If
   
   Set InternetExplorer1 = New InternetExplorer
   
   ' Set the user interface features to match the
   ' entries specified by the user.
   '
   If optAddrBar(ShowBar).Value = True Then
      InternetExplorer1.AddressBar = True
   Else
      InternetExplorer1.AddressBar = False
   End If
   
   If optMenuBar(ShowBar).Value = True Then
      InternetExplorer1.MenuBar = True
   Else
      InternetExplorer1.MenuBar = False
   End If
   
   If optToolBar(ShowBar).Value = True Then
      InternetExplorer1.ToolBar = True
   Else
      InternetExplorer1.ToolBar = False
   End If

   If optStatusBar(ShowBar).Value = True Then
      InternetExplorer1.StatusBar = True
   Else
      InternetExplorer1.StatusBar = False
   End If
   
   ' Make Internet Explorer visible and navigate
   ' to Microsoft's home page.
   '
   InternetExplorer1.Visible = True
   InternetExplorer1.Navigate &quot;http://www.microsoft.com/&quot;
End Sub

Private Sub Form_Load()
   Set InternetExplorer1 = Nothing
End Sub

Private Sub Form_Unload(Cancel As Integer)
   On Error Resume Next
   InternetExplorer1.Quit
End Sub

Private Sub optAddrBar_Click(Index As Integer)
   On Error Resume Next
   InternetExplorer1.AddressBar = CBool(Index)
End Sub

Private Sub optMenuBar_Click(Index As Integer)
   On Error Resume Next
   InternetExplorer1.MenuBar = CBool(Index)
End Sub

Private Sub optStatusBar_Click(Index As Integer)
   On Error Resume Next
   InternetExplorer1.StatusBar = CBool(Index)
End Sub

Private Sub optToolBar_Click(Index As Integer)
   On Error Resume Next
   InternetExplorer1.ToolBar = Index
End Sub
</pre>
</td></tr></table></p>



<p>In Listing 6-1, when the form is loaded, the <I>InternetExplorer1 </I>object is set equal to <I>Nothing. </I>(This is how you know that Internet Explorer hasn't been previously started by this application.) When the Start IE5 button is clicked, we check to ensure that an instance of Internet Explorer wasn't previously created. If one was, we return from this method.</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>This application can start only one instance of Internet Explorer at 
any time, even if the user shuts down the browser. I'll show you how to tell when 
the browser is closed in the <a href="ch07a.htm">next chapter</a>.
</blockquote></div></p>

<P>If another instance of Internet Explorer wasn't previously created by this 
application, we create an instance of Internet Explorer 5 by using the 
<I>New </I>keyword. Then we check the current state of each option button in each control array. We set the appropriate Internet Explorer user interface feature according to the current state of each option button. Then we show Internet Explorer by setting its <I>Visible </I>property to <I>True.</I> Finally we navigate to Microsoft's home page by using the <I>Navigate </I>method.</P>

<p>Each time an option button is clicked, we handle the <I>Click</I> event of the control array associated with the option button. In the event handler, we show or hide the associated Internet Explorer user interface item by setting the associated <I>InternetExplorer</I> property to the <I>Index </I>of the selected option button. Because all the properties (except one) for the user interface items that we're interested in take a Boolean value, we use the <I>CBool</I> function to convert the <I>Index</I> parameter from Integer to Boolean. The <I>ToolBar </I>property takes an Integer value, so <I>ToolBar </I>can be set equal to <I>Index. </I>In each <I>Click</I> event handler, we also use <I>On Error Resume Next</I>, just in case the user clicked the option buttons without starting Internet Explorer.</p>

<p>In the <I>Click </I>event handler for the Change button, we set Internet Explorer's 
status text to the text entered into the text box. We did so by setting the 
<I>StatusText</I> property to the <I>Text </I>property of 
<I>txtStatusText</I>.</p>

<p>When the application is closed, Internet Explorer should shut down if it is 
still running. To cause Internet Explorer to close, call Internet Explorer's 
<I>Quit</I> method in the <I>Unload</I> method for the form. We used the 
<I>On Error Resume Next</I> error handling feature just in case the user previously closed Internet Explorer manually.</p>

<p>Now test your application. Run VbAutoIE,and start a new instance of 
Internet Explorer by clicking the Start IE5 button. Hide and show all the user interface 
items by using the option buttons. Also add some text to the status bar by entering the 
text into the text box and clicking the Change button. The sample created by following 
these steps can be found on the companion CD in the folder \Samples\Chap06\VbAutoIE.</p>

<A NAME="172"><H2>Using Visual C++ and COM APIs</H2></A>

<P>Although automating Internet Explorer in a Visual C++ application isn't as easy 
as doing so in a Visual Basic application, it's not terribly difficult, especially if you 
understand COM and its APIs. And whether you're automating Internet Explorer in 
MFC, ATL, or standard C++, the method is exactly the same&#8212;you use the COM APIs.</P>

<p>We'll convert the VbAutoIEapplication we built in the previous section to 
an MFC application. Although we'll use MFC to build the user interface, the way in 
which we call the Internet Explorer properties, including the way we start Internet 
Explorer, will work in ATL and standard C++ as well.</p>

<p>Creating an instance of Internet Explorer in Visual C++ involves calling the <I>CoCreateInstance</I> COM API function, specifying <I>CLSID_InternetExplorer </I>as the first parameter. Creating an instance of Internet Explorer in this way isn't as difficult as manually creating your own ActiveX control container that hosts the WebBrowser control. You don't need to implement the COM interfaces that are necessary for a container or site the object you're creating.</p>

<p>To see how easily you can automate Internet Explorer by using 
<I>CoCreateInstance</I>, let's go ahead and convert VbAutoIE to an MFC application. We'll call this application MfcAutoIE. (Like the other examples in this chapter, this example can be found on the companion CD in the folder \Samples\Chap06\MfcAutoIE.) Start Visual C++, and create a new MFC AppWizard (exe) application named MfcAutoIE. Choose the 
dialog-based option when prompted, and accept the remainder of the default project settings.</p>

<p>Now add controls to your dialog that match the controls in VbAutoIE. The 
dialog should look like the one shown in Figure 6-21. Assign intuitive ID names to 
each control in your dialog. For example, for the radio button group for 
<I>AddressBar</I>, you could assign the ID 
<I>IDC_ADDRBAR_HIDE</I> for the Hidebutton and the 
ID <I>IDC_ADDRBAR_SHOW</I> for the Showbutton. Make sure the tab order of the 
controls matches the order shown in Figure 6-22. (The tab order is 
important because it affects how the radio buttons work.)</p>

<p>
<A HREF="javascript:fullSize('F06ii21x.htm')"> <img src="images/F06ii21.JPG" width=404 height=301 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><B>Figure 6-21.</B> <I>MfcAutoIE dialog.</I><!-- /caption -->
</p>

<p> 
<A HREF="javascript:fullSize('F06ii22x.htm')"> <img src="images/F06ii22.JPG" width=404 height=302 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><B>Figure 6-22.</B> <I>MfcAutoIE dialog tab order.</I><!-- /caption -->
</p>

<p>Now set the <I>Group </I>property for each of the Hide radio buttons by 
right-clicking them, choosing Properties, and checking the Group check box. Do not set the 
<I>Group </I>property for the Show radio buttons. Next, create member variables for some of 
the controls, which are shown in Table 6-9.</p>

<p><b>Table 6-9.</b> <i>Member Variables for MfcAutoIE Dialog Controls</i></p>

<P><table cellpadding=5 width="95%">

<tr><th><i>Control</i></th><th><i>Type</i></th><th><i>Member Variable</i></th></tr>
<tr><td valign="top">Hide radio button for AddressBar</td><td valign="top"><I>int</I></td>     <td valign="top"><I>m_nAddressBar</I></td></tr>

<tr><td valign="top">Edit box</td><td valign="top"><I>CString</I></td><td valign="top"><I>m_strStatusText</I></td></tr>

<tr><td valign="top">Hide radio button for MenuBar</td><td valign="top"><I>int</I></td><td valign="top"><I>m_nMenuBar</I></td></tr>

<tr><td valign="top">Hide radio button for StatusBar</td><td valign="top"><I>int</I></td>     
<td valign="top"><I>m_nStatusBar</I></td></tr>

<tr><td valign="top">Hide radio button for ToolBar</td><td valign="top"><I>int</I></td>     
<td valign="top"><I>m_nToolBar</I></td></tr>
</table></p>

<P>When the member variables in Table 6-9 are created using ClassWizard, their declarations will be inserted into the class definition for <I>CMfcAutoIEDlg</I>. These member variables will also be initialized to<I> -1</I> in your constructor. Initializing these values to <I>-1 </I>effectively turns all radio buttons off. In VbAutoIE, I told you to set all the Show buttons to <I>true</I> by default. For this example, we're going to do something a little different. Instead of setting these buttons to <I>true</I> by default, we're going to talk about how to determine the current setting of each user interface feature when Internet Explorer is started.</P>

<p><div class="sidebar"><blockquote>
<b>Setting Proper Directory Order Before Compiling the MfcAutoIE Example</b>
<P>Before compiling the MfcAutoIE example, you need to perform a few 
important tasks:</P>
<OL>
<P><LI>Make sure you download the headers and libraries for Internet 
Explorer 5 from the MSDN Online Web Workshop.</LI></P>

<P><LI>In the Directories tab of the Tools/Options menu, make sure to 
select Library Files from the combo box in the upper right-hand corner 
and include the directories of the library files for Internet Explorer 5 
and Windows 2000 first in the list.</li></p>

<P><LI>Select Include Files from the combo box and place your include file 
directories in the order indicated in the following list.</li></p>
<OL type="a">
<P><LI><I>Internet Explorer 5 include directory</I>.By default this directory is \Workshop\Include.</li></p>

<P><LI><I>A temporary directory named VC6.</I> You should create this directory under the include directory for the Internet Explorer 5 include files. Next, copy the unknwn.h and unknwn.idl files from the include directory for Microsoft Visual C++ 6 to this temporary directory. Include this new directory as the second item in your include directories list to avoid conflicts between the files in the Microsoft Visual C++ 6 include directory and the files in the Windows 2000 include directory.</li></p>

<P><LI><I>Windows 2000 include directory. </I>By default this directory is \Workshop\Include\NT5.</li></p>

<P><LI><I>Microsoft Visual C++ 6 include directory.</I></li></p>
<P><LI><I>Microsoft Visual C++ 6 ATL include directory.</I></li></p>
<P><LI><I>Microsoft Visual C++ 6 MFC include directory.</I></li></p>
</OL>
</OL>
&nbsp;
</blockquote></div></p>

<P>Now let's add the code to make it all work. First you should include the ExDisp.h header file in the header file for your dialog&#8212;MfcAutoIEDlg.h. ExDisp.h is the header file that contains the interface definition of the WebBrowser interfaces as well as all the class IDs and interface IDs that pertain to the WebBrowser control and Internet Explorer. Make sure you have downloaded the latest version of the Internet Explorer 5 header and library files from MSDN Online Web Workshop.</P>

<P>Create a private or protected data member of type pointer to <I>IWebBrowser2</I>, and name it <I>m_pInetExplorer</I>. Its declaration should look like this:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
protected:
   IWebBrowser2* m_pInetExplorer;
</PRE>
</td></tr></table></p>

<P>Now initialize <I>m_pInetExplorer</I> to 
<I>NULL</I> in the constructor for the class. You 
must also initialize COM. Place a call to the <I>CoInitialize 
</I>COM API in the constructor. The constructor code should now look like this:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
CMfcAutoIEDlg::CMfcAutoIEDlg(CWnd* pParent /*=NULL*/)
   : CDialog(CMfcAutoIEDlg::IDD, pParent),
     m_pInetExplorer(NULL)
{
   //{{AFX_DATA_INIT(CMfcAutoIEDlg)
   m_strStatusText = _T(&quot;&quot;);
   m_nAddressBar = -1;
   m_nMenuBar = -1;
   m_nStatusBar = -1;
   m_nToolBar = -1;
   //}}AFX_DATA_INIT
   //Note that LoadIcon does not require a subsequent DestroyIcon
   //in Win32.
   m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);

   // Initialize COM
   CoInitialize(NULL);
}
</PRE>
</td></tr></table></p>

<P>Create a destructor for the class. In the destructor, use the <I>CoUninitialize</I> API function to uninitialize COM. Here's the code for the destructor:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
CMfcAutoIEDlg::~CMfcAutoIEDlg()
{
   // Uninitialize COM.
   //
   CoUninitialize();
}
</PRE>
</td></tr></table></p>

<P>With the preliminary work behind us, let's implement the controls. First create a Windows message handler for the Start IE5 button. As usual, you can create this message handler by using ClassWizard<I>. </I>In this message handler, create an instance of Internet Explorer by using the <I>CoCreateInstance</I> API function. The instance of Internet Explorer that is created will initially be hidden, so you must make it visible by using the <I>Visible </I>property. And to navigate to the user's home page, use the <I>GoHome</I> method. Here's the code for the message handler:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
void CMfcAutoIEDlg::OnStartIE5() 
{
   // If an instance of Internet Explorer has
   // not already been created, create one.
   // This instance will initially be hidden,
   // so make it visible by using the Visible
   // property. Also, navigate to the user's
   // home page by using the GoHome method.
   //
   if (m_pInetExplorer)
      MessageBox
         (_T(&quot;Only one instance of Internet Explorer is allowed.&quot;));
   else
   {
      HRESULT hr;
      hr = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_SERVER,
                           IID_IWebBrowser2, (LPVOID*)&amp;m_pInetExplorer);

      if (SUCCEEDED(hr))
      {
         // Set the radio buttons to their correct values.
         SetRadioButtons();

         m_pInetExplorer-&gt;put_Visible(VARIANT_TRUE);
         m_pInetExplorer-&gt;GoHome();
      }
   }
}
</PRE>
</td></tr></table></p>

<P>In this code, we first check to see whether an instance of Internet Explorer 
has already been created. If it has, an error message is displayed. (This example has 
the same problem as the VbAutoIE example&#8212;you can start only one instance of 
Internet Explorer. In the <a href="ch07a.htm">next chapter</a>, you'll learn how to determine when the 
browser is closed so that you can reset the data member representing Internet Explorer.) 
If an instance of Internet Explorer hasn't been created, 
<I>CoCreateInstance</I> is called with <I>CLSID_InternetExplorer</I> as the first parameter. (This class ID is defined in ExDisp.h and is the unique identifier of Internet Explorer.)</p>

<p>Then we specify <I>NULL</I> for the second parameter because we don't want this object to be aggregated. We want Internet Explorer to run in a separate process, so we specify <I>CLSCTX_SERVER</I> for the third parameter. We use the fourth parameter to indicate which interface we want to get from <I>CoCreateInstance</I> after the object is created. In this case, we'll almost always want to get <I>IWebBrowser2</I>, so we specify <I>IID_IWebBrowser2</I> for the fourth parameter. Finally we must pass the address of a variable that will be used to store the returned interface pointer. For this parameter, you must pass the address of a pointer to a <I>void</I> type. (Make sure you pass the address of a pointer that points to an interface type.)</p>

<p>If an instance of Internet Explorer was successfully created, a member 
function named <I>SetRadioButtons </I>is called. This is a protected member function that 
checks the current state of the address bar, menu bar, toolbar, and status bar, and sets 
the radio button groups accordingly. To check the state of each of these user 
interface items, we simply retrieve the current value of the property associated with each 
user interface item.</p>

<p>In C++ applications that use COM without wrapper classes, properties are referenced by using the <I>get_ </I>and <I>put_</I> methods. (Recall that the <I>get_</I> form of a property retrieves the current value of that property; the <I>put_</I> form of a property sets the current value of the property.) To check the state of the user interface items in question, we simply call the <I>get_</I> method of the property associated with each item. All of these <I>get</I>_methods except <I>get_ToolBar</I> take a pointer to a <I>VARIANT_BOOL</I> type that, upon return, indicates whether the user interface item is visible or hidden. If the user interface item is visible, a value of <I>VARIANT_TRUE </I>is returned.If the item is hidden, a value of <I>VARIANT_FALSE </I>is returned. These values are different from the <I>TRUE </I>and <I>FALSE</I> values that you're used to.</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>
When dealing with variables of type <I>VARIANT_BOOL</I> in Visual C++, you must use the values <I>VARIANT_TRUE </I>or <I>VARIANT_FALSE </I>instead of <I>TRUE </I>or <I>FALSE</I>. <I>VARIANT_TRUE </I>is defined as <I>0xffff</I>, whereas <I>TRUE</I> is defined as <I>1</I>. If you compare <I>VARIANT_TRUE </I>to <I>TRUE</I>, you'll find they won't match. In Visual Basic applications, you can use <I>True</I> or <I>False </I>when dealing with variables of type <I>VARIANT_BOOL</I>. Visual Basic takes care of the conversion for you.
</blockquote></div></p>

<P>The <I>get</I>_<I>ToolBar</I> method is different from the other property methods in that it takes a pointer to an integer, so if the value of the integer upon return is nonzero, the toolbar is visible. If the value of the integer is <I>0</I>, the toolbar is hidden.</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>If a property is read-only, the <I>put_</I> form of the property won't exist. The reverse is true as well. If a property is write-only, the <I>get_</I> form of the property won't exist.
</blockquote></div></p>

<P>Here's the code for the <I>SetRadioButtons</I> method:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
void CMfcAutoIEDlg::SetRadioButtons()
{
   VARIANT_BOOL vtBool = VARIANT_TRUE;

   // Get the current state of the AddressBar.
   //
   m_pInetExplorer-&gt;get_AddressBar(&amp;vtBool);
   m_nAddressBar = (vtBool == VARIANT_TRUE) ? 1 : 0;

   // Get the current state of the MenuBar.
   //
   m_pInetExplorer-&gt;get_MenuBar(&amp;vtBool);
   m_nMenuBar = (vtBool == VARIANT_TRUE) ? 1 : 0;

   // Get the current state of the StatusBar.
   //
   m_pInetExplorer-&gt;get_StatusBar(&amp;vtBool);
   m_nStatusBar = (vtBool == VARIANT_TRUE) ? 1 : 0;

   // Get the current state of the ToolBar.
   // Unlike the other get methods, get_ToolBar
   // takes a pointer to an integer.
   //
   m_pInetExplorer-&gt;get_ToolBar(&amp;m_nToolBar);

   UpdateData(FALSE);  // Initializes dialog box with changed values.
}
</PRE>
</td></tr></table></p>

<P>
After the call to <I>SetRadioButtons </I>method, the next thing we do in the <I>OnStartIE5 </I>method is set the <I>Visible</I> property to <I>VARIANT_TRUE</I>. The <I>Visible</I> property takes a <I>VARIANT_BOOL</I> as its only parameter. Here we want to set this value to true, so we add code to pass <I>VARIANT_TRUE.</I> Finally, in the <I>OnStartIE5 </I>method, the <I>GoHome</I> method of the <I>IWebBrowser2</I> interface is called to navigate to the user's home page.</P>

<P>The next step in creating this application is to implement Windows 
message handlers for each of the radio button groups on the dialog. To create a handler 
method for a radio button group, specify a single method to handle the 
<I>BN_CLICKED</I> message for each of the buttons in the group. For example, open 
ClassWizard,and locate the ID for the Hideradio button for the <I>AddressBar</I> group in the Object ID's list box. 
(If you entered the ID that I suggested earlier in this section when talking about 
the radio button group, the ID will be named 
<I>IDC_ADDRBAR_HIDE.</I>) Double-click the <I>BN_CLICKED 
</I>item in the Messages list box.</P>

<P>When prompted for the name of a member function to add to the class, enter 
the name <I>OnAddrBarShowHide</I>. Then locate the ID for the Show radio button for this 
group (<I>IDC_ADDRBAR_SHOW</I>). Double-click the 
<I>BN_CLICKED</I> item in the Messages list box. Again, when prompted, enter the name 
<I>OnAddrBarShowHide</I> for the member function. Now when your user clicks either of the buttons in the group&#8212;Hide or 
Show&#8212;the same member function will be called. Then you check the value of the 
<I>m_nAddressBar</I> data member to see which radio button was selected.
</P>

<P>Now create message handlers for each of the other radio button groups in 
the dialog. Name these message handlers 
<I>OnMenuBarShowHide</I>, 
<I>OnStatusBarShowHide</I>,and 
<I>OnToolBarShowHide</I>, respectively, for the 
<I>MenuBar</I> group, the <I>StatusBar</I> group, and the 
<I>ToolBar</I> group. The code for these handlers should look like this:
</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
void CMfcAutoIEDlg::OnAddrBarShowHide() 
{
   UpdateData(TRUE);

   if (m_pInetExplorer)
   {
      VARIANT_BOOL vtShow = 
         m_nAddressBar ? VARIANT_TRUE : VARIANT_FALSE;

      m_pInetExplorer-&gt;put_AddressBar(vtShow);
   }
}

void CMfcAutoIEDlg::OnMenuBarShowHide() 
{
   UpdateData(TRUE);

   if (m_pInetExplorer)
   {
      VARIANT_BOOL vtShow = 
         m_nMenuBar ? VARIANT_TRUE : VARIANT_FALSE;

      m_pInetExplorer-&gt;put_MenuBar(vtShow);
   }
}

void CMfcAutoIEDlg::OnStatusBarShowHide() 
{
   UpdateData(TRUE);

   if (m_pInetExplorer)
   {
      VARIANT_BOOL vtShow = 
         m_nStatusBar ? VARIANT_TRUE : VARIANT_FALSE;

      m_pInetExplorer-&gt;put_StatusBar(vtShow);
   }
}

void CMfcAutoIEDlg::OnToolBarShowHide() 
{
   UpdateData(TRUE);

   if (m_pInetExplorer)
      m_pInetExplorer-&gt;put_ToolBar(m_nToolBar);
}
</PRE>
</td></tr></table></p>

<P>Notice in the <I>OnToolBarShowHide</I> method that we pass the 
<I>m_nToolBar</I> data member to the 
<I>put_ToolBar</I> method instead of a 
<I>VARIANT_BOOL</I>. We can get away with this because, just like 
<I>get_ToolBar</I>, <I>put_ToolBar</I> takes an integer value and 
not a <I>VARIANT_BOOL</I>.</p>

<P>Now create a Windows message handler for the Change button by 
using ClassWizard. This message handler will set the text in the Internet Explorer status 
bar to the text entered in the edit box whenever the user clicks the 
Changebutton. The code for this message handler should look like this:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
void CMfcAutoIEDlg::OnChangeStatusText() 
{
   UpdateData(TRUE);

   if (m_pInetExplorer)
   {
      _bstr_t bstrStatusText = m_strStatusText.AllocSysString();
      m_pInetExplorer-&gt;put_StatusText(bstrStatusText);
   }
}
</PRE>
</td></tr></table></p>

<P>Make sure that the first task you perform in this code is to call <I>UpdateData</I> and pass <I>TRUE.</I> Doing so updates all data members associated with controls in the 
dialog, including <I>m_strStatusText.</I> If 
<I>m_pInetExplorer</I> isn't <I>NULL</I>&#8212;meaning that an instance 
of Internet Explorer has been created&#8212;the 
<I>StatusText</I> property is set to the text that 
the user entered in the edit box. 
<I>StatusText</I> is set the same way as the <I>Visible 
</I>property&#8212;by calling the <I>put_</I> form of the property function. This function takes a 
<I>BSTR</I> as an input parameter, so the code must call the 
<I>AllocSysString</I> method of the 
<I>m_strStatusText</I> data member to allocate a 
<I>BSTR</I> that can be passed to 
<I>put_StatusText</I>. <I>AllocSysString</I> is a 
<I>CString</I> method that returns a <I>BSTR</I> representation of the string contained in the 
<I>CString</I> object. The <I>BSTR</I> returned from 
<I>AllocSysString </I>is stored in a variable of type 
<I>_bstr_t</I>, one of the COM Compiler Support Classes offered by Visual C++. To use this class, 
you must include the comdef.h header file in the implementation file for 
<I>CMfcAutoIEDlg</I>&#8212;MfcAutoIEDlg.cpp. This class will take care of freeing the 
<I>BSTR</I> when it goes out of scope, so you don't have to call the 
<I>SysFreeString </I>Win32 API function to free the 
<I>BSTR</I> after calling <I>put_StatusText</I>.</P>

<P>
Hang in there; we're almost finished. To prevent the dialog from closing if 
the user presses the Enter key, override the 
<I>OnOK</I> method of the base dialog class. In this method you simply do nothing, which prevents the dialog from closing 
when the user presses Enter. Make sure you don't call the base class 
<I>CDialog::OnOK</I> method; otherwise, the dialog will close.</p>

<p>Now override the <I>OnCancel</I> method of the base dialog class, which is 
called when the user closes the dialog by pressing the Esc key or by clicking the X 
button in the upper right-hand corner of the dialog. In 
<I>OnCancel</I>, if an instance of Internet Explorer was previously created, close that instance by calling the 
<I>Quit</I> method of the <I>InternetExplorer</I> object. 
<I>Quit </I>can be called even when the user has 
already manually closed Internet Explorer. If that's the case, the 
<I>Quit </I>method will return 
<I>RPC_S_SERVER_UNAVAILABLE</I>, which indicates that Internet Explorer is no 
longer available. You can safely ignore this error code. Here's the code for 
<I>OnCancel</I>:</p>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
void CMfcAutoIEDlg::OnCancel()
{
   if (m_pInetExplorer)
      m_pInetExplorer-&gt;Quit();

   CDialog::OnCancel();
}
</PRE>
</td></tr></table></p>

<P>Finally (I bet you can't believe it), you must release the pointer to 
the <I>IWebBrowser2 </I>interface for Internet Explorer. You can do this in the destructor 
for the dialog class. Here's the updated code for the destructor:
</P>
<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
CMfcAutoIEDlg::~CMfcAutoIEDlg()
{
   // Release the WebBrowser interface pointer
   //
   if (m_pInetExplorer)
   {
      m_pInetExplorer-&gt;Release();
      m_pInetExplorer = NULL;
   }

   // Uninitialize COM
   //
   CoUninitialize();
}
</PRE>
</td></tr></table></p>

<P>Now, as usual, compile and run the dialog application. Start an instance 
of Internet Explorer and test it. Show and hide all the user interface features by 
using the radio buttons in the dialog. Also add some text to the status bar by entering 
the text in the edit box and clicking the Change button.</P>

</BODY>
</HTML>






