<HTML>
<head>
<link rel="STYLESHEET" type="text/css" href="Progie5.css">
<TITLE>Events Fired by Internet Explorer 5</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch07c.htm">[Previous]</A> <A HREF="ch07e.htm">[Next]</A><P>

<A NAME="191"><H1>Events Fired by Internet Explorer 5</H1></A>

<p>As you know, Internet Explorer fires events in the same way as any other 
COM object&#8212;through a connection point. Why on earth does Internet Explorer fire 
events? Any time Internet Explorer needs to provide information to its clients about 
current activity, Internet Explorer fires an event through the 
<I>DWebBrowserEvents2</I> connection point. (Prior to version 4, Internet Explorer fired events through the 
<I>DWebBrowserEvents </I>interface. But in versions 
4.<I>x </I>and 5, Internet Explorer fires events through 
the <I>DWebBrowserEvents2</I> connection point.)</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
How can you figure out which events are fired by Internet Explorer? 
The best source of information is the MSDN Online Web Workshop. Another way 
to find out which events are fired by Internet Explorer&#8212;or any other COM 
object&#8212;is by using the OLE-COM Object Viewer that comes with Visual C++ 5 and 6.
</blockquote></div>
</p>

<p>Unlike the standard interfaces of the WebBrowser control and Internet 
Explorer, the event interfaces have no inheritance hierarchy. The 
<I>DWebBrowserEvents </I>interface is strictly for Internet Explorer 3. If you're hosting the WebBrowser control or 
automating Internet Explorer 5, you can sink events for this interface&#8212;but I 
wouldn't advise it. The <I>DWebBrowserEvents2</I> interface contains methods that are 
custom-built for Internet Explorer 5. You'll have much more control over the WebBrowser if 
you sink events for the <I>DWebBrowserEvents2</I> interface instead of sinking events 
for <I>DWebBrowserEvents</I>. So don't forget that 
<I>2</I> at the end of the interface name.</p>

<p>Even though <I>DWebBrowserEvents2 </I>is an event interface, it is just another 
COM interface like <I>IWebBrowser2</I>, so it can contain methods. (The 
<I>D</I> at the beginning of the name simply stands for dispinterface. A dispinterface is an 
<I>IDispatch</I> interface. Unlike a normal interface, a dispinterface has no vtable.) Remember that, like 
an interface, a dispinterface merely provides the definition of some 
functionality&#8212;it doesn't actually provide the implementation of this functionality. The 
implementations for the events are provided by the client. For example, in order for the 
WebBrowser to fire an event, it defines the appropriate method in the 
<I>DWebBrowserEvents2</I> interface. This method is then implemented by the client. But the WebBrowser doesn't call 
these methods directly. In other words, the WebBrowser doesn't call the 
<I>DocumentComplete </I>method. Because <I>DWebBrowserEvents2 
</I>is a dispinterface, the WebBrowser calls these methods through the client's implementation of 
<I>IDispatch::Invoke. </I>As I<I> </I>mentioned earlier, when the WebBrowser calls the client's implementation of 
<I>Invoke</I>, the WebBrowser passes the DISPID of the event being fired.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Certain development tools such as Visual Basic, MFC, and ATL 
allow you to create methods that will be called for the WebBrowser events instead 
of forcing you to implement <I>Invoke</I> yourself, which can be quite cumbersome. 
These development tools provide the implementation of 
<I>Invoke </I>for you and then call methods based on the DISPID of the event that was fired.
</blockquote></div>
</p>

<p>Table 7-6 lists all the WebBrowser events. (These are the 
events for both the WebBrowser control and Internet Explorer, although some events 
apply only when automating Internet Explorer, as I'll explain shortly.) You can 
easily understand the purpose of most of these events by looking at the table, but I'll 
discuss a few events in more detail, in the order of their importance.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Some methods in Table 7-6 include the number 
<I>2</I> at the end of them. Although <I>DWebBrowserEvents2 
</I>doesn't derive from 
<I>DWebBrowserEvents</I>,<I> </I>the methods in 
<I>DWebBrowserEvents2 </I>whose names match those methods 
in <I>DWebBrowserEvents</I> were changed (by adding a 
<I>2</I>) to avoid confusion.
</blockquote></div>
</p>

<p>Note that several input parameters in Table 7-6 have values of either 
<I>VARIANT_
TRUE </I>or <I>VARIANT_FALSE</I>. If you write your application using Visual C++, be sure 
to compare against these values and not against 
<I>TRUE </I>or <I>FALSE</I>. If you write your application using Visual Basic, however, you can compare against the traditional 
<I>True </I>or <I>False </I>values. Visual Basic takes care of the conversion for you.</p>

<p>Now let's take a look at some of the events a bit more closely.</p>

<p><b>Table 7-6</b> <i>WebBrowser Events</i></p>

<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>Private Events</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top"><I>BeforeNavigate2 </I></td>
<td valign="top">Fired before navigation occurs. (This event is not 
fired when you refresh the page.)</td>
</tr>

<tr>
<td valign="top"><I>CommandStateChange </I></td>
<td valign="top">Fired when the enabled state of a command 
has changed. This event tells you when to enable or 
disable Back and Forward menu items or buttons.</td>
</tr>

<tr>
<td valign="top"><I>DocumentComplete </I></td>
<td valign="top">Fired when the entire document is finished loading. 
If you refresh the page, this event isn't fired.</td>
</tr>

<tr>
<td valign="top"><I>DownloadBegin </I></td>
<td valign="top">Fired when the download operation for an item has 
begun. This event is also fired when you refresh the 
page by using the Refresh button in Internet Explorer or 
by calling a refresh method such as <I>IWebBrowser2::Refresh.</i></td>
</tr>

<tr>
<td valign="top"><i>DownloadComplete</i></td>
<td valign="top">Fired when the download operation for an item 
has completed. This event is also fired when you 
refresh the page.</td>
</tr>

<tr>
<td valign="top"><I>NavigateComplete2 </I></td>
<td valign="top">Fired after navigation completes. This event 
corresponds to <I>BeforeNavigate2</I>.</td>
</tr>

<tr>
<td valign="top"><I>NewWindow2 </I></td>
<td valign="top">Fired just before a new window is created for 
displaying a Web page or any other resource.</td>
</tr>

<tr>
<td valign="top"><I>OnFullScreen </I></td>
<td valign="top">Fired when the 
<I>FullScreen</I> property has changed. This event takes one input parameter of type 
<I>VARIANT_
BOOL</I> that indicates whether Internet Explorer is 
in full-screen mode (<I>VARIANT_TRUE</I>) or in 
normal-screen mode (<I>VARIANT_FALSE</I>).</td>
</tr>

<tr>
<td valign="top"><I>OnMenuBar </I></td>
<td valign="top">Fired when the 
<I>MenuBar</I> property is changed. This event takes one input parameter of type 
<I>VARIANT_
BOOL</I> that indicates whether Internet Explorer's 
menu bar is visible (<I>VARIANT_TRUE</I>) or hidden 
(<I>VARIANT_
FALSE</I>).</td>
</tr>

<tr>
<td valign="top"><I>OnQuit </I></td>
<td valign="top">Fired when Internet Explorer is quitting. This event 
will be fired either when the user closes the browser 
or when you call the <I>Quit</I> method.</td>
</tr>

<tr>
<td valign="top"><I>OnStatusBar </I></td>
<td valign="top">Fired when the 
<I>StatusBar</I> property is changed. This event takes one input parameter of type 
<I>VARIANT_
BOOL</I> that indicates whether Internet Explorer's 
status bar is visible (<I>VARIANT_TRUE</I>) or hidden 
(<I>VARIANT_FALSE</I>).</td>
</tr>

<tr>
<td valign="top"><I>OnTheaterMode </I></td>
<td valign="top">Fired when the 
<I>TheaterMode</I> property is changed. This event takes one input parameter of type 
<I>VARIANT_
BOOL.</I> The value of this input parameter is <I>VARIANT_
TRUE </I>if Internet Explorer is in theater mode 
and <I>VARIANT_FALSE</I> otherwise.</td>
</tr>

<tr>
<td valign="top"><I>OnToolBar </I></td>
<td valign="top">Fired when the <I>ToolBar 
</I>property is changed. This means that the toolbar was either hidden or made 
visible. This event takes one input parameter of type 
<I>VARIANT_
BOOL</I> that indicates whether Internet Explorer's 
toolbar is visible (<I>VARIANT_TRUE</I>) or hidden 
(<I>VARIANT_FALSE</I>).</td>
</tr>

<tr>
<td valign="top"><I>OnVisible </I></td>
<td valign="top">Fired when the window for the WebBrowser should 
be shown or hidden. This event allows the container 
to act the same way as the Internet Explorer 
window. <I>OnVisible</I> has one input parameter that is of 
type <I>VARIANT_BOOL</I>. The value of the input parameter 
is <I>VARIANT_TRUE </I>if the WebBrowser is visible 
and <I>VARIANT_FALSE</I> otherwise.</td>
</tr>

<tr>
<td valign="top"><I>ProgressChange </I></td>
<td valign="top">Fired when the progress of a download has been 
updated. (This topic is discussed in more detail 
later in the chapter.)</td>
</tr>

<tr>
<td valign="top"><I>PropertyChange </I></td>
<td valign="top">Fired when a property has changed. Typically, the 
firing of this event indicates that the 
<I>PutProperty</I> method has been called to add or change the value of a property 
in the property bag.</td>
</tr>

<tr>
<td valign="top"><I>StatusTextChange </I></td>
<td valign="top">Fired by Internet Explorer and the WebBrowser 
control when the text of the status bar has 
changed even though the WebBrowser control doesn't have 
a status bar. <I>StatusTextChange</I> gives the client a 
chance to update its status bar with the new text.</td>
</tr>

<tr>
<td valign="top"><I>TitleChange </I></td>
<td valign="top">Fired when the title of the document becomes 
available or has changed.</td>
</tr>
</table>
</p>

<A NAME="192"><h2><I>BeforeNavigate2</I></h2></A>
<p><I>BeforeNavigate2</I> does just what it says. It is fired before Internet Explorer 
navigates to a Web page; therefore, it is fired when the user enters a URL, clicks the Back 
or Forward button, or performs an action that causes navigation to occur. 
<I>BeforeNavigate2</I> is also fired by the WebBrowser control if you call a navigation method of an 
instance of the control, such as <I>Navigate</I>, 
<I>Navigate2</I>, <I>GoHome</I>, or 
<I>GoSearch</I>. However, this event is not fired when you refresh the page. If frames are on a page, 
<I>BeforeNavigate2 </I>will be fired for each frame as well as for the top-level window. 
<I>BeforeNavigate2</I> has seven input parameters, which are described in Table 7-7.</p>

<p><b>Table 7-7</b> <i>Input Parameters of the </I>BeforeNavigate2 <I>Event</i></p>

<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>Parameter</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top"><I>pDisp </I></td>
<td valign="top">Address of the <I>IDispatch</I> interface of the top-level or 
frame WebBrowser object corresponding to the navigation.</td>
</tr>

<tr>
<td valign="top"><I>URL </I></td>
<td valign="top">URL to be navigated to.</td>
</tr>

<tr>
<td valign="top"><I>Flags </I></td>
<td valign="top">Reserved for future use.</td>
</tr>

<tr>
<td valign="top"><I>TargetFrameName </I></td>
<td valign="top">String that contains the name of the frame in which to 
display the resource or <I>NULL</I> if no named frame is targeted for 
the resource.</td>
</tr>

<tr>
<td valign="top"><I>PostData </I></td>
<td valign="top">Address of data to send to the server if the HTTP POST 
transaction is being used.</td>
</tr>

<tr>
<td valign="top"><I>Headers</I></td>
<td valign="top">Additional HTTP headers to send to the server (only 
HTTP URLs). The headers can specify the action required of 
the server, the type of data being passed to the server, a 
status code, and so on.</td>
</tr>

<tr>
<td valign="top"><I>Cancel </I></td>
<td valign="top">Address of a cancel flag. An application can set this 
parameter to <I>TRUE</I> to cancel the navigation operation or to 
<I>FALSE</I> to allow it to proceed.</td>
</tr>
</table>
</p>

<p>Notice that most of these parameters match those that you specify in a call 
to <I>Navigate </I>or <I>Navigate2</I>.<I> </I>If 
<I>BeforeNavigate2</I> was fired in response to a call to one of 
these navigation methods, the parameters that you specify are passed to 
the <I>BeforeNavigate2 </I>method.</p>

<p>In the handler function for this event, you can cancel the navigation by 
using the <I>Cancel </I>parameter, or you can modify it by using the 
<I>pDisp</I> parameter. To cancel the navigation, set the 
<I>Cancel</I> parameter to <I>VARIANT_TRUE</I>. If you want, you 
can modify the navigation information and then navigate to another location by using 
the <I>pDisp</I> parameter. For example, let's say we want to stop the current navigation, 
add some header information, and then navigate to the original URL with the added 
header information. In Visual Basic, we would use the following code to accomplish this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>Private Sub WebBrowser1_BeforeNavigate2(ByVal pDisp As Object, _
                                        URL As Variant, _
                                        Flags As Variant, _
                                        TargetFrameName As Variant, _
                                        PostData As Variant, _
                                        Headers As Variant, _
                                        Cancel As Boolean)

   If TypeName(pDisp) = &quot;WebBrowser&quot; And Headers = &quot;&quot; Then
      pDisp.Stop
      pDisp.Navigate URL, Flags, TargetFrameName, PostData, _
                     Headers + &quot;MyHeaders&quot;
      Cancel = True
   End If
End Sub
</PRE>
</td></tr></table></p>

<p>Note several important aspects of this code. First you must check the type 
of <I>pDisp</I> to make sure it is equal to 
<I>WebBrowser</I> because the 
<I>BeforeNavigate2</I> event is fired for all frames that might exist on a Web page. When a page contains 
frames, <I>pDisp</I> might not be a WebBrowser object and therefore any navigation attempt 
will cause an error.</p>

<p>Second you must check to make sure that the 
<I>Headers</I> parameter is empty to prevent an infinite loop. Remember that 
<I>BeforeNavigate2</I> is fired each time 
navigation occurs. So if you call <I>Navigate </I>in the event handler for the 
<I>BeforeNavigate2 </I>event, another <I>BeforeNavigate2 
</I>will be fired. In the preceding code, calling 
<I>Navigate</I> only if the <I>Headers</I> parameter is empty prevents an infinite loop. If the 
<I>Headers</I> parameter is empty, <I>Navigate</I> is called with a nonempty 
<I>Headers</I> parameter. The next time 
<I>BeforeNavigate2</I> is fired, the 
<I>Headers</I> parameter won't be empty; therefore, we 
don't call <I>Navigate</I> again, preventing an infinite loop.</p>

<p>Third you must call the <I>Stop</I> method for 
<I>pDisp</I>. If you don't, the &quot;about:NavigationCanceled&quot; Web page might be displayed after the navigation is first 
canceled.</p>

<A NAME="193"><h2><I>CommandStateChange</I></h2></A>
<p><I>CommandStateChange </I>is fired when Internet Explorer wants to notify an 
application that the enabled state of a WebBrowser command has changed. Use this event 
to determine when to enable or disable the Forward and Back menu items and buttons.</p>

<p>The <I>CommandStateChange</I> event's two input parameters, 
<I>Command</I> and <I>Enable,</I> warrant special consideration. The 
<I>Command</I> input parameter is the identifier of 
the command whose enabled state has changed. Two commands for the Forward 
and Back menu items and 
buttons&#8212;<I>CSC_NAVIGATEFORWARD</I> and 
<I>CSC_NAVIGATEBACK</I>, respectively&#8212;are of particular interest. (These commands are members of 
the <I>CommandStateChangeConstants </I>enumeration, which is defined in the 
ExDisp.h header file.) Each time a navigation occurs, the 
<I>CommandStateChange</I> event is fired to tell you whether the Forward or Back menu items and buttons should be 
enabled or disabled. For example, if no Web pages exist after the current one, the 
<I>Command</I> parameter will be equal to 
<I>CSC_NAVIGATEFORWARD</I>, and the <I>Enable</I> parameter 
will be equal to <I>VARIANT_FALSE</I>. (The <I>CommandStateChangeConstants 
</I>enumeration contains a third 
value&#8212;<I>CSC_UPDATECOMMANDS</I>&#8212;that specifies that the 
enabled state of a toolbar button might have changed. Typically, you will not be 
concerned with this value.)</p>

<p>The second parameter of special interest, 
<I>Enable</I>, is <I>VARIANT_TRUE</I> if the command is enabled or 
<I>VARIANT_FALSE</I> if the command is disabled.</p>

<p>To show you how to use <I>CommandStateChange </I>to enable Forward and 
Back menu items and buttons, let's update the MfcWebHost example that we created 
in <A HREF="ch06a.htm">Chapter 6</A>. Because this example doesn't have Forward or Back buttons, we'll 
update the menu items for these commands. The Forward and Back menu items in 
the MfcWebHost<I> </I>example are named Go 
Forward<I> </I>and Go Back, respectively. Adding buttons to the toolbar is fairly easy, so I'll leave this as an exercise for you to do 
on your own.</p>

<p>To handle the events in MfcWebHost, you must first enable the event 
sink because MfcWebHost doesn't currently sink events for the WebBrowser control. 
Be sure to include the ExDispID.h<I> </I>header file in MfcWebHost.cpp. Declare and 
initialize the event sink to handle the <I>CommandStateChange 
</I>event:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>// Event sink map declaration for WebBrowser 
// control events. This declaration goes in the
// header file for CMfcWebHostView _ MfcWebHostView.h.
//
DECLARE_EVENTSINK_MAP()

// Initialize the event sink map and handle the 
// CommandStateChange event.
BEGIN_EVENTSINK_MAP(CMfcWebHostView, CView)
   ON_EVENT(CMFCIEEvtSpyDlg, IDC_WEBBROWSER, DISPID_COMMANDSTATECHANGE,
            OnCommandStateChange, VTS_I4 VTS_BOOL)
END_EVENTSINK_MAP()
</PRE>
</td></tr></table></p>

<p>One important change you need to make to the original example is to 
change the call to the <I>Create</I> method of the WebBrowser control. The second parameter 
in the ON_EVENT macro indicates the ID of the WebBrowser control you're hosting. 
The original call to <I>Create</I> specified 
<I>NULL</I> for the ID of the WebBrowser. You must 
declare an ID for the WebBrowser control and change 
<I>Create</I> to specify that this ID is to be used for the WebBrowser control. If you don't, event sinking won't work correctly.</p>

<p>You can define the ID of the WebBrowser control you're hosting in any file 
in your project. (A good place to do so might be the resource.h header file for 
the MfcWebHost project.) When defining the ID for the WebBrowser control, go to 
the resource.h header file and pick a number that is far greater than any of the 
numbers you are using for resources in your project. For example, the largest number in 
the resource.h header file for MfcWebHost is 
<I>32,779</I>, so you could define the ID for the WebBrowser control like this:

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>#define IDC_WEBBROWSER  35000
</PRE>
</td></tr></table></p>

<p>The number <I>35,000</I> is much higher than the largest ID in resource.h, thus 
ensuring that the ID numbers won't conflict if you add more resources using 
ClassWizard. Now change the call to <I>Create</I> to use this ID:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>if (!m_webBrowser.Create(NULL, WS_CHILD|WS_VISIBLE,
                         CRect(), this, IDC_WEBBROWSER))
{
   return -1;
}
</PRE>
</td></tr></table></p>

<p>Next declare the <I>OnCommandStateChange</I> method that will be called when 
the WebBrowser control fires the <I>CommandStateChange 
</I>event. In the class declaration for the <I>CMfcWebHostView 
</I>class, declare <I>OnCommandStateChange</I>:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>void OnCommandStateChange(long lCommand, BOOL bEnable);
</PRE>
</td></tr></table></p>

<p>In the implementation for the <I>OnCommandStateChange 
</I>method, set data members that indicate whether the Go Forward or Go Back items of the 
Navigate<I> </I>menu (or both) should be enabled or disabled. These data members will be 
used for the <I>UPDATE_COMMAND_UI</I> handlers. Following is the implementation of 
the <I>OnCommandStateChange</I> method:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>void CMfcWebHostView::OnCommandStateChange(long lCommand, BOOL bEnable)
{
   switch(lCommand)
   {
      // Forward command
      //

      case CSC_NAVIGATEFORWARD:
         m_fForwardEnabled = bEnable;
         break;

      // Back command
      //
      case CSC_NAVIGATEBACK:
         m_fBackEnabled = bEnable;
         break;

      default:
         break;
   }
}
</PRE>
</td></tr></table></p>

<p>Declare the <I>m_fForwardEnabled</I> and 
<I>m_fBackEnabled</I> data members as protected members of the 
<I>CMfcWebHostView </I>class. These data members are of type 
<I>BOOL</I>. Also initialize these data members to 
<I>TRUE</I> in the constructor for the 
<I>CMfcWebHostView </I>class.</p>

<p>Now when the <I>UPDATE_COMMAND_UI </I>handlers for the Go Forward and 
Go Back menu items are called, you can enable or disable the appropriate menu 
item accordingly. Here's the implementation of the 
<I>UPDATE_COMMAND_UI </I>message handlers for the Go Forward and Go Back menu items:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>void CMfcWebHostView::OnUpdateNavigateGoForward(CCmdUI* pCmdUI) 
{
   pCmdUI-&gt;Enable(m_fForwardEnabled);
}

void CMfcWebHostView::OnUpdateNavigateGoBack(CCmdUI* pCmdUI) 
{
   pCmdUI-&gt;Enable(m_fBackEnabled);
}
</PRE>
</td></tr></table></p>

<A NAME="194"><h2><I>DocumentComplete</I></h2></A>
<p>Internet Explorer fires <I>DocumentComplete</I> when a document is completely 
finished loading. Only after this event is fired can the document object be safely used. 
The document object in the case of a Web page with no frames is the 
<I>IHTMLDocument2 </I>object, which I'll discuss in the <a href="ch08a.htm">next chapter</a>. When the document is ready to be 
used, it has reached the 
<I>READYSTATE_COMPLETE</I> state.</p>

<p>Note the following important points about the 
<I>DocumentComplete</I> event:</p>
<UL>
<p><li> In the case of a page with no frames, 
<I>DocumentComplete</I> is fired once after everything is done.</li></p>
<p><li> In the case of a page with multiple frames, 
<I>DocumentComplete</I> is fired multiple times. Not every frame will fire this event, but each frame that 
fires a <I>DownloadBegin</I> event fires a corresponding 
<I>DocumentComplete</I> event.</li></p>
<p><li> The <I>DocumentComplete</I> event has a pointer to an 
<I>IDispatch</I> parameter, which is the <I>IDispatch 
</I>of the window for which 
<I>DocumentComplete</I> is fired. This window can be the window contained in a frame as well.</li></p>
<p><li> The top-level frame fires the 
<I>DocumentComplete</I> event after all subframes have fired this event. Therefore, to see whether a page is through 
downloading, you need to obtain a pointer to the 
<I>IUnknown</I> interface of the <I>IDispatch</I> parameter sent to the event handler for the 
<I>DocumentComplete</I> event. Next, compare that pointer to the 
<I>IUnknown </I>interface with the pointer to the 
<I>IUnknown </I>interface of the WebBrowser control that you 
are hosting or the instance of Internet Explorer you are automating. If 
these two pointers are the same, the document is completely finished 
loading. This means that all HTML, images, controls, and so on for the 
top-level frame and all subframes are finished downloading.</li></p>
</ul>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
It is not sufficient to compare the pointer to the 
<I>IDispatch </I>of the WebBrowser control you are hosting to the pointer that is passed into the 
event handler for the <I>DocumentComplete</I> event. According to the rules of COM, 
the pointer to <I>IUnknown</I> is the only interface pointer whose value won't change 
if the object that the pointer refers to remains unchanged. For example, an 
object might change the pointer to its 
<I>IDispatch</I> if the <I>IDispatch </I>of the object is 
implemented as a tear-off interface. For more information about tear-off 
interfaces, refer to MSDN or one of the many COM books offered by Microsoft Press.
</blockquote></div>
</p>

<p>Implementing the fourth point in the preceding list in a Visual Basic 
application that is hosting the WebBrowser control is easy. Just check to see whether the 
<I>pDisp</I> parameter sent to the event handler for the 
<I>DocumentComplete </I>event is a WebBrowser object. Visual Basic will take care of checking the pointers to 
<I>IUnknown</I> of these objects to make sure they refer to the same object. Here is the code to 
implement this comparison in Visual Basic:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>Private Sub WebBrowser1_DocumentComplete(ByVal pDisp As Object,
                                         URL As Variant)
   If (pDisp Is WebBrowser1.Object) Then
      MsgBox &quot;The document is finished loading.&quot;
   End If
End Sub
</PRE>
</td></tr></table></p>

<p>Implementing the fourth point in a Visual C++ application is a little more 
difficult, but you can do it! Let's update MfcWebHost to handle the 
<I>DocumentComplete </I>event and display a message when the document is completely finished loading. 
First add an entry for the <I>DocumentComplete</I> event to the event sink map:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>ON_EVENT(CMfcWebHostView, IDC_WEBBROWSER, DISPID_DOCUMENTCOMPLETE,
         OnDocumentComplete, VTS_DISPATCH VTS_PVARIANT)
</PRE>
</td></tr></table></p>

<p>Next declare the <I>OnDocumentComplete</I> method in the class declaration of 
the <I>CMfcWebHostView</I> class:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>void OnDocumentComplete(LPDISPATCH lpDispatch, VARIANT FAR* URL);
</PRE>
</td></tr></table></p>

<p>Finally, implement the <I>OnDocumentComplete 
</I>method to determine whether the page is finished loading. In the code below, we retrieve the pointer 
to the <I>IUnknown </I>of the WebBrowser control we are hosting. (Note that we can't 
simply use the pointer to the <I>IUnknown</I> that is returned from a call to the 
<I>GetControlUnknown </I>method<I>. </I>The pointer to the 
<I>IUnknown </I>returned from 
<I>GetControlUnknown</I> is not actually the pointer to the 
<I>IUnknown </I>of the WebBrowser control being hosted. 
What is returned is actually a pointer to the <I>IOleObject 
</I>interface.) Next, we retrieve the pointer to the 
<I>IUnknown </I>of the object that fired the <I>DocumentComplete 
</I>event by calling <I>QueryInterface </I>using the 
<I>IDispatch </I>parameter that is sent to the 
<I>OnDocumentComplete </I>method. If the two pointers to the 
<I>IUnknown </I>interface are the same, the page 
is completely finished loading.</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>void CMfcWebHostView::OnDocumentComplete(LPDISPATCH lpDispatch,
                                         VARIANT FAR* URL)
{
   HRESULT   hr;
   LPUNKNOWN lpUnknown;
   LPUNKNOWN lpUnknownWB = NULL;
   LPUNKNOWN lpUnknownDC = NULL;

   lpUnknown = m_webBrowser.GetControlUnknown();
   ASSERT(lpUnknown);

   if (lpUnknown)
   {
      // Get the pointer to the IUnknown interface of the WebBrowser 
      // control being hosted. The pointer to the IUnknown returned from 
      // GetControlUnknown is not the pointer to the IUnknown of the 
      // WebBrowser control. It's actually a pointer to the IOleObject.
      // 
      hr = lpUnknown-&gt;QueryInterface(IID_IUnknown,
                                     (LPVOID*)&amp;lpUnknownWB);

      ASSERT(SUCCEEDED(hr));

      if (FAILED(hr))
         return;

      // Get the pointer to the IUnknown of the object that fired this 
      // event.
      //
      hr = lpDispatch-&gt;QueryInterface(IID_IUnknown, 
                                      (LPVOID*)&amp;lpUnknownDC);

      ASSERT(SUCCEEDED(hr));

      if (SUCCEEDED(hr) &amp;&amp; lpUnknownWB == lpUnknownDC)
      {
         // The document has finished loading.
         //
         MessageBox(&quot;The document has finished loading.&quot;);
      }

      if (lpUnknownWB)
         lpUnknownWB-&gt;Release();

      if (lpUnknownDC)
         lpUnknownDC-&gt;Release();
   }
}
</PRE>
</td></tr></table></p>

<p>One thing to note from the previous code is that we never release the 
pointer to the <I>IUnknown</I> interface returned from 
<I>GetControlUnknown</I> because this <I>IUnknown 
</I>pointer isn't <I>AddRef</I>'ed in the 
<I>GetControlUnknown</I> method. The 
<I>GetControlUnknown</I> method merely returns a pointer to an 
<I>IOleObject</I> data member that is maintained 
by the control site class&#8212;<I>CControlSite</I>. If you release this pointer to the 
<I>IUnknown </I>interface, and you shut down the application, an access violation will occur because 
MFC will try to release the pointer to the <I>IUnknown 
</I>interface one more time after the object has been deleted.</p>

<A NAME="195"><h2><I>DownloadBegin</I></h2></A>

<p>The <I>DownloadBegin</I> event notifies an application that a navigation operation 
is beginning. This event is fired shortly after the 
<I>BeforeNavigate2 </I>event in a typical navigation scenario, unless the navigation is canceled in the event handler for 
the <I>BeforeNavigate2</I> event. Any animation or busy indicator that the container needs 
to display should be connected to 
<I>DownloadBegin</I>. Each <I>DownloadBegin</I> event has 
a corresponding <I>DownloadComplete</I> event. In the case of a page 
refresh, <I>DownloadBegin </I>and <I>DownloadComplete 
</I>are the only navigation events that are fired.</p>

<A NAME="196"><h2><I>DownloadComplete</I></h2></A>
<p><I>DownloadComplete</I> occurs when a navigation operation finishes, is halted, or 
fails. Unlike <I>NavigateComplete2</I>, which is fired only when a URL is successfully 
navigated to, <I>DownloadComplete </I>is always fired after navigation starts. Any animation or 
busy indicator that was started in the event handler for 
<I>DownloadBegin </I>should be stopped in the event handler for 
<I>DownloadComplete</I>.</p>

<A NAME="197"><h2><I>NavigateComplete2</I></h2></A>
<p>The <I>NavigateComplete2</I> event is fired after navigation to a hyperlink is completed 
for either a window or a frameset element. The firing of this event is the first 
indication that the document is ready. After this event fires, you can access the document 
via the <I>Document</I> property without receiving an error. But just because you can 
access the document doesn't mean you can do so safely. You can access elements in 
the document safely only after the <I>DocumentComplete 
</I>event is fired.</p>

<p>You'll typically handle the 
<I>NavigateComplete2</I> event as soon as you can 
when you need to access the <I>document</I> object but not necessarily the elements within 
the document, such as when hooking advanced hosting interfaces into the 
document. (<A HREF="ch09a.htm">Chapter 9</A> covers advanced hosting interfaces in detail.) The 
<I>NavigateComplete2</I> event has two parameters&#8212;the 
<I>IDispatch </I>of the object that fired the event and the URL 
that was navigated to.</p>

<A NAME="198"><h2><I>NewWindow2</I></h2></A>
<p>The <I>NewWindow2</I> event is fired when a user wants to create a new window 
for displaying a resource. This event precedes the creation of a new window from 
within the WebBrowser (for example, in response to navigation targeted to a new 
window or to a scripted <I>window</I>.<I>open </I>method).</p>

<p><I>NewWindow2</I> is also fired when the <I>Navigate 
</I>or <I>Navigate2 </I>methods are called and the 
<I>navOpenInNewWindow</I> flag is specified. The 
<I>NewWindow2</I> event isn't fired when the user chooses New Window from the 
File<I> </I>menu because the Internet Explorer frame implements the menus. (The Internet Explorer frame isn't an HTML frame; 
it's the frame window.) Therefore, the 
<I>WebBrowser</I> object doesn't know when this 
new window has been opened. Because <I>NewWindow2 
</I>is sometimes hard to use, let's check out its two parameters: 
<I>ppDisp </I>and <I>Cancel.</I></p>

<p>The <I>ppDisp</I> parameter is the address of an interface pointer that, 
optionally, receives the <I>IDispatch</I> interface pointer of a new 
<I>WebBrowser</I> or <I>InternetExplorer</I> object, enabling you to either create a new instance of Internet Explorer that you 
can control from within your navigation or use your application for the new window. 
This instance is a new, hidden, nonnavigated 
<I>WebBrowser</I> or <I>InternetExplorer</I> object. 
Upon return from the event handler for NewWindow2, the 
<I>InternetExplorer</I> object that fired the 
<I>NewWindow2</I> event will configure and navigate the new object to the 
target location.</p>

<p>The other parameter, <I>Cancel</I>, is the address of a cancel flag. An application 
can set this parameter to <I>TRUE</I> to cancel the navigation operation or set it to 
<I>FALSE</I> to allow the new window operation to proceed. Setting 
<I>Cancel</I> to <I>TRUE</I> completely cancels the new window creation and the navigation.</p>

<p>If you do nothing in the event handler for 
<I>NewWindow2</I>, a new <I>InternetExplorer</I> object will automatically be created for you to handle the navigation. One 
reason you might want to handle <I>NewWindow2</I> is to control the creation of the 
new <I>InternetExplorer</I> object. Why? Because you might want to limit the number of 
instances of Internet Explorer, or perhaps you want to handle events from any new instance 
of Internet Explorer.</p>

<p>The following code handles the <I>NewWindow2</I> event; creates a new, 
hidden, nonnavigated instance of Internet Explorer; and sets the 
<I>ppDisp</I> parameter equal to the new instance. You can add the necessary code for sinking the events of this 
new instance of Internet Explorer if you want to.</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>void CMyEvtSink::NewWindow2(LPDISPATCH* ppDisp, BOOL* Cancel)
{
   // Note that m_pIE is a class member of type IWebBrowser2*.
   HRESULT hr = CoCreateInstance(CLSID_InternetExplorer, NULL, 
                                 CLSCTX_LOCAL_SERVER, IID_IWebBrowser2, 
                                 (void**)&amp;m_pIE);
   if (hr == S_OK)
      *ppDisp = (IDispatch*)pIE;

   // Do not set Cancel to TRUE. If you do,
   // the navigation will be completely canceled.
}
</PRE>
</td></tr></table></p>

<p>Another reason to handle the <I>NewWindow2</I> event is that you might want 
your application to be used for the new window when the user chooses to open a 
URL in a new window. If you don't handle the <I>NewWindow2 
</I>event so that your application is used for the new window, a new instance of Internet Explorer will be 
created in response to the new window request.</p>

<p>You can easily add this functionality so that your application is used for the 
new window to the VbWebHost<I> </I>example from the <a href="ch06a.htm">last chapter</a>. (The entire code for 
the updated example can be found on the companion CD in the folder \Samples
\Chap07\VbWebHostEvt.) Choose <I>WebBrowser1</I> from the Object drop-down list 
in the upper left-hand corner of the code window. Choose 
<I>NewWindow2</I> from the Procedure drop-down list in the upper right-hand corner of the code window. 
Then implement the <I>NewWindow2</I> event by using the following code:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>Private Sub WebBrowser1_NewWindow2(ppDisp As Object, Cancel As Boolean)
   Dim frmWB As Form1
   Set frmWB = New Form1

   Set ppDisp = frmWB.WebBrowser1.Object
   frmWB.Visible = True

   Set frmWB = Nothing
End Sub
</PRE>
</td></tr></table></p>

<p>In the handler for the <I>NewWindow2 </I>event, when a new window needs to 
be created, we create a new copy of <I>Form1</I>. This form, rather than a new instance 
of Internet Explorer, will be used for the navigation. It is very easy to add this 
functionality to the MfcWebHost sample. (The entire code for this revised example 
can be found on the companion CD in the folder 
\Samples\Chap07\MfcWebHostEvt.) First you must add an entry for the 
<I>NewWindow2</I> event in the event sink map for the view class. (Don't forget to include ExDispID.h in the MfcWebHostView.cpp 
implementation file, which is needed to resolve 
<I>DISPID_NEWWINDOW2</I>.)</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>ON_EVENT(CMfcWebHostView, IDC_WEBBROWSER, DISPID_NEWWINDOW2,
         OnNewWindow2, VTS_PDISPATCH VTS_PBOOL)
</PRE>
</td></tr></table></p>

<p>Next declare the <I>OnNewWindow2</I> method in the class declaration 
for <I>CMfcWebHostView</I>:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>void OnNewWindow2(LPDISPATCH* ppDisp, BOOL* Cancel);
</PRE>
</td></tr></table></p>

<p>Finally, implement the <I>OnNewWindow2</I> method to create a new instance of 
the MfcWebHost window when a new window is requested, as shown here:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>void CMfcWebHostView::OnNewWindow2(LPDISPATCH FAR* ppDisp,
                                   BOOL FAR* Cancel)
{
   // Ensure that ppDisp is not NULL.
   // If it is NULL, you probably specified
   // VT_DISPATCH for the first parameter in 
   // the ON_EVENT macro for NewWindow2 in 
   // the event sink map. The correct parameter
   // type is VT_PDISPATCH.
   //
   ASSERT(ppDisp);
   if (!ppDisp)
      return;

   // Get a pointer to the application object
   // for this application.
   //
   CWinApp* pApp = AfxGetApp();

   // Get the correct document template.
   //
   CDocTemplate* pDocTemplate;
   POSITION pos = pApp-&gt;GetFirstDocTemplatePosition();
   pDocTemplate = pApp-&gt;GetNextDocTemplate(pos);

   ASSERT(pDocTemplate);

   // Create the new frame.
   CFrameWnd* pNewFrame = pDocTemplate-&gt;CreateNewFrame(GetDocument(),
                                            (CFrameWnd*)AfxGetMainWnd());
   ASSERT(pNewFrame);

   // Activate the frame, and set its active view.
   //
   pDocTemplate-&gt;InitialUpdateFrame(pNewFrame, NULL);

   CMfcWebHostView* pWbView = 
                    (CMfcWebHostView*)pNewFrame-&gt;GetActiveView();
   
   ASSERT(pWbView);

   *ppDisp = pWbView-&gt;m_webBrowser.GetApplication();
}
</PRE>
</td></tr></table></p>

<p>If you're hosting the WebBrowser control in an SDI or MDI application 
(the preceding code is an SDI application), implementing the 
<I>OnNewWindow2</I> method is complicated and involves knowing how to work with document templates. 
However, if you're hosting the WebBrowser control in a dialog-based application, it is 
a bit easier. Here's how to use your application for the new window if you're 
hosting the WebBrowser control in a dialog-based application:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>void CMyDlg::OnNewWindow2(LPDISPATCH FAR* ppDisp, BOOL FAR* Cancel) 
{
   m_dlgNewWB = new CMyDlg;
   m_dlgNewWB-&gt;Create(IDD_MYDLG_DIALOG);

   *ppDisp = m_dlgNewWB-&gt;m_webBrowser.GetApplication();
}
</PRE>
</td></tr></table></p>

<p>Remember to delete <I>m_dlgNewWB</I> when you're finished with the new 
dialog. And don't perform navigation in the <I>CMyDlg::OnInitDialog 
</I>method, because if you do, the code might not work. (Recall that 
<I>ppDisp</I> must point to a new, hidden, nonnavigated 
<I>WebBrowser</I> or <I>InternetExplorer</I> object.)</p>

<A NAME="199"><h2><I>ProgressChange</I></h2></A>
<p>The <I>ProgressChange</I> event notifies your application that the progress of a 
download operation has been updated. <I>ProgressChange 
</I>has two input parameters:</p>

<UL>
<p><li> <I>Progress.</I> Amount of total progress to show, or 
-1 when the progress is complete</li></p>
<p><li> <I>ProgressMax.</I> Maximum progress value</li></p>
</ul>

The container can use the information that the 
<I>ProgressChange</I> event provides to display the number of bytes downloaded so far or to update a progress 
indicator. To calculate the percentage of progress to show in a progress indicator, multiply 
the value of <I>Progress</I> by 100 and divide by the value of 
<I>ProgressMax</I>. If <I>Progress</I> is -1, the container can indicate that the operation is finished or hide the 
progress indicator.</p>

</BODY>
</HTML>





