<HTML>
<head>
<link rel="STYLESHEET" type="text/css" href="Progie5.css">
<TITLE>Handling DHTML Object Events</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch08d.htm">[Previous]</A> <A HREF="ch08f.htm">[Next]</A><P>

<A NAME="211"><H1>Handling DHTML Object Events</H1></A>

<P>Because you already know how to sink events when hosting the WebBrowser 
control or when automating Internet Explorer, sinking events for the objects in the 
DHTML Object Model should be a breeze. Almost every element on a Web page fires 
events. In fact, the DHTML Object Model fires far too many events to explain them all in 
this chapter. So instead of discussing every event that is fired, I'll just show you how 
to sink the events.</p>

<A NAME="212"><H2>Sinking Events for DHTML Objects in Visual Basic</H2></A>

<P>To see how easily you can sink events for HTML element objects in Visual 
Basic applications, let's update the VbObjMdl<I> 
</I>example to sink events for two of the objects in the object model&#8212;the 
<I>document</I> object and the Click Me button on 
the VbObjMdl.htm Web page. (All the example code to be mentioned in this section 
can be found on the companion CD in the folder \Samples\Chap08\VbObjMdl.)</p>

<P>Creating the event sink for the document involves two simple steps. The first 
step is to change the declaration of the<I> 
WebDoc</I> variable to include the 
<I>WithEvents</I> keyword:</p>

<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>Dim WithEvents WebDoc As HTMLDocument
</PRE>
</td></tr></table></p>

<P>As you learned in <A HREF="ch07a.htm">Chapter 7</A>, the <I>WithEvents 
</I>keyword tells Visual Basic that an object is able to sink events. The event sink is connected to the event source 
when you set <I>WebDoc</I> equal to the 
<I>document</I> object in the event handler for 
the <I>DocumentComplete</I> event.</p>

<P>The second step is to choose which event or events you want to handle 
from the Procedures drop-down list in the upper right-hand corner of the Visual Basic 
IDE. For this simple example, choose the 
<I>ondblclick</I> event of the <I>WebDoc</I>, which is 
fired whenever the user double-clicks anywhere in the document. When the 
<I>ondblclick</I> event is fired, a message box should appear that shows the user the coordinates 
of the document that was double-clicked. You can obtain these coordinates by 
using the <I>event </I>object. (Remember this object from way back in <A HREF="ch03a.htm">Chapter 3</A>?) Here's the 
code to implement the event handler for the 
<I>ondblclick</I> event:</p>

<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>Private Function WebDoc_ondblclick() As Boolean
   On Error Resume Next

   MsgBox &quot;X: &quot; &amp; WebDoc.parentWindow.event.clientX _
      &amp; &quot; Y: &quot; &amp; WebDoc.parentWindow.event.clientY
End Function
</PRE>
</td></tr></table></p>

<P>Notice that the code must use the 
<I>parentWindow</I> property of the 
<I>document</I> object to get the parent <I>window 
</I>object before accessing the <I>event </I>object. 
Remember that the <I>event</I> property of the <I>window 
</I>object is the one that provides access to the 
<I>event </I>object. The <I>event</I> object has two properties of interest in this event 
handler: <I>clientX </I>and <I>clientY</I>. These properties return the 
<I>x</I>-coordinate and the <I>y</I>-coordinate of the location of the mouse pointer when this event was fired. These coordinates 
are relative to the top of the client area of the window.</p>

<P>Sinking events for the Click Me button is a little more complicated. First 
you must declare a new variable of type 
<I>HTMLInputElement</I>. Don't forget to specify 
the <I>WithEvents</I> keyword:</p>

<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>Dim WithEvents btnClickMe As HTMLInputElement
</PRE>
</td></tr></table></p>

<P>Next, in the event handler for the <I>DocumentComplete 
</I>event, you must set the <I>btnClickMe </I>variable equal to the input element object for the Click Me button. 
This is where the event sink for the 
<I>btnClickMe</I> variable is connected to the event 
source. Here's how the <I>DocumentComplete</I> event handler for the 
<I>WebBrowser1</I> sets the <I>btnClickMe </I>variable:</p>

<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>Private Sub WebBrowser1_DocumentComplete(ByVal pDisp As Object, _
                                         URL As Variant)
   On Error Resume Next
   Set WebDoc = WebBrowser1.Document
    
   Set btnClickMe = WebDoc.Forms(0).Item(&quot;Btn1&quot;)
End Sub
</PRE>
</td></tr></table></p>

<P>Now all you have to do is choose which events you want to handle. For 
this simple example, just handle the 
<I>onclick</I> event and display a message box that 
tells the user that the button was clicked. The following code implements the event 
handler for the <I>onclick</I> event in your application:</p>

<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>Private Function btnClickMe_onclick() As Boolean
   MsgBox &quot;The Click Me Button was Clicked!!&quot;
End Function
</PRE>
</td></tr></table></p>

<A NAME="213"><H2>Sinking Events for DHTML Objects in Visual C++</H2></A>

<P>Sinking events for objects in the DHTML Object Model from your Visual C++ 
applications involves a little extra code, but it's really not that much trouble. In this 
section, we'll update the MfcObjMdl example to sink events for the 
<I>document</I> object. (To put your knowledge to the test, I'll let you update the example to sink 
events for the Click Me button and handle its 
<I>onclick</I> event on your own.)</p>
<p>To set up the event sink for the <I>document </I>object, you must first create an 
event sink class. (Remember the MfcIEEvtSpy example from <A HREF="ch07a.htm">Chapter 7</A>? This event 
sink class is similar to the <I>CIE5Events </I>class in the MfcIEEvtSpy example.) Create a 
new class named <I>CHTMLDocEvents</I>. Then add the code to set up the event sink, and 
create a handler method for the <I>ondblclick </I>event. (If you're a little rusty at event 
sinking, you might want to review the section in Chapter 7 titled &quot;<A HREF="ch07c.htm#188">Sinking Events in MFC</A>.&quot;)</p>
<p>Now I'll outline the changes you should make to the 
HTMLDocEvents.h  header file. First create a forward declaration for the 
<I>CMfcObjMdlDlg</I> class. You need this forward declaration so that you can create a data member to hold a pointer to 
the parent class that will be passed into the constructor. Here is the code for the 
forward declaration:</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>class CMfcObjMdlDlg;
</PRE>
</td></tr></table></p>
<P>Change the declaration of the constructor to accept a pointer to the parent 
class. This class is named <I>CHTMLDocEvents</I> and its parent class is 
<I>CMfcObjMdlDlg</I>.</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>CHTMLDocEvents(CMfcObjMdlDlg* pParent = NULL);
</PRE>
</td></tr></table></p>
<P>Add a protected data member to the class to hold the pointer to the parent 
class that is passed to the constructor.</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>protected:
   CMfcObjMdlDlg* m_pParent;
</PRE>
</td></tr></table></p>
<P>Now declare a method that will handle the <I>ondblclick 
</I>event.</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>   VARIANT_BOOL OnDblClick ();
</PRE>
</td></tr></table></p>
<P>Finally, declare the dispatch map that will be used to specify the events 
you want to handle and their associated event handlers.</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>   DECLARE_DISPATCH_MAP()
</PRE>
</td></tr></table></p>
<P>OK, we're finished making changes to the HTMLDocEvents.h header file. 
Next we have to make changes to the HTMLDocEvents.cpp implementation file. First 
include the MfcObjMdlDlg.h and mshtmdid.h header files in HTMLDocEvents.cpp. 
The mshtmdid.h header file defines the dispatch IDs that you will use when 
initializing the dispatch map.</p>
<P>Next change the constructor for the 
<I>CHTMLDocEvents</I> class to accept and store a pointer to the parent. You must also call 
<I>EnableAutomation</I>. This call will be needed by the parent class when the event sink is connected to the event source.</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>CHTMLDocEvents::CHTMLDocEvents(CMfcObjMdlDlg* pParent /* = NULL */)
   : m_pParent(pParent)
{
   EnableAutomation();  // Needed in order to sink events.
}
</PRE>
</td></tr></table></p>
<P>Now initialize the dispatch map, and specify the events you want to handle. 
The DISP_FUNCTION_ID macro specifies the event you want to handle and the 
method to call when this event is fired. In this case, you want the 
<I>OnDblClick </I>method to be called when the document fires the 
<I>ondblclick </I>event. The dispatch ID for the 
<I>ondblclick</I> event is 
<I>DISPID_HTMLDOCUMENTEVENTS_ONDBLCLICK</I>,<I> 
</I>which is defined in mshtmdid.h:</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>BEGIN_DISPATCH_MAP(CHTMLDocEvents, CCmdTarget)
   DISP_FUNCTION_ID(CHTMLDocEvents, &quot;ondblclick&quot;,
                    DISPID_HTMLDOCUMENTEVENTS_ONDBLCLICK,
                    OnDblClick, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()
</PRE>
</td></tr></table></p>
<P>Implement the <I>OnDblClick</I> event handler to obtain the 
<I>event</I> object, and display a message box to show the client coordinates of the mouse pointer when the 
<I>ondblclick </I>event was fired. The following code shows why you need a pointer to the 
parent object. This pointer gives you access to the HTML document pointer stored in 
the parent. (For this code to work correctly, you'll have to specify that 
<I>CHTMLDocEvents </I>is a friend of <I>CMfcObjMdlDlg 
</I>in the class declaration of 
<I>CMfcObjMdlDlg</I>.)</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>VARIANT_BOOL CHTMLDocEvents::OnDblClick()
{
   if (!m_pParent || !m_pParent-&gt;m_pHTMLDocument2)
      return VARIANT_TRUE;

   IHTMLWindow2* pParentWindow;
   IHTMLDocument2* pDocument = m_pParent-&gt;m_pHTMLDocument2;

   HRESULT hr = pDocument-&gt;get_parentWindow(&amp;pParentWindow);

   if (SUCCEEDED(hr))
   {
      IHTMLEventObj* pEvtObj;

      hr = pParentWindow-&gt;get_event(&amp;pEvtObj);
      pParentWindow-&gt;Release();

      if (SUCCEEDED(hr))
      {
         long clientX = 0L, clientY = 0L;

         pEvtObj-&gt;get_clientX(&amp;clientX);
         pEvtObj-&gt;get_clientY(&amp;clientY);
         pEvtObj-&gt;Release();

         CString strText;
         strText.Format(&quot;X: %ld Y: %ld&quot;, clientX, clientY);

         ::MessageBox(NULL, strText, _T(&quot;MfcObjMdl&quot;), MB_OK);
      }
   }

   return VARIANT_TRUE;
}
</PRE>
</td></tr></table></p>
<P>OK, now that we've finished changing the HTMLDocEvents.cpp 
implementation file, the last task is to make a few changes to 
<I>CMfcObjMdlDlg </I>to set up the event sink. Include the HTMLDocEvents.h header file in the MfcObjMdlDlg.h header 
file. And make the <I>CHTMLDocEvents </I>class a friend of the 
<I>CMfcObjMdlDlg </I>class by placing the following code within the class definition of 
<I>CMfcObjMdlDlg</I>:</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>   friend class CHTMLDocEvents;
</PRE>
</td></tr></table></p>
<P>Next declare a protected data member of type 
<I>CHTMLDocEvents</I>. This data member will be used when establishing the event sink. Also, declare a 
<I>DWORD</I> variable that will be used when disconnecting the event sink:</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>protected:
   CHTMLDocEvents* m_pHTMLDocEvents;
   DWORD m_dwCookie;
</PRE>
</td></tr></table></p>
<P>Now, in the constructor for 
<I>CMfcObjMdlDlg</I>, initialize the cookie data 
member and create a new instance of the <I>CHTMLDocEvents 
</I>class. The constructor should now look like this:</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>CMfcObjMdlDlg::CMfcObjMdlDlg(CWnd* pParent /*=NULL*/)
   : CDialog(CMfcObjMdlDlg::IDD, pParent),
     m_pHTMLDocument2(NULL),
     m_dwCookie(0L)
{
   //{{AFX_DATA_INIT(CMfcObjMdlDlg)
   m_strAddress = _T(&quot;&quot;);
   m_strNewText = _T(&quot;&quot;);
   //}}AFX_DATA_INIT
   // Note that LoadIcon does not require a subsequent DestroyIcon 
   // in Win32.
   m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);

   m_pHTMLDocEvents = new CHTMLDocEvents(this);
}
</PRE>
</td></tr></table></p>
<P>Now you're ready to connect the event sink to the document. In the 
<I>OnDocumentComplete</I> event handler, call 
<I>AfxConnectionAdvise</I> to connect the event sink. </p>
<p>This process is almost exactly the same as the process you used to set up the event 
sink when automating Internet Explorer in <A HREF="ch07a.htm">Chapter 7</A>. (Be sure to include the 
afxconv.h  header file in MfcObjMdlDlg.cpp. This header file is needed for the 
<I>AfxConnectionAdvise </I>function.)</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>      // Connect the event sink for the document.
      //
      AfxConnectionAdvise(m_pHTMLDocument2, 
                          DIID_HTMLDocumentEvents2,
                          m_pHTMLDocEvents-&gt;GetInterface(&amp;IID_IUnknown),
                          TRUE, &amp;m_dwCookie);
</PRE>
</td></tr></table></p>
<P>Because the document is destroyed when the user navigates to a new Web 
page or closes the application, disconnecting the event sink is recommended, although 
it isn't absolutely necessary. Disconnecting the event sink ensures that all interfaces 
are decremented and all objects are deleted cleanly. To disconnect the event sink, 
place a call to <I>AfxConnectionUnadvise </I>before the call to 
<I>AfxConnectionAdvise </I>in the event handler for 
<I>DocumentComplete. </I>You should disconnect the event sink only if it 
has been previously established. After adding the call to 
<I>AfxConnectionUnadvise</I>,  your <I>OnDocumentComplete 
</I>method should look like this:</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>void CMfcObjMdlDlg::OnDocumentComplete(LPDISPATCH pDisp, VARIANT FAR* URL) 
{
   LPDISPATCH lpDispatch;
   lpDispatch = m_webBrowser.GetDocument();

   if (lpDispatch)
   {
      HRESULT hr = lpDispatch-&gt;QueryInterface(IID_IHTMLDocument2,
                                              (LPVOID*)&amp;m_pHTMLDocument2);
      lpDispatch-&gt;Release();

      ASSERT(SUCCEEDED(hr));

      // Disconnect the event sink, if needed.
      //
      if (m_pHTMLDocEvents)
      {
         if (m_dwCookie)
         {
            AfxConnectionUnadvise(m_pHTMLDocument2, 
                                  DIID_HTMLDocumentEvents2,
                       m_pHTMLDocEvents-&gt;GetInterface(&amp;IID_IUnknown),
                                  TRUE, m_dwCookie);
            m_dwCookie = 0L;
         }
      }

      // Connect the event sink for the document.
      //
      AfxConnectionAdvise(m_pHTMLDocument2, 
                          DIID_HTMLDocumentEvents2,
                          m_pHTMLDocEvents-&gt;GetInterface(&amp;IID_IUnknown),
                          TRUE, &amp;m_dwCookie);
   }
}
</PRE>
</td></tr></table></p>
<P>To disconnect the event sink when the application is closed, override the 
<I>OnCancel </I>method of <I>CDialog </I>and call 
<I>AfxConnectionUnadvise</I>,  like this:</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>void CMfcObjMdlDlg::OnCancel() 
{
   if (m_pHTMLDocEvents)
   {
      // Disconnect the event sink. 
      //
      if (m_dwCookie)
      {
         AfxConnectionUnadvise(m_pHTMLDocument2, 
                               DIID_HTMLDocumentEvents2,
                    m_pHTMLDocEvents-&gt;GetInterface(&amp;IID_IUnknown),
                               TRUE, m_dwCookie);
      }
   }

   CDialog::OnCancel();
}
</PRE>
</td></tr></table></p>
<P>You also need to delete the pointer to 
<I>CHTMLDocEvents</I>. You can safely do this in the destructor for the 
<I>CMfcObjMdlDlg </I>class. After you add the code to 
delete this pointer, the destructor should look like the following:</p>
<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>CMfcObjMdlDlg::~CMfcObjMdlDlg()
{
   if (m_pHTMLDocument2)
      m_pHTMLDocument2-&gt;Release();

   delete m_pHTMLDocEvents;
}
</PRE>
</td></tr></table></p>
<P>Now compile and test your application. When a Web page is loaded, 
double-click in the WebBrowser window. A dialog box should appear that indicates 
the coordinates of the mouse pointer when this event was fired. Navigate to a new 
Web page, and try it again.</p>
<p>The examples in this section are pretty basic. Now that you know how to 
sink events in Visual Basic and Visual C++, the possibilities are endless. For example, 
you might want to sink events with the <I>form</I> object so that your application can 
validate data entered by the user before it's submitted to your server. You can perform 
hundreds of tasks with the events fired by the objects in the DHTML Object Model. 
You're bound only by the limits of your imagination.</p>

</BODY>
</HTML>






