<html>
<head>
<title>网络编程基础篇之PERL</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<link rel="stylesheet" href="ebook.css" type="text/css">
</head>
<body leftmargin="0" topmargin="0" background="bg.jpg">
<table width="100%" cellspacing="0">
  <tr>
    <td valign="top" bgcolor="#FFD26A" width="24%"> 
      <table width="180" height="100%">
        <tr align="center" valign="top">
          <td>
            <p><img src="image.jpg"></p>
            <p><a href="list.htm"><img src="bd.gif" border="0"></a><br>
              <a href="04.htm"><img src="ap.gif" border="0"></a></p>
          </td>
        </tr>
        <tr align="center" valign="bottom">
          <td><a href="06.htm"><img src="np.gif" border="0"></a></td>
        </tr>
      </table>
    </td>
    <td valign="top" width="76%"> 
      <blockquote>
        <div align="center"><img src="title.gif"></div>
        <!--正文开始-->
        <font color="#0000FF">文件读写 </font> 
        <p> <font color="#0000FF">一、打开、关闭文件 </font><br>
&nbsp;&nbsp;语法为open (filevar, filename)，其中filevar为文件句柄，或者说是程序中用来代表某文件的代号，filename为文件名，其路径可为相对路径，亦可为绝对路径。<br>
&nbsp;&nbsp;&nbsp;&nbsp;open(FILE1,"file1");<br>
&nbsp;&nbsp;&nbsp;&nbsp;open(FILE1,
"/u/jqpublic/file1");<br>
&nbsp;&nbsp;打开文件时必须决定访问模式，在PERL中有三种访问模式：读、写和添加。后两种模式的区别在于写模式将原文件覆盖，原有内容丢失，形式为：open(outfile,"&gt;outfile");而添加模式则在原文件的末尾处继续添加内容，形式为：open(appendfile,
"&gt;&gt;appendfile")。要注意的是，不能对文件同时进行读和写/添加操作。<br>
&nbsp;&nbsp;open的返回值用来确定打开文件的操作是否成功，当其成功时返回非零值，失败时返回零，因此可以如下判断：<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (open(MYFILE, "myfile")) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;# here's what to do if the file opened
successfully<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;当文件打开失败时结束程序：<br>
&nbsp;&nbsp;&nbsp;&nbsp;unless (open (MYFILE, "file1"))
{<br>
&nbsp;&nbsp;&nbsp;&nbsp;die ("cannot open input file
file1\n");<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
&nbsp;&nbsp;亦可用逻辑或操作符表示如下：<br>
&nbsp;&nbsp;&nbsp;&nbsp;open (MYFILE, "file1") || die
("Could not open file"); <br>
&nbsp;&nbsp;当文件操作完毕后，用close(MYFILE);
关闭文件。<br>
          <font color="#0000FF">二、读文件 </font><br>
&nbsp;&nbsp;语句$line = &lt;MYFILE&gt;;从文件中读取一行数据存储到简单变量$line中并把文件指针向后移动一行。&lt;STDIN&gt;为标准输入文件，通常为键盘输入，不需要打开。<br>
&nbsp;&nbsp;语句@array = &lt;MYFILE&gt;;把文件的全部内容读入数组@array，文件的每一行(含回车符)为@array的一个元素。<br>
          <font color="#0000FF">三、写文件</font> <br>
&nbsp;&nbsp;形式为：<br>
&nbsp;&nbsp;&nbsp;&nbsp;open(OUTFILE, "&gt;outfile");<br>
&nbsp;&nbsp;&nbsp;&nbsp;print OUTFILE ("Here is an output
line.\n");<br>
&nbsp;&nbsp;注：STDOUT、STDERR为标准输出和标准错误文件，通常为屏幕，且不需要打开。<br>
          <font color="#0000FF">四、判断文件状态 </font><br>
1、文件测试操作符<br>
&nbsp;&nbsp;语法为：-op expr，如：<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (-e "/path/file1") {<br>
&nbsp;&nbsp;&nbsp;&nbsp;print STDERR ("File file1
exists.\n");<br>
&nbsp;&nbsp;&nbsp;&nbsp;}<br>
</p>

<p align="center"> 文件测试操作符 </p>
<div align="center"><center>

            <table border="1" width="512">
              <tr>
                <td valign="top" width="106"> <i>操作符</i></td>
                <td valign="top"> <i>描述</i></td>
    </tr>
    <tr>
                <td valign="top" width="106"> -b</td>
                <td valign="top"> 是否为块设备</td>
    </tr>
    <tr>
                <td valign="top" width="106"> -c </td>
                <td valign="top"> 是否为字符设备 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -d </td>
                <td valign="top"> 是否为目录 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -e </td>
                <td valign="top"> 是否存在 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -f </td>
                <td valign="top"> 是否为普通文件 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -g </td>
                <td valign="top"> 是否设置了setgid位 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -k </td>
                <td valign="top"> 是否设置了sticky位 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -l </td>
                <td valign="top"> 是否为符号链接 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -o </td>
                <td valign="top"> 是否拥有该文件 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -p </td>
                <td valign="top"> 是否为管道 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -r </td>
                <td valign="top"> 是否可读 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -s </td>
                <td valign="top"> 是否非空 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -t </td>
                <td valign="top"> 是否表示终端 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -u </td>
                <td valign="top"> 是否设置了setuid位 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -w </td>
                <td valign="top"> 是否可写 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -x </td>
                <td valign="top"> 是否可执行 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -z </td>
                <td valign="top"> 是否为空文件 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -A </td>
                <td valign="top"> 距上次访问多长时间 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -B </td>
                <td valign="top"> 是否为二进制文件 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -C </td>
                <td valign="top"> 距上次访问文件的inode多长时间 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -M </td>
                <td valign="top"> 距上次修改多长时间 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -O </td>
                <td valign="top"> 是否只为“真正的用户”所拥有 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -R </td>
                <td valign="top"> 是否只有“真正的用户”可读 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -S </td>
                <td valign="top"> 是否为socket </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -T </td>
                <td valign="top"> 是否为文本文件 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -W </td>
                <td valign="top"> 是否只有"真正的用户"可写 </td>
    </tr>
    <tr>
                <td valign="top" width="106"> -X </td>
                <td valign="top"> 是否只有"真正的用户"可执行 </td>
    </tr>
    <tr>
        <td colspan="2"> 注：“真正的用户”指登录时指定的userid，与当前进程用户ID相对，命令suid可以改变有效用户ID。</td>
    </tr>
</table>
</center></div>

        <p> &nbsp;&nbsp;例：<br>
          &nbsp;&nbsp;&nbsp;&nbsp;unless (open(INFILE, "infile")) {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;die ("Input file infile cannot be opened.\n");<br>
          &nbsp;&nbsp;&nbsp;&nbsp;}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;if (-e "outfile") {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;die ("Output file outfile already exists.\n");<br>
          &nbsp;&nbsp;&nbsp;&nbsp;}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;unless (open(OUTFILE, "&gt;outfile")) 
          {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;die ("Output file outfile cannot be opened.\n");<br>
          &nbsp;&nbsp;&nbsp;&nbsp;}<br>
          &nbsp;&nbsp;等价于<br>
          &nbsp;&nbsp;&nbsp;&nbsp;open(INFILE, "infile") &amp;&amp; 
          !(-e "outfile") &amp;&amp;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;open(OUTFILE, "&gt;outfile") || die("Cannot 
          open files\n");<br>
          <font color="#0000FF">五、命令行参数 </font><br>
          &nbsp;&nbsp;象C一样，PERL也有存储命令行参数的数组@ARGV，可以用来分别处理各个命令行参数；与C不同的是，$ARGV[0]是第一个参数，而不是程序名本身。<br>
          &nbsp;&nbsp;&nbsp;&nbsp;$var = $ARGV[0]; # 第一个参数<br>
          &nbsp;&nbsp;&nbsp;&nbsp;$numargs = @ARGV; # 参数的个数<br>
          &nbsp;&nbsp;PERL中，&lt;&gt;操作符实际上是对数组@ARGV的隐含的引用，其工作原理为：<br>
          1、当PERL解释器第一次看到&lt;&gt;时，打开以$ARGV[0]为文件名的文件；<br>
          2、执行动作shift(@ARGV); 即把数组@ARGV的元素向前移动一个，其元素数量即减少了一个。<br>
          3、&lt;&gt;操作符读取在第一步打开的文件中的所有行。<br>
          4、读完后，解释器回到第一步重复。<br>
          &nbsp;&nbsp;例：<br>
          &nbsp;&nbsp;&nbsp;&nbsp;@ARGV = ("myfile1", "myfile2"); 
          #实际上由命令行参数赋值<br>
          &nbsp;&nbsp;&nbsp;&nbsp;while ($line = &lt;&gt;) {<br>
          &nbsp;&nbsp;&nbsp;&nbsp;print ($line);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;} <br>
          &nbsp;&nbsp;将把文件myfile1和myfile2的内容打印出来。<br>
          <font color="#0000FF">六、打开管道 </font><br>
          &nbsp;&nbsp;用程序的形式也可以象命令行一样打开和使用管道(ex:ls &gt; tempfile)。如语句open (MYPIPE, 
          "| cat &gt;hello"); 打开一个管道，发送到MYPIPE的输出成为命令"cat &gt;hello"的输入。由于cat命令将显示输入文件的内容，故该语句等价于open(MYPIPE, 
          "&gt;hello"); 用管道发送邮件如下：<br>
          &nbsp;&nbsp;&nbsp;&nbsp;open (MESSAGE, "| mail dave");<br>
          &nbsp;&nbsp;&nbsp;&nbsp;print MESSAGE ("Hi, Dave! Your Perl program 
          sent this!\n");<br>
          &nbsp;&nbsp;&nbsp;&nbsp;close (MESSAGE);<br>
          <br>
          <!--正文结束-->
        <center>
      <hr>
      <p>本书由<a href="http://www.huiniao.com/">【灰鸟资讯】</a>免费制作<br>
          想要更多的免费电子图书，请光临<br>
            <a href="http://www.huiniao.com">http://www.huiniao.com</a></p>
      </center>
      </blockquote>
    </td>
  </tr>
</table>
</body>
</html>
