<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>如何在程序中动态取得Win95/98的网络邻居中的工作组及计算机名</title>
</head>

<body bgcolor="#FFFFFF" text="#000000">

<p>[本文不能保证绝对正确, 仅供参考]<br>
<br>
如何在程序中动态取得Win95/98的网络邻居中的工作组及计算机名?可参考下面代码，或许有所帮助：<br>
<br>
procedure GetDomainList(TV:TTreeView);<br>
var<br>
a : Integer;<br>
ErrCode : Integer;<br>
NetRes : Array[0..1023] of TNetResource;<br>
EnumHandle : THandle;<br>
EnumEntries : DWord;<br>
BufferSize : DWord;<br>
s : string;<br>
itm : TTreeNode;<br>
begin<br>
{ Start here }<br>
try<br>
With NetRes[0] do begin<br>
dwScope :=RESOURCE_GLOBALNET;<br>
dwType :=RESOURCETYPE_ANY;<br>
dwDisplayType :=RESOURCEDISPLAYTYPE_DOMAIN;<br>
dwUsage :=RESOURCEUSAGE_CONTAINER;<br>
lpLocalName :=NIL;<br>
lpRemoteName :=NIL;<br>
lpComment :=NIL;<br>
lpProvider :=NIL;<br>
end;<br>
{ get net root }<br>
ErrCode:=WNetOpenEnum(<br>
RESOURCE_GLOBALNET,<br>
RESOURCETYPE_ANY,<br>
RESOURCEUSAGE_CONTAINER,<br>
@NetRes[0],<br>
EnumHandle<br>
);<br>
If ErrCode=NO_ERROR then begin<br>
EnumEntries:=1;<br>
BufferSize:=SizeOf(NetRes);<br>
ErrCode:=WNetEnumResource(<br>
EnumHandle,<br>
EnumEntries,<br>
@NetRes[0],<br>
BufferSize<br>
);<br>
WNetCloseEnum(EnumHandle);<br>
ErrCode:=WNetOpenEnum(<br>
RESOURCE_GLOBALNET,<br>
RESOURCETYPE_ANY,<br>
RESOURCEUSAGE_CONTAINER,<br>
@NetRes[0],<br>
EnumHandle<br>
);<br>
EnumEntries:=1024;<br>
BufferSize:=SizeOf(NetRes);<br>
ErrCode:=WNetEnumResource(<br>
EnumHandle,<br>
EnumEntries,<br>
@NetRes[0],<br>
BufferSize<br>
);<br>
IF ErrCode=No_Error then with TV do try<br>
a:=0;<br>
Items.BeginUpDate;<br>
Items.Clear;<br>
Itm:=Items.Add(TV.Selected,string(NetRes[0].lpProvider));<br>
Itm.ImageIndex:=0;<br>
Itm.SelectedIndex:=0;<br>
<br>
{ get domains }<br>
<br>
<br>
下面的一个单元定义了一个组件. TNetworkBrowser, 可以枚举hierachical树上所有<br>
的网络资源. 实际上浏览是要花费很长时间的,这您可以通过在WINDOWS资源管理器<br>
中打开&quot;整个网络&quot; 来比较一下. 如果你设置SCOPE属性 为nsContext 
, 你就可以看到<br>
和网络邻居中一样的机器列表.<br>
<br>
unit NetBrwsr;<br>
<br>
interface<br>
<br>
uses<br>
Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs;<br>
<br>
type<br>
TNetScope = (nsConnected, nsGlobal, nsRemembered, nsContext);<br>
TNetResourceType = (nrAny, nrDisk, nrPrint);<br>
TNetDisplay = (ndDomain, ndGeneric, ndServer, ndShare, ndFile, ndGroup,<br>
ndNetwork, ndRoot, ndShareAdmin, ndDirectory, ndTree, ndNDSContainer);<br>
TNetUsage = set of (nuConnectable, nuContainer);<br>
<br>
TNetworkItems = class;<br>
<br>
TNetworkItem = class<br>
private<br>
FScope: TNetScope;<br>
FResourceType: TNetResourceType;<br>
FDisplay: TNetDisplay;<br>
FUsage: TNetUsage;<br>
FLocalName: string;<br>
FRemoteName: string;<br>
FComment: string;<br>
FProvider: string;<br>
FSubItems: TNetworkItems;<br>
public<br>
constructor Create;<br>
destructor Destroy; override;<br>
property Scope: TNetScope read FScope;<br>
property ResourceType: TNetResourceType read FResourceType;<br>
property Display: TNetDisplay read FDisplay;<br>
property Usage: TNetUsage read FUsage;<br>
property LocalName: string read FLocalName;<br>
property RemoteName: string read FRemoteName;<br>
property Comment: string read FComment;<br>
property Provider: string read FProvider;<br>
property SubItems: TNetworkItems read FSubItems;<br>
end;<br>
<br>
TNetworkItems = class<br>
private<br>
FList: TList;<br>
procedure SetItem(Index: Integer; Value: TNetworkItem);<br>
function GetItem(Index: Integer): TNetworkItem;<br>
function GetCount: Integer;<br>
public<br>
constructor Create;<br>
destructor Destroy; override;<br>
procedure Clear;<br>
procedure Add(Item: TNetworkItem);<br>
procedure Delete(Index: Integer);<br>
property Items[Index: Integer]: TNetworkItem read GetItem write<br>
SetItem; default;<br>
property Count: Integer read GetCount;<br>
end;<br>
<br>
TNetworkBrowser = class(TComponent)<br>
private<br>
FItems: TNetworkItems;<br>
FScope: TNetScope;<br>
FResourceType: TNetResourceType;<br>
FUsage: TNetUsage;<br>
FActive: Boolean;<br>
procedure Refresh;<br>
procedure SetActive(Value: Boolean);<br>
procedure SetScope(Value: TNetScope);<br>
procedure SetResourceType(Value: TNetResourceType);<br>
procedure SetUsage(Value: TNetUsage);<br>
procedure EnumerateNet(NetItems: TNetworkItems; lpnr: PNetResource);<br>
protected<br>
public<br>
constructor Create(AOwner: TComponent); override;<br>
destructor Destroy; override;<br>
procedure Open;<br>
procedure Close;<br>
property Items: TNetworkItems read FItems;<br>
published<br>
property Scope: TNetScope read FScope write SetScope default nsGlobal;<br>
property ResourceType: TNetResourceType read FResourceType<br>
write SetResourceType default nrAny;<br>
property Usage: TNetUsage read FUsage write SetUsage default [];<br>
property Active: Boolean read FActive write SetActive default False;<br>
end;<br>
<br>
implementation<br>
<br>
type<br>
PNetResourceArray = ^TNetResourceArray;<br>
TNetResourceArray = array[0..0] of TNetResource;<br>
<br>
{ TNetworkItem }<br>
<br>
constructor TNetworkItem.Create;<br>
begin<br>
inherited;<br>
FSubItems := TNetworkItems.Create;<br>
end;<br>
<br>
destructor TNetworkItem.Destroy;<br>
begin<br>
if FSubItems &lt;&gt; nil then<br>
FSubItems.Free;<br>
inherited;<br>
end;<br>
<br>
{ TNetworkItems }<br>
<br>
constructor TNetworkItems.Create;<br>
begin<br>
inherited;<br>
FList := TList.Create;<br>
end;<br>
<br>
destructor TNetworkItems.Destroy;<br>
begin<br>
Clear;<br>
if FList &lt;&gt; nil then<br>
FList.Free;<br>
inherited;<br>
end;<br>
<br>
procedure TNetworkItems.SetItem(Index: Integer; Value: TNetworkItem);<br>
begin<br>
if (FList.Items[Index] &lt;&gt; nil) and (FList.Items[Index] &lt;&gt; Value) then<br>
TNetworkItem(FList.Items[Index]).Free;<br>
FList.Items[Index] := Value;<br>
end;<br>
<br>
function TNetworkItems.GetItem(Index: Integer): TNetworkItem;<br>
begin<br>
Result := TNetworkItem(FList.Items[Index]);<br>
end;<br>
<br>
procedure TNetworkItems.Clear;<br>
begin<br>
while Count &gt; 0 do<br>
Delete(0);<br>
end;<br>
<br>
procedure TNetworkItems.Add(Item: TNetworkItem);<br>
begin<br>
FList.Add(Item);<br>
end;<br>
<br>
procedure TNetworkItems.Delete(Index: Integer);<br>
begin<br>
if FList.Items[Index] &lt;&gt; nil then<br>
TNetworkItem(FList.Items[Index]).Free;<br>
FList.Delete(Index);<br>
end;<br>
<br>
function TNetworkItems.GetCount: Integer;<br>
begin<br>
if FList &lt;&gt; nil then<br>
Result := FList.Count<br>
else<br>
Result := 0;<br>
end;<br>
<br>
{ TNetworkBrowser }<br>
<br>
constructor TNetworkBrowser.Create(AOwner: TComponent);<br>
begin<br>
inherited Create(AOwner);<br>
FItems := TNetworkItems.Create;<br>
FScope := nsGlobal;<br>
FResourceType := nrAny;<br>
FUsage := [];<br>
end;<br>
<br>
destructor TNetworkBrowser.Destroy;<br>
begin<br>
if FItems &lt;&gt; nil then<br>
FItems.Free;<br>
inherited;<br>
end;<br>
<br>
procedure TNetworkBrowser.EnumerateNet(NetItems: TNetworkItems; lpnr:<br>
PNetResource);<br>
var<br>
dwResult, dwResultEnum: Integer;<br>
hEnum: THandle;<br>
cbBuffer, cEntries, i: Integer;<br>
nrArray: PNetResourceArray;<br>
NewItem: TNetworkItem;<br>
dwScope, dwType, dwUsage: Integer;<br>
begin<br>
cbBuffer := 16384;<br>
cEntries := $FFFFFFFF;<br>
<br>
case FScope of<br>
nsConnected: dwScope := RESOURCE_CONNECTED;<br>
nsGlobal: dwScope := RESOURCE_GLOBALNET;<br>
nsRemembered: dwScope := RESOURCE_REMEMBERED;<br>
nsContext: dwScope := RESOURCE_CONTEXT;<br>
else<br>
dwScope := RESOURCE_GLOBALNET;<br>
end;<br>
case FResourceType of<br>
nrAny: dwType := RESOURCETYPE_ANY;<br>
nrDisk: dwType := RESOURCETYPE_DISK;<br>
nrPrint: dwType := RESOURCETYPE_PRINT;<br>
else<br>
dwType := RESOURCETYPE_ANY;<br>
end;<br>
dwUsage := 0;<br>
if nuConnectable in FUsage then<br>
dwUsage := dwUsage or RESOURCEUSAGE_CONNECTABLE;<br>
if nuContainer in FUsage then<br>
dwUsage := dwUsage or RESOURCEUSAGE_CONTAINER;<br>
<br>
dwResult := WNetOpenEnum(dwScope, dwType, dwUsage, lpnr, hEnum);<br>
if dwResult &lt;&gt; NO_ERROR then Exit;<br>
<br>
GetMem(nrArray, cbBuffer);<br>
repeat<br>
dwResultEnum := WNetEnumResource(hEnum, cEntries, nrArray, cbBuffer);<br>
if dwResultEnum = NO_ERROR then<br>
for i := 0 to cEntries-1 do<br>
begin<br>
NewItem := TNetworkItem.Create;<br>
case nrArray[i].dwScope of<br>
RESOURCE_CONNECTED: NewItem.FScope := nsConnected;<br>
RESOURCE_GLOBALNET: NewItem.FScope := nsGlobal;<br>
RESOURCE_REMEMBERED: NewItem.FScope := nsRemembered;<br>
RESOURCE_CONTEXT: NewItem.FScope := nsContext;<br>
else<br>
NewItem.FScope := nsGlobal;<br>
end;<br>
case nrArray[i].dwType of<br>
RESOURCETYPE_ANY: NewItem.FResourceType := nrAny;<br>
RESOURCETYPE_DISK: NewItem.FResourceType := nrDisk;<br>
RESOURCETYPE_PRINT: NewItem.FResourceType := nrPrint;<br>
else<br>
NewItem.FResourceType := nrAny;<br>
end;<br>
case nrArray[i].dwDisplayType of<br>
RESOURCEDISPLAYTYPE_GENERIC: NewItem.FDisplay := ndGeneric;<br>
RESOURCEDISPLAYTYPE_DOMAIN: NewItem.FDisplay := ndDomain;<br>
RESOURCEDISPLAYTYPE_SERVER: NewItem.FDisplay := ndServer;<br>
RESOURCEDISPLAYTYPE_SHARE: NewItem.FDisplay := ndShare;<br>
RESOURCEDISPLAYTYPE_FILE: NewItem.FDisplay := ndFile;<br>
RESOURCEDISPLAYTYPE_GROUP: NewItem.FDisplay := ndGroup;<br>
RESOURCEDISPLAYTYPE_NETWORK: NewItem.FDisplay := ndNetwork;<br>
RESOURCEDISPLAYTYPE_ROOT: NewItem.FDisplay := ndRoot;<br>
RESOURCEDISPLAYTYPE_SHAREADMIN: NewItem.FDisplay :=<br>
ndShareAdmin;<br>
RESOURCEDISPLAYTYPE_DIRECTORY: NewItem.FDisplay :=<br>
ndDirectory;<br>
RESOURCEDISPLAYTYPE_TREE: NewItem.FDisplay := ndTree;<br>
RESOURCEDISPLAYTYPE_NDSCONTAINER: NewItem.FDisplay :=<br>
ndNDSContainer;<br>
else<br>
NewItem.FDisplay := ndGeneric;<br>
end;<br>
NewItem.FUsage := [];<br>
if nrArray[i].dwUsage and RESOURCEUSAGE_CONNECTABLE &lt;&gt; 0 then<br>
Include(NewItem.FUsage, nuConnectable);<br>
if nrArray[i].dwUsage and RESOURCEUSAGE_CONTAINER &lt;&gt; 0 then<br>
Include(NewItem.FUsage, nuContainer);<br>
NewItem.FLocalName := StrPas(nrArray[i].lpLocalName);<br>
NewItem.FRemoteName := StrPas(nrArray[i].lpRemoteName);<br>
NewItem.FComment := StrPas(nrArray[i].lpComment);<br>
NewItem.FProvider := StrPas(nrArray[i].lpProvider);<br>
NetItems.Add(NewItem);<br>
// if container, call recursively<br>
if (nuContainer in NewItem.FUsage) and (FScope &lt;&gt; nsContext) then<br>
EnumerateNet(NewItem.FSubItems, @nrArray[i])<br>
end;<br>
until dwResultEnum = ERROR_NO_MORE_ITEMS;<br>
<br>
FreeMem(nrArray);<br>
WNetCloseEnum(hEnum);<br>
end;<br>
<br>
procedure TNetworkBrowser.Refresh;<br>
begin<br>
FItems.Clear;<br>
if FActive then<br>
EnumerateNet(FItems, nil);<br>
end;<br>
<br>
procedure TNetworkBrowser.SetActive(Value: Boolean);<br>
begin<br>
if Value &lt;&gt; FActive then<br>
begin<br>
FActive := Value;<br>
Refresh;<br>
end;<br>
end;<br>
<br>
procedure TNetworkBrowser.SetScope(Value: TNetScope);<br>
begin<br>
if Value &lt;&gt; FScope then<br>
begin<br>
FScope := Value;<br>
Refresh;<br>
end;<br>
end;<br>
<br>
procedure TNetworkBrowser.SetResourceType(Value: TNetResourceType);<br>
begin<br>
if Value &lt;&gt; FResourceType then<br>
begin<br>
FResourceType := Value;<br>
Refresh;<br>
end;<br>
end;<br>
<br>
procedure TNetworkBrowser.SetUsage(Value: TNetUsage);<br>
begin<br>
if Value &lt;&gt; FUsage then<br>
begin<br>
FUsage := Value;<br>
Refresh;<br>
end;<br>
end;<br>
<br>
procedure TNetworkBrowser.Open;<br>
begin<br>
Active := True;<br>
end;<br>
<br>
procedure TNetworkBrowser.Close;<br>
begin<br>
Active := False;<br>
end;<br>
<br>
end.<br>
<br>
==============================================<br>
http://leonyxl.yeah.net/ <br>
==============================================</p>
</body>
</html>
