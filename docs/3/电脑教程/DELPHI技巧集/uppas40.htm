<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>Delphi 4增訂的Object Pascal</title>
</head>

<body bgcolor="#FFFFFF" text="#000000">
<font FACE="Arial" SIZE="6">

<p ALIGN="CENTER">Delphi 4</font><font SIZE="6">增訂的</font><font FACE="Arial"
SIZE="6">Object Pascal</font><font FACE="Times New Roman" SIZE="1"></p>

<p ALIGN="JUSTIFY"></font><font SIZE="1">　</font><font face="宋体" size="4">本附錄在於說明Delphi 
4新增訂的Object Pascal程式語言。總結來說，Delphi 4的Object Pascal增訂了以下幾大部分：</font></p>

<blockquote>
  <p ALIGN="JUSTIFY"><font face="宋体" size="4">新增加數種內定資料型態。</font></p>
  <p ALIGN="JUSTIFY"><font face="宋体" size="4">Dynamic Arrays</font></p>
  <p ALIGN="JUSTIFY"><font face="宋体" size="4">Method and Routine Overloading</font></p>
  <p ALIGN="JUSTIFY"><font face="宋体" size="4">Default Parameters.</font></p>
  <p ALIGN="JUSTIFY"><font face="宋体" size="4">Implementating interfaces by delegation，可用以下的寫法：</font></p>
</blockquote>

<p><font face="宋体" size="4">　</font></p>

<p><font face="宋体" size="4">property MyInterface: IMyInterface read FMyInterface <br>
implements IMyInterface;</font></p>

<p><font face="宋体" size="4">新增的內定資料型態</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">整數方面：</font></p>

<blockquote>
  <p ALIGN="JUSTIFY"><font face="宋体" size="4">新增加<i>Int64</i>這種長度六十四位元，範圍從-2^63 
  to 2^63 - 1。</font></p>
  <p ALIGN="JUSTIFY"><font face="宋体" size="4">32-bit unsigned integer新增加<i>Longword</i>型態，範圍從0..4294967295。</font></p>
  <i><p ALIGN="JUSTIFY"><font face="宋体" size="4">Cardinal</i>的範圍調整成與上述<i>Longword</i>型態相同。</font></p>
</blockquote>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">浮點數方面：</font></p>

<blockquote>
  <i><p ALIGN="JUSTIFY"><font face="宋体" size="4">Real</i>型態基於效率考量，由過去佔用48-bit調整成64-bits，</font></p>
  <p ALIGN="JUSTIFY"><font face="宋体" size="4">新增加<i>Real48</i>型態，精確度與過去的<i>Real</i>相同，仍是48-bit。</font></p>
</blockquote>

<p><font face="宋体" size="4">　</font></p>

<p><font face="宋体" size="4">Dynamic Array</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">Delphi 4問世之前，Delphi程式設計師若需要動態長度的陣列，在不得已的情況下，往往採用以下這種「表面上陣列的語法，但實際自己配置管理記憶體」的方式來處理動態陣列：</font></p>

<p><font face="宋体" size="4">#0001 procedure TForm1.Button1Click(Sender: TObject);</font></p>

<p><font face="宋体" size="4">#0002 type</font></p>

<p><font face="宋体" size="4">#0003 TIntegerArray = array[0..0] of integer; </font></p>

<p><font face="宋体" size="4">#0004 PIntegerArray = ^TIntegerArray;</font></p>

<p><font face="宋体" size="4">#0005 var</font></p>

<p><font face="宋体" size="4">#0006 pArrayOfInteger: PIntegerArray; </font></p>

<p><font face="宋体" size="4">#0007 j: integer;</font></p>

<p><font face="宋体" size="4">#0008 begin</font></p>

<p><font face="宋体" size="4">#0009 GetMem(pArrayOfInteger, 10 * SizeOf(Integer)); </font></p>

<p><font face="宋体" size="4">#0010 for j := 0 to 9 do</font></p>

<p><font face="宋体" size="4">#0011 pArrayOfInteger^[j] := j; </font></p>

<p><font face="宋体" size="4">#0012 FreeMem(pArrayOfInteger, 10 * SizeOf(Integer));</font></p>

<p><font face="宋体" size="4">#0013 end;</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">如果應用Delphi 4新增加的Dynamic 
Array，則可改用以下的方式：</font></p>

<p><font face="宋体" size="4">var MyFlexibleArray: array of Real;</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">定義之後，以 <i>SetLength</i> 
函數改變陣列實際配置的記憶體大小，例如：</font></p>

<p><font face="宋体" size="4">SetLength(MyFlexibleArray, 20); // 0..19</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">方便很多，是嗎？若想知道Dynamic 
Array實際長度，請分別以<i>High</i>與<i>Low</i>函數判斷，傳回「-1」時，表示是一個該陣列的長度為零，例如：</font></p>

<p><font face="宋体" size="4">　</font></p>

<p><font face="宋体" size="4">#0001 procedure TForm1.Button2Click(Sender: TObject);</font></p>

<p><font face="宋体" size="4">#0002 var</font></p>

<p><font face="宋体" size="4">#0003 A: array of Integer;</font></p>

<p><font face="宋体" size="4">#0004 begin</font></p>

<p><font face="宋体" size="4">#0005 ShowMessage(IntToStr(High(A))); // <b>-1</b></font></p>

<p><font face="宋体" size="4">#0006 SetLength(A, 3);</font></p>

<p><font face="宋体" size="4">#0007 ShowMessage(IntToStr(High(A))); // 3</font></p>

<p><font face="宋体" size="4">#0008 A := nil;</font></p>

<p><font face="宋体" size="4">#0009 ShowMessage(IntToStr(High(A))); // -1</font></p>

<p><font face="宋体" size="4">#0010 end;</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">上述的0008這列，指定<i>nil</i>值將會釋放陣列所配置到的記憶體。</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">值得注意的是，Compiler對於Dynamic 
Array並不會自動進行所謂的「Copy-on-Write」。請看以下的程式例：</font></p>

<p><font face="宋体" size="4">#0001 procedure TForm1.Button1Click(Sender: TObject);</font></p>

<p><font face="宋体" size="4">#0002 var</font></p>

<p><font face="宋体" size="4">#0003 A, B: array of Integer;</font></p>

<p><font face="宋体" size="4">#0004 begin</font></p>

<p><font face="宋体" size="4">#0005 SetLength(A, 1);</font></p>

<p><font face="宋体" size="4">#0006 A[0] := 1;</font></p>

<p><font face="宋体" size="4">#0007 B := A;</font></p>

<p><font face="宋体" size="4">#0008 B[0] := 2;</font></p>

<p><font face="宋体" size="4">#0009 ShowMessage(IntToStr(A[0])); // ==&gt; 2</font></p>

<p><font face="宋体" size="4">#0010 end;</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">0008這列改的雖是<i>B[0]</i>，但Compiler顯然還沒有聰明到在可能修改陣列內容時，將陣列內容複製一份出來（Copy 
on (possible) Write），於是，0009這列程式顯示的結果仍是2。</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">於是，若要進行兩陣列各索引項目一對一的內容複製，只好自行寫迴圈一一複製，或者，採用較為簡便的寫法 
── 呼叫Copy函數：</font></p>

<p><font face="宋体" size="4">#0001 procedure TForm1.Button4Click(Sender: TObject);</font></p>

<p><font face="宋体" size="4">#0002 var</font></p>

<p><font face="宋体" size="4">#0003 A, B: array of Integer;</font></p>

<p><font face="宋体" size="4">#0004 begin</font></p>

<p><font face="宋体" size="4">#0005 SetLength(A, 1);</font></p>

<p><font face="宋体" size="4">#0006 A[0] := 1;</font></p>

<p><font face="宋体" size="4">#0007 B := Copy(A, 0, 1);</font></p>

<p><font face="宋体" size="4">#0008 B[0] := 2;</font></p>

<p><font face="宋体" size="4">#0009 ShowMessage(IntToStr(A[0])); // ==&gt; 1</font></p>

<p><font face="宋体" size="4">#0010 ShowMessage(IntToStr(B[0])); // ==&gt; 2</font></p>

<p><font face="宋体" size="4">#0011 end;</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">最後，請不要將Dynamic Array與第二章提到的Open 
Array（開放陣列）搞混了。函式參數的開放陣列，語法雖與Dynamic Array差不多，但開放陣列指的是：不限定傳入函式的陣列長度，Dynamic 
Array則是指：可變長度的陣列，兩者畢竟有所不同。以下是一則我準備的程式範例，不難看出兩者之間的差異：</font><b></p>

<p><font face="宋体" size="4">#0001 type</font></p>

<p><font face="宋体" size="4">#0002 TDynamicInteger = array of integer;</font></b></p>

<p><font face="宋体" size="4">#0003 </font></p>

<p><font face="宋体" size="4">　</font><b></p>

<p><font face="宋体" size="4">#0004 procedure Clear_OpenArray(var A: array of Integer);</font></b></p>

<p><font face="宋体" size="4">#0005 var</font></p>

<p><font face="宋体" size="4">#0006 I: Integer;</font></p>

<p><font face="宋体" size="4">#0007 begin</font></p>

<p><font face="宋体" size="4">#0008 for I := 0 to High(A) do A[I] := 0;</font></p>

<p><font face="宋体" size="4">#0009 // SetLength(A, 20); // 不可以這麼寫</font></p>

<p><font face="宋体" size="4">#0010 end;</font></p>

<p><font face="宋体" size="4">#0011 </font></p>

<p><font face="宋体" size="4">#0012 // 注意, 以下兩種寫法又有不同喔</font></p>

<p><font face="宋体" size="4">#0013 // I: procedure Clear_DynamicArray(A: 
TDynamicInteger);</font></p>

<p><font face="宋体" size="4">#0014 // II: procedure Clear_DynamicArray(var A: 
TDynamicInteger);</font></p>

<p><font face="宋体" size="4">　</font><b></p>

<p><font face="宋体" size="4">#0015 procedure Clear_DynamicArray(var A: 
TDynamicInteger);</font></b></p>

<p><font face="宋体" size="4">#0016 var</font></p>

<p><font face="宋体" size="4">#0017 I: Integer;</font></p>

<p><font face="宋体" size="4">#0018 begin</font></p>

<p><font face="宋体" size="4">#0019 for I := 0 to High(A) do A[I] := 0;</font></p>

<p><font face="宋体" size="4">#0020 SetLength(A, 20); // 如果是Dynamic Array, 
可以這麼寫</font></p>

<p><font face="宋体" size="4">#0021 end;</font></p>

<p><font face="宋体" size="4">#0022 </font></p>

<p><font face="宋体" size="4">#0023 procedure TForm1.Button3Click(Sender: TObject);</font></p>

<p><font face="宋体" size="4">#0024 var</font></p>

<p><font face="宋体" size="4">#0025 A: TDynamicInteger;</font></p>

<p><font face="宋体" size="4">#0026 begin</font></p>

<p><font face="宋体" size="4">#0027 SetLength(A, 3);</font></p>

<p><font face="宋体" size="4">#0028 Clear_OpenArray(A);</font></p>

<p><font face="宋体" size="4">#0029 ShowMessage(IntToStr(High(A))); // -1</font></p>

<p><font face="宋体" size="4">#0030 Clear_DynamicArray(A);</font></p>

<p><font face="宋体" size="4">#0031 // 以下這列的結果, 要看 Cleary_DynamicArray 
的</font></p>

<p><font face="宋体" size="4">#0032 // 參數有沒有寫 var</font></p>

<p><font face="宋体" size="4">#0033 ShowMessage(IntToStr(High(A)));</font></p>

<p><font face="宋体" size="4">#0034 end;</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">請幫我注意0004的<i>Clear_OpenArray</i>，傳入的是「由整數構成的陣列，不限定陣列的長度」，0015的<i>Clear_DynamicArray</i>的寫法則是「接受一個可變動陣列長度的動態陣列」，若不這樣寫，當場就變成了開放陣列了。</font></p>

<p><font face="宋体" size="4">Method and Routine Overloading</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">所謂的Method Overloading，簡單地說：一個以上的函式使用相同的函式名稱。這項特性是Object 
Pascal長久以來一直有人想要卻一直沒有支援的期盼，終於，Delphi 4多了一個保留字：<i>overload</i><b> 
</b>── 相同名稱的兩個函式，只要在宣告時額外加上<i><b>overload</b></i>，即使函式的參數型態不同，Delphi也會視呼叫當時傳入的參數資料型態，決定該呼叫哪一個函式。例如以下這則例子：</font></p>

<p><font face="宋体" size="4">#0001 // 兩個 Divide 都必須寫overload保留字</font></p>

<p><font face="宋体" size="4">#0002 function Divide(X, Y: Double): Double; <b>overload;</b></font></p>

<p><font face="宋体" size="4">#0003 begin</font></p>

<p><font face="宋体" size="4">#0004 Result := X / Y;</font></p>

<p><font face="宋体" size="4">#0005 end;</font></p>

<p><font face="宋体" size="4">#0006 </font></p>

<p><font face="宋体" size="4">#0007 function Divide(X, Y: Integer): Integer; <b>overload;</b></font></p>

<p><font face="宋体" size="4">#0008 begin</font></p>

<p><font face="宋体" size="4">#0009 Result := X div Y;</font></p>

<p><font face="宋体" size="4">#0010 end;</font></p>

<p><font face="宋体" size="4">#0011 </font></p>

<p><font face="宋体" size="4">#0012 procedure TForm1.Button1Click(Sender: TObject);</font></p>

<p><font face="宋体" size="4">#0013 var</font></p>

<p><font face="宋体" size="4">#0014 a, b, c: integer;</font></p>

<p><font face="宋体" size="4">#0015 i, j, k: Double;</font></p>

<p><font face="宋体" size="4">#0016 begin</font></p>

<p><font face="宋体" size="4">#0017 a := 10;</font></p>

<p><font face="宋体" size="4">#0018 b := 3;</font></p>

<p><font face="宋体" size="4">#0019 i := 10;</font></p>

<p><font face="宋体" size="4">#0020 j := 3;</font></p>

<p><font face="宋体" size="4">#0021 c := Divide(a, b);</font></p>

<p><font face="宋体" size="4">#0022 k := Divide(i, j);</font></p>

<p><font face="宋体" size="4">#0023 ShowMessage(IntToStr(c)); // 3</font></p>

<p><font face="宋体" size="4">#0024 ShowMessage(FloatToStr(k)); // 3.333333...</font></p>

<p><font face="宋体" size="4">#0025 end;</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">請幫我注意到0002與0007這兩列的<i>Divide</i>函數，函數名稱相同，但傳入的參數型態與函數的傳回值並不相同，即使如此，0023與0024呼叫到<i>Divide</i>時，還是會視當時參數的型態型態，決定該呼叫哪一個<i>Divide</i>。</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">很方便，是嗎？有了這項特性，我們就可以寫出應用範圍更廣彈性更大的函數──卻不必為每一種情況各自取一個函數名稱，同時，這項特性也使得函數呼叫的方式更為一致，真是一項早該支援的特性。除了一般的程序與函數，物件的方法也可以採用<i>overload</i>寫法，對於「<i>物件<b>.</b>方法</i>」的撰寫與呼叫，肯定更能提供簡便與彈性。</font><i></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">overload</i>可不可以應用在不同的兩個單元呢？答案是可以的，但是完全相同的函式宣告不能再寫一次。例如上述程式的0007-0010，可以移到其他單元，原來的單元只要<i>uses</i>這個新的單元，函數呼叫時仍然有Overloading的效果。可是，如果將0007-0010的程式碼移到其他單元卻忘了刪除原來位置的程式，換句話說，兩個單元各有一個完全長得一樣的函式，編譯時Delphi就搞不清楚了，結果自然是無法編譯。當然啦！同一個單元同一個範圍發生這樣事也是不許的，各Overloading的函式，在函式宣告上多少總有些不同。</font></p>

<p><font face="宋体" size="4">Default Parameters</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">過去，函式如果定義了六個參數，那麼，寫作函式呼叫的原始碼時，就一定得乖乖地傳入六個參數，不許多也不許少。若是應用「Default 
Parameters」，可以只傳入五個（或者更少）。那．．．，那其他沒給的參數怎麼辦？沒關係，函式內部的程式將自動以預設值代入，稍後我會說明其寫法。</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">舉例來說，Windows API中有一個蠻好用的函數叫<i>MessageBox</i>，呼叫此函數將出現一通用對話盒，不管是顯示訊息或者徵詢使用者意見，都十分好用。像是以下這道敘述將產生如次頁的對話盒，提醒使用者定期備份資料：</font></p>

<p><font face="宋体" size="4">Application.MessageBox('程式要結束了喔! 
請記得定期備份資料',</font></p>

<p><font face="宋体" size="4">'訊息', MB_OK + MB_ICONINFORMATION);</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">　</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">除了顯示資料，經由最後一個參數，彈性地搭配各位元旗標，就可以製作出不同按鈕的對話盒，詢問使用者「是」、「否」、「取消」等簡單的問題。</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">應用Default Parameters的寫法，我們可以寫一個類似以下的函數：</font></p>

<p><font face="宋体" size="4">#0001 function MyMessageBox(Prompt: string;</font></p>

<p><font face="宋体" size="4">#0002 <b>Caption: string = '訊息';</b></font></p>

<p><font face="宋体" size="4">#0003 <b>Flag: LongInt = MB_OK + MB_ICONINFORMATION</b>): 
integer;</font></p>

<p><font face="宋体" size="4">#0004 begin</font></p>

<p><font face="宋体" size="4">#0005 Result := Application.MessageBox(</font></p>

<p><font face="宋体" size="4">#0006 PChar(Prompt), PChar(Caption), Flag);</font></p>

<p><font face="宋体" size="4">#0007 end;</font></p>

<p><font face="宋体" size="4">#0008 </font></p>

<p><font face="宋体" size="4">#0009 procedure TForm1.Button1Click(Sender: TObject);</font></p>

<p><font face="宋体" size="4">#0010 begin</font></p>

<p><font face="宋体" size="4">#0011 MyMessageBox('程式要結束了喔! 
請記得定期備份資料');</font></p>

<p><font face="宋体" size="4">#0012 end;</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">如此一來，我們既能有一個完整支援<i>MessageBox</i>的函數，只想顯示文字時，也能有一個精簡型式的函數可用。大家應該明顯看得出來：不必寫成兩個函數。</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">觀察上述程式的寫法，其實也蠻容易的，只不過是在定義函數參數時，一併給定初值。</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">不過，實際動手去寫時，還是會發現一些限制。繼續這個例子來說，參數的預設值一定得是常數，另外，如果某一個參數開始給預設值，接在後頭的參數也必須用Default 
Parameters的寫法。為什麼得有這項限制？以上例來說，如果0001-0003我改成：</font></p>

<p><font face="宋体" size="4">#0001 function MyMessageBox(Prompt: string;</font></p>

<p><font face="宋体" size="4">#0002 <b>Caption: string = '訊息';</b></font></p>

<p><font face="宋体" size="4">#0003 <b>Flag: LongInt</b>): integer;</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">那麼，只傳入兩個參數進去時，Delphi怎麼知道第二個參數該是<i>Captioin</i>或者是「<i>Caption</i>按預設值，第二個參數代入<i>Flag</i>」。Visual 
Basic對此的解法是在呼叫函數時，一併寫明各參數名稱與值的對應，由於這個緣故，Visual 
Basic甚至允許參數的次序不同也沒關係，因為，各參數與其值的對應關係在呼叫函式時已一併註明清楚。很可惜的，Delphi 
4雖有Default Parametets，但還不支援以下的函數呼叫方式：</font></p>

<p><font face="宋体" size="4">MyMessageBox('程式要結束了喔! 
請記得定期備份資料', Flag = ...);</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">雖然如此，上述「如果某一個參數開始給預設值，接在後頭的參數也必須用Default 
Parameters的寫法」這項限制，多少還是可以搭配前一節的Overloading加以彌補：</font></p>

<p><font face="宋体" size="4">#0001 function MyMessageBox(Prompt: string;</font></p>

<p><font face="宋体" size="4">#0002 Caption: string = '訊息';</font></p>

<p><font face="宋体" size="4">#0003 Flag: LongInt = MB_OK + MB_ICONINFORMATION): 
integer; overload;</font></p>

<p><font face="宋体" size="4">#0004 begin</font></p>

<p><font face="宋体" size="4">#0005 Result := Application.MessageBox(</font></p>

<p><font face="宋体" size="4">#0006 PChar(Prompt), PChar(Caption), Flag);</font></p>

<p><font face="宋体" size="4">#0007 end;</font></p>

<p><font face="宋体" size="4">#0008 </font></p>

<p><font face="宋体" size="4">　</font><b></p>

<p><font face="宋体" size="4">#0009 function MyMessageBox(Prompt: string;</font></p>

<p><font face="宋体" size="4">#0010 Flag: LongInt;</font></p>

<p><font face="宋体" size="4">#0011 Caption: string = '訊息'</font></p>

<p><font face="宋体" size="4">#0012 ): integer; overload;</font></b></p>

<p><font face="宋体" size="4">#0013 begin</font></p>

<p><font face="宋体" size="4">#0014 Result := Application.MessageBox(</font></p>

<p><font face="宋体" size="4">#0015 PChar(Prompt), PChar(Caption), Flag);</font></p>

<p><font face="宋体" size="4">#0016 end;</font></p>

<p><font face="宋体" size="4">#0017 </font></p>

<p><font face="宋体" size="4">#0018 procedure TForm1.Button1Click(Sender: TObject);</font></p>

<p><font face="宋体" size="4">#0019 begin</font></p>

<p><font face="宋体" size="4">#0020 MyMessageBox('程式要結束了喔! 
請記得定期備份資料');</font></p>

<p><font face="宋体" size="4">#0021 MyMessageBox('別說我沒告訴你喔!', MB_OK);</font></p>

<p><font face="宋体" size="4">#0022 end;</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">（好煩的程式，一再提醒要記得備份。:p）</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">請幫我注意這次改寫過的程式0009-0012，我重新調整了各參數的次序，並且分別在兩同名函數都加上了<i>overload</i>保留字，這樣，Delphi就知道該呼叫的是哪一個了。</font></p>

<p ALIGN="JUSTIFY"><font face="宋体" size="4">　</font></p>
</body>
</html>
