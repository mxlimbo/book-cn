<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>DELPHI下的多线程程序设计</title>
</head>

<body bgcolor="#FFFFFF" text="#000000">

<p align="center"><strong><big><big><big>DELPHI下的多线程程序设计</big></big></big> 
<br>
<br>
梁毅 李韬</strong> </p>

<p><br>
　　我们知道，win95或winNT都是“多线程”的操作系统，在DELPHI2．0中，我们可以充分利用这一特性，<br>
编写出“多线程”的应用程序。<br>
<br>
　　对以往在DOS或16位windows下写程序的人来说，“多线程”仍然是陌生的，但如同以前我们从DOS下的单<br>
任务过渡到windows3．1下的多任务，如今我们又必须过渡到“多线程”领域，毕竟计算机时代是在不断发展<br>
的。不过，幸运的是，在DELPHI2．0下进行多线程程序设计并不需要我们去学习庞大的WIN32API函数，我们<br>
可以利用DELPHI下标准的多线程类TThread来完成我们的工作。<br>
<br>
　　TThread是一个abstract（抽象）类，也就是说，并不需要根据TThread来声明变量（而且根据TThread声<br>
明的变量也是完全无用），我们要做的是把TThread作为基类，用继承的形式来生成子类。实际上，根据<br>
TThread来写多线程应用程序是非常容易的。<br>
<br>
　　下面就是一个基本的继承TThread生成的多线程类。<br>
<br>
　　QuerThrd．Pas<br>
<br>
　　unitQuerThrd；<br>
<br>
　　interface<br>
<br>
　　uses<br>
<br>
　　Classes，DBTables；<br>
<br>
　　type<br>
<br>
　　TQueryThreadΚclass（TThread）<br>
<br>
　　private<br>
<br>
　　fQuery：tQuery；<br>
<br>
　　protected<br>
<br>
　　procedureExecute；override；<br>
<br>
　　public<br>
<br>
　　constructorCreate（Suspended：Boolean；Query：<br>
TQuery）；<br>
<br>
　　end；<br>
<br>
　　implementation<br>
<br>
　　constructor<br>
<br>
　　TQueryThread．Create（Suspended：Boolean；Quer<br>
y：TQuery）；<br>
<br>
　　begin<br>
<br>
　　inheritedCreate（Suspended）；<br>
<br>
　　fQuery：ΚQuery；<br>
<br>
　　FreeOnTerminate：ΚTrue；<br>
<br>
　　end；<br>
<br>
　　procedureTQueryThread．Execute；<br>
<br>
　　begin<br>
<br>
　　fQuery．Open；<br>
<br>
　　end；<br>
<br>
　　end．<br>
<br>
　　在上面这个简单的例子中，我们构造了一个TThread的子类TQueryThread，用于在后台执行数据库查<br>
询。在该类的Create函数中，传递了两个参数Suspended和Query，其中Suspended用于控制线程的运行，如果<br>
Suspend为真，TQueryThread类的线程在建立后将立即被悬挂，一直到运行了Resume方法，该线程才会继续执<br>
行，Query参数用于接受一个已经存在的Query控件（在窗体中真正的Query控件）而使它在多线程的情况下运<br>
行。Execute是最重要的过程，它是类TQueryThread的执行部分，所有需要在这个多线程类中运行的语句都必<br>
须写在这个过程里。<br>
<br>
　　实际上构造自己的多线程类时，并不需要输入所有的这些代码，选择DELPHI的File菜单下的new选项，再<br>
选“TThreadObject”项目，DELPHI就会为你构造基本的程序模块。然后我们可以根据需要再做相应的修改。<br>
<br>
　　进程的执行：<br>
<br>
　　假设我们已经建立了一个窗体FORM1，窗体中有我们将要使用的查询控件Query1。那么我们在该单元的<br>
USES部分加入上面写的QuerThrd单元。<br>
<br>
　　procedureTForm1．Button1Click（Sender：TObject）；<br>
<br>
　　begin<br>
<br>
　　｛建立一个运行的进程｝<br>
<br>
　　TQueryThread．Create（False，Query1）；<br>
<br>
　　end；<br>
<br>
　　如果这个过程被执行，那么窗体中的查询控件Query1就会自动在多线程的环境下运行查询。注意<br>
TQueryThread类中只有Create而没有Free，动态建立类以后又忘记删除是我们常犯的错误之一，不过在这里<br>
由于我们指定了FreeOnTerminate（运行完即删除）为真，所以当Execute里的语句执行完后，TQueryThread<br>
类占据的内存控件将被自动释放。<br>
<br>
　　然而还有一个问题值得我们注意，由于同一时刻可以有多个线程同时运行，那么我们还必须解决好同步<br>
的问题，如果几个多线程程序之间没有任何关联，那么它们之间也不会有任何冲突。但实际上，可能同时运<br>
行几个多线程的数据库应用程序，由于需要共享相同的数据库资源，我们还需要为Query1增加一个Tsession<br>
控件。<br>
<br>
　　其实，虽然我们也许没有亲自使用过Session控件，但实际上，在所有的数据库访问时DELPHI都会自动建<br>
立一个临时的Session控件，使用完后又动态地删除掉它。在平常的数据库编程时，用不着我们亲自来操作，<br>
但在数据库多线程执行的情况下，为了不相互冲突，我们必须为每个数据库访问都定制自己的Session控件。<br>
这个步骤非常简单，我们只需要在窗体中增加一个Session控件，然后给它的属性“Sessionname”写一个任<br>
意的名字，并再在Query1的“Sessionname”中写一个相同的名字。这样我们的数据库程序就安全了。<br>
<br>
　　另一类需要解决同步问题的是那些对VCL资源进行操作的程序，这类的程序非常多，好在解决的方法也非<br>
常简单。<br>
<br>
　　我们可以看下面这样一个程序：<br>
<br>
　　unitBncThrd；<br>
<br>
　　interface<br>
<br>
　　uses<br>
<br>
　　WinProcs，Classes，Graphics，ExtCtrls；<br>
<br>
　　type<br>
<br>
　　TBounceThreadΚclass（TThread）<br>
<br>
　　private<br>
<br>
　　FShape：TShape；<br>
<br>
　　FXSpeed：Integer；<br>
<br>
　　FYSpeed：Integer；<br>
<br>
　　procedureMoveShape；<br>
<br>
　　protected<br>
<br>
　　procedureExecute；override；<br>
<br>
　　public<br>
<br>
　　constructorCreate（Suspended：Boolean；Shape：TShape；XSpeed，YSpeed：Integer）；<br>
<br>
　　propertyShape：TShapereadFShape；<br>
<br>
　　end；<br>
<br>
　　implementation<br>
<br>
　　procedureTBouad．MoveShape；<br>
<br>
　　var<br>
<br>
　　MaxHeight，MaxWidth：Integer；<br>
<br>
　　begin<br>
<br>
　　withFShapedo<br>
<br>
　　begin<br>
<br>
　　Left：ΚLeft＋FXSpeed；<br>
<br>
　　Top：ΚTop＋FYSpeed；<br>
<br>
　　if（LeftΙ0）or<br>
<br>
　　（Left＋WidthΛParent．Width）then<br>
<br>
　　FXSpeed：ΚFXSpeed＊－1；<br>
<br>
　　if（TopΙ0）or<br>
<br>
　　（Top＋HeightΛParent．Height）then<br>
<br>
　　FYSpeed：ΚFYSpeed＊－1；<br>
<br>
　　end；<br>
<br>
　　end；<br>
<br>
　　procedureTBounceThread．Execute；<br>
<br>
　　begin<br>
<br>
　　WhilenotTerminateddo<br>
<br>
　　begin<br>
<br>
　　Synchronize（MoveShape）；<br>
<br>
　　end；<br>
<br>
　　end；<br>
<br>
　　constructorTBounceThread．Create（Suspended：Boolean；Shape：TShape；XSpeed，YSpeed：<br>
Integer）；<br>
<br>
　　begin<br>
<br>
　　inheritedCreate（Suspended）；<br>
<br>
　　FShape：ΚShape；<br>
<br>
　　FXSpeed：ΚXSpeed；｛X轴走向的速度｝<br>
<br>
　　FYSpeed：ΚYSpeed；｛Y轴走向的速度｝<br>
<br>
　　FreeOnTerminate：ΚTrue；<br>
<br>
　　end；<br>
<br>
　　end．<br>
<br>
　　这是一个多线程的碰碰球游戏，你可以有多个不同的球，它们分属不同的线程，各自独立的在屏幕上碰<br>
撞。显然，由于多个球运行的显示会同时操作VCL资源，为了安全，我们在Execute过程中的执行部分加入了<br>
Synchronize（MoveShape）来调用MoveShape过程，实际上，在任何需要操作VCL资源的地方，例如窗体、<br>
位图，都应加入Synchronize调用。<br>
<br>
　　执行时我们可以新建一个程序，然后在USES部分加入以上的BncThrd单元，再在它的窗体FORM1上加入两<br>
个Shape控件Shape1和Shape2，Shape1可以是一个矩形而Shape2是一个圆。加入以下的代码就可以让矩形和圆<br>
动起来。<br>
<br>
　　procedureTForm1．Button1Click（Sender：TObject）；<br>
<br>
　　begin<br>
<br>
　　TBounceThread．Create（False，Shape1，1，2）；<br>
<br>
<br>
　　TBounceThread．Create（False，Shape2，2，3）；<br>
<br>
<br>
　　end；</p>
</body>
</html>
