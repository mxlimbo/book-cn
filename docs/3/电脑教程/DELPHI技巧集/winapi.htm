<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<title>充分利用Windows API扩展Delphi函数</title>
</head>

<body bgcolor="#FFFFFF" text="#000000">

<p>　<font size="+1" color="#cc0000"></p>

<p></font><font color="#cc0000" size="4">充分利用Windows API扩展Delphi函数</font><big><big><big> 
<br>
</big></big></big><font size="3"> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 袁卫国</font><big><big><big> 
<br>
</big></big></big></p>

<hr width="100%">

<p><big><big><big><br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; Borland Delphi是与Visual Basic相似的可视化开发工具,但其功能比VB更加强大。<br>
例如,Delphi支持汇编语言和指针操作、全面支持Windows API函数及外部DLL的使<br>
用,使得它具有更广泛的应用范围。即使用于编制一些较小的应用程序,Delphi与VB<br>
相比看来不相上下,</font><big><big><big> </big></big></big><font size="3">但由于Delphi是编译型的语言,其编译后的EXE文件可以真正脱<br>
离Delphi的环境独立运行,而VB 生成的EXE文件离开了VB软件包的一大堆DLL、<br>
VBX等文件可能会无法执行。而更重要的是,一般用户往往并不真正知道自己开发<br>
的VB程序到底使用了哪些DLL一类的文件,为了保证程序的正常运行,可能在最后的<br>
安装盘中包含了不少其实并不需要的文件。所以,一般用户用VB很难开发出真正实<br>
用的软件,难怪有人说VB是&quot;先甜后苦&quot;。Delphi实际上可以看作是VP(Visual 
Pascal),所<br>
以它的易学性也可与VB媲美。今年发布的Delphi2.0可以为Windows 95、Window 
s NT<br>
开发32位程序,使得VB 4.0的优势也不复存在。看来,在今后一段时间内,将会有更多<br>
的人使用Delphi开发Windows应用程序。在DOS下开发过软件的人都知道int 
2lh的重要。<br>
与此类似,Windows应用程序也是离不开Windows API的,许多较底层的操作必须通过<br>
API函数来实现。为此,无论是C++、VB还是Delp hi都无一例外地支持API函数的调<br>
用,只是VB由于自身的特点所限制,仅支持部分API函数,而C++、Delphi则全面地支持<br>
API函数。相比之下,Delphi对API函数的调用最简捷,达到了与自身的内部函数几乎<br>
不分彼此的程度(只要求在interfaces中的user段中加上Windows即可,而这一步Delphi<br>
会自动为您做到),VB则相当繁琐。以调用获得Windows系统子目录的API函数为例<br>
,我们来看一下二者有什么不同:API函数格式的描述:WORD 
GetSystemDirectory(lpBuffer,<br>
nSize)</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; VB 4.0调用时首先要做如下申明:</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; Declare Function GetSystemDirectory 
Lib&quot;kernel32&quot;(ByVal</font><big><big><big> <br>
</big></big></big><font size="3">lpBuffer As String, ByValnSize As Long)As Long</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 然后才能使用:</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; Dim lpBuffer As String *255</font><big><big><big> 
<br>
</big></big></big><font size="3"> 
&nbsp;&nbsp;&nbsp; Size&amp;=GetSystemDirectory(lpBuffer,255)</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 而Delphi只需像调用内部函数那样:</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; var lpBuffer:PChar;{API函数必须使用null结尾的字符串}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; Size:WORD;{返回的系统子目录字符串实际长度}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; begin lpBuffer:=StrAlloc(255);{预留字符串长度}</font><big><big><big> 
<br>
</big></big></big><font size="3"> 
&nbsp;&nbsp;&nbsp; Size:=GetSystemDirectory(lpBuffer,255);end;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 由此可见,Delphi是可以充分利用Windows 
API来扩展其自身功能的。当然,在大<br>
多数情况下,Delphi本身的函数功能已经足够使用了。但是,在有些情况下,需要使<br>
用API函数来实现一些特殊的功能或完善Delphi的一些功能。下面提供两个实例<br>
来说明这一点。</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 一、信息框函数MsgBox</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 信息框是Windows应用程序中使用得较多的一种对话机制,它被广泛地用于提<br>
示、选择程序走向,是一个重要的程序控制手段。Delphi提供的信息框函数MessageDlg<br>
功能比较强,其最大优点是可以任意设定信息框的按钮(使用了集合类型),但其缺<br>
点也是很明显的,主要表现在标题字符串不能由用户自己设置;窗口弹出时寂静无声<br>
;按钮不能随着Windows的不同语言的版本显示不同的文字(例如无论在哪种语言版</font><big><big><big><br>
</big></big></big><font size="3">本下都只能显示&quot;OK&quot;、&quot;Yes&quot;等英文字符)。这些优点和缺点都是由于它是Delphi<br>
自己实现的,而不是通过调用系统API函数实现的,故不能使用系统的语言环境、<br>
多媒体等资源。这样,所开发的程序在中文版中显示信息框时与周围的窗口显得<br>
极不协调。而VB在这方面却做得较好,所以我们按照VB的格式自定义一个信息<br>
框函数MsgBox。下面的函数都假定是在TForml中定义的。为了使用方便,我们首<br>
先在Interfaces段中定义一些符号常量:</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; const</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {第一组:按钮内容选择}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; OKOnly=0;{仅显示&quot;确定&quot;按钮}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; OKCancel=1;{显示&quot;确定&quot;和&quot;取消&quot;按钮}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; AbortRetryIgnore=2;{&quot;中止&quot;&quot;重试&quot;&quot;放弃&quot;}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; YesNoCancel=3;{&quot;是&quot;&quot;否&quot;&quot;取消&quot;}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; YesNo=4;{&quot;是&quot;和&quot;否&quot;}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; RetryCancel=5;{&quot;重试&quot;&quot;取消&quot;}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; {第二组:显示图标选择}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; Critical=16;{&quot;STOP&quot;图标}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; Question=32;{&quot;?&quot;图标}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; Excalamation=48;{&quot;!&quot;图标}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; Information=64;{&quot;i&quot;图标}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; {第三组:缺省指针位置(激活状态)}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; DefaultButton1=0;{第一按钮}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; DefaultButton2=256{第二按钮}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; DefaultButton3=512{第三按钮}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; {第四组:信息框方式}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; ApplicationModal=0;{应用方式}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; SystemModal=4096;{系统方式}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 然后,建立函数MsgBox,由于API函数中使用的字符串必须以mull结尾,所以使用了另<br>
一个自定义的函数StrToPch来将Pascal类型字符串转换成为以mull结尾的字符串。参<br>
数说明 msg为信息框标题变量; mbType为规定信息框类型的变量,使用方式是&quot;mbType=<br>
按钮内容+图标+缺省指针+信息框方式&quot;。便如您想得到一个含&quot;确定&quot;和&quot;取消&quot;两个按<br>
钮、带&quot;?&quot;图标、缺省指针指向第二个按钮(即&quot;取消&quot;)的信息框,那么就该这样设置:<br>
mbType:=OKCancel+Question+DefaultButton2;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; title为信息框中显示文本的变量。</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; MsgBox的返回值与MessageDlg函数的返回值完全一样,例如返回mrYes表示&quot;Yes&quot;或<br>
&quot;是&quot; 按钮被按下,mrNo表示&quot;No&quot;或&quot;否&quot;按钮被按下等等。可参考MessageDlg函数的说<br>
明。下面即是在Delphi中通过调用Windows API的GetActive Windows函数和MessageBox<br>
函数来实现MsgBox函数的代码:{信息框函数}</font><big><big><big><br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; function 
TForm1.MsgBox(msg:string;mbType:Word;title:stri</font><big><big><big> <br>
</big></big></big><font size="3">ng):Word;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; var hWnd:HWND;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 1pText,!pCaption:Pchar;</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; begin</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1pText:=StrToPch(title);</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 1pCaption=StrToPch(msg);</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; hWnd:=GetActiveWindow();</font><big><big><big> 
<br>
</big></big></big><font size="3"> 
&nbsp;&nbsp;&nbsp; MsgBox:=MessageBox(hWnd,1pText,1pCaption,mbType);</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; end;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; {将Pascal字符串转换成null结尾字符串函数}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; function 
TForm1.StrToPch(Str:string):PChar;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; var</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; a:PChar;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; begin</font><big><big><big> <br>
</big></big></big><font size="3"> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a:=StrAlloc(Length(Str)+1);</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StrPCopy(a,Str);</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; StrToPch:=a;</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; end;</font><big><big><big> </big></big></big></p>

<p><font size="3">&nbsp;&nbsp;&nbsp; 二、文件拷贝函数CopyFDelphi提供了一组比较完整的文件操作函数,用它们可以完<br>
成几乎全部的文件操作,但恰恰缺少拷贝文件的函数。而文件拷贝的使用应该说是比<br>
较常用的,因此,笔者利用几个API函数定义了一个功能很强的文件拷贝函数CopyF。<br>
该函数代码如下(请注意:该函数中调用了上述的MsgBox函数):</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; {文件拷贝函数}</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; function TForm1.CopyF(var 
ExistingFileName:string;const</font><big><big><big> <br>
</big></big></big><font size="3">NewFileName:string; var Mode:Integer):Boolean;</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; var</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EFile,NFile:PChar;</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; CpFlag,FailIfExists:Boolean;</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; msg:string;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; ErrID,mbType:integer;</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; begin</font><big><big><big> <br>
</big></big></big><font size="3"> 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; EFile:=StrToPch(ExistingFileName);</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; NFile:=StrToPch(NewFileName);</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; if (Mode=1) or (Mode=3) then 
FailIfExists:=True</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; else FailIfExists:=False;</font><big><big><big> 
<br>
</big></big></big><font size="3"> 
&nbsp;&nbsp;&nbsp; CpFlag:=CopyFile(EFile,NFile,FailIfExists);</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; if not CpFlag then</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; begin</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ErrID:=GetLastError();</font><big><big><big> 
<br>
</big></big></big><font size="3"> 
&nbsp;&nbsp;&nbsp; ExistingFileName:=SysErrorMessage(ErrID);</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; if Mode&lt;2 then</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; begin</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; msg:='CopyFile Error!';</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; mbType:=OKOnly+Excalamation;</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; MsgBox(msg,mbType,ExistingFileName);</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; end;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; Mode:=ErrID;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; end;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; CopyF:=CpFlag;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; end;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; CopyF函数参数说明如下:</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 若拷贝操作成功,函数CopyF返回True,失败函数CopyF返回False。</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; ExistingFileName是字符变量,输入时代表源文件名。若操作失败,则返回错误信息字符<br>
串(由于调用了API函数,在中文Windows下该信息当然就是中文)。 
NewFileName是字符<br>
常量,代表目标文件名。</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; Mode是整数变量,输入时代表拷贝的方式:</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 0表示如果目标文件存在,将覆盖它,操作失败,将显示具有出错信</font><big><big><big> 
<br>
</big></big></big><font size="3">息的信息框;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 1表示如果目标文件存在,不覆盖它,操作失败,显示具有出错信息</font><big><big><big> 
<br>
</big></big></big><font size="3">的信息框;</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 2表示如果目标文件存在,将覆盖它,操作失败,不显示信息框;</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 3表示如果目标文件存在,不覆盖它,操作失败,不显示信息框;</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 当拷贝操作失败时,Mode将返回出错代码。</font><big><big><big> 
<br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; 总之,灵活应用API函数可以使您的应用程序的界面与您使用的Windows的语言环境相<br>
当和谐地融为一体,摆脱掉Delphi的痕迹,使您的程序给人以相当&quot;专业&quot;的感觉。最后说明<br>
一点,如果要使这些自定义的函数成为&quot;全局&quot;的,在其它单元中也能够使用,需将函数标题<br>
复制到Unitl单元interfaces的type段中(应删除&quot;TForml.&quot;几个字符);然后在调用函数的其他单<br>
元implementation中的user段中加入Unitl;在函数名前要加上&quot;Form1.&quot;几个字符,如在Unit2单<br>
元中调用MsgBox就应写成Form1.MsgBox。</font><big><big><big> <br>
</big></big></big><font size="3">&nbsp;&nbsp;&nbsp; (以上所有函数均在Windows 95中文版使用Delphi 
Desktop V2.0</font><big><big><big> <br>
</big></big></big><font size="3">调试通过)</font><big><big><big> </big></big></big></p>
</body>
</html>
