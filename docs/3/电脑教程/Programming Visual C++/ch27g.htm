<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Structured Storage and Persistent COM Objects</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="617"><H1><B>Structured Storage and Persistent COM Objects</B></H1></A>
<P>The EX27A program explicitly called member functions of <I>IStorage</I> and <I>IStream</I> to write and read a compound file. In the object-oriented world, objects should know how to save and load themselves to and from a compound file. That's what the <I>IPersistStorage</I> and 
<I>IPersistStream</I> interfaces are for. If a COM component implements these interfaces, a container program can &quot;connect&quot; the object to a compound file by passing the file's <I>IStorage</I> pointer as a parameter to the <I>Save</I> and <I>Load </I>member functions of the <I>IPersistStorage</I> interface. Such objects are said to be <U>persistent</U>. Figure 27-3 shows the process of calling the <I>IPersistStorage::Save</I> function.

<P>A COM component is more likely to work with an <I>IStorage</I> interface than an <I>IStream</I> interface. If the COM object is associated with a particular storage, the COM component can manage substorages and streams under that storage once it gets the <I>IStorage</I> pointer. A COM component uses the <I>IStream</I> interface only if it stores all its data in an array of bytes. ActiveX controls implement the <I>IStream</I> interface for storing and loading property values.

<P><A HREF="javascript:fullSize('f27og03x.htm')"> <img src="f27og03.jpg" width=404 height=274 border=0 ALT = "Click to view at full size."> </A>

<P><!-- caption --><B>Figure 27-3.</B> <I>Calling </I>IPersistStorage::Save.<!-- /caption -->

<A NAME="618"><H2><B>The <I>IPersistStorage</I> Interface</B></H2></A>
<P>Both the <I>IPersistStorage</I> and <I>IPersistStream</I> interfaces are derived from <I>IPersist</I>, which contributes the <I>GetClassID</I> member function. Here's a summary of 
the <I>IPersistStorage</I> member functions:

<A NAME="619"><H3><B>HRESULT GetClassID(CLSID* <I>pClsid</I>);</B></H3></A>
<P>Returns the COM component's 128-bit class identifier.

<A NAME="620"><H3><B>HRESULT InitNew(IStorage* <I>pStg</I>);</B></H3></A>
<P>Initializes a newly created object. The component might need to use the storage for temporary data, so the container must provide an <I>IStorage</I> pointer that's valid for the life of the object. The component should call <I>AddRef</I> if it intends to use the storage. The component should not use this <I>IStorage</I> pointer for saving and loading; it should wait for <I>Save</I> and <I>Load</I> calls and then use the passed-in <I>IStorage</I> pointer to call <I>IStorage::Write</I> and <I>Read</I>.

<A NAME="621"><H3><B>HRESULT IsDirty(void);</B></H3></A>
<P>Returns <I>S_OK</I> if the object has changed since it was last saved; otherwise, returns <I>S_FALSE</I>.

<A NAME="622"><H3><B>HRESULT Load(IStorage* <I>pStg</I>);</B></H3></A>
<P>Loads the COM object's data from the designated storage.

<A NAME="623"><H3><B>HRESULT Save(IStorage* <I>pStg</I>, BOOL <I>fSameAsLoad</I>);</B></H3></A>
<P>Saves the COM object's data in the designated storage.

<A NAME="624"><H2><B>The <I>IPersistStream</I> Interface</B></H2></A>
<P>Here's a summary of the <I>IPersistStream </I>member functions:

<A NAME="625"><H3><B>HRESULT GetClassID(CLSID* <I>pClsid</I>);</B></H3></A>
<P>Returns the COM component's 128-bit class identifier.

<A NAME="626"><H3><B>HRESULT GetMaxSize(ULARGE_INTEGER* <I>pcbSize</I>);</B></H3></A>
<P>Returns the number of bytes needed to save the object.

<A NAME="627"><H3><B>HRESULT IsDirty(void);</B></H3></A>
<P>Returns <I>S_OK</I> if the object has changed since it was last saved; otherwise, returns <I>S_FALSE</I>.

<A NAME="628"><H3><B>HRESULT Load(IStream* <I>pStm</I>);</B></H3></A>
<P>Loads the COM object's data from the designated stream.

<A NAME="629"><H3><B>HRESULT Save(IStream* <I>pStm</I>, BOOL <I>fClearDirty</I>);</B></H3></A>
<P>Saves the COM object's data to the designated stream. If the <I>fClearDirty</I> parameter is <I>TRUE</I>, <I>Save</I> clears the object's dirty flag.

<A NAME="630"><H2><B><I>IPersistStream</I> Programming</B></H2></A>
<P>The following container program code fragment creates a stream and saves a COM object's data in it. Both the <I>IPersistStream</I> pointer for the COM object and the <I>IStorage</I> pointer are set elsewhere.

<P><pre>
extern IStorage* pStg;
extern IPersistStream* pPersistStream;
IStream* pStream;
if (pStg-&gt;CreateStream(L&quot;MyStreamName&quot;,
    STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
    0, 0, &amp;pStream) == S_OK) {
    ASSERT(pStream != NULL);
    pPersistStream-&gt;Save(pStream, TRUE);
    pStream-&gt;Release();
}
</pre>

<P>If you program your own COM class for use in a container, you'll need to use the MFC interface macros to add the <I>IPersistStream</I> interface. Too bad there's not an &quot;interface wizard&quot; to do the job.

</BODY>
</HTML>



