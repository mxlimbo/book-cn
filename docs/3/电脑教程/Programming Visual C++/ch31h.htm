<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The EX31A Program Elements</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="775"><H1>The EX31A Program Elements</H1></A><P>Let's take a look at the major elements in the EX31A program.
<A NAME="776"><H2>Connecting the Recordset Class to the Application</H2></A><P>When ClassWizard generates the <I>CEx31aSet</I> class, it adds the CPP and H 
files to the project&#151;and that's all it does. It's up to you to link the recordset to 
your view and to your document. By embedding a 
<I>CEx31aSet</I> object inside the 
<I>CEx31aDoc</I> class, you ensure that the recordset object will be constructed 
when the application starts.
<P>The view could always get the recordset from the document, but it's 
more efficient if the view has its own recordset pointer. Notice how the view's 
<I>OnInitialUpdate</I> function sets the <I>m_pSet 
</I>data member.
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
If you run AppWizard with either of the Database 
View options, AppWizard generates a class derived from 
<I>CRecordset</I>, a class derived from <I>CRecordView 
</I>(for ODBC), and all the necessary linkage as just described. We're not using AppWizard in this mode 
because we don't want a form-based application.
</BLOCKQUOTE></DIV>
<A NAME="777"><H2>The <I>CEx31aView</I> Class's <I>OnInitialUpdate</I> Member Function</H2></A><P>The job of the 
<I>CEx31aView::OnInitialUpdate</I> function is to open the 
recordset that's associated with the view. The recordset constructor was called with 
a <I>NULL</I> database pointer parameter, so 
the<I> CRecordset::Open</I> function knows it must construct a 
<I>CDatabase</I> object and link that database one to one with 
the recordset. But how does <I>Open</I> know what data source and table to 
use? It calls two <I>CRecordset</I> virtual functions, 
<I>GetDefaultConnect</I> and <I>GetDefaultSQL</I>. 
ClassWizard generates implementations of these functions in your derived 
recordset class, as shown here:
<P><PRE>CString CEx31aSet::GetDefaultConnect()
{
    return _T(&quot;ODBC;DSN=Student Registration&quot;);
}

CString CEx31aSet::GetDefaultSQL()
{
    return _T(&quot;[Student]&quot;);
}</PRE>
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
ClassWizard and AppWizard place brackets around 
all column and table [names]. These brackets are necessary only if 
the names contain embedded blanks.
</BLOCKQUOTE></DIV>
<P><I>GetDefaultSQL</I> is a pure virtual function, so the derived class must 
implement it. <I>GetDefaultConnect</I>, on the other hand, has a base class 
implementation that opens an ODBC dialog box, which in turn prompts the user for 
the data source name.
<P>Because documents and views are reused in SDI applications, the 
<I>OnInitialUpdate</I> function must close any open recordset before it opens a 
new recordset. The <I>CRecordSet::IsOpen</I> member function is used to test this.
<A NAME="778"><H2>The <I>CEx31aView</I> Class's <I>OnDraw</I> Member Function</H2></A><P>As in any document_view application, the 
<I>CEx31aView::OnDraw</I> function is called every time the view is invalidated and once for every printed page. 
Here <I>OnDraw</I> inefficiently slogs through every row in the recordset and paints 
its column values with the <I>CDC::TextOut</I> function. The principal 
<I>CRecordset</I> member functions it calls are 
<I>MoveFirst</I> and <I>MoveNext</I>. 
<I>MoveFirst</I> will fail if the recordset is empty, so the initial call to 
<I>CRecordset::IsBOF</I> is necessary to detect the beginning-of-file condition. The 
<I>CRecordset::IsEOF</I> call detects the end-of-file condition for the recordset and terminates the row loop.
<P>Remember that ClassWizard generated 
<I>CEx31aSet</I> class data members for the recordset's columns. This means that the recordset class and now the 
view class are both hard-coded for the student record. The 
<I>CRecordset</I> member functions call a pure virtual function, 
<I>DoFieldExchange</I>, that ClassWizard generates based on the data members 
<I>m_StudentID</I>, <I>m_Name</I>, and 
<I>m_GradYear</I>. Here is the code for this example's derived recordset class:
<P><PRE>void CEx31aSet::DoFieldExchange(CFieldExchange* pFX)
{
    //{{AFX_FIELD_MAP(CEx31aSet)
    pFX-&gt;SetFieldType(CFieldExchange::outputColumn);
    RFX_Long(pFX, _T(&quot;[StudentID]&quot;), m_StudentID);
    RFX_Text(pFX, _T(&quot;[Name]&quot;), m_Name);
    RFX_Int(pFX, _T(&quot;[GradYear]&quot;), m_GradYear);
    //}}AFX_FIELD_MAP
}</PRE>
<P>Each SQL data type has a record field exchange (RFX) function. 
RFX functions are quite complex and are called many times during database 
processing. You might think at first that the RFX functions are like the 
<I>CDialog</I> DDX functions and thus actually transfer data between the database and the data 
members. This is not the case. The primary purpose of the RFX functions is to 
<U>bind</U> the database columns to the data members so that the underlying ODBC 
functions, such as <I>SQLExtendedFetch</I>, can transfer the column data. To this end, 
the <I>DoFieldExchange</I> function is called from 
<I>CRecordSet::Open</I>. <I>DoFieldExchange</I> is also called by the 
<I>Move</I> functions for the purpose of reallocating strings 
and clearing status bits.
<P>Because the <I>DoFieldExchange</I> function is so tightly integrated with 
MFC database processing, you are advised not to call this function directly in 
your programs.
</BODY>
</HTML>



