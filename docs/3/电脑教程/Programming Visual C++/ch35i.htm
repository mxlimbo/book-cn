<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>ISAPI Filters</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="953"><H1>ISAPI Filters</H1></A><P>An ISAPI server extension DLL is loaded the first time a client references it 
in a GET or POST request. An ISAPI filter DLL is loaded (based on a 
Registry entry) when the WWW service is started. The filter is then in the loop for 
<U>all</U> HTTP requests, so you can read and/or change any data that enters or 
leaves the server.
<A NAME="954"><H2>Writing an ISAPI Filter DLL</H2></A><P>The ISAPI Extension Wizard makes writing filters as easy as writing server 
extensions. Choose Generate A Filter Object, and Step 2 looks like this.
<P><A HREF="javascript:fullSize('g35og03x.htm')"> <img src="g35og03.jpg" width=404 height=325 border=0 ALT = "Click to view at full size."> </A>
<P>The list of options under Which Notifications Will Your Filter 
Process? refers to seven places where your filter can get control during the processing 
of an HTTP request. You check the boxes, and the wizard generates the code.
<A NAME="955"><H2>The MFC ISAPI Filter Classes</H2></A><P>There are two MFC classes for ISAPI filters, 
<I>CHttpFilter</I> and <I>CHttpFilterContext</I>.
<A NAME="956"><H3><I>CHttpFilter</I></H3></A><P>With the help of the ISAPI Extension Wizard, you derive a class from 
<I>CHttpFilter</I> for each ISAPI filter you create. There's just one object of this class. 
The class has virtual functions for each of seven notifications. The list of filters in 
the order in which IIS calls them is below.
<P><PRE>virtual DWORD OnReadRawData(CHttpFilterContext* pCtxt,
                            PHTTP_FILTER_RAW_DATA pRawData);
virtual DWORD OnPreprocHeaders(CHttpFilterContext* pCtxt,
                               PHTTP_FILTER_PREPROC_HEADERS pHeaderInfo);
virtual DWORD OnUrlMap(CHttpFilterContext* pCtxt,

                       PHTTP_FILTER_URL_MAP pMapInfo);
virtual DWORD OnAuthentication(CHttpFilterContext* pCtxt,
                               PHTTP_FILTER_AUTHENT pAuthent);
virtual DWORD OnSendRawData(CHttpFilterContext* pCtxt,
                            PHTTP_FILTER_RAW_DATA pRawData);
virtual DWORD OnLog(CHttpFilterContext* pfc, PHTTP_FILTER_LOG pLog);
virtual DWORD OnEndOfNetSession(CHttpFilterContext* pCtxt);</PRE>
<P>If you override a function, you get control. It would be inefficient, 
however, if IIS made virtual function calls for every notification for each 
transaction. Another virtual function, 
<I>GetFilterVersion</I>, is called once when the filter is 
loaded. The ISAPI Extension Wizard always overrides this function for you, and it 
sets flags in the function's <I>pVer</I> parameter, depending on which notifications 
you want. Here's a simplified sample with all the flags set:
<P><PRE>BOOL CMyFilter::GetFilterVersion(PHTTP_FILTER_VERSION pVer)
{
    CHttpFilter::GetFilterVersion(pVer);
    pVer-&gt;dwFlags |= SF_NOTIFY_ORDER_LOW | SF_NOTIFY_NONSECURE_PORT | 
        SF_NOTIFY_LOG | SF_NOTIFY_AUTHENTICATION | 
        SF_NOTIFY_PREPROC_HEADERS | SF_NOTIFY_READ_RAW_DATA | 
        SF_NOTIFY_SEND_RAW_DATA | SF_NOTIFY_URL_MAP | 
        SF_NOTIFY_END_OF_NET_SESSION;
    return TRUE;
}</PRE>
<P>If you had specified URL mapping requests only, the wizard would 
have set only the <I>SF_NOTIFY_URL_MAP</I> flag and it would have overridden 
only <I>OnUrlMap</I>. IIS would not call the other virtual functions, even if they 
were overridden in your derived class.
<A NAME="957"><H3><I>CHttpFilterContext</I></H3></A><P>An object of this second MFC class exists for each server transaction, and 
each of the notification functions gives you a pointer to that object. The 
<I>CHttpFilterContext</I> member functions you might call are 
<I>GetServerVariable</I>, 
<I>AddResponseHeaders</I>, and <I>WriteClient</I>.
</BODY>
</HTML>



