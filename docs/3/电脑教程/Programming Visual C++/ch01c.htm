<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The Visual C++ Components</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="10"><H1>The Visual C++ Components</H1></A><P>Microsoft Visual C++ is two complete Windows application development systems in one product. If you so choose, you can develop C-language Windows programs using only the Win32 API. C-language Win32 programming is described in Charles Petzold's book <I>Programming Windows 95</I> (Microsoft Press, 1996). You can use many Visual 
C++ tools, including the resource editors, to make low-level Win32 programming easier.
<P>Visual C++ also includes the ActiveX Template Library (ATL), which 
you can use to develop ActiveX controls for the Internet. ATL 
programming is neither Win32 C-language programming nor MFC programming, and 
it's complex enough to deserve its own book.
<P>This book is not about C-language Win32 programming or ATL 
programming (although <A HREF="ch29a.htm">Chapter 29</A> and <A HREF="ch30a.htm">Chapter 30</A> provide an introduction to ATL). It's 
about C++ programming within the MFC library application framework that's 
part of Visual C++. You'll be using the C++ classes documented in the 
<I>Microsoft Visual C++ MFC Library Reference </I>(Microsoft Press, 
1997)<I>,</I> and you'll also be using application framework-specific Visual 
C++ tools such as AppWizard and ClassWizard.
<p>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><p>

Use of the MFC library programming interface doesn't 
cut you off from the Win32 functions. In fact, you'll almost always 
need some direct Win32 calls in your MFC library programs.
</BLOCKQUOTE>
</DIV>
<P>A quick run-through of the Visual C++ components will help you get 
your bearings before you zero in on the application framework. Figure 1-1 shows 
an overview of the Visual C++ application build process.
<P><A HREF="javascript:fullSize('f01og01x.htm')"> <img src="f01og01.jpg" width=404 height=362 border=0 ALT = "Click to view at full size."> </A><p>
<!-- caption -->
<B>Figure 1-1.</B> <I>The Visual C++ application build process.</I>
<!-- /caption -->
<p>
<A NAME="11"><H2>Microsoft Visual C++ 6.0 and the Build Process</H2></A><P>Visual Studio 6.0 is a suite of developer tools that includes Visual 
C++ 6.0. The Visual C++ IDE is shared by several tools including Microsoft Visual 
J++. The IDE has come a long way from the original Visual Workbench, which was 
based on QuickC for Windows. Docking windows, configurable toolbars, 
plus a customizable editor that runs macros, are now part of Visual Studio. The 
online help system (now integrated with the MSDN Library viewer) works like a 
Web browser. Figure 1-2 shows Visual C++ 6.0 in action.
<A NAME="100"></A>
<P><A HREF="javascript:fullSize('F01OG02x.htm')"> <img src="F01OG02.JPG" width=404 height=329 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 1-2.</B> <I>Visual C++ 6.0 windows.</I>
<!-- /caption -->
<P>If you've used earlier versions of Visual C++ or another vendor's IDE, 
you already understand how Visual C++ 6.0 operates. But if you're new to 
IDEs, you'll need to know what a <U>project</U> is. A project is a collection of 
interrelated source files that are compiled and linked to make up an executable 
Windows-based program or a DLL. Source files for each project are generally stored in 
a separate subdirectory. A project depends on many files outside the 
project subdirectory too, such as include files and library files.
<P>Experienced programmers are familiar with makefiles. A 
<U>makefile</U> stores compiler and linker options and expresses all the interrelationships among 
source files. (A source code file needs specific include files, an executable file 
requires certain object modules and libraries, and so forth.) A 
<U>make</U> <U>program</U> reads the makefile and then invokes the compiler, assembler, resource compiler, and linker to produce the final output, which is generally an executable file. The 
make program uses built-in inference rules that tell it, for example, to invoke 
the compiler to generate an OBJ file from a specified CPP file.
<P>In a Visual C++ 6.0 project, there is no makefile (with an MAK 
extension) unless you tell the system to export one. A text-format 
<U>project</U> <U>file</U> (with a DSP extension) serves the same purpose. A separate text-format 
<U>workspace</U> <U>file</U> (with a DSW extension) has an entry for each project in the workspace. It's 
possible to have multiple projects in a workspace, but all the examples in this book 
have just one project per workspace. To work on an existing project, you tell 
Visual C++ to open the DSW file and then you can edit and build the project.
<P>Visual C++ creates some intermediate files too. The following table 
lists the files that Visual C++ generates in the workspace.<p>

<table width="95%" cellpadding="5">
<tr><td valign="top"><b>File Extension</b></td><td valign="top"><b>Description</b></td></tr>
<tr><td valign="top">APS</td><td valign="top">Supports ResourceView</td></tr>
<tr><td valign="top">BSC</td><td valign="top">Browser information file</td></tr>
<tr><td valign="top">CLW</td><td valign="top">Supports ClassWizard</td></tr>
<tr><td valign="top">DEP</td><td valign="top">Dependency file</td></tr>
<tr><td valign="top">DSP</td><td valign="top">Project file*</td></tr>
<tr><td valign="top">DSW</td><td valign="top">Workspace file*</td></tr>
<tr><td valign="top">MAK</td><td valign="top">External makefile</td></tr>
<tr><td valign="top">NCB</td><td valign="top">Supports ClassView</td></tr>
<tr><td valign="top">OPT</td><td valign="top">Holds workspace configuration</td></tr>
<tr><td valign="top">PLG</td><td valign="top">Builds log file</td></tr>
</table>

<P>*     Do not delete or edit in a text editor.

<A NAME="12"><H2>The Resource Editors&#151;Workspace ResourceView</H2></A><P>When you click on the ResourceView tab in the Visual 
C++ Workspace window, you can select a resource for editing. The main window hosts a 
<U>resource</U> <U>editor</U> appropriate for the resource type. The window can also host a wysiwyg 
editor for menus and a powerful graphical editor for dialog boxes, and it includes 
tools for editing icons, bitmaps, and strings. The dialog editor allows you to 
insert ActiveX controls in addition to standard Windows controls and the new 
Windows common controls (which have been further extended in Visual 
C++ 6.0). Chapter 3 shows pictures of the ResourceView page and one of the 
resource editors (the dialog editor).
<P>Each project usually has one text-format resource script (RC) file 
that describes the project's menu, dialog, string, and accelerator resources. The 
RC file also has <I>#include</I> statements to bring in resources from other 
subdirectories. These resources include project-specific items, such as bitmap (BMP) and 
icon (ICO) files, and resources common to all Visual 
C++ programs, such as error message strings. Editing the RC file outside the resource editors is not 
recommended. The resource editors can also process EXE and DLL files, so you 
can use the clipboard to &quot;steal&quot; resources, such as bitmaps and icons, from 
other Windows applications.
<A NAME="13"><H2>The C/C++ Compiler</H2></A><P>The Visual C++ compiler can process both C source code and 
C++ source code. It determines the language by looking at the source code's filename 
extension. A C extension indicates C source code, and CPP or CXX indicates 
C++ source code. The compiler is compliant with all ANSI standards, including the 
latest recommendations of a working group on C++ libraries, and has 
additional Microsoft extensions. Templates, exceptions, and runtime type 
identification (RTTI) are fully supported in Visual 
C++ version 6.0. The C++ Standard Template Library (STL) is also included, although it is not integrated into the MFC library.
<A NAME="14"><H2>The Source Code Editor</H2></A><P>Visual C++ 6.0 includes a sophisticated source code editor that supports 
many features such as dynamic syntax coloring, auto-tabbing, keyboard bindings 
for a variety of popular editors (such as VI and EMACS), and pretty printing. 
In Visual C++ 6.0, an exciting new feature named AutoComplete has been 
added. If you have used any of the Microsoft Office products or Microsoft Visual 
Basic, you might already be familiar with this technology. Using the Visual 
C++ 6.0 AutoComplete feature, all you have to do is type the beginning of a 
programming statement and the editor will provide you with a list of 
possible completions to choose from. This feature is extremely handy when you 
are working with C++ objects and have forgotten an exact member function or 
data member name&#151;they are all there in the list for you. You no longer have 
to memorize thousands of Win32 APIs or rely heavily on the online help 
system, thanks to this new feature.
<A NAME="15"><H2>The Resource Compiler</H2></A><P>The Visual C++ resource compiler reads an ASCII resource script (RC) file 
from the resource editors and writes a binary RES file for the linker.
<A NAME="16"><H2>The Linker</H2></A><P>The linker reads the OBJ and RES files produced by the 
C/C++ compiler and the resource compiler, and it accesses LIB files for MFC code, runtime 
library code, and Windows code. It then writes the project's EXE file. An 
incremental link option minimizes the execution time when only minor changes have 
been made to the source files. The MFC header files contain 
<I>#pragma </I>statements (special compiler directives) that specify the required library files, so you 
don't have to tell the linker explicitly which libraries to read.
<A NAME="17"><H2>The Debugger</H2></A><P>If your program works the first time, you don't need the debugger. The rest 
of us might need one from time to time. The Visual 
C++ debugger has been steadily improving, but it doesn't actually fix the bugs yet. The debugger works 
closely with Visual C++ to ensure that breakpoints are saved on disk. Toolbar 
buttons insert and remove breakpoints and control single-step execution. Figure 
1-3 illustrates the Visual C++ debugger in action. Note that the Variables and Watch
windows can expand an object pointer to show all data members of the 
derived class and base classes. If you position the cursor on a simple variable, the 
debugger shows you its value in a little window. To debug a program, you 
must build the program with the compiler and linker options set to generate 
debugging information.
<P><A HREF="javascript:fullSize('F01OG03x.htm')"> <img src="F01OG03.JPG" width=404 height=363 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 1-3.</B> <I>The Visual C++ debugger window.</I>
<!-- /caption -->

<P>Visual C++ 6.0 adds a new twist to debugging with the Edit And 
Continue feature. Edit And Continue lets you debug an application, change the 
application, and then continue debugging with the new code. This feature 
dramatically reduces the amount of time you spend debugging because you 
no longer have to manually leave the debugger, recompile, and then debug 
again. To use this feature, simply edit any code while in the debugger and then hit 
the continue button. Visual C++ 6.0 automatically compiles the changes 
and restarts the debugger for you.
<A NAME="18"><H2>AppWizard</H2></A><P>AppWizard is a code generator that creates a working skeleton of a 
Windows application with features, class names, and source code filenames that you 
specify through dialog boxes. You'll use AppWizard extensively as you work 
through the examples in this book. Don't confuse AppWizard with older code 
generators that generate all the code for an application. AppWizard code is 
minimalist code; the functionality is inside the application framework base classes. 
AppWizard gets you started quickly with a new application.
<P>Advanced developers can build custom AppWizards. Microsoft 
Corporation has exposed its macro-based system for generating projects. If you 
discover that your team needs to develop multiple projects with a 
telecommunications interface, you can build a special wizard that automates the process.
<A NAME="19"><H2>ClassWizard</H2></A><P>ClassWizard is a program (implemented as a DLL) that's accessible from 
Visual C++'s View menu. ClassWizard takes the drudgery out of maintaining 
Visual C++ class code. Need a new class, a new virtual function, or a new 
message-handler function? ClassWizard writes the prototypes, the function bodies, 
and (if necessary) the code to link the Windows message to the function. 
ClassWizard can update class code that you write, so you avoid the maintenance 
problems common to ordinary code generators. Some ClassWizard features are 
available from Visual C++'s WizardBar toolbar, shown in Figure 
1-2.
<A NAME="20"><H2>The Source Browser</H2></A><P>If you write an application from scratch, you probably have a good mental 
picture of your source code files, classes, and member functions. If you take 
over someone else's application, you'll need some assistance. The Visual 
C++ Source Browser (the browser, for short) lets you examine (and edit) an application 
from the class or function viewpoint instead of from the file viewpoint. It's a little 
like the &quot;inspector&quot; tools available with object-oriented libraries such as 
Smalltalk. The browser has the following viewing modes:
<UL>
<LI><B>Definitions and 
References</B>&#151;You select any function, 
variable, type, macro, or class and then see where it's defined and used 
in your project.<p>
<LI><B>Call Graph/Callers 
Graph</B>&#151;For a selected function, you'll see 
a graphical representation of the functions it calls or the 
functions that call it.<p>
<LI><B>Derived Classes and 
Members/Base Classes and Members</B>&#151;These are graphical class hierarchy diagrams. For a selected class, you see the derived classes or the base classes plus members. You 
can control the hierarchy expansion with the mouse.<p>
<LI><B>File Outline</B>&#151;For a selected file, the classes, functions, and 
data members appear together with the places in which they're 
defined and used in your project.<p>
</UL>
<P>A typical browser window is shown in <A HREF="ch03a.htm">Chapter 3</A>.
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><p>
If you rearrange the lines in any source code file, Visual 
C++ regenerates the browser database when you rebuild the project. 
This increases the build time.
</BLOCKQUOTE>
</DIV>
<P>In addition to the browser, Visual C++ has a ClassView option that 
does not depend on the browser database. You get a tree view of all the classes in 
your project, showing member functions and data members. Double-click on 
an element, and you see the source code immediately. The ClassView does not 
show hierarchy information, whereas the browser does.
<A NAME="21"><H2>Online Help</H2></A><P>In Visual C++ 6.0, the help system has been moved to a separate 
application named the MSDN Library Viewer. This help system is based on HTML. 
Each topic is covered in an individual HTML document; then all are combined 
into indexed files. The MSDN Library Viewer uses code from Microsoft Internet 
Explorer 4.0, so it works like the Web browser you already know. MSDN 
Library can access the help files from the Visual 
C++ CD-ROM (the default installation option) or from your hard disk, and it can access HTML files on 
the Internet.
<P>Visual C++ 6.0 allows you to access help in four ways:
<UL>
<LI><B>By book</B>&#151;When you choose Contents from Visual 
C++'s Help menu, the MSDN Library application switches to a contents 
view. Here Visual Studio, Visual C++, Win32 SDK documentation, 
and more is organized hierarchically by books and chapters.<P>
<LI><B>By topic</B>&#151;When you choose Search from Visual 
C++'s Help menu, it automatically opens the MSDN Library Viewer. You can then 
select the Index tab, type a keyword, and see the topics and 
articles included for that keyword.<P>
<LI><B>By word</B>&#151;When you choose Search from Visual 
C++'s Help menu, it invokes the MSDN Library with the Search tab active. With 
this tab active, you can type a combination of words to view articles 
that contain those words.<P>
<LI><B>F1 help</B>&#151;This is the programmer's best friend. Just move the 
cursor inside a function, macro, or class name, and then press the F1 
key and the help system goes to work. If the name is found in 
several places&#151;in the MFC and Win32 help files, for example&#151;you 
choose the help topic you want from a list window.<P>
</UL>
<P>Whichever way you access online help, you can copy any help text to 
the clipboard for inclusion in your program.

<A NAME="22"><H2>Windows Diagnostic Tools</H2></A><P>Visual C++ 6.0 contains a number of useful diagnostic tools. 
SPY++ gives you a tree view of your system's processes, threads, and windows. It also lets 
you view messages and examine the windows of running applications. You'll 
find PVIEW (PVIEW95 for Windows 95) useful for killing errant processes 
that aren't visible from the Windows 95 task list. (The Windows NT Task 
Manager, which you can run by right-clicking the toolbar, is an alternative to 
PVIEW.) Visual C++ also includes a whole suite of ActiveX utilities, an ActiveX 
control test program (now with full source code in Visual C++ 6.0), the help 
workshop (with compiler), a library manager, binary file viewers and editors, a source 
code profiler, and other utilities.
<A NAME="23"><H2>Source Code Control</H2></A><P>During development of Visual C++ 5.0, Microsoft bought the rights to an 
established source code control product named SourceSafe. This product has 
since been included in the Enterprise Edition of Visual 
C++ and Visual Studio Enterprise, and it is integrated into Visual 
C++ so that you can coordinate large software projects. The master copy of the project's source code is stored in 
a central place on the network, and programmers can check out modules 
for updates. These checked-out modules are usually stored on the 
programmer's local hard disk. After a programmer checks in modified files, other team 
members can synchronize their local hard disk copies to the master copy. Other 
source code control systems can also be integrated into Visual 
C++.
<A NAME="24"><H2>The Gallery</H2></A><P>The Visual C++ Components and Controls Gallery lets you share 
software components among different projects. The Gallery manages three types 
of modules:
<UL>
<LI><B>ActiveX controls</B>&#151;When you install an ActiveX control 
(OCX&#151;formerly OLE control), an entry is made in the Windows 
Registry. All registered ActiveX controls appear in the Gallery's window, 
so you can select them in any project.<P>
<LI><B>C++ source modules</B>&#151;When you write a new class, you can add 
the code to the Gallery. The code can then be selected and 
copied into other projects. You can also add resources to the Gallery.<P>
<LI><B>Visual C++ components</B>&#151;The Gallery can contain tools that 
let you add features to your project. Such a tool could insert 
new classes, functions, data members, and resources into an 
existing project. Some component modules are supplied by Microsoft 
(Idle time processing, Palette support, and Splash screen, for example) 
as part of Visual C++. Others will be supplied by third-party 
soft-ware firms.<P>
</UL>
<P>
<DIV CLASS=tip>
<BLOCKQUOTE>
<IMG SRC="tip.jpg" width=123 height=18 BORDER="0"><p>
If you decide to use one of the prepackaged Visual C++ 
components, try it out first in a dummy project to see if it's what you 
really want. Otherwise, it might be difficult to remove the generated 
code from your regular project.
</BLOCKQUOTE>
</DIV>
<P>All user-generated Gallery items can be imported from and exported 
to OGX files. These files are the distribution and sharing medium for Visual 
C++ components.
<A NAME="25"><H2>The Microsoft Foundation Class Library Version 6.0</H2></A><P>The Microsoft Foundation Class Library version 6.0 (the MFC library, for 
short) is really the subject of this book. It defines the application framework that 
you'll be learning intimately. <A HREF="ch02a.htm">Chapter 2</A> gets you started with actual code and 
introduces some important concepts.
<A NAME="26"><H2>The Microsoft Active Template Library</H2></A><P>ATL is a tool, separate from MFC, for building ActiveX controls. You can 
build ActiveX controls with either MFC or ATL, but ATL controls are much 
smaller and quicker to load on the Internet. <A HREF="ch29a.htm">Chapter 29</A> and <A HREF="ch30a.htm">Chapter 30</A> provide a brief 
overview of ATL and creating ActiveX controls with ATL.
</BODY>
</HTML>



