<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Component States</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="650"><H1><B>Component States</B></H1></A>
<P>Now that you know what a handler is, you're ready for a description of the four states that an embedded object can assume.

<p>
<table cellpadding=5 width="95%">
<tr><td valign="top"><b>State</b></td>
<td valign="top"><b>Description</b></td></tr>
<tr><td valign="top">Passive</td>
<td valign="top">The object exists only in a storage.</td></tr>
<tr><td valign="top">Loaded</td>
<td valign="top">The object handler is running and has a metafile in its cache, but the EXE component program is not running.</td></tr>
<tr><td valign="top">Running</td>
<td valign="top">The EXE component program is loaded and running, but the window is not visible to the user.</td></tr>
<tr><td valign="top">Active</td>
<td valign="top">The EXE component's window is visible to the user.</td></tr>
</table>

<A NAME="651"><H2><B>The Container Interfaces</B></H2></A>
<P>Now for the container side of the conversation. Look at Figure 28-4. The container consists of a document and one or more <U>sites</U>. The <I>IOleContainer</I> interface has functions for iterating over the sites, but we won't worry about iterating over the client sites here. The important interface is <I>IOleClientSite</I>. Each site is an object that the component accesses through an <I>IOleClientSite</I> pointer. When the container creates an embedded object, it calls <I>IOleObject::SetClientSite</I> to establish one of the two connections from component to container. 
The site maintains an <I>IOleObject</I> pointer to its component object.

<P>One important <I>IOleClientSite</I> function is <I>SaveObject</I>. When the component decides it's time to save itself to its storage, it doesn't do so directly; instead, it asks the site to do the job by calling <I>IOleClientSite::SaveObject</I>. &quot;Why the indirection?&quot; you ask. The handler needs to save the metafile to the storage, that's why. The <I>SaveObject</I> function calls 
<I>IPersistStorage::Save</I> at the handler level, so the handler can do its job before calling the component's <I>Save</I> function.

<P>Another important <I>IOleClientSite</I> function is <I>OnShowWindow</I>. The component program calls this function when it starts running and when it stops running. The client is supposed to display a hatched pattern in the embedded object's rectangle when the component program is running or active.

<P><A HREF="javascript:fullSize('f28og04x.htm')"> <img src="f28og04.jpg" width=404 height=271 border=0 ALT = "Click to view at full size."> </A>

<P><!-- caption --><B>Figure 28-4.</B> <I>The interaction between the container and the component.</I><!-- /caption -->

<A NAME="652"><H2><B>The Advisory Connection</B></H2></A>
<P>Figure 28-4 shows another interface attached to the site&#151;<I>IAdviseSink</I>. This is the container's end of the second component connection. Why have another connection? The <I>IOleClientSite</I> connection goes directly from the component to the container, but the <I>IAdviseSink</I> connection is routed through the handler. After the site has created the embedded object, it calls <I>IViewObject2::SetAdvise</I>, passing its <I>IAdviseSink</I> pointer. Meanwhile, the handler has gone ahead and established <U>two</U> advisory connections to the component. When the embedded object is created, the handler calls <I>IOleObject::Advise</I> and then calls <I>IDataObject::DAdvise</I> to notify the advise sink of changes in the data object. When the component's data changes, it notifies the handler through the <I>IDataObject</I> advisory connection. When the user saves the component's data or closes the program, the component notifies the handler through the <I>IOleObject</I> advisory connection. Figure 28-5 shows these connections.

<P>When the handler gets the notification that the component's data has changed (the component calls 
<I>IAdviseSink::OnDataChange</I>), it can notify the container by calling <I>IAdviseSink::OnViewChange</I>. The container responds by calling <I>IViewObject2::Draw</I> in the handler. If the component program is not running, the handler draws its metafile from the cache. If the component program is running, the handler calls the component's <I>IDataObject::GetData</I> function to get the latest metafile, which it draws. The <I>OnClose</I> and <I>OnSave</I> notifications are passed in a similar manner.

<P><A HREF="javascript:fullSize('f28og05x.htm')"> <img src="f28og05.jpg" width=404 height=143 border=0 ALT = "Click to view at full size."> </A>

<P><!-- caption --><B>Figure 28-5.</B> <I>Advisory connection details.</I><!-- /caption -->

<A NAME="653"><H2><B>A Metafile for the Clipboard</B></H2></A>
<P>As you've just learned, the container doesn't deal with the metafile directly when it wants to draw the embedded object; instead, it calls<I> IViewObject2::Draw</I>. In one case, however, the container needs direct access to the metafile. When the container copies an embedded object to the clipboard, it must copy a metafile in addition to the embedded object and the object descriptor. That's what the 
handler's <I>IDataObject</I> interface is for. The container calls <I>IDataObject::GetData</I>, requesting a metafile format, and it copies that format into the clipboard's data object.

</BODY>
</HTML>



