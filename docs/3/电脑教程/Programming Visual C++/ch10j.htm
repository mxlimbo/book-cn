<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Optimizing Storage for Constant Data</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="210"><H1>Optimizing Storage for Constant Data</H1></A><P>Remember that the code in your program is backed not by the swap file but directly by its EXE and DLL files. If several instances of your program are running, the same EXE and DLL files will be mapped to each process's virtual address space. What about constant data? You would want that data to be part of the program rather than have it copied to another block of address space that's backed by the swap file.
<P>You've got to work a little bit to ensure that constant data gets stored with the program. First consider string constants, which often permeate your 
programs. You would think that these would be read-only data, but guess again. 
Because you're allowed to write code like this:
<P>
<PRE>char* pch = &quot;test&quot;;
*pch = `x';
</PRE>
<P>&quot;<I>test</I>&quot; can't possibly be constant data, and it isn't.
<P>If you want &quot;<I>test</I>&quot; to be a constant, you must declare it as an initialized <I>const</I> static or global variable. Here's the global definition:
<P><pre>const char g_pch[] = &quot;test&quot;;</pre>
<P>Now<I> g_pch</I> is stored with the code, but where, specifically? To answer 
that, you must understand the &quot;data sections&quot; that the Visual C++ linker generates. If you set the link options to generate a map file, you'll see a long list of the sections (memory blocks) in your program. Individual sections can be designated for code or data, and they can be read-only or read/write. The important sections and their characteristics are listed here.<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>Name</B></TD><TD VALIGN="TOP"><B>Type</B></TD><TD VALIGN="TOP"><B>Access</B></TD><TD VALIGN="TOP"><B>Contents</B></TD></TR>
<TR><TD VALIGN="TOP">.text</TD><TD VALIGN="TOP">Code</TD><TD VALIGN="TOP">Read-only</TD><TD VALIGN="TOP">Program code</TD></TR>
<TR><TD VALIGN="TOP">.rdata</TD><TD VALIGN="TOP">Data</TD><TD VALIGN="TOP">Read-only</TD><TD VALIGN="TOP">Constant initialized data</TD></TR>
<TR><TD VALIGN="TOP">.data</TD><TD VALIGN="TOP">Data</TD><TD VALIGN="TOP">Read/write</TD><TD VALIGN="TOP">Nonconstant initialized data</TD></TR>
<TR><TD VALIGN="TOP">.bss</TD><TD VALIGN="TOP">Data</TD><TD VALIGN="TOP">Read/write</TD><TD VALIGN="TOP">Nonconstant uninitialized data</TD></TR>
</TABLE>

<P>The .rdata section is part of the EXE file, and that's where the linker puts the <I>g_pch</I> variable. The more stuff you put in the .rdata section, the better. The use of the <I>const</I> modifier does the trick.
<P>You can put built-in types and even structures in the .rdata section, but you can't put C++ objects there if they have constructors. If you write a 
statement like the following one:
<P><PRE>const CRect g_rect(0, 0, 100, 100);</PRE>
<P>the linker puts the object into the .bss section, and it will be backed 
separately to the swap file for each process. If you think about it, this makes sense because the compiler must invoke the constructor function after the program is loaded.
<P>Now suppose you wanted to do the worst possible thing. You'd declare a <I>CString</I> global variable (or static class data member) like this:
<P><PRE>const CString g_str(&quot;this is the worst thing I can do&quot;);</PRE>
<P>Now you've got the <I>CString</I> object (which is quite small) in the .bss 
section, and you've also got a character array in the .data section, neither of 
which can be backed by the EXE file. To make matters worse, when the program 
starts, the <I>CString</I> class must allocate heap memory for a copy of the characters. You would be much better off using a <I>const</I> character array instead of a <I>CString</I> object.
</BODY>
</HTML>



