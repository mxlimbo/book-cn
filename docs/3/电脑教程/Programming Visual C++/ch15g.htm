<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Using the CString Class</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="302"><H1>Using the <I>CString</I> Class</H1></A>
<P>The MFC <I>CString</I> class is a significant de facto extension to the C++ language. As the <I>Microsoft Foundation</I> <I>Classes and Templates</I> section of the online help points out, the <I>CString</I> class has many useful operators and member functions, but perhaps its most important feature is its dynamic memory allocation. You never have to worry about the size of a <I>CString</I> object. The statements here represent typical uses of <I>CString</I> objects.
<PRE>CString strFirstName(&quot;Elvis&quot;);
CString strLastName(&quot;Presley&quot;);
CString strTruth = strFirstName + &quot; &quot; + strLastName; // concatenation
strTruth += &quot; is alive&quot;;
ASSERT(strTruth == &quot;Elvis Presley is alive&quot;);
ASSERT(strTruth.Left(5) == strFirstName);
ASSERT(strTruth[2] == `v'); // subscript operator</PRE>
<P>In a perfect world, C++ programs would use all <I>CString</I> objects and never use ordinary zero-terminated character arrays. Unfortunately, many runtime library functions still use character arrays, so programs must always mix and match their string representations. Fortunately, the <I>CString</I> class provides a <I>const char*() </I>operator that converts a <I>CString</I> object to a character pointer. Many of the MFC library functions have <I>const char* </I>parameters. Take the global <I>AfxMessageBox</I> function, for example. Here is one of the function's prototypes:
<P><PRE>int AFXAPI AfxMessageBox(LPCTSTR lpszText, UINT nType = MB_OK,
                         UINT nIDHelp = 0);</PRE>
<P>(Note: <I>LPCTSTR</I> is not a pointer to a <I>CString</I> object but rather is a <U>Unicode-enabled</U> replacement for <I>const char*</I>.)
<P>You can call <I>AfxMessageBox</I> this way:
<PRE>char szMessageText[] = &quot;Unknown error&quot;;
AfxMessageBox(szMessageText);</PRE>
<P>or you can call it this way:
<P><PRE>CString strMessageText(&quot;Unknown ;error&quot;);
AfxMessageBox(strMessageText);</PRE>
<P>Now suppose you want to generate a formatted string. <I>CString::Format</I> does the job, as shown here:
<PRE>int nError = 23;
CString strMessageText;
strMessageText.Format(&quot;Error number %d&quot;, nError);
AfxMessageBox(strMessageText);</PRE>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
Suppose you want direct write access to the characters in a <I>CString</I> object. If you write code like this:
<PRE>CString strTest(&quot;test&quot;);
strncpy(strTest, &quot;T&quot;, 1);</PRE>
you'll get a compile error because the first parameter of <I>strncpy</I> is declared <I>char*</I>, not <I>const char*</I>. The <I>CString::GetBuffer</I> function &quot;locks down&quot; the buffer with a specified size and returns a 
<I>char*</I>. You must call the <I>ReleaseBuffer</I> member function later to make the string dynamic again. The correct way to capitalize the <I>T</I> is shown here.
<P>
<PRE>CString strTest(&quot;test&quot;);
strncpy(strTest.GetBuffer(5), &quot;T&quot;, 1);
strTest.ReleaseBuffer();
ASSERT(strTest == &quot;Test&quot;);</PRE>
</BLOCKQUOTE></DIV>
<P>The <I>const char*</I> operator takes care of converting a <I>CString</I> object to a constant character pointer; but what about conversion in the other 
direction? It so happens that the <I>CString</I> class has a constructor that converts a constant character pointer to a <I>CString</I> object, and it has a set of overloaded operators for these pointers. That's why statements such as the following work.
<P><PRE>strTruth += &quot; is alive&quot;;</PRE>
<P>The special constructor works with functions that take a <I>CString</I> reference parameter, such as <I>CDC::TextOut</I>. In the following statement, a 
temporary <I>CString</I> object is created on the calling program's stack and then the object's address is passed to <I>TextOut</I>:
<P><PRE>pDC-&gt;TextOut(0, 0, &quot;Hello, world!&quot;);</PRE>
<P>It's more efficient to use the other overloaded version of <I>CDC::TextOut</I> if you're willing to count the characters:
<P><PRE>pDC-&gt;TextOut(0, 0, &quot;Hello, world!&quot;, 13);</PRE>
<P>If you're writing a function that takes a string parameter, you've got some design choices. Here are some programming rules.
<UL>
<P><LI>If the function doesn't change the contents of the string and you're willing to use C runtime functions such as <I>strcpy</I>, use a <I>const char*</I> parameter.
<P><LI>If the function doesn't change the contents of the string but you want to use <I>CString</I> member functions inside the function, use a <I>const CString&amp;</I>  parameter.
<P><LI>If the function changes the contents of the string, use a<I> CString&amp;</I> parameter.
</UL>
</BODY>
</HTML>



