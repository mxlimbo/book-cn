<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The FORMATETC and STGMEDIUM Structures</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="556"><H1><B>The <I>FORMATETC</I> and <I>STGMEDIUM</I> Structures</B></H1></A>
<P>Before you're ready for the <I>IDataObject</I> member functions, you need to examine two important COM structures that are used as parameter types: the <I>FORMATETC</I> structure and the 
<I>STGMEDIUM</I> structure.

<A NAME="557"><H2><B><I>FORMATETC</I></B></H2></A>
<P>The <I>FORMATETC</I> structure is often used instead of a clipboard format to represent data format information. However, unlike the clipboard format, the <I>FORMATETC</I> structure includes information about a target device, the aspect or view of the data, and a storage medium indicator. Here are the members of the <I>FORMATETC</I> structure.

<p>
<table cellpadding=5 width="95%">
<tr><td valign="top"><b>Type</b></td>
<td valign="top"><b>Name</b></td>
<td valign="top"><b>Description</b></td></tr>
<tr><td valign="top"><I>CLIPFORMAT</I></td>
<td valign="top"><I>cfFormat</I></td>
<td valign="top">Structure that contains clipboard formats, such as standard interchange formats (for example, <I>CF_TEXT</I>, which is a text format, and <I>CF_DIB</I>, which is an image compression format), custom formats (such as rich text format), and OLE formats used to create linked or embedded objects</td></tr>
<tr><td valign="top"><I>DVTARGETDEVICE</I>*</td>
<td valign="top"><I>ptd</I></td>
<td valign="top">Structure that contains information about the target device for the data, including the device driver name (can be <I>NULL</I>)</td></tr>
<tr><td valign="top"><I>DWORD</I></td>
<td valign="top"><I>dwAspect</I></td>
<td valign="top">A <I>DVASPECT</I> enumeration constant (<I>DVASPECT_CONTENT</I>, <I>DVASPECT _THUMBNAIL</I>, and so on)</td></tr>
<tr><td valign="top"><I>LONG</I></td>
<td valign="top"><I>lindex</I></td>
<td valign="top">Usually -1</td></tr>
<tr><td valign="top"><I>DWORD</I></td>
<td valign="top"><I>tymed</I></td>
<td valign="top">Specifies type of media used to transfer the object's data (TYMED_HGLOBAL, TYMED_FILE, TYMED_ISTORAGE, and so on)</td></tr>
</table>

<P>An individual data object accommodates a collection of FORMATETC elements, and the IDataObject interface provides a way to enumerate them. A useful macro for filling in a <I>FORMATETC</I> structure appears below.

<P><pre>#define SETFORMATETC(fe, cf, asp, td, med, li)   \
    ((fe).cfFormat=cf, \
    (fe).dwAspect=asp, \
    (fe).ptd=td, \
    (fe).tymed=med, \
    (fe).lindex=li)
</pre>

<A NAME="558"><H2><B><I>STGMEDIUM</I></B></H2></A>
<P>The other important structure for <I>IDataObject</I> members is the <I>STGMEDIUM</I> structure. The 
<I>STGMEDIUM </I>structure is a global memory handle used for operations involving data transfer. Here are the members.

<p>
<table cellpadding=5 width="95%">
<tr><td valign="top"><b>Type</b></td>
<td valign="top"><b>Name</b></td>
<td valign="top"><b>Description</b></td></tr>
<tr><td valign="top"><I>DWORD</I></td>
<td valign="top"><I>tymed</I></td>
<td valign="top">Storage medium value used in marshaling and unmarshaling routines</td></tr>
<tr><td valign="top"><I>HBITMAP</I></td>
<td valign="top"><I>hBitmap</I></td>
<td valign="top">Bitmap handle*</td></tr>
<tr><td valign="top"><I>HMETAFILEPICT</I></td>
<td valign="top"><I>hMetaFilePict</I></td>
<td valign="top">Metafile handle*</td></tr>
<tr><td valign="top"><I>HENHMETAFILE</I></td>
<td valign="top"><I>hEnhMetaFile</I></td>
<td valign="top">Enhanced metafile handle*</td></tr>
<tr><td valign="top"><I>HGLOBAL</I></td>
<td valign="top"><I>hGlobal</I></td>
<td valign="top">Global memory handle*</td></tr>
<tr><td valign="top"><I>LPOLESTR</I></td>
<td valign="top"><I>lpszFileName</I></td>
<td valign="top">Disk filename (double-byte)*</td></tr>
<tr><td valign="top"><I>ISTREAM</I>*</td>
<td valign="top"><I>pstm</I></td>
<td valign="top"><I>IStream</I> interface pointer*</td></tr>
<tr><td valign="top"><I>ISTORAGE</I>*</td>
<td valign="top"><I>pstg</I></td>
<td valign="top"><I>IStorage</I> interface pointer*</td></tr>
<tr><td valign="top"><I>IUNKNOWN</I></td>
<td valign="top"><I>pUnkForRelease</I></td>
<td valign="top">Used by clients to call <I>Release</I> for formats with interface pointers</td></tr>
</table>

<P>* This member is part of a union, including handles, strings, and interface pointers used by the receiving process to access the transferred data.

<P>As you can see, the <I>STGMEDIUM</I> structure specifies <U>where</U> data is stored. The <I>tymed</I> variable determines which union member is valid.

<A NAME="559"><H2><B>The <I>IDataObject</I> Interface Member Functions</B></H2></A>
<P>This interface has nine member functions. Both Brockschmidt and the online documentation do a good job of describing all of these functions. Following are the functions that are important for this chapter.

<h3><B>
HRESULT EnumFormatEtc(DWORD <I>dwDirection</I>,           
               IEnumFORMATETC <I>ppEnum</I>);
</B></h3>

<P>If you have an <I>IDataObject</I> pointer for a data object, you can use <I>EnumFormatEtc</I> to enumerate all the formats that it supports. This is an ugly API that the MFC library insulates you from. You'll learn how this happens when you examine the <I>COleDataObject</I> class.

<h3><B>
HRESULT GetData(FORMATETC* <I>pFEIn</I>, STGMEDIUM* 
<I>pSTM</I>);
</B></h3>

<P><I>GetData</I> is the most important function in the interface. Somewhere, up in the sky, is a data object, and you have an <I>IDataObject</I> pointer to it. You specify, in a <I>FORMATETC</I> variable, the exact format you want to use when you retrieve the data, and you prepare an empty <I>STGMEDIUM</I> variable to accept the results. If the data object has the format you want, <I>GetData</I> fills in the <I>STGMEDIUM</I> structure. Otherwise, you get an error return value.

<h3><B>
HRESULT QueryGetData(FORMATETC* <I>pFE</I>);
</B></h3>

<P>You call <I>QueryGetData</I> if you're not sure whether the data object can deliver data in the format specified in the <I>FORMATETC</I> structure. The return value says, &quot;Yes, I can&quot; 
(<I>S_OK</I>) or &quot;No, I can't&quot; (an error code). Calling this function is definitely more efficient than allocating a <I>STGMEDIUM</I> variable and calling <I>GetData</I>.

<h3><B>
HRESULT SetData(FORMATETC* <I>pFEIn</I>, 
         STGMEDIUM* <I>pSTM</I>, BOOL <I>fRelease</I>);
</B></h3>

<P>Data objects rarely support<I> SetData</I>. Data objects are normally loaded with formats in their own server module; clients retrieve data by calling <I>GetData</I>. With <I>SetData</I>, you'd be transferring data in the other direction&#151;like pumping water from your house back to the water company.

<h3><B>
Other <I>IDataObject</I> Member Functions&#151;Advisory Connections
</B></h3>

<P>The interface contains other important functions that let you implement an <U>advisory</U> <U>connection</U>. When the program using a data object needs to be notified whether the object's data changes, the program can pass an <I>IAdviseSink</I> pointer to the object by calling the <I>IDataObject::DAdvise</I> function. The object then calls various <I>IAdviseSink</I> member functions, which the client program implements. You won't need advisory connections for drag-and-drop 
operations, but you will need them when you get to embedding in <A HREF="ch28a.htm">Chapter 28</A>.

</BODY>
</HTML>



