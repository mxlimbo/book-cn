<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The EX09A Example</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="198"><H1>The EX09A Example</H1></A><P>To illustrate how to take advantage of the new Internet Explorer 4 Common Controls, we'll build a dialog that demonstrates how to create and program each control type. The steps required to create the dialog are shown below.<P>
<OL>
<B><LI>Run AppWizard to generate the EX09A project.</B> Choose New from the Visual C++ File menu, and then select Microsoft AppWizard (exe) from the Projects page. Accept all the defaults but one: choose Single Document Interface (SDI). The options and the default class names are shown here.<P>

<P> <img src="G09OG01x.gif" width=414 height=423 border=0 ><P>

<B><LI>Create a new dialog resource with ID <I>IDD_DIALOG1</I>.</B> Place the controls as shown in Figure 9-1.
<P>You can drag the controls from the control palette, shown in <A HREF="ch06a.htm">Chapter 6</A>. Remember that IE4 Common Controls are at the bottom of the palette. The following table lists the control types and their IDs.<P>
<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>Tab Sequence</B></TD><TD VALIGN="TOP"><B>Control Type</B></TD><TD VALIGN="TOP"><B>Child Window ID</B></TD></TR>
<TR><TD VALIGN="TOP">1</TD><TD VALIGN="TOP">Group Box</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">2</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">3</TD><TD VALIGN="TOP">Date Time Picker</TD><TD VALIGN="TOP"><I>IDC_DATETIMEPICKER1</I></TD></TR>
<TR><TD VALIGN="TOP">4</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC1</I></TD></TR>
<TR><TD VALIGN="TOP">5</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">6</TD><TD VALIGN="TOP">Date Time Picker</TD><TD VALIGN="TOP"><I>IDC_DATETIMEPICKER2</I></TD></TR>
<TR><TD VALIGN="TOP">7</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC2</I></TD></TR>
<TR><TD VALIGN="TOP">8</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">9</TD><TD VALIGN="TOP">Date Time Picker</TD><TD VALIGN="TOP"><I>IDC_DATETIMEPICKER3</I></TD></TR>
<TR><TD VALIGN="TOP">10</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC3</I></TD></TR>
<TR><TD VALIGN="TOP">11</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">12</TD><TD VALIGN="TOP">Date Time Picker</TD><TD VALIGN="TOP"><I>IDC_DATETIMEPICKER4</I></TD></TR>
<TR><TD VALIGN="TOP">13</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC4</I></TD></TR>
<TR><TD VALIGN="TOP">14</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">15</TD><TD VALIGN="TOP">Month Calendar</TD><TD VALIGN="TOP"><I>IDC_MONTHCALENDAR</I></TD></TR>
<TR><TD VALIGN="TOP">16</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC5</I></TD></TR>
<TR><TD VALIGN="TOP">17</TD><TD VALIGN="TOP">Group Box</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">18</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">19</TD><TD VALIGN="TOP">IP Address</TD><TD VALIGN="TOP"><I>IDC_IPADDRESS1</I></TD></TR>
<TR><TD VALIGN="TOP">20</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC6</I></TD></TR>
<TR><TD VALIGN="TOP">21</TD><TD VALIGN="TOP">Group Box</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">22</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">23</TD><TD VALIGN="TOP">Extended Combo Box</TD><TD VALIGN="TOP"><I>IDC_COMBOBOXEX1</I></TD></TR>
<TR><TD VALIGN="TOP">24</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC7</I></TD></TR>
<TR><TD VALIGN="TOP">25</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC</I></TD></TR>
<TR><TD VALIGN="TOP">26</TD><TD VALIGN="TOP">Extended Combo Box</TD><TD VALIGN="TOP"><I>IDC_COMBOBOXEX2</I></TD></TR>
<TR><TD VALIGN="TOP">27</TD><TD VALIGN="TOP">Static</TD><TD VALIGN="TOP"><I>IDC_STATIC8</I></TD></TR>
<TR><TD VALIGN="TOP">28</TD><TD VALIGN="TOP">Pushbutton</TD><TD VALIGN="TOP"><I>IDOK</I></TD></TR>
<TR><TD VALIGN="TOP">29</TD><TD VALIGN="TOP">Pushbutton</TD><TD VALIGN="TOP"><I>IDCANCEL</I></TD></TR>
</TABLE>

<P>The following figure shows each control and its appropriate tab order.<P>

<P><A HREF="javascript:fullSize('G09OG02x.htm')"> <img src="G09OG02.JPG" width=404 height=270 border=0 ALT = "Click to view at full size."> </A><P>

<P>Until we set some properties, your dialog will not look exactly like the one in Figure 9-1.
<P><B><LI>Use ClassWizard to create a new class, <I>CDialog1</I>, derived from <I>CDialog</I>.</B> ClassWizard will automatically prompt you to create this 
class because it knows that the <I>IDD_DIALOG1</I> resource exists without an 
associated C++ class. Go ahead and create a message handler for the WM_INITDIALOG message.
<P><B><LI>Set the properties for the dialog's controls.</B> To demonstrate the full range of controls, we will need to set a variety of properties on each of 
the IE4 common controls in the example. Here is a brief overview of each property you will need to set:
<UL>
<LI><B>The Short Date and Time Picker.</B> To set up the first date and time picker control to use the short format, select the properties for <I>IDC_DATETIMEPICKER1, </I>as shown in the following figure.

<P><IMG SRC="G09OG03.GIF" width=403 height=162 BORDER=0><P>

<LI><B>The Long Date and Time Picker.</B> Now configure the second date and time picker control (<I>IDC_DATETIMEPICKER2</I>) to use the long format as shown below.

<P><IMG SRC="G09OG04.GIF" width=403 height=162 BORDER=0><P>

<LI><B>The Short and NULL Date and Time Picker.</B> This is the third date and time picker control, <I>IDC_DATETIMEPICKER3</I>. Configure this third date and time picker to use the short format and the styles shown here.

<P><IMG SRC="G09OG05.GIF" width=403 height=162 BORDER=0><P>

<LI><B>The Time Picker.</B> The fourth date and time picker control, <I>IDC_DATETIMEPICKER4</I>, is configured to let the user choose time. To configure this control, select Time from the Format combo box on the Styles tab as shown.

<P><IMG SRC="G09OG06.GIF" width=403 height=162 BORDER=0><P>

<LI><B>The Month View.</B> To configure the month view, you will need to set a variety of styles. First, from the Styles tab, choose Day States, as shown here.

<P><IMG SRC="G09OG07.GIF" width=403 height=162 BORDER=0><P>

<P>If we leave the default styles, the month view does not look like a control on the dialog. There are no borders drawn at all. To make the control fit in with the other controls on the dialog, select Client Edge and Static Edge from the Extended Styles tab, as shown below.

<P><IMG SRC="G09OG08.GIF" width=403 height=162 BORDER=0><P>

<LI><B>The IP Address.</B>This control (<I>IDC_IPADDRESS1</I>) does not require any special properties.<P>
<LI><B>The First Extended Combo Box.</B>Make sure that you enter some items, as shown here, and also make sure the list is tall enough to display several items.<P>

<P><IMG SRC="G09OG09.GIF" width=403 height=162 BORDER=0><P>

<LI><B>The Second Extended Combo Box.</B>Enter three items: Tweety, Mack, and Jaws. Later in the example, we will use these items to show one of the ways to draw graphics in an extended combo box.
</UL>
<P><IMG SRC="G09OG10.GIF" width=403 height=162 BORDER=0><P>

<B><LI>Add the <I>CDialog1</I> variables.</B> Start ClassWizard and click on the Member Variables tab to view the Member Variables page. Enter the following member variables for each control listed.

<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>Control ID</B></TD><TD VALIGN="TOP"><I><B>Data Member</B></I></TD><TD VALIGN="TOP"><I><B>Type</B></I></TD></TR>
<TR><TD VALIGN="TOP"><I>IDC_DATETIMEPICKER1</I></TD><TD VALIGN="TOP">
<I>m_MonthCal1</I></TD><TD VALIGN="TOP"><I>CDateTimeCtrl</I></TD></TR>
<TR><TD VALIGN="TOP"><I>IDC_DATETIMEPICKER2</I></TD><TD VALIGN="TOP"><I>m_MonthCal2</I></TD><TD VALIGN="TOP"><I>CDateTimeCtrl</I></TD></TR>
<TR><TD VALIGN="TOP"><I>IDC_DATETIMEPICKER3</I></TD><TD VALIGN="TOP"><I>m_MonthCal3</I></TD><TD VALIGN="TOP"><I>CDateTimeCtrl</I></TD></TR>
<TR><TD VALIGN="TOP"><I>IDC_DATETIMEPICKER4</I></TD><TD VALIGN="TOP"><I>m_MonthCal4</I></TD><TD VALIGN="TOP">
<I>CDateTimeCtrl</I></TD></TR>
<TR><TD VALIGN="TOP"><I>vIDC_IPADDRESS1</I></TD><TD VALIGN="TOP"><I>m_ptrIPCtrl</I></TD><TD VALIGN="TOP">
<I>CIPAddressCtrl</I></TD></TR>
<TR><TD VALIGN="TOP"><I>IDC_MONTHCALENDAR1</I></TD><TD VALIGN="TOP"><I>m_MonthCal5</I></TD><TD VALIGN="TOP">
<I>CMonthCalCtrl</I></TD></TR>
<TR><TD VALIGN="TOP"><I>IDC_STATIC1</I></TD><TD VALIGN="TOP"><I>m_strDate1</I></TD><TD VALIGN="TOP"><I>CString</I></TD></TR>
<TR><TD VALIGN="TOP"><I>IDC_STATIC2</I></TD><TD VALIGN="TOP"><I>m_strDate2</I></TD><TD VALIGN="TOP"><I>CString</I></TD></TR>
<TR><TD VALIGN="TOP"><I>IDC_STATIC3</I></TD><TD VALIGN="TOP"><I>m_strDate3</I></TD><TD VALIGN="TOP"><I>CString</I></TD></TR>
<TR><TD VALIGN="TOP"><I>IDC_STATIC4</I></TD><TD VALIGN="TOP"><I>m_strDate4</I></TD><TD VALIGN="TOP"><I>CString</I></TD></TR>
<TR><TD VALIGN="TOP"><I>IDC_STATIC5</I></TD><TD VALIGN="TOP"><I>m_strDate5</I></TD><TD VALIGN="TOP"><I>CString</I></TD></TR>
<TR><TD VALIGN="TOP"><I>IDC_STATIC6</I></TD><TD VALIGN="TOP"><I>m_strIPValue</I></TD><TD VALIGN="TOP"><I>CString</I></TD></TR>
<TR><TD VALIGN="TOP"><I>IDC_STATIC7</I></TD><TD VALIGN="TOP"><I>m_strComboEx1</I></TD><TD VALIGN="TOP">
<I>CString</I></TD></TR>
<TR><TD VALIGN="TOP"><I>IDC_STATIC8</I></TD><TD VALIGN="TOP"><I>m_strComboEx2</I></TD><TD VALIGN="TOP"><I>CString</I></TD></TR>
</TABLE>
<P>

<B><LI>Program the short date time picker.</B> In this example, we don't mind if the first date time picker starts with the current date, so we don't have any <I>OnInitDialog</I> handling for this control. However, if we wanted to change the date, we would make a call to <I>SetTime</I> for the control in 
<I>OnInitDialog</I>. At runtime, when the user selects a new date in the first 
date and time picker, the companion static control should be automatically 
updated. To achieve this, we need to use ClassWizard to add a handler for the DTN_DATETIMECHANGE message. Start ClassWizard (CTRL-W) and choose <I>IDC_DATETIMEPICKER1</I> from the Object IDs list and DTN_DATETIMECHANGE from the Messages list. Accept the default message name and click OK. Repeat this step for each of the other three <I>IDC_DATETIMEPICKER</I> IDs. Your ClassWizard should look like the illustration here.

<P><A HREF="javascript:fullSize('G09OG11x.htm')"> <img src="G09OG11.JPG" width=404 height=290 border=0 ALT = "Click to view at full size."> </A><P>

<P>Next add the following code to the handler for Datetimepicker1 created by ClassWizard:
<P><PRE>void CDialog1::OnDatetimechangeDatetimepicker1(NMHDR* pNMHDR,
    LRESULT* pResult) 
{
    <B>CTime ct;
    m_MonthCal1.GetTime(ct);
    m_strDate1.Format(_T(&quot;%02d/%02d/%2d&quot;),
                      ct.GetMonth(),ct.GetDay(),ct.GetYear());
    UpdateData(FALSE);</B>
    *pResult = 0;
}
</PRE><P>This code uses the <I>m_MonthCal1</I> data member that maps to the first date time picker to retrieve the time into the <I>CTime</I> object variable <I>ct</I>. It then calls the <I>CString::Format</I> member function to set the companion static string. Finally the call to <I>UpdateData(FALSE)</I> triggers MFC's DDX and causes the static to be automatically updated to 
<I>m_strDate1</I>.
<P><B><LI>Program the long date time picker.</B> Now we need to provide a similar handler for the second date time picker.
<P><PRE>void CDialog1::OnDatetimechangeDatetimepicker2(NMHDR* pNMHDR, 
    LRESULT* pResult) 
{
    <B>CTime ct;
    m_MonthCal2.GetTime(ct);
    m_strDate2.Format(_T(&quot;%02d/%02d/%2d&quot;),
                      ct.GetMonth(),ct.GetDay(),ct.GetYear());
    UpdateData(FALSE);</B>

    *pResult = 0;
}
</PRE>
<P><B><LI>Program the third date time picker.</B> The third date time picker needs a similar handler, but since we set the Show None style in the dialog properties, it is possible for the user to specify a NULL date by checking the inline check box. Instead of blindly calling <I>GetTime</I>, we have to check the return value. If the return value of the <I>GetTime</I> call is nonzero, the user has selected a NULL date. If the return value is zero, a valid date has been selected. As in the previous two handlers, when a <I>CTime</I> object is returned, it is converted into a string and automatically displayed in the companion static control.
<P><PRE>void CDialog1::OnDatetimechangeDatetimepicker3(NMHDR* pNMHDR, 
    LRESULT* pResult) 
{
    <B>//NOTE: this one can be null!
    CTime ct;
    int nRetVal = m_MonthCal3.GetTime(ct);
    if (nRetVal) //If not zero, it's</B> <B>null; and if it is,
                 // do the right thing.
    {
        m_strDate3 = &quot;NO DATE SPECIFIED!!&quot;;
    }
    else
    {
        m_strDate3.Format(_T(&quot;%02d/%02d/%2d&quot;),ct.GetMonth(),
                          ct.GetDay(),ct.GetYear());
    }
    UpdateData(FALSE);</B>
    *pResult = 0;
}
</PRE><P><B><LI>Program the time picker.</B> The time picker needs a similar handler, but this time the format displays hours/minutes/seconds instead of 
months/days/years:<P>
<PRE>void CDialog1::OnDatetimechangeDatetimepicker4(NMHDR* pNMHDR, 
    LRESULT* pResult) 
{
    <B>CTime ct;
    m_MonthCal4.GetTime(ct);
    m_strDate4.Format(_T(&quot;%02d:%02d:%2d&quot;),
                      ct.GetHour(),ct.GetMinute(),ct.GetSecond());
    UpdateData(FALSE);</B>
    *pResult = 0;
}
</PRE>
<P><B><LI>Program the Month Selector.</B> You might think that the month 
selector handler is similar to the date time picker's handler, but they are 
actually somewhat different. First of all, the message you need to handle for 
detecting when the user has selected a new date is the MCN_SELCHANGE message. Select this message in the ClassWizard, as shown here.
<P><A HREF="javascript:fullSize('G09OG12x.htm')"> <img src="G09OG12.JPG" width=404 height=290 border=0 ALT = "Click to view at full size."> </A><P>
<P>In addition to the different message handler, this control uses <I>GetCurSel</I> as the date time picker instead of <I>GetTime</I>. The code below shows the MCN_SELCHANGE handler for the month calendar control.
<P>
<PRE>void CDialog1::OnSelchangeMonthcalendar1(NMHDR* pNMHDR, 
    LRESULT* pResult) 
{
    <B>CTime ct;
    m_MonthCal5.GetCurSel(ct);
    m_strDate5.Format(_T(&quot;%02d/%02d/%2d&quot;),
                      ct.GetMonth(),ct.GetDay(),ct.GetYear());
    UpdateData(FALSE);</B>
    *pResult = 0;
}
</PRE>
<P><B><LI>Program the IP control.</B> First we need to make sure the control is 
initialized. In this example, we initialize the control to 0 by giving it a 0 
DWORD value. If you do not initialize the control, each segment will be blank. 
To initialize the control, add this call to the <I>CDialog1::OnInitDialog</I> function:
<P><PRE>
<B>m_ptrIPCtrl.SetAddress(0L);</B>
</PRE><P>Now we need to add a handler to update the companion static control whenever the IP address control changes. First we need to add a handler for the IPN_FIELDCHANGED notification message using ClassWizard, as shown here.

<P><A HREF="javascript:fullSize('G09OG13x.htm')"> <img src="G09OG13.JPG" width=404 height=290 border=0 ALT = "Click to view at full size."> </A><P>

<P>Next we need to implement the handler as follows:
<P><PRE>void CDialog1::OnFieldchangedIpaddress1(NMHDR* pNMHDR, 
    LRESULT* pResult) 
{
    <B>DWORD dwIPAddress;
    m_ptrIPCtrl.GetAddress(dwIPAddress);
    
    m_strIPValue.Format(&quot;%d.%d.%d.%d   %x.%x.%x.%x&quot;,
        HIBYTE(HIWORD(dwIPAddress)),
        LOBYTE(HIWORD(dwIPAddress)),
        HIBYTE(LOWORD(dwIPAddress)),
        LOBYTE(LOWORD(dwIPAddress)),
        HIBYTE(HIWORD(dwIPAddress)),
        LOBYTE(HIWORD(dwIPAddress)),
        HIBYTE(LOWORD(dwIPAddress)),
        LOBYTE(LOWORD(dwIPAddress)));
    UpdateData(FALSE);</B>
    *pResult = 0;
}
</PRE><P>The first call to 
<I>CIPAddressCtrl::GetAddress</I> retrieves the current IP address into the local <I>dwIPAddress</I> <I>DWORD</I> variable. Next we make a fairly complex call to <I>CString::Format</I> to deconstruct the <I>DWORD</I> into the various fields. This call uses the <I>LOWORD</I> macro to first get to the bottom word of the <I>DWORD</I> and the <I>HIBYTE/LOBYTE</I> macros to further deconstruct the fields in order from field 0 to field 3.
<P><B><LI>Add a handler for the first extended combo box.</B> No special initialization is required for the extended combo box, but we do need to handle the CBN_SELCHANGE message. The following code shows the extended combo box handler. Can you spot the ways that this differs from a &quot;normal&quot; combo box control?<P>
<PRE>void CDialog1::OnSelchangeComboboxex1() 
{
    <B>COMBOBOXEXITEM cbi;
    CString str (&quot;dummy_string&quot;);
    CComboBoxEx * pCombo = (CComboBoxEx *)GetDlgItem(IDC_COMBOBOXEX1);

    int nSel = pCombo-&gt;GetCurSel();
    cbi.iItem = nSel;
    cbi.pszText = (LPTSTR)(LPCTSTR)str;
    cbi.mask = CBEIF_TEXT;
    cbi.cchTextMax = str.GetLength();
    pCombo-&gt;GetItem(&amp;cbi);
    SetDlgItemText(IDC_STATIC7,str);
    return;</B>
}
</PRE><P>The first thing you probably noticed is the use of the 
<I>COMBOBOXEXITEM</I> structure for the extended combo box instead of the plain 
integers used for items in an older combo box. Once the handler retrieves the 
item, it extracts the string and calls <I>SetDlgItemText</I> to update the companion static control.
<P><B><LI>Add Images to the Items in the second extended combo box.</B> The first extended combo box does not need any special programming. It is used to demonstrate how to implement a simple extended combo box very similar to the older, nonextended combo box. The second combo box requires a good bit of programming. First we created six bitmaps and eight icons that we need to add to the resources for the project, as shown in the following illustration.

<P><IMG SRC="G09OG14.GIF" width=263 height=473 BORDER=0><P>

<P>Of course, you are free to grab these images from the companion CD instead of recreating them all by hand, or you can choose to use any bitmaps and icons.
<P>There are two ways to add our graphics to an extended combo box. The first method is to attach images to existing combo box items. (Remember that we used the dialog editor to add the Tweety, Mack, and Jaws items to the combo box.) The second method is to add new items and specify their corresponding images at the time of addition.
<P>Before we start adding graphics to the extended combo box, let's create a public <I>CImageList</I> data member in the <I>CDialog1</I> class named <I>m_imageList</I>. Be sure you add the data member to the header file (Dialog1.h) for the class.
<P>Now we can add some of the bitmap images to the image list and then &quot;attach&quot; the images to the three items already in the extended combo box. Add the following code to your <I>CDialog1</I>'s <I>OnInitDialog</I> method to achieve this:
<P><PRE><B>    //Initialize the IDC_COMBOBOXEX2
    CComboBoxEx* pCombo =
        (CComboBoxEx*) GetDlgItem(IDC_COMBOBOXEX2);
    //First let's add images to the items there.
    //We have six images in bitmaps to match to our strings:

    //CImageList * pImageList = new CImageList();
    m_imageList.Create(32,16,ILC_MASK,12,4);

    CBitmap bitmap;

    bitmap.LoadBitmap(IDB_BMBIRD);
    m_imageList.Add(&amp;bitmap, (COLORREF)0xFFFFFF);
    bitmap.DeleteObject();

    bitmap.LoadBitmap(IDB_BMBIRDSELECTED);
    m_imageList.Add(&amp;bitmap, (COLORREF)0xFFFFFF);
    bitmap.DeleteObject();
    
    bitmap.LoadBitmap(IDB_BMDOG);
    m_imageList.Add(&amp;bitmap, (COLORREF)0xFFFFFF);
    bitmap.DeleteObject();
    
    bitmap.LoadBitmap(IDB_BMDOGSELECTED);
    m_imageList.Add(&amp;bitmap, (COLORREF)0xFFFFFF);
    bitmap.DeleteObject();    
        
    bitmap.LoadBitmap(IDB_BMFISH);
    m_imageList.Add(&amp;bitmap, (COLORREF)0xFFFFFF);
    bitmap.DeleteObject();
    
    bitmap.LoadBitmap(IDB_BMFISHSELECTED);
    m_imageList.Add(&amp;bitmap, (COLORREF)0xFFFFFF);
    bitmap.DeleteObject();    

    //Set the imagelist
    pCombo-&gt;SetImageList(&amp;m_imageList);
    //Now attach the images to the items in the list.
    COMBOBOXEXITEM    cbi;
    cbi.mask = CBEIF_IMAGE|CBEIF_SELECTEDIMAGE|CBEIF_INDENT;
    CString strTemp;
    int nBitmapCount = 0;
    for (int nCount = 0;nCount &lt; 3;nCount++)
    {
        cbi.iItem = nCount;
        cbi.pszText = (LPTSTR)(LPCTSTR)strTemp;
        cbi.cchTextMax = 256;
        pCombo-&gt;GetItem(&amp;cbi);
        cbi.iImage = nBitmapCount++;
        cbi.iSelectedImage = nBitmapCount++;
        cbi.iIndent = (nCount &amp; 0x03);
        pCombo-&gt;SetItem(&amp;cbi);

    }</B>
</PRE><P>First the extended combo box initialization code creates a pointer to 
the control using <I>GetDlgItem</I>. Next it calls <I>Create</I> to create memory for the images to be added and to initialize the image list. The next series of calls loads each bitmap, adds them to the image list, and then deletes the resource allocated in the load.
<P><I>CComboBoxEx::SetImageList</I> is called to associate the <I>m_imageList</I> with the extended combo box. Next a <I>COMBOBOXEXITEM</I> structure is initialized with a mask, and then the <I>for</I> loop iterates from 0 through 2, setting the selected and unselected images with each pass through the loop. The variable <I>nBitmapCount</I> increments through the image list to ensure that the correct image ID is put into the <I>COMBOBOXEXITEM</I> structure. The <I>for</I> loop makes a call to <I>CComboBoxEx::GetItem</I> to retrieve the <I>COMBOBOXEXITEM</I> structure for each item in the extended 
combo box. Then the loop sets up the images for the list item and finally 
calls <I>CComboBoxEx::SetItem</I> to put the modified <I>COMBOBOXEXITEM</I> structure back into the extended combo box and complete the association 
of images with the existing items in the list.
<P><B><LI>Add Items to the Extended Combobox.</B> The other technique available for putting images into an extended combo box is to add them dynamically, as shown in the code added to <I>OnInitDialog</I> below:
<P><PRE>   <B> HICON hIcon[8];
    int n;
//Now let's insert some color icons
    hIcon[0] = AfxGetApp()-&gt;LoadIcon(IDI_WHITE);
    hIcon[1] = AfxGetApp()-&gt;LoadIcon(IDI_BLACK);
    hIcon[2] = AfxGetApp()-&gt;LoadIcon(IDI_RED);
    hIcon[3] = AfxGetApp()-&gt;LoadIcon(IDI_BLUE);
    hIcon[4] = AfxGetApp()-&gt;LoadIcon(IDI_YELLOW);
    hIcon[5] = AfxGetApp()-&gt;LoadIcon(IDI_CYAN);
    hIcon[6] = AfxGetApp()-&gt;LoadIcon(IDI_PURPLE);
    hIcon[7] = AfxGetApp()-&gt;LoadIcon(IDI_GREEN);
    for (n = 0; n &lt; 8; n++) {
        m_imageList.Add(hIcon[n]);
    }

    static char* color[] = {&quot;white&quot;, &quot;black&quot;, &quot;red&quot;,
                            &quot;blue&quot;, &quot;yellow&quot;, &quot;cyan&quot;,
                            &quot;purple&quot;, &quot;green&quot;};

    cbi.mask = CBEIF_IMAGE|CBEIF_TEXT|CBEIF_OVERLAY|
               CBEIF_SELECTEDIMAGE;

    for (n = 0; n &lt; 8; n++) {</B>
      <B>  cbi.iItem = n;
        cbi.pszText = color[n];
        cbi.iImage = n+6; //6 is the offset into the image list from
        cbi.iSelectedImage = n+6; // the first six items we added...
        cbi.iOverlay = n+6;
        int nItem = pCombo-&gt;InsertItem(&amp;cbi);
        ASSERT(nItem == n);
    }</B>
</PRE><P>The addition of the icons above is similar to the EX06B list control 
example in <A HREF="ch06a.htm">Chapter 6</A>. The <I>for</I> loop fills out the <I>COMBOBOXEXITEM</I> structure and then calls <I>CComboBoxEx::InsertItem</I> with each item to 
add it to the list.
<P><B><LI>Add a handler for the second extended combo box.</B> The second extended combo box handler is essentially the same as the first:
<P><PRE>void CDialog1::OnSelchangeComboboxex2() 
{
    <B>COMBOBOXEXITEM cbi;
    CString str (&quot;dummy_string&quot;);
    CComboBoxEx * pCombo = (CComboBoxEx *)GetDlgItem(IDC_COMBOBOXEX2);
    int nSel = pCombo-&gt;GetCurSel();
    cbi.iItem = nSel;
    cbi.pszText = (LPTSTR)(LPCTSTR)str;
    cbi.mask = CBEIF_TEXT;
    cbi.cchTextMax = str.GetLength();
    pCombo-&gt;GetItem(&amp;cbi);
    SetDlgItemText(IDC_STATIC8,str);

    return;</B>
}
</PRE><P><B><LI>Connect the view and the dialog.</B> Add code to the virtual 
<I>OnDraw</I> function in ex09aView.cpp. The following boldface code replaces the previous code:
<P><PRE>void CEx09aView::OnDraw(CDC* pDC)
{
    <B>pDC-&gt;TextOut(0, 0, &quot;Press the left mouse button here.&quot;);</B>
}
</PRE>
<P><B><LI>Use ClassWizard to add the <I>OnLButtonDown</I> member function to the CEx09aView class.</B> Edit the AppWizard-generated code as follows:
<P><PRE>void CEx09aView::OnLButtonDown(UINT nFlags, CPoint point)
{
<B>    CDialog1 dlg;
    dlg.DoModal();</B>
}
</PRE><P>Add a statement to include Dialog1.h in file ex09aView.cpp.
<P><B><LI>Compile and run the program.</B> Now you can experiment with the 
various IE4 common controls to see how they work and how you can apply them in your own applications.<P>
</OL>
</BODY>
</HTML>



