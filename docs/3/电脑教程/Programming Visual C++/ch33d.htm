<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Basic OLE DB Template Architecture</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="840"><H1>Basic OLE DB Template Architecture </H1></A><P>Now that you understand the basic architecture behind OLE DB, it's time 
to take a look at a specific implementation of the OLE DB interfaces 
(provided by the new OLE DB consumer and provider templates). Like most other 
COM-based technologies, OLE DB involves implementing a bunch of interfaces. 
Of course, just as with ActiveX Controls, you can choose to implement them 
by hand (often an inefficient approach&#151;unless you're just trying to understand 
the technology inside-out), or you can find someone else to do most of the 
dirty work. While OLE DB is a rich and powerful data access technology, getting 
it up and running by hand is a somewhat tedious task.
<P>Just as Visual C++ provides a template library (ATL) for 
implementing ActiveX Controls, Visual C++ also provides a template library that helps 
you manage OLE DB. The OLE DB template support provides classes that 
implement many of the commonly used OLE DB interfaces. In addition, Visual 
C++ provides great wizard support for generating code to apply to common scenarios.
<P>From a high level, you can divide the classes in this template library 
into the two groups defined by OLE DB itself: the consumer classes and the 
provider classes. The consumer classes help you implement database client 
(consumer) applications, while the provider classes help you implement 
database server (provider) applications. Remember that OLE DB consumers are 
applications that call the COM interfaces exposed by OLE DB service providers 
(or regular providers) to access data. OLE DB providers are COM servers 
that provide data and services in a form that a consumer can understand.
<A NAME="841"><H2>OLE DB Consumer Template Architecture</H2></A><P>Microsoft has kept the top layer classes in the OLE DB Consumer 
Templates as close to the OLE DB specification as possible. That is, OLE DB 
templates don't define another object model. Their purpose is simply to wrap the 
existing OLE DB object model. For each of the consumer-related 
components listed, you'll find a corresponding 
C++ template class. This design philosophy leverages the flexibility of OLE DB and allows more 
advanced features&#151;such as multiple accessors on rowsets&#151;to be available through 
the OLE DB Templates.
<P>The OLE DB Templates are small and flexible. They are implemented 
using C++ templates and multiple inheritance. Because OLE DB templates are 

close to the metal (they wrap only the existing OLE DB architecture), each 
class mirrors an existing OLE DB component. For example, 
<I>CDataSource</I> corresponds to the data source object in OLE DB.
<P>The OLE DB Consumer Template architecture can be divided into 
three parts: the general data source support classes, classes for supporting data 
access and rowset operations, and classes for handling tables and commands. 
Here's a quick summary of these classes.
<A NAME="842"><H3>General Data Source Support</H3></A><P>A data source is the most fundamental concept to remember when talking 
about data access using OLE DB. That is, where is the data coming from? Of 
course, the OLE DB templates have support for data sources. General data source 
support comprises three classes as shown in this table.
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD><B>Class</B></TD><TD><B>Use</B></TD></TR>
<TR><TD><I>CDataSource</I></TD><TD>This class represents the data source component and 
manages the connection to a data source.</TD></TR>
<TR><TD><I>CEnumerator</I></TD><TD>This class provides a way to select a provider by 
cycling through a list of providers. Its functionality is 
equivalent to the <I>SQLBrowseConnect</I> and <I>SQLDriverConnect</I> functions.</TD></TR>
<TR><TD><I>CSession</I></TD><TD>This class handles transactions. You can use this class 
to create rowsets, commands, and many other objects. 
A <I>CDataSource</I> object creates a 
<I>CSession</I> object using the 
<I>CSession::Open</I> method.</TD></TR>
</TABLE>

<A NAME="843"><H3>Data Access and Rowset Support</H3></A><P>The OLE DB templates provide binding and rowset support through 
several classes. The accessor classes talk to the data source while the rowset 
manages the data in tabular form. The data access and rowset components are 
implemented through the <I>CAccessorRowset</I> class. 
<I>CAccessorRowset</I> is a template class that's specialized on an accessor and a rowset. This class can handle 
multiple accessors of different types.
<P>The OLE DB Template library defines the accessors in this table.<P>

<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD><B>Class</B></TD><TD><B>Use</B></TD></TR>
<TR><TD><I>CAccessor</I></TD><TD>This class is used when a record is 
statically bound to a data source&#151;it contains the 
pre-existing data buffer and understands the data format up front. 
<I>CAccessor</I> is used when you know the structure and the type of the 
database ahead of time.</TD></TR>
<TR><TD><I>CDynamicAccessor</I></TD><TD>This class is used for retrieving data from 
a source whose structure is not known at design time. This class uses 
<I>IColumnsInfo::GetColumnInfo</I> to get the database 
column information. <I>CDynamicAccessor</I> creates 
and manages the data buffer.</TD></TR>
<TR><TD><I>CDynamicParameterAccessor</I></TD><TD>This class is similar to 
<I>CDynamicAccessor</I> 
except that it's used with commands. When used to prepare commands, 
<I>CDynamicParameterAccessor</I> can get parameter 
information from the <I>ICommandWithParameters</I> interface, which is especially useful for 
handling unknown command types.</TD></TR>
<TR><TD><I>CManualAccessor</I></TD><TD>This class lets you access whatever data 
types you want as long as the provider can convert the type. 
<I>CManualAccessor</I> handles both 
result columns and command parameters.</TD></TR>
</TABLE>

<P>Along with the accessors, the OLE DB templates define three types 
of rowsets: single fetching, bulk, and array. These are fairly self-explanatory 
descriptions. Clients use a function named 
<I>MoveNext</I> to navigate through the data. The difference between the single fetching, bulk, and array rowsets lies in the 
number of row handles retrieved when 
<I>MoveNext</I> is called. Single fetching rowsets 
retrieve a single rowset for each call to 
<I>MoveNext</I> while bulk rowsets fetch multiple rows. Array rowsets provide a convenient array syntax for fetching 
data. The OLE DB Templates provide the single row-fetching capability by default.
<A NAME="844"><H3>Table and Command Support</H3></A><P>The final layer in the OLE DB Template consumer architecture consists of 
two more classes: table and command classes 
(<I>CTable</I> and <I>CCommand</I>). These classes are used to open the rowset, execute commands, and initiate bindings. 
Both classes derive from <I>CAccessorRowset</I>
<P>The <I>CTable</I> class is a minimal class implementation that opens a table 
on a data source (which you can specify programmatically). Use this class when 
you need bare-bones access to a source, since 
<I>CTable</I> is designed for simple providers that do not support commands.
<P>Other data sources also support commands. For those sources, you'll 
want to use the OLE DB Templates' <I>CCommand</I> class. As its name implies, 
<I>CCommand</I> is used mostly for executing commands. This class has a function 
named <I>Open</I> that executes singular commands. This class also has a function named 
<I>Prepare</I> for setting up a command to execute multiple times.
<P>When using the <I>CCommand</I> class, you'll specialize it with three 
template arguments: an accessor, a rowset, and a third template argument (which 
defaults to <I>CNoMultipleResults</I>). If you specify 
<I>CMultipleResults</I> for this third argu-
ment, the <I>CCommand</I> class will support the 
<I>IMultipleResults</I> interface for a command that returns multiple rowsets.
<A NAME="845"><H2>OLE DB Provider Template Architecture</H2></A><P>Remember that OLE DB is really just a set of interfaces that specify a 
protocol for managing data. OLE DB defines several interfaces (some mandatory 
and others optional) for the following types of objects: data source, session, 
rowset, and command. Here's a description of each followed by a code snippet 
that shows how the templates bring in the correct functionality for each component.
<UL>
<LI><B>Data source object</B> A data source object wraps most aspects of 
data access. For example, a data source consists of actual data and its 
associated database management system (DBMS), the platform on 
which the DBMS exists, and the network used to access that platform. 
A data source is just a COM object that implements a bunch of 
interfaces, as shown in Table 33-1.<P>
</UL>

<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD><B>Interface</B></TD><TD><B>Required?</B></TD><TD><B>Implemented?</B></TD></TR>
<TR><TD><I>IDBInitialize</I></TD><TD> Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>IDBCreateSession</I></TD><TD> Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>IDBProperties</I></TD><TD> Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>IPersist</I></TD><TD> Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>IDBDataSourceAdmin</I></TD><TD> Optional</TD><TD>No</TD></TR>
<TR><TD><I>IDBInfo</I></TD><TD> Optional</TD><TD>No</TD></TR>
<TR><TD><I>IPersistFile</I></TD><TD> Optional</TD><TD>No</TD></TR>
<TR><TD><I>ISupportErrorInfo</I></TD><TD>Optional</TD><TD>No</TD></TR>
</TABLE>
<P>
<B>Table 33-1.</B> <I>Data source object interface requirements.</I>
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
Tables in this section were compiled from the 
Microsoft Visual Studio MSDN Online Help.
</BLOCKQUOTE></DIV>
<UL>
<P>Here's a code snippet showing the code that is inserted by 
the ATL Object Wizard when you create a data source for an OLE 
DB provider:<P>
<PRE>class ATL_NO_VTABLE CAProviderSource : 
    public CComObjectRootEx&lt;CComSingleThreadModel&gt;,
    public CComCoClass&lt;CAProviderSource, &amp;CLSID_AProvider&gt;,
    public IDBCreateSessionImpl&lt;CAProviderSource, CAProviderSession&gt;,
    public IDBInitializeImpl&lt;CAProviderSource&gt;,
    public IDBPropertiesImpl&lt;CAProviderSource&gt;,
    public IPersistImpl&lt;CAProviderSource&gt;,
    public IInternalConnectionImpl&lt;CAProviderSource&gt; {
}; 
</PRE>
<P>Notice that this is a normal COM class (with ATL's 
<I>IUnknown</I> implementation). The OLE DB data source object brings in 
implementations of the <I>IDBCreateSession</I>, 
<I>IDBInitialize</I>, <I>IDBProperties</I>, and 
<I>IPersist </I>interfaces through inheritance. Notice how the 
templates are specialized on the 
<I>CAProviderSource</I> and 
<I>CAProviderSession</I> classes. If you decide to add more functionality to your 
class, you can do so by inheriting from one of the OLE DB interface 
implementation classes.
<P>
<LI><B>Command object</B> Providers that support building and 
executing queries expose a command object. Command objects specify, 
prepare, and execute a Database Manipulation Language (DML) 
query or Data Definition Language (DDL) definition and its 
associated properties. For example, the command object translates a 
SQL-type command into an operation specific to the data source. Compared 
to ODBC, the command corresponds to the general functionality 
of an ODBC statement in an unexecuted state. A single session can 
be associated with multiple commands. Table 33-2 shows the 
interfaces used in a command object.
<P>Here's a code snippet showing the code inserted by the 
ATL Object Wizard to implement a command object when you create 
an OLE DB provider:
<P><PRE>class ATL_NO_VTABLE CAProviderCommand : 
    public CComObjectRootEx&lt;CComSingleThreadModel&gt;,
    public IAccessorImpl&lt;CAProviderCommand&gt;,
    public ICommandTextImpl&lt;CAProviderCommand&gt;,
    public ICommandPropertiesImpl&lt;CAProviderCommand&gt;,
    public IObjectWithSiteImpl&lt;CAProviderCommand&gt;,
    public IConvertTypeImpl&lt;CAProviderCommand&gt;,
    public IColumnsInfoImpl&lt;CAProviderCommand&gt; {
};</PRE>
<P>As with the data source, notice that this is just a regular 
COM class. This class brings in the required interfaces through 
inheritance. (For example, <I>IAccesor</I> comes in through the 
<I>IAccessorImpl</I> template.) A command object uses 
<I>IAccessor</I> to specify parameter bindings. Consumers call 
<I>IAccessor::CreateAccessor,</I> passing an array of 
<I>DBBINDING</I> structures. <I>DBBINDING</I> contains information 
on the column bindings (type, length, and so on). The provider receives 
the structures and determines how the data should be transferred 
and whether conversions are necessary.
<P>The <I>ICommandText</I> interface provides a way to specify a 
text command. The <I>ICommandProperties</I> interface handles all of 
the command properties.
<P>The command class is the heart of the data provider. Most of 
the action happens within this class.
</UL>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD><B>Interface</B></TD><TD><B>Required?</B></TD><TD><B>Implemented?</B></TD></TR>
<TR><TD><I>IAccessor</I></TD><TD>Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>IColumnsInfo</I></TD><TD>Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>ICommand</I></TD><TD>Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>ICommandProperties</I></TD><TD>Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>ICommandText</I></TD><TD>Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>IConvertType</I></TD><TD>Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>IColumnsRowset</I></TD><TD>Optional</TD><TD>No</TD></TR>
<TR><TD><I>ICommandPrepare</I></TD><TD>Optional</TD><TD>No</TD></TR>
<TR><TD><I>ICommandWithParameters</I></TD><TD>Optional</TD><TD>No</TD></TR>
<TR><TD><I>ISupportErrorInfo</I></TD><TD>Optional</TD><TD>No</TD></TR>
</TABLE>
<P>
<B>Table 33-2.</B> <I>Command object interfaces requirements.</I>

<UL>
<LI><B>Session object</B> Session objects define the scope of a 
transaction and generate rowsets from the data source. Session objects also 
generate command objects. The command object executes 
commands on the rowset. For providers that support commands, the 
session acts as a command factory. Compared to ODBC, the session 
object and the data source object encapsulate the functionality of 
the ODBC connection. Calling 
<I>IDBCreateSession::CreateSession</I> creates 
a session from the data source object. A single data source object 
can be associated with many sessions. Table 33-3 shows the 
interfaces found on a session object.<P>
</UL>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD><B>Interface</B></TD><TD><B>Required?</B></TD><TD><B>Implemented?</B></TD></TR>
<TR><TD><I>IGetDataSource</I></TD><TD>Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>IOpenRowset</I></TD><TD>Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>ISessionProperties</I></TD><TD>Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>IDBCreateCommand</I></TD><TD>Optional</TD><TD>Yes</TD></TR>
<TR><TD><I>IDBSchemaRowset</I></TD><TD>Optional</TD><TD>Yes</TD></TR>
<TR><TD><I>IIndexDefinition</I></TD><TD>Optional</TD><TD>No</TD></TR>
<TR><TD><I>ISupportErrorInfo</I></TD><TD>Optional</TD><TD>No</TD></TR>
<TR><TD><I>ITableDefinition</I></TD><TD>Optional</TD><TD>No</TD></TR>
<TR><TD><I>ITransactionJoin</I></TD><TD>Optional</TD><TD>No</TD></TR>
<TR><TD><I>ITransactionLocal</I></TD><TD>Optional</TD><TD>No</TD></TR>
<TR><TD><I>ITransactionObject</I></TD><TD>Optional</TD><TD>No</TD></TR>
</TABLE>
<P>
<B>Table 33-3.</B> <I>Session object interfaces requirements.</I>
<UL>
<P>Here's a code snippet showing the code inserted by the 
ATL Object Wizard to implement a session object when you create 
an OLE DB provider:
<P>
<PRE>class ATL_NO_VTABLE CAProviderSession : 
    public CComObjectRootEx&lt;CComSingleThreadModel&gt;,
    public IGetDataSourceImpl&lt;CAProviderSession&gt;,
    public IOpenRowsetImpl&lt;CAProviderSession&gt;,
    public ISessionPropertiesImpl&lt;CAProviderSession&gt;,
    public IObjectWithSiteSessionImpl&lt;CAProviderSession&gt;,
    public IDBSchemaRowsetImpl&lt;CAProviderSession&gt;,
    public IDBCreateCommandImpl&lt;CAProviderSession, CAProviderCommand&gt;
{
};</PRE>
<LI><B>Rowset object</B> A rowset object represents tabular data. At the 
raw OLE DB level, rowsets are generated by calling 
<I>IOpenRowset::OpenRowset</I> on the session. For providers that support commands, 
rowsets are used to represent the results of row-returning queries. 
In addition to <I>IOpenRowset::OpenRowset</I>, there are a number of 
other methods in OLE DB that return rowsets. For example, the 
schema functions return rowsets. Compared to ODBC, a rowset 
encapsulates the general functionality of an ODBC statement in the 
executed state. Single sessions can be associated with multiple rowsets. In 
addition, single command objects can be associated with multiple 
rowsets. Table 33-4 shows the interfaces associated with the rowset object.
</UL>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD>Interface</TD><TD>Required?</TD><TD>Implemented?</TD></TR>
<TR><TD><I>IAccessor</I></TD><TD>Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>IColumnsInfo</I></TD><TD>Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>IConvertType</I></TD><TD>Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>IRowset</I></TD><TD>Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>IRowsetInfo</I></TD><TD>Mandatory</TD><TD>Yes</TD></TR>
<TR><TD><I>IColumnsRowset</I></TD><TD>Optional</TD><TD>No</TD></TR>
<TR><TD><I>IConnectionPointContainer</I></TD><TD>Optional</TD><TD>Yes, through ATL</TD></TR>
<TR><TD><I>IRowsetChange</I></TD><TD>Optional</TD><TD>No</TD></TR>
<TR><TD><I>IRowsetIdentity</I></TD><TD>Required for Level 0</TD><TD>    Yes</TD></TR>
<TR><TD><I>IRowsetLocate</I></TD><TD>Optional</TD><TD>No</TD></TR>
<TR><TD><I>IRowsetResynch</I></TD><TD>Optional</TD><TD>No</TD></TR>
<TR><TD><I>IRowsetScroll</I></TD><TD>Optional</TD><TD>No</TD></TR>
<TR><TD><I>IRowsetUpdate</I></TD><TD>Optional</TD><TD>No</TD></TR>
<TR><TD><I>ISupportErrorInfo</I></TD><TD>Optional</TD><TD>No</TD></TR>
</TABLE>
<P><B>Table 33-4.</B> <I>Rowset object interfaces requirements.</I>
<UL>
<P>Here's a code snippet showing the code inserted by the 
ATL Object Wizard to implement a rowset object when you create 
an OLE DB provider:
<P>
<PRE>class CAProviderWindowsFile: 
    public WIN32_FIND_DATA
{
public:
BEGIN_PROVIDER_COLUMN_MAP(CAProviderWindowsFile)
    PROVIDER_COLUMN_ENTRY(&quot;FileAttributes&quot;, 1, dwFileAttributes)
    PROVIDER_COLUMN_ENTRY(&quot;FileSizeHigh&quot;, 2, nFileSizeHigh)
    PROVIDER_COLUMN_ENTRY(&quot;FileSizeLow&quot;, 3, nFileSizeLow)
    PROVIDER_COLUMN_ENTRY(&quot;FileName&quot;, 4, cFileName)
    PROVIDER_COLUMN_ENTRY(&quot;AltFileName&quot;, 5, cAlternateFileName)
END_PROVIDER_COLUMN_MAP()
};

class CAProviderRowset : 
public CRowsetImpl&lt;CAProviderRowset, 
                     CAProviderWindowsFile, 
                     CAProviderCommand&gt; {
}</PRE>
<P>The wizard-generated rowset object implements the 
<I>IAccessor, IRowset</I>, and <I>IRowsetInfo</I> interfaces, among others. 
<I>IAccessorImpl</I> binds both output columns. The 
<I>IRowset</I> interface fetches rows and data. The 
<I>IRowsetInfo</I> interface handles the rowset properties. The 
<I>CWindowsFile</I> class represents the user record class. The class generated 
by the Wizard is really just a placeholder. It doesn't do very much. 
When you decide on the column format of your data provider, this is 
the class you'll modify.
</UL>

<A NAME="846"><H3>How the Provider Parts Work Together</H3></A><P>The use for the first part of the architecture&#151;the data source&#151;should be 
obvious. Every provider must include a data source object. When a 
consumer application needs data, the consumer calls 
<I>CoCreateInstance</I> to create the data source object and start the provider. Within the provider, it's the data source object's job to create a session object using the 
<I>IDBCreateSession</I> interface. The consumer uses this interface to connect to the data source object. In comparing this to how ODBC works, the data source object is equivalent to 
ODBC's HENV and the session object is the equivalent of ODBC's HDBC.
<P>The command object does most of the work. To make the data 
provider actually do something, you'll modify the command class's 
<I>Execute</I> function.
<P>Like most COM-based protocols, the OLE DB protocol makes sense 
once you've examined it for a little while. Also, like most COM-based protocols, 
the OLE DB protocol involves a good amount of code to get going&#151;code 
that could be easily implemented by some sort of framework. That's what the 
Data Consumer and Data Provider templates are all about. The rest of the 
chapter shows you what you need to do to create Data Consumers and Data 
Providers.
</BODY>
</HTML>



