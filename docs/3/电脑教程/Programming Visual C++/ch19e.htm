<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The EX19A Example -- A Wysiwyg Print Program</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="417"><H1>The EX19A Example&#151;A Wysiwyg Print Program</H1></A><P>This example displays and prints a single page of text stored in a document. 
The printed image should match the displayed image. The 
<I>MM_TWIPS</I> mapping mode is used for both printer and display. First we'll use a fixed drawing 
rectangle; later we'll base the drawing rectangle on the printable area 
rectangle supplied by the printer driver.
<P>Here are the steps for building the example:
<OL>
<B><LI>Run AppWizard to generate \vcpp32\ex19a\ex19a.</B>
Accept the default options, and then rename the document and view classes and files 
as shown here.

<P><img src="G19OG01x.GIF" width=414 height=423 border=0><P>

<P>Note that this is an MDI application.
<P><B><LI>Add a <I>CStringArray</I> data member to the 
<I>CPoemDoc</I> class.</B>Edit the PoemDoc.h header file or use ClassView.
<P><PRE><B>public:
    CStringArray m_stringArray;</B></PRE>
<P>The document data is stored in a string array. The MFC library 
<I>CStringArray</I> class holds an array of 
<I>CString</I> objects, accessible by a zero-based 
subscript. You need not set a maximum dimension in the declaration 
because the array is dynamic.
<P><B><LI>Add a <I>CRect</I> data member to the 
<I>CStringView</I> class.</B> Edit the StringView.h header file or use ClassView:
<P><PRE><B>private:
    CRect m_rectPrint;</b></PRE>
<P><LI><b>Edit three <I>CPoemDoc</I> member functions in the file 
PoemDoc.cpp.</B> AppWizard generated skeleton <I>OnNewDocument 
</I>and <I>Serialize</I> functions, but we'll have to use ClassWizard to override the 
<I>DeleteContents</I> function. We'll initialize the poem document in the overridden 
<I>OnNewDocument</I> function. 
<I>DeleteContents</I> is called in 
<I>CDocument::OnNewDocument</I>, so by calling the base class function first we're sure the poem won't be 
deleted. (The text, by the way, is an excerpt from the twentieth poem in 
Lawrence Ferlinghetti's book <I>A Coney Island of the 
Mind</I>.) Type 10 lines of your choice. You can substitute another poem or maybe your favorite 
Win32 function description. Add the following boldface code:
<P><PRE>BOOL CPoemDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;

    <B>m_stringArray.SetSize(10);
    m_stringArray[0] = &quot;The pennycandystore beyond the El&quot;;
    m_stringArray[1] = &quot;is where I first&quot;;
    m_stringArray[2] = &quot;                  fell in love&quot;;
    m_stringArray[3] = &quot;                      with unreality&quot;;
    m_stringArray[4] = &quot;Jellybeans glowed in the semi-gloom&quot;;
    m_stringArray[5] = &quot;of that september afternoon&quot;;
    m_stringArray[6] = &quot;A cat upon the counter moved among&quot;;
    m_stringArray[7] = &quot;                     the licorice sticks&quot;;
    m_stringArray[8] = &quot;                  and tootsie rolls&quot;;
    m_stringArray[9] = &quot;           and Oh Boy Gum&quot;;

   </B> return TRUE;
}</PRE><P>

<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
The <I>CStringArray</I> class supports dynamic arrays, but 
here we're using the <I>m_stringArray</I> object as though it were a static 
array of 10 elements.
</BLOCKQUOTE></DIV>

<P>The application framework calls the document's virtual 
<I>DeleteContents</I> function when it closes the document; this action deletes the strings in 
the array. A <I>CStringArray</I> contains actual objects, and a 
<I>CObArray</I> contains pointers to objects. This distinction is important when it's time to 
delete the array elements. Here the 
<I>RemoveAll</I> function actually deletes the string objects:
<P><PRE>void CPoemDoc::DeleteContents()
{
   <B> // called before OnNewDocument and when document is closed
    m_stringArray.RemoveAll();</B>
}</PRE>
<P>Serialization isn't important in this example, but the following 
function illustrates how easy it is to serialize strings. The application framework 
calls the <I>DeleteContents</I> function before loading from the archive, so you 
don't have to worry about emptying the array. Add the following boldface code:
<P><PRE>void CPoemDoc::Serialize(CArchive&amp; ar)
{
   <B> m_stringArray.Serialize(ar);</B>
}</PRE>
<P><B><LI>Edit the <I>OnInitialUpdate</I> function in 
StringView.cpp.</B> You must override the function for all classes derived from 
<I>CScrollView</I>. This function's job is to set the logical window size and the mapping mode. Add the 
following boldface code:
<P><PRE>void CStringView::OnInitialUpdate()
{
    CScrollView::OnInitialUpdate();
   <B> CSize sizeTotal(m_rectPrint.Width(), -m_rectPrint.Height());
    CSize sizePage(sizeTotal.cx / 2,
                   sizeTotal.cy / 2);   // page scroll
    CSize sizeLine(sizeTotal.cx / 100,
                   sizeTotal.cy / 100); // line scroll
    SetScrollSizes(MM_TWIPS, sizeTotal, sizePage, sizeLine);</B>
}</PRE>
<P><B><LI>Edit the <I>OnDraw</I> function in 
StringView.cpp.</B> The <I>OnDraw</I> function 
of class <I>CStringView</I> draws on both the display and the printer. In 
addition to displaying the poem text lines in 10-point roman font, it 
draws a border around the printable area and a crude ruler along the top and left 
margins. <I>OnDraw </I>assumes the <I>MM_TWIPS</I> mapping mode, in which 1 inch = 
1440 units. Add the boldface code shown below.
<P><PRE>void CStringView::OnDraw(CDC* pDC)
{
    <B>int        i, j, nHeight;
    CString    str;
    CFont      font;
    TEXTMETRIC tm;

    </B>CPoemDoc* pDoc = GetDocument();
    <B>// Draw a border &#151; slightly smaller to avoid truncation
    pDC-&gt;Rectangle(m_rectPrint + CRect(0, 0, -20, 20));
    // Draw horizontal and vertical rulers
    j = m_rectPrint.Width() / 1440;
    for (i = 0; i &lt;= j; i++) {
        str.Format(&quot;%02d&quot;, i);
        pDC-&gt;TextOut(i * 1440, 0, str);
    }
    j = -(m_rectPrint.Height() / 1440);
    for (i = 0; i &lt;= j; i++) {
        str.Format(&quot;%02d&quot;, i);
        pDC-&gt;TextOut(0, -i * 1440, str);
    }</B>
    <B>// Print the poem 0.5 inch down and over;
    //  use 10-point roman font
    font.CreateFont(-200, 0, 0, 0, 400, FALSE, FALSE, 0, ANSI_CHARSET,
                    OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS,
                    DEFAULT_QUALITY, DEFAULT_PITCH | FF_ROMAN,
                    &quot;Times New Roman&quot;);
    CFont* pOldFont = (CFont*) pDC-&gt;SelectObject(&amp;font);
    pDC-&gt;GetTextMetrics(&amp;tm);
    nHeight = tm.tmHeight + tm.tmExternalLeading;
    TRACE(&quot;font height = %d, internal leading = %d\n&quot;,
          nHeight, tm.tmInternalLeading);
    j = pDoc-&gt;m_stringArray.GetSize();
    for (i = 0; i &lt; j; i++) {
        pDC-&gt;TextOut(720, -i * nHeight - 720, pDoc-&gt;m_stringArray[i]);
    }</B>
   <B> pDC-&gt;SelectObject(pOldFont);
    TRACE(&quot;LOGPIXELSX = %d, LOGPIXELSY = %d\n&quot;,
          pDC-&gt;GetDeviceCaps(LOGPIXELSX),
          pDC-&gt;GetDeviceCaps(LOGPIXELSY));
    TRACE(&quot;HORZSIZE = %d, VERTSIZE = %d\n&quot;,
          pDC-&gt;GetDeviceCaps(HORZSIZE),
          pDC-&gt;GetDeviceCaps(VERTSIZE));</B>
}</PRE>
<P><B><LI>Edit the <I>OnPreparePrinting</I> function in StringView.cpp.</B> 
This function sets the maximum number of pages in the print job. 
This example has only one page. It's absolutely necessary to call the base 
class <I>DoPreparePrinting</I> function in your overridden 
<I>OnPreparePrinting</I> function. Add the following boldface code:
<P><PRE>BOOL CStringView::OnPreparePrinting(CPrintInfo* pInfo)
{
   <B> pInfo-&gt;SetMaxPage(1);
    </B>return DoPreparePrinting(pInfo);
}</PRE>
<P><B><LI>Edit the constructor in 
StringView.cpp.</B> The initial value of the print rectangle should be 8-by-15 inches, expressed in twips (1 inch = 1440 twips). Add the following boldface code:
<P><PRE>CStringView::CStringView() <B>: m_rectPrint(0, 0, 11520, -15120)</B>
{
}</PRE>
<P><B><LI>Build and test the application.</B> If you run the EX19A application 
under Microsoft Windows NT with the lowest screen resolution, your 
MDI child window will look like the one shown below. (The text will be 
larger under higher resolutions and under Windows 95 and Windows 98.)
<P><A HREF="javascript:fullSize('g19og02x.htm')"> <img src="g19og02.jpg" width=404 height=288 border=0 ALT = "Click to view at full size."> </A>
<P>The window text is too small, isn't it? Go ahead and choose Print 
Preview from the File menu, and then click twice with the magnifying glass 
to enlarge the image. The print preview output is illustrated here.
<P><A HREF="javascript:fullSize('g19og03x.htm')"> <img src="g19og03.jpg" width=404 height=303 border=0 ALT = "Click to view at full size."> </A>
<P>Remember &quot;logical twips&quot; from <A HREF="ch05a.htm">Chapter 5</A>? We're going to use 
logical twips now to enlarge type on the display while keeping the printed 
text the same size. This requires some extra work because the 
<I>CScrollView</I> class wasn't designed for nonstandard mapping modes. You will be 
changing the view's base class from 
<I>CScrollView</I> to <I>CLogScrollView</I>, which is a 
class that I created by copying and modifying the MFC code in 
ViewScrl.cpp. The files LogScrollView.h and LogScrollView.cpp are in the 
\vcpp32\ex19a directory on the companion CD-ROM.
<P><B><LI>Insert the <I>CScrollView</I> class into the 
project.</B> Copy the files LogScrollView.h and LogScrollView.cpp from the companion CD-ROM if you 
have not done so already. Choose Add To Project from the Project menu, 
and then choose Files from the submenu. Select the two new files and 
click OK to insert them into the project.
<P><B><LI>Edit the StringView.h header 
file.</B> Add the following line at the top of the 
file:
<P><PRE><B>#include &quot;LogScrollView.h&quot;</B></PRE>
<P>Then change the line
<P><PRE>class CStringView : public CScrollView</PRE>
<P>to
<P><PRE>class CStringView : public C<B>Log</B>ScrollView</PRE>
<P><B><LI>Edit the StringView.cpp file.</B> Globally replace all occurrences 
of <I>CScrollView</I> with <I>CLogScrollView</I>. Then edit the 
<I>OnInitialUpdate</I> function. Here is the edited code, which is much shorter:
<P><PRE>void CStringView::OnInitialUpdate()
{
    CLogScrollView::OnInitialUpdate();
    CSize sizeTotal(m_rectPrint.Width(), -m_rectPrint.Height());
   <B> SetLogScrollSizes(sizeTotal);</B>
}</PRE>
<P><B><LI>Build and test the application 
again.</B> Now the screen should look 
like this.
</OL>
<P><A HREF="javascript:fullSize('g19og04x.htm')"> <img src="g19og04.jpg" width=404 height=300 border=0 ALT = "Click to view at full size."> </A><P>
<A NAME="418"><H2>Reading the Printer Rectangle</H2></A><P>The EX19A program prints in a fixed-size rectangle that's appropriate for a 
laser printer set to portrait mode with 8.5-by-11-inch (letter-size) paper. But 
what if you load European-size paper or you switch to landscape mode? The 
program should be able to adjust accordingly.
<P>It's relatively easy to read the printer rectangle. Remember the 
<I>CPrintInfo</I> pointer that's passed to 
<I>OnPrint</I>? That structure has a data member 
<I>m_rectDraw</I> that contains the rectangle in logical coordinates. Your overridden 
<I>OnPrint</I> function simply stuffs the rectangle in a view data member, and 
<I>OnDraw</I> uses it. There's only one problem: you can't get the rectangle until you start 
printing, so the constructor still needs to set a default value for 
<I>OnDraw</I> to use before printing begins.
<P>If you want the EX19A program to read the printer rectangle and 
adjust the size of the scroll view, use ClassWizard to override 
<I>OnPrint</I> and then code the function as follows:
<P><PRE>void CStringView::OnPrint(CDC* pDC, CPrintInfo* pInfo)
{
<B>    m_rectPrint = pInfo-&gt;
m_rectDraw;
    SetLogScrollSizes(CSize(m_rectPrint.Width(), 
                      -
m_rectPrint.Height()));</B>
    CLogScrollView::OnPrint(pDC, pInfo);
}</PRE>
</BODY>
</HTML>



