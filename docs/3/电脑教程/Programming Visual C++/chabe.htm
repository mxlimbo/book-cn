<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>A Sample Program</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="1004"><H1>A Sample Program</H1></A><P>Here is the code for a command-line program that dynamically constructs 
objects of two classes. Note that this isn't real MFC code&#151;the 
<I>CObject</I> class is a simplified version of the MFC library 
<I>CObject</I> class. You can find this code in 
the dyncreat.cpp file in the \vcpp32\appendb folder.
<P><PRE>#include &lt;stdio.h&gt;

#define RUNTIME_CLASS(class_name) (&amp;class_name::class##class_name)

class CObject;

struct CRuntimeClass
{
    char m_lpszClassName[21];
    int m_nObjectSize;
    CObject* (*m_pfnCreateObject)();
    CObject* CreateObject();
};

// not a true abstract class because there are no pure 
//  virtual functions, but user can't create CObject objects 
//  because of the protected constructor
class CObject
{
public:
    // not pure because derived classes don't necessarily
    // implement it
    virtual CRuntimeClass* GetRuntimeClass() const { return NULL; }
        
    // We never construct objects of class CObject, but in MFC we
    //  use this to get class hierarchy information
    static CRuntimeClass classCObject;        // DYNAMIC
     virtual ~CObject() {};  // gotta have it
protected:
    CObject() { printf(&quot;CObject constructor\n&quot;); }
};

CRuntimeClass CObject::classCObject = { &quot;CObject&quot;, 
    sizeof(CObject), NULL };

CObject* CRuntimeClass::CreateObject()
{
    return (*m_pfnCreateObject)(); // indirect function call
}

class CAlpha : public CObject
{
public:
    virtual CRuntimeClass* GetRuntimeClass() 
        const { return &amp;classCAlpha; }
    static CRuntimeClass classCAlpha;        // DYNAMIC
    static CObject* CreateObject();          // DYNCREATE
protected:
    CAlpha() { printf(&quot;CAlpha constructor\n&quot;); }
};

CRuntimeClass CAlpha::classCAlpha = { &quot;CAlpha&quot;, 
    sizeof(CAlpha), CAlpha::CreateObject };

CObject* CAlpha::CreateObject() // static function
{
    return new CAlpha;    
}

class CBeta : public CObject
{
public:
    virtual CRuntimeClass* GetRuntimeClass() 
        const { return &amp;classCBeta; }
    static CRuntimeClass classCBeta;         // DYNAMIC
    static CObject* CreateObject();          // DYNCREATE
protected:
    CBeta() { printf(&quot;CBeta constructor\n&quot;); }
};

CRuntimeClass CBeta::classCBeta = { &quot;CBeta&quot;, 
    sizeof(CBeta), CBeta::CreateObject };

CObject* CBeta::CreateObject() // static function
{
    return new CBeta;    
}

int main()
{
    printf(&quot;Entering dyncreate main\n&quot;);

    CRuntimeClass* pRTCAlpha = RUNTIME_CLASS(CAlpha);
    CObject* pObj1 = pRTCAlpha-&gt;CreateObject();
    printf(&quot;class of pObj1 = %s\n&quot;, 
        pObj1-&gt;GetRuntimeClass()-&gt;m_lpszClassName);

    CRuntimeClass* pRTCBeta = RUNTIME_CLASS(CBeta);
    CObject* pObj2 = pRTCBeta-&gt;CreateObject();
    printf(&quot;class of pObj2 = %s\n&quot;, 
        pObj2-&gt;GetRuntimeClass()-&gt;m_lpszClassName);

    delete pObj1;
    delete pObj2;
    return 0;
}</PRE>
</BODY>
</HTML>



