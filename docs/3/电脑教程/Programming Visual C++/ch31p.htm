<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Using Recordsets Without Binding</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="788"><H1>Using Recordsets Without Binding</H1></A><P>All three of the examples in this chapter used recordset classes derived 
from <I>CRecordset</I>. The data members of those classes were bound to database 
columns at recordset creation time using the ODBC binding mechanism. When 
the programs called <I>CRecordset::Move</I>, the ODBC driver copied data directly 
from the data source into the data members.
<P>ODBC has always supported unbound data access through the 
functions <I>SQLGetData</I> and <I>SQLPutData</I>. Now the 
<I>CRecordset</I> class supports read-only unbound data access through its 
<I>GetFieldValue</I> member function. One overloaded version of this function retrieves the value of a field specified by 
name and then stores it in an object of class 
<I>CDBVariant</I>. This class is similar to the 
<I>COleVariant</I> class described in <A HREF="ch25a.htm">Chapter 25</A>, but it does not use any OLE 
code and it doesn't have as many overloaded operators and member functions. 
The <I>COleVariant</I> class has a data member, 
<I>m_dwType</I>, followed by a union. If the type code is DBVT_LONG, for example, you access an integer in the 
union member <I>m_lVal</I>.
<P>You can use <I>CRecordset::GetFieldValue</I> for circumstances in which 
you don't know the database schema at design time. Your &quot;dynamic database&quot; 
program constructs an object of class 
<I>CRecordset</I>, and you access the column values with code like this:
<P><PRE>void CEx31dView::DrawDataRow(CDC* pDC, int y)
{
    int x = 0;
    CString strTime, str;
    CEx31dDoc* pDoc = GetDocument();
    for (int i = 0; i &lt; pDoc-&gt;m_nFields; i++) {
        CDBVariant var; // must declare this inside the loop
        m_pSet-&gt;GetFieldValue(i, var);
        switch (var.m_dwType) {
        case DBVT_STRING:
            str = *var.m_pstring; // narrow characters
            break;
        case DBVT_SHORT:
            str.Format(&quot;%d&quot;, (int) var.m_iVal);
            break;
        case DBVT_LONG:
            str.Format(&quot;%d&quot;, var.m_lVal);
            break;
        case DBVT_SINGLE:
            str.Format(&quot;%10.2f&quot;, (double) var.m_fltVal);
            break;
        case DBVT_DOUBLE:
            str.Format(&quot;%10.2f&quot;, var.m_dblVal);
            break;
        case DBVT_DATE:
            str.Format(&quot;%d/%d/%d&quot;, var.m_pdate-&gt;month, var.m_pdate-&gt;day,
                var.m_pdate-&gt;year);
            break;
        case DBVT_BOOL:
            str = (var.m_boolVal == 0) ? &quot;FALSE&quot; : &quot;TRUE&quot;;
            break;
        case DBVT_NULL:
            str =  &quot;&#151;&#151;&quot;;
            break;
        default:
            str.Format(&quot;Unk type %d\n&quot;, var.m_dwType);
            TRACE(&quot;Unknown type %d\n&quot;, var.m_dwType);
        }
        pDC-&gt;TextOut(x, y, str);
        x += pDoc-&gt;m_arrayFieldSize[i] * m_nCharWidth;
    }
}</PRE>
<P>The code above is excerpted from a sample program EX31D, which is 
on the CD-ROM included with this book. That program uses the 
<I>CRowView</I> code from the DAO example, EX32A, described in the <A HREF="ch32a.htm">next chapter</A>. The 
programs EX31D and EX32A are similar in architecture and function. EX31D 
uses ODBC, and EX32A uses DAO.
<P>Although MFC gives you the <I>CRecordset</I> functions 
<I>GetODBCFieldCount</I> and 
<I>GetODBCFieldInfo</I> to get field lengths and types, you must call the 
ODBC function <I>SQLTables</I> to get a &quot;table of tables.&quot; The 
<I>CTables</I> class in the EX31D project encapsulates this table.
</BODY>
</HTML>



