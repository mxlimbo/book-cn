<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>A Custom Control DLL</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="488"><H1><B>A Custom Control DLL</B></H1></A>
<P>Programmers have been using DLLs for custom controls since the early 
days of Windows because custom controls are neatly self-contained. The 
original custom controls were written in pure C and configured as stand-alone 
DLLs. Today you can use the features of the MFC library in your custom controls, and you can use the wizards to make coding easier. A regular DLL is the best choice for a custom control because the control doesn't need a 
C++ interface and because it can be used by any development system that accepts custom controls (such as the Borland C++ compiler). You'll probably want to use the MFC dynamic linking option because the resulting DLL will be small and quick to load.

<A NAME="489"><H2><B>What Is a Custom Control?</B></H2></A>
<P>You've seen ordinary controls and Microsoft Windows common controls 
in <A HREF="ch06a.htm">Chapter 6</A>, and you've seen ActiveX controls in <A HREF="ch08a.htm">Chapter 8</A>. The custom 
control acts like an ordinary control, such as the edit control, in that it 
sends WM_COMMAND notification messages to its parent window and receives 
user-defined messages. The dialog editor lets you position custom controls in 
dialog templates. That's what the &quot;head&quot; control palette item, shown here, is for.

<P><img src="g22og05.gif" width=25 height=23 border="0">

<P>You have a lot of freedom in designing your custom control. You can 
paint anything you want in its window (which is managed by the client 
application) and you can define any notification and inbound messages you need. You 
can use ClassWizard to map normal Windows messages in the control 
(WM_LBUTTONDOWN, for example), but you must manually map the 
user-defined messages and manually map the notification messages in the parent window class.

<A NAME="490"><H2><B>A Custom Control's Window Class</B></H2></A>
<P>A dialog resource template specifies its custom controls by their symbolic 
<U>window</U> <U>class</U> names. Don't confuse the Win32 window class with the C++ class; the only similarity is the name. A window class is defined by a structure that contains the following:

<P><UL>
<LI>The name of the class
<P><LI>A pointer to the <I>WndProc</I> function that receives messages sent 
to windows of the class
<P><LI>Miscellaneous attributes, such as the background brush
</UL>

<P>The Win32 <I>RegisterClass</I> function copies the structure into process 
memory so that any function in the process can use the class to create a window. When the dialog window is initialized, Windows creates the custom control child windows from the window class names stored in the template.

<P>Suppose now that the control's <I>WndProc</I> function is inside a DLL. 
When the DLL is initialized (by a call to <I>DllMain</I>), it can call <I>RegisterClass</I> for the control. Because the DLL is part of the process, the client program can create child windows of the custom control class. To summarize, the client knows the name string of a control window class and it uses that class name to construct the child window. All the code for the control, including the <I>WndProc</I> function, is inside the DLL. All that's necessary is that the client load the DLL prior to creating the child window.

<A NAME="491"><H2><B>The MFC Library and the <I>WndProc</I> Function</B></H2></A>
<P>Okay, so Windows calls the control's <I>WndProc</I> function for each message sent to that window. But you really don't want to write an old-fashioned <I>switch-case</I> statement&#151;you want to map those messages to 
C++ member functions, as you've been doing all along. Now, in the DLL, you must rig up a C++ class that corresponds to the control's window class. Once you've done that, you can happily use ClassWizard to map messages.

<P>The obvious part is the writing of the C++ class for the control. You 
simply use ClassWizard to create a new class derived from <I>CWnd</I>. The tricky part is wiring the C++ class to the <I>WndProc</I> function and to the application framework's message pump. You'll see a real <I>WndProc</I> in the EX22D example, but here's the pseudocode for a typical control <I>WndProc</I> function:

<P><pre>
LRESULT MyControlWndProc(HWND hWnd, UINT message
                         WPARAM wParam, LPARAM lParam)
{
    if (this is the first message for this window) {
        CWnd* pWnd = new CMyControlWindowClass();
        attach pWnd to hWnd
    }
    return AfxCallWndProc(pWnd, hWnd, message, WParam, lParam);
}
</pre>

<P>The MFC <I>AfxCallWndProc</I> function passes messages to the 
framework, which dispatches them to the member functions mapped in 
<I>CMyControlWindowClass</I>.

<A NAME="492"><H2><B>Custom Control Notification Messages</B></H2></A>
<P>The control communicates with its parent window by sending it 
special WM_COMMAND notification messages with parameters, as shown here.
<P>

<table cellpadding=5 width="95%">
<tr><td valign="top"><b>Parameter</b></td>
<td valign="top"><b>Usage</b></td></tr>
<tr><td valign="top"><I>(HIWORD) wParam</I></td>
<td valign="top">Notification code</td></tr>
<tr><td valign="top"><I>(LOWORD) wParam</I></td>
<td valign="top">Child window ID</td></tr>
<tr><td valign="top"><I>lParam</I></td>
<td valign="top">Child window handle</td></tr>
</table>

<P>The meaning of the notification code is arbitrary and depends on 
the control. The parent window must interpret the code based on its 
knowledge of the control. For example, the code 77 might mean that the user typed a character while positioned on the control.

<P>The control might send a notification message such as this:

<P><pre>
GetParent()-&gt;SendMessage(WM_COMMAND,<p>
    GetDlgCtrlID() | ID_NOTIFYCODE &lt;&lt; 16, (LONG) GetSafeHwnd());
</pre>

<P>On the client side, you map the message with the MFC <I>ON_CONTROL</I> macro like this:

<P><pre>
ON_CONTROL(ID_NOTIFYCODE, IDC_MYCONTROL, OnClickedMyControl)
</pre>

<P>Then you declare the handler function like this:

<P><pre>
afx_msg void OnClickedMyControl();
</pre>

<A NAME="493"><H2><B>User-Defined Messages Sent to the Control</B></H2></A>
<P>You have already seen user-defined messages in <A HREF="ch07a.htm">Chapter 7</A>. This is the means 
by which the client program communicates with the control. Because a 
standard message returns a 32-bit value if it is sent rather than posted, the client can 
obtain information from the control.

<A NAME="494"><H2><B>The EX22D Example&#151;A Custom Control</B></H2></A>
<P>The EX22D program is an MFC regular DLL that implements a traffic light control indicating off, red, yellow, and green states. When clicked with the 
left mouse button, the DLL sends a clicked notification message to its parent 
and responds to two user-defined messages, RYG_SETSTATE and RYG_GETSTATE. The state is an integer that represents the color. Credit goes to Richard Wilton, who included the original C-language version of this control in his book <I>Windows 3 Developer's Workshop</I> (Microsoft Press, 1991).

<P>The EX22D project was originally generated using AppWizard, with 
linkage to the shared MFC DLL, just like EX22C. Figure 22-1 shows the code 
for the primary source file, with the added code in the <I>InitInstance</I> function in boldface. The dummy exported <I>Ex22dEntry</I> function exists solely to allow the DLL to be implicitly linked. The client program must include a call to this function. That call must be in an executable path in the program or the compiler will eliminate the call. As an alternative, the client program could call the Win32 <I>LoadLibrary</I> function in its <I>InitInstance</I> function to explicitly link the DLL.

<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>EX22D.CPP</B>
<P><pre>
// ex22d.cpp : Defines the initialization routines for the DLL.
//

#include &quot;stdafx.h&quot;
#include &quot;ex22d.h&quot;
<B>#include &quot;RygWnd.h&quot;</B>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif

<B>extern &quot;C&quot; __declspec(dllexport) void Ex22dEntry() {} // dummy function</B>

<I>(generated comment lines omitted)</I>

///////////////////////////////////////////////////////////////////////
// CEx22dApp

BEGIN_MESSAGE_MAP(CEx22dApp, CWinApp)
    //{{AFX_MSG_MAP(CEx22dApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////
// CEx22dApp construction

CEx22dApp::CEx22dApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

///////////////////////////////////////////////////////////////////////
// The one and only CEx22dApp object

CEx22dApp theApp;

BOOL CEx22dApp::InitInstance()
{
<B>    CRygWnd::RegisterWndClass(AfxGetInstanceHandle());</B>
    return CWinApp::InitInstance();
}
</pre>
</TD></TR></TABLE>

<P><B>Figure 22-1.</B> <I>The EX22D primary source listing.</I>


<P>Figure 22-2 shows the code for the <I>CRygWnd</I> class, including the global <I>RygWndProc</I> function. (Click the Add Class button in ClassWizard to create this class.) The code that paints the traffic light isn't very interesting, so we'll concentrate on the functions that are common to most custom controls. The static <I>RegisterWndClass</I> member function actually registers the <I>RYG</I> window class and must be called as soon as the DLL is loaded. The <I>OnLButtonDown</I> handler is called when the user presses the left mouse button inside the control window. It sends the clicked notification message to the parent window. The overridden <I>PostNcDestroy</I> function is important because it deletes the <I>CRygWnd</I> object when the client program destroys the control window. The <I>OnGetState</I> and <I>OnSetState</I> functions are called in response to user-defined messages sent by the client. Remember to copy the DLL to your system directory.

<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>RYGWND.H</B>
<P><pre>
#if !defined(AFX_RYGWND_H__1AA889D5_9788_11D0_BED2_00C04FC2A0C2
__INCLUDED_)
#define AFX_RYGWND_H__1AA889D5_9788_11D0_BED2_00C04FC2A0C2
__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// RygWnd.h : header file
//

///////////////////////////////////////////////////////////////////////
// CRygWnd window

<B>#define RYG_SETSTATE WM_USER + 0
#define RYG_GETSTATE WM_USER + 1

LRESULT CALLBACK AFX_EXPORT
    RygWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);</B>

class CRygWnd : public CWnd
{
<B>private:
    int m_nState; // 0=off, 1=red, 2=yellow, 3=green
    static CRect  s_rect;
    static CPoint s_point;
    static CRect  s_rColor[3];
    static CBrush s_bColor[4];</B>

// Construction
public:
    CRygWnd();
<B>public:
    static BOOL RegisterWndClass(HINSTANCE hInstance);</B>

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CRygWnd)
    protected:
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CRygWnd();

    // Generated message map functions
<B>private:
    void SetMapping(CDC* pDC);
    void UpdateColor(CDC* pDC, int n);</B>
protected:
    //{{AFX_MSG(CRygWnd)
    afx_msg void OnPaint();
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    //}}AFX_MSG
<B>    afx_msg LRESULT OnSetState(WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnGetState(WPARAM wParam, LPARAM lParam);</B>
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.
#endif // !defined(AFX_RYGWND_H__1AA889D5_9788_11D0_BED2_00C04FC2A0C2__INCLUDED_)
</pre>

<P><B>RYGWND.CPP</B>

<P><pre>
// RygWnd.cpp : implementation file
//

#include &quot;stdafx.h&quot;
#include &quot;ex22d.h&quot;
#include &quot;RygWnd.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif

<B>LRESULT CALLBACK AFX_EXPORT
    RygWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    CWnd* pWnd;

    pWnd = CWnd::FromHandlePermanent(hWnd);
    if (pWnd == NULL) {
        // Assume that client created a CRygWnd window
        pWnd = new CRygWnd();
        pWnd-&gt;Attach(hWnd);
    }
    ASSERT(pWnd-&gt;m_hWnd == hWnd);
    ASSERT(pWnd == CWnd::FromHandlePermanent(hWnd));
    LRESULT lResult = AfxCallWndProc(pWnd, hWnd, message,
                                     wParam, lParam);
    return lResult;
}</B>

///////////////////////////////////////////////////////////////////////
// CRygWnd

<B>// static data members
CRect  CRygWnd::s_rect(-500, 1000, 500, -1000); // outer rectangle
CPoint CRygWnd::s_point(300, 300); // rounded corners
CRect  CRygWnd::s_rColor[] = {CRect(-250, 800, 250, 300),
                              CRect(-250, 250, 250, -250),
                              CRect(-250, -300, 250, -800)};
CBrush CRygWnd::s_bColor[] = {RGB(192, 192, 192),
                              RGB(0xFF, 0x00, 0x00),
                              RGB(0xFF, 0xFF, 0x00),
                              RGB(0x00, 0xFF, 0x00)};

BOOL CRygWnd::RegisterWndClass(HINSTANCE hInstance) // static member
                                                    //  function
{
    WNDCLASS wc;
    wc.lpszClassName = &quot;RYG&quot;; // matches class name in client
    wc.hInstance = hInstance;
    wc.lpfnWndProc = RygWndProc;
    wc.hCursor = ::LoadCursor(NULL, IDC_ARROW);
    wc.hIcon = 0;
    wc.lpszMenuName = NULL;
    wc.hbrBackground = (HBRUSH) ::GetStockObject(LTGRAY_BRUSH);
    wc.style = CS_GLOBALCLASS;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    return (::RegisterClass(&amp;wc) != 0);
}

///////////////////////////////////////////////////////////////////////</B>

CRygWnd::CRygWnd()
{
<B>    m_nState = 0;
    TRACE(&quot;CRygWnd constructor\n&quot;);</B>
}

CRygWnd::~CRygWnd()
{
<B>    TRACE(&quot;CRygWnd destructor\n&quot;);</B>
}


BEGIN_MESSAGE_MAP(CRygWnd, CWnd)
    //{{AFX_MSG_MAP(CRygWnd)
    ON_WM_PAINT()
    ON_WM_LBUTTONDOWN()
    //}}AFX_MSG_MAP
<B>    ON_MESSAGE(RYG_SETSTATE, OnSetState)
    ON_MESSAGE(RYG_GETSTATE, OnGetState)</B>
END_MESSAGE_MAP()
<B>void CRygWnd::SetMapping(CDC* pDC)
{
    CRect clientRect;
    GetClientRect(clientRect);
    pDC-&gt;SetMapMode(MM_ISOTROPIC);
    pDC-&gt;SetWindowExt(1000, 2000);
    pDC-&gt;SetViewportExt(clientRect.right, -clientRect.bottom);
    pDC-&gt;SetViewportOrg(clientRect.right / 2, clientRect.bottom / 2);
}

void CRygWnd::UpdateColor(CDC* pDC, int n)
{
    if (m_nState == n + 1) {
        pDC-&gt;SelectObject(&amp;s_bColor[n+1]);
    }
    else {
        pDC-&gt;SelectObject(&amp;s_bColor[0]);
    }
    pDC-&gt;Ellipse(s_rColor[n]);
}</B>

///////////////////////////////////////////////////////////////////////
// CRygWnd message handlers

void CRygWnd::OnPaint() 
{
<B>    int i;</B>
    CPaintDC dc(this); // device context for painting
<B>    SetMapping(&amp;dc);
    dc.SelectStockObject(DKGRAY_BRUSH);
    dc.RoundRect(s_rect, s_point);
    for (i = 0; i &lt; 3; i++) {
        UpdateColor(&amp;dc, i);
    }</B>
}

void CRygWnd::OnLButtonDown(UINT nFlags, CPoint point) 
{
<B>    // Notification code is HIWORD of wParam, 0 in this case
    GetParent()-&gt;SendMessage(WM_COMMAND, GetDlgCtrlID(),
        (LONG) GetSafeHwnd()); // 0</B>
}
void CRygWnd::PostNcDestroy() 
{
<B>    TRACE(&quot;CRygWnd::PostNcDestroy\n&quot;);
    delete this; // CWnd::PostNcDestroy does nothing</B>
}

<B>LRESULT CRygWnd::OnSetState(WPARAM wParam, LPARAM lParam)
{
    TRACE(&quot;CRygWnd::SetState, wParam = %d\n&quot;, wParam);
    m_nState = (int) wParam;
    Invalidate(FALSE);
    return 0L;
}

LRESULT CRygWnd::OnGetState(WPARAM wParam, LPARAM lParam)
{
    TRACE(&quot;CRygWnd::GetState\n&quot;);
    return m_nState;
}
</B></pre>
</TD></TR></TABLE>

<P><b>Figure 22-2.</B> <I>The </I>CRygWnd<I> class listing.</I>


<H2><B>Revising the Updated EX22B Example&#151;Adding Code to Test ex22d.dll</B></H2>

<P>The EX22B program already links to the EX22A and EX22C DLLs. Now you'll revise the project to implicitly link to the EX22D custom control.

<P>Here are the steps for updating the EX22B example:

<ol>
<P><B><LI>Add a new dialog resource and class to \vcpp32\ex22b\ex22b.</B>Use the dialog editor to create the <I>IDD_EX22D</I> template with a custom control with child window ID <I>IDC_RYG</I>, as shown here.
</ol>

<P><img src="g22og06.gif" width=285 height=179 border="0">

<ol>
<P>Specify <I>RYG</I> as the window class name of the custom control, as shown.
</ol>

<P><img src="g22og07.gif" width=403 height=162 border="0">

<ol start=2>
<P>Then use ClassWizard to generate a class <I>CTest22dDialog</I>, derived from <I>CDialog</I>.

<P><B><LI>Edit the Test22dDialog.h file.</B> Add the following private data member:

<P><pre>
enum { OFF, RED, YELLOW, GREEN } m_nState;
</pre>

<P>Also add the following import and user-defined message IDs:

<P><pre>
extern &quot;C&quot; __declspec(dllimport) void Ex22dEntry(); // dummy function
#define RYG_SETSTATE WM_USER + 0
#define RYG_GETSTATE WM_USER + 1
</pre>

<P><B><LI>Edit the constructor in Test22dDialog.cpp to initialize the state 
data member.</B> Add the following boldface code:

<P><pre>
CTest22dDialog::CTest22dDialog(CWnd* pParent /*=NULL*/)
    : CDialog(CTest22dDialog::IDD, pParent)
{
    //{{AFX_DATA_INIT(CTest22dDialog)
      // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
<B>    m_nState = OFF;
    Ex22dEntry(); // Make sure DLL gets loaded</B>
}
</pre>

<P><B><LI>Map the control's clicked notification message.</B> You can't use ClassWizard here, so you must add the message map entry and handler function in the Test22dDialog.cpp file, as shown here:

<P><pre>
ON_CONTROL(0, IDC_RYG, OnClickedRyg) // Notification code is 0

void CTest22dDialog::OnClickedRyg()
{
    switch(m_nState) {
    case OFF:
        m_nState = RED;
        break;
    case RED:
        m_nState = YELLOW;
        break;
    case YELLOW:
        m_nState = GREEN;
        break;
    case GREEN:
        m_nState = OFF;
        break;
    }
    GetDlgItem(IDC_RYG)-&gt;SendMessage(RYG_SETSTATE, m_nState);
    return;
}
</pre>

<P>When the dialog gets the clicked notification message, it sends 
the RYG_SETSTATE message back to the control in order to change 
the color. Don't forget to add this prototype in the Test22dDialog.h file:

<P><pre>
afx_msg void OnClickedRyg();
</pre>

<P><B><LI>Integrate the <I>CTest22dDialog</I> class into the EX22B application. </B> You'll need to add a second item on the Test menu, an Ex22d DLL option with ID <I>ID_TEST_EX22DDLL</I>. Use ClassWizard to map this option to a member function in the <I>CEx22bView</I> class, and then code the handler in Ex22bView.cpp as follows:

<P><pre>
void CEx22bView::OnTestEx22ddll()
{
    CTest22dDialog dlg;
    dlg.DoModal();
}
</pre>

<P>Of course, you'll have to add the following line to Ex22bView.cpp:

<P><pre>
#include &quot;Test22dDialog.h&quot;
</pre>

<P><B><LI>Add the EX22D import library to the linker's input library list.</B> Choose Settings from Visual C++'s Project menu, and then <U>add</U> <I>\vcpp32\ex22d\Debug\ex22d.lib</I> to the Object/Library Modules control on the Link page. With this addition, the program should implicitly link to all three DLLs.

<P><B><LI>Build and test the updated EX22B application.</B> Choose Ex22d DLL from the Test menu. Try clicking the traffic light with the left mouse button. The traffic-light color should change. The result of clicking the traffic light several times is shown here.
</ol>

<P><img src="g22og08.gif" width=285 height=179 border="0">

</BODY>
</HTML>



