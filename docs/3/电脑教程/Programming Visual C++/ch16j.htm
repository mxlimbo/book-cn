<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The CObList Collection Class</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="327"><H1>The <I>CObList</I> Collection Class</H1></A><P>Once you get to know the collection classes, you'll wonder how you ever got along without them. The <I>CObList</I> class is a useful representative of the collection class family. If you're familiar with this class, it's easy to learn the other list classes, the array classes, and the map classes.
<P>You might think that collections are something new, but the C programming language has always supported one kind of collection&#151;the array. C arrays must be fixed in size, and they do not support insertion of elements. Many C programmers have written function libraries for other collections, including linked lists, dynamic arrays, and indexed dictionaries. For implementing 
collections, the C++ class is an obvious and better alternative than a C function library. A list object, for example, neatly encapsulates the list's internal data structures.
<P>The <I>CObList</I> class supports ordered lists of pointers to objects of 
classes derived from <I>CObject</I>. Another MFC collection class, <I>CPtrList</I>, stores <I>void</I> pointers instead of <I>CObject</I> pointers. Why not use <I>CPtrList</I> instead? The <I>CObList</I> class offers advantages for diagnostic dumping, which you'll see in this chapter, and for serialization, which you'll see in the next chapter. One important feature of <I>CObList</I> is that it can contain <U>mixed</U> pointers. In other words, a 
<I>CObList</I> collection can hold pointers to both <I>CStudent</I> objects and <I>CTeacher</I> objects, assuming that both <I>CStudent</I> and <I>CTeacher</I> were derived from <I>CObject</I>.
<H2>Using the <I>CObList</I> Class for a First-In, First-Out List</H2>
<P>One of the easiest ways to use a <I>CObList</I> object is to add new elements to the tail, or bottom, of the list and to remove elements from the head, or top, of the list. The first element added to the list will always be the first element removed from the head of the list. Suppose you're working with element objects of class <I>CAction</I>, which is your own custom class derived from <I>CObject</I>. A command-line program that puts five elements into a list and then retrieves them in the same sequence is shown here:
<P><PRE>#include &lt;afx.h&gt;
#include &lt;afxcoll.h&gt;

class CAction : public CObject
{
private:
    int m_nTime;
public:
    CAction(int nTime) { m_nTime = nTime; } // Constructor stores
                                            //  integer time value
    void PrintTime() { TRACE(&quot;time = %d\n&quot;, m_nTime); }
};

int main()
{
    CAction* pAction;
    CObList actionList; // action list constructed on stack
    int i;

    // inserts action objects in sequence {0, 1, 2, 3, 4}
    for (i = 0; i &lt; 5; i++) {
        pAction = new CAction(i);
        actionList.AddTail(pAction); // no cast necessary for pAction
    }

    // retrieves and removes action objects in sequence {0, 1, 2, 3, 4}
    while (!actionList.IsEmpty()) {
        pAction =                               // cast required for
            (CAction*) actionList.RemoveHead(); //  return value
        pAction-&gt;PrintTime();
        delete pAction;
    }

    return 0;
}</PRE>
<P>Here's what's going on in the program. First a <I>CObList</I> object, <I>actionList</I>, is constructed. Then the <I>CObList::AddTail</I> member function inserts pointers to newly constructed <I>CAction</I> objects. No casting is necessary for <I>pAction</I> because <I>AddTail</I> takes a 
<I>CObject</I> pointer parameter and <I>pAction</I> is a pointer to a derived class.
<P>Next the <I>CAction</I> object pointers are removed from the list of the 
objects deleted. A cast is necessary for the returned value of <I>RemoveHead</I> because <I>RemoveHead</I> returns a <I>CObject</I> pointer that is <U>higher</U> in the class hierarchy than <I>CAction</I>.
<P>When you remove an object pointer from a collection, the object is not automatically deleted. The <I>delete</I> statement is necessary for deleting the <I>CAction</I> objects.
<A NAME="328"><H2><I>CObList</I> Iteration&#151;The <I>POSITION</I> Variable</H2></A><P>Suppose you want to iterate through the elements in a list. The <I>CObList</I> class provides a <I>GetNext</I> member function that returns a pointer to the &quot;next&quot; list element, but using it is a little tricky. <I>GetNext</I> takes a parameter of type <I>POSITION</I>, which is a 32-bit variable. The <I>POSITION</I> variable is an internal representation of the retrieved element's position in the list. Because the <I>POSITION</I> parameter is declared as a reference (&amp;), the function can change its value.
<P><I>GetNext</I> does the following:
<OL>
<LI>It returns a pointer to the &quot;current&quot; object in the list, identified by the incoming value of the <I>POSITION</I> parameter.<P>
<LI>It increments the value of the <I>POSITION</I> parameter to the next list element.
</OL>
<P>Here's what a <I>GetNext</I> loop looks like, assuming you're using the list 
generated in the previous example:
<P><PRE>CAction* pAction;
POSITION pos = actionList.GetHeadPosition();
while (pos != NULL) {
    pAction = (CAction*) actionList.GetNext(pos);
    pAction-&gt;PrintTime();
}</PRE>
<P>Now suppose you have an interactive Windows-based application that uses toolbar buttons to sequence forward and backward through the list one element at a time. You can't use <I>GetNext</I> to retrieve the entry because <I>GetNext</I> always <U>increments</U> the <I>POSITION</I> variable and you don't know in advance whether the user is going to want the next element or the previous element. Here's a sample view class command message handler function that gets the next list entry. In the <I>CMyView</I> class, <I>m_actionList</I> is an embedded <I>CObList</I> object and the <I>m_position</I> data member is a 
<I>POSITION</I> variable that holds the current list position.
<P><PRE>CMyView::OnCommandNext()
{
    POSITION pos;
    CAction*  pAction;

    if ((pos = m_position) != NULL) {
        m_actionList.GetNext(pos);
        if (pos != NULL) { // pos is NULL at end of list
            pAction = (CAction*) m_actionList.GetAt(pos);
            pAction-&gt;PrintTime();
            m_position = pos;
        }
        else {
            AfxMessageBox(&quot;End of list reached&quot;);
        }
    }
}</PRE>
<P><I>GetNext</I> is now called first to increment the list position, and the 
<I>CObList::GetAt</I> member function is called to retrieve the entry. The 
<I>m_position</I> variable is updated only when we're sure we're not at the tail of the list.
<A NAME="329"><H2>The <I>CTypedPtrList</I> Template Collection Class</H2></A>
<P>The <I>CObList</I> class works fine if you want a collection to contain mixed pointers. If, on the other hand, you want a type-safe collection that contains only one type of object pointer, you should look at the MFC library template pointer collection classes. <I>CTypedPtrList</I> is a good example. Templates are a relatively new C++ language element, introduced by Microsoft Visual C++ version 2.0. <I>CTypedPtrList</I> is a template class that you can use to create a list of any pointers to objects of any specified class. To make a long story short, you use the template to create a custom derived list class, using either <I>CPtrList</I> or <I>CObList</I> as a base class.
<P>To declare an object for <I>CAction</I> pointers, you write the following line of code:
<P><PRE>CTypedPtrList&lt;CObList, CAction*&gt; m_actionList;</PRE>
<P>The first parameter is the base class for the collection, and the second 
parameter is the type for parameters and return values. Only <I>CPtrList</I> and <I>CObList</I> are permitted for the base class because those are the only two MFC library pointer list classes. If you are storing objects of classes derived from <I>CObject</I>, you should use <I>CObList</I> as your base class; otherwise, use <I>CPtrList</I>.
<P>By using the template as shown above, the compiler ensures that all list 
member functions return a <I>CAction</I> pointer. Thus, you can write the following code:
<P><PRE>pAction = m_actionList.GetAt(pos); // no cast required</PRE>
<P>If you want to clean up the notation a little, use a <I>typedef</I> statement to generate what looks like a class, as shown here:
<P><PRE>typedef CTypedPtrList&lt;CObList, CAction*&gt; CActionList;</PRE>
<P>Now you can declare <I>m_actionList</I> as follows:
<P><PRE>CActionList m_actionList;</PRE>
<A NAME="330"><H2>The Dump Context and Collection Classes</H2></A><P>The <I>Dump</I> function for <I>CObList</I> and the other collection classes has a 
useful property. If you call <I>Dump</I> for a collection object, you can get a display of each object in the collection. If the element objects use the 
<I>DECLARE_DYNAMIC</I> and <I>IMPLEMENT_DYNAMIC</I> macros, the dump will show the class name for each object.
<P>The default behavior of the collection <I>Dump</I> functions is to display only class names and addresses of element objects. If you want the collection 
<I>Dump</I> functions to call the <I>Dump</I> function for each element object, you must, somewhere at the start of your program, make the following call:
<P><PRE>#ifdef _DEBUG
    afxDump.SetDepth(1);
#endif</PRE>
<P>Now the statement
<P><PRE>#ifdef _DEBUG
    afxDump &lt;&lt; actionList;
#endif</PRE>
<P>produces output such as this:
<P><PRE>a CObList at $411832
with 4 elements
    a CAction at $412CD6
time = 0
    a CAction at $412632
time = 1
    a CAction at $41268E
time = 2
    a CAction at $4126EA
time = 3</PRE>
<P>If the collection contains mixed pointers, the virtual <I>Dump</I> function is called for the object's class and the appropriate class name is printed.
</BODY>
</HTML>



