<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The EX27A Example -- Structured Storage</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="613"><H1><B>The EX27A Example&#151;Structured Storage</B></H1></A>
<P>When you choose the Storage Write option in the EX27A example, the program walks through your entire disk directory looking for TXT files. As it looks, it writes a compound file (\direct.stg) on the top level of your directory structure. This file contains storages that match your subdirectories. For each TXT file that the program finds in a subdirectory, it copies the first line of text to a stream in the corresponding storage. When you choose the Storage Read option, the program reads the direct.stg compound file and prints the contents of this file in the Debug window.

<P>If you create such an example from scratch, use AppWizard without any ActiveX or Automation options and then add the following lines in your StdAfx.h file:

<P><pre>
#include &lt;afxole.h&gt;
#include &lt;afxpriv.h&gt; // for wide-character conversion
</pre>

<P>Then delete the following line:

<P><pre>
#define VC_EXTRALEAN
</pre>

<P>To prepare EX27A, open the \vcpp32\ex27a\ex27a.dsw workspace and build the project. Run the program from the debugger. First choose Write from the Storage menu and wait for a &quot;Write complete&quot; message box. Then choose Read. Observe the output in the Debug window.

<A NAME="614"><H2><B>The Menu</B></H2></A>
<P>The EX27A example has an added top-level Storage menu with Write and Read options.

<A NAME="615"><H2><B>The <I>CEx27aView</I> Class</B></H2></A>
<P>This class maps the new Storage Read and Write menu commands listed above to start worker threads. The handlers are shown here:

<P><pre>
void CEx27aView::OnStorageRead()
{
    CWinThread* pThread = AfxBeginThread(ReadThreadProc, GetSafeHwnd());
}

void CEx27aView::OnStorageWrite()
{
    CWinThread* pThread = AfxBeginThread(WriteThreadProc, GetSafeHwnd());
}
</pre>

<A NAME="616"><H2><B>The Worker Threads</B></H2></A>
<P>Figure 27-2 lists the code for the Storage Write and Storage Read worker threads.


<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>THREAD.H</B>
<p><pre>
extern int g_nIndent;
extern const char* g_szBlanks;
extern const char* g_szRootStorageName;

UINT WriteThreadProc(LPVOID pParam);
UINT ReadThreadProc(LPVOID pParam);
void ReadDirectory(const char* szPath, LPSTORAGE pStg);
void ReadStorage(LPSTORAGE pStg);
</pre>

<p><B>WRITETHREAD.CPP</B>
<p><pre>
#include &quot;StdAfx.h&quot;
#include &quot;Thread.h&quot;

int g_nIndent = 0;
const char* g_szBlanks = &quot;                                          &quot;;
const char* g_szRootStorageName = &quot;\\direct.stg&quot;;

UINT WriteThreadProc(LPVOID pParam)
{
    USES_CONVERSION;
    LPSTORAGE pStgRoot = NULL;
    g_nIndent = 0;
    VERIFY(::StgCreateDocfile(T2COLE(g_szRootStorageName),
           STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
           0, &amp;pStgRoot) == S_OK);
    ReadDirectory(&quot;\\&quot;, pStgRoot);
    pStgRoot-&gt;Release();
    AfxMessageBox(&quot;Write complete&quot;);
    return 0;
}

void ReadDirectory(const char* szPath, LPSTORAGE pStg)
{
    // recursive function
    USES_CONVERSION;
    WIN32_FIND_DATA fData;
    HANDLE h;
    char szNewPath[MAX_PATH];
    char szStorageName[100];
    char szStreamName[100];
    char szData[81];
    char* pch = NULL;
    LPSTORAGE pSubStg = NULL;
    LPSTREAM pStream = NULL;

    g_nIndent++;
    strcpy(szNewPath, szPath);
    strcat(szNewPath, &quot;*.*&quot;);
    h = ::FindFirstFile(szNewPath, &amp;fData);
    if (h == (HANDLE) 0xFFFFFFFF) return;  // can't find directory
    do {
        if (!strcmp(fData.cFileName, &quot;..&quot;) ||
            !strcmp(fData.cFileName, &quot;.&quot;) ) continue;
        while((pch = strchr(fData.cFileName, `!')) != NULL) {
            *pch = `|';
        }
        if (fData.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {
            // It's a directory, so make a storage
            strcpy(szNewPath, szPath);
            strcat(szNewPath, fData.cFileName);
            strcat(szNewPath, &quot;\\&quot;);

            strcpy(szStorageName, fData.cFileName);
            szStorageName[31] = `\0';    // limit imposed by OLE
            TRACE(&quot;%0.*sStorage = %s\n&quot;, (g_nIndent - 1) * 4,
                  g_szBlanks, szStorageName);
            VERIFY(pStg-&gt;CreateStorage(T2COLE(szStorageName),
                   STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
                   0, 0, &amp;pSubStg) == S_OK);
            ASSERT(pSubStg != NULL);
            ReadDirectory(szNewPath, pSubStg);
            pSubStg-&gt;Release();
        }
        else {
            if ((pch = strrchr(fData.cFileName, `.')) != NULL) {
                if (!stricmp(pch, &quot;.TXT&quot;)) {
                    // It's a text file, so make a stream
                    strcpy(szStreamName, fData.cFileName);
                    strcpy(szNewPath, szPath);
                    strcat(szNewPath, szStreamName);
                    szStreamName[32] = `\0'; // OLE max length
                    TRACE(&quot;%0.*sStream = %s\n&quot;, (g_nIndent - 1) * 4,
                          g_szBlanks, szNewPath);
                    CStdioFile file(szNewPath, CFile::modeRead);
                    // Ignore zero-length files
                    if(file.ReadString(szData, 80)) {
                        TRACE(&quot;%s\n&quot;, szData);
                       VERIFY(pStg-&gt;CreateStream(T2COLE(szStreamName),
                               STGM_CREATE | STGM_READWRITE | 
                               STGM_SHARE_EXCLUSIVE,
                               0, 0, &amp;pStream) == S_OK);
                        ASSERT(pStream != NULL);
                        // Include the null terminator in the stream
                        pStream-&gt;Write(szData, strlen(szData) + 1, NULL);
                        pStream-&gt;Release();
                    }
                }
            }
        }
    } while (::FindNextFile(h, &amp;fData));
    g_nIndent&#151;;
}
</pre>

<p><B>READTHREAD.CPP</B>
<p><pre>
#include &quot;StdAfx.h&quot;
#include &quot;Thread.h&quot;

UINT ReadThreadProc(LPVOID pParam)
{
    USES_CONVERSION;
    LPSTORAGE pStgRoot = NULL;
    // doesn't work without STGM_SHARE_EXCLUSIVE
    g_nIndent = 0;
    if (::StgOpenStorage(T2COLE(g_szRootStorageName), NULL,
        STGM_READ | STGM_SHARE_EXCLUSIVE,
        NULL, 0, &amp;pStgRoot) == S_OK) {
        ASSERT(pStgRoot!= NULL);
        ReadStorage(pStgRoot);
        pStgRoot-&gt;Release();
    }
    else {
        AfxMessageBox(&quot;Storage file not available or not readable.&quot;);
    }
    AfxMessageBox(&quot;Read complete&quot;);
    return 0;
}

void ReadStorage(LPSTORAGE pStg)
// reads one storage &#151; recursive calls for substorages
{
    USES_CONVERSION;
    LPSTORAGE pSubStg = NULL;
    LPSTREAM pStream = NULL;
    LPENUMSTATSTG pEnum = NULL;
    LPMALLOC pMalloc = NULL; // for freeing statstg
    STATSTG statstg;
    ULONG nLength;
    BYTE buffer[101];

    g_nIndent++;
    ::CoGetMalloc(MEMCTX_TASK, &amp;pMalloc); // assumes AfxOleInit
                                          //  was called
    VERIFY(pStg-&gt;EnumElements(0, NULL, 0, &amp;pEnum) == S_OK);
    while (pEnum-&gt;Next(1, &amp;statstg, NULL) == S_OK) {
        if (statstg.type == STGTY_STORAGE) {
            VERIFY(pStg-&gt;OpenStorage(statstg.pwcsName, NULL,
                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                   NULL, 0, &amp;pSubStg) == S_OK);
            ASSERT(pSubStg != NULL);
            TRACE(&quot;%0.*sStorage = %s\n&quot;, (g_nIndent - 1) * 4,
                  g_szBlanks, OLE2CT(statstg.pwcsName));
            ReadStorage(pSubStg);
            pSubStg-&gt;Release();
        }
        else if (statstg.type == STGTY_STREAM) {
            VERIFY(pStg-&gt;OpenStream(statstg.pwcsName, NULL,
                   STGM_READ | STGM_SHARE_EXCLUSIVE,
                   0, &amp;pStream) == S_OK);
            ASSERT(pStream != NULL);
            TRACE(&quot;%0.*sStream = %s\n&quot;, (g_nIndent - 1) * 4,
                  g_szBlanks, OLE2CT(statstg.pwcsName));
            pStream-&gt;Read(buffer, 100, &amp;nLength);
            buffer[nLength] = `\0';
            TRACE(&quot;%s\n&quot;, buffer);
            pStream-&gt;Release();
        }
        else {
            ASSERT(FALSE);  // LockBytes?
        }
        pMalloc-&gt;Free(statstg.pwcsName); // avoids memory leaks
    }
    pMalloc-&gt;Release();
    pEnum-&gt;Release();
    g_nIndent&#151;;
}
</pre>
<TD></TR></TABLE>
<P><B>Figure 27-2.</B> <I>The Storage menu worker threads.</I>


<P>To keep the program simple, there's no synchronization between the main thread and the two worker threads. You could run both threads at the same time if you used two separate compound files.

<P>From your study of the Win32 threading model, you might expect that closing the main window would cause the read thread or write thread to terminate &quot;midstream,&quot; possibly causing memory leaks. But this does not happen because MFC senses that the worker threads are using COM objects. Even though the window closes immediately, the program does not exit until all threads exit.

<P>Both threads use recursive functions. The <I>ReadStorage</I> function reads a storage and calls itself to read the substorages. The <I>ReadDirectory</I> function reads a directory and calls itself to read the subdirectories. This function calls the Win32 functions <I>FindFirstFile</I> and 
<I>FindNextFile</I> to iterate through the elements in a directory. The <I>dwFileAttributes</I> member of the <I>WIN32_FIND_DATA</I> structure indicates whether the element is a file or a subdirectory. 
<I>ReadDirectory</I> uses the MFC <I>CStdioFile</I> class because the class is ideal for reading text.

<P>The <I>USES_CONVERSION</I> macro is necessary to support the wide-character conversion macros <I>OLE2CT</I> and <I>T2COLE</I>. These macros are used here because the example doesn't use the 
<I>CString</I> class, which has built-in conversion logic.

</BODY>
</HTML>



