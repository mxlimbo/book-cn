<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The EX05C Example -- CScrollView Revisited</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="118"><H1>The EX05C Example&#151;<I>CScrollView</I> Revisited</H1></A><P>You saw the <I>CScrollView</I> class in <A HREF="ch04a.htm">Chapter 4</A> (in EX04C). The EX05C program allows the user to move an ellipse with a mouse by &quot;capturing&quot; the mouse, using a scrolling window with the <I>MM_LOENGLISH</I> mapping mode. Keyboard scrolling is left out, but you can add it by borrowing the <I>OnKeyDown</I> member function from EX04C.
<P>Instead of a stock brush, we'll use a pattern brush for the ellipse&#151;a 
real GDI object. There's one complication with pattern brushes: you must reset 
the origin as the window scrolls; otherwise, strips of the pattern don't line up and the effect is ugly.
<P>As with the EX04C program, this example involves a view class derived from <I>CScrollView</I>. Here are the steps to create the application:
<OL>
<P><B><LI>Run AppWizard to generate the EX05C project.</B> Be sure to set the view base class to <I>CScrollView</I>. The options and the default class names are shown here.<P>

<P><img src="G05OG07x.Gif" width=413 height=418 border=0> <P>

<B><LI>Edit the <I>CEx05cView</I> class header in the file ex05cView.h.</B>Add the following lines in the class<I> CEx05cView</I> declaration:<P>
<PRE><B>private:
    const CSize m_sizeEllipse; //
 logical
    CPoint m_pointTopLeft; // logical, top left of ellipse rectangle
    CSize  m_sizeOffset; // device, from rect top left 
                       
  //  to capture point
    BOOL   m_bCaptured;
</B></PRE><P>
<B><LI>Use ClassWizard to add three message handlers to the <I>CEx05cView</I> class.</B> Add the message handlers as follows:<P>

<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>Message</B></TD><TD VALIGN="TOP"><B>Member Function</B></TD></TR>
<TR><TD VALIGN="TOP">WM_LBUTTONDOWN</TD><TD VALIGN="TOP"><I>OnLButtonDown</I></TD></TR>
<TR><TD VALIGN="TOP">WM_LBUTTONUP</TD><TD VALIGN="TOP"><I>OnLButtonUp</I></TD></TR>
<TR><TD VALIGN="TOP">WM_MOUSEMOVE</TD><TD VALIGN="TOP"><I>OnMouseMove</I></TD></TR>
</TABLE>

<P><B><LI>Edit the <I>CEx05cView</I> message handler functions.</B> ClassWizard generated the skeletons for the functions listed in the preceding step. Find the functions in ex05cView.cpp, and code them as follows.<P>
<PRE>void CEx05cView::OnLButtonDown(UINT nFlags, CPoint point) 
{
    <B>CRect rectEllipse(m_pointTopLeft, m_sizeEllipse); // still logical
    CRgn  circle;

    CClientDC dc(this);
    OnPrepareDC(&amp;dc);
    dc.LPtoDP(rectEllipse); // Now it's in device coordinates
    circle.CreateEllipticRgnIndirect(rectEllipse);
    if (circle.PtInRegion(point)) {
        // Capturing the mouse ensures subsequent LButtonUp message
        SetCapture();
        m_bCaptured = TRUE;
        CPoint pointTopLeft(m_pointTopLeft);
        dc.LPtoDP(&amp;pointTopLeft);
        m_sizeOffset = point - pointTopLeft; // device coordinates
        // New mouse cursor is active while mouse is captured
        ::SetCursor(::LoadCursor(NULL, IDC_CROSS));
    }</B>
}

void CEx05cView::OnLButtonUp(UINT nFlags, CPoint point) 
{
    <B>if (m_bCaptured) {
        ::ReleaseCapture();
        m_bCaptured = FALSE;
    }</B>
}

void CEx05cView::OnMouseMove(UINT nFlags, CPoint point) 
{
    <B>if (m_bCaptured) {
        CClientDC dc(this);
        OnPrepareDC(&amp;dc);
        CRect rectOld(m_pointTopLeft, m_sizeEllipse);
        dc.LPtoDP(rectOld);
        InvalidateRect(rectOld, TRUE);
        m_pointTopLeft = point - m_sizeOffset;
        dc.DPtoLP(&amp;m_pointTopLeft);
        CRect rectNew(m_pointTopLeft, m_sizeEllipse);
        dc.LPtoDP(rectNew);
        InvalidateRect(rectNew, TRUE);
    }</B>
}
</PRE><P>
<B><LI>Edit the <I>CEx05cView</I> constructor, the <I>OnDraw</I> function, and the <I>OnInitialUpdate</I> function.</B> AppWizard generated these skeleton functions. Find them in ex05cView.cpp, and code them as follows:<P>
<PRE>CEx05cView::CEx05cView() <B>: m_sizeEllipse(100, -100),
                           m_pointTopLeft(0, 0),
                           m_sizeOffset(0, 0)</B>
{
    <B>m_bCaptured = FALSE;</B>
}

void CEx05cView::OnDraw(CDC* pDC)
{
    <B>CBrush brushHatch(HS_DIAGCROSS, RGB(255, 0, 0));
    CPoint point(0, 0);                  // logical (0, 0)

    pDC-&gt;LPtoDP(&amp;point);                 // In device coordinates,
    pDC-&gt;SetBrushOrg(point);             //  align the brush with
                                         //  the window origin
    pDC-&gt;SelectObject(&amp;brushHatch);
    pDC-&gt;Ellipse(CRect(m_pointTopLeft, m_sizeEllipse));
    pDC-&gt;SelectStockObject(BLACK_BRUSH); // Deselect brushHatch
    pDC-&gt;Rectangle(CRect(100, -100, 200, -200)); // Test invalid rect</B>
}

void CEx05cView::OnInitialUpdate()
{
    CScrollView::OnInitialUpdate();

    <B>CSize sizeTotal(800, 1050); // 8-by-10.5 inches
    CSize sizePage(sizeTotal.cx / 2, sizeTotal.cy / 2);
    CSize sizeLine(sizeTotal.cx / 50, sizeTotal.cy / 50);
    SetScrollSizes(MM_LOENGLISH, sizeTotal, sizePage, sizeLine);</B>
}
</PRE><P>
<B><LI>Build and run the EX05C program.</B> The program allows an ellipse to be dragged with the mouse, and it allows the window to be scrolled through. The program's window should look like the one shown here. As you move the ellipse, observe the black rectangle. You should be able to see the effects of invalidating the rectangle.<P>

<P><IMG SRC="G05OG08.GIF" width=325 height=342 BORDER=0><P>
</OL>

<A NAME="119"><H2>The EX05C Program Elements</H2></A><P>Following is a discussion of the important elements in the EX05C example.
<A NAME="120"><H3>The <I>m_sizeEllipse</I> and <I>m_pointTopLeft </I>Data Members</H3></A><P>Rather than store the ellipse's bounding rectangle as a single <I>CRect</I> object, the program separately stores its size (<I>m_sizeEllipse</I>) and the position of its top left corner (<I>m_pointTopLeft</I>). To move the ellipse, the program merely recalculates <I>m_pointTopLeft</I>, and any round-off errors in the calculation won't affect the size of the ellipse.
<A NAME="121"><H3>The <I>m_sizeOffset</I> Data Member</H3></A><P>When <I>OnMouseMove</I> moves the ellipse, the relative position of the mouse within the ellipse must be the same as it was when the user first pressed the left 
mouse button. The <I>m_sizeOffset</I> object stores this original offset of the mouse from the top left corner of the ellipse rectangle.
<A NAME="122"><H3>The <I>m_bCaptured</I> Data Member</H3></A><P>The <I>m_bCaptured</I> Boolean variable is set to TRUE when mouse tracking is in progress.
<A NAME="123"><H3>The <I>SetCapture</I> and <I>ReleaseCapture</I> Functions</H3></A><P><I>SetCapture</I> is the <I>CWnd</I> member function that &quot;captures&quot; the mouse, such that mouse movement messages are sent to this window even if the mouse cursor is outside the window. An unfortunate side effect of this function is that the ellipse can be moved outside the window and &quot;lost.&quot; A desirable and necessary effect is that <U>all</U> subsequent mouse messages are sent to the window, including the WM_LBUTTONUP message, which would otherwise be lost. The Win32 <I>ReleaseCapture</I> function turns off mouse capture.
<A NAME="124"><H3>The <I>SetCursor</I> and <I>LoadCursor</I> Win32 Functions</H3></A>
<P>The MFC library does not &quot;wrap&quot; some Win32 functions. By convention, we use the C++ scope resolution operator (::) when calling Win32 functions directly. In this case, there is no potential for conflict with a 
<I>CView</I> member function, but you can deliberately choose to call a Win32 function in place of a class member function with the same name. In that case, the :: operator ensures that you call the globally scoped Win32 function.
<P>When the first parameter is <I>NULL</I>, the <I>LoadCursor</I> function creates a <U>cursor</U> <U>resource</U> from the specified predefined mouse cursor that Windows uses. The <I>SetCursor</I> function activates the specified cursor resource. This cursor remains active as long as the mouse is captured.
<A NAME="125"><H3>The <I>CScrollView::OnPrepareDC</I> Member Function</H3></A><P>The <I>CView</I> class has a virtual <I>OnPrepareDC</I> function that does nothing. The <I>CScrollView</I> class implements the function for the purpose of setting the view's mapping mode and origin, based on the parameters that you passed to <I>SetScrollSizes</I> in <I>OnCreate</I>. The application framework calls <I>OnPrepareDC</I> for you prior to calling 
<I>OnDraw</I>, so you don't need to worry about it. You must call <I>OnPrepareDC</I> yourself in any other message handler function that uses 
the view's device context, such as <I>OnLButtonDown</I> and <I>OnMouseMove</I>.
<A NAME="126"><H3>The <I>OnMouseMove</I> Coordinate Transformation Code</H3></A><P>As you can see, this function contains several translation statements. The logic can be summarized by the following steps:
<OL>
<LI>Construct the previous ellipse rectangle and convert it from logical to device coordinates.<P>
<LI>Invalidate the previous rectangle.<P>
<LI>Update the top left coordinate of the ellipse rectangle.<P>
<LI>Construct the new rectangle and convert it to device coordinates.<P>
<LI>Invalidate the new rectangle.<P>
</OL>
<P>The function calls <I>InvalidateRect</I> twice. Windows &quot;saves up&quot; the two invalid rectangles and computes a new invalid rectangle that is the union of the two, intersected with the client rectangle.
<A NAME="127"><H3>The <I>OnDraw</I> Function</H3></A><P>The <I>SetBrushOrg</I> call is necessary to ensure that all of the ellipse's interior pattern lines up when the user scrolls through the view. The brush is aligned with a reference point, which is at the top left of the logical window, converted to device coordinates. This is a notable exception to the rule that <I>CDC</I> member functions require logical coordinates.
<A NAME="128"><H2>The <I>CScrollView SetScaleToFitSize</I> Mode</H2></A><P>The <I>CScrollView</I> class has a stretch-to-fit mode that displays the entire 
scrollable area in the view window. The Windows <I>MM_ANISOTROPIC</I> mapping mode comes into play, with one restriction: positive y values always increase in the down direction, as in <I>MM_TEXT</I> mode.
<P>To use the stretch-to-fit mode, make the following call in your view's function in place of the call to <I>SetScrollSizes</I>:<P>
<PRE>SetScaleToFitSize(sizeTotal);</PRE>
<P>You can make this call in response to a Shrink To Fit menu command. Thus, the display can toggle between scrolling mode and shrink-to-fit mode.
<A NAME="129"><H2>Using the Logical Twips Mapping Mode in a Scrolling View</H2></A><P>The MFC <I>CScrollView</I> class allows you to specify only standard mapping modes. The EX19A example in <A HREF="ch19a.htm">Chapter 19</A> shows a new class 
<I>CLogScrollView </I>that accommodates the logical twips mode.<P>

</BODY>
</HTML>



