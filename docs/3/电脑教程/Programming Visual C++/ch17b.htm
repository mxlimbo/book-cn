<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Serialization -- What Is It?</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="357"><H1>Serialization&#151;What Is It?</H1></A><P>The term &quot;serialization&quot; might be new to you, but it's already seen some 
use in the world of object-oriented programming. The idea is that objects can 
be persistent, which means they can be saved on disk when a program exits and 
then can be restored when the program is restarted. This process of saving and 
restoring objects is called <U>serialization</U>. In the Microsoft Foundation Class 
(MFC) library, designated classes have a member function named 
<I>Serialize</I>. When the application framework calls 
<I>Serialize</I> for a particular object&#151;for example, 
an object of class <I>CStudent</I>&#151;the data for the student is either saved on disk or 
read from disk.
<P>In the MFC library, serialization is not a substitute for a database 
management system. All the objects associated with a document are 
<U>sequentially</U> read from or written to a single disk file. It's not possible to access individual 
objects at random disk file addresses. If you need database capability in your 
application, consider using the Microsoft Open Database Connectivity (ODBC) 
software or Data Access Objects (DAO). <A HREF="ch31a.htm">Chapter 31</A> and <A HREF="ch32a.htm">Chapter 32</A> show you how to 
use ODBC and DAO with the MFC application framework.<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
There's a storage option that fits between sequential 
files and a database: <U>structured</U> 
<U>storage</U>, described in <A HREF="ch27a.htm">Chapter 27</A>. The MFC framework already uses structured storage for container programs that support embedded objects.
</BLOCKQUOTE></DIV>
<P>
<A NAME="358"><H2>Disk Files and Archives</H2></A><P>How do you know whether <I>Serialize</I> should read or write data? How is 
<I>Serialize</I> connected to a disk file? With the MFC library, objects of class 
<I>CFile </I>represent disk files. A <I>CFile</I> object encapsulates the binary file handle that you 
get through the Win32 function <I>CreateFile</I>. This is 
<U>not</U> the buffered <I>FILE</I> pointer that you'd get with a call to the C runtime 
<I>fopen</I> function; rather, it's a handle to a binary file. The application framework uses this file handle for Win32 <I>ReadFile</I>, <I>WriteFile</I>, and 
<I>SetFilePointer</I> calls.
<P>If your application does no direct disk I/O but instead relies on the 
serialization process, you can avoid direct use of 
<I>CFile</I> objects. Between the <I>Serialize</I> function and the 
<I>CFile</I> object is an archive object (of class 
<I>CArchive</I>), as shown in Figure 17-1.
<P>The <I>CArchive</I> object buffers data for the 
<I>CFile</I> object, and it maintains an internal flag that indicates whether the archive is storing (writing to disk) or loading (reading from disk). Only one active archive is associated with a file 
at any one time. The application framework takes care of constructing the 
<I>CFile</I> and <I>CArchive</I> objects, opening the disk file for the 
<I>CFile</I> object and associating the archive object with the file. All you have to do (in your 
<I>Serialize</I> function) is load data from or store data in the archive object. The 
application framework calls the document's 
<I>Serialize</I> function during the File Open and 
File Save processes.
<P><A HREF="javascript:fullSize('F17FG01x.htm')"> <img src="F17FG01.JPG" width=404 height=245 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 17-1.</B> <I>The serialization process.</I>
<!-- /caption -->
<P>
<A NAME="359"><H2>Making a Class Serializable</H2></A><P>A serializable class must be derived directly or indirectly from 
<I>CObject</I>. In 
addition (with some exceptions), the class declaration must contain 
the <I>DECLARE_SERIAL</I> macro call, and the class implementation file must con-
tain the <I>IMPLEMENT_SERIAL</I> macro call. (See the 
<I>Microsoft Foundation</I> <I>Class Reference</I> for a description of these macros.) This chapter's 
<I>CStudent</I> class 
example is modified from the class in <A HREF="ch16a.htm">Chapter 16</A> to include these macros.
<A NAME="360"><H2>Writing a <I>Serialize</I> Function</H2></A><P>In <A HREF="ch16a.htm">Chapter 16</A>, you saw a <I>CStudent</I> class, derived from 
<I>CObject</I>, with these data members:
<P><PRE>public:
    CString m_strName;
    int     m_nGrade;</PRE>
<P>Now your job is to write a <I>Serialize</I> member function for 
<I>CStudent</I>. Because <I>Serialize</I> is a virtual member function of class 
<I>CObject</I>, you must be sure that the return value and parameter types match the 
<I>CObject</I> declaration. The <I>Serialize</I> function for the 
<I>CStudent</I> class is below.
<P><PRE><B>void CStudent::Serialize(CArchive&amp; ar)
{
    TRACE(&quot;Entering CStudent::Serialize\n&quot;);
    if (ar.IsStoring()) {
        ar &lt;&lt; m_strName &lt;&lt; m_nGrade;
    }
    else {
        ar &gt;&gt; m_strName &gt;&gt; m_nGrade;
    }
}</B></PRE>
<P>Most serialization functions call the 
<I>Serialize</I> functions of their base classes. If 
<I>CStudent</I> were derived from <I>CPerson</I>, for example, the first line of the 
<I>Serialize</I> function would be
<P><PRE>CPerson::Serialize(ar);</PRE>
<P>The <I>Serialize</I> function for 
<I>CObject</I> (and for <I>CDocument</I>, which 
doesn't override it) doesn't do anything useful, so there's no need to call it.
<P>Notice that <I>ar</I> is a <I>CArchive</I> reference parameter that identifies the 
application's archive object. The <I>CArchive::IsStoring</I> member function tells 
us whether the archive is currently being used for storing or loading. The 
<I>CArchive</I> class has overloaded insertion operators (&lt;&lt;) and extraction operators (&gt;&gt;) 
for many of the C++ built-in types, as shown in the following table.
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><b>Type</b></TD><TD VALIGN="TOP"><b>Description</b></TD></TR>
<TR><TD VALIGN="TOP"><I>BYTE</I></TD><TD VALIGN="TOP">8 bits, unsigned</TD></TR>
<TR><TD VALIGN="TOP"><I>WORD</I></TD><TD VALIGN="TOP">16 bits, unsigned</TD></TR>
<TR><TD VALIGN="TOP"><I>LONG</I></TD><TD VALIGN="TOP">32 bits, signed</TD></TR>
<TR><TD VALIGN="TOP"><I>DWORD</I></TD><TD VALIGN="TOP">32 bits, unsigned</TD></TR>
<TR><TD VALIGN="TOP"><I>float</I></TD><TD VALIGN="TOP">32 bits</TD></TR>
<TR><TD VALIGN="TOP"><I>double</I></TD><TD VALIGN="TOP">64 bits, IEEE standard</TD></TR>
<TR><TD VALIGN="TOP"><I>int</I></TD><TD VALIGN="TOP">32 bits, signed</TD></TR>
<TR><TD VALIGN="TOP"><I>short</I></TD><TD VALIGN="TOP">16 bits, signed</TD></TR>
<TR><TD VALIGN="TOP"><I>char</I></TD><TD VALIGN="TOP">8 bits, unsigned</TD></TR>
<TR><TD VALIGN="TOP"><I>unsigned</I></TD><TD VALIGN="TOP">32 bits, unsigned</TD></TR>
</TABLE>
<P>The insertion operators are overloaded for values; the extraction operators 
are overloaded for references. Sometimes you must use a cast to satisfy the 
compiler. Suppose you have a data member <I>m_nType</I> that is an enumerated type.
Here's the code you would use:
<P><PRE>ar &lt;&lt; (int) m_nType;
ar &gt;&gt; (int&amp;) m_nType;</PRE>
<P>MFC classes that are not derived from 
<I>CObject</I>, such as <I>CString</I> and 
<I>CRect</I>, have their own overloaded insertion and extraction operators for 
<I>CArchive</I>.
<A NAME="361"><H2>Loading from an Archive&#151;Embedded Objects vs. Pointers</H2></A><P>Now suppose your <I>CStudent</I> object has other objects embedded in it, and 
these objects are not instances of standard classes such as 
<I>CString</I>, <I>CSize</I>, and <I>CRect</I>. Let's add a new data member to the 
<I>CStudent</I> class:
<P><PRE>public:
    CTranscript m_transcript;</PRE>
<P>Assume that <I>CTranscript</I> is a custom class, derived from 
<I>CObject</I>, with its own <I>Serialize</I> member function. There's no overloaded &lt;&lt; or &gt;&gt; operator for 
<I>CObject</I>, so the <I>CStudent::Serialize</I> function now becomes
<P><PRE>void CStudent::Serialize(CArchive&amp; ar)
{
    if (ar.IsStoring()) {
        ar &lt;&lt; m_strName &lt;&lt; m_nGrade;
    }
    else {
        ar &gt;&gt; m_strName &gt;&gt; m_nGrade;
    }
    m_transcript.Serialize(ar);
}</PRE>
<P>Before the <I>CStudent::Serialize</I> function can be called to load a 
student record from the archive, a <I>CStudent</I> object must exist somewhere. The 
embedded <I>CTranscript</I> object 
<I>m_transcript</I> is constructed along with the 
<I>CStudent</I> object before the call to the 
<I>CTranscript::Serialize</I> function. When the 
virtual <I>CTranscript::Serialize</I> function does get called, it can load the archived 
transcript data into the embedded 
<I>m_transcript</I> object. If you're looking for a rule, 
here it is: always make a direct call to 
<I>Serialize</I> for embedded objects of classes 
derived from <I>CObject</I>.
<P>Suppose that, instead of an embedded object, your 
<I>CStudent</I> object contained a <I>CTranscript 
</I><U>pointer</U> data member such as this:
<P><PRE>public:
    CTranscript* m_pTranscript;</PRE>
<P>You could use the <I>Serialize</I> function, as shown below, but 
as you can see, you must construct a new 
<I>CTranscript</I> object yourself.
<P><PRE>void CStudent::Serialize(CArchive&amp; ar)
{
    if (ar.IsStoring())
        ar &lt;&lt; m_strName &lt;&lt; m_nGrade;
    else {
        m_pTranscript = new CTranscript;
        ar &gt;&gt; m_strName &gt;&gt; m_nGrade;
    }
    m_pTranscript-&gt;Serialize(ar);
}
</PRE><P>Because the <I>CArchive</I> insertion and extraction operators are indeed 
overloaded for <I>CObject</I> <U>pointers</U>, you could write 
<I>Serialize</I> this way instead:
<P><PRE>void CStudent::Serialize(CArchive&amp; ar)
{
    if (ar.IsStoring())
        ar &lt;&lt; m_strName &lt;&lt; m_nGrade &lt;&lt; m_pTranscript;
    else
        ar &gt;&gt; m_strName &gt;&gt; m_nGrade &gt;&gt; m_pTranscript;
}
</PRE><P>But how is the <I>CTranscript</I> object constructed when the data is 
loaded from the archive? That's where the 
<I>DECLARE_SERIAL</I> and <I>IMPLEMENT_SERIAL</I> macros in the 
<I>CTranscript </I>class come in.
<P>When the <I>CTranscript</I> object is written to the archive, the macros 
ensure that the class name is written along with the data. When the archive is read, 
the class name is read in and an object of the correct class is dynamically 
constructed, under the control of code generated by the macros. Once the 
<I>CTranscript</I> object has been constructed, the overridden 
<I>Serialize</I> function for <I>CTranscript</I> can 
be called to do the work of reading the student data from the disk file. Finally 
the <I>CTranscript</I> pointer is stored in the 
<I>m_pTranscript</I> data member. To avoid a memory leak, you must be sure that 
<I>m_pTranscript</I> does not already contain 
a pointer to a <I>CTranscript</I> object. If the 
<I>CStudent</I> object was just constructed and thus was not previously loaded from the archive, the transcript pointer 
will be null.
<P>The insertion and extraction operators do 
<U>not</U> work with embedded objects of classes derived from 
<I>CObject</I>, as shown here:
<P><pre>ar &gt;&gt; m_strName &gt;&gt;  m_nGrade &gt;&gt; &amp;m_transcript; // Don't try this</pre>
<A NAME="362"><H2>Serializing Collections</H2></A><P>Because all collection classes are derived from the 
<I>CObject</I> class and the collection class declarations contain the 
<I>DECLARE_SERIAL</I> macro call, you can conveniently serialize collections with a call to the collection class's <I>Serialize</I> member function. If you call <I>Serialize</I> for a <I>CObList</I> collection of <I>CStudent</I> objects, for example, the <I>Serialize</I> function for each <I>CStudent</I> object will be called in turn. You should, however, remember the following specifics about loading collections from an archive:
<UL>
<LI>If a collection contains pointers to objects of mixed classes (all derived from <I>CObject</I>), the individual class names are stored in the archive so that the objects can be properly constructed with the appropriate class constructor.
<P><LI>If a container object, such as a document, contains an embedded collection, loaded data is appended to the existing collection. You might need to empty the collection before loading from the archive. This is usually done in the document's virtual <I>DeleteContents</I> function, which is called by the application framework.
<P><LI>When a collection of <I>CObject</I> pointers is loaded from an archive, 
the following processing steps take place for each object in the collection:
<P><OL>
<LI>The object's class is identified.
<P><LI>Heap storage is allocated for the object.
<P><LI>The object's data is loaded into the newly allocated storage.
<P><LI>A pointer to the new object is stored in the collection.
</OL>
</UL>
<P>The EX17A example shows serialization of an embedded collection of <I>CStudent</I> records.
<A NAME="363"><H2>The <I>Serialize</I> Function and the Application Framework</H2></A><P>OK, so you know how to write <I>Serialize</I> functions, and you know that 
these function calls can be nested. But do you know when the first 
<I>Serialize</I> function gets called to start the serialization process? With the application 
framework, everything is keyed to the document (the object of a class derived from 
<I>CDocument</I>). When you choose Save or Open from the File menu, the 
application framework creates a <I>CArchive</I> object (and an underlying 
<I>CFile</I> object) and then calls your document class's 
<I>Serialize</I> function, passing a reference to the 
<I>CArchive</I> object. Your derived document class 
<I>Serialize</I> function then serializes each of its nontemporary data members.<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
If you take a close look at any AppWizard-generated 
document class, you'll notice that the class includes the 
<I>DECLARE_DYNCREATE</I> and 
<I>IMPLEMENT_DYNCREATE</I> macros rather than the 
<I>DECLARE_SERIAL</I> and <I>IMPLEMENT_SERIAL</I>
 macros. The <I>SERIAL</I> macros are unneeded because document objects 
are never used in conjunction with the 
<I>CArchive</I> extraction operator or included in collections; the application framework calls the 
document's <I>Serialize</I> member function directly. You should include 
the <I>DECLARE_SERIAL</I> and <I>IMPLEMENT_SERIAL</I> macros in all other serializable classes.
</BLOCKQUOTE></DIV>
</BODY>
</HTML>



