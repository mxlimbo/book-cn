<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The Windows Heap and the GlobalAlloc Function Family</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="205"><H1>The Windows Heap and the <I>GlobalAlloc</I> Function Family</H1></A>
<P>A <U>heap</U> is a memory pool for a specific process. When your program needs a block of memory, it calls a heap allocation function, and it calls a companion function to free the memory. There's no assumption about 4-KB page 
boundaries; the heap manager uses space in existing pages or calls <I>VirtualAlloc</I> to get more pages. First we'll look at Windows heaps. Next we'll consider heaps managed by the CRT library for functions like <I>malloc</I> and <I>new</I>.
<P>Windows provides each process with a default heap, and the process can create any number of additional Windows heaps. The <I>HeapAlloc</I> function allocates memory in a Windows heap, and <I>HeapFree</I> releases it.
<P>You might never need to call <I>HeapAlloc</I> yourself, but it will be called for you by the <I>GlobalAlloc</I> function that's left over from Win16. In the ideal 32-bit world, you wouldn't have to use <I>GlobalAlloc</I>, but in this real world, we're stuck with a lot of code ported from Win16 that uses &quot;memory handle&quot; (<I>HGLOBAL</I>) parameters instead of 32-bit memory addresses.
<P><I>GlobalAlloc</I> uses the default Windows heap. It does two different things, depending on its attribute parameter. If you specify <I>GMEM_FIXED</I>, <I>GlobalAlloc</I> simply calls <I>HeapAlloc</I> and returns the address cast as a 32-bit <I>HGLOBAL</I> value. If you specify <I>GMEM_MOVEABLE</I>, the returned <I>HGLOBAL </I>value is a pointer to a <U>handle</U> <U>table</U> entry in your process. That entry contains a pointer to the actual memory, which is allocated with <I>HeapAlloc</I>.
<P>Why bother with &quot;moveable&quot; memory if it adds an extra level of 
indirection? You're looking at an artifact from Win16, in which, once upon a time, the operating system actually moved memory blocks around. In Win32, 
moveable blocks exist only to support the <I>GlobalReAlloc</I> function, which allocates a new memory block, copies bytes from the old block to the new, frees the old block, and assigns the new block address to the existing handle table entry. If nobody called <I>GlobalReAlloc</I>, we could always use <I>HeapAlloc</I> instead of <I>GlobalAlloc</I>.
<P>Unfortunately, many library functions use <I>HGLOBAL</I> return values and parameters instead of memory addresses. If such a function returns an <I>HGLOBAL</I> value, you should assume that memory was allocated with the 
<I>GMEM_MOVEABLE</I> attribute, and that means you must call the <I>GlobalLock</I> function to get the memory address. (If the memory was fixed, the <I>GlobalLock</I> call just returns the handle as an address.) Call 
<I>GlobalUnlock</I> when you're finished accessing the memory. If you're required to supply an <I>HGLOBAL</I> parameter, to be absolutely safe you should generate it with a <I>GlobalAlloc(GMEM_MOVEABLE, &#133;)</I> call in case the called function decides to call <I>GlobalReAlloc</I> and expects the handle value to be unchanged.
</BODY>
</HTML>



