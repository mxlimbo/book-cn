<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Windows Common Controls</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="148"><H1>Windows Common Controls</H1></A>
<P>The controls you used in EX06A are great learning controls because they're 
easy to program. Now you're ready for some more &quot;interesting&quot; controls. We'll take a look at some important new Windows controls, introduced for Microsoft Windows 95 and available in Microsoft Windows NT. These include the progress indicator, trackbar, spin button control, list control, and tree control.
<P>The code for these controls is in the Windows COMCTL32.DLL file. This code includes the window procedure for each control, together with code that registers a window class for each control. The registration code is called when the DLL is loaded. When your program initializes a dialog, it uses the symbolic class name in the dialog resource to connect to the window procedure in the DLL. Thus your program owns the control's window, but the code is in the DLL. Except for ActiveX controls, most controls work this way.
<P>Example EX06B uses the aforementioned controls. Figure 6-2 shows the dialog from that example. Refer to it when you read the control descriptions that follow.
<P>Be aware that ClassWizard offers no member variable support for the common controls. You'll have to add code to your <I>OnInitDialog</I> and <I>OnOK</I> functions to initialize and read control data. ClassWizard will, however, allow you to map notification messages from common controls.
<P><A HREF="javascript:fullSize('F06OG02x.htm')"> <img src="F06OG02.JPG" width=404 height=209 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 6-2.</B> <I>The Windows Common Controls Dialog example.</I>
<!-- /caption -->
<A NAME="149"><H2>The Progress Indicator Control</H2></A><P>The progress indicator is the easiest common control to program and is represented by the MFC <I>CProgressCtrl</I> class. It is generally used only for output. This control, together with the trackbar, can effectively replace the scroll bar 
controls you saw in the previous example. To initialize the progress indicator, 
call the <I>SetRange</I> and <I>SetPos</I> member functions in your <I>OnInitDialog</I> function, and then call <I>SetPos</I> anytime in your message handlers. The progress indicator shown in Figure 6-2 has a range of 0 to 100, which is the default range.
<A NAME="150"><H2>The Trackbar Control</H2></A><P>The trackbar control (class <I>CSliderCtrl</I>), sometimes called a slider, allows the user to set an &quot;analog&quot; value. (Trackbars would have been more effective than sliders for Loyalty and Reliability in the EX06A example.) If you specify a 
large range for this control&#151;0 to 100 or more, for example&#151;the trackbar's motion appears continuous. If you specify a small range, such as 0 to 5, the tracker moves in discrete increments. You can program tick marks to match the increments. In this discrete mode, you can use a trackbar to set such items as the display screen resolution, lens f-stop values, and so forth. The trackbar does not have a default range.
<P>The trackbar is easier to program than the scroll bar because you don't have to map the WM_HSCROLL or WM_VSCROLL messages in the dialog class. As long as you set the range, the tracker moves when the user slides it or clicks in the body of the trackbar. You might choose to map the scroll messages anyway if you want to show the position value in another control. The <I>GetPos</I> member function returns the current position value. The top trackbar in Figure 6-2 operates continuously in the range 0 to 100. The bottom trackbar has a range of 0 to 4, and those indexes are mapped to a series of double-precision values (4.0, 5.6, 8.0, 11.0, and 16.0).
<A NAME="151"><H2>The Spin Button Control</H2></A><P>The spin button control (class <I>CSpinButtonCtrl</I>) is an itsy-bitsy scroll bar that's most often used in conjunction with an edit control. The edit control, located just ahead of the spin control in the dialog's tabbing order, is known as the spin control's <U>buddy</U>. The idea is that the user holds down the left mouse button on the spin control to raise or lower the value in the edit control. The spin speed accelerates as the user continues to hold down the mouse button.
<P>If your program uses an integer in the buddy, you can avoid C++ programming almost entirely. Just use ClassWizard to attach an integer data member to the edit control, and set the spin control's range in the <I>OnInitDialog</I> function. (You probably won't want the spin control's default range, which runs 
backward from a minimum of 100 to a maximum of 0.) Don't forget to select Auto Buddy and Set Buddy Integer in the spin control's Styles property page. You can call the <I>SetRange</I> and <I>SetAccel</I> member functions in your 
<I>OnInitDialog</I> function to change the range and the acceleration profile.
<P>If you want your edit control to display a noninteger, such as a time or a floating-point number, you must map the spin control's WM_VSCROLL (or WM_HSCROLL) messages and write handler code to convert the spin control's integer to the buddy's value.
<A NAME="152"><H2>The List Control</H2></A>
<P>Use the list control (class <I>CListCtrl</I>) if you want a list that contains images as well as text. Figure 6-2 shows a list control with a &quot;list&quot; view style and small icons. The elements are arranged in a grid, and the control includes horizontal scrolling. When the user selects an item, the control sends a notification message, which you map in your dialog class. That message handler can determine which item the user selected. Items are identified by a zero-based integer index.
<P>Both the list control and the tree control get their graphic images from a common control element called an <U>image</U> <U>list</U> (class <I>CImageList</I>). Your program must assemble the image list from icons or bitmaps and then pass an image list pointer to the list control. Your 
<I>OnInitDialog</I> function is a good place to create and attach the image list and to assign text strings. The <I>InsertItem</I> member function serves this purpose.
<P>List control programming is straightforward if you stick with strings and icons. If you implement drag and drop or if you need custom owner-drawn graphics, you've got more work to do.
<A NAME="153"><H2>The Tree Control</H2></A>
<P>You're already familiar with tree controls if you've used Microsoft Windows Explorer or Visual C++'s Workspace view. The MFC <I>CTreeCtrl</I> class makes it easy to add this same functionality to your own programs. Figure 6-2 illustrates a tree control that shows a modern American combined family. The user can expand and collapse elements by clicking the + and - buttons or by double-clicking the elements. The icon next to each item is programmed to change when the user selects the item with a single click.
<P>The list control and the tree control have some things in common: they can both use the same image list, and they share some of the same notification messages. Their methods of identifying items are different, however. The tree control uses an <I>HTREEITEM</I> handle instead of an integer index. To insert 
an item, you call the <I>InsertItem</I> member function, but first you must build up a <I>TV_INSERTSTRUCT</I> structure that identifies (among other things) the string, the image list index, and the handle of the parent item (which is null for top-level items).
<P>As with list controls, infinite customization possibilities are available for the tree control. For example, you can allow the user to edit items and to 
insert and delete items.
<A NAME="154"><H2>The WM_NOTIFY Message</H2></A><P>The original Windows controls sent their notifications in WM_COMMAND messages. The standard 32-bit 
<I>wParam</I> and <I>lParam</I> message parameters are not sufficient, however, for the information that a common control needs to send to its parent. Microsoft solved this &quot;bandwidth&quot; problem by defining a new message, WM_NOTIFY. With the WM_NOTIFY message, <I>wParam</I> is the control ID and <I>lParam</I> is a pointer to an <I>NMHDR</I> structure, which is managed by the control. This C structure is defined by the following code:<P>
<PRE>typedef struct tagNMHDR {
    HWND hwndFrom; // handle to control sending the message
    UINT idFrom;   // ID of control sending the message
    UINT code;     // control-specific notification code
} NMHDR;
</PRE>
<P>Many controls, however, send WM_NOTIFY messages with pointers to structures larger than <I>NMHDR</I>. Those structures contain the three members above plus appended control-specific members. Many tree control notifications, for example, pass a pointer to an <I>NM_TREEVIEW</I> structure that contains 
<I>TV_ITEM</I> structures, a drag point, and so forth. When ClassWizard maps 
a WM_NOTIFY message, it generates a pointer to the appropriate structure.
</BODY>
</HTML>



