<HTML>
<HEAD>
<link rel="STYLESHEET" type="text/css" href="squeal7.css">
<TITLE>Databases Under the Hood</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch05h.htm">[Previous]</A> <A HREF="ch05j.htm">[Next]</A><P>

<A NAME="191"><H1>Databases Under the Hood</H1></A>
<P>A database consists of user-defined space for the permanent storage of user 
objects such as tables and indexes. This space is allocated in one or more 
operating system files.</P>
<P>Databases are divided into logical pages (of 8 KB each), and within 
each file the pages are numbered contiguously from 0 to 
<I>x,</I> with the upper value <I>x</I> being defined by the size of the file. You can then refer to any page by 
specifying a database ID, a file ID, and a page number. When you use the 
ALTER DATABASE command to enlarge a file, the new space is added to the end  
of the file. That is, the first page of the newly allocated space is page 
<I>x </I>+ 1 on  
the file you're enlarging. When you shrink a database by using either the 
DBCC SHRINKDATABASE or DBCC SHRINKFILE command, pages are 
removed starting at the highest page in the database (at the end) and moving 
toward lower-numbered pages. This ensures that page numbers within a file are 
always contiguous.</P>
<P>The <I>master </I>database contains 49 system tables: the same 18 tables 
found in user databases, plus 31 tables that are found only in 
<I>master</I>. Ten of these tables&#8212;including 
<I>syslockinfo</I>,<I> sysperfinfo</I>,<I> 
syscurconfigs</I>, and 
<I>sysprocesses</I>&#8212;don't physically exist in the 
<I>master </I>database; rather, they're built dynamically each 
time a user queries them. Twelve of these tables contain information about 
remote servers; they won't contain any data until you define other servers with 
which you'll be communicating. The <I>master</I> database also contains 23 system 
views: the same 20 found in all user databases, plus 3 additional views. All these 
system objects, in both the <I>master</I> and 
<I>user</I> databases, have names that begin with 
<I>spt_</I>.<I> </I>To see a list of the system tables and views that are found in only the 
<I>master</I> database, you can execute the following query:</P>

<p><table cellpadding=5 width="95%"><tr><td><pre>
SELECT type, name FROM master..sysobjects 
WHERE type IN ('s', 'v') AND name NOT IN 
    (SELECT name FROM model..sysobjects) 
GO
</pre></td></tr></table></p>
<P>The <I>master</I> database also contains 10 tables that can be referred to 
as <I>pseudo-system tables</I>. These table names begin with 
<I>spt_</I> and are used as storage areas for various system procedures, but they aren't true system tables. 
You should never modify them directly because that could break some of the 
system procedures. However, deleting them wouldn't invalidate the basic 
integrity of the database, which is the case if true system tables are altered.</P>
<P>When you create a new database using the CREATE DATABASE 
statement, it's given a unique database ID, or 
<I>dbid,</I> and a new row is inserted in the <I>master..sysdatabases 
</I>table for that database. Only the <I>master 
</I>database contains a <I>sysdatabases </I>table. Figure 5-4 depicts a sample 
<I>sysdatabases </I>table, and Table 5-2 on the following page shows its columns.</P>
<P>The rows in <I>sysdatabases</I> are updated when a database's ownership or 
name is changed or when database options are changed. (Later in the chapter, 
we'll discuss this in more detail.)</P>

<P>
<A HREF="javascript:fullSize('f05wh04x.htm')"> <img src="f05wh04.JPG" width=404 height=101 border=0 ALT="Click to view at full size."> </A>
</P>
<P>
<!-- caption --><B>Figure 5-4.</B> <I>Partial listing of a sysdatabases table.</I><!-- /caption -->
</P>


<P><B>Table 5-2.</B> <I>Columns of the sysdatabases table.</I></P>

<table valign="top" cellpadding=5 width="95%">
<tr><th>Column</th>
<th>Information</th>
</tr>
<tr>
<td valign="top"><I>name</I></td>
<td valign="top">Name of the database.</td>
</tr>
<tr>
<td valign="top"><I>dbid</I></td>
<td valign="top">Unique database ID; can be reused when the database  
is dropped.</td>
</tr>
<tr>
<td valign="top"><I>sid</I></td>
<td valign="top">System ID of the database creator.</td>
</tr>
<tr>
<td valign="top"><I>mode</I></td>
<td valign="top">Locking mode, used internally while a database is 
being created.</td>
</tr>
<tr>
<td valign="top"><I>status</I></td>
<td valign="top">Bit mask that shows whether a database is read only, 
off line, designated for use by a single user only, and so 
on. Some of the settings can be selected by the user with 
the <I>sp_dboption</I><B> </B>stored procedure; others are internally 
set. (The SQL Server product documentation shows all 
the bit-mask values.)</td>
</tr>
<tr>
<td valign="top"><I>status2</I></td>
<td valign="top"> Another bit-mask_like status, with bits indicating additional database options. (Not shown in Figure 5-4.)</td>
</tr>
<tr>
<td valign="top"><I>crdate</I></td>
<td valign="top">For user databases, this is the date when the database 
was created. For <I>tempdb</I>, this is the date and time SQL 
Server was last started. For other system databases, this date 
is not really useful. Depending on decisions made during  
installation, this could be the date Microsoft originally 
created the database prior to shipping the code, or it could  
be the date that you installed SQL Server.</td>
</tr>
<tr>
<td valign="top"><I>reserved</I></td>
<td valign="top">Reserved for future use.</td>
</tr>
<tr>
<td valign="top"><I>category</I></td>
<td valign="top">Another bit-mask_like status. Contains information 
about whether the database is involved with replication. 
(Not shown in Figure 5-4.)</td>
</tr>
<tr>
<td valign="top"><I>cmptlevel</I></td>
<td valign="top">Compatibility level for the database. This concept is 
briefly discussed at the end of this chapter.</td>
</tr>
<tr>
<td valign="top"><I>filename</I></td>
<td valign="top">Operating system path and name for the primary file.</td>
</tr>
<tr>
<td valign="top"><I>suid</I></td>
<td valign="top">ID of SQL Server login that owns the database. 
(Note that the <I>sid</I> column (above) contains the ID of the 
creator of the database, which might or might not be the 
owner.) The column <I>suid</I> always refers to the current owner.</td>
</tr>
<tr>
<td valign="top"><I>version</I></td>
<td valign="top">Internal version of SQL Server with which the database 
was created. (Not shown in Figure 5-4.)</td>
</tr>
</table>

<A NAME="192"><H2>Space Allocation</H2></A>
<P>The space in a database is used for storing tables and indexes. As mentioned 
earlier in the chapter, space is managed in units called 
<I>extents</I>. An extent is made up of eight logically contiguous pages (or 64 KB of space). To make its 
space allocation more efficient, SQL Server 7 doesn't allocate entire extents to 
tables with small amounts of data. SQL Server 7 has two types of extents:</P>
<P>
<UL>
<P><LI><B>     Uniform 
extents</B> These extents are owned by a single object; 
all eight pages in the extent can be used by the owning object only.</LI></P>
<P><LI><B>     Mixed 
extents</B> These are shared by up to eight objects.</LI></P>
</UL>
</P>
<P>A new table or index is allocated pages from mixed extents. When the 
table or index grows to eight pages, all future allocations use uniform extents.</P>
<P>When a table or index needs more space, SQL Server needs to find 
some space that's available to be allocated. If the table or index is still less than 
eight pages total, SQL Server needs to find a mixed extent with space available. If 
the table or index is already eight pages or larger, SQL Server needs to find a 
free uniform extent. SQL Server uses two special types of pages to record 
which extents have been allocated and which type of use (mixed or uniform) the 
extent is available for:</P>
<P>
<UL>
<P><LI><B>     Global Allocation Map (GAM) 
pages</B> These pages record which 
extents have been allocated for any type of use. Each GAM 
covers 64,000 extents, or almost 4 GB of data. This means one GAM 
page exists for every 4 GB of size. A GAM has one bit for each extent 
in the interval it covers. If the bit is 1, the corresponding extent is 
in use; if the bit is 0, the extent is free.</LI></P>

 <P><LI><B>     Secondary Global Allocation Map (SGAM) 
pages</B> These pages record which extents are currently used as mixed extents and have  
at least one unused page. Just like a GAM, each SGAM 
covers 64,000 extents, or almost 4 GB of data. The SGAM has 1 bit 
for each extent in the interval it covers. If the bit is 1, the extent is  
being used as a mixed extent and has free pages; if the bit is 0, 
the extent isn't being used as a mixed extent, or it's a mixed 
extent whose pages are all in use.</LI></P>
</UL>
</P>
<P>The following page shows the bit patterns each extent will have set in 
the GAM and SGAM based on its current use.</P>

<p><table valign="top" cellpadding=5 width="95%">
<tr><th>Current Use of Extent</th>
<th>GAM Bit Setting</th>
<th>SGAM Bit Setting</th>
</tr>
<tr>
<td valign="top">Free, not in use </td>
<td valign="top">0</td>
<td valign="top">0</td>
</tr>
<tr>
<td valign="top">Uniform extent, or full mixed extent</td>
<td valign="top">1</td>
<td valign="top">0</td>
</tr>
<tr>
<td valign="top">Mixed extent with free pages</td>
<td valign="top">1</td>
<td valign="top">1</td>
</tr>
</table></p>
 
<P>If SQL Server needs to find a new, completely unused extent, it can 
use any extent with a corresponding bit value of 1 in the GAM page. If SQL 
Server needs to find a mixed extent with available space (one or more free pages), 
it finds an extent with a value in the GAM of 0 and a value in the SGAM of 1.</P>
<P>SQL Server can quickly locate the GAMs in a file, because a GAM is 
always the third page in any database file (page 2). And an SGAM is the fourth 
page (page 3). Another GAM appears every 64,000 extents (512,000 pages) after 
the first GAM on page 2, and another SGAM every 64,000 extents (512,000 
pages) after the first SGAM on page 3. Page 0 in any file is the File Header page, 
and only one exists per file. Page 1 is a Page Free Space (PFS) page, which will 
be discussed shortly.</P>
<P>In Chapter 6, we'll continue to explore how individual pages within a 
table look, but because we're talking about space allocation here, we'll examine 
how to keep track of which pages belong to which tables. Index Allocation 
Map (IAM) pages map the extents in a database file used by a heap or index. 
Remember from Chapter 3 that a heap is a table without a clustered index. Each 
heap or index has one or more IAM pages recording all the extents allocated to 
the object. A heap or index has at least one IAM for each file on which it has 
extents. A heap or index can have more than one IAM on a file if the range of 
the extents exceeds the range that an IAM can record.</P>
<P>An IAM contains a small header, eight page-pointer slots, and a set of 
bits mapping a range of extents onto a file. The header has the address of the 
first extent in the range mapped by the IAM. The eight page-pointer slots 
might contain pointers to pages belonging to the relevant objects that are 
contained in mixed extents; only the first IAM for an object will have values in these 
pointers. Once an object takes up more than eight pages, all its extents are 
uniform extents&#8212;which means an object will never need more than eight pointers 
to pages in mixed extents. If rows have been deleted from a table, it can 
actually use fewer than eight of these pointers. Each bit of the bitmap represents an 
extent in the range, regardless of whether the extent is allocated to the object 
owning the IAM. If a bit is on, the relative extent in the range is allocated to the 
ob-ject owning the IAM; if a bit is off, the relative extent isn't allocated to the 
object owning the IAM.</P>
<P>For example, if the bit pattern in the first byte of the IAM is 1100 
0000, it means that the first and second extents in the range covered by the IAM  
are allocated to the object owning the IAM and that extents 3 through 8 
aren't allocated to the object owning the IAM.</p>
<P>IAM pages are allocated as needed for each object and are located 
ran-domly in the database file. Each IAM covers a possible range of 512,000 
pages. <I>Sysindexes.FirstIAM</I> points to the first IAM page for an object. All the IAM 
pages for that object are linked in a chain.</P>


<P><DIV CLASS="NOTE"><BLOCKQUOTE><b>NOTE</b><HR>
In a heap, the data pages and the rows within them 
aren't in any specific order and aren't linked together. The only logical  
connection between data pages is recorded in the IAM pages.
</BLOCKQUOTE></DIV></P>
<P>Once extents have been allocated to an object, SQL Server can use 
pages in those extents to insert new data. If the data is to be inserted into a 
B-tree, the location of the new data is based on the ordering within the B-tree. If 
the data is to be inserted into a heap, the data can be inserted into any available 
space. PFS pages within a file record whether an individual page has been allocated 
and the amount of space free on each page. Each PFS page covers 8000 
contiguous pages (almost 64 MB). For each page, the PFS has 1 byte recording 
whether the page is empty, 1_25 percent full, 26_50 percent full, 51_75 percent full, 
or more than 75 percent full. This information is used when SQL Server needs 
to find a page with free space available to hold a newly inserted row. The 
second page (page 1) of a file is a PFS page, as is every 
8000<SUP>th</SUP> page thereafter.</P>
</BODY>
</HTML>



