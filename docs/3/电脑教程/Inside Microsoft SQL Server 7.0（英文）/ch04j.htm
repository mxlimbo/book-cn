<HTML>
<HEAD>
<link rel="STYLESHEET" type="text/css" href="squeal7.css">
<TITLE>Character Sets and Sort Orders</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch04i.htm">[Previous]</A> <A HREF="ch04k.htm">[Next]</A><P>

<A NAME="151"><H1>Character Sets and Sort Orders</H1></A>

<P>During installation, you must decide which character set and sort order to 
use. A SQL Server installation defines a single character set in addition to 
supporting Unicode (2-byte character) data. It also defines two sort orders, one for 
non-Unicode data and one for Unicode data. If you decide later that you want 
a different character set or sort order, you must rebuild all databases, 
including SQL Server's <I>master</I> database. Most of the discussion below concerns 
non-Unicode data. Unicode data is discussed later in a separate section.</P>

<A NAME="152"><H2>Character Sets</H2></A>

<P>A single (non-Unicode) character is stored in SQL Server as 1 byte (8 
bits), which means that 256 (2<SUP>8</SUP>) different characters can be represented. But all 
the world's languages in aggregate have many more than 256 characters. 
Hence, if you don't want to store all your data as Unicode, which takes twice as 
much storage space, you must choose a character set that contains all the 
characters (referred to as the <I>repertoire</I>) you need to work with. For installations in 
the Western Hemisphere and Western Europe, the ISO character set (also 
often referred to as Windows Characters, ISO 8859-1, Latin-1, or ANSI) is the 
default and is compatible with the character set used by all versions of 
Windows in those regions. (Technically, there is a slight 
difference between the Windows character set and ISO 8859-1.) If you choose ISO, you might want to skip 
the rest of this section on character sets, but you should still familiarize yourself 
with sort order issues.</P>

<P>You should also ensure that all your client workstations use a character 
set that is consistent with the characters used by your installation of SQL 
Server. SQL Server stores a byte value for a character. If, for example, the character 
<I>&#165;</I>, the symbol for the Japanese yen, is entered by a client application using the 
standard Windows character set, its byte value (known as the 
<I>code point</I>) of 165 (0xA5) is stored in SQL Server. If an MS-DOS_based application using code page 437 retrieves that value, that application displays the character 
<I>&Ntilde;</I>. (MS-DOS uses the term <I>code pages 
</I>to mean character sets. You can think of them 
as interchangeable terms.) In both cases, the byte value of 165 is stored, but 
the Windows character set and the MS-DOS code page 437 render it 
differently. You must consider whether the ordering of characters is what is 
semantically expected (discussed later in the &quot;<A HREF="ch04j.htm#153">Sort Orders</A>&quot; section) and whether the 
character is rendered on the application monitor (or other output device) as 
expected. SQL Server provides services in the OLE DB provider, the ODBC driver, and DB-Library that use Windows services to perform character set 
conversions. Conversions cannot always be exact, however, because by definition each 
character set has a somewhat different repertoire of characters. For example, 
there is no exact match in code page 437 for the Windows character 
<I>&Otilde;</I>, so the conversion must give a close, but different, character.</P>

<p><div class="sidebar"><blockquote>
<B>The ASCII Character Set</B>
<P>It is worth pointing out that the first 128 characters are the same 
for the character sets ISO, code page 437, and code page 850. These 
128 characters make up the ASCII character set. (Standard ASCII is 
only a 7-bit character set. ASCII was simple and efficient to use in 
telecommunications because the character and a &quot;stop bit&quot; for 
synchronization could all be expressed in a single byte.) If your application uses 
ASCII characters but not the so-called<I> extended 
characters</I> (typically characters with diacritical marks, such 
as &agrave;, &Aring;, &auml;) that differentiate the 
upper 128 characters between these three character sets, it probably 
doesn't matter which character set you choose. In this situation (only), 
whether you choose any of these three character sets or use different 
character sets on your client and server machines doesn't matter because 
the rendering and sorting of every important character uses the same 
byte value in all cases.</P>
</blockquote></div></p>

<P>Windows NT and SQL Server 7 also support 2-byte characters that 
allow representation of virtually every character used in any language. This is 
known as Unicode, and it provides many benefits with some costs. The principal 
cost is that 2 bytes instead of 1 are needed to store a character. SQL Server 
allows storage of Unicode data by using three new datatypes: 
<I>nchar</I>, <I>nvarchar</I>, and <I>ntext</I>. We'll discuss these when we talk about datatypes in <a href="ch06a.htm">Chapter 6.</a> The 
use of Unicode characters for certain data does not affect the character set 
chosen to store the non-Unicode data.</P>

<P>Earlier versions of SQL Server did not support Unicode, but they 
did support double-byte character sets (DBCS). DBCS is a hybrid approach and is the most common way for applications to support Asian languages such as 
Japanese and Chinese. With DBCS encoding, some characters are 1 byte and 
others are 2 bytes. The first bit in the character indicates whether the character 
is a 1-byte or a 2-byte character. (In Unicode, every character is 2 bytes.) 
However, for non-Unicode datatypes, each character is considered 1 byte for 
storage. To store two DBCS characters, a field would need to be declared as 
<I>char(4)</I> instead of <I>char(2)</I>. But SQL Server correctly parses and understands 
DBCS characters in its string functions.</P>

<P>Table 4-4 lists the character sets available in SQL Server and notes 
DBCSs. The DBCSs are still available for backward compatibility, but for new 
applications that need more flexibility in character representation than the 
default ISO code page provides, you should consider using the Unicode datatypes 
exclusively. As mentioned earlier, most sites in countries of the Western 
Hemisphere and in Western Europe are best served by the default ISO character set. 
The choices for code page 437 and code page 850 might be of interest if you 
are supporting many older MS-DOS_based applications that use those code 
pages or for other backward compatibility reasons. The other character sets are 
mostly locale specific.</P>

<P><B>Table 4-4.</B> <I>SQL Server character sets.</I></P>

<p><table cellpadding=5 width="95%">
<tr>
<th>Code Page</th>     
<th>Character Set</th>
</tr>
<tr>
<td valign="top"> 1252 (ISO)</td>     
<td valign="top">Default, multilingual</td>
</tr>
<tr>
<td valign="top">  850</td>     
<td valign="top">Multilingual</td>
</tr>
<tr>
<td valign="top">  437</td>     
<td valign="top">U.S. English</td>
</tr>
<tr>
<td valign="top">  874</td>     
<td valign="top">Thai (DBCS)</td>
</tr>
<tr>
<td valign="top">  932</td>     
<td valign="top">Japanese (DBCS)</td>
</tr>
<tr>
<td valign="top">  936</td>     
<td valign="top">Chinese simplified (DBCS)</td>
</tr>
<tr>
<td valign="top">  949</td>    
<td valign="top">Korean (DBCS)</td>
</tr>
<tr>
<td valign="top">  950</td>     
<td valign="top">Chinese traditional (DBCS)</td>
</tr>
<tr>
<td valign="top"> 1250</td>    
<td valign="top">Central European</td>
</tr>
<tr>
<td valign="top">1251</td>     
<td valign="top">Cyrillic</td>
</tr>
<tr>
<td valign="top">1253</td>     
<td valign="top">Greek</td>
</tr>
<tr>
<td valign="top">1254 </td>    
<td valign="top">Turkish</td>
</tr>
<tr>
<td valign="top">1255</td>     
<td valign="top">Hebrew</td>
</tr>
<tr>
<td valign="top">1256</td>     
<td valign="top">Arabic</td>
</tr>
<tr>
<td valign="top">1257</td>     
<td valign="top">Baltic</td>
</tr></table></P>

<A NAME="153"><H2>Sort Orders</H2></A>

<P>Character sets are not important in many sites, but in nearly every site, 
whether you realize it or not, the basics of sort order (more properly called 
<I>collating sequence</I>) is important. Sort order determines how characters compare and 
assign their values. It determines whether your SQL Server installation is 
case sensitive. (For example, is an uppercase 
<I>A</I> considered identical to a lowercase 
<I>a</I>?) If you use only ASCII characters and no extended characters, you 
should simply decide your case-sensitivity preference and choose accordingly. By 
default, SQL Server installs a case-insensitive sort order. (That is, 
<I>A</I> and <I>a</I> are considered equivalent.) To change the default, you simply choose an 
option during installation that provides case sensitivity, such as Binary Order or 
Dictionary Order, Case-Sensitive.</P>

<P>Sort order affects not only the ordering of a result set but also which 
rows of data qualify for that result set. If a query's criterion is</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
WHERE name='SMITH',
</pre>
</td></tr></table></p>

<P>the case sensitivity installed determines whether a row with the name 
<I>Smith </I>qualifies.</P>

<P>Character matching, string functions, and aggregate functions 
(MIN(), MAX(), COUNT (DISTINCT), GROUP BY, UNION, CUBE, LIKE, 
and ORDER BY) all behave differently with character data depending on the 
sort order specified.</P>

<A NAME="154"><H3>Sort Order Semantics</H3></A>

<P>The sort order also determines more subtle semantic differences. The 
following lengthy discussion principally applies to use of extended characters. If 
you plan to work with only 7-bit ASCII characters, you can skip this section.</P>

<P>A given sort order option is specific to a character set. Not every 
sorting option is available in every character set. For example, you will find the 
option for Croatian Dictionary Order, Case-Sensitive, only with the 1250, 
Central European character set. The DBCS character sets (Japanese, Chinese, 
and Korean) each provide two sort options. The first is Binary, which means 
that characters are sorted on the basis of their internal byte values, without 
regard to cultural correctness. The other choice makes use of Windows NT 
National Language Support (NLS) capabilities and provides a Case-Insensitive, 
Dictionary option consistent with the Windows NT character sorting in the 
respective localized version of the operating system. Hence, the English version of 
SQL Server can be used on the Chinese version of Windows NT, and it can 
work properly with double-byte Chinese characters and can sort them in a 
culturally correct manner.</P>

<P>For non-DBCS character sets, SQL Server provides more sorting 
options (which we'll explain in a moment). In addition, Unicode data has its own 
sort order, referred to as the Unicode collation sequence.Figure 4-3 shows the sort-order definition for the default sort order 
and character set. You can obtain similar information for whatever sort order 
you are using by running the procedure 
<I>sp_helpsort</I>. For example, the output shows that the letter 
<I>A</I> is defined for the current sort order definition file as 
having this collating sequence:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
A=a &Agrave;=&agrave; &Aacute;=&aacute; &Acirc;=&acirc; &Atilde;=&atilde; &Auml;=&auml; &Aring;=&aring; &AElig;=&aelig;
</pre>
</td></tr></table></p>

<P>This definition states that <I>A </I>should be treated identically to 
<I>a</I>, as should all uppercase characters and their lowercase equivalents in this sort order. 
Both <I>A</I> and <I>a</I> have a value before <I>&Agrave; 
</I>and <I>&agrave;</I> (<I>a</I>-grave) followed by 
<I>&Aacute; </I>and <I>&aacute;</I> 
(<I>a</I>-acute) and then <I>&Acirc; </I>and 
<I>&acirc;</I> (<I>a</I>-circumflex). Next is <I>&Atilde; 
</I>and <I>&atilde; </I>followed by <I>&Auml;</I> and 
<I>&auml;</I>, <I>&Aring;</I> and 
<I>&aring;</I>,<I> </I>and finally <I>&AElig; </I>and 
<I>&aelig;</I>.</P>

<P>
<A HREF="javascript:fullSize('f04wh03x.htm')"> <img src="f04wh03.JPG" width=404 height=281 border=0 ALT="Click to view at full size."> </A>
</P>
<P>
<!-- caption --><B>Figure 4-3.</B> <I>The definition for the default character set and sort order.</I><!-- /caption -->
</P>


<P>The default sort order is case insensitive, for both comparison and 
sorting purposes. You must use a variation of this sort order, which is called 
<I>case insensitivity with preference</I>, when you work with multilingual characters. In 
a sort order &quot;with preference,&quot; even though 
<I>A</I> is defined as equal to <I>a</I> for the 
purposes of string comparison (affecting character searches, including the constructs  
DISTINCT, UNION, LIKE, and so on), the<I> preference 
</I>option causes all collating (order by) to present the 
<I>A</I> before the <I>a</I>. In general terms, the 
semantics are &quot;For the search process, treat A and a as identical, but show it to me with the A results preceding a .&quot; You might prefer this behavior, for example, 
when you want to print a list of both uppercase and lowercase entries, without 
regard to case but with names in uppercase printing before those in lowercase 
rather than their being randomly intermixed.</P>

<P>You can actually think of characters as having primary, secondary, 
and tertiary sort values, which are different for different sort order choices. To 
be more precise, the above sort order defines all 
<I>A</I>-like values as having the same primary sort value. 
<I>A </I>and <I>a</I> not only have the same primary sort value, they 
also have the same secondary sort value because they are defined as equal. The 
character <I>&agrave;</I> has the same primary value as 
<I>A</I> and <I>a</I> but is not declared equal to 
them, so <I>&agrave;</I> has a different secondary value. And although 
<I>A</I> and <I>a</I> have the same primary and secondary sort values, with an uppercase preference sort order 
each has a different tertiary sort value, which allows it to compare identically but 
sort differently. If your sort order does not have uppercase preference, 
<I>A</I> and <I>a</I> have the same primary, secondary, and tertiary sort values.</P>

<P>A character's primary sort value is used to distinguish it from other 
characters, without regard to case and diacritical marks. It is essentially an 
optimization: if two characters do not have the same primary sort value, they 
cannot be considered identical for either comparison or sorting and there is no 
reason to look further. The secondary sort value distinguishes two characters that 
share the same primary value. If the characters share the same primary and 
secondary values (for example <I>A =</I> <I>a</I>), they are treated as identical for comparisons. 
The tertiary value allows the characters to compare identically but sort 
differently. Hence, based on <I>A = a</I>, apple and Apple are considered equal. However, 
<I>Apple </I>sorts before <I>apple</I> when a sort order with uppercase preference is used. If 
there is no uppercase preference, whether <I>Apple 
</I>or <I>apple </I>sorts first is simply a random event based on the order in which the data is encountered when retrieved.</P>

<P>Some sort order choices allow for accent insensitivity. This means 
that extended characters with diacritics are defined with primary and secondary 
values equivalent to those without. If you want a search of 
<I>name = 'Jose'</I> to<I> </I>find both <I>Jose 
</I>and <I>Jos&eacute;</I>, you should choose accent insensitivity. Such a sort order 
defines all <I>E</I>-like characters as equal and has the following in the 
<I>sp_helpsort</I> output:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
E=e=&egrave;=&Eacute;=&eacute;=&ecirc;=&euml;
</pre>
</td></tr></table></p>

<P>All the accent-insensitive sort orders provided by SQL Server also 
have uppercase preference enabled, which means that in an ORDER BY, the 
<I>E</I>-like<I> </I>characters above, although considered equivalent for character matching, 
sort as <I>E</I>,<I> e</I>, <I>&egrave;</I>, 
<I>&Eacute;</I>, <I>&eacute;</I>, <I>&ecirc;</I>, 
<I>&euml;</I>, with each uppercase letter paired with its lowercase 
equivalent and distinguished from the other 
<I>E</I>-like characters. Technically, there is no reason that you can't have a sort order of Accent Insensitive Without 
Preference. But because the large number of existing sort orders are confusing to 
most people, not every conceivable variation is offered.</P>

<p><div class="note"><blockquote>
<b>NOTE</b><HR>
When deciding on the case sensitivity for your SQL 
Server installation, you should be aware that the case sensitivity applies  
to object names as well as your user data because object names 
(the metadata) are stored in tables just like user data. So if you have a 
case-insensitive sort order, the table 
<I>CustomerList</I> is seen as identical to a table called 
<I>CUSTOMERLIST</I> and to one called 
<I>customerlist</I>. If your server is case sensitive and you have a table called 
<I>CustomerList</I>, SQL Server will not find the table if you refer to it as 
<I>customerlist.</I>
</blockquote></div></p>

<A NAME="155"><H3>Binary Sorting</H3></A>

<P>Each character set offers a binary sorting option. With binary sorting, you 
do not have to specify each character's sort position. Characters are sorted 
based on their internal byte representation. If you look at a chart for the character 
set, you see the characters ordered by this numeric value. In a binary sort, the 
characters sort according to their position by value, just as they are in the 
chart. Hence, by definition, a binary sort is always case sensitive and accent 
sensitive and every character has a unique byte value.</P>

<P>Binary sorting is the fastest sorting option because all that is 
required internally is a simple byte-by-byte comparison of the values. But if you use 
extended characters, binary sorting is not semantically desirable. Characters 
that are <I>A</I>-like, such as <I>&Auml;</I>, 
<I>&auml;</I>, <I>&Aring;</I>, and <I>&aring;</I>, all sort after 
<I>Z</I> because the extended character <I>A</I>'s are in the top 128 characters and 
<I>Z</I> is a standard ASCII character in the lower 128. If you deal with only ASCII characters (or otherwise don't care 
about the sort  order of extended characters), you want case sensitivity, and you 
don't care about &quot;dictionary&quot; sorting, binary sorting is an ideal choice. (In case- 
sensitive dictionary sorting, the letters <I>ABCXYZabcxyz 
</I>sort as <I>AaBbCcXxYyZz</I>. In binary sorting, all uppercase letters appear before any lowercase letters: 
for example, <I>ABCXYZabcxyz</I>.)</P>

<A NAME="156"><H3>Performance Considerations</H3></A>

<P>Binary sorting uses significantly fewer CPU instructions than sort orders 
with defined sort values. So binary sorting is ideal if it fulfills your semantic 
needs. However, you won't pay a noticeable penalty for using either a simple 
case-insensitive sort order (for example, Dictionary Order, 
Case-Insensitive) or a  
case-sensitive choice that offers better support than binary sorting for 
extended characters. Most large sorts in SQL Server tend to be I/O bound, not 
CPU bound, so the fact that there are fewer CPU instructions used by binary 
sorting doesn't typically translate to a significant performance difference. When 
you sort a small amount of data that is not I/O bound, even though binary 
sorting is faster, the difference is minimal; the sort will be fast in both cases.</P>

<P>A more significant performance difference results if you choose a sort 
order that is Case-Insensitive, Uppercase Preference. Recall that this choice 
considers all values as equal from the comparison standpoint, which also 
includes indexing. Characters retain a unique tertiary sort order, so they might be 
treated differently by an ORDER BY clause. Uppercase Preference can often 
require an additional sort operation in queries, more than with simple case insensitivity.</P>

<P>Consider a query that specifies <I>WHERE LAST_NAME 
&gt;= 'Jackson' ORDER BY LAST_NAME. </I>If an index exists on the 
<I>last_name </I>field, the query optimizer will likely use it to find rows whose 
<I>last_name</I> value is greater  
than or equal to <I>Jackson</I>. If there is no need to use Uppercase Preference, 
the optimizer knows that because it is retrieving records based on the order 
of <I>last_name</I>, there is also no need to physically sort the rows because they 
were extracted in that order already. 
<I>Jackson</I>,<I> jackson</I>, and <I>JACKSON</I> are all 
qualifying rows. All are indexed and treated identically, and they simply appear in 
the results set in the order in which they were encountered. If Uppercase 
Preference is required for sorting, a subsequent sort of the qualifying rows is 
required to differentiate the rows, even though the index can still be used for 
selecting qualifying rows. If many qualifying rows are present, the performance 
difference between the two cases (one needs an additional sort operation) can 
be dramatic. This doesn't mean that you shouldn't 
choose Uppercase Preference. If you require those semantics, the performance aspect might well be a 
secondary concern. But you should be aware of the trade-off and decide which is 
most important to you. Determine whether your application can simply be made 
to input character data in all lowercase or uppercase consistently.</P>

</BODY>
</HTML>




