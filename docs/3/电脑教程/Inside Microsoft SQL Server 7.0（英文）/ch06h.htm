<HTML>
<HEAD>
<link rel="STYLESHEET" type="text/css" href="squeal7.css">
<TITLE>Altering a Table</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch06g.htm">[Previous]</A> <A HREF="ch06i.htm">[Next]</A><P>

<A NAME="252"><H1>Altering a Table</H1></A>

<p>SQL Server 7 allows existing tables to be modified in several ways, and we've seen some of these methods already. You can use ALTER TABLE to add or drop constraints from a table. We've seen that some types of constraints have the option of not being applied to existing data by using the WITH NOCHECK option. Using the ALTER table command, you can make the following types of changes to an existing table:</p>

<ul>
<p><li>Change the datatype or NULL property of a single column.</li></p>
<p><li>Add one or more new columns, with or without defining constraints for those columns.</li></p>
<p><li>Add one or more constraints.</li></p>
<p><li>Drop one or more constraints.</li></p>
<p><li>Drop one or more columns.</li></p>
<p><li>Enable or disable one or more constraints (only applies to CHECK and FOREIGN KEY constraints).</li></p>
<p><li>Enable or disable one or more triggers.</li></p>
</ul>

<A NAME="253"><H2>Changing a Datatype</H2></A>

<p>By using the ALTER COLUMN clause of ALTER TABLE, you can modify the datatype or NULL property of an existing column. But be aware of the following restrictions:</p>

<ul>
<p><li>The modified column can't be a <i>text</i>, <i>image</i>, <i>ntext</i>, or <i>timestamp</i> column.</li></p>
<p><li>If the modified column is the ROWGUIDCOL for the table, only DROP ROWGUIDCOL is allowed; no datatype changes are allowed.</li></p>
<p><li>The modified column can't be a computed or replicated column.</li></p>
<p><li>The modified column can't have a CHECK or FOREIGN KEY constraint defined on it.</li></p>
<p><li>The modified column can't be referenced in a computed column.</li></p>
<p><li>The modified column can't have the type changed to <i>timestamp</i>.</li></p>
<p><li>If the modified column participates in an index, the only type changes that are allowed are increasing the length of a variable-length type, changing nullability of the column (for example, VARCHAR(10) to VARCHAR(20)), or both.</li></p>
<p><li>If the modified column has a default defined on it, the only changes that are allowed are increasing or decreasing the length of a variable-length type, changing nullability, or both.</li></p>
<p><li>The old type of the column should have an allowed implicit conversion to the new type.</li></p>
<p><li>The new type always has ANSI_PADDING semantics if applicable, regardless of the current setting.</li></p>
<p><li>If conversion of old type to new type causes an overflow (arithmetic or size), the ALTER TABLE statement is aborted.</li></p>
</ul>

<p>Here's the syntax and an example of using the ALTER COLUMN clause of the ALTER TABLE statement:</p>

<A NAME="254"><H3>SYNTAX</H3></A>

<p>
<table cellpadding="5" width="95%">
	<tr>
		<td>
<pre>ALTER TABLE <I>table-name</I> ALTER COLUMN <I>column-name</I>
        { <I>type_name</I> [ ( <I>prec</I> [, <I>scale</I>] ) ]  [ NULL | NOT NULL ]
          |  {ADD | DROP} ROWGUIDCOL }
</pre></td>
		</tr>
	</table></p>

<A NAME="255"><H3>EXAMPLE</H3></A>

<p>
<table cellpadding="5" width="95%">
	<tr>
		<td>
<pre>/* Change the length of the emp_name column in the employee 
   table from varchar(30) to varchar(50) */
ALTER TABLE employee 
ALTER COLUMN emp_name (varchar(50)
</pre></td>
		</tr>
	</table></p>

<A NAME="256"><H2>Adding a New Column</H2></A>

<p>You can add a new column, with or without specifying column-level constraints. You can add only one column for each ALTER TABLE statement. If the new column doesn't allow NULLs and isn't an identity column, the new column must have a default constraint defined. SQL Server populates the new column in every row with a NULL, the appropriate identity value, or the specified default. If the newly added column is nullable and has a default constraint, the existing rows of the table are <i>not</i> filled with the default value, but rather with NULL values. You can override this restriction by using the WITH VALUESclause so that the existing rows of the table are filled with the specified default value.</p>

<A NAME="257"><H2>Adding, Dropping, Disabling, or Enabling a Constraint</H2></A>

<p>Constraint modifications were covered earlier in the discussion about constraints. The trickiest part of using ALTER TABLE to manipulate constraints is that the word CHECK can be used in three different ways:</p>

<ul>
<p><li>To specify a CHECK constraint.</li></p>
<p><li>To defer checking of a newly added constraint. In the following example, we're adding a constraint to validate that <i>cust_id</i> in <i>orders</i> matches a <i>cust_id </i>in <i>customer</i>, but we don't want the constraint applied to existing data:</li></p>

<p>
<table cellpadding="5" width="95%">
	<tr>
		<td>
<pre>ALTER TABLE orders
WITH NOCHECK
ADD FOREIGN KEY (cust_id) REFERENCES customer (cust_id)
</pre></td>
		</tr>
	</table></p>

<p>
<div class="note"><blockquote>
<b>NOTE</b><hr>
We could also use WITH CHECK to force the constraint to be applied to existing data, but that's unnecessary because it's the default behavior.
</blockquote></div>
</p>

<p><li>To enable or disable a constraint. In the next example, we're enabling all the constraints on the employee table:</li></p>

<p>
<table cellpadding="5" width="95%">
	<tr>
		<td>
<pre>ALTER TABLE EMPLOYEE
CHECK ALL
</pre></td>
		</tr>
	</table></p>
</ul>

<p>One more commonly misunderstood aspect of using ALTER TABLE to drop constraints is that dropping a PRIMARY KEY or UNIQUE constraint will automatically drop the associated index. In fact, the only way to drop those indexes is by altering the table to remove the constraint.</p>

<A NAME="258"><H2>Dropping a Column</H2></A>

<p>You can use ALTER TABLE to remove one or more columns from a table. However, you can't drop the following columns:</p>

<ul>
<p><li>A replicated column.</li></p>
<p><li>A column used in an index.</li></p>
<p><li>A column used in a CHECK, FOREIGN KEY, UNIQUE, or PRIMARY KEY constraint.</li></p>
<p><li>A column associated with a default defined with the DEFAULT keyword or bound to a default object.</li></p>
<p><li>A column bound to a rule, accomplished via the following syntax:</li></p>

<p>
<table cellpadding="5" width="95%">
	<tr>
		<td>
<pre>ALTER TABLE <i>table-name</i>
DROP COLUMN <i>column-name</i> [,<i>next-column-name</i>]...
</pre></td>
		</tr>
	</table></p>
</ul>	

<p>
<div class="note"><blockquote>
<b>NOTE</b><hr>
Notice the syntax difference between adding a new column and dropping a column: when adding a new column to a table, the word COLUMN isn't used, but when dropping a column, the word COLUMN is required.
</blockquote></div>
</p>

<A NAME="259"><H2>Enabling or Disabling a Trigger</H2></A>

<p>You can enable or disable one or more (or <i>all</i>) triggers on a table using the ALTER TABLE command. We'll look at this topic in more detail when we discuss triggers in <A HREF="ch10a.htm">Chapter 10</A>.</p>

<p>Note that not all the ALTER TABLE variations require SQL Server to change every row when the ALTER TABLE is issued. In many cases, SQL Server can just change the metadata (in <i>syscolumns</i>) to reflect the new structure. In particular, the data isn't touched when a column is dropped, when a new column is added and NULL is assumed as the new value for all rows, when the length of a variable-length column is changed, or when a non-nullable column is changed to allow NULLs. All other changes to a table's structure require SQL Server to physically update every row and to write the appropriate records to the transaction log.</p>

</BODY>
</HTML>



