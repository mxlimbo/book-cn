<HTML>
<HEAD>
<link rel="STYLESHEET" type="text/css" href="squeal7.css">
<TITLE>Lock Types for User Data</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch13b.htm">[Previous]</A> <A HREF="ch13d.htm">[Next]</A><P>

<A NAME="500"><H1>Lock Types for User Data</H1></A>


<p>
Now we'll examine four aspects of locking user data. First, we'll look at the 
mode of locking (the type of lock). We already mentioned shared, exclusive, and 
update locks, and we'll go into more detail about these modes as well as others. 
Next, we'll look at the granularity of the lock, which specifies how much data is 
covered by a single lock. This can be a row, a page, an index key, a range of 
index keys, an extent, or an entire table. The third aspect of locking is the 
duration of the lock. As mentioned earlier, some locks are released as soon as the 
data has been accessed and some locks are held until the transaction commits or 
rolls back. For example, cursor scroll locks are held until a new FETCH operation 
is executed. The fourth aspect of locking concerns the ownership of the lock 
(the scope of the lock). Locks can be owned by a session, a transaction, or a cursor.
</P>

<A NAME="501"><H2>Lock Modes</H2></A>


<p>
SQL Server uses several locking modes, including shared locks, exclusive 
locks, update locks, and intent locks.
</P>

<A NAME="502"><H3>Shared Locks</H3></A>


<p>
Shared locks are acquired automatically by SQL Server when data is read. 
Shared locks can be held on a table, a page, an index key, or an individual row. 
Many processes can hold shared locks on the same data, but no process can 
acquire an exclusive lock on data that has a shared lock on it (unless the process 
requesting the exclusive lock is the same process as the one holding the shared 
lock). Normally, shared locks are released as soon as the data has been read, but 
you can change this by using query hints or a different transaction isolation level.
</P>

<A NAME="503"><H3>Exclusive Locks</H3></A>


<p>
SQL Server automatically acquires exclusive locks on data when it is 
modified by an insert, update, or delete operation. Only one process at a time can 
hold an exclusive lock on a particular data resource; in fact, as we'll see when we 
discuss lock compatibility, no locks of any kind can be acquired by a process if 
another process has the requested data resource exclusively locked. Exclusive locks are 
held until the end of the transaction. This means that the changed data is 
normally not available to any other process until the current transaction commits or rolls 
back. Other processes can decide to read exclusively locked data by using query hints.
</P>

<A NAME="504"><H3>Update Locks</H3></A>


<p>
Update locks are really not a separate kind of lock; they are a hybrid 
between shared and exclusive locks. They are acquired when SQL Server executes a 
data modification operation but first needs to search the table to find the 
resource that will be modified. Using query hints, a process can specifically request 
update locks, and in that case they prevent the conversion deadlock situation 
presented in Figure 13-2.
</P>

<p>
Update locks provide compatibility with other current readers of 
data, allowing the process to later modify data with the assurance that the data 
hasn't been changed since it was last read. An update lock is not sufficient to allow 
you to change the data&#8212;all modifications require that the data resource 
being modified has an exclusive lock. An update lock acts as a serialization gate to 
queue future requests for the exclusive lock. (Many processes can hold shared 
locks for a resource, but only one process can hold an update lock.) As long as a 
process holds an update lock on a resource, no other process can acquire an update 
lock or an exclusive lock for that resource; instead, another process requesting 
an update or exclusive lock for the same resource must wait. The process 
holding the update lock can acquire an exclusive lock on that resource because the 
update lock prevents lock incompatibility with any other processes. You can think 
of update locks as &quot;intent-to-update&quot; locks, which is essentially the role 
they perform. Used alone, update locks are insufficient for updating 
data&#8212;an exclusive lock is still required for actual data modification. Serializing access for 
the exclusive lock lets you avoid conversion deadlocks.
</P>

<p>
Don't let the name fool you: update locks are not just for update 
operations. SQL Server uses update locks for any data modification operation that 
requires a search for the data prior to the actual modification. Such operations 
include qualified updates and deletes, as well as inserts into a table with a clustered 
index. In the latter case, SQL Server must first search the data (using the 
clustered index) to find the correct position at which to insert the new row. While 
SQL Server is only searching, it uses update locks to protect the data; only after 
it has found the correct location and begins inserting does it escalate the 
update lock to an exclusive lock.
</P>

<A NAME="505"><H3>Intent Locks</H3></A>


<p>
Intent locks are not really a separate mode of locking; they are a qualifier to 
the modes previously discussed. In other words, you can have 
<I>intent shared locks, intent exclusive 
locks,</I> and even <I>intent update locks</I>. Because SQL Server 
can acquire locks at different levels of granularity, a mechanism is needed to 
indicate that a component of a resource is already locked. For example, if one 
process tries to lock a table, SQL Server needs a way to determine whether a row (or 
a page) of that table is already locked. Intent locks serve this purpose. We'll 
discuss them in more detail when we look at lock granularity.
</P>

<A NAME="506"><H3>Special Lock Modes</H3></A>


<p>
SQL Server offers three additional lock modes: 
<I>schema stability locks,</I> <I>schema modification 
locks,</I> and <I>bulk update locks</I>. When queries are compiled, 
schema stability locks prevent other processes from acquiring schema modification 
locks, which are taken when a table's structure is being modified. A bulk update 
lock is acquired when the BULK INSERT command is executed or when the 
<I>bcp</I> utility is run to load data into a table. In addition, the copy operation 
must request this special lock by using the TABLOCK hint. Alternatively, the 
table can set the table option called <I>table lock on bulk load 
</I>to true, and then any bulk copy IN or BULK INSERT operation automatically requests a bulk update lock.
</P>

<p>
Another lock mode that you might notice is the SIX lock. This mode 
is never requested directly by the lock manager but is the result of a 
conversion. If a transaction is holding a shared (S) lock on a resource and later an IX 
lock is needed, the lock mode will be indicated as SIX. For example, suppose 
you are operating at the Repeatable Read transaction isolation level and you 
issue the following batch:
</P>

<P>
<table cellpadding=5 width="95%"><tr><td>	
<pre>
BEGIN TRAN
SELECT * FROM bigtable 
UPDATE bigtable
    SET col = 0
    WHERE keycolumn = 100
</pre>
</td></tr></table>
</P>

<p>
Assuming the table is large, the SELECT statement will acquire a 
shared table lock. (If there are only a few rows in 
<I>bigtable</I>, SQL Server will acquire individual row or key locks.) The UPDATE statement will then acquire a 
single exclusive key lock to do the update of a single row, and the X lock at the 
key level will mean an IX lock at the page and table level. The table will then 
show SIX when viewed through <I>sp_lock</I>.
</P>

<p>
Table 13-1 shows most of the lock modes, as well as the abbreviations 
used in the output of <I>sp_lock</I>.
</P>

<P><B>Table 13-1.</B> <I>SQL Server lock modes.</I></P>

<p>
<table cellpadding=5 width="95%">
<tr>
<th>Abbreviation</th> 
<th>Lock Mode</th> 
<th>Description</th>
</TR>
<TR>
<td valign="top">S </td>   
<td valign="top">Shared</td>     
<td valign="top">Allows other processes to read but not change the locked resource.</td>
</tr>
<TR>
<td valign="top">X</td>  
<td valign="top">Exclusive</td>     
<td valign="top">Prevents another process from modifying or reading data in the locked resource (unless the process is set to the Read Uncommitted isolation level).</td>
</TR>
<TR>
<td valign="top">IS</td>  
<td valign="top">Intent shared</td>   
<td valign="top"> Indicates that a component of this resource is locked with a shared lock. This lock can be acquired only at the table or page level.</td>
</tr>
<TR>
<td valign="top">IX </td>    
<td valign="top">Intent exclusive</td>     
<td valign="top"> Indicates that a component of this resource is locked with an exclusive lock. This lock can be acquired only at the table or page level.</td>
</tr>
<TR>
<td valign="top">SIX</td>    
<td valign="top">Shared with shared intent exclusive</td> 
<td valign="top">Indicates that a resource holding a lock also has a component (a page or row) locked with an exclusive lock.</td>
</tr>
<TR>
<td valign="top">Sch-S</td>  
<td valign="top">Schema stability</td>
<td valign="top">Indicates that a query using this table is being compiled.</td>
</tr>
<TR>
<td valign="top">Sch-M</td>
<td valign="top">Schema modification</td>
<td valign="top">Indicates that the structure of the table is being changed.</td>
</tr>
<tr>
<td valign="top">BU</td> 
<td valign="top"> Bulk update </td> 
<td valign="top">Used when a bulk copy operation is copying data into a table and the TABLOCK hint is being applied (either manually or automatically).</td>
</tr>
</table>
</P>


<A NAME="507"><H2>Lock Granularity</H2></A>
<p>
SQL Server can lock user data resources (not system resources, which are protected with latches) at the 
table, page, or row level. SQL Server also locks index keys and ranges of index keys. Figure 13-3 shows 
the possible lock levels in a table. Note that if the table has a clustered index, the data rows are at 
the leaf level of the clustered index, and they are locked with key locks instead of row locks.
</P>

<P>
<A HREF="javascript:fullSize('f13wh03x.htm')"> <img src="f13wh03.JPG" width=404 height=238 border=0 ALT="Click to view at full size."> </A>
</P>
<P>
<!-- caption --><B>Figure 13-3.</B> <I>Levels of granularity for SQL Server locks.</I><!-- /caption -->
</P>


<P>
The <I>syslockinfo</I> table keeps track of each lock by storing the type of resource locked (such as a 
row, key, or page), the mode of the lock, and an identifier for the specific resource. When a process 
requests a lock, SQL Server compares the lock requested to the resources already listed in the 
<I>syslockinfo </I>table and looks for an exact match on the resource type and identifier. (The lock 
modes don't have to be the same to yield an exact match.) However, if one process has a row exclusively 
locked in the <I>authors</I> table, another process might try to get a lock on the entire <I>authors</I> 
table. Since these are two different resources, SQL Server does not find an exact match unless additional 
information is already stored in <I>syslockinfo</I>. This is what intent locks are for. The process that 
has the exclusive lock on a row of the <I>authors</I> table also has an intent exclusive lock on the page 
containing the row and another intent exclusive lock on the table containing the row. When the second 
process attempts to acquire the exclusive lock on the table, it finds a conflicting row already in the 
<I>syslockinfo</I> table on the same lock resource (the <I>authors</I> table).
</P>
<A NAME="508"><H3>Key Locks</H3></A>


<p>
SQL Server 7 supports two kinds of key locks, whose use depends on the isolation level of the current transaction. If the isolation level is Read Committed or Repeatable Read, SQL Server tries to lock the actual index keys accessed 
while processing the query. With a table that has a clustered index, the data rows are the leaf level of the index, and you will see key locks acquired. If the table is 
a heap, you might see key locks for the nonclustered indexes and row locks for the actual data.
</P>

<p>
If the isolation level is Serializable, the situation is special. We want to prevent phantoms, which means that if we have scanned a range of data within a transaction, we need to lock enough of the table to make sure that no one 
can insert a value into the range that was scanned. For example, we can issue 
the following query within an explicit transaction:
</P>

<p>
<table cellpadding=5 width="95%"><tr><td>	
<pre>
SELECT * FROM employees
WHERE salary BETWEEN 30000 AND 50000
</pre>
</td></tr></table>
</P>

<p>
Locks must be acquired to make sure that no new rows with salary values between 30000 and 50000 are inserted before the end of the transaction. Earlier versions of SQL Server guaranteed this by locking whole pages or even the 
entire table. In many cases, however, this was too restrictive&#8212;more data was locked than the actual WHERE clause indicated, resulting in unnecessary 
contention. SQL Server 7 uses key range locks, which are associated with a particular 
key value in an index and indicate that all values between that key and the previous one in the index are locked.
</P>

<p>
Suppose we have an index on the <I>lastname</I> field in the 
<I>employee</I> table. We are in TRANSACTION ISOLATION LEVEL SERIALIZABLE and we issue this SELECT statement:
</P>
<p>
<table cellpadding=5 width="95%"><tr><td>	
<pre>
SELECT * 
FROM members
WHERE last_name BETWEEN 'Delaney' AND 'DuLaney'
</pre>
</td></tr></table>
</P>


<P>If <I>Dallas</I>, <I>Donovan</I>, and <I>Duluth</I> are sequential leaf-level index keys in the table, the 
second two of these (<I>Donovan </I>and 
<I>Duluth</I>) acquire key range locks (although 
only one row, for <I>Donovan</I>, is returned in the result set). The key range locks prevent any inserts into the ranges ending with the two key range locks. No values greater than <I>Dallas </I>and less than or equal to 
<I>Donovan</I> can be inserted, and no values greater than 
<I>Donovan</I> and less than or equal to <I>Duluth</I> can be inserted. Note that the key range locks imply an open interval starting at the previous sequential key and a closed interval ending at the key on which the lock is placed. These two key range locks prevent anyone from 
inserting either <I>Delany </I>or <I>Delanie</I>, which are in the range specified in the WHERE clause. However, the key range locks would also prevent anyone from inserting <I>DeLancey</I> (which is greater than <I>Dallas</I> and less than <I>Donovan</I>) even though <I>DeLancey</I> 
is not in the query's specified range. Key range locks are not perfect, but they do give much greater concurrency than locking whole pages or tables, which was the only possibility in previous SQL Server versions.
</P>

<A NAME="509"><H3>Additional Lock Resources</H3></A>


<p>
Locking is also done on <I>extents</I>&#8212;units of disk space that are 64 KB in size 
(eight pages of 8 KB each). This kind of locking occurs automatically when a table 
or an index needs to grow and a new extent must be allocated. You can think 
of an extent lock as another type of special purpose latch, but it does show up 
in the output of the <I>sp_lock</I> procedure. Extents can have both shared extent 
and exclusive extent locks.
</P>

<p>
When you examine the output of <I>sp_lock</I>, notice that each process 
holds a lock on at least one database. These are always shared locks and are used 
by SQL Server for determining when a database is in use. Generally, you don't 
need to be concerned with extent or database locks, but you might see them if 
you are running <I>sp_lock </I>or<I> </I>perusing 
<I>syslockinfo.</I>
</P>

<A NAME="510"><H3>Identifying Lock Resources</H3></A>


<p>
When the lock manager tries to determine whether a requested lock can 
be granted, it checks the <I>syslockinfo</I> table to determine whether a matching lock 
with a conflicting lock mode already exists. It compares locks by looking at the 
database id (dbid), the object id (objid), the type of resource locked, and the 
description of the specific resource referenced by the lock. The lock manager 
knows nothing about the meaning of the resource description. It simply compares 
the strings identifying the lock resources to look for a match. If it finds a match, 
it knows that resource is already locked; it then uses the lock compatibility 
matrix to determine whether the current lock is compatible with the one being 
requested. Table 13-2 shows all the lock resources, the abbreviations used in the 
output of <I>sp_lock</I>, and the information used to define the actual resource locked.
</P>

<p><B>Table 13-2.</B> <I>Lockable resources in SQL Server.</I></P>

<p>
<table cellpadding=5 width="95%"><tr>	
<th>Resource</th>
<th>Abbreviation</th>
<th>Resource Description</th>
<th>Example</th>
</TR>
<TR>
<td valign="top">Database </td>
<td valign="top">DB</td>
<td valign="top">None; the database is always indicated in the <I>dbid</I> column for every locked resource.</td>
<td valign="top"></td>
</tr>
<TR>
<td valign="top">Table</td>
<td valign="top">TAB</td>
<td valign="top">The table ID.</td>
<td valign="top">261575970 (Note that <I>sp_lock</I> shows the table ID in its own column rather than in the resource description column.)</td>
</tr>
<TR>
<td valign="top">Extent</td>
<td valign="top">EXT</td>
<td valign="top">File number:page number of the first page of the extent.</td>
<td valign="top">1:96</td>
</tr>
<TR>
<td valign="top">Page</td>
<td valign="top">PAG</td>
<td valign="top">File number:page number of the actual table or index page.</td>
<td valign="top">1:104</td>
</tr>
<TR>
<td valign="top">Index Key</td>
<td valign="top">KEY</td>
<td valign="top">A hashed value derived from all the key components and the locator. For a non-clustered index on a heap, where columns <I>c1</I> and <I>c2</I> are indexed, the hash would contain contributions from <I>c1</I>, <I>c2</I>, and the RID.</td>
<td valign="top">ac0001a10a00</td>
</tr>
<TR>
<td valign="top">Index Key Range</td>
<td valign="top">KEY</td>
<td valign="top">Same as Index Key.</td>
<td valign="top">ac0001a10a00</td>
</tr>
<TR>
<td valign="top">Row</td>
<td valign="top">RID</td>
<td valign="top">File number:page number: slot number of the actual row.</td>
<td valign="top">1:161:3</td>
</tr>
</table>
</P>



<p>
Note that key locks and key range locks have identical resource descriptions. When we look at some examples of output from the <I>sp_lock</I> procedure, you'll see that you can distinguish between these types of locks by the value in the lock mode column.
</P>

<A NAME="511"><H2>Lock Duration</H2></A>

<p>
The length of time that a lock is held depends primarily on the mode of the lock and the transaction isolation level in effect. The default isolation level for SQL Server is Read Committed. At this level, shared locks are released as 
soon as SQL Server has read and processed the locked data. An exclusive lock is held until the end of the transaction, whether it is committed or rolled back. An update lock is held until the end of the transaction unless it has been 
promoted to an exclusive lock, in which case the exclusive lock remains for the duration of the transaction. If your transaction isolation level is Repeatable Read or Serializable, shared locks have the same duration as exclusive locks. That is, they are not released until the transaction is over.
</P>

<p>
In addition to changing your transaction isolation level, you can control the lock duration by using query hints. We'll discuss query hints for locking and for other purposes in <a href="ch14a.htm">Chapter 14</a>.
</P>
<A NAME="512"><H2>Lock Ownership</H2></A>


<p>
Lock duration can also be affected by the lock ownership. There are three 
types of lock owners: transactions, cursors, and sessions. These are available 
through the <I>req_ownertype</I> column in the 
<I>syslockinfo</I> table. (This information is not 
visible through the <I>sp_lock</I> stored procedure.) A 
<I>req_ownertype</I> value of 1 indicates that the lock is owned by transaction, and its duration is as discussed above. 
Most of our locking discussion, in fact, deals with locks owned by a transaction. 
A cursor lock has a <I>req_ownertype</I> value of 2. If a cursor is opened using a 
locking mode of scroll_locks, a cursor lock is held on every row fetched 
until the next row is fetched or the cursor is closed. Even if the transaction 
commits before the next fetch, the cursor lock is not released. Locks owned by a 
session have a <I>req_ownertype</I> value of 3. A session lock is one taken on behalf of a 
process that is outside the scope of a transaction. The most common example is 
a database lock, as discussed earlier. A process acquires a session lock on the 
database when it issues the USE database command, and that lock isn't released 
until another USE command is issued or until the process is disconnected.
</P>

<A NAME="513"><H2>Viewing Locks</H2></A>


<p>
To see the locks currently outstanding in the system as well as those that are 
being waited for, examine the <I>syslockinfo </I>system table or execute the system 
stored procedure <I>sp_lock</I>. (The 
<I>syslockinfo</I> table is not really a system table. It is 
not maintained on disk because locks are not maintained on disk. Rather, it 
is materialized in table format based on the lock manager's current accounting 
of locks each time <I>syslockinfo</I> is queried.) Another way to watch locking activity 
is with the excellent graphical representation of locking status provided by 
SQL Server Enterprise Manager. (Even those of you who think GUIs are for 
wimps can appreciate SQL Server Enterprise Manager's view of locking.)
</P>

<p>
The following examples show what each of the lock types and 
modes discussed earlier look like when reported by the 
<I>sp_lock</I> procedure. Note that the call to the 
<I>sp_lock </I>procedure is preceded by the keyword EXECUTE, 
which is required when the call to a stored procedure is not the first thing in a 
batch. Note also that the <I>sp_lock </I>procedure is given an argument of @@spid, which 
refers to the process ID of the current process (the server process ID). We don't 
want to see all the locks in the system, only those held by our process.
</P>

<A NAME="514"><H3>Example 1: SELECT with Default Isolation Level</H3></A>


<p>
<B>SQL BATCH</B>
</P>
<p>
<table cellpadding=5 width="95%"><tr><td>	
<pre>
USE PUBS
SET TRANSACTION ISOLATION LEVEL READ COMMITTED
BEGIN TRAN
SELECT * FROM authors
WHERE au_lname = 'Ringer'
EXEC sp_lock @@spid
COMMIT TRAN
</pre>
</td></tr></table>
</P>

<p>
<B>OUTPUT OF <I>sp_lock</I></B>
</P>

<p>
<table cellpadding=5 width="95%"><tr><td>	
<pre>
spid   dbid   ObjId       IndId  Type Resource         Mode     Status 
------ ------ ----------- ------ ---- ---------------- -------- ----- 
11     1      0           0      DB                    S        GRANT
11     2      0           0      DB                    S        GRANT
11     5      0           0      DB                    S        GRANT
11     1      117575457   0      TAB                   IS       GRANT
</pre>
</td></tr></table>
</P>


<p>
Every time we run the <I>sp_lock</I> procedure, we acquire locks in the master database to generate the output to be displayed. If you look at the <I>dbid</I> column in the output, you'll see locks in database 1 (<I>master</I>) and database 2 (<I>tempdb</I>). We won't show those locks in the output for the rest of the examples. If we ignore the locks in <I>master </I>and <I>tempdb</I>, we'll see that the only lock in the <I>pubs</I> database is the session-level database lock. No locks on the <I>authors</I> table are held at this point because the batch was doing only select operations that acquired shared locks. By default, the shared locks are released as soon as the data has been read, so by the time <I>sp_lock</I> is executed, the locks are no longer held.
</P>

<A NAME="515"><H3>Example 2: SELECT with Repeatable Read Isolation Level</H3></A>


<p>
<B>SQL BATCH</B>
</P>
<P>
<table cellpadding=5 width="95%"><tr><td>
<pre>
USE PUBS
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ
BEGIN TRAN
SELECT * FROM authors
WHERE au_lname = 'Ringer'
EXEC sp_lock @@spid
COMMIT TRAN
</pre>
</td></tr></table>
</P>

<p>
<B>OUTPUT OF <I>sp_lock</I></B></P>
<p>
<table cellpadding=5 width="95%"><tr><td>	
<pre>
spid   dbid   ObjId       IndId  Type Resource         Mode     Status 
------ ------ ----------- ------ ---- ---------------- -------- ------
11     5      117575457   2      PAG  1:123            IS       GRANT
11     5      117575457   1      PAG  1:96             IS       GRANT
11     5      0           0      DB                    S        GRANT
11     5      117575457   2      KEY  (d5f329a7dcdc)   S        GRANT
11     5      117575457   2      KEY  (4c62318cf11f)   S        GRANT
11     5      117575457   1      KEY  (3dc1b1ecb5be)   S        GRANT
11     5      117575457   1      KEY  (37fdb5efbcbe)   S        GRANT
11     5      117575457   0      TAB                   IS       GRANT
</pre>
</td></tr></table>
</P>


<p>
Because the <I>authors</I> table has a clustered index, the rows of data are all 
index rows in the leaf level. The locks on the individual rows are marked as key 
locks instead of row locks. There are also key locks at the leaf level of the 
nonclustered index on the table. You can tell the two indexes apart by the value in the 
<I>IndId</I> field: the data rows have an <I>IndId 
</I>value of 1, and the nonclustered index rows have an 
<I>IndId</I> value of 2. Because the transaction isolation level is 
Repeatable Read, the shared locks are held until the transaction is finished. Note that 
the two rows and two index rows have shared (S) locks, and the data and index 
pages, as well as the table itself, have intent shared (IS) locks.
</P>

<A NAME="516"><H3>Example 3: SELECT with Serializable Isolation Level</H3></A>


<p>
<B>SQL BATCH</B>
</P>
<p>
<table cellpadding=5 width="95%"><tr><td>	
<pre>
USE PUBS
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE
BEGIN TRAN
SELECT * FROM authors
WHERE au_lname = 'Ringer'
EXEC sp_lock @@spid
COMMIT TRAN
</pre>
</td></tr></table>
</P>

<p>
<B>OUTPUT OF <I>sp_lock</I></B>
</P>
<p>
<table cellpadding=5 width="95%"><tr><td>	
<pre>
spid   dbid   ObjId       IndId  Type Resource         Mode     Status 
------ ------ ----------- ------ ---- ---------------- -------- ------
11     5      117575457   2      PAG  1:123            IS       GRANT
11     5      117575457   1      PAG  1:96             IS       GRANT
11     5      0           0      DB                    S        GRANT
11     5      117575457   2      KEY  (d5f329a7dcdc)   IS-S     GRANT
11     5      117575457   2      KEY  (4c62318cf11f)   IS-S     GRANT
11     5      117575457   1      KEY  (3dc1b1ecb5be)   IS-S     GRANT
11     5      117575457   1      KEY  (37fdb5efbcbe)   IS-S     GRANT
11     5      117575457   2      KEY  (d5968ed3b619)   IS-S     GRANT
11     5      117575457   0      TAB                   IS       GRANT
</pre>
</td></tr></table>
</P>

<p>
The locks held with the Serializable isolation level are almost identical 
to those held with the Repeatable Read isolation level. The main difference is in 
the mode of the lock. The two-part mode IS-S indicates a key range lock in 
addition to the lock on the key itself. The first part (IS) is the lock on the range 
of keys between (and including) the key holding the lock and the previous key 
in the index. The key range locks prevent other transactions from inserting 
new rows into the table that meet the condition of this query; that is, no new 
rows with a last name of <I>Ringer </I>can be inserted. There are three key locks in 
the nonclustered index on <I>au_lname</I> 
(<I>IndId</I> = 2) because three different ranges 
need to be locked. SQL Server must lock the range from the key preceding the 
first <I>Ringer </I>in the table up to the first 
<I>Ringer</I>, it must lock the range between the two instances of 
<I>Ringer</I>, and it must lock the range from the second 
<I>Ringer </I>to the next key in the index. (So actually nothing between 
<I>Ringer </I>and the previous key, 
<I>Panteley</I>, and nothing between <I>Ringer 
</I>and the next key, <I>Smith</I>, could be inserted into the table. For example, we could not insert an author with the 
last name <I>Pattin </I>or <I>Singh</I>.)
</P>

<A NAME="517"><H3>Example 4: Update Operations</H3></A>


<p>
<B>SQL BATCH</B>
</P>
<p>
<table cellpadding=5 width="95%"><tr><td>	
<pre>
USE PUBS
SET TRANSACTION ISOLATION LEVEL READ COMMITTED
BEGIN TRAN
UPDATE authors
SET contract = 0
WHERE au_lname = 'Ringer'
EXEC sp_lock @@spid
COMMIT TRAN
</pre>
</td></tr></table>
</P>

<p>
<B>OUTPUT OF <I>sp_lock</I></B></P>
<p>
<table cellpadding=5 width="95%"><tr><td>	
<pre>
spid   dbid   ObjId       IndId  Type Resource         Mode     Status 
------ ------ ----------- ------ ---- ---------------- -------- ------
11     5      117575457   1      PAG  1:96             IX       GRANT
11     5      0           0      DB                    S        GRANT
11     5      117575457   1      KEY  (3dc1b1ecb5be)   X        GRANT
11     5      117575457   1      KEY  (37fdb5efbcbe)   X        GRANT
11     5      117575457   0      TAB                   IX       GRANT
</pre>
</td></tr></table>
</P>


<p>
The two rows in the leaf level of the clustered index are locked with X 
locks. The page and the table are then locked with IX locks. We discussed earlier 
that SQL Server actually acquires update locks while it looks for the rows to 
update. However, these are escalated to X locks when the actual update is done, and 
by the time the <I>sp_lock</I> procedure is run, the update locks are gone. Unless 
you actually force update locks with a query hint, you might never see them in 
the output of <I>sp_lock</I>.
</P>

<A NAME="518"><H3>Example 5: Creating a Table</H3></A>


<p>
<B>SQL BATCH</B></P>
<p>
<table cellpadding=5 width="95%"><tr><td>	
<pre>
USE PUBS
SET TRANSACTION ISOLATION LEVEL READ COMMITTED
BEGIN TRAN
SELECT * 
INTO newTitles
FROM titles
WHERE price &lt; 5
EXEC sp_lock @@spid
COMMIT TRAN
</pre>
</td></tr></table>
</P>


<p>
<B>OUTPUT OF <I>sp_lock</I></B></P>
<p>
<table cellpadding=5 width="95%"><tr><td>	
<pre>
spid   dbid   ObjId       IndId  Type Resource         Mode     Status 
------ ------ ----------- ------ ---- ---------------- -------- ------
7      5      0           0      DB   [BULK-OP-LOG]    S        GRANT
7      5      0           0      DB                    S        GRANT
7      5      0           0      DB   [BULK-OP-DB]     S        GRANT
7      5      1           0      TAB                   IX       GRANT
7      5      3           0      TAB                   IX       GRANT
7      5      2           0      TAB                   IX       GRANT
7      5      0           0      PAG  1:199            X        GRANT
7      5      0           0      PAG  1:198            X        GRANT
7      5      0           0      PAG  1:197            X        GRANT
7      5      0           0      PAG  1:196            X        GRANT
7      5      0           0      PAG  1:195            X        GRANT
7      5      0           0      PAG  1:194            X        GRANT
7      5      0           0      PAG  1:193            X        GRANT
7      5      0           0      EXT  1:192            X        GRANT
7      5      0           0      PAG  1:166            X        GRANT
7      5      0           0      PAG  1:165            X        GRANT
7      5      3           2      KEY  (0693cc100b75)   X        GRANT
7      5      3           2      KEY  (3790f0cf7f55)   X        GRANT
7      5      2           1      KEY  (0257f4438466)   X        GRANT
7      5      3           2      KEY  (242ad7320fa2)   X        GRANT
7      5      3           2      KEY  (e794778e397a)   X        GRANT
7      5      1061578820  0      TAB                   Sch-M    GRANT
7      5      1           2      KEY  (269dc7159f33)   X        GRANT
7      5      3           1      KEY  (024e7788d08c)   X        GRANT
7      5      3           1      KEY  (02567f88d08c)   X        GRANT
(etc.)
</pre>
</td></tr></table>
</P>


<p>
Very few of these locks are actually acquired on elements of the new 
table. In the <I>ObjId</I> column, notice that most of the objects have an ID of less 
than 100, which means that they are system tables. As the new 
<I>newTitles</I> table is built, SQL Server acquires locks on 
<I>sysobjects</I> and <I>syscolumns</I> to record 
information about this new table. Also notice the schema modification (Sch-M) lock on 
the new table as well as extent (EXT) locks. While the table is built, the 
extents are not marked as belonging to the table; you can see that the 
<I>ObjId </I>is 0. In the output above, the extent ID is shown as 1:192. This means that page 
192 in file 1 is the first page of the extent. You can also see that the 
subsequent seven pages (193_199) in this extent are all exclusively locked while the 
table is being created.
</P>

<A NAME="519"><H3>Example 6: Row Locks</H3></A>


<p>
<B>SQL BATCH</B></P>
<p>
<table cellpadding=5 width="95%"><tr><td>	
<pre>
USE PUBS
SET TRANSACTION ISOLATION LEVEL READ COMMITTED
BEGIN TRAN
UPDATE newTitles
SET price = 3.99
WHERE type = 'business'
EXEC sp_lock @@spid
ROLLBACK TRAN
</pre>
</td></tr></table>
</P>

<p>
<B>OUTPUT OF <I>sp_lock</I></B>
<p>
<table cellpadding=5 width="95%"><tr><td>	
<pre>
spid   dbid   ObjId       IndId  Type Resource         Mode     Status 
------ ------ ----------- ------ ---- ---------------- -------- ------
13     1      0           0      DB                    S        GRANT
13     2      0           0      DB                    S        GRANT
13     5      0           0      DB                    S        GRANT
13     5      1077578877  0      RID  1:184:0          X        GRANT
13     5      1077578877  0      PAG  1:184            IX       GRANT
13     5      1077578877  0      TAB                   IX       GRANT
13     1      117575457   0      TAB                   IS       GRANT
</pre>
</td></tr></table>
</P>
</P>

<p>
There are no indexes on the <I>newTitles</I> table, so the lock on the actual 
row meeting our criterion is an exclusive (X) lock on the row (RID). As 
expected, IX locks are taken on the page and the table.
</P>

</BODY>
</HTML>



