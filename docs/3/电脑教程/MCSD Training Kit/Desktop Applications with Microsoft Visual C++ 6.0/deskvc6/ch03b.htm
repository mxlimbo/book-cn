<HTML>
<HEAD>
<TITLE>Lesson 1: Overview of MFC</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch03a.htm", "ch03c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="97"><H1>Lesson 1: Overview of MFC</H1></A>

<p>The MFC Library is a collection of C++ classes and global functions designed for the
rapid development of Microsoft Windows&#8211;based applications. MFC
offers many advantages to C++ developers at all levels, from beginners to
seasoned professionals. It simplifies Windows programming, shortens development time,
and makes code more portable without reducing programming freedom and flexibility. MFC
provides easy access to hard-to-program technologies like ActiveX and Internet
programming. MFC makes it easy to program user interface features such as property
sheets, print preview, shortcut menus, and customizable floating toolbars complete with
ToolTips.</p>

<p>In this lesson, you will learn how the MFC Library is organized, and how it is
designed to encapsulate the Microsoft Win32 API&#8212;the low-level application that
programmers interface to the Windows operating system services. You will also learn
about some of the more important platform issues that need to be considered when using
the MFC Library.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>


<ul>
<p><li> Describe the general structure of the MFC Library and how it relates to the Win32
API.</li></p>

<p><li> Describe some of the issues that should be considered when developing for the
different Win32 Platforms: Microsoft Windows NT, Microsoft Windows 95, and Microsoft
Windows 98.</li></p>

<p><li> Describe the general categories of the MFC classes and their hierarchical
organization.</li></p>

<p><li> Describe when to use an MFC extension DLL.</li></p>
</ul>


<b>Estimated lesson time: 40 minutes</b>
</blockquote></div>
</p>


<A NAME="98"><H2>MFC and the Win32 API</H2></A>

<p>The term <i>Win32</i> is used to describe an Application Programming Interface (API)
that is common to all of the Microsoft 32-bit Windows platforms. These platforms
currently include Windows 95, Windows 98, Windows NT, and Microsoft Windows CE. (Note:
This book will not cover information specific to Windows CE.) The Win32 API is a set of
functions, structures, messages, macros, and interfaces that provides a consistent
interface to enable you to develop applications for any of the Win32 platforms. Table
3.1 lists some of the services provided by the Win32 API.</p>

<p><b>Table 3.1</b> <i>Win32 API Services</i></p>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th>Win32 API service</th>
<th>Description</th>
</tr>
<tr>
<td valign="top">Window Management</td>
<td valign="top">Provides the means to create and manage a user
 interface.</td>
</tr>
<tr>
<td valign="top">Window Controls</td>
<td valign="top">Provides a set of common user interface controls.
 Using the common controls helps keep an application's
 user interface consistent with that of the shell and other
 applications. It also saves a significant amount of
 development time.</td>
</tr>
<tr>
<td valign="top">Shell Features</td>
<td valign="top">Provides access to system objects and resources such as
 files, storage devices, printers, and network resources.</td>
</tr>
<tr>
<td valign="top">Graphics Device Interface</td>
<td valign="top">Provides functions and related structures used to
 generate graphical output for displays, printers, and
 other graphical devices.</td>
</tr>
<tr>
<td valign="top">System Services</td>
<td valign="top">Provides access to the resources of the computer via
 features of the underlying operating system.</td>
</tr>
</table>
</p>

<p>Because the Win32 API is distributed as a set of C functions, users of Visual C++
can simply include the appropriate header files and then call the Win32 API functions
from their code. Before MFC was available, Windows applications were developed using
only the Win32 API&#8212;a time-consuming process. Experienced Win32 programmers would
invariably reuse code and develop libraries to speed up the development of basic,
often-repeated Windows programming tasks. MFC is a formalization of this process that
makes this reusable code available to all C++ developers.</p>

<p>MFC was developed to simplify and speed up the development of Windows applications
by providing a set of C++ classes that encapsulate key features of the Win32 API. As a
C++ programmer, you will be familiar with the way in which
a good class design can be used to encapsulate complex features of a software
object behind a clear and concise interface.</p>

<p>For example, the Win32 concept of a window is encapsulated by the MFC class <b>
CWnd</b>. That is, a C++ class called <b>CWnd</b> encapsulates the HWND handle (HWND is
a Win32-defined data type that represents a Win32 window). Encapsulation means that the
<b>CWnd</b> class contains a member variable of type HWND, and the class's member
functions encapsulate calls to Win32 functions that take an HWND as a parameter. An
example of this is the Win32 function:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>BOOL ShowWindow(HWND hWnd, int nCmdShow);</pre>
</td></tr>
</table>
</p>

<p>that is encapsulated by the MFC function:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>BOOL CWnd::ShowWindow(int nCmdShow);</pre>
</td></tr>
</table>
</p>

<p>MFC class member functions typically have the same name as the Win32 function they
encapsulate.</p>

<p>MFC hides some lower-level aspects of Windows programming through encapsulation,
although low-level access is always available if needed. Encapsulation also helps to
protect against the possibility that pointer values such as window handles or file
handles might become corrupted, or that operations might be performed on an invalid
pointer.</p>

<A NAME="99"><H3>When to Use MFC and When to Use the Win32 API</H3></A>

<p>You should use the MFC Library whenever you need to develop anything but the
simplest of applications. The advantages of the simplified development model and the
benefits of reusing MFC code far outweigh any gains in speed and size made by choosing
not to link the MFC Library to your application. Applications that have a command-line
user interface, or no user interface, might be as easy to implement as non-MFC
applications. Even for these applications you might find MFC helpful because of the
application support it provides through utility classes like its string classes and
generic collection classes.</p>

<p>MFC encapsulates most, but not all, of theWin32 API. Although you can perform most
of the common Windows programming tasks through the use of the MFC classes, you will
sometimes need to make direct calls to the Win32 API functions. This usually becomes
necessary when you need to access system functionality at a fairly low level. For
example, if you were developing a utility to modify user accounts on a network, you
would be required to use the Win32 networking functions because there are no MFC
classes that provide access to Windows NT network management functions.</p>

<A NAME="100"><H2>Win32 Platform Considerations</H2></A>

<p>As mentioned earlier, Windows 95, Windows 98, and Windows NT are all 32-bit
operating systems that use the same Win32 API. Each operating system is intended to
serve a different purpose and therefore has unique characteristics in addition to the
common features shared with the other Win32 operating systems. These differences necessitate functions in the Win32 API that are operating
system-specific.</p>

<p>To learn more about which functions are specific to which operating systems, search
in the Visual C++ Help file for &quot;Differences in Win32 API Implementations.&quot;
This search will result in a useful article that details the differences to be
considered when using the Win32 API for the Windows NT, Windows 95, and
Windows 98 platforms.</p>

<p>If you need to find out which operating system is currently running your
application, perhaps to conditionally branch out part of your code that is specific to
one platform, you can use the API function <b>GetVersionEx()</b>, as illustrated by the
code sample that follows.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>OSVERSIONINFO vinfo;
vinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

::GetVersionEx(&amp;vinfo);

switch(vinfo.dwPlatformId)
{
case VER_PLATFORM_WIN32_WINDOWS :
     // Windows 95 / 98 specific code

case VER_PLATFORM_WIN32_NT :
     // Windows NT specific code
}</pre>
</td></tr>
</table>
</p>

<p>The higher level of abstraction that MFC provides removes you from many
platform-specific considerations. Most of the MFC code you write will run across the
Windows 32-bit platforms without difficulty, but to ensure that your applications will
run without problems, you should be aware of a few platform-specific issues.</p>

<A NAME="101"><H3>Unicode Issues</H3></A>

<p>The ANSI character set used on 16-bit platforms such as MS-DOS and Microsoft Windows
3.1 uses a single byte to represent a character. Since one byte can represent only 256
unique characters, the ANSI character set is insufficient to represent a language with
a large number of characters, such as Chinese. Unicode addresses this problem by using
two bytes to represent each character. The 16-bit Unicode character set has the
capacity to encode 65,536 characters, and so has become a worldwide character-encoding
standard.</p>

<p>Windows NT supports both Unicode and ANSI strings. All Windows NT
internal character strings, including Windows NTFS File System (NTFS) names, are
Unicode strings. The Win32 API provides conditionally defined data types and generic
versions of functions that are implemented differently according to whether the
_UNICODE symbol is defined for a build of your program. For example, when the _UNICODE
symbol is defined, the TCHAR data type is defined as <i>wchar_t</i>, a 16-bit character
encoding type; otherwise, it is defined as <i>char</i>, the normal 8-bit character
encoding type.</p>

<p>Windows 95 and Windows 98 support only ANSI strings&#8212;not Unicode strings. To
ensure that your application string data is portable across all Win32 platforms, you
should always use the generic data types and functions.</p>

<p>The MFC string class <b>CString</b> is based on the TCHAR data type. Its
constructors, assignment operators, and comparison operators are all Unicode-aware.
This means that you can use the <b>CString</b> class transparently, safe in the
knowledge that it will implement Unicode or ANSI strings as appropriate to the build
environment. However, you must be careful to extend the platform independence embodied
in the <b>CString</b> class into your own code. To make your application more
Unicode-aware, you must also consider the following:</p>

<ul>
<p><li> Use the <i>_T</i> macro to conditionally code literal strings to be portable to
Unicode. For example, use <i>_T(&quot;MyString&quot;)</i> where you might otherwise use
<i>&quot;MyString.&quot;</i></li></p>

<p><li> When you pass strings to functions, pay attention to whether function arguments
require a length in characters or a length in bytes. The difference is important if
you're using Unicode strings.</li></p>

<p><li> Use portable versions of the C run-time string-handling functions. For example,
use &quot;_<i>tcslen&quot;</i> rather than &quot;<i>strlen&quot;</i> and <i>
_&quot;tcscat&quot;</i> rather than &quot;<i>strcat</i>.&quot;</li></p>

<p><li> Use the following data types for characters and character pointers:</li></p>
	<ul>
	<p><li> <i>TCHAR</i> where you would use <i>char</i>.</li></p>
	
	<p><li> <i>LPTSTR</i> where you would use <i>char*</i>.</li></p>
	
	<p><li> <i>LPCTSTR</i> where you would use <i>const char*</i>. <b>CString</b> provides
	the operator LPCTSTR to convert between <b>CString</b> and LPCTSTR.</li></p>
	</ul>
</ul>

<A NAME="102"><H3>File System Considerations</H3></A>

<p>NTFS is a high-performance file system that can be installed on Windows NT systems
as an alternative to the older File Allocation Table (FAT) file system used by Windows
95 and Windows 98. In addition to providing Unicode support, NTFS is more robust than
FAT and provides direct support for file- and folder-level security.</p>

<p>When programming with MFC, you have fewer worries about the underlying file system.
If you use the MFC class <b>CFile</b> to handle access to disk files, filenames will be
converted to the correct TCHAR data type. <b>CFile</b> also provides error handling for
&quot;access denied&quot; situations. It is important to be aware that file security on
a corporate network will be more rigorously enforced than the test directories on your
development computer, so your applications should never assume that a file will be
accessible. Where you can, use system environment variables in pathnames
(<i>SystemRoot</i>, for example, which points to the directory in which the operating
system is installed) to avoid dependency on hard-coded paths. System environment
variables can be retrieved by the <b>_tgetenv()</b> API function.</p>

<A NAME="103"><H3>Screen Coordinates</H3></A>

<p>Under Windows 95 and Windows 98, all screen coordinates are limited to 16 bits. If
you develop on a Windows NT computer, be aware that routines that draw to the screen
using coordinate values that lie outside the range -32768 to 32767 will not work
properly on Windows 95 and Windows 98 platforms.</p>

<A NAME="104"><H2>MFC Class Hierarchy</H2></A>

<p>The MFC Library is implemented as a set of C++ classes. One of the main methods of
code reuse in C++ is the <i>inheritance</i> mechanism. A C++ class can be derived from,
and inherit the characteristics of, a parent class. The MFC Library, 
in common with many other C++ class libraries, organizes its contents into an
inheritance hierarchy. This hierarchy contains a large number of classes of specific
functions that are derived from a small number of base classes that implement the
general functionality common to all their descendants.</p>

<p>As an example, Figure 3.1 shows the inheritance structure of the <b>CDialog</b>
class. This MFC class represents a Windows dialog box.</p>

<p>
<img src="images/F03DA01.JPG" width=233 height=203>
</p><p>
<!-- caption --><b>Figure 3.1</b> <i>Inheritance structure of the <b>CDialog</b> class</i><!-- /caption -->
</p>

<p>At the top of the hierarchy is the <b>CObject</b> class. <b>CObject</b> is the base
class for a large number of the MFC classes. <b>CObject</b> provides basic services,
including serialization (loading and saving data objects to a file); run-time class
information; diagnostic and debugging support (validations and dumps); and
compatibility with collection classes.</p>

<p>The <b>CCmdTarget</b> class is the base class for all objects that are capable of
handling Windows messages. You will learn more about this in <a href="ch03d.htm#119">Lesson 3</a>, <i>MFC Application
Framework</i>, later in this chapter.</p>

<p>The <b>CWnd</b> class mentioned at the beginning of this chapter represents a
window. The fact that the <b>CDialog</b> class is derived from the <b>CWnd</b> class
illustrates the idea that a dialog box is a specialized type of window.</p>

<A NAME="105"><H2>Viewing the MFC Object Hierarchy</H2></A>

<p>In this practice exercise, you will learn how to use the Visual C++ Help system to
view the MFC Hierarchy Chart, which displays the entire set of MFC classes and their
inheritance relationships.</p>

<p><li> <b>To view the MFC Hierarchy Chart</b></li></p>

<ol>
<p><li> Start Visual C++. On the <b>Help</b> menu, click <b>Index</b>. The Visual Studio
version of the MSDN Library will open, with the insertion point positioned in the <b>
Type in the keyword to find</b> text box.</li></p>

<p><li> In the <b>Type in the keyword to find</b> text box, type <b>hierarchy
chart</b>.</li></p>

<p><li> In the <b>keyword</b> list, double-click <b>hierarchy chart</b>. The MFC
Hierarchy Chart will appear in the right pane. Resize this pane so that you can see as
much of the chart as possible.</li></p>

<p><li> Explore the Hierarchy Chart. Note how the classes are organized into groups
denoted by bold labels. Note which classes are derived from <b>CObject</b>, which are
derived from <b>CCmdTarget</b>, and which are derived from <b>CWnd</b>. You might want
to keep this chart open for reference while you proceed with this lesson.</li></p>
</ol>

<A NAME="106"><H2>MFC Class Categories</H2></A>

<p>When learning about the MFC classes, you might find it helpful to organize them into
categories, as described in Table 3.2.</p>

<p><b>Table 3.2</b> <i>MFC Class Categories</i></p>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th>MFC class category</th>
<th>Description</th>
</tr>
<tr>
<td valign="top">Application architecture</td>
<td valign="top">The application architecture classes represent the basic
architectural elements of an application and include <b>CWinApp</b>, which represents the application itself.</td>
</tr>
<tr>
<td valign="top">User interface</td>
<td valign="top">The user interface classes typically encompass the elements of a
Windows-based application that are visible to the user. These include windows, dialog boxes,
 menus, and controls. The user interface classes also encapsulate the Windows
device context and graphics device interface (GDI) drawing objects.</td>
</tr>
<tr>
<td valign="top">Collections</td>
<td valign="top">MFC provides a number of easy-to-use collection classes including 
<b>Arrays</b>, <b>Lists</b>, and <b>Maps</b>. These come in both template and non-template versions.</td>
</tr>
<tr>
<td valign="top">General purpose</td>
<td valign="top">MFC includes a number of general-purpose classes that do not
encapsulate functions in the Win32 API. These classes represent simple data types such as points
and rectangles, and more complex data types such as strings.</td>
</tr>
<tr>
<td valign="top">ActiveX</td>
<td valign="top">MFC provides classes that simplify the process of adding ActiveX
capabilities to your applications and significantly reduce development time. The ActiveX classes work
 with the other application framework classes to provide easy access to the ActiveX API.</td>
</tr>
<tr>
<td valign="top">Database</td>
<td valign="top">Accessing data by connecting to databases is one of the most common Windows
environment programming tasks. MFC provides classes that enable operations on databases through Open Database Connectivity (ODBC) and the Data Access Object (DAO).</td>
</tr>
<tr>
<td valign="top">Internet</td>
<td valign="top">Creating applications that interact with the Internet, across intranets, or
both, is becoming a major focus of developers. MFC includes the WinInet APIs and the
 Internet Server API (ISAPI), which provide classes for client-side and server-side
 applications, respectively.</td>
</tr>
<tr>
<td valign="top">Global functions</td>
<td valign="top">MFC provides some functions that are not members of classes. These
global functions generally have the prefix Afx and provide the programmer with
general-purpose utilities. A commonly used example is <b>AfxMessageBox()</b>.</td>
</tr>
</table>
</p>

<A NAME="107"><H2>MFC DLLs</H2></A>

<p>The AppWizard gives you the choice to use the MFC Library either as a shared DLL or
as a static library linked to your application's executable file. If you choose the
shared DLL option, you have to be sure that the MFC Library MFC<i>xx</i>.DLL (<i>xx</i>
stands for the version number you are using), and the Visual C++ standard library
MSVCRT.DLL are both available on the user's computer. To ensure that this is the
case, the DLLs are usually packaged and shipped with the application.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Unicode applications must link to the MFC<i>xx</i>U.DLL version
of the library.</blockquote></div>
</p>

<p>By choosing to link to a shared DLL, you can greatly reduce the size of your
executable program. It makes sense to adopt this strategy if you are going to install a
large number of MFC-based applications on one computer. This way, all the applications
can share one set of DLLs rather than unnecessarily consuming disk space with multiple
copies of the same DLLs.</p>

<A NAME="108"><H3>MFC Extension DLLs</H3></A>

<p>In the course of C++ software development, you will frequently develop custom
classes that you later reuse in other applications. Like the MFC Library, these custom
classes are often packaged as DLLs. Classes that are made available to other
applications via a DLL are said to be <i>exported</i>&#8212;that is, their public member
functions and data members are made visible to the client applications. For example,
the MFC DLLs export the <b>CString</b> class. This means that applications that link to
the MFC DLLs can create and use <b>CString</b> objects in their code.</p>

<p>You can click <b>MFC AppWizard (dll)</b> in the <b>New Projects</b> dialog box to
create DLLs to export your own classes. The AppWizard refers to DLLs of this type as
<i>regular DLLs</i>.</p>

<p>Regular DLLs can use MFC classes in their implementation. However, consider what
happens if you want to export a class that is <i>derived</i> from an MFC class. Suppose
you implement a class for a custom dialog box <b>CMyDialog</b> that derives its
functionality from the MFC <b>CDialog</b> class and provides a set of public member
functions that a client application can call to set and retrieve values from the
controls. How do you ensure that the base class (<b>CDialog</b>) is properly exported
and that its public member functions and data members are available to client
applications?</p>

<p>To enable MFC applications to use <b>CMyDialog</b> as an MFC class, to call
the <b>CDialog</b> base class member functions, and to reference <b>CMyDialog</b>
with <b>CDialog</b> pointers, you need to package the class in a special type of DLL
known as an <i>MFC extension DLL</i>. An MFC extension DLL implements reusable classes
derived from existing MFC classes. MFC extension DLLs allow you to provide an
&quot;extended&quot; version of MFC.</p>

<p>Extension DLLs are built using the shared DLL version of MFC. Only MFC executables
(or DLLs) that are built with the shared version of MFC can use an extension DLL. Both
the client application and the extension DLL must use the same version of the MFC
DLLs.</p>

<p>To build an MFC extension DLL, click <b>MFC AppWizard (dll)</b> in the <b>New
Projects</b> dialog box, and select <b>MFC</b> <b>Extension DLL</b> on the first page
of the MFC DLL AppWizard (shown in Figure 3.2).</p>

<p>
<A HREF="javascript:fullSize('F03DA02x.htm')"> <img src="images/F03DA02.JPG" width=404 height=325 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 3.2</b> <i>Creating an MFC extension DLL</i><!-- /caption -->
</p>

<A NAME="109"><H2>Lesson Summary</H2></A>

<p>The Microsoft Foundation Class Library is implemented as a collection of C++ classes
designed primarily for creating Microsoft Windows&#8211;based applications.</p>

<p>MFC is designed to encapsulate the most commonly used functions of the Win32 API.
The Win32 API is a set of functions, structures, messages, macros, and interfaces
exposed by the operating system, which you can use to develop applications on any of
Microsoft's 32-bit platforms. MFC simplifies Windows development by hiding some of
the more complex features of the Win32 API. MFC should be used wherever possible to
save development time and effort. Even though you use MFC, you can still use the Win32
API when you need to perform certain low-level tasks not supported by MFC.</p>

<p>Although the Win32 API is designed as an interface to all Windows 32-bit operating
systems, there are a few differences among the platforms. For example,
Windows NT uses Unicode strings internally and supports NTFS but Windows 95 and
Windows 98 do not. Although the use of MFC insulates developers from most of the
platform differences, you must still be aware of platform issues.</p>

<p>MFC is implemented as a hierarchical set of C++ classes that use the C++
in-heritance mechanism to provide a reusable and extensible code base for Win32
developers. MFC class categories include:</p>

<ul>
<p><li> Application architecture classes.</li></p>

<p><li> User interface classes.</li></p>

<p><li> Collection classes.</li></p>

<p><li> General purpose classes.</li></p>

<p><li> ActiveX classes.</li></p>

<p><li> Database classes.</li></p>

<p><li> Internet classes.</li></p>

<p><li> Global functions.</li></p>
</ul>


<p>An application that uses the MFC classes in its implementation can either statically
link the MFC Library to the application's executable file or share the MFC DLLs
with other MFC applications. Using the shared DLLs saves disk space on the user's
computer, but you must make sure that the appropriate MFC DLL and MSVCRT.DLL are both
available to the installed version of the application.</p>

<p>You can create your own regular DLLs or MFC extension DLLs. An MFC extension DLL
implements reusable classes derived from existing MFC classes. Extension DLLs are built
using the shared DLL version of MFC.</p>

</BODY>
</HTML>







