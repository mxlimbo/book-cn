<HTML>
<HEAD>
<TITLE>Lesson 1: File I/O</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06a.htm", "ch06c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="237"><H1>Lesson 1: File I/O</H1></A>

<p>In this lesson, you will learn about the file I/O classes provided by MFC. You will
also learn about the basic file services offered by the <b>CFile</b> class and how to
use its derived class <b>CStdioFile</b>, which provides buffered stream file
access.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>


<ul>
<p><li> Create new files and open existing files using member functions of the <b>
CFile</b> class.</li></p>

<p><li> Read and write binary files and text files using the <b>CStdioFile</b>
class.</li></p>

<p><li> Handle errors that might occur while attempting file I/O.</li></p>
</ul>


<b>Estimated lesson time: 25 minutes</b>
</blockquote></div>
</p>


<A NAME="238"><H2>CFile Class</H2></A>

<p>The MFC <b>CFile</b> class provides access to binary disk files by encapsulating an
op-erating system file handle and providing member functions for opening, reading from,
writing to, and closing a file. The <b>CFile</b> class provides direct, unbuffered
access to files. Derived from <b>CFile</b>, the <b>CStdioFile</b> class implements
buffered stream files in MFC.</p>

<p><b>CFile</b> is the base class for the <b>CMemFile</b> and the <b>CSharedFile</b>
classes. <b>CMemFile</b> provides support for <i>in-memory files</i>, which are stored
in RAM rather than on a disk for increased performance. <b>CSharedFile</b> provides
support for shared in-memory files.</p>

<A NAME="239"><H2>Opening and Closing Files</H2></A>

<p>There is more than one way to open a file using the <b>CFile</b> class. The class
provides a constructor that allows you to specify the file to open. This constructor
lets you declare a <b>CFile</b> object and associate that object with a disk file in a
single statement. Specifying the file in the constructor is risky. If the file
doesn't exist, errors will result.</p>

<p>It is generally better to use a two-stage approach. First, create a <b>CFile</b>
object; second, associate this object with a disk file. This approach gives you more
flexibility in handling errors, and also helps clarify the logical distinction between
the file object in your code and the physical disk file.</p>

<p>To open a disk file using the two-stage approach, first declare a <b>CFile</b>
object without any parameters. Next, call the <b>CFile::Open()</b> function for the
object, specify the path to the disk file, and provide flags that specify the access and
sharing modes. For example, note the following code, which uses the two-stage
approach:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CString strPath = &quot;MyFile.bin&quot;;
CFile MyFile;
BOOL bResult = MyFile.Open(strPath, CFile::modeRead);
if(!bResult)
     AfxMessageBox(strPath + &quot; could not be opened&quot;);</pre>
</td></tr>
</table>
</p>

<p>Specifying a file name without any path information will result in the <b>Open</b>
command searching for the file in the current folder first, and in the folders within
the system path next. You can also specify paths relative to the current folder and
paths using a Universal Naming Convention (UNC) name. A UNC name provides a
computer-independent means of locating the file, and has the format <i>\\Server
Name\Network Share\File Path</i>.</p>

<p>When specifying a path name for the file to be opened, don't make any
assumptions about the file's location. For example, specifying the path name as
follows assumes that the MyFile.bin file will be found in the C:\\Program Files\\MyApp
folder:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CString strPath = C:\\Program Files\\MyApp\\MyFile.bin;</pre>
</td></tr>
</table>
</p>

<p>This assumption might not be valid if your application has been installed on a drive
other than drive C. Your application or setup program can create environment variables
or registry entries (see <a href="ch06d.htm#252">Lesson 3</a> of this chapter) to record the location of the files
that it uses.</p>

<p>The second parameter to the <b>Open()</b> function allows you to specify a bitmask
that defines the file's access and sharing modes. The bitmask values are declared
as enumerated constants within the scope of the <b>CFile</b> class, which means that
the flags must be qualified with the class scope. The access mode determines whether
the file will be open for reading only, writing only, or both reading and writing. The
sharing mode determines the access to this file granted to other processes while you
have the file open. You can create a new file by specifying the <b>
CFile::modeCreate</b> value.</p>

<p>The bitmask values passed to the <b>Open()</b> function can be combined by using the
bitwise <b>OR</b> operator (<b>|</b>). Generally, you should specify an access mode as
well as a sharing mode. For example, the following code will open the MyFile.bin file
for reading and writing:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>MyFile.Open(&quot;MyFile.bin&quot;, CFile::modeReadWrite|CFile::shareDenyWrite);</pre>
</td></tr>
</table>
</p>

<p>If the file MyFile.bin is successfully opened by this function call, all other
processes will be denied write permissions to the file. If MyFile.bin cannot be found,
it will not be created.</p>

<p>Table 6.1 summarizes the access and sharing modes defined by the <b>CFile</b>
class.</p>

<p><b>Table 6.1</b> <i>Access and Sharing Modes</i></p>

<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th>Flag Value</th><th>Action</th>
</tr>

<tr>
<td valign="top">CFile::modeCreate </td><td valign="top">Creates a new file. If the specified file already exists, it
is truncated to zero length.</td>
</tr>

<tr>
<td valign="top">CFile::modeNoTruncate</td> <td valign="top">Can be combined with <b>CFile::modeCreate</b> to ensure
 that, if the specified file already exists, it is opened without being truncated to zero length. Thus, the file is guaranteed to open, either as an existing file or as a newly
 created file. This value might be useful when opening a
 settings file that might or might not already exist.</td>
</tr>

<tr>
<td valign="top">CFile::modeRead</td><td valign="top"> Opens the file as read-only.</td>
</tr>

<tr>
<td valign="top">CFile::modeReadWrite</td><td valign="top"> Opens the file as read/write.</td>
</tr>

<tr>
<td valign="top">CFile::modeWrite</td><td valign="top"> Opens the file as write-only.</td>
</tr>

<tr>
<td valign="top">CFile::shareDenyNone</td><td valign="top"> Does not deny other processes read or write permissions to the file.</td>
</tr>

<tr>
<td valign="top">CFile::shareDenyRead</td><td valign="top"> Denies other processes read permissions to the file.</td>
</tr>

<tr>
<td valign="top">CFile::shareDenyWrite</td><td valign="top"> Denies other processes write permissions to the file.</td>
</tr>

<tr>
<td valign="top">CFile::shareExclusive</td> <td valign="top">Denies other processes both read and write permissions to the file.</td>
</tr>
</table>
</p>

<A NAME="240"><H3>File Errors</H3></A>

<p>It is not difficult to see that a number of factors might cause the <b>
CFile::Open()</b> function to fail. Attempting to open a file that does not exist (without specifying the
<b>CFile::modeCreate</b> flag) will cause the <b>Open()</b> function to fail.
Attempting to open a file already opened exclusively by another process will also
result in failure. Numerous environmental factors can cause errors when working with
files.</p>

<p>In the example code showing how to use <b>CFile::Open()</b>, the function returned a
Boolean value indicating success or failure. If there was a failure, you will usually
want to retrieve information about <i>why</i> the operation failed. You can then relay
such information to the user, and suggest steps they can take to remedy the
problem.</p>

<p>MFC provides the <b>CFileException</b> class (derived from the <b>CException</b>
base class) to represent a file error condition. The MFC exception classes contain
member data and functions that allow you to retrieve information about the
error that generated the exception.</p>

<p>The version of the <b>CFile</b> constructor that attempts to open a file will throw
the exception <b>CFileException</b> upon failure. If you use this constructor, you
should enclose it in a <i>try/catch</i> exception handling block, as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>try
{
     CFile MyFile(&quot;MyFile.old&quot;, CFile::modeRead);
}
catch(CFileException * fx)
{
     TCHAR buf[255];
     fx-&gt;GetErrorMessage(buf, 255);
     CString strPrompt(buf);
     AfxMessageBox(strPrompt);
}</pre>
</td></tr>
</table>
</p>

<p>To learn more about exception handling and MFC exceptions, refer to <a href="ch13b.htm#471">Lesson 1</a> of
Chapter 13.</p>

<p>The <b>CFile::Open()</b> function does not throw an exception. Instead, it takes an
optional third parameter that is a pointer to a <b>CFileException</b> object. If the
file open operation fails, the <b>CFileException</b> object is filled with information
about the error's nature. This information can be used by subsequent code to
provide information to the user, as shown in the following code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CFile MyFile;
CFileException fx;

if(!MyFile.Open(&quot;MyFile.old&quot;, CFile::modeRead, &amp;fx))
{
     TCHAR buf[255];
     fx.GetErrorMessage(buf, 255);
     CString strPrompt(buf);
     AfxMessageBox(strPrompt);
}</pre>
</td></tr>
</table>
</p>

<A NAME="241"><H3>Closing Files</H3></A>

<p><b>CFile</b> provides the <b>Close()</b> member function to close an open disk file.
The following code provides an example of how to use the <b>Close()</b> function:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>BOOL MyFileFunction()
{
     CFile MyFile;
     if(!MyFile.Open(&quot;MyFile.old&quot;, CFile::modeRead))
     {
          AfxMessageBox(&quot;Cannot open MyFile.old&quot;);
          return FALSE;
     }
     // Do something with the file . . .
     MyFile.Close();
     return TRUE;
}</pre>
</td></tr>
</table>
</p>

<p>In this example, the call to <b>MyFile.Close()</b> is not strictly necessary. The
<b>CFile</b> destructor, which is called as the object loses scope, will call the <b>
Close()</b> function for you if it detects that you have not done so already. However,
it is good programming style to always match a call to <b>CFile::Open()</b> with a
corresponding call to <b>CFile::Close()</b>.</p>

<p>You can use the <b>Close()</b> function to disassociate your <b>CFile</b> object
from a file before reusing the object to access a different file. For example, the
following code will create three empty files named file1.txt, file2.txt, and file3.txt
in the current application folder. All three files are created using the same <b>
CFile</b> object:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CString  strFiles[3] = { &quot;file1.txt&quot;, &quot;file2.txt&quot;, &quot;file3.txt&quot; };
CFile file;

for(int i = 0; i &lt; 3; i++)
{
     file.Open(strFiles[i], CFile::modeCreate);
     file.Close();
}</pre>
</td></tr>
</table>
</p>

<A NAME="242"><H2>Reading and Writing Files</H2></A>

<p><b>CFile</b> supplies the <b>Read()</b> and <b>Write()</b> functions, which call the
Microsoft Windows API functions <b>ReadFile()</b> and <b>WriteFile()</b>, to provide direct,
unbuffered read and write operations to disk files. Because direct file access is
quite tricky to use, the C run-time library provides <i>stream I/O</i> functions. (For
example, buffers and pointer offsets must be specified in units that are integer
multiples of the disk volume's sector size.)</p>

<p>Stream I/O functions allow you to process data from disk files and other
sources in formats ranging from single characters to large data structures. These
functions also provide I/O buffering, which can improve performance. Ex-amples of
stream I/O functions include <b>fopen()</b>, <b>fseek()</b>, <b>fread()</b> and <b>
fwrite()</b>.  As a C++ programmer, you might be familiar with stream I/O through the <b>
iostream</b> classes.</p>

<p>MFC provides access to stream file I/O through the <b>CStdioFile</b> class. The <b>
CStdioFile</b> versions of <b>Read()</b> and <b>Write()</b> use the run-time stream I/O
functions. Unless you have a specific need for low-level direct access to a disk file,
you should use the <b>CStdioFile</b> class, which is flexible and easy to use.</p>

<p>Disk files associated with a <b>CStdioFile</b> object can be opened in <i>text mode</i>
or in <i>binary mode</i>. Text mode provides special processing for carriage
return/linefeed (CR/LF) pairs. When you write a newline character (0x0A) to a text-mode
<b>CStdioFile</b> object, the byte pair for a CR/LF (0x0D, 0x0A) is sent to the file.
When you read a text-mode file, the byte pair 0x0D, 0x0A is translated to a single 0x0A
byte. To open a <b>CStdioFile</b> object as a textmode file, supply the <b>
CFile::typeText</b> flag to the <b>Open()</b> function as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CStdioFile inFile(&quot;MyFile.txt&quot;, CFile::modeRead | CFile::typeText);</pre>
</td></tr>
</table>
</p>

<p>Use the <b>CFile::typeBinary</b> flag to open a <b>CStdioFile</b> in binary mode.
Newline characters are not converted in binary mode.</p>

<p>To read data from a <b>CStdioFile</b> file object, you can use either the <b>
Read()</b> function or the <b>ReadString()</b> function.</p>

<p><b>Read()</b> takes a pointer to a buffer that will contain the data read from the
file, and an unsigned integer (UINT) value that specifies the number of bytes to read.
The <b>Read()</b> function returns the number of bytes that were read. If the required
number of bytes could not be read because the end of the file was reached, the actual
number of bytes read is returned.</p>

<p>If a read error occurs, a <b>CFileException</b> exception is thrown. When writing to
a text mode file, use the <b>ReadString()</b> function, which is similar to <b>
Read()</b> except that:</p>

<ul>
<p><li> Reading stops when a newline character is encountered.</li></p>

<p><li> A terminating null is appended to the text in the buffer.</li></p>

<p><li> A pointer to the buffer is returned. This pointer will contain a NULL if the end
of the file was reached without reading any data.</li></p>
</ul>


<p><b>ReadString()</b> provides a simple way to read a single line from a text file
into a string by providing a version that returns a BOOL value, which indicates success
or failure.</p>

<p><b>Write()</b> is similar to <b>Read()</b>, taking a buffer containing the bytes to
be written and a value that specifies the number of bytes to read. The number of bytes
written is not returned with the use of <b>Write()</b>. If a write error occurs,
including not writing all bytes specified, <b>CFileException</b> is thrown. When
writing to a text mode file, use <b>CStdioFile::WriteString()</b>, which writes a
newline character.</p>

<p>The following code illustrates how to use the <b>CStdioFile</b> class to read and
write disk files. The code opens the MyFile.bin file in binary mode and reads its data
in blocks of 10 bytes. Each block is written to a new line in the newly created
Output.txt file, as demonstrated in the following code example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>try
{
     CStdioFile inFile(&quot;MyFile.bin&quot;, CFile::modeRead | 
          CFile::typeBinary);
     CStdioFile outFile(&quot;outfile.txt&quot;, CFile::modeCreate | 
          CFile::modeWrite | CFile::typeText);

     const UINT linelength = 10;
     TCHAR strBuf[16];

     while(inFile.ReadString(strBuf, linelength))
     {   
          _tcscat(strBuf, _T(&quot;\n&quot;));
          outFile.WriteString(strBuf);
     }               
}

catch(CFileException * fx)
{
     TCHAR buf[255];
     fx-&gt;GetErrorMessage(buf, 255);
     AfxMessageBox(buf);
}</pre>
</td></tr>
</table>
</p>

<A NAME="243"><H3>Random File Access</H3></A>

<p>Text files are generally read and written sequentially, a line at a time. When
reading binary files, you often need to perform <i>random access.</i> Random access
allows you to jump directly to a specific location, then immediately access data stored
at that location.</p>

<p>An open file maintains a <i>file pointer</i> that specifies the next byte to be read,
or the location to receive the next byte written. When a file is opened, the file
pointer is placed at the beginning of the file. You can position the file pointer by
using the <b>CFile::Seek()</b> function. <b>CFile::Seek()</b> moves the file pointer to
a specified offset from the beginning or end of the file, or from the current file
pointer position. A read or write operation will advance the file pointer by the number
of bytes read or written.</p>

<A NAME="244"><H2>Lesson Summary</H2></A>

<p>The MFC class <b>CFile</b> provides direct, unbuffered I/O to disk files. <b>
CFile</b> is also the base class for the <b>CStdioFile</b> class, which allows access
to files through the buffered stream I/O provided by the C run-time library. The <b>
CStdioFile</b> class allows you to open files in <i>text mode</i> (in which newline
characters are converted to CR/LF pairs) or in <i>binary mode</i> (in which newline
characters are not converted). If you need specific direct access to disk files, you
can use the <b>CFile</b> class. For general-purpose disk file I/O, you should use the
<b>CStdioFile</b> class.</p>

<p>Objects derived from <b>CFile</b> are either associated with a disk file at creation
time (by using the appropriate constructor), or created using a two-stage process, in
which a <b>CFile</b>-derived object is created and its <b>Open()</b> function is
called. The <b>Open()</b> function accepts a path to the file to be opened, and also
accepts flag values that specify the access and sharing modes to be used. The access
mode determines whether the file will be open for read-only, write-only, or read/write
permissions, and whether a new file should be created. The sharing mode determines the
level of access to this file that is granted to other processes while the file is
open.</p>

<p>Many of the <b>CFile</b> member functions throw MFC exceptions of the type <b>
CFileException</b>. <b>CFileException</b> objects can be queried to provide information
about the error that caused the exception condition. The <b>Open()</b> function takes
an exception object as a parameter.</p>

<p>To read and write an open disk file, you can use the <b>Read()</b> and <b>
Write()</b> functions provided by <b>CFile</b>, or you can use <b>CStdioFile::ReadString()</b>
and <b>CStdioFile::WriteString()</b>. Both <b>Read()</b> and <b>ReadString()</b> place
characters read from the file into a buffer that you supply to the function. <b>
ReadString()</b> stops reading when a newline character is encountered, and appends a
terminating null character to the text in the buffer.</p>

<p>Use the <b>Write()</b> function to write text in a buffer into a file. When writing
to a text mode file, use <b>CStdioFile::WriteString()</b>, which writes a newline
character as a CR/LF pair.</p>

<p>A file opened for random access maintains a <i>file pointer</i> that specifies the
next byte to be read or the location to receive the next byte written. Use the <b>
CFile::Seek()</b> function to move the file pointer to a specified offset within the
file before performing a read or write operation.</p>

</BODY>
</HTML>







