<HTML>
<HEAD>
<TITLE>Lesson 2: MFC Database Support</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07b.htm", "ch07d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="288"><H1>Lesson 2: MFC Database Support</H1></A>

<p>MFC provides classes to support database access through DAO or through ODBC. This
lesson shows you how to use these classes to create applications that allow you to
retrieve and manipulate data stored in an external database.</p>

<p>
<div class="sidebar"><blockquote>

<b>After this lesson, you will be able to:</b>

<ul>

<p><li> Describe the MFC DAO and ODBC database classes and how they work
together to provide access to desktop and client/server databases.</li></p>

<p><li> Describe how to use the AppWizard to create a database application based
on the <b>CRecordView</b> or <b>CDaoRecordView</b> class.</li></p>

<p><li> Describe how to use MFC database objects to query a database from within your
application code.</li></p>

<p><li> Describe how to filter a recordset based on parameters supplied at run time.</li></p>

</ul>

<b>Estimated lesson time: 50 minutes</b>

</blockquote></div>
</p>


<A NAME="289"><H2>MFC Database Classes</H2></A>

<p>MFC provides two distinct sets of classes for database access: one to allow access
through DAO, the other through ODBC. DAO is generally used to access desktop databases
and ODBC to connect to relational database servers through a named data source.</p>

<p>Both sets of classes are similar, and are based on a common programming model. The
DAO and ODBC database classes often differ only in name and a few relatively minor
implementation details. Table 7.1 lists the core ODBC classes, their DAO equivalents,
and a brief description of their functions:</p>

<p><b>Table 7.1</b> <i>ODBC Classes and Their DAO Equivalents</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>ODBC class</th>
			<th>DAO class</th>
			<th>Function</th>
		</tr>
		
		<tr>
			<td valign="top">CDatabase</td>
			<td valign="top">CDaoDatabase</td>			
			<td valign="top">Encapsulates a connection to a remote data source or desktop
database</td>
		</tr>

		<tr>
			<td valign="top">CRecordset</td>
			<td valign="top">CDaoRecordset</td>			
			<td valign="top">Encapsulates a set of records selected from a table in a
database</td>
		</tr>

		<tr>
			<td valign="top">CRecordView</td>
			<td valign="top">CDaoRecordView</td>			
			<td valign="top">Provides a dialog-based form view directly connected to a
recordset object</td>
		</tr>
		
	</table>
</p>

<p>These classes work together to enable you to retrieve data from a data source so
that the data can be displayed in a dialog-based view for browsing or updating. The
following sections explain the role of each class. Bear in mind that, because the ODBC
and DAO versions of the classes are so similar, we might often discuss the classes in
general terms rather than naming them specifically. We will draw your attention to
significant differences between the classes where they occur.</p>


<A NAME="290"><H3>CDatabase and CDaoDatabase</H3></A>

<p>The <b>CDatabase</b> class typically establishes a connection to an ODBC data source
such as a SQL Server database. The <b>CDaoDatabase</b> class usually establishes a
connection to a desktop data source such as an Access database.</p>

<p>Establishing a connection to a database is a two-stage process. You first create a
database object, then call that object's <b>Open()</b> member function. Both
classes provide similar <b>Open()</b> functions. For <b>CDatabase::Open()</b>, you
specify a DSN or a connection string; for <b>CDaoDatabase::Open()</b>, you specify a
database file name. The <b>Open()</b> functions take arguments to allow you to specify
whether the connection should be opened for exclusive or for read-only access.</p>

<p>For ODBC connections, use the <b>CDatabase::OpenEx()</b> function. The syntax for
the <b>OpenEx()</b> function is as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
CDatabase::OpenEx (LPCTSTR <i>lpszConnectString</i>,
     DWORD <i>dwOptions</i> = 0);
</pre></td></tr></table>
</p>

<p>The <i>lpszConnectString</i> parameter is the connection string that specifies the
DSN. If Windows NT authentication is not used on the data source, you can supply user
and password information in the connection string. If you pass <b>NULL</b> to the <i>
lpszConnectString</i> parameter, a dialog box will appear at run time that will prompt
you to enter the DSN, user ID, and password.</p>

<p>The second parameter, <i>dwOptions</i>, is a bitmask value that determines the mode
in which the data source is opened. The default value is <b>0</b>, which specifies that
the data source will be opened in the shared mode, with write access. Other values that
can be used are combinations of those shown in Table 7.2.</p>

<p><b>Table 7.2</b> <i>Optional Parameters for the CDatabase::OpenEx Member Function</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th>dwOptions parameter</th>
			<th>Meaning</th>
		</tr>

		<tr>
			<td valign="top">CDatabase::openReadOnly</td>
			<td valign="top">Opens the data source in a read-only mode</td>
		</tr>

		<tr>
			<td valign="top">CDatabase::useCursorLib</td>
			<td valign="top">Loads the ODBC cursor library</td>
		</tr>

		<tr>
			<td valign="top">CDatabase::noOdbcDialog</td>
			<td valign="top">Does not display the ODBC connection dialog box irrespective
of whether insufficient information was provided in the connection string</td>
		</tr>

		<tr>
			<td valign="top">CDatabase::forceOdbcDialog</td>
			<td valign="top">Always displays the ODBC connection dialog box</td>
		</tr>

	</table>
</p>

<p>This code shows how you might call <b>OpenEx()</b> to open a connection to the <i>
pubs</i> DSN, using the <b>sa</b> account with a password of <i>password</i>.</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
CDatabase db;
db.OpenEx(&quot;DSN=pubs;UID=sa;PWD=password&quot;,0);
</pre></td></tr></table>
</p>

<p>The <b>CDaoDatabase</b> class contains several features that allow you to make use
of functionality specific to the Microsoft Jet database engine. For example, you can
associate a collection of <b>CDaoTableDef</b> objects with a <b>CDaoDatabase</b>
object. These are table definition objects that you can use to create and modify tables
within a Jet-compatible database file.</p>

<p>You should always use the <b>Close()</b> function to close your database objects
when you have finished with them. Connections to data sources are expensive resources
that should be conserved.</p>


<A NAME="291"><H3>CRecordset and CDaoRecordset</H3></A>

<p>A recordset encapsulates a set of records selected from a database. A recordset is
comparable to a document in the document/view architecture, in that it holds the data
that a record view object displays.</p>

<p>Recordsets enable scrolling from record to record, updating records (adding,
editing, and deleting records), qualifying the selection with a filter, sorting the
selection, and parameterizing the selection with information obtained or calculated at
run time. <b>Recordset</b> objects contain member variables that correspond to columns
selected from the database table. These member variables are updated with values from
the corresponding database row, as the user moves through the recordset.</p>

<p>The exchange of data between data members of a recordset object and the
corresponding table columns on the data source is implemented by a mechanism called <i>
Record Field Exchange</i> (RFX). RFX is similar to the DDX mechanism used to transfer
data between dialog box controls and dialog classes.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
In the DAO world, RFX is called <i>DFX</i>&#8212;short for DAO
Record Field Exchange.
</blockquote></div>
</p>

<p>Recordset objects are created in association with a database object. You should pass
the address of an existing database object to your recordset constructor, as shown in
the following example that uses the ODBC classes:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
CDatabase db;
db.OpenEx(&quot;DSN=pubs;UID=sa;PWD=password&quot;,0);
CRecordset rs(&amp;db);
</pre></td></tr></table>
</p>

<p>If you derive a recordset class from <b>CRecordset</b> or <b>CDaoRecordset</b>, you
can overload member functions to specify connection information, and pass a NULL value
to the constructor when creating an object instance. If you use this method, MFC will
create a temporary database object to associate with your recordset, using the
connection information that you specify.</p>

<p>Once you have created your recordset object, you call the <b>Open()</b> member
function to submit a query and populate the recordset with the records returned from
the query. The following code shows how to call the <b>Open()</b> function for the <b>
CRecordset</b> object created in the previous example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
rs.Open(CRecordset::dynaset, &quot;SELECT * FROM authors&quot;,
     CRecordset::none);
</pre></td></tr></table>
</p>

<p>The first parameter of the <b>CRecordset::Open()</b> function determines the type of
cursor that will be created for the data that is returned, as shown in Table 7.3.</p>

<p><b>Table 7.3</b> <i>Cursor Types for the CRecordset::Open Member Function</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>Parameter</th>
			<th>Meaning</th>
		</tr>

		<tr>
			<td valign="top">CRecordset::dynaset</td>
			<td valign="top">Creates a recordset that is dynamic in nature and can be
scrolled in both directions. However, the ordering of data is determined when the
record set is opened. Dynasets are applicable for most database operations because they
use minimal memory by storing the keys from the result set only, and they show most
changes by other users. The only changes that cannot be seen are record insertions.</td>
		</tr>

		<tr>
			<td valign="top">CRecordset::snapshot</td>
			<td valign="top">Creates a recordset that does not display the changes made by
other users to the data source; also can be scrolled in both directions. Snapshots are
useful when you need to ensure the result set does not change while you are using it,
for example, when generating reports.</td>
		</tr>

		<tr>
			<td valign="top">CRecordset::dynamic</td>
			<td valign="top">Creates a recordset that is truly dynamic in nature. You can
scroll through the recordset in both directions and every time a user makes a change,
the data source content reflects that change. The dynamic cursor consumes the greatest
amount of resources. The dynaset is useful for situations where the result set must be
constantly up to date.</td>
		</tr>

		<tr>
			<td valign="top">CRecordset::forwardonly</td>
			<td valign="top">Creates a read-only recordset that can be scrolled in the
forward direction only. The forward-only cursor is the fastest and least
memory-consumptive cursor. Many database tasks involve making a single pass through the
result set, making this cursor useful for those tasks.</td>
		</tr>
		
	</table>
</p>

<p>The <b>Open</b> function's second parameter is an SQL command string. The last
parameter is a bitmask value that allows you to specify whether the recordset will be
append-only or read-only, whether it will allow processing of multiple rows of records,
and so on. The value <b>CRecordset::none</b> indicates that none of the options have
been set. For a complete list of values that this parameter can take, search for
&quot;<b>CRecordset::Open</b>&quot; in the Visual C++ Help file.</p>

<p><b>CDaoRecordset::Open()</b> is similar to <b>CRecordset::Open()</b>. The <b>
CDaoRecordset</b> class allows you to create only a dynaset, a snapshot, or a 
<b><i>Table</i></b> recordset. A <b>Table</b> recordset is an updateable
recordset that represents records from a single database table. Snapshot recordsets are
read-only for the <b>CDaoRecordset</b> class.</p>

<p>You must call the <b>Close()</b> member function once you have finished with a
recordset object. Make sure that you close a recordset <i>before</i> you attempt to
close the database object with which it is associated.</p>


<A NAME="292"><H3>CRecordView and CDaoRecordView</H3></A>

<p>The record view classes provide the means of displaying the data in a recordset. <b>
CRecordView</b> and <b>CDaoRecordView</b> are derived from <b><i>CFormView</i></b>, 
a view class that provides an application with a client area
based on a dialog template resource. This kind of application is often referred to as a
<i>forms-based</i> application.</p>

<p>The record view classes add the ability to connect dialog box controls to member
variables of an associated recordset. The user can view the current record through the
controls on the form, as illustrated in Figure 7.7.</p>

<p>
<img src="images/F07DA07.JPG" width=342 height=295 border="0">
</p><p>
<!-- caption --><b>Figure 7.7</b> <i>A <b>CRecordView</b>-based application</i><!-- /caption -->
</p>

<p>The exchange of data between the current record of the recordset and the controls of
the record view is handled by the dialog data exchange/dialog data validation (DDX/DDV)
mechanism, which is implemented for the record view classes. <b>CWnd::UpdateData()</b>
is called from within the record view class's <b>OnMove()</b> function, which is
called when the user moves from the current record. If the recordset is not read-only,
the current record in the recordset is updated with the values from the record view
controls. The RFX/DFX mechanism propagates these changes to the tables on the data
source. Figure 7.8 illustrates the relationships between the ODBC database objects and
the data exchange mechanisms.</p>

<p>
<A HREF="javascript:fullSize('F07DA08x.htm')"> <img src="images/F07DA08.JPG" width=404 height=102 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 7.8</b> <i>DDX and RFX</i><!-- /caption -->
</p>


<A NAME="293"><H3>Database Errors</H3></A>

<p>Accessing an external resource such as a database carries a high risk of failure.
The database might be offline, or a user might not have adequate permissions to access
the database. Calls to open a database connection or a recordset should be protected by
a <b>try&#8230; catch&#8230;</b> block to catch any exceptions that might occur. MFC
provides special database exception classes, similar to the <b>CFileException</b>
class, which provide information about the nature of the database error.</p>

<p>The <b>CDatabase::Open()</b> and the <b>CRecordset::Open()</b> functions throw a <b>
CDBException</b> upon failure. The <b>CDaoDatabase::Open()</b> and the <b>
CDaoRecordset::Open()</b> functions throw a <b>CDaoException</b>. An example of how to
handle database exceptions is given later in this lesson.</p>


<A NAME="294"><H2>Creating a Database Application with AppWizard</H2></A>

<p>To give you a better understanding of how the database, recordset, and record view
classes work together, you will use AppWizard to create a database application. You
will create a form-based application to retrieve and update data on the SQL Server
sample database <i>pubs</i>, using the ODBC data source from Lesson 1. Although the
ODBC classes are used throughout the following examples, the techniques demonstrated
can easily be applied to a project based around the DAO classes.</p>

<p><li> <b>To create the MyDBApp application</b></li></p>

<ol>

<p><li> On the Visual C++ <b>File</b> menu, click <b>New</b> to create an <b>MFC
AppWizard (exe)</b> project. Name the project <b>MyDBApp</b>.</li></p>

<p><li> In Step 1 of the AppWizard, select <b>Single document</b>. Click <b>Next</b> to
display Step 2 as shown in Figure 7.9.</li></p>

<p>
<A HREF="javascript:fullSize('F07DA09x.htm')"> <img src="images/F07DA09.JPG" width=404 height=325 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 7.9</b> <i>AppWizard database options</i><!-- /caption -->
</p>

<p>Step 2 lets you choose between four options to specify the level of database support
to include in the application. Choose the first option if you do not need to include
database support. Select the second option to include the
database header files in your project; this allows you to use the database classes and
manually create your own recordsets. Select the third or fourth option to create a
document/view-based application in which the document class contains a recordset; the
view class is derived from <b>CRecordView</b> or <b>CDAORecordView</b>. The third
option does not provide serialization routines, and is typically used when you want to
create a simple form-based application that views and/or updates data held in a
database. Use the fourth option if you require serialization support.</p>

<p><li> Select the <b>Database view without file support</b> option. Because you have
selected a database view for your application, you must select a data source for the
recordset class created for the project. Click <b>Data Source</b>. The <b>Database
Options</b> dialog box appears as shown in Figure 7.10.</li></p>

<p>
<img src="images/F07DA10.JPG" width=402 height=270 border="0">
</p><p>
<!-- caption --><b>Figure 7.10</b> <i>The <b>Database Options</b> dialog box</i><!-- /caption -->
</p>

<p><li> Ensure that the <b>ODBC</b> option is selected. Click the drop-down list to see
all the DSNs registered on your computer. Click <b>MyDSN</b>.</li></p>

<p><li> Ensure that the <b>Snapshot</b> recordset type is selected, and click <b>OK</b>.
Note that the SQL Server service must be running for this step to be completed
successfully. The <b>Select Database Tables</b> dialog box appears.</li></p>

<p><li> Click <b>dbo.authors</b> and then click <b>OK</b> (<b>dbo</b> is the <i>owner
name</i> assigned to the table by SQL Server).</li></p>

<p><li> Click <b>Finish</b> to accept the default values on the remaining AppWizard
screens. In the <b>New Project Information</b> dialog box, click <b>OK</b> to create
the project.</li></p>

</ol>

<p>The new project opens with the <b>IDD_MYDBAPP_FORM</b> dialog template displayed in
the dialog editor. <b>IDD_MYDBAPP_FORM</b> is the dialog template on which your record
view class <b>CMyDBAppView</b> is based. The template is opened at this point as a hint
that you need to add controls to your record view before you can display any recordset
data.</p>

<p>Before you create the dialog template for your record view, you should take a brief
look at the code generated for you by AppWizard, to help you understand how a database
application is implemented.</p>

<p><li> <b>To view the generated code</b></li></p>

<ol>

<p><li> Open MyDBAppSet.h to view the recordset class definition. Note that AppWizard
has added a set of RFX member variables, one for each column in the authors table, to
the class.</li></p>

<p><li> Open <b>MyDBAppSet.cpp</b> and locate the <b>CMyDBAppSet::DoFieldExchange()</b>
function. Note that this is similar to the <b>DoDataExchange()</b> function used by
DDX. AppWizard adds a call to an RFX function of the appropriate type to this function
for each column in the authors table.</li></p>

<p><li> The <b>GetDefaultSQL()</b> member function, just above the <b>
DoFieldExchange()</b> function, defines the <b>FROM</b> section of the <b>SELECT</b>
statement on which the recordset is based:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
CString CMyDBAppSet::GetDefaultSQL()
{
     return _T(&quot;[dbo].[authors]&quot;);
}
</pre></td></tr></table>
</p>

<p>Note that the ODBC object names are enclosed in square brackets. Although this is
required only when the object names contain spaces, the generated code always contains
them by default.</p>

<p>To define a filter for your recordset, assign a string specifying a <b>WHERE</b>
clause to the m_strFilter data member of your recordset class. You can
also sort the records in your recordset by assigning a string specifying an <b>ORDER
BY</b> clause to the m_strSort data member.</p>

<p><li> The <b>GetDefaultConnect()</b> member function, just above the <b>
GetDefaultSQL()</b> function, returns a connection string that specifies the data
source to be used by the recordset.</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
CString CMyDBAppSet::GetDefaultConnect()
{
     return _T(&quot;ODBC;DSN=MyDSN&quot;);
}
</pre></td></tr></table>
</p>

<p>The framework does not create a <b>CDatabase</b>-derived object for your project.
The recordset constructor receives a <b>NULL</b> parameter, causing a temporary <b>
CDatabase</b> object to be created and used.</p>

<p>If you have used SQL Server authentication for your data source, you can prevent a
<b>SQL Server Login</b> dialog box from appearing when you run the application by
including authentication information in the following connection string:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
CString CMyDBAppSet::GetDefaultConnect()
{
     return _T(&quot;ODBC;DSN=MyDSN;UID=sa;PWD=&quot;);
}
</pre></td></tr></table>
</p>

<p>The connection string shown assumes that the <b>sa</b> account has no password.</p>

<p><li> Finally, open the MyDBAppDoc.h file to view the document class definition.
Notice that the <b>CMyDBAppDoc</b> class contains the m_myDBAppSet public member
variable. The <b>CMyDBApp</b> application conforms to the document/view model&#8212;the
document class contains the application data that is displayed by the view class (the
<b>CMyDBAppView</b> class).</li></p>

</ol>

<p>You can make your recordset class more efficient by deleting the RFX member
variables and functions for the columns in the authors table that are not used by your
application. The next exercise shows you how to use ClassWizard to do this.</p>

<p><li> <b>To remove unwanted fields from your recordset class</b></li></p>

<ol>

<p><li> Press CTRL+W to open ClassWizard, and select the <b>Member Variables</b>
tab.</li></p>

<p><li> Select the <b>CMyDBAppSet</b> class name. In the list of member variables, click
<b>m_au_id,</b> which corresponds to the [au_id] column. Click <b>Delete
Variable</b>.</li></p>

<p><li> Repeat the process to remove the <b>m_contract</b> variable that corresponds to
the [contract] column. Click <b>OK</b> to save the changes.</li></p>

</ol>

<p>You will now return to the IDD_MYDBAPP_FORM dialog template to add the controls to
display the data held in these recordset variables.</p>

<p><li> <b>To modify the record view dialog template</b></li></p>

<ol>

<p><li> Use the dialog editor to add controls the IDD_MYDBAPP_FORM dialog template. Add
three static text controls and seven edit controls as shown in Figure 7.11.</li></p>

<p>
<img src="images/F07DA11.JPG" width=330 height=203 border="0">
</p><p>
<!-- caption --><b>Figure 7.11</b> <i>The IDD_MYDBAPP_FORM dialog template</i><!-- /caption -->
</p>

<p><li> Assign the following control IDs to the edit controls:</li></p>

<ul>

<p><li> <b>IDC_AU_FNAME</b> </li></p>

<p><li> <b>IDC_AU_LNAME</b> </li></p>

<p><li> <b>IDC_AU_ADDRESS</b> </li></p>

<p><li> <b>IDC_AU_CITY</b> </li></p>

<p><li> <b>IDC_AU_STATE</b> </li></p>

<p><li> <b>IDC_AU_ZIP</b> </li></p>

<p><li> <b>IDC_AU_PHONE</b> </li></p>

</ul>

</ol>

<p>You will now use ClassWizard to associate member variables of the recordset class
with these control IDs.</p>

<p><li> <b>To associate recordset variables with the record view dialog control IDs</b></li></p>

<ol>

<p><li> On the ClassWizard <b>Member Variables</b> tab, select the <b>CMyDBAppView</b>
class.</li></p>

<p><li> In the <b>Control IDs</b> box, click <b>IDC_AU_ADDRESS</b>. Click <b>Add
Variable</b>.</li></p>

<p><li> Expand the <b>Member variable name</b> drop-down list to see a list of recordset
class data members that can be associated with the controls in this record view. Select
the <b>m_pSet-&gt;m_address</b> variable.</li></p>

<p><li> Ensure that <b>Value</b> is selected in the <b>Category</b> box, and that <b>
CString</b> is selected in the <b>Variable</b> type box, and click <b>OK</b>.</li></p>

<p><li> Repeat the previous steps to associate the corresponding recordset variable with
each of the control IDs. For the IDC_AU_STATE control, create a validation rule to
specify that a maximum of two characters can be entered.</li></p>

<p><li> Click <b>OK</b> to close ClassWizard and save your work.</li></p>

</ol>

<p>Look through the MyDBAppView.h and MyDBAppView.cpp files to see the changes
ClassWizard has made. Note that you have not added any member variables to the <b>
CMyDBAppView</b> class. You have merely associated the controls with existing member
variables from the <b>CMyDBAppSet</b> class. ClassWizard implements the association by
using the <b>DDX_FieldText()</b> function inside the record view's <b>
DoDataExchange()</b> function, as shown here:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
void CMyDBAppView::DoDataExchange(CDataExchange* pDX)
{
     CRecordView::DoDataExchange(pDX);
     //{{AFX_DATA_MAP(CMyDBAppView)
     DDX_FieldText(pDX, IDC_AU_ADDRESS, m_pSet-&gt;m_address, m_pSet);
     DDX_FieldText(pDX, IDC_AU_CITY, m_pSet-&gt;m_city, m_pSet);
     DDX_FieldText(pDX, IDC_AU_FNAME, m_pSet-&gt;m_au_fname, m_pSet);
     DDX_FieldText(pDX, IDC_AU_LNAME, m_pSet-&gt;m_au_lname, m_pSet);
     DDX_FieldText(pDX, IDC_AU_PHONE, m_pSet-&gt;m_phone, m_pSet);
     DDX_FieldText(pDX, IDC_AU_STATE, m_pSet-&gt;m_state, m_pSet);
     DDV_MaxChars(pDX, m_pSet-&gt;m_state, 2);
     DDX_FieldText(pDX, IDC_AU_ZIP, m_pSet-&gt;m_zip, m_pSet);
     //}}AFX_DATA_MAP
}
</pre></td></tr></table>
</p>

<p>Note that a standard DDV validation function can still be used.</p>

<p>Build and run the MyDBApp application. The application should appear as shown in
Figure 7.12, although you might see a different record displayed.</p>

<p>
<img src="images/F07DA12.JPG" width=342 height=295 border="0">
</p><p>
<!-- caption --><b>Figure 7.12</b> <i>The MyDBApp application</i><!-- /caption -->
</p>

<p>Note that the <b>CRecordView</b> class provides a set of VCR-style navigation
buttons on the toolbar that allows you to move forward and backward through the
recordset, and jump to the beginning or to the end. The framework maps the control IDs
for these buttons to the record view's <b>OnMove()</b> function. The base class
implementation of the <b>OnMove()</b> function calls <b>CWnd::UpdateData(TRUE)</b> to
save changes made to the record as you move off a record; and calls <b>
CWnd::UpdateData(FALSE)</b> to update the record view with values from the recordset as
you move on to a record. <b>UpdateData</b> updates the view by calling its <b>
DoDataExchange()</b> function.</p>


<A NAME="295"><H2>Filtering a Recordset</H2></A>

<p>We mentioned earlier that you could filter a recordset by assigning a string
specifying a <b>WHERE</b> clause to the recordset's m_strFilter data member. The
following exercises show you how to apply this technique so that the MyDBApp
application displays records on the authors table filtered by state of residence. You
will create a menu option that allows the users to select from a list of state codes
from the authors table. The selected state code will be used to filter the
recordset.</p>

<p><li> <b>To update the MyDBApp user interface</b></li></p>

<ol>

<p><li> In the MyDBApp project, open the <b>IDR_MAINFRAME</b> menu in the menu
editor. Delete the <b>Edit</b> menu, since it is not used by the MyDBApp
application.</li></p>

<p><li> In place of the <b>Edit</b> menu, create a new menu with the caption <b>
&amp;Filter</b>. To this menu, add a single item with the caption <b>&amp;State</b>.
This menu command should be assigned the ID <b>ID_FILTER_STATE</b>. Close the menu
editor.</li></p>

<p><li> Using the toolbar editor, delete the buttons on the <b>IDR_MAINFRAME</b> toolbar
that correspond to the deleted <b>Edit</b> menu options (<b>ID_EDIT_CUT</b>, <b>
ID_EDIT_COPY</b> and <b>ID_EDIT_PASTE</b>). Remember that you delete toolbar buttons by
dragging them off the toolbar. Close the toolbar editor.</li></p>

<p><li> Open ClassWizard and select the <b>Message Maps</b> tab. Select the <b>
CMyDBAppDoc</b> class and create a command handler function for the <b>
ID_FILTER_STATE</b> ID. Accept the default name <b>OnFilterState()</b> for the
function.</li></p>

<p><li> Click <b>OK</b> to close ClassWizard and save your changes.</li></p>

</ol>

<p>Next, you will create the <b>Select State</b> dialog box, which will display a list
of state codes from the authors table.</p>

<p><li> <b>To create the Select State dialog box</b></li></p>

<ol>

<p><li> In ResourceView, right-click the Dialog folder. On the shortcut menu, select the
<b>Insert Dialog</b> option to create a new dialog template resource. This resource
should be assigned the ID <b>IDD_STATEDIALOG</b>, and the caption <b>Select
State</b>.</li></p>

<p><li> Add a list box control to the dialog box, and assign it the ID <b>IDC_STATELIST</b>. 
Arrange the controls so that the dialog box resembles the
one shown in Figure 7.13.</li></p>

<p>
<img src="images/F07DA13.JPG" width=224 height=149 border="0">
</p><p>
<!-- caption --><b>Figure 7.13</b> <i>The <b>Select State</b> dialog box</i><!-- /caption -->
</p>

<p><li> Press CTRL+W to open ClassWizard, and create a dialog class for the <b>
IDD_STATEDIALOG</b> template. Name the dialog class <b>CStateDialog</b>.</li></p>

<p><li> On the ClassWizard <b>Member Variables</b> tab, select the <b>IDC_STATELIST</b>
control ID. Click <b>Add Variable</b> to add a <b>CString</b> variable named m_strState
and store the value selected from the list box. Click <b>Add Variable</b> again to add
a <b>CListBox</b> variable named m_statelist, to represent the list box control.</li></p>

<p><li> On the ClassWizard <b>Message Maps</b> tab, select <b>CStateDialog</b> in the
<b>Object IDs</b> box and <b>WM_INITDIALOG</b> in the <b>Messages</b> box. Click <b>Add
Function</b> to create an overload of the <b>OnInitDialog()</b> virtual function for
your class.</li></p>

<p><li> Click <b>Edit Code</b> to edit the function implementation. Replace the // TODO
comment line with the following code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
CDatabase aDB;

try
{
     aDB.OpenEx(&quot;DSN=MyDSN&quot;);
     // Specify login information if using SQL Server authentication,
     // e.g., aDB.OpenEx(&quot;ODBC;DSN=MyDSN;UID=sa;PWD=&quot;);

     CRecordset aRS(&amp;aDB);

     aRS.Open(CRecordset::forwardOnly,
          &quot;SELECT DISTINCT state FROM authors&quot;);

     while(! aRS.IsEOF())
     {
          CString strValue;
          aRS.GetFieldValue(short(0), strValue);
          m_statelist.AddString(strValue);
          aRS.MoveNext();
     }

     m_statelist.InsertString(0, &quot;All records&quot;);

     aRS.Close();
     aDB.Close();
}

catch(CDBException * ex)
{
     TCHAR buf[255];
     ex-&gt;GetErrorMessage(buf, 255);
     CString strPrompt(buf);
     AfxMessageBox(strPrompt);
}
</pre></td></tr></table>
</p>

</ol>

<p>Notice that this function uses locally created <b>CDatabase</b> and <b>
CRecordset</b> objects to retrieve information from the database. The code creates a <i>
forward-only</i> recordset, as it needs to make only a single pass through the
records. The <b>SELECT</b> statement that is used to open the recordset is qualified by the <b>
DISTINCT</b> keyword, which specifies that only unique rows can appear in the
recordset. This means that the recordset will contain one record per state for each
state found in the table.</p>

<p>The <b>CRecordset::MoveNext()</b> function moves through the recordset until <b>
CRecordset::IsEOF()</b> returns true. The value of the state column in each row is
retrieved by the <b>CRecordset::GetFieldValue()</b> function. This function allows you
to dynamically retrieve data from a recordset field by specifying a zero-based numeric
index. Because the recordset in this function returns only one column, we know that the
value we require can be accessed by the index value 0. Note how this function enables
you to use the <b>CRecordset</b> class directly, without deriving your own class and
specifying RFX variables.</p>

<p>Values retrieved from the recordset rows are added to the dialog box's list box
control. The <b>CListBox::InsertString()</b> function is use to insert an &quot;All
records&quot; item at the top of the list.</p>

<p>Notice that the database code is enclosed within a <i>try</i> block, and that the <i>
catch</i> handler extracts information from the <b>CDBException</b> object to display
to the user.</p>

<p>Finally, you will implement the <b>OnFilterState()</b> function to handle the <b>
State</b> option from the <b>Filter</b> menu. This function will display the <b>Select
State</b> dialog box and use the state code chosen by the user to filter the records
displayed by the application.</p>

<p><li> <b>To implement the OnFilterState() function</b></li></p>

<ol>

<p><li> Add the following line to the top of the MyDBAppDoc.cpp file:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
#include &quot;StateDialog.h&quot;
</pre></td></tr></table>
</p>

<p><li> Locate the <b>CMyDBAppDoc::OnFilterState()</b> function that you created
earlier. Replace the // TODO comment line with the following code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
CStateDialog aSD;

if(aSD.DoModal() == IDOK)
{
     if(aSD.m_strState == &quot;All records&quot;)
          m_myDBAppSet.m_strFilter = &quot;&quot;;
     else
          m_myDBAppSet.m_strFilter.Format(&quot;state = '%s'&quot;, 
               aSD.m_strState);

     m_myDBAppSet.Requery();

     POSITION pos = GetFirstViewPosition();
     if (pos != NULL)
     {
          CView* pView = GetNextView(pos);
          ASSERT_VALID(pView);
          pView-&gt;UpdateData(FALSE);
     }
}
</pre></td></tr></table>
</p>

</ol>

<p>The <b>CRecordset::Requery()</b> function refreshes the recordset after the filter
has been changed. After a requery, the first record of the new set of records becomes
the current record. It is important to make sure that you call <b>UpdataData()</b> on
the record view to refresh the values displayed by the controls with data from the new
current record.</p>

<p>You can parameterize your recordset by including question marks (?) as parameter
placeholders in your filter string like this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
m_myDBAppSet.m_strFilter = &quot;state = ?&quot;;
</pre></td></tr></table>
</p>

<p>You can then use the RFX mechanism to replace the parameter placeholders with
run-time values. To learn how to parameterize a recordset in this way, refer to the
article &quot;Recordset: Parameterizing a Recordset (ODBC)&quot; in the Visual C++ Help
file. Using a parameter in this way is more efficient than simply replacing the filter
string. For a parameterized recordset, the database must process an SQL <b>SELECT</b>
statement only once. For a filtered recordset without parameters, the <b>SELECT</b>
statement must be processed each time you requery with a new filter value.</p>


<A NAME="296"><H2>Lesson Summary</H2></A>

<p>MFC provides two distinct sets of classes for database access: one to allow access
through DAO, the other through ODBC. Both sets of classes are similar and are based on
a common programming model.</p>

<p>A set of three core classes work together to enable you to retrieve data from a data
source so that it can be displayed in a dialog-based view for browsing or updating.
These classes are:</p>

<ul>

<p><li> <b>CDatabase/CDaoDatabase</b> </li></p>

<p><li> <b>CRecordset/CDaoRecordset</b> </li></p>

<p><li> <b>CRecordView/CDaoRecordView</b> </li></p>

</ul>

<p>The database classes are used to establish a connection to a data source or database
file. This is achieved by creating an object of the appropriate type, and calling the
object's <b>Open()</b> function. The <b>Open()</b> functions allow you to supply
connection information using a connection string, and to specify whether the connection
should be opened for exclusive or for read-only access.</p>

<p>For ODBC connections, Microsoft recommends that you use the <b>CDatabase::OpenEx()</b> 
function. This function allows you to specify flags to pass additional
ODBC information.</p>

<p>You should always use the <b>Close()</b> functions to close your database objects
when you have finished with them.</p>

<p>A recordset encapsulates a set of records selected from a database. Recordsets
enable scrolling from record to record, updating records, filtering and sorting
records. Recordset objects contain member variables that correspond to columns selected
from the database table. As the user moves through the recordset, the member variables
are updated with values from the corresponding database row, by RFX.</p>

<p>Recordset objects are created in association with a database object. You should pass
the address of an existing database object to your recordset constructor. For derived
recordset classes, you can pass a NULL value to the constructor when creating an object
instance, and the framework will create a temporary database object for the recordset
to use. Overload the <b>GetDefaultConnect()</b> member function to supply connection
information for the temporary database object.</p>

<p>After you have created your recordset object, you call the <b>Open()</b> member
function to submit a query and populate the recordset with the records returned from
the query.</p>

<p>The <b>Open()</b> function specifies the type of cursor to be created for the
recordset. For a <b>CRecordset</b> object, this recordset can be one of the
following:</p>

<ul>

<p><li> <b>dynaset</b> A recordset that is dynamic in nature and can be scrolled in both
directions.</li></p>

<p><li> <b>snapshot</b> A recordset that does not display the changes made by other users
to the data source and can be scrolled in both directions.</li></p>

<p><li> <b>dynamic</b> A recordset that is truly dynamic in nature. The recordset can be
scrolled on both directions, and is reordered every time a user makes a change to the
data source content.</li></p>

<p><li> <b>forwardonly</b> A read-only recordset that can be scrolled in the forward
direction only.</li></p>

</ul>

<p><b>CDaoRecordset</b> objects support read-only snapshot recordsets, dynasets, and
table recordsets, based on an entire table in an .mdb database.</p>

<p>The recordset <b>Open()</b> functions take an SQL command string to select records
for the recordset. <b>CDaoRecordset</b> objects can take the name of a DAO table
definition or query definition object.</p>

<p>Use the <b>Close()</b> functions to close your recordset objects when you have
finished with them.</p>

<p>The record view classes provide the means of displaying recordset data in a view
based on a dialog template resource. Controls in a record view are connected to member
variables of an associated recordset. The exchange of data between the current record
of the recordset and the controls of the record view is handled by the DDX/DDV
mechanism.</p>

<p>The <b>CDatabase::Open()</b> and the <b>CRecordset::Open()</b> functions will throw
a <b>CDBException</b> upon failure. The <b>CDaoDatabase::Open()</b> and the <b>
CDaoRecordset::Open()</b> functions throw a <b>CDaoException</b>.</p>

<p>Step 2 of the <b>MFC AppWizard (.exe)</b> option allows you to specify the level of
database support to include in an application. You can simply include the database
header files in your project, and use the database and recordset classes manually.
Alternatively, you can create a document/view-based application in which the document
class contains a recordset, and the view class is derived from <b>CRecordView</b> or
<b>CDaoRecordView</b>. You can create an application with serialization routines, or a
simple form-based application that views and/or updates data held in a database.</p>

<p>When you select a database view for your application, you must specify a data source
for your application's recordset class. AppWizard creates recordset and record view
classes for your project, and a blank dialog template to which you add controls to
display the recordset data. The record view class supplies a set of VCR-style buttons
on the toolbar that allows you to navigate the recordset.</p>

<p>You can filter a recordset by assigning a string specifying a <b>WHERE</b> clause to
the m_strFilter data member of your recordset class. You can also sort the records in a
recordset by assigning a string specifying an <b>ORDER BY</b> clause to the m_strSort
data member. For maximum efficiency, you can parameterize the m_strFilter string and
use the RFX mechanism to specify parameters.</p>


</BODY>
</HTML>







