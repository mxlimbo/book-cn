<HTML>
<HEAD>
<TITLE>Lesson 1: COM Client Applications</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch10a.htm", "ch10c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="380"><H1>Lesson 1: COM Client Applications</H1></A>

<p>In this lesson, you will create a simple application that uses the Encoder COM
component you created in the exercises in <A HREF="ch09a.htm">Chapter 9</A>. The application will use the
header files generated by the MIDL compiler from the EncodeServer.idl file. In the
latter part of the lesson, you will learn about the features of the Visual C++ compiler
that support the creation of COM client applications and components, and you will 
use these features to re-implement the EncodeClient application.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>

<ul>

<p><li> Describe how the header files generated by the MIDL compiler can be used by a
client application.</li></p>

<p><li> Describe the features of the Visual C++ COM compiler support.</li></p>

<p><li> Describe how to import a type library into a project.</li></p>

</ul>

<b>Estimated lesson time: 30 minutes</b>

</blockquote></div>
</p>


<A NAME="381"><H2>COM Server Header Files</H2></A>

<p>In <A HREF="ch09a.htm">Chapter 9</A>, you learned how the MIDL compiler generates header files that make a
COM server's interface and GUID definitions available to C and C++ clients. The
files generated for the Encoder component are named EncodeServer.h and
EncodeServer_i.c.</p>

<p>The EncodeServer_i.c file contains the following code, which declares the GUIDs
defined by the Encoder component as easy to read (and easy to type!) constants:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>const IID IID_IEncoder = 
{0x69F4B926,0x6641,0x11D3,{0x93,0x4B,0x00,0x80,0xC7,0xFA,0x0C,0x3E}};

const IID LIBID_ENCODESERVERLib = 
{0x69F4B91A,0x6641,0x11D3,{0x93,0x4B,0x00,0x80,0xC7,0xFA,0x0C,0x3E}};

const CLSID CLSID_Encoder = 
{0x69F4B917,0x6641,0x11D3,{0x93,0x4B,0x00,0x80,0xC7,0xFA,0x0C,0x3E}};</pre>
</td></tr>
</table>
</p>

<p>The IID and CLSID types are defined earlier in the file as C structures that
represent a GUID.</p>

<p>At the heart of the EncodeServer.h file is the following C++ declaration (comments have
been removed for clarity):</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>MIDL_INTERFACE(&quot;69F4B926-6641-11D3-934B-0080C7FA0C3E&quot;)
IEncoder : public Iunknown
{
     public:
     virtual HRESULT STDMETHODCALLTYPE EncodeString(
         const BSTR instring, BSTR __RPC_FAR *outstring) = 0;

     virtual HRESULT STDMETHODCALLTYPE get_Key(
         short __RPC_FAR *pVal) = 0;

     virtual HRESULT STDMETHODCALLTYPE put_Key(
         short newVal) = 0;
};</pre>
</td></tr>
</table>
</p>

<p>This code defines an abstract class named <b>IEncoder</b> (derived from the abstract
class <b>IUnknown</b>), which contains member functions corresponding to the methods
exposed by the <b>IEncoder</b> COM interface. The <b>MIDL_INTERFACE</b> macro uses the
Microsoft specific <b>__declspec(uuid())</b> declarator to associate the interface GUID
with the class. The keyword <b>__uuidof()</b> can be applied to retrieve a constant
GUID attached to a class in this way.</p>

<p>Client programs use the definitions contained in these header files to create pointers
to the <b>IEncoder</b> class, which can be passed to the <b>CoCreateInstance</b>()
function, as shown in the following example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>IEncoder * pServer;
HRESULT hr = ::CoCreateInstance(CLSID_Encoder, NULL,
    CLSCTX_INPROC_SERVER,
    IID_IEncoder,
    (void **) &amp;pServer);</pre>
</td></tr>
</table>
</p>

<p>If this function call succeeds in creating an <b>Encoder</b> COM object, the pServer
variable receives a pointer to the vtable of the COM object. The <b>pServer</b> pointer
can then be used to call the methods of the <b>IEncoder</b> interface.</p>

<p>To demonstrate the use of the EncodeServer.h and EncodeServer_i.c header files, you
will develop a simple console application, EncodeHello, that uses an <b>Encoder</b> COM
object to display an encoded &quot;Hello World&quot; string.</p>

<p><li> <b> To create the EncodeHello application</b></li></p>

<ol>

<p><li> On the Visual C++ <b>File</b> menu, click <b>New</b>. Choose <b>Win32 Console
Application</b> as the project type and enter <b>EncodeHello</b> as the project name.
Click <b>OK</b>.</li></p>

<p><li> In Step 1 of the Win32 Console Application Wizard, select <b>A simple
application</b> and click <b>Finish</b>. Click <b>OK</b> to create the project.</li></p>

<p><li> Using Windows Explorer, copy the files EncodeServer.h and EncodeServer_i.c from
the EncodeServer project folder to the EncodeHello project folder.</li></p>

<p><li> In FileView, locate and open the EncodeHello.cpp file. At the top of the file,
add the following lines:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#include &lt;iostream.h&gt;
#include &quot;EncodeServer.h&quot;
#include &quot;EncodeServer_i.c&quot;</pre>
</td></tr>
</table>
</p>

<p><li> Add code to the body of the <b>Main()</b> function so that it appears as
follows:</li></p>

<p>
<img src="images/cd.gif" width=45 height=45 border="0">
</p>

<p>(This code can be found in CH10_01.cpp, installed from the companion CD.)</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>int main(int argc, char* argv[])
{
    ::CoInitialize(NULL);

    IEncoder * pServer;

    HRESULT hr = ::CoCreateInstance(CLSID_Encoder, NULL,
        CLSCTX_INPROC_SERVER,
        IID_IEncoder,
        (void **) &amp;pServer);

    if(SUCCEEDED(hr))
    {
        short nKey = 1;
        cout &lt;&lt; &quot;Enter a code key between -5 and 5: &quot;;
        cin &gt;&gt; nKey;

        wchar_t wstrHello[16] = L&quot;Hello World!&quot;;
        BSTR bstrHello = ::SysAllocString(wstrHello);
        BSTR bstrCodedHello;

        HRESULT hr = pServer-&gt;put_Key(nKey);
        if(FAILED(hr)) goto ComError;

        hr = pServer-&gt;EncodeString(bstrHello, &amp;bstrCodedHello);
        if(FAILED(hr)) goto ComError;

        char strOut[16];
        wcstombs(strOut, bstrCodedHello, 16);
        cout &lt;&lt; &quot;\n&quot; &lt;&lt; strOut &lt;&lt; &quot;\n\n&quot;; 

        ComError:
            if(FAILED(hr)) cout &lt;&lt; &quot;COM Error&quot; &lt;&lt; &quot;\n\n&quot;;

            ::SysFreeString(bstrHello);
            ::SysFreeString(bstrCodedHello);

        pServer-&gt;Release();
     }
     ::CoUninitialize();

     return 0;
}</pre>
</td></tr>
</table>
</p>

<p>The <b>CoInitialize()</b> function calls the <b>CoInitializeEx()</b> function with
the <i>COINIT_APARTMENTTHREADED</i> parameter. In <a href="ch08e.htm#333">Lesson 4</a> of Chapter 8, you learned
how the <b>CoInitializeEx()</b> function must be called to initialize
the COM libraries on the current thread and specify the threading model to use for the
COM objects that are created. Each call to <b>CoInitialize()</b> or to <b>
CoInitializeEx()</b> must be balanced with a call to the <b>CoUninitialize()</b>
function, which closes the COM library on the current thread.</p>

<p>The code contained in EncodeHello.cpp is pretty straightforward&#8212;an instance of the
<b>Encoder</b> COM object is created, the <b>Key</b> property is set to a value
supplied by the user, and the <b>EncodeString()</b> method is called to encode the
&quot;Hello World!&quot; string.</p>

<p>Notice the call to <b>IUnknown::Release()</b> toward the end of the function. In <a href="ch08b.htm#312">Lesson 1</a> of Chapter 8, you learned that when <b>CoCreateInstance()</b> is used to obtain a
pointer to an interface, the server reference count is incremented. It is the
client's responsibility to call <b>Release()</b> to decrement the reference count
after the client has finished with the interface pointer.</p>

<p><li> Build and run the EncodeHello application to ensure its performance.</li></p>

</ol>


<A NAME="382"><H2>Visual C++ COM Compiler Support</H2></A>

<p>With Visual C++ 5.0, Microsoft introduced a number of classes and C++
language extensions that simplified the creation of COM client programs. These include
<b>_com_ptr_t</b>, a smart pointer class that encapsulates a COM interface pointer; and
the <b>_bstr_t</b> and <b>_variant_t</b> classes, which encapsulate the
<b>BSTR</b> and <b>VARIANT</b> data types. Also provided is a COM exception class, <b>
_com_error</b>. You can use these classes by including (using #include) the comdef.h
file. Another new feature introduced with Visual C++ 5.0 is the #import directive,
which generates C++ header files from information contained
in a COM server object's type library. These header files make extensive use of the
<b>_com_ptr_t</b> class and use <b>_bstr_t</b> and <b>_variant_t</b> where the <b>
BSTR</b> and <b>VARIANT</b> data types are used.</p>

<p>The features of the Visual C++ COM compiler support are described briefly in the
following sections.</p>


<A NAME="383"><H3>_com_ptr_t</H3></A>

<p>The <b>_com_ptr_t</b> class is a templated class that encapsulates a COM interface
pointer. The class provides some extra code that helps simplify reference counting. A
<b>_com_ptr_t</b> object calls the <b>IUnknown::AddRef()</b> and <b>IUnknown::Release()</b> 
methods of the encapsulated interface on your behalf to ensure that the
lifetime of the COM object that provides the interface is managed properly. <b>
AddRef()</b> is called automatically when a <b>_com_ptr_t</b> object is created as a
copy from an existing interface pointer, and <b>Release()</b> is called automatically
when a <b>_com_ptr_t</b> object goes out of scope.</p>

<p>Although this &quot;smart pointer&quot; behavior makes for more readable source code,
you shouldn't let the <b>_com_ptr_t</b> class lull you into a false sense of
security. You should always be aware of the current usage of COM objects in your code,
and know when you should be calling <b>AddRef()</b> and <b>Release(</b>)&#8212;even if
you employ a smart pointer to do this for you.</p>

<p>The simplest way to instantiate a <b>_com_ptr_t</b> template to a specific interface
type is to create the <b>_com_ptr_t</b> object with the <b>_COM_SMARTPTR_TYPEDEF</b> 
macro. This macro takes an interface name and the unique GUID
for a specific interface and declares a specialization of <b>_com_ptr_t</b> with the
name of the interface plus a suffix of <i>Ptr</i>. For example, in a file that
includes the EncodeServer.h and EncodeServer_i.c header files, the following line will
declare the <b>_com_ptr_t</b> specialization <b>IEncoderPtr</b>:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>_COM_SMARTPTR_TYPEDEF(IEncoder, __uuidof(IEncoder));</pre>
</td></tr>
</table>
</p>

<p>Instances of the instantiated type can then call the <b>com_ptr_t</b> member
function <b>CreateInstance()</b> to obtain an interface pointer from a COM server, as
follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>IEncoderPtr pEnc ;
pEnc.CreateInstance(CLSID_Encoder);</pre>
</td></tr>
</table>
</p>

<p>This pointer can then be used to call the methods of the interface using the <b>
com_ptr_t</b> overload of the -&gt; operator as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>int n = 3;
HRESULT hr = pEnc-&gt;put_Key(n);</pre>
</td></tr>
</table>
</p>

<p>Note that the <b>_com_ptr_t</b> member functions are called by using the <b>dot</b>
operator (as in the call to <b>CreateInstance()</b>); and that the methods of the
interface are called through the overloaded -&gt; operator (as in the call to the <b>
put_Key()</b> method just shown).</p>

<p>It is also possible for <b>_com_ptr_t</b> objects to be created from an existing
pointer to a COM interface, or copied from another <b>_com_ptr_t</b> object. The Visual
C++ Help file gives details on how the <b>AddRef()</b> and <b>Release()</b> methods are
called by the assignment operators and copy constructors.</p>


<A NAME="384"><H3>_bstr_t</H3></A>

<p>A <b>_bstr_t</b> object encapsulates the <b>BSTR</b> data type. The class manages
resource allocation and de-allocation through internal calls to <b>SysAllocString()</b>
and <b>SysFreeString()</b>, and uses reference counting for efficient use of memory.
The class provides a number of operators that enable you to use a <b>_bstr_t</b> object
as easily as you would use a <b>CString</b> object. One object that isn't provided,
however, is the <b>&amp; &quot;address of&quot;</b> operator, so you cannot pass the
address of a <b>_bstr_t</b> object to a function that expects a <b>BSTR*</b>
object.</p>


<A NAME="385"><H3>_variant_t</H3></A>

<p>A <b>_variant_t</b> object is a thin wrapper for the <b>VARIANT</b> data type. The
class manages creation and destruction of an encapsulated <b>VARIANT</b> through
internal calls to the API functions <b>VariantInit()</b> and <b>VariantClear()</b>. A
_<b>variant_t</b> object provides constructors and operators that allow easy creation
and manipulation of a <b>VARIANT</b>.</p>


<A NAME="386"><H3>_com_error</H3></A>

<p>A <b>_com_error</b> object represents a COM exception condition and encapsulates 
the HRESULT code returned by nearly all COM interface methods. A <b>
_com_error</b> object can be thrown by the <b>_com_raise_error()</b> function. For more
information on <b>_com_error</b>, see <a href="ch13c.htm#480">Lesson 2</a> of Chapter 13.</p>


<A NAME="387"><H3>Import Directive</H3></A>

<p>The #import preprocessor directive enables you to generate C++ header information 
about the COM object and its interfaces from a type library. This is very
useful if you don't have access to the MIDL-generated header files; the type
library is nearly always available because it is usually bound to the server DLL or EXE
file. The #import preprocessor also generates a set of smart pointers that enable you
to access the COM object interfaces.</p>

<p>When you use #import<b>,</b> the Visual Studio C compiler preprocessor creates two
header files that reconstruct the type library contents as C++ source code. The primary
header file is similar to that produced by MIDL in that it defines C++ functions that
can be used to call methods of the interface exposed by the COM object. However, it
also declares additional functions that wrap the direct interface methods to provide
properties and methods similar to those expected by a Visual Basic client. Properties
can be accessed as member variables of the class, and the methods are wrapped so that
an <i>[out, retval]</i> parameter is passed back as a return value. The HRESULT value 
is intercepted&#8212;if it reports an error
condition, it is thrown as a <b>_com_error</b> exception. The <b>_bstr_t</b> and <b>
_variant_t</b> classes are used as argument types and return types for these wrapper
functions wherever it is appropriate.</p>

<p>The primary header file has the same name as the type library or the dynamic link
library, with a .tlh extension. The secondary header file has the same name as the type
library, with a .tli extension. The secondary header file contains the implementations
for compiler-generated wrapper functions, and is included (using #include) in the
primary header file.</p>

<p>Both header files are placed in the output directory. They are read and compiled by
the compiler as if the primary header file was named by a #include directive.</p>

<p>The primary type library header file includes smart pointer declarations for the
interfaces exposed by the COM object. The <b>_COM_SMARTPTR_TYPEDEF</b> macro is used to
instantiate a <b>_com_ptr_t</b> template for every interface defined in the type
library. The file comdef.h, which contains the definitions of the compiler support
classes, is included in the .tlh file.</p>

<p>In the following exercise, you will learn how to use the #import directive to import
a type library, and how to use the generated smart pointer types and wrapper functions
in your client application code. You will modify the EncodeHello application that you
created earlier in this chapter.</p>

<p><li><b> To import the EncodeServer type library</b></li></p>

<ol>

<p><li> Return to the EncodeHello project. In FileView, locate and open the StdAfx.h
file.</li></p>

<p><li> Just before the //{{AFX_INSERT_LOCATION}} comment, add a line similar to the
following:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#import &quot;C:\EncodeServer\Debug\EncodeServer.dll&quot; no_namespace</pre>
</td></tr>
</table>
</p>

<p>Make sure that you type the correct path to the EncodeServer.dll file. It will
probably be different on your computer from the one shown above. You should specify the
<b>no_namespace</b> attribute. This ensures that the classes generated from the type
library will be defined within the global namespace.</p>

<p><li> Save and close the StdAfx.h file. In FileView, right-click the <b>StdAfx.cpp</b>
file, and click <b>Compile StdAfx.cpp</b> on the shortcut menu.</li></p>

<p><li> When the compilation is complete, locate the files EncodeServer.tlh and
EncodeServer.tli in the EncodeServer\Debug folder. Inspect the contents of the .tlh
file. Note the declaration of the <b>IEncoderPtr</b> smart pointer provided by the
following line:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>_COM_SMARTPTR_TYPEDEF(IEncoder, __uuidof(IEncoder));</pre>
</td></tr>
</table>
</p>

<p>Also note the following member functions declared within the <b>IEncoder</b>
structure definition:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>// Property data
__declspec(property(get=GetKey,put=PutKey))
short Key;

   // Wrapper methods for error-handling
   _bstr_t EncodeString (_bstr_t instring);
   short GetKey ();
   void PutKey (short pVal);

   // Raw methods provided by interface
   virtual HRESULT __stdcall raw_EncodeString (BSTR instring, BSTR * 
      outstring) = 0;
   virtual HRESULT __stdcall get_Key (short * pVal) = 0;
   virtual HRESULT __stdcall put_Key (short pVal) = 0;</pre>
</td></tr>
</table>
</p>

</ol>

<p>The &quot;raw&quot; methods at the bottom are similar to those in the EncodeServer.h
file generated by the MIDL compiler. The wrapper methods, however, look much more like
the kind of member functions provided by a regular C++ class. Note that the declaration
of the Key member variable uses the <i>__declspec(property)</i> declarator. This allows
the user of the class to access the <b>Get</b> and <b>Put</b> functions by using the
Key variable on the left and right sides of an assignment statement. Also note that
these functions use the <b>_bstr_t</b> class for argument types and return values.</p>

<p>The implementation of the wrapper functions can be found in the EncodeServer.tli
file. The implementation of the <b>GetKey()</b> function, which follows, demonstrates 
how an <i>[out, retval]</i> parameter is passed back as a
return value and the HRESULT value is intercepted and potentially thrown as an
exception.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>inline short IEncoder::GetKey () 
{
   short _result;
   HRESULT _hr = get_Key(&amp;_result);
   if (FAILED(_hr)) _com_issue_errorex(_hr, this, __uuidof(this));
   return _result;
}</pre>
</td></tr>
</table>
</p>

<p>Now that you have imported the type library, you can alter the application code to
take advantage of the classes generated by importing the type library.</p>

<p><li> <b> To alter the EncodeHello application code</b></li></p>

<ol>

<p><li> Remove the following <b>#include</b> directives from the top of the
EncodeHello.cpp file:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#include &quot;EncodeServer.h&quot;
#include &quot;EncodeServer_i.c&quot;</pre>
</td></tr>
</table>
</p>

<p><li> Re-implement the <b>Main()</b> function of the EncodeHello application as follows:</li></p>

<p>
<img src="images/cd.gif" width=45 height=45 border="0">
</p>

<p>(This code can be found in CH10_02.cpp, installed from the companion CD.)</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>int main(int argc, char* argv[])
{
    CoInitialize(NULL);
    {
        IEncoderPtr pServer;

        HRESULT hr = pServer.CreateInstance(__uuidof(Encoder));

        if(SUCCEEDED(hr))
        {
            short nKey = 1;
            cout &lt;&lt; &quot;Enter a code key between -5 and 5: &quot;;
            cin &gt;&gt; nKey;

            _bstr_t bstrHello = &quot;Hello World!&quot;;
            _bstr_t bstrCodedHello;

            try
            {
               pServer-&gt;Key = nKey;
               bstrCodedHello = pServer-&gt;EncodeString(bstrHello);
			   
	       cout &lt;&lt; &quot;\n&quot; &lt;&lt; (const char *) 
               bstrCodedHello &lt;&lt; &quot;\n\n&quot;;
             }
             catch(_com_error e)
             {
               cout &lt;&lt; e.ErrorMessage() &lt;&lt; &quot;\n\n&quot;;
             }
        }
   }
   ::CoUninitialize();

   return 0;
}</pre>
</td></tr>
</table>
</p>

</ol>

<p>Note that in this example, the application code is placed within its own code block
between the calls to <b>CoInitialize()</b> and <b>CoUninitialize()</b>. This
ensures that the <i>pServer</i> variable goes out of scope before the <b>CoUninitialize()</b>
function is called to close the COM libraries. When <i>pServer</i> goes out of scope,
the <b>_com_ptr_t</b> destructor calls the <b>Release()</b> method on the encapsulated
<b>IEncoder</b> pointer. If this occurs <i>after</i> the COM libraries have been
closed, disaster will ensue.</p>

<p>Notice that this code is much easier to read than the previous version, and that it
closely resembles regular C++ code that does not use COM. Don't be fooled by
appearances, however&#8212;it is impossible to write efficient, error-free COM code
without a thorough understanding of the underlying technology.</p>


<A NAME="388"><H2>Lesson Summary</H2></A>

<p>The MIDL compiler generates header files that make a COM server's interface and
GUID definitions available to C and C++ client application source code. These files
define structures that can be used to access the interface methods of the instantiated
COM objects. Readable definitions of GUIDs are also provided.</p>

<p>Visual C++ COM compiler support provides the <b>#import</b> statement, which allows you
to generate C++ header information about the COM object and its
interfaces from a type library. The generated files make extensive use of the <b>
_com_ptr_t</b> smart pointer class, the <b>_com_error</b> exception class, and other
Microsoft-specific C++ language extensions to wrap the COM interface methods and
simplify client development. The <b>_bstr_t</b> and <b>_variant_t</b> classes simplify
the use of <b>BSTR</b> and <b>VARIANT</b> data types.</p>


</BODY>
</HTML>







