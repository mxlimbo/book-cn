<HTML>
<HEAD>
<TITLE>Lesson 2: Interface Marshaling</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch08b.htm", "ch08d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="320"><H1>Lesson 2: Interface Marshaling</H1></A>

<p>COM servers are not required to load into the same process as the client that makes
use of their services. The client and the server do not even have to reside on the same
computer. This has implications for the way that data is passed
between client and server. You have to ensure that when a COM client calls a method,
the COM server will receive the parameters in a format that it can understand, no
matter where the server is running, or on which platform.</p>

<p>The transferring of data across process boundaries is called <i>marshaling</i>. In
this lesson, you will learn about the different ways in which COM components marshal
data passed to and from methods defined by the component interfaces.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>

<ul>
<p><li>Describe the different execution contexts in which COM components can be
run.</li></p>

<p><li>Describe the different techniques that can be used to marshal your
interfaces.</li></p>
</ul>

<b>Estimated lesson time: 30 minutes</b>
</blockquote></div>
</p>

<A NAME="321"><H2>Component Execution Contexts</H2></A>

<p>A COM component can be run in one of three ways&#8212;as an in-process server, as an
out-of-process server, or as a remote server. Figure 8.8 
summarizes the characteristics and implementations of using each of these execution
environments.</p>

<p>An in-process COM server is implemented as a DLL, and executes within the same
process address space as the object's client application. Since the COM object
resides in the same address space, your COM server responds more quickly than either an
out-of-process server or a remote server can. In-process servers can be developed more
quickly since you have less code to implement. However, with this server, you must
register a copy of the COM object on every computer on which you intend to run the
client application.</p>

<p>Out-of-process COM servers are implemented as .exe files that reside on the same
computer as the client application, but execute in a different process address space.
As a result, you have to ensure that the arguments passed to a method transfer
correctly across process boundaries&#8212;that is to say, you have to marshal your
interfaces. Since you have to write some extra code to accomplish the marshaling of
interfaces, your COM object is going to take a little more time to respond to method
calls. Developing the extra code to pass arguments across process boundaries does
require a bit more coding. Since the COM object executes on the same computer as the
application client, you must also store and register a copy of the COM object on every
client computer.</p>

<p>
<A HREF="javascript:fullSize('f08DA08x.htm')"> <img src="images/f08DA08.jpg" width=404 height=400 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 8.8</b> <i>Execution contexts for COM objects</i><!-- /caption -->
</p>

<p>You can also implement your out-of-process COM object so it executes on a
remote computer. This kind of object is known as a <i>remote server</i>. In this case,
you transmit from the client computer to the server computer across a network. Response
times for executing server methods are considerably longer. Executing a method across a
network connection is a non-deterministic process. Every
time you invoke a remote method, even if it is the same method, your client application
experiences a different response time. If the network is clogged with traffic, your
client application may experience longer response times. The code that you generate to
support marshaling of method arguments for a local server also supports marshaling of
method arguments for a remote server. If you use a remote server, then you need to have
only a single copy of the server loaded and registered on the server computer. Many
remote clients can use this single COM server copy. Since only one server exists,
updating the behavior of the COM component is a relatively painless, low-effort
process.</p>

<A NAME="322"><H2>Marshaling Technologies</H2></A>

<p>The act of marshaling data between a client and a server is a key issue when
implementing a COM object or server. Depending upon the relationship between the client
and the server, you use different programming technologies to marshal data for method
calls between a client application and a COM server.</p>

<p>Table 8.1 identifies the programming technologies employed to perform
marshaling of data for method calls on a COM object, and also shows the
types of marshaling, the boundaries across which you marshal the data, and the specific
approach for marshaling the data.</p>

<p><b>Table 8.1</b> <i>Marshaling Technologies for Data Transfer to COM Objects</i></p>

<p>
	<table valign="top" cellpadding="5" width="95%">

		<tr>
			<th>Type of marshaling</th>
			<th>Boundaries</th>
			<th>Approach</th>
		</tr>

		<tr>
			<td valign="top">No marshaling</td>
			<td valign="top">DLL</td>
			<td valign="top">Global addressing</td>
		</tr>
<tr>
	<td valign="top">Standard marshaling</td>
	<td valign="top">Process</td>
	<td valign="top">Interface Definition Language</td>
</tr>
<tr>
	<td valign="top">Automation marshaling</td>
	<td valign="top">Programming language</td>
	<td valign="top">Automation marshaler</td>
</tr>
<tr>
	<td valign="top">Custom marshaling</td>
	<td valign="top">Process</td>
	<td valign="top">Special software, protocol</td>
</tr>

	</table>
</p>

<p>When you host your COM object as an in-process server, you package the COM object in
a DLL, which means that the COM object loads into the process space of the client. All
of the COM object's methods can be called directly by the client, and data can be
passed freely to and from the object.</p>

<A NAME="323"><H3>Standard Marshaling</H3></A>

<p>When a client calls interface methods from a COM component hosted on a local or a
remote server, data is transferred across process boundaries or between computer nodes
on a network. To accomplish this transfer, you must implement marshaling code to ensure
that the client and server know how to communicate. Visual C++ provides a
utility&#8212;the <i>MIDL compiler</i>&#8212;that enables you to produce a DLL that
implements standard marshaling between an out-of-process object and its client. To
implement standard marshaling, you specify your interfaces using the Interface
Definition Language (IDL). IDL is a strongly typed language, similar to Visual C++ in
its syntax, that allows you to define your interfaces precisely.</p>

<p>The MIDL compiler compiles your IDL code and generates C source code that implements
two components, a proxy and a stub. The proxy attaches to the client application, and
the COM server uses the stub. You compile this code to create a <i>proxy/stub DLL</i>,
which is used by COM to handle the mechanics of moving data between the client
application and the COM server across process or computer boundaries.</p>

<A NAME="324"><H3>Using the Automation Marshaler</H3></A>

<p>The Automation marshaler is a COM server (oleaut32.dll) that provides marshaling
services for the COM-based technology known as Automation (formerly known as OLE
Automation). Automation allows client code written in languages other than C++ to
access COM components. Automation is implemented by
the COM interface <b>IDispatch</b>, which is discussed in greater detail in the next
lesson. To use the Automation marshaler, you do not have to implement a dispatch
interface. You can specify that your component interfaces use the Automation marshaler
by defining them with the IDL attribute <b>oleautomation</b>, as shown in the following
code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>[
    oleautomation,
    object,
    uuid(A84DA762-6486-11D3-9347-0080C7FA0C3E),

    helpstring(&quot;IHello Interface&quot;),
    pointer_default(unique)
]
interface IHello : IUnknown
{
    [propget, helpstring(&quot;property String&quot;)] HRESULT 
    String([out, retval] BSTR *pVal);
};</pre>
</td></tr>
</table>
</p>

<p>To make communication available between different languages, Automation
defines a standard set of data types that can be packaged into a union data structure
called a <b>VARIANT</b>. When you use the Automation marshaler, you must use
Automation-compatible data types. The <b>BSTR</b> data type used in the previous code
snippet is a string type used by Automation.</p>

<p>The Automation marshaler is not as efficient as the standard marshaling code
generated by MIDL.</p>

<A NAME="325"><H3>Custom Marshaling</H3></A>

<p>In some cases, standard marshaling may not be appropriate for an application. In
such cases, a server object can provide support for custom marshaling.</p>

<p>To support custom marshaling, your server should implement the <b>IMarshal</b>
interface. When a server supports custom marshaling, it does not use the standard
marshaling infrastructure. Instead, COM requests that the server object form a packet,
containing the data to be marshaled, and transmit the packet to the client context. COM
instantiates an object-specified handler to receive the packet and act as a smart proxy
to the client. The smart proxy unmarshals the packet to the client.</p>

<p>Communication can now occur across process boundaries just as with standard
marshaling. The client is never aware that custom marshaling (or any form of
marshaling) is occurring.</p>

<p>In general, marshaling is not an issue for developers of COM objects. MIDL generates
marshaling code for standard COM interfaces, and the Automation marshaler provides
marshaling for objects that implement dispatch interfaces. However, there are times
when you may have specific reasons to enable an
object to support custom marshaling, which include the following:</p>

<ul>
<p><li><b>Shared memory</b> Standard marshaling always copies data back and forth 
between client and server. By using custom marshaling, you can create shared memory
that both the client and server can use to avoid repeated copies of data and improve
performance.</li></p>

<p><li><b>Marshaling by value</b> Marshaling by value instead of by reference enables
you to make copies of objects locally so that all subsequent calls are local.</li></p>

<p><li><b>Smart proxy</b> Depending on the state of an internal cache, a proxy can make
an intelligent decision about whether or not to go remote. Some methods 
can be implemented directly by the proxy to avoid making calls on the server. A
smart proxy can also boost performance by enabling asynchronous calls. To allow for
asynchronous calls, a smart proxy can create a new thread to make the call, and then
let the calling thread return while the server is processing the call.</li></p>

<p><li><b>Bypassing native COM threading models</b> You may not want to be bound by the
standard threading models. For a discussion of COM threading models, see <a href="ch08e.htm#333">Lesson 4 </a>of
this chapter.</li></p>
</ul>


<A NAME="326"><H2>Lesson Summary</H2></A>

<p>Every COM object executes within a specific context. In-process servers execute with
the process address space of the client application. When you perform method calls from
client to server, you marshal these calls from the client context to the server
context. Standard marshaling consists of using an interface definition language and the
MIDL compiler to generate a proxy/stub DLL to perform marshaling from a client in one
process to a server in another process. Marshaling across languages employs the
Automation marshaler. When you use the Automation marshaler you must use
Automation-compatible data types. By implementing the <b>IMarshal</b> interface, you
can create a custom marshaling mechanism to meet program-specific needs.</p>

</BODY>
</HTML>







