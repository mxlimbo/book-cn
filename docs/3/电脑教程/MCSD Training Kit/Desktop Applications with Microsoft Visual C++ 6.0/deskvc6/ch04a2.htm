<html>
<head>
<title>Lesson 1: Windows Application User Interfaces</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04a.htm", "ch04b.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="151"><H1>Lesson 1: Windows Application User Interfaces</H1></A>

<p>In this lesson, you will explore elements of the user interface that are created for
you when you generate a document/view-based application using the MFC AppWizard. You
will learn how to use the Microsoft Visual C++ resource editors to edit standard
interface features to suit your own requirements, how to handle user menu or toolbar
selections, and how to update the interface to communicate information to the user.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<ul>
<p><li> Describe the icons that you are required to supply for a program that meets the
Microsoft Windows 98 or Microsoft Windows NT logo requirements, and how to use the
graphics editor to design icons.</li></p>
<p><li> Describe how to edit menus and toolbars.</li></p>
<p><li> Describe how to implement accelerator keys for menu and toolbar commands.</li></p>
<p><li> Describe how to add code to handle menu or toolbar selections.</li></p>
<p><li> Describe how to dynamically update the appearance of menu and toolbar
commands.</li></p>
<p><li> Describe how to write to the status bar.</li></p>
</ul>
<b>Estimated lesson time: 50 minutes</b>
</blockquote></div>
</p>


<A NAME="152"><H2>Application and Document Icons</H2></A>

<p>An application that meets the Windows 98 or Windows NT logo requirements must define
standard (32x32 pixels) and small (16x16 pixels) icons for both the application and the
document type. Icons are application resources that are associated with Windows icon
(.ico) files. The MFC application framework automatically defines default icon
resources and creates icon files for you.</p>

<p>All application resources such as icons, menu commands, dialog boxes, controls, and
so on have a unique numeric identifier known as a <i>resource ID</i>. The resource.h
file defines memorable names to correspond to these IDs.</p>

<p>Figure 4.1 illustrates the icons, resource IDs, and icon files that are created for
the MyApp sample application.</p>

<p>
<A HREF="javascript:fullSize('f04DA01x.htm')"> <img src="images/f04DA01.jpg" width=404 height=142 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 4.1</b> <i>MFC default icons</i><!-- /caption -->
</p>

<p>Your program's application object calls <b>CWinApp::RegisterShellFileTypes()</b>
to register the icons with the Windows file manager when the program starts.</p>

<A NAME="153"><H3>The Graphics Editor</H3></A>

<p>The graphics editor supplied with Visual C++ has an extensive set of tools for
drawing images. In addition to creating and editing images in bitmap (.bmp) format,
you can edit .gif or .jpg images, and convert .gif or .jpg images to bitmaps.</p>

<p>To access the graphics editor, open a graphical resource by double-clicking an
object in ResourceView. This allows you to access the special features that support
icon files and toolbar bitmaps. Figure 4.2 shows the graphics editor opened to edit the
standard-sized default document icon.</p>

<p>
<A HREF="javascript:fullSize('F04DA02x.htm')"> <img src="images/F04DA02.JPG" width=404 height=262 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure. 4.2</b>  <i>The graphics editor</i><!-- /caption -->
</p>

<p><li><b>To edit the default icons</b></li></p>
<ol>
<p><li> Return to the MyApp project you modified in <A HREF="ch03a.htm">Chapter 3</A>.</li></p>
<p><li> In <b>ResourceView</b>, expand MyApp Resources.</li></p>
<p><li> Expand the Icon folder.</li></p>
<p><li> Double-click the <b>IDR_MAINFRAME</b> object to open the icon in the graphics editor.</li></p>
</ol>

<p>Experiment with the drawing features of the graphics editor. Note that you can
switch between the Standard (32x32) icon format and the Small (16x16) icon format using
the <b>Device</b> list in the upper left corner of the editor pane.</p>

<p>You can use <b>New Device Image</b> to create icons in other device formats. The
graphics editor provides different pencil and brush styles, area fill, and text tools;
it also allows you to select an area of your icon to move, resize, or copy
to the clipboard.</p>

<p>If you are feeling creative, you might like to design your own icons for the MyApp
application. The easiest way to do this is to edit the existing icons,
leaving their resource IDs as they are. When you build the application, your changes to
the .ico files will be saved.</p>

<A NAME="154"><H2>Editing Application Menus</H2></A>

<p>Menus offer a convenient and consistent way for you to group commands, and an easy
way for users to access them. An application generated by the MFC AppWizard will
generally include a main menu resource appropriate to the
options selected by the developer. Figure 4.3 depicts a typical menu generated for an
SDI application and illustrates the elements of a menu interface.</p>

<p>
<img src="images/f04DA03.jpg" width=207 height=265>
</p><p>
<!-- caption --><b>Figure 4.3</b> <i>SDI application menu</i><!-- /caption -->
</p>

<p>The menu as a whole is created with a resource ID of <b>IDR_MAINFRAME</b>. You will
recognize that this is the same ID as the application icon that you read about in
<A HREF="ch03a.htm">Chapter 3</A>. When a document template object is created, it is associated with a resource
ID that specifies a group of resources to be used by the document type. These might
include menu, toolbar, icon, accelerator table, and string resources.</p>

<p>Using the menu editor supplied with Visual C++ (shown in Figure 4.4), you can
visually construct a menu and edit the properties of the menu commands.</p>

<p>
<img src="images/f04DA04.jpg" width=380 height=265>
</p><p>
<!-- caption --><b>Figure 4.4</b> <i>The menu editor</i><!-- /caption -->
</p>

<p>In the following exercises, you will learn how to add and remove menus, and you will
add menu commands to the MyApp application menus. You'll start by removing the
standard <b>Edit</b> menu that is depicted in Figure 4.4. You would want to do this if
your application was not going to support the selection of objects in the view, or the
<b>Cut</b>, <b>Copy</b>, and <b>Paste</b> commands that work on selected objects. In its place, you will add a new menu&#8212;the <b>Data</b> menu. The <b>Data</b>
menu will contain commands that will allow the user to connect to a remote database,
and to upload application data. You will add two commands to the menu: the <b>
Connect</b> command and the <b>Upload</b> command.</p>

<p><li><b>To remove the Edit menu</b></li></p>

<ol>
<p><li> In the MyApp project, click the <b>ResourceView</b> tab and expand the MyApp
Resources folder.</li></p>
<p><li> Expand the Menu folder.</li></p>
<p><li> Double-click the <b>IDR_MAINFRAME</b> menu resource to open the menu
editor.</li></p>
<p><li> Click <b>Edit</b> on the menu bar and then press DELETE. Click <b>OK</b> to
confirm the deletion of the <b>Edit</b> menu.</li></p>
</ol>

<p><li> <b>To add the Data menu</b></li></p>
<ol>
<p><li> Click the blank menu command to the immediate right of the <b>Help</b>
menu.</li></p>
<p><li> Drag the blank command to place it between the <b>File</b> and <b>View</b>
menus.</li></p>
<p><li> Double-click the blank menu command to display its properties. Type <b>
&amp;Data</b> as the <b>Caption</b> property. The ampersand (<b>&amp;</b>) has the
effect of designating the character following it as an access key. An access key is
used to select the menu using the keyboard. By preceding the &quot;D&quot; in Data with
an ampersand, users can select the <b>Data</b> menu by pressing ALT+D.</li></p>
</ol>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
If you want to include the ampersand character in a menu name,
use two ampersands as in: &quot;Mutt &amp;&amp; Jeff&quot;. This would result in the
menu name &quot;Mutt &amp; Jeff&quot;.</blockquote></div>
</p>

<p><li><b>To add the Connect command to the Data menu</b></li></p>
<ol>
<p><li> If the <b>Data</b> menu is not already selected, click <b>Data</b>.</li></p>
<p><li> Click the blank command under the <b>Data</b> menu title.</li></p>
<p><li> Type the string <b>&amp;Connect&#8230;\tCTRL+C</b>.</li></p>

<ul>
<p><li> <b>\t</b> is the tab character.</li></p>
<p><li> <b>CTRL+C</b> denotes the shortcut key you will assign to this menu command in a
following exercise.</li></p>
</ul>

<p><li> As you start typing, the <b>Menu Item Properties</b> dialog box will appear. In
the <b>Prompt</b> box, type <b>Connect to database</b>. This is the text to display on
the status bar when the command is selected.</li></p>
<p><li> Click the thumbtack icon in the upper-left corner of the <b>Menu Item
Properties</b> dialog box. This will keep the dialog box open while you move between
different menu commands.</li></p>
<p><li> Click another command, and then click <b>Connect</b> again. The dialog box for
the <b>Import</b> command should now look as it does in Figure 4.5.</li></p>

<p>
<img src="images/f04DA05.jpg" width=403 height=162>
</p><p>
<!-- caption --><b>Figure 4.5</b> <i>The <b>Menu Item Properties</b> dialog box</i><!-- /caption -->
</p>

<p><li> Notice that the editor has constructed the <b>ID_DATA_CONNECT</b> command ID by
appending the command name to the menu name. You can change this ID if you want, but
generally you just accept the default.</li></p>
</ol>

<p>Each selectable menu command (everything but menu titles or separator bars)
is associated with an ID that allows it to be mapped to a handler function. Remember
that when a menu command is selected, the framework generates a WM_COMMAND message,
which is handled by one of the application objects. This message takes the menu
command's command ID as a parameter. You will learn how to associate the command ID
with a handler function later in this chapter in the section <i><a href="ch04a.htm#157">Handling Menu and Toolbar Selections</a></i>.</p>

<p><li><b>To add the Upload command to the Data menu</b></li></p>

<p>Following the steps just described, add another command to <b>Data</b> menu. This
command caption should be <b>&amp;Upload&#8230;\tCTRL+U</b>, and the prompt string
should be <b>Upload data to the database</b>. Allow the menu editor to generate the
command ID <b>ID_DATA_UPLOAD</b>.</p>

<A NAME="155"><H2>Adding Shortcut Keys</H2></A>

<p>You will remember that the captions for commands in the <b>Data</b> menu referred to
keys that could be used as shortcut keys&#8212;namely, CTRL+C for the <b>Connect</b>
command and CTRL+U for the <b>Upload</b> command. Shortcut keys are used as keyboard
shortcuts for program commands that are also available on a menu or toolbar, though you
can also define key combinations for commands that don't have a user-interface
object associated with them.</p>

<p>Shortcut keys, or <i>accelerator keys</i> as they were once known, are defined
in an <i>accelerator table</i>, a Windows resource that contains a list of the defined
keys and the command identifiers that are associated with them. The accelerator table
can be edited by using the accelerator editor (shown in Figure 4.6).</p>

<p>
<A HREF="javascript:fullSize('f04DA06x.htm')"> <img src="images/f04DA06.jpg" width=404 height=259 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 4.6</b> <i>The accelerator editor</i><!-- /caption -->
</p>

<p>In this exercise, you will add the CTRL+C and CTRL+U key combinations to the
application's accelerator table using the accelerator editor.</p>

<p><li><b>To define a shortcut key</b></li></p>
<ol>
<p><li> In ResourceView, expand the Accelerator folder.</li></p>
<p><li> Double-click the <b>IDR_MAINFRAME</b> accelerator resource to open the
accelerator editor.</li></p>

<p>Notice that the CTRL+C shortcut key is already defined for the <b>ID_EDIT_ COPY</b>
command ID. To change the association, double-click the <b>CTRL+C</b> entry at the top
of the table.</p>

<p><li> In the <b>Accel Properties</b> dialog box, select <b>ID_DATA_CONNECT</b> from
the <b>ID</b> list. Close the <b>Accel Properties</b> dialog box to update the ID.</li></p>
<p><li> To add a new shortcut key, double-click the blank entry at the bottom of the
table. In the <b>ID</b> list, click <b>ID_DATA_UPLOAD</b>.</li></p>
<p><li> Type <b>u</b> in the <b>Key</b> box.</li></p>
<p><li> Select the <b>Ctrl</b> check box and clear the <b>Shift</b> check box. The
accelerator editor pane should look similar to the one in Figure 4.6.</li></p>
<p><li> Close the <b>Accel Properties</b> dialog box. The shortcut key is added to the
table.</li></p>
</ol>

<A NAME="156"><H2>Editing Application Toolbars</H2></A>

<p>When AppWizard generates an application, it will create a standard toolbar resource
that includes buttons that are associated with commonly used commands from the <b>
File</b> and <b>Edit</b> menus. The toolbar is one of the groups of resources that is
associated with the application's document template, and thus has the same <b>
IDR_MAINFRAME ID</b> as the application icon, accelerator, and menu resources.</p>

<p>A toolbar resource is associated with a bitmap file, which contains the button
images. The file associated with the <b>IDR_MAINFRAME</b> toolbar is named toolbar.bmp.
The framework places a copy of this file in the \Res folder beneath the project folder.
If you create additional toolbars from within ResourceView, additional bitmaps with
names that reflect the toolbar resource IDs will be created in this folder.</p>

<p>All the button images in the toolbar must be the same size, and are by default 16
pixels wide and 15 pixels high. The bitmap file contains all of the images side by side
in the order they appear in the corresponding resource definition. For this reason, it
is recommended that you edit this file using the special features of the graphics
editor, which are accessible only by double-clicking a toolbar object in the
ResourceView window. These features allow you to manipulate the bitmap in manageable,
button-sized chunks, and to maintain the relationship between buttons and command
IDs.</p>

<p>Figure 4.7 shows the graphics editor being used to edit a toolbar.</p>

<p>
<A HREF="javascript:fullSize('f04DA07x.htm')"> <img src="images/f04DA07.jpg" width=404 height=259 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 4.7</b> <i>Editing toolbars with the graphics editor</i><!-- /caption -->
</p>

<p>In this exercise, you will delete the <b>Cut</b>, <b>Copy</b>, and <b>Paste</b>
toolbar buttons.</p>

<p><li><b>To delete toolbar buttons</b></li></p>

<ol>
<p><li> In ResourceView, expand the MyApp resources.</li></p>
<p><li> Expand the Toolbar folder and double-click the <b>IDR_MAINFRAME</b> toolbar
resource to open the toolbar editor.</li></p>
<p><li> Drag the <b>Cut</b> button off the toolbar.</li></p>
<p><li> Repeat the process for the <b>Copy</b> and <b>Paste</b> buttons.</li></p>
</ol>

<p>In this exercise, you will add buttons to correspond to the <b>Connect</b> and <b>
Upload</b> commands that you added earlier.</p>

<p><li><b>To add toolbar buttons</b></li></p>

<ol>
<p><li> Click the blank button to the right of the toolbar.</li></p>
<p><li> Drag the button to the desired location on the toolbar. For this exercise, drag
it to the left of the <b>Print</b> button.</li></p>
<p><li> Use the graphics editor facilities to design the simple icon shown in Figure
4.8, which represents a connection to a database.</li></p>

<p>
<img src="images/f04DA08.jpg" width=113 height=106>
</p><p>
<!-- caption --><b>Figure 4.8</b> <i>The <b>Connect Toolbar</b> button</i><!-- /caption -->
</p>

<p><li> Press ENTER. The <b>Toolbar Button Properties</b> dialog box will appear.</li></p>
<p><li> In the <b>ID</b> list box, click <b>ID_DATA_CONNECT</b>. Click another toolbar
button to assign the new ID.</li></p>
<p><li> Click the <b>Connect</b> toolbar button to redisplay the properties. Note how
the prompt string associated with the <b>ID_DATA_CONNECT</b> command ID is now
displayed. Add the string <b>\nConnect</b> to the end of the prompt string. This is to
specify the ToolTip text for the button.</li></p>
<p><li> Repeat the previous steps to add another toolbar button for the <b>Upload</b>
command shown in Figure 4.9. Associate this button with the command
ID ID_DATA_UPLOAD, and add the string <b>\nUpload</b> to specify the ToolTip
text.</li></p>

<p>
<img src="images/f04DA09.jpg" width=111 height=105>
</p><p>
<!-- caption --><b>Figure 4.9</b> <i>The <b>Upload</b> Toolbar button</i><!-- /caption -->
</p>

<p><li> Build and run the MyApp application. Test the changes you have made to the menu
and toolbar. Notice that the commands that you have added appear dimmed. This is
because these commands do not yet have handlers associated with them. However, you are
still able to check that the prompt strings and the ToolTips display properly.</li></p>
</ol>

<A NAME="157"><H2>Handling Menu and Toolbar Selections</H2></A>

<p>In <a href="ch03d.htm#119">Lesson 3</a> of Chapter 3, you learned how to use ClassWizard to handle the command
messages that are generated when a user selects a menu or toolbar command. In the
following exercises, you will add handlers for the <b>Connect</b> and
<b>Upload</b> commands.</p>

<p>The command routing feature of the MFC application framework allows you to define
class handlers inside the class most closely associated with the handler function. You
might decide that a connection to a remote database is best conceived as a feature of
the application as a whole, in which case you would consider handling the <b>
Connect</b> command in your <b>CMyAppApp</b> application class.</p>

<p>In this case, the <b>Connect</b> command handler function would contain code to
locate and connect to a remote database. You would probably want to record the current
state of the database connection in a Boolean variable so that the application would
always be able to tell whether there was a live connection to the database. This
variable would be set to TRUE after a successful connection to the database and set to
FALSE after disconnection or if the connection failed.
For the purposes of our example, you will not need to implement the database
connection code. Instead, you will simulate connection and disconnection by creating
the Boolean variable m_isDatabaseConnected as a member of the <b>CMyAppApp</b> class.
The <b>Connect command</b> function will then switch the variable between TRUE and
FALSE.</p>

<p><li><b>To add the m_isDatabaseConnected member to the CMyAppApp class</b></li></p>

<ol>
<p><li> On the <b>ClassView</b> tab, right-click the <b>CMyAppApp</b> class icon.</li></p>
<p><li> On the shortcut menu, click <b>Add Member Variable</b>.</li></p>
<p><li> In the <b>Add Member Variable</b> dialog box, type <b>BOOL</b> in the <b>
Variable Type</b> box.</li></p>
<p><li> Type <b>m_isDatabaseConnected</b> into the <b>Variable Name</b> text box.</li></p>
<p><li> Ensure that the <b>Public</b> <b>Access</b> option is set. Click <b>OK</b> to
add the variable. You can see the new variable by expanding the <b>CMyAppApp</b>
class.</li></p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
When developing MFC code, we will use the MFC-defined BOOL type (an
integer type) rather than the C++ built-in bool type. This is to maintain compatibility
with the MFC functions, which predate the adoption of the bool type as an ANSI standard
and use the BOOL type for Boolean parameters and return values.
</blockquote></div>
</p>

<p><li> Double-click the <b>CMyAppApp</b> class constructor icon to edit the constructor
code.</li></p>
<p><li> Add the following line of code to the body of the constructor (inside the
opening and closing braces) to initialize the m_isDatabaseConnected variable:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>m_isDatabaseConnected = FALSE;</pre>
</td></tr>
</table>
</p>
</ol>

<p>In this exercise, you will add a function to handle the <b>Connect</b> command.</p>

<p><li><b>To add the OnDataConnect() handler function to the CMyAppApp class</b></li></p>

<ol>
<p><li> From within the MyApp project, press CTRL+W to open ClassWizard. Click the <b>
Message Maps</b> tab and do the following:</li></p>

<ul>
<p><li> In the <b>Class Name</b> list, click <b>CMyAppApp</b>.</li></p>
<p><li> In the <b>Object IDs</b> list, click <b>ID_DATA_CONNECT</b>.</li></p>
<p><li> In the <b>Messages</b> list, click <b>COMMAND</b>.</li></p>
</ul>

<p><li> Click <b>Add Function</b>. A dialog box appears and suggests the name <b>
OnDataConnect()</b> for your handler function. Click <b>OK</b> to accept the name.</li></p>
<p><li> Click <b>Edit Code</b>. The MyApp.cpp file is opened and the insertion point is
positioned at the top of the function implementation.</li></p>
<p><li> Replace the // TODO comment line with the following line of code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>m_isDatabaseConnected = m_isDatabaseConnected ? FALSE : TRUE;</pre>
</td></tr>
</table>
</p>
</ol>

<p>Your next task is to add a handler for the <b>Upload</b> command. The purpose of
this function is to upload the application data to the database. As application data is
contained within an application's document class, the <b>CMyAppDoc</b> class seems
to be the appropriate place for the <b>OnDataUpload()</b> function. For the purposes of
this example, all your function will do is display a message box.</p>

<p><li><b>To add the OnDataUpload() handler function to the CMyAppDoc class</b></li></p>

<ol>
<p><li> Repeat the previous steps, but this time add the <b>OnDataUpload()</b> function
to the <b>CMyAppDoc</b> class to handle the <b>ID_DATA_UPLOAD</b> command.</li></p>
<p><li> When editing the <b>OnDataUpload</b> function, replace the // TODO comment line
with the following code:</li></p>
<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>AfxMessageBox(&quot;Upload successfully completed&quot;);</pre>
</td></tr>
</table>
</p>
<p><li> Build and run the MyApp application.</li></p>
<p><li> Now that you have added handlers, the new menu and toolbar commands are
available. The <b>Connect</b> command will have no effect yet, but the <b>Upload</b>
command displays a message box.</li></p>
</ol>

<A NAME="158"><H2>Dynamically Updating Menu and Toolbar Commands</H2></A>

<p>Even if we had provided full implementations of the <b>OnDataConnect()</b> and the
<b>OnDataUpload()</b> functions, in terms of logical design, the user interface as it
stands would still need adjustments. Consider the following points:</p>

<ul>
<p><li> We have no indication of the current state of the data connection&#8212;whether
the database is connected or disconnected. Thus we do not know what the effect of our
selecting the <b>Connect</b> command will be.</li></p>
<p><li> The <b>Upload</b> command, the purpose of which is to upload application data to
a remote database, depends on the existence of a current live connection to the
database. As the program stands, a user can select the <b>Upload</b> command when there
is no connection, a situation in which the upload is bound to fail.</li></p>
<p><li> Menu and toolbar commands often need to be updated to convey the state of the
application to the user. If a menu command or a toolbar button switches between on and
off states, the command should be &quot;checked&quot; to indicate the on state. You can
arrange menu commands and toolbar buttons into what are known as <i>radio groups</i>.
In a radio group, only one of the group buttons can be selected at a time. The act of
selecting a radio button automatically de-selects any other selected buttons in the
group.</li></p>
<p><li> Menu commands and toolbar buttons that cannot perform any useful func-tion within
the current state of the application should be made unavailable. For example, an option
that allows you to upload data to a remote database should be unavailable when the
remote database is offline.</li></p>
<p><li> It is possible to change the text of a menu command according to the application
context. You should use this option carefully, as it is generally confusing for the
user to have menu command captions changing in the middle of a program.</li></p>
</ul>


<p>The MFC application framework provides us with an easy way to update the
appearance and status of menu commands and toolbar buttons by allowing us to provide
handler functions for user-interface update command messages.</p>

<A NAME="159"><H3>User Interface Update Command Handlers</H3></A>

<p>You will recall from the discussion of MFC message handling in <A HREF="ch03a.htm">Chapter 3</A> that the
application framework generates user-interface update command messages, which signal
the application to update the status of user-interface elements. When this occurs, the
message maps of command target objects in the command routing are searched for
ON_UPDATE_COMMAND_UI entries, which associate command IDs with update handler
functions. This process occurs for shortcut menus as they are opened, and for toolbar
buttons during application idle time.</p>

<p>You can create user interface update handler functions to modify the appearance of
menu commands and toolbar buttons. The framework passes the functions a single
parameter&#8212;a pointer to a <b>CCmdUI</b> object. The <b>CCmdUI</b> class gives
access to the user-interface element associated with the handler and allows you to
update a menu command or toolbar button using one of the member functions described in
Table 4.1.</p>

<p><b>Table 4.1</b> <i>CCmd UT Member Functions</i></p>

<p>
<table valign="top" cellpadding="5" width="95%">
<tr><th>Function</th><th>Purpose</th></tr>
<tr><td valign="top">Enable</td><td valign="top">When set to TRUE, makes a menu command or toolbar button available. When set
to FALSE, makes a menu command unavail- able. Unavailable commands are dimmed.</td></tr>
<tr><td valign="top">SetCheck</td><td valign="top">When set to TRUE, places a check mark next to a menu command and makes
toolbar buttons available. When set to FALSE, removes
 the check mark from a menu command and makes toolbar buttons
 unavailable.</td></tr>
<tr><td valign="top">SetRadio</td><td valign="top">Works like <b>SetCheck</b>, except that it operates on user-interface
commands acting as part of a radio group. Clearing the other commands in the group is not automatic unless the commands themselves maintain the radio-group behavior.</td></tr>
<tr><td valign="top">SetText</td><td valign="top">Sets the text of the user-interface command. Has no effect on toolbar
buttons.</td></tr>
</table>
</p>

<p>In the following exercises, you will add user-interface update command handlers to
the <b>CMyAppApp</b> class to modify the status of the <b>Connect</b> and <b>Upload</b>
commands and the corresponding toolbar buttons.</p>

<p><li><b>To add the OnUpdateDataConnect() handler function to the CMyAppApp class</b></li></p>
<ol>
<p><li> From within the MyApp project, press CTRL+W to open ClassWizard. Click the <b>
Message Maps</b> tab and do the following:</li></p>

<ul>
<p><li> In the <b>Class Name</b> list, click <b>CMyAppApp</b>.</li></p>
<p><li> In the <b>Object IDs</b> list, click <b>ID_DATA_CONNECT</b>.</li></p>
<p><li> In the <b>Messages</b> list, click <b>UPDATE_COMMAND_UI</b>.</li></p>
</ul>

<p><li> Click <b>Add Function</b>. A dialog box appears and suggests the name <b>
OnUpdateDataConnect()</b> for your handler function. Click <b>OK</b> to accept the
name.</li></p>
<p><li> Click <b>Edit Code</b>. The MyApp.cpp file is opened and the insertion point is
positioned at the top of the function implementation.</li></p>
<p><li> Replace the // TODO comment line with the following code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td valign="top">
<pre>pCmdUI-&gt;SetCheck(m_isDatabaseConnected);</pre>
</td></tr>
</table>
</p>


<p>A Boolean parameter is passed to the <b>SetCheck()</b> function. TRUE selects the
command and FALSE clears it. The effect of the code just added will be to provide a
visual indication as to the state of the m_isDatabaseConnected variable used to signify
a successful live connection to the database.</p>
</ol>

<p>In the next exercise, you will add the user-interface update command handler for the
<b>Update</b> command.</p>

<p><li><b>To add the OnUpdateDataUpload() handler function to the CMyAppApp class</b></li></p>

<ol>
<p><li> Repeat the steps above, but this time add the <b>OnUpdateDataUpload()</b>
function to the <b>CMyAppApp</b> class to handle the UPDATE_COMMAND_UI message for the
<b>ID_DATA_UPLOAD</b> command.</li></p>
<p><li> When editing the <b>OnUpdateDataUpload()</b> function, replace the // TODO
comment line with the following code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>pCmdUI-&gt;Enable(m_isDatabaseConnected);</pre>
</td></tr>
</table>
</p>

<p>The <b>Enable()</b> function also takes a single Boolean parameter. TRUE makes the
command available and FALSE makes it unavailable. The effect of the code will be to
make the <b>Upload</b> command available only when there is
a live connection to the database. A live connection will be signified by CMyAppApp::m_
isDatabaseConnected being set TRUE.</p>

<p><li> Build and run the MyApp program. Notice how the <b>Connect</b> menu command and
the corresponding toolbar button are affected by being selected. Note, too, how the
selection of the <b>Connect</b> command makes the <b>Upload</b> command available.</li></p>
</ol>

<A NAME="160"><H2>Writing to the Status Bar</H2></A>

<p>In some cases, simply updating menu and toolbar commands is not an adequate method
of conveying information about the status of your application. For example, consider
the MyApp example application above. As it stands, the <b>Connect</b> command simply
allows you to connect to and disconnect from a single data source. What if there were a
number of alternative data sources available and the application was often required to
switch between them?</p>

<p>In this case, you might use the <b>OnDataConnect()</b> function to display a list of
data sources from which the user can select. The connection status would need to be
displayed on the user interface either as the name of the currently selected data
source or as a string indicating that no data source is currently selected.</p>

<p>The appropriate place to display this type of information is on the
application's <i>status bar</i>. You have already seen how an MFC application uses
the status bar to display text that you supply as a menu command prompt. If you run your MyApp
application, you will see that it also displays the status of the CAPS LOCK, NUM LOCK
and SCROLL LOCK keys in separate indicator panes (indicators) on the status bar.</p>

<p>MFC support for status bars is encapsulated in the <b>CStatusBar</b> class. <b>
CStatusBar</b> allows you complete control over the number and style of status
bar indicators and the text they display.</p>

<p>The framework stores indicator information in an array with the leftmost indicator
at position 0. By default, the first indicator is &quot;elastic&quot;&#8212;it takes up
the status-bar length not used by the other indicators, so the other panes are
right-aligned. It is in this indicator that the MFC framework displays menu and toolbar
prompt strings.</p>

<p>When you create a status bar, you use an array of string IDs (which identify entries
in a string table resource) that the framework associates with the corresponding
indicators. You can then use either a string ID or an index to access an indicator.</p>

<p>The recommended way to update text on a status bar indicator is to use an
ON_UPDATE_COMMAND_UI entry in a message map to associate a user-
interface update handler function with an indicator's string ID. You can then use
the <b>SetText()</b> function of the handler's <i>CCmdUI</i> parameter to display
text in the indicator. Note that ClassWizard does not automate the association of
indicator IDs with handler functions, so you are obliged to add these message map
entries manually.</p>

<p>It is possible to update the indicator text by using the <b>
CStatusBar::SetPaneText()</b> function. Even so, you will need to create an update
handler. Without an update handler for the indicator, MFC automatically disables the
indicator, erasing its content.</p>

<p>In the exercises that follow, you will replace the MyApp default status bar
indicators for the CAPS LOCK, NUM LOCK, and SCROLL LOCK keys, with a single database
connection indicator. This indicator will display the name of the current data source,
which will be stored as a variable in the application class. If the application is
disconnected from a data source, the string &quot;Database not connected&quot; will
appear. For the purposes of this exercise, you will not implement a data source
selection routine, but simply hard-code a single name to appear.</p>

<p>In the following exercise, you will add a data member to the <b>CMyAppApp</b> class
to hold the name of the current data source.</p>

<p><li><b>To add the m_strDSN member to the CMyAppApp class</b></li></p>
<ol>
<p><li> On the <b>ClassView</b> tab, right-click the <b>CMyAppApp</b> class icon.</li></p>
<p><li> On the shortcut menu, click <b>Add Member Variable</b>.</li></p>
<p><li> In the <b>Add Member Variable</b> dialog box, type <b>CString</b> in the <b>
Variable Type</b> box.</li></p>
<p><li> Type <b>m_strDSN</b> in the <b>Variable Name</b> box.</li></p>
<p><li> Ensure that the <b>Public</b> <b>Access</b> option is set. Click <b>OK</b> to
add the variable. You should see it appear under the <b>CMyAppApp</b> class on the
MyApp classes tree.</li></p>
<p><li> Double-click the <b>CMyAppApp</b> class constructor icon to edit the
constructor code.</li></p>
<p><li> Add the following line of code to the body of the constructor to initialize the
m_strDSN variable with the name of a data source:</li></p>
<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>m_strDSN = &quot;MyDatabase&quot;;</pre>
</td></tr>
</table>
</p>
</ol>


<p>In the following exercise, you will create a string ID for the new indicator.</p>

<p><li> <b>To create the ID_INDICATOR_DB indicator ID</b></li></p>
<ol>
<p><li> In the MyApp workspace window, click the <b>ResourceView</b> tab.</li></p>
<p><li> Expand the String Table folder.</li></p>
<p><li> Double-click the <b>String Table</b> resource to open the string table
editor.</li></p>
<p><li> Locate the string IDs that represent the indicators. Each of these IDs begins
with <b>ID_INDICATOR_</b>.</li></p>
<p><li> Right-click the last of these entries: <b>ID_INDICATOR_REC</b>.</li></p>
<p><li> On the shortcut menu, click <b>New String</b>.</li></p>
<p><li> In the <b>ID</b> box, type <b>ID_INDICATOR_DB</b>.</li></p>
<p><li> In the <b>Caption</b> box, type <b>Database not connected</b>. This is a default
string that must always be supplied for a string table entry. Use the space bar to type
15 blank spaces after the string. The framework will use the length of the string,
including spaces, to size the indicators. The blank spaces ensure that the indicator
pane is large enough to take the longest string that it is required to display. Your
screen should now look something like Figure 4.10.</li></p>

<p>
<A HREF="javascript:fullSize('f04DA10x.htm')"> <img src="images/f04DA10.jpg" width=404 height=259 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 4.10</b> <i>Adding a string to the string table</i><!-- /caption -->
</p>

<p><li> Press ENTER to add the new string. Close the string table editor.</li></p>
</ol>

<p>Now you will modify the application's status bar creation code so that it
creates the ID_INDICATOR_DB pane instead of the three standard key lock indicators.</p>

<p><li><b>To set up the MyApp status bar indicators</b></li></p>

<ol>
<p><li> In the MyApp workspace window, click the <b>FileView</b> tab.</li></p>
<p><li> Expand the Source Files folder.</li></p>
<p><li> Double-click the <b>MainFrm.cpp</b> file icon to edit the file.</li></p>
<p><li> Locate the code that declares the status bar indicator array. You'll find it
just below the message map. The code reads as follows:</li></p>
<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>static UINT indicators[] =
{
     ID_SEPARATOR,           // status line indicator
     ID_INDICATOR_CAPS,
     ID_INDICATOR_NUM,
     ID_INDICATOR_SCRL,
};</pre>
</td></tr>
</table>
</p>
<p><li> Delete the last three elements of the array so that only <b>ID_SEPARATOR</b>
remains. Add the <b>ID_INDICATOR_DB</b> identifier as the second element. The code
should now read as follows:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>static UINT indicators[] =
{
     ID_SEPARATOR,           // status line indicator
     ID_INDICATOR_DB,
};</pre>
</td></tr>
</table>
</p>
</ol>

<p>If you look through the <b>CMainFrm::OnCreate()</b> function further down the file,
you will see that this array gets passed to the <b>CStatusBar::SetIndicators()</b>
function that is called for the <b>CMainFrame::m_wndStatusBar</b> object.</p>

<p>Now you must manually implement the message map entry and handler function to enable
the framework to update the indicators.</p>

<p><li><b>To add the message map entry</b></li></p>
<ol>
<p><li> Locate the message map. It should be just above the array that you edited in the
previous exercise.</li></p>
<p><li> Add the following entry macro to the message map:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>ON_UPDATE_COMMAND_UI(ID_INDICATOR_DB, OnUpdateDB)</pre>
</td></tr>
</table>
</p>

<p>Note that all message map entries that are not created by ClassWizard should be
placed outside the {{AFX_MSG_MAP comment block. The entire message map should read:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
     //{{AFX_MSG_MAP(CMainFrame)
     // NOTE - ClassWizard will add and remove mapping macros here.
     // DO NOT EDIT what you see in these blocks of generated code!
     ON_WM_CREATE()
     //}}AFX_MSG_MAP
     ON_UPDATE_COMMAND_UI(ID_INDICATOR_DB, OnUpdateDB)
END_MESSAGE_MAP()</pre>
</td></tr>
</table>
</p>
</ol>

<p><li><b>To add the handler function</b></li></p>
<ol>
<p><li> In the MyApp workspace window, click the <b>FileView</b> tab.</li></p>
<p><li> Expand the Header Files folder.</li></p>
<p><li> Double-click the <b>MainFrm.h</b> file icon to edit the file.</li></p>
<p><li> At the bottom of the <b>CMainFrame</b> class declaration, just above the <b>
DECLARE_MESSAGE_MAP</b> macro, add the following function definition:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>afx_msg void OnUpdateDB(CCmdUI *pCmdUI);</pre>
</td></tr>
</table>
</p>

<p>Note that this entry is also outside the {{AFX_MSG comment block.</p>

<p><li> Switch back to the MainFrm.cpp file. At the bottom of the file, add the
following code to implement the <b>OnUpdateDB()</b> function:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CMainFrame::OnUpdateDB(CCmdUI *pCmdUI)
{
     CMyAppApp * pApp = dynamic_cast&lt;CMyAppApp *&gt;(AfxGetApp());
     ASSERT_VALID(pApp);

     if(pApp-&gt;m_isDatabaseConnected)
          pCmdUI-&gt;SetText(&quot;Connected to: &quot;+ pApp-&gt;m_strDSN);
     else
          pCmdUI-&gt;SetText(&quot;Database not connected&quot;);
}</pre>
</td></tr>
</table>
</p>

<p>This function is straightforward. The code checks for a live database connection by
checking the CMyAppApp::m_isDatabaseConnected variable. If m_isDatabaseConnected
contains TRUE, then the function retrieves the name of the current data source from
CMyAppApp::m_strDSN and displays it on the status bar pane. Otherwise it displays the
string &quot;Database not connected.&quot;</p>

<p>Note the use of the MFC global function <b>AfxGetApp()</b>, which returns a pointer
to the main application object. This function must be cast to the CMyAppApp * type so
that you can reference the CMyAppApp member variables. To cast down the inheritance
hierarchy, you should use the <b>dynamic_cast&lt;&gt;()</b> operator.</p>
</ol>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Before you can use the <b>dynamic_cast&lt;&gt;()</b> operator, you must
make sure that you have selected the <b>Enable Run-Time Type Information (RTTI)</b>
check box on the language settings of the <b>C/C++</b> page in the project settings.
(See <a href="ch02c.htm#71">Lesson 2</a> of Chapter 2 for details on how to do this.)
</blockquote></div>
</p>

<ol>
<p>Note the use of the <b>ASSERT_VALID</b> debug macro to check the validity of the
pointer.</p>

<p><li value="6"> Build and run the MyApp program. Test the <b>Connect</b> command to see how the
text on the status bar is updated to indicate the database connection status. In
subsequent exercises, you will change the <b>Connect</b> command so that instead of it
simply switching on and off, it will open a dialog box where you can select a data
source. In this scenario, you will rely entirely on the status-bar indicator to inform
the user of which data source (if any) the application is connected to.</li></p>
</ol>

<A NAME="161"><H2>Lesson Summary</H2></A>

<p>A document/view-based application generated by the MFC AppWizard provides a fully
featured user interface that you can adapt to suit your own requirements. Along with
the application classes and code, the AppWizard creates a group of resources that can
contain application icons, menus and toolbars, and a string table.</p>

<p>These resources can be edited using tools that come as part of the Visual C++
development environment. The graphics editor can be used to edit icons and toolbar
buttons. The menu editor allows you to edit menus visually. There are also editors for
string table entries and shortcut key associations.</p>

<p>While using these editors, you can also edit the property pages of the objects that
you are editing. These property pages allow you to set the text for menu options,
status bar prompt strings and ToolTips, and set command IDs for menu and toolbar
options.</p>

<p>Command IDs are used to map menu or toolbar selections to handler functions. Using
ClassWizard, you can easily add message map entries and create handler functions for
any of the classes derived from <b>CCmdTarget</b>. Similarly, you can use ClassWizard
to add user-interface update command handlers. These are functions that are called by
the framework to allow you to update the status or appearance of user interface
elements. The framework passes these functions a pointer to a <b>CCmdUI</b> object as a
parameter. The <b>CCmdUI</b> class gives access to the user-interface element associated 
with the handler, and provides member functions that allow you to alter the appearance or 
status of menu or toolbar commands.</p>

<p>You can also convey information on the status bar about the status of your application.
The MFC class <b>CStatusBar</b> allows you complete control over the number and style
of status bar indicators and the text they display. You can set up an array of status
bar indicators that are associated with string IDs in the application's string
table. You can use these IDs or the array index to access and update individual status
bar panes. The recommended way to update text in a status bar pane is to use an
ON_UPDATE_COMMAND_UI entry in a message map to associate a user-interface update
handler function with an indicator's string ID. You can then use the <b>
SetText()</b> function of the handler's <i>CCmdUI</i> parameter to display text in
the pane. ClassWizard cannot be used to add handler functions for indicator IDs, so you
are obliged to add these message map entries manually.</p>

</BODY>
</HTML>






