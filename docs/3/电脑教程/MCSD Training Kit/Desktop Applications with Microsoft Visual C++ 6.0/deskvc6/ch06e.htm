<HTML>
<HEAD>
<TITLE>Lab 6: Working with Persistent Data</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06d.htm", "ch06f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="261"><H1>Lab 6: Working with Persistent Data</H1></A>

<p>In this lab, you will enable the STUpload application to work with persistent data contained in files on your local hard disk. You will modify the application in two sections. First, you will finish implementing the <b>CSTUploadDoc::LoadData()</b> function that you created in <A HREF="ch05a.htm">Chapter 5</A>. The <b>CSTUploadDoc::OnDataImport()</b> function calls the <b>LoadData()</b> function to load data from
a text file into the application.</p>

<p>Second, you will implement standard MFC serialization for the STUpload application
so that the application data imported from the text file can be saved as an STUpload
document file.</p>

<A NAME="262"><H2>Importing Data from a Text File</H2></A>

<p>In <a href="ch05f.htm#227">Lab 5</a>, you created a temporary implementation of the <b>CSTUploadDoc::LoadData()</b> function. Currently, this function simply adds some hard-coded stock
price records to the <b>CStockDataList</b> object <b>CSTUploadDoc::m_DocList</b>. You
will finish implementing the <b>LoadData()</b> function to load records into <b>
m_DocList</b> from the <b>CStdioFile</b> object passed in from the <b>CSTUploadDoc::OnDataImport()</b> function. Your first task is to use the <b>CStdioFile</b> object to
open the text file selected by the user.</p>

<p><li> <b>To open the text
file</b></li></p>

<ol>

<p><li> Edit the <b>CSTUploadDoc::OnDataImport()</b> function. Locate the code branch
that begins with the line of code:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>if(nID == IDOK)</pre>
</td></tr>
</table>
</p>



<p><li> After the <b>CStdioFile</b> object declaration, add the following code:</li></p>

<p>
<img src="images/cd.gif" width=45 height=45 border="0">
</p>

<p>(This code can be found in CH6_01.cpp, installed from the companion
CD.)</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CFileException fx;
if(!aFile.Open(aFileDialog.GetPathName(), CFile::modeRead | 
     CFile::typeText, &amp;fx))
{
     TCHAR buf[255];
     fx.GetErrorMessage(buf, 255);
     CString strPrompt(buf);
     AfxMessageBox(strPrompt);
     return;
}</pre>
</td></tr>
</table>
</p>


<p>The entire function should now look as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CSTUploadDoc::OnDataImport()
{
     // String to customize File Dialog
     CString strFilter = 
          Data Files (*.dat)|*.dat|All Files (*.*)|*.*||&quot;;

     CFileDialog aFileDialog(TRUE, NULL, NULL, OFN_HIDEREADONLY | 
          OFN_OVERWRITEPROMPT, strFilter);

     int nID = aFileDialog.DoModal();

     if(nID == IDOK)
     {
          CStdioFile aFile;

          CFileException fx;
          if(!aFile.Open(aFileDialog.GetPathName(), 
               CFile::modeRead | CFile::typeText, &amp;fx))
          {
               TCHAR buf[255];
               fx.GetErrorMessage(buf, 255);
               CString strPrompt(buf);
               AfxMessageBox(strPrompt);
               return;
          }
          LoadData(aFile);
     }
}</pre>
</td></tr>
</table>
</p></ol>

<p>Before you replace the old <b>LoadData()</b> function with a new version, you will
make a couple of changes to enable the new function to use the <b>Conflicting
Records</b> dialog box. First, you must call the <b>AfxInitRichEdit()</b> function to
initialize rich edit controls for your application.</p>

<p><li> <b>To enable the use of
rich edit controls by an application</b></li></p>

<ol>

<p><li> Edit the <b>CSTUploadApp::InitInstance()</b> function. Add the following line
just before the return statement near the end of the function:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>AfxInitRichEdit();</pre>
</td></tr>
</table>
</p>


<p><li> Add a DDX CConflictDialog::m_REditText member variable. This vari-able will be a
CString variable used to set the data displayed in the rich edit control.</li></p>
</ol>


<p><li> <b>To add the CConflictDialog::m_REditText variable</b></li></p>
<ol>
<p><li> Open ClassWizard.</li></p>

<p><li> Click the <b>Member Variables</b> tab.</li></p>

<p><li> Add a <b>CString</b> variable m_REditText to the <b>CConflictDialog</b> class,
which is associated with the <b>IDC_DUPL_RICHEDIT</b> resource ID.</li></p>
</ol>

<p>Now you are ready to implement the new <b>LoadData()</b> function.</p>

<p><li> <b>To replace the LoadData() function</b></li></p>

<ol>

<p><li> To the top of the STUploadDoc.cpp file, with the other #include statements, add
the following line:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#include &quot;ConflictDialog.h&quot;</pre>
</td></tr>
</table>
</p>



<p><li> Locate the <b>CSTUploadDoc::LoadData()</b> function. Delete the entire function
and replace it with the following code:</li></p>

<p>
<img src="images/cd.gif" width=45 height=45 border="0">
</p>

<p>(This code can be found in CH6_02.cpp, installed from the companion
CD.)</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL CSTUploadDoc::LoadData(CStdioFile &amp;infile)
{
     // Check for NULL
     ASSERT(infile.m_hFile != NULL);

     // Hold data in temporary list of CStockData objects,
     // which we assign to CSTUploadDoc::m_DocList only
     // when we are sure load has been completed successfully
     CStockDataList TempList;
     // Additions are cumulative, so we need to copy in existing data
     TempList.AddHead(&amp;m_DocList);

     // Line buffer
     CString strTemp;

     // Today's date
     COleDateTime Today = COleDateTime::GetCurrentTime();
     COleDateTime FileDate;
     CString strFileHeader;

     int addedCtr = 0;     // Count added items
     int discardedCtr = 0;     // Count discarded items

     BOOL bFirstLine = TRUE;

     while(infile.ReadString(strTemp))
     {
          BOOL bValidDate = FALSE;
          CString strFund;
          CString strDate;

          // Exclude blank lines
          if(strTemp.GetLength() == 0) continue;

          if(bFirstLine)
          {
               // Get Header information
               strFileHeader = strTemp.Left(18);
               strFileHeader.TrimRight();
               strDate = strTemp.Mid(18, 10);
          }
          else
          {
               strFund = strTemp.Left(8);
               strFund.TrimRight();
               strDate = strTemp.Mid(8, 10);
          }

          int nYear = atoi(strDate.Right(4));
          int nMonth = atoi(strDate.Left(2));
          int nDay = atoi(strDate.Mid(3, 2));

          COleDateTime aDate(nYear, nMonth, nDay, 0, 0, 0);

     if(aDate.GetStatus() != COleDateTime::valid)
          {
               if(bFirstLine)
               {
                    // Cannot read file date - assume invalid
                    AfxMessageBox(&quot;Invalid File Format&quot;);
                    return FALSE;
               }
               else
               {
                    // Cannot read record date - discard line
                    discardedCtr++;
                    continue;
               }
          }

          if(bFirstLine)
          {
               // Get file date - loop back to top
               FileDate = aDate;
               bFirstLine = FALSE;
               continue;
          }

          double dPrice = atof(strTemp.Mid(19));

          // Make a CStockData object and add it
          // to our temporary array
          CStockData aStData(strFund, aDate, dPrice);
          CStockDataList::errorstatus err;
          POSITION CurPos = TempList.AddSorted(aStData, err);

          switch(err)
          {
               // Discard identical entry
               case CStockDataList::duplicate_entry :

                    discardedCtr ++ ;
                    continue;

               // Same record, different price value
               case CStockDataList::conflicting_entry :
               {
                    // Query if user wants to discard duplicate, 
                    // replace, or abort
                    CConflictDialog aDialog;

                    // Construct text to appear in rich edit 
                    // control
                    CString strText = &quot;Existing entry:\n\n&quot;;

                    CStockData SDTemp = TempList.GetAt(CurPos);

                    strText += SDTemp.GetAsString();
                    strText += &quot;\n\nReplacement entry:\n\n&quot;;
                    strText += aStData.GetAsString();

                    // Assign text to control variable
                    aDialog.m_REditText = strText;

                    switch(aDialog.DoModal())
                    {
                         case IDABORT : // Abandon
                         return FALSE;

                         case IDCANCEL : // Discard new record
                         discardedCtr++ ;
                         continue;

                         case IDOK : // Replace existing record
                         TempList.SetAt(CurPos, aStData);
                    }
               }

          default:  // Ok
               addedCtr++ ;
     }
}

// If we got this far then this is a valid record

CString strPrompt;
strPrompt.Format(
     &quot;Import of file %s complete:\nRecords loaded: %d \
     \nRecords discarded: %d  \
     \n\nHit OK to load data into document.&quot;,
     strFileHeader, addedCtr, discardedCtr);

if(AfxMessageBox(strPrompt, MB_OKCANCEL) == IDOK)
{
     // Update document data
     m_DocList.RemoveAll();
     m_DocList.AddHead(&amp;TempList);

     // Update fund view
     CMainFrame * pWnd =
          dynamic_cast&lt;CMainFrame *&gt; (AfxGetMainWnd());

     if(pWnd)
     {
          pWnd-&gt;UpdateFundList(m_DocList);
          // Show fund window after loading new funds
          pWnd-&gt;SetFundsVisible(TRUE);
     }

     return TRUE;
}
else
     return FALSE;
}
</pre>
</td></tr></table>
</p>


<p><li> Look through the code, and make sure that you understand how:</li></p>


<ul>
<p><li> A temporary list is used to hold the data that is loaded so that the application
data is not modified until the load process has completed successfully, and the user
has approved the import.</li></p>

<p><li> The routine distinguishes between a header line and a data line.</li></p>

<p><li> The header line is parsed to ensure that the correct type of document is being
loaded.</li></p>

<p><li> <b>CString</b> member functions are used to extract data from a data line.</li></p>

<p><li> The routine deals with invalid lines, duplicate lines and conflicting entries
(same fund and date, different price). You might want to pay close attention to the <b>
CStockDataList::AddSorted()</b> function.</li></p>
</ul>



<p><li> Build and run the STUpload application. Try using the <b>Import</b> option from
the <b>Data</b> menu to load the Ch6Test.dat file from the ..\Chapter 6\Data
folder on the companion CD-ROM. Make sure that the data loads as expected. Close the
application and run it again. This time load the conflict.dat file from the ..\Chapter
6\Data folder. This file contains a conflicting record to allow you to test the
conflict handling routine.</li></p>
</ol>

<A NAME="263"><H2>Implementing STUpload Serialization</H2></A>

<p>STUpload application data consists of a single <b>CStockDataList</b> object that is
a collection of <b>CStockData</b> objects. The <b>CStockData</b> object encapsulates a
fund name, a date and a price. The document also contains a CString variable that
records the currently selected fund name. This variable should also be serialized, so
that the fund that was currently selected when the document file was saved will still
be selected when the file is restored.</p>

<p>To serialize the STUpload application data, you will need to:</p>

<ul>
<p><li> Make <b>CStockData</b> a serializable class.</li></p>

<p><li> Provide an implementation of the <b>SerializeElements()</b> function template for
the <b>CStockData</b> element type (This is necessary because <b>CStockData</b>
contains a <b>CString</b>).</li></p>

<p><li> Implement the <b>CSTUploadDoc::Serialize()</b> function.</li></p>

<p><li> Implement the <b>CSTUploadDoc::DeleteContents()</b> function to clear out the
data held in the document object before it is reused.</li></p>

<p><li> Add calls to <b>CDocument::SetModifiedFlag()</b> wherever the application data is
altered so that the framework will prompt the user to save changes before closing a
modified document.</li></p>
</ul>


<A NAME="264"><H3>Making CStockData a Serializable Class</H3></A>

<p>The <b>CStockData</b> class that we have provided is directly derived from the <b>
CObject</b> class, and it includes a default constructor. You will need to add the
serialization macros and the <b>Serialize()</b> function.</p>

<p><li> <b>To add the
serialization macros</b></li></p>

<ol>

<p><li> Open the StockData.h file to edit the <b>CStockData</b> class definition.</li></p>

<p><li> To the top of the class declaration, in the <b>public</b> section, add the
following line:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>DECLARE_SERIAL(CStockData)</pre>
</td></tr>
</table>
</p>


<p><li> Open the StockData.cpp file. At the top of the file, below the preprocessor
statements, add the following line:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>IMPLEMENT_SERIAL(CStockData, CObject, 1)</pre>
</td></tr>
</table>
</p>
</ol>

<p><li> <b>To add the
Serialize() function</b></li></p>

<ol>

<p><li> Switch back to the StockData.h file.</li></p>

<p><li> Add the following declaration to the <b>public</b> section of the <b>
CStockData</b> class definition:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>virtual void Serialize(CArchive&amp; ar);</pre>
</td></tr>
</table>
</p>



<p><li> Switch back to the StockData.cpp file. At the end of the file, add the following
code:</li></p>

<p>
<img src="images/cd.gif" width=45 height=45 border="0">
</p>

<p>(This code can be found in CH6_03.cpp, installed from the companion
CD.)</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CStockData::Serialize(CArchive&amp; ar)
{
     if (ar.IsStoring())
     {
          ar &lt;&lt; m_strFund;
          ar &lt;&lt; m_date;
          ar &lt;&lt; m_dblPrice;
     }
     else
     {
          ar &gt;&gt; m_strFund;
          ar &gt;&gt; m_date;
          ar &gt;&gt; m_dblPrice;
     }
}</pre>
</td></tr>
</table>
</p>
</ol>

<A NAME="265"><H3>Overriding SerializeElements()</H3></A>

<p>You will now implement the function template <b>SerializeElements()</b> for the <b>
CStockData</b> element type. The function will simply iterate across the collection
data and call <b>Serialize()</b> for each <b>CStockData</b> object.</p>

<p><li> <b>To override the
SerializeElements() function</b></li></p>

<ol>

<p><li> Open the StockDataList.h file.</li></p>

<p><li> At the end of the file, before the #endif statement and <i>after</i> the end of
the <b>CStockDataList</b> class declaration, add the following line:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>template &lt;&gt; void AFXAPI SerializeElements &lt;CStockData&gt;
     (CArchive&amp; ar, CStockData* pNewSD, int nCount);</pre>
</td></tr>
</table>
</p>


<p><li> Open the StockDataList.cpp file.</li></p>



<p><li> At the end of the file, add the following code:</li></p>

<p>
<img src="images/cd.gif" width=45 height=45 border="0">
</p>

<p>(This code can be found in CH6_04.cpp, installed from the companion
CD.)</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>template &lt;&gt; void AFXAPI SerializeElements &lt;CStockData&gt;
     (CArchive&amp; ar, CStockData* pNewSD, int nCount)
{
     for (int i = 0; i &lt; nCount; i++, pNewSD++)
     {
          // Serialize each CStockData object
          pNewSD-&gt;Serialize(ar);
     }
}</pre>
</td></tr>
</table>
</p>
</ol>

<A NAME="266"><H3>Implementing the CSTUploadDoc::Serialize() Function</H3></A>

<p>At this point, you are ready to implement the document serialization code.</p>

<p><li><b> To implement the
CSTUploadDoc::Serialize() function</b></li></p>

<ol>

<p><li> Locate the <b>CSTUploadDoc::Serialize()</b> function.</li></p>

<p><li> Replace the function with the following version:</li></p>

<p>
<img src="images/cd.gif" width=45 height=45 border="0">
</p>

<p>(This code can be found in CH6_05.cpp, installed from the companion
CD.)</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CSTUploadDoc::Serialize(CArchive&amp; ar)
{
     m_DocList.Serialize(ar);

     if (ar.IsStoring())
     {
          ar &lt;&lt; m_strCurrentFund;
     }
     else
     {
          ar &gt;&gt; m_strCurrentFund;

          // Update Select Fund window
          CMainFrame* pWnd = dynamic_cast&lt;CMainFrame *&gt; 
               (AfxGetMainWnd());

          if(pWnd)
          // Will fail if running from icon or from
          // command line with file name argument
          {
               // Update and show fund window
               pWnd-&gt;UpdateFundList(m_DocList, m_strCurrentFund);
               pWnd-&gt;SetFundsVisible(TRUE);
          }
     }
}</pre>
</td></tr>
</table>
</p>
</ol>

<p>All the stock data records are serialized in a single call to <b>
CStockDataList::
Serialize()</b>. The <b>CSTUploadDoc::m_strCurrentFund</b> data member is also
serialized.</p>

<A NAME="267"><H3>Displaying the Select Fund Window</H3></A>

<p>Take note of the code that displays the fund window when a document file is loaded.
This is not possible here when the application is launched by double-clicking a
document file icon, as the pointer to the main window is not available at this point.
However, you can instruct the application to display the fund window after the main
window has been created, if it detects that a document has already been loaded.</p>

<p><li> <b>To display the
Select Fund window at application startup</b></li></p>

<ol>

<p><li> Locate the <b>CSTUploadApp::InitInstance()</b> function.</li></p>

<p><li> At the end of the function, just before the return statement, add the following
code:</li></p>

<p>
<img src="images/cd.gif" width=45 height=45 border="0">
</p>

<p>(This code can be found in CH6_06.cpp, installed from the companion
CD.)</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CMainFrame * pFrameWnd =
     dynamic_cast&lt;CMainFrame *&gt; (m_pMainWnd);

ASSERT_VALID(pFrameWnd);

CSTUploadDoc * pDoc =
     dynamic_cast&lt;CSTUploadDoc *&gt;(pFrameWnd-&gt;GetActiveDocument());

ASSERT_VALID(pDoc);

if(pDoc-&gt;GetDocList().GetCount() &gt; 0)
// Non-empty document at main window creation time means we are
// running from icon or from command line with file name argument
{
     pFrameWnd-&gt;UpdateFundList(pDoc-&gt;GetDocList(), 
          pDoc-&gt;GetCurrentFund());
     pFrameWnd-&gt;SetFundsVisible(TRUE);
}</pre>
</td></tr>
</table>
</p>
</ol>

<A NAME="268"><H3>Implementing DeleteContents()</H3></A>

<p>Because STUpload is an SDI application, any data contained in the document object
must be cleared out by the <b>DeleteContents()</b> function.</p>

<p><li> <b>To implement the
CSTUploadDoc::DeleteContents() function</b></li></p>

<ol>

<p><li> Use ClassWizard to overload the <b>DeleteContents()</b> function for the <b>
CSTUploadDoc</b> class.</li></p>

<p><li> Edit the function code. Replace the //TODO comment line with the following
code:</li></p>

<p>
<img src="images/cd.gif" width=45 height=45 border="0">
</p>

<p>(This code can be found CH6_07.cpp, installed from the companion
CD.)</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>m_DocList.RemoveAll();

CMainFrame * pWnd =
     dynamic_cast&lt;CMainFrame *&gt; (AfxGetMainWnd());

if(pWnd)
{
     pWnd-&gt;UpdateFundList(m_DocList);
     // No funds on file, so hide fund window
     pWnd-&gt;SetFundsVisible(FALSE);
     // And reset current fund value
     SetCurrentFund(&quot;&quot;);
}</pre>
</td></tr>
</table>
</p>
</ol>

<A NAME="269"><H3>Notifying Document Data Modification</H3></A>

<p>Finally you must add calls to <b>CDocument::SetModifiedFlag()</b> whenever the
persistent document data is changed. In the STUpload application the data is modified
in two places:</p>

<ul>
<p><li> In the <b>CSTUploadDoc::OnDataImport()</b> function, after the <b>LoadData()</b>
function has returned with a TRUE value, to indicate that records have been
successfully imported from a text file.</li></p>

<p><li> In the <b>CFundDialog::OnSelchangeFundlist()</b> function, when the user changes
the currently selected fund.</li></p>
</ul>


<p><li> <b>To modify the
CSTUploadDoc::OnDataImport() function</b></li></p>

<ol>

<p><li> Locate the line in the <b>OnDataImport()</b> function that reads:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>LoadData(aFile);</pre>
</td></tr>
</table>
</p>


<p><li> Replace this line with the following code:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>if(LoadData(aFile))
{
     SetModifiedFlag();
     UpdateAllViews(NULL);
}</pre>
</td></tr>
</table>
</p>
</ol>

<p><li> <b>To modify the
CFundDialog::OnSelchangeFundlist() function</b></li></p>



<p>Locate the <b>CFundDialog::OnSelchangeFundlist()</b> function. At the end of the
function string, before the closing brace, add the line:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>pDoc-&gt;SetModifiedFlag();</pre>
</td></tr>
</table>
</p>

<A NAME="270"><H3>Testing Serialization</H3></A>

<p><li> <b>To build and test
the STUpload application</b></li></p>

<ol>

<p><li> Run the application, then use the <b>Import</b> option from the <b>Data</b> menu
to load data from the ..\Chapter 6\Data\Test.dat file on the companion CD.</li></p>

<p><li> Select a fund to view, then close the application. When prompted, save the
document as <b>MyFile.stu</b>.</li></p>

<p><li> Restart the application. From the <b>File</b> menu, choose <b>Open</b>, then
select and open the MyFile.stu file.</li></p>

<p><li> Select a new fund to view and close the application, saving your changes.</li></p>

<p><li> Use Windows Explorer to locate the MyFile.stu file, and launch the STUpload
application by double-clicking the file icon.</li></p>

<p><li> Check that the file is restored correctly.</li></p>
</ol>

</BODY>
</HTML>







