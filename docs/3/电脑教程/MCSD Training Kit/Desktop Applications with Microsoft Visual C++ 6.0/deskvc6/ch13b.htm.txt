<HTML>
<HEAD>
<TITLE>Lesson 1: Error Handling</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch13a.htm", "ch13c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="471"><H1>Lesson 1: Error Handling</H1></A>

<p>Experienced developers treat <i>error handling</i> as a natural part of the coding
process; appropriate error handling is an essential component of a robust application.
This lesson explains some of the common techniques used in error handling. This lesson
also presents a broad discussion of how to incorporate code that not only detects a
problem when it occurs but reacts appropriately
(for example, by displaying a message box to users). It's far easier to address
error handling during the coding process than to try retrofitting the code later.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<ul>
<p><li> Write code that effectively handles errors as they occur in a running program.</li></p>
<p><li> Understand exceptions and use exception-handling techniques in your code.</li></p>
<p><li> Keep a running record of a program's progress using the <b>TRACE</b>
macro.</li></p>
</ul>
<b>Estimated lesson time: 30 minutes</b>
</blockquote></div>
</p>


<A NAME="472"><H2>Anticipating Program Errors</H2></A>

<p>Most experienced programmers have a healthy skepticism about whether code will
perform as intended. Your code might contain logical errors that affect your program in
ways that are not instantly apparent. Even code that is <i>logically</i> error free
might have unexpected effects within certain environmental circumstances. As you write
code, develop the habit of questioning every assumption. Try to anticipate things that
might go wrong and incorporate additional code to react gracefully to such problems.
These added lines of code might execute only rarely, if ever, but are present in case
they are needed to solve problems.</p>

<p>Failing to properly anticipate environmental contingencies catches many developers
off guard. Consider the following typical scenario, in which a function
allocates a buffer in memory, then fills it with text. Using the <b>new</b> operator,
this function receives a pointer to a block of memory, then immediately proceeds to
write to it. Throughout the development process, the function performs flawlessly
because the development computer has ample resources to provide free store memory.
After the program is released, the program's developer begins
receiving calls from irate users who have lost a day's work because the program has
failed as a result of the users' computers not having adequate memory to perform
the task.</p>

<p>Experienced programmers take a more conservative approach when allocating memory.
They add code that checks the value of the pointer returned by <b>new</b> and will only
use the pointer if it holds a non-zero value. If <b>new</b> returns a <b>NULL</b>
pointer&#8212;meaning that the allocation failed&#8212;code should react appropriately.
The result should resemble the following code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>int  *ptr = new int[BLOCK_SIZE];
if (ptr)
{
     // Memory block successfully allocated, so use it
     .
     .
     .
     delete[] ptr;
}
else
{
     // Allocation failed &#8212; take appropriate steps
}</pre>
</td></tr>
</table>
</p>

<p>Anticipation of potential problems and implementation of proper contingency
procedures lead to more robust code with increased stability under adverse
circumstances, which in turn leads to reduced failure rates. Programmed robustness is
considered to be <i>fault-tolerant</i>, referring to the degree to which code can
accommodate problems without failure. You might think of this anticipatory
approach as <i>inline error handling</i>, in which possible errors are dealt with
immediately in the body of the code.</p>

<p>Handling errors by continually checking return values can make code difficult
to read and maintain because of constant interruptions of the program's logic flow.
This method of error checking can often lead to a long series of nested
<b>IF</b>-<b>ELSE</b> blocks, in which the <b>IF</b> blocks contain the code as it is
intended to run, and the <b>ELSE</b> blocks contain the code that deals with errors.
Following is
a pseudocode illustration of how such nested tests can move closer to the right side of
the screen. If the nested tests contain long lines of code, the intended flow might be
difficult to follow:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>if (condition1 == TRUE)
{
     // Compute condition2
     if (condition2 == TRUE)
     {
          // Compute condition3
          if (condition3 == TRUE)
          {
               // Other nested conditions
               .
               .
               .
          }
          else
          {
               // Failure for condition3
          }
     }
     else
     {
          // Failure for condition2
     }
}
else
{
     // Failure for condition1
}</pre>
</td></tr>
</table>
</p>

<p>Microsoft Windows and Visual C++ offer another approach to handling errors inline:
<i>exception handling</i>. Exception handling allows developers to separate a function
logically into two sections: one for normal execution and the other for trapping
errors. Seemingly oblivious to potential errors, code in the normal
execution section does not check return values and executes as though no problems
exist. The second code section traps errors as they occur.</p>

<A NAME="473"><H2>Exceptions</H2></A>

<p>An <i>exception</i> is any condition that the operating system considers to be
an error. When an application raises an exception, the operating system attempts
to notify the offending application that it has caused an error by calling the
application's exception handler code (assuming such code exists). If the
application does not provide an exception handler, the operating system resolves the
problem itself, often by terminating the application abruptly with a terse message to
its user such as &quot;This program has performed an illegal operation and will be shut
down.&quot;</p>

<p>Two levels of exception handling exist:</p>

<ul>
<p><li><b>Structured exception handling (SEH)</b> pertains exclusively to operating system errors.</li></p>

<p><li><b>C++ exception handling</b> pertains to errors in Visual C++ applications.</li></p>
</ul>


<A NAME="474"><H3>Structured Exception Handling</H3></A>

<p>Although this chapter primarily examines C++ exception handling, Structured
Exception Handling (SEH) merits attention for two reasons. First, though they are quite
distinct, the two types of exception handling are often confused. Second, although the
C language cannot use C++ exception handling, it can implement SEH.</p>

<p>All exception handling is based on the SEH mechanism. SEH initiates the be-ginning
of a communication chain that winds its way up to the application level. An application
incorporates SEH through the <b>__try</b>, <b>__except</b>, and <b>__finally</b>
keywords. A