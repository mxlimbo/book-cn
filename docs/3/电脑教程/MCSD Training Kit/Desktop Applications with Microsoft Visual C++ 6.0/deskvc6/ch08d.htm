<HTML>
<HEAD>
<TITLE>Lesson 3: Dispatch Interfaces</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch08c.htm", "ch08e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="327"><H1>Lesson 3: Dispatch Interfaces</H1></A>

<p>In <a href="ch08c.htm#320">Lesson 2</a>, you learned that dispatch interfaces implement Microsoft's
Automation technology. Automation allows components written in different languages to
communicate with one another.</p>

<p>In this lesson, you will learn more about how the <b>IDispatch</b> interface and the
VARIANT data type are used to allow other languages to access COM components. You will
also learn how clients written in Microsoft development languages such as Visual Basic
or Microsoft Visual J++ can access component interfaces directly without using the
dispatch mechanism.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>

<ul>
<p><li>Describe how a dispatch interface invokes methods on behalf of a client.</li></p>

<p><li>Describe the structure of the VARIANT data type.</li></p>

<p><li>Describe how type libraries enable Visual Basic clients to access component
interfaces directly.</li></p>

<p><li>Describe how a dual interface exposes component methods.</li></p>
</ul>

<b>Estimated lesson time: 30 minutes</b>
</blockquote></div>
</p>


<A NAME="328"><H2>IDispatch Interface</H2></A>

<p>Dispatch interfaces enable client applications written in different languages to
access your COM objects. For example, consider a scripting language such as Microsoft
Visual Basic Scripting Edition (VBScript), which is used to create an instance of a COM
component written in C++. VBScript does not enforce strict type checking and does not
know about many of the C++ data types. To enable the VBScript client to communicate
successfully with the server component, you must provide your component with a 
<i>dispatch interface</i>. This is achieved by implementing the standard COM interface 
<b>IDispatch</b>.</p>

<p>In certain development situations, you will only want to create COM objects
that are going to be used exclusively by C++ clients. For example, objects
created by a software development company for in-house use might fall into
this category. In such a case you would not need to incur the overhead of implementing
<b>IDispatch</b>. However, if you want your COM object to be accessible from a wider
range of languages, you must implement the <b>IDispatch</b> interface. Clients written
in other Microsoft development languages such as Visual Basic can use COM components
written in C++ that do not implement the <b>IDispatch</b> interface. However, Visual
Basic clients can only use interfaces that pass <i>automation-compatible</i> 
parameters to and from their methods. Automation-compatible data types are those that 
can be packaged into the <b>VARIANT</b> standard
data format. A VARIANT is a COM-defined union data type, described in detail later in
this lesson.</p>

<p>Figure 8.9 provides a simple illustration of how the <b>IDispatch</b> interface
might be implemented for the <b>Encoder</b> class.</p>

<p>
<A HREF="javascript:fullSize('f08DA09x.htm')"> <img src="images/f08DA09.jpg" width=404 height=211 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 8.9</b> <i>Implementing the <b>IDispatch</b> interface</i><!-- /caption -->
</p>

<p>The <b>Encoder</b> object vtable contains entries that point to the implemented 
<b>IDispatch</b> functions. A client application executes the <b>GetIDsOfNames()</b>
method, providing the method name &quot;Encode&quot; as a string value, for example.
The <b>GetIDsOfNames()</b> method implements an internal table, which maps the name of
each method into a numerical dispatch identifier, known as a Dispatch ID, or DISPID.
The DISPID is simply a numerical value&#8212;in the example illustrated in Figure 8.9,
the DISPID of the <b>Encode</b> function is 1.</p>

<p>Once the client application has retrieved the DISPID of the method it wants to call,
it can call the <b>Invoke()</b> method to execute the method. The Dispatch ID returned
from <b>GetIDsOfNames()</b> is passed as an argument to the <b>Invoke()</b> method.
Also passed to <b>Invoke()</b> are the parameters to the requested methods, packaged as
an array of <b>VARIANT</b>s. <b>Invoke()</b> also takes a pointer to a <b>VARIANT</b>
to hold any value returned by the requested method.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
This is a simplified account of the dispatch process. For
example, parameters to invoked methods can be named and can also have Dispatch
IDs.</blockquote></div>
</p>

<p>Your implementation of the <b>Invoke()</b> method calls the requested method on
behalf of the Automation client. Your implementation must maintain some kind of table
to map DISPIDs to component methods. It must also unpack the arguments from the array
of <b>VARIANT</b>s and pass them to the requested component method in the correct form.
Any return values must be packed into the object referenced by the <b>VARIANT</b>
pointer for return to the client.</p>

<A NAME="329"><H2>VARIANT Data Type</H2></A>

<p>The <b>VARIANT</b> data type is defined in the file OAIDL.IDL as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
struct tagVARIANT {
     union {
          struct __tagVARIANT {
               VARTYPE vt;
               WORD    wReserved1;
               WORD    wReserved2;
               WORD    wReserved3;
               union {
                    LONG           lVal;      // VT_I4
                    BYTE           bVal;      // VT_UI1
                    SHORT          iVal;      // VT_I2
                    FLOAT          fltVal;    // VT_R4
                    DOUBLE         dblVal;    // VT_R8
                    VARIANT_BOOL   boolVal;   // VT_BOOL
                    _VARIANT_BOOL  bool;      // (obsolete)
                    SCODE          scode;     // VT_ERROR
                    CY             cyVal;     // VT_CY
                    DATE           date;      // VT_DATE
                    BSTR           bstrVal;   // VT_BSTR 
                    IUnknown *     punkVal;   // VT_UNKNOWN
                    IDispatch *    pdispVal;  // VT_DISPATCH
                    SAFEARRAY *    parray;    // VT_ARRAY
                    BYTE *         pbVal;     // VT_BYREF|VT_UI1
                    SHORT *        piVal;     // VT_BYREF|VT_I2
                    LONG *         plVal;     // VT_BYREF|VT_I4
                    FLOAT *        pfltVal;   // VT_BYREF|VT_R4
                    DOUBLE *       pdblVal;   // VT_BYREF|VT_R8
                    VARIANT_BOOL * pboolVal;  // VT_BYREF|VT_BOOL
                    _VARIANT_BOOl *    pbool; // (obsolete)
                    SCODE *        pscode;    // VT_BYREF|VT_ERROR
                    CY *           pcyVal;    // VT_BYREF|VT_CY
                    DATE *         pdate;     // VT_BYREF|VT_DATE
                    BSTR *         pbstrVal;  // VT_BYREF|VT_BSTR
                    IUnknown **    ppunkVal;  // VT_BYREF|VT_UNKNOWN
                    IDispatch **   ppdispVal; // VT_BYREF|VT_DISPATCH
                    SAFEARRAY **   pparray;   // VT_BYREF|VT_ARRAY
                    VARIANT *      pvarVal;   // VT_BYREF|VT_VARIANT
                    PVOID          byref;     // Generic ByRef
                    CHAR           cVal;      // VT_I1
                    USHORT         uiVal;     // VT_UI2
                    ULONG          ulVal;     // VT_UI4
                    INT            intVal;    // VT_INT
                    UINT           uintVal;   // VT_UINT
                    DECIMAL *      pdecVal;   // VT_BYREF|VT_DECIMAL
                    CHAR *         pcVal;     // VT_BYREF|VT_I1
                    USHORT *       puiVal;    // VT_BYREF|VT_UI2
                    ULONG *        pulVal;    // VT_BYREF|VT_UI4
                    INT *          pintVal;   // VT_BYREF|VT_INT
                    UINT *         puintVal;  // VT_BYREF|VT_UINT
                    struct __tagBRECORD {
                         PVOID     pvRecord;
                         IRecordInfo *     pRecInfo;
                    } __VARIANT_NAME_4;          // VT_RECORD
               } __VARIANT_NAME_3;
          } __VARIANT_NAME_2;
          DECIMAL decVal;
     } __VARIANT_NAME_1;
};
</pre>
</td></tr>
</table>
</p>

<p>The <b>VARIANT</b> data structure contains two fields (if you discount the reserved
fields). The <b>vt</b> field describes the type of data in the second field. To allow
multiple data types to appear in the second field, a union structure is declared.
Therefore, the name of the second field varies, depending on the value typed into the
<b>vt</b> field. The constants used to specify the value of the <b>vt</b> field are
indicated by a comment on the corresponding line of the union declaration.</p>

<p>Using the <b>VARIANT</b> and <b>VARIANTARG</b> data structure requires that you
follow a two-step process. As an example, consider the following code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>long lValue = 555;
VARIANT vParam;

VParam.vt = VT_I4;
vParam.lVal = lValue ;</pre>
</td></tr>
</table>
</p>

<p>In the first line, you specify a data type indicator. The <b>VT_I4</b> constant
states that a long data value appears in the second element. From the definition of the
<b>VARIANT</b> type, you can see that the second field uses the name <b>lVal</b> when
you store a long data value into the <b>VARIANTARG</b> data structure.</p>

<p>Using <b>VARIANT</b>s to pass parameters means that less strongly typed languages,
such as VBScript, can invoke methods implemented in strongly typed languages such as
C++. The implementation of the <b>Invoke()</b> method can check to see if the value
encapsulated in a <b>VARIANT</b> parameter is of the correct type. If it is, then the
type can be extracted and passed to the invoked method. If not, then the <b>
Invoke()</b> method can attempt to coerce the value to the correct type 
using the <b>VariantChangeType()</b> API function.</p>

<A NAME="330"><H2>Type Libraries</H2></A>

<p>You might appreciate, from the previous discussion of the dispatch mechanism, that
it is a relatively slow way of passing data between a server and a client. Also, the
packing and unpacking of parameters into <b>VARIANT</b>s is not type-safe.
High-performance development languages, such as Visual Basic 6.0, need to be able to
access interface methods directly, through the vtable.</p>

<p>To make this possible, the Visual Basic client must know the number and types of
parameters expected by the interface methods. This information is supplied to clients
as a <i>type library</i>&#8212;a binary description of the interface properties and
methods&#8212;and the method arguments. Type libraries can be thought of as a compiled,
language-independent version of a C++ header file.</p>

<p>The Visual Basic environment reads the type library and presents a description of
the interface to a programmer. The programmer creates an instance of the component
using the Visual Basic syntax that allows direct access to the component's vtable.
The information from the type library allows the programmer to pass the correct
argument types to the interface methods. In this way, the Visual Basic programmer can
bypass the dispatch mechanism and improve performance when using an in-process server.
Remember that to make a component usable by a Visual Basic client, you must use only
the Automation data types. A type library is described using IDL. The MIDL compiler
outputs a type library file with a .tlb extension. This file is often linked to the
.dll or .exe server that hosts the COM component.</p>

<p>For clients such as Visual Basic to access your type library, you must place
additional entries into the registry for your COM object. These entries provide the COM
run-time library with information about the location of your type library.</p>

<p>Figure 8.10 is a map of the registry entries associated with a COM object that
supports a type library.</p>

<p>
<A HREF="javascript:fullSize('f08DA10x.htm')"> <img src="images/f08DA10.jpg" width=404 height=438 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 8.10</b> <i>Registry entries for a type library</i><!-- /caption -->
</p>

<p>In fact, you only need two additional entries to locate the type library. Beneath
the <b>CLSID</b> subkey for your COM object, you add the <b>TypeLib</b> subkey. The
value that you assign to this subkey is the type library's <i>LIBID</i>&#8212;the
GUID defined for the type library in the IDL file.</p>

<p>This LIBID is used as the second registry entry for your type library, which you place
beneath the predefined <b>HKEY_CLASSES_ROOT \TypeLib</b> key. As shown in Figure 8.10,
several other subkeys are found beneath your LIBID key. The <b>win32</b> subkey
specifies a path to the file containing your type library as shown here:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>win32 = c:\Encoder\debug\Encoder.dll</pre>
</td></tr>
</table>
</p>

<p>The value that follows the equal sign is a path to the physical location of the type
library file. In this case, it is linked to the COM server DLL. Applications that use
type libraries know how to read them from .dll and .exe files.</p>

<p>When you instruct Visual Basic to reference a COM component, it uses this 
information to retrieve a path to the actual type library file. Once the file path
is obtained, Visual Basic reads and parses the type library, constructs the
programmatic representation, and enables Visual Basic programmers to write and execute
code that uses the services of a COM server.</p>

<A NAME="331"><H2>Dual Interfaces</H2></A>

<p>The preferred way to implement a dispatch interface is as a <i>dual</i> 
<i>interface</i>. Dual interfaces make all of the <b>Invoke()</b> methods available
directly, as entries in the component's vtable. Figure 8.11 illustrates a possible
implementation of a dual interface&#8212;it shows how the addresses of the 
<b>IEncoder</b> methods are included in the vtable, as well as in the table consulted by
the <b>Invoke()</b> function.</p>

<p>
<A HREF="javascript:fullSize('f08DA11x.htm')"> <img src="images/f08DA11.jpg" width=404 height=241 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 8.11</b> <i>Implementation of a dual interface</i><!-- /caption -->
</p>

<p>If you implement a dual interface, properties and methods exposed by a component can
still be accessed through a dispatch interface by languages such as VBScript; while
languages such as Visual C++ can access methods directly through the vtable. Visual
Basic can use either the dispatch interface or the vtable. Implementing a dual
interface allows clients that can access the vtable
to make faster method calls, but still supports those clients that require a
dispatch interface.</p>

<A NAME="332"><H2>Lesson Summary</H2></A>

<p>The <b>IDispatch</b> interface enables a client environment such as VBScript to use
a common entry point, the <b>Invoke()</b> method, to use your COM object. Arguments
passed to the <b>Invoke()</b> method are packed into <b>VARIANT</b> data structures.
These data structures contain one field that describes the type of data and a second
field that stores the actual data.</p>

<p>To enable a development language such as Visual Basic to create a programmatic
interface to your COM object, you generate a type library. The type library is a binary
file that contains a description of your COM object's methods, properties, and the
data types used. Visual Basic can use the type library information when making direct
calls to methods using function pointers obtained from a COM component's
vtable.</p>

<p>A dual interface allows calls through the dispatch interface or through the vtable,
according to the capabilities of the client.</p>

</BODY>
</HTML>







