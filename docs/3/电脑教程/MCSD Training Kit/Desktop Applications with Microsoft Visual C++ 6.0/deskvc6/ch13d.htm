<HTML>
<HEAD>
<TITLE>Lesson 3: Introduction to Debugging</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch13c.htm", "ch13e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="487"><H1>Lesson 3: Introduction to Debugging</H1></A>

<p>This lesson presents a general introduction to the Visual C++ integrated debugger.
Coverage of the extensive subject of debugging is best begun with an overview, rather
than with an immediate jump into specifics about the debugger. After attaining a solid
foundation about the debugger's purpose, as well as its advantages and limitations,
you will be better prepared to use the debugger, which is described in the next
lesson.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<ul>
<p><li> Understand the general manner in which a debugger works.</li></p>
<p><li> Understand specific features of the Visual C++ integrated debugger.</li></p>
<p><li> Use various macros, provided by the MFC framework that facilitate the task of
debugging.</li></p>
</ul>
<b>Estimated lesson time: 20 minutes</b>
</blockquote></div>
</p>


<A NAME="488"><H2>What Is a Debugger?</H2></A>

<p>Debugging is a general term for finding and correcting program logic errors. It is necessary to master the art of debugging to develop applications successfully.
A debugger is an application that facilitates the debugging process. The debugger runs
a program under tight control, and can freeze operations at any point to allow you to
check the program's status during execution.</p>

<p>The Visual C++ debugger is incorporated into the Visual Studio environment, and has
its own menu and toolbar commands. Before using the debugger, you must create a debug
build of your project. You cannot begin using the debugger until your code compiles
into an executable file without syntactic error.</p>

<p><li> <b>To create a debug build</b></li></p>

<ol>
<p><li> Right-click in the toolbar area and display the full <b>Build</b> toolbar (not
the <b>Build</b> minibar). On the <b>Build</b> toolbar, make sure the Win32 Debug
build configuration is selected as shown in Figure 13.2.</li></p>

<p>
<A HREF="javascript:fullSize('F13DA02x.htm')"> <img src="images/F13DA02.JPG" width=404 height=27 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 13.2</b> <i>The Win32 Debug build configuration</i><!-- /caption -->
</p>

<p><li>On the same toolbar, click the <b>Build</b> button.</li></p>
</ol>

<p>A debug operation consists of several steps, typically beginning in the text editor. To begin the debug operation, identify in the source code of a failing program the section where you suspect the problem originates, and then mark the first instruction of that section. Start the debugger, which executes the program until control reaches the mark you set at the start of the questionable section. When the debugger suspends the program's execution, you can then step through each instruction. This process gives you the opportunity to check current data values while the program is suspended, and ensure that the flow of control is proceeding along an expected path.</p>


<A NAME="489"><H2>Debug vs. Release</H2></A>

<p>The debug version of a product is the version with which you work during development
and testing while you strive to make the program error-free. The
debug version contains symbol information that the compiler places in the object file.
By reading both the original source files and the project's symbol information, the
debugger can associate each line of the source code with the corresponding binary
instructions in the executable image. The debugger runs the executable but uses the
source code to show the program's progress.</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>
Code that has been optimized by the compiler can cause the debugger to
behave in an unexpected manner. If strange errors occur when you step through code in
the debugger, check that the debug configuration of your project has compiler
optimization set to unavailable. Optimization is set on the <b>C/C++</b> page of the
<b>Project Settings</b> dialog box.</blockquote></div></p>

<p>The release version of a product is a more tightly compiled version that is
distributed to your customers. The release version contains only executable
in-structions optimized by the compiler, without the symbol information. You can
execute a release version inside the debugger; however, if you do, the debugger informs
you that the file has no symbol data. Conversely, you can execute the debug version of
a program normally, without the debugger. These execution processes have practical
consequences as a result of a Visual C++ feature known as just-in-time debugging. If
the program encounters an unhandled exception, the system's SEH mechanism causes
control to be returned to Visual C++, which then executes the debugger. The debugger
shows the instruction that caused the fault and displays data values as they existed
when the program stopped.</p>

<A NAME="490"><H2>MFC Debug Macros</H2></A>

<p>MFC provides several macros that serve as debugging aids and affect only debug
builds. We have already examined the <b>TRACE</b> macro and its variations, and seen
how it's possible to use <b>TRACE</b> to log a program's actions and state.
This section examines several other MFC macros, including <b>ASSERT</b> and its
variants <b>VERIFY</b> and <b>DEBUG_NEW</b>.</p>

<p>The <b>ASSERT</b> macro offers a convenient way to test assumptions during
application development without adding permanent error-checking code. For example, you
might want to check a pointer for a non-zero value before using it. One way you can perform this action is to add a specific <b>if</b> test, as demonstrated in the following code for a function that accepts a <b>CButton</b> pointer as its parameter:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
void SomeFunction(CButton* pbutton)
{
     if (pbutton)
     {
         // Use the pbutton pointer
         ...
     }
}</pre>
</td></tr>
</table>
</p>

<p>While such checks are good programming practices that help avoid potential problems,
they might no longer be warranted in a program's release version. Including
hundreds of such checks throughout a program can add unnecessary code to the finished
product&#8212;code that increases the program's size and slows its execution. This
unneeded code can be avoided by using an <b>ASSERT</b> macro, as demonstrated in the
following code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
void SomeFunction(CButton* pbutton)
{
     ASSERT(pbutton);   // Make sure that pbutton is non-zero
     // Use the pbutton pointer
     ...
}</pre>
</td></tr>
</table>
</p>

<p>If the expression passed to <b>ASSERT</b> evaluates to zero, the program halts with
a system message alerting you to the problem. As shown in Figure 13.3, the message
gives you the choice of terminating the application, ignoring the problem, or debugging
the application to learn more about the problem.</p>

<p>
<img src="images/F13DA03.JPG" width=359 height=217 border=0>
</p><p>
<!-- caption --><b>Figure 13.3</b> <i>ASSERT failure message</i><!-- /caption -->
</p>

<p>The <b>ASSERT</b> macro creates code only for debug builds and evaluates to nothing
in release builds. You can therefore insert hundreds of <b>ASSERT</b> statements in
your code without increasing the size of the final product. If you prefer to leave a
check in place for both debug and release builds, use the <b>VERIFY</b> macro instead,
which functions regardless of the build configuration.</p>

<p><b>ASSERT</b> can be used with any expression that yields a Boolean result, such as <b>ASSERT</b>(x &lt; y) and <b>ASSERT</b>(i &gt; 10), but its variants are more
specialized. The similar <b>ASSERT_VALID</b> macro, for example, is used only with
pointers to an object derived from the MFC <b>CObject</b> class. This macro does
everything <b>ASSERT</b> does, but also calls the object's <b>AssertValid</b> member
function to verify the object.</p>

<p>The <b>ASSERT_KINDOF</b> macro applies only to pointers to objects derived from <b>
CObject</b>. <b>ASSERT_KINDOF</b> tests that the pointer represents an object of a
specified class, or is an object of a class derived from the specified class. For
example, this line verifies that <b>pDoc</b> points to an object derived from <b>
CDocument</b>:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>ASSERT_KINDOF(CMyDocument, pDoc)</pre>
</td></tr>
</table>
</p>

<p>The <b>DEBUG_NEW</b> macro helps you find memory leaks that can result when a <b>
new</b> statement is not properly matched to a <b>delete</b> statement. The macro is
easy to use and requires the addition of only a single line to your source code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#define new DEBUG_NEW</pre>
</td></tr>
</table>
</p>

<p>With this definition in place, the compiler interprets every <b>new</b> statement
in your code as <b>DEBUG_NEW</b>, and MFC takes care of the rest. For debug builds, <b>DEBUG_NEW</b> keeps track of the file name and line number where each <b>new</b> statement occurs. Your program can then call the <b>CMemoryState:: DumpAllObjectsSince()</b> member function, which displays a list of <b>new</b>
allocations in the Visual C++ Output window, together with the file name and line
number where the allocation occurs. This type of information can aid in pinpointing
leaks. In release builds, <b>DEBUG_NEW</b> simply resolves to <b>new</b>.</p>

<A NAME="491"><H2>Lesson Summary</H2></A>

<p>This lesson introduced the concepts of the important process of debugging, in which
the developer locates and corrects logical errors in an application. It described in
general terms how a debugger works and the differences between release and debug
versions of a project, and explained some of the macros that MFC provides as aids to
debugging.</p>

<p>The <b>ASSERT</b> macro provides an effective means of alerting you to errors without
becoming a permanent part of your program's release version. Its variants <b>
ASSERT_VALID</b> and <b>ASSERT_KINDOF</b> are used with pointers to objects derived
from the MFC <b>CObject</b> class. The <b>ASSERT</b> macro is used with a Debug build of an application. The <b>VERIFY</b> macro may be used with both debug and release builds. The <b>DEBUG_NEW</b> macro finds cases where free store memory is allocated but not properly returned to the system.</p>

</BODY>
</HTML>







