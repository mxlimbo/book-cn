<HTML>
<HEAD>
<TITLE>Lesson 2: Reusing COM Objects</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch10b.htm", "ch10d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="389"><H1>Lesson 2: Reusing COM Objects</H1></A>

<p>One of the principal benefits of object-oriented software development is that it
provides a structure that enables code reuse. After you have created an object that
performs a well-defined service in an efficient and error-free manner, you will
probably want to reuse that object many times. In this lesson, you will learn about the
different ways in which COM objects can use the services of other COM objects. In
particular, this includes a discussion of two common reuse techniques, containment and
aggregation. These techniques allow you to embed existing COM objects within the COM
objects you develop, exposing the interfaces of the embedded objects as interfaces of
the containing object.</p>

<p>
<div class="sidebar"><blockquote>

<b>After this lesson, you will be able to:</b>

<ul>

<p><li> Describe the difference between implementation inheritance and interface
inheritance.</li></p>

<p><li> Describe the difference between containment and aggregation as methods of object
reuse.</li></p>

<p><li> Describe how to implement the <b>IUnknown</b> interface of an aggregatable
object.</li></p>

<p><li> Describe how aggregation is implemented by ATL.</li></p>

</ul>

<b>Estimated lesson time: 30 minutes</b>

</blockquote></div>
</p>


<A NAME="390"><H2>Object Reuse in C++ and COM</H2></A>

<p>C++ programmers generally reuse existing class definitions using either the
<i>containment</i> or <i>inheritance</i> techniques. Containment involves the
declaration of an object within a class scope, as shown in the following example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#include &quot;Acme.h&quot;  // Contains AcmeViewer class definition
        // Defines the member functions SetFile() and Display()
class MyViewer
{
protected:
    AcmeViewer m_obj;

public:
    MyViewer() {m_obj.SetFile(&quot;C:\images\scully.gif&quot;, AV_TYPE_GIF);}
    DisplayGif() {m_obj.Display();}
}</pre>
</td></tr>
</table>
</p>

<p>This code defines a simple class called <b>MyViewer</b>, which contains an instance
of the pre-existing <b>AcmeViewer</b> class. <b>MyViewer</b> reuses the code contained
in the <b>AcmeViewer</b> class. The <b>MyViewer</b> constructor initializes the
contained <b>AcmeViewer</b> object, and the <b>MyViewer::DisplayGif()</b> function uses
services provided by the <b>AcmeViewer</b> object. The <b>MyViewer</b> class can
control access to the <b>AcmeViewer</b> object and the way in which the object's
services are used.</p>

<p>Inheritance is a powerful reuse technique that is central to the C++ language. Given
what you already know about the <b>AcmeViewer</b> class, it should be obvious that the
following declaration:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#include &quot;Acme.h&quot;

class MyViewer : public AcmeViewer
{
public:
    MyViewer() {SetFile(&quot;C:\images\scully.gif&quot;, AV_TYPE_GIF);}
}</pre>
</td></tr>
</table>
</p>

<p>will allow you to call public or protected member functions of the <b>AcmeViewer</b>
class as member functions of a <b>MyViewer</b> object, as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>MyViewer aViewer;
aViewer.Display();</pre>
</td></tr>
</table>
</p>

<p>COM supports containment, but it does not support inheritance in the same way that
C++ does. In the example just given, the <b>MyViewer</b> class inherits functionality
implemented by the <b>AcmeViewer</b> class. The public or protected member functions of
the <b>AcmeViewer</b> class are available to the <b>MyViewer</b> class. This kind of
inheritance is known as <i>implementation</i> inheritance.</p>

<p>COM does not support implementation inheritance. COM makes a strict logical
distinction between the interface that a COM object provides and the object's
implementation of that interface. A published COM interface, which is identified around
the world by its GUID, is <i>immutable</i>&#8212;it is guaranteed never to change.
Although there might be many COM objects that implement the functionality described by
the interface in many different ways, clients will always know how to communicate with
any of these objects. An interface represents a contract between a COM server and a
client that specifies what kind of data the object is expecting and what kind of data
it will return.</p>

<p>Implementation inheritance causes the implementation of a derived class to be dependent
on the implementation of its base class. If the implementation of the base class
changes, the derived classes might cease to function properly and would, therefore,
need to be re-implemented. This can cause serious problems in large-scale development,
particularly if you do not have access to the source code of the base classes. The
separation between interface and implementation that COM provides helps to alleviate
these kind of problems; but it also means that you cannot reuse COM components by
deriving one from another as you can with C++ classes.</p>

<p>COM does support a form of inheritance known as <i>interface</i> inheritance.
Interfaces in C++ are implemented as abstract classes containing only pure virtual
functions that specify, but do not implement, the interface methods. By deriving one
interface from another, you specify the structure of the vtable that will hold pointers
to the instantiated methods. For example, the following definition will create a
properly structured vtable that contains pointers to the three <b>IUnknown</b> methods,
followed by pointers to the methods defined by <b>IEncoder</b>:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>IEncoder : public IUnknown
{
    // IEncoder methods declared here
}</pre>
</td></tr>
</table>
</p>

<p>It is the immutability of COM interfaces that makes interface inheritance possible.
You can derive your COM interface from any other COM interface and be assured that no
one will change the definition of the parent interface without your knowledge and thus
mess up your vtable.</p>


<A NAME="391"><H2>Containment and Aggregation</H2></A>

<p>Developers of COM objects reuse existing COM objects by using either <i>
containment</i> or <i>aggregation</i> techniques. Containment and aggregation depend on
a relationship in which one object (referred to as the <i>outer object</i>) reuses
another object (referred to as the <i>inner object</i>).</p>


<A NAME="392"><H3>Containment</H3></A>

<p>COM containment works in a similar manner to the C++ containment technique discussed
at the beginning of this lesson. The outer object creates an inner object (typically by
calling <b>CoCreateInstance()</b>) and stores a reference to the inner object as a data
member. The outer object implements the interfaces of the inner object through stub
interfaces that forward method calls to the inner object.</p>

<p>Figure 10.1 shows how a COM object with the <b>ICar</b> interface contains a COM
object with the <b>IVehicle</b> interface and how the outer object can expose both
interfaces.</p>

<p>
<A HREF="javascript:fullSize('f10DA01x.htm')"> <img src="images/f10DA01.jpg" width=404 height=251 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 10.1</b> <i>COM containment</i><!-- /caption -->
</p>

<p>The outer object is not required to expose all interfaces of the inner object. Just as
with C++ containment, the interface on the outer object can control access to the inner
object, and can also control the way in which the inner object's services are used.
The outer object does not forward calls to any of the <b>IUnknown</b> interface methods
of the inner object because the inner object does not have any knowledge of the
interfaces exposed by the outer object. For example, if a client of the object depicted
in Fig 10.1 requested an <b>IUnknown</b> pointer, it would expect to be able to use
this pointer to access the <b>ICar</b> interface as well as the <b>IVehicle</b>
interface. A pointer to the <b>IUnknown</b> interface of the inner object would not be
able to service requests for an <b>ICar</b> pointer.</p>


<A NAME="393"><H3>Aggregation</H3></A>

<p>As with containment, the outer object stores a reference to the <b>IUnknown</b>
interface of the inner object. Unlike containment, however, the outer object exposes
interfaces of the inner object directly to the client, rather than implementing
interface stubs for them. This means that aggregation does not incur the overhead of
forwarding method calls imposed by containment.</p>

<p>Figure 10.2 shows how the interface of an inner object is exposed
through aggregation.</p>

<p>
<A HREF="javascript:fullSize('F10DA02x.htm')"> <img src="images/F10DA02.JPG" width=404 height=235 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 10.2</b> <i>COM aggregation</i><!-- /caption -->
</p>

<p>For aggregation to work, the inner object must be <i>aggregatable</i>&#8212;it must
be written to support aggregation. Because clients of the outer object can now
obtain interface pointers exposed by the inner object, they are able to call the <b>
IUnknown</b> interface methods of the inner object. Because the inner object will not
be able to service calls to <b>QueryInterface()</b>, <b>AddRef()</b> and <b>
Release()</b> on behalf of the outer object, client calls to the inner object's <b>IUnknown</b>
interface must be delegated to the outer object's <b>IUnknown</b> interface (the
<i>controlling unknown</i>).</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Bear in mind that a client of an aggregated object knows nothing
of the aggregation, which as far as the client is concerned, is implementation detail.
The client sees a single COM object that exposes a single <b>IUnknown</b> pointer. 
If the client receives pointers to interfaces of the inner object, it will assume
that they are interfaces exposed by the outer object.
</blockquote></div>
</p>

<p>When the outer object creates the inner object, it uses the second argument of the
<b>CoCreateInstance()</b> function to pass the address of the controlling unknown to
the inner object's class factory. If this address is not NULL, the inner object
knows that it is being aggregated and delegates <b>IUnknown</b> method calls from
external clients to the controlling unknown.</p>

<p>However, the inner object must be able to handle <b>IUnknown</b> method calls from
external clients (which are intended for the controlling unknown) differently from <b>
IUnknown</b> method calls that originate from the controlling unknown (which are used
by the outer object to discover the interfaces and control the lifetime of the
aggregated object). This means that an aggregatable COM object must provide two
versions of the <b>IUnknown</b> interface: a <i>delegating</i> version and a <i>
non-delegating</i> version. The outer component calls the non-delegating <b>
IUnknown</b> methods; external clients call the delegating <b>IUnknown</b> methods. The
delegating methods redirect the calls to the controlling unknown (if the
object is aggregated), or to the non-delegating unknown (if the object is not
aggregated).</p>


<A NAME="394"><H2>Implementing Aggregation Using ATL</H2></A>

<p>ATL provides you with a number of macros and base-class methods that facilitate the
implementation of component aggregation. To create an aggregatable (inner) object, you
use the ATL Object Wizard to add a new COM object to an ATL project and specify that
the component is to support aggregation. You select the appropriate option on the <b>
Attributes</b> page, as shown in Figure 10.3.</p>

<p>
<A HREF="javascript:fullSize('f10DA03x.htm')"> <img src="images/f10DA03.jpg" width=404 height=268 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 10.3</b> <i>ATL Object Wizard aggregation options</i><!-- /caption -->
</p>

<p>By default, ATL COM objects are created as aggregatable. Selecting the <b>No</b>
option in the aggregation group will create a non-aggregatable object. The <b>Only</b>
option will create an object that can be used only as an aggregatable object.</p>

<p><li> <b> To implement an outer object:</b></li></p>

<ol>

<p><li> Add an <b>IUnknown</b> pointer to your class object and initialize it to NULL in
the constructor. For the purposes of this example, we will refer to this pointer as <b>
m_pUnkInner</b>.</li></p>

<p><li> Inside your class definition, declare the macro <b>DECLARE_GET_
CONTROLLING_UNKNOWN</b>. This macro defines a function named <b>
GetControllingUnknown()</b>.</li></p>

<p><li> Override the methods <b>FinalConstruct()</b> and <b>FinalRelease()</b>. These
are methods of the <b>CComObjectRootBase</b> base class, which are called as the last
steps for creating and destroying a COM object.</li></p>

<p><li> In <b>FinalConstruct()</b>, you call <b>CoCreateInstance()</b>, passing the
CLSID of the inner object you want to create as the first argument. Pass the return
value of the <b>GetControllingUnknown()</b> function as the second argument to supply
the inner class with the controlling <b>IUnknown</b> pointer. Pass the address
of the <b>m_pUnkInner</b> pointer as the fifth argument, to receive a pointer
of the inner object's <b>IUnknown</b> interface. An example of an overridden <b>
FinalConstruct()</b> function follows:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>HRESULT FinalConstruct()
{
    return CoCreateInstance(CLSID_InnerObject,
        GetControllingUnknown(), CLSCTX_ALL,
        IID_IInnerObject, &amp;m_pUnkInner);
}</pre>
</td></tr>
</table>
</p>

<p><li> In <b>FinalRelease</b>, call <b>IUnknown::Release()</b> on the inner
object.</li></p>

<p><li> Using the <b>COM_INTERFACE_ENTRY_AGGREGATE</b> macro, add an entry to the outer
object's COM map for the interface of the inner object. This is a specialization of
the <b>COM_INTERFACE_ENTRY</b> macro that handles aggregated objects. <b>
COM_INTERFACE_ENTRY_AGGREGATE</b> takes an extra <b>IUnknown *</b> argument that points
to the inner unknown.</li></p>

<p><li> Add the interface definition for the inner object to the .idl file of the outer
object, and reference that interface in the [coclass] section.</li></p>

</ol>


<A NAME="395"><H2>Lesson Summary</H2></A>

<p>C++ developers are accustomed to using implementation inheritance as a code reuse
technique. COM makes a strict logical distinction between interface and implementation
and insists that interfaces remain immutable around the world. This means that COM can
support only interface inheritance (reuse of the interface specification) and not
implementation inheritance.</p>

<p>COM supports two forms of object reuse: aggregation and containment. These techniques
depend on a relationship in which an outer object reuses an inner
object. When an inner object is contained, its interfaces are not exposed directly
to a client but instead are mediated through stub interfaces implemented by the outer
object. An aggregated object exposes its interfaces directly to the client. When
aggregating objects, you must implement the inner and outer objects so that a client
will be able to access only the controlling unknown&#8212;a pointer to the <b>
IUnknown</b> interface of the outer object. ATL provides you with a number of macros
and base-class methods that facilitate the implementation of component aggregation.</p>


</BODY>
</HTML>







