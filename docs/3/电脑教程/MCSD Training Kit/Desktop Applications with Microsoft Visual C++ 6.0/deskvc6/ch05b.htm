<HTML>
<HEAD>
<TITLE>Lesson 1: Working with Dialog Boxes</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch05a.htm", "ch05c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="182"><H1>Lesson 1: Working with Dialog Boxes</H1></A>

<p>In <a href="ch04b.htm#162">Lesson 2</a> of Chapter 4, you learned how to create a dialog class, based on a
dialog template, that could be used to display a dialog box within your
application. In this lesson, you will learn how to work with the dialog class in your
application code. You will pass data between the dialog box controls and your
application, which will process messages that originate from the controls. You will
also learn how to implement dialog templates as pages in a property sheet.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<ul>
<p><li> Describe how to implement dialog data exchange and dialog data validation.</li></p>
<p><li> Use ClassWizard to add member variables to represent dialog data.</li></p>
<p><li> Use ClassWizard to add a function that handles a message from a dialog box control.</li></p>
<p><li> Describe how to implement a property sheet.</li></p>
</ul>
<b>Estimated lesson time: 60 minutes</b>
</blockquote></div>
</p>

<A NAME="183"><H2>Dialog Data Exchange and Validation</H2></A>

<p>Dialog data exchange (DDX) is an easy way to initialize the controls in your dialog
box and to gather data input by the user. Dialog data validation (DDV) provides an easy
way to validate data entry in a dialog box.</p>

<p>DDX and DDV are implemented within the dialog class and use a code architecture
similar to the message map architecture you saw in <A HREF="ch03a.htm">Chapter 3</A>. Member variables within
the dialog class correspond to the controls in your dialog template. Global MFC
functions are used to transfer data between the member variables and the controls and
to validate data input by the user.</p>

<p>When ClassWizard creates a dialog class, it adds code to the class to implement the
basic DDX/DDV architecture. You can then use ClassWizard to add to the dialog class
member variables that correspond to controls in your dialog template, and to specify
simple validation rules for the data that is entered into the controls.</p>

<p>When you use ClassWizard to add DDX member variables, ClassWizard performs the
following tasks for you:</p>

<ul>
<p><li> The member variables are added to the class definition.</li></p>
<p><li> The member variables are initialized in the class constructor.</li></p>
<p><li> DDX functions are added to the class to handle the transfer of data between the DDX member variables and the dialog box controls.</li></p>
<p><li> If you use ClassWizard to specify validation criteria for your variables, DDV functions are added to the class to validate the data input by the user to the dialog box controls before saving that data to the DDX member variables.</li></p>
</ul>


<p>The DDX and DDV functions are global MFC functions that are provided to perform the
task of transferring data between controls and dialog class variables (DDX functions),
and to validate data (DDV functions). MFC defines a number of DDX functions to
correspond to the various types of common controls. The most commonly used functions
are <b>DDX_Text()</b>, which transfers data between an edit control and a CString
member variable of the dialog class; and <b>DDX_Check()</b>, which transfers the select
state of a check box control to or from a BOOL member variable of the dialog class. MFC
defines a number of DDV functions to correspond to the kinds of validation that you
might want to apply to string or numeric values. Example functions are <b>
DDV_MaxChars()</b> and <b>DDV_MinMaxInt()</b>. You can find a complete list of these
functions by going to the <b>Index</b> tab of the Visual C++ Help file and typing <b>
DDX_</b> (or <b>DDV_</b>) in the <b>Keyword</b> box.</p>

<p>Typically, you will define a member variable (and thus a DDX function) for
every control in your dialog box that accepts user input to set its data content or its
state. You need to specify validation only where it is necessary to control the range
of the input data.</p>

<p>The following exercise shows you how to use ClassWizard to add DDX member variables and to specify validation criteria.</p>

<p><li> <b>To add DDX member variables using ClassWizard</b></li></p>

<ol>
<p><li> Return to the MyApp project.</li></p>

<p><li> Press CTRL+W to open ClassWizard. Click the <b>Member Variables</b> tab.</li></p>

<p><li> In the <b>Class name</b> box, click the <b>CConnectDialog</b> class.</li></p>

<p><li> In the <b>Control IDs</b> box, click <b>IDC_USERID</b>.</li></p>

<p><li> Click <b>Add Variable</b>. The <b>Add Member Variable</b> dialog box appears.</li></p>

<p><li> In the <b>Member variable name</b> box, type <b>m_strUserID</b>.</li></p>

<p><li> Make sure that the <b>Category</b> box shows <b>Value</b> and the <b>Variable type</b> box shows <b>CString</b>.</li></p>

<p><li> Click <b>OK</b> to add the variable. The variable name and type will appear selected in the <b>Control IDs</b> box next to the IDC_USERID. This variable will be used to set the text that appears in the User ID edit control and retrieve the text entered into the control by the user.</li></p>

<p><li> Beneath the <b>Control IDs</b> list box is the <b>Maximum Characters</b> edit box. Type <b>15</b> to create a validation function that will limit the length of the input string to 15 characters.</li></p>

<p><li> Repeat the above process to add a CString value variable named <b>m_strPassword</b>, with a maximum length of 15 characters, that is associated with the <b>IDC_PASSWORD</b> control ID.</li></p>

<p><li> Add an <b>int</b> value variable named <b>m_nAccess</b>, which is associated with the <b>IDC_ACCESS</b> control ID. Note that for an integer variable you are able to specify the minimum and maximum values that can be input. In the <b>Minimum value</b> box, type <b>1</b>, and in the <b>Maximum value</b> box, type <b>5</b>.</li></p>

<p><li> Add a BOOL value variable named <b>m_bConnect</b>, which is associated with the <b>IDC_CHECKCONNECT</b> control ID. This will set the control state to selected (TRUE) or cleared (FALSE), and retrieve the control state set by the user.</li></p>

<p><li> Click <b>OK</b> to close ClassWizard. You can now build and run the MyApp application.</li></p>

<p><li> Choose the <b>Connect</b> command from the <b>Data</b> menu and type a username
and password. See how the validation rule that you specified in step 9 makes it
impossible to enter more than 15 characters for a user name. To achieve this behavior,
the <b>DDV_MaxChars()</b> function sends a EM_LIMITTEXT message to the control as it is
initialized. This method of validation is more immediate and user-friendly than the
alternative method of checking the value in the field after the user has clicked <b>
OK</b> (or <b>Connect</b> in our case).</li></p>

<p><li> As an example of the usual form of validation, type <b>6</b> in the <b>Access
level</b> edit box and click <b>Connect</b>. The validation function that has been
assigned to this field should display a message box warning you of the invalid value,
and return you to the offending control. In a real-world application, you would
probably implement the access level selection as a combo box with a limited set of
values from which the user could select one&#8212;thus eliminating the need for a
validation function.</li></p>

<p><li> Click <b>Cancel</b> to close the dialog box.</li></p>
</ol>

<A NAME="184"><H3>How ClassWizard Implements Dialog Data Exchange and Validation</H3></A>

<p>To see the code that ClassWizard has added to implement the DDX/DDV architecture,
open the ConnectDialog.h file and inspect the class declaration. You will see that
ClassWizard has added the following member variables:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
//{{AFX_DATA(CConnectDialog)
enum {IDD = IDD_CONNECTDIALOG};
CString     m_strUserID;
CString     m_strPassword;
BOOL        m_bConnect;
int         m_nAccess;
//}}AFX_DATA</pre>
</td></tr>
</table>
</p>

<p>Like all code maintained by ClassWizard, these declarations are enclosed within a
special //{{AFX_ comment block.</p>

<p>Locate the class constructor in the ConnectDialog.cpp file, which contains the
following ClassWizard code to provide default initialization for the variables:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
//{{AFX_DATA_INIT(CConnectDialog)
m_strUserID = _T(&quot;&quot;);
m_strPassword = _T(&quot;&quot;);
m_bConnect = FALSE;
m_nAccess = 0;
//}}AFX_DATA_INIT</pre>
</td></tr>
</table>
</p>

<p>The function that actually does the work of passing data between the dialog box
controls and the application is <b>CWnd::DoDataExchange()</b>. An overloaded version of
this function is automatically provided for you when you use ClassWizard to derive a
class from <b>CDialog</b>. ClassWizard updates the overloaded <b>DoDataExchange()</b>
function by adding DDX and DDV functions.</p>

<p>Your <b>CConnectDialog::DoDataExchange()</b> function can be found in the
ConnectDialog.cpp file, and at present it should look as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
void CConnectDialog::DoDataExchange(CDataExchange* pDX)
{
     CDialog::DoDataExchange(pDX);
     //{{AFX_DATA_MAP(CConnectDialog)
     DDX_Text(pDX, IDC_USERID, m_strUserID);
     DDV_MaxChars(pDX, m_strUserID, 15);
     DDX_Text(pDX, IDC_PASSWORD, m_strPassword);
     DDV_MaxChars(pDX, m_strPassword, 15);
     DDX_Check(pDX, IDC_CHECKCONNECT, m_bConnect);
     DDX_Text(pDX, IDC_ACCESS, m_nAccess);
     DDV_MinMaxInt(pDX, m_nAccess, 1, 5);
     //}}AFX_DATA_MAP
}
</pre>
</td></tr>
</table>
</p>

<p>The <i>pDX</i> parameter that is passed to the DDX and DDV functions is an object of
the MFC class <b>CDataExchange</b>, which represents the context of the current data
exchange. The <b>CDataExchange</b> class contains a member variable m_bSaveAndValidate,
which indicates the direction of the data exchange. If m_bSaveAndValidate is TRUE, then
data is being passed from the controls to be validated and stored in the dialog class
member variables. If m_bSaveAndValidate is FALSE, data is being passed to the onscreen
dialog box to initialize the controls.</p>

<A NAME="185"><H3>Dialog Data Exchange and Validation Process</H3></A>

<p>The <b>DoDataExchange()</b> function is called by the <b>CWnd::UpdateData()</b>
function. <b>UpdateData()</b> creates the <b>CDataExchange</b> object that <b>
DoDataExchange()</b> receives as a parameter and passes to the DDX/DDV functions.</p>

<p>The <b>UpdateData()</b> function takes a single BOOL parameter that indicates the
direction of the data exchange. The <b>CDialog::OnInitDialog()</b> function, which is
called when a dialog box is created, calls the <b>UpdateData()</b> function with a <i>
FALSE</i> parameter to initialize the controls in the dialog box with the values held
in the dialog class member variables. When a user clicks <b>OK</b> in a dialog box, the
default <b>CDialog::OnOK()</b> handler calls the <b>UpdateData()</b> function with a
<i>TRUE</i> parameter to perform any data validation and to save the values in the
controls to the dialog class. The process is illustrated in Figure 5.1.</p>

<p>
<A HREF="javascript:fullSize('f05DA01x.htm')"> <img src="images/f05DA01.jpg" width=404 height=104 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 5.1</b> <i>Dialog data exchange and validation</i><!-- /caption -->
</p>

<p>Your code might call <b>CWnd::UpdateData()</b> at any time to perform data exchange
and validation. For example, suppose you have an image viewing application that allows
the user to alter the image resolution and color depth with controls in a modeless
dialog box. The updated image is displayed as soon as the user changes the values in
the controls. In such a case, you might call <b>UpdateData()</b> every time the
settings are changed so that they would be saved by the dialog class, and thus made
accessible to the application drawing functions.</p>

<p><li> <b>To set initial values for dialog box controls</b></li></p>

<ol>
<p><li> Return to the MyApp project.</li></p>

<p><li> On the <b>ClassView</b> tab, expand the <b>CMyAppApp</b> class icon.</li></p>

<p><li> Double-click the <b>OnDataConnect()</b> icon to edit the function.</li></p>

<p><li> Between the declaration of the <b>CConnectDialog</b> object and the call to the <b>DoModal()</b> function, add the following lines of code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
aCD.m_nAccess = 1;
aCD.m_bConnect = TRUE;</pre>
</td></tr>
</table>
</p>

<p>The complete function should now look as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CMyAppApp::OnDataConnect() 
{
     CConnectDialog aCD;
     aCD.m_nAccess = 1;
     aCD.m_bConnect = TRUE;
     aCD.DoModal();
}</pre>
</td></tr>
</table>
</p>

<p><li> Build and run the MyApp application. On the <b>Data</b> menu, click <b>
Connect</b>. Confirm that the values you assigned to the member variables of the dialog
object are displayed in the dialog box controls.</li></p>
</ol>

<p><li> <b>To set the values of dialog box controls</b></li></p>

<ol>
<p><li> Return to the <b>OnDataConnect()</b> function.</li></p>

<p><li> Remove the following line:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>aCD.DoModal();</pre>
</td></tr>
</table>
</p>


<p><li> In its place, add the following code:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>if(aCD.DoModal() == IDOK)
{
     CString strMessage;
     strMessage.Format(&quot;User %s logged in&quot;, aCD.m_strUserID);
     AfxMessageBox(strMessage);
}</pre>
</td></tr>
</table>
</p>

<p>An IDOK return value from the <b>DoModal()</b> function signifies that the user has
clicked the <b>OK</b> button to close the dialog box and that the data entered into the
controls has passed the associated validation functions. The data entered by the user
is stored in the dialog class's DDX member variables&#8212;in our case, the value
entered into the <b>User ID</b> edit control is now contained
in the CConnectDialog::m_strUserID variable.</p>

<p><li> Build and run the MyApp application and test the <b>Connect</b> command on the
<b>Data</b> menu to ensure that the User ID value that you entered is displayed in the
message box.</li></p>
</ol>

<A NAME="186"><H3>Custom Dialog Data Exchange and Validation</H3></A>

<p>You can define your own DDX and DDV functions. DDX functions take the pointer to a
<b>CDataExchange</b> object, the ID of the dialog box control, and the dialog class
member variable as parameters. DDV functions also take the pointer to a <b>
CDataExchange</b> object and the dialog class member variable. They might also specify
extra parameters to set the validation constraints, just as <b>DDV_MinMaxInt()</b>
takes parameters to specify the minimum and maximum values. DDV functions must <i>
always</i> be placed directly after the DDX functions to which they refer. For more
information on creating custom DDX/DDV functions, refer to the Technical Note
&quot;TN026: DDX and DDV Functions&quot; in the Visual C++ Help file.</p>

<p>You might also need to add your own DDV functions if you want to set validation
parameters by using variable, rather than constant, values; or if you want to perform
conditional validation. As an example, consider the following code. It applies a
different validation function according to whether or not the IDC_FEMALE check box
control is selected. The maximum age for females and males is passed as a variable.</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
//{{AFX_DATA_MAP(CMyClass)
DDX_Check(pDX, IDC_FEMALE, m_bFemale);
DDX_Text(pDX, IDC_EDIT1, m_age);
//}}AFX_DATA_MAP
if (m_bFemale)
    DDV_MinMax(pDX, m_age, 0, m_maxFemaleAge);
else
    DDV_MinMax(pDX, m_age, 0, m_maxMaleAge);</pre>
</td></tr>
</table>
</p>

<p>This code sample also illustrates the important point that all custom DDX/DDV
functions must be placed <i>outside</i> the //{{AFX_ comment block that delimits code
maintained by ClassWizard.</p>

<p>In the following exercise, you will add a custom validation function that will
require the user to enter a value for the <b>UserID</b> field.</p>

<p><li> <b>To add custom validation to the MyApp application</b></li></p>

<ol>
<p><li> Add the following global function declaration to the ConnectDialog.h file, <i>
outside</i> the <b>CConnectDialog</b> class defintion:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void PASCAL DDV_Required(CDataExchange * pDX, CString str);</pre>
</td></tr>
</table>
</p>


<p><li> Add the <b>DDV_Required()</b> function definition as follows to the bottom of
the ConnectDialog.cpp file:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
void PASCAL DDV_Required(CDataExchange * pDX, CString str)
{
     if(pDX-&gt;m_bSaveAndValidate &amp;&amp; str.IsEmpty())
     {
          AfxMessageBox(&quot;Please enter the User ID.&quot;);
          pDX-&gt;Fail();
     }
}
</pre>
</td></tr>
</table>
</p>

<p>Note how the CDataExchange::m_bSaveAndValidate member variable is queried to affirm
that data validation is taking place. Note, too, how the function <b>
CDataExchange::Fail()</b> is used to abandon the validation process and restore the
focus to the control that has failed the validation.</p>


<p><li> Locate the <b>CConnectDialog::DoDataExchange()</b> function implementation in
the ConnectDialog.cpp file. Select the following two lines:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
DDX_Text(pDX, IDC_USERID, m_strUserID);
DDV_MaxChars(pDX, m_strUserID, 15);</pre>
</td></tr>
</table>
</p>


<p><li> Press CTRL+X to remove these two lines from their current position in the //{{AFX_DATA_MAP comment block and place them on the Clipboard.</li></p>

<p><li> Use CTRL+V to paste the two lines to a new location beneath the //{{AFX_DATA_MAP comment block, but still inside the <b>DoDataExchange()</b> function.</li></p>

<p><li> Immediately following these two lines, add the following line to call your new <b>DDV_Required()</b> function:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>DDV_Required(pDX, m_strUserID);</pre>
</td></tr>
</table>
</p>

<p>Your <b>DoDataExchange()</b> function should now look as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CConnectDialog::DoDataExchange(CDataExchange* pDX)
{
     CDialog::DoDataExchange(pDX);
     //{{AFX_DATA_MAP(CConnectDialog)
     DDX_Text(pDX, IDC_PASSWORD, m_strPassword);
     DDV_MaxChars(pDX, m_strPassword, 15);
     DDX_Check(pDX, IDC_CHECKCONNECT, m_bConnect);
     DDX_Text(pDX, IDC_ACCESS, m_nAccess);
     DDV_MinMaxInt(pDX, m_nAccess, 1, 5);
     //}}AFX_DATA_MAP

     DDX_Text(pDX, IDC_USERID, m_strUserID);
     DDV_MaxChars(pDX, m_strUserID, 15);
     DDV_Required(pDX, m_strUserID);
}</pre>
</td></tr>
</table>
</p>

<p><li> Build and run the MyApp application and test the <b>Connect</b> command on the
<b>Data</b> menu. See what happens if you try to click the <b>Connect</b> button
without entering a User ID.</li></p>
</ol>

<A NAME="187"><H2>Using OnInitDialog() to Initialize Controls</H2></A>

<p>Certain types of controls require more than the standard initialization provided by
the MFC-supplied DDX functions, or more than can be easily achieved by writing a custom
DDX function. An example is the <b>Connect to Data Source</b> dialog box in the MyApp
application, which displays a list of available data sources in a list box control. The
data that the list box displays can vary as data sources are added or removed from the
system. MFC provides the functions <b>DDX_LBIndex</b> and <b>DDX_LBString</b> so that
you can set the initial selection and retrieve the user selection, but you cannot use
these functions to set up the list box items.</p>

<p>The usual way to set up list box items is to provide an overloaded version of the
<b>CDialog::OnInitDialog()</b> virtual function for your class. <b>OnInitDialog()</b>
is the function that calls <b>CWnd::UpdateData()</b> (and ultimately the DDX/DDV
functions) when your dialog class is initialized. <b>OnInitDialog()</b> is the
appropriate place to perform custom initialization of dialog box controls because it is
called after the control windows have been created but before they are displayed.</p>

<p>MFC provides classes to correspond to each of the Windows common controls.
Using ClassWizard, you can create objects of these control classes as data members
of your dialog class. These objects are associated with the controls in your dialog box
by means of a <b>DDX_Control()</b> function placed in the <b>DoDataExchange()</b>
function. You can use these control objects to initialize or update the dialog box
controls. </p>

<p>The following exercises show you how to add an object of the MFC class <b>CListBox</b>
to your dialog class that corresponds to the <b>Data Source</b> list box, and how to
use the member object to initialize the list and set the initial selection.</p>

<p><li> <b>To add a CListBox member variable</b></li></p>

<ol>
<p><li> Press CTRL+W to open ClassWizard. Click the <b>Member Variables</b> tab.</li></p>
<p><li> In the <b>Class name</b> box, click <b>CConnectDialog</b>.</li></p>
<p><li> In the <b>Control IDs</b> box, click <b>IDC_DSNLIST</b>.</li></p>
<p><li> Click <b>Add Variable</b>. The <b>Add Member Variable</b> dialog box appears.</li></p>
<p><li> In the <b>Member variable name</b> box, type <b>m_lbDSN</b>.</li></p>
<p><li> In the <b>Category</b> box, click <b>Control</b>.</li></p>
<p><li> Click <b>OK</b> to add the variable. The variable name and type will appear selected in the <b>Control IDs</b> box next to IDC_DSNLIST.</li></p>
<p><li> Click <b>OK</b> to close ClassWizard.</li></p>
</ol>

<p><li> <b>To overload the OnInitDialog() function</b></li></p>

<ol>
<p><li> Press CTRL+W to open ClassWizard. Click the <b>Message Maps</b> tab.</li></p>
<p><li> In the <b>Class name</b> box, click <b>CConnectDialog</b>.</li></p>
<p><li> With the <b>CConnectDialog</b> class name selected in the <b>Object IDs</b> box, click <b>WM_INITDIALOG</b> in the <b>Messages</b> box.</li></p>
<p><li> Click the <b>Add Function</b> button.</li></p>
<p><li> Click the <b>Edit Code</b> button. Notice that ClassWizard will include a call to the base class where it is necessary. <b>CDialog::OnInitDialog()</b> is called so that <b>CWnd::UpdateData()</b> will be called to initialize the controls. Replace the // TODO comment in the function implementation with the following code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
m_lbDSN.AddString(&quot;Accounts&quot;);
m_lbDSN.AddString(&quot;Admin&quot;);
m_lbDSN.AddString(&quot;Management&quot;);</pre>
</td></tr>
</table>
</p>

<p>Note how the m_lbDSN variable that you added is used to set up the members of the
list box.</p>
</ol>

<p>You can also use your <b>CListBox</b> member object to retrieve the choice made by
the user. You can use the <b>CListBox::GetCurSel()</b> function to get the zero-based
index that indicates the user's selection. You can then pass the index to the <b>
CListBox::GetText()</b> function to retrieve the item text. In the following exercise,
you will retrieve the data source name that the user selects and save it to the
CMyAppApp::m_strDSN variable. This variable is used to store the name of the data
source displayed on the status bar. The best place to implement this code is in a
handler for the <b>OK</b> button for your dialog class because users click the <b>
OK</b> button to indicate that they want to commit their selections. You must be sure
to call the default <b>CDialog::OnOK()</b> handler as it is this function that calls
the <b>CWnd::UpdateData()</b> function.</p>

<p><li> <b>To retrieve the user list box choice</b></li></p>

<ol>
<p><li> Press CTRL+W to open ClassWizard. Click the <b>Message Maps</b> tab.</li></p>
<p><li> In the <b>Class name</b> box, click <b>CConnectDialog</b>.</li></p>
<p><li> In the <b>Object IDs</b> box, click <b>IDOK</b>. In the <b>Messages</b> box, click <b>BN_CLICKED</b>.</li></p>
<p><li> Click the <b>Add Function</b> button. Accept <b>OnOK</b> as the name for the function.</li></p>
<p><li> Click the <b>Edit Code</b> button. Replace the // TODO comment in the function implementation with the following code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
CMyAppApp * pApp = dynamic_cast&lt;CMyAppApp *&gt;(AfxGetApp());
ASSERT_VALID(pApp);
int nChoice = m_lbDSN.GetCurSel();

if(nChoice != LB_ERR)
{
     m_lbDSN.GetText(nChoice, pApp-&gt;m_strDSN);
     pApp-&gt;m_isDatabaseConnected = TRUE;
}
</pre>
</td></tr>
</table>
</p>
</ol>

<p>You can now build and run the MyApp application. Test your dialog box to ensure that
the list box choices appear correctly. Select a data source name and click <b>OK</b>.
The data source name that you choose should appear in the status bar pane.</p>

<A NAME="188"><H2>Handling a Control Message</H2></A>

<p>The <b>OnOK()</b> function that you have just implemented is an example of a control
notification message handler. Recall from <a href="ch03d.htm#119">Lesson 3</a> of Chapter 3 that control
notification messages are sent by controls and other child windows to notify the parent
window of an interaction between the user and the control. The <b>OnOK()</b> function
handles the BN_CLICKED message that is sent to the dialog box window (as a parameter to
a WM_COMMAND message) when the user clicks the <b>OK</b> button once.</p>

<p>Different sets of notification messages are associated with the different types of
controls. The <b>Message Maps</b> tab of ClassWizard provides a convenient
quick-reference for the notification messages associated with any control that is
placed in your dialog box. If you select your dialog class in the <b>Class Name</b> box
and click on the control ID in the <b>Object IDs</b> box, the set of notification
messages that can be generated by the control will appear in the <b>Messages</b> box.
Selecting one of these message IDs will cause a brief explanation of the message to
appear in the <b>Description</b> field at the bottom of the property page.</p>

<p>Figure 5.2 shows the <b>Message Maps</b> tab of the <b>MFC ClassWizard</b> dialog
box and the list of control notification messages that it supports for an edit
control (in this case, <b>IDC_USERID</b>).</p>

<p>
<A HREF="javascript:fullSize('F05DA02x.htm')"> <img src="images/F05DA02.JPG" width=404 height=290 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 5.2</b> <i>Using ClassWizard to handle control notification messages</i><!-- /caption -->
</p>

<p>For more detailed documentation about control notification messages, you can search
for the message IDs in the Visual C++ Help index. Control notification message IDs are
prefixed by an abbreviation of the control type followed by <i>N_</i>, as illustrated
in Table 5.1.</p>

<p><b>Table 5.1</b> <i>Control Notification Message ID Prefixes</i></p>

<table cellpadding="5" border="0" width="95%">
<tr><th>Notification message ID prefix</th><th>Control type</th></tr>
<tr><td valign="top">BN_</td><td valign="top">Button</td></tr>
<tr><td valign="top">CBN_</td><td valign="top">Combo box</td></tr>
<tr><td valign="top">CLBN_</td><td valign="top">Check list box</td></tr>
<tr><td valign="top">EN_</td><td valign="top">Edit control</td></tr>
<tr><td valign="top">LBN_</td><td valign="top">List box</td></tr>
<tr><td valign="top">STN_</td><td valign="top">Static text control</td></tr>
</table>

<p>ClassWizard will insert entry macros into the message map to handle notification
messages from each of these control types. These macros are constructed by prefixing
the message ID with <i>ON_</i>. For example, if you use ClassWizard to create a handler
for the EN_UPDATE notification message from the IDC_USERID edit control (as illustrated
by Figure 5.2), ClassWizard will insert a message map entry similar to the
following:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>ON_EN_UPDATE(IDC_USERID, OnUpdateUserid)</pre>
</td></tr>
</table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
BN_CLICKED notification messages for the <b>IDOK</b> and <b>
IDCANCEL</b> buttons will be mapped directly to overridden versions of the <b>
CDialog::OnOK()</b> and <b>CDialog::OnCancel()</b> virtual functions. Message map entry
macros are not used unless you specify the name of a different function to handle the
messages. In most cases, you should use the <b>OnOK</b> and <b>OnCancel</b>
functions.</blockquote></div>
</p>

<p>MFC provides the generic <b>ON_CONTROL</b> and <b>ON_NOTIFY</b> macros to allow for
the handling of custom messages. ClassWizard uses the <b>ON_NOTIFY</b> macro for
notifications from the newer common controls that became available with Windows NT and
Windows 95/98.</p>

<p>In the following exercise, you will add a handler function for the notification
message that is sent when the user changes the selection in the <b>Data Source</b> box.
You will use the handler function to display Help text for the current selection in the
read-only edit control beneath the list box. First, you will need to create a CEdit
variable to represent the edit control in your code.</p>

<p><li> <b>To add a CListBox member variable</b></li></p>

<ol>
<p><li> Press CTRL+W to open ClassWizard. Click the <b>Member Variables</b> tab.</li></p>
<p><li> In the <b>Class name</b> box, click <b>CConnectDialog</b>.</li></p>
<p><li> In the <b>Control IDs</b> box, click <b>IDC_DESCRIPTION</b>. Click <b>Add Variable</b>.</li></p>
<p><li> In the <b>Member variable name</b> box, type <b>m_editDesc</b>.</li></p>
<p><li> In the <b>Category</b> box, click <b>Control</b>. Click <b>OK</b> to add the variable.</li></p>
<p><li> Click <b>OK</b> to close ClassWizard.</li></p>
</ol>

<p><li> <b>To add the OnSelChangeDsnlist() control notification message handler</b></li></p>

<ol>
<p><li> Press CTRL+W to open ClassWizard. Click the <b>Message Maps</b> tab.</li></p>
<p><li> In the <b>Object IDs</b> box, click <b>IDC_DSNLIST</b>. In the <b>Messages</b> box, click <b>LBN_SELCHANGE</b>.</li></p>
<p><li> Click <b>Add Function</b>. Accept <b>OnSelchangeDsnlist</b> as the name for the function.</li></p>
<p><li> Click <b>Edit Code</b>. Replace the // TODO comment in the function implementation with the following code:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
int nCursel = m_lbDSN.GetCurSel();

switch(nCursel)
{
     case 0 : m_editDesc.SetWindowText(&quot;Accounting Data&quot;);
          break;

     case 1 : m_editDesc.SetWindowText(&quot;Administration Data&quot;);
          break;

     case 2 : m_editDesc.SetWindowText(&quot;Management Data&quot;);
          break;
}
</pre>
</td></tr>
</table>
</p>

<p>Note the use of the <b>CWnd::SetWindowText()</b> function to set the text in the
edit control.</p>


<p><li> Build and run the MyApp application. Test the <b>Connect to Data Source</b>
dialog box to ensure that the description text changes as you select different items in
the <b>Data Source</b> box.</li></p>
</ol>

<A NAME="189"><H3>Enabling and Disabling Controls</H3></A>

<p>In our discussion of user interface design in <a href="ch04a.htm#151">Lesson 1</a> of Chapter 4, we stated that
menu and toolbar commands that were not able to perform their function should not be
available for selection. The same applies to dialog box controls.</p>

<p>The <b>Connect to Data Source</b> dialog box currently allows the user to attempt to
connect to a data source even if no data source is currently selected and no logon ID
has been supplied. Rather than use validation functions to handle this situation, it
would be better to ensure that the <b>Connect</b> button is not available until
sufficient information has been provided. The following exercise shows you how to use
the <b>CWnd::EnableWindow()</b> function to make a control available or unavailable,
and how control notification handler functions can be used to update the status of a
control as the dialog box data is amended by the user.</p>

<p><li> <b>To enable or disable the Connect button</b></li></p>

<ol>
<p><li> On the <b>Member Variables</b> tab of ClassWizard, click the <b>IDOK</b> control ID for the <b>CConnectDialog</b> class. Add a CButton member variable called <b> m_bnConnect</b>.</li></p>
<p><li> On the <b>Member Variables</b> tab of ClassWizard, click the <b>IDC_USERID</b> control ID for the <b>CConnectDialog</b> class. Add a CEdit control member variable called <b>m_editUserID</b>. Click <b>OK</b> to close ClassWizard.</li></p>
<p><li> To the bottom of the <b>CConnectDialog::OnSelchangeDsnlist()</b> function, just before the final closing brace, add the following lines of code to make the <b> Connect</b> button available when a data source is selected and a User ID value has been supplied. (<b>CWnd::GetWindowText()</b> returns the number of characters copied.)</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
char tempbuf[8];
if(m_editUserID.GetWindowText(tempbuf, 7))
     m_bnConnect.EnableWindow(TRUE);</pre>
</td></tr>
</table>
</p>

<p><li> On the <b>Message Maps</b> tab of ClassWizard, select the <b>IDC_USERID</b>
control ID for the <b>CConnectDialog</b> class. Select the <b>EN_UPDATE</b> message and
add the <b>OnUpdateUserid()</b> control notification function. Click <b>Edit Code</b>
to edit the function implementation.</li></p>

<p><li> Add the following lines of code to the <b>OnUpdateUserid()</b> function:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
char tempbuf[8];
if(m_lbDSN.GetCurSel() != LB_ERR)
{
     if(m_editUserID.GetWindowText(tempbuf, 7))
          m_bnConnect.EnableWindow(TRUE);
     else
          m_bnConnect.EnableWindow(FALSE);
}
</pre>
</td></tr>
</table>
</p>

<p><li> To the bottom of the <b>CConnectDialog::OnInitDialog()</b> function, just 
before the return statement, add the following line of code to ensure that the 
<b>Connect</b> button appears correctly when the dialog box is first displayed:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>OnUpdateUserid();</pre>
</td></tr>
</table>
</p>


<p><li> As the validation function for this field is no longer necessary, remove 
the <b>DDV_Required()</b> function from the ConnectDialog.cpp file, along with 
its declaration in the ConnectDialog.h file. Remove the call to <b>
DDV_Required()</b> from the <b>CConnectDialog::DoDataExchange()</b> function 
in the ConnectDialog.cpp file. Move the following lines back within the scope
of the //{{AFX_DATA_MAP comment block to make them maintainable by ClassWizard (making
sure that they are kept together):</li>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>DDX_Text(pDX, IDC_USERID, m_strUserID);
DDV_MaxChars(pDX, m_strUserID, 15);</pre>
</td></tr>
</table>
</p>

<p><li> Build and run the MyApp application. Test the <b>Connect to Data Source</b>
dialog box to ensure that the <b>Connect</b> button is available only when a data
source is selected and an entry is in the <b>UserID</b> edit field.</li></p>
</ol>

<A NAME="190"><H2>Using a Dialog Box to Edit Application Data</H2></A>

<p>In this practice exercise, you will add some member variables to the MyApp
application's document class. Remember that in an MFC application, the document
class is the proper container for the application data. You will create a 
dialog box where you can edit the values of the application data variables. You
should complete this practice before you proceed, as it lays the foundation for
examples and practices in this and subsequent chapters.</p>

<p><li> <b>To add application data variables</b></li></p>

<ol>
<p><li> Open the MyApp project. In ClassView, right-click the <b>CMyAppDoc</b> class and click <b>Add Member Variable</b>. Add a public int variable named <b>m_nLines</b>.</li></p>
<p><li> Double-click the <b>CMyAppDoc</b> constructor to edit the code.</li></p>
<p><li> Initialize the m_nLines variable with a value of <b>20</b>. Assign a string of 60 characters to the m_string variable so that the constructor looks something like this:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
CMyAppDoc::CMyAppDoc()
{
     m_nLines = 20;
     m_string = 
          &quot;This is a very long string designed to take up lots of space&quot;;
}
</pre>
</td></tr>
</table>
</p>

<p><li> Using the menu editor, add a new command to the top of the <b>Data</b> menu.
This command should have the caption <b>&amp;Edit</b> and the prompt string should be
&quot;Edit document data.&quot; Accept the <b>ID_DATA_EDIT</b> ID that is created by
default.</li></p>

<p><li> Use the dialog editor to create a new dialog template with a resource ID of <b>
IDD_EDITDATA</b>. The dialog box should be titled <b>Edit Document Data</b> and contain
two static text items with the captions <b>Line text:</b> and <b>Number of lines:</b>,
which correspond to the edit controls IDC_EDIT_LINETEXT and IDC_EDIT_NUMLINES. The
controls should be arranged as illustrated in Figure 5.3. For the IDC_EDIT_NUMLINES
control, select the <b>Number</b> checkbox on the <b>Styles</b> property page.</li></p>

<p>
<A HREF="javascript:fullSize('f05DA03x.htm')"> <img src="images/f05DA03.jpg" width=404 height=173 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 5.3</b> <i>The <b>Edit Document Data</b> dialog box</i><!-- /caption -->
</p>

<p><li> Use ClassWizard to create a dialog class for the <b>IDD_EDITDATA</b> dialog box.
The class should be called <b>CEditDataDialog</b>, and be derived from the <b>
CDialog</b> class. Add two value member variables to correspond to the edit controls: a
CString variable named <b>m_strLineText</b> and a UINT variable named <b>
m_nLines</b>.</li></p>

<p><li> Add the following line of code to the top of the MyAppDoc.cpp file with the rest
of the #include statements:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#include &quot;EditDataDialog.h&quot;</pre>
</td></tr>
</table>
</p>


<p><li> Use ClassWizard to add a handler function <b>OnDataEdit()</b> for the <b>
ID_DATA_EDIT</b> object ID. The function should handle the COMMAND message and be added
to the <b>CMyAppDoc</b> class.</li></p>

<p><li> Add the following code to the body of the <b>OnDataEdit()</b> function:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
CEditDataDialog aDlg;

aDlg.m_nLines = m_nLines;
aDlg.m_strLineText = m_string;

if(aDlg.DoModal())
{
     m_nLines = aDlg.m_nLines;
     m_string = aDlg.m_strLineText;
     UpdateAllViews(NULL);
}
</pre>
</td></tr>
</table>
</p>


<p><li> Build and run the MyApp application. Click <b>Edit</b> on the <b>Data</b> menu
to check that the <b>Edit Document Data</b> dialog box appears correctly.</li></p>
</ol>

<A NAME="191"><H2>Implementing Property Sheets</H2></A>

<p>In <A HREF="ch04a.htm">Chapter 4</A>, you learned that a property sheet is a special kind of dialog box that
is generally used to modify the attributes of an object, such as the application or the
current selection in a view. The property sheet has three main parts: the containing
dialog box, one or more property pages shown one at a time, and a tab at the top of
each page that the user clicks to select a page. Property sheets are useful for
situations in which you have a number of similar groups of settings or options to
change. A property sheet allows a large amount of information to be grouped in an
easily understood fashion. A good example of a property sheet is the <b>Project
Settings</b> dialog box in the Visual C++ development environment.</p>

<p>MFC implements property sheets through two classes: the <b>CPropertySheet</b> class,
which represents the containing dialog box; and the <b>CPropertyPage</b> class, which
represents the individual pages of the property sheet. The procedure to create a
property sheet using these classes is as follows:</p>

<ol>
<p><li> Create a dialog template resource for each property page. These need not be all
the same size, but try as much as possible to maintain a consistent layout for each
page to make the property sheet intuitive and easy to use. Dialog template resources
for property pages should be created with a <b>Thin</b> style border and should have
the <b>Child</b> and <b>Disabled</b> properties set. The caption that you enter will
appear on the page tab.</li></p>

<p><li> Use ClassWizard to create a class derived from <b>CPropertyPage</b>
corresponding to each property page dialog template.</li></p>

<p><li> Use ClassWizard to create member variables to hold the values for this property
page and set up DDX and DDV functions.</li></p>

<p><li> Create a <b>CPropertySheet</b> object in your source code. Usually, you
construct the <b>CPropertySheet</b> object in the handler for the command that displays
the property sheet. Create one object of each of your property page classes.</li></p>

<p><li> For each page to be added to the property sheet, call the function <b>
CPropertySheet::AddPage()</b> and pass the address of each property page as a parameter.</li></p>

<p><li> Create a modal property sheet with the <b>CDialog::DoModal()</b> function, or a
modeless property sheet with the <b>CDialog::Create()</b> function.</li></p>
</ol>

<p>For modal property sheets, the framework supplies <b>OK</b>, <b>Cancel</b>, and <b>
Apply</b> buttons by default, and handles DDX and DDV for the controls on each of the
property pages. For a modal property sheet, it is generally sufficient to create a
temporary object on the stack, add the <b>CPropertyPage</b> objects, and call <b>
DoModal()</b>. If you need to add additional controls to the property sheet, you will
need to use ClassWizard to create your own class derived from <b>CPropertySheet</b>.
This step is necessary for modeless property sheets because the <b>Create()</b>
function does not add any default controls that could be used to close the property
sheet.</p>

<p>For more information on this topic, search for the title &quot;Adding Controls to a
Property Sheet&quot; in Visual C++ Help. Be sure to select the <b>Search titles
only</b> check box at the bottom of the <b>Search</b> tab so that only the topic with
the desired title is returned.</p>

<p>In the following exercises, you will create the <b>MyApp Settings</b> property sheet
for the MyApp application. This property sheet, illustrated in Figure 5.4, has two
pages. The pages will contain mock controls&#8212;you will not work with their data in
this exercise.</p>

<p>
<img src="images/f05DA04.jpg" width=344 height=248 border="0">
</p><p>
<!-- caption --><b>Figure 5.4</b> <i>The <b>MyApp Settings</b> property sheet</i><!-- /caption -->
</p>

<p><li> <b>To create the Page 1 dialog template</b></li></p>

<ol>
<p><li> In the MyApp project, click <b>ResourceView</b> and expand the MyApp resources folder.</li></p>
<p><li> Right-click the Dialog folder. Click <b>Insert Dialog</b>.</li></p>
<p><li> A new blank dialog box appears. Remove the <b>OK</b> and <b>Cancel</b> buttons by selecting them and pressing DELETE.</li></p>
<p><li> Press ENTER to edit the Dialog Properties. In the <b>ID</b> box, type <b> IDD_PPAGE1</b>. In the <b>Caption</b> edit box, type <b>Page 1</b>.</li></p>
<p><li> Click the <b>Styles</b> tab. In the <b>Style</b> box, click <b>Child</b>.</li></p>
<p><li> In the <b>Border</b> box, click <b>Thin</b>.</li></p>
<p><li> Ensure that the <b>Title bar</b> check box is selected.</li></p>
<p><li> Click the <b>More Styles</b> tab. Select the <b>Disabled</b> check box.</li></p>
<p><li> Add a few controls to the page&#8212;you can use Figure 5.4 as a guide. Include at least one edit control and give it the ID <b>IDC_EDIT_PP1</b>.</li></p>
</ol>

<p><li> <b>To create the CPage1 class</b></li></p>

<ol>
<p><li> With the <b>IDD_PPAGE1</b> dialog box open in the dialog editor, press CTRL+W to open ClassWizard.</li></p>

<p><li> Click <b>OK</b> to open the <b>New Class</b> dialog box.</li></p>

<p><li> In the <b>Name</b> edit box, type <b>CPage1</b>.</li></p>

<p><li> In the <b>Base Class</b> box, click <b>CPropertyPage</b>.</li></p>

<p><li> Click <b>OK</b> to create the <b>CPage1</b> dialog class.</li></p>

<p><li> Click <b>OK</b> to close ClassWizard. Close the dialog editor.</li></p>
</ol>

<p>Create a second property page template. To visually distinguish this template from
the first, change its size and add different controls. Give this template an ID of <b>
IDD_PPAGE2</b> and the caption <b>Page 2</b>. Make sure that it has the same style
settings as the first page. From this template, create the <b>CPage2</b> class, derived
from <b>CPropertyPage</b>.</p>

<p>You will now set up the property sheet to contain the two property pages that you
have created. The property sheet will be displayed by means of a new <b>Settings</b>
command on the <b>View</b> menu.</p>

<p><li> <b>To create the Settings command to display the property sheet</b></li></p>

<ol>
<p><li> Using the menu editor, create a new command under the <b>View</b> menu title.
Type <b>Setti&amp;ngs</b> as a caption and <b>Application settings</b> as a prompt.
Allow the editor to create the ID <b>ID_VIEW_SETTINGS</b>. Close the menu editor.</li></p>

<p><li> Open ClassWizard. To the <b>CMainFrame</b> class, add a command handler named
<b>OnViewSettings()</b> for the <b>ID_VIEW_SETTINGS</b> ID.</li></p>

<p><li> Add the following code to the body of the <b>OnViewSettings()</b> function:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
CPropertySheet PropSheet;
CPage1 pp1;
CPage2 pp2;

PropSheet.AddPage(&amp;pp1);
PropSheet.AddPage(&amp;pp2);

PropSheet.SetTitle(&quot;MyApp Settings&quot;);
PropSheet.DoModal();</pre>
</td></tr>
</table>
</p>


<p><li> Add the following code to the top of the CMainFrame.cpp file:</li></p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
#include &quot;Page1.h&quot;
#include &quot;Page2.h&quot;</pre>
</td></tr>
</table>
</p>

<p><li> Build and run the MyApp application. Click <b>Settings</b> on the <b>View</b>
menu to test the property sheet. Note how the pages are sized to fit the property
sheet, and how the captions are used as tab labels. Note, too, how the framework
automatically adds an <b>Apply</b> button.</li></p>
</ol>

<A NAME="192"><H3>Handling the Apply Button on a Property Page</H3></A>

<p>The <b>OK</b> button closes the property sheet and exchange and validate data from
all the controls on all of the property pages. The <b>Apply</b> button, on the other
hand, allows users to exchange and validate the changes that they have made without
closing the property sheet. This is useful if users want to save the settings made on
one page before proceeding to another.</p>

<p>The <b>Apply</b> button appears unavailable by default. To make the <b>Apply</b>
button become available after the user has entered data or changed the state of one of
the controls, use a call to <b>CPropertyPage::SetModified(TRUE)</b>. Clicking the
<b>Apply</b> button will call the <b>CPropertyPage::OnApply()</b> handler function
to perform data exchange and validation without closing the property sheet.</p>

<p>If you decide not to use the <b>Apply</b> button on your property pages, you do not
have to remove it. Microsoft's design guidelines state that you can leave it
available.</p>

<p>The following exercise shows you how to make the <b>Apply</b> button available when
the user enters data in an edit control.</p>

<p><li> <b>To make the Apply button available</b></li></p>

<ol>
<p><li> Open ClassWizard and click the <b>Message Maps</b> tab. Click <b> CPage1</b>.</li></p>
<p><li> In the <b>Object IDs</b> box, click <b>IDC_EDIT_PP1</b>. In the <b>Messages</b> box, click <b>EN_UPDATE</b>.</li></p>
<p><li> Click <b>Add Function</b>. Accept <b>OnUpdateEditPp1</b> as the name for the function.</li></p>
<p><li> Click <b>Edit Code</b>. Replace the // TODO comment in the function implementation with the following line of code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>SetModified(TRUE);</pre>
</td></tr>
</table>
</p>

<p><li> Build and run the MyApp application. Type some characters into the edit control that corresponds to the IDC_EDIT_PPI resource. Check that the <b>Apply</b> button is available as you type. Click the <b>Apply</b> button and note how it is automatically made unavailable.</li><p>
</ol>

<A NAME="193"><H2>Lesson Summary</H2></A>

<p>You use DDX to set the initial values displayed by the controls in your
application's dialog boxes, and to retrieve the data that the user enters into the
controls so that you can use it in your application code. DDV allows you to validate
the data input by the user before it is passed to the application. The implementation
of DDX and DDV is largely automated by the use of ClassWizard.</p>

<p>Standard DDX functionality is added by using ClassWizard to create a member variable
in your dialog class that corresponds to the data entered into the dialog box control.
Simple DDV functionality can be added by using ClassWizard to specify simple validation
criteria as you create the variable. As you add variables and validation rules,
ClassWizard will add calls to predefined MFC global functions to the overloaded <b>
DoDataExchange()</b> function to perform the tasks of data validation and exchange.</p>

<p>The <b>DoDataExchange()</b> function is called by the <b>CWnd::UpdateData()</b>
function. <b>UpdateData()</b> is called by <b>CDialog::OnInitDialog()</b> to initialize
the controls, and by <b>CDialog::OnOK()</b> to retrieve data from the controls and
perform validation.</p>


<p>You can extend the DDX/DDV functionality by writing your own custom functions. 
Custom DDX and DDV functions should be placed outside of the blocks of
code that are maintained by ClassWizard. All DDX and DDV functions take a parameter to
a <b>CDataExchange</b> object, which represents the context of the current data
exchange. The <b>CDataExchange</b> class includes a member variable m_bSaveAndValidate,
which indicates the direction of the data exchange; and the <b>Fail()</b> function, 
which is used to abandon the validation process and restore the focus to the control 
that has failed the validation.</p>

<p>Control initialization that cannot easily be achieved by a DDX function can be
performed by overloading the <b>CDialog::OnInitDialog()</b> function in the dialog
class. Retrieval of dialog data can also be achieved through an overload of the <b>
CDialog::OnOK()</b> function.</p>

<p>MFC provides classes to correspond to each of the Windows common controls. Using
ClassWizard, you can create objects of these control classes as data members of your
dialog class. These objects are associated with the controls in your dialog box by
means of a <b>DDX_Control()</b> function placed in the <b>DoDataExchange()</b>
function. You can use these control objects to initialize or update the dialog box
controls.</p>

<p>You can use ClassWizard to create functions to handle notification messages that are
sent by controls to their parent window (the dialog box). These control notification
message handlers are usually implemented as members of the dialog class. A common use
of these handler functions is to make controls available or unavailable while the user
is interacting with the dialog box.</p>

<P>Property sheets are multi-tabbed dialog boxes that allow information to be grouped in
an easily understood fashion. MFC implements property sheets through two classes. The
<b>CPropertySheet</b> class represents the containing dialog box, and
the <b>CPropertyPage</b> class represents the individual pages of the property
sheet. To implement a property sheet, for each page, or tab, you first create a dialog
template, and then you create a dialog class derived from <b>CPropertyPage</b>. Create
a <b>CPropertySheet</b> object in your source code and add each property page object
with a call to <b>CPropertySheet::AddPage()</b>. Usually you create your <b>
CPropertySheet</b> object on the stack, in the handler for the command that displays
the property sheet.</p>

<p>By default, the framework creates a property sheet with an <b>Apply</b> button that
is initially unavailable. The <b>Apply</b> button allows users to exchange and validate
the changes that they have made without closing the property sheet. If you choose to
implement the <b>Apply</b> button for your application, you should make it become
available as soon as the user alters any data in the dialog box controls. You can make
the <b>Apply</b> button available with a call to <b>
CPropertyPage::SetModified(TRUE)</b>.</p>

</BODY>
</HTML>







