<HTML>
<HEAD>
<TITLE>Lesson 2: COM Errors</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch13b.htm", "ch13d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="480"><H1>Lesson 2: COM Errors</H1></A>

<p>COM applications and components can use the error handling techniques discussed in
<a href="ch13b.htm#471">Lesson 1</a>, but must also confront COM's preferred method of communicating error
information through values known as HRESULT codes.</p>

<p>This lesson describes HRESULT codes in detail and points out various pitfalls to
avoid when dealing with COM errors. Keep in mind that, with COM, success and failure
are not always black and white concepts. COM allows for the idea that success and
failure might be only partial, not complete.</p>

<p>You will also learn how a COM component can notify its client of an error through
the <b>Error</b> event, one of the several stock events defined in COM.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<ul>
<p><li> Understand and create HRESULT codes used in COM programming.</li></p>
<p><li> Compensate for applications that do not properly receive error codes from COM
servers.</li></p>
<p><li> Understand when to use the COM <b>Error</b> event.</li></p>
</ul>
<b>Estimated lesson time: 15 minutes</b>
</blockquote></div>
</p>


<A NAME="481"><H2>HRESULT Codes</H2></A>

<p>In COM, interface methods return HRESULT codes to report success or failure. Despite
its &quot;H&quot; prefix, an HRESULT code is not a handle, but merely a 32bit value
indicating a success or failure condition.</p>

<p>COM predefines many HRESULT codes such as <b>S_OK</b> for success, <b>S_FALSE</b>
for failure, and various error codes such as <b>E_INVALIDARG</b> and <b>E_NOTIMPL</b>.
The &quot;E&quot; prefix stands for error. The &quot;S&quot; prefix identifies the
first two codes as status code (SCODE) values. Under 32bit Windows, HRESULT and SCODE
mean the same thing.</p>

<p>COM allows your own programs to define new HRESULT values, as explored in the next
section. However, to prevent confusion, you should use COM's predefined values
whenever appropriate. For example, the <b>E_OUTOFMEMORY</b> code, already defined by
the COM library, communicates a common error condition without ambiguity. You can find
a list of predefined HRESULT values and their meanings in the WinError.h file under the
heading &quot;OLE Error Codes.&quot;</p>

<A NAME="482"><H3>Anatomy of an HRESULT Code</H3></A>

<p>An HRESULT code consists of four bit fields, as illustrated in Figure 13.1. Table
13.2, which follows the figure, describes the fields in the figure from left to
right.</p>

<p>
<A HREF="javascript:fullSize('F13DA01x.htm')"> <img src="images/F13DA01.JPG" width=404 height=50 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 13.1</b> <i>Bit fields of an HRESULT value</i><!-- /caption -->
</p>

<p><b>Table 13.2</b> <i>Bit Field Descriptions</i></p>

<table cellpadding=5 width="95%">
<tr><th>Field ID</th>
<th>Bits</th>
<th>Description</th></tr>

<tr><td vAlign=top>S</td> <td vAlign=top>31</td> <td vAlign=top>Severity code. A value of 0 indicates success, and a value of 1 indicates an
error. Because the severity bit is also the value's sign bit, a severity value of 1
makes the HRESULT code a negative number.</td></tr>

<tr><td vAlign=top>R</td> <td vAlign=top>27-30</td> <td vAlign=top>Reserved bits of the facility code. Should be zero.</td></tr>

<tr><td vAlign=top>Facility</td> <td vAlign=top>16-26</td> <td vAlign=top>Facility code that indicates a general category to which the error code belongs.</td></tr>

<tr><td vAlign=top>Code</td> <td vAlign=top>0-15</td> <td vAlign=top>A 16-bit WORD value that identifies the condition.</td></tr>
</table>

<p>Facility codes are defined as part of the COM specification. Error codes within most
facility categories (for example, FACILITY_NULL, FACILITY_RPC) are specified by COM and
have universal meaning. COM defines the FACILITY_ ITF category to contain
developer-specified error codes that have their meanings determined by the interface
member functions from which they are returned.</p>

<p>When defining your own HRESULT codes, use FACILITY_ITF as shown in the following
code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#define MY_SUCCESS_CODE ((0 &lt;&lt; 31) | (FACILITY_ITF &lt;&lt; 16) | 0x200)
#define E_MY_ERROR_CODE ((1 &lt;&lt; 31) | (FACILITY_ITF &lt;&lt; 16) | 0x201)</pre>
</td></tr>
</table>
</p>

<p>The WinError.h file defines FACILITY_ITF as 4, so the first example creates a
positive value of 0x00040200. The second example produces a negative value of
0x80040201. WinError.h also defines the <b>MAKE_HRESULT</b> macro to simplify forming
HRESULTs on the fly:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>// Set HRESULT value 0x80040202
HRESULT hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x202);</pre>
</td></tr>
</table>
</p>

<p>A further wrinkle to keep in mind when dealing with HRESULT codes is that COM
assumes that a value of zero indicates success, not failure. The manifest constant <b>
S_OK</b>, for example, has a value of zero. As Table 13.1 illustrates, COM also assumes
that any positive value indicates success, though perhaps qualified.</p>

<p>To save developers the trouble of memorizing these rules, COM provides two macros,
named <b>SUCCEEDED</b> and <b>FAILED</b>, which are often used to test HRESULT codes.
The macros are not a required addition to your COM programs, but they help make code
more readable, as demonstrated in the following code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>HRESULT hr;

hr = pUnk-&gt;QueryInterface(IID_SomeObject, (PVOID*) &amp;pObj);
if (SUCCEEDED(hr))
{
     // Use the pObj value
     .
     .
     .
     pObj-&gt;Release();
}</pre>
</td></tr>
</table>
</p>

<p>The macro definitions in the WinError.h file show that <b>SUCCEEDED</b> returns <b>
TRUE</b> for any expression that evaluates to zero or greater; in contrast, <b>
FAILED</b> evaluates to <b>TRUE</b> for any negative expression, as demonstrated in the
following code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>#define SUCCEEDED(Status) ((HRESULT)(Status) &gt;= 0)
#define FAILED(Status) ((HRESULT)(Status) &lt; 0)</pre>
</td></tr>
</table>
</p>

<p>When dealing with an HRESULT not of your making, be careful how your code interprets
it. Generally, you can rely on any constant with an &quot;E&quot; prefix having a
negative value; other than that, you have no assurances. When unsure, consult the
appropriate header file to determine a defined constant's true numeric value.</p>

<A NAME="483"><H3>_com_error Support Class</H3></A>

<p>Visual C++ provides the <b>_com_error</b> support class, which encapsulates an
HRESULT code and helps hide the details behind COM error codes. The <b>_com_error</b>
class provides several member functions that retrieve information about the
encapsulated error. The most important of these functions are listed in Table 13.3.</p>

<p><b>Table 13.3</b> <i>Important _com_error Member Functions</i></p>

<table cellpadding=5 width="95%">
<tr><th>Member function</th> <th>Return value</th></tr>

<tr><td valign="top">Error</td> <td valign="top">The HRESULT code from which the <b>_com_error</b> object is constructed.</td></tr>

<tr><td valign="top">ErrorInfo</td> 
<td valign="top">A pointer to an associated <b>IErrorInfo</b> (described later), or NULL if
no <b>IErrorInfo</b> item exists. The caller must call <b>Release()</b> on the returned
<b>IErrorInfo</b> object when finished using it.</td></tr>

<tr><td valign="top">Wcode</td> <td valign="top">The HRESULT minus 0x80040200 if the HRESULT uses FACILITY_ITF. Otherwise, the function returns zero.</td></tr>

<tr><td valign="top">ErrorMessage</td> 
<td valign="top">A <b>TCHAR</b> pointer to a system message describing the error. If no
system message is available, the returned string is &quot;Unknown error&quot;
followed by the hexadecimal HRESULT value.</td></tr>
</table>

<p>If the encapsulated HRESULT has an associated <b>IErrorInfo</b> object, <b>
_com_error</b> can access the contextual error information that the object contains.
For example, the <b>HelpFile()</b> and <b>HelpContext()</b> member functions access the
<b>IErrorInfo</b> object and return information about context-sensitive help pertaining
to the error, which the caller can then display to the user through the familiar
Windows Help system.</p>

<p>Because <b>_com_error</b> represents an exception condition, it often serves as the
object passed to a <b>catch</b> block. Following is a simple program that illustrates
how to trap errors with <b>_com_error</b>, using the <b>E_OUTOFMEMORY</b> error code as
an example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
#include &lt;comdef.h&gt;
#include &lt;stdio.h&gt;

void main()
{
     try
     {
          _com_error e(E_OUTOFMEMORY);     // Construct the object
          throw(e);                        // Force an exception
     }

     catch(_com_error&amp; e)
     {
          printf(&quot;Error   = %08lx\n&quot;, e.Error());
          printf(&quot;WCode   = %04x\n&quot;,  e.WCode());
          printf(&quot;Meaning = %s\n\n&quot;,  e.ErrorMessage());
     }
}</pre>
</td></tr>
</table>
</p>

<p>When the program runs, it displays the following lines:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Error     = 8007000e
WCode     = 0000
Meaning     = Not enough storage is available to complete this operation.</pre>
</td></tr>
</table>
</p>

<A NAME="484"><H3>Client Access to HRESULT Codes</H3></A>

<p>After all this, you might be disappointed to learn that many client applications
cannot even receive the HRESULT codes that a server's methods return. Thus, your
carefully constructed and expressive codes often go to waste. The blame can be traced
to limitations inherent in the <b>IDispatch</b> interface.</p>

<p>For example, the MFC client applications discussed in <A HREF="ch11a.htm">Chapter 11</A> do not receive HRESULT
codes from their embedded COM components. The reason for this is because the wrapper
class that Visual C++ creates for a component communicates through the <b>IDispatch</b>
interface rather than calling component methods directly through a vtable. During its
circuitous connections with the server, <b>IDispatch</b> loses the method's return
value, which never makes its way back to the client. The MFC client using <b>
IDispatch</b> can only infer when an error occurs in a COM server because a negative
HRESULT value returned from a method generates an exception. By enclosing code that
accesses the server in <b>try</b>-<b>catch</b> blocks, the client can respond in a
general way to errors, though it cannot tell precisely what error occurred.</p>

<p>A Microsoft Visual Basic client fares no better. Like the MFC client, a program
written in Visual Basic cannot receive HRESULT return values. The Visual Basic client can only react to negative error codes, usually through an <b>On Error</b> statement.</p>

<p>Before closing this section, we should point out that some C++ clients do properly
receive HRESULT return codes. Whether it uses MFC or not, an application written in C++
does not need to rely on <b>IDispatch</b> and can receive a server's return values by bypassing the wrapper class that Visual C++ creates. However, such
a technique is beyond the scope of this course.</p>

<A NAME="485"><H2>Error Event</H2></A>

<p>When a COM component method returns an HRESULT code to the client application, the
notification is said to be <i>synchronous.</i> A synchronous notification forms part of
the normal flow of communication between server and client: the client calls the
server, the server detects an error, the server returns an HRESULT code explaining the
problem, and the client reacts to the error. These steps occur in ordered progression;
the client learns of the error only after the component ceases its task and
returns.</p>

<p>In some cases, the component might encounter an error of which the client should be
immediately apprised. In such a case, the component can fire an event and continue
working. In another scenario, a component might have worker threads operating
simultaneously with the client. If a worker thread detects an error, its only means of
notifying the client is by firing an event. COM defines a stock event named <b>
Error</b> that allows this type of asynchronous error notification.</p>

<p>The <b>Error</b> event has the predefined dispatch identifier <b>DISPID_ERROREVENT</b>. An ActiveX control using MFC and derived from <b>COleControl</b>
can invoke the <b>FireError()</b> member function.</p>

<A NAME="486"><H2>Lesson Summary</H2></A>

<p>This lesson described how to deal with COM error codes, with particular attention
paid to creating and using HRESULT codes in servers such as ActiveX controls. HRESULT
codes are not handles, but simply 32bit values containing four bit fields. The bit
fields describe an error's severity, its facility category, and its code within a
category. Negative HRESULT codes indicate failure, and generate exceptions in MFC and
Visual Basic clients. The HRESULT and SCODE type definitions are interchangeable under
32bit Windows programming.</p>

<p>By encapsulating an HRESULT value, the <b>_com_error</b> support class can make
dealing with COM errors easier. A <b>_com_error</b> object is often passed as the
exception parameter to a <b>catch</b> block.</p>

<p>Although developers of COM servers have an obligation to ensure that their products
return accurate and expressive error codes, most client applications cannot or do not
receive those codes. This will undoubtedly change in the future.</p>

<p>The stock <b>Error</b> event provides a COM component with the means of immediately
notifying the client when an error occurs. The <b>Error</b> event should be used in
asynchronous programming situations, where it is neither possible nor practical to use
returned HRESULT values to indicate errors.</p>

</BODY>
</HTML>







