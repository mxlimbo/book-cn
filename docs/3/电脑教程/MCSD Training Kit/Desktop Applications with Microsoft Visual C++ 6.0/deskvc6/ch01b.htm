<HTML>
<HEAD>
<TITLE>Lesson 1: Defining the Solution with the Microsoft Solutions Framework</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch01a.htm", "ch01c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="21"><H1>Lesson 1: Defining the Solution with the Microsoft Solutions Framework</H1></A>

<p>Developing large, complex software projects is risky. Statistics on large
information technology (IT) projects show that a significant number of software
projects fail. Some of the reasons for project failure include the following:</p>

<ul>
<p><li> Constantly changing requirements</li></p>
<p><li> Volatile or incomplete specifications</li></p>
<p><li> Poor quality coding</li></p>
<p><li> A scope that is too large</li></p>
<p><li> Inadequate staffing</li></p>
<p><li> Poor process</li></p>
<p><li> Unclear goals</li></p>
</ul>

<p>To address the problems of software development, Microsoft Consulting
Services developed the Microsoft Solutions Framework (MSF). MSF is based
on best practices from within Microsoft product groups, technology partners, and
corporate customers. Consider using the framework to benefit your own development
efforts and applying the MSF concepts as you plan a multi-developer project.</p>

<p>This lesson explains the features of MSF and how they relate to implementing
Visual C++ applications.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<ul>
<p><li> Describe the elements of MSF.</li></p>
<p><li> Explain the role of MSF in the design and development process.</li></p>
</ul>
<b>Estimated lesson time: 30 minutes</b>
</blockquote></div>
</p>



<A NAME="22"><H2>Overview of MSF</H2></A>

<p>MSF is a collection of models, principles, and practices that helps organizations
become more effective in their creation and use of technology to solve their business
problems. MSF helps by providing measurable progress and adaptable guidance that is
flexible enough to meet the changing needs of a modern business. The core building
blocks for this MSF-based solutions guidance are the six major models:</p>

<ul>
<p><li> MSF Enterprise Architecture Model</li></p>
<p><li> MSF Risk Management Model</li></p>
<p><li> MSF Team Model for Application Development</li></p>
<p><li> MSF Process Model for Application Development</li></p>
<p><li> MSF Application Model</li></p>
<p><li> MSF Design Process Model</li></p>
</ul>

<p>We describe each model briefly and elaborate on the specific uses of each later in
this lesson.</p>

<A NAME="23"><H3>MSF Enterprise Architecture Model</H3></A>

<p>The MSF Enterprise Architecture Model provides a consistent set of guidelines for
rapidly building enterprise architecture through versioned releases. This model aligns
information technology with business requirements through four perspectives: Business,
Application, Information, and Technology. Using this model helps shorten the enterprise
architecture planning cycle.</p>

<A NAME="24"><H3>MSF Risk Management Model</H3></A>

<p>The MSF Risk Management Model provides a structured and proactive way to manage
project risks. This model sets forth a discipline and environment of proactive
decisions and actions to continuously assess potential problems, determine what risks
are important to confront, and then implement strategies to deal with those risks.
Using this model and its underlying principles and practices helps teams focus on what
is most important, make the right decisions, and be more prepared for the future.</p>

<A NAME="25"><H3>MSF Team Model for Application Development</H3></A>

<p>The MSF Team Model for Application Development (MSF Development Team Model) provides
a flexible structure for organizing project teams. This model clearly emphasizes roles,
responsibilities, and goals for team success, and increases team member accountability
through its team-of-peers approach. This model's flexibility allows for adaptation
depending on project scope, team size, and team members' skills. Using this model
and its underlying principles and practices helps produce more engaged, effective,
resilient, and successful teams.</p>

<A NAME="26"><H3>MSF Process Model for Application Development</H3></A>

<p>The MSF Process Model for Application Development (MSF Development
Process Model) provides structure and guidance through a project's life cycle that
is milestone-based, iterative, and flexible. This model describes an application
development project's phases, milestones, activities and deliverables; and these
elements' relationship to the MSF Development Team Model roles. Using this model
helps improve project control, minimize risk, improve quality, and shorten delivery
time.</p>

<A NAME="27"><H3>MSF Application Model</H3></A>

<p>The MSF Application Model provides a logical, multi-layer, services-based approach
to designing and developing software applications. The implementation of user services,
business services, and data services allows for parallel development, improved use of
technology, easier maintenance and support, and optimal flexibility in distribution,
because the services that make up the application can reside anywhere, from a single
desktop to servers and clients around the world.</p>

<A NAME="28"><H3>MSF Design Process Model</H3></A>

<p>The MSF Design Process Model provides a three-phase, user-centric continuum that
allows for a parallel and iterative approach to design for the greatest efficiency and
flexibility. The three design phases&#8212;Conceptual, Logical, and
Physical&#8212;provide three different perspectives for three different
audiences&#8212;the users, the project team, and the developers. Moving through each of
these design phases shows the translation of user-based scenarios to services-based
components so that application features can be traced back to user requirements. Using
this model helps ensure that applications are created not just for the sake of
technology, but to meet business and user requirements.</p>

<A NAME="29"><H3>Presentation of MSF in This Book</H3></A>

<p>Throughout this lesson, we use some of the basic concepts of MSF to provide a
foundation for our discussions of application design and implementation. We concentrate
on the aspects of MSF that are directly related to the process of
application development&#8212;specifically the Team model, the Process model, the
Application model, and the Design Process model. For a broader and more
detailed treatment of MSF, read <i>Analyzing Requirements and Defining Solution
Architectures: MCSD Training Kit for Exam 70-100</i> (Microsoft Press, 1999).</p>

<A NAME="30"><H2>Using the MSF Development Team Model</H2></A>

<p>Rather than being a methodology, MSF is a framework that can be adapted to suit the
particular needs of any organization. The MSF Development Team Model is one aspect of
this framework. The model describes how teams should structure themselves and what
principles they should follow to be successful at developing software.</p>

<p>The MSF Development Team Model is specific in nature, but as part of the framework,
it should be viewed as a starting point. Different project teams can implement aspects
of the framework differently, depending on project scope, team size, and team
members' skills.</p>

<p>Specific responsibilities must be carried out and specific goals must be met for any
project to be successful. These responsibilities and goals serve to provide continual
direction for all the team members. Key project responsibilities and goals include the
following:</p>

<ul>
<p><li> <b>Customer satisfaction</b> Projects must meet the needs of their customers and
users to be successful. It is possible for a team to meet budget and time goals but
still be unsuccessful in meeting its goals, because customer needs have not been
met.</li></p>

<p><li> <b>Delivery within project constraints</b> Most projects measure success using
&quot;on time, on budget&quot; metrics.</li></p>

<p><li> <b>Delivery to specifications based on user requirements</b> The Functional
Specification describes in detail the deliverable to be provided by the team to the
customer. This specification represents an agreement between the team and the customer
as to what will be built, and constitutes the basis for &quot;Doing what we say we will
do.&quot;</li></p>

<p><li> <b>Release after identifying and addressing all issues</b> All software is
delivered with defects. The team's goal is to ensure that those defects are
identified and addressed before the product is released. Addressing defects can involve
everything from fixing the defect in question to documenting work-around solutions.
Delivering a known defect that has been addressed along with a work-around solution is
preferable to delivering a product containing unidentified defects that might
&quot;surprise&quot; the team and the customer later.</li></p>

<p><li> <b>Enhanced user performance</b> For a product to be successful, it must enhance
the way that users work. Delivering a product that is rich in features and content but
can't be used is considered a failure.</li></p>

<p><li> <b>Smooth deployment and ongoing management</b> The effectiveness of deployment
directly affects the perceived quality of a product. For example, a faulty installation
program might imply to users that the installed application is similarly faulty. The
team must do more than simply deploy the product; it must deploy the product smoothly,
and then support and manage the product.</li></p>
</ul>


<p>The MSF Development Team Model addresses the need to meet these key goals by
assigning tasks to six team roles: Product Management, Program Management, Development,
Testing, User Education, and Logistics Management. Each goal requires a different
discipline, so each team role embodies a different discipline. The people who carry out
the team roles must have the unique perspective and set of skills necessary to meet
each goal.</p>

<p>Table 1.1 shows the correspondence between the six roles
of the MSF Development Team Model, and the six key goals of an effective pro-ject team.
Because each goal is critical to the success of a project, the roles that correspond to
these goals are seen as peers with equal say in decisions. There
is no project master, but simply a team that knows what to do and is properly equipped
to do it.</p>

<p><b>Table 1.1</b> <i>Goals and corresponding team roles</i></p>

<table cellpadding="5" border="0" width="95%">
<tr><th>Goal</th><th>Team role</th></tr>
<tr><td valign="top">Customer satisfaction</td><td valign="top">Product Management</td></tr>
<tr><td valign="top">Delivery within project constraints</td><td valign="top">Program Management</td></tr>
<tr><td valign="top">Delivery to product specifications</td><td valign="top">Development</td></tr>
<tr><td valign="top">Release after identifying and addressing all issues</td><td valign="top">Testing</td></tr>
<tr><td valign="top">Enhanced user performance</td><td valign="top">User Education</td></tr>
<tr><td valign="top">Smooth deployment and ongoing management</td><td valign="top">Logistics Management</td></tr>
</table>

<A NAME="31"><H2>Using the MSF Development Process Model</H2></A>

<p>The MSF Development Process Model fulfills a key function of project development by
specifying which activities should be performed and when. The model has two other
important aspects: its close relationship with the MSF Development Team Model and the
benefits to the organization of using them together; and the MSF Development Process
Model's underlying practices and principles. The latter include:</p>

<ul>
<p><li> Using versioned releases.</li></p>

<p><li> Creating living documents.</li></p>

<p><li> Scheduling for an uncertain future.</li></p>

<p><li> Managing tradeoffs.</li></p>

<p><li> Managing risks.</li></p>

<p><li> Maintaining a fixed ship date mindset.</li></p>

<p><li> Breaking large projects into manageable parts.</li></p>

<p><li> Performing daily builds.</li></p>

<p><li> Using bottom-up estimating.</li></p>
</ul>


<p>Traditional approaches to software development, such as the Waterfall and Spiral
Models, often cannot meet the needs of current enterprise application development
environments.</p>

<p>With the Waterfall Model, a project progresses through sequential steps, from the
initial concept through system testing. This model identifies milestones along the
course of the project and uses them as transition and assessment points. This approach
works well for a project in which requirements can easily be specified at the
beginning, but might not work well for a complex project where requirements can change
during the project's life cycle. Additionally, practitioners of this model rely
heavily on volumes of documentation and a single review process for each stage. These
two Waterfall practices usually lead to overextended &quot;analysis paralysis&quot; and
adversarial relationships between developers, customers, and users.</p>

<p>Using the Spiral Model, the application evolves over a number of iterations. Early
passes through the Spiral life cycle provide increasingly tight definitions of the
product, with middle and later iterations adding features and functionality to the
application. The Spiral Model seeks to confront project risks early in a software
project and address them in early product releases.</p>

<p>Due to its iterative nature, the Spiral Model supports creative adjustments
along the way, thus evolving and hopefully improving the quality of product. The highly
iterative Spiral process requires significant amounts of process and documentation
automation to become efficient. In practice, customers and users might develop a
general sense of instability because the product can change too rapidly for them to
grasp. Finally, many Spiral projects lack a known ending point, so they continue to
iterate indefinitely with no financial or business end within site.</p>

<p>As shown in Figure 1.1, the MSF Development Process Model combines the strengths of
these two models, providing the benefits of milestone-based planning from the Waterfall
Model and the benefits of the iterative creative process from the Spiral Model.</p>

<p>
<A HREF="javascript:fullSize('F01DA01x.htm')"> <img src="images/F01DA01.JPG" width=404 height=288 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 1.1</b> <i>The MSF Development Process Model</i><!-- /caption -->
</p>

<p>The MSF Development Process Model has three primary traits:</p>

<ul>
<p><li> A phased process (the four wedges of the diagram in Figure 1.1)</li></p>

<p><li> A milestone-driven process (the diamonds separating the phases)</li></p>

<p><li> An iterative process (the process arrow aiming back into the first phase)</li></p>
</ul>


<p>Although Figure 1.1 shows the four phases as quarters, the phases do not
necessarily require equal amounts of time to complete. Different business and
technological environments will require different time and resource ratios for the
various phases.</p>

<A NAME="32"><H3>Phased Process</H3></A>

<p>The MSF Development Process Model consists of four interrelated phases.
Each of these phases represents deliverables for which a baseline should be
established before the development process can move to the next phase of the project.
The four phases and their primary tasks are:</p>

<ul>
<p><li> Envisioning, which must produce a shared vision.</li></p>

<p><li> Planning, which must produce a detailed project plan and application architecture.</li></p>

<p><li> Developing, which must produce a well-built, complete product.</li></p>

<p><li> Stabilizing, which must produce a stable, deployable product.</li></p>
</ul>


<A NAME="33"><H3>Milestone-Driven Process</H3></A>

<p>The MSF Development Process Model is based on milestones that are points
for review and synchronization, rather than points for freezing the application or its
specifications. They enable the team to assess the project's progress and
make midcourse corrections, such as adjusting the scope of the project to reflect
changing customer requirements, or reacting to risks that might materialize during the
course of the project.</p>

<p>The MSF Development Process Model uses two types of milestones: <i>major
milestones</i> and <i>interim milestones</i>. Each milestone, whether major or interim,
is marked by one or more <i>deliverables</i>. Deliverables are physical evidence that
the team has reached a milestone.</p>

<p><b>Major Milestones</b></p>

<p>Each phase of the development process culminates in an externally visible major
milestone. <i>Externally visible</i> means that the milestone and its deliverables are
visible to entities outside the project team, such as the customer or operations
personnel.</p>

<p>A major milestone is a point in time when all team members synchronize their
deliverables. Additionally, those external to the project team such as the customer and
users; operations, support, and help desk personnel; the distribution channel
(commercial software); and other key project stakeholders, should be updated on the
project status.</p>

<p>A significant role of major milestones is to allow for a stage-by-stage assessment
of the project's viability. The project team and the customer, having reviewed the
deliverables for the current phase, jointly make the decision whether or not to move
into the next phase. Thus, major milestones serve to move the project from one phase to
another.</p>

<p><b>Interim Milestones</b></p>

<p>Within each phase of the MSF Development Process Model are various interim
milestones which, like major milestones, are review and synchronization points rather
than freeze points. Unlike major milestones, however, interim milestones are <i>
internally visible</i>&#8212;that is, visible only to project team members.</p>

<p>Interim milestones indicate early progress and break large work assignments into
smaller pieces that are easier to address.</p>

<A NAME="34"><H3>Versioned Process</H3></A>

<p>The MSF Development Process Model is a versioned process in the sense that it is
designed to be repeated during the life cycle of a given product. Each succeeding
completion of the MSF Development Process Model allows for the addition of features and
functionality to satisfy changing business requirements.</p>

<A NAME="35"><H2>Using the MSF Application Model</H2></A>

<p>An application model is a conceptual view of an application that establishes the
definitions, rules, and relationships that will structure the application.
Additionally, an application model serves as a basis for exchanging ideas during the
logical design (rather than the physical design) of an application. The application
model shows how the application is structured, not how it will be implemented.</p>

<p>The MSF Application Model provides a multi-layer services-based approach to
designing and developing software applications. MSF views an application at a logical
level as a network of cooperative, distributed, and reusable services that supports a
business solution. Application services are units of application logic that include
methods for implementing an operation, function, or transformation. These services
should be accessed through a published interface that is driven by the interface
specification, and focus value toward the customer rather than the provider. Services
should map directly to user operations.</p>

<p>The MSF Application Model is Microsoft's recommended approach to designing
distributed, multi-tier client-server applications. This model aims to:</p>

<ul>
<p><li> Promote a consistent approach to design and development of client-server
applications.</li></p>

<p><li> Provide a standard set of definitions for the application logic in a multi-layer
application.</li></p>

<p><li> Make it easier to use component technology to implement distributed, multi-tier
applications that have the flexibility, scalability, and maintainability needed to
address the needs of mission-critical, enterprise-wide applications.</li></p>

<p><li> Shift from the traditional view of monolithic applications supporting specific
business processes to the concept of systems of interoperable applications built upon a
common set of components.</li></p>

<p><li> Describe a way of consistently applying the skills and resources of an
application development organization across multiple projects.</li></p>

<p><li> Define a framework for organizing teams, introducing parallelism into the
development process and identifying the required skills.</li></p>
</ul>


<p>The MSF Application Model describes applications as using three services: user,
business, and data. A service is a unit of application logic that implements
operations, functions, or transformations applied to objects. Services can enforce
business rules; perform calculations or manipulations on data; and expose features for
entering, retrieving, viewing or modifying information. These services allow for
parallel development, improved use of technology, easier maintenance and support, and
flexibility in distributing the application's services. In addition, these services
can reside anywhere in the environment, from a single desktop to servers and clients
around the world.</p>

<A NAME="36"><H3>Application Architectures</H3></A>

<p>An application architecture is a conceptual view of the structure of an application.
As shown in Figure 1.2, each application has three distinct layers: the user layer, the
business layer, and the data layer. Each application also contains the following types
of code: presentation, business-rule processing, data processing, and data storage.
Application architectures differ in how this code is packaged
to form a particular application product.</p>

<p>
<A HREF="javascript:fullSize('F01DA02x.htm')"> <img src="images/F01DA02.JPG" width=404 height=241 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 1.2</b> <i>The Application Model and its application layers</i><!-- /caption -->
</p>

<p>Many current applications have a <i>two-tier architecture,</i> also known as <i>
client/server architecture</i>. In a two-tier architecture, a client process handles
the data processing and presentation parts of the application. Data is stored on
centrally administered server computers. Clients connect directly to the servers they
need, often for the lifetime of the application's use.</p>

<p>Client/server applications work well in controlled environments in which the number
of users can be estimated and managed, and resources can be allocated accordingly.
However, when the number of users is unknown or very large, the client/server
architecture breaks down. Because each client connects to data servers directly, the
number of available data connections limits scalability.
Opportunities for reuse are limited because the clients are bound to the database formats. Each client application contains data processing logic, making the
applications relatively large. (This type of client is sometimes called a <i>fat
client</i>.) If the data processing logic ever needs to change, new applications must
be distributed to every client computer.</p>

<p>A slight improvement comes from moving parts of the data processing, or business
logic, to the data servers&#8212;for example, by using SQL Server stored procedures.
This architecture is sometimes called &quot;two-and-a-half tier.&quot; Applications
built on this model are somewhat more scalable, but not scalable enough to meet the
needs of highly distributed applications. In addition, opportunities for reuse are
limited.</p>

<p>Scalability and reuse can be improved significantly by introducing a third tier to
the application architecture. With <i>multi-layer architecture</i>, also known as <i>
N-tier architecture</i>, the user, business, and data tiers are logically separated, as
illustrated in Figure 1.3.</p>

<p>
<img src="images/F01DA03.JPG" width=347 height=551 border="0">
</p><p>
<!-- caption --><b>Figure 1.3</b> <i>Multi-layer application architecture</i><!-- /caption -->
</p>

<p>The three tiers perform the following functions:</p>

<ul>
<p><li> <b>User layer</b> The user layer presents data to the user and, optionally,
lets the user edit data. The two main types of user interfaces (UIs) for personal
computer-based applications are native and Web-based. Native UIs use the service of the
underlying operating system. On the Microsoft Windows platform, for example, native UIs
use the Microsoft Win32 API and Windows controls. Web-based UIs are based on HTML and
Extensible Markup Language (XML), which can be rendered by a Web browser on any
platform.</li></p>

<p><li> <b>Business layer</b> The business layer is used to enforce business and data
rules. The presentation tier uses the services of the business tier. However, the
business tier is not tied to any specific client; its services are available to all
applications. Business rules can be business algorithms, business policies, legal
policies, and so on&#8212;for example, &quot;Users get a 10 percent discount for ads
placed before Tuesday night&quot; or &quot;Six percent sales tax must be collected for
all orders delivered to the Commonwealth of Kentucky.&quot; Data rules help to ensure
the validity and occasionally the integrity of the stored data&#8212;for example, 
&quot;An order header must have at least one detail record&quot; or
&quot;Money must not be lost or generated during transfers between bank
accounts.&quot; Business rules are typically implemented in isolated code modules, which
are usually stored in a centralized location so that multiple applications can use
them.</li></p>

<p><li> <b>Data layer</b> The business tier has no knowledge of how or where the data it
works on is stored. Instead, it relies on the data access services, which perform the
actual work of storing and retrieving the data. The data access services are also
implemented in isolated code modules, encapsulating knowledge of the underlying data
store. If the data store moves or changes format, only the data access services need to
be updated. Each data access module typically is responsible for the integrity of a set
of data&#8212;for example, data placed in relational tables or the Microsoft ActiveX
Data Objects (ADO) and OLE DB technology. For the purpose of N-tier design, the data
store is simply the DBMS&#8212;the systems required to serve data from tables, as well
as optimize information retrieval, such as database indexes. Examples of data stores
are SQL Server, Microsoft Exchange Server, Microsoft Database Engine (MSDE), Microsoft
FoxPro, Microsoft Access, and Microsoft Jet.</li></p>
</ul>


<p>It might be slightly confusing to talk about logical architecture as part of the
Physical Model. It is important to understand that logical architecture encompasses a
wide range of physical architectures and implementations that specify where services
are deployed. In other words, applications are constructed as logical networks of
consumers and suppliers of services. Services are merely units of application logic
that provide well-defined functionality.</p>

<p>The terms <i>multi-layer</i> and <i>N-tier</i> don't imply separate computers.
The N-tier application architecture promotes scalable applications. To create highly scalable
applications, resources such as database connections must be shared. Instead of each
client application consuming resources to access data servers directly, client
applications communicate with business services. One instance of a business service can
support many clients, reducing resource consumption and improving scalability, as shown in Figure 1.4 and Figure 1.5. Because business services do not manage
data directly, it's easy to replicate these services to support even more clients.
Services can often be designed and implemented independently of any particular client
applications, providing flexibility and the potential for reuse in many applications.
By encapsulating application logic behind well-defined public interfaces, developers
create a body of reusable services that can easily be combined in new ways to create
new applications. In addition, common functionality can easily be updated in response
to changing business requirements, without impacting the client applications that rely
on the functionality. This aspect reduces the management and deployment costs of
changing requirements.</p>

<p>
<img src="images/F01DA04.JPG" width=324 height=337 border="0">
</p><p>
<!-- caption --><b>Figure 1.4</b> <i>Client/server systems</i><!-- /caption -->
</p>

<p>
<A HREF="javascript:fullSize('F01DA05x.htm')"> <img src="images/F01DA05.JPG" width=404 height=444 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 1.5</b> <i>N-tier systems</i><!-- /caption -->
</p>

<p>The multi-layer application architecture can also help developers deal with
existing, or legacy systems. Developers can &quot;wrap&quot; access to existing systems
within business logic, data access, or data store services. Client applications need to
worry only about how to access the business logic, not about how to access all the
different legacy systems on which they might rely. If the legacy system is modified or
replaced, only the wrapper needs to be updated.</p>

<A NAME="37"><H2>Using the MSF Design Process Model</H2></A>

<p>The MSF Design Process consists of three distinct types of design work: conceptual,
logical, and physical. Each of these generates a model of the same name: the Conceptual
Design Model, the Logical Design Model, and the
Physical Design Model.</p>

<p>Each part of the process approaches the design task from a different perspective and
defines the solution differently, as shown in Table 1.2.</p>

<p><b>Table 1.2</b> <i>Design task approaches to the three parts of the MSF Design Process</i></p>

<table cellpadding="5" border="0" width="95%">
<tr><th>Type of design work</th><th>Perspective </th><th>Action  </th></tr>
<tr><td valign="top">Conceptual</td><td valign="top">Views the problem from the perspective of the user and  business</td><td valign="top">Defines the problem and solution in terms of scenarios</td></tr>
<tr><td valign="top">Logical</td><td valign="top">Views the solution from the perspective of the project team</td><td valign="top">Defines the solution as a set of cooperating services team</td></tr>
<tr><td valign="top">Physical</td><td valign="top">Views the solution from the perspective of the developers</td><td valign="top">Defines the solution's services and technologies</td></tr>
</table>

<p>The output of each part is used as the input for the succeeding part, as Figure 1.6
illustrates.</p>

<p>
<A HREF="javascript:fullSize('F01DA06x.htm')"> <img src="images/F01DA06.JPG" width=404 height=292 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 1.6</b> <i>The output of the three interdependent design process models</i><!-- /caption -->
</p>

<p>The goals of the three parts are:</p>

<ul>
<p><li> <b>Conceptual Design</b> Identify business needs and understand what users do and
what they require. Conceptual Design generates scenarios that reflect complete and
accurate requirements by involving the customer, users, and other stakeholders.</li></p>

<p><li> <b>Logical Design</b> Organize the solution and the communication among its
elements. Logical Design takes the business problem identified in Conceptual Design
scenarios and formulates an abstract model of the solution. Following the workflow in
Figure 1.6, Logical Design takes the scenarios from Conceptual Design and produces
objects and services, UI prototypes, and a logical database design.</li></p>

<p><li> <b>Physical Design</b> Apply real-world technology constraints, including those
dealing with implementation and performance, to the output of Logical Design by
specifying the details of the solution. The output of Logical Design is used to 
produce components, UI specifications, and physical database design.</li></p>
</ul>


<p>The MSF Design Process moves from tangible requirements (use cases) to an abstract
application design (Conceptual Design), then to a rationalized application design
(Logical Design), then to a concrete application design (Physical
Design), and finally, to the tangible product. Conceptual Design is the initial
translation of the use cases (the language of the users) to the application design (the
language of the application developers). Logical Design is the developers'
perspective and serves as a translator between the high-level application
concepts&#8212;the business and user requirements&#8212;and the detailed application
design.</p>

<p>Conceptual Design does not take into account the approach or the technologies needed
to build the solution. Rather, Conceptual Design corresponds to rough sketches and
scenarios for building a house. These elements are easily understood models jointly
created by the customer, user, and architect. Conceptual Design is the translation of
business and user requirements from the language
of the users to the language of the developers.</p>

<p>Logical Design starts to get into the details of the application that the team will
build to fulfill business needs and user requirements. Logical Design thus corresponds
to the floor plan and elevation of a house, where elements such as spatial
relationships are organized. In this part of the process, the architect's team lays
out the design's relationships and communication paths.</p>

<p>Physical Design addresses the technology that will be used. This design adds detail
to the architecture and reflects real-world implementation constraints.</p>

<p>Essentially, the different parts of the MSF Design Process address the needs of
different &quot;readers&quot; while still serving as parts of a functional whole.
Instead of forcing readers to digest what might be a very large and detailed document,
this model allows readers to focus only on the information&#8212;the part of the
whole&#8212;that is pertinent to them. The model also allows the use of formal or
informal techniques as appropriate.</p>

<p>The design evolves as each step in the process contributes more detail to the
Functional Specification. And as the design evolves, every aspect is traceable from any
point back to the original business problem, for verification and testing purposes.</p>

<p>Although the MSF Design Process resides primarily within the Planning Phase of the
MSF Development Process Model, the work of design often begins before the Planning
Phase is officially started, and it continues to some extent up to the point when the
code is frozen (near the end of the Developing Phase). The baselines for each of the
three parts of the process are established during the Planning Phase. As shown in
Figure 1.7, the three design activities occur in a staggered, parallel manner, with the
early output of one activity signaling that the next activity should begin.</p>

<p>
<A HREF="javascript:fullSize('F01DA07x.htm')"> <img src="images/F01DA07.JPG" width=404 height=168 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 1.7</b> <i>The overlapping, iterative, and spiral qualities of the MSF Design Process</i><!-- /caption -->
</p>

<p>The Conceptual Design activity begins when the team agrees upon a vision statement,
which can occur before the team reaches the formal Vision Approved Milestone. The
Logical Design and Physical Design activities parallel those of Conceptual Design, and
all three sit squarely in, but are not limited to, the Planning Phase of the MSF
Development Process Model.</p>

<p>It is the parallel execution of all three design activities that allows the
product's conceptual, logical, and physical design to have the following three
qualities: </p>

<ul>
<p><li> <b>Overlapping</b> The activities are parallel, with Conceptual Design typically
starting first, followed by Logical Design and then Physical Design. They are not
sequential, so one doesn't have to finish before the next can begin. In fact,
Logical Design and Physical Design can begin even before the baseline for Conceptual
Design is established.</li></p>

<p><li> <b>Iterative</b> The activities have their own cycles of validation, design
testing (as opposed to code testing), and redesign.</li></p>

<p><li> <b>Spiral</b> Each iteration of all three activities represents progress toward
the Project Plan Approved Milestone of the Planning Phase.</li></p>
</ul>


<p>Obviously, a minimum degree of sequencing must occur as a practical matter.
Conceptual Design must start before Logical Design, which must start before Physical
Design. Similarly, the baseline for Conceptual Design must be established before the
baseline for Logical Design, which must be established before the baseline for Physical
Design.</p>

<A NAME="38"><H3>Design Considerations</H3></A>

<p>The promotion of understanding among members of the project team is a primary
consideration when determining how to manage the inherent <i>complexity</i> of
large-scale business applications and when trying to assess the level of detail that
should be included in the design. If too little detail is included, the team runs the
risk of missing relevant interactions. If too much detail is included, the design might
become overly complicated.</p>

<p>The experience and skill of C++ developers are especially valuable to the logical
design process, as the principles of object-oriented software development are very
similar to the methods used to establish a logical design. This section outlines some
of the key concepts used in the logical design process&#8212;concepts that will be
familiar to anyone with experience in developing object-oriented software
solutions.</p>

<p><b>Modularity</b></p>

<p>The team starts the Logical Design process by defining the major services of the
system. A service represents some collection of processes that work together to
accomplish a task. The principle behind modular design is that the final product will
be constituted by the combination of the major services. Each service is deliberately
designed to perform a particular function as a stand-alone unit that must work with
other parts of the system.</p>

<p><b>Abstraction</b></p>

<p>Abstraction is the process of examining and distilling the properties and features
of a distinct item, and the classification of groups of items through the recognition
of essential common characteristics. Abstraction enables us to classify and organize
our day-to-day world by concentrating on the defining characteristics and behavior of
an object while ignoring its non-essential details. This process enables us to deal
with what would otherwise be overwhelmingly complex
situations.</p>

<p>Typically, C++ developers are accustomed to abstracting real-world objects, and more
abstract entities, into <i>classes</i> that specify the characteristics of the software
objects in the application. For example, designers of a postal delivery system might
design classes to represent letters, packets, van routes, and airline schedules; as
4well as entities internal to the software environment such as caches, event schedulers,
and barcode input handlers.</p>

<p><b>Encapsulation</b></p>

<p>Encapsulation is a fundamental principle of structured design, object-oriented
design, and object-based component design. In structured design, encapsulation provides
the notion of a &quot;black box&quot;&#8212;a compiled, unit-tested module that can be
assumed to perform a limited, well-defined function correctly. In object-oriented
design, it provides the basis for abstraction. Abstraction focuses upon the essential
characteristics of some object, relative to the perspective of the viewer. Software
components encapsulate behaviors, which they expose as services to client programs.</p>

<p>Encapsulation is the technique for packaging information (data and process) in such
a way as to hide what should be hidden, and make visible what is intended to be
visible. A component should describe the services that it can provide and specify the
data types of the input and output parameters. It should not expose the means by which
it provides its advertised services&#8212;in particular, it should ensure that its inner
state is not exposed in such a way that it can be corrupted by external factors.</p>

<p>When developers decide to expose some aspect of a component, they use an
interface. An <i>interface</i> describes the services that a component can provide to a
client. To ensure that a component is easy to use, and difficult to abuse, it should
hide as much as possible about its inner workings from the outside world.</p>

<p>Encapsulation allows a system to be assembled out of parts. The idea of
encapsulation is applicable at all levels of design&#8212;from the largest subsystem to
the smallest code routines and functions.</p>

<p><b>Cohesion and Coupling</b></p>

<p><i>Cohesion</i> refers to how closely the operations within a service are related.
The goal of any design is to maximize the beneficial cohesion among its constituent
parts. High cohesion allows a module's purpose or function to be more easily
abstracted so that its behavior can be more easily and accurately specified.</p>

<p><i>Coupling</i> refers to the relationships between services. The less information
that links services to each other, the freer the designer is to compose a solution
without causing perturbations within the individual services themselves, or the
existing assembly of those services. One service should depend as little as possible on
other services. However, where a dependency exists, the connection between those
services should be as clear and straightforward as possible. This leads to easier
definition and greater simplicity in determining interfaces.</p>

<p>The constituent units of a well-defined service have loose inter-unit coupling and
high internal cohesion. As an example, consider a hi-fi music system built of three
separate services&#8212;an amplifier, a CD player, and a tape deck. The internal
components of the amplifier, such as the transistors and the resistors, don't do
much on their own. They rely upon a relationship of high internal cohesion with the
other parts of the amplifier module to perform their task. On the other hand, the
modular units of the hi-fi system exhibit a loosely coupled relationship&#8212;they are
usually connected together by a few cables, and can easily be interchanged.</p>

<p><b>Separation of Interface and Implementation</b></p>

<p>Services exhibit external characteristics that make them available as building
blocks. Each service has an interface that allows it to be used, but the interface
hides internal implementations so those implementations can be replaced without
affecting the rest of the system. For this approach to work effectively, developers
must recognize that each service contains some capability that needs to
be represented to the outside world. A description of this capability can be used as a
contract with other modules. Any other service that complies with this contract can
access the capability.</p>

<p>A contract sets up the rules for interaction between the supplier and the consumer.
For example, we know that when we use a public telephone, we have to insert some coins
and dial a number. We trust that if we do this correctly, the
call will be connected or, if the call is unsuccessful, the money will be returned.
Likewise, users of a software component know that as long as the conditions of the
interface &quot;contract&quot; are met, any consumer can call upon it as a supplier and
receive the specified service. This is known as an open-ended contract. It is important
that interfaces be designed as open-ended as possible to facilitate modularity and
reuse.</p>

<p>The interface is defined logically, independent of its implementation, providing
common access to any potential user. The contractual nature of the interface places the
responsibility for fulfilling the request on the supplier of that capability. If we
type the number correctly, it is the phone company's responsibility to handle the
necessary details to connect us to the intended party. Interface implementations are
replaceable as long as the replacement can service the same public interface. This
allows services to evolve as conditions and requirements change, or as improvements are
made. For example, the phone company can
often upgrade the handset in a telephone booth. As long as it maintains the familiar
dial pad and coin slot interface, we can continue to use the handset without
difficulty.</p>

<p>Clearly specifying interfaces is necessary for services to be designed and coded
independently. With well-defined interfaces, these independently coded services can be
reliably integrated into a fully functional application. The inter-service independence
afforded by clearly specified interfaces allows for easier maintenance and greater
flexibility with regard to future upgrades.</p>

<A NAME="39"><H2>Developing Desktop Applications</H2></A>

<p>In this course, we will be applying the Application Model in the creation of desktop
applications. By &quot;desktop applications,&quot; we do not just mean applications
like Microsoft Word that run self-contained on a single computer. We
define desktop applications to include client/server applications&#8212;particularly
those based on the so-called &quot;fat client model,&quot; where the business services
and the presentation services are implemented together as a locally deployed
appli-cation retrieving data from a remote data source. This model tends to assume
business rules of limited complexity and of limited deployment scope.</p>

<p>Where appropriate, a desktop application should make use of the component-based
design described by the Application Model to take advantage of the flexibility,
scalability, and reliability offered by a component-based architecture.</p>

<A NAME="40"><H2>Lesson Summary</H2></A>

<p>MSF is a suite of models, principles, and guides for building and deploying
software. MSF is a collection of best practices used by the Microsoft product groups
and Microsoft Consulting Services.</p>

<p>MSF implements the following models and perspectives, which contribute to the
development cycle:</p>

<ul>
<p><li> <b>MSF Development Team Model</b> Defines a team of peers working in
interdependent and cooperating roles.</li></p>

<p><li> <b>MSF Development Process Model</b> Helps the team establish guidelines for
planning and controlling results-oriented projects based on project scope, the
resources available, and the schedule.</li></p>

<p><li> <b>MSF Application Model</b> Helps the team design distributed applications that
take optimum advantage of component reuse. It establishes standards and guidelines for
designing distributed client/server and multi-tier applications that can be implemented
using Microsoft's component-based tools and technologies.</li></p>

<p><li> <b>MSF Design Process Model</b> Shows how applications must be designed from both
a user and business perspective. It specifies three iterative design phases, tying
together the Team Model, Process Model, and Application Model in a solution-oriented
context.</li></p>

<p><li> <b>Conceptual design perspective</b> Focuses on the needs and technological 
capabilities of the business and of the users. The output of conceptual design is
typically documented as scenarios.</li></p>

<p><li> <b>Logical design perspective</b> Focuses on project team understanding. The 
solution is described in terms of the constituent parts of the system and how they
interact. The output of logical design consists of high-level functional specification
documents.</li></p>

<p><li> <b>Physical design perspective</b> Focuses on providing information necessary to
allow developers to implement the solution. Physical design focuses on the
organization, structure and technology of the solution. The output of physical design
consists of lower-level specification documents such as flowcharts, object models, and
pseudocode.</li></p>
</ul>


<p>Sometimes developers participate only in the physical design of a solution. However,
logical design should not be neglected, as it plays an important role in software
development. The purpose of the logical design process is to promote a greater
understanding of the system by the entire project team, helping team members to
determine how to manage the inherent complexity of large-scale business applications.
Management of this complexity is achieved through the application of design concepts
similar to those employed by object-oriented software developers.</p>

</BODY>
</HTML>







