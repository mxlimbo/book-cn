<HTML>
<HEAD>
<TITLE>Lesson 1: Error Handling</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch13a.htm", "ch13c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="471"><H1>Lesson 1: Error Handling</H1></A>

<p>Experienced developers treat <i>error handling</i> as a natural part of the coding
process; appropriate error handling is an essential component of a robust application.
This lesson explains some of the common techniques used in error handling. This lesson
also presents a broad discussion of how to incorporate code that not only detects a
problem when it occurs but reacts appropriately
(for example, by displaying a message box to users). It's far easier to address
error handling during the coding process than to try retrofitting the code later.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>
<ul>
<p><li> Write code that effectively handles errors as they occur in a running program.</li></p>
<p><li> Understand exceptions and use exception-handling techniques in your code.</li></p>
<p><li> Keep a running record of a program's progress using the <b>TRACE</b>
macro.</li></p>
</ul>
<b>Estimated lesson time: 30 minutes</b>
</blockquote></div>
</p>


<A NAME="472"><H2>Anticipating Program Errors</H2></A>

<p>Most experienced programmers have a healthy skepticism about whether code will
perform as intended. Your code might contain logical errors that affect your program in
ways that are not instantly apparent. Even code that is <i>logically</i> error free
might have unexpected effects within certain environmental circumstances. As you write
code, develop the habit of questioning every assumption. Try to anticipate things that
might go wrong and incorporate additional code to react gracefully to such problems.
These added lines of code might execute only rarely, if ever, but are present in case
they are needed to solve problems.</p>

<p>Failing to properly anticipate environmental contingencies catches many developers
off guard. Consider the following typical scenario, in which a function
allocates a buffer in memory, then fills it with text. Using the <b>new</b> operator,
this function receives a pointer to a block of memory, then immediately proceeds to
write to it. Throughout the development process, the function performs flawlessly
because the development computer has ample resources to provide free store memory.
After the program is released, the program's developer begins
receiving calls from irate users who have lost a day's work because the program has
failed as a result of the users' computers not having adequate memory to perform
the task.</p>

<p>Experienced programmers take a more conservative approach when allocating memory.
They add code that checks the value of the pointer returned by <b>new</b> and will only
use the pointer if it holds a non-zero value. If <b>new</b> returns a <b>NULL</b>
pointer&#8212;meaning that the allocation failed&#8212;code should react appropriately.
The result should resemble the following code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>int  *ptr = new int[BLOCK_SIZE];
if (ptr)
{
     // Memory block successfully allocated, so use it
     .
     .
     .
     delete[] ptr;
}
else
{
     // Allocation failed &#8212; take appropriate steps
}</pre>
</td></tr>
</table>
</p>

<p>Anticipation of potential problems and implementation of proper contingency
procedures lead to more robust code with increased stability under adverse
circumstances, which in turn leads to reduced failure rates. Programmed robustness is
considered to be <i>fault-tolerant</i>, referring to the degree to which code can
accommodate problems without failure. You might think of this anticipatory
approach as <i>inline error handling</i>, in which possible errors are dealt with
immediately in the body of the code.</p>

<p>Handling errors by continually checking return values can make code difficult
to read and maintain because of constant interruptions of the program's logic flow.
This method of error checking can often lead to a long series of nested
<b>IF</b>-<b>ELSE</b> blocks, in which the <b>IF</b> blocks contain the code as it is
intended to run, and the <b>ELSE</b> blocks contain the code that deals with errors.
Following is
a pseudocode illustration of how such nested tests can move closer to the right side of
the screen. If the nested tests contain long lines of code, the intended flow might be
difficult to follow:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>if (condition1 == TRUE)
{
     // Compute condition2
     if (condition2 == TRUE)
     {
          // Compute condition3
          if (condition3 == TRUE)
          {
               // Other nested conditions
               .
               .
               .
          }
          else
          {
               // Failure for condition3
          }
     }
     else
     {
          // Failure for condition2
     }
}
else
{
     // Failure for condition1
}</pre>
</td></tr>
</table>
</p>

<p>Microsoft Windows and Visual C++ offer another approach to handling errors inline:
<i>exception handling</i>. Exception handling allows developers to separate a function
logically into two sections: one for normal execution and the other for trapping
errors. Seemingly oblivious to potential errors, code in the normal
execution section does not check return values and executes as though no problems
exist. The second code section traps errors as they occur.</p>

<A NAME="473"><H2>Exceptions</H2></A>

<p>An <i>exception</i> is any condition that the operating system considers to be
an error. When an application raises an exception, the operating system attempts
to notify the offending application that it has caused an error by calling the
application's exception handler code (assuming such code exists). If the
application does not provide an exception handler, the operating system resolves the
problem itself, often by terminating the application abruptly with a terse message to
its user such as &quot;This program has performed an illegal operation and will be shut
down.&quot;</p>

<p>Two levels of exception handling exist:</p>

<ul>
<p><li><b>Structured exception handling (SEH)</b> pertains exclusively to operating system errors.</li></p>

<p><li><b>C++ exception handling</b> pertains to errors in Visual C++ applications.</li></p>
</ul>


<A NAME="474"><H3>Structured Exception Handling</H3></A>

<p>Although this chapter primarily examines C++ exception handling, Structured
Exception Handling (SEH) merits attention for two reasons. First, though they are quite
distinct, the two types of exception handling are often confused. Second, although the
C language cannot use C++ exception handling, it can implement SEH.</p>

<p>All exception handling is based on the SEH mechanism. SEH initiates the be-ginning
of a communication chain that winds its way up to the application level. An application
incorporates SEH through the <b>__try</b>, <b>__except</b>, and <b>__finally</b>
keywords. A <b>__try</b> block must be matched with either an <b>__except</b> block or
a <b>__finally</b> block, but not both. The syntax is as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
__try
{
     // Normal code goes here
}
__except (filter)
{
     // Errors that occur in the try block are trapped here
}</pre>
</td></tr>
</table>
</p>

<p>Note that SEH keywords are preceded by two underscores, not one. The
<b>__except</b> block executes only if code in the <b>__try</b> block causes an
exception. If the <b>__try</b> block finishes successfully, execution resumes at the next
instruc-tion following the <b>__except</b> block, thus bypassing the <b>__except</b>
block entirely.</p>

<p>Through its <i>filter</i> parameter, the <b>__except</b> block specifies whether it
is able to deal with the exception. The <b>filter</b> parameter must evaluate to one of the
values described in Table 13.1.</p>

<p><b>Table 13.1</b> <i>Filter Parameter Evaluation Values</i></p>

<table cellpadding=5 width="95%">
<tr><th>Value</th> <th>Meaning</th></tr>

<tr><td valign="top">EXCEPTION_CONTINUE_SEARCH</td> 
<td valign="top">The <b>__except</b> block declines the exception and
passes control to the handler with the next highest precedence.</td></tr>

<tr><td valign="top">EXCEPTION_CONTINUE_EXECUTION</td> 
<td valign="top">The <b>__except</b> block dismisses the exception
without ex- ecuting, forcing control to return to the instruction that raised the
exception.</td></tr>

<tr><td valign="top">EXCEPTION_EXECUTE_HANDLER</td> 
<td valign="top">The body of the <b>__except</b> block executes.</td></tr>
</table>

<p>A filter such as EXCEPTION_CONTINUE_EXECUTION might seem odd
in that it apparently renders the <b>__except</b> block useless. Why have an exception
handler if it never executes, but merely requests that the statement causing the
exception be repeated? An <b>__except</b> block usually calls a helper function that
returns a value for the <i>filter</i> parameter, as shown in the following code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>__except (GetFilter())
{
     // Body of __except block
}
.
.
.
long GetFilter()
{
     long lFilter;
     // Determine the filter appropriate for the error
     return lFilter;
}</pre>
</td></tr>
</table>
</p>

<p>The helper function must analyze current conditions and attempt to fix the
problem that triggered the exception. If it succeeds, the helper function returns
EXCEPTION_CONTINUE_EXECUTION, thus causing control to bypass the
<b>__except</b> block and return to the original instruction in the <b>__try</b> block
for another attempt. However, such techniques must be employed with care; if the helper
function does not truly fix the problem, the program enters an infinite loop in which
the statement in the <b>__try</b> block continually executes, raising
over and over an exception that is never properly solved.</p>

<p>Although nominally part of SEH, the <b>__finally</b> keyword has little to do with
the operating system. Rather, it defines a block of instructions that the compiler
guarantees will execute when the <b>__try</b> block finishes. Even if the <b>__try</b>
block contains a <b>RETURN</b> or <b>GOTO</b> statement that jumps beyond the <b>
__finally</b> block, the compiler ensures that the <b>__finally</b> block executes
before returning
or jumping. The <b>__finally</b> keyword does not take a parameter.</p>

<A NAME="475"><H3>C++ Exception Handling</H3></A>

<p>C++ exception handling is at the higher end of the command chain initiated by SEH.
Whereas SEH is a system service, C++ exception handling is code that you write to
implement that system service. C++ exception handling is more
sophisticated and offers more options than SEH. Use of the low-level <b>__try</b>
and <b>__except</b> keywords of SEH is discouraged for Visual C++ applications.</p>

<p>In much the same way that a C application uses SEH, a Visual C++ application
provides exception handler code that executes in response to an error. This code
resolves the problem and retries the instruction that caused the error, ignores the
problem completely, or passes the notification further along the chain of potential
handlers. C++ provides the <b>try</b>, <b>catch</b>, and <b>throw</b> keywords for this
purpose. Unlike their SEH counterparts, these keywords do not have a double-underscore
prefix.</p>

<p>To see a simple example of C++ exception handling, consider again the scenario in
which a program attempts to write to unowned memory after the <b>new</b> operator
fails. Previously, we saw how an application can prevent failure by testing the value
of a returned pointer. Exception handling offers a somewhat more sophisticated solution
in which code is separated into <b>try</b> and <b>catch</b> blocks instead of a series
of nested <b>IF</b>-<b>ELSE</b> blocks, as demonstrated in the following code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
try
{
     int  *iptr = new int[BLOCK_SIZE]; 
     .
     .          // If we reach this point, allocation succeeded
     .
     delete[] iptr;
}
catch(CMemoryException* e)
{
     // Allocation failed, so address the problem
     e-&gt;Delete();
}</pre>
</td></tr>
</table>
</p>

<p>If the <b>new</b> command fails to allocate the requested memory, it triggers an
exception that causes the <b>catch</b> block to execute. In this example, the <b>
catch</b> block
accepts as its parameter a pointer to an MFC <b>CMemoryException</b> object, which
contains information about out-of-memory conditions caused by the <b>new</b> operator.
C++ programs that do not use MFC can design their own class for this purpose, or even
use a pointer to a standard type, such as a pointer to a string. The block's
parameter list can also be an ellipsis (&#8230;), which indicates to the compiler that
the <b>catch</b> block handles all types of exceptions, not exclusively memory
exceptions.</p>

<p>If the <b>catch</b> block can fix the problem, it retries the instruction that
caused the exception by executing the <b>throw</b> command. Notice that this option is
much more flexible than using the EXCEPTION_CONTINUE_EXECUTION filter
of SEH, because it allows the <b>catch</b> block to execute. If the <b>catch</b> block
does not retry (or <i>rethrow</i>) the exception, program flow continues to the next
statement following the <b>catch</b> block.</p>

<A NAME="476"><H3>MFC Exception Macros</H3></A>

<p>Early versions of MFC provided macros as substitutes for the C++ exception handling
commands, naming them <b>TRY</b>, <b>CATCH</b>, and <b>THROW</b>. For various reasons,
the macros have fallen out of favor; since MFC 3.0, these macros have simply become
aliases for the original C++ keywords <b>try</b>, <b>catch</b>, and <b>throw</b>. Thus,
while MFC still supports the uppercase macro names, the names are no longer recommended
because there is no advantage to using them.</p>

<A NAME="477"><H3>Benign Exceptions</H3></A>

<p>Some exceptions are benign and consequently do not show up as errors in an
application. For example, a benign exception can occur when a program accesses an
uncommitted page of its stack memory. The operating system confronts this situation
transparently by trapping the invalid access, committing another page to the stack, and
then allowing the access to continue using the committed
page. The application does not recognize that the exception has occurred. The only
external evidence of such an exception is a momentary delay while the
operating system sets up a new page.</p>

<A NAME="478"><H2>Logging Errors</H2></A>

<p>The first two sections of this lesson describe how errors can be handled inline as
they occur. Because not all errors can be anticipated and caught by developers,
it is important to keep a record of unexpected errors as they occur. This section
presents a third technique in which an executing program simply compiles a record of
errors (an error log) without stopping to confront them. Developers
can then read through the resulting error log after the program terminates, and revise
the program's code to ensure that the errors do not occur again.</p>

<p>MFC programs use the <b>TRACE</b> macro and its variations to achieve this
&quot;offline&quot; approach to error handling. Many C programmers employ a similar
technique
by the liberal use of <b>printf()</b> statements throughout their code, which provide a
running commentary as the code progresses by displaying brief messages such as
these:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
Entering Function1
Allocating memory block
Block successfully allocated
.
.
.
Leaving Function1</pre>
</td></tr>
</table>
</p>

<p>The <b>TRACE</b> macro logs errors by displaying messages at the location specified
by <b>AfxDump</b>, which by default is the <b>Debug</b> tab of the Visual C++ Output
window. <b>TRACE</b> operates only for a project's debug build (described in
<a href="ch13d.htm#487">Lesson 3</a> of this chapter). For release builds, the macro does nothing. Because it does not
expand into code, the <b>TRACE</b> macro does not increase the size of a program's
release version.</p>

<p><b>TRACE</b> accepts the same string formatting commands as <b>printf()</b>, so you
can display variables in a <b>TRACE</b> line as demonstrated in the following code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
int  iFileSize = 10;
char sz[] = &quot;kilobytes&quot;;
// Display the string &quot;File size is 10 kilobytes&quot;
TRACE(&quot;File size is %d %s\n&quot;, iFileSize, sz);</pre>
</td></tr>
</table>
</p>

<p>The maximum string length after formatting cannot exceed 512 characters, including
the terminating <b>NULL</b>. MFC also offers the macros <b>TRACE0</b>, <b>TRACE1</b>,
<b>TRACE2</b>, and <b>TRACE3</b>, which take fixed numbers of variables (0, 1, 2 or 3).
The only advantage offered by these variations over <b>TRACE</b> is that they expand
into code that is a bit more compact.</p>

<A NAME="479"><H2>Lesson Summary</H2></A>

<p>In this lesson, you've learned some of the many ways an application can
anticipate and respond to errors as they occur during execution.</p>

<p>The operating system's structured exception handling mechanism is the
foundation on which C++ exception handling is built. Visual C++ implements
C++ exception handling through the <b>try</b>, <b>catch</b>, and <b>throw</b> keywords. The MFC macro equivalents for these keywords are no longer used in C++ programming.</p>

<p>Testing for return values is an excellent programming habit, but can often be
replaced by exception handling. <b>TRACE</b> statements provide a convenient way to
create a running record of a program's logic flow, which you can examine to make
sure your program is executing as expected.</p>

<p>The philosophy of error handling can be summed up in two words: &quot;Don't
assume!&quot; Errors have a habit of occurring when least expected. Proper error-handling techniques enable your program to gracefully respond to the unexpected,
without terminating abnormally&#8212;or worse, continuing to execute in an unstable
state.</p>

</BODY>
</HTML>







