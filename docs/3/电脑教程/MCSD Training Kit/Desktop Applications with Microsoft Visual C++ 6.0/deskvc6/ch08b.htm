<HTML>
<HEAD>
<TITLE>Lesson 1: COM Architecture</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch08a.htm", "ch08c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="312"><H1>Lesson 1: COM Architecture</H1></A>

<p>COM is a binary standard that defines a way for software objects, developed in
different languages or operating on different platforms, to communicate. A COM
component is a reusable software object that conforms to COM specifications.</p>

<p>In this lesson, you will learn about the basic architecture of Win32 operating
systems, which allows you to create and use COM components in your programs. You will
learn about the essential features of the COM specification, and how COM components are
registered on a computer so that client programs can identify and make use of the
functionality they offer.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>

<ul>
<p><li>Describe the architecture that enables a client to use a COM object.</li></p>

<p><li>Describe the role of interfaces in COM.</li></p>

<p><li>Describe the purpose of the <b>IUnknown</b> interface.</li></p>

<p><li>Describe how globally unique identifiers (GUIDs) uniquely identify components and interfaces.</li></p>

<p><li>Describe the registry entries required to register a COM object.</li></p>

<p><li>Describe how to use the <b>CoCreateInstance()</b> function to create COM objects.</li></p>
</ul>


<b>Estimated lesson time: 50 minutes</b>
</blockquote></div>
</p>


<A NAME="313"><H2>Using COM Objects</H2></A>

<p>COM objects allow you to construct an application comprising a set of distinct
cooperating components. One benefit of using COM objects is that they make
interoperability available, irrespective of where the binary object is physically
located. An important aspect of COM objects is that a program may attach dynamically to
the object during execution.</p>

<p>For example, an application hosted in an executable file may link dynamically
to a COM component hosted in a DLL. Because the component and executable are
dynamically linked, they do not need to reside in the same location. To dynamically
link to a binary object during execution, a program and the operating system cooperate
to locate the object. COM defines all elements that both you and the operating system
use in cooperation to ensure that the dynamic linking process works correctly.</p>

<p>Figure 8.1 shows the elements that participate in the dynamic linking process.</p>

<p>
<A HREF="javascript:fullSize('f08DA01x.htm')"> <img src="images/f08DA01.jpg" width=404 height=179 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 8.1</b> <i>COM elements used to support dynamic linking</i><!-- /caption -->
</p>

<p>COM objects are implemented as .dll or .exe files. Every COM object that resides on
your system must be registered with the Windows operating system. Registration
information appears in the Windows registry. In the registry, you find a class
identifier (ClassID) that identifies the object uniquely across all computers. The
ClassID is a specially formatted globally unique identifier, or <i>GUID</i>. You will
learn more about GUIDs later in this lesson.</p>

<p>When your client wants to link dynamically to a registered COM object, the
client program uses the ClassID to identify the binary object. The COM run-time
libraries, an integral component of the Windows operating system, provide the means for
clients to locate and instantiate COM objects.</p>

<p>Once the COM libraries receive a ClassID, they search the <b>HKEY_CLASSES_ROOT</b> portion of the registry in an attempt 
to find the location of the COM object
that owns that ClassID. If the search is successful, the COM libraries create an
instance of the object and return a pointer to the object's interface. The client
uses this pointer to call the methods that the object provides. Otherwise, an error is
reported to the client. An application will typically interact with this dynamically
linked binary object by executing methods listed in its interface pointer. If the
object needs to initiate interaction with your client program, you register event
handler methods with the object. Under appropriate and well-defined conditions, the
object fires events that are processed by these handler methods.</p>

<p>One of the features of COM is <i>location transparency</i>. Client applications can
be written without concern as to whether the objects used run within their process, in
a different process on the same computer, or in a process on a separate computer.</p>

<A NAME="314"><H2>COM Interfaces</H2></A>

<p>Your COM object provides access to its services through one or more interfaces. A
COM interface is a logical grouping of related methods identified by a GUID, known as
an Interface Identifier (IID). COM components are often described in terms of the
client/server model, wherein a COM server is a component that provides services to
client programs through the methods it exposes. Using this model, an interface can be
understood as a description of the services provided by a component.</p>

<p>You gain access to the methods provided by the interface by obtaining a pointer to
the interface, which references a table of function pointers known as the 
<i>vtable</i>. Each function pointer in the vtable enables you to access a single method
provided by the interface.</p>

<p>Figure 8.2 shows a COM server object named <b>Encoder</b> that exposes three
interfaces. <b>IUnknown</b> (discussed in the following section) is the interface that
must be implemented by every COM component. The <b>IEncoder</b> and <b>ICommunicate</b>
interfaces are specified by the designer of the component to expose the <b>Encoder</b>
object's services. Figure 8.2 illustrates the default notation for illustrating COM
components. We have shown the methods provided by the interfaces to the left of the
diagram.</p>

<p>
<A HREF="javascript:fullSize('f08DA02x.htm')"> <img src="images/f08DA02.jpg" width=404 height=155 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 8.2</b> <i>Components and interfaces</i><!-- /caption -->
</p>

<p>Figure 8.2 shows that components and interfaces have separate GUIDs. The names of
the GUIDs shown illustrate the kind of #defined IDs that you use in your code to refer
to the different types of GUIDs. As you will learn later in this chapter, GUIDs are
large hexadecimal numbers.</p>

<p>An <i>interface</i> is a logically separate entity from the component that
implements the component. In other words, the same interface can be implemented by
many different components. An interface is analogous to a C++ abstract class
definition. The identity of an interface is established by its unique IID. Once you
publish your interface specification to the world, you are guaranteeing to anyone who
might want to use or implement your interface that it <i>will not change</i>. The
number and order of the methods, and the data types of the arguments and return values,
are guaranteed to remain the same. If you want to add or alter methods, you must define
a new interface with a different IID.</p>

<p>The fact that an interface is obtained as a pointer to a function table (the
vtable), would seem to imply that a COM object could provide only methods to client
applications. However, many languages that support COM (Microsoft Visual
Basic, for example) support the notion of <i>properties&#8212;</i>public data members of
components that are analogous to the member variables of a C++ class. Components
written in C++ implement properties as pairs of methods used to set
and get the value of encapsulated class data. This technique is illustrated in <A HREF="ch09a.htm">Chapter 9</A>.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
In this book we use the terms <i>property</i> and <i>method</i>
to refer specifically to features of a COM interface. For regular C++ objects we use
the terms <i>member variable</i> and <i>member function</i>.</blockquote></div>
</p>

<A NAME="315"><H3>IUnknown</H3></A>

<p>The <b>IUnknown</b> interface, illustrated in Figure 8.3, must be implemented by
every COM component.</p>

<p>
<A HREF="javascript:fullSize('f08DA03x.htm')"> <img src="images/f08DA03.jpg" width=404 height=262 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 8.3</b> <i>The <b>IUnknown</b> interface</i><!-- /caption -->
</p>

<p><b>IUnknown</b> contains three methods that you implement for your COM object. When
you implement the <b>QueryInterface()</b> method, you provide a mechanism for a client
program to access any of the interfaces supported by your COM
object.</p>

<p>Because a single instance of a component may service requests from a number of
different clients, you must implement a reference counter for your COM object. This
private data member serves to track the number of connected client applications. The
<b>AddRef()</b> and <b>Release()</b> methods operate on the reference counter. When the
reference counter reaches zero, the component terminates itself.</p>

<p>You must implement your COM components so that the <b>IUnknown</b> methods are
always the first three methods in the vtable. The methods exposed by the other
interfaces are listed sequentially after these methods.</p>

<p>Figure 8.4 illustrates a possible vtable layout for the <b>Encoder</b> object
illustrated in Figure 8.2.</p>

<p>
<img src="images/f08DA04.jpg" width=311 height=291>
</p><p>
<!-- caption --><b>Figure 8.4</b> <i>The structure of a vtable</i><!-- /caption -->
</p>

<p>At the beginning of the vtable are the <b>IUnknown</b> methods, followed by the
methods exposed by the <b>IEncoder</b> interface, and then followed by the <b>
ICommunicate</b> methods. When the COM run-time library instantiates the <b>Encoder</b>
object, it obtains a pointer to the beginning of the vtable (shown as <b>pVtbl</b> in
Figure 8.4). This pointer can be used to call the first function in the table&#8212;the
<b>QueryInterface()</b> function. Your object's implementation of the <b>
QueryInterface()</b> function must
return a pointer to the requested interface.</p>

<A NAME="316"><H2>GUIDs</H2></A>

<p>GUIDs are 128-bit numeric identifiers that uniquely distinguish each COM
object and the specific interfaces supported by COM objects. GUIDs are guaranteed to
be unique across the world and to remain unique for a very long time. You use the
Windows command-line utility UUIDGEN.EXE (or the graphical user-interface version
GUIDGEN.EXE) to generate GUIDs for your components and interfaces.</p>

<p>A detailed characterization of a GUID appears in Figure 8.5.</p>

<p>
<A HREF="javascript:fullSize('f08DA05x.htm')"> <img src="images/f08DA05.jpg" width=404 height=209 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 8.5</b> <i>The construction of a GUID</i><!-- /caption -->
</p>

<p>A GUID actually exists in two formats: string and numeric. A string format appears
in various locations in the registry. Numeric representations of GUIDs are necessary
when using the GUID within client applications and within the actual COM object
implementation.</p>

<p>As you can see in Figure 8.5, the numeric representation of a GUID is 128 bits in
length. Within the structure _GUID, an unsigned long field named <b>Data1</b> is
32 bits long. The fields named <b>Data2</b> and <b>Data3</b> are unsigned short values,
each consuming 16 bits. Eight unsigned <b>char</b> values each require 8 bits. If you
add all of this together, you find that the numeric representation of a GUID consists
of a 128-bit representation.</p>

<p>When you use the numeric representation within your COM object or within
C++ client code, you declare a variable and use a specific macro to initialize
the variable to the associated numeric value. The macro that you use is named 
<b>DEFINE_GUID</b> and appears in the header file initguid.h. Typically, the variable name
that you use begins with either the prefix <i>CLSID</i> or <i>IID</i>. These prefixes
indicate whether the GUID refers to a COM object or to an interface supported by a COM
object.</p>

<A NAME="317"><H2>COM Registry Entries</H2></A>

<p>When you install a COM object onto a computer, you must register the object by
creating entries in the computer's registry.</p>

<p>Figure 8.6 illustrates the registry entries required for a
typical COM object.</p>

<p>
<A HREF="javascript:fullSize('f08DA06x.htm')"> <img src="images/f08DA06.jpg" width=404 height=256 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 8.6</b> <i>Registering the COM object</i><!-- /caption -->
</p>

<p>To register your COM object, you create entries under the <b>HKEY_CLASSES_ ROOT</b>
subtree, under the predefined <b>CLSID</b> key. These entries enable the COM libraries
to locate your COM object and load it into memory. Beneath the <b>CLSID</b> key, you
type a subkey that is the string form of your <b>CLSID</b> COM object. Beneath this
subkey, you attach the subkey that provides COM with the path to the component server,
as shown here:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>HKEY_CLASSES_ROOT\CLSID\{64CE33A0-6B03-11d3-9352-0080C7FA0C3E}\
    InprocServer32 = c:\Encoder\debug\Encoder.dll</pre>
</td></tr>
</table>
</p>

<p>The name of the subkey&#8212;<b>InprocServer32</b>&#8212;indicates that the component
server is a DLL on the local computer.</p>

<p>Immediately beneath <b>HKEY_CLASSES_ROOT</b>, you can provide a key value
representing a string name for your COM object. This string name is a
version-independent programmatic identifier (ProgID). Associated with this string name,
you type a subkey explicitly named <b>CLSID</b> whose value indicates the GUID for your
COM object in its string format. A path representation for this entry looks like
this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>HKEY_CLASSES_ROOT\Encoder\CLSID = {64CE33A0-6B03-11d3-9352-0080C7FA0C3E}</pre>
</td></tr>
</table>
</p>

<p>By using a function named <b>CLSIDFromProgID()</b>, a client application can
retrieve the CLSID from the ProgID. By providing the ProgID, you enable a client
application developer to create an instance of your COM object without having to go
through the error-prone process of typing a CLSID into the source code. Visual Basic
client code will always specify COM objects as ProgIDs, so you will need to register a
ProgID if you are intending to use your objects with non-C++ clients.</p>

<A NAME="318"><H2>Creating Objects Using CoCreateInstance()</H2></A>

<p>Once the CLSID is obtained using the <b>CLSIDFromProgID()</b> function, a client
application submits the CLSID to the COM run-time library to load the COM object and
retrieve an interface pointer. The function used to perform this operation is 
<b>CoCreateInstance()</b>. Using the CLSID and the registry, <b>CoCreateInstance()</b>
locates the specified object, creates an instance of that object, and returns an
interface pointer to that object.</p>

<p>The signature of the <b>CoCreateInstance()</b> function is shown below:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre><b>STDAPI CoCreateInstance (REFCLSID</b> <i>rclsid</i>,
<b>    LPUNKNOWN</b> <i>pUnkOuter</i>,
<b>    DWORD</b> <i>dwClsContext</i>,
<b>    REFIID</b> <i>riid</i>,
<b>    LPVOID *</b> <i>ppv</i><b>)</b> ;</pre>
</td></tr>
</table>
</p>

<p>The first argument to the function is the CLSID of the object. The second argument
is used to aggregate the object as part of another object. Aggregation is explained in
detail in <a href="ch10c.htm#389">Lesson 2</a> of Chapter 10.</p>

<p>The third argument specifies the execution context of the object. The possible
values for this argument are:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>CLSCTX_INPROC_SERVER
CLSCTX_INPROC_HANDLER
CLSCTX_LOCAL_SERVER
CLSCTX_REMOTE_SERVER</pre>
</td></tr>
</table>
</p>

<p>Execution contexts are discussed in the following lesson.</p>

<p>The <i>riid</i> argument is the IID of the requested interface. If the COM object is
created successfully and supports the interface requested by the client, an interface
pointer is returned through the <i>ppv</i> argument.</p>

<p>A detailed operational analysis of COM object creation that results from executing
the <b>CoCreateInstance()</b> function appears in Figure 8.7.</p>

<p>
<A HREF="javascript:fullSize('f08DA07x.htm')"> <img src="images/f08DA07.jpg" width=404 height=288 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 8.7</b> <i>The COM object creation sequence</i><!-- /caption -->
</p>

<p>This sequencing diagram shows the elements used in the COM object creation process.
The specific entities involved in COM object creation are across the top of the
diagram. The sequence of interactions among the participating entities proceeds from
the top of the diagram down to the bottom of the diagram.</p>

<p>A client application requests access to a specific interface supported by the COM
object using the <b>CoCreateInstance()</b> function. This function accesses
the COM library, requesting that the COM object be loaded. The COM library queries the
registry along the indicated path, obtaining the path to and the name of the component
server (in this case, a DLL).</p>

<p>When the component server is initialized, a class factory object is
instantiated.
A class factory is an object that creates other objects of a specific class, which you
implement as part of your COM component. A class factory implements
the <b>IClassFactory</b> interface. A pointer to the class factory interface then
propagates all the way back to the COM library. Using this interface pointer, the
COM library executes the <b>CreateInstance()</b> method supported by the class factory
object. Your implementation of this method creates an instance of the COM class that
actually provides all the methods that might be accessed by a client application. The
act of creating this class initializes the vtable so a client application can execute
the supported methods. A pointer to the <b>IUnknown</b> interface is returned to the
COM library. When the COM library receives this interface pointer, it releases the
class factory object and returns the <b>IUnknown</b> pointer to the client application.
This pointer now references the component vtable, enabling the client to execute the
methods provided by the COM object.</p>

<p>The entity interaction sequence outlined previously occurs in its entirety only the
first time a client instantiates a COM object. If another client wants to use methods
supported by this COM object, an interface pointer to the same COM object returns to
the new client, and the server increments the reference count by calling 
<b>IUnknown::AddRef()</b>. When the client has finished using the component interface, it
<i>must</i> call the <b>IUnknown::Release()</b> method to decrement the reference
count. If any client fails to perform this action, the reference count will never reach
zero, and the component will not be destroyed, leading to serious memory leakage
problems.</p>

<A NAME="319"><H2>Lesson Summary</H2></A>

<p>COM allows dynamic linking of binary software components that can reside on a local
computer or on a computer across a network. The COM run-time library uses registry
entries to locate and to load a COM object. Every COM object supports the 
<b>IUnknown</b> interface and additional component-specific interfaces. Each interface is
a collection of one or more methods. Separate GUIDs identify the COM object and every
interface exposed by the object. Within your class implementation you provide an object
known as a class factory that creates an instance of your COM object.</p>

</BODY>
</HTML>







