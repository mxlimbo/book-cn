<HTML>
<HEAD>
<TITLE>Lesson 3: MFC Application Framework</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch03c.htm", "ch03e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="119"><H1>Lesson 3: MFC Application Framework</H1></A>

<p>Now that you have an understanding of the Windows application architecture, you are
ready to learn how MFC implements a basic Windows application.</p>

<p>In addition to the encapsulation of the Win32 API, MFC defines a small group of classes
to represent common application objects, and establishes relationships within this
group to implement fundamental Windows application behaviors. These application
architecture classes, along with a number of global functions, comprise an <i>
application framework</i> that you can use as a basis for constructing applications.
You can use the MFC AppWizard to generate a set of classes that is derived from the
framework classes. You can build upon these classes to construct an application to suit
your individual requirements.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to:</b>


<ul>
<p><li> Describe how the MFC application framework implements a Windows application.</li></p>

<p><li> Describe the role of the application class and the main window class in the
application framework.</li></p>

<p><li> Describe how the AppWizard can be used to generate a basic framework application.</li></p>

<p><li> Describe how Windows messages are handled by the application framework.</li></p>
</ul>


<b>Estimated lesson time: 40 minutes</b>
</blockquote></div>
</p>


<A NAME="120"><H2>MFC Application Architecture</H2></A>

<p>The MFC application framework implements a basic Windows application architecture by
providing:</p>

<ul>
<p><li> A class to represent the application.</li></p>

<p><li> An implementation of the <b>WinMain()</b> function.</li></p>

<p><li> A class to represent the main application window.</li></p>
</ul>


<A NAME="121"><H3>Application Class</H3></A>

<p>The MFC class <b>CWinApp</b> represents the application as a whole. <b>CWinApp</b>
is derived from <b>CWinThread</b>, the class that represents a thread in an MFC
application. <b>CWinApp</b> represents the primary thread of an application's
process, and encapsulates the initialization, running, and termination of a
Windows-based application. These behaviors are implemented by the member functions
described in Table 3.3.</p>

<p><b>Table 3.3</b> <i>CWin App Member Functions</i></p>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th>CWinApp member function</th>
<th>Purpose</th>
</tr>
<tr>
<td valign="top">InitInstance()</td>
<td valign="top">Initializes each new instance of your application
running under Windows. Displays the application's
main window.</td>
</tr>
<tr>
<td valign="top">Run()</td>
<td valign="top">Provides the implementation of the message loop.</td>
</tr>
<tr>
<td valign="top">OnIdle()</td>
<td valign="top">Called by the framework when no Windows messages
 are being processed. You can override this function to
perform background tasks.</td>
</tr>
<tr>
<td valign="top">ExitInstance()</td>
<td valign="top">Called each time a copy of your application terminates.</td>
</tr>
</table>
</p>

<p>An application built on the MFC framework must implement exactly one class derived from
<b>CWinApp</b>. You must also provide your own overridden version of the <b>
InitInstance()</b> member function. The <b>InitInstance()</b> function is called
directly by the <b>WinMain()</b> function, and is the proper location for
initialization specific to your application.</p>

<A NAME="122"><H3>WinMain() Function</H3></A>

<p>The framework provides a standard <b>WinMain()</b> function for your application.
<b>WinMain()</b> calls a number of global functions to perform standard initialization
services such as registering window classes. It then calls the <b>InitInstance()</b>
member function of the application object to initialize the application. Next <b>
WinMain()</b> calls the <b>Run()</b> member function of the application object to run
the application message loop. The message loop will continue to acquire and dispatch
messages until a WM_QUIT message is received, at which point it calls the application
object's <b>ExitInstance()</b> function and returns. <b>WinMain()</b> will then
call cleanup routines and terminate the application.</p>

<A NAME="123"><H3>Main Window</H3></A>

<p>An essential component of a Windows application is the <i>main window,</i> which
represents the principal interface to your application. This might be a simple dialog
box; or it might be a <i>frame window</i>, which is a resizable window that houses the
application menu, the toolbars, and the window client area. In either case, a framework
application should provide a class&#8212;derived from the <b>CDialog</b> class or from
the <b>CFrameWnd</b> class&#8212;that the application can use to create the main window
object. The main window is initially displayed by the application object's <b>
InitInstance()</b> function.</p>

<p>As an exercise, return to the MyApp project you created in Chapter 2 to view the framework classes that have been created for you.</p>

<p><li> <b>To view the MyApp framework classes</b></li></p>

<ol>
<p><li> Open the MyApp workspace by clicking <b>Open Workspace</b> on the <b>File</b>
menu. If you saved your work in the default directory, the workspace name will
appear in the list. If not, navigate to where you saved the workspace. Double-click
<b>CMyApp.dsw</b> to open the workspace.</li></p>

<p><li> In ClassView, expand the first item in the list, <b>MyApp classes</b> (if it is
not already expanded), to view the classes created for this project by the
AppWizard.</li></p>

<p><li> Expand the <b>CMyAppApp</b> class to view the overloaded methods created by the
AppWizard for this class. Your Workspace pane should now look like Figure 3.4.</li></p>

<p>
<img src="images/f03DA04.jpg" width=271 height=333>
</p><p>
<!-- caption --><b>Figure 3.4</b> <i>The MyApp project ClassView</i><!-- /caption -->
</p>

<p><li> Double-click <b>CMyAppApp</b> to view the class declaration. Note how this class
is derived from the MFC class <b>CWinApp</b>.</li></p>

<p><li> Double-click <b>InitInstance()</b> to view its source code. Look through the
code and the comments to gain an idea of the sort of initializations that are performed
by this function. The implementation of <b>InitInstance()</b> that the AppWizard
generates will perform initializations in accordance with the
options you chose while stepping through the AppWizard.</li></p>
</ol>

<A NAME="124"><H2>Application Framework Message Handling</H2></A>

<p>In <a href="ch03c.htm#110">Lesson 2</a>, you learned that one of the key tasks of Windows application
development is the mapping of system messages to routines that will handle them. In
Win32 applications constructed without MFC, you supply a window procedure for each type
of window class that is registered. These window procedures are often implemented as
switch statements based on the value of the message ID. In an application based on the
MFC framework, messages are handled by member functions of the application's
classes. These can be classes that you create yourself or classes generated by the
AppWizard for your application. The mapping of messages to their appropriate handler
function is achieved by the use of <i>message maps</i>.</p>

<A NAME="125"><H3>Message Maps</H3></A>

<p>A message map is a table, declared within a class definition, that maps system
messages to the member functions of the class. The message map contains entries that
link the message IDs to the handler functions. The message map recognizes four types of
messages, as described in Table 3.4.</p>

<p><b>Table 3.4</b> <i>MFC Message Types</i></p>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th>Message type</th>
<th>Description</th>
</tr>
<tr>
<td valign="top">Windows</td>
<td valign="top">Windows messages are generated by the operating system. They inform the
application about window creation, impending window destruction, mouse
and keyboard events, changes to the system colors, and anything else that
can affect the operation of the application. The identifiers for these mes-
 sages generally begin with the WM_ prefix. Windows messages are usually
 handled by the window to which Windows sends the message, such as an
 application's main frame window, or by a dialog box.</td>
</tr>
<tr>
<td valign="top">Command</td>
<td valign="top">Command messages are generated from user interaction with the user
 interface&#8212;for example when the user selects a menu item, clicks a tool-
 bar button, or presses a shortcut key. When one of these events occurs, a WM_COMMAND message with command-specific parameters is sent to
 the application. Command messages are routed by the framework to the
 application objects. This <i>command routing</i> is a feature that allows the
application to handle the message in the class most closely associated with the
 message.</td>
</tr>
<tr>
<td valign="top">User interface update command</td>
<td valign="top">User interface update command messages are generated from
within an application by the application framework&#8212;that is, they are MFC-specific.
 They signal the application to update the status of user interface elements
such as menu items or toolbar buttons. For example, before a menu is dis-
 played, the application framework will send the application an appropriate
 update command message that gives the application the opportunity to
 modify the menu command state&#8212;whether it should be available, unavailable, or
displayed with a check mark.</td>
</tr>
<tr>
<td valign="top">Control notification</td>
<td valign="top">Control notification messages are sent from controls and other
child windows to their parent windows. These are generally sent as
 WM_COMMAND messages with control notification parameters. For
 example, an edit control sends its parent a WM_COMMAND message
 containing the EN_CHANGE control notification code when the user
 has taken an action that might have altered text in the edit control.</td>
</tr>
</table>
</p>

<A NAME="126"><H3>Creating Message Maps</H3></A>

<p>MFC makes it easy to implement message maps. Any class that is derived from the <b>
CCmdTarget</b> class is capable of supporting a message map. All the framework classes
generated with the AppWizard will be created with a basic mes-
sage map structure. You can use the ClassWizard tool to create new classes that
implement message maps and to maintain the message maps of existing classes by adding
and removing message map entries. Use ClassWizard to maintain your classes' message
maps wherever possible to save time and to ensure that the message maps are correctly implemented.</p>

<A NAME="127"><H3>Adding Handler Functions Using ClassWizard</H3></A>

<p>In this section, you will learn how to use ClassWizard to add handlers for a Windows
message and for a command message. In subsequent chapters, you will learn how to
implement user interface update command messages and control notification messages. By
looking at the code that is generated, you will learn how message maps are implemented
in an MFC application.</p>

<p>In the following exercise, you will add a handler to display a message box when the
user clicks in the client area of your MyApp application window. The <i>client area</i>
is the area enclosed by the frame window, where application data is usually
displayed.</p>

<p><li> <b>To add a handler for a Windows message</b></li></p>

<ol>
<p><li> Return to the MyApp project.</li></p>

<p><li> Press CTRL+W to open ClassWizard. Click the <b>Message Maps</b> tab.</li></p>

<p><li> In the <b>Class Name</b> list, click <b>CMyAppView</b>. This indicates that you
want to handle a message sent to the application's <i>view</i> class. The view
class encapsulates the main window's client area.</li></p>

<p><li> In the <b>Object IDs</b> list, click <b>CMyAppView</b>.</li></p>

<p><li> In the <b>Messages</b> list, click <b>WM_LBUTTONDOWN</b>. This message is
sent to the application when a user clicks the left mouse button in the window
client area.</li></p>

<p><li> Click <b>Add Function</b>. ClassWizard creates a stub function to which you can
add your own code. All Windows messages are handled by overloaded virtual functions on
the <b>CWnd</b> base class. The name of the overloaded virtual function will start with
&quot;On&quot; and is followed by the name of the message, with the initial
&quot;WM_&quot; removed, and only the first letter of each word capitalized. In this
case, the stub function created is named <b>OnLButtonDown()</b>.</li></p>

<p><li> Click <b>Edit Code</b>. The MyAppView.cpp file is opened and the insertion point
is positioned at the top of the <b>OnLButtonDown()</b> function implementation.</li></p>

<p><li> Replace the // TODO comment line with the following code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>AfxMessageBox(&quot;You clicked?&quot;);</pre>
</td></tr>
</table>
</p>

<p>so that your code reads as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CMyAppView::OnLButtonDown(UINT nFlags, CPoint point) 
{
     AfxMessageBox(&quot;You clicked?&quot;);
     CView::OnLButtonDown(nFlags, point);
}</pre>
</td></tr>
</table>
</p>

<p><li> Press F7 to build the MyApp project, and then press CTRL+F5 to run the
application. Click with the left mouse button in the application client area to test
that the WM_LBUTTONDOWN message is handled as expected. Close the MyApp
application.</li></p>
</ol>

<p>In the following exercise, you will add a handler for a command message that is
generated when the user clicks <b>Paste</b> on the <b>Edit</b> menu in the MyApp
application.</p>

<p><li> <b>To add a handler for a command message</b></li></p>

<ol>
<p><li> From within the MyApp project, press CTRL+W to open ClassWizard. Click the <b>
Message Maps</b> tab.</li></p>

<p><li> In the <b>Class Name</b> list, click <b>CMyAppApp</b>. Remember that command
messages can be handled by any of the application classes. Because our handler function
does very little, we will make it a member of the application class. The class most
closely associated with the command should handle command messages. For example, the
CMainFrame class would best handle a command that simply modifies attributes of the
main frame window, such as hiding or showing a toolbar.</li></p>

<p><li> In the <b>Object IDs</b> list, click <b>ID_EDIT_PASTE</b>. This is the command
ID that is passed as a parameter of the WM_COMMAND message generated when <b>Paste</b>
is clicked on the <b>Edit</b> menu.</li></p>

<p><li> In the <b>Messages</b> list, click <b>COMMAND</b>. This indicates that we are to
handle a command message and not a user interface update command message.</li></p>

<p><li> Click <b>Add Function</b>. A dialog box appears, suggesting the name <b>
OnEditPaste()</b> for your handler function. This is because you are defining a new
function to handle the message rather than overloading an existing virtual function of
the parent class. Click <b>OK</b> to accept the name.</li></p>

<p><li> Click <b>Edit Code</b>. The MyAppView.cpp file is opened and the insertion point
is positioned at the top of the function implementation.</li></p>

<p><li> Replace the // TODO comment line with the following code:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>AfxMessageBox(&quot;MYAPP does not support the Paste command&quot;);</pre>
</td></tr>
</table>
</p>

<p>so that your code reads as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CMyAppApp::OnEditPaste() 
{
     AfxMessageBox(&quot;MYAPP does not support the Paste command&quot;);
}</pre>
</td></tr>
</table>
</p>

<p><li> Build and run the CMyApp application. Click <b>Paste</b> on the <b>Edit</b> menu
to test that your handler function behaves as expected. Note that the framework
disables menu items for commands for which you haven't provided handlers.</li></p>
</ol>

<A NAME="128"><H3>Understanding the Message Map Code</H3></A>

<p>When you use ClassWizard to add handler functions, it automatically performs the
following tasks for you:</p>

<ul>
<p><li> It declares the handler function in the class header file.</li></p>

<p><li> It creates a handler function stub in the class implementation file.</li></p>

<p><li> It adds an entry for the handler to the message map.</li></p>
</ul>


<p><li> <b>To see the declaration for the CMyAppApp::OnEditPaste() function</b></li></p>

<ol>
<p><li> In ClassView, double-click <b>CMyAppApp</b> to view the class definition in the
file MyAppApp.h.</li></p>

<p><li> Locate the code toward the bottom of the class definition that reads:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>//{{AFX_MSG(CMyAppApp)
afx_msg void OnAppAbout();
afx_msg void OnEditPaste();
//}}AFX_MSG
DECLARE_MESSAGE_MAP()</pre>
</td></tr>
</table>
</p>
</ol>

<p>Note the <b>DECLARE_MESSAGE_MAP</b> macro. This is an essential part of the message
map implementation and is added to the class by the AppWizard or ClassWizard. You will
learn how to create classes using ClassWizard in subsequent chapters.</p>

<p>You have already seen, and added code to, the function stub that ClassWizard
provides.</p>

<p><li> <b>To view the message map entry for the CMyAppApp::OnEditPaste() function</b></li></p>

<ol>
<p><li> Return to the CMyApp.cpp file. If it has been closed, you can open it by
double-clicking the <b>OnEditPaste()</b> function icon in ClassView (beneath the <b>
CMyAppApp</b> class icon).</li></p>

<p><li> Near the top of the CMyApp.cpp file is the message map that looks like
this:</li></p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>BEGIN_MESSAGE_MAP(CMyAppApp, CWinApp)
     //{{AFX_MSG_MAP(CMyAppApp)
     ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
     ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
     //}}AFX_MSG_MAP
     // Standard file based document commands
     ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
     ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
     // Standard print setup command
     ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()</pre>
</td></tr>
</table>
</p>
</ol>

<p>You can see that ClassWizard has added an <b>ON_COMMAND</b> entry macro to the
message map. The structure of this macro is quite straightforward. The first parameter
is the ID of the command. (You will learn more about assigning command IDs in the next
chapter.) The second parameter is the name of the handler function.</p>

<p>The <b>OnLButtonDown ()</b> function handles the WM_LBUTTONDOWN message and is declared
in MyAppView.h as:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>afx_msg void OnLButtonDown(UINT nFlags, CPoint point);</pre>
</td></tr>
</table>
</p>

<p>The corresponding message map entry in MyAppView.cpp is:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>ON_WM_LBUTTONDOWN()</pre>
</td></tr>
</table>
</p>

<p>Because Windows messages are handled by overloaded virtual functions on
the <b>CWnd</b> base class, there is no need to supply the handler function name
as a parameter. The MFC framework automatically maps the message to the appropriate
virtual function. Windows messages often have additional information
attached to them in the form of parameters. The framework will take care of
extracting the information from these parameters and passing it to the handler
functions. If you look at the <b>CMyApp::OnLButtonDown</b> function declaration, you
will see that it takes the following: two parameters, derived from the WM_LBUTTONDOWN
message parameters, which indicate the current screen position of the mouse pointer;
and a flag value to indicate whether any of the &quot;virtual keys&quot; (for example,
CTRL or SHIFT) are also being depressed.</p>

<A NAME="129"><H3>Message Map Entry Macros</H3></A>

<p>MFC defines four message map entry macros, listed in Table 3.5, to correspond to the
four types of messages that can be handled by the message map.</p>

<p><b>Table 3.5</b> <i>Message Map Entry Macros</i></p>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th>Message type</th>
<th>Macro form</th>
<th>Parameters</th>
</tr>
<tr>
<td valign="top">Standard Windows message</td>
<td valign="top">ON_WM_<i>XXX</i> (where <i>XXX</i> is the name of the message)</td>
<td valign="top">None</td>
</tr>
<tr>
<td valign="top">Command message</td>
<td valign="top">ON_COMMAND</td>
<td valign="top">Command ID, Handler Name</td>
</tr>
<tr>
<td valign="top">Update command</td>
<td valign="top">ON_UPDATE_COMMAND_UI</td>
<td valign="top">Command ID, Handler Name</td>
</tr>
<tr>
<td valign="top">Control notification</td>
<td valign="top">ON_<i>XXX</i> (where <i>XXX</i> is the name of the parameter indicating the control notification)</td>
<td valign="top">Control ID, Handler Name</td>
</tr>
</table>
</p>

<p>You may have noticed that all ClassWizard-generated code is placed within comment
blocks beginning with {{AFX_MSG and ending with }}AFX_MSG. These tags denote areas that
are modified by ClassWizard. You are allowed to add message map entries or handler
function declarations manually, but you should add them <i>outside</i> of these
sections. Failure to do so might result in improper functioning of ClassWizard. The
AFX_MSG modifier that precedes the handler declaration is also used by ClassWizard. As
far as the compiler is concerned, it has no value.</p>

<A NAME="130"><H3>Deleting Message Map Entries</H3></A>

<p>If you use ClassWizard to delete message map entries, it will also delete the
function declaration in the class header file. It will not delete the function
implementation, which might contain code that you have written.</p>

<p><li> <b>To remove the CCMyAppApp::OnEditPaste() function</b></li></p>

<ol>
<p><li> From within the CMyApp project, press CTRL+W to open ClassWizard. Click the <b>
Message Maps</b> tab.</li></p>

<p><li> In the <b>Class Name</b> list, click <b>CCMyAppApp</b>.</li></p>

<p><li> In the <b>Member functions</b> list, click <b>OnEditPaste</b>.</li></p>

<p><li> Click <b>Delete Function</b>. A message box appears, warning you that you must
delete the function implementation yourself. Click <b>Yes</b>.</li></p>

<p><li> Click <b>OK</b> to close ClassWizard.</li></p>

<p><li> Locate the function implementation in MyApp.cpp and delete it.</li></p>

<p><li> Build and execute the application to ensure you removed the function properly
and to see the effect on the <b>Edit</b> menu.</li></p>
</ol>

<A NAME="131"><H3>Command Routing</H3></A>

<p>You will recall that command messages are routed by the framework to the application
objects. This <i>command routing</i> feature allows the application to handle the
message in the class most closely associated with the message. The MFC application
framework routes commands through a standard sequence of command-target objects
(defined by the classes in your application that are derived from <b>CCmdTarget</b> and
implement message maps) to see if any of them provide a handler for the command. Each
command-target object checks its message map to see if it can handle the incoming
message.</p>

<p>This command routing sequence can sometimes be used to your advantage. For example,
you can set up an application shortcut key to send a command message with <b>
ID_SAVE_WINDOW_STATE</b>. This shortcut key indicates that the user wants to save the
current window's settings. Some window objects in the system might provide their
own implementations of the associated handler function <b>OnSaveWindowState()</b>.
Other windows, such as temporary dialog boxes and help screens, might not. The command
routing sequence will check the message map of the currently active window to see if it
implements the function <b>OnSaveWindowState()</b>. If it does not, the message map of
the parent window will be checked. If that does not provide a handler, the message map
of the application object can be checked.</p>

<p>The command routing sequence varies according to context. To find out more about
command routing, search for &quot;command routing&quot; in the Visual C++ Help file.</p>

<A NAME="132"><H2>Lesson Summary</H2></A>

<p>The MFC application framework is a small group of interrelated classes that,
together with a number of global functions, implement a basic Windows application.
Using the AppWizard, you can easily generate a set of classes, derived from
the framework classes, on which they can build an application to suit their own
particular requirements.</p>

<p>The framework classes include the <b>CWinApp</b> class, which encapsulates the
application as a whole. It exposes several functions that are called by the
frame-work's implementation of the <b>WinMain()</b> function to handle the
initialization, running, and termination of a Windows-based application. The <b>
CFrameWnd</b> class encapsulates a frame window, which is a main application window
that is capable of hosting application menus, toolbars, and a window client area.</p>

<p>In an application based on the MFC framework, messages are handled by member functions
of the application's classes. The mapping of messages to their appropriate handler
function is achieved by the use of message maps, a feature supported by classes derived
from the MFC class <b>CCmdTarget</b>. Message maps are tables that are declared within
a class definition to link message IDs to member functions of the class. You should use
the ClassWizard tool to add and remove message map entries.</p>

<p>In this lesson, you learned how to use ClassWizard to add handlers for Windows
messages. Windows messages are generated by the operating system to inform the
application of changes in the Windows environment. These changes include mouse and
keyboard events and command messages. Command messages are generated by user
interaction with user interface elements such as menus and toolbars.</p>

<p>Command messages are routed by the framework to the application's command target
objects in a specific sequence until an object is found that provides the appropriate
handler. This command routing is a feature that allows the application to handle the
message in the class most closely associated with the message.</p>

</BODY>
</HTML>







