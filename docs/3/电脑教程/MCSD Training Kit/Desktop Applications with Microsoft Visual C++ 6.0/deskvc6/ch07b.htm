<HTML>
<HEAD>
<TITLE>Lesson 1: Data Access with Visual C++</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07a.htm", "ch07c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="275"><H1>Lesson 1: Data Access with Visual C++</H1></A>

<p>This lesson will explain the different data access interfaces available to the
Visual C++ application developer, and also explain circumstances in which each
interface should be used. Because these technologies can connect to relational
databases, you should have a basic understanding of relational database theory and
Structured Query Language (SQL), the host language for controlling and interacting with
an RDBMS. This lesson provides only a cursory introduction to relational database
theory and SQL.</p>

<p>
<div class="sidebar"><blockquote>

<b>After this lesson, you will be able to:</b>


<ul>

<p><li> Describe the development of Microsoft's strategy for data access.</li></p>

<p><li> Describe the data access interfaces available and determine the appropriate
technology to use for a given situation.</li></p>

<p><li> Describe the basic architecture of a relational database and how to use simple
SQL statements to retrieve data from tables within an RDBMS.</li></p>

</ul>

<b>Estimated lesson time: 40 minutes</b>

</blockquote></div>
</p>


<A NAME="276"><H2>Data Access Interfaces</H2></A>

<p>The number of data access interfaces available for Microsoft Windows applications
can seem overwhelming. Which of the cryptically named technologies&#8212;DAO, ODBC, RDO,
UDA, OLE DB or ADO&#8212;should you use to meet your specific application
requirements?</p>

<p>Your decision may be made easier by an explanation of the historical context of
these technologies. Microsoft's data access strategy was previously based on Data
Access Objects (DAO), for access to desktop databases; and Remote Data Objects (RDO),
which use the Open Database Connectivity (ODBC) architecture, for access to
client/server databases. This strategy is now being replaced by a single model,
Universal Data Access (UDA), which provides access to all types of data.</p>

<p>The goal of Microsoft's UDA strategy is to provide high-performance access to
non-relational data sources as well as relational databases through an easy-to-use
programming interface that is tool- and language-independent. UDA is implemented
through ADO, which provides a high-level interface to OLE DB, Microsoft's newest
Component Object Model (COM)-based data access technology.</p>

<p>While you can still use any of the earlier C++ data access technologies, you should
always use UDA technology when developing a new application. Generally, you should use
ADO for all of your data access because ADO is easy to use, has many powerful features,
and performs well. Experienced COM devel-opers can use the OLE DB interfaces directly
to gain optimum performance and efficiency benefits. Visual C++ 6.0 provides the <i>OLE
DB Templates</i>, a set of templated classes that implement many of the commonly used
OLE DB interfaces, to make the OLE DB technology easier to use.</p>

<p>If you are considering migrating an existing DAO/ODBC application to ADO, you will
have to consider whether the benefits of ADO justify the cost of the conversion. Code
written in DAO or RDO will not directly map to ADO code. However, a solution
implemented using other data access technologies will most likely be achievable using
ADO. Eventually, you should look towards converting all your code to ADO because it
implements a simpler, more flexible object model.</p>


<A NAME="277"><H3>Data Access Objects</H3></A>

<p>DAO, the native programming interface to the Microsoft Jet database engine, was
originally designed for use with Microsoft Visual Basic and Microsoft Visual Basic for
Applications. DAO uses the Microsoft Jet engine to provide a set of data access objects
that encapsulate common database objects such as tables, queries, and <i>recordsets</i>
(objects that contain a set of rows returned as a result of a query against a
database).</p>

<p>DAO is generally used to access local desktop data sources such as Microsoft Access,
Microsoft FoxPro, and Paradox, but it can also be used to access remote data
sources.</p>

<p>At the lowest level, DAO exposes its objects through COM interfaces. However, C++
programmers are more likely to access them through the MFC DAO database classes
(described in <a href="ch07c.htm#288">Lesson 2</a> of this chapter), or through the <b>dbDAO</b> classes. The <b>
dbDAO</b> classes provide C++ with the same DAO functionality available through Visual
Basic and also use a similar syntax.</p>


<A NAME="278"><H3>Open Database Connectivity</H3></A>

<p>ODBC provides a common application programming interface (API) to access
client/server data sources, usually an RDBMS, such as SQL Server or Oracle. ODBC's
consistent interface provides maximum interoperability; a single application can access
different RDBMS platforms through a common set of code.</p>

<p>This ability enables developers to build and distribute a client/server application
without targeting a specific RDBMS or having to know specific details of the different
database server platforms that the application may access. All that is needed to
connect to a RDBMS is an ODBC driver. These drivers are supplied by RDBMS vendors or
third-party developers, and developed according to the ODBC open standard.</p>

<p>Because the capabilities of different RDBMS platforms vary, and because ODBC driver
developers might choose to limit the number of features they implement, ODBC defines
three levels of driver <i>conformance</i> that provide the application with information
about what features are available to the application from the driver:</p>

<ul>

<p><li> <i>Core</i> conformance, which all ODBC drivers must meet.</li></p>

<p><li> <i>Level 1</i> conformance, which includes the Core interface conformance level
functionality plus additional features, like transactions, that are usually available
in a RDBMS.</li></p>

<p><li> <i>Level 2</i> conformance, which includes the Level 1 interface conformance
level functionality plus advanced features like the asynchronous execution of
ODBC.</li></p>

</ul>

<p>For more information about ODBC conformance levels, search for &quot;Interface
conformance levels&quot; in the Visual C++ Help file.</p>

<p>You can install and configure ODBC drivers on your computer using the ODBC Data
Sources applet in Control Panel. The ODBC Data Sources applet is also used to register
a <i>Data Source Name</i> (DSN). A DSN is a uniquely named collection of information
used by the ODBC Driver Manager to connect your application to a particular ODBC
database. A DSN must be registered on the specific system that will use it. DSNs can be
stored in a file (a <i>file DSN</i>) or in the registry (a <i>machine DSN</i>). Machine
DSNs are either installed for a particular user (a <i>user DSN</i>), or are accessible
to all users of a computer (a <i>system DSN</i>). Figure 7.1 shows the ODBC Data Source
Administrator being used to inspect system DSNs.</p>

<p>
<A HREF="javascript:fullSize('F07DA01x.htm')"> <img src="images/F07DA01.JPG" width=404 height=330 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 7.1</b> <i>The ODBC Data Source Administrator</i><!-- /caption -->
</p>

<p>ODBC is based on SQL as a standard for accessing data. When an application needs to
get data from a data source, the application sends an SQL statement to the ODBC Driver
Manager, which then loads the ODBC driver required to interface with the data. The
driver then translates the SQL sent by the application into the SQL used by the DBMS,
and finally sends it to the database server. The DBMS retrieves the data and passes it
back to the application via the driver and the Driver Manager.</p>

<p>ODBC provides a <i>cursor library</i>, which provides scrollable cursors for any
driver that meets the minimum level of ODBC conformance. You can use cursors to iterate
across a set of rows selected from a database.</p>

<p>C++ developers can use the ODBC API to connect to a database, send SQL statements,
retrieve results, get errors, disconnect, and so on. The ODBC API is a well-documented
way of writing client/server applications but is fairly difficult and involves a lot of
code. As a result, object models such as ADO or RDO, or the MFC ODBC database support
classes, are more commonly used.</p>


<A NAME="279"><H3>Remote Data Objects</H3></A>

<p>RDO is a thin objectified layer over the ODBC API. RDO depends on the ODBC driver
and the database engine for much of its functionality. Data access using RDO is
intended to provide access to an ODBC data source through an object model similar to
that used by DAO, without additional memory requirements necessitated by supporting a
local database. The RDO object model provides additional features such as server-side
cursors, disconnected recordsets, and asynchronous processing.</p>

<p>Like DAO, RDO exposes its objects through COM interfaces. RDO provides
the <i>Data Source Control</i>, an ActiveX control that encapsulates a database query
and the retrieved recordset. The Data Source Control provides controls that allow you
to browse through the recordset, displaying the data that it contains in one of
Microsoft's data-bound ActiveX controls, such as the <i>DBGrid</i> or <i>DBList</i>
controls.</p>


<A NAME="280"><H3>OLE DB</H3></A>

<p>OLE DB is a set of COM interfaces that provides applications with uniform access to
data stored in diverse information sources, regardless of location or type. OLE DB is
an open specification designed to build on the success of ODBC by providing an open
standard for accessing all types of data. Whereas ODBC was created to access relational
databases, OLE DB is designed for both relational and non-relational information
sources, including but not limited to mainframe, server, and desktop databases; e-mail
and file system stores; spreadsheets and project management tools; and custom business
objects.</p>

<p>Conceptually, OLE DB has three types of components: <i>data consumers</i>, <i>
service components,</i> and <i>data providers,</i> as illustrated in Figure 7.2.</p>

<p>
<A HREF="javascript:fullSize('F07DA02x.htm')"> <img src="images/F07DA02.JPG" width=404 height=431 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 7.2</b> <i>Components of OLE DB</i><!-- /caption -->
</p>

<p>Data consumers are applications or components that use the data exposed by data
providers. Any application that uses ADO is an OLE DB data consumer.</p>

<p>Service components are elements that process or transport data to extend the
functionality of data providers. Examples of service components include query
processors that generate or optimize queries; or cursor engines that consume data from
a sequential, forward-only data source to produce scrollable data.</p>

<p>Data providers are applications such as SQL Server or Microsoft Exchange, or system
components such as file systems or document stores, which expose their data to other
applications. Data providers expose OLE DB interfaces that data consumers or service
components can access directly. An OLE DB provider is available for ODBC; this provider 
makes the many existing ODBC data sources available to OLE DB data consumers.</p>


<A NAME="281"><H3>ActiveX Data Objects</H3></A>

<p>ADO is designed as a high-performance, easy-to-use application-level interface to
OLE DB. ADO is implemented with a small footprint, minimal network traffic, and a
minimal number of layers between the application and the data source, all contributing
to a lightweight, high-performance interface. ADO exposes a COM Automation interface,
which makes it accessible by all leading Rapid Application Development tools, database
tools, application development environments, and scripting languages.</p>

<p>Since ADO was designed to combine the best features of, and eventually replace, RDO
and DAO, it uses similar conventions with simplified semantics to make it easy to
learn. ADO provides the <i>ADO Data Control</i>, an improved version of the RDO Data
Source Control.</p>

<p>A feature of ADO, <i>Remote Data Service</i> (RDS) manages the transport of
disconnected recordsets to clients over HTTP as well as over <i>Distributed COM</i>
(DCOM), making it possible to develop full-featured, data-centric Web applications. ADO
will be covered in greater detail in <a href="ch07d.htm#297">Lesson 3</a> of this chapter.</p>


<A NAME="282"><H2>Using the ODBC Data Source Administrator</H2></A>

<p>In this practice exercise, you will use the ODBC Data Source Administrator to
register a system DSN for the <i>pubs</i> sample database that is included as part of a
standard SQL Server installation. You will use this DSN in subsequent exercises to
access ODBC data.</p>

<p><li> <b>To add a data source using the ODBC Administrator</b></li></p>

<ol>

<p><li> On the <b>Start</b> menu, click <b>Control Panel</b>. Open the <b>ODBC Data
Sources</b> applet.</li></p>

<p><li> On the <b>System DSN</b> tab, click <b>Add</b>. Select the SQL Server driver
from the list of drivers that are displayed, and then click <b>Finish</b>.</li></p>

</ol>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
If the SQL Server driver is not displayed in the list, you will need to
install the SQL Server ODBC Driver from your Visual C++ CD-ROM. Select <b>
Add/Remove</b> from the installation screen, and install the driver from the <b>Data
Access</b> option group.
</blockquote></div>
</p>

<ol start=3>

<p><li> Type <b>MyDSN</b> as the name of the data source. You can leave the <b>
Description</b> box empty.</li></p>

<p><li> Select <b>(local)</b> as the SQL Server to connect to, and click <b>
Next</b>.</li></p>

<p><li> If you have installed the Desktop version of SQL Server, select <b>SQL Server
authentication using a login ID and password entered by the user</b>. Enter the login
ID and password on this screen, and click <b>Next</b>.</li></p>

</ol>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Use the default login ID, <b>sa</b>, and leave the password box blank
unless you have assigned a password for this account. (On a default installation, the
<b>sa</b> account has no password.)
</blockquote></div>
</p>

<ol start=6>

<p>If you have installed the SQL Server Standard version, select <b>Windows NT
authentication using the network login ID</b>, and click <b>Next</b>.</p>

<p><li> Select the check box to make the <b>Change the default database to:</b> option
available. Select <b>pubs</b> from the drop-down list, and click <b>Next</b>.</li></p>

</ol>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
If the pubs database does not appear, you will need to install it on
your SQL Server. To do this, use the SQL Server Query Analyzer to load and execute the
<i>MSSQL7\Install\InstPubs.sql</i> script.
</blockquote></div>
</p>

<ol start=7>

<p><li> On the following screen, maintain the default options, and click <b>
Finish</b>.</li></p>

<p><li> Test the data source by clicking <b>Test Data Source</b>. The last line returned
should read TESTS COMPLETED SUCCESSFULLY! Click <b>OK</b> to dismiss the <b>SQL Server
ODBC Data Source Test</b> dialog box, then click <b>OK</b> again to complete the
registration procedure.</li></p>

</ol>

<p>You will see that the DSN has been added to the list of system DSNs. Close the ODBC
Data Source Administrator, and then close Control Panel.</p>


<A NAME="283"><H2>Relational Database Concepts</H2></A>

<p>While there are database system types other than relational databases, and while ADO
is intended to provide access to non-relational data as well as relational data, the
relational model is currently dominant. For that reason, before working with a data
source, you should have a basic understanding of relational database theory.</p>

<p>A <i>relational database</i> stores and presents data as a collection of tables.
(Tables are covered in greater detail later in this section.) A logical structure is
defined for this type of database by establishing relationships between tables. The <i>
relational database model</i> offers the following benefits in that it:</p>

<ul>

<p><li> Organizes data into a collection of tables to make the design easy to
understand.</li></p>

<p><li> Provides a relationally complete language for data definition, retrieval, and
update.</li></p>

<p><li> Provides data integrity rules that define consistent database states to improve
data reliability.</li></p>

</ul>


<A NAME="284"><H3>Elements of a Relational Database</H3></A>

<p>A relational database presents data as a collection of tables. For example, the SQL
Server sample database <i>pubs</i> contains business information of the type that might
be held by a publishing house. The pubs database contains one table that lists all
authors, and another that lists all book titles. Figure 7.3 shows a portion of the <i>
authors</i> table.</p>

<p>
<img src="images/F07DA03.JPG" width=332 height=257 border="0">
</p><p>
<!-- caption --><b>Figure 7.3</b> <i>The authors table from the pubs database</i><!-- /caption -->
</p>

<p><i>Tables</i> are logical groupings of related information made up of <i>rows</i>
and <i>columns</i>. A row (sometimes called a <i>record</i>) contains information about
a single entry in a table. For example, a row in the authors table would contain
information about a single author.</p>

<p>A row is composed of multiple columns (sometimes called <i>fields)</i>. Each column
contains a single piece of information about the row. For example, a row in the authors
table has columns for the author ID, the author's first name, and the author's
last name. If you look at the portion of the authors table shown in Figure 7.3, you
will see that these columns are named <i>au_id</i>, <i>au_lname</i> and <i>
au_fname</i>.</p>

<p>Unlike columns, table rows are not named. To uniquely identify rows within a table,
you must define a <i>primary key</i> for the table. A primary key is a column, or a
combination of columns, which has a unique value for each row in the table. The <b>
au_id</b> column shown in Figure 7.3 is an example of a primary key. Once a column or
columns have been defined as the primary key for a table, the data integrity rules
built into the RDBMS ensure that rows with duplicate keys cannot be added to the
table.</p>

<p>A table can also define <i>foreign keys</i> to specify relationships between tables.
A foreign key points to a primary key field in a related table. For example, the pubs
database contains the <i>titles</i> table, which lists published titles. The titles
table defines one of its columns as a foreign key, containing a primary key value from
the <i>publishers</i> table to designate the publisher of a particular title. Figure
7.4 shows this relationship as portrayed in the Visual Studio database diagram
tool.</p>

<p>
<A HREF="javascript:fullSize('F07DA04x.htm')"> <img src="images/F07DA04.JPG" width=404 height=248 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 7.4</b> <i>The relationship between the titles table and the publishers table</i><!-- /caption -->
</p>

<p>The symbols used to qualify the relationship depicted by this diagram indicate that
a <i>one-to-many</i> relationship exists between the publishers table and the titles
table. In other words, the titles table can contain any number of rows with the same
value in the <b>pub_id</b> column; or to put it another way, the titles table can
contain many titles from the same publisher. Because the <b>pub_id</b> column in the
publishers table is defined as the table's primary key, each row in the publishers
table will have a unique value in the <b>pub_id</b> column.</p>


<A NAME="285"><H2>Structured Query Language</H2></A>

<p>Structured Query Language (SQL) is a well-defined, standard language used for
querying, updating, and managing relational databases. Approved as a standard by the
International Standards Organization (ISO), SQL can retrieve, sort, and filter specific
data from a database. In addition, you can change and delete data in a database using
SQL statements.</p>

<p>It is important to have a fundamental understanding of SQL so that your applications
will communicate effectively with your database. By using SQL, an application can ask
the database to perform tasks rather than requiring application code and processing
cycles to perform them. More importantly, effective use of SQL can minimize the amount
of data that must be read from and written to a remote database server. Effective use
of SQL can also minimize the amount of data sent across the network. Minimizing disk
and network input/output (I/O) are important factors in improving application
performance.</p>

<p>You must be aware that, in different environments, databases have different
implementations of the same SQL functionality, both syntactically and semantically.
Each implementation of SQL has its own support for different data types, integrity
rules, and query optimization.</p>


<A NAME="286"><H3>SQL SELECT Statement</H3></A>

<p>The SQL <b>SELECT</b> statement returns information from the database as a set of
selected rows. The <b>SELECT</b> statement is divided into three major sections:</p>

<ul>

<p><li> <b>SELECT</b> The <b>SELECT</b> list allows you to specify which columns will be
returned from the query.</li></p>

<p><li> <b>FROM</b> The <b>FROM</b> clause allows you to specify which tables will be used
to get the columns specified in the <b>SELECT</b> list.</li></p>

<p><li> <b>WHERE</b> The optional <b>WHERE</b> clause allows you to specify filter
criteria to limit the selection of rows. You can filter queries based on multiple
columns.</li></p>

</ul>

<p>The minimum syntax for a <b>SELECT</b> statement is:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
SELECT <i>columns</i> FROM <i>tables</i>
</pre></td></tr></table>
</p>

<p>To perform this operation, the database engine searches the specified table or
tables and extracts the chosen columns. You can select all columns in a table by using
an asterisk (*). For example, the following SQL statement will return all columns and
rows from the authors table:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
SELECT *
FROM authors
</pre></td></tr></table>
</p>

<p>It might not be efficient to return all data from a table. By adding a <b>WHERE</b>
clause to the end of the statement, you can specify that only rows meeting a certain
condition are to be returned. The following example will return all columns from all
rows in the authors table having a last name equal to Ringer:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
SELECT *
FROM authors
WHERE au_lname = 'Ringer'
</pre></td></tr></table>
</p>

<p>Note the use of apostrophes (') surrounding the name Ringer in this example.
Apostrophes are used when the value in the <b>WHERE</b> clause is a string. In this
case, au_lname is defined by the database as a string value. When a numeric value is
specified in the <b>WHERE</b> clause, apostrophes are not used, as shown in the
following example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
SELECT *
FROM titles
WHERE royalty = 10
</pre></td></tr></table>
</p>


<p><b>IN Operator</b></p>

<p>By using the IN operator in a <b>WHERE</b> clause, you can return only those rows in
which a <b>WHERE</b> clause parameter is contained in a specified list. For example,
you can use the IN operator to return last names and state codes of all authors living
in Utah or Tennessee, as illustrated in the following example and in Figure 7.5.</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
SELECT au_lname, state
FROM authors
WHERE state IN ('UT', 'TN')
</pre></td></tr></table>
</p>

<p>
<img src="images/F07DA05.JPG" width=326 height=216 border="0">
</p><p>
<!-- caption --><b>Figure 7.5</b> <i>Using the IN operator with a <b>WHERE</b> clause to filter rows</i><!-- /caption -->
</p>


<p><b>BETWEEN Operator</b></p>

<p>This operator returns a selection of rows in which the <b>WHERE</b> parameter is
between two given criteria. Note that dates are specified in the <i>'yyyymmdd'</i>
string format.</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
SELECT title_id, title, pubdate
FROM titles
WHERE pubdate BETWEEN '19910601' AND '19910630'
</pre></td></tr></table>
</p>


<p><b>LIKE Operator</b></p>

<p>You can use the <b>LIKE</b> operator to find values in a column that match a pattern
you specify. You can specify the complete value, as in <b>LIKE 'Smith'</b>, or you
can use wildcard characters to find a range of values (for example, <b>LIKE
'Sm%'</b>). In the following example, also illustrated in Figure 7.6, all rows
where the author's last name starts with the letter S are returned.</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
SELECT au_lname
FROM authors
WHERE au_lname LIKE 'S%'
</pre></td></tr></table>
</p>

<p>
<A HREF="javascript:fullSize('F07DA06x.htm')"> <img src="images/F07DA06.JPG" width=404 height=236 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 7.6</b> <i>Syntax and results of an SQL statement using the <b>LIKE</b> operator</i><!-- /caption -->
</p>


<p><b>ORDER BY Clause</b></p>

<p>By default, rows are returned in the order they were entered in the database. The
optional <b>ORDER BY</b> clause will sort a query's resulting rows on a specified
column or columns, in ascending or descending order. The ASC option indicates ascending
order; the DESC option indicates descending order. The default sort order is ascending
(A to Z, 0 to 9). The following example selects all columns from the authors table and
sorts them in descending order, by last name:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
SELECT *
FROM authors
ORDER BY au_lname DESC
</pre></td></tr></table>
</p>


<A NAME="287"><H2>Lesson Summary</H2></A>

<p>A number of different interfaces are available to allow your Visual C++ application 
to access persistent data from an externally managed source. Over the last
few years, Microsoft's data access strategy has moved from a model based on the DAO
and the ODBC-based RDO, to a newer, single model known as UDA. UDA is based on OLE DB,
which is a set of COM interfaces that provide high-performance access to all types of
data&#8212;both relational databases and
nonrelational sources such as e-mail and file-system stores. Although you can
use the OLE DB interfaces directly, Microsoft recommends that you use ADO, which is a
powerful, easy-to-use, high-level interface to OLE DB data sources.</p>

<p>Visual C++ still supports DAO and RDO, so you can support and maintain
earlier applications that use these technologies. However, you should always
use UDA technology when creating a new application.</p>

<p>DAO uses the Microsoft Jet database engine to provide a set of data access objects
to access local desktop data sources. The DAO object model encapsulates common database
objects such as tables, queries, and recordsets. DAO exposes its objects through COM
interfaces, but Visual C++ programmers generally use the DAO database classes provided
by MFC.</p>

<p>RDO provides access to ODBC data sources through an object model similar to that
used by DAO. ODBC has been widely used as a low-level API to client/server data
sources. RDO provides many powerful features such as server-side cursors, disconnected
recordsets, and asynchronous processing.</p>

<p>Based on SQL as a standard for accessing data, ODBC is an important
technology&#8212;a large number of ODBC-based applications have been written. ODBC-based
applications interface with a database through ODBC drivers, which are supplied by
RDBMS vendors or third-party developers, and developed according to the ODBC open
standard. You can use the ODBC Data Source Administrator to install and configure ODBC
drivers on your computer and register a DSN with the operating system.</p>

<p>Visual C++ developers can use the ODBC API to connect to a database, send SQL
statements, retrieve results, get errors, disconnect, and so on. However, it is easier
to use one of the object models such as ADO or RDO, or to use the MFC ODBC database
support classes.</p>

<p>OLE DB is an open specification, designed to build on the success of ODBC by
providing an open standard for accessing all kinds of data. Conceptually, OLE DB has
three types of components: <i>data consumers</i>, <i>service components,</i> and <i>
data providers</i>.</p>

<ul>

<p><li> Data providers are applications that expose their data to other applications.
They also expose OLE DB interfaces that service components or data consumers can access
directly. The OLE DB provider for ODBC makes the many existing ODBC data sources
available to OLE DB data consumers.</li></p>

<p><li> Data consumers are applications or components that use the data exposed by data
providers. Any application that uses ADO is an OLE DB data consumer.</li></p>

<p><li> Service components are elements that process or transport data to extend the
functionality of data providers.</li></p>

</ul>

<p>ADO is designed as a high-performance, easy-to-use application-level interface to
OLE DB. ADO exposes a COM Automation interface, which makes it accessible by a wide
variety of development tools and scripting languages.</p>

<p>So that you can use ODBC and ADO efficiently, you should have a basic understanding
of relational database theory and SQL, the language that controls and interacts with an
RDBMS.</p>

<p>A relational database presents data as a collection of <i>tables</i> made up of <i>
rows</i> and <i>columns</i>. A row contains information about a single record in a
table. Each column contains a single piece of information about the record.</p>

<p>To uniquely identify rows within a table, you should define a <i>primary key</i> for
the table. A primary key is a column or a combination of columns whose value is
guaranteed to be unique for each row in the table. You can also define <i>foreign
keys</i> to specify relationships between tables. A foreign key &quot;points to&quot; a
primary key field in a related table.</p>

<p>Remember that SQL is a standard language used for querying, updating, and managing
relational databases. SQL can both retrieve and update data in a database. You should
have a fundamental understanding of SQL so your applications will communicate
effectively with your database. The proper use of SQL can ensure that the database
server, on behalf of your application, executes processing; and also that your data is
retrieved efficiently, without generating unnecessary network traffic and disk I/O.</p>

<p>You should be aware that, in different environments, databases have different
implementations of the same SQL functionality.</p>

<p>The SQL <b>SELECT</b> statement returns information from the database as a set of
records. The <b>SELECT</b> statement is divided into three major sections: <b>
SELECT</b>, <b>FROM</b>, and <b>WHERE</b>.</p>

<ul>

<p><li> <b>SELECT</b> allows you to specify which columns will be returned from the
query.</li></p>

<p><li> <b>FROM</b> allows you to specify which tables will be used to get the columns
specified in the <b>SELECT</b> section of the SQL statement.</li></p>

<p><li> <b>WHERE</b> allows you to specify filter criteria to limit the selection of
rows. You can filter queries based on multiple columns. The <b>WHERE</b> clause can be
further qualified with <b>IN</b>, <b>BETWEEN</b>, or <b>LIKE</b> operators.</li></p>

</ul>

<p>You can also specify an <b>ORDER BY</b> clause to sort a query's resulting rows
on a specified column or columns, in ascending or descending order.</p>


</BODY>
</HTML>







