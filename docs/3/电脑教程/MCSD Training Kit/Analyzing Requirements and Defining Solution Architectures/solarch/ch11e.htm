<HTML>
<HEAD>
<TITLE>Auditing</title>
<link rel="STYLESHEET" type="text/css" href="library.css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch11d.htm", "ch11f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="585"><H1>Auditing</H1></A>

<p>Auditing is an important step in effective security management.
Unfortunately, many applications do not incorporate simple auditing
techniques that can provide a tracking mechanism to identify security
breaches. In addition to security auditing, simple auditing can operate
as application monitoring to help determine what an application is
doing and who did what with the application.</p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>
Those new to incorporating auditing into applications
should be forewarned: Auditing can be expensive because it can utilize
extensive processing and storage resources. Also, auditing is an
intrusive process that, when overzealously implemented, can cripple an
application's performance. The application development team must
determine an appropriate level of auditing to reach a medium between
governing the working application and allowing the application freedom
to simply operate unencumbered.
</blockquote></div>
</p>

<p>A common way to address this concern is to emulate the designers of
Windows NT. Within Windows NT, seemingly everything that can occur on a
system can be audited into a Windows Event Log. However, as shipped
Windows NT does not activate most auditing features by default. These
features can be activated when system administrators think it is
necessary. Minimal information is always recorded in the Event Log,
such as System or Application Errors, or the start-up of certain
application services.</p>

<p>One way to categorize auditing events that can be incorporated into
applications is to group them by the following headings:</p>

<ul>

<p><li> <b>Information</b>  Informational messages enable applications to
pass along state knowledge, such as noting that a computers data
storage has reached 750 MB. Messages can also communicate the
application is functioning correctly.</li></p>

<p><li> <b>Success</b>  Incorporating success messages (for example,
notifying users that an application service has successfully begun at a
particular date or time) can provide reassurances to administrators as
well as allow automated monitoring systems to check for successful
entries.</li></p>

<p><li> <b>Warning</b>  Warning messages typically signify problems that
may arise. Warning messages could alert users to unexpected events in
an application. When users receive warning messages, they should
perform a follow-up to determine if additional action is required to
solve the problem being addressed.</li></p>

<p><li> <b>Failure</b>  If an action cannot be properly completed, the
application should make a permanent record in the form of a failure
message. The development team should not rely upon users to report that
they have been receiving error messages, as such the application should
track important client or server errors. From a security point of view,
it is important to capture failure messages that result when an
application reports that access to a particular system was denied.
These access failures are the first line of defense against unwanted
software violations. For example, 42,000 failed data requests in a
one-minute period can signify a potential security breach, as well as a
significant problem with the application.</li></p>

</ul>


<A NAME="586"><H2>Log Files</H2></A>

<p>Writing text files that act as log files is a simple way to provide
auditing. Text files can be written from all common programming
languages, as well as through ADO and ODBC. It is recommended
programming practice to allow system administrators to determine where
log files are physically located. The application can request a log
file directory during installation and store the location within the
application's registry setting.</p>


<A NAME="587"><H2>Event Logs</H2></A>

<p>The logs created by the Windows NT event logging service are
accessible from the Windows event viewer. They are separated into three
different logs: a security log, a system log, and an application log.
Support for these logs can be incorporated into applications to ensure
that information is written into the appropriate event log. The event
logs are physically located in the Windows NT
Systemroot\System32\Config directory in the appevent.evt, secevent.evt,
and sysevent.evt files. Server administrators should secure access to
these files to prevent tampering, as well as prevent software criminals
from trying to cover the tracks of their illegal system access.</p>

<p>Windows NT provides several interfaces for controlling auditing. As
mentioned, most auditing is disabled by default, but can occur for:</p>

<ul>

<p><li> <b>Windows NT system auditing</b>  System auditing includes user
logon and logoff, object access, file and object access, use of user
rights, user and group management, security policy changes, system
restart and shutdown, and Process Tracking.</li></p>

<p><li> <b>File and directory auditing</b>  This type of auditing can be
set to determine the success and/or failure of read, write, execute,
delete, change-permission, and take-ownership actions.</li></p>

<p><li> <b>Registry auditing</b>  Auditing within the registry includes
success and failure actions that query values, set values, create
subkeys, enumerate subkeys, notify, create link, delete, write DAC, and
read control.</li></p>

</ul>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>
An excessive amount of auditing can adversely impact
system performance. For additional information on how to set auditing
values, refer to <i>Microsoft Windows NT 4.0 Security, Audit, and
Control</i> (Microsoft Press, 1998).
</blockquote></div>
</p>

<p>For ongoing monitoring of applications, the project team can build
Windows NT performance counter capabilities into the application. As
discussed previously, the Windows NT Performance Monitor provides
excellent real-time information regarding how an application is
functioning. Additional counter information specific to the application
can be reported to the performance monitoring system by including the
appropriate performance interfaces. For additional information on
incorporating performance monitor interfaces, refer to the <i>Microsoft
Windowsç‡¦T Workstation 4.0 Resource Kit</i> (Microsoft Press,
1996).</p>


<A NAME="588"><H2>Distributed Environments</H2></A>

<p>The way Windows NT 4.0 authenticates users directly affects how the
use of distributed applications should be audited. For example, with
Windows NT authentication, a token gets passed only from point A to
point B. When B wants to access something, B's security token is
used to access C. The effect is not transitive, meaning if C trusts A,
and A trusts B, C does NOT inherently trust B. (Kerberos security, on
the other hand, is transitive.) To successfully build auditing into
Windows NT 4.0 distributed N-tier environments, developers need to
understand this underlying method of authentication.</p>

<p>Obviously, developers need to audit for errors. However, the
following items can also be audited for:</p>

<ul>

<p><li> Success events.</li></p>

<p><li> Failure events.</li></p>

<p><li> Object access monitoring.</li></p>

<p><li> Database access monitoring.</li></p>

<p><li> Runtime diagnostics.</li></p>

<p><li> Development diagnostics.</li></p>

<p><li> Usage monitoring.</li></p>

</ul>

<p>When developers create an audit trail for object security, they
generally want to know who was trying to use the application. To
determine who is using an application, the programmatic security
services provided by MTS must be implemented. For example, developers
could create audit objects to implement an audit trail originating from
the presentation tier and ending at the data tier. MTS programmatic
services also enable developers to perform more sophisticated security
checks in components, rather than simply checking role membership.</p>

<p>Most security needs&#8212;even programmatic security&#8212;can be met
by using role-based security. For example, when designing a banking
application, developers may have a business rule enabling a bank teller
to authorize withdrawals of up to $500 from a particular user's
account, but larger withdrawals must be authorized by a manager. In
this case, the <b>Withdraw</b>  method implementation needs to take
different actions depending on the caller's role. The object
context methods <b>IsSecurityEnabled</b>  and <b>IsCallerInRole</b>  can
be used to handle this procedure.</p>

<p>In rare instances in which role-based security is insufficient, MTS
provides the <b>ISecurityProperty</b>  interface, which can be used to
access Windows NT user identities. The object context is queried to
obtain an <b>ISecurityProperty</b>  interface pointer, and then one of
the following four methods is called to obtain a security identifier
(SID):</p>

<ul>

<p><li> <b>GetDirectCallerSID</b>  returns the SID of the external process
that called the currently executing method.</li></p>

<p><li> <b>GetDirectCreatorSID</b>  returns the SID of the external
process that created the currently executing object.</li></p>

<p><li> <b>GetOriginalCallerSID</b>  returns the SID of the base client
process that initiated the sequence of calls from which the call to the
current object originated.</li></p>

<p><li> <b>GetOriginalCreatorSID</b>  returns the SID of the base client
process that initiated the current activity.</li></p>

</ul>

<p>A SID is a Windows structure containing information about a
particular user and any groups to which the user belongs. The Windows
API must be used to parse a SID. The SID's information can be used
to restrict access to components or to obtain information for auditing
and logging. When a SID obtained from the <b>ISecurityProperty</b> 
interface is no longer needed, <b>ReleaseSID</b>  should be called to
release the SID.</p>

<p>SIDs are not easily accessible from Visual Basic, so MTS also
provides a <b>SecurityProperty</b>  object. The <b>SecurityProperty</b> 
object is defined in the MTS type library. A reference to the object
can be obtained using the Security property of the object context, as
shown in the following code example:</p>

<p>
<table cellpadding=5 width ="95%">
<tr><td>
<pre>
Dim secProperty as SecurityProperty

Set secProperty = GetObjectContext.Security
</pre>
</td></tr></table>
</p>

<p>The <b>SecurityProperty</b>  object provides access to usernames
only, not to the entire SID. Fortunately, the username is all
that's generally need for auditing or logging.</p>

<p>Just as they can audit object security programmatically, developers
can audit database security by building in parameters, such as a
username, that is passed to stored procedures in the database. Later,
the database can record the username in the appropriate table using an
additional stored procedure or trigger.</p>


</BODY>
</HTML>


