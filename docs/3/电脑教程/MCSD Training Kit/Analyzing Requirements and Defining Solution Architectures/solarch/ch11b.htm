<HTML>
<HEAD>
<TITLE>Authentication Security</title>
<link rel="STYLESHEET" type="text/css" href="library.css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch11a.htm", "ch11c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="546"><H1>Authentication Security</H1></A>

<p>The best security system is only as safe as its authentication
scheme. Although many secure applications exist, users can jeopardize
efforts to secure applications by using generic passwords such as 1234,
not using any passwords at all, or writing passwords and leaving them
in places where they can easily be discovered. Remedies such as
password dictionary check or minimum password lengths are available to
safeguard potentially unsecured applications; however, not all
application security problems can be solved programmatically. Assuming
that steps will be taken to exclude reckless password behavior on the
part of users, in this section we take a look at the security process
of <i>authentication,</i> which involves identifying and validating
users, and potentially revalidating 
users as an ongoing process.</p>


<A NAME="547"><H2>Windows NT Authentication</H2></A>

<p>Windows NT users are authenticated by the MSV1_0 Authentication
Package that corresponds to MSV1_0.DLL in Windows NT's
&lt;systemroot&gt;\SYSTEM32 directory. Conceptually, MSV1_0 is split
into two halves. The top half is responsible for receiving the logon
request and determining whether the request is to the local or remote
Windows NT computer. If the request is local, MSV1_0 passes the logon
information to the bottom half of MSV1_0. The bottom half of MSV1_0 in
turn authenticates the user by referencing the local security database.
However, if the logon request is to a remote Windows NT computer, the
top half of MSV1_0 passes the logon information to the local
computer's Netlogon service. The Netlogon service in turn passes
the logon information to the remote Windows NT computer's bottom half of 
MSV1_0. When the Netlogon services of two computers communicate, 
challenge/response occurs. Challenge/response doesn't occur with 
local logons. The request is answered and returned to the top half of 
the local Windows NT computer's MSV1_0 through the respective 
Netlogon services.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> We focus mainly on network authentication as it
relates to Windows NT LAN Manager (NTLM) security over the network via
challenge/response. However, MSV1_0 also supports interactive logons,
service logons, and network logons. All forms of logon through the
MSV1_0 Authentication Package pass the name of the domain containing
the user account, the name of the user account, and some function of
the user password. These various types of logon differ in the way the
password is represented. For interactive logons and service logons, the
client logging on is physically on the computer running the top half of
the MSV1_0 Authentication Package. In this case, the clear
(unencrypted) text password is sent into the top half of the MSV1_0
Authentication Package. The top half of the MSV Authentication Package
converts the clear text password to both a LAN Manager password and a
Windows NT password before sending it on to either the Netlogon service
or the lower half. The lower half queries the passwords from the
Security Account Manager (SAM) and compares the passwords to ensure
they are identical.
</blockquote></div>
</p>

<p>The following steps are an example of how a user might log on
locally or remotely to a Windows NT system:</p>

<ol>

<p><li> Press CTRL+ALT+DEL to display the Windows NT Security logon
dialog box. Pressing this key combination before logging on protects
against Trojan Horse-type programs that impersonate the operating
system and manipulate users into disclosing their username and
password.</li></p>

<p><li>Provide a username and password to enable the logon process to
call the Local Security Authority (LSA).</li></p>

<p><li>The Local Security Authority runs the MSV1_0 Authentication
Package.</li></p>

<p><li>The authentication package checks the user accounts database to
see whether the account is local. If it is, the username and password
are verified against those held in the user accounts database. If it is
not, the requested logon is forwarded to the Windows NT Netlogon
service. The Netlogon service on the local computer communicates with
the Netlogon service of the remote Windows NT system (in this example,
a domain controller). Here, the upper half of MSV1_0 on the local
computer communicates with the lower half of MSV1_0 on the remote
computer, initiating a challenge/response.</li></p>

<p><li>When the account is validated either locally or remotely, the SAM
(which owns the user accounts database) returns the user's security
ID (SID) and the security IDs of any global groups to which the user
belongs.</li></p>

<p><li>The authentication package creates a logon session and then
passes the logon session and the security IDs associated with the user
to the Local Security Authority.</li></p>

<p><li>If the logon is rejected, the logon session is deleted, and an
error is returned to the logon process.</li></p>

<p><li>If the logon is accepted, an access token is created, containing
the user's security ID and the security IDs of the Everyone group
and any other groups to which the user belongs. It also contains user
rights assigned to the collective security IDs. This access token is
returned to the logon process with a Success status.</li></p>

<p><li>The logon session calls the Win32 subsystem to create a process
and attach the access token to the process, thus creating a <i>
subject</i> for the user account.</li></p>

<p><li>For an interactive Windows NT session, the Win32 subsystem
starts a shell process (that is, starts the desktop) for the user.</li></p>

<p>After the validation process, the user's shell process
is given an access token. For Windows NT 4.0, the token is associated
with Explorer.exe. The information in this access token is a reflection
of anything the user does or by any process that runs on the user's
behalf.</p>

</ol>


<A NAME="548"><H2>Kerberos Authentication</H2></A>

<p>Kerberos authentication was developed within the think tanks of MIT.
It is a ticket-, session-, and trust-based authentication scheme. The
Kerberos Authentication included in Windows 2000 is based on Kerberos
v5. When compared with the Windows NT domain strategy, the Kerberos
authentication protocol provides the following benefits:</p>

<ul>

<p><li> <b>Faster server authentication performance during initial
connection establishment</b>  The application server doesn't have to
connect to the domain controller to authenticate the client, so
applications servers can scale better when handling a large number of
client requests.</li></p>

<p><li> <b>Delegation of authentication for multi-tier client/server
applications and architectures</b>  When a client connects to a server,
the server impersonates the client on that system. But if the server
needs to make a network connection to another network server to
complete the client transaction, the Kerberos protocol allows
delegation of authentication for the first server to connect on behalf
of the client to another server. The delegation also allows the second
server to impersonate the client.</li></p>

</ul>

<p><div class="note"><blockquote><b>NOTE</b><hr> Applications that use process access permissions
can take advantage of additional security providers on Microsoft
Windows 2000 and can use <i>delegate-level impersonation</i> and <i>
cloaking</i> to affect the security credentials used during method
calls. Delegate-level impersonation is established by the client
process and allows a server to impersonate the client and to pass the
client's credentials to remote computers. Previously, servers could
impersonate the client only to access local resources. Cloaking is used
to hide an intermediate server's identity from a destination
server. For example, if Client A calls Server B, which then calls
Server C on Client A's behalf, and Server B has cloaking enabled,
Client A's identity will be used for calls to Server
C.</blockquote></div>
</p>

<ul>

<p><li> <b>Transitive trust relationships for inter-domain
authentication</b>  Users can authenticate to domains anywhere in the
domain tree because each domain's authentication services trust the
tickets issued by other authentication services in the tree. Transitive
trust simplifies domain management for large networks with multiple
domains.</li></p>

<p><li> <b>Authentication between heterogeneous systems (even
Internet-based systems)</b>  Users can validate once and access many different
systems on different operating system platforms. For example, Windows
2000 security can be utilized between Windows 2000 and UNIX or
mainframe environments, provided the correct Microsoft COM libraries
are being utilized on the UNIX or mainframe systems. Users don't
have to be running Windows 2000 to be authenticated by a Windows
2000/Kerberos domain.</li></p>

</ul>

<p><div class="note"><blockquote><b>NOTE</b><hr> The transition from the NTLM authentication used
in Windows NT 4.0 to Kerberos domain authentication can be very smooth.
Windows 2000 services support client or server connection using either
security protocol. The transition from enterprise-based services using
Kerberos authentication to Internet-based services using public-key
authentication (discussed later in this chapter) is mostly transparent
to the user.</blockquote></div>
</p>


<A NAME="549"><H2>Web-Based Authentication</H2></A>

<p>Almost every Web browser on the market supports a basic form of
authentication that involves sending a username and password in clear
text over the Internet or an intranet. Unfortunately, this basic
authentication allows this information to be stolen by others. Because
organizations need to provide secure access to information on their
networks and servers, user authentication is an important aspect of a
Web server. In addition to the security provided by Windows NT,
Microsoft Internet Information Server (IIS) 4.0 includes additional
security features that Windows NT uses to correctly identify users,
determine their level of access, and create a secure Internet
connection.</p>

<p>In this section, we first describe the IIS 4.0 authentication
technology. Then we discuss Microsoft's Secure Channel technology,
which is used to protect networked data from prying eyes when
communicating in Internet or intranet environments after users have
been authenticated.</p>


<A NAME="550"><H3>Windows NT Challenge/Response Support</H3></A>

<p>IIS 4.0 provides support for the Windows NT challenge/response
authentication, which uses a cryptographic technique to authenticate
the password. The actual password is never sent across the network, so
it cannot be captured by an unauthenticated source. Challenge/response
is supported by Microsoft Internet Explorer 2.0 and later versions.</p>

<p>When Windows NT challenge/response authentication is enabled, the
user's Internet Explorer browser proves its knowledge of the
password through a cryptographic exchange with the Web server. If the
authentication exchange succeeds in identifying the user, the user is
not prompted for account information. However, if the authentication
exchange initially fails to identify the user, Internet Explorer
prompts the user for a Windows NT account username and password, which
it processes using the same Windows NT challenge/response method.
Internet Explorer continues to prompt the user until the user enters a
valid username and password or closes the prompt dialog box.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> Windows NT challenge/response authentication
takes precedence over basic authentication. If the user's Web
browser supports both authentication methods, it chooses Windows NT
challenge/response authentication.</blockquote></div>
</p>


<A NAME="551"><H3>Cookies</H3></A>

<p>Web applications can use simple cookie mechanisms to track and
identify users. Cookies are small files sent from the server to the
user's computer, where they are stored locally. These
identification cookies typically contain a globally unique identifier
(GUID) that can be requested and queried by a Web server. Although
cookies provide a simple means of identifying users, they should not be
used when the information being accessed is considered confidential or
private. A cookie can be intercepted in transit, or even copied from a
user's computer, and anyone can then use it to represent himself or
herself as the cookie's user. Although the concept of stealing
cookies is similar to that of stealing logon usernames and passwords,
cookies are technically much easier to &quot;borrow.&quot;</p>


<A NAME="552"><H3>Digital Certificates</H3></A>

<p>Digital certificates give users a secure method of logging onto a
Web site without having to remember logon usernames and passwords. IIS
supports the use of X.509 certificates for access control. Certificates
verify identity in much the same way as driver's licenses or
corporate identification cards do. They are issued by a trusted
certificate authority, either a department within an organization or a
public company such as VeriSign or Entrust. How rigorously IIS checks
identities or credentials when issuing a certificate depends upon the
level of security&#8212;or trust&#8212;required for the information or
application being accessed.</p>

<p>Certificate-based client authentication requires a protocol that can
handle certificates at both the client end and the server end, as well
as the appropriate requests and replies.</p>

<p><b>Server Certificates</b></p>

<p>Unique digital identifications, called <i>server certificates</i>,
form the basis of a Web server's Secure Sockets Layer (SSL)
security features. Server certificates, obtained from a trusted,
third-party organization, provide a way for users to authenticate the
identity of a Web site. The server certificate contains detailed
identification information, such as the name of the organization
affiliated with the server content, the name of the organization that
issued the certificate, and a unique identification file called a <i>
public key</i>. This information helps to assure users about the
authenticity of Web server content and the integrity of the secured
HTTP connection. The public key, along with another privately held key,
form the SSL <i>key pair</i>. A Web server utilizes the key pair to
negotiate a secure TCP/IP connection with the user's Web browser.
(Although the key pair serves a vital role in establishing a secure
link, the key pair is not directly used for data encryption.)</p>

<p><b>Client Certificates</b></p>

<p>With SSL, a Web server can also authenticate users by checking the
contents of their <i>client certificates</i>. These encrypted files are
similar to conventional forms of identification such as driver's
licenses or passports. A typical client certificate contains detailed
identification information about a user and the organization that
issued the certificate. Each user enters a password when signing his or
her certificate, and this password is required every time the
certificate is activated for use. As with a driver's license, mere
possession of a certificate does not constitute proof of ownership.
Only the owner of the certificate should know the password because it
is the key to verifying access.</p>

<p><b>Certificate Mapping</b></p>

<p>This method maps the client certificate to the Windows NT server
user account and requires a copy of the certificate. The Web server has
a client certificate-mapping feature that authenticates users who log
on with client certificates, without requiring the use of basic or
Windows NT challenge/response authentication. A certificate mapping
relates the contents of the user's client certificate to a
corresponding Windows NT account, which is a file that defines the
rights and access policies of the user. After a mapping is created and
enabled for a particular user, each time that user logs on with his or
her client certificate, the Web server automatically connects, or maps,
that user to the appropriate Windows NT account.</p>

<p>This approach is ideal when the Web site issues its own certificates
using a certificate server, such as Microsoft Certificate Server, which
is included in the Windows NT 4.0 Option Pack.</p>

<p><b>Wildcard Mapping</b></p>

<p>When using wildcard mapping, the IIS server doesn't need to
possess the client certificate, but instead authenticates the user
based on information stored in the certificate, such as
&quot;SubjectName.&quot; IIS 4.0 also includes a Microsoft ActiveX
component that automates the wildcard mapping using an Active Server
Page (ASP). For example, a business could set up an ASP page that asks
users whether they want to map their certificate to their Windows NT
Server user account. If a user chooses to do so, the information in the
certificate is mapped to the appropriate Windows NT Server user
account.</p>

<p>IIS 4.0 can authenticate users who log on with a client certificate
by creating mappings that relate the information contained in the
certificate to a Windows NT user account. Using the Web server's
certificate mapping feature, IIS 4.0 can either map a specific
user's client certificate to an account (a one-to-one mapping), or
map multiple certificates to an account. To map multiple certificates,
wildcard-matching rules must be defined that create a mapping by
verifying only whether a certificate contains certain items of
information. For example, to map all users who log on with client
certificates issued by a particular organization, a wildcard-matching
rule could be defined that automatically maps any certificate issued by
that organization to a single user account, rather than creating a
separate mapping for each client certificate.</p>

<p><b>Programmatic Use of Certificates</b></p>

<p>Client authentication in IIS 4.0 goes beyond pure authentication and
access control. Information in the certificate is exposed to both ASP
and Internet Information Server Application Programming Interface
(ISAPI) applications. As a result, developers try to create custom ASP
and ISAPI applications that can serve personalized content, control
access, or query databases based on the information fields in the
client certificate. Developers can use client certificate
authentication, along with SSL encryption, to implement a very
tamper-resistant method for verifying user identity.</p>

<p><b>Microsoft Certificate Server</b></p>

<p>Internet Information Server 4.0 Option Pack contains certificate
management features available through Microsoft Certificate Server, and
standard cryptographic API functions available through Microsoft's
CryptoAPI, which we discuss later in this chapter. Certificate Server
has the following features:</p>

<ul>

<p><li> Accepts standard PKCS #10 certificate requests.</li></p>

<p><li> Issues X-509 version 1 and version 3 certificates in PKCS#7
format.</li></p>

<p><li> Issues SSL client and server certificates.</li></p>

<p><li> Issues Secure Multipurpose Internet Mail Extensions (S/MIME)
certificates.</li></p>

<p><li> Issues Secure Electronic Transactions (SET)-compliant
certificates.</li></p>

<p><li> Supports open interfaces that enable writing of modules to
support custom formats.</li></p>

</ul>


<A NAME="553"><H2>SQL Server Authentication</H2></A>

<p>In this section, we discuss the various types of security available
with Microsoft SQL Server, including standard security, integrated
security, and mixed security.</p>


<A NAME="554"><H3>Standard Security</H3></A>

<p>Standard security uses SQL Server's own logon validation process
for all connections. Connections validated by SQL Server are referred
to as <i>non-trusted connections</i>. Standard security is useful in
network environments with a variety of clients, some of which may not
support <i>trusted connections,</i> which we discuss below. Also,
standard security provides backward compatibility for older versions of
SQL Server.</p>


<A NAME="555"><H3>Integrated Security</H3></A>

<p>Integrated security allows SQL Server to use Windows NT
authentication mechanisms to validate SQL Server logons for all
connections. Connections validated by Windows NT Server and accepted by
SQL Server are referred to as <i>trusted connections</i>. Only trusted
connections are allowed. Integrated security should be used in network
environments where all clients support trusted connections. The clients
of SQL Server in a three-tier application are MTS components.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> With Windows NT 4.0, MTS components must be
authenticated by a domain controller. Authentication of a component by
a domain controller over the network adds extra traffic and therefore
extra expense. With Windows 2000, Kerberos helps hold down traffic by
carrying information that allows direct component authentication
without taking a trip to the domain controller.</blockquote></div>
</p>

<p>When the SQL Server logon security mode is set to integrated, an MTS
component's login is validated as follows:</p>

<ol>

<p><li> To access SQL Server, a component first obtains a valid Windows
NT user account. MTS components use the Windows NT user account
specified in the component's MTS package's <b>Identity</b> 
property. When the user account is in a domain, the username and
password are validated by the domain controller's security accounts
database when the MTS package executable launches via LAN Manager
security. However, if the user account is located in a workgroup, the
username and password are validated by the local security accounts
database.</li></p>

<p><li> The component connects to SQL Server, and SQL Server looks in the
syslogins table for a mapping to a SQL Server logon ID. This mapping is
created as part of the configuration process based on whether a logon
exists, a logon does not exist, or neither a logon nor a default logon
exists. If the logon exists, the component is logged onto SQL Server
with the privileges associated with that logon ID. If the logon does
not exist, the component is logged onto SQL Server using the default
SQL Server logon ID, which is usually a guest account. However, if the
component's account has administrator privileges on Windows NT, the
user will also have administrator privileges within SQL. Finally, if
the logon does not exist and there is no default logon ID, the
component is denied access to SQL Server.</li></p>

<p><li> Once the logon process is complete, access to individual SQL
Server tables is managed through permissions granted within an SQL
Server database.</li></p>

</ol>


<A NAME="556"><H3>Mixed Security</H3></A>

<p>When mixed security is used, SQL Server validates logon requests
using either integrated or standard security methods. Both trusted
connections (as used by integrated security) and non-trusted
connections (as used by standard security) are supported. Mixed
security is useful in network environments that have a mixed client
base. For those clients that support trusted connections, Windows NT
validates logons. For clients that support only non-trusted
connections, SQL Server validates logons.</p>

<p>When a server's login security mode is set to mixed, a
component's logon is validated as follows:</p>

<ul>

<p><li> When a component attempts to log onto the server over a trusted
connection, SQL Server examines the logon name. If this logon name
matches the component's network username, or if the logon name is
blank or contains spaces, SQL Server uses the Windows NT integrated
logon rules (as for integrated security).</li></p>

<p><li> If the requested logon name is any other value, the component
must supply the correct SQL Server password, and SQL Server uses its
own logon validation process (as for standard security). If the logon
attempt is not over a trusted connection, the component must supply the
correct logon ID and password to establish the connection, and SQL
Server uses its own logon validation process (standard security).</li></p>

</ul>

<p><div class="note"><blockquote><b>NOTE</b><hr> Integrated or mixed security is recommended for
enterprise solutions using Windows NT Server, MTS, and SQL Server.
Integrated security makes management of logons easier because accounts
can be administrated from one source in Windows NT. Also, developers
can avoid coding logon IDs and passwords into their components or
placing them in ODBC DSNs. Any logon changes under standard security
forces components to be recompiled or ODBC DSNs to be tracked down and
updated.</blockquote></div>
</p>


<A NAME="557"><H3>Using SQL Authentication with Objects</H3></A>

<p>As we've said, SQL Server requires a logon ID and password.
We'll now demonstrate how a component can implement such a security
measure.</p>

<p>A component supplies its logon either through the <b>
ConnectionString</b>  property of the ADO Connection object, or as a
Connection String parameter to the Open method of the <b>Connection</b> 
or <b>Recordset</b>  objects. If a component supplies a logon ID and
password, the component connects using standard security. If the
component does not supply a logon ID and password, the component
connects using integrated security, and within MTS, the component's
package identity is used as the logon.</p>

<p>If the connection is through an OLE DB provider, the provider must
be notified that integrated security is to be used. The logon ID or
password should not be provided, but instead the <b>
Trusted_Connection</b>  attribute should be set as shown in the
following code:</p>

<p>
<table cellpadding=5 width ="95%">
<tr><td>
<pre>
Dim conn as ADODB.Connection 
Set conn = New ADODB.Connection 
conn.Provider = &quot;SQLOLEDB&quot; 
conn.ConnectionSTring= &quot;Data Source=MYSERVER;' &amp; _ 
 &quot;Initial Catalog=Pubs;Trusted_Connection=Yes&quot; 
conn.Open
</pre>
</td></tr></table>
</p>


</BODY>
</HTML>


