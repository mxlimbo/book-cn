<HTML>
<HEAD>
<TITLE>Designing MTS Packages</title>
<link rel="STYLESHEET" type="text/css" href="library.css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch08f.htm", "ch08h.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="412"><H1>Designing MTS Packages</H1></A>

<p>The starting point for package design is the physical design, as
discussed in <A HREF="ch06a.htm">Chapter 6</A>. During the application design phase, the
primary goal was to document any constraints imposed by application
requirements, such as requiring authorization checks on calls into
particular components or requiring certain components to run on a
particular computer. It was not necessary, or even desirable, to have
the entire physical design completed before implementing components. As
applications are implemented, their physical design should be refined,
with components placed into packages and any package deployment
constraints documented. These four issues should be kept in mind when
deciding how to package components:</p>

<ul>
<p><li> Activation</li></p>

<p><li> Shared resources</li></p>

<p><li> Fault isolation</li></p>

<p><li> Security isolation</li></p>
</ul>



<p>We look at each of these issues in detail in the following
sections.</p>

<A NAME="413"><H2>Activation</H2></A>

<p>An application servers' components can be activated in one of
two ways: in the client's process or in a package-specific
MTS-managed process. We've already seen that MTS library packages
are used to run the components in the client's process. Note that
the term &quot;client&quot; in this sense is a different component
or 
application running on the same computer on which the library package
is installed, rather than a user application. Library packages do not
support declarative security, nor do they offer the benefits of process
isolation. Thus, library packages are typically used for utility
components that might be used by multiple applications. Library
packages are also useful when separate process 
overhead is undesirable and authorization checks are not required.</p>

<p>MTS server packages are used to run components in a separate
MTS-managed process. MTS server packages also support declarative
security, resource pooling, and so on. Most MTS packages are server
packages. Application components are grouped into packages based on
common resource usage, security requirements, and fault isolation
needs.</p>

<p>Deciding how many packages are needed in an application is a
balancing act. With many packages, system administrators have a lot of
flexibility in deploying their applications. However, each MTS server
package requires a certain amount of overhead to manage resource pools,
shared properties, and so on. In addition, inter-process COM calls are
much more expensive than in-process COM calls within a single
apartment. And too many packages make system management tough. At this
point in their application development, developers should create
packages they think they need based on resource usage, security, and
fault isolation. During performance testing, developers can adjust how
components are allocated to packages if they find that process overhead
or inter-process calls are a bottleneck.</p>

<A NAME="414"><H2>Shared Resources</H2></A>

<p>Components that use the same resources, such as databases, should be
grouped together in a single MTS server package. Remember that MTS
manages resource pools on a per-process basis. Each MTS server package
gets its 
own thread pool, database connection pool, Shared Property Manager
(SPM), and so on. If two components using the same database are located
in separate MTS server packages, they can not pool database
connections. If the components are in the same MTS server package, they
can pool connections. This capability can greatly improve developed
application performance and scalability. Similarly, components in
separate MTS server packages can not share properties by using the SPM.
Components that need to share properties must be in the same package to
ensure correct application operation.</p>

<p>The location of resources should also be considered when designing
packages. In general, components should be deployed as close as
possible to the resources they use, particularly data stores, to help
reduce network traffic within applications. For example, if two data
stores used by applications might be located on different computers,
consider putting the data objects that use each data store in separate
packages. This arrangement gives system administrators the flexibility
to install each package near the data store it uses. Any deployment
recommendations or requirements, such as locating a package and a data
store on the same computer, should be noted in the physical design
documentation distributed with each application.</p>

<A NAME="415"><H2>Fault Isolation</H2></A>

<p>Separating components into different packages will also ensure that
a fault in one component does not cause other components to fail. MTS
will terminate a process whenever it detects internal corruption.
Exceptions within a component can also force an MTS server process to
terminate. Any transient state maintained in running objects or the SPM
will be lost. If an application has components that maintain transient
state, consider placing those components in a separate server package.
Components should also be isolated during quality-assurance testing.</p>

<A NAME="416"><H2>Security Isolation</H2></A>

<p>MTS server packages are units of trust for MTS. Calls into a package
can be secured. Calls within the package are trusted. Thus, application
security requirements have a big impact on package design. If calls
into a component must be authorized, clients and components must be
allocated into different packages. Only components that can safely call
each other without requiring an authorization check should be allocated
into one package.</p>

<p>MTS security roles are defined on a per-package basis. If multiple
components use the same roles, consider placing them in the same
package. Generally, this method of grouping is safe, since components
can be called by the same set of users, and should be trusted to call
each other. Placing components that use the same roles in one package
simplifies administration, since the system administrator does not need
to remember to populate the role in multiple packages.</p>

<p>In addition, an MTS server package runs as a particular identity,
and all components in the package run as the package identity.
Components that need to run as different user identities should be in
separate packages. Components might need to run as different identities
because they should have different access rights to some resource or in
order to maintain an audit trail. Although the exact identity each
server package will run as cannot generally be defined during 
development, document any recommendations along with the permissions
required by package components. For example, if a data object in a
given package requires read/write access to a particular data store,
document that fact.</p>

<A NAME="417"><H2>Implementing COM in an MTS Environment</H2></A>

<p>Let's examine the general concepts behind components that will
run within the MTS environment. The four major tasks of implementing
such components are:</p>

<ul>
<p><li> Write single-user, in-process COM components.</li></p>

<p><li> Use explicit interfaces to define objects' public
interfaces.</li></p>

<p><li> Use <b>ObjectContext</b>  methods to tell MTS when object state
can be reclaimed.</li></p>

<p><li> Use transactions to manage errors.</li></p>
</ul>



<p>All components that run in the MTS environment must be implemented
as in-process components. Each component must provide a class factory
for each COM class in the component, as well as a type library that
describes all COM classes and their interfaces.</p>

<p>In addition to these requirements, MTS components should be written
as single-user components. The MTS Executive, mtxex.dll, provides
thread management services, so developers don't need to cover
multithreading issues in their components. In fact, threads should not
be created on their own within their components. Components should
simply be written as if one caller at a time will use them.</p>

<p>Recall that every in-process COM component has a <b>
ThreadingModel</b>  registry value associated with it; this registry
value describes how the component's objects will be assigned to
threads during execution. If a <b>ThreadingModel</b>  value is not
specified, the component uses the single-threaded apartment (STA)
model. Thus, all objects will execute on the containing process main
thread. COM synchronizes access to all objects on the main thread, so
this approach is not very scalable. In addition, single-threaded
stateful objects are prone to deadlock. However, if non-reentrant
libraries are used within components, the STA model may need to be
used.</p>

<p>A more suitable choice for MTS components is to use the
apartment-threading model, by setting the registry key <b>
ThreadModel</b>=Apartment. Remember that in the apartment-threading
model, each object is assigned to a single thread for its entire
lifetime, but multiple instances of the object can be created at once
in any number of STAs. The component's global data and DLL entry
points must be thread safe and protected from concurrent updates. This
approach improves scalability without overly complicating their
component implementation. It's 
not necessary to implement fully thread-safe components that support
the free-threaded model; if these components are implemented, they must
not create 
any threads on their own. Fortunately, every COM programming tool
currently available can generate, at the push of a button, skeleton
code that meets these requirements.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> What about Java and COM? Java is a good language
for implementing COM components. With the COM support provided by the
Microsoft Virtual Machine for Java and Microsoft Visual J++, developers
can easily create components from Java classes. MTS even provides a
package to help developers access its features from Java: com.ms.mtx.
The details of how developers code their components will vary. For
additional information about writing components in Java, Paul
Stafford's &quot;Writing Microsoft Transaction Server Components in
Java,&quot; available in the Microsoft Developer Network (MSDN)
Library, is highly recommended.</blockquote></div>
</p>

<p>The default behavior provided by COM programming tools is adequate
for most components needed in a three-service layered application. If
these defaults are used, developers can spend more time focusing on
application-specific logic, and save hand-coding the basic COM
component infrastructure for times when performance requirements cannot
be met with the default code provided by their tools. Since COM is a
binary standard, developers can change the implementation of any
component without affecting its clients, as long as the public
interface is not changed&#8212;even to the extent of changing
implementation languages. In this book, we use the standard COM
implementations provided by Microsoft Visual Studio tools. For
information about hand-tuning components, or to learn more about how
COM works, many books detailing the writing of COM components,
especially for C++ developers, are available such as David
Kryuglinski's <i>Programming Visual C++</i>, Fifth Edition and Guy
and Henry Eddon's <i>Inside Distributed COM</i> (Microsoft Press,
1998).</p>

<p>Once basic in-process component framework is in place, COM class
implementations can be added to the framework. Each COM class exposes
its behavior through one or more COM interfaces. Some programming
tools, such as Visual Basic, allow methods and properties to be exposed
directly on the class and internally convert these methods and
properties to a COM interface. Try to avoid this practice; always
define COM interfaces explicitly by referring to the IDL. As mentioned,
COM interfaces represent a contract between the caller and the object
being called, and once published these interfaces must not be changed.
When interface definition is mixed with implementation, changes could
be made to interfaces without a full understanding of the possible
consequences. Defining interfaces separately also helps when multiple
developers are working on an application. Test objects that expose the
interfaces can be created quickly to verify that interface-reliant
client code works correctly.</p>

<p>In addition to the actual work of the method, each interface method
implementation has two requirements. First, MTS must be notified when
the object's state is finished. Second, errors must be handled
within their objects, and MTS must be notified whether or not the
method was successful. The Object Context associated with each object
must be used. The <b>IObjectContext SetComplete</b>  method indicates
that an object has completed its work successfully. The <b>
IObjectContext SetAbort</b>  method indicates the object encountered an
error.</p>

<p>When <b>SetAbort</b>  is called, if the object is participating in a
transaction, that transaction will fail and managed resources will be
rolled back to their state prior to the transaction. This is an
extraordinarily powerful mechanism for handling errors when many
independently implemented objects are working 
together to perform some higher-level functionality requested by a
client. If 
any one object can't complete its work, the entire request
fails.</p>

<p>Since most objects will not retain state across method calls, the
basic structure of each method will look something like the following
pseudocode:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>MyMethod(&#8230;)
   On Error Goto ErrorHandler
   CtxObject = GetObjectContext()
   
   Do work
   If error condition then
      Raise error 
	  
   CtxObject.SetComplete
   Return success
   
ErrorHandler:
   CtxObject.SetAbort
   Return error
</pre>
</td></tr></table>
</p> 

<p><div class="note"><blockquote><b>NOTE</b><hr> In addition to calling <b>SetAbort</b>  when an
error occurs, a normal COM error should be returned. Clients then have
the information they need to decide whether to continue doing work. <b>
SetAbort</b>  does not have any effect until the containing transaction
ends.</blockquote></div>
</p>

<p>These basic ideas apply to both data objects and business objects.
With the basic component framework and a skeleton implementation of
each class in place, we can turn our attention to the interesting part:
implementing the application logic.</p>

<A NAME="418"><H2>Basic Windows NT Application Services</H2></A>

<p>Windows NT provides many of the services that were once the domain
of the application developer, including:</p>

<ul>
<p><li> System services to ensure that separate applications are
protected from each other on the system at all times.</li></p>

<p><li> Memory management.</li></p>

<p><li> Virtual memory services.</li></p>

<p><li> File caching.</li></p>
</ul>



<p>In the following sections, we discuss Windows NT architecture, and
how applications interact with each other to utilize these
services.</p>

<A NAME="419"><H3>User Mode and Kernel Mode</H3></A>

<p>Windows NT architecture is separated into a <i>user mode</i> and a
<i>kernel mode</i>. Windows NT controls access to the memory on the
system as well as access to all hardware. Applications running in user
mode have no direct access to the hardware; they must communicate with
the Windows NT Executive Service running in kernel mode to gain access
to resources such as files, printers, communication ports, or even the
processor.</p>

<p>Figure 8.4 shows Windows NT architecture and how applications behave
and gain access to system resources.</p>

<P><A HREF="javascript:fullSize('f08ar04x.htm')" onMouseOver="window.status='Click to view at full size';return true;" onMouseOut="window.status='';return true;"><IMG SRC="images/f08ar04.jpg" WIDTH=404 HEIGHT=438 BORDER=0 ALT="Click to view at full size"></A></P>
<P><!-- caption --><b>Figure 8.4</b> <i> Windows NT architecture</i><!-- /caption --></P>

<p>The Executive Service controls access to all resources. The I/O
Manager is the heart of access to resources such as files, system
devices, and the network. The Virtual Memory Manager is responsible for
managing the computer's memory and setting up protected memory
areas for each application running in user mode. The microkernel
provides such basic services as interrupt handling and thread
scheduling.</p>

<p>User mode contains applications and user processes. There is only
one way for information to pass from user mode to kernel mode: through
the Executive Service. This means that there is no other way for an
application to bypass security on the Windows NT system or compromise
the complete control that Windows NT has over the physical resources on
the workstation.</p>

<p>User mode is composed of several subsystems where applications
reside. These in turn send and receive messages from the Executive
Service. The subsystems include OS/2 and POSIX, and the security
subsystem.</p>

<p>In Figure 8.4, a Win32 application communicates with the proper
subsystem through messaging to gain access to the required resources.
The subsystem is responsible for passing requests to the Windows NT
Executive to be fulfilled. The Executive Service first assures that the
operation is safe (not something that would disrupt the system or
violate system integrity) and then completes the 
operation.</p>

<A NAME="420"><H3>Virtual Memory</H3></A>

<p>The Windows NT Executive Service also manages memory. The Virtual
Memory Manager provides applications with memory, and manages virtual
memory and the Windows NT pagefile. Each application has its own
dedicated memory address. Different operating systems allow
applications to access different amounts of memory:</p>

<ul>
<p><li> <b>Windows NT Server 4.0</b>  Windows NT 4.0 grants 4 gigabytes
(GB) of memory for each application. The application itself has a 2 GB
addressable memory space.</li></p>

<p><li> <b>Windows NT Server 4.0 Enterprise Edition</b>  Windows NT 4.0
Enterprise Edition offers 4-GB memory tuning, which allows applications
to address 3 GB of memory.</li></p>

<p><li> <b>Windows 2000 Server</b>  Windows 2000 Server will add support
for the Enterprise Memory Architecture, which can provide up to 64 GB
of addressable memory for an application that is &quot;large-memory
aware.&quot;</li></p>
</ul>



<p>The virtual memory process, shown in Figure 8.5, works as
follows:</p>

<ol>
<p><li> An application submits a request to store data in memory.</li></p>

<p><li> When an application issues a call for a memory location, the
Virtual Memory Manager maps the request to a non-conflicting memory
address. The Virtual Memory Manager intercepts the request, determines
how many pages are needed to fulfill the request, and then maps unused
physical memory to empty address spaces in the application's
virtual memory space. The Virtual Memory Manager hides the organization
of physical memory from the application.</li></p>

<p><li> If there isn't enough unused physical memory available, the
Virtual Memory Manager uses <i>demand paging</i> to find pages of RAM
that haven't been used recently, and then copies that data to the
paging file (pagefile.sys) on the hard disk. The newly freed RAM is
remapped to fill the application's request.</li></p>

<p><li> When the data stored in pagefile.sys is needed, the pages are
copied back into RAM. The new RAM location is mapped back to the same
virtual address required by the application.</li></p>

<P><A HREF="javascript:fullSize('f08ar05x.htm')" onMouseOver="window.status='Click to view at full size';return true;" onMouseOut="window.status='';return true;"><IMG SRC="images/f08ar05.jpg" WIDTH=404 HEIGHT=282 BORDER=0 ALT="Click to view at full size"></A></P>
<P><!-- caption --><b>Figure 8.5</b> <i> Virtual memory process</i><!-- /caption --></P>
</ol>

<A NAME="421"><H3>Cooperative Multitasking</H3></A>

<p>Multitasking refers to the ability of multiple applications and
processes to run at what appears to be the same time on a single system
with a single processor. There are two types of multitasking systems:
cooperative and pre-emptive.</p>

<p>The Windows 3.1 family of products is based on the concept of
cooperative multitasking. The operating system grants each application
access to the processor and system resources; it's up to that
application to relinquish control of those resources for other
applications to use. Clearly, a poorly written application that
doesn't multitask well can easily bring the system to a halt, since
that application is never forced to relinquish processor control.</p>

<A NAME="422"><H3>Pre-Emptive Multitasking</H3></A>

<p>The multitasking model used in the Windows 95, Windows 98, Windows
NT and Windows 2000 families relies on pre-emptive multitasking. In a
pre-emptively multitasked system, the system itself takes full control
of the processor. In the case of Windows NT, the Executive Service
controls the processor and resources at all times, not the
applications. The Executive Service then grants access to the processor
and other resources when necessary. Since the Windows NT Executive
Service always controls hardware resources, such as the processor, it
does not allow a single application or process to take control of the
processor time and not relinquish it. For the application developer
this means that it's no longer necessary to design an application
to perform in a cooperatively multitasked environment, because this
function is managed by the operating system.</p>

<A NAME="423"><H3>Multithreading</H3></A>

<p>In a multithreaded application, a single process or application can
run several 
tasks at once. The Windows NT Executive Service grants each thread a
slice of processor time. For example, a spreadsheet program may have an
option that allows a recalculation to be done on a spreadsheet. By
using multiple threads, the spreadsheet program can recalculate the
spreadsheet in one thread and still allow the user to update other
portions of the spreadsheet in another thread. Otherwise, to continue
working, the user will have to wait until the recalculation is
complete. Figure 8.6 illustrates both a single-threaded and a
multithreaded process.</p>

<P><A HREF="javascript:fullSize('f08ar06x.htm')" onMouseOver="window.status='Click to view at full size';return true;" onMouseOut="window.status='';return true;"><IMG SRC="images/f08ar06.jpg" WIDTH=404 HEIGHT=269 BORDER=0 ALT="Click to view at full size"></A></P>
<P><!-- caption --><b>Figure 8.6</b> <i> Multithreading in Windows NT</i><!-- /caption --></P>

</BODY>
</HTML>


