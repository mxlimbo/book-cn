<HTML>
<HEAD>
<TITLE>Automation</title>
<link rel="STYLESHEET" type="text/css" href="library.css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch08c.htm", "ch08e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="400"><H1>Automation</H1></A>

<p>In covering the essentials of COM, we've learned that a common
characteristic of COM objects and interfaces is that client
applications must recognize the COM interfaces they will use when they
are built. A client application can't create a random COM object
and use interfaces possibly exposed by that object; the application can
use only the interfaces it recognizes at build time.</p>

<p>While this scenario works well for many applications, it is often
helpful to determine at run time what objects may be used, and their
corresponding interfaces. This capability is provided by Automation,
originally developed to provide a means for macro and scripting
languages to programmatically control applications. Word and Excel
macros are examples of Automation in action. As of this book's
publication, both Word and Excel use a common macro scripting language,
Microsoft Visual Basic for Applications. General-purpose scripting
languages such as Visual Basic for Applications can't contain
built-in knowledge of every interface possibly exposed by an object, so
Automation performs this role for these applications.</p>

<A NAME="401"><H2>The IDispatch Interface</H2></A>

<p>Automation defines a standard COM interface, <b>IDispatch</b>, for
programmatic access to an object. By implementing <b>IDispatch</b>,
components can expose any number of functions to clients. Clients
access all functionality through a single well-known function, <b>
IDispatch Invoke</b>, as shown in Figure 8.1.</p>

<P><A HREF="javascript:fullSize('f08ar01x.htm')" onMouseOver="window.status='Click to view at full size';return true;" onMouseOut="window.status='';return true;"><IMG SRC="images/f08ar01.jpg" WIDTH=404 HEIGHT=288 BORDER=0 ALT="Click to view at full size"></A></P>
<P><!-- caption --><b>Figure 8.1</b> <i> Invoking an Automation method using IDispatch</i><!-- /caption --></P>

<p>In its simplest form, late binding, Automation lets clients call
objects without any prior knowledge of methods exposed by the objects.
A client application creates an object as it usually would and requests
the <b>IDispatch</b>  interface. To access the object's
functionality, the client calls the <b>IDispatch GetIDsOfNames</b>  method with the text name of a function it intends to
call. If the function is supported, a <i>dispatch ID</i> (DISPID), or a
number identifying the function, will be returned. The client then
packages all parameters to the function in a standard data structure,
and calls <b>IDispatch Invoke</b>, passing in the DISPID and the
parameter data structure.</p>

<p>When the object receives a call to <b>Invoke</b>, usually a method,
it uses the DISPID as a key to determine which internal function to
call. The object pulls apart the parameter data structure to build the
method call to the internal function. If the correct parameters
aren't available, the <b>Invoke</b>  method can return immediately,
without risking a component failure due to a poorly formatted method
call. After the internal function completes its work, the return value
and/or any error information is packaged into standard data structures,
and returned as <b>[out]</b>  parameters from the <b>Invoke</b> 
call.</p>

<p>This process is complicated if all the required &quot;plumbing&quot;
has to be built. However, this process is enormously useful for
interpreted languages. To use Automation-aware objects, an interpreter
(sometimes called a <i>script engine</i>) needs to recognize how to
create objects, call methods through <b>IDispatch</b>, detect errors,
and destroy objects. Such an interpreter doesn't need to construct
stack frames for different calling conventions, interpret interface
pointers, or determine which functions an object exposes. All of these
functions can be hidden within the interpreter itself, leaving a simple
programming model for the script author.</p>

<p>On the component side, most of the plumbing can be hidden as well.
Most COM-aware development tools create Automation-aware components by
default. If the language itself is COM-aware, as Visual Basic is,
details of implementing <b>IDispatch</b>  can be hidden entirely, so
only the exposed functions need to be implemented. If a particular
framework provides COM support, the framework usually implements
standard <b>IDispatch</b>  and defines a data-driven mechanism for
hooking up DISPIDs to internal methods. Again, the developer needs to
implement only the actual functions.</p>

<p>The flexibility of late binding involves a price. First, all
parameters passed to <b>Invoke</b>  must be the <b>VARIANT</b>  type. A
<b>VARIANT</b>  contains a value and a tag that identifies the
value's type. Automation defines a set of types that can be placed
in <b>VARIANT</b>s. If a particular set of data is not one of these
types, it will need to be converted before developers can pass it as a
parameter to an <b>Automation</b>  method.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> In practice, this <b>VARIANT</b>  limitation is
usually not a problem as the set of types supported by Automation is
fairly extensive. Windows NT 4.0 Service Pack 4, Windows 98, and
Windows 2000 are expected to add user-defined structures to the set of
Automation types.</blockquote></div>
</p>

<p>Second, objects can expose only one <b>IDispatch</b>  interface at a
time. While it is possible to expose additional <b>IDispatch</b>-based
interfaces using different IIDs, in practice, no scripting languages
can access these interfaces. Therefore, most 
Automation-aware objects expose a single programmatic interface for
clients to use. This quality can impact development application design,
particularly if 
security constraints are in place.</p>

<p>Finally, considerable overhead is associated with late binding.
Every method call results in two calls to the object&#8212;one call to
<b>GetIDsOfNames</b>  to find the DISPID, and another call to <b>
Invoke</b>. Overhead is also associated with packaging and unpackaging
parameters passed into and out of <b>Invoke</b>. Generally, this
overhead is acceptable in interpreted environments, but possibly not
acceptable to all other clients.</p>

<A NAME="402"><H2>Type Libraries</H2></A>

<p>Because they are usually compiled, many client applications do not
need the absolute run-time flexibility offered by late binding. In
these scenarios, the required objects and methods are identified during
the development process.</p>

<p>Rather than call <b>GetIDsOfNames</b>  and risk overhead, DISPIDs for
methods can be hard-coded into applications, in another form of
Automation called <i>early binding.</i> This form of Automation
involves binding the necessary components into the client application
at build time. For early binding to work, development environments must
have a way to determine the DISPIDs of methods being called. Ideally,
the development environment could determine whether correct parameters
were being passed to methods, and thus eliminate a multitude of
application errors. Essentially, the development tool needs a complete
description of component-exposed methods. Such a description would be
provided by type information, usually stored in a type library
associated with each component.</p>

<A NAME="403"><H2>Dispinterfaces</H2></A>

<p>As with normal COM interfaces, IDL can be used to define Automation
interfaces. Automation defines a set of standard interfaces for
creating and browsing type information. However, instead of using the
<b>interface</b>  keyword, the <b>dispinterface</b>  keyword is used.
This keyword indicates that the interface will be implemented using <b>
IDispatch</b>; therefore, only Automation types can be used. The
methods defined for the <b>dispinterface</b>  will not appear in the
interface's vtable.</p>

<p>With <b>dispinterface</b>  keywords, developers can explicitly
distinguish properties from methods&#8212;a property represents an
attribute; a method represents an action. For example, a <b>
Rectangle dispinterface</b>  could have <b>Height</b>  and <b>
Width</b>  properties and a <b>Move</b>  method. Each property is
implemented as a set of accessor functions: one function reads the
property and an optional function writes the property. Both functions
have the same DISPID; a flag is passed to <b>IDispatch Invoke</b>  to indicate whether a read or write operation is requested.
This capability is useful for Automation-aware languages, which can
coat properties in syntactical sugar to make the objects easier to use.
For example, in Microsoft Visual 
Basic Scripting Edition (VBScript), properties almost identically
resemble variables, as shown here:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>set rect = CreateObject(&quot;Shapes.Rectangle&quot;)
rect.Left = 10
rect.Top = 10
rect.Height = 30
rect.Width = rect.Height
</pre>
</td></tr></table>
</p> 

<p>As mentioned, it is rarely necessary to hand-code interface
definitions in IDL. Development environments such as Visual Basic let
developers define interfaces in standard language syntax and create the
type library directly. Other development environments provide wizards
to help define methods and properties on interfaces. The wizards
generate correctly formatted IDL, which can be compiled using MIDL to
generate a type library.</p>

<A NAME="404"><H2>Dual Interfaces</H2></A>

<p>Early binding is a substantial improvement over late binding for
compiled clients. However, if a client is written in a development
language that supports vtable binding, calling <b>IDispatch Invoke</b> 
seems to allow for much unneeded overhead. To address this concern,
Automation supports <i>dual interfaces,</i> which are interfaces with
characteristics of both vtable-based interfaces and <b>
dispinterface</b>s.</p>

<p>Dual interfaces are defined using the <b>interface</b>  keyword in
IDL. All dual interfaces have the <b>dual</b>  attribute, which
indicates that parameter types in interface methods must be Automation
types. In addition, all dual interfaces are derived from <b>
IDispatch</b>. Methods defined in a dual interface are part of its
vtable, so clients that understand vtable binding can make direct calls
to the methods. But the interface also provides the <b>Invoke</b> 
method; therefore, clients that exclusively understand either early
binding or late binding can also use the interface. The <b>Invoke</b> 
method implementation still uses the DISPID to decide which method to
call.</p>

<p>For components that expose a programmatic interface, there is little
reason not to define an interface as a dual interface. As of this
book's publication, almost every COM-aware development tool can use
dual interfaces, and most tools that let developers create COM
components generate dual interfaces by default. Client applications
that can take advantage of vtable-binding get improved performance with
essentially no extra work for both component and application
developers. Dual interfaces can also use the Automation marshaler,
eliminating the need to install a custom proxy/stub DLL on client
computers for such interfaces.</p>

</BODY>
</HTML>


