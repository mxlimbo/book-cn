<HTML>
<HEAD>
<TITLE>Component Object Model (COM)</title>
<link rel="STYLESHEET" type="text/css" href="library.css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch08b.htm", "ch08d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="386"><H1>Component Object Model (COM)</H1></A>

<p>To facilitate understanding of Microsoft business service
technologies, we'll examine COM, which is the foundation of many of
the technologies we will discuss in this book. This chapter is not
intended as an exhaustive discussion of COM, but we will briefly review
some of the basic concepts developers should know before they begin
their application architectures. Recommendations for further reading
are listed in the bibliography.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> Another leading object model and implementation
in the computer industry is Common Object Request Broker Architecture
(CORBA). For CORBA-specific information, we recommend Alan Pope's
<i>The CORBA Reference Guide</i> (Addison-Wesley, 1998).</blockquote></div>
</p>

<A NAME="387"><H2>Why COM?</H2></A>

<p>The fundamental goal of COM is to enable developers to create
applications 
assembled from pre-built parts, or components. Components are the
physical 
binary implementations of the business object. For example, an
order-entry 
application could use a data-entry grid component to simplify entering
ordered items into the application. Another component could look up a
customer's city and state by entering the customer's ZIP code
or postal code. Yet another component could calculate the order's
sales tax. To make such a component-based 
application a reality, several technical challenges must be met.</p>

<p>The first technical challenge is how to locate the component on a
computer or network and, once located, to execute the component. The
locating of components is also referenced as a directory service for
the components. If no such standards exist, overhead costs of learning
to use components is very high. Additionally, the costs and
inconsistencies of coding logic to locate additional components and
create objects would present significant barriers to reusing pre-built
components. In conjunction with these standard mechanisms used for
internally created components, applications must also be available to
identify and execute vendor-created components.</p>

<p>The second technical challenge is to provide standards for the
application to interact with the components. Again, if no standards
exist, the overhead cost of learning how to use such objects creates a
barrier to reusing code. Ideally, a standard mechanism for object
interaction would not distinguish the location of any given object,
whether the object exists within its own application's process,
within another process on the application's host computer, or
within a different process on another computer altogether.
Inter-process and remote communications usually require tremendously
complex coding within an application. Providing standards for object
interaction will allow application and component developers to spend
less time creating such complex code.</p>

<p>The third technical challenge is executing true language
independence, a complex challenge for any object model. Every element
involved in a particular 
object&#8212;memory allocation, method names, parameter types, calling
conventions, and so on&#8212;must be defined in such a way that the
object can be created in one programming language and used by another.
Application developers should not need to spend valuable time or energy
worrying which programming languages or tools are used to create a
desired component. Without wide support from development languages and
tools, many different models will fragment the component market. This
fragmentation raises the costs of identifying, purchasing, and
developing components that are operable only in certain
environments.</p>

<p>Finally, an ongoing challenge is in maintaining the potential to
create newer versions of applications and components. Applications
developed at different times can implement identical components, and
thus cause usage conflicts, when running on a given computer. As
developers continue to upgrade components to maintain function in the
ever-changing world of computer technology, version compatibility must
be maintained. These ongoing upgrades can involve fixing problems in
existing component features, adding new functionality to existing
components themselves, or creating new components altogether.</p>

<p>The following subsections review elements and terminology of COM
that are commonly used in application development.</p>

<A NAME="388"><H3>Objects</H3></A>

<p>&quot;Object&quot; is one of the most overloaded terms in
programming. As with most 
object-oriented models, COM objects are run-time instances of a
particular class, with the class representing a real-world entity.
We'll define the exact meaning of classes later in this chapter;
conceptually, however, classes are types of objects. For example, based
on their characteristics, classes could define a <b>Customer</b>, <b>
Order</b>, or <b>SalesTaxCalculator</b>. Thus, each <b>Customer</b> 
object would represent a specific instance of a real-world customer;
each <b>Order</b>  object a specific instance of an order; and so
on.</p>

<p>An object usually contains an identity, a state, and a type of
behavior. Identity is the unique name or label distinguishing one
object from any other. State represents data associated with a
particular object. Behavior is a set of methods called to query or
manipulate an object's state.</p>

<p>To help clarify these concepts, let's examine C++ objects, which
are run-time instances of C++ classes. A C++ class defines member
variables and methods that apply only to objects of this particular
class. Upon a particular object's creation, a contiguous block of
memory becomes allocated for member variables; the allocated
memory's address in effect becomes the object's identity and
the memory block's contents become the object's state. Located
elsewhere in memory, method implementation code defines the
object's behavior.</p>

<p>Most language-based object models are similar to that of C++, but
the COM 
object model is somewhat different. Recall that two challenges faced by
COM are language- and location-independence. When developers begin to
examine inter-process and remote communications, memory addresses are
not sufficient to identify objects. In addition, compatibility among
all programming languages and tools regarding memory layout for object
member variables is nearly 
impossible.</p>

<p>Accounting for these potential complications, COM approaches objects
in a different manner than C++. In COM, the notion of an object's
public interface and its implementation are completely separate.
Applications can interact with COM objects only through the
object's public interfaces using a COM-defined interface pointer.
Since all interactions must go through the interface pointer, COM
ignores an object's state location and memory inner workings.
Additionally, since an interface pointer is the only means through
which an application references a given object, the object's
identity must relate to that pointer.</p>

<A NAME="389"><H3>Interfaces</H3></A>

<p>Understanding interfaces is essential to understanding COM. A COM
interface is a collection of logically related operations that define a
particular behavior. When developers define an interface, they provide
specifications only for a set of operations, but not for
implementations. Interface definitions represent a con-tract between a
caller and an implementer: if a component implements a particular
interface, the caller can expect the component to obey the interface
specification. Such a specification includes a strict definition of
interface method syntax, as well as a definition of interface
semantics.</p>

<p>To be defined as a COM interface, such an interface must satisfy the
following requirements:</p>

<ul>
<p><li> A unique identifier must identify the interface.</li></p>

<p><li> The interface must ultimately derive from the special interface
<b>IUnknown</b>.</li></p>

<p><li> Once published, the interface must be immutable. In other words,
the interface can't be changed.</li></p>
</ul>



<A NAME="390"><H3>COM Identifiers</H3></A>

<p>Unique COM identifiers are needed to locate components, and also to
reference each interface. Providing a unique identifier to cite each
interface could involve using a string identifier, which could cause
several problems.</p>

<p>The most critical issue raised by performing this action is the
difficulty of guaranteeing the selection of a truly unique identifier.
Even when a naming convention is imposed, there is a possibility that
another developer elsewhere in the world will use the same identifier
for a different purpose. To guarantee uniqueness, prefixes could be
issued from a central authority&#8212;for example, one prefix per
company. Each company would, in turn, need a central registry of names
to prevent any duplicates within the company. To impose such a method
on string identifiers seems much too complicated.</p>

<p>Instead of using string identifiers, COM implements globally unique
identifiers (GUIDs, pronounced &quot;goo-ids&quot; or
&quot;gwids&quot;), which are 128-bit system-generated integers that
uniquely identify components. The algorithm used to generate GUIDs is
statistically guaranteed to generate unique identification numbers.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> According to the COM specification, GUIDs can be
generated at the rate of 10,000,000 per second per computer for the
next 3,240 years without risk of duplication.</blockquote></div>
</p>

<p>GUIDs can be generated using a tool such as GUIDGEN, which
accompanies the Microsoft Platform Software Development Kit (SDK).
GUIDGEN calls the system application programming interface (API)
function <b>CoCreateGuid</b>  to generate the GUID, then provides
several output options. For example, the following GUID was generated
using the static const output option, and is suitable for inclusion in
a C++ source file:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>// {45D3F4B0-DB76-11d1-AA06-0040052510F1}
static const GUID GUID_Sample = { 0x45d3f4b0, 0xdb76, 0x11d1,
    { 0xaa, 0x6, 0x0, 0x40, 0x5, 0x25, 0x10, 0xf1 } };
</pre>
</td></tr></table>
</p> 

<p>The first line in the code example shown above is a comment showing
how a GUID appears in string form; GUIDs are normally presented to
users in this string form. The second and third lines in the code
example above define the GUID as a constant that can be used in C++
code.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> Most development tools automate the process of
creating skeleton COM components. Such tools also generate appropriate
GUIDs for developers in a format that the skeleton COM code can
recognize.</blockquote></div>
</p>

<p>Every interface is identified by a GUID. Whenever we need to
uniquely identify an interface to COM, we use its GUID, which we call
an interface identification (IID). The IID can be complex numerical
figures such as {45D3F4B0-DB76-11d1-AA06-0040052510F1} or
{45D3F4B1-DB76-11d1-AA06-0040052510F1}.</p>

<p>To simplify IID standards for use in source code, every interface
should also have a string name. Conventionally, these string names
usually begin with the letter &quot;I&quot;&#8212;for example, <b>
IComputeSalesTax</b>. String names aren't guaranteed to be unique,
but it's unlikely that two different interfaces with an identical
string name would be used in one source code file.</p>

<A NAME="391"><H3>Defining Interfaces</H3></A>

<p>Concern may arise over how to define interfaces so that component
developers know how to implement them and application developers know
how to use them. COM does not rigidly distinguish interface
definitions, as long as both component and application developers can
agree on the definitions. In practice, COM interfaces are usually
defined using the Interface Definition Language (IDL).</p>

<p>Similar to C++, IDL is a language that describes the exact syntax of
an interface. Interface definitions begin with an interface keyword;
interface attributes are contained in square brackets preceding the
interface keyword. An object attribute indicates that COM IDL
extensions should be used, and a UUID attribute (see the following
note) specifies the IID for the interface being defined.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> The attribute is named UUID because COM IDL is
based on the Open Software Foundation's Distributed Computing
Environment (DCE) IDL, which uses the term &quot;universally unique
identifier&quot; (UUID) instead of GUID.</blockquote></div>
</p>

<p>Not all development languages will support all data types that can
be specified using IDL. Most interfaces use a fairly restricted set of
data types. We discuss this limitation in more detail later in this
chapter. COM methods can have any number of parameters and arbitrarily
complex data types. Beside simple types such as a name and data type,
developers can specify additional attributes for each IDL parameter.
These attributes provide clues about how data should be copied from one
place to another. IDL is a convenient text format for documenting the
interface syntax. Once the IDL code is written, it can be compiled
using the Microsoft IDL (MIDL) compiler to generate the following
equivalent interface definition representations, which are useful to
development tools:</p>

<ul>
<p><li> <b>Header file</b>  Header files define the IDL types that can be
used to declare interface pointer variables, or to derive an
implementation class for an interface. Header files can be included in
a C or C++ program.</li></p>

<p><li> <b>Type library</b>  Type libraries are binary representations of
IDL code. Development languages, such as Microsoft Visual Basic, read
the type library to determine the syntax of the interfaces described in
the type library.</li></p>

<p><li> <b>Source code for a proxy/stub DLL</b>  This source code
implements proxy/stub DLLs used for inter-process and remote
communication.</li></p>
</ul>



<p>While not difficult to use, IDL is still new to many developers;
thus most development languages and tools offer assistance. Some
systems, such as Visual Basic, completely hide IDL by allowing
developers to define interfaces directly in the system's syntax
while the system itself generates a type library for the interface.
Other tools generate the IDL file automatically, usually by providing a
wizard or similar automated guide to help developers define an
interface and its methods; after the interface and its methods have
been defined, the tools generate the correct IDL syntax.</p>

<p>Defining interfaces using IDL is a preliminary step toward language
independence, but not a complete solution. Given an IDL file, or an
equivalent header file or type library, an interface or client
application implementation can be coded, as long as it is done in any
language recognizing the interface's types used. To ensure
communication between the implementation developed and the client
computer, both client and implementation must agree on what an
interface pointer would represent, and how that pointer intermediates
method calls.</p>

<A NAME="392"><H3>COM as a Binary Standard</H3></A>

<p>COM, as a binary standard for object interaction, addresses many
component challenges. COM is a binary standard because:</p>

<ul>
<p><li> It is part specification-oriented.</li></p>

<p><li> It is part implementation-oriented.</li></p>
</ul>



<p>COM is part specification-based in that it defines objects in a
language- and 
location-independent manner, as well as how to locate and identify
components, and also create objects. A COM component's interface
can be recognized with the IDL, or equivalent header file or type
library.</p>

<p>COM is also part implementation-based in that it provides system
services that locate components and load them into memory.
Additionally, COM can perform inter-process and remote communications
as well as other needed tasks. COM defines the exact binary
representation of an interface. Any programming language or tool that
supports COM must create object interfaces that correspond to this
standard binary representation.</p>

<p>The client's interface pointer is actually a pointer to a table
of more pointers. The table of pointers is called the vtable. Each
pointer in the vtable points to the binary code for an interface method
in exactly the same manner as in a C++ virtual function table.</p>

<p>A specific pointer to a vtable is appropriately called a <i>vtable
pointer</i>. Each COM object contains a vtable pointer for each
interface it supports. A client requesting an interface pointer to an
object obtains <i>a pointer to</i> an appropriate vtable pointer, <i>
not</i> the vtable pointer itself. The vtable pointer needs an
additional pointer to support an interface because the component needs
a way to identify the object on which it should be working.</p>

<p>When a COM object is created, a single block of memory is usually
allocated for both vtable pointers as well as any internal data members
that the object needs. The component recognizes the relationship
between the locations of both the vtable pointer and the object's
entire memory block; thus, this component can identify its appropriate
object. By using the interface pointer, COM further specifies that the
first parameter passed to each method call is a pointer to the
particular object mentioned.</p>

<p>Fortunately, most COM-supportive programming languages and tools
automatically map interface pointers and vtables to equivalent concepts
in the languages themselves. For example, C++ interfaces are equivalent
to abstract base classes. These interfaces can be implemented by
deriving a particular class from the abstract base class. Calling COM
methods through an interface pointer is exactly like calling C++
methods through an object pointer. As another example, Visual Basic
interfaces are almost completely hidden within the Visual Basic
language itself. An interface can be implemented by using the <b>implements</b>  keyword and thereby implementing the interface's
methods. To use a COM object, declare an interface type object
variable, create the object, and make function calls as normal.</p>

<p>Combined with a common interpretation of interface definitions, the
binary standard for interfaces provides language independence as well
as the potential for complete location independence. As mentioned,
it's ideal to make in-process, inter-process, and remote calls
identical on the client computer. Within a single process, the
interface pointer can direct itself to the original vtable pointer and
call methods directly. Although such a technique probably wouldn't
work across different processes or computers, the interface pointer
could be redirected to point to a proxy vtable pointer. The client-side
proxy would presumably recognize methods in which to make inter-process
or remote calls to an equivalent server-side object, or stub; in turn,
that particular object would make in-process calls to the original
object. To clients and components, method calls would appear
identical.</p>

<A NAME="393"><H3>The IUnknown Interface</H3></A>

<p>A vtable contains three methods&#8212;<b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b>&#8212;not defined by the developer for a
COM component interface. The <b>IUnknown</b>  interface provides these
three methods, and also defines fundamental behavior for COM
interfaces. Clients can rely on this fundamental behavior because all
COM interfaces derive from <b>IUnknown</b>. <b>IUnknown</b>  helps
resolve the technical challenge of providing a standard means to
interact with objects, and additionally provides three important
features: interface navigation, interface versioning, and object
lifetime management.</p>

<p><b>Interface Navigation</b></p>

<p>Interface navigation is provided by the <b>QueryInterface</b> 
method. As mentioned previously, COM objects can support more than one
interface. For example, if developers have one interface pointer to an
object and desire another, they can request it from the object using
the <b>QueryInterface</b>  method. Because all interfaces derive from
<b>IUnknown</b>, every interface conveniently supports <b>
QueryInterface</b>.</p>

<p>To use <b>QueryInterface</b>, a client chooses an IID it wants to
pass to an object. If it supports that interface, the object passes
back the interface pointer. If not, the object returns an error. <b>
QueryInterface</b>  is an extraordinarily powerful mechanism that allows
independently created clients and components to negotiate a common
communication method. <b>QueryInterface</b>  is also the key to solving
the challenge of versioning, which is discussed in greater detail in
the following paragraphs.</p>

<p><b>Interface Versioning</b></p>

<p>Because components and applications can be built and published
independently, an interface that has been published is
immutable&#8212;no changes to syntax or semantics are allowed. Changing
a published interface is not permitted; even changes to an
interface's number of methods could cause damage. For instance, a
new client application could erroneously read an interface as
containing five methods, and unsuccessfully attempt to call an obsolete
component containing only four methods, thus a program error would
occur. COM interfaces are therefore immutable to avoid such
conflicts.</p>

<p>Now that we have said an interface cannot be changed, a new
interface must actually be defined to &quot;version&quot; an interface.
Existing clients are probably incompatible with new interfaces, since
the original interface continues to exist, so these clients are
unaffected by whether or not components implement the interfaces. New
clients can implement support for new interfaces and access new
features when the clients communicate with new components. If a new
client happens to access an older component, it can use <b>
QueryInterface</b>  to safely detect that the component does not support
the new interface and avoid using the new features.</p>

<p>In summary, once a COM interface is defined it cannot be changed, so
to create a new version, the new interface is added to the component
and the previous interface is also maintained.</p>

<p><b>Object Lifetime Management</b></p>

<p>Assuming that an object has been created on a client computer
holding an interface pointer to the object, it seems logical that this
object could be destroyed on the client on which it was created.
However, the process of destroying an object that is no longer needed
is complicated. For instance, one client can use <b>QueryInterface</b> 
to obtain multiple interface pointers to a single object. This client
may not be able to track when it had finished using all interface
pointers needed to safely destroy the object. Another client could
potentially need to use the object after it was marked for deletion. No
single client can distinguish when all clients have finished using the
object except the object itself&#8212;with some assistance from each
client.</p>

<p>To address the issues involved in destroying an object, <b>
IUnknown</b>  provides a third feature&#8212;<i>object lifetime
management</i>, commonly referred to as reference
counting&#8212;which tracks the number of clients using an interface.
When a new interface pointer to an object is created, the object's
reference count must be incremented by calling <b>IUnknown AddRef</b>. A client computer that has finished using an interface
pointer calls <b>IUnknown Release</b>  to <i>decrement</i> the
object's reference count. When the reference count is set to zero,
the object destroys itself upon determining that its use is complete.
Hence the object lifetime management feature neatly solves the problems
of both a single client with multiple interface pointers as well as
multiple independent clients. With this feature implemented, the client
computer's only tasks are to create an object to get an interface
pointer, use the pointer to make method calls, and release the pointer
using <b>IUnknown Release</b>.</p>

<A NAME="394"><H3>Classes</H3></A>

<p>When considering classes, it should be remembered that all COM
objects are instances of COM classes. A COM class is simply a named
implementation of one or more COM interfaces. A COM class is named
using a class identifier (CLSID), which is a type of GUID. Like IIDs,
CLSIDs are guaranteed to be unique, but are difficult to use.
Therefore, COM classes can also have string names, called <i>
programmatic identifiers</i> (ProgID).</p>

<p>Every COM class has an associated <i>class object,</i> also known as
a class factory, which has the ability to create instances of a single
COM class. The COM spe-cification defines a standard API function for
creating class objects (<b>CoGetClassObject</b>), and a standard
interface for communicating with class 
objects (<b>IClassFactory</b>). Thus, clients need only one mechanism
to create any type of COM object. The most important method of <b>
IClassFactory</b>  is <b>CreateInstance</b>, which creates an object and
returns a specified interface pointer. A client can create a COM object
simply by calling <b>CoGetClassObject</b>  to capture an <b>
IClassFactory</b>  interface pointer. Similarly, a client can create
such an object by calling <b>IClassFactory CreateInstance</b>  to
send an interface pointer to the object, then releasing the <b>
IClassFactory</b>  interface pointer. Because this procedure occurs
often in COM applications, COM provides a wrapper function that lets
developers perform this procedure with one call: <b>
CoCreateInstanceEx</b>.</p>

<p>COM classes differ from most language-based classes in that, once an
object has been created, its class is irrelevant to the client. All
interaction with the object occurs through public interface pointers,
which don't recognize the private implementation class used to
create the object. This rigorous separation of interface and
implementation is a key feature of COM. This &quot;black box&quot;
concept greatly simplifies the client coding effort because the client
need not know how the component works, just that they do work.</p>

<A NAME="395"><H3>Components</H3></A>

<p>A <i>COM component</i> is a binary unit of software that can
be used to create COM objects. For a given CLSID, a component will
include the COM class, the code to implement the class object, and
usually the code needed to create appropriate entries in a system
registry.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> Although components are sometimes called
servers, we avoid confusion with server computers by maintaining the
original term, &quot;component,&quot; throughout this
chapter.</blockquote></div>
</p>

<p>The Microsoft Windows 95, Windows 98, and Microsoft Windows NT
platforms allow three basic packaging methods for COM components:
Windows services, executable files, or DLLs. Components are built as
Windows services in situations where the components must always be
running, even if no one is logged on to the host computer. Windows
executable files are often used where an application provides a UI in
addition to furnishing COM objects. Microsoft Word is an example of a
COM component built as an executable file. In most other scenarios,
components are packaged as DLLs. In particular, most components used to
construct three-service layered applications will be packaged as DLLs.
The Microsoft ActiveX controls used in a presentation layer are DLLs,
as are all business service components that run within the MTS
environment.</p>

<p>Another way to categorize components is by their location relative
to the client, as described in the three categories listed below:</p>

<ul>
<p><li> <b>In-process components</b>  These components run within the same
process as the client. All in-process components are implemented as
DLLs.</li></p>

<p><li> <b>Local components</b>  Local components run in separate
processes, all on the client computer. A local component can be an
executable file or a Windows service.</li></p>

<p><li> <b>Remote components</b>  Remote components operate on computers
entirely separate from the client. Remote components can be executable
files, Windows services, or DLLs. To run a DLL component remotely, a
remote computer would implement a <i>surrogate process</i>,  or
an application run on a remote computer capable of running DLL
components. Both COM and MTS provide standard surrogates for DLL
components.</li></p>
</ul>



<p>For the remainder of this section relating to COM, we will focus on
components implemented as DLLs, as these are most prevalent in N-tier,
or service-layered, applications.</p>

<A NAME="396"><H3>DLL Component Structure</H3></A>

<p>In addition to implementing COM classes and class objects provided
by all types of components, DLL components are expected to implement
four well-known entry points:</p>

<ul>
<p><li> <b>DllGetClassObject</b>  returns an interface pointer to a class
object for a specified component-implemented CLSID.</li></p>

<p><li> <b>DllCanUnloadNow</b>  indicates whether any objects created by a
component are still active. If so, the DLL needs to remain in memory;
otherwise, the DLL can be unloaded, allowing for computer resource
conservation.</li></p>

<p><li> <b>DllRegisterServer</b>  writes all registry entries required for
all COM classes implemented in the component.</li></p>

<p><li> <b>DllUnregisterServer</b>  removes all registry entries created
by <b>DllRegisterServer</b>.</li></p>
</ul>



<p>The COM run time calls <b>DllGetClassObject</b>  and <b>
DllCanUnloadNow</b>; applications should never need to call these
functions directly. Installation programs and developer tools usually
call <b>DllRegisterServer</b>  and <b>DllUnregisterServer</b>.</p>

<A NAME="397"><H3>Threading</H3></A>

<p>COM supports multiple threading models for components. A <i>
threading model</i> defines on which threads a component's objects
can run, and also specifies how COM will synchronize access to the
objects. On the Windows 95, Windows 98, and Windows NT platforms, COM
components run in a multi-threaded environment. Components must be
written to run correctly in such an environment.</p>

<p>All COM threading models are based on the notion of apartments. An
<i>apartment</i> is an execution context for objects. Every object
resides in exactly one apartment for its entire lifetime; one or more
apartments reside within each process. All threads in a given process
must be associated with an apartment before making COM calls, by
calling <b>CoInitialize</b>  or <b>CoInitializeEx</b>.</p>

<p>All calls to an object are made in the object's apartment. If
the application responsible for calling runs in a different apartment,
COM synchronizes access to the object's apartment. In addition,
cross-apartment calls must be marshaled when using a <i>single-threaded
apartment</i> (STA) model. More fully detailed in the &quot;<a href="ch08e.htm#410">Remote
Activation and Marshaling</a>&quot; section later in this chapter, <i>
marshaling</i> essentially means that COM intercepts a call, packages
the call stack into a standard format, does some work, and then
converts the package back to a method call in the object's
apartment. In-process, cross-apartment calls can substantially impact
performance, highlighting the importance of understanding COM threading
models.</p>

<p>In Windows 95, Windows 98, and Windows NT 4.0, COM supports two
types of apartments. A single-threaded apartment (STA) is associated
with one thread for the lifetime of an apartment. Such an apartment is
created when a thread calls <b>CoInitialize</b>  or <b>CoInitializeEx</b>. One process can have multiple STAs; the first STA
created is the main STA. Each process can also have one <i>
multi-threaded apartment</i>. Multiple threads can be associated with a
multi-threaded apartment model. The registry key <b>
ThreadModel</b>=FREE denotes a multi-threaded apartment model, also
referred to as a <i>free-threaded model</i>.</p>

<p>By default, if the registry key <b>ThreadModel</b>  is not set, an
STA has a single thread associated with it for its entire lifetime, and
apartment model objects residing in an STA will never be accessed
concurrently, as they will always run on one thread. No matter how many
objects are in this apartment, only one method call will execute at a
time, and only a single instance of each particular object may exist in
the STA at any given point in time. Thus, object developers are helped
considerably as it eliminates the need to synchronize access to
per-object state; if necessary, thread-local storage can be used. To
provide better scalability, the registry key <b>ThreadModel</b>=Apartment can be set to allow multiple instances of an
object to exist in an STA at any point in time. To implement this
apartment value, the component's global data and DLL entry points
must be coded as thread safe.</p>

<p>Synchronization in the STA is based on Windows messages. Calls are
queued as special messages and processed by a COM-created hidden
window. As a result, threads associated with an STA must have a <i>
message pump</i>, which is a special program loop that retrieves
Windows messages from the current thread's message queue,
translates them, and dispatches the messages to other parts of the
application. If the thread does not have a message pump, no calls will
be processed. The STA synchronization model does not prevent
re-entrance; it just provides thread safety. This model is exactly the
same as that used by window procedures. During method calls to other
apartments or processes, COM continues to pump messages so that the STA
can process incoming calls and ensure that the thread's windows are
responsive. Called objects can call to other objects in the STA without
fear of deadlock.</p>

<p>Components complying with the apartment model are easy to write, but
concurrency constraints can create an unacceptable performance
bottleneck. In this case, such components may need to support the
free-threaded model. COM does not synchronize access to objects in the
multi-threaded apartment. Threads are dynamically allocated as needed
to service all concurrent calls into the multi-threaded apartment.
Thus, it is possible for free-threaded objects to be accessed
concurrently by multiple threads, which can improve performance.</p>

<p>Writing thread-safe code can be difficult. Both global variables and
per-object state must be protected. Developers must also be concerned
as to whether functions from run-time or statically linked libraries
are thread-safe. COM provides an important advantage in that it
provides a choice of threading models when writing code. COM also
resolves any mismatches between an object and caller-supported
threading models.</p>

<p>This feature is particularly interesting for in-process components.
In-process components normally use their client process threads instead
of creating new threads. For the client process to create a COM object,
it must have already called <b>CoInitialize</b>  or <b>CoInitializeEx</b>  to establish the apartment associated with the
calling thread. But then how does COM ensure that the caller's
apartment is compatible with the threading model supported by the
created object? When a component is created, it specifies the threading
model it supports using a named registry value on the <b>
InprocServer32</b>  key, as shown here:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>HKCR\CLSID\{45D3F4B1-DB76-11d1-AA06-0040052510F1}\InprocServer32
   @=&quot;salestax.dll&quot;
   ThreadingModel=&quot;Apartment&quot;
</pre>
</td></tr></table>
</p> 

<p>COM uses the <b>ThreadingModel</b>  value to determine which
apartment an object will be created in, as shown in Table 8.1. For
example, if the caller's apartment is an STA and the
component's <b>ThreadingModel</b>  is Apartment, the object will be
created in the caller's STA. All calls from caller to object will
be direct calls; no marshaling is needed. If the caller's apartment
is a multi-threaded apartment and the component's <b>
ThreadingModel</b>  is Apartment, the object will be created in a new
STA. All calls from caller to object will be marshaled.</p>

<p><b>Table 8.1</b> <i>In-process server threading model options</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th colspan="4">Caller's apartment  </th></tr>
<tr>
<td valign="top"><b>ThreadingModel value</b>  </td>  
<td valign="top">Main single-threaded apartment </td>
<td valign="top">Single-threaded apartment</td>
<td valign="top">Multi-threaded apartment  </td></tr>
<tr>
<td valign="top" colspan="4">  </td></tr>
<tr>
<td valign="top"><b>Unspecified</b>  </td>
<td valign="top">Main STA  </td>
<td valign="top">Main STA  </td>
<td valign="top">Main STA  </td></tr>
<tr>
<td valign="top"><b>Apartment</b>  </td>
<td valign="top">Main STA   </td>
<td valign="top">Calling STA  </td>
<td valign="top">New STA created  </td></tr>
<tr>
<td valign="top"><b>Free</b>  </td>
<td valign="top">Multi-threaded apartment </td>
<td valign="top">Multi-threaded apartment  </td>
<td valign="top">Multi-threaded apartment  </td></tr>
<tr>
<td valign="top"><b>Both</b>  </td>
<td valign="top">Main STA   </td>
<td valign="top">Calling STA  </td>
<td valign="top">Multi-threaded apartment  </td></tr>
</table></p>


<p>Most applications and components available today either support the
apartment model or are single-threaded (that is, they use the main
STA). Apartment model components offer a nice balance of ease of
development and performance. As discussed in more detail later in this
chapter, MTS provides features to help apartment model components scale
to support large numbers of users.</p>

<A NAME="398"><H2>COM Programming Model</H2></A>

<p>The programming model specified by COM is simple and powerful.
Sometimes it's difficult to see the basic model's simplicity
and elegance underneath all the services built on top of it. So we
won't talk about any of those services here; instead, we'll
focus on the programming model itself.</p>

<A NAME="399"><H3>COM, OLE, and ActiveX</H3></A>

<p>Developers might be more familiar with OLE and ActiveX than with
COM, and might be confused about what technologies these terms refer to
and how they are related. This wouldn't be surprising: Microsoft
has changed its definitions of these terms over the past couple of
years even though the technologies themselves have not changed.
Here's a quick run-down:</p>

<ul>
<p><li> <b>COM</b>  The fundamental component object model, introduced in
1992. The COM specification is available on the Microsoft Web site (at
<a href="http://www.microsoft.com/com/resources/specs.ASP" target="_window2">www.microsoft.com/com/resources/specs.ASP)</a>, and only those items defined in the specification are part of COM proper.</li></p>

<p><li> <b>OLE</b>  Built on top of COM and the mechanism used for
compound documents. An example of using OLE is when a Microsoft Excel
spreadsheet is inserted into a Word document.</li></p>

<p><li> <b>ActiveX</b>  Originally introduced with Microsoft's
COM-based Internet technologies in 1996; essentially a marketing label
used to identify these technologies. Then things got a little crazy,
and everything COM-based got grouped under the ActiveX umbrella. That
just confused everyone. Today some degree of normalcy has returned and
the term ActiveX is used only when referring to ActiveX controls, a
specific technology built on top of COM for programmatic controls. When
developers put a control on a Visual Basic form or embed an
&lt;OBJECT&gt; tag in an HTML page, they use ActiveX controls.</li></p>
</ul>



</BODY>
</HTML>


