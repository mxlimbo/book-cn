<HTML>
<HEAD>
<TITLE>MSF Development Process Model Principles</title>
<link rel="STYLESHEET" type="text/css" href="library.css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04g.htm", "ch04i.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="208"><H1>MSF Development Process Model Principles</H1></A>

<p>The MSF Development Process Model fulfills a key function of project
development by specifying which activities should be performed and
when. The model has two other important aspects: its close relationship
with the MSF Development Team Model and the benefits to the
organization of using them together; and the MSF Development Process
Model's underlying practices and principles. The latter
include:</p>

<ul>

<p><li> Using versioned releases.</li></p>

<p><li> Creating living documents.</li></p>

<p><li> Scheduling for an uncertain future.</li></p>

<p><li> Managing tradeoffs.</li></p>

<p><li> Managing risks.</li></p>

<p><li> Maintaining a fixed ship date mindset.</li></p>

<p><li> Breaking large projects into manageable parts.</li></p>

<p><li> Performing daily builds.</li></p>

<p><li> Using bottom-up estimating.</li></p>

</ul>


<A NAME="209"><H2>Using Versioned Releases</H2></A>

<p>We recommend a product development strategy that divides large
projects into multiple versioned releases, with no separate product
maintenance phase. After the project team establishes a pattern of
making good tradeoff decisions and shipping the right products at the
right time, it's important to begin cycling through versioned
releases as rapidly as possible. Versioned releases enable the project
team to respond to continuous changes in scope, schedule, and project
risk. In the process of frequently updating the product, communication
is maintained with the customer, and the customer's suggestions for
future releases of the product can be taken into consideration.</p>

<p>The team should deliver a core set of features in the first release
and add features incrementally in later releases until the full vision
for the product is achieved. For later versions, the product vision can
be reshaped as business requirements change, and the product can be
updated accordingly.</p>

<p>To summarize, using versioned releases has the following
benefits:</p>

<ul>

<p><li> <b>Communication</b> Promotes frequent and honest communication
between the team and the customer. Each release reflects the best ideas
of everyone involved.</li></p>

<p><li> <b>Earlier delivery</b> Enables the project team to deliver
critical functionality earlier and to obtain feedback from the customer
for future releases. When the customer knows (or senses) that future
product releases will be delivered in a timely manner, the customer is
much more receptive to deferring features to later releases.</li></p>

<p><li> <b>Closure</b> Forces closure on project issues. Using a versioned
release allows the team to deal with a manageable number of issues
during the Stabilizing Phase and to address all the issues before
release.</li></p>

<p><li> <b>Goals</b> Sets clear, motivating goals for all team members.
The team can easily manage each version's scope and quickly achieve
results, so team members see rapid progress. Their role in determining
the schedule helps ensure that their tasks are manageable, specific,
and associated with a tangible result.</li></p>

<p><li> <b>Freedom and flexibility</b> Allows freedom and flexibility in
the design process, enabling the team to be responsive to changes in
the business environment. This freedom and flexibility reduces
uncertainty and helps to manage the changes in project scope by
allowing the team to vary features and schedules in relation to the
overall plan. Features that become critical as a result of business
changes can be designated as high priority for the next release. The
early release becomes stable as the team starts work on the next
one.</li></p>

<p><li> <b>Continuous and incremental feature delivery</b> Dictates a new
set of features immediately following the release of the completed set.
As a result, the team continues to add value for the project's
customer and users.</li></p>

</ul>

<p>In <i>Rapid Development</i>, Steve McConnell explains:</p>

<p><blockquote><i>One of the keys to users and customers agreeing to the
version-2 approach is that they have some assurance that there will in
fact be a version 2. If they fear that the current version will be the
last version ever built, they'll try harder to put all their pet
features into it. Short release cycles help to build the users'
confidence that their favorite feature will eventually make it into the
product.</i></blockquote></p>

<p>Another way to reassure the project's customer and users is to
create a multi-release product plan from the beginning of the project.
This plan involves the articulation of both current <i>and</i> future
versions of the product so that the team and the customer can trust in
the product's future.</p>


<A NAME="210"><H2>Creating Living Documents</H2></A>

<p>Although a sufficient amount of good planning is crucial to project
success, too much planning is harmful. As we've said, an
over-emphasis on planning can create &quot;analysis paralysis.&quot; To
avoid endless spinning in the Planning Phase, the team needs to
establish a baseline in its planning efforts as early as possible, so
that it can move on to developing the solution even if some questions
are left unanswered. On the other hand, because of the ongoing need for
change, planning and other documents should be frozen only when leaving
them unfrozen poses an unacceptable project risk.</p>

<p>This concept of &quot;baseline early, freeze late&quot; is the
essence of creating living documents that change and grow throughout
the development process.</p>

<p>One mark of a mature project team is that it admits when a document
needs to be changed to reflect new or updated information. Another mark
is that it has implemented a good change control process, so that
documents are changed only when necessary.</p>


<A NAME="211"><H2>Scheduling for an Uncertain Future</H2></A>

<p>The future is inherently uncertain. Teams need to address future
uncertainties in project scheduling and management by planning for
them, using two primary approaches: adding buffer time and using
risk-driven scheduling.</p>


<A NAME="212"><H3>Buffer Time</H3></A>

<p>Typically, the project team determines the product's ship date
by simply adding up all the time estimates along the critical path. In
some cases, the team then increases all the estimates by a given
percentage in an attempt to allow for delays. This practice is not the
same as buffer time.</p>

<p>To use an analogy, buffer time is what a military commander gains by
holding back reserve troops to account for variations in the results of
an attack plan. In the world of software development, buffer time is a
period added by Program Management to the end of a project timeline.
Program Management owns the scheduled buffer time and applies it as
needed. As shown in Figure 4.8, this period is not factored into the
individual tasks, and the goal is still to complete the tasks within
the time allotted for them. Buffer time is not an allowance for poorly
defined tasks. In almost all cases, having to use the buffer period
comes at a cost, even if it is nothing more than a required explanation
and justification for using the buffer and a plan for avoiding the
problem that caused the buffer use in the future.</p>

<P><A HREF="javascript:fullSize('f04ar08x.htm')" onMouseOver="window.status='Click to view at full size';return true;" onMouseOut="window.status='';return true;"><IMG SRC="images/f04ar08.jpg" WIDTH=404 HEIGHT=108 BORDER=0 ALT="Click to view at full size"></A></P>
<P><!-- caption --><b>Figure 4.8</b> <i>Critical-path timeline</i><!-- /caption --></P>

<p>The addition of buffer time to the timeline creates two ship dates:
an internal ship date and an external ship date. The internal ship date
is the summation  of the critical-path time estimates, and the external 
ship date is the internal ship date plus the buffer time.</p>


<A NAME="213"><H3>Risk-Driven Scheduling</H3></A>

<p>Risk-driven scheduling assigns a high priority to high-risk tasks
and takes into account risk priorities assigned by the customer. If the
high-risk tasks require more time than planned, risk-driven scheduling
increases the amount of required reaction time. Risk-driven
scheduling:</p>

<ul>

<p><li> Encourages early proof-of-concept prototypes.</li></p>

<p><li> Determines which features will be shipped and when.</li></p>

<p><li> Prioritizes tasks based on technical and business risk.</li></p>

<p><li> Encourages developers to aggressively shoot for the early
deadline.</li></p>

<p><li> Signals a warning if the early deadline is missed, pinpointing
the need to make adjustments and tradeoffs earlier.</li></p>

<p><li> Gives the customer a better view of the riskier areas of the
project and manages customer expectations in a more productive
manner.</li></p>

</ul>


<A NAME="214"><H2>Managing Tradeoffs</H2></A>

<p>In <i>Dynamics of Software Development</i>, Jim McCarthy confirms
that every project balances three critical elements:</p>

<p><blockquote><i>&#8230;you're working with only three things:</i> resources<i> (people and money),</i> features <i>(the product and its quality), and</i> the schedule. <i>This triangle of elements is all you work with. There's
nothing else to be worked with. And changing one side of the triangle
has an impact on at least one other side, usually two.</i></blockquote></p>

<p>The relationship between these three variables tends to be hazy at
the beginning of the development process. At that point, the team has a
rough idea of what to build, an estimate of available resources, and an
approximate target delivery date. During the Planning Phase, the
project elements represented in the triangle become more distinct. By
the time the Planning Phase is complete, the team knows the nature of
available resources, the product features, and the fixed ship date.</p>

<p>It's important to keep in mind that the three variables are
interrelated. Changes on one side of the tradeoff triangle affect the
other two sides. If the team understands and utilizes this concept, the
team has both the rationale and the motivation to take corrective
action as changes occur during development.</p>

<p>For example, suppose that a triangle shows that 10 resources will
deliver 20 features by June 1. During the development process, the
customer discovers a new critical feature that was not included in the
original Functional Specification. Adding this new feature to the
triangle creates an imbalance in the other sides. As noted in Figure
4.9, the team must correct this imbalance by dropping features, adding
resources, changing the ship date, or some combination of all three
actions.</p>

<P>
<IMG SRC="images/f04ar09.jpg" WIDTH=285 HEIGHT=227 BORDER=0>
</P><P>
<!-- caption --><b>Figure 4.9</b> <i> Unbalanced tradeoff triangle</i><!-- /caption -->
</P>

<p>The power of the triangle lies in its simplicity. It's simple
enough that it can be drawn on a napkin during lunch with a customer to
explain the types of tradeoffs that must occur in order for the project
to succeed.</p>

<p>Although the triangle is a simple and effective tool, it does not
convey the project's priorities with regard to the three variables.
One way to document these priorities and to manage the expectations of
the team and the customer is to create a tradeoff matrix like the ones
shown in Table 4.1 for the project variables and the levels of
constraint. This matrix allows the team and the customer to indicate
the manner in which tradeoffs should occur.</p>

<p><b>Table 4.1</b> <i>Sample Tradeoff matrixes</i></p>

<p>
	<table cellpadding=5 width="95%">
	
		<tr>
			<th colspan="4">Project 1</th>
			<th colspan="4">Project 2</th>
		</tr>

		<tr>
			<td valign="TOP">&nbsp;</td>
			<td valign="TOP" align="center"><b>Optimize</b></td>
			<td valign="TOP" align="center"><b>Constrain</b></td>
			<td valign="TOP" align="center"><b>Accept</b></td>
			<td valign="TOP">&nbsp;</td>
			<td valign="TOP" align="center"><b>Optimize</b></td>
			<td valign="TOP" align="center"><b>Constrain</b></td>
			<td valign="TOP" align="center"><b>Accept</b></td>
		</tr>

		<tr>
			<td valign="TOP"><b>Resources</b></td>
			<td valign="TOP">&nbsp;</td>
			<td valign="TOP" align="center"><b>X</b></td>
			<td valign="TOP">&nbsp;</td>
			<td valign="TOP"><b>Resources</b></td>
			<td valign="TOP" align="center"><b>X</b></td>
			<td valign="TOP">&nbsp;</td>
			<td valign="TOP">&nbsp;</td>
		</tr>

		<tr>
			<td valign="TOP"><b>Ship Date</b></td>
			<td valign="TOP" align="center"><b>X</b></td>
			<td valign="TOP">&nbsp;</td>
			<td valign="TOP">&nbsp;</td>
			<td valign="TOP"><b>Ship Date</b></td>
			<td valign="TOP">&nbsp;</td>
			<td valign="TOP">&nbsp;</td>
			<td valign="TOP" align="center"><b>X</b></td>
		</tr>

		<tr>
			<td valign="TOP"><b>Features</b></td>
			<td valign="TOP">&nbsp;</td>
			<td valign="TOP">&nbsp;</td>
			<td valign="TOP" align="center"><b>X</b></td>
			<td valign="TOP"><b>Features</b></td>
			<td valign="TOP">&nbsp;</td>
			<td valign="TOP" align="center"><b>X</b></td>
			<td valign="TOP">&nbsp;</td>
		</tr>

	</table>
</p>

<p>Working together, the team and the customer select an exclusive
level of constraint for each of the project variables. No row or column
in the project tradeoff matrix may have more than one check mark,
because hybrid combinations pose serious risks to the project and must
be accounted for explicitly in the risk management plan. The columns
are defined as follows:</p>

<ul>

<p><li> <b>Optimize</b> The optimized variable is the one that should be
as good as possible at the end of the project. To optimize resources is
to seek the lowest possible allocation of resources (minimum cost
strategy). To optimize the ship date is to seek the earliest possible
ship date (early to market strategy). To optimize features is to seek
the most complete product possible (maximum benefit strategy).</li></p>

<p><li> <b>Constrain</b> The constrained variable has been assigned a
fixed value. To constrain resources is to set a ceiling for them (not-to-exceed
strategy). To constrain the ship date is to time-box the project (not before
and not after strategy). To constrain features is to ship at least the
essential set of functionality (minimal acceptable benefit
strategy).</li></p>

<p><li> <b>Accept</b> When one variable has been constrained and another
optimized, the third variable must simply be accepted. To accept
resources is to acknowledge that the product will take whatever
resources it takes (time and materials strategy). To accept the ship
date is to acknowledge that the product won't ship before it's
finished (it's done when it's done strategy). To accept
features is to achieve one or more of the other project tradeoffs by
dropping features immediately before the ship date (it's done when
it ships strategy). The check mark in the &quot;accept&quot; column
designates the variable that is owned by the team and ensures that the
team is empowered to manage change and risk, and is therefore
positioned to succeed, not fail. For example, if the customer says that
the feature set must be as rich as possible (features are optimized)
and that the project must be done by a certain date (the ship date is
constrained), the customer needs to give the team whatever resources
are necessary to meet those two conditions (resource costs are
accepted).</li></p>

</ul>

<p>The team should use the tradeoff matrix as a reference when making
decisions. The matrix is not intended to show absolute priorities; it
is merely a tool to facilitate communication and understanding. Most
important for the project team is that the matrix defines areas in
which the customer is willing to compromise.</p>


<A NAME="215"><H2>Managing Risk</H2></A>

<p>For most projects, the ability to manage risk is the key to project
success. For a project team to be successful, it must:</p>

<ul>

<p><li> Learn from its environment.</li></p>

<p><li> Adapt to the environment rapidly.</li></p>

<p><li> Predict accurately what will happen next.</li></p>

<p><li> Take actions based on the above.</li></p>

</ul>

<p>When the team understands and implements actions that minimize
uncertainty and maximize stability and predictability, it can operate
equally well in either a volatile or a stable environment. Preparedness
for uncertain events is the goal of risk assessment and management.</p>

<p>There are two inherently different approaches to managing risk. Most
teams practice <i>reactive</i> risk management; that is, they react in
some way after the risk has already caused a problem. We advocate
practicing <i>proactive</i> risk management, which we discuss in detail
in <A HREF="ch05a.htm">Chapter 5</A>. Proactive risk management means that the team has a
visible process for managing risks before they are realized.</p> 

<p>The process should also be measurable and repeatable. With proactive risk
management, risks are assessed continuously, and this assessment
information is used to make decisions in all phases of the project. The
risks are then carried forward until they are resolved or, if they
emerge as problems, until they are handled.</p>


<A NAME="216"><H2>Maintaining a Fixed Ship-Date Mindset</H2></A>

<p>A fixed ship-date mindset means that the team treats its projected
ship date as unchangeable. Essentially, the team builds the project
schedule and then agrees that the schedule side of the triangle is
fixed in place. Once the ship date is fixed, the team cannot use this
side of the triangle for making corrective decisions unless there are
no other options available.</p>

<p>Adopting a fixed ship-date mindset has the following advantages:</p>

<ul>

<p><li> <b>Forces creativity</b> Creativity is necessary to implement
features in as timely a manner as possible, because the option of
delaying the ship date has been removed.</li></p>

<p><li> <b>Prioritizes tasks according to importance</b> Features are
prioritized so that lower priority features can be dropped if necessary
to ship on time. If features must be dropped in order to make the ship
date, the features that are most important to the customer will be
delivered.</li></p>

<p><li> <b>Empowers the team by providing an effective decision-making
tool</b> The team makes decisions on the basis of how they will affect
the ability to deliver on the fixed ship date.</li></p>

<p><li> <b>Provides a motivational goal for the team</b> A constantly
slipping ship date creates team morale problems and can ultimately lead
to a developmental &quot;death march,&quot; in which team members lose
interest in a project because it seems as if the product will never
ship.</li></p>

</ul>

<p>The team arrives at a fixed ship date through bottom-up estimation
and the use of buffer time. This estimation process is fundamental to
the success of implementing a fixed ship date mindset, because the team
must be willing to commit to the date as a realistic and achievable
goal.</p>


<A NAME="217"><H2>Breaking Large Projects into Manageable Parts</H2></A>

<p>For large projects or complex projects, the feature set should be
broken up into smaller, somewhat independent pieces. These pieces
should then be treated as internal releases or subprojects. This
process can be thought of as versioned releases within a single
project, where only the final version is released at the end of the
project life cycle.</p>

<p>Teams can spend approximately two to four months on an internal
release. Each release has time allocated for feature development,
optimization, testing, and stabilization. In addition, approximately
one-third of the total development time is added as buffer time for
unplanned contingencies.</p>

<p>For each internal release, Development delivers a cluster of
features for testing. Assuming that the release is testable, the team
goes through a full test/debug/retest cycle, as if it was going to ship
the product with just these features. When the code meets or exceeds
the quality bar for the internal release, the team can proceed to
develop the next set of features. This internal-release approach also
helps solve the significant problems that can arise when applications
are integrated only in the late stages of product development.</p>

<p>Breaking a large project into subprojects:</p>

<ul>

<p><li> Allows the team to focus on delivering a smaller and more easily
definable aspect of the project.</li></p>

<p><li> Provides a sense of completion for the team as it achieves each
internal release milestone.</li></p>

<p><li> Provides early warning signs of project health, because each
internal release milestone is an assessment point with its own
postmortem review. If internal releases slip, then the team can take
corrective action earlier to keep the larger project on track.</li></p>

<p><li> Increases the overall quality of the product, because each
internal release has its own quality bar.</li></p>

<p><li> Allows the team to practice shipping with each internal release
so that the actual shipping of the product at the end of the project is
more predictable.</li></p>

</ul>

<p>In <i>Debugging the Development Process</i> (Microsoft Press, 1994),
Steve Maguire states:</p>

<p><blockquote><i>It's not the two-month period alone that creates the
wins and fosters enthusiasm. It's the thrill of finishing an
interesting subproject.</i> 

<p><i>&quot;Finishing all top-priority items&quot; may be important, but
the top-priority items don't make up a subproject. They're just
a random list of things that happen to be important. There's no
motivating theme behind such a list.</i></p>

<p><i>For example, &quot;Implementing the charting subsystem&quot; is a
subproject. All of the tasks that would be involved would relate to
that common theme. You might use a task list to remind people of the
known charting issues they'd have to handle, but ultimately the
theme of the subproject would drive development. The goal wouldn't
be for the team to finish 352 unrelated tasks. The goal would be to do
everything necessary to fully complete&#8212;to
&quot;ship&quot;&#8212;the charting subsystem, regardless of whether the
tasks it would take were on a list somewhere. The subproject would be
in &quot;ship mode&quot; from the outset.</i></p>
</blockquote></p>


<A NAME="218"><H2>Performing Daily Builds</H2></A>

<p>A typical software development project involves &quot;building&quot;
an executable program from up to thousands of different files. Some
software development teams practice the &quot;daily build and smoke
test&quot; process in which they compile every file, combine them into
a single executable program, and put the program through a smoke test,
or simple coverage test, to see if it runs. The smoke test is a
quick-pass test of the entire system to expose any major problems. The
daily build is not valuable unless accompanied by a smoke test. We
discuss coverage testing further in <A HREF="ch12a.htm">Chapter 12</A>.</p>

<p>Performing daily builds and smoke tests provides a number of
important benefits including:</p>

<ul>

<p><li> Minimizing code integration risk by identifying incompatible code
early and allowing the team to make debugging or redesign
decisions.</li></p>

<p><li> Supporting improved defect diagnosis, making it easier to
pinpoint why the product may be broken on any single day.</li></p>

<p><li> Reducing the risk of low quality.</li></p>

</ul>

<p>The daily build and smoke test must be performed each day&#8212;not
weekly or monthly&#8212;to produce the greatest benefits. The software
being built must work; otherwise, the build is viewed as broken, and it
must be fixed. Performing daily builds and smoke tests is like trying
to ship a product every day, which enforces a sense of discipline.</p>

<p>Standards for daily builds and smoke tests vary from project to
project, but at a minimum the standards should include:</p>

<ul>

<p><li> Compiling all files and components successfully.</li></p>

<p><li> Linking all files and components successfully.</li></p>

<p><li> Finding no &quot;showstopper&quot; bugs that would make the
program hazardous to operate or prevent it from launching.</li></p>

<p><li> Passing the smoke test.</li></p>

</ul>


<A NAME="219"><H2>Using Bottom-Up Scheduling</H2></A>

<p>Simply put, those who will be doing the work should schedule the
work.</p>

<p>Two fundamental benefits result from requiring the individuals who
actually perform the work to develop their own work estimates are:</p>

<ul>

<p><li> <b>Accuracy</b> The estimates tend to be more accurate because
they are based on experience. A person asked to perform a particular
task is expected to have previous experience in executing this or other
similar tasks.</li></p>

<p><li> <b>Accountability</b> Because team members have developed their
own estimates, they are more accountable for the success of meeting
those estimates. Initial estimates may be high, but with milestone
reviews, project knowledge, and also estimating practice, the estimates
will begin to more accurately reflect the tasks and will provide the
right task-level motivation.</li></p>

</ul>

<p>As shown in Figure 4.10, the estimating process is the
responsibility of the entire team. As the low-level estimates are
rolled up into the Master Project Schedule, buffer time is added to
ensure that the schedule is attainable. It's this technique that
makes the fixed ship-date mindset possible.</p>

<P><A HREF="javascript:fullSize('f04ar10x.htm')" onMouseOver="window.status='Click to view at full size';return true;" onMouseOut="window.status='';return true;"><IMG SRC="images/f04ar10.jpg" WIDTH=404 HEIGHT=269 BORDER=0 ALT="Click to view at full size"></A></P>
<P><!-- caption --><b>Figure 4.10</b> <i> Bottom-up scheduling</i><!-- /caption --></P>


</BODY>
</HTML>


