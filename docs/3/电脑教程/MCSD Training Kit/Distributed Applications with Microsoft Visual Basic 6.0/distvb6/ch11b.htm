<HTML>
<HEAD>
<TITLE>Lesson 1: Handling Errors in an Application</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch11a.htm", "ch11c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="416"><H1>Lesson 1: Handling Errors in an Application</H1></A>

<P>When you create the presentation layer in an n-tier application, you will often use Microsoft Visual Basic forms to interact with end-users. It is important to handle errors that can occur in your front-end applications to allow the program to exit gracefully, allow users to save work, and to possibly provide directions to users to allow them to fix a problem and continue working.</P>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson you will be able to:</b>
<ul>

<p><li>Use the Locals and Immediate window to check or change values.</li></p>

<p><li>Set watch expressions using the Watch window.</li></p>

<p><li>Create an error handler in a procedure.</li></p>

</ul>
<b>Estimated lesson time: 20 minutes</b>
</blockquote></div>
</p>

<A NAME="417"><H2>Using Visual Basic Debugging Tools</H2></A>

<P>Sometimes errors, commonly referred to as bugs, can occur within your code. Minor bugs are frustrating and inconvenient. More severe bugs can cause an application to stop responding to commands, possibly requiring the user to restart the application and, as a result, lose whatever work has not been saved. In a Visual Basic program, three different types of errors can occur:</P>
<ul>
<p><li>Syntax errors</li></p>

<p>Syntax errors occur in code when a statement is constructed incorrectly. Examples of syntax errors include an incorrectly typed keyword, omission of required punctuation, or an incorrect construct (such as an If keyword on a line without a condition).</p>

<p><li>Run-time errors</li></p>

<p>Run-time errors occur while the application is executing. Visual Basic detects run-time errors when the statement attempts an operation that is impossible to carry out. Run-time errors are especially important to plan for since the user can detect them.</p>

<p><li>Logic errors</li></p>

<p>Logic errors occur when your code does not perform the way that you intended. These errors can be especially difficult to find because an application can run without performing any invalid operations and still produce incorrect results. The way to verify that your application does not have logic errors is to run test data through the program and analyze the results. Logic errors, like run-time errors, can occur when the user is interacting with the application.</p>
</ul>

<P>To fix errors in your application, you can use Visual Basic debugging tools such as the Immediate window, Locals window, and Watch window.</P>

<A NAME="418"><H3>Using the Immediate Window</H3></A>

<P>When you are debugging your application, there might be times when you want to evaluate expressions, change the value of variables, or execute different procedures. You can use the Immediate window, illustrated in Figure 11.1, to accomplish all of these tasks.</P>

<P>
<img src="images/F11xx01.GIF" width=328 height=165 border="0">
</P><P>
<!--caption--><b>Figure 11.1</b> <i>The Immediate window</i><!--/caption-->
</P>


<P>You use the Immediate window to evaluate any valid Visual Basic statement. However, the Immediate window does not accept data declarations. When you type a statement and press ENTER, Visual Basic switches to run-time mode to execute the statement, and then returns to break mode. At that point, you can see the results and test any possible effects on variables or property values. In addition to executing a statement in the Immediate window, you can examine data by printing values directly in the Immediate window while in break mode. Use the Print statement to view the value of a variable. You can also use a question mark for shorthand. </P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>
? EmployeeID
? txtFirstName.Text</PRE>
</TD></TR></TABLE>
</P>

<P>When in break mode, you can set values in the Immediate window:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>
EmployeeID = 9
txtFirstName.Text = &quot;Nancy&quot;</PRE>
</TD></TR></TABLE>
</P>

<P>Once the values of one or more properties or variables are changed, you can resume execution to see the results. It is important to understand that when a variable, or property value, is changed, it will contain this new value even after you resume execution of the program. </P>

<A NAME="419"><H3>Using the Locals Window</H3></A>

<P>The Locals window shows the value of all variables that are within the scope of the current procedure. As the execution of your program goes from procedure to procedure, the information shown in the Locals window changes to only the variables that are used in the current procedure. For example, you would use the Locals window to monitor how all your values change as you run the code. To access the Locals window, select Locals Window from the View menu or from the Debug toolbar. When the Locals window (illustrated in Figure 11.2) is visible, it is automatically updated every time your program changes from run mode to break mode or when you navigate in the Call Stack dialog box.</P>

<P>
<A HREF="javascript:fullSize('F11xx02x.htm')"> <img src="images/F11xx02.JPG" width=404 height=125 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 11.2</b> <i>The Locals window</i><!--/caption-->
</P>


<P>The Call Stack button, which is the button with the ellipsis, opens the Call Stack dialog box. The Call Stack dialog box lists the procedures in the call stack. </P>

<P>The Expression column lists the name of the variables. The first variable in the list &lt;Me&gt; is a special module variable and can be expanded to display all module level variables and properties of objects within the current scope. You cannot access global variables and variables in other projects from the Locals window.</P>

<P>The Value column lists the value of each of the variables and properties. When you select an item and click on its value in the Value column, the cursor changes to an I-beam, allowing you to edit the value. Once you have changed a value, press the ENTER<B> </B>key or move to another field to validate the change. You can cancel a change that you made by pressing ESC. Within the Value column, all numeric variables must have a value listed. String variables can have an empty Value list. </P>

<A NAME="420"><H3>Using the Watch Window</H3></A>

<P>As you work through debugging your application, a calculation might not produce the desired result, or problems might occur when a certain variable or property assumes a particular value. Not all debugging problems are immediately traceable to a statement, so sometimes you might need to observe the value of a variable or expression throughout a procedure. In this case, you define a watch expression, or expression whose value you want to monitor. Visual Basic can automatically monitor the watch expressions that you define. When your application enters break mode, these watch expressions appear in the Watch window, where you can observe their values.</P>

<P>You can also set watch expressions that put your application into break mode whenever the expression's value changes or equals a specified value. These are sometimes called break expressions. Break expressions are extremely helpful when you are debugging a section of your code that uses a large number of iterations. For example, instead of stepping through a loop in your program one statement at a time, you can set a watch expression to put your application into break mode when a counter variable reaches a certain value.</P>

<P>You can add Watch expressions at design time or while your application is in break mode using the Add Watch dialog box, illustrated in Figure 11.3.</P>

<P>
<img src="images/F11xx03.GIF" width=384 height=277 border="0">
</P><P>
<!--caption--><b>Figure 11.3</b> <i>The Add Watch dialog box</i><!--/caption-->
</P>


<P>The first component of the Add Watch dialog box is the Expression box. This is where you enter the expression to be evaluated. The expression can be a variable, a property, a function call, or any other valid expression. </P>

<P>The second component is the Context option group. These options allow you to set the scope of variables watched in the expression. You should use the Context option if you have variables of the same name with different scope. This will then allow you to restrict the scope of variables in watch expressions to a specific procedure or to a specific form or module. You can also apply the watch expression to the entire application by selecting All Procedures and All Modules. </P>

<P>The third component is the Watch Type option group. This sets how Visual Basic responds to the watch expression. The Watch Expression option displays the expression's value in the Watch window when the application enters break mode. The other two options have the application enter break mode automatically when the expression evaluates to a True (nonzero) statement or each time the value of the expression changes.</P>

<p><li><b> To add a watch expression</b></li></p>

<ol>
<p><li>On the <B>Debug</B> menu, click <B>Add Watch</B>.</li></p>

<p><li>Enter the expression that you want to evaluate in the <B>Expression</B> box.</li></p>

<p><li>Use the <B>Context</B> options if you need to set the scope of the variables to watch.</li></p>

<p><li>Select an option in the <B>Watch Type</B> group to determine how you want Visual Basic to respond to the watch expression.</li></p>

<p><li>Click <B>OK</B>.</li></p>
</ol>

<P>The Edit Watch dialog box lists all of your current watch expressions. You can use this dialog box to edit and delete any watch expression listed in the Watch window.</P>

<p><li><b> To edit a watch expression </b></li></p>

<ol>
<p><li>In the <B>Watch</B> window, click the watch expression you want to edit.</li></p>

<p><li>Double-click the watch expression or, on the <B>Debug</B> menu, click <B>Edit Watch</B>. </li></p>

<p>The Edit Watch dialog box appears.</p>

<p><li>Make any changes to the expression, the scope for evaluating variables, or the watch type.</li></p>

<p><li>Click <B>OK</B>.</li></p>
</ol>

<A NAME="421"><H2>Creating Error Handlers</H2></A>

<P>When Visual Basic encounters a run-time error, it checks to see whether an error handler has been enabled. If it has not, Visual Basic automatically presents the user with a message box showing the error number and a brief description. Unfortunately, when the user clicks OK to this message, the Visual Basic program immediately terminates. The program ignores the code in an Unload event that might have queried the user to first save his or her changes. For this reason, allowing Visual Basic to automatically handle run-time errors is not recommended. </P>

<P>Instead, you should write code to handle errors, called error handlers, in your applications. Error handlers are specific to individual procedures, which means that each event or general procedure you create should have its own error handler. There are three basic steps in creating an error handler:</P>

<ol>
<p><li>Enable an error handler.</li></p>

<p><li>Add code to handle the possible errors.</li></p>

<p><li>Resume normal execution of the program.</li></p>
</ol>

<A NAME="422"><H3>Enabling an Error Handler</H3></A>

<P>The first step in controlling run-time errors is to enable an error handler. Every procedure should include an error handler of some kind. To enable an error handler, use the On Error GoTo statement and provide the name of a label in your procedure. The label marks a point in code that you want Visual Basic to jump to when a run-time error occurs. Labels follow the same naming rules as variables. However, you must add a colon to the end of the name. In addition to providing a label name in the On Error GoTo statement, you can use the On Error GoTo 0 statement to disable an error handler in the current procedure. The following example enables an error handler called OpenError:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>
Private Sub cmdOpenFile_Click()
     On Error GoTo OpenError
     ' Code to open a file
     Exit Sub
OpenError:
     ' Code to handle an error goes here
End Sub</PRE>
</TD></TR></TABLE>
</P>

<P>Visual Basic does not stop executing when it reaches a label. If you do not tell Visual Basic to exit the procedure, the error handler code executes even when there is no run-time error. Use the Exit Sub or Exit Function statement before the start of an error handler to avoid this problem.</P>

<A NAME="423"><H3>Writing Error Handling Code</H3></A>

<P>The second step in creating an error handler is to add code under the label to manage the potential errors that could occur. You can use Visual Basic's Err object to determine the specific error. The Err object's Number property provides the Visual Basic error code. Use this property to have your application prompt the user to take corrective action, such as when a floppy disk is not present, or to proceed with an orderly shutdown when a critical error occurs. If you want the user to see a description of the error, use the Description property of the Err object.</P>

<P>The following example uses the Err object to determine what error occurred:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>
ErrorHandler:
Select Case Err.Number
     Case 53
         ' File not found
         MsgBox Err.Description
         MsgBox &quot;Please enter a valid filename.&quot;
     Case Else
         ' An unplanned error occurred
         MsgBox &quot;The following error occurred: &quot; &amp; Err.Description
End Select</PRE>
</TD></TR></TABLE>
</P>

<P>Instead of setting up an error handler that you branch to, you might want to check for an error immediately after executing a statement that could cause an error. When you check for errors in this way, you are performing <I>inline error handling</I>. Inline error-handling code does not contain labels or Resume statements.</P>

<p><li><b> To handle an error inline, follow these steps:</b></li></p>

<ol>
<p><li>Include the On Error Resume Next statement in your code.</li></p>

<p><li>Check the value of Err.Number after each statement that might have an error.</li></p>

<p><li>Use Err.Clear to clear the Err object.</li></p>
</ol>

<P>You can use inline error handling to test whether or not the Shell function failed, as shown in the following code:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>
Dim strAppName As String

On Error Resume Next
strAppName = InputBox(&quot;To run the Calculator type 'calc'. &quot; &amp; _
     &quot;To run Notepad type 'notepad'.&quot;)

' Use the Shell function to run an application
Shell strAppName, vbNormalFocus

' Check for an error
If Err.Number &lt;&gt; 0 Then
     MsgBox &quot;Unable to find &quot; &amp; strAppName &amp; _
         vbCrLf &amp; &quot;Run-time error.  Number &quot; &amp; Err.Number
End If</PRE>
</TD></TR></TABLE>
</P>

<A NAME="424"><H3>Resuming Execution</H3></A>

<P>When the error has been handled by using the On Error GoTo statement, the final step is to resume execution of the application. There are three ways to return control:</P>
<ul>
<p><li>Retry the line of code that caused the initial error.</li></p>

<p><li>Start from the line immediately following the one that caused the error.</li></p>

<p><li>Terminate the application.</li></p>
</ul>

<P>If the error handler prompted the user to correct the problem, such as asking the user to insert a floppy disk into the drive, you might want the application to retry the operation that initially failed. To have Visual Basic retry the line of code that failed, use the Resume keyword. To skip the line of code that caused the error and continue executing your program, use the Resume Next statement. The final option is to close the form and exit the program by calling Unload Me, which ensures an orderly shutdown. In the following example, the error handler prompts the user to retry the operation, ignore the problem, or exit the application:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>
ErrorHandler:
Answer = MsgBox(&quot;An error occurred. &quot;, vbAbortRetryIgnore)
Select Case Answer
     Case vbRetry
         Resume
     Case vbIgnore
         Resume Next
     Case vbAbort
         Unload Me
End Select</PRE>
</TD></TR></TABLE>
</P>

<A NAME="425"><H3>Visual Basic Error Handling Options</H3></A>

<P>When testing error handlers, you might want to control how Visual Basic manages errors at design time by using one of the following error trapping options:</P>
<ul>
<p><li>Break on All Errors</li></p>

<p>Any error causes the project to enter break mode, whether or not an error handler is active and whether or not the code is in a class module.</p>

<p><li>Break in Class Module</li></p>

<p>Any unhandled error produced in a class module causes the project to enter break mode at the line of code in the class module that produced the error. </p>

<p>When you debug a COM DLL or COM EXE project by running a client test program in another project, use this option. Set this option in the component project to break on errors in its class modules instead of always returning the error to the client test program.</p>

<p><li>Break on Unhandled Errors</li></p>

<p>If an error handler is active, the error is trapped without entering break mode. If there is no active error handler, the error causes the project to enter break mode. An unhandled error in a class module, however, causes the project to enter break mode on the line of code that invoked the offending procedure of the class. </p>
</ul>

<p><li><b> To access the Visual Basic options for error handling</b></li></p>

<ol>
<p><li>On the <B>Tools </B>menu, click <B>Options</B>.</li></p>

<p><li>Click the <B>General</B> tab.</li></p>

<p><li>Select the appropriate error-handling option.</li></p>
</ol>

<A NAME="426"><H2>Lesson Summary </H2></A>

<P>You will sometimes make mistakes when you develop your applications. Visual Basic's debugging tools help you fix these problems. You can use the Immediate window when you are debugging your application to evaluate expressions, change the value of variables, or execute different procedures. You can also use the Locals window to view the values of all variables that are within the scope of the current procedure. You can change the value of a variable by selecting an item and then clicking on its value in the Value column.</P>

<P>You can also specify logical expressions or variables that you want Visual Basic to monitor. When your application enters break mode, these watch expressions appear in the Watch window, where you can observe their values.</P>

<P>Unhandled run-time errors can cause your application to terminate and potentially cause the user to lose data. Therefore, allowing Visual Basic to automatically handle run-time errors is not recommended. Instead, you should write code to handle errors, called error handlers, in your applications. Error handlers are typically included with each event or general procedure, which means that each event or general procedure you create should have its own error handler. Errors can be managed using the On Error GoTo statement. You can also manage errors using inline error handling.</P>

</BODY>
</HTML>



