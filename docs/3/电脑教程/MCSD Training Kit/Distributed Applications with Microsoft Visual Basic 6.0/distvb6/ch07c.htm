<HTML>
<HEAD>
<TITLE>Lesson 2: Using Disconnected Recordsets</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07b.htm", "ch07d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="278"><H1>Lesson 2: Using Disconnected Recordsets</H1></A>

<P>As you learned in Chapter 5, &quot;<A HREF="ch05a.htm#194">Introducing ActiveX Data Objects</A>,&quot; the ADO Recordset object provides methods for manipulating result sets, and allows you to add, update, delete, and scroll through records in the recordset. If the provider supports it, you can create a recordset and then disconnect from the data source. The Recordset will reside in a client cache and will no longer have a live connection to the server. Later, you could re-establish the connection if you need to do something with the original data source, such as updating data. This type of recordset is called a <I>disconnected recordset</I>.</P>

<P>Caching data on a client workstation can reduce network traffic and improve performance. For example, your application may use a large client-side result set. Instead of having a large number of requests for data from the client-side application to the server, you work with the data locally without having to send requests across the network, improving both the actual performance and the perceived performance of the client-side application. Furthermore, you can open and populate a disconnected Recordset object asynchronously. This improves performance by leaving the client free to execute other tasks while records are still being returned.</P>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson you will be able to:</b>
<ul>

<p><li>Describe the difference between client and server-side cursors.</li></p>

<p><li>Create disconnected recordsets.</li></p>

<p><li>Persist data from a disconnected recordset.</li></p>

<p><li>Modify data while disconnected from a data source.</li></p>

<p><li>Reconnect and update a data source.</li></p>

</ul>
<b>Estimated lesson time: 60 minutes</b>
</blockquote></div>
</p>

<A NAME="279"><H2>Specifying the CursorLocation Property</H2></A>

<P>When a Recordset object is created, specific records based on a SQL query are returned. A Recordset object uses a cursor mechanism to return records and to define how ADO can access and use these records. A cursor also indicates the current position in the recordset, just as the cursor on a computer display indicates the current position on the screen. You can specify four types of cursors: static, dynamic, keyset, and forward-only, as you learned in Chapter 5, &quot;<A HREF="ch05a.htm#194">Introducing ActiveX Data Objects</A>.&quot; You can also specify two different cursor locations: server-side and client-side. The size of the cursor and the capabilities of the server data source determine which location is preferable. </P>

<P>Every cursor uses temporary resources to hold its data. These resources can be memory, a disk paging file, temporary disk files, or even temporary storage in the database. The cursor is called a <I>client-side cursor</I> when the resources are located on the client machine and a <I>server-side cursor</I> when the resources are located on the server machine.</P>

<A NAME="280"><H3>Server-Side Cursors</H3></A>

<P>Server-side cursors are the default in ADO. To explicitly specify the creation of a server-side cursor, set the CursorLocation property of the Recordset object to adUseServer. If a server-side cursor is created, the values of the records contained in the recordset are stored on the server. </P>

<P>Using a server-side cursor can increase an application's performance since the overhead on the client is limited and the amount of network traffic is reduced. Server-side cursors also permit more than one operation on the connection. When you create the cursor, you can use the same connection to make changes to the rows without having to establish an additional connection to handle the underlying update queries.</P>

<P>Server-side cursors are best used when you are inserting, updating, or deleting records. Server-side cursors also allow you to have multiple active statements on the same connection. However, a server-side cursor consumes server resources for every active client. You must plan for this to ensure that your server is able to manage server-side cursors used by clients. The following list includes some advantages to using server-side cursors:</P>

<ul>
<p><li>Memory usage</li></p>

<p>Less client resources are used because data is not chached on the client. The server, no the client, maintains information about the cursor position. </p>

<p><li>Performance</li></p>

<p>Less network traffic occurs with a server-side cursor if a small amount of data in the recordset is used. This is also true if data is accessed infrequently. </p>

<p><li>Additional cursor types</li></p>

<p>Client-side cursors limit the types of cursors you can use; however, server-side cursors allow you to use both keyset and dynamic cursors.</p>

<p><li>Positioned updates</li></p>

<p>Server-side cursors support direct positioned updates, which are fast, and avoid the risk of unintended update collisions.</p>
</ul>

<A NAME="281"><H3>Client-Side Cursors</H3></A>

<P>If the data source you are connecting to does not support server-side cursors, then you must create a client-side server. With a non-keyset client-side cursor, the server sends the whole recordset to the client across the network. The client computer will temporarily provide and manage resources used by the cursor and recordset, and the client-side application can browse the recordset.</P>

<P>If a large number of rows (or records) are returned, static and keyset-driven client-side cursors place a significant load on a workstation. All cursor libraries are capable of building cursors with thousands of records. A <I>fetch</I> is an operation that retrieves a record or group of records from a cursor. Applications designed to fetch a large recordset may perform poorly. If performance is not an issue, using a large client-side cursor may be appropriate.</P>

<P>A benefit of using a client-side cursor is that it provides a faster response. After the recordset has been cached on the client computer, record browsing is very fast because data does not have to be transported across the network. In addition, your application is generally more scalable when it implements client-side cursors. This is because the resource requirements for the cursor are placed on each individual client instead of the server.</P>

<A NAME="282"><H3>Client-Side Cursors and Disconnected Recordsets</H3></A>

<P>A disconnected Recordset is a Recordset without a live connection to a database server. You can create a disconnected Recordset using the CursorLocation property of a Recordset object. The CursorLocation property allows you to specify whether to use client or server cursors and, most importantly, allows changes to be made in a batch mode. When you specify adUseClient for the CursorLocation property, you can make any updates for the disconnected Recordset in a batch mode and use the client cursor to cache the unique identification for the Recordset. The following example demonstrates how to create a disconnected Recordset by specifying the CursorLocation property:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Dim cn As New ADODB.Connection
Dim rs As New ADODB.Recordset

With cn
    .Provider = &quot;SQLOLEDB&quot;
    .ConnectionString = &quot;User ID=sa;&quot; &amp; _
        &quot;Data Source=VB6ENTSVR;&quot; &amp; _
        &quot;Initial Catalog=Pubs&quot;
    .Open
End With
rs.CursorLocation = adUseClient
rs.Open &quot;SELECT * FROM authors for browse&quot;, cn, _
    adOpenUnspecified, adLockUnspecified, adCmdUnspecified
</pre></td></tr></table></p>
	
<A NAME="283"><H2>Disconnecting from a Data Source</H2></A>

<P>Setting the recordset's ActiveConnection property to Nothing disconnects the recordset from the active connection. Your application can then close the active Connection object using the Close method. If the adUseClient parameter was used with the Open method, the client will have a copy of the recordset data and can begin navigating or updating the records. The following example closes the connection and disconnects from the data source:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Set rs.ActiveConnection = Nothing
cn.Close
</pre></td></tr></table></p>

<P>Once a recordset has been disconnected from the data source, your application can use any of the data update and navigation techniques. For example, you can add new records using the AddNew method, delete records using the Delete method, and change existing records using the Update method. However, all changes are cached on the client until the connection is re-established.</P>

<A NAME="284"><H3>Persisting Data</H3></A>

<P>A recordset's contents can be saved (<I>persisted</I>) to a file. Because you can persist a recordset, you can close an application and return to it later without reconnecting to the data source. To persist a recordset to a file, use the ADO Save method using the following syntax:</P>

<p>recordset.Save FileName, PersistFormat</p>

<P>The parameters for the Save method include:</P>

<ul>
<p><li>FileName</li></p>

<p>The FileName parameter is the complete path name of the file where the Recordset is to be saved.</p>

<p><li>PersistFormat</li></p>

<p>The PersistFormat parameter is a value that specifies the format in which the Recordset is to be saved. These values are the enumeration constants adPersistADTG and adPersistXML.</p>

<p>The constant adPersistADTG is the default setting that saves the recordset in a proprietary Advanced Data Tablegram (ADT) format. If you specify adPersistXML, the recordset will be saved in Extensible Markup Language (XML) format.</p>
</ul>

<P>When you save a recordset for the first time, specify the FileName parameter. When you invoke the Save method later, you should omit the FileName parameter or else a run-time error will occur. If you invoke the Save method providing a new FileName parameter, and the Recordset will be saved to the new specified file location.</P>

<P>The Save method does not close the Recordset or the file specified in the FileName parameter. This allows you to continue to work with the Recordset and save your most recent changes. The file remains open until the Recordset is closed, during which time other applications can read but not write to the file. The following example saves the recordset's contents to a file on the local computer:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
rs.Save &quot;C:\Recordset.dat&quot;, adPersistADTG
</pre></td></tr></table></p>

<P>To rebuild the recordset from data that was saved, use the Open method and refer to the file name. The following example reopens a persisted recordset:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
rs.Open &quot;C:\Recordset.dat&quot;
</pre></td></tr></table></p>

<A NAME="285"><H2>Reconnecting to a Data Source</H2></A>

<P>After a connection has been closed, it can be reopened and any changes the user made offline can be saved to the data source. The original connection information, such as the data source provider, is retained as long as the Connection object was disconnected using the Close method. If the Connection object is set to Nothing, all connection information must be re-established. The following example reconnects to a data source and associates the Recordset object with the connection:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Sub cmdReconnect_Click()
    ' Set Connection properties
    ' ...
    cn.Open
    rs.ActiveConnection = cn
End Sub
</pre></td></tr></table></p>

<P>One use of a disconnected recordset is to provide offline updating. A client can spend as much time as needed reviewing and editing data while disconnected from the data source.</P>

<A NAME="286"><H3>Applying Changes to the Data Source</H3></A>

<P>While disconnected from the data source, you can use the Update method to apply changes to the disconnected recordset cached on the client. Once you reconnect to the data source, you can use the ADO UpdateBatch method to apply changes to the actual data source. The UpdateBatch method applies all pending new, updated, and deleted records to the Recordset object.</P>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Although you can request batch updating with a forward-only and dynamic cursor, you cannot update more than one record at a time. You should use keyset or static cursors with batch updating. If you are using SQL Server as your back-end server, the only cursor type that will do true batch updating is keyset.
</blockquote></div>
</p>

<P>If you are editing the current record or adding a new record when you call the UpdateBatch method, ADO will automatically call the Update method to save any pending changes to the current record before transmitting the batched changes to the provider. In addition, using a LockType property value of adLockBatchOptimistic, the UpdateBatch method allows you to commit all pending changes at the client and send all the changes to the database at one time. </P>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Pending changes to a recordset can be canceled by calling the CancelBatch method.
</blockquote></div>
</p>

<P>The following example sends all cached changes to the data source:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Sub cmdUpdateAll_Click()
    rs.UpdateBatch
End Sub
</pre></td></tr></table></p>

<A NAME="287"><H3>Conflict Management Issues</H3></A>

<P>When updating records after reconnecting to the data source, you should consider the possibility that conflicts may arise due to concurrent activity by other users of the data source. ADO will report conflicts and retrieve information about conflicts when asked. However, it is your responsibility to specify what types of conflicts ADO should report, request details about the conflicts, and supply code to handle the different types of conflicts in a manner that is appropriate for your application.</P>

<P>After you call the UpdateBatch method, you need to determine whether conflicts did occur and then supply the appropriate code to resolve each type of conflict in a way that makes sense for your application. It is advisable to wrap your batch updates and associated conflict resolution in a transaction to ensure that additional changes to the data source do not occur between the time you identify and then handle the conflicts.</P>

<P>If the attempt to transmit changes fails for any or all records because of a conflict with the underlying data (for example, a record has already been deleted by another user), the provider returns warnings to the Errors collection and a run-time error occurs. You can use the Filter and Status properties to locate records with conflicts.</P>

<p>
<img src="images/practice.gif" width=67 height=55 border=0>
</p>

<A NAME="288"><H2>Practice: Working With Disconnected Recordsets  </H2></A>

<P>In this practice, you will create a COM DLL that acts as a data source. In the COM DLL, you will provide functionality to allow the client to use a disconnected recordset. This includes the ability to save the recordset to a local file and open that file to re-establish the recordset. You will also provide the ability to update the recordset on the database server.</P>

<A NAME="289"><H3>Exercise 1: Creating a COM DLL</H3></A>

<P>In this exercise you will add methods, events, and enumerations to a COM DLL to provide functionality to a client application that you will create in Exercise 2.</P>

<P><li><B> To create a COM DLL that is a data source</B></li></P>

<ol>
<p><li>Create a new ActiveX DLL project.</li></p>

<p><li>Set a reference to the Microsoft ActiveX Data Objects library.</li></p>

<p><li>Name the project <B>DisconRS</B>.</li></p>

<p><li>Change the name of Class1 to <B>CRecSet</B>.</li></p>

<p><li>Set the DataSourceBehavior property to vbDataSource.</li></p>

<p><li>In the Initialize event of CRecSet, connect to the Northwind database on your SQL server and create a recordset by querying the Employees table.</li></p>

<p>The fields that you must return are Lastname, Firstname, Title, and Extension. Your code should look similar to the following:</p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private Sub Class_Initialize()
    Set cnNorthWind = New Connection
    Set rsEmployees = New Recordset
    Dim SQL As String

    ' Establish a connection
    With cnNorthWind
        .Provider = &quot;SQLOLEDB&quot;
        .ConnectionString = &quot;User ID=sa;&quot; &amp; _
                            &quot;Data Source=vb6entsvr;&quot; &amp; _
                            &quot;Initial Catalog=northwind&quot;
        .Open
    End With

    ' Build a recordset
    SQL = &quot;SELECT LastName, FirstName, Title, &quot; &amp; _
        &quot;Extension FROM Employees;&quot;
    With rsEmployees
        ' Specify the cursor's location
        .CursorLocation = adUseClient
        .CursorType = adOpenDynamic
        .LockType = adLockBatchOptimistic
        .Open SQL, cnNorthWind
        m_status = staConnected
    End With
End Sub
</pre></td></tr></table></p>

<p><li>Use the Class_GetDataMember event procedure to return the Recordset to the client application to provide data binding. For example:</li></p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private Sub Class_GetDataMember(DataMember As String, Data As Object)
    Set Data = rsEmployees
End Sub
</pre></td></tr></table></p>

</ol>

<P><li><B> To add an event and enumeration to CRecSet</B></li></P>

<ol>
<p><li>Declare an event in the General Declarations section of CRecSet called Error.</li></p>

<p>The Error event will have one String argument called ErrorDescription.</p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Public Event Error(ErrorDescription As String)
</pre></td></tr></table></p>

<p><li>In addition, declare an enumeration called rsStatus as follows:</li></p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Public Enum rsStatus
    staIsNothing
    staDisconnected
    staConnected
    staSavedToFile
End Enum
</pre></td></tr></table></p>

<p>The enumeration value provides the client with information on the recordset's status.</p>

<p><li>To allow the client to check the recordset's status, create a property procedure to return the value of rsStatus as follows:</li></p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Public Property Get Status() As rsStatus
    Status = m_status
End Property
</pre></td></tr></table></p>
</ol>

<P><li><B> To add methods for database functionality to CRecSet</B></li></P>

<ol>
<p><li>Create a method called Disconnect in CRecSet.</li></p>

<p>This method disconnects the recordset from the active connection.</p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Public Sub Disconnect()
    If m_status = staConnected Then
        ' Disconnect the recordset from the active connection
        Set rsEmployees.ActiveConnection = Nothing
        Set cnNorthWind = Nothing
        m_status = staDisconnected
    Else
        RaiseEvent Error(&quot;Cannot disconnect recordset.&quot;)
    End If
End Sub
</pre></td></tr></table></p>

<p><li>Create a method called SaveRecordset that accepts a String argument that determines where to persist the recordset.</li></p>

<p>In this method, check the current recordset status to make sure that the recordset is disconnected before saving to the file. If the recordset is not disconnected, raise the Error event. Your code should look similar to the following:</p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Public Sub SaveRecordset(FileName As String)
    If m_status = staDisconnected Then
        ' Save the recordset contents to a file on the local computer
        rsEmployees.Save FileName, adPersistADTG
        rsEmployees.Close
        m_status = staSavedToFile
    Else
        RaiseEvent Error(&quot;Recordset not disconnnected&quot; &amp; _
        &quot; - cannot save.&quot;)
    End If
End Sub
</pre></td></tr></table></p>

<p><li>Create a method called GetPersistedData that accepts a string argument.</li></p>

<p>This method will be used to open the file to which you saved the disconnected recordset. You will use the Open method of the Recordset object to open the file.</p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Public Sub GetPersistedData(FileName As String)
    If m_status = staSavedToFile Then
        rsEmployees.Open FileName
    Else
        RaiseEvent Error(&quot;Recordset has not been saved to a file.&quot;)
    End If
End Sub
</pre></td></tr></table></p>

<p><li>Create a method called UpdateDatabase that reconnects to the data source and updates any changes made to the recordset.</li></p>

<p>Your code should look similar to the following:</p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Public Sub UpdateDatabase()
    ' Reconnect to the data source and associate
    ' the Recordset object with the connection
    Set cnNorthWind = New ADODB.Connection
    With cnNorthWind
        .Provider = &quot;SQLOLEDB&quot;
        .ConnectionString = &quot;User ID=sa;&quot; &amp; _
                        &quot;Data Source=vb6entsvr;&quot; &amp; _
                        &quot;Initial Catalog=northwind&quot;
        .Open
    End With
    rsEmployees.ActiveConnection = cnNorthWind
    m_status = staConnected

    ' Send all cached changes to the data source
    rsEmployees.UpdateBatch
End Sub
</pre></td></tr></table></p>
</ol>

<P><li><B> To provide recordset navigation methods</B></li></P>

<ol>
<p><li>Create four methods to move to the first, last, next, and previous records in the recordset. </li></p>

<p>Be sure to check the BOF and EOF recordset properties when calling the MoveNext and MovePrevious methods.Your code should look similar to the following:</p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Public Sub MoveNext()
    With rsEmployees
        .MoveNext
        If .EOF Then .MoveFirst
    End With
End Sub

Public Sub MovePrevious()
    With rsEmployees
        .MovePrevious
        If .BOF Then .MoveLast
    End With
End Sub

Public Sub MoveLast()
    rsEmployees.MoveLast
End Sub

Public Sub MoveFirst()
    rsEmployees.MoveFirst
End Sub
</pre></td></tr></table></p>
</ol>

<A NAME="290"><H3>Exercise 2: Creating the Client Application</H3></A>

<P>In this exercise, you will create a client application that instantiates and binds to the CRecSet class.</P>

<P><li><B> To create the client form</B></li></P>

<ol>
<p><li>Create a new Standard EXE project.</li></p>

<p><li>Set a reference to the DisconRS project.</li></p>

<p><li>Change the name of Form1 to <B>frmEmps</B>.</li></p>

<p><li>Set the Caption of frmEmps to <B>Employee</B> <B>Information</B>.</li></p>

<p><li>Add four textboxes to frmEmps named <B>txtLastName</B>, <B>txtFirstName</B>, <B>txtTitle</B>, and <B>txtExtension</B>.</li></p>

<p>These textboxes will be bound to an object created from CRecSet at run time.</p>

<p><li>Put labels above each textbox to identify their purpose.</li></p>

<p><li>Add four command buttons to frmEmps named <B>cmdSaveRS</B>, <B>cmdGetPersistedData</B>, <B>cmdUpdateDatabase</B>, and <B>cmdExit</B>.</li></p>

<p>Your form should look similar to the illustration in Figure 7.1.</p>

<P>
<A HREF="javascript:fullSize('F07xx01x.htm')"> <img src="images/F07xx01.JPG" width=404 height=255 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 7.1</b> <i>Creating data entry fields on the client form</i><!--/caption-->
</P>


<p><li>Add a Common Dialog control to frmEmps and name it <B>cDlg</B>.</li></p>

<p><li>Set the filter property of cDlg to <B>Dat Files (*.dat)|*.dat</B>, and set the FileName property to <B>C:\RS.dat</B>.</li></p>

<p><li>Add four command buttons to the bottom of frmEmps named <B>cmdMoveFirst</B>, <B>cmdMovePrevious</B>, <B>cmdMoveNext</B>, and <B>cmdMoveLast,</B> as illustrated in Figure 7.2.</li></p>

<P>
<A HREF="javascript:fullSize('F07xx02x.htm')"> <img src="images/F07xx02.JPG" width=404 height=256 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!--caption--><b>Figure 7.2</b> <i>Employee Information form containing all controls</i><!--/caption-->
</P>

</ol>

<P><li><B> To add functionality to the client application</B></li></P>

<ol>
<p><li>In the Form_Load event, add code to bind the textbox controls to the CRecSet class and disconnect from the database server as follows:</li></p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private Sub Form_Load()
    Set dRSobj = New CRecSet

    ' Bind textboxes to the CRecSet data source class
    Set txtLastName.DataSource = dRSobj
    txtLastName.DataField = &quot;LastName&quot;
    Set txtFirstName.DataSource = dRSobj
    txtFirstName.DataField = &quot;FirstName&quot;
    Set txtTitle.DataSource = dRSobj
    txtTitle.DataField = &quot;Title&quot;
    Set txtExtension.DataSource = dRSobj
    txtExtension.DataField = &quot;Extension&quot;

    With dRSobj
        If .Status = staConnected Then .Disconnect
    End With
End Sub
</pre></td></tr></table></p>

<p><li>In the cmdGetPersistedData_Click event, add code to call the GetPersistedData method of the CRecSet class.</li></p>

<p>To provide a file name to open, use the Common Dialog control to request that information from the user. In addition, you have to re-bind your textbox controls to the recordset. Your code should look similar to the following:</p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private Sub cmdGetPersistedData_Click()
    cDlg.ShowOpen
    ' Get the saved recordset
    dRSobj.GetPersistedData cDlg.FileName    
    ' Bind textboxes to the CRecSet data source class
    Set txtLastName.DataSource = dRSobj
    txtLastName.DataField = &quot;LastName&quot;
    Set txtFirstName.DataSource = dRSobj
    txtFirstName.DataField = &quot;FirstName&quot;
    Set txtTitle.DataSource = dRSobj
    txtTitle.DataField = &quot;Title&quot;
    Set txtExtension.DataSource = dRSobj
    txtExtension.DataField = &quot;Extension&quot;

    cmdGetPersistedData.Enabled = False
    cmdSaveRS.Enabled = True
    cmdMoveFirst.Enabled = True
    cmdMovePrevious.Enabled = True
    cmdMoveNext.Enabled = True
    cmdMoveLast.Enabled = True
    cmdUpdateDatabase.Enabled = True
End Sub
</pre></td></tr></table></p>

<p><li>In the cmdSaveRS_Click event, add code to save the disconnected recordset to a file.</li></p>

<p>Again, the file name and location are based on the user input entered in the Common Dialog control. Your code should look similar to the following:</p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private Sub cmdSaveRS_Click()
    cDlg.ShowSave
    ' Save the recordset
    dRSobj.SaveRecordset cDlg.FileName

    cmdGetPersistedData.Enabled = True
    cmdSaveRS.Enabled = False
    cmdMoveFirst.Enabled = False
    cmdMovePrevious.Enabled = False
    cmdMoveNext.Enabled = False
    cmdMoveLast.Enabled = False
    cmdUpdateDatabase.Enabled = False
End Sub
</pre></td></tr></table></p>

<p><li>In the Click event of the navigation command buttons that you added, type code to call the MoveFirst, MovePrevious, MoveNext, and MoveLast methods of CRecSet.</li></p>

<p><li>In the cmdUpdateDatabase_Click event procedure, call the UpdateDatabase method of the CRecSet class.</li></p>

<p><li>In the cmdExit_Click event procedure, unload the current form.</li></p>

<p><li>In the Form_Unload event, display a message box to the user asking them if they are certain that they want to exit the application.</li></p>

<p>Your code should look similar to the following:</p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Private Sub Form_Unload(Cancel As Integer)
    Dim ret As Integer

    ret = MsgBox(&quot;Are you sure you want to exit?&quot;, vbYesNo, &quot;Exit&quot;)
    If ret = vbNo Then Cancel = 1
End Sub
</pre></td></tr></table></p>

<p><li>Save and test your application by saving the records to a file and clicking on the navigation buttons.</li></p>

<p>Your application will connect to a data source, create a recordset, disconnect from the data source, update the recordset, and then reconnect to the data source. The data source will then be updated with any changes made to the disconnected Recordset.</p>
</ol>

<A NAME="291"><H2>Lesson Summary </H2></A>

<P>Every cursor uses temporary resources to hold its data. These resources can be memory, a disk paging file, temporary disk files, or even temporary storage in the database. The cursor is called a client-side cursor when these resources are located on the client machine. </P>

<P>Server-side cursors are the default in ADO. To explicitly specify the creation of a client-side cursor, set the CursorLocation property of the Recordset object to adUseClient. One benefit of the client-side cursor is quick response. After the result set has been downloaded to the client machine, browsing through the rows is very fast because data does not have to be transported across the network. Your application is generally more scalable with client-side cursors because the cursor's resource requirements are placed on each separate client and not on the server.</P>

<P>A disconnected recordset resides in a client cache and no longer has a live connection to the server. Later, you can re-establish the connection if you need to do something with the original data source, such as updating data.</P>

<P>Setting the recordset's ActiveConnection property to Nothing disconnects the recordset from the active connection. Your application can then close the active Connection object using the Close method. A recordset's contents can be saved (persisted) to a file. To persist a recordset to a file, use the ADO Save method. After a connection has been closed, it can be reopened. Once you reconnect to the data source, you can use the ADO UpdateBatch method to apply changes to the actual data source. The UpdateBatch method applies all pending new, updated, and deleted records to the Recordset object.</P>

</BODY>
</HTML>



