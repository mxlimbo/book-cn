<HTML>
<HEAD>
<TITLE>Lesson 1: Introduction to Transactions</TITLE>
<link rel="STYLESHEET" type="text/css" href="Library.css">

</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07a.htm", "ch07c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="266"><H1>Lesson 1: Introduction to Transactions</H1></A>

<P>Often, database applications need to perform multiple related tasks. One way to manage a group of related tasks is to use <I>transactions</I>. Transactions help ensure data integrity by grouping one or more Structured Query Language (SQL) statements, or database operations together. A transaction is an &quot;all or nothing&quot; proposition; either all of the statements are executed and completed, or none of them are. If any command fails, you can <I>roll</I> <I>back</I> all of the commands, returning the data source to its original state. If all of the commands are successful, you can <I>commit</I> the changes and make them permanent.</P>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson you will be able to:</b>
<ul>

<p><li>Describe the ACID properties of transactions.</li></p>

<p><li>List the ADO Connection object methods used to implement transactions.</li></p>

<p><li>Describe the three types of transactions.</li></p>

<p><li>Define the various isolation levels you can implement for transactions.</li></p>

</ul>
<b>Estimated lesson time: 45 minutes</b>
</blockquote></div>
</p>

<A NAME="267"><H2>Definition of a Transaction</H2></A>

<P>A transaction is composed of database operations that are combined into a logical unit of work that succeeds or fails as a whole and must exhibit four properties, called the ACID (Atomicity, Consistency, Isolation, and Durability) properties. These properties are described here: </P>

<ul>
<p><li>Atomicity</li></p>

<p>A transaction must be an atomic unit of work. This means either all of the data modifications are performed or none of them are performed. </p>

<p><li>Consistency</li></p>

<p>A transaction must leave all data in a consistent state when completed. In a relational database, this means all rules must be applied to the transaction's modifications to maintain data integrity. In addition, all of the data source's internal data structures must be accurate at the end of the transaction.</p>

<p><li>Isolation</li></p>

<p>Isolation is the ability to protect transactions from the effects of updates performed by other concurrent transactions. Modifications made by one transaction must be isolated from the modifications made by any other coexisting transactions. A transaction either accesses data in the state the data was in before another transaction modified it, or it accesses the data after the other transaction has completed. However, it does not access the data in an intermediate state. </p>

<p><li>Durability</li></p>

<p>Durability means that after a transaction has completed, the effects are permanent. The modifications persist even in the event of a system failure and automatically roll back any uncompleted transactions to the point of the system failure.</p>
</ul>

<P>When you are making many related changes to a database or updating several databases at once, you want to ensure that all of the changes are correctly executed. If any of the changes fail, you want to restore the original state of the database tables. A transaction allows you to perform an operation even if the operation involves many steps. For example, one part of an operation could process an order, another checks inventory, and another performs billing.</P>

<P>A transaction goes through several phases:</P>

<ul>
<p><li>Before the transaction starts, the database is considered to be in a consistent state.</li></p>

<p><li>The application signals the start of a transaction.</li></p>

<p><li>The application starts modifying data.</li></p>

<p>These modifications are made one table at a time. As a series of modifications are made, they may leave the database in a temporarily inconsistent intermediate state.</p>

<p><li>When the application reaches a point where all the modifications have completed successfully and the database is once again consistent, the application commits the transaction.</li></p>

<p>This makes all the modifications a permanent part of the database.</p>

<p><li>If the application encounters an error that prevents it from completing the transaction, it rolls back (cancels), all of the data modifications.</li></p>

<p>This returns the database to the point of consistency it was at before the transaction started.</p>
</ul>

<A NAME="268"><H2>Transactions and ADO</H2></A>

<P>You can use transaction methods with a Connection object when you want to save or cancel a series of changes made to the source data as a single unit. For example, to transfer money between accounts, you subtract an amount from one and add the same amount to the other. If either update fails, the accounts no longer balance. Making these changes within a transaction ensures that either all or none of the changes go through.</P>

<P>The following transaction methods manage transaction processing within a Connection object:</P>

<ul>
<p><li>BeginTrans </li></p>

<p>Begins a new transaction.</p>

<p><li>CommitTrans  </li></p>

<p>Saves any changes and ends the current transaction. It may also start a new transaction.</p>

<p><li>RollbackTrans </li></p>

<p>Cancels any changes made during the current transaction and ends the transaction. It may also start a new transaction.</p>
</ul>

<P>Once you call the BeginTrans method, the provider no longer autocommits any changes you make until you call CommitTrans or RollbackTrans to end the transaction.</P>

<A NAME="269"><H2>Types of Transactions</H2></A>

<P>All SQL statements run in a transaction-either an explicit transaction or an autocommit transaction. The SQL Server transactions that include data modifications either reach a new point of consistency and are committed, or are rolled back to the original point of consistency. Transactions are not left in an intermediate state where the database is not consistent. Because there are different types of SQL Server transactions, it is important to understand each one when your are programming with ADO.</P>

<A NAME="270"><H3>Autocommit transactions</H3></A>

<P>In autocommit mode, which is the default mode for SQL Server, each individual SQL statement is committed automatically if it is successful and rolled back automatically if it generates an error. There is no need for an application running in autocommit mode to issue statements that specifically start or end a transaction. When using Transact-SQL within SQL Server, each individual Transact-SQL statement is committed when it completes. You do not have to specify any statements to control transactions. Transact-SQL will be discussed later in this lesson.</P>

<A NAME="271"><H3>Implicit Transactions</H3></A>

<P>Implicit transactions do not allow you to group multiple commands together. Instead a transaction is built around each individual command. Using implicit transactions, you cannot programmatically roll back or commit the changes. However, you can trap for a run-time error if the command were to fail. Your program can then resubmit the individual change.</P>

<P>If you do not explicitly turn on a transaction, implicit transactions are used automatically. SQL Server uses auto-commit mode and builds a transaction around each individual command.</P>

<A NAME="272"><H3>Explicit Transactions</H3></A>

<P>Explicit transactions allow your application to manage multiple SQL statements as if they were a single command. When you use an explicit transaction, your application groups commands into a single action.</P>

<P>For example, you can use an explicit transaction if your application transfers money between bank accounts. The act of transferring money consists of two operations: removing money from one account (a debit) and then adding it to another account (a credit). Without using a transaction, if there are any network problems or other errors that prevent the credit from occurring, the money is removed from the first account without being added to the second. This situation is avoided when you use an explicit transaction.</P>

<P>Transactions are managed at the Connection object level. Any Recordset objects or Command objects created when a transaction is enabled automatically share the transaction.</P>

<P>Your application can manage explicit transactions by using one of three transaction methods: BeginTrans, RollbackTrans, or CommitTrans. When you create an explicit transaction with the BeginTrans method, all statements that follow are automatically a part of that transaction. When you use the RollbackTrans or CommitTrans methods, the transaction is closed and a new one can be created. The following example creates a new transaction and closes it appropriately:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
Sub cmdMakeChanges_Click()
    Dim cn As ADODB.Connection
    Set cn = New ADODB.Connection

    With cn
        .Provider = &quot;SQLOLEDB&quot;
        .ConnectionString = &quot;User ID=sa;&quot; &amp; _
            &quot;Data Source=VB6ENTSVR;&quot; &amp; _
            &quot;Initial Catalog=Pubs&quot;
        .Open
    End With

    ' Begin a transaction
    cn.BeginTrans
    On Error GoTo Error_Handler

    ' SQL Commands are executed in the transaction
    cn.Execute &quot;INSERT INTO Authors...&quot;
    cn.Execute &quot;DELETE FROM Publishers...&quot;

' If all commands are successful, commit them
    cn.CommitTrans
    Exit Sub

Error_Handler:
    ' If an error occured, roll back the changes
    cn.RollbackTrans
    MsgBox &quot;An error occured changing the records.&quot;, vbExclamation
End Sub
</pre></td></tr></table></p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Although transactions ensure data integrity, locks are created by the data source while a transaction is open. Commit or roll back the transaction as soon as possible to allow other applications access to the data.
</blockquote></div>
</p>

<A NAME="273"><H2>Coding Efficient Transactions</H2></A>

<P>It is important to keep transactions as short as possible because when a transaction is started, a database management system (DBMS) must hold many resources until the end of the transaction to protect the ACID properties of the transaction. If you modify data, you must protect the modified with exclusive locks that prevent any other transaction from reading the rows. Exclusive locks must be held until the transaction is committed or rolled back.</P>

<A NAME="274"><H3>Isolation Levels</H3></A>

<P>The level at which a transaction is prepared to accept inconsistent data is termed the isolation level. It is the degree to which one transaction must be isolated from other transactions. A lower isolation level increases concurrency but at the expense of data correctness. Conversely, a higher isolation level ensures that data is correct but can negatively affect concurrency.</P>

<P>When many people attempt to modify data in a database simultaneously, a system of controls must be implemented so that modifications made by one person do not adversely affect another. This system is called <I>concurrency</I> <I>control</I>. In SQL Server, you use locking as the concurrency control mechanism. Locking allows all transactions to run in complete isolation of one another, although there can be more than one transaction running in SQL Server at any one time. The isolation level required by an application determines the locking behavior used by SQL Server. SQL-92 defines four isolation levels, all of which are supported by SQL Server.</P>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
SQL-92 is the latest version of the standard for SQL, published in 1992. The international standard is ISO/IEC 9075:1992 Database Language SQL. The American National Standards Institute (ANSI) also published a corresponding standard (Data Language SQL X3.135-1192), so SQL-92 is sometimes referred to as ANSI SQL in the United States.
</blockquote></div>
</p>

<P>Ideally, transactions should be <I>serializable</I>, which means that the results of running the transactions simultaneously are the same as the results of running them serially (one after the other). It is not important which transaction executes first, only that the result does not reflect any mixing of the transactions.</P>

<p><b>Read Committed Isolation Level</b></p>

<P>Transactions need serialization to make sure that the data in the database remains up to date and meaningful. Still, many transactions do not require this type of full isolation. For example, several writers may be working on different chapters of the same book.  They can submit the new chapters to the project whenever they choose. However, after a chapter is edited, a writer cannot make any changes to the chapter without first obtaining the editor's approval.  The editor can be assured that the book will maintain its accuracy throughout the project, despite the arrival of new unedited chapters. This is an example of the <I>read committed isolation level</I>: The editor can view any recently submitted chapters and previously edited chapters.</P>

<P>When using the read committed isolation level, SQL Server acquires a share lock while reading a record into a cursor, and frees the lock immediately after reading the record. Cursors are prevented from reading records that another task has updated but not yet committed. This concept is known as preventing <I>dirty</I> <I>reads</I>. Dirty reads contain uncommitted data. For example, a transaction could change a row. A second transaction could then read the changed row before the first transaction commits the change. If first transaction rolls back the change, the result is the second transaction reading a row that is considered to have never existed. The read committed isolation level specifies that shared locks are held while the data is being read to avoid dirty reads, but the data can be changed before the end of the transaction, resulting in nonrepeatable reads or phantom data.</P>

<P>Sometimes, a transaction may read the same row more than once. If a separate transaction modifies that row between the two (or more) reads, then it is called a nonrepeatable read. Each read produces different values because the row was modified between reads during the same transaction, thus introducing inconsistency. This is called a nonrepeatable read. Phantom data, or phantom behavior, occurs when a transaction attempts to select a row that does not exist and a second transaction inserts the row before the first transaction finishes. If the row is inserted, the row appears as a phantom to the first transaction, inconsistently appearing and disappearing.</P>

<p><b>Read Uncommitted Isolation Level</b></p>

<P>The read committed isolation level is the SQL Server default, and is the least restrictive of the four isolation levels. Using the read committed isolation level makes it possible to read uncommitted or dirty data. In this case, values in the data may or may not exist in the recordset before the end of the transaction.</P>

<p><b>Repeatable Read Isolation Level</b></p>

<P>When the repeatable read isolation level is set, other users can be prevented from updating data. This is because locks are used on all data that is processed in a query. Although these locks prevent other users from updating the data, other users can insert new phantom rows into the data set. These phantom rows are included in subsequent reads in the current transaction. Because concurrency is lower than the default isolation level, you should avoid using the repeatable read isolation level when multiple users perform updates to the same data source.</P>

<p><b>Serializable Isolation Level</b></p>

<P>The serializable isolation level is the most restrictive of the four isolation levels because it places a range lock on the data set, preventing other users from updating or inserting rows into the data set until the transaction is complete. Because concurrency is lower, avoid using the serializable isolation level when multiple users continuously add or update records in the same data source.</P>

<A NAME="275"><H3>Effects of Isolation Levels in Transactions</H3></A>

<P>As you can see, the four isolation levels allow different types of behavior. Depending on transaction isolation level settings, Select statements may acquire locks that must be held until the transaction is committed or rolled back. In systems with many users, transactions must be kept as short as possible to reduce locking contention for resources between concurrent connections. Long-running, inefficient transactions may not be a problem with small numbers of users, but they are unacceptable in a system with thousands of users.</P>

<A NAME="276"><H2>Transact-SQL</H2></A>

<P>Transact-SQL is the standard language for communicating between applications and SQL Server. The Transact-SQL language is an enhancement to SQL, the ANSI-standard relational database language. It provides a comprehensive language for defining tables; inserting, updating, or deleting information stored in tables; and for controlling access to data in those tables. Extensions such as stored procedures make Transact-SQL a complete programming language.</P>

<P>The following Transact-SQL statements are used to define explicit transactions: </P>

<ul>
<p><li>Begin Transaction</li></p>

<p>Marks the starting point of an explicit transaction for a connection. Begin Transaction is equivalent to the the following ADO command:</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
cn.BeginTrans
</PRE></TD></TR></TABLE></P>

<p><li>Commit Transaction</li></p>

<p>Used to end a transaction successfully if no errors were encountered. All data modifications made in the transaction become a permanent part of the database. Resources held by the transaction are freed. Commit Transaction is equivalent to the following ADO command:</p>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>
cn.CommitTrans
</PRE></TD></TR></TABLE></P>

<p><li>Rollback Transaction</li></p>

<p>Used to erase a transaction in which errors are encountered. All data modified by the transaction is returned to the state it was in at the start of the transaction. Resources held by the transaction are freed. Rollback Transaction is equivalent to the following ADO command:</p>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
cn.RollbackTrans
</pre></td></tr></table></p>

</ul>

<P>The Begin Transaction statement starts a new transaction for a connection. Resources can be locked by a transaction until it is complete depending on the transaction isolation level settings. If a transaction remains outstanding for a long time, other users are prevented from accessing the locked resources. The following example increases the royalties paid for all popular computer books by 5 percent:</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD><PRE>
DECLARE @TranName VARCHAR(15)
SELECT @TranName = 'UpdateRoyalties'

BEGIN TRANSACTION @TranName
GO
USE pubs
GO
UPDATE roysched
SET royalty = royalty * 1.05
WHERE title_id LIKE 'A%'
GO

COMMIT TRANSACTION UpdateRoyalties
GO
</pre></td></tr></table></p>

<A NAME="277"><H2>Lesson Summary </H2></A>

<P>A transaction is an &quot;all or nothing&quot; operation; either all of the statements are executed and completed or none of them are. If any command fails, you can roll back all commands, returning the data source to its original state. If all commands are successful, you can commit the changes and make them permanent. Database operations are combined into a logical unit of work that succeeds or fails as a whole, and must exhibit four properties, called the ACID (Atomicity, Consistency, Isolation, and Durability) properties, to qualify as a transaction.</P>

<P>The following transaction methods manage transaction processing within a Connection object as follows: </P>

<ul>
<p><li>BeginTrans </li></p>

<p>Begins a new transaction.</p>

<p><li>CommitTrans </li></p>

<p>Saves any changes and ends the current transaction. It may also start a new transaction.</p>

<p><li>RollbackTrans </li></p>

<p>Cancels any changes made during the current transaction and ends the transaction. It may also start a new transaction.</p>
</ul>

<P>Transact-SQL is the standard language for communicating between applications and SQL Server. The Transact-SQL language is an enhancement to Structured Query Language (SQL), the ANSI-standard relational database language. It provides a comprehensive language for defining tables; inserting, updating, or deleting information stored in tables; and for controlling access to data in those tables.</P>

</BODY>
</HTML>



