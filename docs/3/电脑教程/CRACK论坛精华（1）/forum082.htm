<html>
<head>
<title>看雪学苑</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<style type="text/css">
<!--
.p8 {  font-size: 8pt}
.p9 {  font-size: 9pt}
a:hover {  color: #00FF00}
a {  text-decoration: none}
.p12 {  font-size: 12pt; font-weight: bold; color: #FF3333}
-->
</style>
</head>

<body bgcolor="#FFFFFF">
<p><span class="p9"><font color=blue>标 题:</font>手工脱壳 Advanced Administrative Tools 
  4.0a (8千字)<br>
  <font color=blue>发信人:</font>cloudnumber9<br>
  <font color=blue>时 间:</font>2000-6-6 16:38:39 <br>
  <font color=blue>详细信息:</font></span></p>
<p><span class="p9"> 下载： http://newhua.myrice.com/down/aat40a.zip <br>
  </span> </p>
<blockquote><span class="p9"> 手工脱壳 Advanced Administrative Tools 4.0a <br>
  <br>
  作者&nbsp; &nbsp;&nbsp;：Cloud Number 9 <br>
  Email&nbsp; &nbsp;&nbsp;: cloudnumber9@sina.com <br>
  版权声明：本文可自由转载和引用，但请勿用于商业目的。转载时请保持完整。 <br>
  写作目的：我已很久没有破解软件，在偶然的机会里看到了一些看学学苑的脱壳教程， <br>
  &nbsp; &nbsp;&nbsp;&nbsp; 随即顺手找了这个软件练习一下。没想到竟碰上一个大难题，足足用了我 <br>
  &nbsp; &nbsp;&nbsp;&nbsp; 一个星期的时间。我先用 ProcDump 的 script 脱掉了壳，后来发现不能 <br>
  &nbsp; &nbsp;&nbsp;&nbsp; 运行，随后又看了很多文章，敖了好多夜，才最后解决这个问题。 <br>
  &nbsp; &nbsp;&nbsp;&nbsp; 我想，cracker 的精神就是共享软件、共享知识、共享快乐和骄傲。 <br>
  &nbsp; &nbsp;&nbsp;&nbsp; 这也就是我写作本文的唯一目的。 <br>
  写作日期：新世纪的第一个端午节，6th June, 2000. <br>
  <br>
  脱壳软件：AATools 4.0a build 4.0.0.596 <br>
  文件大小: 752,128 bytes <br>
  软件功能：我没太注意，只为练习脱壳。 <br>
  发行公司：G-lock software, http://www.glocksoft.com <br>
  脱壳日期：June 3rd, 2000 <br>
  <br>
  破解环境：Windows Me (English Version), MMX 200, 64M. <br>
  使用工具：Trw2000 V1.21, ProcDump 1.6.2, topo, UltraEdit 7.0, W32dsm89. <br>
  --------------------------------------------------------------------------- 
  <br>
  <br>
  首先用 ProcDump 看一下 AATools.exe 的 PE 头。 <br>
  Entry Point&nbsp; &nbsp;&nbsp;: 00222001 <br>
  Size of Image&nbsp; &nbsp;&nbsp;: 00239000 <br>
  Image Base &nbsp; &nbsp;&nbsp;: 00400000 <br>
  <br>
  现在运行 trw2k, 起始代码如下： <br>
  ---------&nbsp; &nbsp;&nbsp;AATOOLS!.data&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;----------------------- 
  <br>
  :00622001 60&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;PUSHA <br>
  :00622002 E801000000&nbsp; &nbsp;&nbsp;CALL 00622008 <br>
  :00622007 90&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;NOP <br>
  <br>
  按 F8 跟踪，只见这程序费劲了心思、不断的在内存中动态生成代码， <br>
  从.data 转换到一段段无名的空间，最后终于变换到 .CODE, 出现下列代码： <br>
  ---------&nbsp; &nbsp;&nbsp;AATOOLS!.CODE+1754C0&nbsp; &nbsp;&nbsp;----------------------- 
  <br>
  :005764C0 55&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; push ebp <br>
  :005764C1 8BEC&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; mov ebp, esp <br>
  :005764C3 83C4F4&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  add esp, FFFFFFF4 <br>
  :005764C6 53&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; push ebx <br>
  :005764C7 B8705E5700&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov eax, 
  00575E70 <br>
  :005764CC E8CF0EE9FF&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call 004073A0 
  <br>
  :005764D1 8B1D84A85700&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov ebx, dword 
  ptr [0057A884] <br>
  <br>
  经过不断试验，确定此时程序已完全脱壳。cs:5764c0 就是程序的新入口点。 <br>
  由于我没有注册的 trw2k, 所以手工脱壳， <br>
  E CS:EIP EB FE 90 <br>
  G <br>
  然后运行 ProcDump 脱壳。文件大小应为 2135K. <br>
  （如果将 ProcDump 中的 rebuild new import table 选项选中的话，脱壳后的文件 <br>
  大小为 2138K, 同用 script 脱壳的大小一样） <br>
  <br>
  这时 PE 头变为： <br>
  Name&nbsp; &nbsp;&nbsp;Virtual Size&nbsp; &nbsp;&nbsp;Virtual Offset&nbsp; &nbsp;&nbsp;Raw 
  Size&nbsp; &nbsp;&nbsp;Raw Offset <br>
  CODE&nbsp; &nbsp;&nbsp;00176000&nbsp; &nbsp;&nbsp;00001000&nbsp; &nbsp;&nbsp;001755B8&nbsp; 
  &nbsp;&nbsp;00000600 <br>
  DATA&nbsp; &nbsp;&nbsp;00004000&nbsp; &nbsp;&nbsp;00177000&nbsp; &nbsp;&nbsp;00003B30&nbsp; 
  &nbsp;&nbsp;00175C00 <br>
  BSS&nbsp; &nbsp;&nbsp;00002000&nbsp; &nbsp;&nbsp;0017B000&nbsp; &nbsp;&nbsp;00000000&nbsp; 
  &nbsp;&nbsp;0017B000 <br>
  .idata&nbsp; &nbsp;&nbsp;00004000&nbsp; &nbsp;&nbsp;0017D000&nbsp; &nbsp;&nbsp;00000B04&nbsp; 
  &nbsp;&nbsp;00179800 <br>
  .tls&nbsp; &nbsp;&nbsp;00001000&nbsp; &nbsp;&nbsp;00181000&nbsp; &nbsp;&nbsp;00000000&nbsp; 
  &nbsp;&nbsp;00181000 <br>
  .rdata&nbsp; &nbsp;&nbsp;00001000&nbsp; &nbsp;&nbsp;00182000&nbsp; &nbsp;&nbsp;00000010&nbsp; 
  &nbsp;&nbsp;0017A400 <br>
  .reloc&nbsp; &nbsp;&nbsp;00019000&nbsp; &nbsp;&nbsp;00183000&nbsp; &nbsp;&nbsp;00000000&nbsp; 
  &nbsp;&nbsp;0017A600 <br>
  .rsrc&nbsp; &nbsp;&nbsp;00086000&nbsp; &nbsp;&nbsp;0019C000&nbsp; &nbsp;&nbsp;00085BD0&nbsp; 
  &nbsp;&nbsp;0017A600 <br>
  .data&nbsp; &nbsp;&nbsp;00016000&nbsp; &nbsp;&nbsp;00222000&nbsp; &nbsp;&nbsp;000158AC&nbsp; 
  &nbsp;&nbsp;00200200 <br>
  .data&nbsp; &nbsp;&nbsp;00001000&nbsp; &nbsp;&nbsp;00238000&nbsp; &nbsp;&nbsp;00000000&nbsp; 
  &nbsp;&nbsp;00215C00 <br>
  <br>
  将脱壳后文件中的 EB FE 90 改回 55 8B EC，然后将 Entry Point 改为 1764C0. <br>
  但此时文件还是不能运行。 <br>
  <br>
  再通过 trw2k 跟踪， <br>
  :004073A0 50&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; push eax <br>
  :004073A1 6A00&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; push 00000000 <br>
  :004073A3 E8F8FEFFFF&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call 004072A0 
  <br>
  :004073A8 BA00715700&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov edx, 
  00577100 <br>
  :004073AD 52&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; push edx <br>
  :004073AE 8905DCB45700&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov dword ptr 
  [0057B4DC], eax <br>
  :004073B4 894204&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  mov dword ptr [edx+04], eax <br>
  :004073B7 C7420800000000&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov [edx+08], 00000000 
  <br>
  :004073BE C7420C00000000&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; mov [edx+0C], 00000000 
  <br>
  :004073C5 E88AFFFFFF&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call 00407354 
  <br>
  :004073CA 5A&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; pop edx <br>
  :004073CB 58&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; pop eax <br>
  :004073CC E827C8FFFF&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; call 00403BF8 
  <br>
  :004073D1 C3&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; ret <br>
  <br>
  其中： <br>
  :0057D1C0 00 00 00 00 00 00 00 00 00 00 00 00 8C 54 3B 01 <br>
  :0057D1D0 98 54 3B 01 A4 54 3B 01 B0 54 3B 01 BC 54 3B 01 <br>
  <br>
  :004072A0 FF25E4D25700&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; jmp dword ptr 
  [0057D2E4] <br>
  <br>
  在 cs:0057d2e4 数据为: <br>
  :0057D2E0 14 57 3B 01 20 57 3B 01 <br>
  <br>
  cs:013b5720 处代码为: <br>
  :013B5720 E9C91FBBBE&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; JMP KERNEL32!GetModuleHandleA 
  <br>
  :013B5725 1000 <br>
  <br>
  :013B572C E99E1FBBBE&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; JMP KERNEL32!GetModuleFileNameA 
  <br>
  :013B5731 1000 <br>
  <br>
  继续跟踪会发现一段特别的代码： <br>
  :004013D0 FF258CD25700&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; jmp dword 
  ptr [0057D28C] <br>
  <br>
  在 cs:0057d28c 数据为： <br>
  :0057D28C C4 56 3B 01 <br>
  <br>
  :013B56C4 68CE563B01&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; PUSH DWORD 
  013B56CE <br>
  :013B56C9 E8720F2CFF&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CALL 00676640 
  <br>
  :013B56CE EB2F <br>
  <br>
  从 PE 头可知，cs:57d000 - cs:57d000 + b04 为 idata 的数据， <br>
  可见从 cs:57d1cc 开始为 first_thunk 库, 而 cs:013bxxxx 为跳转表。 <br>
  （我不知道专门的术语，请指正） <br>
  再跟踪 CALL 00676640, 发现这是一段解码程序，在很多地方都被调用。 <br>
  而且其内部用了很多硬码，如： <br>
  mov dword ptr [0067xxxx], eax <br>
  call 0066xxxx <br>
  push 0066xxxx <br>
  <br>
  通过 PE 头可知： <br>
  Size of Image : 00239000 <br>
  Image Base&nbsp; &nbsp; : 00400000 <br>
  所以程序所占地址空间为 00400000 - 00639000。 <br>
  可见 00676640, 013bxxxx 都是申请的空间，超出了程序的地址空间， <br>
  脱壳后都不会被保存。 <br>
  <br>
  这种加壳方法非常难以恢复，以至我已几乎失去信心。 <br>
  <br>
  经过几天的实验和摸索，终于找到解决方法。 <br>
  简单讲，就是扩展脱壳后的程序地址空间，然后将上述地址中的数据移回。 <br>
  我将保存 0066 和 0067 段，将 013b 段保存到 0069 段。 <br>
  （一开始我将 013b 改到 0064 或 0065， 后来发现不行，浪费了很多时间） <br>
  <br>
  具体步骤如下： <br>
  --------------------------------------------------------------------------- 
  <br>
  1、重新脱壳：（必须手动，因为 script 无法存下 ） <br>
  bpx 5764c0 <br>
  1.1 Start AATools <br>
  1.2 Interrupted by Trw2k <br>
  1.3 Quit AATools <br>
  <br>
  重复运行 1.1 - 1.3，直到 cs: 013b56c9 为 call 0067xxxx. <br>
  (0068 或 0069 占用空间太多，运气好的话有可能为 0066) <br>
  <br>
  下面以 call 00676640 为例， <br>
  键入下列命令： <br>
  W cs:00664000 L1e000 0066.bin <br>
  W cs:013b0000 L8000 013b.bin <br>
  W cs:00640000 L200 0064.bin <br>
  E cs:eip EB FE 90 <br>
  G <br>
  然后再用 ProcDump 脱壳，假设存为 aa.exe。 <br>
  将 aa.exe 中的 EB FE 90 改回 55 8B EC. Entry Point 改为 1764c0. <br>
  经过观察，动态申请的006X 内存段大小为固定的 1E000 大，013b 为 8000。 <br>
  00676640 和 00664000 的偏移好像是固定的（请自试之）。 <br>
  0064 段是后来跟踪时发现的。 <br>
  <br>
  --------------------------------------------------------------------------- 
  <br>
  2、用 topo, 在aa.exe 中加入大小为 458822 的段，这时 PE 头变为： <br>
  Name&nbsp; &nbsp;&nbsp;Virtual Size&nbsp; &nbsp;&nbsp;Virtual Offset&nbsp; &nbsp;&nbsp;Raw 
  Size&nbsp; &nbsp;&nbsp;Raw Offset <br>
  CODE&nbsp; &nbsp;&nbsp;00176000&nbsp; &nbsp;&nbsp;00001000&nbsp; &nbsp;&nbsp;001755B8&nbsp; 
  &nbsp;&nbsp;00000600 <br>
  DATA&nbsp; &nbsp;&nbsp;00004000&nbsp; &nbsp;&nbsp;00177000&nbsp; &nbsp;&nbsp;00003B30&nbsp; 
  &nbsp;&nbsp;00175C00 <br>
  BSS&nbsp; &nbsp;&nbsp;00002000&nbsp; &nbsp;&nbsp;0017B000&nbsp; &nbsp;&nbsp;00000000&nbsp; 
  &nbsp;&nbsp;0017B000 <br>
  .idata&nbsp; &nbsp;&nbsp;00004000&nbsp; &nbsp;&nbsp;0017D000&nbsp; &nbsp;&nbsp;00000B04&nbsp; 
  &nbsp;&nbsp;00179800 <br>
  .tls&nbsp; &nbsp;&nbsp;00001000&nbsp; &nbsp;&nbsp;00181000&nbsp; &nbsp;&nbsp;00000000&nbsp; 
  &nbsp;&nbsp;00181000 <br>
  .rdata&nbsp; &nbsp;&nbsp;00001000&nbsp; &nbsp;&nbsp;00182000&nbsp; &nbsp;&nbsp;00000010&nbsp; 
  &nbsp;&nbsp;0017A400 <br>
  .reloc&nbsp; &nbsp;&nbsp;00019000&nbsp; &nbsp;&nbsp;00183000&nbsp; &nbsp;&nbsp;00000000&nbsp; 
  &nbsp;&nbsp;0017A600 <br>
  .rsrc&nbsp; &nbsp;&nbsp;00086000&nbsp; &nbsp;&nbsp;0019C000&nbsp; &nbsp;&nbsp;00085BD0&nbsp; 
  &nbsp;&nbsp;0017A600 <br>
  .data&nbsp; &nbsp;&nbsp;00016000&nbsp; &nbsp;&nbsp;00222000&nbsp; &nbsp;&nbsp;000158AC&nbsp; 
  &nbsp;&nbsp;00200200 <br>
  .data&nbsp; &nbsp;&nbsp;00001000&nbsp; &nbsp;&nbsp;00238000&nbsp; &nbsp;&nbsp;00000000&nbsp; 
  &nbsp;&nbsp;00215C00 <br>
  .topo0&nbsp; &nbsp;&nbsp;00070046&nbsp; &nbsp;&nbsp;00238000&nbsp; &nbsp;&nbsp;00070200&nbsp; 
  &nbsp;&nbsp;00215C00 <br>
  <br>
  Size of Image : 2c,b000 <br>
  <br>
  这时，.topo0 中就有了 00660000 - 006A0000 的空间。 <br>
  <br>
  --------------------------------------------------------------------------- 
  <br>
  3、使用 UltraEdit 7.0 改换地址。 <br>
  <br>
  3.1 将 .idata 段的所有 013b 改为 0069。 <br>
  （最好先从aa.exe 中抽出存入 idata.bin 中） <br>
  <br>
  3.2 将 013b.bin 中的地址改换。 <br>
  如 <br>
  :013B5720 E9C91FBBBE&nbsp; &nbsp;&nbsp;(3.2.1)&nbsp; &nbsp;&nbsp;&nbsp; JMP 
  KERNEL32!GetModuleHandleA <br>
  :013B5725 1000 <br>
  如果 013B 移为 0069 的话，应为 <br>
  :00695720 E9C91F8DBF <br>
  :00695725 1000 <br>
  而 <br>
  :013B56C4 68CE563B01&nbsp; &nbsp;&nbsp;(3.2.2)&nbsp; &nbsp;&nbsp;&nbsp; PUSH 
  DWORD 013B56CE <br>
  :013B56C9 E8720F2CFF&nbsp; &nbsp;&nbsp;(3.2.3)&nbsp; &nbsp;&nbsp;&nbsp; CALL 
  00676640 <br>
  :013B56CE EB2F <br>
  改为 <br>
  :006956C4 68CE566900&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; PUSH DWORD 
  006956CE <br>
  :006956C9 E8720FFEFF&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; CALL 00676640 
  <br>
  :006956CE EB2F <br>
  <br>
  具体实施如下： <br>
  3.2.1 从 be ac 开始，一直到 be bf， ( be ad, be ae, ..., be bb, ... be bf ) <br>
  &nbsp; &nbsp;&nbsp;将 ac be 10 改为 7e bf 10 <br>
  &nbsp; &nbsp;&nbsp;将 bf be 10 改为 91 bf 10 <br>
  013b&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;0069&nbsp; &nbsp;&nbsp;( 0069 + 00d2 
  == 013b ) <br>
  be ac&nbsp; &nbsp;&nbsp;->&nbsp; &nbsp;&nbsp;bf 7e&nbsp; &nbsp;&nbsp;(2 places) 
  <br>
  ... <br>
  be bb&nbsp; &nbsp;&nbsp;->&nbsp; &nbsp;&nbsp;bf 8d <br>
  ... <br>
  be bf&nbsp; &nbsp;&nbsp;->&nbsp; &nbsp;&nbsp;bf 91&nbsp; &nbsp;&nbsp;(1 place) 
  <br>
  （由于我漏改了一处 be ac, 程序总是抛出个Exception, 说 Imagelist1.Bitmap <br>
  调用出错，以至于我调试了很久、很久...很久） <br>
  <br>
  3.2.2 将所有的 013b 改为 0069 <br>
  <br>
  3.2.3 将 2c ff, 2b ff 改为 fe ff, fd ff <br>
  013b&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;0069&nbsp; &nbsp;&nbsp;( 0069 + 00d2 
  == 013b ) <br>
  ff 2c&nbsp; &nbsp;&nbsp;->&nbsp; &nbsp;&nbsp;ff fe <br>
  ff 2b&nbsp; &nbsp;&nbsp;->&nbsp; &nbsp;&nbsp;ff fd <br>
  <br>
  3.3 改动 0066.bin，将0067:d800 后所有 013b 改为 0069。 <br>
  经过跟踪发现，程序在 0067:d800 - 0067:d9a0 处还有一段 import table 数据。 <br>
  好在数据已保存在 0066.bin 中了。 <br>
  （如果地址不同的话，我估计偏移量应该相同，00664000 - 0067d800 ） <br>
  <br>
  --------------------------------------------------------------------------- 
  <br>
  4、用 UltraEdit 恢复 aa.exe。 <br>
  Raw Offset&nbsp; &nbsp;&nbsp;Virtual Offset&nbsp; &nbsp;&nbsp;Copy Size <br>
  0021,5c00&nbsp; &nbsp;&nbsp;0063,8000 <br>
  0021,dc00&nbsp; &nbsp;&nbsp;0064,0000&nbsp; &nbsp;&nbsp;200 <br>
  0023,dc00&nbsp; &nbsp;&nbsp;0066,0000&nbsp; &nbsp;&nbsp;1,e000 <br>
  0026,dc00&nbsp; &nbsp;&nbsp;0069,0000&nbsp; &nbsp;&nbsp;8000 <br>
  <br>
  按照相应的位置和大小，将 0064.bin, 0066.bin, 013b.bin 拷贝到 aa.exe 中。 <br>
  <br>
  --------------------------------------------------------------------------- 
  <br>
  5、至此程序已完全脱壳，运行无误。 <br>
  但我发现只能在 Windows Me 下运行，不能在 Win2k Pro 运行。（同机不同硬盘） <br>
  另外，在 PWin98, 16M 机器上也不能运行。 <br>
  我只能接触到这两种机器，其他的请自试验。 <br>
  估计是要改正 PE 头，使之能够在 NT 下运行。 <br>
  <br>
  --------------------------------------------------------------------------- 
  <br>
  6、总结： <br>
  据网友说AATools 用的是一种新的 Asprotect , 此种保护实在是非常难于脱壳。 <br>
  经过我的实践，相信我的方法基本上已经可以解掉此类加壳方式。 <br>
  Cracking 其实没有什么神秘之处，只要知道了基本方法，剩下的只是耐心和毅力。 <br>
  <br>
  另：一开始我用的是 trw2k v1.21，后来刚好碰上新出的 v1.22。 <br>
  新版本稳定多了，非常好用。只可惜还是要提示，注册费也太贵。不爽而破之。:-p <br>
  <br>
  -全文完- </span></blockquote>
<hr>
<p>&nbsp; </p>
</body>
</html>
