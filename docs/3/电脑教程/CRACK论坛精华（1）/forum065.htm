<html>
<head>
<title>看雪学苑</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<style type="text/css">
<!--
.p8 {  font-size: 8pt}
.p9 {  font-size: 9pt}
a:hover {  color: #00FF00}
a {  text-decoration: none}
.p12 {  font-size: 12pt; font-weight: bold; color: #FF3333}
-->
</style>
</head>

<body bgcolor="#FFFFFF">
<span class="p9"><font color=blue>标 题:</font>软件锁的加密与解密 (2千字)<br>
<font color=blue>发信人:</font>小楼<br>
<font color=blue>时 间:</font>2000-5-26 18:46:05 <br>
<font color=blue>详细信息:</font><br>
</span>
<blockquote><span class="p9"> 软件锁的加密与解密 <br>
  <br>
  前言：本文作者是一家软件狗制造厂商，因此从制造商的角度谈了软件狗的破解问题，希望由此对我们有所启发。 <br>
  <br>
  本文见于《软件》杂志2000年第5期 <br>
  由北京飞天庆信公司提供 <br>
  http://wwwo.dongle.com.cn <br>
  <br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  软件锁的加密与解密 <br>
  &nbsp; &nbsp; 在现有的各种加密方案中，软件琐是其中的一种。在这里之所以专门讨论这个问题，是因为软件锁加密是现今世界上加密的主流方案。现在希望说明的主要是软件锁加密的安全性问题。 
  <br>
  &nbsp; &nbsp; 首先从软件锁的硬件方面进行研究。因为软件锁是插在计算机并口上的设备，依靠计算机并口微弱的电压来工作，而计算机并口的电压没有严格统一的标准，从2伏-5伏都有可能，这对于软件锁中的元器件的采用有很大的限制，最早一批的软件锁里面的核心就只是一个EEPROM能够在计算机掉电后仍然保持原有的记录。这种软件锁从硬件上没有加密性可言，只要能够找到相同的EEPROM，就能够完全的复制软件锁。再其后出现了EEPROM+计算机芯片的组合，软件锁不仅能够记录信息，而且能够产生一些数学上的变换。有些软件锁的厂家甚至把EEPROM和计算机芯片合而为一，制成专用的芯片，大大增加了软件锁硬件上的加密程度，但这种方法由于生产上的大批量要求，芯片内的设计不可能修改，一旦被解密者破解了一个芯片，所有同类型的软件锁也就被破解了。最近一年的软件锁设计大多采用了低电压CPU为基础的设计，CPU内部的程序由软件锁厂家自行写入，由于CPU程序是一次写入而且不可修改、不可读出的，安全性也比较高；另外CPU程序是由厂家来写入，厂家可以根据自己的要求随时修改软件锁内部的程序，灵活性也比较高。 
  <br>
  &nbsp; &nbsp; 其次我们从软件锁软件上来考虑一下这个问题，实际上大多数破解者攻击的只是软件锁和客户的软件方面，真正从硬件角度来破解软件锁的比较少。从结构上来说，一个使用软件锁进行加密的软件分为三个部分： 
  <br>
  &nbsp; &nbsp; 1、软件锁的驱动程序方面 <br>
  &nbsp; &nbsp; 2、软件锁提供的负责同驱动程序进行通讯的具体语言模块（OBJ、..DLL..） <br>
  &nbsp; &nbsp; 3、客户软件部分 <br>
  &nbsp; &nbsp; 其中软件琐驱动程序负责计算机用软件锁交换数据，如果这个环节的安全性比较差，那么很容易被软件锁模拟程序钻空子，尤其是交换的数据比较固定而有未加密的情况现更是如此。市面上的“打狗棒”、“WKPE”等都是基于此原理做出来的。其实这个问题很容易防范，只要在通讯过程中加入一些随机的信号就可以防止这种程序的有效运行。 
  <br>
  &nbsp; &nbsp; 第二部分具体语言的软件锁模块负责同软件驱动程序的通讯，如果驱动程序过于简单或通讯协议过于清晰，可以通过制作一个假的驱动程序来模拟所有软件锁的操作，但这种方法过于复杂，不但要对如何编制设备驱动程序有所了解，还要完全理解软件锁驱动程序的工作原理与通讯方式。所以有些破解者从另一端入手，也就是客户端程序所要调用的具体语言的通讯模块。因为有些客户端模块非常大（大于10K），而且在不同程序中的表征都相同，破解者完全可以写一段小的仿真程序来替换掉原来的软件锁客户端模块，也能达到破解的目的。 
  <br>
  &nbsp; &nbsp; 最后一部分也就是客户化程序的部分，也往往是破解者攻击的主要部分。因为软件锁的其它部分都是由软件锁的厂家来完成的，都有不同程度的加密和反跟踪成分，只有客户自己的程序是相对简单的，在用户使用的时候如果没有仔细规划一下自己的加密方案的话，所有其它的方面再严也是徒劳的。 
  <br>
  &nbsp; &nbsp; 从上面的分析我们可以看出，软件锁的使用环节很多，任何一个环节出了问题，都会造成整个加密方案的失败。厂家设计的部分相对要严密一些，而客户的使用方法往往是加密成败的关键。如果某个软件锁的访问最后可以归结为某个条件判别的话，那么一旦在这里被跳过，那么整个加密也就失去作用了。规划一套真正行之有效的加密方案，才能更好的发挥软件锁的保护功效。 
  </span></blockquote>
<hr>
</body>
</html>
