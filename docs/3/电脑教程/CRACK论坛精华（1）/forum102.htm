<html>
<head>
<title>看雪学苑</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<style type="text/css">
<!--
.p8 {  font-size: 8pt}
.p9 {  font-size: 9pt}
a:hover {  color: #00FF00}
a {  text-decoration: none}
.p12 {  font-size: 12pt; font-weight: bold; color: #FF3333}
-->
</style>
</head>

<body bgcolor="#FFFFFF">
<span class="p9"><font color=blue>序 号:</font>1882<br>
<font color=blue>标 题:</font>谁有winhex9.4的注册码？ (16字)<br>
<font color=blue>发信人:</font>isno<br>
<font color=blue>时 间:</font>2000-6-23 15:30:49<br>
<font color=blue>阅读次数:</font>18<br>
<font color=blue>详细信息:</font><br>
</span>
<blockquote> 
  <p><span class="p9">或者谁能破了它？ </span></p>
  <hr>
  <p>&nbsp;</p>
</blockquote>
<p><span class="p9"><font color=blue>标 题:</font>试试这个注册码： (45字)<br>
  <font color=blue>发信人:</font>china2000<br>
  <font color=blue>时 间:</font>2000-6-23 15:45:41<br>
  <font color=blue>阅读次数:</font>46<br>
  <font color=blue>详细信息:</font><br>
  </span></p>
<blockquote><span class="p9"> 试试这个注册码： <br>
  CODE1：78907 <br>
  CODE2：580966 </span></blockquote>
<hr>
<p><span class="p9"><font color=blue>标 题:</font>我在SMTH以前发过一篇，请进 (2千字)<br>
  <font color=blue>发信人:</font>shizg<br>
  <font color=blue>时 间:</font>2000-6-23 23:57:38<br>
  <font color=blue>阅读次数:</font>75<br>
  <font color=blue>详细信息:</font><br>
  </span></p>
<blockquote><span class="p9"> 发信人: shizg (刀客☆永远的痛), 信区: Hacker <br>
  标&nbsp; 题: Winhex的破解，大家感兴趣么？新版本也不怕哟 <br>
  发信站: BBS 水木清华站 (Fri Jun&nbsp; 9 09:47:56 2000) <br>
  &nbsp; <br>
  winhex这个编辑器功能很强大，可以改ram。当初出来新版本而老注册号不能用时， <br>
  只好自己解决。好像从9.1*版本到现在的9.41，我都是这么做的，连跟踪都不用做， <br>
  找特征串，几分钟就搞定。有了注册码，不知大家还感不感兴趣，还是贴出来， <br>
  供参考。遇到新版本也可以试试。 <br>
  要求：W32dasm，任意16进制编辑器，呵呵，比如老版本的winhex:) <br>
  &nbsp; <br>
  下面以V9.25版为例，关键代码如下： <br>
  &nbsp; :00448611 mov dword ptr [2*edi+0044B8A6], eax <br>
  &nbsp; :00448618 jmp WINHEX.00448680 <br>
  &nbsp; :0044861A mov eax, dword ptr [0044D180] <br>
  &nbsp; :0044861F call WINHEX.0042C608 <br>
  &nbsp; :00448624 cmp eax, dword ptr [0044D184] <br>
  1&nbsp; :0044862A jne 0044864A ->*******此处让它跳到0044864E，即不用做下面的比较 <br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 16进制751E改为EB22。4E-2C=22为跳的长度 <br>
  &nbsp; <br>
  &nbsp; :0044862C cmp byte ptr [0044E95D], 00 <br>
  2&nbsp; :00448633 jne 0044864E ->*******就是上面要改的地址 <br>
  &nbsp; :00448635 mov al, 03 <br>
  &nbsp; :00448637 call WINHEX.0040B5AC <br>
  &nbsp; :0044863C not ax <br>
  &nbsp; :0044863F movzx eax, ax <br>
  &nbsp; :00448642 cmp eax, dword ptr [0044D15C] <br>
  &nbsp; :00448648 je 0044864E <br>
  &nbsp; :0044864A xor eax, eax <br>
  &nbsp; :0044864C jmp WINHEX.00448650 <br>
  3&nbsp; :0044864E mov al, 01&nbsp; ->********跳到这里，要赋值了 <br>
  4&nbsp; :00448650 mov byte ptr [0044EE8B], al ->****记下0044EE8B，它就是整个程序 <br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 判断的特征地址。如为1表示注册过，因此将程 <br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 序中所有mov byte ptr [0044EE8B], 00都让它 
  <br>
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 赋1 <br>
  &nbsp; <br>
  例如： <br>
  &nbsp; :00438111 call WINHEX.004049F8 <br>
  &nbsp; :00438116 mov dword ptr [0044FCD4], eax <br>
  &nbsp; :0043811B call WINHEX.0043679C <br>
  &nbsp; :00438120 cmp byte ptr [edi+0000189F], 00 <br>
  &nbsp; :00438127 je 00438130 <br>
  &nbsp; :00438129 mov byte ptr [0044EE8B], 00&nbsp; &nbsp; ***一个需要改的地方 <br>
  &nbsp; :00438130 push 00000000 <br>
  &nbsp; :00438132 mov eax, dword ptr [0044B00C] <br>
  <br>
  &nbsp; <br>
  &nbsp; <br>
  上面是代码，拿到一个新版本，先用w32dasm反编译，然后： <br>
  1。搜索特征串mov dword ptr [2*edi+ <br>
  &nbsp; 只有一个，找到下面的jne处，改为强制跳转，例如改为jmp 0044864e， <br>
  &nbsp; 跳转长度16进制一减就可以。 <br>
  2。看0044864e处将al=1赋值给什么地址，如0044ee8b，记下 <br>
  3。查找所有赋0语句，例如mov byte ptr [0044EE8B], 00 <br>
  &nbsp; 很快找到一个，记下其16进制机器码，例如c6058bee440000，就不用找了。 <br>
  &nbsp; 全部将其替换为c6058bee440001 <br>
  4。随便一个16进制编辑器，修改即可。 </span></blockquote>
<hr>
<p><span class="p9"><font color=blue>标 题:</font>实际上在cfg里面存有code和使用次数。我最初也用这方法，但无新版本code，只好用前面的方法。从9.1开始我都... 
  (363字)<br>
  <font color=blue>发信人:</font>shizg<br>
  <font color=blue>时 间:</font>2000-6-24 8:37:09<br>
  <font color=blue>阅读次数:</font>40<br>
  <font color=blue>详细信息:</font><br>
  </span></p>
<blockquote><span class="p9"> 标题: 实际上在cfg里面存有code和使用次数。我最初也用这方法，但无新版本code，只好用前面的方法。从9.1开始我都这么干的：） 
  <br>
  <br>
  内容: <br>
  这是我最早跟9.04版时，发现cfg文件的 <br>
  : 0x90开始是winhex运行的次数. <br>
  : 0xa8开始是输入的两个code的二进制,例如8.85版本的就是: <br>
  : 81030100160e08 <br>
  : 0x10381就是66433,0x80e16就是527894&nbsp; <br>
  <br>
  BTW:这里可真是一个好地方，我也是一只菜鸟，多请教:) </span></blockquote>
<hr>
<p><span class="p9"><font color=blue>标 题:</font>试试这个注册码：cdoe1－111184，code2－785826 
  (3千字)<br>
  <font color=blue>发信人:</font>dr0<br>
  <font color=blue>时 间:</font>2000-6-24 10:34:15<br>
  <font color=blue>阅读次数:</font>66<br>
  <font color=blue>详细信息:</font><br>
  </span></p>
<blockquote><span class="p9"> http://www.winhex.com <br>
  <br>
  输入注册码之后关闭该程序，然后用bpx GetVolumeInformationA设断点， <br>
  等中断下来后按两次F12，看见如下的判断： <br>
  <br>
  0167:0044E150&nbsp; MOV&nbsp; &nbsp; &nbsp; AL,03 <br>
  0167:0044E152&nbsp; CALL&nbsp; &nbsp; &nbsp; 0040BEF8&nbsp; &nbsp; &nbsp; &nbsp; 
  //这里头调用GetVolumeInformationA <br>
  0167:0044E157&nbsp; NOT&nbsp; &nbsp; &nbsp; AX <br>
  0167:0044E15A&nbsp; MOVZX&nbsp; &nbsp; EAX,AX <br>
  0167:0044E15D&nbsp; CMP&nbsp; &nbsp; &nbsp; EAX,[0045321C] <br>
  0167:0044E163&nbsp; JNZ&nbsp; &nbsp; &nbsp; 0044E186 <br>
  0167:0044E165&nbsp; MOV&nbsp; &nbsp; &nbsp; EAX,00453258 <br>
  0167:0044E16A&nbsp; SUB&nbsp; &nbsp; &nbsp; EAX,08 <br>
  0167:0044E16D&nbsp; SUB&nbsp; &nbsp; &nbsp; EAX,10 <br>
  0167:0044E170&nbsp; MOV&nbsp; &nbsp; &nbsp; EAX,[EAX]&nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; &nbsp; //取出code1 <br>
  0167:0044E172&nbsp; CALL&nbsp; &nbsp; &nbsp; 0042E9E0&nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; &nbsp; //检查code1，并计算code2 <br>
  0167:0044E177&nbsp; MOV&nbsp; &nbsp; &nbsp; EDX,00453258 <br>
  0167:0044E17C&nbsp; SUB&nbsp; &nbsp; &nbsp; EDX,04 <br>
  0167:0044E17F&nbsp; SUB&nbsp; &nbsp; &nbsp; EDX,10 <br>
  0167:0044E182&nbsp; CMP&nbsp; &nbsp; &nbsp; EAX,[EDX]&nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; &nbsp; //比较真假code2 <br>
  0167:0044E184&nbsp; JZ&nbsp; &nbsp; &nbsp; &nbsp; 0044E18A <br>
  0167:0044E186&nbsp; XOR&nbsp; &nbsp; &nbsp; EAX,EAX&nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; &nbsp; //bad flag <br>
  0167:0044E188&nbsp; JMP&nbsp; &nbsp; &nbsp; 0044E18C <br>
  0167:0044E18A&nbsp; MOV&nbsp; &nbsp; &nbsp; AL,01&nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; &nbsp; &nbsp; //good flag <br>
  0167:0044E18C&nbsp; MOV&nbsp; &nbsp; &nbsp; EDX,00455384 <br>
  0167:0044E191&nbsp; INC&nbsp; &nbsp; &nbsp; EDX <br>
  0167:0044E192&nbsp; MOV&nbsp; &nbsp; &nbsp; [EDX],AL&nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; &nbsp; //set a flag <br>
  0167:0044E194&nbsp; JMP&nbsp; &nbsp; &nbsp; 0044E1DD <br>
  <br>
  上面的CALL 0042E9E0中会检查code1的合法性，如果合法则返回计算出来的code2，否则返回-1。 <br>
  对code1的检查是比较麻烦的，如果有兴趣可以跟踪一下，大致上是这样的：求code1的平方，并将该平方值转换为字符串， <br>
  再将串的首字符和尾字符去掉，得到一个新串，再将新串转换成整数，然后再进行其它处理。 <br>
  MOV [EDX], AL这条指令会设一个标志，用BPM EDX设断点监视此标志，很快看见如下的判断，是用来检查code1的： <br>
  <br>
  0167:0043D279&nbsp; CMP&nbsp; &nbsp; &nbsp; BYTE PTR [00455385],00 <br>
  0167:0043D280&nbsp; JNZ&nbsp; &nbsp; &nbsp; 0043D29F <br>
  0167:0043D282&nbsp; CMP&nbsp; &nbsp; &nbsp; DWORD PTR [EDI+00000088],02 <br>
  0167:0043D289&nbsp; JLE&nbsp; &nbsp; &nbsp; 0043D29F <br>
  0167:0043D28B&nbsp; PUSH&nbsp; &nbsp; &nbsp; 00 <br>
  0167:0043D28D&nbsp; PUSH&nbsp; &nbsp; &nbsp; 000DBBA0 <br>
  0167:0043D292&nbsp; PUSH&nbsp; &nbsp; &nbsp; 02 <br>
  0167:0043D294&nbsp; MOV&nbsp; &nbsp; &nbsp; EAX,[004562B0] <br>
  0167:0043D299&nbsp; PUSH&nbsp; &nbsp; &nbsp; EAX <br>
  0167:0043D29A&nbsp; CALL&nbsp; &nbsp; &nbsp; USER32!SetTimer <br>
  0167:0043D29F&nbsp; LEA&nbsp; &nbsp; &nbsp; EAX,[EDI+000000E0] <br>
  0167:0043D2A5&nbsp; SUB&nbsp; &nbsp; &nbsp; EAX,08 <br>
  0167:0043D2A8&nbsp; MOV&nbsp; &nbsp; &nbsp; EAX,[EAX]&nbsp; &nbsp; &nbsp; &nbsp; 
  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; //取出code1 <br>
  0167:0043D2AA&nbsp; MOV&nbsp; &nbsp; &nbsp; [00455424],EAX <br>
  0167:0043D2AF&nbsp; CMP&nbsp; &nbsp; &nbsp; DWORD PTR [00455424],000D9038 <br>
  0167:0043D2B9&nbsp; JG&nbsp; &nbsp; &nbsp; &nbsp; 0043D31C <br>
  0167:0043D2BB&nbsp; CMP&nbsp; &nbsp; &nbsp; DWORD PTR [00455424],00008235 <br>
  0167:0043D2C5&nbsp; JL&nbsp; &nbsp; &nbsp; &nbsp; 0043D31C <br>
  0167:0043D2C7&nbsp; MOV&nbsp; &nbsp; &nbsp; EAX,[00455424] <br>
  0167:0043D2CC&nbsp; MOV&nbsp; &nbsp; &nbsp; EBX,000003E8 <br>
  0167:0043D2D1&nbsp; CDQ <br>
  0167:0043D2D2&nbsp; IDIV&nbsp; &nbsp; &nbsp; EBX <br>
  0167:0043D2D4&nbsp; CMP&nbsp; &nbsp; &nbsp; EDX,00000247 <br>
  0167:0043D2DA&nbsp; JZ&nbsp; &nbsp; &nbsp; &nbsp; 0043D31C <br>
  0167:0043D2DC&nbsp; MOV&nbsp; &nbsp; &nbsp; EAX,[00455424] <br>
  0167:0043D2E1&nbsp; MOV&nbsp; &nbsp; &nbsp; EBX,000003E8 <br>
  0167:0043D2E6&nbsp; CDQ <br>
  0167:0043D2E7&nbsp; IDIV&nbsp; &nbsp; &nbsp; EBX <br>
  0167:0043D2E9&nbsp; CMP&nbsp; &nbsp; &nbsp; EDX,00000315 <br>
  0167:0043D2EF&nbsp; JZ&nbsp; &nbsp; &nbsp; &nbsp; 0043D31C <br>
  0167:0043D2F1&nbsp; MOV&nbsp; &nbsp; &nbsp; EAX,[00455424] <br>
  0167:0043D2F6&nbsp; MOV&nbsp; &nbsp; &nbsp; EBX,000003E8 <br>
  0167:0043D2FB&nbsp; CDQ <br>
  0167:0043D2FC&nbsp; IDIV&nbsp; &nbsp; &nbsp; EBX <br>
  0167:0043D2FE&nbsp; CMP&nbsp; &nbsp; &nbsp; EDX,7B <br>
  0167:0043D301&nbsp; JZ&nbsp; &nbsp; &nbsp; &nbsp; 0043D31C <br>
  0167:0043D303&nbsp; MOV&nbsp; &nbsp; &nbsp; EAX,[00455424] <br>
  0167:0043D308&nbsp; MOV&nbsp; &nbsp; &nbsp; ECX,00000064 <br>
  0167:0043D30D&nbsp; CDQ <br>
  0167:0043D30E&nbsp; IDIV&nbsp; &nbsp; &nbsp; ECX <br>
  0167:0043D310&nbsp; MOV&nbsp; &nbsp; &nbsp; ECX,EDX <br>
  0167:0043D312&nbsp; CMP&nbsp; &nbsp; &nbsp; ECX,07 <br>
  0167:0043D315&nbsp; JZ&nbsp; &nbsp; &nbsp; &nbsp; 0043D327 <br>
  0167:0043D317&nbsp; CMP&nbsp; &nbsp; &nbsp; ECX,54 <br>
  0167:0043D31A&nbsp; JZ&nbsp; &nbsp; &nbsp; &nbsp; 0043D327 <br>
  0167:0043D31C&nbsp; MOV&nbsp; &nbsp; &nbsp; EAX,004553A0 <br>
  0167:0043D321&nbsp; SUB&nbsp; &nbsp; &nbsp; EAX,1B <br>
  0167:0043D324&nbsp; MOV&nbsp; &nbsp; &nbsp; BYTE PTR [EAX],00&nbsp; &nbsp; &nbsp; 
  &nbsp; &nbsp; //bad guy! <br>
  0167:0043D327&nbsp; XOR&nbsp; &nbsp; &nbsp; EAX,EAX <br>
  <br>
  根据上面的代码可知code1还要满足如下几个条件： <br>
  1、code1取值范围为[0x8235，0xD9038]； <br>
  2、code1除以1000的余数不能等于0x247或者0x315或者0x7B； <br>
  3、code1除以100的余数必须为7或者0x54。 <br>
  <br>
  经过几次试探就可以找到合适的code1，继而得到对应的code2。 <br>
  code1：&nbsp; &nbsp; &nbsp; 111184 <br>
  code2：&nbsp; &nbsp; &nbsp; 785826 <br>
  <br>
  dr0/China </span></blockquote>
<hr>
</body>
</html>
