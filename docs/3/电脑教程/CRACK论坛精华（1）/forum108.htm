<html>
<head>
<title>看雪学苑</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<style type="text/css">
<!--
.p8 {  font-size: 8pt}
.p9 {  font-size: 9pt}
a:hover {  color: #00FF00}
a {  text-decoration: none}
.p12 {  font-size: 12pt; font-weight: bold; color: #FF3333}
-->
</style>
</head>

<body bgcolor="#FFFFFF">
<span class="p9"><font color=blue>标 题:</font>转载 软件诊所论坛:李伟帖的一篇《关于硬盘序列号的探讨! 》。以前有人问过这方面的问题 
(4千字)<br>
<font color=blue>发信人:</font>看雪<br>
<font color=blue>时 间:</font>2000-6-27 19:31:08 <br>
<font color=blue>详细信息:</font><br>
</span>
<blockquote><span class="p9"> From: "Wang Xianbing" &lt;Wang.Xianbing@p0.f25.n662.z6.fidonet.org> 
  <br>
  Subject: 关于硬盘序列号的探讨! <br>
  Newsgroups: programr.china <br>
  <br>
  大家好: <br>
  <br>
  近来在CFIDO和E-mail中一直有朋友询问关于如何能在Windows下用VB来 <br>
  获取硬盘序列号的问题, 因为在VB的for Windows中版本中没有了端口存取 <br>
  函数, 所以就写了一个HDIDE16.DLL的东东, 放在主页上免费发放, 并且 <br>
  HDIDE32版本的即将出台, 孰知却遭到 XXX 肆意践踏, 理由如下: <br>
  ---- CUT ---- <br>
  WX> 好久一来, 一直未能发现有用VB来获取硬盘序列号的东东, <br>
  WX> 以致于VB的程序 不能得到很好的保护, 所以昨天做了个HDIDE16.DLL, <br>
  RT> 太烦了吧! <br>
  RT> 不是我想给你泼冷水,你的WINAPI知识有点欠乏! <br>
  RT> 取计算机硬盘序列号及卷名的函数是: <br>
  RT> 这个老早我就用了. <br>
  RT> 加密方法很多种,也不一定用硬盘序列号. <br>
  RT> 可惜不能说. :))) <br>
  --- CUT --- <br>
  <br>
  对此, 我表示强烈的抗议, 并且为避免由此引起的误导, 特将基本的常识区 <br>
  分如下, 附有完整的对比源程序: <br>
  <br>
  关于盘序列号有两种: <br>
  <br>
  硬盘序列号: 英文名 Hard Disk Serial Number, 该号是出厂时生产厂家为 <br>
  区别产品而设置的, 是唯一的, 是只读的, 利用硬盘序列号的 <br>
  加密往往是利用其唯一和只读的特性, 大多是针对有序列号的 <br>
  IDE HDD而言, 对于没有序列号或SCSI HDD硬盘则无能为力, <br>
  这也是利用它进行加密的局限性. <br>
  卷的序列号: 英文名 Volume Serial Number, 该号既可指软磁盘要得, 如: <br>
  A:盘和B:盘的, 又可以指硬盘的逻辑盘, 如: C:, D:...的, <br>
  是高级格式化时随机产生的, 是可以修改的, 所以利用其进行 <br>
  加密, 其唯一性还可, 而其可修改性对于安全而言就大打折扣 <br>
  了. <br>
  <br>
  那么如何获得它们呢? 这要视不同的平台而论, 核心实现方法如下: <br>
  <br>
  DOS平台 Windows 3.X Windows 9.X <br>
  <br>
  硬盘序列号: 端口I/O 端口I/O Ring0级I/O <br>
  <br>
  卷的序列号: 中断调用 WINAPI WINAPI <br>
  <br>
  <br>
  为方便大家验证, 特贴如下两程序用TC或BC编译后运行在DOS下即可: <br>
  <br>
  /* 程序1: 获得IDE硬盘C的序列号 */ <br>
  #include &lt;stdio.h> <br>
  #include &lt;stdlib.h> <br>
  #include &lt;dos.h> <br>
  #include &lt;conio.h> <br>
  #include &lt;string.h> <br>
  <br>
  char *getascii (unsigned int in_data [], int off_start, int off_end); <br>
  <br>
  void main (void) <br>
  { <br>
  unsigned int dd [256]; /* DiskData */ <br>
  unsigned int dd_off; /* DiskData offset */ <br>
  <br>
  while (inp (0x1F7) != 0x50) /* Wait for controller not busy */ <br>
  ; <br>
  <br>
  outp (0x1F6, 0xA0); /* Get first/second drive */ <br>
  <br>
  outp (0x1F7, 0xEC); /* Get drive info data */ <br>
  <br>
  while (inp (0x1F7) != 0x58) /* Wait for data ready */ <br>
  ; <br>
  <br>
  for (dd_off = 0; dd_off != 256; dd_off++) /* Read "sector" */ <br>
  dd [dd_off] = inpw (0x1F0); <br>
  <br>
  printf ("The Serial Number Hard Disk [C] is %s", getascii (dd, 10, 19)); <br>
  <br>
  } <br>
  <br>
  char *getascii (unsigned int in_data [], int off_start, int off_end) <br>
  { <br>
  static char ret_val [255]; <br>
  int loop, loop1; <br>
  <br>
  for (loop = off_start, loop1 = 0; loop &lt;= off_end; loop++) <br>
  { <br>
  ret_val [loop1++] = (char) (in_data [loop] / 256); /* Get High byte */ <br>
  ret_val [loop1++] = (char) (in_data [loop] % 256); /* Get Low byte */ <br>
  } <br>
  ret_val [loop1] = ""; /* Make sure it ends in a NULL character */ <br>
  return (ret_val); <br>
  } <br>
  <br>
  /* 程序2: 获得逻辑盘C的序列号 */ <br>
  #include &lt;stdio.h> <br>
  #include &lt;stdlib.h> <br>
  #include &lt;ctype.h> <br>
  #include &lt;dos.h> <br>
  <br>
  void main(void) <br>
  { <br>
  char serial_no[10]; <br>
  union REGS r; <br>
  struct SREGS s; <br>
  unsigned sno1, sno2; <br>
  <br>
  r.x.ax = 0x6900; <br>
  r.h.bl = 3; /* A:=1, B:=2, C:=3 etc. */ <br>
  segread(&amp;s); <br>
  intdosx(&amp;r, &amp;r, &amp;s); <br>
  if (r.x.cflag) <br>
  *serial_no = ""; <br>
  else <br>
  { <br>
  sno2 = *((unsigned far *)MK_FP(s.ds, r.x.dx+2)); <br>
  sno1 = *((unsigned far *)MK_FP(s.ds, r.x.dx+4)); <br>
  sprintf(serial_no, "%04X-%04X <br>
  ", sno1, sno2); <br>
  } <br>
  printf("The Serial Number of Login Disk [C] is %s", serial_no ); <br>
  <br>
  } <br>
  <br>
  在Windows 3.X中: <br>
  <br>
  硬盘序列号: 使用端口I/O即可, 将以上程序稍加修改并用VC或BC做成DLL <br>
  即可在VB中调用, 本人就是这样做的. <br>
  卷的序列号: 用那位朋友所说的WINAPI函数GetVolumeInformation即可. <br>
  <br>
  在Windows 9.X中: <br>
  <br>
  硬盘序列号: 必须使用VxD技术, 即便不写VxD文件, 要获得Ring0级的访问权 <br>
  才能获得, 否则程序工作在Ring3级会死在以下语句处: <br>
  while (inp (0x1F7) != 0x50) /* Wait for controller not busy */ <br>
  详细技术请访问http://dingkai.sdxf.com <br>
  <br>
  卷的序列号: 用那位朋友所说的WINAPI函数GetVolumeInformation即可. <br>
  <br>
  <br>
  我欢迎每一位热情, 诚挚的朋友! 拒绝狂妄. <br>
  <br>
  让我们携起手来, 从小做起, 共通推动民族软件发展! <br>
  <br>
  <br>
  ~~~ 赏屯  光辉软件工作室 - 王献冰 屯屯屯屯屯屯屯屯屯屯[][⺌[X]? ? ===> 振兴民族软件 抗击北约暴行 &lt;=== ?~~~ 
  韧屯 URL: http://glowsoft.126.com E-mail: wxbing@163.net 屯图 </span></blockquote>
<hr>
</body>
</html>
