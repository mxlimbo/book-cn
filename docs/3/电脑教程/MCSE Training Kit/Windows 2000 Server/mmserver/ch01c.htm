<HTML>
<HEAD>
<TITLE>Lesson 2: Operating System Architecture</TITLE>
<link rel="STYLESHEET" type="text/css" href="mmserver.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch01b.htm", "ch01d.htm", "images/unit_p_a1.gif", "images/unit_p_a2.gif", "images/unit_p_b1.gif", "images/unit_p_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#aa22aa", "2");
//--></SCRIPT><P>

<A NAME="42"><h1>Lesson 2: Operating System Architecture</h1></A>
<p>Windows 2000 is an object-based system. In other words, it is a modular operating system made up of small, self-contained software components that work together to perform operating system tasks. Each component provides a set of functions that act as an interface to the rest of the system.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to</b> 

<ul>
<p><li>Identify the main components of the Windows 2000 operating system architecture</li></p>

<p><li>Distinguish those components in the user mode layer from those in the kernel mode layer</li></p>

<p><li>Identify the characteristics of kernel mode drivers, including Windows Driver Model (WDM) drivers</li></p>
</ul>

<b>Estimated lesson time: 45 minutes</b> 
</blockquote></div>
</p>

<A NAME="43"><h2>Windows 2000 Architectural Overview</h2></A>
<p>Windows 2000 is a portable operating system designed to run on Complex Instruction Set Computing (CISC)-based and Reduced Instruction Set Computing (RISC)-based computers. Because of this, devices and their drivers are both hardware-configurable and software-configurable. Windows 2000 is always preemptible and always interruptible, and it is designed to run uniformly on uniprocessor and SMP platforms, ensuring that code being executed on one processor does not simultaneously access and modify data being accessed and modified from another processor. Windows 2000 supports packet-driven input/output (I/O) with reusable I/O request packets (IRPs) and asynchronous I/O so that the originator of an I/O request can continue to be executed, rather than waiting for its I/O request to be completed. To support the various functionality, Windows 2000 is designed to be a modular system made up of a set of objects that can be broken into two major layers: user mode and kernel mode.</p>

<p>Figure 1.1 provides an overview of the Windows 2000 operating system architecture. Like all operating systems, Windows 2000 contains many lines of code designed to make computer hardware available to applications. Figure 1.1 merely provides a conceptual framework for understanding how the code fits together. Therefore, diagrams from different sources may vary from this one.</p>

<p>
<A HREF="javascript:fullSize('f01xx01gx.htm')"> <img src="images/f01xx01g.jpg" border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 1.1 </b> <i>Overview of the Microsoft Windows 2000 operating system architecture </i><!--/caption-->
</p>


<A NAME="44"><h2>User Mode</h2></A>
<p>The user mode layer of Windows 2000 is made up of a set of components referred to as <i>subsystems</i>. A subsystem passes I/O requests to the appropriate kernel mode driver through the I/O systems services. The subsystem insulates its end users and applications from having to know anything about kernel mode components. The user mode layer is made up of two kinds of subsystems: environment subsystems and integral subsystems.</p>

<A NAME="45"><h3>Environment Subsystems</h3></A>
<p><i>Environment subsystems</i> allow Windows 2000 to run applications written for different operating systems. These subsystems emulate different operating systems by presenting the application programming interfaces (APIs) that the applications need to be available. The environment subsystems accept the API calls made by the application, convert the API calls into a format understood by Windows 2000, and then pass the converted API to Executive components running in kernel mode.</p>

<p>The following table describes the environment subsystems in Windows 2000.</p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Environment subsystem </th>
<th>Function  </th></tr>
<tr>
<td valign="top">Win32  </td>
<td valign="top">Controls Win32-based applications and provides an environment for Win16 and Microsoft MS-DOS-based applications.  </td></tr>
<tr>
<td valign="top">POSIX   </td>
<td valign="top">Provides APIs for POSIX-based applications. <i>POSIX</i> refers to the portable operating system interface standard developed by the Institute of Electrical and Electronics Engineers (IEEE) to ensure portability of applications across different platforms.  </td></tr>
</table></p>

<p>The environment subsystems and the applications that run within them have no direct access to hardware or device drivers. They are limited to an assigned address space. Environment subsystems are forced to use hard disk space as virtual memory whenever the system needs memory. In addition, these subsystems run at a lower priority than kernel mode processes. Consequently, they have less access to CPU cycles than processes that run in kernel mode.</p>

<p>
<div class="note"><blockquote><b>NOTE</b> <hr>
Microsoft Enterprise Memory Architecture (EMA), part of Windows 2000 Advanced Server and Windows 2000 Datacenter Server, can make larger amounts of physical RAM available to applications, thereby improving their performance.</blockquote></div>
</p>

<A NAME="46"><h3>Integral Subsystems</h3></A>
<p>Integral subsystems perform essential operating system functions. The following table describes some of the important integral subsystems.</p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Integral subsystem  </th>
<th>Function  </th></tr>
<tr>
<td valign="top">Security  </td>
<td valign="top">Creates security tokens and tracks rights and permissions associated with user accounts. The subsystem accepts user logon requests and initiates logon authentication. The Security subsystem also tracks which system resources are audited.  </td></tr>
<tr>
<td valign="top">Workstation service  </td>
<td valign="top">A networking integral subsystem that provides an API to access the network redirector. The Workstation service allows a Windows 2000 computer to access the network.  </td></tr>
<tr>
<td valign="top">Server service  </td>
<td valign="top">A networking integral subsystem that provides an API to access the network server. The Server service allows a Windows 2000 computer to provide network resources.  </td></tr>
</table></p>

<A NAME="47"><h2>Kernel Mode</h2></A>
<p>The kernel mode layer of the Windows 2000 architecture has access to system data and hardware. Kernel mode provides direct access to memory and is executed in a protected memory area. It determines when a particular sequence of code is run by following prioritizing criteria. Every thread has an associated priority attribute. The kernel mode also prioritizes hardware and software interrupts so that some kernel mode code runs at higher interrupt request levels (IRQLs). The kernel mode consists of several components with well-defined functionality isolated in each component: the Executive, the Hardware Abstraction Level (HAL), and the set of kernel mode drivers.</p>

<A NAME="48"><h3>Windows 2000 Executive</h3></A>
<p>The Executive performs most of the I/O and object management, including security. Various components within the Executive, such as the Virtual Memory Manager (VMM) and the I/O Manager, define one or more object types. These components provide system services and internal routines. System services are available to both the user mode subsystems and to other Executive components. Internal routines are available only to other components within the Executive. No component is allowed to access any instance of another component's object types directly. The component must call the exported support routines in order to use another component's objects. Each component exports kernel-only support routines that manipulate instances of its object types when these routines are called. If the underlying implementation of a support routine changes over time, its caller remains portable because the interface to the defining component does not change.</p>

<p>The following table includes the kernel mode components contained in the Executive.</p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Component  </th>
<th>Function  </th></tr>
<tr>
<td valign="top">I/O Manager  </td>
<td valign="top">Provides core services for device drivers and translates user-mode read and write commands into read or write IRPs. It manages all the other main operating system IRPs. The I/O Manager manages input from and the delivery of output to different devices. The I/O Manager includes the following components: <p><b>File systems</b> Accept the oriented I/O requests and translate them into device-specific calls. The network redirector and the network server are both implemented as file system drivers.</p> <p><b>Device drivers</b> Low-level drivers that directly manipulate hardware to accept input or to write output.</p><p><b>Cache Manager</b> Improves disk I/O by storing disk reads in system memory. Cache Manager also improves write performance by caching writes to disk in the background.</p></td></tr>
<tr>
<td valign="top">Security reference monitor  </td>
<td valign="top"> Enforces security policies on the local computer. </td></tr>
<tr>
<td valign="top">Interprocess Communication (IPC) Manager </td>
<td valign="top"> Manages communication between clients and servers. The IPC Manager manages communication between environmental subsystems and the Executive. The subsystem acts like a client requesting information, and the Executive acts like a server to satisfy the request for information. The IPC Manager includes the following two components: <p><b>Local Procedure Call (LPC) facility</b> Manages communication when clients and servers exist on the same computer.</p> <p><b>Remote Procedure Call (RPC) facility</b> Manages communication when clients and servers exist on separate computers.</p></td></tr>
<tr>
<td valign="top">Virtual Memory Manager (VMM)  </td>
<td valign="top">Implements and controls virtual memory, a memory management that provides a private address space for each process and protects that address space. The VMM allows the operating system to use peripheral hard disk storage as if it is actually part of the physical memory. Virtual memory uses both physical memory and disk storage. The VMM also controls demand for paging, allowing the use of disk space as a storage area to move code and data in and out of physical RAM.  </td></tr>
<tr>
<td valign="top">Process Manager  </td>
<td valign="top">Creates and terminates processes and threads. A process is a program or part of a program, and a thread is a specific set of commands within a program. The Process Manager also suspends and resumes threads, and stores and retrieves information about processes and threads.  </td></tr>
<tr>
<td valign="top">Plug and Play (PnP) Manager  </td>
<td valign="top">Maintains central control of the Plug and Play process. The PnP Manager supports boot-time Plug and Play activity and interfaces with HAL, the Executive, and device drivers. It maintains central control, directing bus drivers to perform enumeration and configuration and directing device drivers to add and start devices. The PnP Manager coordinates with the user mode PnP counterpart to pause or remove devices as appropriate.  </td></tr>
<tr>
<td valign="top">Power Manager  </td>
<td valign="top">Controls power management APIs, coordinates power events, and generates power management IRPs. For example, when several devices request to be turned off, the Power Manager collects those requests, determines which requests must be serialized, and then generates appropriate power management IRPs.  </td></tr>
<tr>
<td valign="top">Window Manager and graphical device interface (GDI) </td>
<td valign="top">Manages the display system. These two components, implemented as  a single device driver named Win32k.sys, perform the following functions: <p><b>Window Manager</b> Controls window displays and manages screen output. Window Manager is also responsible for receiving input from devices such as the keyboard and the mouse and then passing messages to applications that are receiving input.</p> <p><b>GDI</b> Contains the functions that are required for drawing and manipulating graphics.</p></td></tr>
<tr>
<td valign="top">Object Manager  </td>
<td valign="top">Creates, manages, and deletes objects that represent operating system resources, such as processes, threads, and data structures.  </td></tr>
</table></p>

<A NAME="49"><h3>Hardware Abstraction Layer (HAL)</h3></A>
<p>The HAL virtualizes, or hides, the hardware interface details, making Windows 2000 more portable across different hardware architectures. The HAL contains the hardware-specific code that handles I/O interfaces, interrupt controllers, and multiprocessor communication mechanisms. This layer was originally designed to allow Windows 2000 to run on both Intel-based and other platforms, such as Alpha-based systems, without having to maintain two separate versions of the Windows 2000 Executive.</p>

<p>
<img src="images/cd.JPG" border="0">
</p>

<p>
<div class="note"><blockquote><b>NOTE</b> <hr>
Support for Alpha-based hardware was discontinued after Windows 2000 Release Candidate One. See the Supplemental Course Materials CD-ROM (\chapt01\articles\compaq.html) that accompanies this book.</blockquote></div>
</p>

<p>The HAL is implemented as a dynamic-link library and is responsible for all hardware-level, platform-specific support needed by every component in the system. The HAL exports support routines that hide platform-specific hardware details about caches, I/O buses, and interrupt controllers; and provides an interface between the platform's hardware and the system's software components.</p>

<A NAME="50"><h3>Kernel Mode Drivers</h3></A>
<p>Like the Windows 2000 operating system, kernel mode drivers are implemented as discrete, modular components with a well-defined set of required functionality. All kernel mode drivers, including Windows Driver Model (WDM) drivers, include a set of system-defined standard driver routines and some internal routines, depending on individual device requirements. To all other components in the system, including user mode code, a connection to a device is represented as an open operation of a file object in I/O Manager. However, within the I/O system, the logical, virtual, and physical devices for each driver are represented as device objects. Each driver's load image is represented as a driver object within I/O Manager. I/O Manager defines the object types for file objects, device objects, and driver objects. Drivers use objects by calling kernel mode support routines exported by I/O Manager and other system components.</p>

<p>Kernel mode drivers share many of the design goals of Windows 2000, including all of the following:</p>

<ul>
<p><li>Portability from one platform to another</li></p>

<p><li>Configurability of hardware and software</li></p>

<p><li>Always preemptible and always interruptible</li></p>

<p><li>Multiprocessor-safe on multiprocessor platforms</li></p>

<p><li>Object-based</li></p>

<p><li>Packet-driven I/O with reusable IRPs</li></p>

<p><li>Support for asynchronous I/O</li></p>
</ul>

<p>There are three basic types of kernel mode drivers: highest-level drivers, intermediate drivers, and lowest-level drivers, as shown in Figure 1.2.</p>

<p>
<A HREF="javascript:fullSize('f01xx02gx.htm')"> <img src="images/f01xx02g.jpg" border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 1.2</b> <i>The three types of kernel mode drivers</i><!--/caption-->
</p>

<p>Each type of kernel mode driver has a slightly different structure and quite different functionality. The following table provides an overview of each type of driver. Note that Windows Driver Model (WDM) drivers are included in the intermediate level.</p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Driver type  </th>
<th>Description  </th></tr>
<tr>
<td valign="top">Highest-level drivers  </td>
<td valign="top">Includes such files system drivers (FSDs) as the system-supplied file allocation table (FAT), NT file system (NTFS), and Compact Disk File System (CDFS) drivers. Highest-level drivers always depend on support from underlying lower-level drivers. Although an FSD may or may not get support from one or more intermediate drivers, every FSD depends on support from one or more underlying peripheral device drivers.  </td></tr>
<tr>
<td valign="top">Intermediate drivers   </td>
<td valign="top">Includes such drivers as a virtual disk, mirror, or device-type-specific class driver. Intermediate drivers depend on support from underlying lower-level drivers. Intermediate drivers also include the following drivers: <p>PnP function drivers that control specific peripheral devices on an I/O controlled by a PnP hardware bus driver;</p> <p>PnP filter drivers that insert themselves above or below PnP function drivers in the driver stack for a peripheral device;</p><p>Any system-supplied class driver that exports a system-defined WDM class/miniport interface;</p> <p>PnP software bus drivers that present a set of child devices to which higher-level class, function, or filter drivers can attach themselves;</p> <p>WDM software bus drivers.</p></td></tr>
<tr>
<td valign="top">Lowest-level drivers  </td>
<td valign="top">Includes such drivers as PnP hardware bus drivers that control an I/O bus on which some number of peripheral devices are connected. Lowest-level drivers do not depend on lower-level drivers but control physical peripheral devices such as buses. Lowest-level drivers also include legacy Windows燦T device drivers that control a physical peripheral device directly, such as the small computer system interface (SCSI) host bus adapter driver.  </td></tr>
</table></p>


<p><b>Windows Driver Model (WDM)</b></p>

<p>Some Windows 2000 kernel model drivers are also WDM drivers. WDM drivers are a subset of the intermediate level of kernel mode drivers. The WDM specification defines the architecture for hardware drivers and interfaces to the operating system. Devices that conform to WDM device driver architecture benefit from a common set of WDM I/O services and a planned binary compatibility between Windows 2000 and Windows 98 operating systems.</p>

<p>To help decrease the effort necessary for hardware vendors to support all Windows platforms, WDM enables devices designed for either Windows 2000 or Windows 98 to be installed and used with computers running under either operating system.</p>

<p>This driver model is based on a class/miniport structure that provides modular, extensible architectures for device support. WDM is a core technology for the Simply Interactive PC (SIPC) and Zero Administration initiatives and for new PnP device support for USB, IEEE 1394, and the OnNow power management initiative.</p>

<p>Each WDM class abstracts many of the common details involved in controlling similar devices. For example, consider five separate devices attached to a USB. If each driver for each device separately contained all the code needed to talk to its device over the USB, there would be five very large drivers, consisting mainly of the same code, to deal with USB communications issues. With WDM, driver developers write the generally smaller code pieces (miniports) that talk to their hardware directly and call the appropriate class driver to do the bulk of the common tasks. Another significant advantage of writing miniports is that it decreases the likelihood of introducing bugs into device driver code.</p>

<p><b>WDM Layered Architecture</b></p>

<p>WDM is a multiple-layer driver architecture that uses special class drivers to provide cross-platform support. Driver classes are layers of abstraction that allow WDM drivers to be used in both Windows 2000 and Windows 98. There are four different classes of drivers:</p>

<ul>
<p><li>Miniport drivers</li></p>

<p><li>Class drivers</li></p>

<p><li>OS services</li></p>

<p><li>Virtualization drivers</li></p>
</ul>

<p>For each bus class and hardware device class supported by WDM, Windows 2000 provides a class driver. Because Microsoft provides all platform-specific integration support for WDM, only miniports are required to be written for all hardware devices whose classes are supported by Microsoft.</p>

<p><b>Miniport Drivers</b> Miniport drivers are already implemented in Windows 2000 in the classes of SCSI and network adapters. With Windows 2000, the concept of miniport drivers has been widened to include the USB support. Miniport drivers have the following attributes:</p>

<ul>
<p><li>Indirect control of hardware through a specific bus class driver</li></p>

<p><li>Source and binary compatibility across Windows platforms</li></p>

<p><li>Dynamic loading and unloading</li></p>

<p><li>Hardware-specific functionality only</li></p>

<p><li>Capacity to expose multiple class interfaces</li></p>
</ul>

<p><b>Class Drivers</b> A class driver is best conceptualized as a driver for drivers. Class drivers provide interfaces between different layers of the WDM architecture. The lower layer of a class driver communicates with the class-specific interface exposed by a miniport driver. The upper edge of top-level class drivers is operating system-specific. Class drivers also have the following capabilities:</p>
<ul>
<p><li>Class-specific functions, not hardware-specific or bus-specific, except for bus-type class drivers</li></p>

<p><li>Dynamic loading and unloading</li></p>

<p><li>Class-specific functions only (such as enumeration)</li></p>

<p><li>Capacity to expose a single class-specific interface to multiple client layers</li></p>
</ul>

<p><b>OS Services</b> The OS services layer is always specific to the operating system. This layer abstracts all the operating system specific functionality from the miniport layers beneath it. This functionality includes:</p>
<ul>
<p><li>Thread management</li></p>

<p><li>Heap management</li></p>

<p><li>Event services</li></p>
</ul>

<p><b>Virtualization Drivers</b> Virtualization drivers have been a part of Microsoft Windows since the release of version 3.0. They are the familiar .vxd files in Windows 95 and the .386 files in earlier versions of Windows. Virtualization drivers under WDM have some very specific functions. The functions virtualize the interfaces of legacy hardware and send class-specific commands to the appropriate device. For instance, an MS-DOS game running under Windows would use the virtualization driver to work with a USB-based joystick.</p>

<p>These drivers do not access hardware directly but act as go-betweens so that legacy software or hardware can work correctly under the new architecture.</p>

<p>The WDM driver support for Windows 2000 includes:</p>

<ul>
<p><li>Stream class driver to support kernel-mode streaming of data for video capture, MPEG decoders, audio, DVD-ROM, and broadcast architectures</li></p>

<p><li>Human Interface Devices (HID) class driver to support input devices</li></p>

<p><li>USB class driver</li></p>

<p><li>IEEE 1394 bus class driver</li></p>
</ul>

<A NAME="51"><h2>Lesson Summary</h2></A>
<p>Windows 2000 is a modular operating system made up of small, self-contained software components that work together to perform operating system tasks. Windows 2000 consists of a set of objects that can be broken into two major layers: user mode and kernel mode. The main components of the user mode layer are a set of subsystems that insulate end users and applications from having to know anything about kernel mode components. There are two kinds of subsystems: environment and integral. The main components of the kernel mode layer are the Executive, the HAL, and the kernel mode drivers. The Executive performs most of the I/O and object management, including security. The HAL hides the hardware interface details and handles I/O interfaces, interrupt controllers, and multiprocessor communication mechanisms. Kernel mode drivers are implemented as discrete, modular components with a well-defined set of required functionality. There are three types of kernel mode drivers: highest-level drivers, intermediate drivers, and lowest-level drivers. Windows Driver Model (WDM) drivers are a subset of intermediate kernel mode drivers.</p>

</BODY>
</HTML>



