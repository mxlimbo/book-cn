<HTML>
<HEAD>
<TITLE>Lesson 2: Public Key Technologies</TITLE>
<link rel="STYLESHEET" type="text/css" href="mmserver.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch11b.htm", "ch11d.htm", "images/unit_p_a1.gif", "images/unit_p_a2.gif", "images/unit_p_b1.gif", "images/unit_p_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#aa22aa", "2");
//--></SCRIPT><P>

<A NAME="610"><h1>Lesson 2: Public Key Technologies</h1></A>
<p>Windows 2000 extends security by supporting a number of technologies that are based on public key security, including the Secure Channel authentication package, smart cards, Authenticode, the Encrypting File System (EFS), and Internet Protocol Security (IPSec). This lesson reviews each of these technologies and explains how they fit into the PKI framework.</p>

<p>
<div class="sidebar"><blockquote>
<b>After this lesson, you will be able to</b> 

<ul>
<p><li>Describe the primary public key-based components of Windows 2000 security</li></p>
</ul>

<b>Estimated lesson time: 35 minutes</b> 
</blockquote></div>
</p>

<A NAME="611"><h2>Secure Channel Authentication Package</h2></A>
<p>In Windows 2000, a Secure Channel (SChannel) authentication package is located below the Security Support Provider Interface (SSPI) as shown in Figure 11.7.</p>

<p>
<A HREF="javascript:fullSize('f11xx07gx.htm')"> <img src="images/f11xx07g.jpg" border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 11.7</b> <i>Authentication Services architecture in Windows 2000</i><!--/caption-->
</p>

<p>The SChannel authentication package implements the Secure Sockets Layer (SSL) 3.0 protocol and the Transport Layer Security (TLS) 1.0 protocol. SSL and TLS are flexible security protocols that can be layered on top of other transport protocols. They rely on PK-based authentication technology and use PK-based key negotiation to generate a unique encryption key for each client/server session. They are most commonly associated with Web-based applications and the HTTP protocol (referred to as HTTPS).</p>

<p>The TLS protocol is based on the SSL 3.0 protocol and moves forward as the Internet Engineering Task Force (IETF) standard. The differences between TLS 1.0 and SSL 3.0 are not significant, but they are enough that TLS 1.0 and SSL 3.0 cannot interoperate. TLS 1.0, however, does have a negotiation mechanism whereby TLS can back down to and use SSL 3.0. Therefore, a client that supports only SSL 3.0 can still communicate with a server that supports TLS 1.0.</p>

<p>Both the SSL and TLS protocols provide secure data communication through data encryption and decryption, client authentication, and optional server authentication. Both are typically used to send and receive private communication across the Internet by using public key cryptography as its authentication method.</p>

<p>The SSL/TLS protocol is implemented by an SChannel provider (such as IIS, Proxy Server, and Exchange), and by client applications that transit the Internet (such as Internet Explorer and Outlook e-mail clients). Applications request the services of SSL and TLS through the SSPI API.</p>

<p>The benefits of SSL and TLS include the following:</p>

<ul>
<p><li>Authentication that assures the client that data is sent to the correct server and that the server is secure</li></p>

<p><li>Encryption that assures that nothing other than the secure target server can read the data</li></p>

<p><li>Data integrity that assures that the transferred data has not been altered</li></p>
</ul>

<A NAME="612"><h2>Smart Cards</h2></A>
<p>Smart cards, which are the size of credit cards, can be used to store a user's public key, private key, and certificate. Smart cards are a secure way to protect and control a user's keys, instead of storing them on a computer. A user's keys and certificates move with the user. Security-critical computations are performed by the smart card, instead of exposing a user's private key to the computer. In addition, smart cards enhance software-only solutions, such as logon and secure e-mail.</p>

<p>To use a smart card, a computer must have a smart card reader. A smart card is an ISO 7816-compatible device that contains an embedded microprocessor, an RSA or equivalent cryptography coprocessor, and local storage. The local storage includes the following:</p>

<ul>
<p><li>6 to 24 KB ROM for the smart card operating system and applications</li></p>

<p><li>128 to 512 bytes of RAM for run-time data</li></p>

<p><li>1 to 16 KB EEPROM for user data</li></p>
</ul>

<A NAME="613"><h3>Smart Card Logon</h3></A>
<p>Windows 2000 introduces PK-based smart card logon as an alternative to passwords for domain authentication. This relies on a PC/SC Workgroup-compliant smart card infrastructure, first introduced for Windows NT and Windows 95 in December 1997, and RSA-capable smart cards with supporting CryptoAPI cryptographic service providers (CSPs). The authentication process makes use of the PKINIT protocol to integrate PK-based authentication with the Windows 2000 Kerberos access-control system.</p>

<p>During operation, the system recognizes a smart card insertion event as an alternative to the standard Ctrl+Alt+Del secure attention sequence to initiate a logon. The user is then prompted for the smart card PIN code, which controls access to operations with the private key stored on the smart card. In this system, the smart card also contains a copy of the user's certificate (issued by an enterprise CA). This allows the user to roam within the domain.</p>

<A NAME="614"><h2>Authenticode</h2></A>
<p>The growing use of the Internet has led to an increased reliance on downloaded active content, such as Windows-based applications, ActiveX controls, and Java applets. The result has been a heightened concern for the safety of such downloads, since they often occur as a side effect of Web scripts without any specific user notification. In response to these concerns, Microsoft introduced Authenticode digital signature technology in 1996 and introduced significant enhancements of it in 1997.</p>

<p>Authenticode technology, a security feature in Microsoft Internet Explorer, assures accountability and authenticity for software components on the Internet. Authenticode verifies that the software hasn't been tampered with and identifies the publisher of the software. Users can decide on a case-by-case basis what code to download, based on their experience with and trust in a software publisher. By signing their code, developers can build an increasingly trusting relationship with their users.</p>

<p>Authenticode technology allows software publishers to digitally sign any form of active content, including multiple-file archives. These signatures may be used to verify both the publishers of the content and the content integrity at download time. This verification infrastructure scales to the worldwide base of users of Windows by relying on a hierarchical CA structure in which a small number of commercial CAs issue software-publishing certificates. For enterprise needs, the Windows 2000 PKI allows you to issue Authenticode certificates to internal developers or contractors and allows any employee to verify the origin and integrity of downloaded applications.</p>

<A NAME="615"><h2>Encrypting File System</h2></A>
<p>EFS is an extension to the NTFS file system that provides strong data protection and encryption for files and folders. The encryption technology is based on use of public keys and runs as an integrated system service, making it easy to manage, difficult to attack, and transparent to the user. This is particularly useful for securing data on computers that may be vulnerable to theft, such as mobile computers.</p>

<p>The encrypting user's public key is used in the encryption process, ensuring data privacy. Decryption is denied to any user without the corresponding private key. A special recovery key is also generated for each encrypted file. This key is for emergency use by a qualified administrator in the event that an employee leaves or a private key is lost.</p>

<p>Encryption and decryption is done transparently during the I/O process. EFS imposes no discernible performance penalty during the encryption/decryption process.</p>

<p>EFS also supports encryption and decryption of files stored on remote NTFS volumes. However, EFS addresses only the encryption and decryption of stored data. Although encrypted files can be exported, data is transferred over the network in a clear (unencrypted) format by default. Windows 2000 provides network protocols such as SSL, TLS, and IPSec to encrypt data during transfer over the network.</p>

<A NAME="616"><h3>Data Protection</h3></A>
<p>EFS uses a combination of the user's public and private keys as well as a randomly generated file encryption key (FEK). The FEK is a 128-bit key for North America and a 40-bit key for international releases. Windows 2000 uses the Data Encryption Standard X (DESX) algorithm to encrypt files.</p>

<A NAME="617"><h3>Data Recovery</h3></A>
<p>The Encrypted Data Recovery Policy (EDRP) is used to specify who can recover data in case a user's private key is lost. An EDRP is automatically generated on stand-alone computers to minimize administration. Computers that are members of a domain receive the EDRP from the domain policy. For security, recovery is limited to the encrypted data; it is not possible to recover the users' keys.</p>

<A NAME="618"><h3>Encrypted Backup and Restoration</h3></A>
<p>Because members of the Backup Operators group do not have the keys necessary for decryption, encrypted data is read and stored in the backup as an opaque stream of data.</p>

<A NAME="619"><h3>Fault Tolerance</h3></A>
<p>Encryption and decryption are sensitive operations because failure could result in data loss. Therefore, EFS makes all operations automatic. If an operation cannot be completed, it is completely undone. For example, if a computer loses power during an encryption operation, EFS undoes the operation on restart so that the file is in a consistent state.</p>

<p>Once a file is encrypted, the processes of encryption and decryption are automatic and transparent to users and applications whenever the file is used. It is possible to perform encryption one file at a time or one folder at a time.</p>

<p>You can encrypt a file or folder in Windows Explorer and from the command prompt.</p>

<p>
<div class="note"><blockquote><b>NOTE</b> <hr>
It is not possible to use NTFS compression and encryption on the same file. Compression and encryption are mutually exclusive.
</blockquote></div>
</p>

<A NAME="620"><h3>EFS Encryption</h3></A>
<p>EFS encrypts, decrypts, and recovers files. Figure 11.8 provides an overview of the encryption process. The numbered steps shown in the illustration are described below.</p>

<p>
<A HREF="javascript:fullSize('f11xx08gx.htm')"> <img src="images/f11xx08g.JPG" border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 11.8</b> <i>EFS encryption process</i><!--/caption-->
</p>

<p>When a user encrypts a file in EFS, the following process occurs:</p>

<ol>
<p><li>The EFS service opens the file for exclusive access.</li></p>

<p><li>All data streams in the file are copied to a temporary file.</li></p>

<p><li>A file key is randomly generated and used to encrypt the file according to the DES encryption scheme.</li></p>

<p><li>A Data Decryption Field (DDF) is created that contains the file key, which is encrypted with the user's public key.</li></p>

<p><li>A Data Recovery Field (DRF) is created that contains the file key, this time encrypted with the recovery agent's public key. The recovery agent's public key is obtained from the Encrypted Data Recovery Policy (EDRP).</li></p>

<p><li>The EFS server writes the encrypted data, along with the DDF and DRF, back to the file.</li></p>
</ol>

<A NAME="621"><h3>EFS Decryption</h3></A>
<p>The decryption process uses the DDF, created during encryption, to decrypt a file. Figure 11.9 provides an overview of the decryption process. The numbered steps shown in the illustration are described below.</p>

<p>
<A HREF="javascript:fullSize('f11xx09gx.htm')"> <img src="images/f11xx09g.JPG" border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 11.9</b> <i>EFS decryption process</i><!--/caption-->
</p>

<p>When a file is decrypted in EFS, the following process occurs:</p>

<ol>
<p><li>When an application accesses an encrypted file, NTFS recognizes the file as encrypted and sends a request to the EFS driver.</li></p>

<p><li>The EFS driver retrieves the DDF and passes it to the EFS service.</li></p>

<p><li>The EFS service decrypts the DDF with the user's private key to obtain the file key.</li></p>

<p><li>The EFS service passes the file key back to the EFS driver.</li></p>

<p><li>The EFS driver uses the file key to decrypt the file.</li></p>

<p><li>The EFS driver returns the decrypted data to NTFS, which then completes the file request, and sends the data to the requesting application.</li></p>
</ol>

<A NAME="622"><h3>EFS Recovery</h3></A>
<p>The EFS recovery is much the same as the decryption process. Figure 11.10 provides an overview of the recovery process. The numbered steps shown in the illustration are described below.</p>

<p>
<A HREF="javascript:fullSize('f11xx10gx.htm')"> <img src="images/f11xx10g.jpg" border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 11.10</b> <i>EFS recovery process</i><!--/caption-->
</p>

<p>When a file is recovered in EFS, the following process occurs:</p>

<ol>
<p><li>NTFS sends a request to the EFS driver.</li></p>

<p><li>The EFS driver retrieves the DRF and passes it to the EFS service.</li></p>

<p><li>The EFS service recovers the DRF by using the recovery agent's private key to obtain the file key.</li></p>

<p><li>The EFS service passes the file key back to the EFS driver.</li></p>

<p><li>The EFS driver uses the file key to recover the file.</li></p>

<p><li>The EFS driver returns the recovered data to NTFS, which then completes the file request, and sends the data to the requesting application.</li></p>
</ol>

<A NAME="623"><h3>Cipher Command-Line Utility</h3></A>
<p>The cipher command-line utility allows you to encrypt and decrypt files from a command prompt. The command uses the following syntax:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>
cipher [/e| /d] [/s:<i>dir</i>] [/a][/i] [/f] [/q] [/h] [/k] 
[<i>pathname</i> [...]]
</pre></td></tr></table>
</p>

<p>If no parameters are used, the cipher command displays the encryption state of the current folder and any files it contains. Spaces must be put in between multiple parameters. The following table provides a description of each parameter.</p>

<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th>Parameter</th>
			<th>Description</th>
		</tr>

		<tr>
			<td valign="top">/e</td>
			<td valign="top">Encrypts the specified folders. Folders are marked so that files added to the folder later will be encrypted.</td>
		</tr>

		<tr>
			<td valign="top">/d</td>
			<td valign="top">Decrypts the specified folders. Folders are marked so that files added to the folder later will not be encrypted.</td>
		</tr>

		<tr>
			<td valign="top">/s:<i>dir</i></td>
			<td valign="top">Performs the selected operation on folders in the specified folder and all subfolders.</td>
		</tr>

		<tr>
			<td valign="top">/a</td>
			<td valign="top">Performs the selected operation on files with the specified names. If there is no matching file, this parameter is ignored.</td>
		</tr>

		<tr>
			<td valign="top">/I</td>
			<td valign="top">Continues performing the specified operation even after errors have occurred. By default, cipher stops when an error is encountered.</td>
		</tr>
		
		<tr>
			<td valign="top">/f</td>
			<td valign="top">Forces the encryption or decryption of all specified objects. By default, files that have already been encrypted or decrypted are skipped.</td>
		</tr>

		<tr>
			<td valign="top">/q</td>
			<td valign="top">Reports only the most essential information.</td>
		</tr>

		<tr>
			<td valign="top">/h</td>
			<td valign="top">Displays files with hidden or system attributes. By default, these files are not encrypted or decrypted.</td>
		</tr>

		<tr>
			<td valign="top">/k</td>
			<td valign="top">Creates a new file encryption certificate on the computer where CIPHER is run. This switch causes all other switches to be ignored. Therefore, run /k exclusive of the other switches.</td>
		</tr>

		<tr>
			<td valign="top"><i>pathname</i></td>
			<td valign="top">Specifies a pattern, file, or folder. You can use multiple filenames and wildcards.</td>
		</tr>
		
	</table>
</p>

<A NAME="624"><h3>Examples</h3></A>
<p>To encrypt the C:\My Documents directory, type <b>cipher /e &quot;My Documents&quot;</b> at the C: command prompt.</p>

<p>To encrypt all files on the C: drive with the word &quot;test&quot; in the filename, type <b>cipher /e /s *test*</b> at the C: command prompt</p>

<p>
<img src="images/practic.JPG" border="0">
</p>

<A NAME="625"><h3>Exercise 2: Configuring and Using File Encryption</h3></A>
<p>In this exercise you configure a data recovery policy in the domain, and then encrypt a folder. Complete this exercise on Server01.</p>

<p>
<img src="images/cd.JPG" border="0">
</p>

<p>
<div class="note"><blockquote><b>NOTE</b> <hr>
For additional practice, open the \chapt11\articles\efs-wp.doc on the Windows 2000 Training Supplemental CD-ROM and complete examples 2-7.
</blockquote></div>
</p>

<p><li><b>Procedure 1: Configuring a data recovery policy for the domain</b></li></p>

<p>Recovery policy is configured by default when the first domain controller is installed. As a result, a self-signed certificate assigns the domain administrator as the recovery agent. In this procedure, you manually add the administrator as the recovery agent before using EFS.</p>

<ol>
<p><li>Log on to Server01 as administrator with a password of &quot;password.&quot;</li></p>

<p><li>Click Run, verify that the URL for the Certificate Services enrollment page (<i>http://server01/certsrv/</i>) appears and then click OK.</li></p>

<p>Internet Explorer appears and it is displaying the Certificate Services enrollment page.</p>

<p><li>Verify that the Request A Certificate radio button is selected and then click Next.</li></p>

<p>The Choose Request Type page appears.</p>

<p><li>Click the Advanced Request radio button and then click Next.</li></p>

<p>The Advanced Certificate Requests page appears.</p>

<p><li>Verify that the Submit A Certificate Request To This CA Using A Form radio button is selected and then click Next.</li></p>

<p>The Advanced Certificate Requests form page appears.</p>

<p><li>From the Certificate Template drop-down list box select EFS recovery agent.</li></p>

<p><li>Click Submit.</li></p>

<p>The Certificate Issued page appears.</p>

<p><li>Click the Install This Certificate hyperlink.</li></p>

<p>A Certificate Installed page appears.</p>

<p><li>Close Internet Explorer.</li></p>
</ol>

<p>
<div class="note"><blockquote><b>NOTE</b> <hr>
You can complete all of the preceding steps in this procedure from the Group Policy snap-in. In step 19 of this procedure, you choose Create rather than Add. The Create option creates the certificate and then allows you to assign the certificate to the group policy.
</blockquote></div>
</p>

<ol start=10>
<p><li>Open the Active Directory Users And Computers snap-in from the Administrative Tools group.</li></p>

<p><li>Expand the console tree and then select the microsoft.com node.</li></p>

<p><li>Click the Action menu and then click Properties.</li></p>

<p><li>The microsoft.com Properties dialog box appears.</li></p>

<p><li>Click the Group Policy tab and then click Edit.</li></p>

<p>The Group Policy snap-in appears.</p>

<p><li>Under the Computer Configuration node, expand the Windows Settings container.</li></p>

<p><li>Under the Windows Settings container, expand the Security Settings node.</li></p>

<p><li>Under the Security Settings node, expand the Public Key Policies container.</li></p>

<p><li>Under the Public Key Policies container, expand the Encrypted Data Recovery Agents container.</li></p>

<p><li>Click the Action menu, and then click Add.</li></p>

<p>The Add Recovery Agent wizard appears.</p>

<p><li>Click Next.</li></p>

<p>The Select Recovery Agents screen appears.</p>

<p><li>Read the Select Recovery Agents screen and then click Browse Directory.</li></p>

<p>The Find Users, Contacts, And Groups dialog box appears.</p>

<p><li>Click Find Now.</li></p>

<p><li>In the list of Users And Groups, double-click Administrator.</li></p>

<p>The Select Recover Agents screen appears.</p>

<p><li>Click Next.</li></p>

<p>The Completing The Add Recovery Agent wizard appears.</p>

<p><li>Click Finish.</li></p>

<p>Administrator appears in the details pane of the Group Policy snap-in.</p>

<p><li>Click the entry in the details pane.</li></p>

<p><li>Click the Action menu and then click Properties.</li></p>

<p>The Administrator Properties dialog box appears.</p>

<p>Notice that all purposes are enabled for this certificate. The only purpose currently available for this certificate is File Recovery.</p>

<p><li>Click OK.</li></p>

<p><li>Close the Group Policy snap-in.</li></p>

<p>The microsoft.com Properties dialog box appears.</p>

<p><li>Click OK.</li></p>

<p>The Active Directory Users And Computers snap-in appears.</p>

<p><li>Click the View menu and then click Advanced Features.</li></p>

<p><li>In the console tree, click the Users container.</li></p>

<p><li>In the details pane, click Administrator.</li></p>

<p><li>Click the Action menu and then click Properties.</li></p>

<p>The Administrator Properties dialog box appears.</p>

<p><li>Click the Published Certificates tab.</li></p>

<p>The list of X.509 certificates published to this user account appears.</p>

<p>Notice that two certificates were published to the Administrator account and were issued by the Administrator account. The certificate listed as File Recovery under the Intended Purpose column is used to recover files encrypted with EFS if the original private key is lost or otherwise invalid.</p>

<p><li>Click OK.</li></p>

<p><li>Close the Active Directory Users And Computers snap-in.</li></p>
</ol>

<p><li><b>Procedure 2: Encrypting a folder using EFS</b></li></p>

<p>In this procedure, you encrypt a folder using the Windows Explorer on Server01.</p>

<ol>
<p><li>On the desktop, double-click My Computer.</li></p>

<p>The My Computer window appears.</p>

<p><li>Double-click the Local Disk (C:) drive.</li></p>

<p>The Local Disk (C:) window appears.</p>

<p><li>Double-click the Document And Settings folder.</li></p>

<p>The Document And Settings window appears.</p>

<p><li>Double-click the Administrator folder.</li></p>

<p>The Administrator window appears.</p>

<p><li>Click once on the My Documents folder.</li></p>

<p><li>Click the File menu and then click Properties.</li></p>

<p>The My Documents Properties dialog box appears.</p>

<p><li>Click the Advanced button.</li></p>

<p>The Advanced Attributes dialog box appears.</p>

<p><li>Click the Encrypt Contents To Secure Data check box and then click OK.</li></p>

<p>The My Documents Properties dialog box appears.</p>

<p><li>Click OK.</li></p>

<p>The Confirm Attribute Changes dialog box appears.</p>

<p><li>Click the Apply Changes To This Folder, Subfolders And Files radio button.</li></p>

<p><li>Click OK.</li></p>

<p>The My Documents Properties dialog box appears and then the Applying Attributes status message box appears. When the operation has completed, the My Documents Properties dialog box closes.</p>

<p><li>The Administrator window appears.</li></p>

<p>Notice that the Attributes for the selected My Documents folder is Encrypted.</p>

<p><li>Close the Administrator window.</li></p>
</ol>

<A NAME="626"><h2>IP Security</h2></A>
<p>In the <a href="ch10a.htm">previous chapter</a>, an overview of IPSec was provided in the discussion of tunneling protocols. This chapter continues with the discussion of IPSec, providing more details about how IPSec is used to support public key security.</p>

<p>IPSec in Windows 2000 is designed to protect sensitive data on a TCP/IP network. IPSec is useful when the network between two communicating computers is not secure. It provides confidentiality, integrity, and authentication of IP traffic for each packet traversing the network.</p>

<p>When using IPSec, the two computers communicating over the network first agree on the highest common security policy; then each handles the IP Security at its respective end. Before sending data across the network, the computer initiating communication transparently encrypts the data by using IP Security. The destination computer transparently decrypts the data before passing it to the destination process. Because the data is passed down to and encrypted at the IP protocol level, separate security packages are not required for each protocol in the TCP/IP suite.</p>

<p>Using IPSec to encrypt all IP network traffic ensures that any TCP/IP-based communication is secure from network eavesdropping. Any routers or switches that are in the path between the communicating computers can simply forward the encrypted IP packets.</p>

<p>
<div class="note"><blockquote><b>NOTE</b> <hr>
To ensure full compatibility with previous versions of Windows, a computer running Windows 2000 configured for IPSec sends the data without encryption to pre-Windows 2000 computers.
</blockquote></div>
</p>

<A NAME="627"><h3>IPSec Policies</h3></A>
<p>With Windows 2000 IPSec, you can create policies that define the type and level of security to be used during network communication.</p>

<p><b>Negotiation Policies</b></p>

<p>Negotiation policies determine the security services used during network communication. The security protocol chosen for negotiation policies is the basis for the security services. For example, if the IP Authentication Header protocol is chosen, integrity, authentication, and anti-replay services will be provided&#8212;but not confidentiality.</p>

<p>It is possible to set multiple security methods for each negotiation policy. If the first method is not acceptable for the security association, the service continues through an ordered list until it finds a policy it can use to establish the association. If the negotiation is not successful, the communication is established without IPSec.</p>

<p><b>IP Filters</b></p>

<p>IP filters direct actions based on the destination of an IP packet, what IP protocol is in effect, and the related ports that the protocol uses. Each IP packet is checked against the IP filter, and if a match is found, the properties of the associated security policy are used to send the communication. Filters need to be configured for both incoming and outgoing traffic.</p>

<p><b>Security Policies</b></p>

<p>Security policies are used to configure IPSec attributes. These policies are made up of associated negotiation policies and IP filters, and are associated with domain controller policies. Security policies define the type and level of security to use for any given IP network communication. An IP security policy can be assigned to the default domain policy, the default local policy, or a customized domain policy.</p>

<p>A computer logging onto a domain automatically obtains the properties of the default domain and local policies, including the IPSec policy assigned to the domain policy.</p>

<A NAME="628"><h3>IPSec Components</h3></A>
<p>The Windows 2000 installation process installs the services, protocols, and drivers necessary for IPSec:</p>

<ul>
<p><li>IPSec Policy Agent service</li></p>

<p><li>Internet Security Association and Key Management Protocol (ISAKMP)</li></p>

<p><li>Oakley Key Management protocol</li></p>

<p><li>IPSec driver</li></p>
</ul>

<p>The ISAKMP and Oakly Key Management protocols are collectively referred to as ISAKMP/Oakley (IKE) protocols.</p>

<p><b>IPSec Policy Agent Service</b></p>

<p>During system initialization, the IPSec Policy Agent service retrieves IPSec polices from the Active Directory service. The IPSec Policy Agent service passes the policy information to the IPSec network driver and the ISAKMP/Oakley protocols. The IPSec Policy Agent service does not store policies locally; instead, it must retrieve them from the Active Directory store. The IPSec Policy Agent service also starts both the ISAKMP/Oakley (IKE) protocols and the IPSec driver.</p>

<p><b>ISAKMP/Oakley IKE Protocols</b></p>

<p>Using the information in the IPSec policy, the ISAKMP/Oakley (IKE) protocols negotiate and establish a Security Association (SA) between computers. The Kerberos service authenticates the identities of the communicating computers. Finally, the ISAKMP/Oakley (IKE) protocols send the SA and key information to the IPSec driver.</p>

<p><b>IPSec Driver</b></p>

<p>This driver examines all IP packets for a match with an IP filter. If a match is found, the IPSec driver holds the packets in a queue while the ISAKMP/Oakley (IKE) protocols generate the necessary SA and key to secure the packet. After the IPSec driver receives the information from the ISAKMP/Oakley (IKE) protocols, the driver encrypts the IP packets and sends them to the destination computer.</p>

<A NAME="629"><h3>Example of IPSec Communication</h3></A>
<p>In this example, User 1 on Computer A is sending data to User 2 on Computer B. IP Security has been implemented for both computers. Figure 11.11 provides an overview of the IPSec communication process. The numbered steps in the illustration are described below.</p>

<p>
<A HREF="javascript:fullSize('f11xx11gx.htm')"> <img src="images/f11xx11g.jpg" border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 11.11</b> <i>An example of the IPSec communication process</i><!--/caption-->
</p>

<p>At the user level, the process of securing the IP packets is transparent and works as follows:</p>

<ol>
<p><li>User 1 launches an application that communicates on the network by using TCP/IP to send data to User 2. The security policies assigned to Computer A and Computer B determine the level of security for the network communication.</li></p>

<p><li>The IPSec Policy Agent service retrieves the policies and passes them to the ISAKMP/Oakley (IKE) protocols and IPSec driver.</li></p>

<p><li>The ISAKMP/Oakley (IKE) protocols on each computer use the negotiation policies associated with the assigned security policy to establish the key and a common negotiation method, or Security Association (SA). The results of the policy negotiation are passed between the two computers to the IPSec driver, which uses the key to encrypt the data.</li></p>

<p><li>Finally, the IPSec driver sends the encrypted data to Computer B. The IPSec driver on Computer B decrypts the data and passes it on to the receiving application.</li></p>
</ol>

<A NAME="630"><h2>Lesson Summary</h2></A>
<p>Windows 2000 extends security by supporting a number technologies that are based on public key security, including the SChannel authentication package, smart cards, Authenticode, the Encrypting File System (EFS), and Internet Protocol Security (IPSec). The SChannel authentication package implements SSL 3.0 and the TLS 1.0. SSL and TLS are flexible security protocols that can be layered on top of other transport protocols. Smart Cards are credit-card-sized devices that can be used to store a user's public key, private key, and certificate. Smart cards are a secure way to protect and control a user's keys, instead of storing them on a computer. Authenticode technology allows software publishers to digitally sign any form of active content, including multiple-file archives. These signatures can be used to verify both the publishers of the content and the content integrity at download time. EFS is an extension to the NTFS file system that provides strong data protection and encryption for files and folders. The encryption technology is based on the use of public keys and runs as an integrated system service. IPSec in Windows 2000 is designed to protect sensitive data on a TCP/IP network. IPSec is useful when the network between two communicating computers is not secure. It provides confidentiality, integrity, and authentication of IP traffic per packet.</p>

</BODY>
</HTML>



