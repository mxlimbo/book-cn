<HTML><!-- #BeginTemplate "/模板/software.dwt" -->
<HEAD>
<META HTTP-EQUIV='Content-Type' CONTENT='text/html; charset=gb2312'>
<META NAME='author' CONTENT='William Wan'>
<LINK REL='STYLESHEET' HREF='epcw.css' TYPE='text/css'>
<!-- #BeginEditable "doctitle" --> 
<TITLE>电脑报电子版 -- 9911请你编程</TITLE>
<!-- #EndEditable --> 
<style type="text/css">
<!--
.centertitle {  font-weight: bold; text-align: center; line-height: 35px; font-size: 9pt; color: #000000}
.lefttitle {  line-height: 35px; font-weight: bold; font-size: 9pt; color: #000000}
-->
</style>
</HEAD>
<BODY BGCOLOR='white'>
<span class="centertitle"></span> 
<TABLE BORDER='0' WIDTH='615' CELLSPACING='0' CELLPADDING='0' HEIGHT='6' ALIGN='Center' BGCOLOR='#CCCC99'>
<TR VALIGN='top'><TD WIDTH='100%'><IMG SRC='../../images/dot.gif' WIDTH='615' HEIGHT='1'></TD></TR>
</TABLE><TABLE WIDTH='615' BORDER='0' CELLSPACING='0' CELLPADDING='0' ALIGN='Center'>
<TR>
<TD WIDTH='145' BGCOLOR='#CCCC99' 	ALIGN='Center' VALIGN='top'><A HREF='http://www.yesky.com'><IMG SRC='images/logo.gif' WIDTH='140' HEIGHT='60' ALT='天极网' BORDER='0'></A></TD>
<TD WIDTH='470' BGCOLOR='#CCCC99' HEIGHT='50'><a href="http://chat.yesky.com"><img src="images/0823-3.gif" width="468" height="60" border="0"></a></TD>
</TR>
</TABLE><TABLE BORDER='0' WIDTH='615' CELLSPACING='0' CELLPADDING='0' HEIGHT='2' ALIGN='Center' BGCOLOR='#CCCC99'>
<TR>
<TD WIDTH='100%'><IMG SRC='../../images/pixel.gif' WIDTH='1' HEIGHT='1'></TD>
</TR>
</TABLE>
<TABLE BORDER='0' WIDTH='615' CELLSPACING='0' CELLPADDING='0' HEIGHT='3' ALIGN='Center' BGCOLOR='#CCCC99'>
<TR VALIGN='bottom'>
<TD WIDTH='100%'><IMG SRC='../../images/dot.gif' WIDTH='615' HEIGHT='1'></TD>
</TR></TABLE>
<table width='615' border='0' cellspacing='0' cellpadding='2' align='Center'>
  <tr> 
    <td width='615' colspan='2'><font color="#FF6666">当前位置：</font><a href='http://www.cpcw.com/issue/index.html'>CPCW电子版</a> 
      &gt; <a href='http://www.cpcw.com/issue/all.html'>2000年</a> &gt; <a href="index.html"><!-- #BeginEditable "%C6%DA" -->02期<!-- #EndEditable --></a> 
      &gt; <!-- #BeginEditable "%C0%B8%C4%BF" --><a href="software.html">软件世界</a><!-- #EndEditable --> 
      &gt; <!-- #BeginEditable "%B1%EA%CC%E2" -->{9911请你编程}<!-- #EndEditable --></td>
  </tr>
</table>
<TABLE WIDTH='615' BORDER='0' CELLSPACING='0' CELLPADDING='0' ALIGN='center'><TR ALIGN='center' VALIGN='bottom'><TD HEIGHT='6'><IMG SRC='../../images/dot.gif' WIDTH='615' HEIGHT='1'></TD></TR></TABLE>
<BR><TABLE WIDTH='615' BORDER='0' CELLSPACING='0' CELLPADDING='2' BGCOLOR='#FFCC66' ALIGN='center'>
<TR>
    <TD><SPAN CLASS='title'>《 <!-- #BeginEditable "%CE%C4%D5%C2%CD%B7" -->{9911请你编程}<!-- #EndEditable --> 
      》</SPAN></TD>
</TR></TABLE><BR><TABLE WIDTH='615' BORDER='0' CELLSPACING='0' CELLPADDING='2' ALIGN='center'>
<TR>
    <TD><!-- #BeginEditable "%CE%C4%D5%C2%C4%DA%C8%DD" -->{ 9911请你编程<br>
      　　读者朋友们新年好！《请你编程》又与你们见面了。《请你编程》得到了广大朋友的关心和支持，我在这里表示衷心的感谢。《请你编程》是一个读者朋友直接参与的栏目，是一个体现自我的园地，希望有编程愿望的朋友，无论是编程高手，还是初学者都能参与进来，我们将会认真对待每一份作品。下面请看本期重庆读者杨先飞的解法。<br>
      　　9911请你编程解题思路<br>
      　　将蜂窝形分成12个区域，如^02020401a^1：蜂房1为区域0；直线2－9－22为区域8；直线3－11－25为区域9；直线4－13－28为区域10；直线5－15－31为区域11；直线6－17－34为区域12；直线7－19－37为区域7；区域7与区域8之间为区域1，区域8与区域9之间为区域2,区域9与区域10之间为区域3,区域10与区域11之间为区域4,区域11与区域12之间为区域5,区域12与区域7之间为区域6。<br>
      然后对每个小六边形定义如^02020401b^2：<br>
      　　最后,求出与number1的边1相邻的六边形,再求出与该六边形的边1相邻的六边形,以此类推,然后求与number2的边1相邻的六边形,再检查此六边形number1是否已求出,如果还没有求出,就继续计算下一个六边形,然后再次判断……。最后在计算出的路径中选择出最短路径.程序使用Turbo 
      C＋＋ 3.00调试通过。<br>
      　　源程序<br>
      　　＃include &lt;stdio.h&gt;<br>
      　　＃include &lt;iostream.h&gt;<br>
      　　＃include &lt;stdlib.h&gt;<br>
      　　＃include &lt;conio.h&gt;<br>
      　　int cal_loca(int number)// 计算number所处的层数<br>
      　　{ int loca=2,tmp=2;<br>
      　　　while(number&gt;=tmp) {tmp=tmp＋(loca－1)＊6;loca＋＋;}<br>
      　　　return －－loca;}<br>
      　　int cal_start(int loca)// 计算loca层的开始数字,参数loca为number所处的层数<br>
      　　{ if(loca&lt;3) return loca;int i=3,start=2;<br>
      　　　for(;i&lt;=loca;i＋＋) start=start＋(i－2)＊6;return start;}<br>
      　　int which_seg(int number)//计算number位于哪条边上<br>
      　　{ if(number==1) return 0;<br>
      　　　int start,loca,a[6],i;loca=cal_loca(number);start=cal_start(loca);<br>
      　　　a[0]=start＋loca＊6－7;a[1]=start＋loca－2;<br>
      　　　for(i=2;i&lt;6;i＋＋) a[i]=a[i－1]＋loca－1;<br>
      　　　for(i=0;i&lt;6;i＋＋) if(number==a[i]) return i＋7;<br>
      　　for(i=1;i&lt;6;i＋＋) if(number&lt;a[i]) return i;return 6;}<br>
      　　int cal_round(int number,int which)//计算number的第which边相邻的数字<br>
      　　{ if(number==1) return which＋1; //区域0(即number=1)时<br>
      　　　int next_start,pre_start,dis,loca,seg,start;<br>
      　　loca=cal_loca(number);next_start=cal_start(loca＋1); pre_start=cal_start(loca－1);<br>
      　　　start=cal_start(loca);dis=number－start;seg=which_seg(number);<br>
      　　　if(seg&lt;7) //区域1－－6时<br>
      　　{ if(seg==which) return next_start＋dis＋seg;<br>
      　　if(which==(seg－1&gt;0?seg－1:6)) return next_start＋dis＋seg－1;<br>
      　　if((seg==6?1:seg＋1)==which) return number＋1;<br>
      　　if((which&lt;seg?which＋6－seg:which－seg)==4) return (dis==0?number＋loca＊6－7:number－1);<br>
      　　if((which&lt;seg?which＋6－seg:which－seg)==2) return pre_start＋dis＋1－seg;<br>
      　　return pre_start＋(dis&lt;1?loca＊6－13:dis－seg);}<br>
      　　if(seg==7) //区域7时<br>
      　　switch(which) {<br>
      　　case 1: return number＋1;<br>
      　　case 4: return number－1;<br>
      　　case 2: return start;<br>
      　　case 3: return start－1;<br>
      　　case 5: return (loca==2?7:next_start＋loca＊6－2);<br>
      　　case 6: return next_start＋loca＊6－1;}<br>
      　　if((seg－(which==1?7:which))==5) return number＋1;<br>
      　　if((seg－(which&lt;4?which＋6:which))==3) return (dis==0?7:number－1);<br>
      　　if((seg－(which==6?0:which))==8) return next_start＋dis＋(which==6?0:which);<br>
      　　if((seg－which)==7||(seg－which)==6) return next_start＋dis＋which;<br>
      　　return (loca==2?1:pre_start＋dis－(which&lt;3?which＋3:which－3));}<br>
      　　int is_reach(int ＊tmp_num1,int tmp2,int max_step)// 检查是否找到路径<br>
      　　{ int i;<br>
      　　　for(i=0;i&lt;max_step;i＋＋)<br>
      　　　if(tmp2==tmp_num1[i]) return i;//找到<br>
      　　　return max_step＋1; //没找到}<br>
      　　int cal_step(int＊tmp_num1,int＊tmp_num2,int max_step)// 寻找两个数字之间的最短路径<br>
      　　{ int path1,path2,i,step=max_step,step1;<br>
      　　　for(path1=1;path1&lt;7;path1＋＋)<br>
      　　　{ for(i=1;i&lt;max_step;i＋＋)<br>
      　　　tmp_num1[i]=cal_round(tmp_num1[i－1],path1);<br>
      　　　if((step1=is_reach(tmp_num1,tmp_num2[0],max_step))&lt;step) step=step1;<br>
      　　　for(path2=1;path2&lt;7;path2＋＋)<br>
      　　　{ for(i=1;i&lt;max_step;i＋＋)<br>
      　　　{ tmp_num2[i]=cal_round(tmp_num2[i－1],path2);<br>
      　　　step1=is_reach(tmp_num1,tmp_num2[i],max_step)＋i;<br>
      　　　if(step1&lt;step) step=step1;}}}<br>
      　　　return step;}<br>
      　　void main(void) // 主程序<br>
      　　{ int loca1,loca2,max_step,i,loop,c,number1,number2,＊tmp_num1,＊tmp_num2;<br>
      　　　FILE ＊ handle;clrscr();<br>
      　　　if((handle=fopen(&quot;network.txt&quot;,&quot;r&quot;))==NULL)<br>
      　　　{ cout&lt;&lt;&quot;\nCan't open file network.txt!&quot;; exit(1);}<br>
      　　　fscanf(handle,&quot;％i&quot;,＆loop);<br>
      　　　for(i=0;i&lt;loop;i＋＋)<br>
      　　　{ fscanf(handle,&quot;％i％c％i&quot;,＆number1,＆c,＆number2);<br>
      　　　loca1=cal_loca(number1);loca2=cal_loca(number2);<br>
      　　　max_step=(loca1&gt;loca2?loca1:loca2)＊2＋1;//两点之间的最大步数不超过 max_step　tmp_num1=(int＊)malloc(sizeof(int) 
      ＊max_step);tmp_num2=(int＊)malloc(sizeof(int) ＊max_step);<br>
      　　　tmp_num1[0]=number1;tmp_num2[0]=number2;cout&lt;&lt;number1&lt;&lt;&quot; 
      to &quot;&lt;&lt;number2&lt;&lt;&quot; need &quot;;<br>
      　　　cout&lt;&lt;cal_step(tmp_num1,tmp_num2,max_step)&lt;&lt;&quot; steps.\n&quot;;<br>
      　　　free(tmp_num1);free(tmp_num2);}<br>
      　　　fclose(handle);}<br>
      　　2000．1请你编程题目<br>
      　　有一家工厂生产一种产品，这种产品呈立方体。它的高度都为h，但底面有1×1，2×2，3×3，4×4，5×5，6×6这六种系列。现在有一种高为h，底面为6×6的箱子来装这些产品。为了节约成本，一个箱子应装尽可能多的产品。请你编程解决至少要用多少箱子来装这些产品。<br>
      　　输入：输入文件为packets.txt；输入文件有若干行，每一行有6个用空格分隔的整数；这6个整数分别表示底面从1×1到6×6每种系列产品的数量<br>
      　　输出：输出的每一行对应于输入文件中该行，表示至少要用多少箱子来装这些产品，如：<br>
      　　输入：<br>
      　　0 0 4 0 0 1<br>
      　　7 5 1 0 0 0<br>
      　　0 0 1 1 0 0<br>
      　　输出：<br>
      　　2<br>
      　　1<br>
      　　2<br>
      　　本期题目由上海的卜天明提供。<br>
      　　来稿请寄磁盘稿或用E－mail投稿，请写明解题思路和源程序（包含详细的注解），将来稿寄到电脑报编辑部的收信地址或E－mail信箱，同时欢迎提供请你编程的题目。来稿截止日期：2000年2月15日。<br>
      　　本期获奖者名单<br>
      　　（河南　廉东方）　（重庆　王忠贵）　（安徽　程正贤）　（广西　黄晓峰）　（重庆　王建）　（湖北　郑秋枫）　（四川　杨礴）　（甘肃　崔炜光）　（广东　姚丽）　（天津　孟平辉）　	
      (上海　李远志）　（新疆　胡强）<br>
      　　每位获奖者将获得苦丁香公司提供的光盘一张。<br>
      　　投稿电子邮箱：software@cpcw.com}<!-- #EndEditable --></TD>
  </TR></TABLE><TABLE WIDTH='615' BORDER='0' CELLSPACING='0' CELLPADDING='2' ALIGN='center'>
<TR>
    <TD>&nbsp;</TD>
    <TD ALIGN='right'><A HREF='#top'>页 首</A></TD>
</TR></TABLE><BR>
<TABLE WIDTH='615' BORDER='0' CELLSPACING='0' CELLPADDING='0' ALIGN='center'>
<TR ALIGN='center' VALIGN='bottom'>
<TD HEIGHT='6'><IMG SRC='../../images/dot.gif' WIDTH='615' HEIGHT='1'></TD>
</TR></TABLE><TABLE WIDTH='615' BORDER='0' CELLSPACING='0' CELLPADDING='2' ALIGN='center'>
<TR ALIGN='center'>
    <TD>
      <script language="JavaScript" src="../../download/yeskye.js">
</script>
    </TD>
    <TD> <noscript></noscript> <a href='/'>《电脑报》版权所有</a>，<a href='mailto:webmaster@staff.yesky.com'>YESKY网站编辑部</a>设计制作发布</TD>
</TR>
</TABLE></BODY><!-- #EndTemplate --></HTML>