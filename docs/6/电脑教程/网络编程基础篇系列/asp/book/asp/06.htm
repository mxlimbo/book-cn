<html>
<head>
<title>网络编程基础篇之ASP</title>
<meta http-equiv="Content-Type" content="text/html; charset=gb2312">
<link rel="stylesheet" href="ebook.css" type="text/css">
</head>
<body leftmargin="0" topmargin="0" background="bg.jpg">
<table width="100%" cellspacing="0">
  <tr>
    <td valign="top" bgcolor="#FFD26A">
      <table width="180" height="100%">
        <tr align="center" valign="top">
          <td>
            <p><img src="image.jpg"></p>
            <p><a href="list.htm"><img src="bd.gif" border="0"></a><br>
              <a href="05.htm"><img src="ap.gif" border="0"></a></p>
          </td>
        </tr>
        <tr align="center" valign="bottom">
          <td><a href="07.htm"><img src="np.gif" border="0"></a></td>
        </tr>
      </table>
    </td>
    <td valign="top">
      <blockquote>
        <div align="center"><img src="title.gif"></div>
        <!--正文开始-->
<p><font color="#0000FF">6、使用集合</font></p>  
    <p>大多数 ASP   
    内建对象支持集合。集合是存储字符串、数字、对象和其他值的地方。除了在存储或取出项目时集合会自动扩展与搜索外，集合与数组非常相近。与数组不同的是，集合被修改后，项目的位置将会移动。可以通过集合中项目的名称、索引或者通过在集合的所有项目中遍历访问项目。</p>  
    <p>通过名称和索引访问项目</p>  
    <p>通过使用项目名称可以访问集合中的具体项目。例如，Contents   
    集合拥有在 Session 对象中保存的所有变量。同样也拥有由   
    Server.CreateObject 创建的所有对象。假设在 Session   
    对象中存储了下列用户信息：</p>  
    <p>&lt;%</p>  
    <p>Session.Contents("FirstName") = "Sam"</p>  
    <p>Session.Contents("LastName") = "Woo"</p>  
    <p>Session.Contents("Age") = 29</p>  
    <p>%&gt;</p>  
    <p>可以使用在集合中存储项目时关联的名称访问项目。例如，下面的表达式返回字符串?/FONT&gt;Sam”：</p>  
    <p>&lt;%= Session.Contents("FirstName") %&gt;</p>  
    <p>通过使用与项目关联的索引或号码也可以访问项目。例如，下面的表达式检索存储在   
    Session 对象的第二个存储槽中的信息并且返回?/FONT&gt;Woo”：</p>  
    <p>&lt;%= Session.Contents(2) %&gt;</p>  
    <p>ASP 集合从 1   
    开始编号。当在集合中增加或删除项目时，与项目关联的索引将会改变。所以不能认为项目的索引始终不变。正如将在下面的主题中说明的那样，利用索引的访问一般用来遍历集合，或访问只读集合中的项目。</p>  
    <p>通过使用速记的名称可以访问项目。ASP   
    以特定的顺序搜索与对象关联的集合。如果在对象的集合中特定名称的项目只出现一次的话，可以消除该集合的名称：</p>  
    <p>&lt;%= Session("FirstName") %&gt;</p>  
    <p>访问存储在 Application 或 Session   
    对象中的项目时，消除集合名称一般是安全的。但是，对于 Request   
    对象，最好指定集合名称，因为该集合很可能包含重复的名称。</p>  
    <p>遍历集合</p>  
    <p>在集合的所有项目中遍历可以了解集合中存储的项目或修改项目。遍历集合时，必须提供集合名称。例如，可以使用   
    VBScript 中的 For...Each 语句访问存储在 Session 对象中的项目：</p>  
    <p>&lt;% </p>  
    <p>'Declare a counter variable.</p>  
    <p>Dim Item </p>  
    <p>'For each item in the collection, display its value.</p>  
    <p>For Each Item in Session.Contents </p>  
    <p>Response.Write Session.Contents(Item) &amp;   
    "&lt;BR&gt;"</p>  
    <p>Next</p>  
    <p>%&gt;</p>  
    <p>可以使用 VBScript 中的 For...Next   
    语句遍历集合。例如，要列出上例中存储在 Session   
    中的三个项目，可以使用下列语句。</p>  
    <p>&lt;% </p>  
    <p>'Declare a counter variable.</p>  
    <p>Dim Item</p>  
    <p>'Repeat the loop until the value of counter is equal to   
    3.</p>  
    <p>For Item = 1 to 3</p>  
    <p>Response.Write Session.Contents(Item) &amp;   
    "&lt;BR&gt;"</p>  
    <p>Next</p>  
    <p>%&gt;</p>  
    <p>因为一般不知道存储在集合中的项目个数，ASP   
    支持集合的 Count 属性，这个属性返回集合中的项目数。可以使用   
    Count 属性指定计数器的终值。</p>  
    <p>&lt;% </p>  
    <p>'Declare a counter variable.</p>  
    <p>Dim Item</p>  
    <p>'Repeat this loop until the counter equals the number of   
    items</p>  
    <p>'in the collection.</p>  
    <p>For Item = 1 to Session.Contents.Count</p>  
    <p>Response.Write Session.Contents(Item) &amp;   
    "&lt;BR&gt;"</p>  
    <p>Next</p>  
    <p>%&gt;</p>  
    <p>可以在脚本中使用 for   
    语句在集合中循环。在 JScript 的 for 语句中使用 Count   
    属性时，为了收到更大的效果，应该将 Count   
    值分配给本地变量并使用该变量设置计数器终值。这样，脚本引擎就不需要每次循环都查寻   
    Count 的值。下面的例子展示了这个技巧：</p>  
    <p>&lt;% </p>  
    <p>var item, numitems;</p>  
    <p>numitems = Session.Contents.Count;</p>  
    <p>for (item = 1; item &lt;= numitems; item++) {</p>  
    <p>Response.Write(Session.Contents(item) +   
    "&lt;BR&gt;")</p>  
    <p>}</p>  
    <p>%&gt;</p>  
    <p>Microsoft JScript 3.0 引入了 Enumerator   
    对象。可以使用该对象遍历 ASP 集合。atEnd   
    方法指出了集合中是否还存在项目。moveNext   
    方法移动到集合中的下一个项目。</p>  
    <p>&lt;%</p>  
    <p>// Create an Enumerator object</p>  
    <p>var mycoll = new Enumerator(Session.Contents);</p>  
    <p>//Iterate through the collection and display each item</p>  
    <p>while (!mycoll.atEnd()) {</p>  
    <p>var x = mycoll.item();</p>  
    <p>Response.Write(Session.Contents(x) +   
    "&lt;BR&gt;");</p>  
    <p>mycoll.moveNext();</p>  
    <p>}</p>  
    <p>%&gt;</p>  
    <p>遍历带子关键字 (Subkeys) 的集合</p>  
    <p>脚本在单一 cookie   
    中嵌入相关值以减少在浏览器和 Web 服务器之间传送的 cookie   
    数目。因此 Request 和 Response 对象的 Cookies   
    集合能够在单一项目中拥有多个值。这些子项目或子关键字可以被单个访问。只有   
    Request.Cookies 和 Response.Cookies 集合支持子关键字 (Subkeys)。Request.Cookies   
    只支持读操作；Response.Cookies 只支持写操作。</p>  
    <p>可以列举 Request.Cookie 集合中所有的 cookie   
    以及 Cookie 中所有的子关键字 (Subkeys)。但是，如果在没有子关键字   
    (Subkeys) 的 Cookie 上遍历子关键字，将不会产生任何结果。通过使用   
    .HasKeys 语法首先检查 cookie 是否含有子关键字 (Subkeys)，就可以避免这种情况。下面的这个例子展示了这个技巧。</p>  
    <p>&lt;% </p>  
    <p>'Declare counter variables</p>  
    <p>Dim Cookie, Subkey</p>  
    <p>'Display the entire cookie collection.</p>  
    <p>For Each Cookie in Request.Cookies</p>  
    <p>Response.Write Cookie &amp; "&lt;BR&gt;"</p>  
    <p>If Request.Cookies(Cookie).HasKeys Then</p>  
    <p>'Display the subkeys</p>  
    <p>For Each Subkey in Request.Cookies(Cookie)</p>  
    <p>Response.Write Subkey &amp; "=" &amp;   
    Request.Cookies(Cookie)(Subkey) &amp; "&lt;BR&gt;"</p>  
    <p>Next</p>  
    <p>Else</p>  
    <p>Response.Write "No subkeys in this cookie   
    &lt;BR&gt;"</p>  
    <p>End If</p>  
    <p>Next </p>  
    <p>%&gt;</p>  
    <p>遍历对象集合</p>  
    <p>Session 和 Application   
    集合可以保存数量变量或者对象实例。Contents   
    集合拥有数量变量和通过调用 Server.CreateObject 生成的对象实例。StaticObjects   
    集合拥有在 Global.asa 文件中使用 HTML &lt;OBJECT&gt; 元素创建的对象。</p>  
    <p>在遍历包含对象的集合时，可以访问对象的标识符或对象的方法和属性。例如，假设应用程序使用一些对象创建用户帐号，而且每个对象有初始化方法，可以遍历   
    StaticObjects 集合来调用每个初始化方法：</p>  
    <p>&lt;%</p>  
    <p>For Each Object in Session.StaticObjects</p>  
    <p>Session.StaticObjects(Object).InitializeUser</p>  
    <p>Next</p>  
    <p>%&gt;</p>  
    <p>ASP 集合有何不同之处？</p>  
    <p>尽管在本主题中讨论的 ASP 集合与 Visual Basic   
    的 Collection 对象非常相似，但还是有些不同。ASP 集合支持 Count   
    属性和 Item 方法，但不支持 Add 和 Remove 方法。</p>  
    <p>设置对象作用域</p>  
    <p>对象的作用域决定哪些脚本可以使用该对象。默认情况下，当您创建对象实例时，该对象具有页作用域。同一   
    ASP 页中的任何脚本命令都能使用该页作用域的对象；当 ASP   
    页送回客户端时，该对象即被释放。对大多数对象来说，推荐的作用域是页作用域。您可以改变一个对象的作用域，使其可被其他页的脚本使用。本主题将解释如何使用页作用域的对象以及如何改变对象的作用域。</p>  
    <p>使用页作用域对象</p>  
    <p>在 ASP 页上用 Server.CreateObject   
    创建的对象在该页的生存期内一直存在。该对象对该页的任何脚本命令都是可访问的，当   
    ASP   
    处理完该页时，该对象即被释放。因此，对象具有该页的作用域或生命周期。   
    </p>  
    <p>在用 Visual Basic 或 VBScript 编程时，要注意在   
    ASP   
    处理完该页之前不要释放对象。例如，以下语句经常用于通过将对象变量赋以   
    Nothing 值来释放对象：</p>  
    <p>Set myObj = Nothing</p>  
    <p>如果您在 ASP   
    页中包含了该语句，那么任何使用 myObj   
    的企图都将会返回一个预期的错误代码。但在内部，即使在对象释放以后，ASP   
    仍保留对它的引用。当您在脚本中不能使用对象时，对象的资源直到   
    ASP   
    处理完页之后才释放。同样，如果您通过创建另一个对象实例并将其赋给已使用过的对象变量来释放该对象时，ASP   
    将保留对原对象实例的引用。对大多数脚本来说，创建多个对象可能不会产生问题，但如果对象使用共享资源，比如数据库连接，就有可能出现问题。</p>  
    <p>由于对象有页作用域，所以不要依靠手工释放的对象。例如，以下的循环创建   
    1001 个 Connection 对象，它将能打开大多数的连接甚至于一个大型的 SQL   
    server：</p>  
    <p>&lt;% </p>  
    <p>For I = 0 to 1000</p>  
    <p>Set Conn =   
    Server.CreateObject("ADODB.Connection")</p>  
    <p>Conn.Open "connection string"</p>  
    <p>Next </p>  
    <p>%&gt;</p>  
    <p>总的来说，应该尽量避免在一个循环内部创建对象。如果无法避免，您应该手工释放被对象使用过的资源。如果   
    Connection   
    对象仅被创建一次，且数据资源的物理连接在每个循环中被打开然后关闭，那么上例将会正常运行：</p>  
    <p>&lt;%</p>  
    <p>Set Conn =   
    Server.CreateObject("ADODB.Connection")</p>  
    <p>For I = 0 to 1000</p>  
    <p>Conn.Open "connection string"</p>  
    <p>Conn.Close </p>  
    <p>Next</p>  
    <p>%&gt;</p>  
    <p>为对象赋予会话作用域</p>  
    <p>在应用程序中，对于每个新会话，都会创建   
    session-scope   
    对象，并且在会话结束后会将其释放。因此，每个活动的会话都有一个对象。会话作用域用于从多个脚本中调用的对象，但只影响一个用户会话。您可以只在需要时才为对象赋予会话作用域。如果确实需要使用会话作用域，那么就必须了解提供对象的组件的线程模型，因为它影响性能和对象的安全环境。详细信息，请参阅本主题的摳呒缎畔ⅲ盒阅芪侍鈹   
    。</p>  
    <p>要为对象赋予会话作用域，请将对象存储在   
    ASP Session 内建对象中，您既可以在 Global.asa 文件中使用 &lt;OBJECT&gt;   
    标记，也可以在 ASP 页上使用 Server.CreateObject   
    方法创建具有会话作用域的对象实例。 </p>  
    <p>在 Global.asa 文件中，您可用扩展了 RUNAT   
    属性（必须设置为 Sever）和 SCOPE 属性（必须设置为 Session）的   
    ;OBJECT&gt; 标记。以下示例创建一个 Ad Rotator 对象的会话作用域实例：</p>  
    <p>&lt;OBJECT RUNAT=Server SCOPE=Session ID=MyAd   
    PROGID="MSWC.Adrotator"&gt;</p>  
    <p>&lt;/OBJECT&gt;</p>  
    <p>一旦您在 Session   
    对象中存储了对象，您就可以从应用程序的任何页中访问该对象。下面的语句使用上例中由   
    &lt;OBJECT&gt; 标记创建的对象实例：</p>  
    <p>&lt;%= MyAd.GetAdvertisement("addata.txt")   
    %&gt; </p>  
    <p>在 ASP 页上，您也可以使用 Server.CreateObject   
    方法将对象存储在 Session 内建对象中。以下示例在 Session 对象中存储   
    Ad Rotator 对象的一个实例。</p>  
    <p>&lt;% Set Session("MyAd") =   
    Server.CreateObject("MSWC.Adrotator") %&gt; </p>  
    <p>要显示广告，您首先应该获取存储在 Session   
    对象中的 Ad Rotator 对象的实例，然后才能调用方法来显示对象：</p>  
    <p>&lt;% Set MyAd = Session("MyAd") %&gt; </p>  
    <p>&lt;%= MyAd.GetAdvertisement("addata.txt")   
    %&gt; </p>  
    <p>在用 &lt;OBJECT&gt; 标记声明的对象被某个 .asp   
    文件中的脚本命令引用之前，ASP 并不创建其实例。Server.CreateObject   
    方法则立即创建该对象实例。因此，对会话作用域对象来说，使用   
    &lt;OBJECT&gt; 标记要比 Server.CreateObject 属性更好。</p>  
    <p>为对象赋予应用程序作用域</p>  
    <p>application-scope   
    对象是在应用程序启动时就创建的对象的单个实例。该对象由所有客户端请求共享。仅在极少数情况下，您才需要为对象赋予应用程序作用域。一些实用程序对象，例如计数器等，可能需要应用程序作用域。但一般来说，您可用在下一节中建议的替代方案。另外，线程模型会影响性能和对象安全环境（请参阅本主题的摳呒缎畔ⅲ盒阅芪侍鈹）。</p>  
    <p>要为对象赋予应用程序作用域并将其存储在   
    ASP Application 内建对象中，既可以使用 Global.asa 文件中的 &lt;OBJECT&gt;   
    标记，也可以使用 ASP 页上的 Server.CreateObject   
    方法创建应用程序作用域的对象实例。</p>  
    <p>在 Global.asa 文件中，您可用扩展了 RUNAT   
    属性（必须设置为 Sever）和 SCOPE 属性（必须设置为 Session）的   
    ;OBJECT&gt; 标记。在 ASP 页中，您可以使用 Server.CreateObject   
    将对象实例存储在 Application 内建对象中。关于使用 &lt;OBJECT&gt;   
    标记和 Server.CreateObject   
    的示例，请参阅上一节撐韵蟾秤杌峄白饔糜驍。</p>  
    <p>会话和应用程序作用域的替代方案</p>  
    <p>仅当需要时，才能为对象赋予会话或应用程序作用域。因为在会话或应用程序结束运行之前，这些对象会一直保留。它们会占用内存或数据库连接等资源，这些资源可能会在其他方面更有用。另外，组件的线程模型会影响您从中所创建的对象的性能，尤其是那些具有会话或应用程序作用域的对象。</p>  
    <p>在很多情况下，比创建应用程序或会话作用域对象更好的方法就是利用会话或应用程序作用域变量，将信息传递给在网页一级创建的对象。例如，不要为   
    ADO Connection   
    对象赋予会话或应用程序作用域，因为它创建的连接会在相当长的一段时间一直保持打开而此时脚本已不再使用   
    ODBC 连接共享。但您可以将 ODBC 连接字符串存储在 Session 或 Application   
    内建对象中，并在网页上从创建的 Connection   
    对象实例中获取该字符串。通过这种方式，您可以存储在会话或应用程序名称空间中频繁使用的信息，但只有在需要时才创建用该信息的对象。关于作用域变量的详细信息，请参阅撌褂帽淞亢统Ａ繑。</p>  
    <p>用户自定义的 JScript 对象</p>  
    <p>您可以通过定义一个创建和初始化新对象的属性和方法的构造函数来创建自己的   
    JScript 对象。当脚本用 new   
    操作符来调用构造函数时，就会创建该对象的实例。ASP   
    脚本支持用户自定义的对象，当具有页作用域时，后者正常运行。但如果为用户自定义的   
    JScript   
    对象赋予应用程序或会话作用域，将可能影响该对象的功能。特别是，若一个对象具有会话或应用程序作用域，则其他页的脚本可以获取该对象的属性，但是却不能调用其方法。</p>  
    <p>高级信息：性能问题</p>  
    <p>组件的线程模型可能会影响 Web   
    站点的性能，一般来说，带有 Both 标记的对象是推荐在所有的 ASP   
    脚本中使用的对象，尤其是在 Session 和 Application   
    对象中。不推荐使用单线程对象。 </p>  
    <p>因为您可能不会始终控制所用对象的线程模型，所以，以下的指导可帮助您获得最佳性能：</p>  
    <p>页作用域对象。带有 Both 或 Apartment   
    标记的对象将给予您最佳的性能。 </p>  
    <p>应用程序作用域对象。一般来说，应避免在   
    Application   
    对象中放置对象。如果确需使用应用程序作用域对象，您会从结合了   
    FreeThreadedMarshaler 的带有 Both   
    标记的对象中获得最佳性能。您既可以用 &lt;OBJECT&gt; 标记也可以用   
    Server.CreateObject 方法在 Application 对象中存储带有 Single、Free 或 Both   
    标记的对象。您必须用单元线程对象来使用 &lt;OBJECT&gt; 标记。 </p>  
    <p>会话作用域对象。带有 Both   
    标记的对象将为您提供最佳性能。用单线程或单元线程对象会导致   
    Web   
    服务器将会话锁定在一个线程上。自由线程对象不会锁定会话，但运行速度不高。在   
    Session 对象中，您可以用 &lt;OBJECT&gt; 标记或 Server.CreateObject   
    方法存储对象 。 </p>  
    <p>如果您已安装了 SDK 文档，请参阅“创建 ASP   
    组件”，您将会获得有关线程模型及其隐含的组件性能的详细信息。（   
    在 Windows 95 及其后续版本中 SDK 文档不可用。）</p>  
        <!--正文结束-->
      <center>
      <hr>
      <p>本书由<a href="http://www.huiniao.com/">【灰鸟资讯】</a>免费制作<br>
          想要更多的免费电子图书，请光临<br>
          <a href="http://www.huiniao.com">http://www.huiniao.com</a></p>
      </center>
      </blockquote>
    </td>
  </tr>
</table>
</body>
</html>
