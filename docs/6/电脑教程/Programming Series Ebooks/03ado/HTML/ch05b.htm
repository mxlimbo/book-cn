<html>
<head>
<TITLE>ADO Command Object Properties and Collections</title>
<link rel="STYLESHEET" type="text/css" href="progado.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor = "#ffffff" text="#000000">
<A HREF="ch05a.htm">[Previous]</A> <A HREF="ch05c.htm">[Next]</A><P>

<A NAME="163"><H1>ADO Command Object Properties and Collections</H1></A>

<p>Let's take a closer look at the properties and collections of the Command object.</p>

<table cellpadding="5" border="0" width="95%">
<tr><th colspan="3">Command Object Properties and Collections</th></tr>
<tr><th><i>Property or Collection Name</i></th><th><i>Data Type</i></th><th><i>Description</i></th></tr>
<tr><td valign="top">ActiveConnection</td><td valign="top">String or Connection</td><td valign="top">Specifies the Connection object used to communicate with your database</td></tr>
<tr><td valign="top">CommandText</td><td valign="top">String</td><td valign="top">Contains the query string or the name of the table, view, or stored procedure you want to execute</td></tr>
<tr><td valign="top">CommandTimeout</td><td valign="top">Long</td><td valign="top">Controls the number of seconds the query will run before timing out</td></tr>
<tr><td valign="top">CommandType</td><td valign="top">CommandTypeEnum</td><td valign="top">Specifies the type of Command to execute</td></tr>
<tr><td valign="top">Name</td><td valign="top">String</td><td valign="top">Contains the name of the Command object</td></tr>
<tr><td valign="top">Parameters</td><td valign="top">Collection of Parameter objects</td><td valign="top">Contains parameter information for the query </td></tr>
<tr><td valign="top">Prepared</td><td valign="top">Boolean</td><td valign="top">Specifies whether the Command will be prepared and stored in the database</td></tr>
<tr><td valign="top">Properties</td><td valign="top">Collection of Property objects</td><td valign="top">Contains dynamic properties for the query</td></tr>
<tr><td valign="top">State</td><td valign="top">Long</td><td valign="top">Indicates the current state of the Command object</td></tr>
</table>

<A NAME="164"><H2>ActiveConnection Property</H2></A>

<p>This property is similar to the ActiveConnection property on the
Recordset object (described in <A HREF="ch04a.htm">Chapter 4</A>). You can set this property
either to a Connection object or to a connection string. If you set the
ActiveConnection property to a string, ADO will create a new Connection
object and attempt to connect to the database based on this string.</p>

<A NAME="165"><H2>CommandText Property</H2></A>

<p>The CommandText property contains the query string you want to
execute. You can use simple query strings such as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SELECT CustomerID, CompanyName, BalanceDue FROM Customers 
       WHERE CustomerID = 7
</pre>
</td></tr></table>
</p>

<p>as well as parameterized queries such as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SELECT CustomerID, CompanyName, BalanceDue FROM Customers 
       WHERE CustomerID = ?
</pre>
</td></tr></table>
</p>

<p>This property is possibly the heart of the Command object, yet it's one of the simplest and most straightforward properties.</p>

<A NAME="166"><H2>CommandTimeout Property</H2></A>

<p>Queries can hang for a number of reasons, including high network
traffic, data-locking issues, and extreme complexity. In many cases,
you'll want to cancel your query after a certain length of time.
The CommandTimeout property allows you to do so.</p>

<p>The CommandTimeout property takes a long integer that specifies the
number of seconds that ADO will wait for your query to complete before
timing out and canceling the query; it defaults to 30 seconds. If you
want your query to run indefinitely without timing out, set
CommandTimeout to 0.</p>

<p>Not all queries time out the same way. A query that generates a
client-side Recordset might run longer than the CommandTimeout setting.
The reason is that the CommandTimeout property controls how long ADO
will wait for the query to begin to return results. Once the OLE DB
provider starts to return data, ADO retrieves the rest of the results
of your query regardless of the CommandTimeout setting. With a
server-side Recordset that uses a static cursor, you might be more
likely to time out because the database's query processor might
generate the results for the entire query before returning the records
that ADO requested.</p>

<p>If the database takes more time than you've specified in the
CommandTimeout property, ADO will cancel the query and generate an
error. If you have enough expertise with your particular database, you
should be able to test this scenario by generating a query whose
results take longer to return than you've specified. For example,
I'll lock data in my Microsoft SQL Server database by modifying it
within a transaction, and then I'll submit a query on another
connection that should retrieve that same row of data to see whether
the query will time out.</p>

<A NAME="167"><H2>CommandType Property</H2></A>

<p>The CommandType property represents an attempt to simplify data
access by letting you simplify your query. You can specify what type of
query you're submitting to ADO by using the CommandType property.
For example, you can simply supply a table name as your query string
and specify a CommandType of adCmdTable. The following table shows the
CommandTypeEnum values you can use with this property.</p>

<table cellpadding="5" border="0" width="95%">
<tr><th colspan="3">CommandTypeEnum Values</th></tr>
<tr><th><i>Constant</i></th><th><i>Value</i></th><th><i>Description</i></th></tr>
<tr><td valign="top">adCmdText</td><td valign="top">1</td><td valign="top">The query will not be modified by ADO.</td></tr>
<tr><td valign="top">adCmdTable</td><td valign="top">2</td><td valign="top">ADO will append &quot;select * from &quot; to the query.</td></tr>
<tr><td valign="top">adCmdStoredProc</td><td valign="top">4</td><td valign="top">ADO will format the query as a call to a stored procedure; for example: <i>{? = CALL MyProc (?)}</i>.</td></tr>
<tr><td valign="top">adCmdUnknown</td><td valign="top">8</td><td valign="top">Default value; ADO will try different methods of executing the query until the query succeeds.</td></tr>
<tr><td valign="top">adCmdFile</td><td valign="top">256</td><td valign="top">Indicates that the CommandText property refers to a filename. Not applicable to the Command object. Applicable to the Open method on the Recordset object.</td></tr>
<tr><td valign="top">adCmdTableDirect</td><td valign="top">512</td><td valign="top">ADO will use an optional but advanced set of OLE DB API calls to retrieve all rows and columns from the table name specified. Not applicable to the Command object. Applicable to the Open method on the Recordset object.</td></tr>
</table>

<p>Wouldn't it be nice to simply supply an object name&#8212;a table
name, or the name of a stored procedure or view&#8212;instead of having
to type out the entire query, and to simply let ADO determine what to
do with that information? Maybe, maybe not.</p>

<p>I talk a little bit about why I avoid using the adCmdTable constant
in the discussion on the Recordset's <i>Open</i> method in <a href="ch04a.htm">Chapter
4</a>.</p>

<p>The default value for CommandType is adCmdUnknown. What happens if
you use this value with your query? As the name of the constant
implies, ADO does not know what type of query you're submitting. So
ADO guesses based on some internal algorithms that we won't discuss
here. Let's look at an example and see how ADO handles a Command
object whose CommandType is adCmdUnknown:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Set cmdCustomers = New ADODB.Command
Set cmdCustomers.ActiveConnection = cnNorthwind
cmdCustomers.CommandText = &quot;Customers&quot;
Set rsCustomers = New ADODB.Recordset
rsCustomers.Open cmdCustomers
</pre>
</td></tr></table>
</p>

<p>Yes, this code will work. It will successfully retrieve the contents
of the Customers table into the Recordset object. I ran similar code
against SQL Server and used the SQL Server Profiler to watch the
Transact-SQL commands that ADO submits. This is what I saw in the
log:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
exec Customers
Customers
select * from Customers
</pre>
</td></tr></table>
</p>

<p>ADO had to go through three iterations of what the query could be
before it found the right one. This is an example of why I avoid using
the default value, adCmdUnknown, as the CommandType value.</p>

<p>Quite a few programmers use the adCmdStoredProc constant. It's
similar to the adCmdTable constant except that it lets you specify only
the stored procedure name in the CommandText property rather than the
table name. However, this constant doesn't allow much control over
the way ADO handles the parameters associated with the stored
procedure. For example, you might want to call a stored procedure and
provide some values as part of the call rather than as ADO Parameter
objects. (We'll talk about the Parameter object in the second half
of this chapter.)</p>

<p>Let's see what happens to the CommandText property for the
Command object when you use the adCmdStoredProc value. In the following
code, we'll examine the contents of the CommandText property after
each call:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
With cmdStoredProc
    'Specify that the Command object will call a stored procedure.
    .CommandType = adCmdStoredProc
    'Specify the stored procedure name.
    .CommandText = &quot;MySP&quot;
    'CommandText property now contains &quot;{ call MySP }&quot;.
    'Populate the Parameters collection.
    .Parameters.Append .CreateParameter(&quot;@RetVal&quot;, adInteger, _
                                        adParamReturnValue)
    .Parameters.Append .CreateParameter(&quot;@Param1&quot;, adInteger, _
                                        adParamInput)
    .Parameters.Append .CreateParameter(&quot;@Param2&quot;, adInteger, _
                                        adParamInput)
    'CommandText property now contains &quot;{ ? = call MySP (?, ?) }&quot;.
End With
</pre>
</td></tr></table>
</p>

<p>ADO will take the value specified in the CommandText property and
format it to the ODBC standard for stored procedure calls, <i>{ call
MySP }</i>. If you populate the Parameters collection, ADO will build
that information into the CommandText property. Although this is an
efficient, appropriate, and impressive algorithm, I'd rather simply
specify the query string the way it should be formatted. In the
preceding case, I would use the following code instead:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
With cmdStoredProc
    'Specify that the Command object will use a text string.
    .CommandType = adCmdText
    .CommandText = &quot;{? = CALL MySP(?,?)}&quot;
    'Populate the Parameters collection.
    .Parameters.Append .CreateParameter(&quot;@RetVal&quot;, adInteger, _
                                        adParamReturnValue)
    .Parameters.Append .CreateParameter(&quot;@Param1&quot;, adInteger, _
                                        adParamInput)
    .Parameters.Append .CreateParameter(&quot;@Param2&quot;, adInteger, _
                                        adParamOutput)
End With
</pre>
</td></tr></table>
</p>

<p>This code specifies parameters, but the values must be provided
elsewhere. However, by using adCmdText and maintaining full control
over the query string that ADO will submit as we've done here, you
can modify this code to supply some parameter values in line. Suppose
your sample stored procedure took an input parameter followed by an
output parameter. If you know the value you want to submit for the
input parameter, you can build it into your code this way:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
With cmdStoredProc
    .CommandType = adCmdText
    .CommandText = &quot;{? = CALL MySP(&quot; &amp; intParam1 &amp; &quot;,?)}&quot;
    .Parameters.Append .CreateParameter(&quot;@RetVal&quot;, adInteger, _
                                        adParamReturnValue)
    .Parameters.Append .CreateParameter(&quot;@Param2&quot;, adInteger, _
                                        adParamOutput)
End With
</pre>
</td></tr></table>
</p>

<p>You don't need to use a Parameter object for the input parameter
if you plan to call this stored procedure only once. With the
adCmdStoredProc constant, you don't have this level of control.</p>

<p>In short, you should avoid using adCmdUnknown (the default),
adCmdStoredProc, and adCmdTable for the CommandType property.</p>

<A NAME="168"><H2>Name Property</H2></A>

<p>The Command object exposes a Name property, which stores a string.
This property is set to an empty string by default. The Name property
is read/write prior to setting ActiveConnection, at which point it
becomes read-only.</p>

<p>The Name property serves two purposes. First, it helps you better
trap for asynchronous events. The Command object doesn't expose
events, so if you execute commands asynchronously, you might need to
use events exposed by the Connection and Recordset objects to check the
status of the operation. Since you'll probably execute more than
one query on a particular Connection object, you need to be able to
determine which query fired the event you're currently
trapping.</p>

<p>Here's an example: The Connection object's <i>
ExecuteComplete</i> event uses a <i>pCommand</i> parameter to specify
which query generated the event. Rather than having to use the
Microsoft Visual Basic Is operator or examine a lengthy string in the
CommandText property on the <i>pCommand</i> parameter, you can choose
to examine the Name property instead, assuming you set this property
earlier in your code.</p>

<p>There's a second use for the Name property, which I file under
&quot;Just because you can, that doesn't mean you should.&quot;
Once you set the Name property on the Command object and set the
ActiveConnection property to a Connection object, you can execute the
command as if it were a method on the Connection object, as shown in
the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
strSQL = &quot;SELECT OrderID FROM Orders WHERE OrderDate &gt;= ? AND&quot; &amp; _
         &quot; OrderDate &lt;= ?&quot;
'Create the Command object.
Set qryOrderRange = New ADODB.Command
With qryOrderRange
    'Set the Name of the qryOrderRange command to OrderRange.
    .Name = &quot;OrderRange&quot;
    .CommandText = strSQL
    'Create the parameters to insert into the query string.
    .Parameters.Append .CreateParameter(&quot;@Start&quot;, adDBTimeStamp, _
                                        adParamInput)
    .Parameters.Append .CreateParameter(&quot;@EndDate&quot;, adDBTimeStamp, _
                                        adParamInput)
    'Set the Command object's ActiveConnection property.
    .ActiveConnection = cnNorthwind
End With
Set rsOrders = New ADODB.Recordset
rsOrders.CursorLocation = adUseClient
'Use the Name of the qryOrderRange object to access the query
' through the Connection object.
cnNorthwind.OrderRange #8/1/1996#, #8/31/1996#, rsOrders
</pre>
</td></tr></table>
</p>

<p>While it's a neat trick, code like this uses late binding, so it
runs slower than code that uses the <i>Execute</i> method on the
Command object or the <i>Open</i> method on the
Recordset object.</p>

<A NAME="169"><H2>Parameters Collection</H2></A>

<p>The Command object exposes a Parameters collection, which we'll
discuss a little later in this chapter.</p>

<A NAME="170"><H2>Prepared Property</H2></A>

<p>Some database systems allow you to compile a query once and execute
it multiple times with different parameters. Essentially, this feature
is similar to a temporary stored procedure. The Command property
exposes this functionality through the Prepared property. The Prepared
property stores a Boolean value and defaults to False.</p>

<p>To determine whether setting this property to True will improve the
performance of your application, your best bet is to run your own
tests. I've yet to see any definitive statistics that explain under
what circumstances Prepared should be set to True. Through my own
testing, I've found that using this property with SQL Server 7
actually decreases performance even when executing the same query
repeatedly. Your mileage can vary.</p>

<A NAME="171"><H2>Properties Collection</H2></A>

<p>Like most ADO objects, the Command object exposes a Properties
collection whose contents depend on your choice of OLE DB provider.
Unlike with the Connection, Recordset, and Field objects, however,
there's generally no need to use these properties with the Command
object.</p>

<A NAME="172"><H2>State Property</H2></A>

<p>Just like the Connection and Recordset objects, the Command object
exposes a State property. The State property takes an ObjectStateEnum
type, but only two values from ObjectStateEnum apply to the Command
object: adStateClosed and adStateExecuting. If you execute the command
asynchronously (with either the <i>Command.Execute</i> or the <i>
Recordset.Open</i> method), the State property of the Command object
will return adStateExecuting while ADO awaits the results of the query.
Once the Connection object's <i>ExecuteComplete</i> event fires,
this property is reset to adStateClosed.</p>

<p>If you're also using the ADO Cursor Engine's asynchronous
fetching feature, the Command object's State property is set to
adStateClosed once the ADO Cursor Engine has retrieved the initial set
of rows. I don't recommend using the Command object again until ADO
has fetched all the results for the query. Wait for the Recordset
object's <i>FetchComplete</i> event to fire, or make sure the
Recordset's State property is set to 1 (adStateOpen) and not 9
(adStateOpen + adStateFetching).</p>

</BODY>
</HTML>






