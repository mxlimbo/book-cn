<html>
<head>
<TITLE>ADO Field Object Properties</title>
<link rel="STYLESHEET" type="text/css" href="progado.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor = "#ffffff" text="#000000">
<A HREF="ch04e.htm">[Previous]</A> <A HREF="ch04g.htm">[Next]</A><P>

<A NAME="145"><H1>ADO Field Object Properties</H1></A>

<p>Let's take a closer look at the properties of the Field object.
This next table offers a preliminary description of each property.</p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th colspan="3">Field Object Properties  </th></tr>
<tr>
<th><i>Property Name</i>  </th>
<th><i>Data Type</i>  </th>
<th><i>Description</i>  </th></tr>
<tr>
<td valign="top">ActualSize  </td>
<td valign="top">Long </td>
<td valign="top">Returns the actual size of a field's value  </td></tr>
<tr>
<td valign="top">Attributes  </td>
<td valign="top">Long   </td>
<td valign="top">Describes characteristics of the field  </td></tr>
<tr>
<td valign="top">DataFormat  </td>
<td valign="top">Object  </td>
<td valign="top">Can be used to format your data  </td></tr>
<tr>
<td valign="top">DefinedSize  </td>
<td valign="top">Long   </td>
<td valign="top">Returns the defined size for a field  </td></tr>
<tr>
<td valign="top">Name  </td>
<td valign="top">String  </td>
<td valign="top">Contains the name of the field  </td></tr>
<tr>
<td valign="top">NumericScale  </td>
<td valign="top">Byte  </td>
<td valign="top">Indicates the numeric scale for numeric data  </td></tr>
<tr>
<td valign="top">OriginalValue   </td>
<td valign="top">Variant  </td>
<td valign="top">Contains the original value for the field  </td></tr>
<tr>
<td valign="top">Precision  </td>
<td valign="top">Byte  </td>
<td valign="top">Indicates the precision for numeric data  </td></tr>
<tr>
<td valign="top">Properties  </td>
<td valign="top">Collection of Property objects  </td>
<td valign="top">Collection of dynamic properties </td></tr>
<tr>
<td valign="top">Type  </td>
<td valign="top">Byte  </td>
<td valign="top">Returns the data type for the field  </td></tr>
<tr>
<td valign="top">UnderlyingValue  </td>
<td valign="top">Variant  </td>
<td valign="top">Indicates the most recently retrieved value from the database for the field  </td></tr>
<tr>
<td valign="top">Value   </td>
<td valign="top">Variant  </td>
<td valign="top">Contains the current value for the field  </td></tr>
</table></p>


<A NAME="146"><H2>ActualSize Property</H2></A>

<p>The ActualSize property tells you how much data actually exists in
your field. This property is read-only and is primarily intended for
variable length strings or binary data. For example, if you define an
Address field to hold up to 64 characters, you can check the ActualSize
property to find out how much data actually exists in the field without
having to examine the contents of the Value property. The ActualSize
property is also helpful when dealing with long variable and binary
data types.</p>

<p>As of ADO 2.1, it is possible for the ActualSize property to be
larger than the DefinedSize property. If you're using a Unicode
data type, the DefinedSize property will return the number of Unicode
characters that the field can hold. The ActualSize property will return
the length of that string in bytes. Thus, the ActualSize property value
is twice the number of Unicode characters.</p>

<A NAME="147"><H2>Attributes Property</H2></A>

<p>The Attributes property contains metadata about the field, such as
whether it's updatable or nullable. The property is a bitmask and
is the sum of one or more values from FieldAttributeEnum, as shown in
the following table.</p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th colspan="3">FieldAttributeEnum Values  </th></tr>
<tr>
<th><i>Constant </i>  </th>
<th><i>Value </i>  </th>
<th><i>Description</i>  </th></tr>
<tr>
<td valign="top">adFldMayDefer  </td>
<td valign="top">2  </td>
<td valign="top">The data is retrieved separately from the other
fields in your Recordset. This behavior is common for long text or
binary fields with server-side Recordsets that support scrolling.  </td></tr>
<tr>
<td valign="top">adFldUpdatable  </td>
<td valign="top">4   </td>
<td valign="top">The field is updatable.  </td></tr>
<tr>
<td valign="top">adFldUnknownUpdatable  </td>
<td valign="top">8   </td>
<td valign="top">The provider cannot determine if the data is
updatable.  </td></tr>
<tr>
<td valign="top">adFldFixed   </td>
<td valign="top">16   </td>
<td valign="top">The field contains fixed-length data such as an
integer.  </td></tr>
<tr>
<td valign="top">adFldIsNullable  </td>
<td valign="top">32  </td>
<td valign="top">The field accepts Null values.  </td></tr>
<tr>
<td valign="top">adFldMayBeNull  </td>
<td valign="top">64   </td>
<td valign="top">The field can contain Null values.  </td></tr>
<tr>
<td valign="top">adFldLong   </td>
<td valign="top">128   </td>
<td valign="top">The field contains long string or binary data. You can
use the <i>AppendChunk</i> and <i>GetChunk</i> methods.  </td></tr>
<tr>
<td valign="top">adFldRowID   </td>
<td valign="top">256  </td>
<td valign="top">The field contains a row identifier.  </td></tr>
<tr>
<td valign="top">adFldRowVersion  </td>
<td valign="top">512  </td>
<td valign="top">The field contains some kind of time or date
stamp used to track updates.  </td></tr>
<tr>
<td valign="top">adFldCacheDeferred   </td>
<td valign="top">4096   </td>
<td valign="top">The provider caches field values, and
subsequent reads are done from the cache.  </td></tr>
<tr>
<td valign="top">adFldIsChapter  </td>
<td valign="top">8192  </td>
<td valign="top">The Field corresponds to a chapter in a
hierarchical Recordset.  </td></tr>
<tr>
<td valign="top">adFldNegativeScale  </td>
<td valign="top">16384  </td>
<td valign="top">The field has a negative value for its
numeric scale. (For example, 12,000 with a numeric scale of -3 would be
stored as 12.)  </td></tr>
<tr>
<td valign="top">adFldKeyColumn   </td>
<td valign="top">32768   </td>
<td valign="top">The field is part of the primary key.  </td></tr>
<tr>
<td valign="top">adFldIsRowURL  </td>
<td valign="top">65536  </td>
<td valign="top">For fields exposed by the Record object; the
value of the field corresponds to the location of the Record.  </td></tr>
<tr>
<td valign="top">adFldIsDefaultStream  </td>
<td valign="top">131072   </td>
<td valign="top">For fields exposed by the Record object;
the field contains the default stream of data for the Record.  </td></tr>
<tr>
<td valign="top">adFldIsCollection  </td>
<td valign="top">262144  </td>
<td valign="top">For fields exposed by the Record object;
the field contains a collection of data.  </td></tr>
</table></p>


<A NAME="148"><H2>DataFormat Property</H2></A>

<p>You can use the DataFormat property on a field to control how the
data is retrieved or displayed. This feature is fairly well explained
in the Visual Basic documentation. The DataFormat property is also
exposed on most Visual Basic controls that you can bind to a field,
such as a TextBox. The property is basically a pointer to a DataFormat
object, which extends the functionality available in the Visual Basic
<i>Format</i> function.</p>

<p>Possibly the best use of this feature is to display True, False, and
Null values. In order to use the DataFormat property on a Field object,
you must reference the Microsoft Data Formatting Object Library
(MSStdFmt.dll) and use the StdDataFormat object. The following code
uses a StdDataFormat object on a bit field in the Products table of the
Northwind database:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim fmtDiscontinued As StdFormat.StdDataFormat
<img src="images/grayvellip.JPG" width=3 height=13 border=0>
strSQL = &quot;SELECT * FROM Products&quot;
rsProducts.Open strSQL, cnNorthwind, adOpenStatic

Set fmtDiscontinued = New StdFormat.StdDataFormat
fmtDiscontinued.Type = fmtBoolean
fmtDiscontinued.TrueValue = &quot;Discontinued&quot;
fmtDiscontinued.FalseValue = &quot;Currently Produced&quot;
Set rsProducts!Discontinued.DataFormat = fmtDiscontinued
</pre>
</td></tr></table>
</p>

<p>Checking the Value property of the Discontinued field will now
return &quot;Currently Produced&quot; or &quot;Discontinued&quot;
instead of True/False or 0/1.</p>

<A NAME="149"><H2>DefinedSize Property</H2></A>

<p>The DefinedSize property contains the defined size for a field. This
property is a long data type and is read-only. Generally, this
information is helpful when you're using a variable-length string
or binary field. The ADO documentation implies that the property
returns the size of the field in bytes.</p>

<p>As of ADO 2.1, the DefinedSize property returns the number of
characters a variable length string field supports rather than the
number of bytes. Thus, both ANSI (single-byte) and Unicode
(double-byte) string fields that accept the same number of their
respective characters have the same value for the DefinedSize property.
This behavior is different from that of the related property,
ActualSize. With that property, the returned value is the number of
bytes in the string, rather than the number of characters.</p>

<A NAME="150"><H2>Name Property</H2></A>

<p>The Name property contains the name of the Field object in string
format. Generally, this property will refer to the name of the column
in the table that you're querying. With most OLE DB providers, you
can use an AS clause to choose a different name if you don't want
to use the column name.</p>

<p><div class="sidebar"><blockquote>
<b>Using the Name Property with Join Queries</b>

<p>If you're using a Recordset based on a join query, the behavior
of the Name property will depend on how the OLE DB provider or ODBC
driver returns data about the columns in the results of your query.
Using ADO 2.5 and the OLE DB Provider For SQL Server as a test, I
submitted a join query that retrieved data from the Customers and
Orders tables, basing the relationship on the CustomerID field:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
strSQL = &quot;SELECT * FROM Customers, Orders WHERE &quot; &amp; _
         &quot;Customers.CustomerID = Orders.CustomerID&quot;
</pre>
</td></tr></table>
</p>

<p>I found that as I examined the Name property of each Field
object, there were two fields with the same name&#8212;CustomerID. Keep
in mind that you'll see the same behavior with the SQL Server query
tools. I then used the Jet 4.0 OLE DB Provider, and the two fields came
back with different values for the Name
property&#8212;Customers.CustomerID and Orders.CustomerID. Compare this
to using RDO with SQL Server, which returned two rdoColumn objects of
different names&#8212;CustomerID and CustomerID1.</p>

<p>If you're going to use Recordsets based on a join, test to see
whether your query returns multiple Field objects with the same value
for the Name property. If that's the case and it poses a problem,
your best bet is to use AS clauses in your query to ensure unique
column names in the results.</p></blockquote></div>
</p>

<A NAME="151"><H2>NumericScale Property</H2></A>

<p>Used for numeric data, the NumericScale property returns the scale
of the numeric values for the field. This property contains a byte
value and indicates the number of digits to the right of the decimal
point that you can store in the field. For example, if you used a
numeric data type in your database to store monetary units and did not
store fractions of a cent, then NumericScale would be 2.</p>

<p>It's possible for a database to use a negative value for a
numeric scale, though I'm not aware of any databases or providers
that implement this functionality. There is a value in
FieldAttributeEnum called adFldNegativeScale that would (we hope) be
used to indicate that a field has a negative value for its numeric
scale. This could come in handy for large numbers with limited
precision. For example, if you wanted to keep track of the past lottery
jackpots and decrease the amount of data to store, you could store 5
with a NumericScale of -6 to represent $5 million.</p>

<A NAME="152"><H2>OriginalValue Property</H2></A>

<p>When you're editing the Recordset, the OriginalValue property
contains the data for the Value property of the Field object before it
was edited. This property is read-only and returns a Variant.</p>

<p>If you're using a LockType of adLockOptimistic or
adLockPessimistic, the OriginalValue property contains the value for
the field prior to editing. If you call <i>CancelUpdate</i> while
editing the current record, the Value property on each field will be
set to the OriginalValue property. Once you modify the value of a field
and successfully update that record with the <i>Update</i> method on
the Recordset object, the OriginalValue property on the Field is set to
the newly submitted value.</p>

<p>In batch optimistic update mode, using <i>CancelUpdate</i> to cancel
changes to a record while that record's EditMode is
adEditInProgress resets the Value property on each Field to the
OriginalValue property. Because calling the <i>Update</i> method in
this mode caches only the pending changes in the Recordset rather than
actually modifying the data in your database, the OriginalValue
property is not updated until you call <i>UpdateBatch</i>. After
you've called the <i>Update</i> method, canceling the pending
changes in a record by calling <i>CancelBatch</i> will reset the Value
property on the Field objects to the OriginalValue property.</p>

<p>We'll talk more about this property in <A HREF="ch10a.htm">Chapter 10</A>, when we
examine how the ADO Cursor Engine submits changes to your database.</p>

<A NAME="153"><H2>Precision Property</H2></A>

<p>The Precision property returns the maximum number of digits that the
field can store, including digits to the right of the decimal point.
This property is read-only and contains a byte value.</p>

<A NAME="154"><H2>Properties Collection</H2></A>

<p>Like most ADO objects, the Field object exposes a Properties
collection. The contents of the collection will depend on the OLE DB
provider, CursorLocation, CursorType, and LockType. We'll discuss
many of the dynamic properties specific to the ADO Cursor Engine in
Chapters <a href="ch10a.htm">10</a> and <a href="ch12a.htm">12</a> of this book.</p>

<A NAME="155"><H2>Type Property</H2></A>

<p>The Type property on a Field object contains a byte value from
DataTypeEnum. For more information on the contents of DataTypeEnum,
please see the ADO documentation in the Microsoft Data Access
Components (MDAC) SDK and Platform SDK. This property is read-only. See
the discussion of creatable Recordsets in the section &quot;<A HREF="ch04e.htm#139"><i>Append</i> Method</A>&quot; for more information
on how to use the Type property.</p>

<A NAME="156"><H2>UnderlyingValue Property</H2></A>

<p>You can use the UnderlyingValue property to check the current
field's value in your database. This property is not available for
read-only Recordsets. With some OLE DB providers, this property will
contain live data when using a server-side Recordset. If you're
using a client-side Recordset, this data is not live and can be
retrieved by using the <i>Resync</i> method. The UnderlyingValue
property can also be updated by a failed optimistic update attempt on a
client-side Recordset if you're using the Update Resync dynamic
property with the adResyncConflicts constant.</p>

<p>The UnderlyingValue property is read-only and contains a Variant.
We'll discuss this property in more depth when we discuss conflict
detection in <A HREF="ch12a.htm">Chapter 12</A>.</p>

<A NAME="157"><H2>Value Property</H2></A>

<p>The data you retrieved from your query is stored in the Value
property. This property is the default property on the Field object, so
you generally do not need to explicitly call the Value property when
you want to examine the contents of a field. The Value property
contains a Variant and is read/write only if your Recordset supports
updates.</p>

<p>ADO supports setting and returning long string and binary data with
the Value property.</p>

</BODY>
</HTML>






