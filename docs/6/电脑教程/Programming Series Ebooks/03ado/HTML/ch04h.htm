<html>
<head>
<title>Questions That Should Be Asked More Frequently</title>
<LINK REL=STYLESHEET HREF="progado.css" TYPE="text/css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<A HREF="ch04g.htm">[Previous]</A> <A HREF="ch05a.htm">[Next]</A><P>

<A NAME="161"><H1>Questions That Should Be Asked More Frequently</H1></A>

<p><b>Q. <i>Do you really need every record in
your table?</i></b></p>

<p><b>A.</b> So many customers call to complain that the applications
they built suddenly started to perform poorly once they moved into
production. The most common cause? Queries that retrieve all records
and all fields from a table. Of course the query's performance will
degrade when you move from a small test database to a full production
database. It will continue to degrade as you add more data to the
table.</p>

<p><b>Q. <i>Do you really need every field in
your table?</i></b></p>

<p><b>A.</b> Even if you do need to retrieve every record, do you really
need to retrieve every field? Too many programmers use <i>SELECT * FROM
MyTable</i> simply out of laziness. Others use this simple query
because it's the only way they ever learned to query tables. Books
and documentation tend to show simple, concise code primarily because a
single line of code that takes up multiple lines on a page doesn't
look nice, and too much detail can often make an example confusing. As
a result, many queries that you'll see in online documentation or
in books such as this will use <i>SELECT * FROM MyTable</i>. You'll
see a number of queries of this type in this book, but now you know
why.</p>

<p>Even if you do need every column from your table, you would probably
see better performance if you avoided the wildcard character (asterisk)
and listed each field instead&#8212;unless the query string is so long
that the OLE DB provider or ODBC driver chokes on it.</p>

<p><b>Q.<i>How do I know when my asynchronous query has
completed?</i></b></p>

<p><b>A.</b> Unfortunately, the answer isn't quite as simple as the
question. If you're simply using the adAsyncExecute constant in
your <i>Recordset.Open</i> call, the <i>ExecuteComplete</i> event will
fire when your query completes. If you're using the ADO Cursor
Engine's asynchronous fetching feature, things get a little more
complex.</p>

<p>In this chapter, we covered the <i>FetchProgress</i> and <i>
FetchComplete</i> events for the Recordset object. These events fire
when you fetch your data asynchronously. Usually.</p>

<p>Actually, these events fire (as of ADO 2.5) only if your query
returns at least the number of records specified in the Initial Fetch
Size dynamic property in the Recordset object's Properties
collection. What to do if your query returns fewer records? Well,
here's some code for the <i>ExecuteComplete</i> and <i>
FetchComplete</i> event handlers that works pretty well for me.</p>

<p>The initial test makes sure that the <i>pRecordset</i> object
exists. (If you used <i>adExecuteNoRecords</i> as one of the parameters
when you created your Recordset object, this <i>pRecordset</i> object
is set to Nothing.) The Recordset object's State property is set to
adStateOpen or adStateClosed if the query has completed. If the State
property returns adStateOpen + adStateFetching, there's still more
data for ADO to fetch. Once ADO has fetched the remaining data, the <i>
FetchComplete</i> event on the Recordset object will fire.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
'The ExecuteComplete event handler
Private Sub cn_ExecuteComplete(...)
    If Not pRecordset Is Nothing Then
        If pRecordset.State = adStateOpen Or _
           pRecordset.State = adStateClosed Then
            Debug.Print &quot;cn_ExecuteComplete -- Query has completed&quot;
        Else 
            pRecordset.State = adStateOpen + adStateFetching
            Debug.Print _
                &quot;cn_ExecuteComplete -- Wait for rs_FetchComplete&quot;
        End If
    Else
        Debug.Print &quot;cn_ExecuteComplete -- Query has completed&quot;
    End If
    If Not pError Is Nothing Then
        Debug.Print pError.Description
    End If
End Sub

'The FetchComplete event handler
Private Sub rs_FetchComplete(...)
    Debug.Print &quot;rs_FetchComplete -- Query has completed&quot;
End Sub
</pre>
</td></tr></table>
</p>

<p>Actually, this code won't tell you exactly when you've
fetched all your data if you're running a hierarchical query, but
we'll talk more about hierarchical queries in <A HREF="ch14a.htm">Chapter 14</A>.</p>
</BODY>
</html>







