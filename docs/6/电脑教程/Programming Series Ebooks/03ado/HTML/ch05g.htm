<html>
<head>
<title>Questions That Should Be Asked More Frequently</title>
<LINK REL=STYLESHEET HREF="progado.css" TYPE="text/css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<A HREF="ch05f.htm">[Previous]</A> <A HREF="ch06a.htm">[Next]</A><P>

<A NAME="191"><H1>Questions That Should Be Asked More Frequently</H1></A>

<p><b>Q. <i>Should I always use a Command object?</i></b> </p>

<p><b>A.</b> In short, no. The Command object can be extremely handy,
but it's primarily designed for two-tiered client-server
applications, which, these days, aren't as fashionable as
multitiered applications. If you're building a query that will run
in a Component Services (formerly known as Microsoft Transaction
Server) component or in Active Server Pages (ASP), there's really
no reason to use a Command object.</p>

<p><b>Q. <i>Should I always use Parameter objects in my query?</i></b> </p>

<p><b>A.</b> Again, in short, no. If you're executing your query
only once, there's usually little reason to use a parameterized
query.</p>

<p>If you know ahead of time that you're going to retrieve
information about a particular customer, but you're accepting input
from the user to decide which customer, you might be tempted to use
this information in a Parameter object. While that's a perfectly
acceptable reason for using a Parameter object, bear in mind that you
could also simply build your query string and include that information
prior to submitting the query.</p>

<p>Many developers will use parameterized queries because they're
receiving input from the user and don't want to worry about
delimiting the string or date. You'll understand why if you've
ever had to build a query like the following:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SELECT * FROM Authors WHERE Au_LName = 'O''Leary'
</pre>
</td></tr></table>
</p>

<p><b>Q. <i>Why should I use</i> Parameters.Append <i>instead of</i> Parameters.Refresh<i>?</i></b> </p>

<p><b>A.</b> Unless you're building an ad hoc query tool, you should
avoid calling <i>Parameters.Refresh</i> in your application at all
costs.</p>

<p>When you call <i>Parameters</i>.<i>Refresh</i>, you're asking
the OLE DB provider to supply parameter information that you should
already have available to you. If you're not dealing with an ad hoc
query tool, you should know what the data type and direction for your
parameters are.</p>

<p>There's a natural tendency to believe that writing less code
means your application will run faster. While that's true in
general, your application will often run faster if you populate the
parameters collection yourself. Why? Asking the OLE DB provider to
supply information about the parameters for your query incurs network
round-trips that could easily be avoided by writing a little more
code.</p>

<p>Also, for large database systems, it's actually the database
system that has to generate the information that's handed back to
ADO. Collecting information about the parameters is often a costly
query that examines system tables. Many developers using Visual Basic,
Remote Data Objects (RDO), and Oracle complained about poor performance
on parameterized queries because the more tables and stored procedures
they added to their database, the longer it took to retrieve the
parameter information. This is one of the reasons the ADO developers
added the <i>Append</i> method to the Parameters collection.</p>

<p>Finally, many OLE DB providers are unable to supply all the
information you need for your Parameter objects anyway. SQL Server has
no way of indicating whether a parameter is input/output or
output-only. Even if you call <i>Parameters.Refresh</i>, you'll
need to modify the Direction property of your Parameter object if you
want it to be an output-only parameter. The Microsoft Jet 4.0 OLE DB
Provider has difficulty determining the length of character-based
parameters, and you might need to set the Size property yourself even
after calling <i>Parameters.Refresh</i>. (If this information seems
overwhelming, revisit the previous two questions.)</p>

<p><b>Q. <i>What's the deal with Microsoft Access QueryDefs with ADO?</i></b> </p>

<p><b>A.</b> The answer to this question could fill an entire book, but
I'll give a brief answer here. There is a difference between how
the Jet 4.0 OLE DB Provider and the Jet ODBC driver handle QueryDefs
(query definitions). Part of the reason for this difference in behavior
is that a Jet QueryDef is somewhere between a view and a stored
procedure. The other part of the reason is that the OLE DB provider and
the ODBC driver were developed by entirely different teams, and the
provider and driver libraries each directly access the Access
database.</p>

<p>To make a long story short, the Jet 4.0 OLE DB Provider treats a
QueryDef as a view, and the Jet ODBC driver treats a QueryDef as a
stored procedure. Say that you built a parameterized QueryDef named
GetAnOrder for the query <i>SELECT * FROM Orders WHERE OrderID = ?</i>.
The Jet 4.0 OLE DB Provider treats the QueryDef like a table. You would
use the following code to run the query with the Jet 4.0 OLE DB
Provider:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
With qryGetOrder
    .CommandText = &quot;SELECT * FROM GetAnOrder&quot;
    .CommandType = adCmdText
    .Parameters.Append .CreateParameter(&quot;pOrderID&quot;, adInteger, _
                                        adParamInput)
    Set .ActiveConnection = cnNorthwind
End With
</pre>
</td></tr></table>
</p>

<p>The ODBC driver for Access treats that same QueryDef like a stored
procedure. To run the QueryDef using the ODBC driver for Access, you
would use the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
With qryGetOrder
    .CommandText = &quot;{CALL GetAnOrder (?)}&quot;
    .CommandType = adCmdText
    .Parameters.Append .CreateParameter(&quot;pOrderID&quot;, adInteger, _
                                        adParamInput)
    Set .ActiveConnection = cnNorthwind
End With
</pre>
</td></tr></table>
</p>

<p>You're also likely to see inconsistencies if you compare schema
information returned by the OLE DB provider and the ODBC driver, or if
you look at QueryDefs in the Visual Basic DataView window.</p>
</BODY>
</html>





