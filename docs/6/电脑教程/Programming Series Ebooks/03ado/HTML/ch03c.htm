<html>
<head>
<TITLE>ADO Connection Object Functions and Methods</title>
<link rel="STYLESHEET" type="text/css" href="progado.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor = "#ffffff" text="#000000">
<A HREF="ch03b.htm">[Previous]</A> <A HREF="ch03d.htm">[Next]</A><P>

<A NAME="44"><H1>ADO Connection Object Functions and Methods</H1></A>

<p>Now let's examine each of the functions and methods exposed by
the Connection object and listed in this next table.</p>

<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th colspan=2>Connection Object Functions and Methods</th>
		</tr>

		<tr>
			<th><i>Function or Method Name</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top"><i>BeginTrans</i></td>
			<td valign="top">Initiates a transaction</td>
		</tr>

		<tr>
			<td valign="top"><i>Cancel</i></td>
			<td valign="top">Cancels an asynchronous attempt to connect to your database</td>
		</tr>

		<tr>
			<td valign="top"><i>Close</i></td>
			<td valign="top">Closes the connection to your database</td>
		</tr>

		<tr>
			<td valign="top"><i>CommitTrans</i></td>
			<td valign="top">Commits the current transaction</td>
		</tr>

		<tr>
			<td valign="top"><i>Execute</i></td>
			<td valign="top">Submits a query to your database</td>
		</tr>
		
		<tr>
			<td valign="top"><i>Open</i></td>
			<td valign="top">Opens a connection to your database</td>
		</tr>

		<tr>
			<td valign="top"><i>OpenSchema</i></td>
			<td valign="top">Retrieves schema information from your database</td>
		</tr>

		<tr>
			<td valign="top"><i>RollbackTrans</i></td>
			<td valign="top">Rolls back the current transaction</td>
		</tr>
		
	</table>
</p>

<A NAME="45"><h2><i>BeginTrans</i> Method</h2></A>
<p>The <i>BeginTrans</i> method initiates a transaction on your
database. Actually, <i>BeginTrans</i> is a function that returns the
nesting level of the transaction, but don't let the return value
fool you. Currently, you can't nest ADO transactions. If you call
<i>BeginTrans</i> more than once, you'll receive an error stating
that only one transaction can be active on this session. 
<i>BeginTrans</i> takes no parameters.</p>

<p>The &quot;<A HREF="ch03f.htm#70">Managing Your Transactions</A>&quot; section of this chapter
provides more detailed information about this method.</p>

<A NAME="46"><h2><i>Cancel</i> Method</h2></A>
<p>The <i>Cancel</i> method is intended to cancel an asynchronous query
or an asynchronous attempt to connect to your database. <i>Cancel</i>
takes no parameters.</p>

<A NAME="47"><h2><i>Close</i> Method</h2></A>
<p>You can use the <i>Close</i> method to close an open connection. You
might want to check the State property in your code before calling this
method, to prevent generating an error. Calling the <i>Close</i> method
on a Connection object that's already closed will generate an
error. <i>Close</i> takes no parameters.</p>

<A NAME="48"><h2><i>CommitTrans</i> Method</h2></A>
<p>The <i>CommitTrans</i> method commits the pending changes in the
current transaction. <i>CommitTrans</i> takes no parameters. To learn
more about using this method, see the &quot;<A HREF="ch03f.htm#70">Managing YourTransactions</A>&quot; section later in this chapter.</p>

<A NAME="49"><h2><i>Execute</i> Method</h2></A>
<p>You can use the <i>Execute</i> method to submit a query to your
database. This method has three parameters, as shown here:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
<i>Connection</i>.Execute <i>CommandText</i>, <i>RecordsAffected</i>, <i>Options</i>
</pre>
</td></tr></table>
</p>

<p>The first parameter, <i>CommandText</i>, is a string that specifies
the query you want to submit. This is the only parameter of the <i>
Execute</i> method that is required. Here's an example:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
cnDatabase.Execute &quot;DELETE FROM MyTable WHERE ID = 7&quot;
</pre>
</td></tr></table>
</p>

<p><i>RecordsAffected</i>, the second parameter, is an optional output
parameter that you can use to determine how many rows were affected by
your query. This parameter returns a value of type long and can come in
handy if you're submitting action queries to update data:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
strSQL = &quot;DELETE FROM MyTable WHERE ID = 7&quot;
cnDatabase.Execute strSQL, lngRecordsAffected
MsgBox lngRecordsAffected &amp; &quot; record(s) deleted&quot;
</pre>
</td></tr></table>
</p>

<p>The last parameter is the <i>Options</i> parameter, which also is
optional and takes a long value. You can use this parameter with a
value from CommandTypeEnum or one of the ExecuteOptionEnum values
listed in the following table. For more information on specifying the
command type and on the possible values for CommandTypeEnum, see the
documentation on the CommandType property of the Recordset and Command
objects in <A HREF="ch04a.htm">Chapter 4</A> 
and <A HREF="ch05a.htm">Chapter 5</A>, respectively.</p>

<p>
	<table valign="top" cellpadding="5" width="95%">
	
		<tr>
			<th colspan=3>ExecuteOptionEnum Values</th>
		</tr>
		
		<tr>
			<th><i>Constant</i></th>
			<th><i>Value</i></th>
			<th><i>Description</i></th>
		</tr>

		<tr>
			<td valign="top">adAsyncExecute</td>
			<td valign="top">16</td>			
			<td valign="top">Executes the query asynchronously</td>
		</tr>

		<tr>
			<td valign="top">adAsyncFetch</td>
			<td valign="top">32</td>			
			<td valign="top">Fetches the results of the query asynchronously</td>
		</tr>
		
		<tr>
			<td valign="top">adAsyncFetchNonBlocking</td>
			<td valign="top">64</td>			
			<td valign="top">Fetches the results of the query asynchronously without blocking</td>
		</tr>

		<tr>
			<td valign="top">adExecuteNoRecords</td>
			<td valign="top">128</td>			
			<td valign="top">Specifies that the query does not return records</td>
		</tr>
		
	</table>
</p>

<p>Perhaps you're calling a stored procedure that will take a while
to execute, or perhaps your query requires a great deal of processing
by the server before it returns results. In that case, you can execute
your query asynchronously by using the adAsyncExecute constant, and the
rest of your code will continue to execute while ADO waits for the
results of your query. (To determine when your query has completed, use
the <i>ExecuteComplete</i> event on the Connection object.)</p>

<p>If you're using a client-side Recordset, you can use the
adAsyncFetch constant to fetch the results of your query
asynchronously. Once you submit your query and ADO has retrieved the
number of rows specified in the Recordset object's CacheSize
property, the adAsyncFetch constant specifies that your code continue
to execute while ADO retrieves the rest of the results of the query
asynchronously.</p>

<p>By default, the <i>Execute</i> method on the Connection object
returns a Recordset object. If you use code such as the following to
try to create an updatable Recordset, you will still have a read-only
Recordset once the <i>Execute</i> method has completed:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
'Create a new Recordset.
Set rsResults = New ADODB.Recordset
'Set the Recordset to use a keyset cursor and optimistic locking.
'These settings make the Recordset updatable.
rsResults.CursorType = adOpenKeyset
rsResults.LockType = adLockOptimistic
'Call Connection.Execute and retrieve a new, nonupdatable
' Recordset object.
Set rsResults = cnDatabase.Execute(strSQL)
</pre>
</td></tr></table>
</p>

<p>The Recordset object is a return value, not an output parameter. The
<i>rsResults</i> object variable in this example is not passed into the
<i>Execute</i> method; the <i>Execute</i> method generates an entirely
new Recordset object and returns it. This new Recordset object
overwrites the old Recordset object referenced by the <i>rsResults</i>
object variable.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
While the fact that the Recordset object generated by
the <i>Execute</i> method will overwrite the existing <i>rsResults</i>
object variable might be obvious to many programmers, one of the most
commonly asked questions on the external ADO newsgroups is, &quot;Why
is the setting I've assigned to the
LockType/CursorLocation/MaxRecords property ignored when I call the <i>
Execute</i> method on the Connection and Command
objects?&quot;</blockquote></div>
</p>

<p>The Recordset object returned by the <i>Execute</i> method inherits
the default cursor type from the Connection object, based on the value
of the Connection object's CursorLocation property. Because all
client-side Recordset objects are static, if you use the <i>Execute</i>
method with a Connection object whose CursorLocation property is set to
adUseClient, you'll generate a static Recordset. If your Connection
object's CursorLocation property is set to adUseServer (the
default), the cursor type of the Recordset object returned from the
call to the <i>Execute</i> method will be forward-only.</p>

<p>In short, if you want to maintain any control over the Recordset
object generated by your query, use the <i>Open</i> method on the
Recordset object rather than the <i>Execute</i> method of the
Connection object. (See <A HREF="ch04a.htm">Chapter 4</A> for 
more information on using the Recordset's <i>Open</i> method.)</p>

<p>The best use of the <i>Execute</i> method is for action
queries&#8212;queries that will not return a recordset. Just be sure to
use the adExecuteNoRecords constant in the <i>Options</i> parameter.
This will speed up the execution of your query because ADO will not
attempt to fetch the query's results or generate a new Recordset
object.</p>

<p>Another tip to improve performance is to use the appropriate value
for the CommandTypeEnum in the <i>Options</i> parameter rather than
letting ADO guess what type of query you're submitting.</p>

<A NAME="50"><h2><i>Open</i> Method</h2></A>
<p>You use the <i>Open</i> method to connect to your database. The <i>
Open</i> method on the Connection object has four parameters, all of
which are optional:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
<i>Connection</i>.Open <i>ConnectionString</i>, <i>UserID</i>, <i>Password</i>, <i>Options</i> 
</pre>
</td></tr></table>
</p>

<p>In the <i>Open</i> method, you can specify a connection string
rather than setting the ConnectionString property prior to calling the
method. The <i>UserID</i> and <i>Password</i> parameters are fairly
self-explanatory; they accept string values that allow you to specify
the user and password, respectively.</p>

<p>If you want to connect to your database asynchronously, simply use
the adAsyncConnect constant (a member of the ConnectOptionEnum type) in
the <i>Options</i> parameter. Your code will continue to run while ADO
attempts to connect to your database. Once the attempt to connect
completes (whether it succeeds or fails), the <i>ConnectComplete</i>
event on the Connection object will fire. Not all OLE DB providers
support asynchronous operations.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
I've noticed somewhat unexpected behavior when
using the SQL Server OLE DB provider to connect asynchronously. The
provider will try to locate the server synchronously. Once the provider
locates the server, it will try to establish a connection
asynchronously. Thus, the call to the <i>Open</i> method will not
appear asynchronous if the server you're trying to connect to is
unavailable.</blockquote></div>
</p>

<p>If you're connecting to your database asynchronously, you might
want to disable some of your application's functionality while you
attempt the connection. For example, you would not want to try to
submit a query to a Connection object that's still trying to
connect. When the <i>ConnectComplete</i> event fires, you can determine
whether the connection succeeded and enable the functionality in your
application to submit the query, if appropriate.</p>

<A NAME="51"><h2><i>OpenSchema</i> Method</h2></A>
<p>Perhaps your application allows the user to build queries at run
time with a slick user interface. In that case, your application might
need to retrieve metadata from your database. You'll want to
provide a list of tables and the names of the fields in each table. You
might even want to retrieve foreign key constraints to show
relationships within the database. The <i>OpenSchema</i> method returns
a Recordset object to help you retrieve this type of information:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Set<i> Recordset</i> = <i>Connection</i>.OpenSchema <i>QueryType</i>, <i>Criteria</i>, <i>SchemaID</i>
</pre>
</td></tr></table>
</p>

<p>To use this method, you must specify a schema type in the <i>
QueryType</i> parameter. Numerous values are available for the schema
type and are contained in SchemaEnum. See the ADO Help files for a
complete list of values. (Keep in mind that data access providers are
not required to support all schemas.)</p>

<p>Generally, you want to put some restrictions on the schema that
you're retrieving. For example, you might want to see the list of
columns in a particular table. Simply specifying adSchemaColumns in the
first parameter will retrieve information for all columns in all
tables. The second parameter on the <i>OpenSchema</i> method, <i>
Criteria</i>, is optional and takes a Variant array that defines the
restriction you want to place on the schema. Each schema type has its
own options for restrictions, and there are too many to list here. Your
best bet is to look in the Microsoft Data Access SDK for the
restrictions available for any particular schema type.</p>

<p>The current documentation for adSchemaColumns lists four available
restrictions: TABLE_CATALOG, TABLE_SCHEMA, TABLE_NAME, and COLUMN_NAME.
If you wanted to retrieve the columns for only the Customers table in
your database, you could use code such as the following:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim rsSchema As ADODB.Recordset
Dim aRestrictions As Variant

aRestrictions = Array(Empty, Empty, &quot;Customers&quot;, Empty)
Set rsSchema = cnDatabase.OpenSchema(adSchemaColumns, _
                                     aRestrictions)
</pre>
</td></tr></table>
</p>

<p>We created a Variant array with the same number of entries as the
number of available restrictions for the schema. We used the desired
entry in the Variant array and designated the other entries as
Empty.</p>

<p>The <i>OpenSchema</i> method returns a Recordset object with the
schema information. If you want to be able to sort or scroll through
the resulting Recordset, set the CursorLocation property of the
Connection object to adUseClient prior to calling <i>OpenSchema</i>.</p>

<p>The <i>OpenSchema</i> method has another optional
parameter&#8212;<i>SchemaID</i>. The documentation states that you can
set this parameter to a schema's globally unique identifier (GUID)
if you've set the <i>QueryType</i> to adSchemaProviderSpecific.</p>

<A NAME="52"><h2><i>RollbackTrans</i> Method</h2></A>
<p>This method rolls back the pending changes in the current
transaction. <i>RollbackTrans</i> takes no parameters. To learn more
about using this method, see the &quot;<A HREF="ch03f.htm#70">Managing Your Transactions</A>&quot;
section.</p>

</BODY>
</HTML>






