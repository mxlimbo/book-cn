<HTML>
<HEAD>
<TITLE>Detecting Conflicts</title>
<link rel="STYLESHEET" type="text/css" href="progado.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<A HREF="chabc.htm">[Previous]</A> <A HREF="chabe.htm">[Next]</A><P>

<h1>Detecting Conflicts</h1>

<p><a href="ch12a.htm">Chapter 12</a>, which discusses batch updating conflicts, might make the
process of detecting and resolving conflicts seem more complex than it
really is. The chapter examines the features of the ADO object model
that you can utilize when you encounter batch updating conflicts, and I
felt a sample application that demonstrates how to use these features
would be helpful.</p>

<p>The Detecting Conflicts sample lets you select which types of
conflicts you want to learn more about and then causes them to occur.
When you click the Cause Conflicts button in the Detecting Conflicts
window, the sample code executes a number of steps that cause the
conflicts to occur and records information about those conflicts in a
log file. Let's examine these steps now.</p>

<p>First the sample connects to your database by using the connection
string the user supplies. Then the sample creates and populates its own
table, named ConflictTest, in the database. Next the contents of this
table are retrieved into a Recordset object. The code modifies the
contents of the Recordset and then records the pending changes (the
contents of each record and the value of the Status property) in the
log file. The sample then modifies the contents of the table to
simulate the changes another user would make, causing the conflicts to
occur. Finally the sample submits the pending changes to the database
and logs information about any conflicts that occurred.</p>

<p>I wanted this sample to be simple and flexible, but those two traits
are often mutually exclusive. In order to allow the user to select
which types of conflicts to cause, I had to come up with a way to
handle those selections dynamically. So I created a user-defined type
(UDT) called udtConflict (defined in the modDetectingConflicts module)
that contains information about each type of conflict. Actually, I call
these items &quot;conflicts&quot; for lack of a better term. Some of
these items, such as a successful update, do not constitute a conflict.
Take a look at the comments with the UDT declaration and at the <i>
InitConflicts</i> procedure in the module. This information should make
the purpose of the UDT's different attributes fairly clear.</p>

<p>Before the sample submits the pending changes to the database, it
loops through the Recordset and records information about those pending
changes in the log file. Why did I add this code to the sample? As I
mentioned in the answer to the last question in the &quot;<a href="ch08d.htm#275">Questions
That Should Be Asked More Frequently</a>&quot; section of Chapter 8, you
can use the ADO Cursor Engine to store pending changes and then call
stored procedures based on those changes. This portion of the code
demonstrates how you can use the Status property of a pending change to
determine which type of change it represents: insertion, deletion, or
modification. Assuming you'll need different stored procedures for
each type of change, you can use this information to determine which
stored procedure to call. Or you can generate and submit your own
action query instead.</p>

<p>After the sample logs the pending changes and modifies the table, it
submits those changes by calling the <i>UpdateBatch</i> method on the
Recordset. It then logs information about any conflicts that occurred.
The code records the value of the Status property for each record that
contains a conflict, as well as information about the Value,
OriginalValue, and UnderlyingValue properties for each Field object.
Note that the code traps for errors when trying to access these
properties in case the record or its counterpart in the database has
been deleted. Once the sample has logged information about the
conflicts, it displays the contents of the log file in Notepad. Using
this information, you should be able to determine how to resolve your
conflicts.</p>

<p>The Detecting Conflicts sample uses a copy of the same form that the
Cursors sample uses to manage connection strings
(frmManageConnectionStrings), as well as a copy of the module for
interacting with the settings file (modSettingsFile) and a procedure
copied from the What's My Constant sample
(<i>GetRecordStatus</i>).</p>

</BODY>
</HTML>




