<html>
<head>
<TITLE>Which Data Is Marshaled with a Client-Side Recordset?</title>
<link rel="STYLESHEET" type="text/css" href="progado.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor = "#ffffff" text="#000000">
<A HREF="ch15d.htm">[Previous]</A> <A HREF="ch15f.htm">[Next]</A><P>

<A NAME="397"><H1>Which Data Is Marshaled with a Client-Side Recordset?</H1></A>

<p>When you pass a client-side Recordset across process boundaries, the
new Recordset is not an exact duplicate of the original. This is not
the same concept as photocopying a document and getting a slightly
blurrier copy of the original. You'll definitely receive all the
values for all currently visible records and fields. Let's take a
closer look at what is and is not copied into your new Recordset
object.</p>

<A NAME="398"><H2>Metadata to Support Updating</H2></A>

<p>The ADO Cursor Engine's batch updating functionality is one of
the more compelling reasons to use client-side Recordsets. The Cursor
Engine passes all the metadata it needs to support batch updating. The
base table names, base column names, and primary key information are
included in the stream of data. The ADO Cursor Engine also includes the
value stored in the OriginalValue property of each Field in each record
of your Recordset.</p>

<p>However, the data stored in the UnderlyingValue property is not
included. If you pass a Recordset back to your business object to
submit pending changes to your database and any updates fail because of
conflicts, you can resynchronize your Recordset to try to determine why
the updates failed. But if you marshal the contents of the Recordset to
the client application, the data you retrieved into the UnderlyingValue
property for each Field object will not be included with the rest of
the data, so at that point you won't be able to determine how to
deal with the conflict.</p>

<A NAME="399"><H2>Filters</H2></A>

<p>Here's one area in which marshaling a Recordset object across
process boundaries yields different results than saving the Recordset
to a file. If you use the Filter property on a client-side Recordset to
control which records are visible in the Recordset and then call its
<i>Save</i> method, only the currently visible records will be stored
in the file or stream.</p>

<p>When you pass a Recordset across process boundaries, all
records&#8212;not only those currently visible&#8212;are included in the
new Recordset. Keep this behavior in mind; otherwise, you might anger
your network administrator by wasting bandwidth and upset your database
administrator by accidentally passing sensitive data that the user
wasn't meant to see. (But at least you'd make some new contacts
in the human resources group&#8212;in your upcoming exit interview.)</p>

<A NAME="400"><H2>Hierarchies</H2></A>

<p>What if you're passing a hierarchical Recordset across process
boundaries? (Don't forget that you can't marshal parameterized
hierarchies.) Which levels and chapters of the hierarchy will appear in
your new Recordset object?</p>

<p>Let's use a hierarchy that contains customers, orders, and order
details. Say that you have a reference to a particular chapter of the
orders level of the hierarchy. Only the orders for the current customer
are visible in the orders Recordset. But if you pass this Recordset
across a process boundary, ADO will include all orders&#8212;rather than
only including the orders for the current customer. ADO will also
include all order detail information, but it won't include customer
information. In short, ADO will pass all chapters for the referenced
level of the hierarchy, as well as all data in child levels of the
hierarchy, across the process boundary.</p>

<A NAME="401"><H2>MarshalOptions Property</H2></A>

<p>You can use the MarshalOptions property on the Recordset object to
control which records in your client-side Recordset are marshaled out
of process. By default, this property is set to adMarshalAll, which
means that all records in the Recordset will be marshaled. You can set
this property to adMarshalModifiedOnly so that only the records
containing pending changes will be passed across the process boundary.
Using this property can decrease network traffic when you're
passing a Recordset from your client application to your business
object in order to submit the pending changes to your database. (For
more information on the MarshalOptions property, see <A HREF="ch04a.htm">Chapter 4</A>.)</p>

</BODY>
</HTML>






