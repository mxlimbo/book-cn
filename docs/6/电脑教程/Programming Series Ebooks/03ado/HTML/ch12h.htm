<html>
<head>
<title>Questions That Should Be Asked More Frequently</title>
<LINK REL=STYLESHEET HREF="progado.css" TYPE="text/css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<A HREF="ch12g.htm">[Previous]</A> <A HREF="ch13a.htm">[Next]</A><P>

<A NAME="356"><H1>Questions That Should Be Asked More Frequently</H1></A>

<p><b>Q.<i>  I can handle optimistic updating
conflicts once, but I don't want to continually trap for them. Is
there any way I can make sure that my second update attempt
succeeds?</i></b></p>

<p><b>A.</b>  You can use transactions to accomplish this if you're
working with a transactional database. This will prevent other users
from changing the record while you resync and update. The following
code begins a transaction before resynchronizing the records whose
updates failed because of conflicts:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
rsCustomers.Filter = adFilterConflictingRecords
cnDatabase.BeginTrans
rsCustomers.Resync adAffectGroup, adResyncUnderlyingValues
'Resolve conflicts.
<img src="images/grayvellip.JPG" width=3 height=13 border=0>
rsCustomers.UpdateBatch
cnDatabase.CommitTrans
</pre>
</td></tr></table>
</p>

<p>After resynchronizing those conflicts, resolve your conflicts within
the Recordset object, and then call <i>Recordset.UpdateBatch</i> to
submit the changes and <i>Connection.CommitTrans</i> to commit the
transaction. Because you retrieve the current contents of the
conflicting records within a transaction, that data is locked for the
lifetime of the transaction and can be modified only within that
transaction. As a result, there is no chance of another user modifying
that data and causing conflicts when you call <i>UpdateBatch</i> this
second time. Keep in mind that the greatest benefit in using
transactions is also the greatest drawback: the data is locked for the
lifetime of the transaction. See <A HREF="ch03a.htm">Chapter 3</A> for more on using
transactions.</p>

<p><b>Q.<i>  I think I found a way to avoid
conflicts. I set the Update Criteria property to adCriteriaKey, and now
I rarely see update conflicts. But I'm a little worried. Was this a
good idea?</i></b></p>

<p><b>A.</b>  Probably not. You're correct in assuming that by
setting Update Criteria to adCriteriaKey you'll avoid generating
conflicts. However, you're likely to overwrite changes made by
other users. Reread the section &quot;Controlling the Criteria in the
WHERE Clause&quot; in <A HREF="ch10a.htm">Chapter 10</A> to make sure you understand
<i>why</i> you'll avoid generating conflicts by using the property
this way. Generally, you don't want to overwrite other users'
changes.</p>
</BODY>
</html>







