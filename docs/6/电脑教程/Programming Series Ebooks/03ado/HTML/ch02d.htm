<html>
<head>
<TITLE>Out of the Order Came Chaos</title>
<link rel="STYLESHEET" type="text/css" href="progado.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor = "#ffffff" text="#000000">
<A HREF="ch02c.htm">[Previous]</A> <A HREF="ch02e.htm">[Next]</A><P>

<A NAME="17"><H1>Out of the Order Came Chaos</H1></A>

<p>With DAO and RDO, it's fairly simple to explain to a programmer
new to the object model how to connect to and query the desired
database. In each case, you use the object model to create an object
that represents a connection to your database. Then you use that object
to retrieve the results of your query into another object.</p>

<p>As I explained earlier, you can follow the same pattern with the ADO
object model. However, you can also open an ADO Recordset to retrieve
the results of your query in a single call without using either a
Connection object or a Command object. This flexibility makes the
process of determining the &quot;right&quot; way to get your data more
complicated.</p>

<p>There are times when you won't want to use all of the objects in
the ADO hierarchy. For example, perhaps you have no intention of
executing a query more than once, so you don't have any need to use
the Command object. Or maybe your application will require only one
Recordset object, and you don't plan to use the Connection object
for any reason other than to retrieve the results of that one query.
The following sections discuss these and other examples in detail.</p>

<A NAME="18"><H2>Obtaining a Recordset Without a Command Object</H2></A>

<p>If you are not going to execute your query more than once, or if you
won't need Parameter objects, you probably don't need to use a
Command object. As was shown in Figure 2-1, you can use a
Recordset object with a Connection object without having to use a
Command object. Here's an example:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
strConn = &quot;Provider=SQLOLEDB;Data Source=MyServer;&quot; &amp; _
          &quot;Initial Catalog=Northwind;&quot; &amp; _
          &quot;User ID=MyUserID;Password=MyPassword;&quot;
Set cnNorthwind = New ADODB.Connection
cnNorthwind.Open strConn

strSQL = &quot;SELECT * FROM Customers&quot;
Set rsCustomers = New ADODB.Recordset
rsCustomers.Open strSQL, cnNorthwind
</pre>
</td></tr></table>
</p>

<A NAME="19"><H2>Connection Object: To Use or Not to Use</H2></A>

<p>You might find that sometimes the only reason you use your
Connection object is to open Recordset objects. Who would want to write
the code shown in the previous section when you could use code that
looks like this instead:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
strConn = &quot;Provider=SQLOLEDB;Data Source=MyServer;&quot; &amp; _
          &quot;Initial Catalog=Northwind;&quot; &amp; _
          &quot;User ID=MyUserID;Password=MyPassword;&quot;

strSQL = &quot;SELECT * FROM Customers&quot;
Set rsCustomers = New ADODB.Recordset
rsCustomers.Open strSQL, strConn
</pre>
</td></tr></table>
</p>

<p>In this code snippet, we are opening the Recordset object without
explicitly using a Connection object. Instead, we're passing a
connection string, <i>strConn</i>, into the <i>ActiveConnection</i>
parameter (the second parameter) on the <i>Open</i> method. This
parameter (and the ActiveConnection property on the Recordset object)
accepts a connection string or a Connection object. If a connection
string is supplied instead of a Connection object, ADO will establish a
connection to the database based on that connection string.</p>

<p>There is absolutely nothing wrong with the syntax of either example;
each has its place. But proceed with caution! Before you decide that
you'll always use the latter syntax, here's something to
consider: do you want the ActiveConnection property on each of your
Recordset objects to refer to the same Connection object?</p>

<p>If you choose to use the process demonstrated in the second snippet,
you could wind up with code similar to the following:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Set rsCustomers = New ADODB.Recordset
rsCustomers.Open &quot;SELECT * FROM Customers&quot;, strConn
Set rsOrders = New ADODB.Recordset
rsOrders.Open &quot;SELECT * FROM Orders&quot;, strConn
</pre>
</td></tr></table>
</p>

<p>Although each Recordset object was opened using the same connection
string to communicate with the same database, you've created a
separate Connection object for each Recordset. Each of the resulting
Connection objects maintains its own physical connection to the
database. For most database systems, physical connections are a
precious resource and should not be consumed frivolously.</p>

<p>You can avoid generating additional Connection objects in two ways (or
derivatives thereof). Your first alternative is to explicitly create a
Connection object and use it with both Recordset objects:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Set cnNorthwind = New ADODB.Connection
cnNorthwind.Open strConn
Set rsCustomers = New ADODB.Recordset
rsCustomers.Open &quot;SELECT * FROM Customers&quot;, cnNorthwind
Set rsOrders = New ADODB.Recordset
rsOrders.Open &quot;SELECT * FROM Orders&quot;, cnNorthwind
</pre>
</td></tr></table>
</p>

<p>The other method to ensure that you use only one Connection object,
but without having to explicitly create one, is to utilize the
ActiveConnection property on the initial Recordset object as shown in
the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Set rsCustomers = New ADODB.Recordset
rsCustomers.Open &quot;SELECT * FROM Customers&quot;, strConn
Set rsOrders = New ADODB.Recordset
rsOrders.Open &quot;SELECT * FROM Orders&quot;, _
              rsCustomers.ActiveConnection
</pre>
</td></tr></table>
</p>

<p>Here we simply passed the ActiveConnection property from the initial
Recordset, <i>rsCustomers</i>, into the <i>ActiveConnection</i>
parameter on the <i>Open</i> method for the second Recordset, <i>
rsOrders</i>.</p>

<p>Using the same Connection object for each of your Recordsets (even if
you're not explicitly declaring a Connection object) will improve
the performance of your queries and help control the number of actual
connections you're making to the database. We'll discuss the
reasons why one Connection object can generate multiple connections to
your database in greater depth in <A HREF="ch03a.htm">Chapter 3</A>.</p>

<A NAME="20"><H2>Obtaining a Recordset Without a Database</H2></A>

<p>Toward the end of the Bronze Age, Microsoft developed the ODBC
cursor library. (OK, maybe the ODBC cursor library isn't that old,
but given how quickly new technology is being released it seems like it
might require carbon dating to determine when it was created.)
Applications could use this library to store the results of a query
while having to store only a small amount of the data within the
application itself. Some saw this event as the beginning of database
programming with rapid application development (RAD) tools and
components. Programmers who loathe the idea of relying on anyone
else's code believed it marked the beginning of the fall of
civilization as programmers know it.</p>

<p>RDO 2.0 added its own cursor library. Microsoft Visual Basic 5 users
could retrieve the results of a query into this library and actually
disconnect from the database while still working with the query
results. In fact, those users could modify the data and later reconnect
to their databases to update them with that batch of changes.</p>

<p>ADO carries that concept of a disconnected recordset further. Early
in ADO's lifetime, the Advanced Data Connector, a technology that
was later renamed Remote Data Services (RDS), provided early versions
of ADO with a cursor engine similar to RDO 2.0's client batch
cursor library. This technology allowed ADO to pass a recordset across
process boundaries. Rather than passing just a pointer to the object
that contained the data, you could pass the data itself across the
process boundaries. Beginning with ADO 2.0, recordsets can be persisted
to a file and reopened later. You can also create your own recordset by
taking a Recordset object variable and populating the Fields collection
yourself.</p>

<A NAME="21"><H2>Disconnecting a Recordset from a Connection</H2></A>

<p>Prior to version 3.5 of DAO and version 2.0 of RDO, you couldn't
work with a recordset without a live connection to your database. This
restriction forced many programmers to maintain a live connection to
the database for the lifetime of the application in order to continue
to work with DAO and RDO objects, regardless of how infrequently that
connection was used.</p>

<p>The other option was to retrieve the data from the DAO or RDO object
and maintain that data within the application in some other fashion
(Variant arrays, arrays of user-defined types, collections, and so
forth). While this method of programming required a connection to the
database only when necessary, it could require the developer to write a
great deal more code than if she used DAO or RDO and maintained the
database connection.</p>

<p>RDO 2.0 introduced the notion of disconnected recordsets. The
operating principle here is that you should be able to open a
connection to your database, retrieve data, close the connection, work
with the data, and reopen the connection when you want to communicate
with your database again.</p>

<p>You can use that same functionality in ADO 2.0 and later with
client-side recordsets by setting the ActiveConnection property of the
Recordset object to Nothing, as in the following example:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
'Open a connection to your database.
Set cnDatabase = New ADODB.Connection
cnDatabase.CursorLocation = adUseClient
cnDatabase.Open strConn, strUserID, strPassword

'Make the query and retrieve the results.
Set rsData = New ADODB.Recordset
rsData.Open strSQL, cnDatabase, adOpenStatic, _
            adLockBatchOptimistic, adCmdText
Set rsData.ActiveConnection = Nothing

'Close your connection.
cnDatabase.Close

'Modify your recordset.
<img src="images/grayvellip.JPG" width=3 height=13 border="0">

'Reopen your connection.
cnDatabase.Open

'Point your recordset at your connection.
Set rsData.ActiveConnection = cnDatabase

'Submit the changes from the recordset to your database.
rsData.UpdateBatch
</pre>
</td></tr></table>
</p>

<p>Figure 2-2 provides a summary of what's happening. Your
application sends ADO a request for data. ADO asks the OLE DB provider
or ODBC driver to establish a connection to the database. ADO then
passes the query string to the provider/driver, the provider/driver
retrieves the results from the database and passes them back to ADO,
and ADO stores them in the ADO Cursor Engine. You can then close 
your connection. Using the ADO Cursor Engine's batch updating
feature, you can modify the recordset and cache the changes until you
want to submit them to the database.</p>

<p>
<A HREF="javascript:fullSize('F02no02x.htm')"> <img src="images/F02no02.JPG" width=404 height=127 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 2-2</b> <i>The ADO Cursor Engine and disconnected recordsets.</i><!-- /caption -->
</p>


<p>Normally, when you call the <i>Close</i> method on the Connection
object, all Recordset objects associated with that Connection object
are implicitly closed as well. By setting the ActiveConnection property
on the Recordset object to Nothing prior to closing the Connection
object, you're asking the ADO Cursor Engine to dissociate the
Recordset object from the Connection object.</p>

<p>After you've made all the desired changes to the Recordset object,
reconnect to the database by calling the <i>Open</i> method of the
Connection object, associate the Recordset with the Connection object,
and submit the changes in the Recordset to the database by calling the
<i>UpdateBatch</i> method on the Recordset.</p>

<A NAME="22"><H2>Passing a Recordset Out of Process</H2></A>

<p>The way in which Visual Basic handles objects might seem somewhat
magical to developers who don't have a great deal of experience
with COM. Visual Basic hides the complexities of COM from the
developer. (I strongly recommend the books <i>Understanding ActiveX and
OLE,</i> by David Chappell [Microsoft Press, 1996], and Dale
Rogerson's <i>Inside COM</i> [Microsoft Press, 1996], to help you
develop an understanding of working with COM objects across process
boundaries.) For the benefit of the inexperienced, I'll attempt to
explain the passing of COM objects across process boundaries without
undue complexity.</p>

<p>You can create a function in Visual Basic that will return an object
such as rdoResultset. If you call such a function locally, everything
will behave exactly as you expect, just as if you'd returned
simpler data such as a string or an integer. So long as you're
using in-process libraries, your code will compile and run
successfully. However, if your function passes the rdoResultset across
process boundaries (such as from a Component Services component or from
an ActiveX EXE), you're actually passing a pointer to the object;
the object itself still resides on the server. (See Figure 2-3.)
(Component Services was previously known as Microsoft Transaction
Server, or MTS.) The reason only a pointer is passed has to do with the
default functionality of COM. Maintaining data in your Component
Services or MTS objects in this fashion is strongly discouraged. These
server technologies are designed to handle objects that maintain no
state from the calling component. Returning a pointer to a COM object
that resides in your Component Services or MTS business object requires
maintaining state; this can lead to unexpected problems and generally
results in poor performance and limitations on your ability to scale
your application.</p>

<p>While there is code built into COM that passes simple data
structures such as strings, integers, and even Variant arrays from one
process to another, COM does not know how to pass complete objects. By
default, COM will instead pass a pointer to the actual object. As a
result, developers who want to build <i>n</i>-tiered applications using
DAO or RDO make use of the <i>GetRows</i> function on the DAO Recordset
and RDO rdoResultset objects. This function returns a Variant array
with the results of the query rather than an object.</p>

<p>While code that passes Variant arrays instead of objects runs
quickly and allows you to build stateless server components, you lose
the ability to use many of the RAD features of DAO and RDO. For
instance, you can't use bound controls such as text boxes, grids,
list boxes, or combo boxes. (Although, some developers will tell you
that not being able to use bound controls is a blessing in disguise.)
You have to write code that interprets the contents of the Variant
array, manages that data within your client application, passes that
data back to your server component, interprets that information in your
server component, and updates your database.</p>

<p>Keep in mind that passing a pointer to an object rather than passing
the object itself is the default behavior for passing COM object
information across process boundaries. While it's easy to
understand how to pass an integer into another application, passing a
COM object is more complicated. Let's look at the rdoResultset
object again as an example. The COM libraries don't automatically
know what information RDO needs in order to take the information stored in the
rdoResultset object on the server and create an rdoResultset on the
client. If you're building your own COM object in C++, you can
build custom marshaling libraries to pass the required information from
the server to the client. Essentially, you're telling COM that
rather than having COM pass a pointer to your object across process
boundaries, you want to handle the marshaling process yourself. ADO
saves you the trouble of having to build these libraries by providing a
custom marshaling routine for Recordset objects. This routine is
illustrated in Figure 2-4.</p>

<p>
<A HREF="javascript:fullSize('F02no03x.htm')"> <img src="images/F02no03.JPG" width=404 height=240 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 2-3</b> <i>Passing a pointer to an rdoResultset across a process boundary.</i><!-- /caption -->
</p>


<p>
<A HREF="javascript:fullSize('F02no04x.htm')"> <img src="images/F02no04.JPG" width=404 height=240 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 2-4</b> <i>Marshaling an ADO Recordset object across a process boundary.</i><!-- /caption -->
</p>


<p>When you pass a Recordset object across process boundaries, ADO is
loaded in both processes. All of the metadata for the
Recordset&#8212;such as information about the Fields collection,
including data types, which Field objects are updatable, and which
Field objects are part of the primary key&#8212;as well as the contents
of the Recordset are passed across the process boundary. The client
application has its very own Recordset object, rather than a pointer to
a Recordset object that resides on the server. With ADO, you can pass a
Recordset object to another process on the same computer, to a process
on another computer inside your network through Distributed COM (DCOM),
or across the Internet through RDS and HTTP. If you're using
ADO's batch updating feature, the client application can make
changes to the Recordset that you can later submit to your database by
passing the Recordset back to a server.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> 
Before you pass judgment too quickly and decide the
preceding steps are too much work to go through, note that this
approach allows you to have almost complete control of how the server
and client manage the data in the application. If you want your client
application to update a row in the table based on a timestamp by
retrieving that timestamp value and merging it into the data already in
the client application, you can write code to do just that. Time or
budget constraints might impose the only limits to the functionality
you can add to your application.</blockquote></div>
</p>

<A NAME="23"><H2>Persistence Can Pay Off</H2></A>

<p>A salesman is going to call on a customer and needs to be able to
generate order information, but since he's on the road, he
won't have access to the database server once he leaves the office.
It would be helpful if he could download customer, order, and product
information and persist that data into a file or files on his laptop
before he leaves. That way he could generate new orders while
disconnected from the network and submit those orders when he
returns.</p>

<p>In the past, you would have had to use a desktop database such as
Access to maintain that data. ADO 2.0 introduced functionality that
makes it possible to store database information on the desktop without
having a desktop database. We discussed earlier how ADO can pass a
Recordset object from one process to another. As you can see in the
following code, the ADO Recordset object also has a <i>Save</i> method
(as of ADO 2.0), which essentially takes the same data that ADO would
normally pass across the process boundary from the client to the server
and writes it to a file instead. You can later turn that file back into
a Recordset object.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
'Retrieve the results of your query
' and save them to a file. The path to the file
' and the filename are stored in the string
' strPathToOrdersFile.
Set cnDatabase = New ADODB.Connection
<img src="images/grayvellip.JPG" width=3 height=13 border="0">
Set rsOrders = New ADODB.Recordset
rsOrders.Open strSQL, cnDatabase, adOpenStatic, _
              adLockBatchOptimistic, adCmdText
rsOrders.Save strPathToOrdersFile

'Retrieve the contents of the file into a Recordset,
' modify the Recordset accordingly, and then save the
' changes back to a file.
rsOrders.Open strPathToOrdersFile, , , _
              adLockBatchOptimistic, adCmdFile
rsOrders.AddNew
<img src="images/grayvellip.JPG" width=3 height=13 border="0">
rsOrders.Update
rsOrders.Save strPathToOrdersFile

'Retrieve the contents of the file into a Recordset
' and submit the changes to your database.
rsOrders.Open strPathToOrdersFile, , , _
              adLockBatchOptimistic, adCmdFile
Set rsOrders.ActiveConnection = cnDatabase
rsOrders.UpdateBatch
</pre>
</td></tr></table>
</p>

<A NAME="24"><H2>Creating Your Own Recordset</H2></A>

<p>Maybe you don't want to use a database at all, but you like
using Recordset objects to store data in your application. You can then
allow the user to interact with that data by means of a bound control
such as a data grid.</p>

<p>ADO 2.0 introduced an <i>Append</i> method to the Fields collection for
this very reason. You use this method to supply the structure for each
field in your Recordset. Once you've provided this information
about the fields, you call the <i>Open</i> method and start adding,
editing, and deleting data, as shown in the following code snippet. The
Recordset isn't actually updated until the <i>Update</i> method has
been called.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
'Retrieve the results of your query
' and store them in a file.
Set rsData = New ADODB.Recordset
rsData.Fields.Append &quot;ID&quot;, adInteger, , adFldKeyColumn
rsData.Fields.Append &quot;Description&quot;, adVarChar, 40
rsData.Open LockType:=adLockBatchOptimistic
rsData.AddNew
rsData.Fields(&quot;ID&quot;).Value = 1
rsData.Fields(&quot;Description&quot;).Value = &quot;First Record&quot;
rsData.Update
</pre>
</td></tr></table>
</p>

</BODY>
</HTML>






