<html>
<head>
<TITLE>ADO Field Object Properties</title>
<link rel="STYLESHEET" type="text/css" href="progado.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor = "#ffffff" text="#000000">
<A HREF="ch04e.htm">[Previous]</A> <A HREF="ch04g.htm">[Next]</A><P>

<A NAME="145"><H1>ADO Field Object Properties</H1></A>

<p>Let's take a closer look at the properties of the Field object.
This next table offers a preliminary description of each property.</p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th colspan="3">Field Object Properties  </th></tr>
<tr>
<th><i>Property Name</i>  </th>
<th><i>Data Type</i>  </th>
<th><i>Description</i>  </th></tr>
<tr>
<td valign="top">ActualSize  </td>
<td valign="top">Long </td>
<td valign="top">Returns the actual size of a field's value  </td></tr>
<tr>
<td valign="top">Attributes  </td>
<td valign="top">Long   </td>
<td valign="top">Describes characteristics of the field  </td></tr>
<tr>
<td valign="top">DataFormat  </td>
<td valign="top">Object  </td>
<td valign="top">Can be used to format your data  </td></tr>
<tr>
<td valign="top">DefinedSize  </td>
<td valign="top">Long   </td>
<td valign="top">Returns the defined size for a field  </td></tr>
<tr>
<td valign="top">Name  </td>
<td valign="top">String  </td>
<td valign="top">Contains the name of the field  </td></tr>
<tr>
<td valign="top">NumericScale  </td>
<td valign="top">Byte  </td>
<td valign="top">Indicates the numeric scale for numeric data  </td></tr>
<tr>
<td valign="top">OriginalValue   </td>
<td valign="top">Variant  </td>
<td valign="top">Contains the original value for the field  </td></tr>
<tr>
<td valign="top">Precision  </td>
<td valign="top">Byte  </td>
<td valign="top">Indicates the precision for numeric data  </td></tr>
<tr>
<td valign="top">Properties  </td>
<td valign="top">Collection of Property objects  </td>
<td valign="top">Collection of dynamic properties </td></tr>
<tr>
<td valign="top">Type  </td>
<td valign="top">Byte  </td>
<td valign="top">Returns the data type for the field  </td></tr>
<tr>
<td valign="top">UnderlyingValue  </td>
<td valign="top">Variant  </td>
<td valign="top">Indicates the most recently retrieved value from the database for the field  </td></tr>
<tr>
<td valign="top">Value   </td>
<td valign="top">Variant  </td>
<td valign="top">Contains the current value for the field  </td></tr>
</table></p>


<A NAME="146"><H2>ActualSize Property</H2></A>

<p>The ActualSize property tells you how much data actually exists in
your field. This property is read-only and is primarily intended for
variable length strings or binary data. For example, if you define an
Address field to hold up to 64 characters, you can check the ActualSize
property to find out how much data actually exists in the field without
having to examine the contents of the Value property. The ActualSize
property is also helpful when dealing with long variable and binary
data types.</p>

<p>As of ADO 2.1, it is possible for the ActualSize property to be
larger than the DefinedSize property. If you're using a Unicode
data type, the DefinedSize property will return the number of Unicode
characters that the field can hold. The ActualSize property will return
the length of that string in bytes. Thus, the ActualSize property value
is twice the number of Unicode characters.</p>

<A NAME="147"><H2>Attributes Property</H2></A>

<p>The Attributes property contains metadata about the field, such as
whether it's updatable or nullable. The property is a bitmask and
is the sum of one or more values from FieldAttributeEnum, as shown in
the following table.</p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th colspan="3">FieldAttributeEnum Values  </th></tr>
<tr>
<th><i>Constant </i>  </th>
<th><i>Value </i>  </th>
<th><i>Description</i>  </th></tr>
<tr>
<td valign="top">adFldMayDefer  </td>
<td valign="top">2  </td>
<td valign="top">The data is retrieved separately from the other
fields in your Recordset. This behavior is common for long text or
binary fields with server-side Recordsets that support scrolling.  </td></tr>
<tr>
<td valign="top">adFldUpdatable  </td>
<td valign="top">4   </td>
<td valign="top">The field is updatable.  </td></tr>
<tr>
<td valign="top">adFldUnknownUpdatable  </td>
<td valign="top">8   </td>
<td valign="top">The provider cannot determine if the data is
updatable.  </td></tr>
<tr>
<td valign="top">adFldFixed   </td>
<td valign="top">16   </td>
<td valign="top">The field contains fixed-length data such as an
integer.  </td></tr>
<tr>
<td valign="top">adFldIsNullable  </td>
<td valign="top">32  </td>
<td valign="top">The field accepts Null values.  </td></tr>
<tr>
<td valign="top">adFldMayBeNull  </td>
<td valign="top">64   </td>
<td valign="top">The field can contain Null values.  </td></tr>
<tr>
<td valign="top">adFldLong   </td>
<td valign="top">128   </td>
<td valign="top">The field contains long string or binary data. You can
use the <i>AppendChunk</i> and <i>GetChunk</i> methods.  </td></tr>
<tr>
<td valign="top">adFldRowID   </td>
<td valign="top">256  </td>
<td valign="top">The field contains a row identifier.  </td></tr>
<tr>
<td valign="top">adFldRowVersion  </td>
<td valign="top">512  </td>
<td valign="top">The field contains some kind of time or date
stamp used to track updates.  </td></tr>
<tr>
<td valign="top">adFldCacheDeferred   </td>
<td valign="top">4096   </td>
<td valign="top">The provider caches field values, and
subsequent reads are done from the cache.  </td></tr>
<tr>
<td valign="top">adFldIsChapter  </td>
<td valign="top">8192  </td>
<td valign="top">The Field corresponds to a chapter in a
hierarchical Recordset.  </td></tr>
<tr>
<td valign="top">adFldNegativeScale  </td>
<td valign="top">16384  </td>
<td valign="top">The field has a negative value for its
numeric scale. (For example, 12,000 with a numeric scale of -3 would be
stored as 12.)  </td></tr>
<tr>
<td valign="top">adFldKeyColumn   </td>
<td valign="top">32768   </td>
<td valign="top">The field is part of the primary key.  </td></tr>
<tr>
<td valign="top">adFldIsRowURL  </td>
<td valign="top">65536  </td>
<td valign="top">For fields exposed by the Record object; the
value of the field corresponds to the location of the Record.  </td></tr>
<tr>
<td valign="top">adFldIsDefaultStream  </td>
<td valign="top">131072   </td>
<td valign="top">For fields exposed by the Record object;
the field contains the default stream of data for the Record.  </td></tr>
<tr>
<td valign="top">adFldIsCollection  </td>
<td valign="top">262144  </td>
<td valign="top">For fields exposed by the Record object;
the field contains a collection of data.  </td></tr>
</table></p>


<A NAME="148"><H2>DataFormat Property</H2></A>

<p>You can use the DataFormat property on a field to control how the
data is retrieved or displayed. This feature is fairly well explained
in the Visual Basic documentation. The DataFormat property is also
exposed on most Visual Basic controls that you can bind to a field,
such as a TextBox. The property is basically a pointer to a DataFormat
object, which extends the functionality available in the Visual Basic
<i>Format</i> function.</p>

<p>Possibly the best use of this feature is to display True, False, and
Null values. In order to use the DataFormat property on a Field object,
you must reference the Microsoft Data Formatting Object Library
(MSStdFmt.dll) and use the StdDataFormat object. The following code
uses a StdDataFormat object on a bit field in the Products table of the
Northwind database:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim爁mtDiscontinued燗s燬tdFormat.StdDataFormat
<img src="images/grayvellip.JPG" width=3 height=13 border=0>
strSQL