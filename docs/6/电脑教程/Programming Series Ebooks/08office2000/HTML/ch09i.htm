<HTML>
<HEAD>
<TITLE>Generating HTML from the Spreadsheet Component</TITLE>
<link rel="STYLESHEET" type="text/css" href="webcomp.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch09h.htm">[Previous]</A> <A HREF="ch09j.htm">[Next]</A><P>

<A NAME="191"><H1>Generating HTML from the Spreadsheet Component</H1></A>

<P>On the surface, generating HTML from the Spreadsheet component that you can 
return to the client browser seems as easy as writing the HTMLData property, just as we 
did in <A HREF="ch08a.htm">Chapter 8</A>. However, it is not quite that easy, and there will be many times 
that you actually will want to send back more basic HTML so that older browsers 
can display the results.</P>

<P>In <A HREF="ch08a.htm">Chapter 8</A>, I used the HTMLData property as a way to get the 
persistence stream for the Spreadsheet control and write that stream to a database table. 
Later on, I could retrieve that stream and reload the Spreadsheet control by setting 
the property. In this case, I would want the Spreadsheet component to write a cell 
value only once instead of writing both a full precision, unformatted version and the 
formatted display version. By writing the full precision value only, the text stream 
is smaller; therefore, it transmits over the network more quickly and takes up less 
space in the database.</P>

<P>In the Loan Calculation solution, I actually want the display value and not 
the full precision, unformatted version of the value. Unfortunately, we did not have 
time in this version of the components to implement two properties, one that returns 
the full precision values and one that returns the display values, so only the former 
is available. This makes it easy to save and reload the Spreadsheet component but 
much harder to render its contents as HTML that a browser can display. We hope to 
offer both properties in the next version.</P>

<P>However, the code to write a range as an HTML table is included in this 
solution, and I will walk you through it in this section. You can use this code in your 
own solutions whenever you need to get an HTML representation of a range in the 
Spreadsheet control. The method, WriteRange in Default.asp, begins like this:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
Sub WriteRange(rngOut, fUseCSS)
    ' Local variables
    Dim rngRow                  ' Current row
    Dim rngCell                 ' Current cell
    Dim rngMerge                ' Merged cell range
    Dim cxTblWidth              ' Width of the output table
        
    ' Begin by writing the open table tag
    Response.Write &quot;&lt;table cellspacing=0 cellpadding=2 &quot;
    
    ' If using CSS formatting, use a fixed table layout
    ' and emit the &lt;col&gt; tags. The fixed table layout
    ' increases perceived rendering speed dramatically since the
    ' browser doesn't have to parse and calculate the entire
    ' table before beginning to render it.
    If fUseCSS Then
        Response.Write &quot; border=0 &quot;
        cxTblWidth = 0
        For Each rngCell In rngOut.Columns
            cxTblWidth = cxTblWidth + rngCell.ColumnWidth
        Next 'rngCell
        Response.Write &quot; style=&quot;&quot;table-layout:fixed;width:&quot; &amp; _
                       cxTblWidth &amp; &quot;&quot;&quot;&gt;&quot;
        For Each rngCell In rngOut.Columns
            Response.Write &quot;&lt;col width=&quot; &amp; rngCell.ColumnWidth &amp; &quot;&gt;&quot;
        Next 'rng
    Else
        ' Not using CSS, so just use a 1-weight border
        Response.Write &quot;border=1&gt;&quot;
    End If
    
    Response.Flush
    <img src="images/grayvellip.JPG" width=3 height=13 border="0">
</pre></td></tr></table></p>

<P>This method accepts the range to write and a flag indicating whether the 
function should use CSS attributes for formatting. I start by writing the first part of 
the &lt;table&gt; tag, specifying a 
<I>cellspacing</I> of 0 and a <I>cellpadding</I> of 2. (Cellspacing is 
the number of pixels between cells, and cellpadding is the number of pixels in the 
margin between a cell wall and its content.) Then I check the fUseCSS flag and write the 
rest of the &lt;table&gt; tag accordingly.</P>

<P>If the function is asked to use CSS, it performs a few tasks that dramatically 
speed up rendering in Internet Explorer. First it sets the borders explicitly to 0. 
Internet Explorer seems to default the borders to 0, while Netscape Navigator seems to 
default them to 1&#8212;when I explicitly set them to 0, the results look identical in 
both browsers. Next I quickly calculate the total width of all the columns in the output 
range and write it as the overall table width. I also use the &quot;table-layout:fixed&quot; style 
setting, which tells the browser that it should use a fixed width for the table, and I 
write column width values for each column as &lt;col&gt; tags. If the browser knows that 
the table will be a certain width and that all columns will have a fixed width, it can 
begin to display the content as soon as it gets the first row. If the table is not fixed, 
the browser must first parse the entire table and determine how large to make the 
table based on all the content. Since a spreadsheet has fixed column widths, you can 
give the browser a hint that the table will be fixed. This will dramatically increase the 
speed at which the browser loads and displays the results.</P>

<P>If the function is not supposed to use CSS, I instead set the borders 
explicitly to 1. When formatting without CSS, you cannot control individual cell borders 
within a table. Instead, you can control only the size of all cell borders for the entire 
table. Since the mortgage spreadsheet does use cell borders to denote various sections, 
I chose to turn borders on for the whole table in the non-CSS case so that there is 
some semblance of cell borders. If you do not like that, you can change this to read 
&quot;border=0&quot;. After writing the starting &lt;table&gt; tag, I call the Flush method on the 
Response object to send the start of the table to the client browser.</P> 

<P>The WriteRange method continues like this:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
    <img src="images/grayvellip.JPG" width=3 height=13 border="0">
    ' Loop over all rows and columns in the range
    For Each rngRow In rngOut.Rows
        If fUseCSS Then
            Response.Write &quot;&lt;tr height=&quot; &amp; _
                           rngRow.RowHeight + 2 &amp; &quot;&gt;&quot;
        Else
            Response.Write &quot;&lt;tr&gt;&quot;
        End If
        <img src="images/grayvellip.JPG" width=3 height=13 border="0">
</pre></td></tr></table></p>

<P>The basic plan for writing a range is to walk row-by-row, cell-by-cell and 
write &lt;tr&gt; and &lt;td&gt; tags for each row and cell, respectively. This block of code is the 
start of the outer row loop and uses the For Each syntax over the Range object's 
Rows collection. For each row, it writes a &lt;tr&gt; tag, formatting it with an explicit row 
height if fUseCSS is True. I add 2 to the row height here because the output looks a 
little less cramped with an extra 2 pixels per row.</P>

<P>Within each row, the code continues:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
        <img src="images/grayvellip.JPG" width=3 height=13 border="0">
        For Each rngCell In rngRow.Cells
            ' Check whether this cell is in a merged cell range
            ' If so, process it only if it is the upper-left
            ' cell in the range (the owner cell). Otherwise,
            ' ignore the cell and go to the next one.
            If rngCell.HasMergeCells And (rngCell.Address &lt;&gt; _
                rngCell.MergeArea.Cells(1,1).Address) Then
                ' Ignore this cell
            Else
                If rngCell.HasMergeCells Then
                    ' Get the merged cell area
                    Set rngMerge = rngCell.MergeArea

                    ' Write a &lt;td&gt; tag with colspan and rowspan
                    ' attributes to emulate the merged cell
                    Response.Write &quot;&lt;td colspan=&quot; &amp; _
                        rngMerge.Columns.Count &amp; _
                        &quot; rowspan=&quot; &amp; _
                        rngMerge.Rows.Count
                Else
                    ' Write the starting &lt;td&gt; tag
                    Response.Write &quot;&lt;td&quot;
                End If
                <img src="images/grayvellip.JPG" width=3 height=13 border="0">
</pre></td></tr></table></p>

<P>I use the For Each syntax again to loop over all cells within the current 
row. For each cell, I first check whether the cell is merged. (A cell is merged if it is 
anywhere within a merged cell range.) The <I>owner 
cell</I> of a merged range is the upper-left cell, and this is the cell that actually defines the value for the merged range. 
If the current cell is part of a merged area but not the owner cell, I can ignore it 
because I would have already written a &lt;td&gt; tag with the appropriate rowspan 
and colspan attributes to cover this current cell. This is one critical difference 
between the Spreadsheet control and HTML tables. In the Spreadsheet control, the 
individual cells in a merged range still exist, though they have no value. In HTML tables, 
there is only one &lt;td&gt; tag for the merged area, and you indicate how big it should be 
by specifying the rowspan and colspan attributes.</P>

<P>After dealing with the merged cell case, the code continues as follows:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
                <img src="images/grayvellip.JPG" width=3 height=13 border="0">
                If fUseCSS Then
                    ' Start the style attribute
                    Response.Write &quot; style=&quot;&quot;&quot;
                    
                    ' Write the cell's alignment
                    Response.Write &quot; text-align:&quot; &amp; _
                        SSAlign2HTML(rngCell) &amp; &quot;;&quot;
                    
                    ' Write the cell background color
                    Response.Write &quot;background-color:&quot; &amp; _
                        RGB2HTML(rngCell.Interior.Color) &amp; &quot;;&quot;
                    
                    ' Write the font information for the cell
                    Response.Write &quot;font-family:&quot; &amp; _
                        rngCell.Font.Name &amp; &quot;;&quot;
                    Response.Write &quot;font-size:&quot; &amp; _
                        rngCell.Font.Size &amp; &quot;pt;&quot;
                    Response.Write &quot;color:&quot; &amp; _
                        RGB2HTML(rngCell.Font.Color) &amp; &quot;;&quot;
                    If rngCell.Font.Bold Then
                        Response.Write &quot;font-weight:bold;&quot;
                    End If
                    If rngCell.Font.Italic Then
                        Response.Write &quot;font-style:italic;&quot;
                    End If
                    
                    ' Write the cell border info. (We can do
                    ' this in CSS because it supports per-cell
                    ' borders.) If the cell is merged, write
                    ' the borders for the whole merged area
                    ' and not the cell itself.
                    If rngCell.HasMergeCells Then
                        Response.Write _
                            GetBorderStyles(rngMerge, 1, &quot;bottom&quot;)
                        Response.Write _
                            GetBorderStyles(rngMerge, 2, &quot;left&quot;)
                        Response.Write _
                            GetBorderStyles(rngMerge, 3, &quot;right&quot;)
                        Response.Write _
                            GetBorderStyles(rngMerge, 4, &quot;top&quot;)
                    Else
                        Response.Write _
                            GetBorderStyles(rngCell, 1, &quot;bottom&quot;)
                        Response.Write _
                            GetBorderStyles(rngCell, 2, &quot;left&quot;)
                        Response.Write _
                            GetBorderStyles(rngCell, 3, &quot;right&quot;)
                        Response.Write _
                            GetBorderStyles(rngCell, 4, &quot;top&quot;)
                    End If
                    
                    ' End the style attribute and the &lt;td&gt; tag
                    Response.Write &quot;&quot;&quot;&gt;&quot;
                    <img src="images/grayvellip.JPG" width=3 height=13 border="0">
</pre></td></tr></table></p>

<P>This code block is executed when fUseCSS is True, and it writes a rather 
lengthy style attribute for the &lt;td&gt; tag. This code uses a number of helper functions to 
translate between Spreadsheet control settings or constants and those defined by the 
CSS standard. I will not describe all these functions in detail here, but I do want to 
discuss one that is rather tricky.</P>

<P>The Spreadsheet control natively expresses colors as RGB values, just as 
most other Windows programs do. RGB stands for Red Green Blue, which describes 
the physical layout of the various bits in the RGB value (red value at the lowest 
position, then green value, then blue value). For example, the color pure red has the 
decimal value 255 and the hexadecimal value 0000FF. The color pure blue has the 
decimal value 16711680 and the hexadecimal value FF0000. However, HTML colors are 
laid out in exactly the opposite manner (BGR). The color pure red has the 
hexadecimal value FF0000, and the color pure blue has the hexadecimal value 0000FF. 
When writing &lt;td&gt; tag background colors, you must write an HTML color value, so you 
need to translate between the two. Fortunately, the mapping is fairly easy, and the 
following function, RGB2HTML, converts between the two:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
Function RGB2HTML(rgb)
    RGB2HTML = Hex(rgb)
    ' Hex returns a single zero for black
    ' Change it to six zeros if it is
    ' just one zero
    If RGB2HTML = &quot;0&quot; Then 
        RGB2HTML = &quot;#000000&quot;
    Else
        ' If not zero, we have to convert between RGB values
        ' as hexadecimal strings and the way HTML colors are represented
        ' HTML colors are laid out as BGR instead of RGB, so this
        ' line flips the first two and last two hexadecimal digits 
        RGB2HTML = &quot;#&quot; &amp; Mid(RGB2HTML, 5) &amp; Mid(RGB2HTML, 3, 2) &amp; _
            Left(RGB2HTML, 2)
    End If
End Function 'RGB2HTML()
</pre></td></tr></table></p>

<P>This function simply uses the Hex function to convert the RGB value to a 
hexadecimal string and then uses the Mid and Left functions to swap the first two 
(red) and last two (blue) characters.</P>
 
<P>If the method was instructed to not use CSS for formatting, the 
WriteRange method continues with this block of code:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
                <img src="images/grayvellip.JPG" width=3 height=13 border="0">
                Else
                    ' No CSS formatting (use &lt;font&gt;, &lt;b&gt;, and &lt;i&gt; tags)
                    
                    ' Write the cell's alignment
                    Response.Write &quot; align=&quot; &amp; SSAlign2HTML(rngCell)
            
                    ' Write the cell background color
                    Response.Write &quot; bgcolor=&quot; &amp; _
                        RGB2HTML(rngCell.Interior.Color) &amp; _
                        &quot;&gt;&quot;

                    ' Write the font information for the cell
                    Response.Write &quot;&lt;font face=&quot; &amp; rngCell.Font.Name &amp; _
                        &quot; size=&quot; &amp; _
                        Points2HTML(rngCell.Font.Size) &amp; _
                        &quot; color=&quot; &amp; _
                        RGB2HTML(rngCell.Font.Color) &amp; _
                        &quot;&gt;&quot;
            
                    ' If the cell is bold, write a &lt;b&gt; tag
                    If rngCell.Font.Bold Then
                        Response.Write &quot;&lt;b&gt;&quot;
                    End If 
            
                    ' If the cell is italic, write an &lt;i&gt; tag
                    If rngCell.Font.Italic Then
                        Response.Write &quot;&lt;i&gt;&quot;
                    End If
                End If 'fUseCSS
                <img src="images/grayvellip.JPG" width=3 height=13 border="0">
</pre></td></tr></table></p>

<P>This is similar to the previous code, except that it uses &lt;font&gt;, &lt;b&gt;, and &lt;i&gt; 
tags to encode the cell formatting information. Note that I also have to translate 
between explicit font point sizes and the HTML font size value, which is on a scale from 1 
to 7. This doesn't guarantee a purely accurate rendering at the client, but it is as 
close as HTML can get. </P>

<P>The WriteRange method continues by writing the current cell's formatted 
display text:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
                <img src="images/grayvellip.JPG" width=3 height=13 border="0">
                ' Write the cell's formatted text
                If Len(rngCell.Text) &gt; 0 Then
                    Response.Write rngCell.Text
                Else
                    Response.Write &quot;&amp;nbsp;&quot;
                End If
                <img src="images/grayvellip.JPG" width=3 height=13 border="0">
</pre></td></tr></table></p>

<P>Note that I write a &amp;nbsp; symbol if the cell's text is blank. If I do not, 
Internet Explorer will not draw the cell border properly. The &amp;nbsp; symbol is decoded 
by the browser as a nonbreaking space, so the user sees only a space and not the 
&amp;nbsp; character string.</P>

<P>The WriteRange method continues by writing the closing &lt;/b&gt; and &lt;/i&gt; tags 
if fUseCSS is False and then ends the loops like so:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
                <img src="images/grayvellip.JPG" width=3 height=13 border="0">
                ' Close the table cell
                Response.Write &quot;&lt;/td&gt;&quot;
            End If 'Ignore nonowning merged cell
        Next 'rngCell
        
        ' Close the table row
        Response.Write &quot;&lt;/tr&gt;&quot;
        
        ' Flush every 10 rows
        If (rngRow.Row Mod 10) = 0 Then 
            Response.Flush
        End If
    Next 'rngRow
    
    ' End by writing the closing table tag
    Response.Write &quot;&lt;/table&gt;&quot;
    
End Sub 'WriteRange()
</pre></td></tr></table></p>

<P>I periodically flush the content I have written back to the client browser. 
After ending a row, if the row number is evenly divisible by 10 (that is, every 10 rows), 
I call the Flush method of the Response object. At the end of this method, I write 
the closing &lt;/table&gt; tag and exit the method. The code that calls this method will 
call the final Flush method to send back the last part of the table. </P>

<P><div class="sidebar"><blockquote>
<b>Another Approach to Generating HTML for a Range</b>

<P>Although the HTMLData property does not include the display value in 
between the starting &lt;td&gt; and ending &lt;/td&gt; tags, the Spreadsheet control will include 
the display value in HTML that it generates when you copy a range of cells to 
the clipboard. It does this so that a user can copy some cells and paste them 
into an HTML document as a table, but you can also take advantage of this 
programmatically. The Range object has a Copy method that copies the range's 
contents to the clipboard in the CF_HTML clipboard format. Although VBScript does 
not provide a function to read from the clipboard, you can retrieve the 
generated HTML from the clipboard with the help of a custom-written COM object 
that accesses the clipboard for you.</P>

<P>However, the HTML generated by the Spreadsheet control relies heavily 
on CSS formatting, so you might still want to use something like the 
WriteRange function I just discussed. When you write the range yourself, you have total 
control over how the content is generated and can add formatting not present in 
the spreadsheet, such as alternating background colors in a long table of numbers.</P>
</blockquote></div></p>

</BODY>
</HTML>





