<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>A Scrolling View Window</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="73"><H1>A Scrolling View Window</H1></A><P>As the lack of scroll bars in EX04A and EX04B indicates, the MFC 
<I>CView</I> class, the base class of 
<I>CEx04bView</I>, doesn't directly support scrolling. Another 
MFC library class, <I>CScrollView</I>, does support scrolling. 
<I>CScrollView</I> is derived from <I>CView</I>. We'll create a new program, EX04C, that uses 
<I>CScrollView</I> in place of <I>CView</I>. All the coordinate conversion code you added in EX04B sets you up for scrolling.
<P>The <I>CScrollView</I> class supports scrolling from the scroll bars but not 
from the keyboard. It's easy enough to add keyboard scrolling, so we'll do it.
<A NAME="74"><H2>A Window Is Larger than What You See</H2></A><P>If you use the mouse to shrink the size of an ordinary window, the contents 
of the window remain anchored at the top left of the window, and items at 
the bottom and/or on the right of the window disappear. When you expand 
the window, the items reappear. You can correctly conclude that a window is 
larger than the <U>viewport</U> that you see on the screen. The viewport doesn't have to 
be anchored at the top left of the window area, however. Through the use of 
the <I>CWnd</I> functions <I>ScrollWindow</I> and 
<I>SetWindowOrg</I>, the <I>CScrollView</I> class 
allows you to move the viewport anywhere within the window, including areas 
above and to the left of the origin.
<A NAME="75"><H2>Scroll Bars</H2></A><P>Microsoft Windows makes it easy to display scroll bars at the edges of a 
window, but Windows by itself doesn't make any attempt to connect those 
scroll bars to their window. That's where the 
<I>CScrollView</I> class fits in. 
<I>CScrollView</I> member functions process the WM_HSCROLL and WM_VSCROLL 
messages sent by the scroll bars to the view. Those functions move the viewport 
within the window and do all the necessary housekeeping.
<A NAME="76"><H2>Scrolling Alternatives</H2></A><P>The <I>CScrollView</I> class supports a particular kind of scrolling that involves 
one big window and a small viewport. Each item is assigned a unique position in 
this big window. If, for example, you have 10,000 address lines to display, 
instead of having a window 10,000 lines long, you probably want a smaller window 
with scrolling logic that selects only as many lines as the screen can display. In 
that case, you should write your own scrolling view class derived from 
<I>CView</I>.<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
Microsoft Windows NT uses 32-bit numbers for 
logical coordinates, so your logical coordinate space is almost 
unlimited. Microsoft Windows 95, however, still has some 16-bit 
components, so it uses 16-bit numbers for logical coordinates, limiting values 
to the range -32,768 to 32,767. Scroll bars send messages with 
16-bit values in both operating systems. With these facts in mind, you 
probably want to write code to the lowest common denominator, 
which is Windows 95.
</BLOCKQUOTE></DIV>
<P>
<A NAME="77"><H2>The <I>OnInitialUpdate</I> Function</H2></A><P>You'll be seeing more of the 
<I>OnInitialUpdate</I> function when you study the document-view architecture, starting in <A HREF="ch16a.htm">Chapter 16</A>. The virtual <I>OnInitial-Update</I> function is important here because it is the first function called by the 
framework after your view window is fully created. The framework calls 
<I>OnInitialUpdate</I> before it calls <I>OnDraw</I> for the first time, so 
<I>OnInitialUpdate</I> is the natural place for setting the logical size and mapping mode for a 
scrolling view. You set these parameters with a call to the <I>CScrollView::SetScrollSizes</I> 
function.

<A NAME="78"><H2>Accepting Keyboard Input</H2></A><P>Keyboard input is really a two-step process. Windows sends 
WM_KEYDOWN and WM_KEYUP messages, with 
<U>virtual</U> <U>key</U> <U>codes</U>, to a window, but before 
they get to the window they are translated. If an ANSI character is typed 
(resulting in a WM_KEYDOWN message), the translation function checks the 
keyboard shift status and then sends a WM_CHAR message with the proper code, 
either uppercase or lowercase. Cursor keys and function keys don't have codes, 
so there's no translation to do. The window gets only the WM_KEYDOWN 
and WM_KEYUP messages.
<P>You can use ClassWizard to map all these messages to your view. If 
you're expecting characters, map WM_CHAR; if you're expecting other 
keystrokes, map WM_KEYDOWN. The MFC library neatly supplies the character code 
or virtual key code as a handler function parameter.
<A NAME="79"><H2>The EX04C Example&#151;Scrolling</H2></A><P>The goal of EX04C is to make a logical window 20 centimeters wide by 
30 centimeters high. The program draws the same ellipse that it drew in the 
EX04B project. You could edit the EX04B source files to convert the 
<I>CView</I> base class to a <I>CScrollView</I> base class, but it's easier to start over with 
AppWizard. AppWizard generates the <I>OnInitialUpdate</I> override function for you. Here 
are the steps:
<OL>
<B><LI>Run AppWizard to create EX04C.</B>Use AppWizard to generate a 
program named EX04C in the \vcpp32\ex04c subdirectory. In 
AppWizard Step 6, set the <I>CEx04cView</I> base class to 
<I>CScrollView</I>, as shown here.
<P>
</OL>
<P><A HREF="javascript:fullSize('G04OG04x.htm')"> <img src="G04OG04.JPG" width=404 height=349 border=0 ALT = "Click to view at full size."> </A><P>
<OL START="2">
<B><LI>Add the <I>m</I>_<I>rectEllipse</I> and <I>m_nColor</I> data members in ex04cView.h.</B>
Insert the following code by right-clicking the 
<I>CEx04cView</I> class in the Workspace window or by typing inside the 
<I>CEx04cView</I> class declaration:<P>
<PRE><B>private:
    CRect m_rectEllipse;
    int m_nColor;</B>
</PRE>
<P>These are the same data members that were added in the EX04A 
and EX04B projects.<P>
<B><LI>Modify the AppWizard-generated <I>OnInitialUpdate 
</I>function.</B> Edit <I>OnInitialUpdate</I> in ex04cView.cpp as shown here:
<P>
<PRE>void CEx04cView::OnInitialUpdate()
{
    CScrollView::OnInitialUpdate();
    <B>CSize sizeTotal(20000, 30000); // 20 by 30 cm
    CSize sizePage(sizeTotal.cx / 2, sizeTotal.cy / 2);
    CSize sizeLine(sizeTotal.cx / 50, sizeTotal.cy / 50);</B>
   <B> SetScrollSizes(MM_HIMETRIC, sizeTotal, sizePage, sizeLine);</B>
}
</PRE>
<P>
<B><LI>Use ClassWizard to add a message handler for the 
WM_KEYDOWN message.</B> ClassWizard generates the member function 
<I>OnKeyDown</I> along with the necessary message map entries and prototypes. Edit 
the code as follows:<P>
<PRE>void CEx04cView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags)
{
    <B>switch (nChar) {
    case VK_HOME:
        OnVScroll(SB_TOP, 0, NULL);
        OnHScroll(SB_LEFT, 0, NULL);
        break;
    case VK_END:
        OnVScroll(SB_BOTTOM, 0, NULL);
        OnHScroll(SB_RIGHT, 0, NULL);
        break;
    case VK_UP:
        OnVScroll(SB_LINEUP, 0, NULL);
        break;
    case VK_DOWN:
        OnVScroll(SB_LINEDOWN, 0, NULL);
        break;
    case VK_PRIOR:
        OnVScroll(SB_PAGEUP, 0, NULL);
        break;
    case VK_NEXT:
        OnVScroll(SB_PAGEDOWN, 0, NULL);
        break;
    case VK_LEFT:
        OnHScroll(SB_LINELEFT, 0, NULL);
        break;
    case VK_RIGHT:
        OnHScroll(SB_LINERIGHT, 0, NULL);
        break;
    default:
        break;</B>
   <B> }</B>
}
</PRE>
<P>
<B><LI>Edit the constructor and the <I>OnDraw</I> function.</B> Change the 
AppWizard-generated constructor and the 
<I>OnDraw</I> function in ex04cView.cpp as follows:<P>
<PRE>CEx04cView::CEx04cView() <B>: m_rectEllipse(0, 0, 4000, -4000)</B>
{
    <B>m_nColor = GRAY_BRUSH;</B>
}
.
.
.
void CEx04cView::OnDraw(CDC* pDC)
{
    <B>pDC-&gt;SelectStockObject(
m_nColor);
    pDC-&gt;Ellipse(m_rectEllipse);
}</B>
</PRE>
<P>These functions are identical to those used in the EX04A and 
EX04B projects.<P>
<B><LI>Map the WM_LBUTTONDOWN message and edit the 
handler.</B> Make the following changes to the ClassWizard-generated code:<P>
<PRE>void CEx04cView::OnLButtonDown(UINT nFlags, CPoint point) 
{
    <B>CClientDC dc(this);
    OnPrepareDC(&amp;dc);
    CRect rectDevice = m_rectEllipse;
    dc.LPtoDP(rectDevice);
    if (rectDevice.PtInRect(point)) {
        if (m_nColor == GRAY_BRUSH) {
            m_nColor = WHITE_BRUSH;
        }
        else {
            m_nColor = GRAY_BRUSH;
        }
        InvalidateRect(rectDevice);
    }</B>
}
</PRE>
<P>This function is identical to the 
<I>OnLButtonDown</I> handler in the EX04B project. It calls 
<I>OnPrepareDC</I> as before, but there is something 
different. The <I>CEx04bView</I> class doesn't have an overridden 
<I>OnPrepareDC</I> function, so the call goes to 
<I>CScrollView::OnPrepareDC</I>. That function 
sets the mapping mode based on the first parameter to 
<I>SetScrollSizes</I>, and it sets the window origin based on the current scroll position. Even if 
your scroll view used the <I>MM_TEXT</I> mapping mode, you'd still need the 
coordinate conversion logic to adjust for the origin offset.
<P>
<B><LI>Build and run the EX04C program.</B> Check to be sure the mouse 
hit logic is working even if the circle is scrolled partially out of the 
window. Also check the keyboard logic. The output should look like this.
</OL>
<P><img src="G04OG05x.gif" width=419 height=334 border=0> <P>

</BODY>
</HTML>



