<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>An Automation Client Program Using the Compiler's #import Directive</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="536"><H1><B>An Automation Client Program Using the Compiler's <I>#import</I> Directive</B></H1></A>
<P>Now there's an entirely new way of writing Automation client programs. Instead of using ClassWizard to generate a class derived from <I>COleDispatchDriver</I>, you use the compiler to generate header and implementation files directly from a component's type library. For the clock component, your client program contains the following statement:

<P><pre>
#import&quot;..\ex25c\debug\ex25c.tlb&quot; rename_namespace(&quot;ClockDriv&quot;) using namespace ClockDriv;
</pre>

<P>The compiler then generates (and processes) two files, ex25c.tlh and ex25c.tli, in the project's Debug or Release subdirectory. The TLH file contains the <I>IEx25c</I> clock driver class declaration plus this <U>smart</U> <U>pointer</U> declaration:

<P><pre>
_COM_SMARTPTR_TYPEDEF(IEx25c, __uuidof(IDispatch));
</pre>

<P>The <I>_COM_SMARTPTR_TYPEDEF</I> macro generates the <I>IEx25cPtr </I>pointer type, which encapsulates the component's <I>IDispatch</I> pointer. The TLI file contains inline implementations of member functions, some of which are shown in the following code:

<P><pre>
inline HRESULT IEx25c::RefreshWin ( ) {
    return _com_dispatch_method(this, 0x4, DISPATCH_METHOD, 
        VT_EMPTY, NULL, NULL);
}

inline DATE IEx25c::GetTime ( ) {
    DATE _result;
    _com_dispatch_propget(this, 0x1, VT_DATE, (void*)&amp;_result);
    return _result;
}

inline void IEx25c::PutTime ( DATE _val ) {
    _com_dispatch_propput(this, 0x1, VT_DATE, _val);
}
</pre>

<P>Note the similarity between these functions and the <I>COleDispatchDriver</I> member functions you've already seen. The functions <I>_com_dispatch_method</I>, <I>_com_dispatch_propget</I>, and 
<I>_com_dispatch_propput</I> are in the runtime library.

<P>In your Automation client program, you declare an embedded smart pointer member in your view class (or in another class) like this:

<P><pre>
IEx25cPtr  m_clock;
</pre>

<P>Then you create a clock component object with this statement:

<P><pre>
m_clock.CreateInstance(__uuidof(Document));
</pre>

<P>Now you're ready to use the <I>IEx25cPtr</I> class's overloaded -&gt; operator to call the member functions defined in the TLI file:

<P><pre>
m_clock-&gt;PutTime(COleDateTime::GetCurrentTime());
m_clock-&gt;RefreshWin();
</pre>

<P>When the <I>m_clock</I> smart pointer object goes out of scope, its destructor calls the COM <I>Release</I> function.

<P>The <I>#import</I> directive is the future of COM programming. With each new version of Visual C++, you'll see COM features moving into the compiler, along with the document_view architecture itself.

</BODY>
</HTML>



