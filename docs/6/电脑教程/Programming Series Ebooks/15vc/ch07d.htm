<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The Windows Common Dialogs</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="164"><H1>The Windows Common Dialogs</H1></A>
<P>Windows provides a group of standard user interface dialogs, and these are supported by the MFC library classes. You are probably familiar with all or 
most of these dialogs because so many Windows-based applications, including 
Visual C++, already use them. All the common dialog classes are derived from a 
common base class, <I>CCommonDialog</I>. A list of the COMDLG32 classes is 
shown in the following table.
<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>Class</B></TD><TD VALIGN="TOP"><B>Purpose</B></TD></TR>
<TR><TD VALIGN="TOP"><I>CColorDialog</I></TD><TD VALIGN="TOP">Allows the user to select or create a color</TD></TR>
<TR><TD VALIGN="TOP"><I>CFileDialog</I></TD><TD VALIGN="TOP">Allows the user to open or save a file</TD></TR>
<TR><TD VALIGN="TOP"><I>CFindReplaceDialog</I></TD><TD VALIGN="TOP">Allows the user to substitute one string for another</TD></TR>
<TR><TD VALIGN="TOP"><I>CPageSetupDialog</I></TD><TD VALIGN="TOP">Allows the user to input page 
measurement parameters</TD></TR>
<TR><TD VALIGN="TOP"><I>CFontDialog</I></TD><TD VALIGN="TOP">Allows the user to select a font from a list of available fonts</TD></TR>
<TR><TD VALIGN="TOP"><I>CPrintDialog</I></TD><TD VALIGN="TOP">Allows the user to set up the printer and print a document</TD></TR>
</TABLE>
<P>
Here's one characteristic that all common dialogs share: they gather information from the user, but they don't do anything with it. The file dialog can help the user select a file to open, but it really just provides your program with the pathname&#151;your program must make the call that opens the file. Similarly, a font dialog fills in a structure that describes a font, but it doesn't create the font.
<A NAME="165"><H2>Using the <I>CFileDialog</I> Class Directly</H2></A><P>Using the <I>CFileDialog</I> class to open a file is easy. The following code opens 
a file that the user has selected through the dialog:<P>
<PRE>CFileDialog dlg(TRUE, &quot;bmp&quot;, &quot;*.bmp&quot;);
if (dlg.DoModal() == IDOK) {
    CFile file;
    VERIFY(file.Open(dlg.GetPathName(), CFile::modeRead));
}
</PRE><P>The first constructor parameter (<I>TRUE</I>) specifies that this object is a &quot;File Open&quot; dialog instead of a &quot;File Save&quot; dialog. The default file extension is <I>bmp</I>, and <I>*.bmp</I> appears first in the filename edit box. The <I>CFileDialog::GetPathName</I> function returns a <I>CString</I> object that contains the full pathname of the selected file.
<A NAME="166"><H2>Deriving from the Common Dialog Classes</H2></A>
<P>Most of the time, you can use the common dialog classes directly. If you 
derive your own classes, you can add functionality without duplicating code. 
Each COMDLG32 dialog works a little differently, however. The next example is specific to the file dialog, but it should give you some ideas for customizing 
the other common dialogs.
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
In the early editions of this book, the EX07B example dynamically created controls inside the standard file dialog. That technique doesn't work in Win32, but the nested dialog method described here has the same effect.
</BLOCKQUOTE></DIV>
<A NAME="167"><H2>Nested Dialogs</H2></A><P>Win32 provides a way to &quot;nest&quot; one dialog inside another so that multiple dialogs appear as one seamless whole. You must first create a dialog resource template with a &quot;hole&quot; in it&#151;typically a group box control&#151;with the specific child window ID <I>stc32 (=0x045f)</I>. Your program sets some parameters that tell COMDLG32 to use your template. In addition, your program must hook into the COMDLG32 message loop so that it gets first crack at selected notifications. When you're done with all of this, you'll notice that you have created a dialog window that is a child of the COMDLG32 dialog window, even though your template wraps COMDLG32's template.
<P>This sounds difficult, and it is unless you use MFC. With MFC, you build the dialog resource template as described above, derive a class from one of the common dialog base classes, add the class-specific connection code in <I>OnInitDialog</I>, and then happily use ClassWizard to map the messages that 
originate from your template's new controls.
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
Windows NT 3.51 uses an earlier version of the common dialogs DLL that does not support the new Windows namespace feature. The nested dialog technique illustrated in the EX07B example won't work with the Windows NT 3.51 version of the file dialog.
</BLOCKQUOTE></DIV>
<A NAME="168"><H2>A <I>CFileDialog</I> Example&#151;EX07B</H2></A><P>In this example, you will derive a class <I>CEx07bDialog</I> that adds a working Delete All Matching Files button to the standard file dialog. It also changes the dialog's title and changes the Open button's caption to Delete (to delete a single file). The example illustrates how you can use nested dialogs to add new controls to standard common dialogs. The new file dialog is activated as in the 
previous examples&#151;by pressing the left mouse button when the mouse cursor is in the view window. Because you should be gaining skill with Visual C++, the following steps won't be as detailed as those for the earlier examples. Figure 7-1 shows what the dialog looks like.
<P><A HREF="javascript:fullSize('f07og01x.htm')"> <img src="f07og01.jpg" width=404 height=291 border=0 ALT = "Click to view at full size."> </A>
<P>
<!-- caption -->
<B>Figure 7-1.</B> <I>The Delete File dialog in action.</I>
<!-- /caption -->
<P>Follow these steps to build the EX07B application:
<OL>
<B><LI>Run AppWizard to produce \vcpp32\ex07b\ex07b.</B> Accept all the defaults but two: select Single Document and deselect Printing And Print Preview. The options and the default class names are shown in the next graphic.<P>
</OL>
<P><img src="G07OG04x.GIF" width=413 height=418 border=0><P>
<OL START="2">
<B><LI>Use the dialog editor to create a dialog resource.</B> Make the dialog box about 3-by-5 inches, and use the ID <I>IDD_FILESPECIAL</I>. Set the dialog's Style property to Child, its Border property to None, and select its Clip Siblings and Visible properties. Create the template with a button with 
ID <I>IDC_DELETE</I> and a group box with ID <I>stc32=0x045f</I>, as shown here.<P>
</OL>
<P><A HREF="javascript:fullSize('G07OG05x.htm')"> <img src="G07OG05.JPG" width=404 height=377 border=0 ALT = "Click to view at full size."> </A><P>
<OL><P>
Check your work by choosing Resource Symbols from the Visual C++ View menu. You should see a symbol list like the one shown in the graphic below.
</OL>
<P><IMG SRC="G07OG06.GIF" width=399 height=309 BORDER=0><P>
<OL START="3">
<B><LI>Use ClassWizard to create the <I>CSpecialFileDialog</I> class.</B> Fill in the New Class dialog, as shown here, and then click the Change button.
</OL>
<P><IMG SRC="G07OG07.GIF" width=404 height=366 BORDER=0><P>
<OL START="4">
<P>Change the names to SpecFileDlg.h and SpecFileDlg.cpp. Unfortunately, we cannot use the Base Class drop-down list to change the base class to <I>CFileDialog</I>, as that would decouple our class from the <I>IDD_FILESPECIAL</I> template. We have to change the base class by hand.
<P><B><LI>Edit the file SpecFileDlg.h.</B> Change the line
<P><PRE>class CSpecialFileDialog : public CDialog</PRE>
<P>to
<P><PRE>class CSpecialFileDialog : public C<B>File</B>Dialog</PRE>
<P>Add the following two public data members:
<P><PRE><B>CString m_strFilename;
BOOL m_bDeleteAll;</B></PRE>
<P>Finally, edit the constructor declaration:
<P><PRE>CSpecialFileDialog(<B>BOOL bOpenFileDialog, 
    LPCTSTR lpszDefExt = NULL,
    LPCTSTR lpszFileName = NULL,
    DWORD dwFlags = OFN_HIDEREADONLY | OFN_OVERWRITEPROMPT,
    LPCTSTR lpszFilter = NULL,
    CWnd* pParentWnd = NULL</B>
);</PRE>
<P><B><LI>Replace <I>CDialog</I> with <I>CFileDialog</I> in SpecFileDlg.h.</B> Choose Replace from Visual C++'s Edit menu, and replace this name globally.
<P><B><LI>Edit the <I>CSpecialFileDialog</I> constructor in SpecFileDlg.cpp. </B>The derived class destructor must invoke the base class constructor and 
initialize the <I>m_bDeleteAll</I> data member. In addition, it must set some members of the <I>CFileDialog</I> base class data member <I>m_ofn</I>, which is an instance of the Win32 <I>OPENFILENAME</I> structure. The <I>Flags</I> and <I>lpTemplateName</I> members control the coupling to your <I>IDD_FILESPECIAL</I> template, and the <I>lpstrTitle</I> member changes the main dialog box title. Edit the constructor as follows:
<P><PRE>CSpecialFileDialog::CSpecialFileDialog(<B>BOOL bOpenFileDialog,
        LPCTSTR lpszDefExt, LPCTSTR lpszFileName, DWORD dwFlags,
        LPCTSTR lpszFilter, CWnd* pParentWnd)
    : CFileDialog(bOpenFileDialog, lpszDefExt, lpszFileName,
        dwFlags, lpszFilter, pParentWnd)</B>
{
    //{{AFX_DATA_INIT(CSpecialFileDialog)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
<B>    m_ofn.Flags |= OFN_ENABLETEMPLATE;
    m_ofn.lpTemplateName = MAKEINTRESOURCE(IDD_FILESPECIAL);
    m_ofn.lpstrTitle = &quot;Delete File&quot;;
    m_bDeleteAll = FALSE;</B>
}
</PRE>
<P><B><LI>Map the WM_INITDIALOG message in the <I>CSpecialDialog</I> class.</B> The <I>OnInitDialog</I> member function needs to change the common dialog's Open button caption to Delete. The child window ID is <I>IDOK</I>.
<P><PRE><B>BOOL bRet = CFileDialog::OnInitDialog();
if (bRet == TRUE) {
    GetParent()-&gt;GetDlgItem(IDOK)-&gt;SetWindowText(&quot;Delete&quot;);
}
return bRet;
</B></PRE>
<P><B><LI>Map the new IDC_DELETE button (Delete All Matching Files) in the <I>CSpecialDialog</I> class.</B> The <I>OnDelete</I> member function sets the 
<I>m_bDeleteAll</I> flag and then forces the main dialog to exit as if the 
Cancel button had been clicked. The client program (in this case, the view) 
gets the <I>IDCANCEL</I> return from <I>DoModal</I> and reads the flag to see whether it should delete all files. Here is the function:
<P><PRE> void CSpecialFileDialog::OnDelete() 
{
<B>    m_bDeleteAll = TRUE;
    // 0x480 is the child window ID of the File Name edit control
    //  (as determined by SPYXX)
    GetParent()-&gt;GetDlgItem(0x480)-&gt;GetWindowText(m_strFilename);
    GetParent()-&gt;SendMessage(WM_COMMAND, IDCANCEL);</B>
}
</PRE><P><B><LI>Add code to the virtual <I>OnDraw</I> function in file ex07bView.cpp.</B> The <I>CEx07bView OnDraw</I> function (whose skeleton was generated by AppWizard) should be coded as follows to prompt the user to press 
the mouse button:
<P><PRE>void CEx07bView::OnDraw(CDC* pDC)
{
<B>    pDC-&gt;TextOut(0, 0, &quot;Press the left mouse button here.&quot;);</B>
}
</PRE>
<P><B><LI>Add the OnLButtonDown message handler to the <I>CEx07bView</I> class.</B> Use ClassWizard to create the message handler for WM_LBUTTON-DOWN, and then edit the code as follows:
<P><PRE>void CEx07bView::OnLButtonDown(UINT nFlags, CPoint point) 
{
<B>    CSpecialFileDialog dlgFile(TRUE, NULL, &quot;*.obj&quot;);
    CString strMessage;
    int nModal = dlgFile.DoModal();
    if ((nModal == IDCANCEL) &amp;&amp; (dlgFile.m_bDeleteAll)) {
        strMessage.Format(
            &quot;Are you sure you want to delete all %s files?&quot;,
            dlgFile.m_strFilename);
        if (AfxMessageBox(strMessage, MB_YESNO) == IDYES) {
            HANDLE h;
            WIN32_FIND_DATA fData;
            while((h = ::FindFirstFile(dlgFile.m_strFilename, &amp;fData))
                    != (HANDLE) 0xFFFFFFFF) { // no MFC equivalent
                if (::DeleteFile(fData.cFileName) == FALSE) {
                    strMessage.Format(&quot;Unable to delete file %s\n&quot;,
                        fData.cFileName);
                    AfxMessageBox(strMessage);
                    break;
                }
            }
        }
    }
    else if (nModal == IDOK) {
        CString strSingleFilename = dlgFile.GetPathName();
        strMessage.Format(
            &quot;Are you sure you want to delete %s?&quot;, strSingleFilename);
        if (AfxMessageBox(strMessage, MB_YESNO) == IDYES) {
            CFile::Remove(strSingleFilename);
        }
    }</B>
}</PRE>
<P>Remember that common dialogs just gather data. Since the view is the client of the dialog, the view must call <I>DoModal</I> for the file dialog object and then figure out what to do with the information returned. In this case, the view has the return value from <I>DoModal</I> (either<I> IDOK</I> or 
<I>IDCANCEL</I>) and the value of the public <I>m_bDeleteAll</I> data member, and it can call various <I>CFileDialog</I> member functions such as <I>GetPathName</I>. If <I>DoModal</I> returns <I>IDCANCEL</I> and the flag is 
<I>TRUE</I>, the function makes the Win32 file system calls necessary to delete all the matching files. If <I>DoModal</I> returns <I>IDOK</I>, the function can use the MFC <I>CFile</I> functions to delete an individual file.
<P>Using the global <I>AfxMessageBox</I> function is a convenient way to pop up a simple dialog that displays some text and then queries the user for a Yes/No answer. The <I>Microsoft Foundation</I> <I>Classes And Templates </I> section in the online help describes all of the message box variations and options.
<P>Of course, you'll need to include the statement
<P><PRE><B>#include &quot;SpecFileDlg.h&quot;</B></PRE>
<P>after the line
<P><PRE>#include &quot;ex07bView.h&quot;</PRE>
<P><B><LI>Build and test the application.</B>Build and run EX07B. Pressing the 
left mouse button should bring up the Delete File dialog, and you should be able to use it to navigate through the disk directory and to delete files. Be careful not to delete your important source files!
</OL>

<A NAME="169"><H2>Other Customization for <I>CFileDialog</I></H2></A><P>In the EX07B example, you added a pushbutton to the dialog. It's easy to add other controls too. Just put them in the resource template, and if they are standard Windows controls such as edit controls or list boxes, you can use ClassWizard to add data members and DDX/DDV code to your derived class. The client program can set the data members before calling <I>DoModal</I>, and it can retrieve the updated values after <I>DoModal</I> returns.
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
Even if you don't use nested dialogs, two windows are still associated with a <I>CFileDialog</I> object. Suppose you have overridden <I>OnInitDialog</I> in a derived class and you want to assign an icon to the file dialog. You must call 
<I>CWnd::GetParent</I> to get the top-level window, just as you did in the EX07B example. Here's the code:
<P><PRE>HICON hIcon = AfxGetApp()-&gt;LoadIcon(ID_MYICON);
GetParent()-&gt;SetIcon(hIcon, TRUE);        // Set big icon
GetParent()-&gt;SetIcon(hIcon, FALSE);       // Set small icon
</PRE>
</BLOCKQUOTE></DIV>

</BODY>
</HTML>



