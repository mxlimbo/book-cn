<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Using the Companion CD-ROM</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="1042"><H1>Using the Companion CD-ROM</H1></A><P>The companion CD-ROM bound inside the back cover of this book contains the source code files for all the sample programs. The executable program files are included, so you won't have to build the samples that you're interested in. To install the companion CD-ROM's files, insert the disc in your CD-ROM drive and run the Setup program. Follow the on-screen instructions.
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.gif" width=123 height=18 BORDER="0"><P>
The Setup program copies about 30 MB of files to your hard disk. If you prefer, you can manually install only the files for individual projects. Simply tree-copy the corresponding subdirectories from the CD-ROM to c:\vcpp32. Because each project is self-contained, no additional files from other projects are needed. (You'll need to remove the read-only attribute from these files if you copy them using Windows Explorer or File Manager.)
</blockquote></div>
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.gif" width=123 height=18 BORDER="0"><P>Many of the files on the companion CD-ROM have long filenames. If you use Windows 95 and your CD-ROM drive uses a real-mode driver, you'll see truncated names for these files and you might not see all of the files or directories. The Setup program will still work correctly, however, by copying files from a special \SETUP directory on the CD-ROM and renaming them with their proper long filenames. You can then browse the files on your hard disk. Alternatively, you can browse the files using the 8.3 aliases in the \SETUP directory on the CD-ROM.
</blockquote></div>
<P>With a conventional C-language program using the Windows API, the source code files tell the whole story. With the MFC library application framework, things are not so simple. AppWizard generates much of the C++ code, and the resources originate in the resource editors. The examples in the early chapters of this book include step-by-step instructions for using the tools to generate and customize the source code files. You'd be well advised to walk through those instructions for the first few examples; there's very little code to type. For the middle chapters, use the code from the companion CD-ROM but read through the steps in order to appreciate the role of the resource editors and the wizards. For the final chapters, not all the source code is listed. You'll need to examine the companion CD-ROM's files for those examples.
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<B>For Win32 Programmers: Unicode</B>
<P>Until recently, Windows-based programs have used only the ANSI character set, which consists of 256 single-byte characters. Developers targeting the Asian software market are moving to the Unicode character set, which consists of 65,536 characters, each 2 bytes (wide). A third option, the double-byte character set (DBCS), includes both 1-byte characters and 2-byte characters, but DBCS is falling out of favor.
<P>The MFC library and the runtime library both support Unicode applications. If you define the constant <I>_UNICODE</I> and follow the steps described in the online documentation, all your character variables and constant strings will be wide and the compiler will generate calls to the wide-character versions of the Win32 functions. This assumes that you use certain macros when you declare character pointers and arrays&#151;for example, <I>TCHAR</I> and 
<I>_T</I>.
<P>You'll hit a snag, though, if you try to run your MFC Unicode applications under Windows 95 or Windows 98, because they don't support Unicode internally. Even though Windows 95 and Windows 98 have wide-character versions of Win32 functions, those functions return a failure code. Windows NT, on the other hand, uses Unicode internally and has two versions of the Win32 functions that deal with characters. If you call a single-byte version, Windows NT makes the necessary conversions to and from wide characters.
<P>None of the sample programs in this book are configured for Unicode. All the programs use single-byte types such as <I>char</I> and single-byte string constants, and they <U>do</U> <U>not</U> define <I>_UNICODE</I>. If you 
run the samples under Windows NT, the operating system will do the necessary single-to-wide conversions; if you run them under Windows 95 or Windows 98, the interface is pure single-byte.
<P>One area in which you're forced to deal with wide characters is COM. All non-MFC COM functions (except DAO functions) that have string and character parameters require wide (<I>OLECHAR</I>) characters. If you write a non-Unicode program, you must do the conversions yourself with the help of the MFC 
<I>CString </I>class and various MFC macros.
<P>If you want to write Unicode applications, read the Unicode chapter in Jeffrey Richter's <I>Advanced Windows</I>. You should also read the Unicode material in the Visual C++ online documentation.
</BLOCKQUOTE>
</DIV>
</BODY>
</HTML>



