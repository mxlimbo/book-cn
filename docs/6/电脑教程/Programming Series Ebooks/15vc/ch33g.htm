<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Creating an OLE DB Provider</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="849"><H1>Creating an OLE DB Provider</H1></A><P>It's pretty obvious how OLE DB consumers are useful. You just ask a 
wizard to create a wrapper for you, and you get a fairly easy way to access the data 
in a database. However, it might be a bit less obvious why you'd want to 
create an OLE DB provider.
<A NAME="850"><H2>Why Write an OLE DB Provider?</H2></A><P>Writing an OLE DB allows you to insert a layer between a client of some 
data and the actual data itself. Here are just a few reasons you might want to 
write a provider.
<UL>
<LI>Writing an OLE DB provider means clients don't necessarily 
touch the data directly. Therefore, you can add additional capabilities 
to your data, such as query processing.<P>
<LI>In some cases, writing an OLE DB provider gives you the 
opportunity to increase data access performance by controlling how the 
data is manipulated.<P>
<LI>Adding an OLE DB provider layer increases the potential 
audience of your data. For example, if you have a proprietary data format 
that can be accessed by only one programming language, you have 
a single point of failure. OLE DB providers give you a way to 
open that proprietary format to a wider variety of programmers, 
regardless of the programming language they use.<P>
</UL>
<A NAME="851"><H2>Writing an OLE DB Provider</H2></A><P>Working with the OLE DB Providers is similar to working with the 
Consumers. The wizards do a lot of the work for you. You just need to know how 
to work with the generated classes. The steps for creating an OLE DB 
Provider are listed here. 
<OL>
<LI>The first step is to decide what you want the provider to do. 
Remember the philosophy behind OLE DB: it's all about providing 
a singular way to access multiple data sources. For example, you 
might want to write a provider that recursively enumerates the contents 
of a structured storage file. Or you might want a provider that 
sifts through e-mail folders and allows clients database-style access 
to your e-mail system. The possibilities are nearly endless.<P>
<LI>Just as you did when writing a data consumer, use the ATL 
Object Wizard to create a provider. Just start the ATL Object Wizard 
from ClassView or from the Insert menu. Select the Data Access 
objects category, and choose Provider. The ATL Object Wizard will ask 
you to provide a name for your object and will allow you to modify 
the default names for the files it will create.
<P>
<LI>After you click OK, the ATL Object Wizard creates the code for 
a provider, including a data source, a rowset, and a session. In 
addition to these objects, a provider supports one or more 
properties, which are defined in property maps within the files created by 
the OLE DB Provider Template Wizard. When the Wizard creates 
the files, it inserts maps for the properties belonging to the OLE 
DB property group defined for the object or objects included in 
those files. For example, the header file containing the data source 
object also contains the property map for the DataSource properties. 
The session header file contains the property map for the Session 
properties. Finally, the rowset and command objects reside in a 
single header file, which includes properties for the command object.
</OL>
<P>For example, here's what the ATL Object Wizard produces for an 
OLE DB provider named AProvider. First the ATL Object Wizard creates a 
data source object, which lives in a file named AProviderDS.H:
<P><PRE>class ATL_NO_VTABLE CAProviderSource : 
    public CComObjectRootEx&lt;CComSingleThreadModel&gt;,
    public CComCoClass&lt;CAProviderSource, &amp;CLSID_AProvider&gt;,
    public IDBCreateSessionImpl&lt;CAProviderSource, CAProviderSession&gt;,
    public IDBInitializeImpl&lt;CAProviderSource&gt;,
    public IDBPropertiesImpl&lt;CAProviderSource&gt;,
    public IPersistImpl&lt;CAProviderSource&gt;,
    public IInternalConnectionImpl&lt;CAProviderSource&gt;
{
public:
    HRESULT FinalConstruct()
    {
        return FInit();
    }
DECLARE_REGISTRY_RESOURCEID(IDR_APROVIDER)
BEGIN_PROPSET_MAP(CAProviderSource)
    BEGIN_PROPERTY_SET(DBPROPSET_DATASOURCEINFO)
        PROPERTY_INFO_ENTRY(ACTIVESESSIONS)
        PROPERTY_INFO_ENTRY(DATASOURCEREADONLY)
        PROPERTY_INFO_ENTRY(BYREFACCESSORS)
        PROPERTY_INFO_ENTRY(OUTPUTPARAMETERAVAILABILITY)
        PROPERTY_INFO_ENTRY(PROVIDEROLEDBVER)
        PROPERTY_INFO_ENTRY(DSOTHREADMODEL)
        PROPERTY_INFO_ENTRY(SUPPORTEDTXNISOLEVELS)
        PROPERTY_INFO_ENTRY(USERNAME)
    END_PROPERTY_SET(DBPROPSET_DATASOURCEINFO)
    BEGIN_PROPERTY_SET(DBPROPSET_DBINIT)
        PROPERTY_INFO_ENTRY(AUTH_PASSWORD)
        PROPERTY_INFO_ENTRY(AUTH_PERSIST_SENSITIVE_AUTHINFO)
        PROPERTY_INFO_ENTRY(AUTH_USERID)
        PROPERTY_INFO_ENTRY(INIT_DATASOURCE)
        PROPERTY_INFO_ENTRY(INIT_HWND)
        PROPERTY_INFO_ENTRY(INIT_LCID)
        PROPERTY_INFO_ENTRY(INIT_LOCATION)
        PROPERTY_INFO_ENTRY(INIT_MODE)
        PROPERTY_INFO_ENTRY(INIT_PROMPT)
        PROPERTY_INFO_ENTRY(INIT_PROVIDERSTRING)
        PROPERTY_INFO_ENTRY(INIT_TIMEOUT)
    END_PROPERTY_SET(DBPROPSET_DBINIT)
    CHAIN_PROPERTY_SET(CAProviderCommand)
END_PROPSET_MAP()
BEGIN_COM_MAP(CAProviderSource)
    COM_INTERFACE_ENTRY(IDBCreateSession)
    COM_INTERFACE_ENTRY(IDBInitialize)
    COM_INTERFACE_ENTRY(IDBProperties)
    COM_INTERFACE_ENTRY(IPersist)
    COM_INTERFACE_ENTRY(IInternalConnection)
END_COM_MAP()
public:
};</PRE>
<P>In addition to the data object, the ATL Object Wizard produces a 
command object and a rowset that both live within AProviderRS.H:
<P><PRE>class ATL_NO_VTABLE CAProviderCommand : 
    public CComObjectRootEx&lt;CComSingleThreadModel&gt;,
    public IAccessorImpl&lt;CAProviderCommand&gt;,
    public ICommandTextImpl&lt;CAProviderCommand&gt;,
    public ICommandPropertiesImpl&lt;CAProviderCommand&gt;,
    public IObjectWithSiteImpl&lt;CAProviderCommand&gt;,
    public IConvertTypeImpl&lt;CAProviderCommand&gt;,
    public IColumnsInfoImpl&lt;CAProviderCommand&gt;
{
public:
BEGIN_COM_MAP(CAProviderCommand)
    COM_INTERFACE_ENTRY(ICommand)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IAccessor)
    COM_INTERFACE_ENTRY(ICommandProperties)
    COM_INTERFACE_ENTRY2(ICommandText, ICommand)
    COM_INTERFACE_ENTRY(IColumnsInfo)
    COM_INTERFACE_ENTRY(IConvertType)
END_COM_MAP()
// ICommand
public:
    HRESULT FinalConstruct()
    {
        HRESULT hr = CConvertHelper::FinalConstruct();
        if (FAILED (hr))
            return hr;
        hr = IAccessorImpl&lt;CAProviderCommand&gt;::FinalConstruct();
        if (FAILED(hr))
            return hr;
        return CUtlProps&lt;CAProviderCommand&gt;::FInit();
    }
    void FinalRelease()
    {
        IAccessorImpl&lt;CAProviderCommand&gt;::FinalRelease();
    }
    HRESULT WINAPI Execute(IUnknown * pUnkOuter, 
                           REFIID riid, DBPARAMS * pParams, 
                           LONG * pcRowsAffected, 
                           IUnknown ** ppRowset);
    static ATLCOLUMNINFO* GetColumnInfo(CAProviderCommand* pv,
                                        ULONG* pcInfo)
    {
        return CAProviderWindowsFile::GetColumnInfo(pv,pcInfo);
    }
BEGIN_PROPSET_MAP(CAProviderCommand)
    BEGIN_PROPERTY_SET(DBPROPSET_ROWSET)
        PROPERTY_INFO_ENTRY(IAccessor)
        PROPERTY_INFO_ENTRY(IColumnsInfo)
        PROPERTY_INFO_ENTRY(IConvertType)
        PROPERTY_INFO_ENTRY(IRowset)
        PROPERTY_INFO_ENTRY(IRowsetIdentity)
        PROPERTY_INFO_ENTRY(IRowsetInfo)
        PROPERTY_INFO_ENTRY(IRowsetLocate)
        PROPERTY_INFO_ENTRY(BOOKMARKS)
        PROPERTY_INFO_ENTRY(BOOKMARKSKIPPED)
        PROPERTY_INFO_ENTRY(BOOKMARKTYPE)
        PROPERTY_INFO_ENTRY(CANFETCHBACKWARDS)
        PROPERTY_INFO_ENTRY(CANHOLDROWS)
        PROPERTY_INFO_ENTRY(CANSCROLLBACKWARDS)
        PROPERTY_INFO_ENTRY(LITERALBOOKMARKS)
        PROPERTY_INFO_ENTRY(ORDEREDBOOKMARKS)
    END_PROPERTY_SET(DBPROPSET_ROWSET)
END_PROPSET_MAP()
};

class RAProviderRowset : public CRowsetImpl&lt;RAProviderRowset, 
                                            CWindowsFile, 
                                            CAProviderCommand&gt;
{
public:
    HRESULT Execute(DBPARAMS * pParams, LONG* pcRowsAffected)
    {
        USES_CONVERSION;
        BOOL bFound = FALSE;
        HANDLE hFile;
        LPTSTR  szDir = (m_strCommandText == _T(&quot;&quot;)) ? _T(&quot;*.*&quot;) : 
                         OLE2T(m_strCommandText);
        CAProviderWindowsFile wf;
        hFile = FindFirstFile(szDir, &amp;wf);
        if (hFile == INVALID_HANDLE_VALUE)
            return DB_E_ERRORSINCOMMAND;
        LONG cFiles = 1;
        BOOL bMoreFiles = TRUE;
        while (bMoreFiles)
        {
            if (!m_rgRowData.Add(wf))
                return E_OUTOFMEMORY;
            bMoreFiles = FindNextFile(hFile, &amp;wf);
            cFiles++;
        }
        FindClose(hFile);
        if (pcRowsAffected != NULL)
            *pcRowsAffected = cFiles;
        return S_OK;
    }
};</PRE>
<P>The ATL Object Wizard produces a session object in a file 
named AProviderSess.H as shown in this code:
<P><PRE>class ATL_NO_VTABLE CAProviderSession : 
    public CComObjectRootEx&lt;CComSingleThreadModel&gt;,
    public IGetDataSourceImpl&lt;CAProviderSession&gt;,
    public IOpenRowsetImpl&lt;CAProviderSession&gt;,
    public ISessionPropertiesImpl&lt;CAProviderSession&gt;,
    public IObjectWithSiteSessionImpl&lt;CAProviderSession&gt;,
    public IDBSchemaRowsetImpl&lt;CAProviderSession&gt;,
    public IDBCreateCommandImpl&lt;CAProviderSession, CAProviderCommand&gt;
{
public:
    CAProviderSession()
    {
    }
    HRESULT FinalConstruct()
    {
        return FInit();
    }
    STDMETHOD(OpenRowset)(IUnknown *pUnk, DBID *pTID, 
                          DBID *pInID, REFIID riid,
                          ULONG cSets, DBPROPSET rgSets[], 
                          IUnknown **ppRowset)
    {
        CAProviderRowset* pRowset;
        return CreateRowset(pUnk, pTID, pInID, riid, 
                            cSets, rgSets, ppRowset, pRowset);
    }
BEGIN_PROPSET_MAP(CAProviderSession)
    BEGIN_PROPERTY_SET(DBPROPSET_SESSION)
        PROPERTY_INFO_ENTRY(SESS_AUTOCOMMITISOLEVELS)
    END_PROPERTY_SET(DBPROPSET_SESSION)
END_PROPSET_MAP()
BEGIN_COM_MAP(CAProviderSession)
    COM_INTERFACE_ENTRY(IGetDataSource)
    COM_INTERFACE_ENTRY(IOpenRowset)
    COM_INTERFACE_ENTRY(ISessionProperties)
    COM_INTERFACE_ENTRY(IObjectWithSite)
    COM_INTERFACE_ENTRY(IDBCreateCommand)
    COM_INTERFACE_ENTRY(IDBSchemaRowset)
END_COM_MAP()
BEGIN_SCHEMA_MAP(CAProviderSession)
    SCHEMA_ENTRY(DBSCHEMA_TABLES, CAProviderSessionTRSchemaRowset)
    SCHEMA_ENTRY(DBSCHEMA_COLUMNS, CAProviderSessionColSchemaRowset)
    SCHEMA_ENTRY(DBSCHEMA_PROVIDER_TYPES, CAProviderSessionPTSchemaRowset)
END_SCHEMA_MAP()
};
class CAProviderSessionTRSchemaRowset : 
    public CRowsetImpl&lt; CAProviderSessionTRSchemaRowset, 
                        CTABLESRow, CAProviderSession&gt;
{
public:
    HRESULT Execute(LONG* pcRowsAffected, ULONG, const VARIANT*)
    {
        USES_CONVERSION;
        CAProviderWindowsFile wf;
        CTABLESRow trData;
        lstrcpyW(trData.m_szType, OLESTR(&quot;TABLE&quot;));
        lstrcpyW(trData.m_szDesc, OLESTR(&quot;The Directory Table&quot;));
        HANDLE hFile = INVALID_HANDLE_VALUE;
        TCHAR szDir[MAX_PATH + 1];
        DWORD cbCurDir = GetCurrentDirectory(MAX_PATH, szDir);
        lstrcat(szDir, _T(&quot;\\*.*&quot;));
        hFile = FindFirstFile(szDir, &amp;wf);
        if (hFile == INVALID_HANDLE_VALUE)
            return E_FAIL; // User doesn't have a c:\ drive
        FindClose(hFile);
        lstrcpynW(trData.m_szTable, T2OLE(szDir), 
                  SIZEOF_MEMBER(CTABLESRow, m_szTable));
        if (!m_rgRowData.Add(trData))
            return E_OUTOFMEMORY;
        *pcRowsAffected = 1;
        return S_OK;
    }
};
class CAProviderSessionColSchemaRowset : 
    public CRowsetImpl&lt; CAProviderSessionColSchemaRowset, 
                        CCOLUMNSRow, CAProviderSession&gt;
{
public:
    HRESULT Execute(LONG* pcRowsAffected, ULONG, const VARIANT*)
    {
        USES_CONVERSION;
        CAProviderWindowsFile wf;
        HANDLE hFile = INVALID_HANDLE_VALUE;
           TCHAR szDir[MAX_PATH + 1];
        DWORD cbCurDir = GetCurrentDirectory(MAX_PATH, szDir);
        lstrcat(szDir, _T(&quot;\\*.*&quot;));
        hFile = FindFirstFile(szDir, &amp;wf);
        if (hFile == INVALID_HANDLE_VALUE)
            return E_FAIL; // User doesn't have a c:\ drive
        FindClose(hFile);// szDir has got the tablename
        DBID dbid;
        memset(&amp;dbid, 0, sizeof(DBID));
        dbid.uName.pwszName = T2OLE(szDir);
        dbid.eKind = DBKIND_NAME;
        return InitFromRowset &lt;RowsetArrayType&gt; (m_rgRowData, 
                                                 &amp;dbid, 
                                                 NULL, 
                                                 m_spUnkSite, 
                                                 pcRowsAffected);
    }
};
class CAProviderSessionPTSchemaRowset : 
    public CRowsetImpl&lt;CAProviderSessionPTSchemaRowset, 
                       CPROVIDER_TYPERow, CAProviderSession&gt;
{
public:
    HRESULT Execute(LONG* pcRowsAffected, ULONG, const VARIANT*)
    {
        return S_OK;
    }
};</PRE>
<A NAME="852"><H3>Modifying the Provider Code</H3></A><P>As with most Wizard-generated code, the OLE DB Provider code 
generated by the ATL Object Wizard is just boilerplate code&#151;it doesn't do very 
much. You need to take several steps to turn this boilerplate code into a real OLE 
DB Provider. The two critical pieces that need to be added to a provider are the 
user record and code to manage a data set and to set the data up as rows and columns.
<UL>
<LI><B>The user record</B> The ATL Object Wizard provides a default 
user record named CAProviderWindowsFile. You don't really want to 
use this user record. You'll probably scrap it and replace it with 
something useful in your domain. As a simple example, imagine you 
want to write an OLE DB Provider that enumerates the compound 
file. Your user record might look like this:
<P><PRE>struct CStgInfo {
BEGIN_PROVIDER_COLUMN_MAP(CStgInfo)
    PROVIDER_COLUMN_ENTRY(&quot;StgName&quot;, 1, szName)
    PROVIDER_COLUMN_ENTRY(&quot;Size&quot;, 2, cbSizeLow)
    PROVIDER_COLUMN_ENTRY(&quot;Size&quot;, 2, cbSizeHigh)

END_PROVIDER_COLUMN_MAP()

    OLECHAR szName[256];
    long cbSizeLow;
    long cbSizeHigh;
};</PRE>
<P>This structure contains the data fields for the name and size 
of the substorage. The provider column map macros map the data 
into columns. You could actually derive the structure from a 
<I>STATSTG</I> structure (used to enumerate structured storages). You just need 
to add entries to the provider column map to handle the members.
<LI><B>Code to open the data set</B> The other important addition to the provider is the code necessary to open the data set. This happens in the rowset's <I>Execute</I> function. There are many different kinds 
of functionality that can go on here. For example, if you want to 
enumerate the top-level substorages in a compound file, you'd first 
open the storage and then enumerate the contents as shown in the 
following code snippet:
<P><PRE>class RStgInfoProviderRowset : 
    public CRowsetImpl&lt;RStgInfoProviderRowset, 
                       CStgInfo, 
                       CStgInfoProviderCommand&gt;
{
public:
    HRESULT Execute(DBPARAMS * pParams, LONG* pcRowsAffected)
    {
        USES_CONVERSION;
        LPTSTR  szFile = 
               m_strCommandText == _T(&quot;&quot;)) ? _T(&quot;&quot;) :
                   OLE2T(m_strCommandText);

        IStorage* pStg = NULL;

        HRESULT hr = StgOpenStorage(szFile, NULL, 
                                    STGM_READ|STGM_SHARE_EXCLUSIVE, 
                                    NULL, NULL, &amp;pStg);

        if(FAILED(hr))
            return DB_E_ERRORSINCOMMAND;

        LONG cStgs = 0;

        IEnumSTATSTG* pEnumSTATSTG;

        hr = pStg-&gt;EnumElements(0, 0, 0, &amp;pEnumSTATSTG);

        if(pEnumSTATSTG) {

            STATSTG rgSTATSTG[100];
            ULONG nFetched;

            hr = pEnumSTATSTG-&gt;Next(100, rgSTATSTG, &amp;nFetched);

            for(ULONG i = 0; i &lt; nFetched; i++) {
                CStgInfo stgInfo;

                stgInfo.cbSizeLow = rgSTATSTG[i].cbSize.LowPart;
                stgInfo.cbSizeHigh = rgSTATSTG[i].cbSize.HighPart;

                wcsncpy(stgInfo.szName, 
                        rgSTATSTG[i].pwcsName,
                        255);

                CoTaskMemFree(rgSTATSTG[i].pwcsName);

                if (!m_rgRowData.Add(stgInfo))
                    return E_OUTOFMEMORY;
                cStgs++;
            }
            pEnumSTATSTG-&gt;Release();
        }

        if(pStg)
            pStg-&gt;Release();

        if (pcRowsAffected != NULL)
            *pcRowsAffected = cStgs;
        return S_OK;
    }
}</PRE>
<P>When some client code tries to open the OLE DB data provider, 
the call ends up inside this function. This function simply opens 
the structured storage file passed in as the command text and uses 
the standard structured storage enumerator to find the 
top-level substorages. Then the <I>Execute</I> function stores the name of 
the substorage and the size of the substorage in an array. The OLE 
DB provider uses this array to fulfill requests for the column data.
</UL>
<A NAME="853"><H2>Enhancing the Provider</H2></A><P>Of course, there's a lot you can do to beef up this OLE DB provider. 
We've barely scratched the surface of what you can do with a provider. When the 
ATL Object Wizard pumps out the default provider, it's a read-only provider. 
That is, users cannot change the contents of the data. In addition, the OLE DB 
templates provide support for locating rowsets and setting bookmarks. In 
most cases, enhancing the provider is a matter of tacking on implementations of 
COM interfaces provided by the OLE DB templates.
</BODY>
</HTML>



