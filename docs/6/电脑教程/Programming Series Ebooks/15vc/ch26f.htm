<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The EX26A Example -- A Data Object Clipboard</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="567"><H1><B>The EX26A Example&#151;A Data Object Clipboard</B></H1></A>
<P>This example uses the <I>CDib</I> class from EX11C. Here you'll be able to move and resize the DIB image with a tracker rectangle, and you'll be able to copy and paste the DIB to and from the clipboard using a COM data object. The example also includes functions for reading DIBs from and writing DIBs to BMP files.

<P>If you create such an example from scratch, use AppWizard without any ActiveX or Automation options and then add the following line in your StdAfx.h file:

<P><pre>
#include &lt;afxole.h&gt;
</pre>

<P>Add the following call at the start of the application's <I>InitInstance</I> function:

<P><pre>
AfxOleInit();
</pre>

<P>To prepare EX26A, open the \vcpp32\ex26a\ex26a.dsw workspace and then build the project. Run the application, and paste a bitmap into the rectangle by choosing Paste From on the Edit menu. You'll see an MDI application similar to the one shown in Figure 26-2.

<P><A HREF="javascript:fullSize('f26og02x.htm')"> <img src="f26og02.jpg" width=404 height=309 border=0 ALT = "Click to view at full size."> </A>

<P><!-- caption --><B>Figure 26-2.</B> <I>The EX26A program in operation.</I><!-- /caption -->

<A NAME="568"><H2><B>The <I>CMainFrame</I> Class</B></H2></A>
<P>This class contains the handlers <I>OnQueryNewPalette</I> and <I>OnPaletteChanged</I> for the WM_QUERYNEWPALETTE and WM_PALETTECHANGED messages, respectively. These handlers send a user-defined 
WM_VIEWPALETTECHANGED message to all the views, and then the handler calls <I>CDib::UsePalette</I> to realize the palette. The value of <I>wParam</I> tells the view whether it should realize the palette in background or foreground mode.

<A NAME="569"><H2><B>The <I>CEx26aDoc</I> Class</B></H2></A>
<P>This class is pretty straightforward. It contains an embedded <I>CDib</I> object, <I>m_dib</I>, plus a Clear All command handler. The overridden <I>DeleteContents</I> member function calls the 
<I>CDib::Empty</I> function.

<A NAME="570"><H2><B>The <I>CEx26aView</I> Class</B></H2></A>
<P>This class contains the clipboard function command handlers, the tracking code, the DIB drawing code, and the palette message handler. Figure 26-3 shows the header and implementation files with manually entered code in boldface.
<P>

<TABLE cellpadding=5 width="95%"><TR><TD>
<pre>
<B>EX26AVIEW.H</B>

#if !defined(AFX_EX26AVIEW_H__4F329B0F_5DF1_11D0_848F_00400526305B
_ _INCLUDED_)
#define AFX_EX26AVIEW_H__4F329B0F_5DF1_11D0_848F_00400526305B
_ _INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif// _MSC_VER &gt; 1000

#define WM_VIEWPALETTECHANGED  WM_USER + 5

class CEx26aView : public CScrollView
{
<B>    // for tracking
    CRectTracker m_tracker;
    CRect m_rectTracker; // logical coordinates
    CSize m_sizeTotal;   // document size</B>
protected: // create from serialization only
    CEx26aView();
    DECLARE_DYNCREATE(CEx26aView)

// Attributes
public:
    CEx26aDoc* GetDocument();
// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEx26aView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);
    virtual void OnInitialUpdate();
    protected:
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CEx26aView();

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:

// generated message map functions
protected:
    //{{AFX_MSG(CEx26aView)
    afx_msg void OnEditCopy();
    afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);]
    afx_msg void OnEditCopyto();
    afx_msg void OnEditCut();
    afx_msg void OnEditPaste();
    afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
    afx_msg void OnEditPastefrom();
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
    afx_msg LONG OnViewPaletteChanged(UINT wParam, LONG lParam);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
<B>private:
    BOOL DoPasteDib(COleDataObject* pDataObject);
    COleDataSource* SaveDib();</B>
};

#ifndef _DEBUG  // debug version in Ex26aView.cpp
inline CEx26aDoc* CEx26aView::GetDocument()
    { return (CEx26aDoc*)
m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
//  immediately before the previous line

#endif 
// !defined(AFX_EX26AVIEW_H__4F329B0F_5DF1_11D0_848F_00400526305B
__INCLUDED_)

<B>EX26AVIEW.CPP</B>
#include &quot;stdafx.h&quot;
#include &quot;ex26a.h&quot;

#include &quot;cdib.h&quot;
#include &quot;ex26aDoc.h&quot;
#include &quot;ex26aView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif

///////////////////////////////////////////////////////////////////////
// CEx26aView

IMPLEMENT_DYNCREATE(CEx26aView, CScrollView)

BEGIN_MESSAGE_MAP(CEx26aView, CScrollView)
    //{{AFX_MSG_MAP(CEx26aView)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
    ON_COMMAND(ID_EDIT_COPYTO, OnEditCopyto)
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
    ON_COMMAND(ID_EDIT_PASTEFROM, OnEditPastefrom)
    ON_WM_LBUTTONDOWN()
    ON_WM_SETCURSOR()
    ON_MESSAGE(WM_VIEWPALETTECHANGED, OnViewPaletteChanged)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPYTO, OnUpdateEditCopy)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCopy)
    ON_WM_SETFOCUS()
    //}}AFX_MSG_MAP
    // standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CScrollView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CScrollView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW, CScrollView::OnFilePrintPreview)
END_MESSAGE_MAP()

//////////////////////////////////////////////////////////////////////
// CEx26aView construction/destruction

CEx26aView::CEx26aView() <B>: m_sizeTotal(800, 1050), // 8-by-10.5 inches
                                                   //  when printed
    m_rectTracker(50, 50, 250, 250)</B>
{
}

CEx26aView::~CEx26aView()
{
}

BOOL CEx26aView::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CScrollView::PreCreateWindow(cs);
}

//////////////////////////////////////////////////////////////////////
// CEx26aView drawing

void CEx26aView::OnDraw(CDC* pDC)
{
<B>    CDib&amp; dib = GetDocument()-&gt;m_dib;
    m_tracker.m_rect = m_rectTracker;
    pDC-&gt;LPtoDP(m_tracker.m_rect); // tracker wants device coordinates
    m_tracker.Draw(pDC);
    dib.Draw(pDC, m_rectTracker.TopLeft(), 
m_rectTracker.Size());</B>
}

//////////////////////////////////////////////////////////////////////
// CEx26aView printing

BOOL CEx26aView::OnPreparePrinting(CPrintInfo* pInfo)
{
<B>    pInfo-&gt;SetMaxPage(1);</B>
    return DoPreparePrinting(pInfo);
}

void CEx26aView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add extra initialization before printing
}

void CEx26aView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add cleanup after printing
}

//////////////////////////////////////////////////////////////////////
// CEx26aView diagnostics

#ifdef _DEBUG
void CEx26aView::AssertValid() const
{
    CScrollView::AssertValid();
}

void CEx26aView::Dump(CDumpContext&amp; dc) const
{
    CScrollView::Dump(dc);
}

CEx26aDoc* CEx26aView::GetDocument() // nondebug version is inline
{
    ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CEx26aDoc)));
    return (CEx26aDoc*)m_pDocument;
}
#endif //_DEBUG

<B>//////////////////////////////////////////////////////////////
// helper functions used for clipboard and drag-drop 

BOOL CEx26aView::DoPasteDib(COleDataObject* pDataObject)
{
    // update command user interface should keep us out of 
    //  here if not CF_DIB
    if (!pDataObject-&gt;IsDataAvailable(CF_DIB)) {
        TRACE(&quot;CF_DIB format is unavailable\n&quot;);
        return FALSE;
    }
    CEx26aDoc* pDoc = GetDocument();
    // Seems to be MOVEABLE memory, so we must use GlobalLock!
    //  (hDib != lpDib) GetGlobalData copies the memory, so we can
    //  hang onto it until we delete the CDib.
    HGLOBAL hDib = pDataObject-&gt;GetGlobalData(CF_DIB);
    ASSERT(hDib != NULL);
    LPVOID lpDib = ::GlobalLock(hDib);
    ASSERT(lpDib != NULL);
    pDoc-&gt;m_dib.AttachMemory(lpDib, TRUE, hDib);
    pDoc-&gt;SetModifiedFlag();
    pDoc-&gt;UpdateAllViews(NULL);
    return TRUE;
}

COleDataSource* CEx26aView::SaveDib()
{
    CDib&amp; dib = GetDocument()-&gt;m_dib;
    if (dib.GetSizeImage() &gt; 0) {
        COleDataSource* pSource = new COleDataSource();
        int nHeaderSize = dib.GetSizeHeader();
        int nImageSize = dib.GetSizeImage();
        HGLOBAL hHeader = ::GlobalAlloc(GMEM_SHARE,
            nHeaderSize + nImageSize);
        LPVOID pHeader = ::GlobalLock(hHeader);
        ASSERT(pHeader != NULL);
        LPVOID pImage = (LPBYTE) pHeader + nHeaderSize;
        memcpy(pHeader, dib.m_lpBMIH, nHeaderSize); 
        memcpy(pImage, dib.m_lpImage, nImageSize);
        // Receiver is supposed to free the global memory 
        ::GlobalUnlock(hHeader);
        pSource-&gt;CacheGlobalData(CF_DIB, hHeader);
        return pSource;
    }
    return NULL;
}</B>


//////////////////////////////////////////////////////////////////////
// CEx26aView message handlers

void CEx26aView::OnEditCopy() 
{
<B>    COleDataSource* pSource = SaveDib();
    if (pSource) {
        pSource-&gt;SetClipboard(); // OLE deletes data source
    }</B>
}

void CEx26aView::OnUpdateEditCopy(CCmdUI* pCmdUI) 
{
<B>    // serves Copy, Cut, and Copy To
    CDib&amp; dib = GetDocument()-&gt;m_dib;
    pCmdUI-&gt;Enable(dib.GetSizeImage() &gt; 0L);</B>
}

void CEx26aView::OnEditCopyto()
{
<B>    CDib&amp; dib = GetDocument()-&gt;m_dib;
    CFileDialog dlg(FALSE, &quot;bmp&quot;, &quot;*.bmp&quot;);
    if (dlg.DoModal() != IDOK) return;

    BeginWaitCursor();
    dib.CopyToMapFile(dlg.GetPathName());
    EndWaitCursor();</B>
}

void CEx26aView::OnEditCut() 
{
<B>    OnEditCopy();
    GetDocument()-&gt;OnEditClearAll();</B>
}
void CEx26aView::OnEditPaste() 
{
<B>    CEx26aDoc* pDoc = GetDocument();
    COleDataObject dataObject;
    VERIFY(dataObject.AttachClipboard());
    DoPasteDib(&amp;dataObject);
    CClientDC dc(this);
    pDoc-&gt;m_dib.UsePalette(&amp;dc);
    pDoc-&gt;SetModifiedFlag();
    pDoc-&gt;UpdateAllViews(NULL);</B>
}

void CEx26aView::OnUpdateEditPaste(CCmdUI* pCmdUI) 
{
<B>    COleDataObject dataObject;
    BOOL bAvail = dataObject.AttachClipboard() &amp;&amp;
        dataObject.IsDataAvailable(CF_DIB);
    pCmdUI-&gt;Enable(bAvail);</B>
}

void CEx26aView::OnEditPastefrom() 
{
<B>    CEx26aDoc* pDoc = GetDocument();
    CFileDialog dlg(TRUE, &quot;bmp&quot;, &quot;*.bmp&quot;);
    if (dlg.DoModal() != IDOK) return;
    if (pDoc-&gt;m_dib.AttachMapFile(dlg.GetPathName(), TRUE)) { // share
        CClientDC dc(this);
        pDoc-&gt;m_dib.SetSystemPalette(&amp;dc);
        pDoc-&gt;m_dib.UsePalette(&amp;dc);
        pDoc-&gt;SetModifiedFlag();
        pDoc-&gt;UpdateAllViews(NULL);
    }</B>
}

void CEx26aView::OnPrepareDC(CDC* pDC, CPrintInfo* pInfo) 
{
<B>    // custom MM_LOENGLISH; positive y is down
    if (pDC-&gt;IsPrinting()) {
        int nHsize = pDC-&gt;GetDeviceCaps(HORZSIZE) * 1000 / 254;
        int nVsize = pDC-&gt;GetDeviceCaps(VERTSIZE) * 1000 / 254;
        pDC-&gt;SetMapMode(MM_ANISOTROPIC);
        pDC-&gt;SetWindowExt(nHsize, nVsize);
        pDC-&gt;SetViewportExt(pDC-&gt;GetDeviceCaps(HORZRES),
                            pDC-&gt;GetDeviceCaps(VERTRES));
    }
    else {
        CScrollView::OnPrepareDC(pDC, pInfo);
    }</B>
}
void CEx26aView::OnInitialUpdate() 
{
<B>    SetScrollSizes(MM_TEXT, m_sizeTotal);
    m_tracker.m_nStyle = CRectTracker::solidLine |
        CRectTracker::resizeOutside;
    CScrollView::OnInitialUpdate();</B>
}

void CEx26aView::OnLButtonDown(UINT nFlags, CPoint point) 
{
<B>    if (m_tracker.Track(this, point, FALSE, NULL)) {
        CClientDC dc(this);
        OnPrepareDC(&amp;dc);
        m_rectTracker = m_tracker.m_rect;
        dc.DPtoLP(m_rectTracker); // Update logical coordinates
        Invalidate();
    }</B>
}

BOOL CEx26aView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
<B>    if (m_tracker.SetCursor(pWnd, nHitTest)) {
        return TRUE;
    }
    else {
        return CScrollView::OnSetCursor(pWnd, nHitTest, message);
    }</B>
}

LONG CEx26aView::OnViewPaletteChanged(UINT wParam, LONG lParam) 
{
<B>    TRACE(&quot;CEx26aView::OnViewPaletteChanged, HWND = %x,  \ 
        code = %d\n&quot;, GetSafeHwnd(), wParam);
    CClientDC dc(this);
    GetDocument()-&gt;m_dib.UsePalette(&amp;dc, wParam);
    Invalidate();
    return 0;</B>
}

void CEx26aView::OnSetFocus(CWnd* pOldWnd) 
{
<B>    CScrollView::OnSetFocus(pOldWnd);
    AfxGetApp()-&gt;m_pMainWnd-&gt;SendMessage(WM_PALETTECHANGED, 
        (UINT) GetSafeHwnd());</B>
}
</pre>
</TD></TR></TABLE>

<B>Figure 26-3.</B> <I>The </I>CEx26aView<I> class listing.</I><P>


<P>Several interesting things happen in the view class. In the <I>DoPasteDib</I> helper, we can call 
<I>GetGlobalData</I> because we can attach the returned <I>HGLOBAL</I> variable to the document's 
<I>CDib</I> object. If we called <I>GetData</I>, we would have to copy the memory block ourselves. The Paste From and Copy To command handlers rely on the memory-mapped file support in the <I>CDib</I> class. The <I>OnPrepareDC</I> function creates a special printer-mapping mode that is just like MM_LOENGLISH except that positive <I>y</I> is down. One pixel on the display corresponds to 0.01 inch on the printer.

</BODY>
</HTML>



