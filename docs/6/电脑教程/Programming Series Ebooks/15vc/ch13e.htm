<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Command Processing</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="258"><H1>Command Processing</H1></A>
<P>As you saw in <A HREF="ch02a.htm">Chapter 2</A>, the application framework provides a sophisticated routing system for command messages. These messages originate from menu selections, keyboard accelerators, and toolbar and dialog button clicks. Command messages can also be sent by calls to the <I>CWnd::SendMessage</I> or <I>PostMessage</I> function. Each message is identified by a <I>#define</I> constant that is often assigned by a resource editor. The application framework has its own set of internal command message IDs, such as <I>ID_FILE_PRINT</I> and <I>ID_FILE_OPEN</I>. Your project's resource.h file contains IDs that are unique to your application.
<P>Most command messages originate in the application's frame window, and without the application framework in the picture, that's where you would put the message handlers. With command routing, however, you can handle a message almost anywhere. When the application framework sees a frame window command message, it starts looking for message handlers in one of the sequences listed here.<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>SDI Application</B></TD><TD VALIGN="TOP"><B>MDI Application</B></TD></TR>
<TR><TD VALIGN="TOP">View</TD><TD VALIGN="TOP">View</TD></TR>
<TR><TD VALIGN="TOP">Document</TD><TD VALIGN="TOP">Document</TD></TR>
<TR><TD VALIGN="TOP">SDI main frame window</TD><TD VALIGN="TOP">MDI child frame window</TD></TR>
<TR><TD VALIGN="TOP">Application</TD><TD VALIGN="TOP">MDI main frame window <BR>Application</TD></TR>
</TABLE>
<P>Most applications have a particular command handler in only one class, but suppose your one-view application has an identical handler in both the view class and the document class. Because the view is higher in the command route, 
only the view's command handler function will be called.
<P>What is needed to install a command handler function? The installation requirements are similar to those of the window message handlers you've already seen. You need the function itself, a corresponding message map entry, and the function prototype. Suppose you have a menu item named Zoom (with <I>IDM_ZOOM</I> as the associated ID) that you want your view class to handle. First you add the following code to your view implementation file:
<P>
<PRE>BEGIN_MESSAGE_MAP(CMyView, CView)
    ON_COMMAND(IDM_ZOOM, OnZoom)
END_MESSAGE_MAP()

void CMyView::OnZoom()
{
    // command message processing code
}
</PRE><P>Now add the following function prototype to the <I>CMyView</I> class header file (before the <I>DECLARE_MESSAGE_MAP</I> macro):<P>
<PRE>afx_msg void OnZoom();</PRE>
<P>Of course, ClassWizard automates the process of inserting command message handlers the same way it facilitates the insertion of window message handlers. You'll learn how this works in the next example, EX13A.
<A NAME="259"><H2>Command Message Handling in Derived Classes</H2></A>
<P>The command routing system is one dimension of command message handling. The class hierarchy is a second dimension. If you look at the source code for the MFC library classes, you'll see lots of <I>ON_COMMAND</I> message map entries. When you derive a class from one of these base classes&#151;for example, <I>CView</I>&#151;the derived class inherits all the <I>CView</I> message map functions, including the command message functions. To override one of the base class message map functions, you must add both a function and a message map entry to your derived class.
<A NAME="260"><H2>Update Command User Interface Handlers</H2></A><P>
You often need to change the appearance of a menu item to match the internal state of your application. If your application's Edit menu includes a Clear All item, for example, you might want to disable that item if there's nothing to clear. You've undoubtedly seen such grayed menu items in Windows-based applications, and you've probably also seen check marks next to menu items.
<P>With Win32 programming, it's difficult to keep menu items synchronized with the application's state. Every piece of code that changes the internal state must contain statements to update the menu. The MFC library takes a different approach by calling a special update command user interface (UI) handler function whenever a pop-up menu is first displayed. The handler function's 
argument is a <I>CCmdUI</I> object, which contains a pointer to the corresponding menu item. The handler function can then use this pointer to modify the menu item's appearance. Update command UI handlers apply only to items on pop-up menus, not to top-level menu items that are permanently displayed. You can't use an update command UI handler to disable a File menu item, for example.
<P>The update command UI coding requirements are similar to those for commands. You need the function itself, a special message map entry, and of course the prototype. The associated ID&#151;in this case, <I>IDM_ZOOM</I>&#151;is the same constant used for the command. Here is an example of the necessary additions to the view class code file:
<P><PRE>BEGIN_MESSAGE_MAP(CMyView, CView)
    ON_UPDATE_COMMAND_UI(IDM_ZOOM, OnUpdateZoom)
END_MESSAGE_MAP()

void CMyView::OnUpdateZoom(CCmdUI* pCmdUI)
{
    pCmdUI-&gt;SetCheck(m_bZoomed); // m_bZoomed is a class data member
}
</PRE><P>Here is the function prototype that you must add to the class header 
(before the <I>DECLARE_MESSAGE_MAP</I> macro):
<P><PRE>afx_msg void OnUpdateZoom(CCmdUI* pCmdUI);</PRE>
<P>Needless to say, ClassWizard automates the process of inserting update command UI handlers.
<A NAME="261"><H2>Commands That Originate in Dialogs</H2></A>
<P>Suppose you have a pop-up dialog with buttons, and you want a particular button to send a command message. Command IDs must be in the range 0x8000 to 0xDFFF, the same ID range that the resource editor uses for your menu items. If you assign an ID in this range to a dialog button, the button will generate a routable command. The application framework first routes this command to the main frame window because the frame window owns all pop-up dialogs. The command routing then proceeds normally; if your view has a handler for the button's command, that's where it will be handled. To ensure that the ID is in the range 0x8000 to 0xDFFF, you must use Visual C++'s symbol editor to enter the ID prior to assigning the ID to a button.
</BODY>
</HTML>



