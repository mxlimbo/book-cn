<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Storages and the IStorage Interface</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="582"><H1><B>Storages and the <I>IStorage</I> Interface</B></H1></A>
<P>If you have a storage object, you can manipulate it through the <I>IStorage</I> interface. Pay attention to these functions because Microsoft Foundation Class 
offers no support for storage access. Following are some of the important 
member functions and their significant parameters.

<A NAME="583"><h3><B>HRESULT Commit(&#133;);</B></h3></A>
<P>Commits all the changes to this storage and to all elements below it.

<A NAME="584"><h3><B>HRESULT CopyTo(&#133;, IStorage**<br><I>pStgDest</I>);</B></h3></A>
<P>Copies a storage, with its name and all its substorages and streams (recursively), to another existing storage. Elements are merged into the target storage, replacing elements with matching names.

<A NAME="585"><h3><B>HRESULT CreateStorage(const WCHAR*<br><I>pName</I>, &#133;, DWORD <I>mode</I>, &#133;, IStorage** <I>ppStg</I>);</B></h3></A>
<P>Creates a new substorage under this storage object.

<A NAME="586"><h3><B>HRESULT CreateStream(const WCHAR*<br><I>pName</I>, &#133;, DWORD <I>mode</I>, &#133;, IStream** <I>ppStream</I>);</B></h3></A>
<P>Creates a new stream under this storage object.

<A NAME="587"><h3><B>HRESULT DestroyElement(const WCHAR* <I>pName</I>);</B></h3></A>
<P>Destroys the named storage or stream that is under this storage object. A storage cannot destroy itself.

<A NAME="588"><h3><B>HRESULT EnumElements(&#133;, IEnumSTATSTG** <I>ppEnumStatstg</I>);</B></h3></A>
<P>Iterates through all the storages and streams under this storage object. The <I>IEnumSTATSTG</I> interface has <I>Next</I>, <I>Skip</I>, and <I>Clone</I> member functions, as do other COM enumerator interfaces.

<A NAME="589"><h3><B>HRESULT MoveElementTo(const WCHAR* <I>pName</I>,<br>IStorage* <I>pStgDest</I>, const LPWSTR* <I>pNewName</I>, DWORD <I>flags</I>);</B></h3></A>
<P>Moves an element from this storage object to another storage object.

<A NAME="590"><h3><B>HRESULT OpenStream(const WCHAR*<br><I>pName</I>, &#133;, DWORD <I>mode</I>, &#133;, IStorage** <I>ppStg</I>);</B></h3></A>
<P>Opens an existing stream object, designated by name, under this storage object.

<A NAME="591"><h3><B>HRESULT OpenStorage(const WCHAR*<br><I>pName</I>, &#133;, DWORD <I>mode</I>, &#133;, IStorage** <I>ppStg</I>);</B></h3></A>
<P>Opens an existing substorage object, designated by name, under this storage object.

<A NAME="592"><h3><B>DWORD Release(void);</B></h3></A>
<P>Decrements the reference count. If the storage is a root storage representing a disk file, <I>Release</I> closes the file when the reference count goes to 0.

<A NAME="593"><h3><B>HRESULT RenameElement(const<br>WCHAR* <I>pOldName</I>, const WCHAR* <I>pNewName</I>);</B></h3></A>
<P>Assigns a new name to an existing storage or stream under this storage object.

<A NAME="594"><h3><B>HRESULT Revert(void);</B></h3></A>
<P>Abandons a transaction, leaving the compound file unchanged.

<A NAME="595"><h3><B>HRESULT SetClass(CLSID&amp; <I>clsid</I>);</B></h3></A>
<P>Inserts a 128-bit class identifier into this storage object. This ID can then be retrieved with the <I>Stat</I> function.

<A NAME="596"><h3><B>HRESULT Stat(STATSTG* <I>pStatstg</I></B>, <B>DWORD</B> <B><I>flag</I>);</B></h3></A>
<P>Fills in a <I>STATSTG</I> structure with useful information about the storage object, including its name and class ID<I>.</I>

<A NAME="597"><H2><B>Getting an <I>IStorage</I> Pointer</B></H2></A>
<P>Where do you get the first <I>IStorage</I> pointer? COM gives you the global function <I>StgCreateDocfile</I> to create a new structured storage file on disk and the function <I>StgOpenStorage</I> to open an existing file. Both of these set a pointer to the file's <U>root</U> <U>storage</U>. Here's some code that opens an existing storage file named MyStore.stg and then creates a new substorage:

<P><pre>
IStorage* pStgRoot;
IStorage* pSubStg;

if (::StgCreateDocfile(L&quot;MyStore.stg&quot;,
    STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
    0, &amp;pStgRoot) == S_OK) {
    if (pStgRoot-&gt;CreateStorage(L&quot;MySubstorageName&quot;,
        STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
        0, 0, &amp;pSubStg) == S_OK) {
        // Do something with pSubStg
        pSubStg-&gt;Release();
    }
    pStgRoot-&gt;Release();
}
</pre>

<A NAME="598"><H2><B>Freeing <I>STATSTG</I> Memory</B></H2></A>
<P>When you call <I>IStorage::Stat</I> with a <I>STATFLAG_DEFAULT</I> value for the flag parameter, COM allocates memory for the element name. You must free this memory in a manner compatible with its allocation. COM has its own allocation system that uses an <U>allocator</U> <U>object</U> with an <I>IMalloc</I> interface. You must get an <I>IMalloc</I> pointer from COM, call <I>IMalloc::Free</I> for the string, and then release the allocator. The code below illustrates this.

<P>If you want just the element size and type and not the name, you can call <I>Stat</I> with the <I>STATFLAG_NONAME</I> flag. In that case, no memory is allocated and you don't have to free it. This seems like an irritating detail, but if you don't follow the recipe, you'll have a memory leak.

<A NAME="599"><H2><B>Enumerating the Elements in a Storage Object</B></H2></A>
<P>Following is some code that iterates through all the elements under a storage object, differentiating between substorages and streams. The elements are retrieved in a seemingly random sequence, independent of the sequence in which they were created; however, I've found that streams are always retrieved first. The <I>IEnumSTATSTG::Next</I> element fills in a <I>STATSTG</I> structure that tells you whether the element is a stream or a storage object.

<P><pre>
IEnumSTATSTG* pEnum;
IMalloc* pMalloc;
STATSTG statstg;
extern IStorage* pStg;  // maybe from OpenStorage
::CoGetMalloc(MEMCTX_TASK, &amp;pMalloc); // assumes AfxOleInit called
VERIFY(pStg-&gt;EnumElements(0, NULL, 0, &amp;pEnum) == S_OK)
while (pEnum-&gt;Next(1, &amp;statstg, NULL) == NOERROR) {
    if (statstg.type == STGTY_STORAGE) {
        if (pStg-&gt;OpenStorage(statstg.pwcsName, NULL,
            STGM_READ | STGM_SHARE_EXCLUSIVE,
            NULL, 0, &amp;pSubStg) == S_OK) {
            // Do something with the substorage
        }
        else if (statstg.type == STGTY_STREAM) {
            // Process the stream
        }
        pMalloc-&gt;Free(statstg.pwcsName); // avoids memory leaks
    }
    pMalloc-&gt;Release();
}
</pre>

<A NAME="600"><H2><B>Sharing Storages Among Processes</B></H2></A>
<P>If you pass an <I>IStorage</I> pointer to another process, the marshaling code ensures that the other process can access the corresponding storage element and everything below it. This is a convenient way of sharing part of a file. One of the standard data object media types of the <I>TYMED</I> enumeration is <I>TYMED_ISTORAGE</I>, and this means you can pass an <I>IStorage</I> pointer on the clipboard or through a drag-and-drop operation.

</BODY>
</HTML>



