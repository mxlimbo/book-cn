<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Container-Component Interactions</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="644"><H1><B>Container-Component Interactions</B></H1></A>
<P>Analyzing the component and the container separately won't help you to understand fully how they work. You must watch them working together to understand their interactions. Let's reveal the complexity one step at a time. Consider first that you have a container EXE and a component EXE, and the container must manage the component by means of OLE interfaces.

<P>Look back to the space simulation example in <A HREF="ch24a.htm">Chapter 24</A>. The client program called <I>CoGetClassObject</I> and <I>IClassFactory::CreateInstance</I> to load the spaceship component and to create a spaceship object, and then it called <I>QueryInterface</I> to get <I>IMotion</I> and 
<I>IVisual</I> pointers. An embedding container program works the same way that the space simulation client works. It starts the component program based on the component's class ID, and the component 
program constructs an object. Only the interfaces are different.

<P>Figure 28-2 shows a container program looking at a component. You've already seen all the interfaces except one&#151;<I>IOleObject</I>.

<P><A HREF="javascript:fullSize('f28og02x.htm')"> <img src="f28og02.jpg" width=404 height=317 border=0 ALT = "Click to view at full size."> </A>

<P><!-- caption --><B>Figure 28-2.</B> <I>A container program's view of the component.</I><!-- /caption -->

<A NAME="645"><H2><B>Using the Component's <I>IOleObject</I> Interface</B></H2></A>
<P>Loading a component is not the same as activating it. Loading merely starts a process, which then sits waiting for further instructions. If the container gets an <I>IOleObject</I> pointer to the component object, it can call the <I>DoVerb</I> member function with a verb parameter such as 
<I>OLEIVERB_SHOW</I>. The component should then show its main window and act like a Windows-based 
program. If you look at the <I>IOleObject::DoVerb</I> description, you'll see an <I>IOleClientSite*</I> parameter. We'll consider client sites shortly, but for now you can simply set the parameter to <I>NULL</I> and most components will work okay.

<P>Another important <I>IOleObject</I> function, <I>Close</I>, is useful at this stage. As you might expect, the container calls <I>Close</I> when it wants to terminate the component program. If the component process is currently servicing one embedded object (as is the case with MFC components), the process exits.

<A NAME="646"><H2><B>Loading and Saving the Component's Native Data&#151;Compound Documents</B></H2></A>
<P>Figure 28-2 demonstrates that the container manages a storage through an <I>IStorage</I> pointer and that the component implements <I>IPersistStorage</I>. That means that the component can load and save its native data when the container calls the <I>Load</I> and <I>Save</I> functions of <I>IPersistStorage</I>. You've seen the <I>IStorage</I> and <I>IPersistStorage</I> interfaces used in <A HREF="ch27a.htm">Chapter 27</A>, but this time the container is going to save the component's class ID in the storage. The container can read the class ID from the storage and use it to start the 
component program prior to calling <I>IPersistStorage::Load.</I>

<P>Actually, the storage is very important to the embedded object. Just as a virus needs to live in a cell, an embedded object needs to live in a storage. The storage must always be available because the object is constantly loading and saving itself and reading and writing temporary data.

<P>A <U>compound</U> <U>document</U> appears at the bottom of Figure 28-2. The container manages the whole file, but the embedded components are responsible for the storages inside it. There's one main storage for each embedded object, and the container doesn't know or care what's inside those storages.

<A NAME="647"><H2><B>Clipboard Data Transfers</B></H2></A>
<P>If you've run any OLE container programs, including Microsoft Excel, you've noticed that you can copy and paste whole embedded objects. There's a special data object format, <I>CF_EMBEDDEDOBJECT</I>, for embedded objects. If you put an <I>IDataObject</I> pointer on the clipboard and that data object 
contains the <I>CF_EMBEDDEDOBJECT</I> format (and the companion <I>CF</I>_<I>OBJECTDESCRIPTOR</I> format), another program can load the proper component program and reconstruct the object.

<P>There's actually less here than meets the eye. The only thing inside the <I>CF_EMBEDDEDOBJECT</I> format is an <I>IStorage</I> pointer. The clipboard copy program verifies that <I>IPersistStorage::Save</I> has been called to save the embedded object's data in the storage, and then it passes off the <I>IStorage</I> pointer in a data object. The clipboard paste program gets the class ID from the source storage, loads the component program, and then calls <I>IPersistStorage::Load</I> to load the data from the source storage.

<P>The data objects for the clipboard are generated as needed by the container program. The component's <I>IDataObject</I> interface isn't used for transferring the objects' native data.

<A NAME="648"><H2><B>Getting the Component's Metafile</B></H2></A>
<P>You already know that a component program is supposed to draw in a metafile and that a container is supposed to play it. But how does the component deliver the metafile? That's what the <I>IDataObject</I> interface, shown in Figure 28-2, is for. The container calls 
<I>IDataObject::GetData</I>, asking for a <I>CF_METAFILEPICT</I> format. But wait a minute. The container is supposed to get the metafile even if the component program isn't running. So now you're ready for the next complexity level.

<A NAME="649"><H2><B>The Role of the In-Process Handler</B></H2></A>
<P>If the component program is running, it's in a separate process. Sometimes it's not running at all. In either case, the OLE32 DLL is linked into the container's process. This DLL is known as the 
<U>object</U> <U>handler</U>.

<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
It's possible for an EXE component to have its own custom handler DLL, but most components use the &quot;default&quot; OLE32 DLL.</blockquote></div>

<P>Figure 28-3 shows the new picture. The handler communicates with the component over the RPC link, marshaling all interface function calls. But the handler does more than act as the component's proxy for marshaling; it maintains a <U>cache</U> that contains the component object's metafile. The handler saves and loads the cache to and from storage, and it can fill the cache by calling the component's <I>IDataObject::GetData </I>function.

<P>When the container wants to draw the metafile, it doesn't do the drawing itself; instead, it asks the handler to draw the metafile by calling the handler's <I>IViewObject2::Draw</I> function. The handler tries to satisfy as many container requests as it can without bothering the component program. If the handler needs to call a component function, it takes care of loading the component program if it is not already loaded.

<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
The <I>IViewObject2</I> interface is an example of OLE's design evolution. Someone decided to add a new function&#151;in this case, <I>GetExtent</I>&#151;to the <I>IViewObject</I> interface. <I>IViewObject2</I> is derived from <I>IViewObject</I> and contains the new function. All new components should implement the new interface and should return an <I>IViewObject2</I> pointer when 
<I>QueryInterface</I> is called for either <I>IID_IViewObject</I> or <I>IID_IViewObject2</I>. This is easy with the MFC library because you write two interface map entries that link to the same nested class.</blockquote></div>

<P><A HREF="javascript:fullSize('f28og03x.htm')"> <img src="f28og03.jpg" width=404 height=246 border=0 ALT = "Click to view at full size."> </A>

<P><!-- caption --><B>Figure 28-3.</B> <I>The in-process handler and the component.</I><!-- /caption -->

<P>Figure 28-3 shows both object data and metafile data in the object's storage. When the container calls the handler's <I>IPersistStorage::Save</I> function, the handler writes the cache (containing the metafile) to the storage and then calls the component's <I>IPersistStorage::Save</I> function, which writes the object's native data to the same storage. The reverse happens when the object is loaded.

</BODY>
</HTML>



