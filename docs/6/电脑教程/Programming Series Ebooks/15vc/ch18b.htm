<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The MDI Application</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="392"><H1>The MDI Application</H1></A><P>Before you look at the MFC library code for MDI applications, you should be familiar with the operation of Microsoft Windows MDI programs. Take a close look at Visual C++ now. It's an MDI application whose &quot;multiple documents&quot; are program source code files. Visual C++ is not the most typical MDI application, however, because it collects its documents into projects. It's better to examine Microsoft Word or, better yet, a real MFC library MDI application&#151;the kind that AppWizard generates.
<A NAME="393"><H2>A Typical MDI Application, MFC Style</H2></A><P>This chapter's example, EX18A, is an MDI version of EX17A. Run the EX17A example to see an illustration of the SDI version after the user has selected a file. Now look at the MDI equivalent, as shown in Figure 18-1.
<P><A HREF="javascript:fullSize('f18og01x.htm')"> <img src="f18og01.jpg" width=404 height=302 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 18-1.</B> <I>The EX18A application with two files open and the Window menu shown.</I>
<!-- /caption -->
<P>The user has two separate document files open, each in a separate MDI child window, but only one child window is active&#151;the lower window, which lies on top of the other child window. The application has only one menu and one toolbar, and all commands are routed to the active child window. The main window's title bar reflects the name of the active child window's document file.
<P>The child window's minimize box allows the user to reduce the child window to an icon in the main window. The application's Window menu (shown in Figure 18-1) lets the user control the presentation through the following items.
<P><TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>Menu Item</B></TD><TD VALIGN="TOP"><B>Action</B></TD></TR>
<TR><TD VALIGN="TOP">New Window</TD><TD VALIGN="TOP">Opens as an additional child window for the selected document</TD></TR>
<TR><TD VALIGN="TOP">Cascade</TD><TD VALIGN="TOP">Arranges the existing windows in an overlapped pattern</TD></TR>
<TR><TD VALIGN="TOP">Tile</TD><TD VALIGN="TOP">Arranges the existing windows in a nonoverlapped, tiled pattern</TD></TR>
<TR><TD VALIGN="TOP">Arrange Icons</TD><TD VALIGN="TOP">Arranges minimized windows in the frame window</TD></TR>
<TR><TD VALIGN="TOP">(document names)</TD><TD VALIGN="TOP"> Selects the corresponding child window and brings it to the top</TD></TR>
</TABLE>
<P>If the user closes both child windows (and opens the File menu), the application looks like Figure 18-2.
<P><A HREF="javascript:fullSize('f18og02x.htm')"> <img src="f18og02.jpg" width=404 height=300 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 18-2.</B> <I>EX18A with no child windows.</I>
<!-- /caption -->
<P>The File menu is different, most toolbar buttons are disabled, and the window caption does not show a filename. The only choices the user has are to start a new document or to open an existing document from disk.
<P>Figure 18-3 shows the application when it first starts up and a new document is created. The single child window has been maximized.
<P><A HREF="javascript:fullSize('f18og03x.htm')"> <img src="f18og03.jpg" width=404 height=300 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 18-3.</B> <I>EX18A with initial child window.</I>
<!-- /caption -->
<P>The single, empty child window has the default document name Ex18a1. This name is based on the Doc Type Name (Ex18a) that you selected in the Advanced Options dialog after clicking the Advanced button in Step 4 of AppWizard. The first new file is Ex18a1, the second is Ex18a2, and so forth. The user normally chooses a different name when saving the document.
<P>An MFC library MDI application, like many commercial MDI applications, starts up with a new, empty document. (Visual C++ is an exception.) If you want your application to start up with a blank frame, you can modify the argument to the <I>ProcessShellCommand</I> call in the application class file, as shown in example EX18A.
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<B>For Win32 Programmers</B>
<P>Starting with version 3.0, Windows directly supports MDI applications. The MFC library builds on this Windows support to create an MDI environment that parallels the SDI environment. In a Win32 MDI application, a main application frame window contains the menu and a single <U>client</U> <U>window</U>. The client window manages various child windows that correspond to documents. The MDI client window has its own preregistered window class (not to be confused with a C++ class) with a procedure that handles special messages such as 
WM_MDICASCADE and WM_MDITILE. An MDI child window procedure is similar to the window procedure for an SDI main window.
<P>In the MFC library, the <I>CMDIFrameWnd</I> class encapsulates the functions of both the main frame window and the MDI client window. This class has message handlers for all the Windows MDI messages and thus can manage its child windows, which are represented by objects of class <I>CMDIChildWnd</I>.
</BLOCKQUOTE></DIV>
<P>
<A NAME="394"><H2>The MDI Application Object</H2></A>
<P>You're probably wondering how an MDI application works and what code makes it different from an SDI application. Actually, the startup sequences are pretty much the same. An application object of a class derived from class 
<I>CWinApp</I> has an overridden <I>InitInstance</I> member function. This 
<I>InitInstance</I> function is somewhat different from the SDI <I>InitInstance </I>function, starting with the call to <I>AddDocTemplate</I>.
<A NAME="395"><H2>The MDI Document Template Class</H2></A>
<P>The MDI template construction call in <I>InitInstance</I> looks like this:
<P><PRE>CMultiDocTemplate* pDocTemplate;
pDocTemplate = new CMultiDocTemplate(
    IDR_EX18ATYPE,
    RUNTIME_CLASS(CStudentDoc),
    RUNTIME_CLASS(CChildFrame), // custom MDI child frame
    RUNTIME_CLASS(CStudentView));
AddDocTemplate(pDocTemplate);</PRE>
<P>Unlike the SDI application you saw in <A HREF="ch17a.htm">Chapter 17</A>, an MDI application can use multiple document types and allows the simultaneous existence of <U>more</U> <U>than</U> <U>one</U> <U>document</U> <U>object</U>. This is the essence of the MDI application.
<P>The single <I>AddDocTemplate</I> call shown above permits the MDI application to support multiple child windows, each connected to a document object and a view object. It's also possible to have several child windows (and 
corresponding view objects) connected to the same document object. In this chapter, we'll start with only one view class and one document class. You'll see multiple view classes and multiple document classes in <A HREF="ch20a.htm">Chapter 20</A>.<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
When your application is running, the document template object maintains a list of active document objects that were created from the template. The 
<I>CMultiDocTemplate</I> member functions <I>GetFirstDocPosition</I> and <I>GetNextDoc</I> allow you to iterate through the list. Use <I>CDocument::GetDocTemplate</I> to navigate from a document to its template.
</BLOCKQUOTE></DIV>
<P>
<A NAME="396"><H2>The MDI Frame Window and the MDI Child Window</H2></A>
<P>The SDI examples had only one frame window class and only one frame window object. For SDI applications, AppWizard generated a class named <I>CMainFrame</I>, which was derived from the class <I>CFrameWnd</I>. An MDI application has two frame window classes and many frame objects, as shown in the table below. The MDI frame-view window relationship is shown in Figure 18-4.
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>Base Class</B></TD><TD VALIGN="TOP"><B>AppWizard-Generated Class</B></TD><TD VALIGN="TOP"><B>Number of Objects</B></TD><TD VALIGN="TOP"><B>Menu and Control Bars</B></TD><TD VALIGN="TOP"><B>Contains a View</B></TD><TD VALIGN="TOP"><B>Object Constructed</B></TD></TR>
<TR><TD VALIGN="TOP"><I>CMDIFrameWnd</I></TD><TD VALIGN="TOP"><I>CMainFrame</I></TD><TD VALIGN="TOP">1 only</TD><TD VALIGN="TOP">Yes</TD><TD VALIGN="TOP">No</TD><TD VALIGN="TOP">In 
application class's <I>InitInstance</I> function</TD></TR>
<TR><TD VALIGN="TOP"><I>CMDIChildWnd</I></TD><TD VALIGN="TOP"><I>CChildFrame</I></TD><TD VALIGN="TOP">1 per child window</TD><TD VALIGN="TOP"> No</TD><TD VALIGN="TOP">Yes</TD><TD VALIGN="TOP">By application framework when a new child window is opened</TD></TR>

</TABLE>
<P><A HREF="javascript:fullSize('f18if04x.htm')"> <img src="f18if04.jpg" width=404 height=231 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 18-4.</B> <I>The MDI frame-view window relationship.</I>
<!-- /caption -->
<P>In an SDI application, the <I>CMainFrame</I> object frames the application 
<U>and</U> contains the view object. In an MDI application, the two roles are 
separated. Now the <I>CMainFrame</I> object is explicitly constructed in 

<I>InitInstance</I>, and the <I>CChildFrame</I> object contains the view. AppWizard generates the following code:
<P><PRE>CMainFrame* pMainFrame = new CMainFrame;
if (!pMainFrame-&gt;LoadFrame(IDR_MAINFRAME))
    return FALSE;
m_pMainWnd = pMainFrame;</PRE>
<P><I>(code calls </I>ProcessShellCommand<I> to create child frame)</I>
<P><PRE>pMainFrame-&gt;ShowWindow(m_nCmdShow);
pMainFrame-&gt;UpdateWindow();</PRE>
<P>The application framework can create the <I>CChildFrame</I> objects dynamically because the <I>CChildFrame </I>runtime class pointer is passed to the <I>CMultiDocTemplate</I> constructor.
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
The MDI <I>InitInstance</I> function sets the <I>CWinApp</I> data member <I>m_pMainWnd</I> to point to the application's main frame window. This means you can access <I>m_pMainWnd</I> through the global <I>AfxGetApp</I> function anytime you need to get your application's main frame window.
</BLOCKQUOTE></DIV>
<A NAME="397"><H2>The Main Frame and Document Template Resources</H2></A>
<P>An MDI application (EX18A, as described later in this chapter) has two separate string and menu resources, identified by the <I>IDR_MAINFRAME</I> and <I>IDR_EX18ATYPE </I>constants. The first resource set goes with the empty 
main frame window; the second set goes with the occupied main frame window. Here are the two string resources with substrings broken out:
<P><PRE>IDR_MAINFRAME
    &quot;ex18a&quot;                     // application window caption

IDR_EX18ATYPE
    &quot;\n&quot;                        // (not used)
    &quot;Ex18a\n&quot;                   // root for default document name
    &quot;Ex18a\n&quot;                   // document type name
    &quot;Ex18a Files (*.18a)\n&quot;     // document type description and filter
    &quot;.18a\n&quot;                    // extension for documents of this type
    &quot;Ex18a.Document\n&quot;          // Registry file type ID
    &quot;Ex18a Document&quot;            // Registry file type description</PRE>
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
The resource compiler won't accept the string concatenations as shown above. If you examine the ex18a.rc file, you'll see the substrings combined in one long string.
</BLOCKQUOTE></DIV>
<P>The application window caption comes from the <I>IDR_MAINFRAME</I> string. When a document is open, the document filename is appended. The last two substrings in the <I>IDR_EX18ATYPE </I>string support embedded launch and drag and drop.
<H2>Creating an Empty Document&#151;The <I>CWinApp::OnFileNew </I>Function</H2>
<P>The MDI <I>InitInstance</I> function calls <I>OnFileNew</I> (through 
<I>ProcessShellCommand</I>), as did the SDI <I>InitInstance</I> function. This time, however, the main frame window has already been created. <I>OnFileNew</I>, through a call to the <I>CMultiDocTemplate</I> function 
<I>OpenDocumentFile</I>, now does the following:
<OL>
<P><LI>Constructs a document object but does not attempt to read data from disk.
<P><LI>Constructs a child frame window object (of class <I>CChildFrame</I>). Also creates the child frame window but does not show it. In the main frame window, the <I>IDR_EX18ATYPE </I>menu replaces the<I> IDR_MAINFRAME </I>menu. <I>IDR_EX18ATYPE </I>also identifies an icon resource that is used when the child window is minimized within the frame.
<P><LI>Constructs a view object. Also creates the view window but does not show it.
<P><LI>Establishes connections among the document, the main frame, and view <U>objects</U>. Do not confuse these object connections with the <U>class</U> associations established by the call to <I>AddDocTemplate</I>.
<P><LI>Calls the virtual <I>OnNewDocument</I> member function for the document object.
<P><LI>Calls the virtual <I>OnInitialUpdate</I> member function for the view object.
<P><LI>Calls the virtual <I>ActivateFrame</I> member function for the child 
frame object to show the frame window and the view window.
</OL>

<P>The <I>OnFileNew</I> function is also called in response to the File New menu command. In an MDI application, <I>OnFileNew</I> performs exactly the same steps as it does when called from <I>InitInstance</I>.
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
Some functions listed above are not called directly by <I>OpenDocumentFile</I> but are called indirectly through the application framework.
</BLOCKQUOTE></DIV>
<A NAME="398"><H2>Creating an Additional View for an Existing Document</H2></A>
<P>If you choose the New Window command from the Window menu, the application framework opens a new child window that is linked to the currently selected document. The associated <I>CMDIFrameWnd</I> function, <I>OnWindowNew</I>, does 
the following:
<OL>
<P><LI>Constructs a child frame object (of class <I>CChildFrame</I>). Also creates the child frame window but does not show it.
<P><LI>Constructs a view object. Also creates the view window but does not show it.
<P><LI>Establishes connections between the new view object and the existing document and main frame objects.
<P><LI>Calls the virtual <I>OnInitialUpdate</I> member function for the view object.
<P><LI>Calls the virtual <I>ActivateFrame</I> member function for the child frame object to show the frame window and the view window.
</OL>
<A NAME="399"><H2>Loading and Storing Documents</H2></A>
<P>In MDI applications, documents are loaded and stored the same way as in SDI applications but with two important differences: a new document object is constructed each time a document file is loaded from disk, and the document object is destroyed when the child window is closed. Don't worry about clearing a document's contents before loading&#151;but override the <I>CDocument::DeleteContents</I> function anyway to make the class portable to the SDI environment.
<A NAME="400"><H2>Multiple Document Templates</H2></A><P>An MDI application can support multiple document templates through multiple calls to the <I>AddDocTemplate</I> function. Each template can specify a different combination of document, view, and MDI child frame classes. When the user chooses New from the File menu of an application with multiple templates, the application framework displays a list box that allows the user to select a 
template by name as specified in the string resource (document type substring). 
Multiple <I>AddDocTemplate</I> calls are not supported in SDI applications because the document, view, and frame objects are constructed once for the life of the application.
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
When your application is running, the application object keeps a list of active document template objects. The <I>CWinApp</I> member functions 
<I>GetFirstDocTemplatePosition</I> and <I>GetNextDocTemplate</I> allow you to iterate through the list of templates. These functions, together with the <I>CDocTemplate</I> member functions <I>GetFirstDocPosition</I> and <I>GetNextDoc</I>, allow you to access all of the application's document objects.
</BLOCKQUOTE></DIV>
<P>If you don't want the template list box, you can edit the File menu to add a New menu item for each document type. Code the command message handlers as shown below, using the document type substring from each template.
<P><PRE>void CMyApp::OnFileNewStudent()
{
    OpenNewDocument(&quot;Studnt&quot;);
}
void CMyApp::OnFileNewTeacher()
{
    OpenNewDocument(&quot;Teachr&quot;);
}</PRE>
<P>Then add the <I>OpenNewDocument</I> helper function as follows:
<P><PRE>BOOL CMyApp::OpenNewDocument(const CString&amp; strTarget)
{
    CString strDocName;
    CDocTemplate* pSelectedTemplate;
    POSITION pos = GetFirstDocTemplatePosition();
    while (pos != NULL) {
        pSelectedTemplate = (CDocTemplate*) GetNextDocTemplate(pos);
        ASSERT(pSelectedTemplate != NULL);
        ASSERT(pSelectedTemplate-&gt;IsKindOf(
            RUNTIME_CLASS(CDocTemplate)));
        pSelectedTemplate-&gt;GetDocString(strDocName,
            CDocTemplate::docName);
        if (strDocName == strTarget) { // from template's
                                       //  string resource
            pSelectedTemplate-&gt;OpenDocumentFile(NULL);
            return TRUE;
        }
    }
    return FALSE;
}</PRE>
<A NAME="401"><H2>Explorer Launch and Drag and Drop</H2></A>
<P>When you double-click on a document icon for an MDI application in Windows Explorer, the application launches only if it was not running already; otherwise, a new child window opens in the running application for the document you selected. The <I>EnableShellOpen</I> call in the application class <I>InitInstance</I> function is necessary for this to work. Drag and drop works much the same way in an MDI application as it does in an SDI application. If you drag a file from Windows Explorer to your MDI main frame window, the program opens a new child frame (with associated document and view) just as if you'd chosen the File Open command. As with SDI applications, you must use the AppWizard Step 4 Advanced button to specify the filename extension.
</BODY>
</HTML>



