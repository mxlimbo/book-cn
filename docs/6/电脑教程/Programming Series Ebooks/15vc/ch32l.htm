<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The EX32A Example</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="805"><H1><B>The EX32A Example</B></H1></A>
<p>Now we'll put everything together and build another working 
program&#151;an MDI application that connects to any DAO data source. The application dynamically displays tables in scrolling view windows, and it allows the user to type in the SQL QUERY statement, which is stored in the document along with data source and table information. AppWizard generates the usual MDI main frame, document, application, and view classes, and we change the view class base to <I>CRowView</I> and add the DAO-specific code. Figure 32-2 shows the EX32A program in operation.

<p>The document's File menu includes the following commands:

<blockquote>
<p>DAO Open MDB
<p>DAO Open ISAM
<p>DAO Open ODBC
</blockquote>

<p>The user must choose one of these commands after opening a document. As you will see, the code for opening the database is different depending on the data source type.

<p>You can learn a lot about this application by looking at the three-view window in Figure 32-2. The two view windows in the upper part of the main window are tied to the same document, and the lower view window is tied to another document. The dialog bar shows the SQL statement associated with the active view window.

<P><A HREF="javascript:fullSize('f32og02x.htm')"> <img src="f32og02.jpg" width=404 height=292 border=0 ALT = "Click to view at full size."> </A>

<P><!-- caption --><B>Figure 32-2.</B> <I>The EX32A program in operation.</I><!-- /caption -->

<p>The EX32A example includes source code listings and resource requirements. Here is a table of the files and classes.

<p><table cellpadding=5 width="95%">
<tr><td valign="top"><b>Header File</b></td>
<td valign="top"><b>Source Code File</b></td>
<td valign="top"><b>Class</b></td>
<td valign="top"><b>Description</b></td></tr>
<tr><td valign="top">Ex32a.h</td>
<td valign="top">Ex32a.cpp</td>
<td valign="top"><I>CEx32aApp</I></td>
<td valign="top">Main application</td></tr>
<tr><td valign="top">MainFrm.h</td>
<td valign="top">MainFrm.cpp</td>
<td valign="top"><I>CMainFrame</I></td>
<td valign="top">MDI main frame</td></tr>
<tr><td valign="top">ChildFrm.h</td>
<td valign="top">ChildFrm.cpp</td>
<td valign="top"><I>CChildFrame</I></td>
<td valign="top">MDI child frame</td></tr>
<tr><td valign="top">Ex32aDoc.h</td>
<td valign="top">Ex32aDoc.cpp</td>
<td valign="top"><I>CEx32aDoc</I></td>
<td valign="top">EX32A document</td></tr>
<tr><td valign="top">Ex32aView.h</td>
<td valign="top">Ex32aView.cpp</td>
<td valign="top"><I>CEx32aView</I></td>
<td valign="top">Scrolling database view class</td></tr>
<tr><td valign="top">Rowview.h</td>
<td valign="top">Rowview.cpp</td>
<td valign="top"><I>CRowView</I></td>
<td valign="top">Row view base class</td></tr>
<tr><td valign="top">Tablesel.h</td>
<td valign="top">Tablesel.cpp</td>
<td valign="top"><I>CTableSelect</I></td>
<td valign="top">Table selection dialog class</td></tr>
<tr><td valign="top">IsamSelect.h</td>
<td valign="top">IsamSelect.cpp</td>
<td valign="top"><I>CIsamSelect</I></td>
<td valign="top">ISAM-type data source selection dialog class</td></tr>
<tr><td valign="top">StdAfx.h</td>
<td valign="top">StdAfx.cpp</td>
<td valign="top"></td>
<td valign="top">Precompiled headers</td></tr>
</table>

<p>Now we'll go through the application's classes one at a time, excluding <I>CRowView</I>. You'll see the important data members and the principal member functions.

<A NAME="806"><H2><B><I>CEx32aApp</I></B></H2></A>
<p>The application class is the unmodified output from AppWizard. Nothing special here.

<A NAME="807"><H2><B><I>CMainFrame</I> and <I>CChildFrame</I></B></H2></A>
<p>These classes are the standard output from AppWizard except for the addition of the dialog bar created in the <I>CMainFrame::OnCreate</I> member function.

<A NAME="808"><H2><B><I>CEx32aDoc</I></B></H2></A>
<p>The document class manages the database connections and recordsets. Each document object can support one main recordset attached to one data source. A document object can have several views attached. Data sources (represented by <I>CDaoDatabase</I> objects) are not shared among document objects; each 
document has its own.

<A NAME="809"><H3><B>Data Members</B></H3></A>
<p>The important <I>CEx32aDoc </I>data members are listed in the following table.

<p><table cellpadding=5 width="95%">
<tr><td valign="top"><b>Data Member</b></td>
<td valign="top"><b>Description</b></td></tr>
<tr><td valign="top"><I>m_pRecordset</I></td>
<td valign="top">Pointer to the document's recordset object</td></tr>
<tr><td valign="top"><I>m_database</I></td>
<td valign="top">Document's embedded <I>CDaoDatabase</I> object</td></tr>
<tr><td valign="top"><I>m_strDatabase</I></td>
<td valign="top">Database pathname (MDB file)</td></tr>
<tr><td valign="top"><I>m_strConnect</I></td>
<td valign="top">ODBC connection string or ISAM connection string</td></tr>
<tr><td valign="top"><I>m_strQuery</I></td>
<td valign="top">Entire SQL SELECT statement</td></tr>
<tr><td valign="top"><I>m_bConnected</I></td>
<td valign="top">Flag that is <I>TRUE</I> when the document is connected to a recordset</td></tr>
<tr><td valign="top"><I>m_nFields</I></td>
<td valign="top">Number of fields (columns) in the recordset</td></tr>
<tr><td valign="top"><I>m_nRowCount</I></td>
<td valign="top">Number of records (rows) in the recordset</td></tr>
<tr><td valign="top"><I>m_nDatabaseType</I></td>
<td valign="top"><I>enum {UNK, MDB, ISAM, ODBC}</I></td></tr>
</table>

<A NAME="810"><H3><B><I>OnOpenDocument</I></B></H3></A>
<p>This overridden <I>CDocument</I> function is called when the user loads a 
document from disk. The document contains the name of the database and the query string, so the program can open the database and run the query upon loading.

<P><pre>
BOOL CEx32aDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
    if (!CDocument::OnOpenDocument(lpszPathName))
        return FALSE;
    PutQuery();
    switch (m_nDatabaseType) {
    case UNK:
        break;
    case MDB:
        DaoOpenMdb();
        break;
    case ISAM:
        DaoOpenIsam();
        break;
    case ODBC:
        DaoOpenOdbc();
        break;
    }
    return TRUE;
}
</pre>

<A NAME="811"><H3><B><I>OnCloseDocument</I></B></H3></A>
<p>This overridden <I>CDocument</I> function closes the database if one is connected:

<P><pre>void CEx32aDoc::OnCloseDocument() 
{
    m_strQuery.Empty();
    PutQuery();
    if (m_bConnected) {
        delete m_pRecordset; // Destructor calls Close
        m_database.Close();
        m_bConnected = FALSE;
        m_pRecordset = NULL;
        m_nRowCount = 0;
    }
    CDocument::OnCloseDocument();
}
</pre>

<A NAME="812"><H3><B><I>OnFileDaoOpenOdbc</I> and <I>DaoOpenOdbc</I></B></H3></A>
<p>These functions are called in response to the user choosing the DAO Open ODBC command from the File menu. <I>DaoOpenOdbc</I>, which is also called by 
<I>OnOpenDocument</I>, calls <I>CDaoDatabase::Open</I> with the connect 
parameter string. The string <I>&quot;ODBC;&quot;</I> causes the ODBC data source selection dialog to be displayed. Notice the use of the <I>try</I>/<I>catch</I> block to detect SQL processing errors.

<P><pre>
void CEx32aDoc::OnFileDaoOpenOdbc()
{
    m_strConnect.Empty();
    m_strQuery.Empty();
    DaoOpenOdbc();
}

void CEx32aDoc::DaoOpenOdbc()
{
    // can't open ODBC using Access driver
    if (m_strConnect.IsEmpty()) {
        m_strConnect = &quot;ODBC;&quot;;
    }
    BeginWaitCursor();
    try {
        // nonexclusive, read-only
        m_database.Open(&quot;&quot;, FALSE, TRUE, m_strConnect);
    }
    catch (CDaoException* e) {
        ::DaoErrorMsg(e);
        EndWaitCursor();
        e-&gt;Delete();
        return;
    }
    m_strConnect = m_database.GetConnect();
    TRACE(&quot;database name = %s, connect = %s\n&quot;,
         (const char*) m_strDatabase,
         (const char*) m_strConnect);
    OpenRecordset();
    m_nDatabaseType = ODBC;
    EndWaitCursor();
}
</pre>

<A NAME="813"><H3><B><I>OnFileDaoOpenIsam</I> and <I>DaoOpenIsam</I></B></H3></A>
<p>These functions are called in response to the user choosing the DAO Open ISAM command from the File menu. <I>DaoOpenIsam</I>, which is also called by 
<I>OnOpenDocument</I>, gets a directory name from the user (through the 
<I>CIsamSelect</I> class) and then calls <I>CDaoDatabase::Open</I> with the connect parameter string. The <I>CIsamSelect::m_strIsam</I> string specifies the type of file. Example strings are <I>&quot;dBASE III&quot;</I>, <I>&quot;FoxPro 2.6&quot;</I>, and <I>&quot;Excel 8.0&quot;</I>.

<P><pre>
void CEx32aDoc::OnFileDaoOpenIsam() 
{
    m_strConnect.Empty();
    m_strQuery.Empty();
    DaoOpenIsam();
}

void CEx32aDoc::DaoOpenIsam() 
{
    BeginWaitCursor();
    if (m_strConnect.IsEmpty()) {
        CIsamSelect isamDlg;
        if (isamDlg.DoModal() != IDOK) {
            return;
        }
        m_strConnect = isamDlg.m_strIsam + &quot;;DATABASE=&quot; +
            isamDlg.m_strDirectory;
        TRACE(&quot;m_strConnect = %s\n&quot;, (const char*) m_strConnect);
    }
    try {
        // nonexclusive, read-only
        m_database.Open(&quot;&quot;, FALSE, TRUE, m_strConnect);
    }
    catch(CDaoException* e) {
        ::DaoErrorMsg(e);
        EndWaitCursor();
        e-&gt;Delete();
        return;
    }
    m_strConnect = m_database.GetConnect();
    TRACE(&quot;database name = %s, connect = %s\n&quot;,
         (const char*) m_strDatabase, (const char*) m_strConnect);
    OpenRecordset();
    m_nDatabaseType = ISAM;
    EndWaitCursor();
}
</pre>

<A NAME="814"><H3><B><I>OnFileDaoOpenMdb</I> and <I>DaoOpenMdb</I></B></H3></A>
<p>These functions are called in response to the user choosing the DAO Open MDB command from the File menu. <I>DaoOpenMdb</I>, which is also called by <I>OnOpenDocument</I>, uses the MFC <I>CFileDialog</I> class to get an MDB file pathname from the user. Compare the <I>CDaoDatabase::Open </I>call with the calls in the two preceding functions. Notice that the MDB pathname is passed as the first parameter.

<P><pre>
void CEx32aDoc::OnFileDaoOpenMdb()
{
    m_strDatabase.Empty();
    m_strQuery.Empty();
    DaoOpenMdb();
}

void CEx32aDoc::DaoOpenMdb()
{
    if (m_strDatabase.IsEmpty()) {
        CFileDialog dlg(TRUE, &quot;.mdb&quot;, &quot;*.mdb&quot;);
        if (dlg.DoModal() == IDCANCEL) return;
        m_strDatabase = dlg.GetPathName();
    }
    BeginWaitCursor();
    try {
        // nonexclusive, read-only
        m_database.Open(m_strDatabase, FALSE, TRUE);
    }
    catch (CDaoException* e) {
        ::DaoErrorMsg(e);
        EndWaitCursor();
        e-&gt;Delete();
        return;
    }
    m_strDatabase = m_database.GetName();
    TRACE(&quot;database name = %s, connect = %s\n&quot;,
         (const char*) m_strDatabase, (const char*) m_strConnect);
    OpenRecordset();
    m_nDatabaseType = MDB;
    EndWaitCursor();
}
</pre>

<A NAME="815"><H3><B><I>OnFileDaoDisconnect</I></B></H3></A>
<p>This function closes the DAO database, enabling the document to be saved.

<P><pre>
void CEx32aDoc::OnFileDaoDisconnect() 
{
    if (m_bConnected) {
        delete m_pRecordset; // Destructor calls Close
        m_database.Close();
        m_bConnected = FALSE;
        m_pRecordset = NULL;
        m_nRowCount = 0;
        UpdateAllViews(NULL);
    }
}
</pre>

<A NAME="816"><H3><B><I>OpenRecordset</I></B></H3></A>
<p>This helper function is called by <I>DaoOpenOdbc</I>, <I>DaoOpenIsam</I>, and <I>DaoOpenMdb</I>. The <I>CTableSelect</I> class allows the user to select a table name, which is used to construct a SELECT statement. Calls to 
<I>CDaoRecordset::MoveLast</I> and <I>CDaoRecordset::GetAbsolutePosition</I> set the record count for ODBC, ISAM, and MDB data sources.

<P><pre>
void CEx32aDoc::OpenRecordset()
{
    GetQuery();
    if (m_strQuery.IsEmpty()) {
        CTableSelect tableDlg(&amp;m_database);
        if (tableDlg.DoModal() != IDOK) {
            m_database.Close();  // escape route
            return;
        }
        m_strQuery.Format(&quot;select * from [%s]&quot;, tableDlg.m_strSelection);
        PutQuery();
    }

    m_pRecordset = new CDaoRecordset(&amp;m_database);
    try {    
        m_pRecordset-&gt;Open(dbOpenDynaset, m_strQuery, dbReadOnly);
    }
    catch (CDaoException* e) {
        ::DaoErrorMsg(e);
        UpdateAllViews(NULL);
        m_bConnected = FALSE;
        e-&gt;Delete();
        return;
    }
    if (!m_pRecordset-&gt;IsBOF()) {
        // might be expensive for a really big table
        // View adjusts its m_nRowCount if you supply a big value here
        m_pRecordset-&gt;MoveLast(); // to validate record count
    }
    m_nRowCount = m_pRecordset-&gt;GetAbsolutePosition() + 2;
    TRACE(&quot;m_nRowCount = %d\n&quot;, m_nRowCount);
    GetFieldSpecs();
    UpdateAllViews(NULL);
    m_bConnected = TRUE;
}
</pre>

<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
The MFC <I>CDaoRecordset</I> class has <I>m_strFilter</I> and <I>m_strSort</I> data members, as does the ODBC <I>CRecordset </I>class. You can't use these strings, however, if your recordset doesn't have bound fields; you must construct the entire SELECT statement as shown above.</blockquote></div>

<A NAME="817"><H3><B><I>OnRequery</I></B></H3></A>
<p>This message handler is called in response to the user clicking the Requery 
button on the dialog bar. This message handler reads the query string value and 
regenerates the recordset. Note that the <I>CDaoRecordset::Requery</I> function doesn't handle an updated SELECT statement, so we close and reopen the recordset instead.

<P><pre>
void CEx32aDoc::OnRequery()
{ 
    GetQuery();
    // Requery won't work because we're changing the SQL statement
    BeginWaitCursor();
    if(m_pRecordset-&gt;IsOpen()) {
        m_pRecordset-&gt;Close();
    }
    try {    
        m_pRecordset-&gt;Open(dbOpenDynaset, m_strQuery, dbReadOnly);
    }
    catch (CDaoException* e) {
        ::DaoErrorMsg(e);
        m_nRowCount = 0;
        UpdateAllViews(NULL);
        EndWaitCursor();
        e-&gt;Delete();
        return;
    }
    if (!m_pRecordset-&gt;IsBOF()) {
        m_pRecordset-&gt;MoveLast(); // to validate record count
    }
    m_nRowCount = m_pRecordset-&gt;GetAbsolutePosition() + 2;
    TRACE(&quot;m_nRowCount = %d\n&quot;, m_nRowCount);
    GetFieldSpecs();
    UpdateAllViews(NULL); 
    EndWaitCursor();
}
</pre>

<A NAME="818"><H3><B><I>PutQuery</I> and <I>GetQuery</I></B></H3></A>
<p>These utility functions move the document's query string to and from the edit control on the dialog bar.

<A NAME="819"><H3><B><I>Serialize</I></B></H3></A>
<p>The <I>Serialize</I> function reads and writes the <I>m_strConnect</I>, <I>m_strDatabase</I>, and <I>m_strQuery</I> data members.

<A NAME="820"><H2><B><I>CEx32aView</I></B></H2></A>
<p>This class is derived from <I>CRowView</I> and implements the virtual functions.

<A NAME="821"><H3><B>Data Members</B></H3></A>
<p>The <I>CEx32aView</I> class uses the integer variable <I>m_nSelectedRow</I> to track the currently selected row. The recordset pointer is held in <I>m_pSet</I>.

<A NAME="822"><H3><B><I>OnUpdate</I></B></H3></A>
<p>This virtual <I>CView</I> function is called through the application framework when the view is created and when the document's contents change in response to a database open or requery event. If several views are active for a given document, all views reflect the current query but each can maintain its own current row and scroll position. <I>OnUpdate</I> also sets the value of the 
<I>m_pSet</I> data member. This can't be done in <I>OnInitialUpdate</I> because the recordset is not open at that point.

<A NAME="823"><H3><B><I>GetRowWidthHeight</I>, <I>GetActiveRow</I>, <br><I>ChangeSelectionNextRow</I>, and <I>ChangeSelectionToRow</I></B></H3></A>
<p>These functions are implementations of the <I>CRowView</I> class pure virtual functions. They take care of drawing a specified query result row, and they track the current selection.

<A NAME="824"><H3><B><I>GetRowCount</I></B></H3></A>
<p>This virtual function, which is called from <I>CRowView</I>, simply returns the record count value stored in the document.

<A NAME="825"><H3><B><I>OnDrawRow</I> and <I>DrawDataRow</I></B></H3></A>
<p>The <I>OnDrawRow</I> virtual function is called from <I>CRowView</I> member functions to perform the actual work of drawing a designated row. <I>OnDrawRow</I> reads the recordset's current row and then calls the<I> CDaoRecordset::Move</I> function to position the cursor and read the data. The 
<I>try</I>/<I>catch</I> block detects catastrophic errors resulting from unreadable data. The <I>DrawDataRow</I> helper function steps through the columns and prints the values. Notice that <I>OnDrawRow</I> displays &quot;**RECORD DELETED**&quot; when it encounters a record that has been deleted by another user since the dynaset was first created. <I>OnDrawRow</I> and <I>DrawDataRow</I> are shown here:

<P><pre>
void CEx32aView::OnDrawRow(CDC* pDC, int nRow, int y, BOOL bSelected)
{
    int x = 0;
    int i;
    CEx32aDoc* pDoc = GetDocument();

    if (m_pSet == NULL) return;
    
    if (nRow == 0) {    // title row
        for (i = 0; i &lt; pDoc-&gt;m_nFields; i++) {
            pDC-&gt;TextOut(x, y, pDoc-&gt;m_arrayFieldName[i]);
            x += pDoc-&gt;m_arrayFieldSize[i] * m_nCharWidth;
        }    
    }
    else {
        try {
            m_pSet-&gt;SetAbsolutePosition(nRow - 1);
            // adjust for title row
            // SetAbsolutePosition doesn't throw exception until AFTER  
            //  end of set
            if (m_pSet-&gt;GetAbsolutePosition() == (nRow - 1)) {
                DrawDataRow(pDC, y);
            }
        }
        catch (CDaoException* e) {
            // might be a time delay before delete is seen in this program
            if (e-&gt;m_pErrorInfo-&gt;m_lErrorCode == 3167) {
                pDC-&gt;TextOut(0, y, &quot;**RECORD DELETED**&quot;);
            }
            else {
                m_pSet-&gt;MoveLast(); // in case m_nRowCount is too big
                pDoc-&gt;m_nRowCount = m_pSet-&gt;GetAbsolutePosition() + 2;
            }
            e-&gt;Delete();
        }
    }
}

void CEx32aView::DrawDataRow(CDC* pDC, int y)
{
    int x = 0;
    CString strTime;

    COleVariant var;
    CString str;
    CEx32aDoc* pDoc = GetDocument();
    for (int i = 0; i &lt; pDoc-&gt;m_nFields; i++) {
        var = m_pSet-&gt;GetFieldValue(i);
        switch (var.vt) {
            case VT_BSTR:
                str = (LPCSTR) var.bstrVal; // narrow characters in DAO
                break;



            case VT_I2:
                str.Format(&quot;%d&quot;, (int) var.iVal);
                break;
            case VT_I4:
                str.Format(&quot;%d&quot;, var.lVal);
                break;
            case VT_R4:
                str.Format(&quot;%10.2f&quot;, (double) var.fltVal);
                break;
            case VT_R8:
                str.Format(&quot;%10.2f&quot;, var.dblVal);
                break;
            case VT_CY:
                str = COleCurrency(var).Format();
                break;
            case VT_DATE:
                str = COleDateTime(var).Format();
                break;
            case VT_BOOL:
                str = (var.boolVal == 0) ? &quot;FALSE&quot; : &quot;TRUE&quot;;
                break;
            case VT_NULL:
                str =  &quot;----&quot;;
                break;
            default:
                str.Format(&quot;Unk type %d\n&quot;, var.vt);
                TRACE(&quot;Unknown type %d\n&quot;, var.vt);
            }
        pDC-&gt;TextOut(x, y, str);
        x += pDoc-&gt;m_arrayFieldSize[i] * m_nCharWidth;
    }
}
</pre>

<A NAME="826"><H3><B><I>OnInitialUpdate</I> and <I>OnTimer</I></B></H3></A>
<p>Because we're working with a dynaset, we want to show database changes made by other programs. The timer handler calls <I>CWnd::Invalidate</I>, which causes all records in the client area to be refreshed, as shown here:

<P><pre>void CEx32aView::OnInitialUpdate() 
{
    CRowView::OnInitialUpdate(); 
}

void CEx32aView::OnTimer(UINT nIDEvent) 
{
    Invalidate(); // Update view from database
}
</pre>
 
<A NAME="827"><H2><B><I>CTableSelect</I></B></H2></A>
<p>This is a ClassWizard-generated dialog class that contains a list box used 
for selecting the table. For the student registration database, the dialog looks like the one shown below.

<P><img src="g32og02.gif" width=185 height=175 border="0">

<A NAME="828"><H3><B>Data Members</B></H3></A>
<p>The <I>CTableSelect</I> data members are as follows.

<p><table cellpadding=5 width="95%">
<tr><td valign="top"><b>Data Member</b></td>
<td valign="top"><b>Description</b></td></tr>
<tr><td valign="top"><I>m_pDatabase</I></td>
<td valign="top">Pointer to the recordset's <I>CDaoDatabase</I> object</td></tr>
<tr><td valign="top"><I>m_strSelection</I></td>
<td valign="top">ClassWizard-generated variable that corresponds to the list-box selection</td></tr>
</table>
<A NAME="829"><H3><B>Constructor</B></H3></A>
<p>The constructor takes a database pointer parameter, which it uses to set 
the <I>m_pDatabase</I> data member, as shown here:

<P><pre>
CTableSelect::CTableSelect(CDaoDatabase* pDatabase,
    CWnd* pParent /*=NULL*/)
    : CDialog(CTableSelect::IDD, pParent)
{
    //{{AFX_DATA_INIT(CTableSelect)
    m_strSelection = &quot;&quot;;
    //}}AFX_DATA_INIT
    m_pDatabase = pDatabase;
}
</pre>

<A NAME="830"><H3><B><I>OnInitDialog</I></B></H3></A>
<p>This self-contained function creates, opens, and reads the data source's list of tables and puts the table name strings in the dialog's list box, as shown here:

<P><pre>
BOOL CTableSelect::OnInitDialog()
{
    CListBox* pLB = (CListBox*) GetDlgItem(IDC_LIST1);
    int nTables = m_pDatabase-&gt;GetTableDefCount();
    TRACE(&quot;CTableSelect::OnInitDialog, nTables = %d\n&quot;, nTables);
    CDaoTableDefInfo tdi;
    for (int n = 0; n &lt; nTables; n++) {
        m_pDatabase-&gt;GetTableDefInfo(n, tdi);
        TRACE(&quot;table name = %s\n&quot;, (const char*) tdi.m_strName);
        if (tdi.m_strName.Left(4) != &quot;MSys&quot;) {
            pLB-&gt;AddString(tdi.m_strName);
        }
    }
    return CDialog::OnInitDialog();
}
</pre>

<A NAME="831"><H3><B><I>OnDblclkList1</I></B></H3></A>
<p>It's handy for the user to choose a list-box entry with a double click. This 
function is mapped to the appropriate list-box notification message, as shown here:

<P><pre>void CTableSelect::OnDblclkList1()
{
    OnOK();  // Double-clicking on list-box item exits dialog
}
</pre>

<A NAME="832"><H2><B><I>CIsamSelect</I></B></H2></A>
<p>This ClassWizard-generated dialog class contains a list box and an edit 
control used for selecting the ISAM-type data source. The user must type the 
directory for the files, as shown here.

<P><img src="g32og03.gif" width=243 height=231 border="0">

<A NAME="833"><H3><B>Data Members</B></H3></A>
<p>The<I> CIsamSelect</I> class data members are as follows.

<p><table cellpadding=5 width="95%">
<tr><td valign="top"><b>Data Member</b></td>
<td valign="top"><b>Definition</b></td></tr>
<tr><td valign="top"><I>m_strIsam</I></td>
<td valign="top">ClassWizard-generated variable that corresponds to the list-box selection</td></tr>
<tr><td valign="top"><I>m_strDirectory</I></td>
<td valign="top">ClassWizard-generated variable that corresponds to the edit control contents</td></tr>
</table>

<A NAME="834"><H3><B><I>OnInitDialog</I></B></H3></A>
<p>This function sets the initial values of the list box, which are the options 
from the &quot;Connect Property&quot; topic in Books Online, as shown here:

<P><pre>
BOOL CIsamSelect::OnInitDialog() 
{
    CListBox* pLB = (CListBox*) GetDlgItem(IDC_LIST1);
    pLB-&gt;AddString(&quot;dBASE III&quot;);
    pLB-&gt;AddString(&quot;dBASE IV&quot;);
    pLB-&gt;AddString(&quot;dBASE 5&quot;);
    pLB-&gt;AddString(&quot;Paradox 3.x&quot;);
    pLB-&gt;AddString(&quot;Paradox 4.x&quot;);
    pLB-&gt;AddString(&quot;Paradox 5.x&quot;);
    pLB-&gt;AddString(&quot;Btrieve&quot;);
    pLB-&gt;AddString(&quot;FoxPro 2.0&quot;);
    pLB-&gt;AddString(&quot;FoxPro 2.5&quot;);
    pLB-&gt;AddString(&quot;FoxPro 2.6&quot;);
    pLB-&gt;AddString(&quot;Excel 3.0&quot;);
    pLB-&gt;AddString(&quot;Excel 4.0&quot;);
    pLB-&gt;AddString(&quot;Excel 5.0&quot;);
    pLB-&gt;AddString(&quot;Excel 7.0&quot;);
    pLB-&gt;AddString(&quot;Text&quot;);
    CDialog::OnInitDialog();
    
    return TRUE;  // Return TRUE unless you set the focus to a control.
                  // EXCEPTION: OCX Property Pages should return FALSE.
}
</pre>

</BODY>
</HTML>



