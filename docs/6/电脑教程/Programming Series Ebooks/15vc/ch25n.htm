<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Automation Examples</TITLE>
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>

</HEAD>
<BODY>
<A NAME="540"><H1><B>Automation Examples</B></H1></A>
<P>The remainder of this chapter presents five sample programs. The first three programs are Automation components&#151;an EXE component with no user interface, a DLL component, and a multi-instance SDI EXE component. Each of these component programs comes with a Microsoft Excel driver 
workbook file. The fourth sample program is an MFC Automation client program that drives the three components and also runs Excel using the <I>COleDispatchDriver</I> class. The last sample is a client program that uses the C++ <I>#import</I> directive instead of the MFC <I>COleDispatchDriver</I> class.

<A NAME="541"><H2><B>The EX25A Automation Component<br>EXE Example&#151;No User Interface</B></H2></A>
<P>The Visual C++ Autoclik example is a good demonstration of an MDI framework application with the document object as the Automation component. (To find the Autoclik example, look in the online documentation under Visual C++ Documentation/Samples/MFC Samples/Tutorial Samples.) The EX25A 
example is different from the Autoclik example because EX25A has no user interface. There is one Automation-aware class, and in the first version of the program, a single process supports the construction of multiple Automation component objects. In the second version, a new process starts up each time an Automation client creates an object.

<P>The EX25A example represents a typical use of Automation. A C++ component implements financial transactions. VBA programmers can write User-interface-intensive applications that rely on the audit rules imposed by the Automation component. A production component program would probably use a database, but EX25A is simpler. It implements a bank account with two methods, <I>Deposit</I> and <I>Withdrawal</I>, and one read-only property, Balance. Obviously, <I>Withdrawal</I> can't permit withdrawals that make the balance negative. You can use Excel to control the component, as shown in Figure 25-3.

<P><A HREF="javascript:fullSize('f25og03x.htm')"> <img src="f25og03.jpg" width=404 height=181 border=0 ALT = "Click to view at full size."> </A>


<P><!-- caption --><B>Figure 25-3.</B> <I>This Excel workbook is controlling the EX25A component.</I><!-- /caption -->



<P>Here are the steps for creating the program from scratch:

<ol>
<P><LI><B>Run AppWizard to create the EX25A project in the \vcpp32\ex25a directory.</B> Select the Dialog Based option (Step 1). Deselect <U>all</U> options in Step 2, and accept the remaining default settings. This is the simplest application that AppWizard can generate.
<P><LI><B>Eliminate the dialog class from the project.</B> Using Windows Explorer or the command-line prompt, delete the files ex25aDlg.cpp and ex25aDlg.h. Remove ex25aDlg.cpp and ex25aDlg.h from the project by deleting them from the project's Workspace window (FileView). Edit ex25a.cpp. Remove the dialog <I>#include</I>, and remove all dialog-related code from the <I>InitInstance</I> function. In ResourceView, delete the <I>IDD_EX25A_DIALOG</I> dialog resource template.
<P><LI><B>Add code to enable Automation.</B> Add this line in StdAfx.h:

<p><pre>
#include &lt;afxdisp.h&gt;
</pre>

<P>Edit the <I>InitInstance</I> function (in Ex25a.cpp) to look like this:
<p><pre>
BOOL CEx25aApp::InitInstance()
{
    <B>AfxOleInit();
    if(RunEmbedded() || RunAutomated()) {
        // component started by COM
        COleTemplateServer::RegisterAll();
        return TRUE;
    }
    // Component is being run directly by the user
    COleObjectFactory::UpdateRegistryAll();</B>
   <B> AfxMessageBox(&quot;Bank server is registered&quot;);</B>
    return FALSE;
}
</pre>

<P><LI><B>Use ClassWizard to add a new class, <I>CBank</I>, as shown here.</B>


<P><img src="g25og03.gif" width=404 height=366 border="0">
<P>Be sure to select the Createable By Type ID option.
</ol>

<ol start=5>
<P><LI><B>Use ClassWizard to add two methods and a property.</B> Click on the Automation tab, and then add a Withdrawal method, as shown here.


<P><img src="g25og04.gif" width=357 height=344 border="0">

<P>The <I>dAmount</I> parameter is the amount to be withdrawn, and the return value is the actual amount withdrawn. If you try to withdraw $100 from an account that contains $60, the amount withdrawn is $60.

<P>Add a similar <I>Deposit </I>method that returns <I>void</I>, and then add the Balance property, as shown here.
<P><img src="g25og05x.gif" width=434 height=344 border=0> 

<P>We could have chosen direct access to a component data member, but then we wouldn't have read-only access. We choose Get/Set Methods so that we can code the <I>SetBalance</I> function to do nothing.
</ol>

<ol start=6>
<P><LI><B>Add a public <I>m_dBalance</I> data member of type <I>double</I> to the <I>CBank</I> class.</B> Because we've chosen the Get/Set Methods option for the Balance property, ClassWizard doesn't generate a data member for us. You should declare <I>m_dBalance</I> in the Bank.h file and initialize <I>m_dBalance</I> to 0.0 in the <I>CBank</I> constructor located in the bank.cpp file.
<P><LI><B>Edit the generated method and property functions.</B> Add the following boldface code:

<p><pre>
double CBank::Withdrawal(double dAmount) 
{<B>
        if (dAmount &lt; 0.0) {
        return 0.0;
        }
        if (dAmount &lt;= m_dBalance) {
            m_dBalance -= dAmount;</B>
            return dAmount<B>
        }
        double dTemp = m_dBalance;
        m_dBalance = 0.0;
        return dTemp;</B>
}

void CBank::Deposit(double dAmount) 
{<B>
        if (dAmount &lt; 0.0) {
            return;
        }
        m_dBalance += dAmount;</B>
}

double CBank::GetBalance( ) 
{<B>
        return m_dBalance;</B>
}

void CBank::SetBalance(double newValue) 
{<B>
        TRACE(&quot;Sorry, Dave, I can't do that!\n&quot;);</B>
}
</pre>

<P><LI><B>Build the EX25A program; run it once to register the component.</b>
<P><LI><B>Set up five Excel macros in a new workbook file, ex25a.xls.</B> Add the following code:

<p><pre>
Dim Bank As Object
Sub LoadBank()
    Set Bank = CreateObject(&quot;Ex25a.Bank&quot;)
End Sub

Sub UnloadBank()
    Set Bank = Nothing
End Sub

Sub DoDeposit()
    Range(&quot;D4&quot;).Select
    Bank.Deposit (ActiveCell.Value)
End Sub

Sub DoWithdrawal()
    Range(&quot;E4&quot;).Select
    Dim Amt
    Amt = Bank.Withdrawal(ActiveCell.Value)
    Range(&quot;E5&quot;).Select
    ActiveCell.Value = Amt
End Sub

Sub DoInquiry()
    Dim Amt
    Amt = Bank.Balance()
    Range(&quot;G4&quot;).Select
    ActiveCell.Value = Amt
End Sub
</pre>

<P><LI><B>Arrange an Excel worksheet as shown in Figure 25-3.</B> Attach the macros to the pushbuttons (by right-clicking the pushbuttons).
<P><LI><B>Test the EX25A bank component.</B> Click the Load Bank Program button, and then enter a deposit value in cell D4 and click the Deposit button. Click the Balance Inquiry button, and watch the balance appear in cell G4. Enter a withdrawal value in cell E4, and click the Withdrawal button. To see the balance, click the Balance Inquiry button.
</ol>

<DIV CLASS=note>

<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
Sometimes you need to click the buttons twice. The first click switches the focus to the worksheet, and the second click runs the macro. The hourglass pointer tells you the macro is working.</blockquote></div>

<P>What's happening in this program? Look closely at the <I>CEx25aApp::InitInstance</I> function. When you run the program directly from Windows, it displays a message box and then quits, but not before it updates the Registry. The<I> COleObjectFactory::UpdateRegistryAll</I> function hunts for global class 
factory objects, and the <I>CBank</I> class's <I>IMPLEMENT_OLECREATE</I> macro invocation defines such an object. (The <I>IMPLEMENT_OLECREATE</I> line was generated because you checked ClassWizard's Createable By Type ID check box when you added the <I>CBank</I> class.) The unique class ID and the program ID, <I>EX25A.BANK</I>, are added to the Registry.

<P>When Excel now calls <I>CreateObject</I>, COM loads the EX25A program, which contains the global factory for <I>CBank</I> objects; COM then calls the factory object's <I>CreateInstance</I> function to construct the <I>CBank</I> object and return an <I>IDispatch</I> pointer. Here's the <I>CBank</I> class declaration that ClassWizard generated in the bank.h file, with unnecessary detail (and the 
method and property functions you've already seen) omitted:

<P><pre>
class CBank : public CCmdTarget
{
    DECLARE_DYNCREATE(CBank)
public:
    double m_dBalance;
    CBank();   // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CBank)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual ~CBank();

    // Generated message map functions
    //{{AFX_MSG(CBank)
        // NOTE - the ClassWizard will add and remove member
        //  functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    DECLARE_OLECREATE(CBank)

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CBank)
    afx_msg double GetBalance();
    afx_msg void SetBalance(double newValue);
    afx_msg double Withdrawal(double dAmount);
    afx_msg void Deposit(double dAmount);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()
};
</pre>

<P>Here is the code automatically generated by ClassWizard in bank.cpp:

<P><pre>
IMPLEMENT_DYNCREATE(CBank, CCmdTarget)

CBank::CBank()
{
    EnableAutomation();
    
    // To keep the application running as long as an OLE automation 
    //  object is active, the constructor calls AfxOleLockApp.
    
    AfxOleLockApp();
}

CBank::~CBank()
{
    // To terminate the application when all objects created with
    //  OLE automation, the destructor calls AfxOleUnlockApp.
    
    AfxOleUnlockApp();
}

void CBank::OnFinalRelease()
{
    // When the last reference for an automation object is released,
    //  OnFinalRelease is called. This implementation deletes the 
    //  object. Add additional cleanup required for your object
    //  before deleting it from memory.

    CCmdTarget::OnFinalRelease
}

BEGIN_MESSAGE_MAP(CBank, CCmdTarget)
    //{{AFX_MSG_MAP(CBank)
        // NOTE - the ClassWizard will add and remove 
        //  mapping macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CBank, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CBank)
    DISP_PROPERTY_EX(CBank, &quot;Balance&quot;, GetBalance, SetBalance, VT_R8)
    DISP_FUNCTION(CBank, &quot;Withdrawal&quot;, Withdrawal, VT_R8, VTS_R8)
    DISP_FUNCTION(CBank, &quot;Deposit&quot;, Deposit, VT_EMPTY, VTS_R8)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IBank to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {A9515AB6-5B85-11D0-848F-00400526305B}
static const IID IID_IBank =
{ 0xa9515ab6, 0x5b85, 0x11d0, { 0x84, 0x8f, 0x0, 0x40, 0x5, 0x26, 
    0x30, 0x5b } };

BEGIN_INTERFACE_MAP(CBank, CCmdTarget)
    INTERFACE_PART(CBank, IID_IBank, Dispatch)
END_INTERFACE_MAP()

// {632B1E4C-F287-11CE-B5E3-00AA005B1574}
IMPLEMENT_OLECREATE2(CBank, &quot;EX25A.BANK&quot;, 0x632b1e4c, 0xf287, 
    0x11ce, 0xb5, 0xe3, 0x0, 0xaa, 0x0, 0x5b, 0x15, 0x74)
</pre>

<P>This first version of the EX25A program runs in single-process mode, as does the Autoclik program. If a second Automation client asks for a new <I>CBank</I> object, COM calls the class factory <I>CreateInstance</I> function again and the existing process constructs another <I>CBank</I> object on the heap. You can verify this by making a copy of the ex25a.xls workbook (under a different name) and loading both the original and the copy. Click the Load Bank Program button in each workbook, and watch the Debug window. <I>InitInstance</I> should be called only once.

<P>A small change in the EX25A program makes it behave differently. To have a new EX25A process start up each time a new component object is requested, follow these steps.

<ol>
<P><LI><B>Add the following macro in bank.h:</B>

<p><pre>
<B>#define IMPLEMENT_OLECREATE2(class_name, external_name, \
    l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    AFX_DATADEF COleObjectFactory class_name::factory(class_name::guid, \
    RUNTIME_CLASS(class_name), TRUE, _T(external_name)); \
    const AFX_DATADEF GUID class_name::guid = \
    { l, w1, w2, { b1, b2, b3, b4, b5, b6, b7, b8 } };</B>
</pre>

<P>This macro is the same as the standard MFC <I>IMPLEMENT_OLECREATE</I> macro except that the original <I>FALSE</I> parameter (after the <I>RUNTIME_CLASS</I> parameter) has been changed to 
<I>TRUE</I>.

<P><LI><B>In bank.cpp, change the <I>IMPLEMENT_OLECREATE</I> macro invocation to <I>IMPLEMENT_OLECREATE2</I></B>.

<P><LI><B>Build the program and test it using Excel.</B> Start two Excel processes and then load the bank program from each. Use the Microsoft Windows NT Task Manager or PVIEW95 to verify that two EX25A processes are running.


<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
The EX25A program on the companion CD-ROM uses the<I> IMPLEMENT_OLECREATE2</I> macro.</blockquote></div>

<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B><a name="100">Debugging an EXE Component Program</A></B>

<P>When an Automation client launches an EXE component program, it sets the <I>/Embedding</I> command-line parameter. If you want to debug your component, you must do the same. Choose Settings from the Visual C++ Project menu, and then enter <I>/Embedding</I> in the Program Arguments box on the Debug page, as shown here.

<P><A HREF="javascript:fullSize('g25og06x.htm')"> <img src="g25og06.jpg" width=404 height=260 border="0" ALT = "Click to view at full size."> </A>


<P>When you click the Go button on the Debug toolbar, your program will start and then wait for a client to activate it. At this point, you should start the client program from Windows (if it is not already running) and then use it to create a component object. Your component program in the debugger should then construct its object. It might be a good idea to include a <I>TRACE</I> statement in the 
component object's constructor.

<P>Don't forget that your component program must be registered before the client can find it. That means you have to run it once <U>without</U> the <I>/Embedding</I> flag. Many clients don't synchronize with Registry changes. If your client is running when you register the component, you may have to restart the client.
</TD></TR></TABLE>
</ol>

<A NAME="542"><H2><B>The EX25B Automation Component DLL Example</B></H2></A>
<P>You could easily convert EX25A from an EXE to a DLL. The <I>CBank</I> class would be exactly the same, and the Excel driver would be similar. It's more interesting, though, to write a new application&#151;this time with a minimal user interface (UI). We'll use a modal dialog box because it's the most complex UI we can conveniently use in an Automation DLL.


<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>Parameters Passed by Reference</B>

<P>So far, you've seen VBA parameters passed by <U>value</U>. VBA has pretty strange rules for calling methods. If the method has one parameter, you can use parentheses; if it has more than one, you can't (unless you're using the function's return value, in which case you <U>must</U> use parentheses). Here is some sample VBA code that passes the string parameter by value:

<P><PRE>
Object.Method1 parm1, &quot;text&quot;
Object.Method2(&quot;text&quot;)
Dim s as String
s = &quot;text&quot;
Object.Method2(s)
</PRE>

<P>Sometimes, though, VBA passes the address of a parameter (a reference). In this example, the string is passed by reference:

<P><PRE>
Dim s as String
s = &quot;text&quot;
Object.Method1 parm1, s
</PRE>

<P>You can override VBA's default behavior by prefixing a parameter with <I>ByVal</I> or <I>ByRef</I>. Your component can't predict if it's getting a value or a reference&#151;it must prepare for both. The trick is to test <I>vt</I> to see whether its <I>VT_BYREF</I> bit is set. Here's a sample method 
implementation that accepts a string (in a <I>VARIANT</I>) passed either by reference or value:

<P><PRE>
void CMyComponent::Method(long nParm1, const VARIANT&amp; vaParm2)
{
    CString str;
    if ((vaParm2.vt &amp; 0x7f) == VT_BSTR) {
        if ((vaParm2.vt &amp; VT_BYREF) != 0)
            str = *(vaParm2.pbstrVal); // byref
        else
            str = vaParm2.bstrVal; // byval
    }
    AfxMessageBox(str);
}
</PRE>

<P>If you declare a <I>BSTR</I> parameter, the MFC library does the conversion for you. Suppose your client program passed a <I>BSTR</I> reference to an out-of-process component and the component program 
changed the value. Because the component can't access the memory of the client process, COM must copy the string to the component and then copy it back to the client after the function returns. So before 
you declare reference parameters, remember that passing references through <I>IDispatch</I> is not like passing references in C++.

</TD></TD></TABLE>


<P>The EX25B program is fairly simple. An Automation component class, identified by the registered name Ex25b.Auto, has the following properties and method:

<p><table cellpadding=5 width="95%">
<tr><td valign="top"><b>LongData</td>
<td valign="top">Long integer property</b></td></tr>
<tr><td valign="top">TextData</td>
<td valign="top"><I>VARIANT</I> property</td></tr>
<tr><td valign="top"><I>DisplayDialog</I></td>
<td valign="top">Method&#151;no parameters, <I>BOOL</I> return </td></tr>
</table>

<P><I>DisplayDialog</I> displays the EX25B data gathering dialog box shown in Figure 25-4. An Excel macro passes two cell values to the DLL and then updates the same cells with the updated values.

<P><img src="f25og04.gif" width=285 height=179 border="0">

<P><!-- caption --><B>Figure 25-4.</B> <I>The EX25B DLL dialog in action.</I><!-- /caption -->

<P>The example was first generated as an MFC AppWizard DLL with the Regular DLL Using Shared MFC DLL option and the Automation option selected. Here are the steps for building and testing the EX25B component DLL from the code installed from the companion CD-ROM:

<ol>
<P><B><LI>From Visual C++, open the \vcpp32\ex25b\ex25b.dsw workspace. </B>Build the project.
<P><B><LI>Register the DLL with the RegComp utility.</B> You can use the RegComp program in the \vcpp32\RegComp\Release directory on the companion CD-ROM; a file dialog makes it easy to select the DLL file.
<P><B><LI>Start Excel, and then load the \vcpp32\ex25b\ex25b.xls workbook file.</B> Type an integer in cell C3, and type some text in cell D3.



<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>Debugging a DLL Component</B>


<P>To debug a DLL, you must tell the debugger which EXE file to load. Choose Settings from Visual C++'s Project menu, and then enter the controller's full pathname (including the EXE extension) in the 
Executable For Debug Session box on the Debug page.<P>


<A HREF="javascript:fullSize('g25og08x.htm')"> <img src="g25og08.jpg" width=404 height=260 border=0 ALT = "Click to view at full size."> </A>

<P>When you click the Go button on the Debug toolbar, your controller will start (loading the DLL as part of its process) and then wait for you to activate the component.

<P>When you activate the component, your DLL in the debugger should then construct its component object. It might be a good idea to include a <I>TRACE</I> statement in the component object's 
constructor. Don't forget that your DLL must be registered before the client can load it.

<P>Here's another option. If you have the source code for the client program, you can start the client program in the debugger. When the client loads the component DLL, you can see the output from the component program's <I>TRACE</I> statements.

</TD></TR></TABLE>

<P><A HREF="javascript:fullSize('g25og07x.htm')"> <img src="g25og07.jpg" width=404 height=156 border=0 ALT = "Click to view at full size."> </A>

<P>Click the Load DLL button, and then click the Gather Data button. Edit the data, click OK, and watch the new values appear in the spreadsheet.
</ol>

<ol start=4>
<P><LI><B>Click the Unload DLL button.</B>If you've started the DLL (and Excel) from the debugger, you can watch the Debug window to be sure the DLL's <I>ExitInstance</I> function is called.
</ol>

<P>Now let's look at the EX25B code. Like an MFC EXE, an MFC regular DLL has an application class (derived from <I>CWinApp</I>) and a global application object. The overridden <I>InitInstance</I> member function in ex25b.cpp looks like this:

<P><pre>
BOOL CEx25bApp::InitInstance()
{
    TRACE(&quot;CEx25bApp::InitInstance\n&quot;);
    // Register all OLE server (factories) as running.  This 
    //  enables the OLE libraries to create objects from other 
    //  applications.
    COleObjectFactory::RegisterAll();

    return TRUE;
}
</pre>

<P>There's also an <I>ExitInstance</I> function for diagnostic purposes only, as well as the following code for the three standard COM DLL exported functions:

<P><pre>
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return AfxDllGetClassObject(rclsid, riid, ppv);
}

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return AfxDllCanUnloadNow();
}

STDAPI DllRegisterServer(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    COleObjectFactory::UpdateRegistryAll();
    VERIFY(AfxOleRegisterTypeLib(AfxGetInstanceHandle(),
           theTypeLibGUID, &quot;ex25b.tlb&quot;));
       return S_OK;
}
</pre>

<P>The PromptDl.cpp file contains code for the <I>CPromptDlg</I> class, but that class is a standard class derived from <I>CDialog</I>. The file PromptDl.h contains the <I>CPromptDlg</I> class header.

<P>The <I>CEx25bAuto</I> class, the Automation component class initially generated by ClassWizard (with the Createable By Type ID option), is more interesting. This class is exposed to COM under the program ID ex25b.Auto. Figure 25-5 below shows the header file ex25bAuto.h.


<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>EX25BAUTO.H</B>

<P><pre>
class CEx25bAuto : public CCmdTarget
{
    DECLARE_DYNCREATE(CEx25bAuto)

    CEx25bAuto(); // protected constructor used by dynamic creation

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEx25bAuto)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual ~CEx25bAuto();

    // Generated message map functions
    //{{AFX_MSG(CEx25bAuto)
        // NOTE - the ClassWizard will add and remove member 
        //  functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    DECLARE_OLECREATE(CEx25bAuto)

    // Generated OLE dispatch map functions
    //{{AFX_DISPATCH(CEx25bAuto)
    long m_lData;
    afx_msg void OnLongDataChanged();
    VARIANT m_vaTextData;
    afx_msg void OnTextDataChanged();
    afx_msg BOOL DisplayDialog();
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()
};
</pre>
</TD></TR></TABLE>

<P><B>Figure 25-5.</B> <I>Excerpt from the ex25bAuto.h header file.</I>

<P>Figure 25-6 shows the implementation file ex25bAuto.cpp.

<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>EX25BAUTO.CPP</B>

<P><pre>
#include &quot;stdafx.h&quot;
#include &quot;ex25b.h&quot;
#include &quot;Ex25bAuto.h&quot;
#include &quot;PromptDl.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif

////////////////////////////////////////////////////////////////////
// CEx25bAuto

IMPLEMENT_DYNCREATE(CEx25bAuto, CCmdTarget)

CEx25bAuto::CEx25bAuto()
{
    EnableAutomation();

    // To keep the application running as long as an OLE automation
    //  object is active, the constructor calls AfxOleLockApp.

    ::VariantInit(&amp;m_vaTextData); // necessary initialization
    m_lData = 0;

    AfxOleLockApp();
}

CEx25bAuto::~CEx25bAuto()
{
    // To terminate the application when all objects created with
    //  with OLE automation, the destructor calls AfxOleUnlockApp.

    AfxOleUnlockApp();
}

void CEx25bAuto::OnFinalRelease()
{
    // When the last reference for an automation object is released,
    //  OnFinalRelease is called. The base class will automatically
    //  delete the object. Add additional cleanup required for your
    //  object before calling the base class.

    CCmdTarget::OnFinalRelease();
}

BEGIN_MESSAGE_MAP(CEx25bAuto, CCmdTarget)
    //{{AFX_MSG_MAP(CEx25bAuto)
        // NOTE - the ClassWizard will add and remove mapping 
        //  macros here.
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CEx25bAuto, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CEx25bAuto)
        DISP_PROPERTY_NOTIFY(CEx25bAuto, &quot;LongData&quot;, 
m_lData, 
            OnLongDataChanged, VT_I4)
        DISP_PROPERTY_NOTIFY(CEx25bAuto, &quot;TextData&quot;, 
m_vaTextData, 
<B>Figure 25-6.</B><I>continued</I>
            OnTextDataChanged, VT_VARIANT)
        DISP_FUNCTION(CEx25bAuto, &quot;DisplayDialog&quot;, DisplayDialog,
            VT_BOOL, VTS_NONE)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IEx25bAuto to support typesafe
//  binding from VBA. This IID must match the GUID that is attached 
//  to the dispinterface in the .ODL file.

// {A9515AD7-5B85-11D0-848F-00400526305B}
static const IID IID_IEx25bAuto =
{ 0xa9515ad7, 0x5b85, 0x11d0, { 0x84, 0x8f, 0x0, 0x40, 0x5, 0x26,
     0x30, 0x5b } };

BEGIN_INTERFACE_MAP(CEx25bAuto, CCmdTarget)
    INTERFACE_PART(CEx25bAuto, IID_IEx25bAuto, Dispatch)
END_INTERFACE_MAP()

// {A9515AD8-5B85-11D0-848F-00400526305B}
IMPLEMENT_OLECREATE(CEx25bAuto, &quot;ex25b.Auto&quot;, 0xa9515ad8, 0x5b85, 
    0x11d0, 0x84, 0x8f, 0x0, 0x40, 0x5, 0x26, 0x30, 0x5b)

////////////////////////////////////////////////////////////////////
// CEx25bAuto message handlers

void CEx25bAuto::OnLongDataChanged() 
{
    TRACE(&quot;CEx25bAuto::OnLongDataChanged\n&quot;);
}
void CEx25bAuto::OnTextDataChanged() 
{
    TRACE(&quot;CEx25bAuto::OnTextDataChanged\n&quot;);
}

BOOL CEx25bAuto::DisplayDialog() 
{
    TRACE(&quot;Entering CEx25bAuto::DisplayDialog %p\n&quot;, this);
    BOOL bRet = TRUE;
    AfxLockTempMaps();  // See MFC Tech Note #3
    CWnd* pTopWnd = CWnd::FromHandle(::GetTopWindow(NULL));
    try {
        CPromptDlg dlg /*(pTopWnd)*/;
        if (
m_vaTextData.vt == VT_BSTR){
            dlg.
m_strData = m_vaTextData.bstrVal; // converts 
                                                  // 
 double-byte
                                                  //  character to
                                                  //  single-byte
                                                  //  character
        }
        dlg.
m_lData = m_lData;
        if (dlg.DoModal() == IDOK) {
            
m_vaTextData = COleVariant(dlg.m_strData).Detach();
            
m_lData = dlg.m_lData;
            bRet = TRUE;
        }
        else {
            bRet =  FALSE;
        }
    }
    catch (CException* pe) {
        TRACE(&quot;Exception: failure to display dialog\n&quot;);
        bRet =  FALSE;
        pe-&gt;Delete();
    }
    AfxUnlockTempMaps();
    return bRet;
}
</pre>

</TD></TR></TABLE>
<P><B>Figure 25-6.</B> <I>The ex25bAuto.cpp implementation file.</I>


<P>The two properties, LongData and TextData, are represented by class data members <I>m_lData</I> and 
<I>m_vaTextData</I>, both initialized in the constructor. When the LongData property was added in ClassWizard, a notification function, <I>OnLongDataChanged</I>, was specified. This function is called whenever the controller changes the property value. Notification functions apply only to properties that are represented by data members. Don't confuse this notification with the notifications that ActiveX controls give their container when a bound property changes.

<P>The <I>DisplayDialog</I> member function, which is the <I>DisplayDialog</I> method, is ordinary except that the <I>AfxLockTempMaps</I> and <I>AfxUnlockTempMaps</I> functions are necessary for cleaning up temporary object pointers that would normally be deleted in an EXE program's idle loop.

<P>What about the Excel VBA code? Here are the three macros and the global declarations:

<P><pre>
Dim Dllcomp As Object
Private Declare Sub CoFreeUnusedLibraries Lib &quot;OLE32&quot; ()

Sub LoadDllComp()
    Set Dllcomp = CreateObject(&quot;Ex25b.Auto&quot;)
    Range(&quot;C3&quot;).Select
    Dllcomp.LongData = Selection.Value
    Range(&quot;D3&quot;).Select
    Dllcomp.TextData = Selection.Value
End Sub

Sub RefreshDllComp() `Gather Data button
    Range(&quot;C3&quot;).Select
    Dllcomp.LongData = Selection.Value
    Range(&quot;D3&quot;).Select
    Dllcomp.TextData = Selection.Value
    Dllcomp.DisplayDialog
    Range(&quot;C3&quot;).Select
    Selection.Value = Dllcomp.LongData
    Range(&quot;D3&quot;).Select
    Selection.Value = Dllcomp.TextData
End Sub
    
Sub UnloadDllComp()
    Set Dllcomp = Nothing
    Call CoFreeUnusedLibraries
End Sub
</pre>

<P>The first line in <I>LoadDllComp</I> creates a component object as identified by the registered name <I>Ex25b.Auto</I>. The <I>RefreshDllComp</I> macro accesses the component object's LongData and TextData properties. The first time you run <I>LoadDllComp</I>, it loads the DLL and constructs an 
<I>Ex25b.Auto </I>object. The second time you run <I>LoadDllComp</I>, something curious happens: a second object is constructed, and the original object is destroyed. If you run <I>LoadDllComp</I> from another copy of the workbook, you get two separate <I>Ex25b.Auto </I>objects. Of course, there's only one mapping of ex25b.dll in memory at any time unless you're running more than one Excel process.

<P>Look closely at the <I>UnloadDllComp</I> macro. When the &quot;Set Dllcomp = Nothing&quot; statement is executed, the DLL is disconnected, but it's not unmapped from Excel's address space, which means the component's <I>ExitInstance</I> function is not called. The <I>CoFreeUnusedLibraries</I> function calls the exported <I>DllCanUnloadNow</I> function for each component DLL and, if that function returns <I>TRUE</I>, <I>CoFreeUnusedLibraries</I> frees the DLL. MFC programs call <I>CoFreeUnusedLibraries</I> in the idle loop (after a one-minute delay), but Excel 
doesn't. That's why <I>UnloadDllComp</I> must call <I>CoFreeUnusedLibraries</I> after disconnecting the component.

<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
The <I>CoFreeUnusedLibraries</I> function doesn't do anything in Windows NT 3.51 unless you have Service Pack 2 (SP2) installed.</blockquote></div>

<A NAME="543"><H2><B>The EX25C SDI Automation Component <p>EXE Example&#151;with User Interface</B></H2></A>
<P>This Automation component example illustrates the use of a document component class in an SDI application in which a new process is started for each object. This component program demonstrates an indexed property plus a method that constructs a new COM object.

<P>The first Automation component example you saw, EX25A, didn't have a user interface. The global class factory constructed a <I>CBank</I> object that did the component's work. What if you want your EXE component to have a window? If you've bought into the MFC document_view architecture, you'll 
want the document, view, and frame, with all the benefits they provide.

<P>Suppose you created a regular MFC application and then added a COM-creatable class such as <I>CBank</I>. How do you attach the <I>CBank</I> object to the document and view? From a <I>CBank</I> class member function, you could navigate through the application object and main frame to the current document or view, but you'd have a tough time in an MDI application if you encountered several component objects and several documents. There is a better way. You make the document class the creatable class, and you have the full support of AppWizard for this task. This is true for both MDI and SDI applications.

<P>The MDI Autoclik example demonstrates how COM triggers the construction of new document, view, and child frame objects each time an Automation client creates a new component object. Because the EX25C example is an SDI program, Windows starts a new process each time the client creates an object. Immediately after the program starts, COM, with the help of the MFC application framework, constructs not only the Automation-aware document but also the view and the main frame window.

<P>Now is a good time to experiment with the EX25C application, which was first generated by AppWizard with the Automation option checked. It's a Windows-based alarm clock program designed to be manipulated from an Automation client such as Excel. EX25C has the following properties and methods.

<p><table cellpadding=5 width="95%">
<tr><td valign="top"><b>Name</b></td>
<td valign="top"><b>Description</b></td></tr>
<tr><td valign="top">Time</td>
<td valign="top"><I>DATE</I> property that holds a <I>COM DATE</I> (<I>m_vaTime</I>)</td></tr>
<tr><td valign="top">Figure</td>
<td valign="top">Indexed <I>VARIANT</I> property for the four figures on the clockface (<I>m_strFigure[]</I>)</td></tr>
<tr><td valign="top"><I>RefreshWin</I></td>
<td valign="top">Method that invalidates the view window and brings the main frame window to the top (<I>Refresh</I>)</td></tr>
<tr><td valign="top"><I>ShowWin</I></td>
<td valign="top">Method that displays the application's main window (<I>ShowWin</I>)</td></tr>
<tr><td valign="top"><I>CreateAlarm</I></td>
<td valign="top">Method that creates a <I>CAlarm</I> object and returns its <I>IDispatch</I> pointer (<I>CreateAlarm</I>)</td></tr>
</table>

<P>Here are the steps for building and running EX25C from the 
companion CD-ROM:

<ol>
<P><B><LI>From Visual C++, open the workspace \vcpp32\ex25c\ex25c.dsw.</B> Build the project to produce the ex25c.exe file in the project's Debug subdirectory.

<P><B><LI>Run the program once to register it.</B> The program is designed to be executed either as a stand-alone application or as an Automation component. When you run it from Windows or from Visual C++, it updates the Registry and displays the face of a clock with the characters XII, III, VI, and IX at the 12, 3, 6, and 9 o'clock positions. Exit the program.

<P><B><LI>Load the Excel workbook file \vcpp32\ex25c\ex25c.xls.</B>The worksheet should look like the one shown here.


<P><A HREF="javascript:fullSize('g25og09x.htm')"> <img src="g25og09.jpg" width=404 height=274 border=0 ALT = "Click to view at full size."> </A>

<P>Click the Load Clock button, and then double-click the Set Alarm button. (There could be a long delay after you click the Load Clock button, depending on your system.) The clock should appear as shown below, with the letter <I>A</I> indicating the alarm setting.



<P><img src="g25og10.gif" width=307 height=288 border="0">


<P>If you've started the component program from the debugger, you can watch the Debug window to see when <I>InitInstance</I> is called and when the document object is constructed.

<P>If you're wondering why there's no menu, it's because of the following statement in the <I>CMainFrame::PreCreateWindow</I> function:

<p><pre>
cs.hMenu = NULL;
</pre>
</ol>

<ol start=4>
<P><B><LI>Close the Clock program and then click the Unload Clock button.</B> If you've started the component program from the debugger, you can watch the Debug window for a message box that indicates that the <I>ExitInstance</I> function is called.
</ol>

<P>AppWizard did most of the work of setting up the document as an Automation component. In the derived application class <I>CEx25cApp</I>, it generated a data member for the component, as shown here:

<P><pre>
public:
    COleTemplateServer m_server;
</pre>

<P>The MFC <I>COleTemplateServer</I> class is derived from <I>COleObjectFactory</I>. It is designed to create a COM document object when a client calls <I>IClassFactory::CreateInstance</I>. The class ID comes from the global <I>clsid</I> variable defined in ex25c.cpp. The human-readable program ID 
(Ex25c.Document) comes from the <I>IDR_MAINFRAME</I> string resource.

<P>In the <I>InitInstance</I> function (in ex25c.cpp), AppWizard generated the code below, which connects the component object (the document) to the application's document template.


<P><pre>
CSingleDocTemplate* pDocTemplate;
pDocTemplate = new CSingleDocTemplate(
    IDR_MAINFRAME,
    RUNTIME_CLASS(CEx25cDoc),
    RUNTIME_CLASS(CMainFrame),     // main SDI frame window
    RUNTIME_CLASS(CEx25cView));
AddDocTemplate(pDocTemplate);
.
.
.
m_server.ConnectTemplate(clsid, pDocTemplate, TRUE);
</pre>

<P>Now all the plumbing is in place for COM and the framework to construct the document, together with the view and frame. When the objects are constructed, however, the main window is not made visible. That's your job. You must write a method that shows the window.

<P>The following <I>UpdateRegistry</I> call from the <I>InitInstance</I> function updates the Windows Registry with the contents of the project's <I>IDR_MAINFRAME</I> string resource:

<P><pre>
m_server.UpdateRegistry(OAT_DISPATCH_OBJECT);
</pre>

<P>The following dispatch map in the ex25cDoc.cpp file shows the properties and methods for the <I>CEx25cDoc</I> class. Note that the Figure property is an indexed property that ClassWizard can generate if you specify a parameter. Later you'll see the code you have to write for the <I>GetFigure</I> and <I>SetFigure</I> functions.

<P><pre>
BEGIN_DISPATCH_MAP(CEx25cDoc, CDocument)
    //{{AFX_DISPATCH_MAP(CEx25cDoc)
    DISP_PROPERTY_NOTIFY(CEx25cDoc, &quot;Time&quot;, 
m_time, OnTimeChanged,
        VT_DATE)
    DISP_FUNCTION(CEx25cDoc, &quot;ShowWin&quot;, ShowWin, VT_EMPTY, VTS_NONE)
    DISP_FUNCTION(CEx25cDoc, &quot;CreateAlarm&quot;, CreateAlarm,
        VT_DISPATCH, VTS_DATE)
    DISP_FUNCTION(CEx25cDoc, &quot;RefreshWin&quot;, Refresh, VT_EMPTY,
        VTS_NONE)
    DISP_PROPERTY_PARAM(CEx25cDoc, &quot;Figure&quot;, GetFigure, SetFigure, 
        VT_VARIANT, VTS_I2)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()
</pre>

<P>The <I>ShowWin</I> and <I>RefreshWin</I> member functions aren't very interesting, but the <I>CreateAlarm</I> method is worth a close look. Here's the corresponding <I>CreateAlarm</I> member function:

<P><pre>
LPDISPATCH CEx25cDoc::CreateAlarm(DATE time)
{
    TRACE(&quot;Entering CEx25cDoc::CreateAlarm, time = %f\n&quot;, time);
    // OLE deletes any prior CAlarm object
    m_pAlarm = new CAlarm(time);
    return m_pAlarm-&gt;GetIDispatch(FALSE);   // no AddRef here
}
</pre>

<P>We've chosen to have the component create an alarm object when a controller calls <I>CreateAlarm.</I> <I>CAlarm</I> is an Automation component class that we've generated with ClassWizard. It is <U>not</U> COM-creatable, which means there's no <I>IMPLEMENT_OLECREATE</I> macro and no class factory. The <I>CreateAlarm</I> function constructs a <I>CAlarm</I> object and returns an 
<I>IDispatch</I> pointer. (The <I>FALSE</I> parameter for <I>CCmdTarget::GetIDispatch </I>means that the reference count is not incremented; the <I>CAlarm</I> object already has a reference count of 1 
when it is constructed.)

<P>The <I>CAlarm</I> class is declared in alarm.h as follows:

<P><pre>
class CAlarm : public CCmdTarget
{
    DECLARE_DYNAMIC(CAlarm)
public:
    CAlarm(DATE time);

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAlarm)
    public:
    virtual void OnFinalRelease();
    //}}AFX_VIRTUAL

// Implementation
protected:
    virtual ~CAlarm();

    // Generated message map functions
    //{{AFX_MSG(CAlarm)
        // NOTE - the ClassWizard will add and remove member 
        //  functions here.
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()
    // Generated OLE dispatch map functions
public:
    //{{AFX_DISPATCH(CAlarm)
    DATE m_time;
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()
    DECLARE_INTERFACE_MAP()
};
</pre>

<P>Notice the absence of the <I>DECLARE_DYNCREATE</I> macro.

<P>Alarm.cpp contains a dispatch map, as follows:

<P><pre>
BEGIN_DISPATCH_MAP(CAlarm, CCmdTarget)
    //{{AFX_DISPATCH_MAP(CAlarm)
    DISP_PROPERTY(CAlarm, &quot;Time&quot;, 
m_time, VT_DATE)
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()
</pre>

<P>Why do we have a <I>CAlarm</I> class? We could have added an AlarmTime property in the <I>CEx25cDoc</I> class instead, but then we would have needed another property or method to turn the alarm on and off. By using the <I>CAlarm</I> class, what we're really doing is setting ourselves up to support multiple alarms&#151;a <U>collection</U> of alarms.

<P>To implement an Automation collection, we would write another class, <I>CAlarms</I>, that would contain the methods <I>Add, Remove,</I> and <I>Item</I>. <I>Add</I> and <I>Remove</I> are self-explanatory; <I>Item</I> returns an IDispatch pointer for a collection element identified by an index, numeric, or some other key. We would also implement a read-only Count property that returned the number of elements. The document class (which owns the collection) would have an <I>Alarms</I> method with an optional <I>VARIANT</I> parameter. If the parameter were omitted, the method would return the <I>IDispatch</I> pointer for the collection. If the parameter specified an index, the method would return an <I>IDispatch</I> pointer for the selected alarm.

<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
If we wanted our collection to support the VBA &quot;For Each&quot; syntax, we'd have some more work to do. We'd add an <I>IEnum VARIANT</I> interface to the <I>CAlarms</I> class to enumerate the 
collection of variants and implement the <I>Next</I> member function of this interface to step through the collection. Then we'd add a <I>CAlarms</I> method named <I>_NewEnum</I> that returned an 
<I>IEnumVARIANT</I> interface pointer. If we wanted the collection to be general, we'd allow separate enumerator objects (with an <I>IEnum VARIANT</I> interface) and we'd implement the other 
<I>IEnumVARIANT</I> functions&#151;<I>Skip</I>, <I>Reset</I>, and <I>Clone</I>.</blockquote></div>

<P>The Figure property is an indexed property, which makes it interesting. The Figure property represents the four figures on the clock face&#151;XII, III, VI, and IX. It's a <I>CString</I> array, so we can use Roman numerals. Here's the declaration in ex25cDoc.h:

<P><pre>
public:
    CString m_strFigure[4];
</pre>

<P>And here are the <I>GetFigure</I> and <I>SetFigure</I> functions in ex25cDoc.cpp:

<P><pre>
VARIANT CEx25cDoc::GetFigure(short n) 
{
    TRACE(&quot;Entering CEx25cDoc::GetFigure -
-           n = %d 
m_strFigure[n] = %s\n&quot;,
           n, 
m_strFigure[n]);
    return COleVariant(m_strFigure[n]).Detach();
}

void CEx25cDoc::SetFigure(short n, const VARIANT FAR&amp; newValue) 
{
    TRACE(&quot;Entering CEx25cDoc::SetFigure -- n = %d, vt = %d\n&quot;, n, 
          newValue.vt);
    COleVariant vaTemp;
    vaTemp.ChangeType(VT_BSTR, (COleVariant*) &amp;newValue);
    m_strFigure[n] = vaTemp.bstrVal; // converts double-to-single
}
</pre>

<P>These functions tie back to the <I>DISP_PROPERTY_PARAM</I> macro in the <I>CEx25cDoc</I> dispatch map. The first parameter is the index number, specified as a short integer by the last macro parameter. Property indexes don't have to be integers, and the index can have several components (row and column numbers, for example). The <I>ChangeType</I> call in <I>SetFigure</I> is necessary because the controller might otherwise pass numbers instead of strings.

<P>You've just seen collection properties and indexed properties. What's the difference? A controller can't add or delete elements of an indexed property, but it can add elements to a collection and it can delete elements from a collection.

<P>What draws the clock face? As you might expect, it's the <I>OnDraw</I> member function of the view class. This function uses <I>GetDocument</I> to get a pointer to the document object, and then it accesses the document's property data members and method member functions.

<P>The Excel macro code appears below.


<P><pre>
Dim Clock As Object
Dim Alarm As Object

Sub LoadClock()
    Set Clock = CreateObject(&quot;ex25c.Document&quot;)
    Range(&quot;A3&quot;).Select
    n = 0
    Do Until n = 4
        Clock.figure(n) = Selection.Value
        Selection.Offset(0, 1).Range(&quot;A1&quot;).Select
        n = n + 1
    Loop
    RefreshClock
    Clock.ShowWin
End Sub

Sub RefreshClock()
    Clock.Time = Now()
    Clock.RefreshWin
End Sub
    
Sub CreateAlarm()
    Range(&quot;E3&quot;).Select
    Set Alarm = Clock.CreateAlarm(Selection.Value)
    RefreshClock
End Sub
    
Sub UnloadClock()
    Set Clock = Nothing
End Sub
</pre>

<P>Notice the Set Alarm statement in the <I>CreateAlarm</I> macro. It calls the <I>CreateAlarm</I> method to return an <I>IDispatch</I> pointer, which is stored in an object variable. If the macro is run a second time, a new alarm is created, but the original one is destroyed because its reference count goes to 0.

<P><DIV CLASS=warning>
<BLOCKQUOTE>
<IMG SRC="warning.jpg" width=123 height=18 BORDER=0><P>
You've seen a modal dialog in a DLL (EX25B) 
and you've seen a main frame window in an EXE (EX25C). Be careful 
with modal dialogs in EXEs. It's fine to have an About dialog that is 
invoked directly by the component program, but it isn't a good 
idea to invoke a modal dialog in an out-of-process component 
method function. The problem is that once the modal dialog is on the 
screen, the user can switch back to the client program. MFC clients 
handle this situation with a special &quot;Server Busy&quot; message box, which 
appears right away. Excel does something similar, but it waits 30 seconds, 
and this could confuse the user.</blockquote></div>

<A NAME="544"><H2><B>The EX25D Automation Client Example</B></H2></A>
<P>So far, you've seen C++ Automation component programs. Now you'll see a C++ Automation client program that runs all the previous components and also controls Microsoft Excel 97. The EX25D program was originally generated by AppWizard, but without any COM options. It was easier to add the COM 
code than it would have been to rip out the component-specific code. If you do use AppWizard to build such an Automation controller, add the following line at the end of StdAfx.h:

<P><pre>
#include &lt;afxdisp.h&gt;
</pre>

<P>Then add this call at the beginning of the application's <I>InitInstance</I> function:

<P><pre>
AfxOleInit();
</pre>

<P>To prepare EX25D, open the \vcpp32\ex25d\ex25d project and do the build. Run the application from the debugger, and you'll see a standard SDI application with a menu structure similar to that shown in Figure 25-7.

<P>If you have built and registered all the components, you can test them from EX25D. Notice that the DLL doesn't have to be copied to the \Winnt\System32 directory because Windows finds it through the Registry. For some components, you'll have to watch the Debug window to verify that the test results are correct. The program is reasonably modular. Menu commands and update command UI events are mapped to the view class. Each component object has its own C++ controller class and an embedded data member in ex25dView.h. We'll look at each part separately after we delve into type libraries.

<P><a href="f25og07x.gif"><img src="f25og07.jpg" width=404 height=111 border="0"></a>

<P><!-- caption --><B>Figure 25-7.</B> <I>A sample menu structure for a standard SDI application.</I><!-- /caption -->

<P><B>Type Libraries and ODL Files</B>

<P>We've told you that type libraries aren't necessary for the MFC <I>IDispatch</I> implementation, but Visual C++ has been quietly generating and updating type libraries for all your components. What good are these type libraries? VBA can use a type library to browse your component's methods and properties, and it can use the type library for improved access to properties and methods, a process called <U>early</U> <U>binding</U> described later in this chapter. But we're building a C++ client program here, not a VBA program. It so happens that ClassWizard can read a component's type library and use the information to generate C++ code for the client to use to &quot;drive&quot; an Automation component.

<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
AppWizard initializes a project's Object Description Language (ODL) file when you first create it. ClassWizard edits this file each time you generate a new Automation component class or 
add properties and methods to an existing class. Unlike it does with the ClassWizard (CLW) file, ClassWizard can't rebuild an ODL file from the contents of your source files. If you mess up your ODL file, you'll have to re-create it manually.</blockquote></div>

<P>When you were adding properties and methods to your component classes, ClassWizard was updating the project's ODL file. This file is a text file that describes the component in an ODL. (Your GUID will be different if you used AppWizard to generate this project.) Here's the ODL file for the bank 
component:

<P><pre>
// ex25a.odl : type library source for ex25a.exe

// This file will be processed by the MIDL compiler to produce the
//  type library (ex25a.tlb).

[ uuid(85D56DE4-789D-11D0-92E1-D74D1B9CCD32), version(1.0) ]
library Ex25a
{
    importlib(&quot;stdole32.tlb&quot;);

    // Primary dispatch interface for CBank

    [ uuid(99EA95E1-78A1-11D0-92E1-D74D1B9CCD32) ]
    dispinterface IBank
    {
        properties:
            // NOTE - ClassWizard will maintain property information
            //  here.
            //  Use extreme caution when editing this section.
            //{{AFX_ODL_PROP(CBank)
            [id(1)] double Balance;
            //}}AFX_ODL_PROP

        methods:
        // NOTE - ClassWizard will maintain method information here.
        // Use extreme caution when editing this section.
        //{{AFX_ODL_METHOD(CBank)
        [id(2)] double Withdrawal(double dAmount);
        [id(3)] void Deposit(double dAmount);
        //}}AFX_ODL_METHOD

    };

    // Class information for CBank

        [ uuid(99EA95E2-78A1-11D0-92E1-D74D1B9CCD32) ]
        coclass Bank
        {
            [default] dispinterface IBank;
        };

    // {{AFX_APPEND_ODL}}
};
</pre>

<P>The ODL file has a unique GUID type library identifier, 85D56DE4-789D-11D0-92E1-D74D1B9CCD32, and it completely describes the bank component's properties and methods under a <U>dispinterface</U> named <I>IBank</I>. In addition, it specifies the dispinterface GUID, 99EA95E1-78A1-11D0-92E1-D74D1B9CCD32, which is the same GUID that's in the interface map of the <I>CBank</I> class. You'll see the significance of this GUID when you read the &quot;VBA Early Binding&quot; section near the end of this chapter. The CLSID, 99EA95E2-78A1-11D0-92E1-D74D1B9CCD32, is what a VBA browser can actually use to load your component.

<P>Anyway, when you build your <U>component</U> project, Visual C++ invokes the MIDL utility, which reads the ODL file and generates a binary TLB file in your project's debug or release subdirectory. Now when you develop a C++ <U>client</U> <U>program</U>, you can ask ClassWizard to generate a driver class from the component project's TLB file.

<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
The MIDL utility generates the type library in a stand-alone TLB file, and that's what Automation controllers such as Excel look for. ActiveX controls have their type libraries bound into their resources.</blockquote></div>

<P>To actually do this, you click the ClassWizard Add Class button and then select From A Type Library from the drop-down list. You navigate to the component project's TLB file, and then ClassWizard shows you a dialog similar to the illustration below.


<P><img src="g25og11.gif" width=335 height=353 border="0">

<P><I>IBank</I> is the dispinterface specified in the ODL file. You can keep this name for the class if you want, and you can specify the H and CPP filenames. If a type library contains several interfaces you can make multiple selections. You'll see the generated controller classes in the sections that follow.

<P><B>The Controller Class for ex25a.exe</B>

<P>ClassWizard generated the <I>IBank</I> class (derived from <I>COleDispatchDriver</I>) listed in Figure 25-8. Look closely at the member function implementations. Note the first parameters of the 
<I>GetProperty</I>, <I>SetProperty</I>, and <I>InvokeHelper</I> function calls. These are hard-coded DISPIDs for the component's properties and methods, as determined by the component's dispatch map sequence.

<DIV CLASS=warning>
<BLOCKQUOTE>
<IMG SRC="warning.jpg" width=123 height=18 BORDER=0><P>
If you use ClassWizard to delete a property and then add the property back, you'll probably change the component's dispatch IDs. That means that you'll have to regenerate or edit the controller class so that the IDs match.</blockquote></div>


<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>BANKDRIVER.H</B>

<P><pre>
class IBank : public COleDispatchDriver
{
public:
    IBank() {} // calls COleDispatchDriver default constructor
    IBank(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    IBank(const IBank&amp; dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    double GetBalance();
    void SetBalance(double);

// Operations
public:
    double Withdrawal(double dAmount);
    void Deposit(double dAmount);
}; 
</pre>

<P><B>BANKDRIVER.CPP</B>

<P><pre>
#include &quot;StdAfx.h&quot;
#include &quot;BankDriver.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif

////////////////////////////////////////////////////////////////////
// IBank properties

double IBank::GetBalance()
{
    double result;
    GetProperty(0x1, VT_R8, (void*)&amp;result);
    return result;
}
void IBank::SetBalance(double propVal)
{
    SetProperty(0x1, VT_R8, propVal);
}

////////////////////////////////////////////////////////////////////
// IBank operations

double IBank::Withdrawal(double dAmount)
{
    double result;
    static BYTE parms[] =
        VTS_R8;
    InvokeHelper(0x2, DISPATCH_METHOD, VT_R8, (void*)&amp;result, parms,
                 dAmount);
    return result;
}

void IBank::Deposit(double dAmount)
{
    static BYTE parms[] =
        VTS_R8;
    InvokeHelper(0x3, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
                 dAmount);
}
</pre>

</TD></TR></TABLE>

<P><B>Figure 25-8.</B> <I>The </I>IBank<I> class listing.</I>

<P>The <I>CEx25dView</I> class has a data member <I>m_bank</I> of class <I>IBank</I>. The <I>CEx25dView</I> member functions for the Ex25a.Bank component are listed below. They are hooked up to options on the EX25D main menu. Of particular interest is the <I>OnBankoleLoad</I> function. The 
<I>COleDispatchDriver::CreateDispatch</I> function loads the component program (by calling <I>CoGetClassObject </I>and<I> IClassFactory::CreateInstance</I>) and then calls <I>QueryInterface</I> to get an <I>IDispatch</I> pointer, which it stores in the object's <I>m_lpDispatch</I> data member. The <I>COleDispatchDriver::ReleaseDispatch</I> function, called in <I>OnBankoleUnload</I>, calls <I>Release</I> on the pointer.

<P><pre>
void CEx25dView::OnBankoleLoad() 
{
   if(!m_bank.CreateDispatch(&quot;Ex25a.Bank&quot;)) {
        AfxMessageBox(&quot;Ex25a.Bank component not found&quot;);
        return;
   }
}

void CEx25dView::OnUpdateBankoleLoad(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_bank.m_lpDispatch == NULL);
}
 
void CEx25dView::OnBankoleTest() 
{
    m_bank.Deposit(20.0);
    m_bank.Withdrawal(15.0);
    TRACE(&quot;new balance = %f\n&quot;, 
m_bank.GetBalance());
}

void CEx25dView::OnUpdateBankoleTest(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_bank.m_lpDispatch != NULL);
}

void CEx25dView::OnBankoleUnload() 
{   
    m_bank.ReleaseDispatch();
}

void CEx25dView::OnUpdateBankoleUnload(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_bank.m_lpDispatch != NULL);
}
</pre>

<P><B>The Controller Class for ex25b.dll</B>

<P>Figure 25-9 shows the class header file generated by ClassWizard.



<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>AUTODRIVER.H</B>

<P><pre>
class IEx25bAuto : public COleDispatchDriver
{
public:
    IEx25bAuto() {} // calls COleDispatchDriver default constructor
    IEx25bAuto(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    IEx25bAuto(const IEx25bAuto&amp; dispatchSrc) :
        COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    long GetLongData();
    void SetLongData(long);
    VARIANT GetTextData();
    void SetTextData(const VARIANT&amp;);

// Operations
public:
    BOOL DisplayDialog();
};
</pre>
</TD></TR></TABLE>
<P><B>Figure 25-9.</B> <I>The </I>Ex25bAuto<I> class header file.</I>

<P>Notice that each property requires separate <I>Get</I> and <I>Set</I> functions in the client class, even though a data member in the component represents the property.

<P>The view class header has a data member <I>m_auto </I>of class <I>IEx25bAuto</I>. Here are some DLL-related command handler member functions from ex25dView.cpp:

<P><pre>
void CEx25dView::OnDlloleGetdata() 
{
    m_auto.DisplayDialog();
    COleVariant vaData = 
m_auto.GetTextData();
    ASSERT(vaData.vt == VT_BSTR);
    CString strTextData = vaData.bstrVal;
    long lData = 
m_auto.GetLongData();
    TRACE(&quot;CEx25dView::OnDlloleGetdata &#151; long = %ld, text = %s\n&quot;,
          lData, strTextData);
}

void CEx25dView::OnUpdateDlloleGetdata(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_auto.m_lpDispatch != NULL);
}

void CEx25dView::OnDlloleLoad() 
{
    if(!m_auto.CreateDispatch(&quot;Ex25b.Auto&quot;)) {
        AfxMessageBox(&quot;Ex25b.Auto component not found&quot;);
        return;
    }
    m_auto.SetTextData(COleVariant(&quot;test&quot;));  // testing
    m_auto.SetLongData(79);  // testing
    // verify dispatch interface
    //  {A9515AD7-5B85-11D0-848F-00400526305B}
    static const IID IID_IEx25bAuto =
        { 0xa9515ad7, 0x5b85, 0x11d0, { 0x84, 0x8f, 0x0, 0x40, 0x5,
            0x26, 0x30, 0x5b } };
    LPDISPATCH p;
    HRESULT hr = 
m_auto.m_lpDispatch-&gt;QueryInterface(IID_IEx25bAuto,
        (void**) &amp;p);
    TRACE(&quot;OnDlloleLoad &#151; QueryInterface result = %x\n&quot;, hr);
    p-&gt;Release();
}

void CEx25dView::OnUpdateDlloleLoad(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_auto.m_lpDispatch == NULL);
}

void CEx25dView::OnDlloleUnload() 
{
    m_auto.ReleaseDispatch();
}

void CEx25dView::OnUpdateDlloleUnload(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_auto.m_lpDispatch != NULL);
}
</pre>

<P><B>The Controller Class for ex25c.exe</B>
<P>Figure 25-10 shows the headers for the <I>IEx25c </I>and <I>IAlarm</I> classes, which drive the EX25C Automation component.




<TABLE Cellpadding=5 width="95%"><TR><TD>
<P><B>CLOCKDRIVER.H</B>

<P><pre>
class IEx25c : public COleDispatchDriver
{
public:
    IEx25c() {} // calls COleDispatchDriver default constructor
    IEx25c(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    IEx25c(const IEx25c&amp; dispatchSrc) : 
        COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    DATE GetTime();
    void SetTime(DATE);

// Operations
public:
    void ShowWin();
    LPDISPATCH CreateAlarm(DATE time);
    void RefreshWin();
    void SetFigure(short n, const VARIANT&amp; newValue);
    VARIANT GetFigure(short n);
};

class IAlarm : public COleDispatchDriver
{
public:
    IAlarm() {} // calls COleDispatchDriver default constructor
    IAlarm(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
    IAlarm(const IAlarm&amp; dispatchSrc) :
        COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
    DATE GetTime();
    void SetTime(DATE);

// Operations
public:
};
</pre>
</TD></TR></TABLE>

<P><B>Figure 25-10.</B> <I>The </I>IEx25c <I>and</I> IAlarm<I> class header files.</I>
<P>Of particular interest is the <I>IEx25c::CreateAlarm </I>member function in ClockDriver.cpp:

<P><pre>
LPDISPATCH IEx25c::CreateAlarm(DATE time)
{
    LPDISPATCH result;
    static BYTE parms[] =
        VTS_DATE;
    InvokeHelper(0x3, DISPATCH_METHOD, VT_DISPATCH, (void*)&amp;result,
        parms, time);
    return result;
}
</pre>

<P>This function can be called only after the clock object (document) has been constructed. It causes the EX25C component to construct an alarm object and return an <I>IDispatch</I> pointer with a reference count of 1. The <I>COleDispatchDriver::AttachDispatch</I> function connects that pointer to the client's <I>m_alarm</I> object, but if that object already has a dispatch pointer, the old pointer is released. That's why, if you watch the Debug window, you'll see that the old EX25C instance exits immediately after you ask for a new instance. You'll have to test this behavior with the Excel driver because EX25D disables the Load menu option when the clock is running.

<P>The view class has the data members <I>m_clock </I>and <I>m_alarm</I>. Here are the view class command handlers:

<P><pre>
void CEx25dView::OnClockoleCreatealarm() 
{
    CAlarmDialog dlg;
    if (dlg.DoModal() == IDOK) {
        COleDateTime dt(1995, 12, 23, dlg.
m_nHours, dlg.m_nMinutes,
            dlg.
m_nSeconds);
        LPDISPATCH pAlarm = 
m_clock.CreateAlarm(dt);
        m_alarm.AttachDispatch(pAlarm);  // releases prior object!
        m_clock.RefreshWin();
    }
}
void CEx25dView::OnUpdateClockoleCreatealarm(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_clock.m
_lpDispatch != NULL);
}

void CEx25dView::OnClockoleLoad() 
{
   if(!m_clock.CreateDispatch(&quot;Ex25c.Document&quot;)) {
        AfxMessageBox(&quot;Ex25c.Document component not found&quot;);
        return;
   }
    m_clock.SetFigure(0, COleVariant(&quot;XII&quot;));
    m_clock.SetFigure(1, COleVariant(&quot;III&quot;));
    m_clock.SetFigure(2, COleVariant(&quot;VI&quot;));
    m_clock.SetFigure(3, COleVariant(&quot;IX&quot;));
    OnClockoleRefreshtime();
    m_clock.ShowWin();
}

void CEx25dView::OnUpdateClockoleLoad(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_clock.m
_lpDispatch == NULL);
}

void CEx25dView::OnClockoleRefreshtime() 
{
    COleDateTime now = COleDateTime::GetCurrentTime();
    m_clock.SetTime(now);
    m_clock.RefreshWin();
}

void CEx25dView::OnUpdateClockoleRefreshtime(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_clock.m_lpDispatch != NULL);
}

void CEx25dView::OnClockoleUnload() 
{
    m_clock.ReleaseDispatch();
}

void CEx25dView::OnUpdateClockoleUnload(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_clock.m
_lpDispatch != NULL);
}
</pre>

<P><B>Controlling Microsoft Excel</B>

<P>The EX25D program contains code that loads Excel, creates a workbook, and reads from and writes to cells from the active worksheet. Controlling Excel is exactly like controlling an MFC Automation component, but you need to know about a few Excel peculiarities.

<P>If you study Excel VBA, you'll notice that you can use more than 100 &quot;objects&quot; in your programs. All of these objects are accessible through Automation, but if you write an MFC Automation client program, you'll need to know about the objects' properties and methods. Ideally, you'd like a 
C++ class for each object, with member functions coded to the proper dispatch IDs.

<P>Excel has its own type library, found in the file Excel8.olb, usually in the \Program Files\Microsoft Office\Office directory. ClassWizard can read this file&#151;exactly as it reads TLB files&#151;to create C++ driver classes for individual Excel objects. It makes sense to select the objects you need and then combine the classes into a single pair of files, as shown in Figure 
25-11.

<P><img src="f25og11.gif" width=335 height=353 border="0">

<P><!-- caption --><B>Figure 25-11.</B> <I>ClassWizard can create C++ classes for the Excel objects listed in Excel8.olb.</I><!-- /caption -->

<P>You might need to edit the generated code to suit your needs. Let's look at an example. If you use ClassWizard to generate a driver class for the <I>Worksheet</I> object, you get a <I>GetRange</I> member function, as shown here:

<P><pre>
LPDISPATCH _Worksheet::GetRange(const VARIANT&amp; Cell1,
                                const VARIANT&amp; Cell2)
{
    LPDISPATCH result;
    static BYTE parms[] = VTS_VARIANT VTS_VARIANT;
    InvokeHelper(0xc5, DISPATCH_PROPERTYGET, VT_DISPATCH,
        (void*)&amp;result, parms, &amp;Cell1, &amp;Cell2);
    return result;
}
</pre>

<P>You know (from the Excel VBA documentation) that you can call the method with either a single cell (one parameter) or a rectangular area specified by two cells (two parameters). Remember: you can omit optional parameters in a call to <I>InvokeHelper</I>. Now it makes sense to add a second overloaded <I>GetRange</I> function with a single cell parameter like this:

<P><pre>
LPDISPATCH _Worksheet::GetRange(const VARIANT&amp; Cell1) // added
{
    LPDISPATCH result;
    static BYTE parms[] = VTS_VARIANT;
    InvokeHelper(0xc5, DISPATCH_PROPERTYGET, VT_DISPATCH,
        (void*)&amp;result, parms, &amp;Cell1);
    return result;
}
</pre>

<P>How do you know which functions to fix up? They're the functions you decide to use in your program. You'll have to read the Excel VBA reference manual to figure out the required parameters and return values. Perhaps someday soon someone will write a set of C++ Excel controller classes.

<P>The EX25D program uses the Excel objects and contains the corresponding classes shown in the table below. All the code for these objects is contained in the files excel8.h and excel8.cpp.

<p><table cellpadding=5 width="95%">
<tr><td valign="top"><b>Object/Class</b></td>
<td valign="top"><b>View Class Data Member</b></td></tr>
<tr><td valign="top"><I>_Application</I></td>
<td valign="top"><I>m_app</I></td></tr>
<tr><td valign="top"><I>Range</I></td>
<td valign="top"><I>m_range[5]</I></td></tr>
<tr><td valign="top"><I>_Worksheet</I></td>
<td valign="top"><I>m_worksheet</I></td></tr>
<tr><td valign="top"><I>Workbooks</I></td>
<td valign="top"><I>m_workbooks</I></td></tr>
<tr><td valign="top"><I>Worksheets</I></td>
<td valign="top"><I>m_worksheets</I></td></tr>
</table>

<P>The following view member function, <I>OnExceloleLoad</I>, handles the Excel Comp Load menu command. This function must work if the user already has Excel running on the desktop. The COM 
<I>GetActiveObject</I> function tries to return an <I>IUnknown</I> pointer for Excel. <I>GetActiveObject</I> requires a class ID, so we must first call <I>CLSIDFromProgID</I>. If 
<I>GetActiveObject</I> is successful, we call <I>QueryInterface</I> to get an <I>IDispatch</I> pointer and we attach it to the view's <I>m_app </I>controller object of class _<I>Application</I>. If <I>GetActiveObject</I> is unsuccessful, we call <I>COleDispatchDriver::CreateDispatch</I>, as we did for the other components.

<P><pre>
void CEx25dView::OnExceloleLoad() 
{   // If Excel is already running, attach to it; otherwise, start it
    LPDISPATCH pDisp;
    LPUNKNOWN pUnk;
    CLSID clsid;
    TRACE(&quot;Entering CEx25dView::OnExcelLoad\n&quot;);
    BeginWaitCursor();
    ::CLSIDFromProgID(L&quot;Excel.Application.8&quot;, &amp;clsid); // from Registry
    if(::GetActiveObject(clsid, NULL, &amp;pUnk) == S_OK) {
        VERIFY(pUnk-&gt;QueryInterface(IID_IDispatch, 
              (void**) &amp;pDisp) == S_OK);
        m_app.AttachDispatch(pDisp);
        pUnk-&gt;Release();
        TRACE(&quot; attach complete\n&quot;);
    } 
    else {
        if(!m_app.CreateDispatch(&quot;Excel.Application.8&quot;)) {
            AfxMessageBox(&quot;Excel 97 program not found&quot;);
        }
        TRACE(&quot; create complete\n&quot;);
    }
    EndWaitCursor();
}
</pre>

<P><I>OnExceloleExecute</I> is the command handler for the Execute item in the Excel Comp menu. Its first task is to find the Excel main window and bring it to the top. We must write some Windows code here because a method for this purpose couldn't be found. We must also create a workbook if no workbook is currently open.

<P>We have to watch our method return values closely. The <I>Workbooks Add</I> method, for example, returns an <I>IDispatch</I> pointer for a <I>Workbook</I> object and, of course, increments the reference count. If we generated a class for <I>Workbook</I>, we could call <I>COleDispatchDriver::AttachDispatch</I> so that <I>Release</I> would be called when the <I>Workbook</I> object was destroyed. Because we don't need a <I>Workbook</I> class, we'll simply release the pointer at the end of the function. If we don't properly clean up our pointers, we might get memory-leak messages from the Debug version of MFC.

<P>The rest of the <I>OnExceloleExecute</I> function accesses the cells in the worksheet. It's easy to get and set numbers, dates, strings, and formulas. The C++code is similar to the VBA code you would write to do the same job.

<P><pre>
void CEx25dView::OnExceloleExecute() 
{
   LPDISPATCH pRange, pWorkbooks;
    
   CWnd* pWnd = CWnd::FindWindow(&quot;XLMAIN&quot;, NULL);
   if (pWnd != NULL) {
     TRACE(&quot;Excel window found\n&quot;);
     pWnd-&gt;ShowWindow(SW_SHOWNORMAL);
     pWnd-&gt;UpdateWindow();
     pWnd-&gt;BringWindowToTop();
   }

   m_app.SetSheetsInNewWorkbook(1);
   
   VERIFY(pWorkbooks = m_app.GetWorkbooks());
   m_workbooks.AttachDispatch(pWorkbooks);

   LPDISPATCH pWorkbook = NULL;
   if (m_workbooks.GetCount() == 0) {
      // Add returns a Workbook pointer, but we
      //  don't have a Workbook class
      pWorkbook = 
m_workbooks.Add(); // Save the pointer for
                                     //  later release
   }
   LPDISPATCH pWorksheets = 
m_app.GetWorksheets();
   ASSERT(pWorksheets != NULL);
   m_worksheets.AttachDispatch(pWorksheets);
   LPDISPATCH pWorksheet = 
m_worksheets.GetItem(COleVariant((short) 1));

   m_worksheet.AttachDispatch(pWorksheet);
   m_worksheet.Select();

   VERIFY(pRange = m_worksheet.GetRange(COleVariant(&quot;A1&quot;)));
   m_range[0].AttachDispatch(pRange);

   VERIFY(pRange = m_worksheet.GetRange(COleVariant(&quot;A2&quot;)));
   m_range[1].AttachDispatch(pRange);
   
   VERIFY(pRange = m_worksheet.GetRange(COleVariant(&quot;A3&quot;)));
   m_range[2].AttachDispatch(pRange);

   VERIFY(pRange = m_worksheet.GetRange(COleVariant(&quot;A3&quot;), 
        COleVariant(&quot;C5&quot;)));
   m_range[3].AttachDispatch(pRange);

   VERIFY(pRange = m_worksheet.GetRange(COleVariant(&quot;A6&quot;)));
    m_range[4].AttachDispatch(pRange);

    m_range[4].SetValue(COleVariant(COleDateTime
                                    (1998, 4, 24, 15, 47, 8)));
    // Retrieve the stored date and print it as a string
    COleVariant vaTimeDate = 
m_range[4].GetValue();
    TRACE(&quot;returned date type = %d\n&quot;, vaTimeDate.vt);
    COleVariant vaTemp;
    vaTemp.ChangeType(VT_BSTR, &amp;vaTimeDate);
    CString str = vaTemp.bstrVal;
    TRACE(&quot;date = %s\n&quot;, (const char*) str);

    m_range[0].SetValue(COleVariant(&quot;test string&quot;));

    COleVariant vaResult0 = 
m_range[0].GetValue();
    if (vaResult0.vt == VT_BSTR) {
        CString str = vaResult0.bstrVal;
        TRACE(&quot;vaResult0 = %s\n&quot;, (const char*) str);
    }

    m_range[1].SetValue(COleVariant(3.14159));
    
    COleVariant vaResult1 = 
m_range[1].GetValue();
    if (vaResult1.vt == VT_R8) {
        TRACE(&quot;vaResult1 = %f\n&quot;, vaResult1.dblVal);
    }

    m_range[2].SetFormula(COleVariant(&quot;=$A2*2.0&quot;));

    COleVariant vaResult2 = 
m_range[2].GetValue();
    if (vaResult2.vt == VT_R8) {
        TRACE(&quot;vaResult2 = %f\n&quot;, vaResult2.dblVal);
    }

    COleVariant vaResult2a = 
m_range[2].GetFormula();
    if (vaResult2a.vt == VT_BSTR) {
        CString str = vaResult2a.bstrVal;
        TRACE(&quot;vaResult2a = %s\n&quot;, (const char*) str);
    }

    m_range[3].FillRight();
    m_range[3].FillDown();

    // cleanup  
    if (pWorkbook != NULL) {
        pWorkbook-&gt;Release();
    }
}
</pre>

<A NAME="545"><H2><B>The EX25E Automation Client Example</B></H2></A>
<P>This program uses the new <I>#import</I> directive to generate smart pointers. It behaves just like EX25D except that it doesn't run Excel. The <I>#import</I> statements are in the StdAfx.h file to minimize the number of times the compiler has to generate the driver classes. Here is the added code:

<P><pre>
#include &lt;afxdisp.h&gt;

#import &quot;..\ex25a\debug\ex25a.tlb&quot; rename_namespace(&quot;BankDriv&quot;) 
using namespace BankDriv;

#import &quot;..\ex25b\debug\ex25b.tlb&quot; rename_namespace(&quot;Ex25bDriv&quot;) 
using namespace Ex25bDriv;

#import &quot;..\ex25c\debug\ex25c.tlb&quot; rename_namespace(&quot;ClockDriv&quot;)
using namespace ClockDriv;
</pre>

<P>And of course you'll need to call <I>AfxOleInit</I> in your application class <I>InitInstance</I> member function.

<P>The view class header contains embedded smart pointers as shown:

<P><pre>
IEx25bAutoPtr m_auto;
IBankPtr m_bank;
IEx25cPtr m_clock;
IAlarmPtr m_alarm;
</pre>

<P>Here is the code for the view class menu command handlers:

<P><pre>
void CEx25eView::OnBankoleLoad() 
{
    if(m_bank.CreateInstance(__uuidof(Bank)) != S_OK) {
        AfxMessageBox(&quot;Bank component not found&quot;);
        return;
    }
}

void CEx25eView::OnUpdateBankoleLoad(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_bank.GetInterfacePtr() == NULL);
}

void CEx25eView::OnBankoleTest() 
{
    try {
        m_bank-&gt;Deposit(20.0);
        m_bank-&gt;Withdrawal(15.0);
        TRACE(&quot;new balance = %f\n&quot;, 
m_bank-&gt;GetBalance());
    } catch(_com_error&amp; e) {
        AfxMessageBox(e.ErrorMessage());
    }
}

void CEx25eView::OnUpdateBankoleTest(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_bank.GetInterfacePtr() != NULL);
}

void CEx25eView::OnBankoleUnload() 
{
    m_bank.Release();
}

void CEx25eView::OnUpdateBankoleUnload(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_bank.GetInterfacePtr() != NULL);
}

void CEx25eView::OnClockoleCreatealarm() 
{
    CAlarmDialog dlg;
    try {
        if (dlg.DoModal() 
== IDOK) {
            COleDateTime dt(1995, 12, 23, dlg.
m_nHours, dlg.m_nMinutes, 
                dlg.
m_nSeconds);
            LPDISPATCH pAlarm = m_clock-&gt;CreateAlarm(dt);
            
m_alarm.Attach((IAlarm*) pAlarm);  // releases prior object!
            
m_clock-&gt;RefreshWin();
        }
    } catch(_com_error&amp; e) {
        AfxMessageBox(e.ErrorMessage());
    }
}

void CEx25eView::OnUpdateClockoleCreatealarm(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_clock.GetInterfacePtr() != NULL);
}

void CEx25eView::OnClockoleLoad() 
{
    if(m_clock.CreateInstance(_
_uuidof(Document)) != S_OK) {
        AfxMessageBox(&quot;Clock component not found&quot;);
        return;
    }
    try {
        m_clock-&gt;PutFigure(0, COleVariant(&quot;XII&quot;));
        m_clock-&gt;PutFigure(1, COleVariant(&quot;III&quot;));
        m_clock-&gt;PutFigure(2, COleVariant(&quot;VI&quot;));
        m_clock-&gt;PutFigure(3, COleVariant(&quot;IX&quot;));
        OnClockoleRefreshtime();
        m_clock-&gt;ShowWin();
    } catch(_com_error&amp; e) {
        AfxMessageBox(e.ErrorMessage());
    }
}

void CEx25eView::OnUpdateClockoleLoad(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_clock.GetInterfacePtr() == NULL);
}

void CEx25eView::OnClockoleRefreshtime() 
{
    COleDateTime now = COleDateTime::GetCurrentTime();
    try {
        m_clock-&gt;PutTime(now);
        m_clock-&gt;RefreshWin();
    } catch(_com_error&amp; e) {
        AfxMessageBox(e.ErrorMessage());
    }
}

void CEx25eView::OnUpdateClockoleRefreshtime(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_clock.GetInterfacePtr() != NULL);
}

void CEx25eView::OnClockoleUnload() 
{
    m_clock.Release();
}

void CEx25eView::OnUpdateClockoleUnload(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_clock.GetInterfacePtr() != NULL);
}

void CEx25eView::OnDlloleGetdata() 
{
    try {
        m_auto-&gt;DisplayDialog();
        COleVariant vaData = 
m_auto-&gt;GetTextData();
        ASSERT(vaData.vt == VT_BSTR);
        CString strTextData = vaData.bstrVal;
        long lData = 
m_auto-&gt;GetLongData();
        TRACE(&quot;CEx25dView::OnDlloleGetdata&#151;long = %ld, text = %s\n&quot;,
              lData, strTextData);
    } catch(_com_error&amp; e) {
        AfxMessageBox(e.ErrorMessage());
    }
}

void CEx25eView::OnUpdateDlloleGetdata(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_auto.GetInterfacePtr() != NULL);
}

void CEx25eView::OnDlloleLoad() 
{
    if(m_auto.CreateInstance(__uuidof(Ex25bAuto)) != S_OK) {
        AfxMessageBox(&quot;Ex25bAuto component not found&quot;);
        return;
    }
}

void CEx25eView::OnUpdateDlloleLoad(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_auto.GetInterfacePtr() == NULL);
}

void CEx25eView::OnDlloleUnload() 
{
    m_auto.Release();
}

void CEx25eView::OnUpdateDlloleUnload(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(m_auto.GetInterfacePtr() != NULL);
}
</pre>

<P>Note the use of the <I>try/catch</I> blocks in the functions that manipulate the components. These are particularly necessary for processing errors that occur when a component program stops running. In the previous example, EX25D, the MFC <I>COleDispatchDriver</I> class took care of this detail.

</BODY>
</HTML>


