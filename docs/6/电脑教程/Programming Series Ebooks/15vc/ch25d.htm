<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Microsoft Excel -- A Better Visual Basic than Visual Basic</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="528"><P><H1><B>Microsoft Excel&#151;A Better Visual Basic than Visual Basic</B></H1></A>
<P>At the time that the first three editions of this book were written, Visual Basic worked as an Automation client, but you couldn't use it to create an Automation component. Since version 5.0, Visual Basic lets you write components too, even ActiveX controls. We originally used Excel instead of VB because Excel was the first Microsoft application to support VBA syntax and it could serve as both a client and a component. We decided to stick with Excel because C++ programmers who look down their noses at Visual Basic might be inclined to buy Excel (if only to track their software royalties).

<P>We strongly recommend that you get a copy of Excel 97 (or a later version). This is a true 32-bit application and a part of the Microsoft Office suite. With this version of Excel, you can write VBA code in a separate location that accesses worksheet cells in an object-oriented manner. Adding visual 
programming elements&#151;such as pushbuttons&#151;is easy. Forget all you ever knew about the old spreadsheet programs that forced you to wedge macro code inside cells.

<P>This chapter isn't meant to be an Excel tutorial, but we've included a simple Excel workbook. (A <U>workbook</U> is a file that can contain multiple worksheets plus separate VBA code.) This workbook demonstrates a VBA macro that executes from a pushbutton. You can use Excel to load Demo.xls from the 
\vcpp32\ex25a subdirectory, or you can key in the example from scratch. Figure 25-1 shows the actual spreadsheet with the button and sample data.

<P>In this spreadsheet, you highlight cells A4 through A9 and click the Process Col button. A VBA program iterates down the column and draws a hatched pattern on cells with numeric values greater than 10.

<P>Figure 25-2 shows the macro code itself, which is &quot;behind&quot; the worksheet. In Excel 97, choose Macro from the Tools menu, and then choose Visual Basic Editor. (Alt-F11 is the shortcut.) As you can see, you're working in the standard VBA 5.0 environment at this point.

<P><A HREF="javascript:fullSize('f25og01x.htm')"> <img src="F25og01.jpg" width=404 height=300 border=0 ALT = "Click to view at full size."> </A>

<P><!-- caption --><B>Figure 25-1.</B> <I>An Excel spreadsheet that uses VBA code.</I><!-- /caption -->
<P>&nbsp;

<P><A HREF="javascript:fullSize('f25og02x.htm')"> <img src="f25og02.jpg" width=404 height=229 border=0 ALT = "Click to view at full size."> </A>

<P><!-- caption --><B>Figure 25-2.</B> <I>The VBA code for the Excel spreadsheet.</I><!-- /caption -->
<P>&nbsp;

<P>If you want to create the example yourself, follow these steps:

<ol>
<P><LI>Start Excel with a new workbook, press Alt-F11, and then double-click Sheet1 in the top left window.
<P><LI>Type in the macro code shown in Figure 25-2.
<P><LI>Return to the Excel window by choosing Close And Return To Microsoft Excel from the File menu. Choose Toolbars from the View menu. Check Forms to display the Forms toolbar. (You can also access the list of toolbars by right-clicking on any existing toolbar.)
<P><LI>Click the Button control, and then create the pushbutton by dragging the mouse in the upper-left corner of the worksheet. Assign the button to the <I>Sheet1.ProcessColumn</I> macro.
<P><LI>Size the pushbutton, and type the caption <I>Process Col</I>, as shown in Figure 25-1.
<P><LI>Type some numbers in the column starting at cell A4. Select the cells containing these numbers, and then click the button to test the program.
</ol>

<P>Pretty easy, isn't it?
<P>Let's analyze an Excel VBA statement from the macro above:

<P><pre>
Selection.Offset(1, 0).Range(&quot;A1&quot;).Select
</pre>

<P>The first element, Selection, is a <U>property</U> of an implied <U>object</U>, the Excel 
application. The Selection property in this case is assumed to be a <I>Range</I> object that represents a rectangular array of cells. The second element, Offset, is a property of the <I>Range</I> object that returns another <I>Range</I> object based on the two parameters. In this case, the returned <I>Range</I> object is the one-cell range that begins one row down from the original range. The third element, Range, is a property of the <I>Range</I> object that returns yet another range. This time it's the upper-left cell in the second range. Finally, the <I>Select</I> <U>method</U> causes Excel to highlight the selected cell and makes it the new Selection property of the application.
<P>As the program iterates through the loop, the preceding statement moves the selected cell down the worksheet one row at a time. This style of programming takes some getting used to, but you can't afford to ignore it. The real value here is that you now have all the capabilities of the Excel spreadsheet and graphics engine available to you in a seamless programming environment.

</BODY>
</HTML>



