<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>How Virtual Memory Works</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="203"><H1>How Virtual Memory Works</H1></A>
<P>You know that your computer doesn't really have hundreds of gigabytes of RAM. And it doesn't have hundreds of gigabytes of disk space either. Windows uses some smoke and mirrors here.
<P>First of all, a process's 4-GB address space is going to be used sparsely. Various programs and data elements will be scattered throughout the 4-GB address space in 4-KB units starting on 4-KB boundaries. Each 4-KB unit, called a <U>page</U>, can hold either code or data. When a page is being used, it 
occupies physical memory, but you never see its physical memory address. The 
Intel microprocessor chip efficiently maps a 32-bit virtual address to both a 
physical page and an offset within the page, using two levels of 4-KB page tables, as shown in Figure 10-2. Note that individual pages can be flagged as either read-only or read/write. Also note that each process has its own set of page tables. The chip's CR3 register holds a pointer to the directory page, so when Windows switches from one process to another, it simply updates CR3.
<P><A HREF="javascript:fullSize('F10OG02x.htm')"> <img src="F10OG02.JPG" width=404 height=321 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 10-2.</B> <I>Win32 virtual memory management (Intel).</I>
<!-- /caption -->
<P>So now our process is down from 4 GB to maybe 5 MB&#151;a definite improvement. But if we're running several programs, along with Windows itself, 
we'll still run out of RAM. If you look at Figure 10-2 again, you'll notice that the page table entry has a &quot;present&quot; bit that indicates whether the 4-KB page is currently in RAM. If we try to access a page that's not in RAM, an interrupt fires and Windows analyzes the situation by checking its internal tables. If the memory reference was bogus, we'll get the dreaded &quot;page fault&quot; message and the program will exit. Otherwise, Windows reads the page from a disk file into RAM and updates the page table by loading the physical address and setting the present bit. This is the essence of Win32 virtual memory.
<P>The Windows virtual memory manager figures out how to read and write 4-KB pages so that it optimizes performance. If one process hasn't used a page for a while and another process needs memory, the first page is swapped out or discarded and the RAM is used for the new process's page. Your program isn't normally aware that this is going on. The more disk I/O that happens, however, the worse your program's performance will be, so it stands to reason that more RAM is better.
<P>I mentioned the word &quot;disk,&quot; but I haven't talked about files yet. All processes share a big systemwide <U>swap</U> <U>file</U> that's used for all read/write data and some read-only data. (Windows NT supports multiple swap files.) Windows determines the swap file size based on available RAM and free disk space, but there are ways to fine-tune the swap file's size and specify its physical location on disk.
<P>The swap file isn't the only file used by the virtual memory manager, however. It wouldn't make sense to write code pages back to the swap file, so 
instead of using the swap file, Windows maps EXE and DLL files directly to their files on disk. Because the code pages are marked read-only, there's never a need to write them back to disk.
<P>If two processes use the same EXE file, that file is mapped into each process's address space. The code and constants never change during program 
execution, so the same physical memory can be mapped for each process. The two 
processes cannot share global data, however, and Windows 95 and Windows NT 
handle this situation differently. Windows 95 maps separate copies of the global data to each process. In Windows NT, both processes use the same copy of each page of global data until one process attempts to write to that page. At that point the page is copied; as a result, each process has its own private copy stored at the same virtual address.
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
A dynamic link library can be mapped directly to its DLL file only if the DLL can be loaded at its designated base address. If a DLL were statically linked to load at, say, 0x10000000 but that address range is already occupied by another DLL, Windows must &quot;fix up&quot; the addresses within the DLL code. Windows NT copies the altered pages to the swap file when the DLL is first loaded, but Windows 95 can do the fixup &quot;on the fly&quot; when the pages are brought into RAM. Needless to say, it's important to build your DLLs with nonoverlapping address ranges. If you're using the MFC DLLs, set the base address of your own DLLs outside the range 0x5F400000 through 0x5FFFFFFF. <A HREF="ch22a.htm">Chapter 22</A> provides more details on writing DLLs.
</BLOCKQUOTE></DIV>
<P>Memory-mapped files, which I'll talk about later, are also mapped directly. These can be flagged as read/write and made available for sharing among processes.
<P>
<DIV CLASS="Note">
<BLOCKQUOTE>
<B>For Win32 Programmers: Segment Registers in Win32</B><P>
If you've experimented with the debugger in Win32, you may have noticed the <U>segment</U> <U>registers</U>, particularly CS, DS, and SS. These 16-bit relics haven't gone away, but you can mostly ignore them. In 32-bit mode, the Intel microprocessor still uses segment registers, which are 16 bits long, to translate addresses prior to sending them through the virtual memory system. A table in RAM, called the <U>descriptor</U> <U>table</U>, has entries that contain the virtual memory base address and block size for code, data, and stack segments. In 32-bit mode, these segments can be up to 4 GB in size and can be flagged as read-only or read/write. For every memory reference, the chip uses the <U>selector</U>, the contents of a segment register, to look up the descriptor table entry for the purpose of translating the address.
<P>Under Win32, each process has two segments&#151;one for code and one for data and the stack. You can assume that both have a base value of 0 and a size of 4 GB, so they overlap. The net result is no translation at all, but Windows uses some tricks that exclude the bottom 16 KB from the data segment. If you try to access memory down there, you get a protection fault instead of a page fault, which is useful for debugging null pointers.
<P>Some future operating system might someday use segments to get around that annoying 4-GB size limitation, but by then we'll have Win64 to worry about!
</BLOCKQUOTE></DIV>
<P>
</BODY>
</HTML>



