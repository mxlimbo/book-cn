<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Enhancing the Dialog Program</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="139"><H1>Enhancing the Dialog Program</H1></A><P>The EX06A program required little coding for a lot of functionality. Now we'll make a new version of this program that uses some hand-coding to add extra features. We'll eliminate EX06A's rude habit of dumping the user in response to a press of the Enter key, and we'll hook up the scroll bar controls.
<A NAME="140"><H2>Taking Control of the <I>OnOK</I> Exit</H2></A><P>In the original EX06A program, the <I>CDialog::OnOK</I> virtual function handled the OK button, which triggered data exchange and the exit from the dialog. Pressing the Enter key happens to have the same effect, and that might or might not be what you want. If the user presses Enter while in the Name edit control, for example, the dialog closes immediately.
<P>What's going on here? When the user presses Enter, Windows looks to see which pushbutton has the <U>input</U> 
<U>focus</U>, as indicated on the screen by a dotted rectangle. If no button has the focus, Windows looks for the <U>default</U> <U>pushbutton</U> that the program or the resource specifies. (The default pushbutton has a thicker border.) If the dialog has no default button, the virtual <I>OnOK</I> function is called, even if the dialog does not contain an OK button.
<P>You can disable the Enter key by writing a do-nothing <I>CEx06aDialog::OnOK</I> function and adding the exit code to a new function that responds to clicking the OK button. Here are the steps:<P>
<OL>
<B><LI>Use ClassWizard to &quot;map&quot; the IDOK button to the virtual 
<I>OnOK</I> function.</B>  In ClassWizard, choose <I>IDOK</I> from the <I>CEx06aDialog</I> Object IDs list, and then double-click on BN_CLICKED. This generates the prototype and skeleton for <I>OnOK</I>.
<P><B><LI>Use the dialog editor to change the OK button ID.</B>  Select the OK 
button, change its ID from <I>IDOK</I> to <I>IDC_OK</I>, and then uncheck its 
Default Button property. Leave the <I>OnOK</I> function alone.
<P><B><LI>Use ClassWizard to create a member function called <I>OnClickedOk</I>.</B>  This <I>CEx06aDialog</I> class member function is keyed to the BN<I>_</I>CLICKED message from the newly renamed control <I>IDC_OK</I>.
<P><B><LI>Edit the body of the <I>OnClickedOk</I> function in ex06aDialog.cpp.</B>  This function calls the base class <I>OnOK</I> function, as did the original <I>CEx06aDialog::OnOK</I> function. Here is the code:
<P>
<PRE>void CEx06aDialog::OnClickedOk()
{
    <B>TRACE(&quot;CEx06aDialog::OnClickedOk\n&quot;);
    CDialog::OnOK();</B> 
}
</PRE><P>
<B><LI>Edit the original <I>OnOK</I> function in ex06aDialog.cpp.</B> This function is a &quot;leftover&quot; handler for the old <I>IDOK</I> button. Edit the code as shown here:<P>
<PRE>void CEx06aDialog::OnOK()
{
    <B>// dummy OnOK function -- do NOT call CDialog::OnOK()
    TRACE(&quot;CEx06aDialog::OnOK\n&quot;);</B> 
}
</PRE><P>
<B><LI>Build and test the application.</B> Try pressing the Enter key now. 
Nothing should happen, but <I>TRACE</I> output should appear in the Debug 
window. Clicking the OK button should exit the dialog as before, however.
<P>
</OL>
<DIV CLASS=note>
<BLOCKQUOTE>
<B>For Win32 Programmers</B> <P>
Dialog controls send WM<B><I>_</I></B> COMMAND <U>notification</U> <U>messages</U> to their parent dialogs. For a single button click, for example, the bottom 16 bits of <I>wParam</I> contain the button ID, the top 16 bits of <I>wParam</I> contain the BN_CLICKED notification code, and <I>lParam</I> contains the button handle. Most window procedure functions process these notification messages with a nested switch statement. MFC &quot;flattens out&quot; the message processing logic by &quot;promoting&quot; control notification messages to the same level as other Windows messages.
<P>For a Delete button (for example), ClassWizard generates notification message map entries similar to these:<P>
<PRE>ON_BN_CLICKED(IDC_DELETE, OnDeleteClicked)
ON_BN_DOUBLECLICKED(IDC_DELETE, OnDeleteDblClicked)
</PRE><P>Button events are special because they generate <U>command</U> <U>messages</U> if your dialog class doesn't have notification handlers like the ones above. As <A HREF="ch13a.htm">Chapter 13</A> explains, the application framework &quot;routes&quot; these command messages to various objects in your application. You could also map the control notifications with a more generic 
<I>ON<B>_</B> COMMAND</I> message-handling entry like this:<P>
<PRE>ON_COMMAND(IDC_DELETE, OnDelete)</PRE>
<P>In this case, the <I>OnDelete</I> function is unable to distinguish between a single click and a double click, but that's no problem because few Windows-based programs utilize double clicks for buttons.
</BLOCKQUOTE></DIV>

<A NAME="141"><H2><I>OnCancel</I> Processing</H2></A><P>Just as pressing the Enter key triggers a call to <I>OnOK</I>, pressing the Esc key triggers a call to <I>OnCancel</I>, which results in an exit from the dialog with a <I>DoModal</I> return code of <I>IDCANCEL</I>. EX06A does no special processing 
for <I>IDCANCEL</I>; therefore, pressing the Esc key (or clicking the Close 
button) closes the dialog. You can circumvent this process by substituting a 
dummy <I>OnCancel</I> function, following approximately the same procedure you used for the OK button.
<A NAME="142"><H2>Hooking Up the Scroll Bar Controls</H2></A><P>The dialog editor allows you to include scroll bar controls in your dialog, and ClassWizard lets you add integer data members. You must add code to make the Loyalty and Reliability scroll bars work.
<P>Scroll bar controls have position and range values that can be read and written. If you set the range to (0, 100), for example, a corresponding data member with a value of 50 positions the scroll box at the center of the bar. 
(The function <I>CScrollBar::SetScrollPos</I> also sets the scroll box position.) The scroll bars send the WM<B><I>_</I></B> HSCROLL and 
WM<B><I>_</I></B> VSCROLL messages to the dialog when the user drags the scroll box or clicks the arrows. The dialog's message handlers must decode these messages and position the scroll box accordingly.
<P>Each control you've seen so far has had its own individual message handler function. Scroll bar controls are different because all horizontal scroll bars in a dialog are tied to a single WM_HSCROLL message handler and all vertical scroll bars are tied to a single WM_VSCROLL handler. Because this monster dialog contains two horizontal scroll bars, the single WM<B><I>_</I></B> HSCROLL message handler must figure out which scroll bar sent the scroll message.
<P>Here are the steps for adding the scroll bar logic to EX06A:<P>
<OL>
<B><LI>Add the class <I>enum</I> statements for the minimum and maximum scroll range.</B>  In ex06aDialog.h, add the following lines at the top of the class declaration:<P>
<PRE><B>enum { nMin = 0 };
enum { nMax = 100 };</B> 
</PRE>
<P><B><LI>Edit the <I>OnInitDialog</I> function to initialize the scroll ranges.</B>  In the <I>OnInitDialog</I> function, we'll set the minimum and the maximum scroll values such that the <I>CEx06aDialog</I> data members represent 
percentage values. A value of 100 means &quot;Set the scroll box to the extreme right&quot;; a value of 0 means &quot;Set the scroll box to the extreme left.&quot;
<P>Add the following code to the <I>CEx06aDialog</I> member function 
<I>OnInitDialog</I> in the file ex06aDialog.cpp:<P>
<PRE><B>CScrollBar* pSB = (CScrollBar*) GetDlgItem(IDC_LOYAL);
pSB-&gt;SetScrollRange(nMin, nMax);

pSB = (CScrollBar*) GetDlgItem(IDC_RELY);
pSB-&gt;SetScrollRange(nMin, nMax);</B> 
</PRE>
<P><B><LI>Use ClassWizard to add a scroll bar message handler to <I>CEx06aDialog</I>.</B> Choose the WM<I>_</I>HSCROLL message, and then add the 
member function <I>OnHScroll</I>. Enter the following boldface code:
<P>
<PRE>void CEx06aDialog::OnHScroll(UINT nSBCode, UINT nPos,
                             CScrollBar* pScrollBar)
{
    <B>int nTemp1, nTemp2;

    nTemp1 = pScrollBar-&gt;GetScrollPos();
    switch(nSBCode) {
    case SB_THUMBPOSITION:
        pScrollBar-&gt;SetScrollPos(nPos);
        break;
    case SB_LINELEFT: // left arrow button
        nTemp2 = (nMax - nMin) / 10;
        if ((nTemp1 - nTemp2) &gt; nMin) {
            nTemp1 -= nTemp2;
        }
        else {
            nTemp1 = nMin;
        }
        pScrollBar-&gt;SetScrollPos(nTemp1);
        break;
    case SB_LINERIGHT: // right arrow button
        nTemp2 = (nMax - nMin) / 10;
        if ((nTemp1 + nTemp2) &lt; nMax) {
            nTemp1 += nTemp2;
        }
        else {
            nTemp1 = nMax;
        }
        pScrollBar-&gt;SetScrollPos(nTemp1);
        break;
    }</B> 
}
</PRE><P>
</OL>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
The scroll bar functions use 16-bit integers for both range and position.
</BLOCKQUOTE>
</DIV>
<OL START="4">
<B><LI>Build and test the application.</B> Build and run EX06A again. Do the scroll bars work this time? The scroll boxes should &quot;stick&quot; after you 
drag them with the mouse, and they should move when you click the scroll bars' arrows. (Notice that we haven't added logic to cover the user's click on the scroll bar itself.)
</OL>
</BODY>
</HTML>



