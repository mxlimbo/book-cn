<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Winsock</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="876"><H1>Winsock</H1></A><P>Winsock is the lowest level Windows API for TCP/IP programming. Part 
of the code is located in wsock32.dll (the exported functions that your 
program calls), and part is inside the Windows kernel. You can write both internet 
server programs and internet client programs using the Winsock API. This API is 
based on the original Berkely Sockets API for UNIX. A new and much more 
complex version, Winsock 2, is included for the first time with Windows NT 
4.0, but we'll stick with the old version because it's the current standard for 
both Windows NT, Windows 95, and Windows 98.
<A NAME="877"><H2>Synchronous vs. Asynchronous Winsock Programming</H2></A><P>Winsock was introduced first for Win16, which did not support 
multithreading. Consequently, most developers used Winsock in the 
<U>asynchronous</U> mode. In that mode, all sorts of hidden windows and 
<I>PeekMessage</I> calls enabled single-threaded programs to make Winsock send and receive calls without blocking, thus 
keeping the user interface (UI) alive. Asynchronous Winsock programs were 
complex, often implementing &quot;state machines&quot; that processed callback functions, 
trying to figure out what to do next based on what had just happened. Well, we're 
not in 16-bit land anymore, so we can do modern multithreaded programming. 
If this scares you, go back and review <A HREF="ch12a.htm">Chapter 12</A>. Once you get used 
to multithreaded programming, you'll love it.
<P>In this chapter, we will make the most of our Winsock calls from 
worker threads so that the program's main thread is able to carry on with the 
UI. The worker threads contain nice, sequential logic consisting of 
blocking Winsock calls.
<A NAME="878"><H2>The MFC Winsock Classes</H2></A><P>We try to use MFC classes where it makes sense to use them, but the 
MFC developers informed us that the 
<I>CAsyncSocket</I> and <I>CSocket</I> classes were 
not appropriate for 32-bit synchronous programming. The Visual 
C++ online help says you can use <I>CSocket</I> for synchronous programming, but if you look at 
the source code you'll see some ugly message-based code left over from 
Win16.
<A NAME="879"><H2>The Blocking Socket Classes</H2></A><P>Since we couldn't use MFC, we had to write our own Winsock 
classes. <I>CBlockingSocket</I> is a thin wrapping of the Winsock API, designed only 
for synchronous use in a worker thread. The only fancy features are 
exception-throwing on errors and time-outs for sending and receiving data. The 
exceptions help you write cleaner code because you don't need to have error tests after 
every Winsock call. The time-outs (implemented with the Winsock 
<I>select</I> function) prevent a communication fault from blocking a thread indefinitely.
<P><I>CHttpBlockingSocket</I> is derived from 
<I>CBlockingSocket</I> and provides functions for reading HTTP data. 
<I>CSockAddr</I> and 
<I>CBlockingSocketException</I> are helper classes.
<A NAME="880"><H3>The <I>CSockAddr</I> Helper Class</H3></A><P>Many Winsock functions take socket address parameters. As you might 
remember, a socket address consists of a 32-bit IP address plus a 16-bit port 
number. The actual Winsock type is a 16-byte 
<I>sockaddr_in</I> structure, which looks like this:
<P><PRE>struct sockaddr_in {
    short   sin_family;
    u_short sin_port;
    struct  in_addr sin_addr;
    char    sin_zero[8];
};</PRE>
<P>The IP address is stored as type <I>in_addr</I>, which looks like this:
<P><PRE>struct in_addr {
    union {
        struct { u_char s_b1,s_b2,s_b3,s_b4; } S_un_b;
        struct { u_short s_w1,s_w2; } S_un_w;
        u_long S_addr;
    } S_un;
}</PRE>
<P>These are ugly structures, so we'll derive a programmer-friendly 
C++ class from <I>sockaddr_in</I>. The file \vcpp32\ex34a\Blocksock.h on the CD-ROM 
contains the following code for doing this, with inline functions included:
<P><PRE>class CSockAddr : public sockaddr_in {
public:
    // constructors
    CSockAddr()
    { 
        sin_family = AF_INET;
        sin_port = 0;
        sin_addr.s_addr = 0; 
    } // Default
    CSockAddr(const SOCKADDR&amp; sa) { memcpy(this, &amp;sa,
        sizeof(SOCKADDR)); }
    CSockAddr(const SOCKADDR_IN&amp; sin) { memcpy(this, &amp;sin,
        sizeof(SOCKADDR_IN)); }
    CSockAddr(const ULONG ulAddr, const USHORT ushPort = 0)
    // parms are host byte ordered
    { 
        sin_family = AF_INET;
        sin_port = htons(ushPort);
        sin_addr.s_addr = htonl(ulAddr); 
    }
    CSockAddr(const char* pchIP, const USHORT ushPort = 0)  
    // dotted IP addr string
    { 
        sin_family = AF_INET;
        sin_port = htons(ushPort);
        sin_addr.s_addr = inet_addr(pchIP); 
    } // already network byte ordered
    // Return the address in dotted-decimal format
    CString DottedDecimal()
        { return inet_ntoa(sin_addr); } 
    // constructs a new CString object
    // Get port and address (even though they're public)
    USHORT Port() const
        { return ntohs(sin_port); }
    ULONG IPAddr() const
        { return ntohl(sin_addr.s_addr); }
    // operators added for efficiency
    const CSockAddr&amp; operator=(const SOCKADDR&amp; sa)
    { 
        memcpy(this, &amp;sa, sizeof(SOCKADDR));
        return *this; 
    }
    const CSockAddr&amp; operator=(const SOCKADDR_IN&amp; sin)
    { 
        memcpy(this, &amp;sin, sizeof(SOCKADDR_IN));
        return *this; 
    }
    operator SOCKADDR()
        { return *((LPSOCKADDR) this); }
    operator LPSOCKADDR()
        { return (LPSOCKADDR) this; }
    operator LPSOCKADDR_IN()
        { return (LPSOCKADDR_IN) this; }
};</PRE>
<P>As you can see, this class has some useful constructors and 
conversion operators, which make the 
<I>CSockAddr</I> object interchangeable with the 
type <I>sockaddr_in</I> and the equivalent types 
<I>SOCKADDR_IN</I>, <I>sockaddr</I>, and 
<I>SOCKADDR</I>. There's a constructor and a member function for IP 
addresses in dotted-decimal format. The internal socket address is in network byte 
order, but the member functions all use host byte order parameters and return 
values. The Winsock functions <I>htonl</I>, 
<I>htons</I>, <I>ntohs</I>, and <I>ntohl</I> take care of the 
conversions between network and host byte order.
<A NAME="881"><H3>The <I>CBlockingSocketException</I> Class</H3></A><P>All the <I>CBlockingSocket</I> functions throw a 
<I>CBlockingSocketException</I> object when Winsock returns an error. This class is derived from the MFC 
<I>CException</I> class and thus overrides the 
<I>GetErrorMessage</I> function. This function gives 
the Winsock error number and a character string that 
<I>CBlockingSocket</I> provided when it threw the exception.
<A NAME="882"><H3>The <I>CBlockingSocket </I>Class</H3></A><P>Figure 34-9 shows an excerpt from the header file for the 
<I>CBlockingSocket</I> class.

<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>BLOCKSOCK.H</B>
<P><PRE>class CBlockingSocket : public CObject
{
    DECLARE_DYNAMIC(CBlockingSocket)
public:
    SOCKET m_hSocket;
    CBlockingSocket();  { m_hSocket = NULL; }
    void Cleanup();
    void Create(int nType = SOCK_STREAM);
    void Close();
    void Bind(LPCSOCKADDR psa);
    void Listen();
    void Connect(LPCSOCKADDR psa);
    BOOL Accept(CBlockingSocket&amp; s, LPCSOCKADDR psa);
    int Send(const char* pch, const int nSize, const int nSecs);
    int Write(const char* pch, const int nSize, const int nSecs);
    int Receive(char* pch, const int nSize, const int nSecs);
    int SendDatagram(const char* pch, const int nSize, LPCSOCKADDR psa,
        const int nSecs);
    int ReceiveDatagram(char* pch, const int nSize, LPCSOCKADDR psa,
        const int nSecs);
    void GetPeerAddr(LPCSOCKADDR psa);
    void GetSockAddr(LPCSOCKADDR psa);
    static CSockAddr GetHostByName(const char* pchName,
        const USHORT ushPort = 0);
    static const char* GetHostByAddr(LPCSOCKADDR psa);
    operator SOCKET();
        { return m_hSocket; }
};</PRE>
</TD></TR></TABLE>
<P><B>Figure 34-9.</B> <I>Excerpt from the header file for the </I>CBlockingSocket<I>class.</I>


<P>Following is a list of the 
<I>CBlockingSocket</I> member functions, starting 
with the constructor:
<UL>
<LI><B><I>Constructor</I></B>&#151;The 
<I>CBlockingSocket</I> constructor makes an 
uninitialized object. You must call the 
<I>Create</I> member function to create a Windows socket and connect it to the 
C++ object.
<P><LI><B><I>Create</I></B>&#151;This function calls the Winsock 
<I>socket</I> function and then sets the 
<I>m_hSocket</I> data member to the returned 32-bit 
<I>SOCKET</I> handle.
</UL>
<P>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>Parameter</B></TD><TD VALIGN="TOP"><B>Description</B></TD></TR>
<TR><TD VALIGN="TOP"><I>nType</I></TD><TD VALIGN="TOP">Type of socket; should be 
<I>SOCK_STREAM</I> 
(the default value) or <I>SOCK_DGRAM</I></TD></TR>
</TABLE>

<UL>
<LI><B><I>Close</I></B>&#151;This function closes an open socket by calling the 
Winsock <I>closesocket</I> function. The 
<I>Create</I> function must have been called previously. The destructor does not call this function because it 
would be impossible to catch an exception for a global object. Your 
server program can call <I>Close</I> anytime for a socket that is listening.
<LI><B><I>Bind</I></B>&#151;This function calls the Winsock 
<I>bind</I> function to bind a previously created socket to a specified socket address. Prior to 
calling <I>Listen</I>, your server program calls 
<I>Bind</I> with a socket address containing the listening port number and server's IP address. If you 
supply <I>INADDR_ANY</I> as the IP address, Winsock deciphers your 
computer's IP address.
</UL>

<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP"><B>Parameter</B></TD><TD VALIGN="TOP"><B>Description</B></TD></TR>
<TR><TD VALIGN="TOP"><I>psa</I></TD><TD VALIGN="TOP">A <I>CSockAddr</I> object or a pointer to a variable of 
type <I>sockaddr</I></TD></TR>
</TABLE>
<P>

<UL>
<LI><B><I>Listen</I></B>&#151;This TCP function calls the Winsock 
<I>listen</I> function. Your server program calls 
<I>Listen</I> to begin listening on the port specified 
by the previous <I>Bind</I> call. The function returns immediately.
<LI><B><I>Accept</I></B>&#151;This TCP function calls the Winsock 
<I>accept</I> function. Your server program calls 
<I>Accept</I> immediately after calling 
<I>Listen</I>. <I>Accept</I> returns when a client connects to the socket, sending back a 
new socket (in a <I>CBlockingSocket</I> object that you provide) that 
corresponds to the new connection.
</UL>

<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP">Parameter</TD><TD VALIGN="TOP">Description</TD></TR>
<TR><TD VALIGN="TOP"><I>s</I></TD><TD VALIGN="TOP">A reference to an existing 
<I>CBlockingSocket</I> object for which 
<I>Create</I> has not been called</TD></TR>
<TR><TD VALIGN="TOP"><I>psa</I></TD><TD VALIGN="TOP">A <I>CSockAddr</I> object or a pointer to a variable of 
type <I>sockaddr</I> for the connecting socket's address</TD></TR>
<TR><TD VALIGN="TOP">Return value</TD><TD VALIGN="TOP"><I>TRUE</I> if successful</TD></TR>
</TABLE>

<UL>
<LI><B><I>Connect</I></B>&#151;This TCP function calls the Winsock 
<I>connect</I> function. Your client program calls 
<I>Connect</I> after calling <I>Create</I>. 
<I>Connect</I> returns when the connection has been made.
</UL>

<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP">Parameter</TD><TD VALIGN="TOP">Description</TD></TR>
<TR><TD VALIGN="TOP"><I>psa</I></TD><TD VALIGN="TOP">A <I>CSockAddr</I> object or a pointer to a variable of 
type <I>sockaddr</I></TD></TR>
</TABLE>

<UL>
<LI><B><I>Send</I></B>&#151;This TCP function calls the Winsock 
<I>send</I> function after calling <I>select</I> to activate the time-out. The number of bytes 
actually transmitted by each <I>Send</I> call depends on how quickly the 
program at the other end of the connection can receive the bytes. 
<I>Send</I> throws an exception if the program at the other end closes 
the socket before it reads all the bytes.
</UL>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP">Parameter</TD><TD VALIGN="TOP">Description</TD></TR>
<TR><TD VALIGN="TOP"><I>pch</I></TD><TD VALIGN="TOP">A pointer to a buffer that contains the bytes to send</TD></TR>
<TR><TD VALIGN="TOP"><I>nSize</I></TD><TD VALIGN="TOP">The size (in bytes) of the block to send</TD></TR>
<TR><TD VALIGN="TOP"><I>nSecs</I></TD><TD VALIGN="TOP">Time-out value in seconds</TD></TR>
<TR><TD VALIGN="TOP">Return value</TD><TD VALIGN="TOP">The actual number of bytes sent</TD></TR>
</TABLE>
<UL>
<LI><B><I>
Write</I></B>&#151;This TCP function calls 
<I>Send</I> repeatedly until all the bytes are sent or until the receiver closes the socket.
</UL>

<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP">Parameter</TD><TD VALIGN="TOP">Description</TD></TR>
<TR><TD VALIGN="TOP"><I>pch</I></TD><TD VALIGN="TOP">A pointer to a buffer that contains the bytes to send</TD></TR>
<TR><TD VALIGN="TOP"><I>nSize</I></TD><TD VALIGN="TOP">The size (in bytes) of the block to send</TD></TR>
<TR><TD VALIGN="TOP"><I>nSecs</I></TD><TD VALIGN="TOP">Time-out value in seconds</TD></TR>
<TR><TD VALIGN="TOP">Return value</TD><TD VALIGN="TOP">The actual number of bytes sent</TD></TR>
</TABLE>
<UL>
<LI><B><I>Receive</I></B>&#151;This TCP function calls the Winsock 
<I>recv</I> function after calling <I>select</I> to activate the time-out. This function returns only 
the bytes that have been received. For more information, see the 
description of the <I>CHttpBlockingSocket</I> class in the next section.
</UL>

<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP">Parameter</TD><TD VALIGN="TOP">Description</TD></TR>
<TR><TD VALIGN="TOP"><I>pch</I></TD><TD VALIGN="TOP">A pointer to an existing buffer that will receive 
the incoming bytes</TD></TR>
<TR><TD VALIGN="TOP"><I>nSize</I></TD><TD VALIGN="TOP">The maximum number of bytes to receive</TD></TR>
<TR><TD VALIGN="TOP"><I>nSecs</I></TD><TD VALIGN="TOP">Time-out value in seconds</TD></TR>
<TR><TD VALIGN="TOP">Return value</TD><TD VALIGN="TOP">The actual number of bytes received</TD></TR>
</TABLE>
<UL>
<LI><B><I>SendDatagram</I></B>&#151;This UDP function calls the Winsock 
<I>sendto</I> function. The program on the other end needs to call 
<I>ReceiveDatagram</I>. There is no need to call 
<I>Listen</I>, <I>Accept</I>, or <I>Connect</I> for 
datagrams. You must have previously called 
<I>Create</I> with the parameter set to 
<I>SOCK_DGRAM</I>.
</UL>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP">Parameter</TD><TD VALIGN="TOP">Description</TD></TR>
<TR><TD VALIGN="TOP"><I>pch</I></TD><TD VALIGN="TOP">A pointer to a buffer that contains the bytes to send</TD></TR>
<TR><TD VALIGN="TOP"><I>nSize</I></TD><TD VALIGN="TOP">The size (in bytes) of the block to send</TD></TR>
<TR><TD VALIGN="TOP"><I>psa</I></TD><TD VALIGN="TOP">The datagram's destination address; a 
<I>CSockAddr</I> 
object or a pointer to a variable of type <I>sockaddr</I></TD></TR>
<TR><TD VALIGN="TOP"><I>nSecs</I></TD><TD VALIGN="TOP">Time-out value in seconds</TD></TR>
<TR><TD VALIGN="TOP">Return value</TD><TD VALIGN="TOP">The actual number of bytes sent</TD></TR>
</TABLE>
<UL>
<LI><B><I>ReceiveDatagram</I></B>&#151;This UDP function calls the Winsock 
<I>recvfrom</I> function. The function returns when the program at the other 
end of the connection calls <I>SendDatagram</I>. You must have 
previously called <I>Create</I> with the parameter set to 
<I>SOCK_DGRAM</I>.
</UL>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP">Parameter</TD><TD VALIGN="TOP">Description</TD></TR>
<TR><TD VALIGN="TOP"><I>pch</I></TD><TD VALIGN="TOP">A pointer to an existing buffer that will receive 
the incoming bytes</TD></TR>
<TR><TD VALIGN="TOP"><I>nSize</I></TD><TD VALIGN="TOP">The size (in bytes) of the block to send</TD></TR>
<TR><TD VALIGN="TOP"><I>psa</I></TD><TD VALIGN="TOP">The datagram's destination address; a 
<I>CSockAddr</I> 
object or a pointer to a variable of type <I>sockaddr</I></TD></TR>
<TR><TD VALIGN="TOP"><I>nSecs</I></TD><TD VALIGN="TOP">Time-out value in seconds</TD></TR>
<TR><TD VALIGN="TOP">Return value</TD><TD VALIGN="TOP">The actual number of bytes received</TD></TR>
</TABLE>
<UL>
<LI><B><I>GetPeerAddr</I></B>&#151;This function calls the Winsock 
<I>getpeername</I> function. It returns the port and IP address of the socket on the 
other end of the connection. If you are connected to the Internet 
through a Web proxy server, the IP address is the proxy server's IP address.
</UL>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP">Parameter</TD><TD VALIGN="TOP">Description</TD></TR>
<TR><TD VALIGN="TOP"><I>psa</I></TD><TD VALIGN="TOP">A <I>CSockAddr</I> object or a pointer to a variable of 
type <I>sockaddr</I></TD></TR>
</TABLE>
<UL>
<LI><B><I>
GetSockAddr</I></B>&#151;This function calls the Winsock 
<I>getsockname</I> function. It returns the socket address that Winsock assigns to this end 
<LI>of the connection. If the other program is a server on a LAN, the 
IP address is the address assigned to this computer's network board. 
If the other program is a server on the Internet, your service 
provider assigns the IP address when you dial in. In both cases, Winsock 
assigns the port number, which is different for each connection.
</UL>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP">Parameter</TD><TD VALIGN="TOP">Description</TD></TR>
<TR><TD VALIGN="TOP"><I>psa</I></TD><TD VALIGN="TOP">A <I>CSockAddr</I> object or a pointer to a variable of 
type <I>sockaddr</I></TD></TR>
</TABLE>
<UL>
<LI><B><I>
GetHostByName</I></B>&#151;This static function calls the Winsock 
function <I>gethostbyname</I>. It queries a name server and then returns the 
socket address corresponding to the host name. The function times out 
by itself.
</UL>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP">Parameter</TD><TD VALIGN="TOP">Description</TD></TR>
<TR><TD VALIGN="TOP"><I>pchName</I></TD><TD VALIGN="TOP">A pointer to a character array containing the 
host name to resolve</TD></TR>
<TR><TD VALIGN="TOP"><I>ushPort</I></TD><TD VALIGN="TOP">The port number (default value 0) that will 
become part of the returned socket address</TD></TR>
<TR><TD VALIGN="TOP">Return value</TD><TD VALIGN="TOP">The socket address containing the IP address from 
the DNS plus the port number <I>ushPort</I></TD></TR>
</TABLE>
<UL>
<LI><B><I>GetHostByAddr</I></B>&#151;This static function calls the Winsock 
<I>gethostbyaddr</I> function. It queries a name server and then returns the 
host name corresponding to the socket address. The function times 
out by itself.
</UL>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP">Parameter</TD><TD VALIGN="TOP">Description</TD></TR>
<TR><TD VALIGN="TOP"><I>psa</I></TD><TD VALIGN="TOP">A <I>CSockAddr</I> object or a pointer to a variable of 
type <I>sockaddr</I></TD></TR>
<TR><TD VALIGN="TOP">Return value</TD><TD VALIGN="TOP">A pointer to a character array containing the 
host name; the caller should not delete this memory</TD></TR>
</TABLE>
<UL>
<LI><B><I>Cleanup</I></B>&#151;This function closes the socket if it is open. It 
doesn't throw an exception, so you can call it inside an exception 
<I>catch</I> block.
<LI><B><I>operator 
SOCKET</I></B>&#151;This overloaded operator lets you use 
a <I>CBlockingSocket</I> object in place of a 
<I>SOCKET</I> parameter.
</UL>

<A NAME="883"><H3>The <I>CHttpBlockingSocket</I> Class</H3></A><P>If you call <I>CBlockingSocket::Receive</I>, you'll have a difficult time knowing 
when to stop receiving bytes. Each call returns the bytes that are stacked up at 
your end of the connection at that instant. If there are no bytes, the call blocks, 
but if the sender closed the socket, the call returns zero bytes.
<P>In the HTTP section, you learned that the 
client sends a request terminated by a blank line. The server is supposed to send 
the response headers and data as soon as it detects the blank line, but the client 
needs to analyze the response headers before it reads the data. This means that as 
long as a TCP connection remains open, the receiving program must process 
the received data as it comes in. A simple but inefficient technique would be to 

call <I>Receive</I> for 1 byte at a time. A better way is to use a buffer.
<P>The <I>CHttpBlockingSocket</I> class adds buffering to 
<I>CBlockingSocket</I>, and it provides two new member functions. Here is part of the 
\vcpp32\ex34A\Blocksock.h file:
<P><PRE>class CHttpBlockingSocket : public CBlockingSocket
{
public:
    DECLARE_DYNAMIC(CHttpBlockingSocket)
    enum {nSizeRecv = 1000}; // max receive buffer size (&gt; hdr line
                             //  length)
    CHttpBlockingSocket();
    ~CHttpBlockingSocket();
    int ReadHttpHeaderLine(char* pch, const int nSize, const int nSecs);
    int ReadHttpResponse(char* pch, const int nSize, const int nSecs);
private:
    char* m_pReadBuf; // read buffer
    int m_nReadBuf; // number of bytes in the read buffer
};</PRE>
<P>The constructor and destructor take care of allocating and freeing a 
1000-character buffer. The two new member functions are as follows:
<UL>
<LI><B><I>ReadHttpHeaderLine</I></B>&#151;This function returns a single header 
line, terminated with a &lt;cr&gt;&lt;lf&gt; pair. 
<I>ReadHttpHeaderLine</I> inserts a terminating zero at the end of the line. If the line buffer is full, the terminating zero is stored in the last position.
</UL>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP">Parameter</TD><TD VALIGN="TOP">Description</TD></TR>
<TR><TD VALIGN="TOP"><I>pch</I></TD><TD VALIGN="TOP">A pointer to an existing buffer that will receive 
the incoming line (zero-terminated)</TD></TR>
<TR><TD VALIGN="TOP"><I>nSize</I></TD><TD VALIGN="TOP">The size of the <I>pch</I> buffer</TD></TR>
<TR><TD VALIGN="TOP"><I>nSecs</I></TD><TD VALIGN="TOP">Time-out value in seconds</TD></TR>
<TR><TD VALIGN="TOP">Return value</TD><TD VALIGN="TOP">The actual number of bytes received, excluding 
the terminating zero</TD></TR>
</TABLE>
<UL>
<LI><B><I>ReadHttpResponse</I></B>&#151;This function returns the remainder of 
the server's response received when the socket is closed or when 
the buffer is full. Don't assume that the buffer contains a 
terminating zero.
</UL>
<TABLE WIDTH="95%" CELLPADDING="5">
<TR><TD VALIGN="TOP">Parameter</TD><TD VALIGN="TOP">Description</TD></TR>
<TR><TD VALIGN="TOP"><I>pch</I></TD><TD VALIGN="TOP">A pointer to an existing buffer that will receive 
the incoming data</TD></TR>
<TR><TD VALIGN="TOP"><I>nSize</I></TD><TD VALIGN="TOP">The maximum number of bytes to receive</TD></TR>
<TR><TD VALIGN="TOP"><I>nSecs</I></TD><TD VALIGN="TOP">Time-out value in seconds</TD></TR>
<TR><TD VALIGN="TOP">Return value</TD><TD VALIGN="TOP">The actual number of bytes received</TD></TR>
</TABLE>
<A NAME="884"><H2>A Simplified HTTP Server Program</H2></A><P>Now it's time to use the blocking socket classes to write an HTTP server 
program. All the frills have been eliminated, but the code actually works with 
a browser. This server doesn't do much except return some hard-coded 
headers and HTML statements in response to any GET request. (See the EX34A 
program later in this chapter for a more complete HTTP server.)
<A NAME="885"><H3>Initializing Winsock</H3></A><P>Before making any Winsock calls, the program must initialize the Winsock 
library. The following statements in the application's 
<I>InitInstance</I> member 
function do the job:
<P><PRE>WSADATA wsd;
WSAStartup(0x0101, &amp;wsd);</PRE>
<A NAME="886"><H3>Starting the Server</H3></A><P>The server starts in response to some user action, such as a menu choice. 
Here's the command handler:
<P><PRE>CBlockingSocket g_sListen; // one-and-only global socket for listening
void CSocketView::OnInternetStartServer() 
{
    try {
        CSockAddr saServer(INADDR_ANY, 80);
        g_sListen.Create();
        g_sListen.Bind(saServer);
        g_sListen.Listen();
        AfxBeginThread(ServerThreadProc, GetSafeHwnd());
    }
    catch(CBlockingSocketException* e) {
        g_sListen.Cleanup();
        // Do something about the exception
        e-&gt;Delete();
    }
}</PRE>
<P>Pretty simple, really. The handler creates a socket, starts listening on it, 
and then starts a worker thread that waits for some client to connect to port 80. 
If something goes wrong, an exception is thrown. The global 
<I>g_sListen</I> object lasts for the life of the program and is capable of accepting multiple 
simultaneous connections, each managed by a separate thread.
<A NAME="887"><H3>The Server Thread</H3></A><P>Now let's look at the <I>ServerThreadProc</I> function:
<P><PRE>UINT ServerThreadProc(LPVOID pParam)
{
    CSockAddr saClient;
    CHttpBlockingSocket sConnect;
    char request[100];
    char headers[] = &quot;HTTP/1.0 200 OK\r\n&quot;
        &quot;Server: Inside Visual C++ SOCK01\r\n&quot;
        &quot;Date: Thu, 05 Sep 1996 17:33:12 GMT\r\n&quot;
        &quot;Content-Type: text/html\r\n&quot;
        &quot;Accept-Ranges: bytes\r\n&quot;
        &quot;Content-Length: 187\r\n&quot;
        &quot;\r\n&quot;; // the important blank line
    char html[] =
        &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Inside Visual C++ Server&lt;/title&gt;&lt;/head&gt;\r\n&quot;
        &quot;&lt;body&gt;&lt;body background=\&quot;/samples/images/usa1.jpg\&quot;&gt;\r\n&quot;
        &quot;&lt;h1&gt;&lt;center&gt;This is a custom home page&lt;/center&gt;&lt;/h1&gt;&lt;p&gt;\r\n&quot;
        &quot;&lt;/body&gt;&lt;/html&gt;\r\n\r\n&quot;;
    try {
        if(!g_sListen.Accept(sConnect, saClient)) {
            // Handler in view class closed the listening socket
            return 0;
        }
        AfxBeginThread(ServerThreadProc, pParam);
        // read request from client
        sConnect.ReadHttpHeaderLine(request, 100, 10);
        TRACE(&quot;SERVER: %s&quot;, request); // Print the first header
        if(strnicmp(request, &quot;GET&quot;, 3) == 0) {
            do { // Process the remaining request headers
                sConnect.ReadHttpHeaderLine(request, 100, 10);
                TRACE(&quot;SERVER: %s&quot;, request); // Print the other headers
            } while(strcmp(request, &quot;\r\n&quot;));
            sConnect.Write(headers, strlen(headers), 10); // response hdrs
            sConnect.Write(html, strlen(html), 10); // HTML code
        }
        else {
            TRACE(&quot;SERVER: not a GET\n&quot;);
            // don't know what to do
        }
        sConnect.Close(); // Destructor doesn't close it
    }
    catch(CBlockingSocketException* e) {
        // Do something about the exception
        e-&gt;Delete();
    }
    return 0;
}</PRE>
<P>The most important function call is the 
<I>Accept</I> call. The thread blocks until a client connects to the server's port 80, and then 
<I>Accept</I> returns with a new socket, 
<I>sConnect</I>. The current thread immediately starts another thread.
<P>In the meantime, the current thread must process the client's request 
that just came in on <I>sConnect</I>. It first reads all the request headers by calling 
<I>ReadHttpHeaderLine</I> until it detects a blank line. Then it calls 
<I>Write</I> to send the response headers and the HTML statements. Finally, the current thread calls 
<I>Close</I> to close the connection socket. End of story for this connection. The next 
thread is sitting, blocked at the <I>Accept</I> call, waiting for the next connection.
<A NAME="888"><H3>Cleaning Up</H3></A><P>To avoid a memory leak on exit, the program must ensure that all worker 
threads have been terminated. The simplest way to do this is to close the listening 
socket. This forces any thread's pending 
<I>Accept</I> to return <I>FALSE</I>, causing the thread 
to exit.
<P><PRE>try {
    g_sListen.Close();
    Sleep(340); // Wait for thread to exit
    WSACleanup(); // Terminate Winsock
}
catch(CUserException* e) {
    e-&gt;Delete();
}</PRE>
<P>A problem might arise if a thread were in the process of fulfilling a 
client request. In that case, the main thread should positively ensure that all 
threads have terminated before exiting.
<A NAME="889"><H2>A Simplified HTTP Client Program</H2></A><P>Now for the client side of the story&#151;a simple working program that does a 
<U>blind</U> <U>GET</U> request. When a server receives a GET request with a slash, as shown 
below, it's supposed to deliver its default HTML file:
<P><PRE>GET / HTTP/1.0</PRE>
<P>If you typed <I>http://www.slowsoft.com</I> in a browser, the browser sends 
the blind GET request.
<P>This client program can use the same 
<I>CHttpBlockingSocket</I> class you've already seen, and it must initialize Winsock the same way the server did. 
A command handler simply starts a client thread with a call like this:
<P><PRE>AfxBeginThread(ClientSocketThreadProc, GetSafeHwnd());</PRE>
<P>Here's the client thread code:
<P><PRE>CString g_strServerName = &quot;localhost&quot;; // or some other host name
UINT ClientSocketThreadProc(LPVOID pParam)
{
    CHttpBlockingSocket sClient;
    char* buffer = new char[MAXBUF];
    int nBytesReceived = 0;
    char request[] = &quot;GET / HTTP/1.0\r\n&quot;;
    char headers[] = // Request headers
        &quot;User-Agent: Mozilla/1.22 (Windows; U; 32bit)\r\n&quot;
        &quot;Accept: */*\r\n&quot;
        &quot;Accept: image/gif\r\n&quot;
        &quot;Accept: image/x-xbitmap\r\n&quot;
        &quot;Accept: image/jpeg\r\n&quot;
        &quot;\r\n&quot;; // need this
    CSockAddr saServer, saClient;
    try {
        sClient.Create();
        saServer = CBlockingSocket::GetHostByName(g_strServerName, 80);
        sClient.Connect(saServer);
        sClient.Write(request, strlen(request), 10);
        sClient.Write(headers, strlen(headers), 10);
        do { // Read all the server's response headers
            nBytesReceived = sClient.ReadHttpHeaderLine(buffer, 100, 10);
        } while(strcmp(buffer, &quot;\r\n&quot;)); // through the first blank line
        nBytesReceived = sClient.ReadHttpResponse(buffer, 100, 10);
        if(nBytesReceived == 0) {
            AfxMessageBox(&quot;No response received&quot;);
        }
        else {
            buffer[nBytesReceived] = `\0';
            AfxMessageBox(buffer);
        }
    }
    catch(CBlockingSocketException* e) {
        // Log the exception
        e-&gt;Delete();
    }
    sClient.Close();
    delete [] buffer;
    return 0; // The thread exits
}</PRE>
<P>This thread first calls <I>CBlockingSocket::GetHostByName</I>
 to get the server computer's IP address. Then it creates a socket and calls 
<I>Connect</I> on that socket. Now there's a two-way communication channel to the server. The thread 
sends its GET request followed by some request headers, reads the server's 
response headers, and then reads the response file itself, which it assumes is a text 
file. After the thread displays the text in a message box, it exits.
</BODY>
</HTML>



