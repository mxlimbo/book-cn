<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Writing COM Code</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="699"><H1>Writing COM Code</H1></A><P>As you can see, writing COM client code isn't a whole lot different from 
writing regular C++ code. However, the C++ classes that the client talks to are 
abstract base classes. Instead of calling <I>operator 
new</I> as you would in C++, you create COM objects and acquire COM interfaces by explicitly calling some sort of API function. And instead of deleting the object outright, you simply follow 
the COM interface rule of balancing calls to 
<I>AddRef</I> with calls to <I>Release</I>.
<P>What does it take to get the COM class up and running? You saw how 
to do it using MFC in <A HREF="ch24a.htm">Chapter 24</A>. Here's another example of 
implementing <I>CSpaceship</I> as a COM class. This example uses the multiple inheritance 
approach to writing COM classes. That is, the C++ class inherits from several 
interfaces and then implements the union of all the functions (including 
<I>IUnknown</I>, of course).
<P><PRE>struct CSpaceship : IMotion, IDisplay {
    ULONG m_cRef;
    int m_nPosition;

    CSpaceship() : m_cRef(0),
                   m_nPosition(0) {
    }

    HRESULT QueryInterface(REFIID riid,
                           void** ppv);
    ULONG AddRef() {
        return InterlockedIncrement(&amp;m_cRef);
    }
    ULONG Release() {
        ULONG cRef = InterlockedIncrement(&amp;m_cRef);
        if(cRef == 0){
            delete this;
            return 0;
        } else
            return m_cRef;
    }

    // IMotion functions:
    void Fly() {
        // Do whatever it takes to fly here
    }
    int GetPosition() {
        return m_nPosition;
    }

    // IVisual functions:
    void Display() {
        // Uncloak
    }
};</PRE>
<A NAME="700"><H2>COM Classes Using Multiple Inheritance</H2></A><P>If you're used to seeing plain C++ code, the preceding code might look a 
little strange to you. This is a less common form of multiple inheritance called 
<U>interface inheritance</U>. Most C++ developers are used to an implementation 
inheritance in which the derived class inherits everything from the base class&#151;including 
the implementation. Interface inheritance simply means the derived class 
inherits the interfaces of the base class. The preceding code effectively adds two 
data members to the <I>CSpaceship</I> class&#151;a <I>vptr</I> for each implied <I>vtable</I>.
<P>When using the multiple inheritance approach to implementing 
interfaces, each interface shares 
<I>CSpaceship</I>'s implementation of 
<I>IUnknown</I>. This sharing illustrates a rather esoteric yet important concept known as 
<U>COM identity</U>. The basic idea of COM identity is that 
<I>IUnknown</I> is the void* of COM. <I>IUknown 
</I>is the one interface guaranteed to be hanging off any object, and you can 
always get to it. COM identity also says (in the previous example) the client can 
call <I>QueryInterface</I> through the 
<I>CSpaceship</I> <I>IMotion</I> interface to get the 
<I>IVisible</I> interface. Conversely, the client can call 
<I>QueryInterface</I> through the 
<I>CSpaceship</I> <I>IVisible</I> interface to get the 
<I>IMotion</I> interface. Finally, the client can call 
<I>QueryInterface</I> through <I>IUnknown</I> to acquire the 
<I>IMotion</I> or the <I>IVisible</I> interface, and the client can call 
<I>QueryInterface</I> through either 
<I>IMotion</I> or <I>IVisual</I> to get a pointer to 
<I>IUnknown</I>. To learn more about COM identity, see 
<I>Essential COM</I> by Don Box (Addison-Wesley, 1997) or 
<I>Inside COM</I> by Dale Rogerson (Microsoft Press, 1997).
<P>Often you'll see COM classes illustrated with &quot;lollipop&quot; diagrams 
depicting the interfaces implemented by a COM class. You can see an example of a 
lollipop diagram in &quot;<A HREF="ch24c.htm#507">The <I>IUnknown</I> Interface and the <I>QueryInterface</I> Member Function</A>&quot; in Chapter 24.
<P>The multiple inheritance method of implementing 
<I>CSpaceship</I> automatically fulfills the rules of COM identity. Note that all calls to 
<I>QueryInterface, AddRef,</I> and <I>Release</I> land in the same place in the 
C++ class, regardless of the interface through which they were called.
<P>This is more or less the essence of COM. As a COM developer, your 
job is to create useful services and expose them through COM interfaces. At the 
most basic level, this means wiring up some function tables to follow COM's 
identity rules. You've seen two ways to accomplish this so far. (<A HREF="ch24a.htm">Chapter 24</A> 
showed you how to do it using nested classes and MFC. This chapter just showed 
you how to write a COM class using multiple inheritance in 
C++.) However, in addition to interface programming and writing classes to implement 
interfaces, there are several other pieces to the COM puzzle.
</BODY>
</HTML>



