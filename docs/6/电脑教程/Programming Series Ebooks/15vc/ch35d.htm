<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>ISAPI Server Extensions</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="930"><H1>ISAPI Server Extensions</H1></A><P>An ISAPI server extension is a program (implemented as a DLL loaded by 
IIS) that runs in response to a GET or POST request from a client 
program (browser). The browser can pass parameters to the program, which are 
often values that the browser user types into edit controls, selects from list boxes, 
and so forth. The ISAPI server extension typically sends back HTML code 
based on those parameter values. You'll better understand this process when you 
see an example.
<A NAME="931"><H2>Common Gateway Interface and ISAPI</H2></A><P>Internet server programs were first developed for UNIX computers, so the 
standards were in place long before Microsoft introduced IIS. The Common 
Gateway Interface (CGI) standard, actually part of 
HTTP, evolved as a way for browser programs to interact with scripts or separate executable programs 
running on the server. Without altering the HTTP/CGI specifications, 
Microsoft designed IIS to allow any browser to load and run a server DLL. DLLs are 
part of the IIS process and thus are faster than scripts that might need to load 
separate executable programs. Because of your experience, you'll probably 
find it easier to write an ISAPI DLL in C++ than to write a script in PERL, the 
standard Web scripting language for servers.
<P>CGI shifts the programming burden to the server. Using CGI 
<U>parameters</U>, the browser sends small amounts of information to the server computer, 
and the server can do absolutely anything with this information, including access 
a database, generate images, and control peripheral devices. The server sends 
a file (HTML or otherwise) back to the browser. The file can be read from 
the server's disk, or it can be generated by the program. No ActiveX controls or 
Java applets are necessary, and the browser can be running on any type of computer.
<A NAME="932"><H2>A Simple ISAPI Server Extension GET Request</H2></A><P>Suppose an HTML file contains the following tag:
<P><PRE>&lt;a href=&quot;scripts/maps.dll?State=Idaho&quot;&gt;Idaho Weather Map&lt;/a&gt;&lt;p&gt;</PRE>
<P>When the user clicks on <I>Idaho Weather 
Map</I>, the browser sends the server a CGI GET request like this:
<P><PRE>GET scripts/maps.dll?State=Idaho HTTP/1.0</PRE>
<P>IIS then loads maps.dll from its scripts (virtual) directory, calls a 
<U>default</U> <U>function</U> (often named 
<I>Default</I>), and passes it the <I>State</I> parameter 
<I>Idaho</I>. The DLL then goes to work generating a JPG file containing the 
up-to-the-minute satellite weather map for Idaho and sends it to the client.
<P>If maps.dll had more than one function, the tag could specify the 
function name like this:
<P><PRE>&lt;a href=&quot;scripts/maps.dll?GetMap?State=Idah
o&amp;Res=5&quot;&gt;Idaho Weather Map&lt;/a&gt;&lt;p&gt;</PRE>
<P>In this case, the function <I>GetMap</I> is called with two parameters, 
<I>State</I> and <I>Res</I>.
<P>You'll soon learn how to write an ISAPI server similar to maps.dll, but 
first you'll need to understand <U>HTML</U> 
<U>forms</U>, because you don't often see CGI GET requests by themselves.
<A NAME="933"><H2>HTML Forms&#151;GET vs. POST</H2></A><P>In the HTML code for the simple CGI GET request above, the state name 
was hard-coded in the tag. Why not let the user select the state from a 
drop-down list? For that, you need a form, and here's a simple one that can do the job.
<P><PRE>&lt;html&gt;
&lt;head&gt;&lt;title&gt;Weathermap HTML Form&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;&lt;center&gt;Welcome to the Satellite Weathermap Service&lt;/center&gt;&lt;/h1&gt;
&lt;form action=&quot;scripts/maps.dll?GetMap&quot; method=GET&gt;
    &lt;p&gt;Select your state:
    &lt;select name=&quot;State&quot;&gt;
        &lt;option&gt; Alabama
        &lt;option&gt; Alaska
        &lt;option&gt; Idaho
        &lt;option&gt; Washington
    &lt;/select&gt;
&lt;p&gt;&lt;input type=&quot;submit&quot;&gt;&lt;input type=&quot;reset&quot;&gt;
&lt;/form&gt;
&lt;/body&gt;&lt;/html&gt;</PRE>
<P>If you looked at this HTML file with a browser, you would see the 
form shown in Figure 35-4.
<P><A HREF="javascript:fullSize('f35og04x.htm')"> <img src="f35og04.jpg" width=404 height=228 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 35-4.</B> <I>The Weathermap HTML Form window.</I>
<!-- /caption -->
<P>The select tag provides the state name from a list of four states, and 
the all-important &quot;submit&quot; input tag displays the pushbutton that sends the 
form data to the server in the form of a CGI GET request that looks like this:
<P><PRE>GET scripts/maps.dll?GetMap?State=Idaho HTTP/1.0
<I>(various request headers)
(blank line)</I></PRE>
<P>Unfortunately, some early versions of the Netscape browser omit the 
function name in form-originated GET requests, giving you two choices: 
provide only a default function in your ISAPI DLL, and use the POST method 
inside a form instead of the GET method.
<P>If you want to use the POST option, change one HTML line in the 
form above to the following:
<P><PRE>&lt;form action=&quot;scripts/maps.dll?GetMap&quot; method=POST&gt;</PRE>
<P>Now here's what the browser sends to the server:
<P><PRE>POST scripts/maps.dll?GetMap
<I>(various request headers)
(blank line)</I>

State=Idaho</PRE>
<P>Note that the parameter value is in the last line instead of in the request line.
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
ISAPI DLLs are usually stored in a separate virtual 
directory on the server because these DLLs must have 
<U>execute</U> <U>permission</U> but do not need 
<U>read</U> <U>permission</U>. Clicking the Edit Properties 
button shown in Figure 35-3 will allow you to access these 
permissions from the Internet Service Manager, or you can double-click on 
a directory to change its properties.
</BLOCKQUOTE></DIV>

<A NAME="934"><H2>Writing an ISAPI Server Extension DLL</H2></A><P>Visual C++ gives you a quick start for writing ISAPI server extensions. Just 
select ISAPI Extension Wizard from the Projects list. After you click the OK 
button, your first screen looks like Figure 35-5.
<P><A HREF="javascript:fullSize('f35og05x.htm')"> <img src="f35og05.jpg" width=404 height=325 border=0 ALT = "Click to view at full size."> </A><P>
<!-- caption -->
<B>Figure 35-5.</B> <I>The Step 1 page of the ISAPI Extension Wizard.</I>
<!-- /caption -->
<P>Check the Generate A Server Extension Object box, and you've got a 
do-nothing DLL project with a class derived from the MFC 
<I>CHttpServer </I>class and a <I>Default</I> member function. Now it's time for a little programming.
<P>You must write your ISAPI functions as members of the derived 
<I>CHttpServer</I> class, and you must write 
<U>parse</U> <U>map</U> macros to link them to IIS. 
There's no &quot;parse map wizard,&quot; so you have to do some coding. It's okay to use 
the <I>Default</I> function, but you need a 
<I>GetMap</I> function too. First insert these 
lines into the wizard-generated parse map:
<P><PRE>ON_PARSE_COMMAND(GetMap, CWeatherExtension, ITS_PSTR)
ON_PARSE_COMMAND_PARAMS(&quot;State&quot;)</PRE>
<P>Then write the <I>GetMap</I> function:
<P><PRE>void CWeatherExtension::GetMap(CHttpServerContext* pCtxt, LPCTSTR pstrState)
{
    StartContent(pCtxt);
    WriteTitle(pCtxt);
    *pCtxt &lt;&lt; &quot;Visualize a weather map for the state of &quot;;
    *pCtxt &lt;&lt; pstrState;
    EndContent(pCtxt);
}</PRE>
<P>This function doesn't actually generate the weather map (what did 
you expect?), but it does display the selected state name in a custom HTML file. 
The <I>CHttpServer::StartContent</I> and 
<I>CHttpServer::EndContent</I> functions write the HTML boilerplate, and 
<I>CHttpServer::WriteTitle</I> calls the virtual 
<I>CHttpServer::GetTitle</I> function, which you need to override:
<P><PRE>LPCTSTR CWeatherExtension::GetTitle() const
{
    return &quot;Your custom weather map&quot;; // for browser's title window
}</PRE>
<P>The MFC <I>CHttpServerContext</I> class has an overloaded &lt;&lt; operator, 
which you use to put text in the HTML file you're building. Behind the scenes, 
an attached object of the MFC class 
<I>CHtmlStream</I> represents the output to the server's socket.
<A NAME="935"><H2>The MFC ISAPI Server Extension Classes</H2></A><P>Now is a good time to review the three MFC classes that are used to create 
an MFC ISAPI server extension. Remember that these classes are for ISAPI 
server extensions <U>only</U>. Don't even think of using them in ordinary Winsock or 
WinInet applications.
<A NAME="936"><H3><I>CHttpServer</I></H3></A><P>With the help of the ISAPI Extension Wizard, you derive a class from 
<I>CHttpServer</I> for each ISAPI server extension DLL that you create. You need 
one member function for each extension function (including the default 
function), and you need an overridden 
<I>GetTitle</I> function. The framework calls your 
extension functions in response to client requests, using the connections 
established in the parse map. The ISAPI Extension Wizard provides an overridden 
<I>GetExtensionVersion</I> function, which you seldom edit unless you need 
initialization code to be executed when the DLL is loaded.
<P>One of the <I>CHttpServer</I> member<I> </I>functions that you're likely to call 
is <I>AddHeader</I>, which adds special response headers, such as Set-Cookie, 
before the response is sent to the server. (More on cookies later.)
<A NAME="937"><H3><I>CHttpServerContext</I></H3></A><P>There's one <I>CHttpServer</I> object per DLL, but there is one 
<I>CHttpServerContext</I> object for each server transaction request. Your extension functions each 
provide a pointer to one of these objects. You don't derive from 
<I>CHttpServerContext</I>, so you can't easily have variables for individual transactions. 
Because different IIS threads can manage transactions, you have to be careful to 
perform synchronization for any data members of your 
<I>CHttpServer</I> class or global 
variables.
<P>You've already seen the use of the 
<I>StartContent</I>, <I>EndContent</I>, and 
<I>WriteTitle</I> functions of the 
<I>CHttpServer</I> class plus the overloaded &gt;&gt; operator. 
You might also need to call the 
<I>CHttpServerContext::GetServerVariable</I> function 
to read information sent by the client in the request headers.
<A NAME="938"><H3><I>CHtmlStream</I></H3></A><P>Most of the time, you don't use the 
<I>CHtmlStream</I> class directly. The 
<I>CHttpServerContext</I> class has a 
<I>CHtmlStream</I> data member, <I>m_pStream</I>, that's 
hooked up to the &gt;&gt; operator and serves as the output for HTML data. You could 
access the <I>CHtmlStream</I> object and call its 
<I>Write</I> member function if you needed to send binary data to the client. Because objects of the 
<I>CHtmlStream</I> class accumulate bytes in memory before sending them to the client, you need an 
alternative approach if your DLL relays large files directly from disk.
</BODY>
</HTML>



