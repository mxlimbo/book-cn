<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>Revisiting COM</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="697"><H1>Revisiting COM</H1></A><P>The most important concept to understand about COM programming is 
that it is interface-based. As you saw in <A HREF="ch24a.htm">Chapter 24</A>, you don't need real COM 
or even Microsoft runtime support to use interface-based programming. All 
you need is some discipline.
<P>Think back to the spaceship example in <A HREF="ch24a.htm">Chapter 24</A>. You started out 
with a single class named <I>CSpaceship</I> that implemented several functions. 
Seasoned C++ developers usually sit down at the computer and start typing a class like this:
<P><PRE>class CSpaceship {
    void Fly();
    int&amp; GetPosition();
};</PRE>
<P>However, the procedure is a little different with interface-based 
development. Instead of writing the class directly, interface-based programming 
involves spelling out an interface before implementing it. In <A HREF="ch24a.htm">Chapter 24</A>, the 
<I>Fly</I> and <I>GetPosition</I> functions were moved into an abstract base class named 
<I>IMotion</I>.
<P><PRE>struct IMotion {
    virtual void Fly() = 0;
    virtual int&amp; GetPosition() = 0;
};</PRE>
<P>Then we inherited the <I>CSpaceship</I> class from the 
<I>IMotion</I> interface like this:
<P><PRE>class CSpaceship : IMotion {
    void Fly();
    int&amp; GetPosition();
};</PRE>
<P>Notice that at this point the motion interface has been separated from 
its implementation. When practicing interface development, the interface 
comes first. You can work on the interface as you develop it, making sure it's 
complete while at the same time not over-bloated. But once the interface has been 
published (that is, once a lot of other developers have started coding to it), 
the interface is frozen and can never change.
<P>This subtle distinction between class-based programming and 
interface-based programming seems to introduce some programming overhead. 
However, it turns out to be one of the key points to understanding COM. 
By collecting the <I>Fly</I> and the 
<I>GetPosition</I> functions in an interface, you've 
developed a binary signature. That is, by defining the interface ahead of time 
and talking to the class through the interface, client code has a potentially 
language-neutral way of talking to the class.
<P>Gathering functions together into interfaces is itself quite powerful. 
Imagine you want to describe something other than a spaceship&#151;an airplane, for 
example. It's certainly conceivable that an airplane would also have 
<I>Fly</I> and <I>GetPosition</I> functions. Interface programming provides a more advanced form of 
polymorphism&#151;polymorphism at the interface level, not only at the single-function level.
<P>Separating interface from implementation is the basis of 
interface-based development. The Component Object Model is centered on interface 
programming. COM enforces the distinction between interface and implementation. 
In COM, the only way client code can talk to an object is through an 
interface. However, gathering functions together into interfaces isn't quite 
enough. There's one more ingredient needed&#151;a mechanism for discovering 
functionality at runtime.
<A NAME="698"><H2>The Core Interface: <I>IUnknown</I></H2></A><P>The key element that makes COM different from ordinary interface 
programming is this rule: the first three functions of every COM interface are the same. 
The core interface in COM, <I>IUnknown,</I> looks like this:
<P><PRE>struct IUnknown {
    virtual HRESULT QueryInterface(REFIID riid, void** ppv) = 0;
    virtual ULONG AddRef() = 0;
    virtual ULONG Release() = 0;
};</PRE>
<P>Every COM interface derives from this interface (meaning the first 
three functions of every COM interface you ever see will be 
<I>QueryInterface, AddRef,</I> and <I>Release</I>). To turn 
<I>IMotion</I> into a COM interface, derive it from 
<I>IUnknown</I> like this:
<P><PRE>struct IMotion : IUnknown {
    void Fly();
    int&amp; GetPosition();
};</PRE>
<P>
<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER="0"><P>
If you wanted these interfaces to work 
out-of-process, you'd have to make each function return an HRESULT. You'll see this 
when we cover Interface Definition Language (IDL) later in this chapter.
</BLOCKQUOTE></DIV>
<P><I>AddRef</I> and <I>Release</I> deserve some mention because they are part of 
<I>IUnknown</I>. <I>AddRef</I> and <I>Release</I> allow an object to control its own lifetime if it 
chooses to. As a rule, clients are supposed to treat interface pointers like resources: 
clients acquire interfaces, use them, and release them when they are done using 
them. Objects learn about new references to themselves via 
<I>AddRef</I>. Objects learn they have been unreferenced through the 
<I>Release</I> function. Objects often use this information to control their lifetimes. For example, many objects self-destruct when their reference count reaches zero.
<P>Here's how some client code might use the spaceship:
<P><PRE>void UseSpaceship() {
    IMotion* pMotion = NULL;

    pMotion = GetASpaceship(); // This is a member of the
                               //  hypothetical Spaceship 
                               //  API. It's presumably an
                               //  entry point into some DLL.
                               //  Returns an IMotion* and
                               //  causes an implicit AddRef.
    If(pMotion) {
        pMotion-&gt;Fly();
        int i = pMotion-&gt;GetPosition();
        pMotion-&gt;Release(); // done with this instance of CSpaceship
    }
}</PRE>
<P>The other (and more important) function within 
<I>IUnknown</I> is the first one: <I>QueryInterface. 
QueryInterface</I> is the COM mechanism for discovering 
functionality at runtime. If someone gives you a COM interface pointer to an object 
and you don't want to use that pointer, you can use the pointer to ask the 
object for a different interface to the same object. This mechanism, along with the 
fact that interfaces remain constant once published, are the key ingredients that 
allow COM-based software to evolve safely over time. The result is that you can 
add functionality to your COM software without breaking older versions of 
the clients running that software. In addition, clients have a widely recognized 
means of acquiring that new functionality once they know about it. For example, 
you add functionality to the implementation of 
<I>CSpaceship</I> by adding a new interface named 
<I>IVisual</I>. Adding this interface makes sense because you can have 
objects in three-dimensional space that move in and out of view. You might also 
have an invisible object in three-dimensional space (a black hole, for example). 
Here's the <I>IVisual</I> interface:
<P><PRE>struct IVisual : IUnknown {
    virtual void Display() = 0;
};</PRE>
<P>A client might use the <I>IVisual</I> interface like this:
<P><PRE>void UseSpaceship() {
    IMotion* pMotion = NULL;

    pMotion = GetASpaceship(); // Implicit AddRef
    if(pMotion) {
        pMotion-&gt;Fly();
        int i = pMotion-&gt;GetPosition();

        IVisual* pVisual = NULL;
        PMotion-&gt;QueryInterface(IID_IVisual, (void**) &amp;pVisual);
        // Implicit AddRef within QueryInterface

        if(pVisible) {
            pVisual-&gt;Display(); // uncloaking now
            pVisual-&gt;Release(); // done with this interface
        }
    }
    pMotion-&gt;Release(); // done with this instance of IMotion
}</PRE>
<P>Notice that the preceding code uses interface pointers very carefully: it 
uses them only if the interface was acquired 
properly, and then it releases the interface pointers when it is done using them. This is raw COM programming at the lowest level&#151;you acquire an interface pointer, you use the interface pointer, 
and you release it when you're done with it.
</BODY>
</HTML>



