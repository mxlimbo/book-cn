<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="basicIE4.css" TYPE="text/css">
<TITLE>The EX28B Example -- An Embedding Container</TITLE>
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY>
<A NAME="683"><H1><B>The EX28B Example&#151;An Embedding Container</B></H1></A>
<P>Now we can move on to the working program. It's a good time to open the \vcpp32\ex28b\ex28b.dsw workspace and build the EX28B project. If you choose Insert Object from the Edit menu and select Ex28a Document, the EX28A component will start. If you change the component's data, the container and the component will look like this.

<P><A HREF="javascript:fullSize('g28og07x.htm')"> <img src="g28og07.jpg" width=404 height=268 border="0" ALT = "Click to view at full size."> </A>

<A NAME="684"><H2><B>The <I>CEx28bView</I> Class</B></H2></A>
<P>You can best understand the program by first concentrating on the view class. Look at the code in Figure 28-6, but ignore all <I>IOleClientSite</I> pointers. The container program will actually work if you pass <I>NULL</I> in every <I>IOleClientSite</I> pointer parameter. It just won't get notifications when the metafile or the native data changes. Also, components will appear displaying their stand-alone menus instead of the special embedded menus.



<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>EX28BVIEW.H</B>

<P><pre>
#if !defined(AFX_EX28BVIEW_H__1EAAB6E1_6011_11D0_848F_00400526305B__INCLUDED_)
#define AFX_EX28BVIEW_H__1EAAB6E1_6011_11D0_848F_00400526305B__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#define CF_OBJECTDESCRIPTOR &quot;Object Descriptor&quot;
#define CF_EMBEDDEDOBJECT &quot;Embedded Object&quot;
#define SETFORMATETC(fe, cf, asp, td, med, li)   \
    ((fe).cfFormat=cf, \
     (fe).dwAspect=asp, \
     (fe).ptd=td, \
     (fe).tymed=med, \
     (fe).lindex=li)
////////////////////////////////////////////////////////////////////
class CEx28bView : public CScrollView
{
public:
    CLIPFORMAT m_cfObjDesc;
    CLIPFORMAT m_cfEmbedded;
    CSize m_sizeTotal;  // document size
    CRectTracker m_tracker;
    CRect m_rectTracker; // logical coords
protected: // create from serialization only
    CEx28bView();
    DECLARE_DYNCREATE(CEx28bView)

// Attributes
public:
    CEx28bDoc* GetDocument();

private:
    void GetSize();
    void SetNames();
    void SetViewAdvise();
    BOOL MakeMetafilePict(COleDataSource* pSource);
    COleDataSource* SaveObject();
    BOOL DoPasteObject(COleDataObject* pDataObject);
    BOOL DoPasteObjectDescriptor(COleDataObject* pDataObject);

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEx28bView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    virtual void OnInitialUpdate();
    protected:
    virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
    virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
    virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CEx28bView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CEx28bView)
    afx_msg void OnEditCopy();
    afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
    afx_msg void OnEditCopyto();
    afx_msg void OnEditCut();
    afx_msg void OnEditPaste();
    afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
    afx_msg void OnEditPastefrom();
    afx_msg void OnEditInsertobject();
    afx_msg void OnUpdateEditInsertobject(CCmdUI* pCmdUI);
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
    afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, 
                             UINT message);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in ex28bView.cpp
inline CEx28bDoc* CEx28bView::GetDocument()
    { return (CEx28bDoc*)
m_pDocument; }
#endif

////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
//  immediately before the previous line.

#endif 
//!defined(AFX_EX28BVIEW_H__1EAAB6E1_6011_11D0_848F_00400526305B__INCLUDED_)
</pre>

<P><B>EX28BVIEW.CPP</B>

<p><pre>
#include &quot;stdafx.h&quot;
#include &quot;ex28b.h&quot;

#include &quot;ex28bDoc.h&quot;
#include &quot;ex28bView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = _FILE_;
#endif

////////////////////////////////////////////////////////////////////
// CEx28bView

IMPLEMENT_DYNCREATE(CEx28bView, CScrollView)

BEGIN_MESSAGE_MAP(CEx28bView, CScrollView)
    //{{AFX_MSG_MAP(CEx28bView)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
    ON_COMMAND(ID_EDIT_COPYTO, OnEditCopyto)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPYTO, OnUpdateEditCopy)
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCopy)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
    ON_COMMAND(ID_EDIT_PASTEFROM, OnEditPastefrom)
    ON_COMMAND(ID_EDIT_INSERTOBJECT, OnEditInsertobject)
    ON_UPDATE_COMMAND_UI(ID_EDIT_INSERTOBJECT, 
                         OnUpdateEditInsertobject)
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONDBLCLK()
    ON_WM_SETCURSOR()
    //}}AFX_MSG_MAP
    // Standard printing commands
    ON_COMMAND(ID_FILE_PRINT, CScrollView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_DIRECT, CScrollView::OnFilePrint)
    ON_COMMAND(ID_FILE_PRINT_PREVIEW,
               CScrollView::OnFilePrintPreview)
END_MESSAGE_MAP()

////////////////////////////////////////////////////////////////////
// CEx28bView construction/destruction

CEx28bView::CEx28bView() : m_sizeTotal(20000, 25000),
    // 20 x 25 cm when printed
    m_rectTracker(0, 0, 0, 0) 
{
    m_cfObjDesc = ::RegisterClipboardFormat(CF_OBJECTDESCRIPTOR);
    m_cfEmbedded = ::RegisterClipboardFormat(CF_EMBEDDEDOBJECT);
}

CEx28bView::~CEx28bView()
{
}

BOOL CEx28bView::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CScrollView::PreCreateWindow(cs);
}

////////////////////////////////////////////////////////////////////
// CEx28bView drawing

void CEx28bView::OnDraw(CDC* pDC)
{
    CEx28bDoc* pDoc = GetDocument();

    if(pDoc-&gt;m_lpOleObj != NULL) {
        VERIFY(::OleDraw(pDoc-&gt;
m_lpOleObj, DVASPECT_CONTENT,
               pDC-&gt;GetSafeHdc(), 
m_rectTracker) == S_OK);
    }

    m_tracker.m_rect = 
m_rectTracker;
    pDC-&gt;LPtoDP(m_tracker.m_rect);   // device
    if(pDoc-&gt;m_bHatch) {
        m_tracker.
m_nStyle |= CRectTracker::hatchInside;
    }
    else {
        m_tracker.
m_nStyle &amp;= ~CRectTracker::hatchInside;
    }
    m_tracker.Draw(pDC);
}

////////////////////////////////////////////////////////////////////
// CEx28bView printing

BOOL CEx28bView::OnPreparePrinting(CPrintInfo* pInfo)
{
    pInfo-&gt;SetMaxPage(1);
    return DoPreparePrinting(pInfo);
}

void CEx28bView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add extra initialization before printing
}

void CEx28bView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
    // TODO: add cleanup after printing
}

////////////////////////////////////////////////////////////////////
// CEx28bView diagnostics

#ifdef _DEBUG
void CEx28bView::AssertValid() const
{
    CScrollView::AssertValid();
}

void CEx28bView::Dump(CDumpContext&amp; dc) const
{
    CScrollView::Dump(dc);
}

CEx28bDoc* CEx28bView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CEx28bDoc)));
    return (CEx28bDoc*)m_pDocument;
}
#endif //_DEBUG

////////////////////////////////////////////////////////////////////
// CEx28bView message handlers

void CEx28bView::OnInitialUpdate() 
{
    TRACE(&quot;CEx28bView::OnInitialUpdate\n&quot;);
    m_rectTracker = CRect(1000, -1000, 5000, -5000);
    m_tracker.m_nStyle = CRectTracker::solidLine |
        CRectTracker::resizeOutside;
    SetScrollSizes(MM_HIMETRIC, 
m_sizeTotal);
    CScrollView::OnInitialUpdate();
}

void CEx28bView::OnEditCopy() 
{
    COleDataSource* pSource = SaveObject();
    if(pSource) {
        pSource-&gt;SetClipboard(); // OLE deletes data source 
    }
}

void CEx28bView::OnUpdateEditCopy(CCmdUI* pCmdUI) 
{
    // serves Copy, Cut, and Copy To
    pCmdUI-&gt;Enable(GetDocument()-&gt;
m_lpOleObj != NULL);
}

void CEx28bView::OnEditCopyto() 
{
    // Copy text to an STG file (nothing special about STG ext)
    CFileDialog dlg(FALSE, &quot;stg&quot;, &quot;*.stg&quot;);
    if (dlg.DoModal() != IDOK) {
        return;
    }
    CEx28bDoc* pDoc = GetDocument();
    // Create a structured storage home for the object ( pStgSub).
    //  Create a root storage file, then a substorage named &quot;sub&quot;.
    LPSTORAGE pStgRoot;
    VERIFY(::StgCreateDocfile(dlg.GetPathName().AllocSysString(),
           STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_CREATE,
           0, &amp;pStgRoot) == S_OK);
    ASSERT(pStgRoot != NULL);

    LPSTORAGE pStgSub;
    VERIFY(pStgRoot-&gt;CreateStorage(CEx28bDoc::s_szSub,
           STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
           0, 0, &amp;pStgSub) == S_OK); 
    ASSERT(pStgSub != NULL);

    // Get the IPersistStorage* for the object
    LPPERSISTSTORAGE pPS = NULL;
    VERIFY(pDoc-&gt;m_lpOleObj-&gt;QueryInterface(IID_IPersistStorage,
          (void**) &amp;pPS) == S_OK);

    // Finally, save the object in its new home in the user's file
    VERIFY(::OleSave(pPS, pStgSub, FALSE) == S_OK); 
    // FALSE means different stg
    pPS-&gt;SaveCompleted(NULL);  // What does this do?
    pPS-&gt;Release();

    pStgSub-&gt;Release();
    pStgRoot-&gt;Release();
}

void CEx28bView::OnEditCut() 
{
    OnEditCopy();
    GetDocument()-&gt;OnEditClearAll();
}
void CEx28bView::OnEditPaste() 
{
    CEx28bDoc* pDoc = GetDocument();
    COleDataObject dataObject;
    VERIFY(dataObject.AttachClipboard());
    pDoc-&gt;DeleteContents();
    DoPasteObjectDescriptor(&amp;dataObject);
    DoPasteObject(&amp;dataObject);
    SetViewAdvise();
    GetSize();
    pDoc-&gt;SetModifiedFlag();
    pDoc-&gt;UpdateAllViews(NULL);
}

void CEx28bView::OnUpdateEditPaste(CCmdUI* pCmdUI) 
{
    // Make sure that object data is available
    COleDataObject dataObject;
    if (dataObject.AttachClipboard() &amp;&amp;
        dataObject.IsDataAvailable(
m_cfEmbedded)) {
        pCmdUI-&gt;Enable(TRUE);
    } else {
        pCmdUI-&gt;Enable(FALSE);
    }
}

void CEx28bView::OnEditPastefrom() 
{
    CEx28bDoc* pDoc = GetDocument();
    // Paste from an STG file
    CFileDialog dlg(TRUE, &quot;stg&quot;, &quot;*.stg&quot;);
    if (dlg.DoModal() != IDOK) {
        return;
    }
    // Open the storage and substorage
    LPSTORAGE pStgRoot;
    VERIFY(::StgOpenStorage(dlg.GetPathName().AllocSysString(),
           NULL, STGM_READ|STGM_SHARE_EXCLUSIVE,
           NULL, 0, &amp;pStgRoot) == S_OK);
    ASSERT(pStgRoot != NULL);

    LPSTORAGE pStgSub;
    VERIFY(pStgRoot-&gt;OpenStorage(CEx28bDoc::s_szSub, NULL,
           STGM_READ|STGM_SHARE_EXCLUSIVE,
           NULL, 0, &amp;pStgSub) == S_OK);
    ASSERT(pStgSub != NULL);

    // Copy the object data from the user storage to the temporary
    //  storage
    VERIFY(pStgSub-&gt;CopyTo(NULL, NULL, NULL, 
           pDoc-&gt;
m_pTempStgSub) == S_OK);
    // Finally, load the object -- pClientSite not necessary
    LPOLECLIENTSITE pClientSite =
        (LPOLECLIENTSITE) pDoc-&gt;GetInterface(&amp;IID_IOleClientSite);
    ASSERT(pClientSite != NULL);
    pDoc-&gt;DeleteContents();
    VERIFY(::OleLoad(pDoc-&gt;m
_pTempStgSub, IID_IOleObject,
           pClientSite, (void**) &amp;pDoc-&gt;
m_lpOleObj) == S_OK);
    SetViewAdvise();
    pStgSub-&gt;Release();
    pStgRoot-&gt;Release();
    GetSize();
    pDoc-&gt;SetModifiedFlag();
    pDoc-&gt;UpdateAllViews(NULL);
}

void CEx28bView::OnEditInsertobject() 
{
    CEx28bDoc* pDoc = GetDocument();
    COleInsertDialog dlg;
    if(dlg.DoModal() == IDCANCEL) return;
    // no addrefs done for GetInterface
    LPOLECLIENTSITE pClientSite =
        (LPOLECLIENTSITE) pDoc-&gt;GetInterface(&amp;IID_IOleClientSite);
    ASSERT(pClientSite != NULL);
    pDoc-&gt;DeleteContents();
    VERIFY(::OleCreate(dlg.GetClassID(), IID_IOleObject,
           OLERENDER_DRAW, NULL, pClientSite, pDoc-&gt;m_pTempStgSub,
           (void**) &amp;pDoc-&gt;
m_lpOleObj) == S_OK);
    SetViewAdvise();

    pDoc-&gt;m_lpOleObj-&gt;DoVerb(OLEIVERB_SHOW, NULL, pClientSite, 0, 
        NULL, NULL); // OleRun doesn't show it
    SetNames();
    GetDocument()-&gt;SetModifiedFlag();
    GetSize();
    pDoc-&gt;UpdateAllViews(NULL);
}

void CEx28bView::OnUpdateEditInsertobject(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable(GetDocument()-&gt;m_lpOleObj == NULL);
}

void CEx28bView::OnLButtonDown(UINT nFlags, CPoint point) 
{
    TRACE(&quot;**Entering CEx28bView::OnLButtonDown -- point = &quot;
          &quot;(%d, %d)\n&quot;, point.x, point.y);
    if(m_tracker.Track(this, point, FALSE, NULL)) {
        CClientDC dc(this);
        OnPrepareDC(&amp;dc);
        m_rectTracker = 
m_tracker.m_rect;
        dc.DPtoLP(
m_rectTracker); // Update logical coords
        GetDocument()-&gt;UpdateAllViews(NULL);
    }
    TRACE(&quot;**Leaving CEx28bView::OnLButtonDown\n&quot;);
}

void CEx28bView::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
    if(m_tracker.HitTest(point) == CRectTracker::hitNothing) return;
    // Activate the object
    CEx28bDoc* pDoc = GetDocument();
    if(pDoc-&gt;m_lpOleObj != NULL) {
        LPOLECLIENTSITE pClientSite =
            (LPOLECLIENTSITE) 
             pDoc-&gt;GetInterface(&amp;IID_IOleClientSite);
        ASSERT(pClientSite != NULL);
        VERIFY(pDoc-&gt;
m_lpOleObj-&gt;DoVerb(OLEIVERB_OPEN, NULL,
               pClientSite, 0,GetSafeHwnd(), CRect(0, 0, 0, 0))
               == S_OK);
        SetNames();
        GetDocument()-&gt;SetModifiedFlag();
    }
}

BOOL CEx28bView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
    if(m_tracker.SetCursor(pWnd, nHitTest)) {
        return TRUE;
    }
    else {
        return CScrollView::OnSetCursor(pWnd, nHitTest, message);
    }
}

////////////////////////////////////////////////////////////////////

void CEx28bView::SetViewAdvise() 
{
    CEx28bDoc* pDoc = GetDocument();
    if(pDoc-&gt;m_lpOleObj != NULL) {
        LPVIEWOBJECT2 pViewObj;
        pDoc-&gt;
m_lpOleObj-&gt;QueryInterface(IID_IViewObject2, 
            (void**) &amp;pViewObj);
        LPADVISESINK pAdviseSink = 
            (LPADVISESINK) pDoc-&gt;GetInterface(&amp;IID_IAdviseSink);
        VERIFY(pViewObj-&gt;SetAdvise(DVASPECT_CONTENT, 0, pAdviseSink)
            == S_OK);
        pViewObj-&gt;Release();
    }
}

void CEx28bView::SetNames() // sets host names
{
    CEx28bDoc* pDoc = GetDocument();
    CString strApp = AfxGetApp()-&gt;
m_pszAppName;
    if(pDoc-&gt;m_lpOleObj != NULL) {
        pDoc-&gt;
m_lpOleObj-&gt;SetHostNames(strApp.AllocSysString(),
        NULL);
    }
}

void CEx28bView::GetSize()
{
    CEx28bDoc* pDoc = GetDocument();
    if(pDoc-&gt;m_lpOleObj != NULL) {
        SIZEL size;      // Ask the component for its size
        pDoc-&gt;
m_lpOleObj-&gt;GetExtent(DVASPECT_CONTENT, &amp;size);
        m_rectTracker.right = m_rectTracker.left + size.cx;
        m_rectTracker.bottom = m_rectTracker.top - size.cy;
    }
}

BOOL CEx28bView::DoPasteObject(COleDataObject* pDataObject)
{
    TRACE(&quot;Entering CEx28bView::DoPasteObject\n&quot;);
    // Update command UI should keep us out of here if not 
    //  CF_EMBEDDEDOBJECT
    if (!pDataObject-&gt;IsDataAvailable(m_cfEmbedded)) {
        TRACE(&quot;CF_EMBEDDEDOBJECT format is unavailable\n&quot;);
        return FALSE;
    }
    CEx28bDoc* pDoc = GetDocument();
    // Now create the object from the IDataObject*.
    //  OleCreateFromData will use CF_EMBEDDEDOBJECT format if
    //  available.
    LPOLECLIENTSITE pClientSite = 
        (LPOLECLIENTSITE) pDoc-&gt;GetInterface(&amp;IID_IOleClientSite);
    ASSERT(pClientSite != NULL);
    VERIFY(::OleCreateFromData(pDataObject-&gt;m_lpDataObject,
           IID_IOleObject, OLERENDER_DRAW, NULL, pClientSite,
           pDoc-&gt;
m_pTempStgSub, (void**) &amp;pDoc-&gt;m_lpOleObj) == S_OK);
    return TRUE;
}

BOOL CEx28bView::DoPasteObjectDescriptor(COleDataObject* pDataObject)
{
    TRACE(&quot;Entering CEx28bView::DoPasteObjectDescriptor\n&quot;);
    STGMEDIUM stg;

    FORMATETC fmt;
    CEx28bDoc* pDoc = GetDocument();
    if (!pDataObject-&gt;IsDataAvailable(m_cfObjDesc)) {
        TRACE(&quot;OBJECTDESCRIPTOR format is unavailable\n&quot;);
        return FALSE;
    }
    SETFORMATETC(fmt, m_cfObjDesc, DVASPECT_CONTENT, NULL, 
        TYMED_HGLOBAL, -1);
    VERIFY(pDataObject-&gt;GetDatam_cfObjDesc, &amp;stg, &amp;fmt));

    return TRUE;
}

// helper function used for clipboard and drag-drop 
COleDataSource* CEx28bView::SaveObject()
{
    TRACE(&quot;Entering CEx28bView::SaveObject\n&quot;);
    CEx28bDoc* pDoc = GetDocument();
    if (pDoc-&gt;m_lpOleObj != NULL) {
        COleDataSource* pSource = new COleDataSource();

        // CODE FOR OBJECT DATA
        FORMATETC fmte;
        SETFORMATETC(fmte, m_cfEmbedded, DVASPECT_CONTENT, NULL,
            TYMED_ISTORAGE, -1);
        STGMEDIUM stgm;
        stgm.tymed = TYMED_ISTORAGE;
        stgm.pstg = pDoc-&gt;m_pTempStgSub;
        stgm.pUnkForRelease = NULL;
        pDoc-&gt;m_pTempStgSub-&gt;AddRef();   // must do both!
        pDoc-&gt;m_pTempStgRoot-&gt;AddRef();
        pSource-&gt;CacheData(m_cfEmbedded, &amp;stgm, &amp;fmte);

        // metafile needed too
        MakeMetafilePict(pSource);

        // CODE FOR OBJECT DESCRIPTION DATA
        HGLOBAL hObjDesc = ::GlobalAlloc(GMEM_SHARE,
            sizeof(OBJECTDESCRIPTOR));
        LPOBJECTDESCRIPTOR pObjDesc =
            (LPOBJECTDESCRIPTOR) ::GlobalLock(hObjDesc);
        pObjDesc-&gt;cbSize = sizeof(OBJECTDESCRIPTOR);
        pObjDesc-&gt;clsid = CLSID_NULL;
        pObjDesc-&gt;dwDrawAspect = 0;
        pObjDesc-&gt;dwStatus = 0;
        pObjDesc-&gt;dwFullUserTypeName = 0;
        pObjDesc-&gt;dwSrcOfCopy = 0;
        pObjDesc-&gt;sizel.cx = 0;
        pObjDesc-&gt;sizel.cy = 0;
        pObjDesc-&gt;pointl.x = 0;
        pObjDesc-&gt;pointl.y = 0;
        ::GlobalUnlock(hObjDesc);
        pSource-&gt;CacheGlobalData(
m_cfObjDesc, hObjDesc);
        return pSource;
    }
    return NULL;
}

BOOL CEx28bView::MakeMetafilePict(COleDataSource* pSource)
{
    CEx28bDoc* pDoc = GetDocument();
    COleDataObject dataObject;
    LPDATAOBJECT pDataObj; // OLE object's IDataObject interface
    VERIFY(pDoc-&gt;m_lpOleObj-&gt;QueryInterface(IID_IDataObject,
          (void**) &amp;pDataObj) == S_OK);
    dataObject.Attach(pDataObj);
    FORMATETC fmtem;
    SETFORMATETC(fmtem, CF_METAFILEPICT, DVASPECT_CONTENT, NULL,
        TYMED_MFPICT, -1);
    if (!dataObject.IsDataAvailable(CF_METAFILEPICT, &amp;fmtem)) {
        TRACE(&quot;CF_METAFILEPICT format is unavailable\n&quot;);
        return FALSE;
    }
    // Just copy the metafile handle from the OLE object
    //  to the clipboard data object
    STGMEDIUM stgmm;
    VERIFY(dataObject.GetData(CF_METAFILEPICT, &amp;stgmm, &amp;fmtem));
    pSource-&gt;CacheData(CF_METAFILEPICT, &amp;stgmm, &amp;fmtem);
    return TRUE;
}
</pre>

</TD></TR></TABLE>
<P><B>Figure 28-6.</B> <I>The container's </I>CEx28bView<I> class listing.</I>


<P>Study the message map and the associated command handlers. They're all relatively short, and they mostly call the OLE functions described earlier. A few private helper functions need some explanation, however.

<DIV CLASS=note>
<BLOCKQUOTE>
<IMG SRC="note.jpg" width=123 height=18 BORDER=0><P>
You'll see many calls to a <I>GetInterface</I> function. This is a member of class <I>CCmdTarget</I> and returns the specified OLE interface pointer for a class in your project. It's used mostly to get 
the <I>IOleClientSite</I> interface pointer for your document. It's more efficient than calling 
<I>ExternalQueryInterface</I>, but it doesn't increment the object's reference count.</blockquote></div>

<A NAME="685"><H3><B><I>GetSize</I></B></H3></A>
<P>This function calls <I>IOleObject::GetSize</I> to get the embedded object's extents, which it converts to a rectangle for storage in the tracker.

<A NAME="686"><H3><B><I>SetNames</I></B></H3></A>
<P>The <I>SetNames</I> function calls <I>IOleObject::SetHostNames</I> to send the container application's name to the component.

<A NAME="687"><H3><B><I>SetViewAdvise</I></B></H3></A>
<P>This function calls the embedded object's <I>IViewObject2::SetAdvise</I> function to set up the advisory connection from the component object to the container document.

<A NAME="688"><H3><B><I>MakeMetafilePict</I></B></H3></A>
<P>The <I>MakeMetafilePict</I> function calls the embedded object's <I>IDataObject::GetData</I> function to get a metafile picture to copy to the clipboard data object. (A metafile picture, by the way, is a Windows <I>METAFILEPICT</I> structure instance, which contains a pointer to the metafile plus extent information.)

<A NAME="689"><H3><B><I>SaveObject</I></B></H3></A>
<P>This function acts like the <I>SaveDib</I> function in the EX25A example. It creates a <I>COleDataSource</I> object with three formats: embedded object, metafile, and object descriptor.

<A NAME="690"><H3><B><I>DoPasteObjectDescriptor</I></B></H3></A>
<P>The <I>DoPasteObjectDescriptor</I> function pastes an object descriptor from the clipboard but doesn't do anything with it. This function must be called prior to calling <I>DoPasteObject</I>.

<A NAME="691"><H3><B><I>DoPasteObject</I></B></H3></A>
<P>This function calls <I>OleCreateFromData</I> to create an embedded object from an embedded object format on the clipboard.

<A NAME="692"><H2><B>The <I>CEx28bDoc</I> Class</B></H2></A>
<P>This class implements the <I>IOleClientSite</I> and <I>IAdviseSink</I> interfaces. Because of our one-embedded-item-per-document simplification, we don't need to track separate site objects. The document <U>is</U> the site. We're using the standard MFC interface macros, and, as always, we must provide at least a skeleton function for <U>all</U> interface members.

<P>Look carefully at the functions <I>XOleClientSite::SaveObject</I>, <I>XOleClientSite::OnShowWindow</I>, and <I>XAdviseSink::OnViewChange</I> in Figure 28-7. They're the important ones. The other ones are less important, but they contain TRACE statements as well, so you can watch the functions as they're called by the handler. Look also at the <I>OnNewDocument</I>, <I>OnCloseDocument</I>, and <I>DeleteContents</I> functions of the <I>CEx28bView</I> class. Notice how the document is managing a temporary storage. The document's <I>m_pTempStgSub</I> data member holds the storage pointer for the embedded object, and the <I>m_lpOleObj</I> data member holds the embedded object's <I>IOleObject</I> pointer.

<TABLE cellpadding=5 width="95%"><TR><TD>
<P><B>EX28BDOC.H</B>

<P><pre>
#if !defined(AFX_EX28BDOC_H__1EAAB6DF_6011_11D0_848F_00400526305B__INCLUDED_)
#define AFX_EX28BDOC_H__1EAAB6DF_6011_11D0_848F_00400526305B__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif //_MSC_VER &gt; 1000

void ITrace(REFIID iid, const char* str);

class CEx28bDoc : public CDocument
{
protected: // create from serialization only
    CEx28bDoc();
    DECLARE_DYNCREATE(CEx28bDoc)
    BEGIN_INTERFACE_PART(OleClientSite, IOleClientSite)
        STDMETHOD(SaveObject)();
        STDMETHOD(GetMoniker)(DWORD, DWORD, LPMONIKER*);
        STDMETHOD(GetContainer)(LPOLECONTAINER*);
        STDMETHOD(ShowObject)();
        STDMETHOD(OnShowWindow)(BOOL);
        STDMETHOD(RequestNewObjectLayout)();
    END_INTERFACE_PART(OleClientSite)

    BEGIN_INTERFACE_PART(AdviseSink, IAdviseSink)
        STDMETHOD_(void,OnDataChange)(LPFORMATETC, LPSTGMEDIUM);
        STDMETHOD_(void,OnViewChange)(DWORD, LONG);
        STDMETHOD_(void,OnRename)(LPMONIKER);
        STDMETHOD_(void,OnSave)();
        STDMETHOD_(void,OnClose)();
    END_INTERFACE_PART(AdviseSink)

    DECLARE_INTERFACE_MAP()

friend class CEx28bView;
private:
    LPOLEOBJECT m_lpOleObj;
    LPSTORAGE m_pTempStgRoot;
    LPSTORAGE m_pTempStgSub;
    BOOL m_bHatch;
    static const OLECHAR* s_szSub;
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CEx28bDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive&amp; ar);
    virtual void OnCloseDocument();
    virtual void DeleteContents();
    protected:
    virtual BOOL SaveModified();
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CEx28bDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CEx28bDoc)
    afx_msg void OnEditClearAll();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations
//  immediately before the previous line.

#endif 
// !defined(AFX_EX28BDOC_H__1EAAB6DF_6011_11D0_848F_00400526305B__INCLUDED_)
<B>EX28BDOC.CPP</B>
#include &quot;stdafx.h&quot;
#include &quot;ex28b.h&quot;

#include &quot;ex28bDoc.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE
__;
#endif
const OLECHAR* CEx28bDoc::s_szSub = L&quot;sub&quot;;   // static

////////////////////////////////////////////////////////////////////
// CEx28bDoc

IMPLEMENT_DYNCREATE(CEx28bDoc, CDocument)

BEGIN_MESSAGE_MAP(CEx28bDoc, CDocument)
    //{{AFX_MSG_MAP(CEx28bDoc)
    ON_COMMAND(ID_EDIT_CLEAR_ALL, OnEditClearAll)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_INTERFACE_MAP(CEx28bDoc, CDocument)
    INTERFACE_PART(CEx28bDoc, IID_IOleClientSite, OleClientSite)
    INTERFACE_PART(CEx28bDoc, IID_IAdviseSink, AdviseSink)
END_INTERFACE_MAP()

////////////////////////////////////////////////////////////////////
// implementation of IOleClientSite

STDMETHODIMP_(ULONG) CEx28bDoc::XOleClientSite::AddRef()
{
    TRACE(&quot;CEx28bDoc::XOleClientSite::AddRef\n&quot;);
    METHOD_PROLOGUE(CEx28bDoc, OleClientSite)
    return pThis-&gt;InternalAddRef();
}

STDMETHODIMP_(ULONG) CEx28bDoc::XOleClientSite::Release()
{
    TRACE(&quot;CEx28bDoc::XOleClientSite::Release\n&quot;);
    METHOD_PROLOGUE(CEx28bDoc, OleClientSite)
    return pThis-&gt;InternalRelease();
}

STDMETHODIMP CEx28bDoc::XOleClientSite::QueryInterface(
    REFIID iid, LPVOID* ppvObj)
{
    ITrace(iid, &quot;CEx28bDoc::XOleClientSite::QueryInterface&quot;);
    METHOD_PROLOGUE(CEx28bDoc, OleClientSite)
    return pThis-&gt;InternalQueryInterface(&amp;iid, ppvObj);
}

STDMETHODIMP CEx28bDoc::XOleClientSite::SaveObject()
{
    TRACE(&quot;CEx28bDoc::XOleClientSite::SaveObject\n&quot;);
    METHOD_PROLOGUE(CEx28bDoc, OleClientSite)
    ASSERT_VALID(pThis);

    LPPERSISTSTORAGE lpPersistStorage;
    pThis-&gt;m_pOleObj-&gt;QueryInterface(IID_IPersistStorage,
        (void**) &amp;lpPersistStorage);
    ASSERT(lpPersistStorage != NULL);
    HRESULT hr = NOERROR;
    if (lpPersistStorage-&gt;IsDirty() == NOERROR)
    {
        // NOERROR == S_OK != S_FALSE, therefore object is dirty!
        hr = ::OleSave(lpPersistStorage, pThis-&gt;
m_pTempStgSub,
                       TRUE);
        if (hr != NOERROR)
            hr = lpPersistStorage-&gt;SaveCompleted(NULL);

        // Mark the document as dirty if save successful
        pThis-&gt;SetModifiedFlag();
    }
    lpPersistStorage-&gt;Release();
    pThis-&gt;UpdateAllViews(NULL);
    return hr;
}

STDMETHODIMP CEx28bDoc::XOleClientSite::GetMoniker(
    DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER* ppMoniker)
{
    TRACE(&quot;CEx28bDoc::XOleClientSite::GetMoniker\n&quot;);
    return E_NOTIMPL;
}

STDMETHODIMP CEx28bDoc::XOleClientSite::GetContainer(
    LPOLECONTAINER* ppContainer)
{
    TRACE(&quot;CEx28bDoc::XOleClientSite::GetContainer\n&quot;);
    return E_NOTIMPL;
}

STDMETHODIMP CEx28bDoc::XOleClientSite::ShowObject()
{
    TRACE(&quot;CEx28bDoc::XOleClientSite::ShowObject\n&quot;);
    METHOD_PROLOGUE(CEx28bDoc, OleClientSite)
    ASSERT_VALID(pThis);
    pThis-&gt;UpdateAllViews(NULL);
    return NOERROR;
}

STDMETHODIMP CEx28bDoc::XOleClientSite::OnShowWindow(BOOL fShow)
{
    TRACE(&quot;CEx28bDoc::XOleClientSite::OnShowWindow\n&quot;);
    METHOD_PROLOGUE(CEx28bDoc, OleClientSite)
    ASSERT_VALID(pThis);
    pThis-&gt;m_bHatch = fShow;
    pThis-&gt;UpdateAllViews(NULL);
    return NOERROR;
}
STDMETHODIMP CEx28bDoc::XOleClientSite::RequestNewObjectLayout()
{
    TRACE(&quot;CEx28bDoc::XOleClientSite::RequestNewObjectLayout\n&quot;);
    return E_NOTIMPL;
}

////////////////////////////////////////////////////////////////////
// implementation of IAdviseSink

STDMETHODIMP_(ULONG) CEx28bDoc::XAdviseSink::AddRef()
{
    TRACE(&quot;CEx28bDoc::XAdviseSink::AddRef\n&quot;);
    METHOD_PROLOGUE(CEx28bDoc, AdviseSink)
    return pThis-&gt;InternalAddRef();
}

STDMETHODIMP_(ULONG) CEx28bDoc::XAdviseSink::Release()
{
    TRACE(&quot;CEx28bDoc::XAdviseSink::Release\n&quot;);
    METHOD_PROLOGUE(CEx28bDoc, AdviseSink)
    return pThis-&gt;InternalRelease();
}
STDMETHODIMP CEx28bDoc::XAdviseSink::QueryInterface(
    REFIID iid, LPVOID* ppvObj)

{
    ITrace(iid, &quot;CEx28bDoc::XAdviseSink::QueryInterface&quot;);
    METHOD_PROLOGUE(CEx28bDoc, AdviseSink)
    return pThis-&gt;InternalQueryInterface(&amp;iid, ppvObj);
}

STDMETHODIMP_(void) CEx28bDoc::XAdviseSink::OnDataChange(
    LPFORMATETC lpFormatEtc, LPSTGMEDIUM lpStgMedium)
{
    TRACE(&quot;CEx28bDoc::XAdviseSink::OnDataChange\n&quot;);
    METHOD_PROLOGUE(CEx28bDoc, AdviseSink)
    ASSERT_VALID(pThis);

    // Interesting only for advanced containers. Forward it such
    //  that containers do not have to implement the entire
    //  interface.
}

STDMETHODIMP_(void) CEx28bDoc::XAdviseSink::OnViewChange(
    DWORD aspects, LONG /*lindex*/)
{
    TRACE(&quot;CEx28bDoc::XAdviseSink::OnViewChange\n&quot;);
    METHOD_PROLOGUE(CEx28bDoc, AdviseSink)
    ASSERT_VALID(pThis);

    pThis-&gt;UpdateAllViews(NULL);        // the really important one
}

STDMETHODIMP_(void) CEx28bDoc::XAdviseSink::OnRename(
    LPMONIKER /*lpMoniker*/)
{
    TRACE(&quot;CEx28bDoc::XAdviseSink::OnRename\n&quot;);
    // Interesting only to the OLE link object. Containers ignore
    //  this.
}

STDMETHODIMP_(void) CEx28bDoc::XAdviseSink::OnSave()
{
    TRACE(&quot;CEx28bDoc::XAdviseSink::OnSave\n&quot;);
    METHOD_PROLOGUE(CEx28bDoc, AdviseSink)
    ASSERT_VALID(pThis);

    pThis-&gt;UpdateAllViews(NULL);
}
STDMETHODIMP_(void) CEx28bDoc::XAdviseSink::OnClose()
{
    TRACE(&quot;CEx28bDoc::XAdviseSink::OnClose\n&quot;);
    METHOD_PROLOGUE(CEx28bDoc, AdviseSink)
    ASSERT_VALID(pThis);

    pThis-&gt;UpdateAllViews(NULL);
}

////////////////////////////////////////////////////////////////////
// CEx28bDoc construction/destruction

CEx28bDoc::CEx28bDoc()
{
    m_lpOleObj = NULL;
    m_pTempStgRoot = NULL;
    m_pTempStgSub = NULL;
    m_bHatch = FALSE;
}

CEx28bDoc::~CEx28bDoc()
{
}

BOOL CEx28bDoc::OnNewDocument()
{
    TRACE(&quot;Entering CEx28bDoc::OnNewDocument\n&quot;);
    // Create a structured storage home for the object
    //  (m_pTempStgSub). This is a temporary file -- random name
    //  supplied by OLE.
    VERIFY(::StgCreateDocfile(NULL,
           STGM_READWRITE|STGM_SHARE_EXCLUSIVE|STGM_CREATE|
           STGM_DELETEONRELEASE,
           0, &amp;m_pTempStgRoot) == S_OK);
    ASSERT(m_pTempStgRoot != NULL);

    VERIFY(m_pTempStgRoot-&gt;CreateStorage(OLESTR(&quot;sub&quot;),
           STGM_CREATE|STGM_READWRITE|STGM_SHARE_EXCLUSIVE,
           0, 0, &amp;m_pTempStgSub) == S_OK);
    ASSERT(m_pTempStgSub != NULL);
    return CDocument::OnNewDocument();
}

////////////////////////////////////////////////////////////////////
// CEx28bDoc serialization

void CEx28bDoc::Serialize(CArchive&amp; ar)
{
    // no hookup to MFC serialization
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
}

////////////////////////////////////////////////////////////////////
// CEx28bDoc diagnostics

#ifdef _DEBUG
void CEx28bDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CEx28bDoc::Dump(CDumpContext&amp; dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

////////////////////////////////////////////////////////////////////
// CEx28bDoc commands

void CEx28bDoc::OnCloseDocument() 
{
    m_pTempStgSub-&gt;Release(); // must release BEFORE calling
                              //  base class
    m_pTempStgRoot-&gt;Release();
    CDocument::OnCloseDocument();
}

void CEx28bDoc::DeleteContents() 
{
    if(m_lpOleObj != NULL) {
        // If object is running, close it, which releases our
        //  IOleClientSite
        m_lpOleObj-&gt;Close(OLECLOSE_NOSAVE);
        m_lpOleObj-&gt;Release(); // should be final release
                               //  (or else...)
        m_lpOleObj = NULL;
    }
}

void CEx28bDoc::OnEditClearAll() 
{
    DeleteContents();
    UpdateAllViews(NULL);
    SetModifiedFlag();
    m_bHatch = FALSE;
}

BOOL CEx28bDoc::SaveModified() 
{
    // Eliminate &quot;save to file&quot; message
    return TRUE;
}

void ITrace(REFIID iid, const char* str)
{
    OLECHAR* lpszIID;
    ::StringFromIID(iid, &amp;lpszIID);
    CString strIID = lpszIID;
    TRACE(&quot;%s - %s\n&quot;, (const char*) strIID, (const char*) str);
    AfxFreeTaskMem(lpszIID);
}
</pre>
</TD></TR></TABLE>

<P><B>Figure 28-7.</B> <I>The container's </I>CEx28bDoc <I>class listing.</I>


</BODY>
</HTML>


