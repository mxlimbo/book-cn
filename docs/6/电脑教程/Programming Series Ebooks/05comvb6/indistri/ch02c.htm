<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="Library.css" TYPE="text/css">
<TITLE>Implementation Inheritance</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch02b.htm", "ch02d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="17"><H1>Implementation Inheritance</H1></A>

<p>Many of the features of OOP are meant to give programmers higher levels of code reuse. Languages such as C++, Smalltalk, and Java offer a popular feature known as <I>implementation inheritance,</I> which offers one of many possible ways to achieve code reuse in an object-oriented paradigm. Some people argue that a language must offer implementation inheritance to be considered a real object-oriented language. This has led to a heated debate in both the software industry and the academic community&#8212;a debate that this book will not address. Instead, we will focus on the benefits and problems associated with this powerful feature.

<P>In implementation inheritance, one class is defined to reuse the code of another class. The class that is reused is called the <I>superclass</I>. The class that benefits from the reuse is the <I>subclass</I>. Visual Basic doesn't currently support implementation inheritance, so I will use a Java example to illustrate what implementation inheritance looks like. Examine the following Java class <I>CDog</I>:

<p><pre>
// superclass
class CDog
{
    // dog state
    public String Name;

    // dog behavior
    public void Bark()
        {/* method implementation */}
    public void RollOver(int Rolls)
        {/* method implementation */}
}
</PRE>

<p>The class <I>CDog </I>contains a property and two methods. Assume that each method has been defined with a valuable implementation. You can reuse the state and the behavior of the class by using implementation inheritance. <I>CDog </I>will be used as a superclass. A subclass that extends <I>CDog </I>will inherit both the class properties and the method implementations. The following Java code shows the syntax required to achieve implementation inheritance:

<p><pre>
// subclass
class CBeagle extends CDog
{
    // beagle state
    // Name property is inherited.
    // A color property is added.
    Public String Color;

    // beagle behavior
    // Implementation of RollOver() is inherited.
    // Implementation of Bark() is overridden.
    public void Bark()
        {/* CBeagle-specific implementation */}
    // CBeagle extends CDog by adding a new method.
    public void FetchSlippers()
        {/* CBeagle-specific implementation */}
}
</PRE>

<p>When <I>CBeagle </I>(the subclass) extends <I>CDog </I>(the superclass), it inherits all of the existing properties and method implementations. This means that <I>CBeagle </I>can reuse all of the state and behavior defined in <I>CDog</I>. You can then extend <I>CDog </I>by overriding existing methods such as <I>Bark </I>and adding methods such as <I>FetchSlippers </I>in CBeagle. You can also add new properties to the subclass definition.

<P>You should use implementation inheritance only when a logical &quot;is a&quot; relationship exists between the subclass and the superclass. In this example, you can say, &quot;A beagle is a dog,&quot; as shown in Figure 2-1. As long as the &quot;is a&quot; requirement is met, implementation inheritance is useful for achieving code reuse. Implementation inheritance can be especially valuable when an application contains many classes that must exhibit a common behavior. The commonality of several classes can be hoisted to a superclass. For example, once the <I>CDog </I>class has been written, it can be extended by <I>CBeagle</I>, <I>CTerrier</I>, <I>CBoxer</I>, and any other class that &quot;is a&quot; dog. Code written to define state and behavior in the <I>CDog </I>class can be reused in many other classes.<BR>

<P><A HREF="javascript:fullSize('F02wg01x.htm')"> <img src="images/F02wg01.JPG" width=404 height=163 border=0 ALT = "Click to view at full size."> </A>

<p><!-- caption --><B>Figure 2-1.</B> <I>Implementation inheritance allows one class to reuse the state and the behavior of another.</I><!-- /caption -->

<p>Figure 2-2 is a graphic representation of what is known as an <I>inheritance hierarchy</I>. The hierarchy shows the relationships among the various classes in the application. This hierarchy is simple; you can create others that are far more complex. Imagine a hierarchy in which <I>CScottie </I>extends <I>CTerrier</I>,<I> </I>which extends <I>CDog</I>,<I> </I>which extends <I>CMammal</I>,<I> </I>which extends <I>CAnimal</I>. As you can imagine, inheritance hierarchies can become large and complex. Hierarchies containing five or more levels aren't uncommon in production code.<BR>

<P><A HREF="javascript:fullSize('F02wg02x.htm')"> <img src="images/F02wg02.JPG" width=404 height=255 border=0 ALT = "Click to view at full size."> </A>

<p><!-- caption --><B>Figure 2-2.</B> <I>An inheritance hierarchy shows the relationships between the superclasses and the subclasses in an application.</I><!-- /caption -->

<P>When implementation inheritance is used correctly, it can be a powerful mechanism for code maintenance. When you improve the implementation of a method in a superclass, all the classes down the inheritance hierarchy automatically benefit from the changes. A bug fix to the <I>CAnimal </I>class can potentially improve hundreds of other classes. As the inheritance hierarchy becomes larger and more complex, modifications to classes at the top can have a significant impact on many classes below. This implies that a single modification can affect the behavior of many distinct object types.

<A NAME="18"><H2>What Is Polymorphism?</H2></A>

<p>So far, this chapter has explained how implementation inheritance offers the implicit reuse of method implementations, which results in greater maintainability through the elimination of duplicate code. Another powerful OOP feature provided by implementation inheritance is known as <I>polymorphism</I>. This is arguably the most important concept in object-oriented programming. Polymorphism allows a client to treat different objects in the same way, even if they were created from different classes and exhibit different behaviors.

<p>You can use implementation inheritance to achieve polymorphism in languages such as C++ and Java. For instance, you can use a superclass reference to connect to and invoke methods on subclass instances. Figure 2-3 shows how a client can use a <I>CDog </I>reference to communicate with three different types of objects. Each subclass that derives from <I>CDog </I>is type-compatible with a <I>CDog </I>reference. Therefore, a client can use a <I>CDog </I>reference when communicating with objects of type <I>CBeagle</I>, <I>CRetriever</I>, or <I>CBoxer</I>.

<p><IMG SRC="images/F02wg03.gif" width=373 height=307 border=0>

<p><!-- caption --><B>Figure 2-3.</B> <I>You can achieve polymorphism by using a superclass reference to communicate with subclass instances. A client can use a </I>CDog <I>reference to communicate with any </I>CDog<I>-compatible object.</I><!-- /caption -->

<p>A client can be sure that any class that extends the <I>CDog </I>class provides an implementation of the <I>Bark </I>method. The client doesn't care if the subclass uses the definition of <I>Bark </I>that was supplied by <I>CDog </I>or if the subclass has overridden this method with its own implementation. The client simply invokes the method using the calling syntax defined in the <I>CDog </I>class. However, if each subclass supplies its own implementation of <I>Bark</I>, each object type can respond in its own unique way to the same request. Examine the following Java code:

<p><pre>
// Method accepts any CDog-compatible object.
Public void MakeDogBark(CDog Dog)
{
    // Different objects can respond differently.
    Dog.Bark()
}
</PRE>

<p>If this method is invoked using a <I>CBeagle </I>object, it might have very different results than if it is invoked using a <I>CTerrier </I>object. The client code knows which method to call, but it has no idea how the <I>Bark </I>method will be carried out. The calling syntax is well defined at compile time, but the actual method implementation is not determined until run time. Polymorphism is based on the idea of <I>dynamic binding </I>as opposed to static binding. Dynamic binding provides a degree of controlled uncertainty that makes polymorphism extremely powerful. You can create applications based on <I>plug-compatible</I> objects. If thousands of lines of client code have been written to <I>CDog</I>'s public interface, you can easily replace a <I>CBeagle </I>object with a <I>CTerrier </I>object or a <I>CBoxer </I>object. Such a change has little or no impact on client code because client code has dependencies on the <I>CDog </I>class but not on any of the classes that extend it.

<A NAME="19"><H2>Problems Associated with Implementation Inheritance</H2></A>

<p>So far, this chapter has explored the two biggest benefits of implementation inheritance: the implicit reuse of method implementations and polymorphism. It has not yet covered some of the potential problems with implementation inheritance. Unfortunately, implementation inheritance makes an application more susceptible to the kinds of dependency problems associated with class-based references because of the tight coupling between a subclass and its superclass.

<p>With the proper use of encapsulation, you can hide implementation details from clients. This allows you to freely change the implementation details of the class without breaking client code. The problem with implementation inheritance is that it breaks the encapsulation of nonpublic members. Languages that offer implementation inheritance provide a <I>protected </I>level of visibility in addition to public and private. Properties and methods that are marked as protected are hidden from a client but are accessible from subclasses. Subclasses therefore have access to implementation details that have been hidden from the client. As you hardcode the names of protected properties and methods of a superclass into a subclass, another layer of inflexible dependencies is created.

<p>Implementation inheritance is an example of a development style known as <I>white-box reuse. </I>Applications that are built on white-box reuse often experience tight coupling between the classes in the inheritance hierarchy. Once a subclass uses a protected property or method, you can't change the superclass's signature or remove it without breaking dependencies built into subclasses. This leads to fragility in applications with large inheritance hierarchies. Changing the classes at the top of the hierarchy often requires modifications to many subclasses. In some applications, changing a method signature or a property type at the top of the hierarchy can result in breaking tens or hundreds of classes down the inheritance chain. On the other hand, freezing the public and protected interfaces of key superclasses usually results in a system that can't evolve.

<p> As in the case of simple class design, you must carefully consider whether to give a property or a method protected visibility. Proper design using implementation inheritance requires a high level of expertise and discipline to prevent what is known as the <I>fragile superclass scenario</I>. You should know whether a class will be extended by other subclasses. If you expect a class to be extended, it's as important to encapsulate implementation details from subclasses as it is to encapsulate them from clients.

<p>This isn't to suggest that implementation inheritance isn't useful. It's powerful in appropriate development scenarios. It's best used in smaller, controlled situations. Creating a large inheritance hierarchy that can evolve along with the requirements of an application is beyond the reach of all but the most experienced object-oriented designers.

<P>When C++ and Smalltalk were first introduced, the OOP evangelists oversold implementation inheritance as a cure-all technique to achieve code reuse. As a result, this feature has been abused by designers who haven't understood the coupling problems that accompany white-box reuse. Over the past decade, the casual use of implementation inheritance has crippled the evolution of many large systems. Experienced developers who knew that implementation inheritance was most appropriate in small doses continued to look for more flexible ways to achieve reuse on a large scale. In particular, they looked for ways to achieve reuse without compromising extensibility in larger systems. This fueled the birth of interface-based programming and a development style known as <I>object composition</I>.

</BODY>
</HTML>






