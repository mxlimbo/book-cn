<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="Library.css" TYPE="text/css">
<TITLE>Automation</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04b.htm", "ch04d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="47"><H1>Automation</H1></A>

<p>In the early days, COM was accessible only to C and C++ programmers because of the raw nature of vTable binding. IDL and type libraries then made it possible for development tools such as Visual Basic 4 to build the required vTable bindings at compile time. However, some languages and development environments still can't make sense of a type library. If a client doesn't have the information from a server's type library, it can't build vTable bindings against a user-defined interface. COM addresses this problem with a run-time binding mechanism known as <I>automation</I>.

<p>Microsoft was motivated to build automation into the development culture of COM because such an extension would result in many more COM programmers. Automation gives COM greater language independence. The original version of automation (which was called <I>OLE automation</I>) shipped at roughly the same time as Visual Basic 3. Previous versions of Visual Basic didn't include any COM support, so automation was the first means by which a Visual Basic programmer could use a COM object created by a C++ programmer.

<p>The COM team and the Visual Basic team worked hard together to make automation work with Visual Basic 3. Version 4 added support for type libraries, so Visual Basic is no longer limited to automation when creating COM clients. However, many languages and tools still rely on automation. For instance, most of Microsoft's Web-based technologies use languages such as VBScript and JavaScript, which cannot build custom vTable bindings. Programmers in these languages rely instead on automation when they need to access a COM object.

<A NAME="48"><h2>The <I>IDispatch </I>Interface</h2></A>
<p>Automation relies on an interface named <I>IDispatch</I>, which allows clients to discover method bindings at run time in a process known as <I>late binding</I>. The vTable that represents <I>IDispatch </I>is shown in Figure 4-2. <I>IDispatch </I>extends <I>IUnknown </I>by adding four methods. Automation clients use <I>GetIDsOfNames</I> and <I>Invoke</I> to achieve late binding. As in the case of <I>IUnknown</I>, Visual Basic programmers never deal with this interface directly. Instead, the Visual Basic mapping layer translates your code and makes the calls to <I>IDispatch </I>methods.

<p><A HREF="javascript:fullSize('F04wg02x.htm')"> <img src="images/F04wg02.JPG" width=404 height=181 border=0 ALT = "Click to view at full size."> </A> 

<p><!-- caption --><B>Figure 4-2.</B> <I>Automation clients bind to a vTable that represents the </I>IDispatch <I>interface. An automation client achieves late binding by calling </I>GetIDsOfNames <I>and then </I>Invoke<I>.</I><!-- /caption -->

<p>Here's how automation works. After a client receives an <I>IDispatch </I>reference, it can ask an object whether it supports a particular method by calling <I>GetIDsOfNames</I>. The client must pass the name of the method as a string argument in the call. If the object doesn't support the requested method, the call to <I>GetIDsOfNames </I>fails. If the method is supported, <I>GetIDsOfNames </I>returns a logical identifier for the method called a DISPID. A DISPID is simply an integer that an object provides to identify one of its methods. Positive DISPIDs indicate that a method is user-defined, while negative DISPIDs are reserved for methods with special meanings.

<p>A client armed with a valid DISPID can execute a method through automation by calling <I>Invoke</I>. In fact, <I>Invoke </I>is the only way to execute a user-defined method through the <I>IDispatch </I>interface. As you can see, <I>IDispatch </I>is a single physical interface that allows unsophisticated clients to get at any number of logical operations. In essence, <I>IDispatch </I>represents a standard vTable with a highly flexible invocation architecture. This arrangement allows clients such as VBScript to access many different types of COM objects while knowing about only a single vTable layout. This effectively eliminates the need for a client to build custom binding code from information in a type library.

<p>While <I>IDispatch </I>is very flexible, it isn't very efficient compared to custom vTable binding. Every logical call through <I>IDispatch </I>requires two actual calls. The first call to <I>GetIDsOfNames </I>requires a string lookup in the object to return the proper DISPID to the client. The call to <I>Invoke </I>also requires quite a bit of overhead. This overhead is necessary because of the open-ended nature of this dispatching architecture.

<p>A method can have an arbitrary number of parameters, which can come in all shapes and sizes. Automation deals with this by requiring the client to pass all parameters as an array of variants in the call to <I>Invoke</I>. The array allows the method to define any number of parameters, and the variant type allows each parameter to be self-describing. An object responds to a call to <I>Invoke </I>by resolving the DISPID and unpacking the variant arguments to their proper types. After the object processes a call to <I>Invoke</I>,<I> </I>it must pass the return value to the client as a variant as well.

<p>A client in Visual Basic can go through the <I>IDispatch </I>interface by using the <I>Object</I> data type. This data type is really an <I>IDispatch </I>reference. Here's a Visual Basic example of using <I>IDispatch</I>:

<p><pre>
Dim Dog As Object
Set Dog = CreateObject(&quot;DogServer.CBeagle&quot;)
Dog.Name = &quot;Fankie&quot;
Dog.Bark
</PRE>

<p>When the object is created, an <I>IDispatch </I>reference is assigned to the <I>Object </I>variable <I>Dog</I>. A logical call to a property or a method in Visual Basic code translates to a call to both <I>GetIDsOfNames </I>and <I>Invoke</I>. Visual Basic could optimize automation by caching the DISPIDs of properties and methods, but it doesn't. Each logical call results in two round-trips between the client and the object. When you add the overhead of a call to <I>Invoke</I>, you can see that you don't want to use the <I>Object </I>data type if you don't have to.

<p>Another important thing to keep in mind when you use the <I>Object </I>data type is that you have no type safety. The Visual Basic environment assumes at compile time that any method call through <I>IDispatch </I>will succeed. This means you lose out on wonderful features of the Visual Basic IDE such as compile-time type checking and IntelliSense. You have another reason to avoid using the <I>Object </I>data type.

<A NAME="49"><H2>Dual Interfaces</H2></A>

<p>You should note two key facts about late binding and <I>IDispatch</I>: Late binding and <I>IDispatch</I> are great for clients that can't deal with custom vTable bindings, and they offer slow execution times compared with custom vTables. You can expect a call through a custom vTable binding to be 500 to 1000 times faster than a call using automation for an in-process object.

<p>COM servers that cater to automation clients are often based on <I>dual interfaces</I>. A dual interface offers binding through <I>IDispatch </I>as well as a custom vTable interface. Figure 4-3 compares the vTables for the three types of interfaces. A dual interface is simply a hybrid vTable that combines the two others. It offers  the speed of custom vTable bindings to sophisticated clients created with tools such as C++ and Visual Basic. It also provides a standard implementation of <I>IDispatch </I>for automation clients such as VBScript and JavaScript.

<p><A HREF="javascript:fullSize('F04wg03x.htm')"> <img src="images/F04wg03.JPG" width=404 height=168 border=0 ALT = "Click to view at full size."> </A>

<p><!-- caption --><B>Figure 4-3.</B> <I>A dual interface is a hybrid of an </I>IDispatch <I>interface and a custom interface.</I><!-- /caption -->

<p><I>IDispatch </I>restricts interfaces to using variant-compliant data types. This restriction applies to dual interfaces as well because they must expose every method through <I>IDispatch</I>. This isn't much of a limitation for Visual Basic developers because all the primitive types supplied by Visual Basic are variant-compliant. C++ programmers, on the other hand, are far more restricted because their language gives them many more types to choose from. A C++ programmer who is building a server exclusively for C++ clients might elect to forgo supporting <I>IDispatch </I>or a dual interface in order to use non-variant-compliant data types.

<p>As of version 5, Visual Basic always builds servers using dual interfaces. You don't have to request dual interfaces, and there's nothing you can do to avoid them. When you choose the Make<I> </I>command from the File menu, Visual Basic generates a full-blown dual interface behind every interface in your server. To do this properly, it must also provide a standard implementation of <I>IDispatch </I>behind every creatable class. This means that your Visual Basic objects can cater to both custom vTable clients and automation clients.

<A NAME="50"><H2>Binding Techniques</H2></A>

<p>You can experience three types of binding when you create a client with Visual Basic. <I>Late binding </I>is used whenever the <I>Object </I>data type is used. This is true whether or not you include a type library for the object. Late binding provides the worst performance and no type checking at compile time. Use late binding only when you have no other choice. You can almost always avoid it in Visual Basic code.

<p><I>Early binding </I>occurs when you have an <I>IDispatch</I>-only object but you can use a type library. The client can read the DISPIDs at compile time and embed them in the client executable. This eliminates the need for a call to <I>GetIDsOfNames</I>, but the client still goes through <I>Invoke </I>to execute the method. Early binding is faster than late binding, but it's still much slower than vTable binding. Early binding also allows the Visual Basic IDE to perform compile-time type checking and to use IntelliSense.

<p>Early binding occurs only if you have a type library for an <I>IDispatch </I>object that doesn't provide a dual interface. The consensus among COM programmers is that any object that provides <I>IDispatch </I>should also provide a custom interface whenever possible. However, MFC is an example of a C++ framework that creates <I>IDispatch</I>-only COM objects. Here's another interesting fact. When you place a control on a form, Visual Basic uses early binding instead of vTable binding because controls must use the <I>IDispatch</I> interface to support custom properties.

<p>vTable binding is always best. It is faster than the other two kinds by an order of magnitude. Visual Basic clients always use vTable bindings as long as the following are true:

<UL>
<P><LI>The client project contains a reference to the type library.
<P><LI>The reference is typed to an interface or a creatable class (the default interface).
<P><LI>The object exposes vTables for dual interfaces or for pure vTable interfaces. (That is, the object isn't <I>IDispatch</I>-only.)
</UL>

<A NAME="51"><H2>Supporting both a User-Defined Interface and Automation</H2></A>

<p>Automation clients can use only an object's default interface. They can't call <I>QueryInterface</I>. This makes sense because an automation client can't use a type library and can never ask for a specific IID. When you create objects with Visual Basic, Visual Basic builds the default interface from the public members of a creatable class. You can't change which interface is marked as the default. Consequently, Visual Basic objects can support automation clients only by providing public methods in a creatable class. This means that an automation client can't get at any functionality that you expose through a user-defined interface.

<p>If you are certain that your objects will be used exclusively by automation clients, you can create classes with public methods and avoid user-defined interfaces. This makes the initial design easy. If you are certain that your objects will be used exclusively by clients capable of vTable binding, you can add user-defined interfaces to your designs. Things get tricky when you want to expose functionality through a user-defined interface as well as through automation.

<p>Sometimes a developer needs to expose functionality through both a user-defined interface and automation. In this situation, a Visual Basic programmer must create two sets of entry points into the object. For instance, if the <I>IDog </I>interface contains a single method named <I>Bark</I>, the <I>CBeagle </I>class can provide access to <I>IDog</I>-bound clients as well as to automation clients with the following code:

<p><pre>
&#39;*** vTable client support
Implements IDog

Private Sub IDog_Bark()
    InvokeBark &#39; Forward call
End Sub

&#39;*** Automation client support
Public Sub Bark()
    InvokeBark &#39; Forward call
End Sub

&#39;*** Actual implementation
Private Sub InvokeBark()
    &#39; Your code here
End Sub
</PRE>

<p>As you can see, there's nothing terribly complicated about supporting a user-defined interface and automation at the same time. It's just tedious and can easily lead to errors. You must write the code to forward the incoming requests from each entry point to the appropriate implementation. Of course, you have to do this only if you want to cater to both types of clients. If you are certain that you are dealing with either one type or the other, you don't have to worry about maintaining dual entry points into your objects.

</BODY>
</HTML>






