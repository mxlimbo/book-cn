<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="Library.css" TYPE="text/css">
<TITLE>Separating the Interface from the Implementation</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch02c.htm", "ch02e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="20"><H1>Separating the Interface from the Implementation</H1></A>

<p>Object composition offers another way to achieve reuse without the tendency toward tight coupling. Object composition is based on <I>black-box reuse,</I> in which implementation details of a class are never revealed to the client. Clients know only about an available set of requests. Objects never expose internal details of the response.

<p>Black-box reuse is based on formal separation of interface and implementation. This means that the interface becomes a first-class citizen. An interface is an independent data type that is defined on its own. This is an evolution of classic OOP, in which a public interface is defined within the context of a class definition.

<P>At this point, you are probably thinking that this is all pretty vague. You're asking yourself, &quot;What exactly is an interface?&quot; Unfortunately, it's hard to provide a concise definition that conveys the key concepts of an entirely new way to write software. An interface can be described in many ways. You can get up to speed pretty quickly on the syntax for defining, implementing, and using interfaces. However, the ramifications of interfaces for software design are much harder for the average programmer to embrace. Learning how to design with interfaces usually takes months or years.

<p>At its most basic level, <I>an interface is a set of public method signatures</I>. It defines the calling syntax for a set of logically related client requests. However, while an interface defines method signatures, it can't include any implementation or data properties. By providing a layer of indirection, an interface decouples a class from the clients that use it. This means that an interface must be implemented by one or more classes in order to be useful. Once an interface has been implemented by a class, a client can create an object from the class and communicate with it through an interface reference.

<p>You can use an interface to create an object reference but not the object itself. This makes sense because an object requires data properties and method implementations that cannot be supplied by an interface. Because it isn't a creatable entity, <I>an interface is an abstract data type</I>. Objects can be instantiated only from creatable classes known as <I>concrete data types</I>.

<p>From a design standpoint, <I>an interface is a contract</I>. A class that implements an interface guarantees that the objects it serves up will support a certain type of behavior. More specifically, a class must supply an implementation for each method defined by the interface. When communicating with an object through an interface reference, a client can be sure that the object will supply a reasonable response to each method defined in the interface.

<p>More than one class can implement the same interface. An interface defines the exact calling syntax and the loose semantics for each method. The loose semantics give each class author some freedom in determining the appropriate object behavior for each method. For instance, if the <I>IDog </I>interface defines a method named <I>Bark</I>, different class authors can supply different responses to the same request as long as each somehow reinforces the concept of a dog barking. The <I>CBeagle </I>class can implement <I>Bark </I>in a way that's different from either <I>CTerrier </I>or <I>CBoxer</I>. This means that <I>interfaces provide the opportunity for polymorphism</I>. Interfaces are like implementation inheritance in that they let you build applications composed of plug-compatible objects. But interfaces provide plug compatibility without the risk of the tight coupling that can occur with implementation inheritance and white-box reuse.

<A NAME="21"><H2>The Two Faces of Inheritance</H2></A>

<p>Inheritance is an objected-oriented concept that models an &quot;is a&quot; relationship between two entities. So far, this chapter has used the term <I>implementation inheritance</I> instead of the more generic term <I>inheritance </I>because extending a superclass with a subclass is only one way to leverage an &quot;is a&quot; relationship. When a class implements an interface, it also takes advantage of an &quot;is a&quot; relationship. For instance, if a class <I>CBeagle </I>implements the interface <I>IDog</I>, it is correct to say that a beagle &quot;is a&quot; dog. You can use a <I>CBeagle </I>object in any situation in which an <I>IDog</I>-compatible object is required.

<p>Interface-based programming is founded on a second form of inheritance known as <I>interface inheritance</I>. This means that inheritance doesn't require the reuse of method implementations. Instead, the only true requirement for inheritance is that a subclass instance be compatible with the base type that's being inherited. The base type that's inherited can be a class or a user-defined interface. In either situation, you can use the base-type references to communicate with objects of many different types. This allows both forms of inheritance to achieve polymorphism.

<p>Both implementation inheritance and interface inheritance offer polymorphism, but they differ greatly when it comes to their use of encapsulation. Implementation inheritance is based on white-box reuse. It allows a subclass to know intimate details of the classes it extends. This allows a subclass to experience implicit reuse of a superclass's method implementation and data properties. Implementation inheritance is far more powerful than interface inheritance in terms of reusing state and behavior. However, this reuse comes with a cost. The loss of encapsulation in white-box reuse limits its scalability in large designs.

<p>As the term <I>black-box reuse </I>suggests, interface inheritance enforces the concepts of encapsulation. Strict adherence to the encapsulation of implementation details within classes allows for more scalable application designs. Interface-based programming solves many problems associated with white-box reuse. However, to appreciate this style of programming, you must accept the idea that the benefits are greater than the costs. This is a struggle for many programmers.

<p>When a class implements an interface, it takes on the obligation to provide a set of methods. Subclass authors must write additional code whenever they decide to implement an interface. When you compare this with implementation inheritance, it seems like much more work. When you inherit from a class, most of your work is already done, but when you inherit from an interface, your work has just begun. At first glance, implementation inheritance looks and smells like a cheeseburger, while interface inheritance looks like a bowl of steamed broccoli. You have to get beyond the desire to have the cheeseburger to reach a higher level of interface awareness. The key advantage of interface inheritance over implementation inheritance is that interface inheritance isn't vulnerable to the tight coupling that compromises the extensibility of an application.

<A NAME="22"><H2>Using Interfaces with Visual Basic</H2></A>

<p>Visual Basic 5.0 was the first version of the product to support user-defined interfaces. You can achieve the benefits of interface-based programming with a Visual Basic project by following these three required steps:

<OL>
<P><LI>Define an interface.
<P><LI>Implement the interface in one or more creatable classes.
<P><LI>Use an interface reference in a client to communicate with objects.
</OL>


<p>As you can see, the basic steps for adding interfaces to your applications are pretty easy. Using interfaces also lets you add polymorphism to your application designs. We'll use a simple example to demonstrate the Visual Basic syntax required to complete these steps.

<p>You define a custom interface in Visual Basic by using a regular class module. It would be better if the Visual Basic IDE were to provide a separate editor for defining interfaces, but unfortunately an editor dedicated to creating interfaces isn't currently available. You use the class module editor to create both interface definitions and classes.

<p>To define a new interface, you simply add a new class module to an existing project. Then you give it an appropriate name. If you're creating an interface to express the behavior of a dog, a suitable name might be <I>IDog </I>or <I>itfDog</I>. These are the two most common naming conventions among Visual Basic developers. If you're working in a Visual Basic project that's either an ActiveX DLL or an ActiveX EXE, you should also set the class module's instancing property to <I>PublicNotCreatable</I>. This setting makes sense because the interface will represent an abstract data type. In a Standard EXE project, class modules don't have an instancing property.

<p>You define your interface by creating the calling syntax for a set of public methods. Don't include an implementation for any of the methods in your interface. You need only define the signatures, nothing more. In essence, you define <I>how</I> the client calls these methods, not <I>what</I> will happen. Here's an example of the <I>IDog </I>interface defined in a Visual Basic class module:

<p><pre>
&#39; Interface IDog
&#39; expresses behavior of a dog object.

Public Property Get Name() As String
End Property

Public Property Let Name(ByVal Value As String)
End Property

Public Sub Bark()
End Sub

Public Sub RollOver(ByRef Rolls As Integer)
End Sub
</PRE>

<p>One of the first things you notice when declaring an interface in Visual Basic is the presence of <I>End Sub</I>,<I> End Function</I>,<I> </I>or <I>End Property </I>after each method signature. This makes no sense. The keyword <I>End</I> usually signifies the end of a method implementation. This is a confusing idiosyncrasy of the Visual Basic IDE and an unfortunate side effect of using the Visual Basic class module for defining both classes and interfaces. Perhaps a future version of Visual Basic will provide a module type dedicated to defining interfaces that won't require <I>End Sub</I>, <I>End Function</I>, or <I>End Property</I>, but for now you just have to grin and bear it.

<P>Another important point is that this interface can use logical properties in addition to methods. This is reasonable when you consider that a logical property is actually a set of methods, not a data property. The client can use the logical property <I>Name</I> defined in the interface above just like a regular data property, but it must be implemented in terms of a <I>Property Let/Property Get </I>method pair.

<P>Stop and think about this: Why can't an interface contain data members? Because an interface, unlike a class, is never used to create objects. Its mission is to encapsulate a class's implementation details. The data layout of an object is among the most important details to encapsulate within a class definition. If an interface were to contain actual data members, the client would build dependencies on them. You know by this point that dependencies are bad.

<P>Even though interfaces can't contain data properties, Visual Basic still lets you define a property in an interface, like this:

<p><pre>
Public Name As String
</PRE>

<p>However, when you define a data property in an interface, Visual Basic transparently redefines the data property as a logical property. This is simply a convenience that Visual Basic provides when you create interfaces. The <I>Name </I>property defined above still requires <I>Property Let </I>and <I>Property Get </I>in any class that implements the interface. Also note that implementing an interface has no effect on the data layout for a class definition. Any class that implements this interface should include a private data property for the physical storage of the dog's name.

<p>After you create the interface definition, the next step is to create a concrete class that implements it. Add a second class module to your project, and give it an appropriate name. For instance, you can create a concrete class <I>CBeagle </I>that implements the <I>IDog </I>interface. You must use the keyword <I>Implements </I>at the top of a class module. This is what the statement looks like:

<p><pre>
Implements IDog
</PRE>

<p>Once a class module contains this line, every method and logical property in the interface must have an associated implementation in the class module. This 
requirement will be checked by Visual Basic's compiler. You can't compile your code without supplying every implementation. For instance, implementing the <I>Bark</I> method in the <I>IDog </I>interface requires this definition:

<p><pre>
Private Sub IDog_Bark()
    &#39; Implementation code goes here.
End Sub
</PRE>

<p>Visual Basic's mapping of interfaces requires each method implementation to use the name of the interface followed by an underscore and the method name. Visual Basic uses this proprietary syntax to create an entry point into an object when a particular interface is used. The Visual Basic compiler requires you to supply a similar implementation for each method and logical property in the interface. This guarantees that objects created from the class will provide an entry point for each interface member.

<p>Fortunately, the Visual Basic IDE makes it easy to create the procedure stubs for the method implementations if you use the keyword <I>Implements</I> at the top of the class module. The class module's editor window has a <I>wizard bar </I>that includes two drop-down combo boxes. If you select the name of the interface in the left combo box, you can quickly generate the skeletons for the method implementations by selecting the method names in the right combo box. An example of using the wizard bar is shown in Figure 2-4. Here's a partial implementation of the <I>CBeagle </I>class that implements the <I>IDog </I>interface:

<p><pre>
Implements IDog
Private Name As String

Private Property Let IDog_Name(ByVal Value As String)
    Name = Value
End Property

Private Property Get IDog_Name() As String
    IDog_Name = Name
End Property

Private Sub IDog_Bark()
    &#39; Implementation code goes here.
End Sub

Private Sub IDog_RollOver(ByRef Rolls As Integer)
    &#39; Implementation code goes here.
End Sub
</PRE>

<P><A HREF="javascript:fullSize('F02wg04x.htm')"> <IMG SRC="images/F02WG04.JPG" width=404 height=236 border=0></A>

<P><!-- caption --><B>Figure 2-4.</B> <I>The wizard bar makes it easy to create the procedure stubs for implementing a user-defined interface.</I><!-- /caption -->

<P>The wizard bar generates method implementations that are marked as private. This means that these method implementations aren't available to clients that use a <I>CBeagle </I>reference. They're available only to clients that use an <I>IDog </I>reference. The code above also demonstrates how the <I>CBeagle </I>class can implement the logical <I>Name </I>property by defining a private data property and implementing the <I>Property Let </I>and <I>Property Get </I>methods.

<P>Now that you have created an interface and a class that implements it, you can use the interface to communicate with an object. For instance, a client can communicate with a <I>CBeagle </I>object through an <I>IDog </I>reference. You can use the <I>IDog </I>reference to invoke any method that the interface exposes. Here's a simple example.

<p><pre>
Dim Dog As IDog
Set Dog = New CBeagle
&#39; Access object through interface reference.
Dog.Name = &quot;Spot&quot;
Dog.Bark
Dog.RollOver 12
</PRE>

<p>Once the client is connected to the object through the interface reference, it can invoke methods and access logical properties. The Visual Basic IDE provides the same IntelliSense, type checking, and debugging that are available when you use class-based references. Note that you can't use an interface after the <I>New</I> operator. An interface isn't a creatable type. You must use a concrete class such as <I>CBeagle </I>to create an object when you use the <I>New</I> operator.

<A NAME="23"><H2>Why Use Interfaces?</H2></A>

<p>When Visual Basic programmers learn how to use interfaces in an application, they often wonder, &quot;Why would I ever want to do that?&quot; or, &quot;Why should I care?&quot; Programming with class-based references seems far more natural compared with the additional complexity required with user-defined interfaces. The previous example would have been far easier if the client code had programmed against a <I>CBeagle </I>class instead of the <I>IDog </I>interface. User-defined interfaces seem like extra work without any tangible benefits.

<P>There are several significant reasons why a Visual Basic/COM programmer should care about interfaces. The first reason is that interfaces are the foundation of COM. In COM, clients can't use class-based references. Instead, they must access COM objects through interface references. As you'll see in later chapters, Visual Basic can do a pretty good job of hiding the complexities of this requirement. When you use a class-based reference, Visual Basic generates a default COM interface for the class behind the scenes. This means that you can work in Visual Basic without ever having to deal with user-defined interfaces explicitly. However, if you embrace interface-based programming, you will become a much stronger COM programmer.

<p>Another reason you should care about interfaces is that they can offer power and flexibility in software designs. Using user-defined interfaces in Visual Basic becomes valuable when you don't have a one-to-one mapping between a class and a public interface. There are two common scenarios. In one scenario, you create an interface and implement it in multiple classes. In the other scenario, you implement multiple interfaces in a single class. Both techniques offer advantages over application designs in which clients are restricted to using references based on concrete classes. While interface-based designs often require more complexity, the sky is the limit when it comes to what you can do with them.

<p>Consider a case in which many classes implement the same interface. For example, assume that the classes <I>CBeagle</I>, <I>CTerrier</I>, and <I>CBoxer </I>all implement the interface <I>IDog</I>. An application can maintain a collection of <I>IDog</I>-compatible objects using the following code:

<p><pre>
Dim Dog1 As IDog, Dog2 As IDog, Dog3 As IDog
&#39; Create and initialize dogs.
Set Dog1 = New CBeagle
Dog1.Name = &quot;Mo&quot;
Set Dog2 = New CTerrier
Dog2.Name = &quot;Larry&quot;
Set Dog3 = New CBoxer
Dog3.Name = &quot;Curly&quot;
&#39; Add dogs to a collection.
Dim Dogs As New Collection
Dogs.Add Dog1
Dogs.Add Dog2
Dogs.Add Dog3
</PRE>

<p>The application can achieve polymorphic behavior by treating all of the <I>IDog</I>-compatible objects in the same manner. The following code demonstrates enumerating through the collection and invoking the <I>Bark </I>method on each object:

<p><pre>
Dim Dog As IDog
For Each Dog In Dogs
    Dog.Bark
Next Dog
</PRE>

<p>As the application evolves, this collection can be modified to hold any mix of <I>IDog</I>-compatible objects, including objects created from <I>CBeagle</I>, <I>CTerrier</I>, <I>CBoxer</I>,<I> </I>and any other future class that is written to implement the <I>IDog </I>interface. The <I>For Each </I>loop in the previous example is written in terms of the <I>IDog </I>interface and has no dependencies on any concrete class. You don't have to modify the loop when you introduce new concrete class types into the application.

<P>Another powerful design technique is to have a single class implement multiple interfaces. If you do this, you'll have objects that support multiple interfaces and therefore multiple behaviors. When used together with run-time type inspection, this becomes very powerful. Assume that the sample application adds another interface, <I>IWonderDog</I>, with the following method:

<p><pre>
Sub FetchSlippers()
End Sub
</PRE>

<p>Assume that the <I>CBeagle </I>class implements <I>IWonderDog </I>but that the <I>CTerrier </I>class doesn't. A client can inspect an object at run time and ask whether it supports a specific interface. If the object does support the interface, the client can call upon its functionality. If the object doesn't support the interface, the client can degrade gracefully. The following code demonstrates using the Visual Basic <I>TypeOf</I> syntax to test for <I>IWonderDog </I>support.

<p><pre>
Dim Dog1 As IDog, Dog2 As IDog

Set Dog1 = New CBeagle
Set Dog2 = New CTerrier

If TypeOf Dog1 Is IWonderDog Then
    Dim WonderDog1 As IWonderDog
    Set WonderDog1 = Dog1
    WonderDog1.FetchSlippers
End If

If TypeOf Dog2 Is IWonderDog Then
    Dim WonderDog2 As IWonderDog
    Set WonderDog2 = Dog2
    WonderDog2.FetchSlippers
End If
</PRE>

<p>When the client queries the <I>CBeagle </I>object, it finds that it's <I>IWonderDog</I>-compatible. In other words, the object supports the <I>IWonderDog </I>interface. The client can then create an <I>IWonderDog </I>reference and assign the <I>CBeagle </I>object to it by casting the <I>IDog </I>reference with the <I>Set </I>statement. Once the client has an <I>IWonderDog </I>reference, it can successfully call <I>FetchSlippers</I>. Note that there are two references but only one object. When you have multiple interfaces, code in the client becomes more complex because it takes several references to a single object to get at all the functionality.

<P>When the <I>CTerrier </I>object is queried for <I>IWonderDog </I>compatibility, the client discovers that the interface isn't supported. This condition allows the client to degrade gracefully. Client code can enumerate through a collection of <I>IDog</I>-compatible objects and safely call <I>FetchSlippers </I>on each object that supports the <I>IWonderDog</I> interface, like this:

<p><pre>
Dim Dog As IDog, WonderDog As IWonderDog
For Each Dog In Dogs
    If TypeOf Dog Is IWonderDog Then
        Set WonderDog = Dog
        WonderDog.FetchSlippers
    End If
Next Dog
</PRE>

<p>As you can imagine, this ability to determine the functionality of an object at run time is very useful when you improve an application. If a later version of the <I>CBoxer </I>class implements the <I>IWonderDog </I>interface, the <I>For Each </I>loop shown above can take advantage of that without being rewritten. Client code can anticipate supported functionality in future versions of the object.

<A NAME="24"><H2>Extending an Object</H2></A>

<p>The example above showed how to use an object that supports more than one interface. You can also employ user-defined interfaces to safely extend the behavior of an object when an existing set of method signatures has become too limiting. For instance, the <I>IDog </I>interface defines the <I>RollOver </I>method as follows:

<p><pre>
Public Sub RollOver(ByRef Rolls As Integer)
End Sub
</PRE>

<p>If you need to extend the functionality of dog objects in the application so that clients can pass larger integer values, you can create a second interface named <I>IDog2</I>. Assume that the <I>IDog2 </I>interface defines the same members as <I>IDog </I>with the exception of the <I>RollOver </I>method, which is defined like this:

<p><pre>
Public Sub RollOver(ByRef Rolls As Long)
End Sub
</PRE>

<p>A new client can test to see whether an <I>IDog</I> object supports the new behavior. If the new behavior isn't supported, the client can simply fall back on the older behavior. Here's an example of how this works:

<p><pre>
Sub ExerciseDog(Dog As IDog)
    If TypeOf Dog Is IDog2 Then
        &#39; Use new behavior if supported.
        Dim Dog2 As IDog2, lRolls As Long
        Set Dog2 = Dog
        lRolls = 50000
        Dog2.RollOver lRolls
    Else
        &#39; Use older behavior if necessary.
        Dim iRolls As Integer
        iRolls = 20000
        Dog.RollOver iRolls
    End If
End Sub
</PRE>

<p>The key observation to make about this versioning scheme is that you can introduce new clients and new objects into an application without breaking older clients and older objects. A new object can accommodate older clients by continuing to support the interfaces from earlier versions. New clients deal with older objects by using the older interface when required. In a world without interfaces, extending objects often requires modifying all the clients. Modifying clients often requires modifying all the objects. The versioning scheme made possible by interface-based programming allows you to make small changes to an application with little or no impact on code that's already in production.

</BODY>
</HTML>






