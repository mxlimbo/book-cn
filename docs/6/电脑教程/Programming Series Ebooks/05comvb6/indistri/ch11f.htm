<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="Library.css" TYPE="text/css">
<TITLE>Using Transactional Messages</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch11e.htm", "ch11g.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="176"><H1>Using Transactional Messages</H1></A>

<P>When you send a message inside a transaction, you get a few guarantees that you don't get with a nontransactional message. First, MSMQ provides exactly-once delivery semantics. It takes some extra precautions so that messages that are on their way to a destination queue are not lost or duplicated. MSMQ also ensures that messages inside the same transaction are delivered in the order in which they were sent. MSMQ doesn't use message priorities in transactional queues for this reason. Every message in a transaction queue has a priority level of 0.

<P>Let's look at an example of in-order delivery. Let's say that you send message A and then you send message B to the same queue. Message A will arrive before message B as long as they are part of the same transaction. This means that message A will be placed closer to the head of the queue. However, you should note that other messages from other transactions might be interleaved with yours. MSMQ guarantees the ordering of messages only within a single transaction.

<P>In MSMQ, transactional messages must be sent to transactional queues. You can't change the transactional attribute after a queue has been created. It is therefore important to indicate whether you want a queue to be transactional when you create it. You can use the first parameter of the <I>MSMQQueueInfo</I> component's <I>Create</I> method to indicate whether you want a transactional queue. If you don't pass this parameter, a nontransactional queue will be created by default. It's also easy to indicate that you want a transactional queue when you create one by hand using the MSMQ Explorer.

<P>You can send and receive transactional messages with MSMQ in two ways. You can use MSMQ's internal transactioning mechanism, or you can use external transactions that are coordinated by the Distributed Transaction Coordinator (DTC) with the two-phase commit protocol (described in <a href="ch10a.htm">Chapter 10</a>). Each technique offers distinct advantages.

<P>MSMQ provides its own internal transactioning mechanism, which provides the best performance. However, when you use internal transactions, MSMQ can't coordinate the transaction with any other type of resource manager, such as a SQL Server database. Internal transactions do not use the DTC or the two-phase commit protocol. Instead, MSMQ uses a more efficient protocol that is especially tuned for transactional messaging. Consequently, internal transactions are much faster than externally coordinated transactions.

<P>Because MSMQ supports the OLE Transactions protocol, you can use it along with another resource manager when you create DTC-based transactions. Your connection to a transactional queue can be enlisted with the DTC. External transactions are also known as <I>coordinated transactions </I>because they are managed by the DTC. While external transactions are slower than internal transactions, they let you define transactions that include message passing along with operations to other resource managers. For example, you can write a transaction that receives a request message, modifies a SQL Server database, and sends a response message. Because the three operations are part of a single transaction, the DTC enforces the ACID rules (described in <a href="ch10a.htm">Chapter 10</a>).


<P>MSMQ lets you explicitly begin and control an external DTC-based transaction. However, it's hard for you to do much in Visual Basic with the DTC without using MTS because you have to enlist any other resource manager connection yourself. Fortunately, you can send and receive messages from inside an MTS transaction and let MTS deal with enlisting the connection to a DBMS. This makes it easy to mix message passing and DBMS access inside a single transaction. The MTS run time will enlist all the resource managers (including MSMQ) for you behind the scenes.

<A NAME="177"><H2>MSMQ Internal Transactions</H2></A>


<P>MSMQ provides a shortcut when you want to send only a single transacted message. To send a single message in its own transaction, pass the constant <I>MQ_SINGLE_MESSAGE</I> when you call <I>Send</I>. Here's what a call to <I>Send</I> looks like:

<p><pre>
msg.Send q, MQ_SINGLE_MESSAGE
</PRE>

<P>You'll often want to send single messages inside a transaction because you'll want to guarantee exactly-once delivery. If you don't send the message inside a transaction, it might be lost or duplicated.

<P>If you want to send multiple messages inside an internal transaction, you must create a new <I>MSMQTransactionDispenser </I>object. You can then invoke its <I>BeginTransaction</I> method to start a new transaction. A call to <I>BeginTransaction</I> returns an <I>MSMQTransaction</I> object. You can pass a reference to this <I>MSMQTransaction</I> object when you call a message writing operation such as  <I>Send</I>, <I>Receive</I>, or <I>ReceiveCurrent</I>. The code below is an example of sending two messages to one transaction queue while performing a receive operation on another transactional queue.

<p><pre>
Dim td As MSMQTransactionDispenser
Set td = New MSMQTransactionDispenser
Dim tx As MSMQTransaction
Set tx = td.BeginTransaction()
&#39; Send and receive message from transactional queues.
msg1.Send q1, tx 
msg2.Send q1, tx
Set msg3 = q2.Receive(Transaction:=tx, ReceiveTimeOut:=0) 
&#39; Commit the transaction.
tx.Commit
</PRE>

<P>The messages are not sent to the queue until the transaction has been committed. In this example, you can be sure that <I>msg1</I> will be placed in the queue ahead of <I>msg2</I>. When you receive a message inside a transaction, it is removed from the queue immediately. Another application won't see the message in the queue, even though the transaction hasn't been committed. However, if the transaction is aborted, the message is returned to the queue. This behavior is the same for transactional queues whether you are using internal transactions or external transactions.

<p>You must follow certain rules when you program against transactional queues. If you violate one of the rules, you will experience a run-time error.

<UL>
<P><LI>You can't send a message from inside a transaction to a nontransactional queue.
<P><LI>You can't send a message to a transactional queue if the message isn't part of a transaction.
<P><LI>You can't receive messages from and send messages to the same queue from inside the same transaction.
<P><LI>You can receive transactional messages only when the receiving application is running on the same computer as the transactional queue.
</UL>

<P>Another thing to keep in mind is that MSMQ transactions run at a lower isolation level than those in SQL Server. As you remember from <a href="ch10a.htm">Chapter 10</a>, SQL Server will always conduct the operations inside an MTS transaction with an isolation level of Serializable. MSMQ doesn't support the Serializable isolation level because of the way it manages locks during a transaction.

<P>MSMQ provides an isolation level of Read Committed between a receiving transaction and a sending transaction. The receiver can see messages from the committed send transaction even if the send transaction started after the receive transaction. If MSMQ were to run transactions with an isolation level of Serializable, it would have to put a lock on the queue and block send operations until the receiving transaction was complete. A locking scheme such as this would pose an unacceptable concurrency restraint in a queuing system.


<P>With respect to two receiving transactions, however, the isolation level is Read Uncommitted. Let's look at an example to demonstrate this point. Assume there is a single message in a transactional queue. If transaction A receives the message from the queue, transaction B will see the queue as empty. If transaction A later aborts, the message will be written back to the queue. The queue was really never empty. However, transaction B saw the queue as empty because it read the queue in an uncommitted state. You shouldn't see the inability to run serializable transactions as a flaw in MSMQ. It's really just an inherent problem with transactional queuing. Isolation is sacrificed to maintain higher levels of concurrency. This means you can't make as many assumptions as you can when working with a DBMS that runs its operations with an isolation level of Serializable.

<A NAME="178"><H2>External Transactions with MTS</H2></A>

<P>MSMQ includes an ActiveX component for creating DTC-based transactions named the <I>MSMQCoordinatedTransactionDispenser</I>. This component's interface is identical to the <I>MSMQTransactionDispenser</I> component that you saw earlier in this chapter. Both components expose a single method, <I>BeginTransaction</I>, which returns an <I>MSMQTransaction </I>object. In fact, in most of your code you can use these two components interchangeably.

<P>The difference between the two components is that the coordinated dispenser works with the DTC, while the internal dispenser doesn't. When you commit an external transaction, the DTC executes the two-phase protocol against MSMQ, which acts as a resource manager. The coordinated dispenser also lets you enlist a resource manager other than MSMQ into a transaction. There's currently no straightforward way, however, to enlist another resource manager such as SQL Server using the <I>MSMQTransaction </I>object. This means that most Visual Basic programmers can't benefit from using the coordinated dispenser directly.

<P>Fortunately, you can get the same benefits of external transactions by sending and receiving messages from within an MTS transaction. The MTS run time can enlist MSMQ as well as other resource managers such as SQL Server and Oracle into a single transaction. Here's an example of sending a message inside a transactional MTS component:

<p><pre>
Dim ObjCtx As ObjectContext
Set ObjCtx = GetObjectContext()
&#39; First, write a few records to a SQL Server database.
&#39; Second, send a message to MSMQ.
Dim qi As MSMQQueueInfo
Set qi = New MSMQQueueInfo
qi.PathName = &quot;.\MyResponseQueue&quot;
Dim q As MSMQQueue
Set q = qi.Open(MQ_SEND_ACCESS, MQ_DENY_NONE)
Dim msg As MSMQMessage
Set msg = New MSMQMessage
msg.Body = &quot;The database has been updated&quot;
msg.Send q, MQ_MTS_TRANSACTION
q.Close
ObjCtx.SetComplete &#39; Or call SetAbort.
</PRE>

<P>You can pass the constant <I>MQ_MTS_TRANSACTION</I> in a call to <I>Send</I>, <I>Receive</I>,<I> </I>or <I>ReceiveCurrent </I>to indicate that you want your writing operation to be part of the current MTS transaction. If you don't pass a transaction parameter, this value is also the default. Note that passing <I>MQ_MTS_TRANSACTION </I>results in a transacted operation if you make the call from within an MTS transaction.

<P>Passing <I>MQ_MTS_TRANSACTION</I> results in a <I>Wrong Transaction Usage</I> error if your program attempts to send a message inside MTS outside the scope of a transaction. Passing <I>MQ_MTS_TRANSACTION </I>will result in a nontransacted receive if your program calls <I>Receive </I>or <I>ReceiveCurrent </I>inside MTS outside the scope of a transaction.

<P>As in the case of an internal transaction, messages inside an MTS transaction are not actually sent until the transaction has been committed. When you receive messages inside a transaction, they are removed from the queue right away. If you call <I>SetAbort</I> to roll back a transaction, your messages are written back to the queue. Remember, there are no guarantees that the message will be placed back in the same positions. The previous description of MSMQ isolation levels applies to external transactions as well as internal transactions.

</BODY>
</HTML>






