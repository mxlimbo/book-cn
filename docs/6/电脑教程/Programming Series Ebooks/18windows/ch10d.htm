<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Keyboard Accelerators</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="317"><h1>Keyboard Accelerators</h1></A>
<p>Keyboard accelerators are key combinations that generate WM_COMMAND (or, in 
some cases, WM_SYSCOMMAND) messages. Most often, programs use keyboard accelerators 
to duplicate the action of common menu options, but they can also perform nonmenu 
functions. For instance, some Windows programs have an Edit menu that includes a Delete 
or Clear option; these programs conventionally assign the Del key as a keyboard 
accelerator for this option. The user can choose the Delete option from the menu by pressing an 
Alt-key combination or can use the keyboard accelerator simply by pressing the Del key. 
When the window procedure receives a WM_COMMAND message, it does not have to 
determine whether the menu or the keyboard accelerator was used.

<A NAME="318"><h2>Why You Should Use Keyboard Accelerators</h2></A>
<p>You might ask: Why should I use keyboard accelerators? Why can't I simply trap WM_
KEYDOWN or WM_CHAR messages and duplicate the menu functions myself? What's 
the advantage? For a single-window application, you can certainly trap keyboard 
messages, but one simple advantage of using keyboard accelerators is that you don't need to 
duplicate the menu and keyboard accelerator logic.

<p>For applications with multiple windows and multiple window procedures, 
keyboard accelerators become very important. As we've seen, Windows sends keyboard 
messages to the window procedure for the window that currently has the input focus. For 
keyboard accelerators, however, Windows sends the WM_COMMAND message to the 
window procedure whose handle is specified in the Windows function 
<I>TranslateAccelerator</I>. Generally, this will be your main window, the same window that has the menu, 
which means that the logic for acting upon keyboard accelerators does not have to be 
duplicated in every window procedure.

<p>This advantage becomes particularly important if you use modeless dialog boxes 
(discussed in the next chapter) or child windows on your main window's client area. If a 
particular keyboard accelerator is defined to move among windows, only one 
window procedure has to include this logic. The child windows do not receive 
WM_COMMAND messages from the keyboard accelerators.

<A NAME="319"><h2>Some Rules on Assigning Accelerators</h2></A>
<p>In theory, you can define a keyboard accelerator for almost any virtual key or 
character key in combination with the Shift key, Ctrl key, or Alt key. However, you should try 
to achieve some consistency with other applications and avoid interfering with Windows' 
use of the keyboard. You should avoid using Tab, Enter, Esc, and the Spacebar in 
keyboard accelerators because these are often used for system functions.

<p>The most common use of keyboard accelerators is for items on the program's 
Edit menu. The recommended keyboard accelerators for these items changed between 
Windows 3.0 and Windows 3.1, so it's become common to support both the old and the 
new accelerators, as shown in the following table:
<table cellpadding=5 width="95%">
<tr><td valign="top"><i><b>Function</b></i></td>
    <td valign="top"><i><b>Old Accelerator</b></i></td>
	<td valign="top"><i><b>New Accelerator</b></i></td></tr>

<tr><td valign="top">Undo</td><td valign="top">Alt+Backspace</td><td valign="top">Ctrl+Z</td></tr>

<tr><td valign="top">Cut</td><td valign="top">Shift+Del</td><td valign="top">Ctrl+X</td></tr>

<tr><td valign="top">Copy</td><td valign="top">Ctrl+Ins</td><td valign="top">Ctrl+C</td></tr>

<tr><td valign="top">Paste</td><td valign="top">Shift+Ins</td><td valign="top">Ctrl+V</td></tr>

<tr><td valign="top">Delete or Clear</td><td valign="top">Del</td><td valign="top">Del</td></tr>
</table>

<p>Another common accelerator is the F1 function key to invoke help. Avoid use of 
the F4, F5, and F6 keys because these are often used for special functions in Multiple 
Document Interface (MDI) programs, which are discussed in <a href="ch19a.htm#695">Chapter 19</a>.

<A NAME="320"><h2>The Accelerator Table</h2></A>
<p>You can define an accelerator table in Developer Studio. For ease in loading the 
accelerator table in your program, give it the same text name as your program (and your 
menu and your icon).


<p>Each accelerator has an ID and a keystroke combination that you define in the 
Accel Properties dialog box. If you've already defined your menu, the menu IDs will be 
available in the combo box, so you don't have to retype them.

<p>Accelerators can be either virtual key codes or ASCII characters in combination 
with the Shift, Ctrl, or Alt keys. You can specify that an ASCII character is to be typed with 
the Ctrl key by typing a ^ before the letter. You can also pick virtual key codes from 
a combo box.

<p>When you define keyboard accelerators for a menu item, you should include the 
key combination in the menu item text. The tab (\t) character separates the text from the 
accelerator so that the accelerators align in a second column. To notate accelerator keys 
in a menu, use the text Ctrl, Shift, or Alt followed by a plus sign and the key (for 
example, Shift+F6 or Ctrl+F6).

<A NAME="321"><h2>Loading the Accelerator Table</h2></A>
<p>Within your program, you use the 
<I>LoadAccelerators</I> function to load the accelerator 
table into memory and obtain a handle to it. The 
<I>LoadAccelerators</I> statement is similar to 
the <I>LoadIcon</I>, <I>LoadCursor</I>, and 
<I>LoadMenu</I> statements.

<p>First define a handle to an accelerator table as type HANDLE:

<p><pre>
HANDLE hAccel ;
</PRE>

<p>Then load the accelerator table:

<p><pre>
hAccel = LoadAccelerators (hInstance, TEXT (&quot;MyAccelerators&quot;)) ;
</PRE>

<p>As with icons, cursors, and menus, you can use a number for the accelerator table 
name and then use that number in the 
<I>LoadAccelerators</I> statement with the 
MAKEINTRESOURCE macro or enclosed in quotation marks and preceded by a # character.

<A NAME="322"><h2>Translating the Keystrokes</h2></A>
<p>We will now tamper with three lines of code that are common to all the Windows 
programs we've created so far in this book. The code is the standard message loop:

<p><pre>
while (GetMessage (&amp;msg, NULL, 0, 0))
{
     TranslateMessage (&amp;msg) ;
     DispatchMessage (&amp;msg) ;
}
</PRE>

<p>Here's how we change it to use the keyboard accelerator table:

<p><pre>
while (GetMessage (&amp;msg, NULL, 0, 0))
{
     if (!TranslateAccelerator (hwnd, hAccel, &amp;msg))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
}
</PRE>

<p>The <I>TranslateAccelerator</I> function determines whether the message stored in the 
<I>msg</I> message structure is a keyboard message. If it is, the function searches for a match in the 
accelerator table whose handle is <I>hAccel</I>. If it finds a match, it calls the window procedure for 
the window whose handle is <I>hwnd</I>. If the keyboard accelerator ID corresponds to a 
menu item in the system menu, the message is WM_SYSCOMMAND. Otherwise, the 
message is WM_COMMAND.

<p>When <I>TranslateAccelerator</I> returns, the return value is nonzero if the message 
has been translated (and already sent to the window procedure) and 0 if not. If 
<I>TranslateAccelerator</I> returns a nonzero value, you should not call 
<I>TranslateMessage</I> and <I>DispatchMessage</I> but rather should loop back to the 
<I>GetMessage</I> call.

<p>The <I>hwnd</I> parameter in 
<I>TranslateMessage</I> looks a little out of place because it's 
not required in the other three functions in the message loop. Moreover, the message 
structure itself (the structure variable 
<I>msg</I>) has a member named <I>hwnd</I>, which is also a 
handle to a window.

<p>Here's why the function is a little different: The fields of the 
<I>msg</I> structure are filled in by the 
<I>GetMessage</I> call. When the second parameter of 
<I>GetMessage</I> is NULL, the function retrieves messages for all windows belonging to the application. When 
<I>GetMessage</I> returns, the <I>hwnd</I> member of the 
<I>msg</I> structure is the window handle of the window 
that will get the message. However, when 
<I>TranslateAccelerator</I> translates a keyboard 
message into a WM_COMMAND or WM_SYSCOMMAND message, it replaces the 
<I>msg.hwnd</I> window handle with the <I>hwnd</I> window handle specified as the first parameter to the 
function. That is how Windows sends all keyboard accelerator messages to the same 
window procedure even if another window in the application currently has the input 
focus. <I>TranslateAccelerator</I> does not translate keyboard messages when a modal dialog box 
or message box has the input focus, because messages for these windows do not come 
through the program's message loop.

<p>In some cases in which another window in your program (such as a modeless 
dialog box) has the input focus, you may not want keyboard accelerators to be 
translated. You'll see how to handle this situation in the next chapter.

<A NAME="323"><h2>Receiving the Accelerator Messages</h2></A>
<p>When a keyboard accelerator corresponds to a menu item in the system menu, 
<I>TranslateAccelerator</I> sends the window procedure a WM_SYSCOMMAND message. 
Otherwise, <I>TranslateAccelerator</I> sends the window procedure a WM_COMMAND message. The 
following table shows the types of WM_COMMAND messages you can receive for 
keyboard accelerators, menu commands, and child window controls:

<table cellpadding=5 width="95%">

<tr><td valign="top"><i><b>Accelerator</b></i></td>
    <td valign="top"><i><b>Menu</b></i></td>
	<td valign="top"><i><b>Control</b></i></td></tr>
<tr><td valign="top">LOWORD (<I>wParam</I>)</td>
    <td valign="top">Accelerator ID</td>
	<td valign="top">Menu ID</td>
	<td valign="top">Control ID</td></tr>
<tr><td valign="top">HIWORD (<I>wParam</I>)</td>
    <td valign="top">1</td>
	<td valign="top">0</td>
	<td valign="top">Notification code</td></tr>

<tr><td valign="top"><I>lParam</I></td>
    <td valign="top">0</td>
    <td valign="top">0</td>
    <td valign="top">Child window handle</td></tr>
</table>

<p>If the keyboard accelerator corresponds to a menu item, the window procedure 
also receives WM_INITMENU, WM_INITMENUPOPUP, and WM_MENUSELECT messages, 
just as if the menu option had been chosen. Programs usually enable and disable items in 
a popup menu when processing WM_INITMENUPOPUP, so you still have that facility 
when using keyboard accelerators. If the keyboard accelerator corresponds to a disabled 
or grayed menu item, <I>TranslateAccelerator</I> does not send the window procedure a 
WM_COMMAND or WM_SYSCOMMAND message.

<p>If the active window is minimized, 
<I>TranslateAccelerator</I> sends the window procedure WM_SYSCOMMAND messages&#8212;but not WM_COMMAND messages&#8212;for 
keyboard accelerators that correspond to enabled system menu items. 
<I>TranslateAccelerator</I> also sends that window procedure WM_COMMAND messages for accelerators that do not 
correspond to any menu items.

<A NAME="324"><h2>POPPAD with a Menu and Accelerators</h2></A>
<p>In <a href="ch09a.htm#806">Chapter 9</a>, we created a program called POPPAD1 that uses a child window edit 
control to implement a rudimentary notepad. In this chapter, we'll add File and Edit 
menus and call it POPPAD2. The Edit items will all be functional; we'll finish the File functions 
in <a href="ch11a.htm#331">Chapter 11</a> and the Print function in <a href="ch13a.htm#401">Chapter 13</a>. POPPAD2 is shown in Figure 10-11.

<p><B>Figure 10-11.</b> <i>The POPPAD2 program.</I>
<TABLE cellpadding=5 width="95%"><TR><TD>

<A NAME="325"><h3>POPPAD2.C</h3></A>
<p><pre>
/*-----------------------------------------------------
   POPPAD2.C -- Popup Editor Version 2 (includes menu)


                (c) Charles Petzold, 1998
  -----------------------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;resource.h&quot;

#define ID_EDIT     1

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);

TCHAR szAppName[] = TEXT (&quot;PopPad2&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HACCEL   hAccel ;
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (hInstance, szAppName) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = szAppName ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, szAppName,
                          WS_OVERLAPPEDWINDOW,
                          GetSystemMetrics (SM_CXSCREEN) / 4,
                          GetSystemMetrics (SM_CYSCREEN) / 4,
                          GetSystemMetrics (SM_CXSCREEN) / 2,
                          GetSystemMetrics (SM_CYSCREEN) / 2,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ; 
     
     hAccel = LoadAccelerators (hInstance, szAppName) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          if (!TranslateAccelerator (hwnd, hAccel, &amp;msg))
          {
               TranslateMessage (&amp;msg) ;
               DispatchMessage (&amp;msg) ;
          }
     }
     return msg.wParam ;
}

AskConfirmation (HWND hwnd)
{
     return MessageBox (hwnd, TEXT (&quot;Really want to close PopPad2?&quot;),
                        szAppName, MB_YESNO | MB_ICONQUESTION) ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HWND hwndEdit ;
     int         iSelect, iEnable ;
     
     switch (message)
     {
     case WM_CREATE:
          hwndEdit = CreateWindow (TEXT (&quot;edit&quot;), NULL,
                              WS_CHILD | WS_VISIBLE | WS_HSCROLL | WS_VSCROLL |
                              WS_BORDER | ES_LEFT | ES_MULTILINE |
                              ES_AUTOHSCROLL | ES_AUTOVSCROLL,
                              0, 0, 0, 0, hwnd, (HMENU) ID_EDIT,
                              ((LPCREATESTRUCT) lParam)-&gt;hInstance, NULL) ;
          return 0 ;
          
     case WM_SETFOCUS:
          SetFocus (hwndEdit) ;
          return 0 ;
          
     case WM_SIZE: 
          MoveWindow (hwndEdit, 0, 0, LOWORD (lParam), HIWORD (lParam), TRUE) ;
          return 0 ;
          
     case WM_INITMENUPOPUP:
          if (lParam == 1)
          {
               EnableMenuItem ((HMENU) wParam, IDM_EDIT_UNDO,
                    SendMessage (hwndEdit, EM_CANUNDO, 0, 0) ?
                                   MF_ENABLED : MF_GRAYED) ;
               
               EnableMenuItem ((HMENU) wParam, IDM_EDIT_PASTE,
                    IsClipboardFormatAvailable (CF_TEXT) ?
                                   MF_ENABLED : MF_GRAYED) ;
               
               iSelect = SendMessage (hwndEdit, EM_GETSEL, 0, 0) ;
               
               if (HIWORD (iSelect) == LOWORD (iSelect))
                    iEnable = MF_GRAYED ;
               else
                    iEnable = MF_ENABLED ;
               
               EnableMenuItem ((HMENU) wParam, IDM_EDIT_CUT,   iEnable) ;
               EnableMenuItem ((HMENU) wParam, IDM_EDIT_COPY,  iEnable) ;
               EnableMenuItem ((HMENU) wParam, IDM_EDIT_CLEAR, iEnable) ;
               return 0 ;
          }
          break ;
     case WM_COMMAND:
          if (lParam)
          {
               if (LOWORD (lParam) == ID_EDIT &amp;&amp;
                         (HIWORD (wParam) == EN_ERRSPACE ||
                          HIWORD (wParam) == EN_MAXTEXT))
                    MessageBox (hwnd, TEXT (&quot;Edit control out of space.&quot;),
                                szAppName, MB_OK | MB_ICONSTOP) ;
               return 0 ;
          }
          else switch (LOWORD (wParam))
          {
          case IDM_FILE_NEW:
          case IDM_FILE_OPEN:
          case IDM_FILE_SAVE:
          case IDM_FILE_SAVE_AS:
          case IDM_FILE_PRINT:
               MessageBeep (0) ;
               return 0 ;
          
          case IDM_APP_EXIT:
               SendMessage (hwnd, WM_CLOSE, 0, 0) ;
               return 0 ;

          case IDM_EDIT_UNDO:
               SendMessage (hwndEdit, WM_UNDO, 0, 0) ;
               return 0 ;
          
          case IDM_EDIT_CUT:
               SendMessage (hwndEdit, WM_CUT, 0, 0) ;
               return 0 ;
          
          case IDM_EDIT_COPY:
               SendMessage (hwndEdit, WM_COPY, 0, 0) ;
               return 0 ;
          
          case IDM_EDIT_PASTE:
               SendMessage (hwndEdit, WM_PASTE, 0, 0) ;
               return 0 ;
          
          case IDM_EDIT_CLEAR:
               SendMessage (hwndEdit, WM_CLEAR, 0, 0) ;
               return 0 ;

          case IDM_EDIT_SELECT_ALL:
               SendMessage (hwndEdit, EM_SETSEL, 0, -1) ;
               return 0 ;
          
          case IDM_HELP_HELP:
               MessageBox (hwnd, TEXT (&quot;Help not yet implemented!&quot;),
                           szAppName, MB_OK | MB_ICONEXCLAMATION) ;
               return 0 ;
          
          case IDM_APP_ABOUT:
               MessageBox (hwnd, TEXT (&quot;POPPAD2 (c) Charles Petzold, 1998&quot;),
                           szAppName, MB_OK | MB_ICONINFORMATION) ;
               return 0 ;
          }
          break ;
          
     case WM_CLOSE:
          if (IDYES == AskConfirmation (hwnd))
               DestroyWindow (hwnd) ;
          return 0 ;
          
     case WM_QUERYENDSESSION:
          if (IDYES == AskConfirmation (hwnd))
               return 1 ;
          else
               return 0 ;
          
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

<P><TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="326"><h3>POPPAD2.RC (excerpts)</h3></A>
<p><pre>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;
/////////////////////////////////////////////////////////////////////////////
// Icon

POPPAD2                 ICON    DISCARDABLE     &quot;poppad2.ico&quot;

/////////////////////////////////////////////////////////////////////////////
// Menu
POPPAD2 MENU DISCARDABLE 
BEGIN
    POPUP &quot;&amp;File&quot;
    BEGIN
        MENUITEM &quot;&amp;New&quot;,                        IDM_FILE_NEW
        MENUITEM &quot;&amp;Open...&quot;,                    IDM_FILE_OPEN
        MENUITEM &quot;&amp;Save&quot;,                       IDM_FILE_SAVE
        MENUITEM &quot;Save &amp;As...&quot;,                 IDM_FILE_SAVE_AS
        MENUITEM SEPARATOR
        MENUITEM &quot;&amp;Print&quot;,                      IDM_FILE_PRINT
        MENUITEM SEPARATOR
        MENUITEM &quot;E&amp;xit&quot;,                       IDM_APP_EXIT
    END
    POPUP &quot;&amp;Edit&quot;
    BEGIN
        MENUITEM &quot;&amp;Undo\tCtrl+Z&quot;,               IDM_EDIT_UNDO
        MENUITEM SEPARATOR
        MENUITEM &quot;Cu&amp;t\tCtrl+X&quot;,                IDM_EDIT_CUT
        MENUITEM &quot;&amp;Copy\tCtrl+C&quot;,               IDM_EDIT_COPY
        MENUITEM &quot;&amp;Paste\tCtrl+V&quot;,              IDM_EDIT_PASTE
        MENUITEM &quot;De&amp;lete\tDel&quot;,                IDM_EDIT_CLEAR
        MENUITEM SEPARATOR
        MENUITEM &quot;&amp;Select All&quot;,                 IDM_EDIT_SELECT_ALL
    END
    POPUP &quot;&amp;Help&quot;
    BEGIN
        MENUITEM &quot;&amp;Help...&quot;,                    IDM_HELP_HELP
        MENUITEM &quot;&amp;About PopPad2...&quot;,           IDM_APP_ABOUT
    END
END

/////////////////////////////////////////////////////////////////////////////
// Accelerator

POPPAD2 ACCELERATORS DISCARDABLE 
BEGIN
    VK_BACK,        IDM_EDIT_UNDO,          VIRTKEY, ALT, NOINVERT
    VK_DELETE,      IDM_EDIT_CLEAR,         VIRTKEY, NOINVERT
    VK_DELETE,      IDM_EDIT_CUT,           VIRTKEY, SHIFT, NOINVERT
    VK_F1,          IDM_HELP_HELP,          VIRTKEY, NOINVERT
    VK_INSERT,      IDM_EDIT_COPY,          VIRTKEY, CONTROL, NOINVERT
    VK_INSERT,      IDM_EDIT_PASTE,         VIRTKEY, SHIFT, NOINVERT
    &quot;^C&quot;,           IDM_EDIT_COPY,          ASCII,  NOINVERT
    &quot;^V&quot;,           IDM_EDIT_PASTE,         ASCII,  NOINVERT
    &quot;^X&quot;,           IDM_EDIT_CUT,           ASCII,  NOINVERT
    &quot;^Z&quot;,           IDM_EDIT_UNDO,          ASCII,  NOINVERT
END
</pre>
</td></tr></table>

<P><TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="327"><h3>RESOURCE.H (excerpts)</h3></A>
<p><pre>
// Microsoft Developer Studio generated include file.
// Used by POPPAD2.RC

#define IDM_FILE_NEW                    40001
#define IDM_FILE_OPEN                   40002
#define IDM_FILE_SAVE                   40003
#define IDM_FILE_SAVE_AS                40004
#define IDM_FILE_PRINT                  40005
#define IDM_APP_EXIT                    40006
#define IDM_EDIT_UNDO                   40007
#define IDM_EDIT_CUT                    40008
#define IDM_EDIT_COPY                   40009
#define IDM_EDIT_PASTE                  40010
#define IDM_EDIT_CLEAR                  40011
#define IDM_EDIT_SELECT_ALL             40012
#define IDM_HELP_HELP                   40013
#define IDM_APP_ABOUT                   40014

</pre>

<A NAME="328"><h2>POPPAD2.ICO</h2></A><p><img src="F10zg11a.GIF" width=205 height=205 border="0">

<p><img src="F10zg11b.GIF" width=109 height=109 border="0">
</td></tr></table>


<p>The POPPAD2.RC resource script file contains the menu and the accelerator 
table. You'll notice that the accelerators are all indicated within the character strings of the 
Edit popup menu following the tab (\t) character.

<A NAME="329"><h2>Enabling Menu Items</h2></A>
<p>The major job in the window procedure now involves enabling and graying the 
options in the Edit menu, which is done when processing the WM_INITMENUPOPUP message. 
First the program checks to see if the Edit popup is about to be displayed. Because the 
position index of Edit in the menu (starting with File at 0) is 1, 
<I>lParam</I> equals 1 if the Edit popup is about to be displayed.

<p>To determine whether the Undo option can be enabled, POPPAD2 sends an EM_CANUNDO message to the edit control. The 
<I>SendMessage</I> call returns nonzero if the 
edit control can perform an Undo action, in which case the option is enabled; otherwise, 
the option is grayed:

<p><pre>
EnableMenuItem (wParam, IDM_UNDO,
     SendMessage (hwndEdit, EM_CANUNDO, 0, 0) ?
                  MF_ENABLED : MF_GRAYED) ;
</PRE>

<p>The Paste option should be enabled only if the clipboard currently contains 
text. We can determine this through the 
<I>IsClipboardFormatAvailable</I> call with the 
CF_TEXT identifier:

<p><pre>
EnableMenuItem (wParam, IDM_PASTE,
     IsClipboardFormatAvailable (CF_TEXT) ? MF_ENABLED : MF_GRAYED) ;
</PRE>

<p>The Cut, Copy, and Delete options should be enabled only if text in the edit 
control has been selected. Sending the edit control an EM_GETSEL message returns an 
integer containing this information:

<p><pre>
iSelect = SendMessage (hwndEdit, EM_GETSEL, 0, 0) ;
</PRE>

<p>The low word of <I>iSelect</I> is the position of the first selected character; the high word of 
<I>iSelect</I> is the position of the character following the selection. If these two words are equal, 
no text has been selected:

<p><pre>
if (HIWORD (iSelect) == LOWORD (iSelect))
     iEnable = MF_GRAYED ;
else
     iEnable = MF_ENABLED ;
</PRE>

<p>The value of <I>iEnable</I> is then used for the Cut, Copy, and Delete options:

<p><pre>
EnableMenuItem (wParam, IDM_CUT,  iEnable) ;
EnableMenuItem (wParam, IDM_COPY, iEnable) ;
EnableMenuItem (wParam, IDM_DEL,  iEnable) ;
</PRE>

<A NAME="330"><h2>Processing the Menu Options</h2></A>
<p>Of course, if we were not using a child window edit control for POPPAD2, we would 
now be faced with the problems involved with actually implementing the Undo, Cut, Copy, 
Paste, Clear, and Select All options from the Edit menu. But the edit control makes this 
process easy, because we merely send the edit control a message for each of these options:

<p><pre>
case IDM_UNDO :
     SendMessage (hwndEdit, WM_UNDO, 0, 0) ;
     return 0 ;

case IDM_CUT :
     SendMessage (hwndEdit, WM_CUT, 0, 0) ;
     return 0 ;

case IDM_COPY :
     SendMessage (hwndEdit, WM_COPY, 0, 0) ;
     return 0 ;
 
case IDM_PASTE :
     SendMessage (hwndEdit, WM_PASTE, 0, 0) ;
     return 0 ;

case IDM_DEL :
     SendMessage (hwndEdit, WM_DEL, 0, 0) ;
     return 0 ;

case IDM_SELALL :
     SendMessage (hwndEdit, EM_SETSEL, 0, -1) ;
     return 0 ;
</PRE>

<p>Notice that we could have simplified this even further by making the values of IDM_UNDO, IDM_CUT, and so forth equal to the values of the corresponding window 
messages WM_UNDO, WM_CUT, and so forth.

<p>The About option on the File popup invokes a simple message box:

<p><pre>
case IDM_ABOUT :
     MessageBox (hwnd, TEXT (&quot;POPPAD2 (c) Charles Petzold, 1998&quot;),
                 szAppName, MB_OK &#166; MB_ICONINFORMATION) ;
     return 0 ;
</PRE>

<p>In the next chapter, we'll make this a dialog box. A message box is also invoked 
when you select the Help option from this menu or when you press the F1 accelerator key.

<p>The Exit option sends the window procedure a WM_CLOSE message:

<p><pre>
case IDM_EXIT :
     SendMessage (hwnd, WM_CLOSE, 0, 0) ;
     return 0 ;
</PRE>

<p>That is precisely what <I>DefWindowProc</I> does when it receives a 
WM_SYSCOMMAND message with <I>wParam</I> equal to SC_CLOSE.

<p>In previous programs, we have not processed the WM_CLOSE messages in our 
window procedure but have simply passed them to 
<I>DefWindowProc</I>. <I>DefWindowProc</I> does something simple with WM_CLOSE: it calls the 
<I>DestroyWindow</I> function. Rather than send WM_CLOSE messages to 
<I>DefWindowProc</I>, however, POPPAD2 processes them. (This 
fact is not so important now, but it will become very important in <a href="ch11a.htm#331">Chapter 11</a> when 
POPPAD can actually edit files.)

<p><pre>
case WM_CLOSE :
     if (IDYES == AskConfirmation (hwnd))

          DestroyWindow (hwnd) ;
     return 0 ;
</PRE>

<p><I>AskConfirmation</I> is a function in POPPAD2 that displays a message box asking for 
confirmation to close the program:

<p><pre>
AskConfirmation (HWND hwnd)
{
     return MessageBox (hwnd, TEXT (&quot;Really want to close Poppad2?&quot;),
                        szAppName, MB_YESNO &#166; MB_ICONQUESTION) ;
}
</PRE>

<p>The message box (as well as the 
<I>AskConfirmation</I> function) returns IDYES if the Yes 
button is selected. Only then does POPPAD2 call 
<I>DestroyWindow</I>. Otherwise, the program is 
not terminated.

<p>If you want confirmation before terminating a program, you must also process WM_
QUERYENDSESSION messages. Windows begins sending every window procedure 
a WM_QUERYENDSESSION message when the user chooses to shut down Windows. If 
any window procedure returns 0 from this message, the Windows session is not 
terminated. Here's how we handle WM_QUERYENDSESSION:

<p><pre>
case WM_QUERYENDSESSION :
     if (IDYES == AskConfirmation (hwnd))
          return 1 ;
     else
          return 0 ;
</PRE>

<p>The WM_CLOSE and WM_QUERYENDSESSION messages are the only two 
messages you have to process if you want to ask for user confirmation before ending a 
program. That's why we made the Exit menu option in POPPAD2 send the window procedure 
a WM_CLOSE message&#8212;by doing so, we avoided asking for confirmation at yet a third point.

<p>If you process WM_QUERYENDSESSION messages, you may also be interested in 
the WM_ENDSESSION message. Windows sends this message to every window 
procedure that has previously received a WM_QUERYENDSESSION message. The 
<I>wParam</I> parameter is 0 if the session fails to terminate because another program has returned 0 
from WM_QUERYENDSESSION. The WM_ENDSESSION message essentially answers the 
question: I told Windows it was OK to terminate me, but did I really get terminated?

<p>Although I've included the normal New, Open, Save, and Save As options 
in POPPAD2's File menu, they are currently nonfunctional. To process these commands, 
we need to use dialog boxes. And you're now ready to learn about them.
</BODY>
</HTML>






