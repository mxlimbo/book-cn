<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Drawing Filled Areas</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="121"><h1>Drawing Filled Areas</h1></A>
<p>The next step up from drawing lines is filling enclosed areas. Windows' seven functions for drawing filled areas with borders are listed in the table below.

<p>
<table width="95%" cellpadding="5" valign="TOP">
<tr>
<td valign=top><b><i>Function</i></b></td>
<td valign=top><b><i>Figure</i></b></td>
</tr>
<tr>
<td valign=top><I>Rectangle</I></td>
<td valign=top>Rectangle with square corners</td>
</tr>
<tr>
<td valign=top><I>Ellipse</I></td>
<td valign=top>Ellipse</td>
</tr>
<tr>
<td valign=top><I>RoundRect</I></td>
<td valign=top>Rectangle with rounded corners</td>
</tr>
<tr>
<td valign=top><I>Chord</I> </td>
<td valign=top>Arc on the circumference of an ellipse with endpoints connected by a chord</td>
</tr>
<tr>
<td valign=top><I>Pie</I> </td>
<td valign=top>Pie wedge defined by the circumference of an ellipse</td>
</tr>
<tr>
<td valign=top><I>Polygon</I> </td>
<td valign=top>Multisided figure</td>
</tr>
<tr>
<td valign=top><I>PolyPolygon</I></td>
<td valign=top>Multiple multisided figures</td>
</tr>
</table>
<p>Windows draws the outline of the figure with the current pen selected in the device context. The current background mode, background color, and drawing mode are all used for this outline, just as if Windows were drawing a line. Everything we learned about lines also applies to the borders around these figures.

<p>The figure is filled with the current brush selected in the device context. By default, this is the stock object called WHITE_BRUSH, which means that the interior will be drawn as white. Windows defines six stock brushes: WHITE_BRUSH, LTGRAY_BRUSH, GRAY_BRUSH, DKGRAY_BRUSH, BLACK_BRUSH, and NULL_BRUSH (or HOLLOW_BRUSH). You can select one of the stock brushes into the device context the same way you select a stock pen. Windows defines HBRUSH to be a handle to a brush, so you can first define a variable for the brush handle:

<p><pre>
HBRUSH hBrush ;
</pre>

<p>You can get the handle to the GRAY_BRUSH by calling <I>GetStockObject</I>:

<p><pre>
hBrush = GetStockObject (GRAY_BRUSH) ;
</pre>

<p>You can select it into the device context by calling <I>SelectObject</I>:

<p><pre>
SelectObject (hdc, hBrush) ;
</pre>

<p>Now when you draw one of the figures listed above, the interior will be gray.

<p>To draw a figure without a border, select the NULL_PEN into the device context:

<p><pre>
SelectObject (hdc, GetStockObject (NULL_PEN)) ;
</pre>

<p>If you want to draw the outline of the figure without filling in the interior, select the NULL_BRUSH into the device context:

<p><pre>
SelectObject (hdc, GetStockobject (NULL_BRUSH) ;
</pre>

<p>You can also create customized brushes just as you can create customized pens. We'll cover that topic shortly.

<A NAME="122"><h2>The <I>Polygon</I> Function and the Polygon-Filling Mode</h2></A>
<p>I've already discussed the first five area-filling functions. <I>Polygon</I> is the sixth function for drawing a bordered and filled figure. The function call is similar to the <I>Polyline</I> function:

<p><pre>
Polygon (hdc, apt, iCount) ;
</pre>

<p>The <I>apt</I> argument is an array of POINT structures, and <I>iCount</I> is the number of points. If the last point in this array is different from the first point, Windows adds another line that connects the last point with the first point. (This does not happen with the <I>Polyline</I> function.) The <I>PolyPolygon</I> function looks like this:

<p><pre>
PolyPolygon (hdc, apt, aiCounts, iPolyCount) ;
</pre>

<p>The function draws multiple polygons. The number of polygons it draws is given as the last argument. For each polygon, the <I>aiCounts</I> array gives the number of points in the polygon. The <I>apt</I> array has all the points for all the polygons. Aside from the return value, <I>PolyPolygon</I> is functionally equivalent to the following code:

<p><pre>
for (i = 0, iAccum = 0 ; i &lt; iPolyCount ; i++)
{
     Polygon (hdc, apt + iAccum, aiCounts[i]) ;
     iAccum += aiCounts[i] ;
}
</pre>

<p>For both <I>Polygon</I> and <I>PolyPolygon</I>, Windows fills the bounded area with the current brush defined in the device context. How the interior is filled depends on the polygon-filling mode, which you can set using the <I>SetPolyFillMode</I> function:

<p><pre>
SetPolyFillMode (hdc, iMode) ;
</pre>

<p>By default, the polygon-filling mode is ALTERNATE, but you can set it to WINDING. The difference between the two modes is shown in Figure 5-19.

<p><A HREF="javascript:fullSize('F05zg19x.htm')"> <img src="F05zg19.JPG" width=404 height=189 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 5-19.</B> <I>Figures drawn with the two polygon-filling modes: ALTERNATE (left) and WINDING (right).</I><!-- /caption -->

<p>At first, the difference between alternate and winding modes seems rather simple. For alternate mode, you can imagine a line drawn from a point in an enclosed area to infinity. The enclosed area is filled only if that imaginary line crosses an odd number of boundary lines. This is why the points of the star are filled but the center is not.

<p>The example of the five-pointed star makes winding mode seem simpler than it actually is. When you're drawing a single polygon, in most cases winding mode will cause all enclosed areas to be filled. But there are exceptions.

<p>To determine whether an enclosed area is filled in winding mode, you again imagine a line drawn from a point in that area to infinity. If the imaginary line crosses an odd number of boundary lines, the area is filled, just as in alternate mode. If the imaginary line crosses an even number of boundary lines, the area can either be filled or not filled. The area is filled if the number of boundary lines going in one direction (relative to the imaginary line) is not equal to the number of boundary lines going in the other direction.

<p>For example, consider the object shown in Figure 5-20. The arrows on the lines indicate the direction in which the lines are drawn. Both winding mode and alternate mode will fill the three enclosed L-shaped areas numbered 1 through 3. The two smaller interior areas, numbered 4 and 5, will not be filled in alternate mode. But in winding mode, area number 5 is filled because you must cross two lines going in the same direction to get from the inside of that area to the outside of the figure. Area number 4 is not filled. You must again cross two lines, but the two lines go in opposite directions.

<p>If you doubt that Windows is clever enough to do this, the ALTWIND program in Figure 5-21 demonstrates that it is.

<p><img src="F05zg20.GIF" width=282 height=282 border="0">

<p><!-- caption --><B>Figure 5-20.</B> <I>A figure in which winding mode does not fill all interior areas.</I><!-- /caption -->


<p><B>Figure 5-21.</B> <I>The ALTWIND program.</I>
<table width="95%" cellpadding="5" valign="TOP" cols="1"><tr><td valign=top>
<A NAME="123"><h3>ALTWIND.C</h3></A><p><pre>
/*-----------------------------------------------
   ALTWIND.C -- Alternate and Winding Fill Modes
                (c) Charles Petzold, 1998
  -----------------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;AltWind&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;Program requires Windows NT!&quot;), 
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Alternate and Winding Fill Modes&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static POINT aptFigure [10] = { 10,70, 50,70, 50,10, 90,10, 90,50,
                                     30,50, 30,90, 70,90, 70,30, 10,30 };
     static int   cxClient, cyClient ;
     HDC          hdc ;
     int          i ;
     PAINTSTRUCT  ps ;
     POINT        apt[10] ;
     
     switch (message)
     {
     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;

     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;

          SelectObject (hdc, GetStockObject (GRAY_BRUSH)) ;

          for (i = 0 ; i &lt; 10 ; i++)
          {
               apt[i].x = cxClient * aptFigure[i].x / 200 ;
               apt[i].y = cyClient * aptFigure[i].y / 100 ;
          }

          SetPolyFillMode (hdc, ALTERNATE) ;
          Polygon (hdc, apt, 10) ;

          for (i = 0 ; i &lt; 10 ; i++)
          {
               apt[i].x += cxClient / 2 ;
          }

          SetPolyFillMode (hdc, WINDING) ;
          Polygon (hdc, apt, 10) ;
          
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</PRE></td></tr></table>

<p>The coordinates of the figure&#8212;scaled to an arbitrary 100-unit-by-100-unit area&#8212;are stored in the <I>aptFigure</I> array. These coordinates are scaled based on the width and height of the client area. The program displays the figure twice, once using the ALTERNATE filling mode and then using WINDING. The results are shown in Figure 5-22.

<p><A HREF="javascript:fullSize('F05zg22x.htm')"> <img src="F05zg22.JPG" width=404 height=285 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 5-22.</B> <I>The ALTWIND display.</I><!-- /caption -->

<A NAME="124"><h2>Brushing the Interior</h2></A>
<p>The interiors of the <I>Rectangle</I>, <I>RoundRect</I>, <I>Ellipse</I>, <I>Chord</I>, <I>Pie</I>, <I>Polygon</I>, and <I>PolyPolygon</I> figures are filled with the current brush (sometimes also called a &quot;pattern&quot;) selected in the device context. A brush is a small 8-pixel-by-8-pixel bitmap that is repeated horizontally and vertically to fill the area.

<p>When Windows uses dithering to display more colors than are normally available on a display, it actually uses a brush for the color. On a monochrome system, Windows can use dithering of black and white pixels to create 64 different shades of gray. More precisely, Windows can create 64 different monochrome brushes. For pure black, all bits in the 8-by-8 bitmap are 0. One bit out of the 64 is made 1 (that is, white) for the first gray shade, two bits are white for the second gray shade, and so on, until all bits in the 8-by-8 bitmap are 1 for pure white. With a 16-color or 256-color video system, dithered colors are also brushes and Windows can display a much wider range of color than would normally be available.

<p>Windows has five functions that let you create logical brushes. You select the brush into the device context with <I>SelectObject</I>. Like logical pens, logical brushes are GDI objects. Any brush that you create must be deleted, but it must not be deleted while it is selected in a device context.

<p>Here's the first function to create a logical brush:

<p><pre>
hBrush = CreateSolidBrush (crColor) ;
</pre>

<p>The word <I>Solid</I> in this function doesn't really mean that the brush is a pure color. When you select the brush into the device context, Windows may create a dithered bitmap and use that for the brush.

<p>You can also create a brush with &quot;hatch marks&quot; made up of horizontal, vertical, or diagonal lines. Brushes of this style are most commonly used for coloring the interiors of bar graphs and when drawing to plotters. The function for creating a hatch brush is

<p><pre>
hBrush = CreateHatchBrush (iHatchStyle, crColor) ;
</pre>

<p>The <I>iHatchStyle</I> argument describes the appearance of the hatch marks. Figure 5-23 shows the six available hatch style constants and what they look like.

<p><A HREF="javascript:fullSize('F05zg23x.htm')"> <img src="F05zg23.JPG" width=404 height=100 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 5-23.</B> <I>The six hatch brush styles.</I><!-- /caption -->

<p>The <I>crColor</I> argument to 
<I>CreateHatchBrush</I> specifies the color of the hatch lines. When you select the brush into a device context, Windows converts this color to the nearest pure color available on the display. The area between the hatch lines is colored based on the current background mode and the background color. If the background mode is OPAQUE, the background color (which is also converted to a pure color) is used to fill in the spaces between the lines. If the background mode is TRANSPARENT, Windows draws the hatch lines without filling in the area between them.

<p>You can also create your own brushes based on bitmaps using <I>CreatePatternBrush </I>and<I> CreateDIBPatternBrushPt</I>.

<p>The fifth function for creating a logical brush encompasses the other four functions:

<p><pre>
hBrush = CreateBrushIndirect (&amp;logbrush) ;
</pre>

<p>The <I>logbrush</I> variable is a structure of type LOGBRUSH (&quot;logical brush&quot;). The three fields of this structure are shown below. The value of the <I>lbStyle</I> field determines how Windows interprets the other two fields:

<p><table width="95%" cellpadding="5" valign="TOP">
<tr>
<td valign=top><b><i>lbStyle (UINT)</i></b></td>
<td valign=top><b><i>lbColor (COLORREF)</i></b></td>
<td valign=top><b><i>lbHatch (LONG)</i></b></td>
</tr>
<tr>
<td valign=top>BS_SOLID</td>
<td valign=top>Color of brush</td>
<td valign=top>Ignored</td>
</tr>
<tr>
<td valign=top>BS_HOLLOW</td>
<td valign=top>Ignored</td>
<td valign=top>Ignored</td>
</tr>
<tr>
<td valign=top>BS_HATCHED</td>
<td valign=top>Color of hatches</td>
<td valign=top>Hatch brush style</td>
</tr>
<tr>
<td valign=top>BS_PATTERN</td>
<td valign=top>Ignored</td>
<td valign=top>Handle to bitmap</td>
</tr>
<tr>
<td valign=top>BS_DIBPATTERNPT</td>
<td valign=top>Ignored</td>
<td valign=top>Pointer to DIB</td>
</tr>
</table>
<p>Earlier we used <I>SelectObject</I> to select a logical pen into a device context, <I>DeleteObject</I> to delete a logical pen, and <I>GetObject</I> to get information about a logical pen. You can use these same three functions with brushes. Once you have a handle to a brush, you can select the brush into a device context using <I>SelectObject</I>:

<p><pre>
SelectObject (hdc, hBrush) ;
</pre>

<p>You can later delete a created brush with the <I>DeleteObject</I> function:

<p><pre>
DeleteObject (hBrush) ;
</pre>

<p>Do not delete a brush that is currently selected in a device context.

<p>If you need to obtain information about a brush, you can call <I>GetObject</I>,

<p><pre>
GetObject (hBrush, sizeof (LOGBRUSH), (LPVOID) &amp;logbrush) ;
</pre>

<p>where <I>logbrush</I> is a structure of type LOGBRUSH.

</BODY>
</HTML>






