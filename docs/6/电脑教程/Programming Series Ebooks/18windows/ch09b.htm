<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<TITLE>The Button Class</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">

<A NAME="235"><h1>The Button Class</h1></A>
<p>We'll begin our exploration of the button window class with a program named BTNLOOK (&quot;button look&quot;), which is shown in Figure 9-1. BTNLOOK creates 10 child window button controls, one for each of the 10 standard styles of buttons.



<p><B>Figure 9-1.</B> <I>The BTNLOOK program.</I>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="236"><p><H3>BTNLOOK.C</H3></A>
<p><pre>
/*----------------------------------------
   BTNLOOK.C -- Button Look Program
                (c) Charles Petzold, 1998
  ----------------------------------------*/

#include &lt;windows.h&gt;

struct
{
     int     iStyle ;
     TCHAR * szText ;
}
button[] =
{
     BS_PUSHBUTTON,      TEXT (&quot;PUSHBUTTON&quot;),
     BS_DEFPUSHBUTTON,   TEXT (&quot;DEFPUSHBUTTON&quot;),
     BS_CHECKBOX,        TEXT (&quot;CHECKBOX&quot;), 
     BS_AUTOCHECKBOX,    TEXT (&quot;AUTOCHECKBOX&quot;),
     BS_RADIOBUTTON,     TEXT (&quot;RADIOBUTTON&quot;),
     BS_3STATE,          TEXT (&quot;3STATE&quot;),
     BS_AUTO3STATE,      TEXT (&quot;AUTO3STATE&quot;),
     BS_GROUPBOX,        TEXT (&quot;GROUPBOX&quot;),
     BS_AUTORADIOBUTTON, TEXT (&quot;AUTORADIO&quot;),
     BS_OWNERDRAW,       TEXT (&quot;OWNERDRAW&quot;)
} ;

#define NUM (sizeof button / sizeof button[0])

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;BtnLook&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Button Look&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {  
   TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HWND  hwndButton[NUM] ;
     static RECT  rect ;
     static TCHAR szTop[]    = TEXT (&quot;message            wParam       lParam&quot;),
                  szUnd[]    = TEXT (&quot;_______            ______       ______&quot;),
                  szFormat[] = TEXT (&quot;%-16s%04X-%04X    %04X-%04X&quot;),
                  szBuffer[50] ;
     static int   cxChar, cyChar ;
     HDC          hdc ;
     PAINTSTRUCT  ps ;
     int          i ;
     
     switch (message)
     {
     case WM_CREATE :
          cxChar = LOWORD (GetDialogBaseUnits ()) ;
          cyChar = HIWORD (GetDialogBaseUnits ()) ;
          
          for (i = 0 ; i &lt; NUM ; i++)
               hwndButton[i] = CreateWindow ( TEXT(&quot;button&quot;), 
                                   button[i].szText,
                                   WS_CHILD | WS_VISIBLE | button[i].iStyle,
                                   cxChar, cyChar * (1 + 2 * i),
                                   20 * cxChar, 7 * cyChar / 4,
                                   hwnd, (HMENU) i,
                                   ((LPCREATESTRUCT) lParam)-&gt;hInstance, NULL) ;
          return 0 ;

     case WM_SIZE :
          rect.left   = 24 * cxChar ;
          rect.top    =  2 * cyChar ;
          rect.right  = LOWORD (lParam) ;
          rect.bottom = HIWORD (lParam) ;
          return 0 ;

     case WM_PAINT :
          InvalidateRect (hwnd, &amp;rect, TRUE) ;
          
          hdc = BeginPaint (hwnd, &amp;ps) ;
          SelectObject (hdc, GetStockObject (SYSTEM_FIXED_FONT)) ;
          SetBkMode (hdc, TRANSPARENT) ;
          
          TextOut (hdc, 24 * cxChar, cyChar, szTop, lstrlen (szTop)) ;
          TextOut (hdc, 24 * cxChar, cyChar, szUnd, lstrlen (szUnd)) ;
          
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_DRAWITEM :
     case WM_COMMAND :
          ScrollWindow (hwnd, 0, -cyChar, &amp;rect, &amp;rect) ;
          
          hdc = GetDC (hwnd) ;
          SelectObject (hdc, GetStockObject (SYSTEM_FIXED_FONT)) ;
          
          TextOut (hdc, 24 * cxChar, cyChar * (rect.bottom / cyChar - 1),
                   szBuffer,
                   wsprintf (szBuffer, szFormat,
                         message == WM_DRAWITEM ? TEXT (&quot;WM_DRAWITEM&quot;) : 
                                                  TEXT (&quot;WM_COMMAND&quot;),
                         HIWORD (wParam), LOWORD (wParam),
                         HIWORD (lParam), LOWORD (lParam))) ;
          
          ReleaseDC (hwnd, hdc) ;
          ValidateRect (hwnd, &amp;rect) ;
          break ;
          
     case WM_DESTROY :
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</TD></TR></TABLE> 

<p>As you click on each button, the button sends a WM_COMMAND message to the parent window procedure, which is the familiar <I>WndProc</I>. BTNLOOK's <I>WndProc</I> displays the <I>wParam</I> and <I>lParam</I> parameters of this message in the right half of the client area, as shown in Figure 9-2.

<p>The button with the style BS_OWNERDRAW is displayed on this window only with a background shading because this is a style of button that the program is responsible for drawing. The button indicates it needs drawing by WM_DRAWITEM messages containing an <I>lParam</I> message parameter that is a pointer to a structure of type DRAWITEMSTRUCT. These messages are also displayed in BTNLOOK. I'll discuss owner-draw buttons in more detail later in this chapter.

<p><A HREF="javascript:fullSize('F09zg02x.htm')"><img src="F09zg02.JPG" width=404 height=285 border=0 ALT="Click to view at full size."></a>

<p><!-- caption --><B>Figure 9-2.</B> <I>The BTNLOOK display.</I><!-- /caption -->

<A NAME="237"><h2>Creating the Child Windows</h2></A>
<p>BTNLOOK defines a structure called <I>button</I> that contains button window styles and descriptive text strings for each of the 10 types of buttons. The button window styles all begin with the letters BS, which stand for &quot;button style.&quot; The 10 button child windows are created in a <I>for</I> loop during WM_CREATE message processing in <I>WndProc</I>. The <I>CreateWindow</I> call uses the following parameters:

<P>
<table CELLPADDING="5" WIDTH="95%">
<tr><td valign="top">Class name</td>
<td valign="top"><pre>TEXT (&quot;button&quot;)</pre></td></tr>
<tr><td valign="top">Window text</td>
<td valign="top"><pre>button[i].szText</pre></td></tr>
<tr><td valign="top">Window style</td>
<td valign="top"><pre>WS_CHILD &#166; WS_VISIBLE &#166; button[i].iStyle</pre></td></tr>
<tr><td valign="top">x position</td>
<td valign="top"><pre>cxChar</pre></td></tr>
<tr><td valign="top">y position</td>
<td valign="top"><pre>cyChar * (1 + 2 * i)</pre></td></tr>
<tr><td valign="top">Width</td>
<td valign="top"><pre>20 * xChar</pre></td></tr>
<tr><td valign="top">Height</td>
<td valign="top"><pre>7 * yChar / 4</pre></td></tr>
<tr><td valign="top">Parent window</td>
<td valign="top"><pre>hwnd</pre></td></tr>
<tr><td valign="top">Child window ID</td>
<td valign="top"><pre>(HMENU) i</pre></td></tr>
<tr><td valign="top">Instance handle</td>
<td valign="top"><pre>((LPCREATESTRUCT) lParam) -&gt; hInstance</pre></td></tr>
<tr><td valign="top">Extra parameters</td>
<td valign="top"><pre>NULL</pre></td></tr>
</TABLE> 

<p>The class name parameter is the predefined name. The window style uses WS_CHILD, WS_VISIBLE, and one of the 10 button styles (BS_PUSHBUTTON, BS_DEFPUSHBUTTON, and so forth) that are defined in the button structure. The window text parameter (which for a normal window is the text that appears in the caption bar) is text that will be displayed with each button. I've simply used text that identifies the button style.

<p>The <I>x</I> position and <I>y</I> position parameters indicate the placement of the upper left corner of the child window relative to the upper left corner of the parent window's client area. The width and height parameters specify the width and height of each child window. Notice that I'm using a function named <I>GetDialogBaseUnits</I> to obtain the width and height of the characters in the default font. This is the function that dialog boxes use to obtain text dimensions. The function returns a 32-bit value comprising a width in the low word and a height in the high word. While <I>GetDialogBaseUnits</I> returns roughly the same values as can be obtained from the <I>GetTextMetrics</I> function, it's somewhat easier to use and will ensure more consistency with controls in dialog boxes.

<p>The child window ID parameter should be unique for each child window. This ID helps your window procedure identify the child window when processing WM_COMMAND messages from it. Notice that the child window ID is passed in the <I>CreateWindow</I> parameter normally used to specify the program's menu, so it must be cast to an HMENU.

<p>The instance handle parameter of the <I>CreateWindow</I> call looks a little strange, but we're taking advantage of the fact that during a WM_CREATE message <I>lParam</I> is actually a pointer to a structure of type CREATESTRUCT (&quot;creation structure&quot;) that has a member <I>hInstance</I>. So we cast <I>lParam</I> into a pointer to a CREATESTRUCT structure and get <I>hInstance</I> out.

<p>(Some Windows programs use a global variable named <I>hInst</I> to give window procedures access to the instance handle available in <I>WinMain</I>. In <I>WinMain</I>, you need to simply set

<p><pre>
hInst = hInstance ;
</PRE>

<p>before creating the main window. In the CHECKER3 program in <a href="ch07a.htm#182">Chapter 7</a>, we used <I>GetWindowLong</I> to obtain this instance handle:

<p><pre>
GetWindowLong (hwnd, GWL_HINSTANCE)
</PRE>


<p>Any of these methods is fine.)

<p>After the <I>CreateWindow</I> call, we needn't do anything more with these child windows. The button window procedure within Windows maintains the buttons for us and handles all repainting jobs. (The exception is the button with the BS_OWNERDRAW style; as I'll discuss later, this button style requires the program to draw the button.) At the program's termination, Windows destroys these child windows when the parent window is destroyed.

<A NAME="238"><h2>The Child Talks to Its Parent</h2></A>
<p>When you run BTNLOOK, you see the different button types displayed on the left side of the client area. As I mentioned earlier, when you click a button with the mouse, the child window control sends a WM_COMMAND message to its parent window. BTNLOOK traps the WM_COMMAND message and displays the values of <I>wParam</I> and <I>lParam</I>. Here's what they mean:

<P>
<table CELLPADDING="5" WIDTH="95%">
<tr><td valign="top">LOWORD (wParam)</td>
<td valign="top">Child window ID</td></tr>
<tr><td valign="top">HIWORD (wParam)</td>
<td valign="top">Notification code</td></tr>
<tr><td valign="top"><I>lParam</I></td>
<td valign="top">Child window handle</td></tr>
</TABLE> 

<p>If you're converting programs written for the 16-bit versions of Windows, be aware that these message parameters have been altered to accommodate 32-bit handles.

<p>The child window ID is the value passed to <I>CreateWindow</I> when the child window is created. In BTNLOOK, these IDs are 0 through 9 for the 10 buttons displayed in the client area. The child window handle is the value that Windows returns from the <I>CreateWindow</I> call.

<p>The notification code indicates in more detail what the message means. The possible values of button notification codes are defined in the Windows header files:

<P> 
<table CELLPADDING="5" WIDTH="95%">
<tr><td valign="top"><B><I>Button Notification Code Identifier</I></B></td>
<td valign="top"><B><I>Value</I></B></td></tr>
<tr><td valign="top">BN_CLICKED</td>
<td valign="top">0</td></tr>
<tr><td valign="top">BN_PAINT</td>
<td valign="top">1</td></tr>

<tr><td valign="top">BN_HILITE or BN_PUSHED</td>
<td valign="top">2</td></tr>
<tr><td valign="top">BN_UNHILITE or BN_UNPUSHED</td>
<td valign="top">3</td></tr>
<tr><td valign="top">BN_DISABLE</td>
<td valign="top">4</td></tr>
<tr><td valign="top">BN_DOUBLECLICKED or BN_DBLCLK</td>
<td valign="top">5</td></tr>
<tr><td valign="top">BN_SETFOCUS</td>
<td valign="top">6</td></tr>
<tr><td valign="top">BN_KILLFOCUS</td>
<td valign="top">7</td></tr>
</TABLE> 

<p>In reality, you'll never see most of these button values. The notification codes 1 through 4 are for an obsolete button style called BS_USERBUTTON. (It's been replaced with BS_OWNERDRAW and a different notification mechanism.) The notification codes 6 and 7 are sent only if the button style includes the flag BS_NOTIFY. The notification code 5 is sent only for BS_RADIOBUTTON, BS_AUTORADIOBUTTON, and BS_OWNERDRAW buttons, or for other buttons if the button style includes BS_NOTIFY.

<p>You'll notice that when you click a button with the mouse, a dashed line surrounds the text of the button. This indicates that the button has the input focus. All keyboard input now goes to the child window button control rather than to the main window. However, when the button control has the input focus, it ignores all keystrokes except the Spacebar, which now has the same effect as a mouse click.

<A NAME="239"><h2>The Parent Talks to Its Child</h2></A>
<p>Although BTNLOOK does not demonstrate this fact, a window procedure can also send messages to the child window control. These messages include many of the window messages beginning with the prefix WM. In addition, eight button-specific messages are defined in WINUSER.H; each begins with the letters BM, which stand for &quot;button message.&quot; These button messages are shown in the following table:

<P> 
<table CELLPADDING="5" WIDTH="95%">
<tr><td valign="top"><B><I>Button Message</I></B></td>
<td valign="top"><B><I>Value</I></B></td></tr>
<tr><td valign="top">BM_GETCHECK</td>
<td valign="top">0x00F0</td></tr>
<tr><td valign="top">BM_SETCHECK</td>

<td valign="top">0x00F1</td></tr>
<tr><td valign="top">BM_GETSTATE</td>
<td valign="top">0x00F2</td></tr>
<tr><td valign="top">BM_SETSTATE</td>
<td valign="top">0x00F3</td></tr>
<tr><td valign="top">BM_SETSTYLE</td>
<td valign="top">0x00F4</td></tr>
<tr><td valign="top">BM_CLICK</td>
<td valign="top">0x00F5</td></tr>
<tr><td valign="top">BM_GETIMAGE</td>
<td valign="top">0x00F6</td></tr>
<tr><td valign="top">BM_SETIMAGE</td>
<td valign="top">0x00F7</td></tr>
</TABLE>

<p>The BM_GETCHECK and BM_SETCHECK messages are sent by a parent window to a child window control to get and set the check mark of check boxes and radio buttons. The BM_GETSTATE and BM_SETSTATE messages refer to the normal, or pushed, state of a window when you click it with the mouse or press it with the Spacebar. We'll see how these messages work when we look at each type of button. The BM_SETSTYLE message lets you change the button style after the button is created.

<p>Each child window has a window handle and an ID that is unique among its siblings. Knowing one of these items allows you to get the other. If you know the window handle of the child, you can obtain the ID using

<p><pre>
id = GetWindowLong (hwndChild, GWL_ID) ;
</PRE>

<p>This function (along with <I>SetWindowLong</I>) was used in the CHECKER3 program in <a href="ch07a.htm#182">Chapter 7</a> to maintain data in a special area reserved when the window class was registered. The area accessed with the GWL_ID identifier is reserved by Windows when the child window is created. You can also use

<p><pre>
id = GetDlgCtrlID (hwndChild) ;
</PRE>



<p>Even though the &quot;Dlg&quot; part of the function name refers to a dialog box, this is really a general-purpose function.

<p>Knowing the ID and the parent window handle, you can get the child window handle:

<p><pre>
hwndChild = GetDlgItem (hwndParent, id) ;
</PRE>

<A NAME="240"><h2>Push Buttons</h2></A>
<p>The first two buttons shown in BTNLOOK are &quot;push&quot; buttons. A push button is a rectangle enclosing text specified in the window text parameter of the <I>CreateWindow</I> call. The rectangle takes up the full height and width of the dimensions given in the <I>CreateWindow</I> or <I>MoveWindow</I> call. The text is centered within the rectangle.

<p>Push-button controls are used mostly to trigger an immediate action without retaining any type of on/off indication. The two types of push-button controls have window styles called BS_PUSHBUTTON and BS_DEFPUSHBUTTON. The &quot;DEF&quot; in BS_DEFPUSHBUTTON stands for &quot;default.&quot; When used to design dialog boxes, BS_PUSHBUTTON controls and BS_DEFPUSHBUTTON controls function differently from one another. When used as child window controls, however, the two types of push buttons function the same way, although BS_DEFPUSHBUTTON has a heavier outline.

<p>A push button looks best when its height is 7/4 times the height of a text character, which is what BTNLOOK uses. The push button's width must accommodate at least the width of the text, plus two additional characters.

<p>When the mouse cursor is inside the push button, pressing the mouse button causes the button to repaint itself using 3D-style shading to appear as if it's been depressed. Releasing the mouse button restores the original appearance and sends a WM_COMMAND message to the parent window with the notification code BN_CLICKED. As with the other button types, when a push button has the input focus, a dashed line surrounds the text and pressing and releasing the Spacebar has the same effect as pressing and releasing the mouse button.

<p>You can simulate a push-button flash by sending the window a BM_SETSTATE message. This causes the button to be depressed:

<p><pre>
SendMessage (hwndButton, BM_SETSTATE, 1, 0) ;
</PRE>

<p>This call causes the button to return to normal:

<p><pre>
SendMessage (hwndButton, BM_SETSTATE, 0, 0) ;
</PRE>

<p>The <I>hwndButton</I> window handle is the value returned from the <I>CreateWindow</I> call.

<p>You can also send a BM_GETSTATE message to a push button. The child window control returns the current state of the button: TRUE if the button is depressed and FALSE if it isn't depressed. Most applications do not require this information, however. And because push buttons do not retain any on/off information, the BM_SETCHECK and BM_GETCHECK messages are not used.

<A NAME="241"><h2>Check Boxes</h2></A>
<p>A check box is a square box with text; the text usually appears to the right of the check box. (If you include the BS_LEFTTEXT style when creating the button, the text appears to the left; you'll probably want to combine this style with BS_RIGHT to right-justify the text.) Check boxes are usually incorporated in an application to allow a user to select options. The check box commonly functions as a toggle switch: clicking the box once causes a check mark to appear; clicking again toggles the check mark off.

<p>The two most common styles for a check box are BS_CHECKBOX and BS_AUTOCHECKBOX. When you use the BS_CHECKBOX style, you must set the check mark yourself by sending the control a BM_SETCHECK message. The <I>wParam</I> parameter is set to 1 to create a check mark and to 0 to remove it. You can obtain the current check state of the box by sending the control a BM_GETCHECK message. You might use code like this to toggle the X mark when processing a WM_COMMAND message from the control:

<p><pre>
SendMessage ((HWND) lParam, BM_SETCHECK, (WPARAM)
          !SendMessage ((HWND) lParam, BM_GETCHECK, 0, 0), 0) ;
</PRE>

<p>Notice the ! operator in front of the second <I>SendMessage</I> call. The <I>lParam</I> value is the child window handle that is passed to your window procedure in the WM_COMMAND message. When you later need to know the state of the button, send it another BM_GETCHECK message. Or you can retain the current check state in a static variable in your window procedure. You can also initialize a BS_CHECKBOX check box with a check mark by sending it a BM_SETCHECK message:

<p><pre>
SendMessage (hwndButton, BM_SETCHECK, 1, 0) ;
</PRE>

<p>For the BS_AUTOCHECKBOX style, the button control itself toggles the check mark on and off. Your window procedure can ignore WM_COMMAND messages. When you need the current state of the button, send the control a BM_GETCHECK message:

<p><pre>
iCheck = (int) SendMessage (hwndButton, BM_GETCHECK, 0, 0) ;
</PRE>

<p>The value of iCheck is TRUE or nonzero if the button is checked and FALSE or 0 if not.

<p>The other two check box styles are BS_3STATE and BS_AUTO3STATE. As their names indicate, these styles can display a third state as well&#8212;a gray color within the check box&#8212;which occurs when you send the control a WM_SETCHECK message with <I>wParam</I> equal to 2. The gray color indicates to the user that the selection is indeterminate or irrelevant.

<p>The check box is aligned with the rectangle's left edge and is centered within the top and bottom dimensions of the rectangle that were specified during the <I>CreateWindow</I> call. Clicking anywhere within the rectangle causes a WM_COMMAND message to be sent to the parent. The minimum height for a check box is one character height. The minimum width is the number of characters in the text, plus two.

<A NAME="242"><h2>Radio Buttons</h2></A>
<p>A radio button is named after the row of buttons that were once quite common on car radios. Each button on a car radio is set for a different radio station, and only one button can be pressed at a time. In dialog boxes, groups of radio buttons are conventionally used to indicate mutually exclusive options. Unlike check boxes, radio buttons do not work as toggles&#8212;that is, when you click a radio button a second time, its state remains unchanged.

<p>The radio button looks very much like a check box except that it contains a little circle rather than a box. A heavy dot within the circle indicates that the radio button has been checked. The radio button has the window style BS_RADIOBUTTON or BS_AUTORADIOBUTTON, but the latter is used only in dialog boxes.

<p>When you receive a WM_COMMAND message from a radio button, you should display its check by sending it a BM_SETCHECK message with <I>wParam</I> equal to 1:

<p><pre>
SendMessage (hwndButton, BM_SETCHECK, 1, 0) ;
</PRE>

<p>For all other radio buttons in the same group, you can turn off the checks by sending them BM_SETCHECK messages with <I>wParam</I> equal to 0:

<p><pre>
SendMessage (hwndButton, BM_SETCHECK, 0, 0) ;
</PRE>

<A NAME="243"><h2>Group Boxes</h2></A>
<p>The group box, which has the BS_GROUPBOX style, is an oddity in the button class. It neither processes mouse or keyboard input nor sends WM_COMMAND messages to its parent. The group box is a rectangular outline with its window text at the top. Group boxes are often used to enclose other button controls.

<A NAME="244"><h2>Changing the Button Text</h2></A>
<p>You can change the text in a button (or in any other window) by calling <I>SetWindowText</I>:

<p><pre>
SetWindowText (hwnd, pszString) ;
</PRE>

<p>where <I>hwnd</I> is a handle to the window whose text is being changed and <I>pszString</I> is a pointer to a null-terminated string. For a normal window, this text is the text of the caption bar. For a button control, it's the text displayed with the button.

<p>You can also obtain the current text of a window:

<p><pre>
iLength = GetWindowText (hwnd, pszBuffer, iMaxLength) ;
</PRE>

<p>The <I>iMaxLength</I> parameter specifies the maximum number of characters to copy into the buffer pointed to by <I>pszBuffer</I>. The function returns the string length copied. You can prepare your program for a particular text length by first calling

<p><pre>
iLength = GetWindowTextLength (hwnd) ;
</PRE>

<A NAME="245"><h2>Visible and Enabled Buttons</h2></A>
<p>To receive mouse and keyboard input, a child window must be both visible (displayed) and enabled. When a child window is visible but not enabled, Windows displays the text in gray rather than black.

<p>If you don't include WS_VISIBLE in the window class when creating the child window, the child window will not be displayed until you make a call to <I>ShowWindow</I>:

<p><pre>
ShowWindow (hwndChild, SW_SHOWNORMAL) ;
</PRE>

<p>But if you include WS_VISIBLE in the window class, you don't need to call <I>ShowWindow</I>. However, you can hide the child window by this call to <I>ShowWindow</I>:

<p><pre>
ShowWindow (hwndChild, SW_HIDE) ;
</PRE>

<p>You can determine if a child window is visible by a call to

<p><pre>
IsWindowVisible (hwndChild) ;
</PRE>

<p>You can also enable and disable a child window. By default, a window is enabled. You can disable it by calling

<p><pre>
EnableWindow (hwndChild, FALSE) ;
</PRE>

<p>For button controls, this call has the effect of graying the button text string. The button no longer responds to mouse or keyboard input. This is the best method for indicating that a button option is currently unavailable.

<p>You can reenable a child window by calling

<p><pre>
EnableWindow (hwndChild, TRUE) ;
</PRE>

<p>You can determine whether a child window is enabled by calling

<p><pre>
IsWindowEnabled (hwndChild) ;
</PRE>

<A NAME="246"><h2>Buttons and Input Focus</h2></A>
<p>As I noted earlier in this chapter, push buttons, check boxes, radio buttons, and owner-draw buttons receive the input focus when they are clicked with the mouse. The control indicates it has the input focus with a dashed line that surrounds the text. When the child window control gets the input focus, the parent window loses it; all keyboard input then goes to the control rather than to the parent window. However, the child window control responds only to the Spacebar, which now functions like the mouse. This situation presents an obvious problem: your program has lost control of keyboard processing. Let's see what we can do about it.

<p>As I discussed in <a href="ch06a.htm#144">Chapter 6</a>, when Windows switches the input focus from one window (such as a parent) to another (such as a child window control), it first sends a WM_KILLFOCUS message to the window losing the input focus. The <I>wParam</I> parameter is the handle of the window that is to receive the input focus. Windows then sends a WM_SETFOCUS message to the window receiving the input focus, with <I>wParam</I> specifying the handle of the window losing the input focus. (In both cases, <I>wParam</I> might be NULL, which indicates that no window has or is receiving the input focus.)

<p>A parent window can prevent a child window control from getting the input focus by processing WM_KILLFOCUS messages. Assume that the array <I>hwndChild</I> contains the window handles of all child windows. (These were saved in the array during the <I>CreateWindow</I> calls that created the windows.) NUM is the number of child windows.

<p><pre>
case WM_KILLFOCUS :

     for (i = 0 ; i &lt; NUM ; i++)
          if (hwndChild [i] == (HWND) wParam)
          {
               SetFocus (hwnd) ;
               break ;
          }
     return 0 ;
</PRE>

<p>In this code, when the parent window detects that it's losing the input focus to one of its child window controls, it calls <I>SetFocus</I> to restore the input focus to itself.

<p>Here's a simpler (but less obvious) way of doing it:

<p><pre>
case WM_KILLFOCUS :
     if (hwnd == GetParent ((HWND) wParam))
          SetFocus (hwnd) ;
     return 0 ;
</PRE>

<p>Both these methods have a shortcoming, however: they prevent the button from responding to the Spacebar, because the button never gets the input focus. A better approach would be to let the button get the input focus but also to include the facility for the user to move from button to button using the Tab key. At first this sounds impossible, but I'll show you how to accomplish it with a technique called &quot;window subclassing&quot; in the COLORS1 program shown later in this chapter.

</body>
</html>


