<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Simple Use of the Clipboard</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="382"><h1>Simple Use of the Clipboard</h1></A><P>We'll begin by looking at the code involved for transferring data to the clipboard (Cut 
and Copy) and getting access to clipboard data (Paste).

<A NAME="383"><h2>The Standard Clipboard Data Formats</h2></A><P>Windows supports various predefined clipboard formats that have identifiers beginning 
with the prefix CF defined in WINUSER.H.
<P>First, there are three types of text data that can be stored in the clipboard, and 
another related clipboard format:
<UL>
<p><li><I>CF_TEXT</I> A NULL-terminated ANSI character-set character string containing 
a carriage return and a linefeed character at the end of each line. This is the 
simplest form of clipboard data. The data to be transferred to the clipboard is stored 
in a memory block and is transferred using the handle to the block. (I'll 
discuss this concept shortly.) The memory block becomes the property of the 
clipboard, and the program that creates the block should not continue to use it.
<p><li><I>CF_OEMTEXT</I> A memory block containing text data (similar to CF_TEXT) 
but using the OEM character set. Windows programs usually don't need to 
worry about this; it comes into play when using the clipboard in conjunction 
with MSDOS programs running in a window.
<p><li><I>CF_UNICODETEXT</I> A memory block containing Unicode text. Like 
CF_TEXT, each line is terminated with a carriage return and linefeed character, and a 
NULL character (two zero bytes) indicates the end of the data. CF_UNICODETEXT 
is supported under Windows NT only.
<p><li><I>CF_LOCALE</I> A handle to a locale identifier indicating the locale associated 
with clipboard text.
</UL>
<P>There are two additional clipboard formats that are conceptually similar to 
the CF_TEXT format (that is, they are text-based), but they are not necessarily 
NULL-terminated, because the formats define the end of the data. These formats are rarely used these days:
<UL>
<p><li><I>CF_SYLK</I> A memory block containing data in the Microsoft &quot;Symbolic 
Link&quot; format. This format is used for exchanging data between Microsoft's 
Multiplan, Chart, and Excel programs. It is an ASCII format with each line terminated 
with a carriage return and a linefeed.
<p><li><I>CF_DIF</I> A memory block containing data in the Data Interchange Format 
(DIF). This is a format devised by Software Arts for use in transferring data to 
the VisiCalc spreadsheet program. This is also an ASCII format with lines 
terminated with carriage returns and linefeeds.
</UL>
<P>There are three clipboard formats used in conjunction with bitmaps, which are 
rectangular arrays of bits that correspond to the pixels of an output device. Bitmaps and 
these bitmap clipboard formats are discussed in more detail in Chapters <a href="ch14a.htm#426">14</a> and <a href="ch15a.htm#473">15</a>:
<UL>
<p><li><I>CF_BITMAP</I> A device-dependent bitmap. The bitmap is transferred to 
the clipboard using the bitmap handle. Again, a program should not continue 
to use this bitmap after giving it to the clipboard.
<p><li><I>CF_DIB</I> A memory block defining a device-independent bitmap, as 


described in <a href="ch15a.htm#473">Chapter 15</a>. The memory block begins with a bitmap information 
structure followed by a possible color table and the bitmap bits.
<p><li><I>CF_PALETTE</I> A handle to a color palette. This is generally used in 
conjunction with CF_DIB for defining a color palette used by a 
device-dependent bitmap.
</UL>

<P>It is also possible to store bitmap data in the clipboard in the industry-standard 
TIFF format:
<UL>
<p><li> <I>CF_TIFF</I> A memory block containing data in the Tag Image File Format 
(TIFF). This is a format devised by Microsoft, Aldus Corporation, and 
Hewlett-Packard Company in conjunction with some hardware manufacturers. The format 
is available from the Hewlett-Packard Web site.
</UL>
<P>There are two metafile formats that I'll describe in more detail in <a href="ch18a.htm#659">Chapter 18</a>. A 
metafile is a collection of drawing commands stored in a binary form:
<UL>
<p><li> <I>CF_METAFILEPICT</I> A &quot;metafile picture&quot; based on the old metafile support 
of Windows.
<p><li> <I>CF_ENHMETAFILE</I> A handle to an enhanced metafile supported under the 

32-bit versions of Windows.
</UL>
<P>And finally there are also a few other miscellaneous clipboard formats:
<UL>
<p><li> <I>CF_PENDATA</I> Used in conjunction with the pen extensions to Windows.
<p><li> <I>CF_WAVE</I> A sound (waveform) file.
<p><li> <I>CF_RIFF</I> Multimedia data in the Resource Interchange File Format.
<p><li> <I>CF_HDROP</I> A list of files used in conjunction with drag-and-drop services.
</UL>

<A NAME="384"><h2>Memory Allocation</h2></A><P>When your program transfers something to the clipboard, it must allocate a memory 
block and essentially hand it over to the clipboard. When we've needed to allocate memory 
in earlier programs in this book, we've simply used the 
<I>malloc</I> function that is supported by the standard C run-time library. However, because the memory blocks stored by the 
clipboard must be shared among applications running under Windows, the 
<I>malloc</I> function is inadequate for this task.
<P>Instead, we must dredge up memory allocation functions that were designed 
back in the dark ages of Windows, in the days when the operating system ran in a 16-bit 
real-mode memory architecture. These functions are still supported and you can still use 
them, but they are not often needed.
<P>To allocate a memory block using the Windows API, you can call
<P>
<PRE>hGlobal = GlobalAlloc (uiFlags, dwSize) ;</PRE>
<P>The function takes two parameters: a possible series of flags and a size in bytes of 
the allocated block. The function returns a handle of type HGLOBAL, called a &quot;handle to 
a global memory block&quot; or a &quot;global handle.&quot; A NULL return value indicates that 
sufficient memory was not available for the allocation.
<P>Although the two parameters to 
<I>GlobalAlloc</I> are defined a bit differently, they are 
both 32-bit unsigned integers. If you set the first parameter to zero, you effectively use the 
flag GMEM_FIXED. In this case, the global handle that 
<I>GlobalAlloc</I> returns is actually a pointer to the allocated memory block.
<P>You can also use the flag GMEM_ZEROINIT if you'd like every byte in the 
memory block to be initially set to zero. The succinct GPTR flag combines the GMEM_FIXED 
and GMEM_ZEROINIT flags as defined in the Windows header files:
<P><PRE>     #define GPTR (GMEM_FIXED | GMEM_ZEROINIT)</pre>
<P>There is also a reallocation function:
<P><PRE>hGlobal = GlobalReAlloc (hGlobal, dwSize, uiFlags) ;</pre>
<P>You can use the GMEM_ZEROINIT flag to zero out the new bytes if the memory block 
is being enlarged.
<P>Here's the function to obtain the size of the memory block:
<P><pre>dwSize = GlobalSize (hGlobal) ;</pre>
<P>and the function to free it:
<P><pre>GlobalFree (hGlobal) ;</pre>
<P>In the early 16-bit versions of Windows, the GMEM_FIXED flag was strongly 
discouraged because Windows could not move the block in physical memory. In the 32-bit 
versions of Windows, the GMEM_FIXED flag is normal because it returns a virtual address and 
the operating system can move the block in physical memory by altering the page table. 
When programming for the 16-bit versions of Windows, using the flag GMEM_MOVEABLE 
in <I>GlobalAlloc</I> was instead recommended. (Note that most dictionaries prefer the 
spelling &quot;movable&quot; over &quot;moveable,&quot; so that's how I'll spell the word otherwise.) There's also 
a shorthand identifier identified in the Windows header files to additionally zero out 
the movable memory:
<P><pre>#define GHND (GMEM_MOVEABLE | GMEM_ZEROINIT)</pre>
<P>The GMEM_MOVEABLE flag allows Windows to move a memory block in virtual 
memory. This doesn't necessarily mean that the memory block will be moved in physical memory, 
but the address that the application uses to read and write to the block can change.
<P>Although GMEM_MOVEABLE was the rule in 16-bit versions of Windows, it is 
generally less useful now. However, if your application frequently allocates, reallocates, 
and frees memory blocks of various sizes, the virtual address space of your application 
can become fragmented. Conceivably, you could run out of virtual memory addresses. If 
this is a potential problem, then you'll want to use movable memory, and here's how to do it.
<P>First define a pointer (for example, to an 
<I>int</I> type) and a variable of type GLOBALHANDLE:
<P><pre>     int * p ;
     GLOBALHANDLE hGlobal ;</pre>
<P>Then allocate the memory. For example:
<P><pre>     hGlobal = GlobalAlloc (GHND, 1024) ;</pre>
<P>As with any Windows handle, don't worry too much about what the number 
really means. Just store it. When you need to access that memory block, call
<P><pre>     p = (int *) GlobalLock (hGlobal) ;</pre>
<P>This translates the handle into a pointer. During the time that the block is locked, 
Windows will fix the address in virtual memory. It will not move. When you are finished 
accessing the block, call
<P><pre>     GlobalUnlock (hGlobal) ;</pre>
<P>This gives Windows the freedom to move the block in virtual memory. To be really 
compulsively correct about this process (and to experience the torments of early Windows 
programmers), you should lock and unlock the memory block in the course of a single message.
<P>When you want to free the memory, call 
<I>GlobalFree</I> with the handle rather than the pointer. If you don't currently have access to the handle, use the function
<P><pre>     hGlobal = GlobalHandle (p) ;</pre>
<P>You can lock a memory block multiple times before unlocking it. Windows 
maintains a lock count, and each lock requires a corresponding unlock before the block is free 
to be moved. When Windows moves a block in virtual memory, it doesn't need to copy 
the bytes from one location to another&#8212;it needs only manipulate the page tables. In 
general, in the 32-bit versions of Windows the only real reason for allocating a movable block 
for your own program's use is to prevent fragmentation of virtual memory. When using 
the clipboard, you should also use movable memory.
<P>When allocating memory for the clipboard, you should use the 
<I>GlobalAlloc</I> function with both the GMEM_MOVEABLE and the GMEM_SHARE flags. The GMEM_SHARE 
flag makes the block available to other Windows applications.

<A NAME="385"><h2>Transferring Text to the Clipboard</h2></A>
<P>Let's assume that you want to transfer an ANSI character string to the clipboard. You 
have a pointer (called <I>pString</I>) to this string, and you want to transfer 
<I>iLength</I> characters that might or might not be NULL-terminated.
<P>You must first use <I>GlobalAlloc</I> to allocate a memory block of sufficient size to 
hold the character string. Include room for a terminating NULL:
<P><pre>hGlobal = GlobalAlloc (GHND | GMEM_SHARE, iLength + 1) ;</pre>
<P>The value of <I>hGlobal</I> will be NULL if the block could not be allocated. If the allocation 
is successful, lock the block to get a pointer to it:
<P><pre>pGlobal = GlobalLock (hGlobal) ;</pre>
<P>Copy the character string into the global memory block:
<P><pre>for (i = 0 ; i &lt; wLength ; i++)
     *pGlobal++ = *pString++ ;</pre>
<P>You don't need to add the terminating NULL because the GHND flag for 
<I>GlobalAlloc</I> zeroes out the entire memory block during allocation. Unlock the block:
<P><pre>GlobalUnlock (hGlobal) ;</pre>
<P>Now you have a global memory handle that references a memory block 
containing the NULL-terminated text. To get this into the clipboard, open the clipboard and empty it:
<P><pre>OpenClipboard (hwnd) ;
EmptyClipboard () ;</pre>
<P>Give the clipboard the memory handle by using the CF_TEXT identifier, and close 
the clipboard:
<P><pre>SetClipboardData (CF_TEXT, hGlobal) ;
CloseClipboard () ;</pre>
<P>You're done.
<P>Here are some rules concerning this process:
<UL>
<p> <li>Call <I>OpenClipboard</I> and 
<I>CloseClipboard</I> while processing a single 
message. Don't leave the clipboard open any longer than necessary.
<p> <li>Don't give the clipboard a locked memory handle.
<p> <li>After you call <I>SetClipboardData</I>, don't continue to use the memory block. It 
no longer belongs to your program, and you should treat the handle as invalid. 
If you need to continue to access the data, make another copy of it or read it 
from the clipboard (as described in the next section). You can also continue to 
reference the block between the 
<I>SetClipboardData</I> call and the 
<I>CloseClipboard</I> call, but don't use the global handle you passed to the 
<I>SetClipboardData</I> function. This function also 
<I>returns</I> a global handle that you can use instead. Lock 
this handle to access the memory. Unlock the handle before you call 
<I>CloseClipboard</I>.
</UL>

<A NAME="386"><h2>Getting Text from the Clipboard</h2></A>
<P>Getting text from the clipboard is only a little more complex than transferring text to the 
clipboard. You must first determine whether the clipboard does in fact contain data in the 
CF_TEXT format. One of the easiest methods is to use the call
<P><pre>bAvailable = IsClipboardFormatAvailable (CF_TEXT) ;</pre>
<P>This function returns TRUE (nonzero) if the clipboard contains CF_TEXT data. We 
used this function in the POPPAD2 program in <a href="ch10a.htm#279">Chapter 10</a> to determine whether the Paste 
item on the Edit menu should be enabled or grayed. 
<I>IsClipboardFormatAvailable</I> is one of the few clipboard functions that you can use without first opening the clipboard. However, 
if you later open the clipboard to get this text, you should also check again (using the 
same function or one of the other methods) to determine whether the CF_TEXT data is still 
in the clipboard.

<P>To transfer the text out, first open the clipboard:
<P><pre>OpenClipboard (hwnd) ;</pre>
<P>Obtain the handle to the global memory block referencing the text:
<P><pre>hGlobal = GetClipboardData (CF_TEXT) ;</pre>
<P>This handle will be NULL if the clipboard doesn't contain data in the CF_TEXT format. 
This is another way to determine whether the clipboard contains text. If 
<I>GetClipboardData</I> returns NULL, close the clipboard without doing anything else.
<P>The handle you receive from 
<I>GetClipboardData</I> doesn't belong to your 
program&#8212;it belongs to the clipboard. The handle is valid only between the 
<I>GetClipboardData</I> and <I>CloseClipboard</I> calls. You can't free that handle or alter the data it references. If you 
need to have continued access to the data, you should make a copy of the memory block.
<P>Here's one method for copying the data into your program. Just allocate a 
pointer to a block of the same size as the clipboard data block:
<P><pre>pText = (char *) malloc (GlobalSize (hGlobal)) ;</pre>
<P>Recall that <I>hGlobal</I> was the global handle obtained from the 
<I>GetClipboardData</I> call. Now lock the handle to get a pointer to the clipboard block:
<P><pre>pGlobal = GlobalLock (hGlobal) ;</pre>
<P>Now just copy the data:
<P><pre>strcpy (pText, pGlobal) ;</pre>
<P>Or you can use some simple C code:
<P><pre>while (*pText++ = *pGlobal++) ;</pre>
<P>Unlock the block before closing the clipboard:
<P><pre>GlobalUnlock (hGlobal) ;
CloseClipboard () ;</pre>
<P>Now you have a pointer called <I>pText</I> that references the program's own copy of the text.

<A NAME="387"><h2>Opening and Closing the Clipboard</h2></A>
<P>Only one program can have the clipboard open at any time. The purpose of the 
<I>OpenClipboard</I> call is to prevent the clipboard contents from changing while a program is 
using the clipboard. <I>OpenClipboard</I> returns a BOOL value indicating whether the clipboard 
was successfully opened. It will not be opened if another application failed to close it. If 
every program politely opens and then closes the clipboard as quickly as possible 
responding to a user command, you'll probably never run into the problem of being unable to 
open the clipboard.
<P>In the world of impolite programs and preemptive multitasking, some problems 
could arise. Even if your program hasn't lost input focus between the time it put something 
into the clipboard and the time the user invokes a Paste option, don't assume that what 
you've put in there is still there. A background process 
<I>could</I> have accessed the clipboard during that time.
<P>Watch out for a more subtle problem involving message boxes: If you can't 
allocate enough memory to copy something to the clipboard, then you might want to display 
a message box. If this message box isn't system modal, however, the user can switch 
to another application while the message box is displayed. You should either make 
the message box system modal or close the clipboard before you display the message box.
<P>You can also run into problems if you leave the clipboard open while you display 
a dialog box. Edit fields in a dialog box use the clipboard for cutting and pasting text.

<A NAME="388"><h2>The Clipboard and Unicode</h2></A>
<P>So far I've been discussing using the clipboard solely with ANSI (one byte per 
character) text. This is the format when you use the CF_TEXT identifier. You may be wondering 
about CF_OEMTEXT and CF_UNICODETEXT.
<P>I have some good news: you only need to call 
<I>SetClipboardData</I> and 
<I>GetClipboardData</I> with your preferred text format and Windows will handle all text 
conversions in the clipboard. For example, under Windows NT if a program uses 
<I>SetClipboardData</I> with a CF_TEXT clipboard data type, programs can also call 
<I>GetClipboardData</I> using CF_OEMTEXT. Similarly, the clipboard can convert CF_OEMTEXT data to CF_TEXT.
<P>Under Windows NT, conversions occur between CF_UNICODETEXT, CF_TEXT, 
and CF_OEMTEXT. A program should call 
<I>SetClipboardData</I> using whatever text format is 
most convenient for the program. Similarly, a program should call 
<I>GetClipboardData</I> using whatever text form is desired by the program. As you know, the programs shown in 
this book are written so that they can be compiled with and without the UNICODE 
identifier. If your programs are like that, you'll probably implement code that calls 
<I>SetClipboardData</I> and 
<I>GetClipboardData</I> using CF_UNICODETEXT if the UNICODE identifier is defined 
and CF_TEXT if it is not.
<P>The CLIPTEXT program shown in Figure 12-1 demonstrates one way this can be done.
<P><B>Figure 12-1.</b> <i>The CLIPTEXT program.</I>

<P><TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="389"><H3>CLIPTEXT.C</H3></A><pre>
/*-----------------------------------------
   CLIPTEXT.C -- The Clipboard and Text
                 (c) Charles Petzold, 1998
  -----------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;resource.h&quot;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

#ifdef UNICODE

#define CF_TCHAR CF_UNICODETEXT
TCHAR szDefaultText[] = TEXT (&quot;Default Text - Unicode Version&quot;) ;
TCHAR szCaption[]     = TEXT (&quot;Clipboard Text Transfers - Unicode Version&quot;) ;

#else

#define CF_TCHAR CF_TEXT
TCHAR szDefaultText[] = TEXT (&quot;Default Text - ANSI Version&quot;) ;
TCHAR szCaption[]     = TEXT (&quot;Clipboard Text Transfers - ANSI Version&quot;) ;

#endif

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;ClipText&quot;) ;
     HACCEL       hAccel ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = szAppName ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, szCaption,
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;

     hAccel = LoadAccelerators (hInstance, szAppName) ;

     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          if (!TranslateAccelerator (hwnd, hAccel, &amp;msg))
          {
               TranslateMessage (&amp;msg) ;
               DispatchMessage (&amp;msg) ;
          }
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static PTSTR pText ;
     BOOL         bEnable ;
     HGLOBAL      hGlobal ;
     HDC          hdc ;
     PTSTR        pGlobal ;
     PAINTSTRUCT  ps ;
     RECT         rect ;
     
     switch (message)
     {
     case WM_CREATE:
          SendMessage (hwnd, WM_COMMAND, IDM_EDIT_RESET, 0) ;
          return 0 ;

    case WM_INITMENUPOPUP:
          EnableMenuItem ((HMENU) wParam, IDM_EDIT_PASTE,
               IsClipboardFormatAvailable (CF_TCHAR) ? MF_ENABLED : MF_GRAYED) ;

          bEnable = pText ? MF_ENABLED : MF_GRAYED ;

          EnableMenuItem ((HMENU) wParam, IDM_EDIT_CUT,   bEnable) ;
          EnableMenuItem ((HMENU) wParam, IDM_EDIT_COPY,  bEnable) ;
          EnableMenuItem ((HMENU) wParam, IDM_EDIT_CLEAR, bEnable) ;
          break ;
          
     case WM_COMMAND:
          switch (LOWORD (wParam))
          {
          case IDM_EDIT_PASTE:
               OpenClipboard (hwnd) ;

               if (hGlobal = GetClipboardData (CF_TCHAR))
               {
                    pGlobal = GlobalLock (hGlobal) ;
                    if (pText)
                    {
                         free (pText) ;
                         pText = NULL ;
                    }
                    pText = malloc (GlobalSize (hGlobal)) ;
                    lstrcpy (pText, pGlobal) ;
                    InvalidateRect (hwnd, NULL, TRUE) ;
               }
               CloseClipboard () ;
               return 0 ;

          case IDM_EDIT_CUT:
          case IDM_EDIT_COPY:
               if (!pText)
                    return 0 ;

               hGlobal = GlobalAlloc (GHND | GMEM_SHARE, 
                                      (lstrlen (pText) + 1) * sizeof (TCHAR)) ;
               pGlobal = GlobalLock (hGlobal) ;
               lstrcpy (pGlobal, pText) ;
               GlobalUnlock (hGlobal) ;

               OpenClipboard (hwnd) ;
               EmptyClipboard () ;
               SetClipboardData (CF_TCHAR, hGlobal) ;
               CloseClipboard () ;

               if (LOWORD (wParam) == IDM_EDIT_COPY)
                    return 0 ;        
                                             // fall through for IDM_EDIT_CUT
          case IDM_EDIT_CLEAR:
               if (pText)
               {
                    free (pText) ;
                    pText = NULL ;
               }
               InvalidateRect (hwnd, NULL, TRUE) ;
               return 0 ;

          case IDM_EDIT_RESET:
               if (pText)
               {
                    free (pText) ;
                    pText = NULL ;
               }
               pText = malloc ((lstrlen (szDefaultText) + 1) * sizeof (TCHAR)) ;
               lstrcpy (pText, szDefaultText) ;
               InvalidateRect (hwnd, NULL, TRUE) ;
               return 0 ;
          }
          break ;

     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;

          GetClientRect (hwnd, &amp;rect) ;
          
          if (pText != NULL)
               DrawText (hdc, pText, -1, &amp;rect, DT_EXPANDTABS | DT_WORDBREAK) ;

          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_DESTROY:
          if (pText)
               free (pText) ;

          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</PRE>
</TD></TR></TABLE>

<P><TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="390"><H3>CLIPTEXT.RC (excerpts)</h3></A><PRE>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;

/////////////////////////////////////////////////////////////////////////////
// Menu

CLIPTEXT MENU DISCARDABLE 
BEGIN
    POPUP &quot;&amp;Edit&quot;
    BEGIN
        MENUITEM &quot;Cu&amp;t\tCtrl+X&quot;,                IDM_EDIT_CUT
        MENUITEM &quot;&amp;Copy\tCtrl+C&quot;,               IDM_EDIT_COPY
        MENUITEM &quot;&amp;Paste\tCtrl+V&quot;,              IDM_EDIT_PASTE
        MENUITEM &quot;De&amp;lete\tDel&quot;,                IDM_EDIT_CLEAR
        MENUITEM SEPARATOR
        MENUITEM &quot;&amp;Reset&quot;,                      IDM_EDIT_RESET
    END
END

/////////////////////////////////////////////////////////////////////////////
// Accelerator

CLIPTEXT ACCELERATORS DISCARDABLE 
BEGIN
    &quot;C&quot;,            IDM_EDIT_COPY,          VIRTKEY, CONTROL, NOINVERT
    &quot;V&quot;,            IDM_EDIT_PASTE,         VIRTKEY, CONTROL, NOINVERT
    VK_DELETE,      IDM_EDIT_CLEAR,         VIRTKEY, NOINVERT
    &quot;X&quot;,            IDM_EDIT_CUT,           VIRTKEY, CONTROL, NOINVERT
END</PRE>
</TD></TR></TABLE>

<P><TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="391"><H3>RESOURCE.H (excerpts)</H3></A><PRE>
// Microsoft Developer Studio generated include file.
// Used by ClipText.rc

#define IDM_EDIT_CUT                    40001
#define IDM_EDIT_COPY                   40002
#define IDM_EDIT_PASTE                  40003
#define IDM_EDIT_CLEAR                  40004
#define IDM_EDIT_RESET                  40005
</PRE>
</TD></TR></TABLE>

<P>The idea here is that you can run both the Unicode and ANSI versions of this 
program under Windows NT and see how the clipboard translates between the two 
character sets. Notice the <I>#ifdef</I> statement at the top of CLIPTEXT.C. If the UNICODE 
identifier is defined, then CF_TCHAR (a generic text clipboard format name I made up) is equal 
to CF_UNICODETEXT; if not, it's equal to CF_TEXT. The 
<I>IsClipboardFormatAvailable</I>, 
<I>GetClipboardData</I>, and 
<I>SetClipboardData</I> function calls later in the program all use 
this CF_TCHAR name to specify the data type.
<P>At the outset of the program (and whenever you select the Reset option from the 
Edit menu), the static variable <I>pText</I> contains a pointer to the Unicode string &quot;Default Text - Unicode version&quot; in the Unicode version of the program and &quot;Default Text - ANSI 
version&quot; in the non-Unicode version. You can use the Cut or Copy command to transfer this 
text string to the clipboard, and you can use the Cut or Delete command to delete the 
string from the program. The Paste command copies any text contents of the clipboard to 
<I>pText</I>. The <I>pText</I> string is displayed on the program's client area during the WM_PAINT message.
<P>If you first select the Copy command from the Unicode version of CLIPTEXT and 
then the Paste command from the non-Unicode version, you can see that the text has 
been converted from Unicode to ANSI. Similarly, if you do the opposite commands, the text 
is converted from ANSI to Unicode.

</BODY>
</HTML>






