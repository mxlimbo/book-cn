<HTML>
<HEAD>
<TITLE>MM_ANISOTROPIC: Stretching the Image to Fit</TITLE>
<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A NAME="133"><h1>MM_ANISOTROPIC: Stretching the Image to Fit</h1></A>
<p>When you set the viewport and window extents in the MM_ISOTROPIC mapping mode, Windows adjusts the values so that logical units on the two axes have the same physical dimensions. In the MM_ANISOTROPIC mapping mode, Windows makes no adjustments to the values you set. This means that MM_ANISOTROPIC does not necessarily maintain the correct aspect ratio.

<p>One way you can use MM_ANISOTROPIC is to have arbitrary coordinates for the client area, as we did with MM_ISOTROPIC. This code sets the point (0, 0) at the lower left corner of the client area with the <I>x</I> and <I>y</I> axes ranging from 0 to 32,767:

<p><pre>
SetMapMode (hdc, MM_ANISOTROPIC) ;
SetWindowExtEx (hdc, 32767, 32767, NULL) ;
SetViewportExtEx (hdc, cxClient, -cyClient, NULL) ;
SetViewportOrgEx (hdc, 0, cyClient, NULL) ;
</pre>

<p>With MM_ISOTROPIC, similar code caused part of the client area to be beyond the range of the axes. With MM_ANISOTROPIC, the upper right corner of the client area is always the point (32767, 32767), regardless of its dimensions. If the client area is not square, logical <I>x</I> and <I>y</I> units will have different physical dimensions.

<p>In the previous section on the MM_ISOTROPIC mapping mode, I discussed how you might draw a round clock in the client area where the <I>x</I> and <I>y</I> axes ranged from -1000 to 1000. You can do something similar with MM_ANISOTROPIC:

<p><pre>
SetMapMode (hdc, MM_ANISOTROPIC) ;
SetWindowExtEx (hdc, 1000, 1000, NULL) ;
SetViewportExtEx (hdc, cxClient / 2, -cyClient / 2, NULL) ;
SetViewportOrgEx (hdc, cxClient / 2, cyClient / 2, NULL) ;
</pre>

<p>The difference with MM_ANISOTROPIC is that in general the clock would be drawn as an ellipse rather than a circle.

<p>Another way to use MM_ANISOTROPIC is to set <I>x</I> and <I>y</I> units to fixed but unequal values. For instance, if you have a program that displays only text, you may want to set coarse coordinates based on the height and width of a single character:

<p><pre>
SetMapMode (hdc, MM_ANISOTROPIC) ;
SetWindowExtEx (hdc, 1, 1, NULL) ;
SetViewportExtEx (hdc, cxChar, cyChar, NULL) ;
</pre>

<p>Of course, I've assumed that <I>cxChar</I> and <I>cyChar</I> are the width and height of characters in that font. Now you can specify coordinates in terms of character rows and columns. For instance, the following statement displays text three characters from the left and two character rows from the top of the client area:

<p><pre>
TextOut (hdc, 3, 2, TEXT (&quot;Hello&quot;), 5) ;
</pre>

<p>This might be more appropriate if you're using a fixed-point font, as in the upcoming WHATSIZE program.

<p>When you first set the MM_ANISOTROPIC mapping mode, it always inherits the extents of the previously set mapping mode. This can be very convenient. One way of thinking about MM_ANISTROPIC is that it &quot;unlocks&quot; the extents; that is, it allows you to change the extents of an otherwise fully-constrained mapping mode. For instance, suppose you want to use the MM_LOENGLISH mapping mode because you want logical units to be 0.01 inch. But you don't want the values along the <I>y</I>-axis to increase as you move up the screen&#8212;you prefer the MM_TEXT orientation, where <I>y</I> values increase moving down. Here's the code:

<p><pre>
SIZE size ;
<I>[other program lines]</I>
SetMapMode (hdc, MM_LOENGLISH) ;
SetMapMode (hdc, MM_ANISOTROPIC) ;
GetViewportExtEx (hdc, &amp;size) ;
SetViewportExtEx (hdc, size.cx, -size.cy, NULL) ;
</pre>

<p>We first set the mapping mode to MM_LOENGLISH. Then we liberate the extents by setting the mapping mode to MM_ANISOTROPIC. The <I>GetViewportExtEx</I> function obtains the viewport extents in a SIZE structure. Then we call <I>SetViewportExtEx</I> with the extents, except that the <I>y</I> extent is made negative.


<A NAME="134"><h2>The WHATSIZE Program</h2></A>
<p>A little Windows history: The first how-to-program-for-Windows article appeared in the December 1986 issue of <I>Microsoft Systems Journal</I>. The sample program in that article was called WSZ (&quot;what size&quot;), and it displayed the size of a client area in pixels, inches, and millimeters. A simplified version of that program is WHATSIZE, shown in Figure 5-24. The program shows the dimensions of the window's client area in terms of the five metric mapping modes.



<A NAME="135"><p><table width="95%" cellpadding="5" valign="TOP"><tr><td valign=top><h3>WHATSIZE.C</h3></A>
<p><pre>
/*-----------------------------------------
   WHATSIZE.C -- What Size is the Window?
                 (c) Charles Petzold, 1998
  -----------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;WhatSize&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;

     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;What Size is the Window?&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}
void Show (HWND hwnd, HDC hdc, int xText, int yText, int iMapMode,
           TCHAR * szMapMode)
{
     TCHAR szBuffer [60] ;
     RECT  rect ;
     
     SaveDC (hdc) ;
     
     SetMapMode (hdc, iMapMode) ;
     GetClientRect (hwnd, &amp;rect) ;
     DPtoLP (hdc, (PPOINT) &amp;rect, 2) ;
     
     RestoreDC (hdc, -1) ;
     
     TextOut (hdc, xText, yText, szBuffer,
              wsprintf (szBuffer, TEXT (&quot;%-20s %7d %7d %7d %7d&quot;), szMapMode,
              rect.left, rect.right, rect.top, rect.bottom)) ;
}  

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static TCHAR szHeading [] =
          TEXT (&quot;Mapping Mode            Left   Right     Top  Bottom&quot;) ;
     static TCHAR szUndLine [] = 
          TEXT (&quot;------------            ----   -----     ---  ------&quot;) ;
     static int   cxChar, cyChar ;
     HDC          hdc ;
     PAINTSTRUCT  ps ;
     TEXTMETRIC   tm ;
     
     switch (message)
     {
     case WM_CREATE:
          hdc = GetDC (hwnd) ;
          SelectObject (hdc, GetStockObject (SYSTEM_FIXED_FONT)) ;
          
          GetTextMetrics (hdc, &amp;tm) ;
          cxChar = tm.tmAveCharWidth ;
          cyChar = tm.tmHeight + tm.tmExternalLeading ;
          
          ReleaseDC (hwnd, hdc) ;
          return 0 ;
          
     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
          SelectObject (hdc, GetStockObject (SYSTEM_FIXED_FONT)) ;

          SetMapMode (hdc, MM_ANISOTROPIC) ;
          SetWindowExtEx (hdc, 1, 1, NULL) ;
          SetViewportExtEx (hdc, cxChar, cyChar, NULL) ;
          
          TextOut (hdc, 1, 1, szHeading, lstrlen (szHeading)) ;
          TextOut (hdc, 1, 2, szUndLine, lstrlen (szUndLine)) ;
          
          Show (hwnd, hdc, 1, 3, MM_TEXT,      TEXT (&quot;TEXT (pixels)&quot;)) ;
          Show (hwnd, hdc, 1, 4, MM_LOMETRIC,  TEXT (&quot;LOMETRIC (.1 mm)&quot;)) ;
          Show (hwnd, hdc, 1, 5, MM_HIMETRIC,  TEXT (&quot;HIMETRIC (.01 mm)&quot;)) ;
          Show (hwnd, hdc, 1, 6, MM_LOENGLISH, TEXT (&quot;LOENGLISH (.01 in)&quot;)) ;
          Show (hwnd, hdc, 1, 7, MM_HIENGLISH, TEXT (&quot;HIENGLISH (.001 in)&quot;)) ;
          Show (hwnd, hdc, 1, 8, MM_TWIPS,     TEXT (&quot;TWIPS (1/1440 in)&quot;)) ;
          
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</PRE></td></tr>
</table>
<p><B>Figure 5-24.</B> <I>The WHATSIZE program.</I>
<p>For ease in displaying the information using the <I>TextOut</I> function, WHATSIZE uses a fixed-pitch font. Switching to a fixed-pitch font (which was the default prior to Windows 3.0) involves this simple statement:

<p><pre>
SelectObject (hdc, GetStockObject (SYSTEM_FIXED_FONT)) ;
</pre>

<p>These are the same two functions used for selecting stock pens and brushes. WHATSIZE also uses the MM_ANISTROPIC mapping mode with logical units set to character dimensions, as shown earlier.

<p>When WHATSIZE needs to obtain the size of the client area for one of the six mapping modes, it saves the current device context, sets a new mapping mode, obtains the client-area coordinates, converts them to logical coordinates, and then restores the original mapping mode before displaying the information. This code is in WHATSIZE's <I>Show</I> function:

<p><pre>
SaveDC (hdc) ;
SetMapMode (hdc, iMapMode) ;
GetClientRect (hwnd, &amp;rect) ;
DptoLP (hdc, (PPOINT) &amp;rect, 2) ;
RestoreDC (hdc, -1) ;
</pre>

<p>Figure 5-25 shows a typical display from WHATSIZE.

<p><A HREF="javascript:fullSize('F05zg25x.htm')"> <img src="F05zg25.JPG" width=404 height=303 border=0 ALT = "Click to view at full size."> </A>

<p><!-- caption --><B>Figure 5-25.</B> <I>A typical WHATSIZE display.</I><!-- /caption -->

</BODY>
</HTML>






