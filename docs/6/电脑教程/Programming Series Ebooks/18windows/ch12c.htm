<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Beyond Simple Clipboard Use</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="392"><h1>Beyond Simple Clipboard Use</h1></A>
We've seen that transferring text from the clipboard requires four calls after the data 
has been prepared:
<P>
<PRE>OpenClipboard (hwnd) ;
EmptyClipboard () ;
SetClipboardData (iFormat, hGlobal) ;
CloseClipboard () ;</PRE>
<P>Getting access to this data requires three calls:
<P>
<PRE>OpenClipboard (hwnd) ;
hGlobal = GetClipboardData (iFormat) ;
<I>[other program lines]</I>
CloseClipboard () ;</pre>
<P>You can make a copy of the clipboard data or use it in some other manner 
between the <I>GetClipboardData</I> and 
<I>CloseClipboard</I> calls. That approach may be all you'll need 
for most purposes, but you can also use the clipboard in more sophisticated ways.

<A NAME="393"><h2>Using Multiple Data Items</h2></A>
When you open the clipboard to put data into it, you must call 
<I>EmptyClipboard</I> to signal Windows to free or delete the contents of the clipboard. You can't add something to 
the existing contents of the clipboard. So, in this sense, the clipboard holds only one item 
at a time.
<P>However, between the <I>EmptyClipboard</I> and the 
<I>CloseClipboard</I> calls, you can call 
<I>SetClipboardData</I> several times, each time using a different clipboard format. For 
instance, if you want to store a short string of text in the clipboard, you can write that text to a 
metafile and to a bitmap. In this way, you make that character string available not only to 
programs that can read text from the clipboard but also to programs that read bitmaps and 
metafiles from the clipboard. Of course, these programs won't be able to easily recognize that 
the metafile or bitmap actually contains a character string.
<P>If you want to write several handles to the clipboard, you call 
<I>SetClipboardData</I> for each of them:
<P><PRE>OpenClipboard (hwnd) ;
EmptyClipboard () ;
SetClipboardData (CF_TEXT, hGlobalText) ;
SetClipboardData (CF_BITMAP, hBitmap) ;
SetClipboardData (CF_METAFILEPICT, hGlobalMFP) ;
CloseClipboard () ;</pre>
<P>While these three formats of data are in the clipboard, an 
<I>IsClipboardFormatAvailable</I> call with the CF_TEXT, CF_BITMAP, or CF_METAFILEPICT argument will return TRUE. A 
program can get access to these handles by calling
<P><PRE>hGlobalText = GetClipboardData (CF_TEXT) ;</pre>
<P>or
<P><PRE>hBitmap = GetClipboardData (CF_BITMAP) ;</pre>
<P>or
<P><PRE>hGlobalMFP = GetClipboardData (CF_METAFILEPICT) ;</pre>
<P>The next time a program calls 
<I>EmptyClipboard</I>, Windows will free or delete all 
three of the handles retained by the clipboard.
<P>Don't use this technique to add different text formats, different bitmap formats, 
or different metafile formats to the clipboard. Use only one text format, one bitmap 
format, and one metafile format. As I mentioned, Windows will convert among 
CF_TEXT, CF_
OEMTEXT, and CF_UNICODETEXT. It will also convert between CF_BITMAP and 
CF_DIB, and between CF_METAFILEPICT and CF_ENHMETAFILE.
<P>A program can determine all the formats stored by the clipboard by first opening 
the clipboard and then calling 
<I>EnumClipboardFormats</I>. Start off by setting a variable 
<I>iFormat</I> to 0:
<PRE><P>iFormat = 0 ;
OpenClipboard (hwnd) ;</pre>
<P>Now make successive <I>EnumClipboardFormats</I> calls starting with the 0 value. The 
function will return a positive <I>iFormat</I> value for each format currently in the clipboard. 
When the function returns 0, you're done:
<P><PRE>while (iFormat = EnumClipboardFormats (iFormat))
{
<I>     [logic for each iFormat value]</I>
}
CloseClipboard () ;</pre>
<P>You can obtain the number of different formats currently in the clipboard by calling
<P><PRE>iCount = CountClipboardFormats () ;</pre>

<A NAME="394"><h2>Delayed Rendering</h2></A>
When you put data into the clipboard, you generally make a copy of the data and 
give the clipboard a handle to a global memory block that contains the copy. For very 
large data items, this approach can waste memory. If the user never pastes that data into 
another program, it will continue to occupy memory space until it is replaced by something else.
<P>You can avoid this problem by using a technique called &quot;delayed rendering,&quot; in 
which your program doesn't actually supply the data until another program needs it. Rather 
than give Windows a handle to the data, you simply use a NULL in the 
<I>SetClipboardData</I> call:
<P><PRE>OpenClipboard (hwnd) ;
EmptyClipboard () ;
SetClipboardData (iFormat, NULL) ;
CloseClipboard () ;</pre>
<P>You can have multiple <I>SetClipboardData</I> calls using different values of 
<I>iFormat</I>. You can use NULL parameters with some of them and real handles with others.
<P>That's simple enough, but now the process gets a little more complex. When 
another program calls <I>GetClipboardData</I>, Windows will check to see if the handle for that 
format is NULL. If it is, Windows will send a message to the &quot;clipboard owner&quot; (your 
program) asking for a real handle to the data. Your program must then supply this handle.
<P>More specifically, the &quot;clipboard owner&quot; is the last window that put data into the 
clipboard. When a program calls 
<I>OpenClipboard</I>, Windows stores the window handle 
required by this function. This handle identifies the window that has the clipboard open. On 
receipt of an <I>EmptyClipboard</I> call, Windows establishes this window as the new clipboard owner.
<P>A program that uses delayed rendering must process three messages in its 
window procedure: WM_RENDERFORMAT, WM_RENDERALLFORMATS, and 
WM_DESTROYCLIPBOARD. Windows sends your window procedure a WM_RENDERFORMAT 
message when another program calls 
<I>GetClipboardData</I>. The value of 
<I>wParam</I> is the format requested. When you process the WM_RENDERFORMAT message, don't open and empty the 
clipboard. Simply create a global memory block for the format given by 
<I>wParam</I>, transfer the data to it, and call 
<I>SetClipboardData</I> with the correct format and the global handle. 
Obviously, you'll need to retain information in your program to construct this data properly 
when processing WM_RENDERFORMAT. When another program calls 
<I>EmptyClipboard</I>, Windows sends your program a WM_DESTROYCLIPBOARD message. This tells you that the 
information to construct the clipboard data is no longer needed. You are no longer the 
clipboard owner.
<P>If your program terminates while it is still the clipboard owner, and the clipboard 
still contains NULL data handles that your program set with 
<I>SetClipboardData</I>, you'll receive a WM_RENDERALLFORMATS message. You should open the clipboard, empty it, put 
the data in global memory blocks, and call 
<I>SetClipboardData</I> for each format. Then close 
the clipboard. The WM_RENDERALLFORMATS message is one of the last messages 
your window procedure receives. It is followed by a WM_DESTROYCLIPBOARD 
message&#8212;because you've rendered all the data&#8212;and then the normal WM_DESTROY.
<P>If your program can transfer only one format of data to the clipboard (text, for 
instance), you can combine the WM_RENDERALLFORMATS and WM_RENDERFORMAT 
processing. The code will look something like this:
<P><PRE>case WM_RENDERALLFORMATS :
     OpenClipboard (hwnd) ;
     EmptyClipboard () ;
                              // fall through
case WM_RENDERFORMAT :
<I>     [put text into global memory block]</I>
     SetClipboardData (CF_TEXT, hGlobal) ;

     if (message == WM_RENDERALLFORMATS)
          CloseClipboard () ;
     return 0 ;</pre>
<P>If your program uses several clipboard formats, you'll want to process the 
WM_ RENDERFORMAT message only for the format requested by 
<I>wParam</I>. You don't need to process the WM_DESTROYCLIPBOARD message unless it is burdensome for your 
program to retain the information necessary to construct the data.

<A NAME="395"><h2>Private Data Formats</h2></A>
So far we've dealt with only the standard clipboard formats defined by Windows. 
However, you may want to use the clipboard to store a &quot;private data format.&quot; Many word 
processors use this technique to store text that contains font and formatting information.
<P>At first, this concept may seem nonsensical. If the purpose of the clipboard is to 
transfer data between applications, why should the clipboard contain data that only one 
application understands? The answer is simple: The clipboard also exists to allow the 
transfer of data to and from itself (or perhaps between different instances of the same 
program), and these instances obviously understand the same private formats.
<P>There are several ways to use private data formats. The easiest involves data that 
is ostensibly in one of the standard clipboard formats (that is, text, bitmap, or metafile) 
but that has meaning only to your program. In this case, you use one of the following 
<I>wFormat</I> values in your 
<I>SetClipboardData</I> and 
<I>GetClipboardData</I> calls: CF_DSPTEXT, 
CF_DSPBITMAP, CF_DSPMETAFILEPICT, or CF_DSPENHMETAFILE. (The letters DSP stand for 
&quot;display.&quot;) These formats allow the Windows clipboard viewer to display the data as text, a 
bitmap, or a metafile. However, another program that calls 
<I>GetClipboardData</I> using the normal CF_TEXT, CF_BITMAP, CF_DIB, CF_METAFILEPICT, or CF_ENHMETAFILE format won't 
obtain this data.
<P>If you use one of these formats to put data in the clipboard, you must also use 
the same format to get the data out. But how do you know if the data is from another 
instance of your program or from another program using one of these formats? Here's one way: 
You can first obtain the clipboard owner by calling
<P><PRE>hwndClipOwner = GetClipboardOwner () ;</pre>
<P>You can then get the name of the window class of this window handle:
<P><PRE>TCHAR szClassName [32] ;
<I>[other program lines]</I>
GetClassName (hwndClipOwner, szClassName, 32) ;</pre>
<P>If the class name is the same as your program's, then the data was put in the clipboard 
by another instance of your program.
<P>The second way to use private formats involves the CF_OWNERDISPLAY flag. 
The global memory handle to 
<I>SetClipboardData</I> is NULL:
<P><PRE>SetClipboardData (CF_OWNERDISPLAY, NULL) ;</pre>
<P>This is the method that some word processors use to show formatted text in the client 
area of the clipboard viewer included with Windows. Obviously, the clipboard viewer 
doesn't know how to display this formatted text. When a word processor specifies 
the CF_OWNERDISPLAY format, it is also taking responsibility for painting the clipboard viewer's client area.
<P>Because the global memory handle is NULL, a program that calls 
<I>SetClipboardData</I> with the CF_OWNERDISPLAY format (the clipboard owner) must process the delayed 
rendering messages sent to the clipboard owner by Windows, as well as five additional 
messages. The following five messages are sent by the clipboard viewer to the clipboard owner:
<UL>
<p><li> <I>WM_ASKCBFORMATNAME</I> The clipboard viewer sends this message to 
the clipboard owner to get a name for the format of the data. The 
<I>lParam</I> parameter is a pointer to a buffer, and 
<I>wParam</I> is the maximum number of characters for this buffer. The clipboard owner must copy the name of the clipboard 
format into this buffer.
<p><li> <I>WM_SIZECLIPBOARD</I> This message tells the clipboard owner that the 
size of the clipboard viewer's client area has changed. The 
<I>wParam</I> parameter is a handle to the clipboard viewer, and 
<I>lParam</I> is a pointer to a RECT structure containing the new size. If the RECT structure contains all zeros, 
the clipboard viewer is being destroyed or minimized. And, although the 
Windows clipboard viewer allows only one instance of itself to be running, other 
clipboard viewers can also send this message to the clipboard owner. 
Handling these multiple clipboard viewers isn't impossible for the clipboard 
owner (given that <I>wParam</I> identifies the particular viewer), but it isn't easy, either.
<p><li> <I>WM_PAINTCLIPBOARD</I> This message tells the clipboard owner to update 
the clipboard viewer's client area. Again, 
<I>wParam</I> is a handle to the clipboard viewer's window. The 
<I>lParam</I> parameter is a global handle to a 
PAINTSTRUCT structure. The clipboard owner can lock the handle and obtain a handle to 
the clipboard viewer's device context from the 
<I>hdc</I> field of this structure.
<p><li> <I>WM_HSCROLLCLIPBOARD</I> and 
<I>WM_VSCROLLCLIPBOARD</I>These messages inform the clipboard owner that a user has scrolled the clipboard viewer's 
scroll bars. The <I>wParam</I> parameter is a handle to the clipboard viewer's window, 
the low word of <I>lParam</I> is the scrolling request, and the high word of 
<I>lParam</I> is the thumb position if the low word is SB_THUMBPOSITION.
</UL>
<P>Handling these messages may look like more trouble than it's worth. However, 
the process does provide a benefit to the user: when copying text from a word processsor 
to the clipboard, the user will find it comforting to see the text still formatted in the 
clipboard viewer's client area.
<P>The third way to use private clipboard data formats is to register your own 
clipboard format name. You supply a name for this format to Windows, and Windows gives 
your program a number to use as the format parameter in 
<I>SetClipboardData</I> and 
<I>GetClipboardData</I>. Programs that use this method generally also copy data to the clipboard in one of the 
standard formats. This approach allows the clipboard viewer to display data in its client 
area (without the hassles involved with CF_OWNERDISPLAY) and permits other programs 
to copy data from the clipboard.
<P>As an example, let's assume we've written a vector-drawing program that copies 
data to the clipboard in a bitmap format, a metafile format, and its own registered 
clipboard format. The clipboard viewer will display the metafile or bitmap. Other programs that 
can read bitmaps or metafiles from the clipboard will obtain those formats. However, when 
the vector-drawing program itself needs to read data from the clipboard, it will copy the 
data in its own registered format because that format probably contains more information 
than the bitmap or metafile.
<P>A program registers a new clipboard format by calling
<P><PRE>iFormat = RegisterClipboardFormat (szFormatName) ;</pre>
<P>The <I>iFormat</I> value is between 0xC000 and 0xFFFF. A clipboard viewer (or a program 
that obtains all the current clipboard formats by calling 
<I>EnumClipboardFormats</I>) can obtain the ASCII name of this format by calling
<P><PRE>GetClipboardFormatName (iFormat, psBuffer, iMaxCount) ;</pre>
<P>Windows copies up to <I>iMaxCount</I> characters into 
<I>psBuffer</I>.
<P>Programmers who use this method for copying data to the clipboard might want 
to publicize the format name and the actual format of the data. If the program 
becomes popular, other programs can then copy data in this format from the clipboard.

</BODY>
</HTML>






