<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>The Fun and Fancy Stuff</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="650"><h1>The Fun and Fancy Stuff</h1></A>
<p>Expressing font characters in terms of outlines opens up lots of potential in combining fonts with other graphics techniques. Earlier we saw how fonts can be rotated. This final section shows some other tricks. But before we continue, let's look at two important preliminaries: graphics paths and extended pens.

<A NAME="651"><h2>The GDI Path</h2></A>
<p>A path is a collection of straight lines and curves stored internally to GDI. Paths were introduced in the 32-bit versions of Windows. The path may initially seem similar to the region, and indeed you can convert a path to a region and use a path for clipping. However, we'll see shortly how they differ.

<p>To begin a path definition, you simply call

<P><pre>
BeginPath (hdc) ;
</PRE>

<p>After this call, any line you draw (such as straight lines, arcs, and Bezier splines) will be stored internally to GDI as a path and not rendered on the device context. Often a path consists of connected lines. To make connected lines, you use the <I>LineTo</I>, <I>PolylineTo</I>, and <I>BezierTo</I> functions, all of which draw lines beginning at the current position. If you change the current position by using <I>MoveToEx</I>, or if you call any of the other line-drawing functions, or if you call one of the window/viewport functions that cause a change in the current position, you create a new subpath within the entire path. Thus, a path contains one or more subpaths, where each subpath is a series of connected lines.

<p>Each subpath within the path can be open or closed. A closed subpath is one in which the first point of the first connected line is the same as the last point of the last connected line, and moreover, the subpath is concluded by a call to <I>CloseFigure</I>. <I>CloseFigure</I> will close the subpath with a straight line, if necessary. Any subsequent line-drawing function begins a new subpath. Finally, you end the path definition by calling

<P><pre>
EndPath (hdc) ;
</PRE>

<p>At this point you then call one of the following five functions:

<P><pre>
StrokePath (hdc) ;
FillPath (hdc) ;
StrokeAndFillPath (hdc) ;
hRgn = PathToRegion (hdc) ;
SelectClipPath (hdc, iCombine) ;
</PRE>

<p>Each of these functions destroys the path definition after completion.

<p><I>StrokePath</I> draws the path using the current pen. You might wonder: What's the point? Why can't I just skip all this path stuff and draw the lines normally? I'll tell you why shortly.

<p>The other four functions close any open paths with straight lines. <I>FillPath</I> fills the path using the current brush according to the current polygon-filling mode. <I>StrokeAndFillPath</I> does both jobs in one shot. You can also convert the path to a region or use the path for a clipping area. The <I>iCombine</I> argument is one of the RGN_ constants used with the <I>CombineRgn</I> function, and it indicates how the path is combined with the current clipping region.

<p>Paths are more flexible than regions for filling and clipping because regions can be defined only by combinations of rectangles, ellipses, and polygons. Paths can be composed of Bezier splines and, at least in Windows NT, arcs. In GDI, paths and regions are stored quite differently. The path is a collection of line and curve definitions, and the region (in the general sense) is a collection of scan lines.

<A NAME="652"><h2>Extended Pens</h2></A>
<p>When you call <I>StrokePath</I>, the path is rendered using the current pen. Back in <a href="ch04a.htm#62">Chapter 4</a>, I discussed the <I>CreatePen</I> function that you use to create a pen object. With the introduction of paths, Windows also supports an extended pen function call named <I>ExtCreatePen</I>. This function reveals why it's sometimes useful to create a path and stroke it rather than to draw lines without using a path. The <I>ExtCreatePen</I> function looks like this:

<P><pre>
hPen = ExtCreatePen (iStyle, iWidth, &amp;lBrush, 0, NULL) ;
</PRE>


<p>You can use this function for normal line drawing, but in that case some of the features aren't supported by Windows 98. Even when used for rendering paths, some features are still not supported by Windows 98, which I've indicated above by setting the last two arguments to 0 and NULL.

<p>For the first argument to <I>ExtCreatePen</I>, you can use any of the styles described in <a href="ch04a.htm#62">Chapter 4</a> for <I>CreatePen</I>. You can additionally combine these styles with PS_GEOMETRIC, where the <I>iWidth</I> argument denoting the width of the line is in logical units and is subject to transforms, or PS_COSMETIC, where the <I>iWidth</I> argument must be 1. In Windows 98, pens with a dashed or dotted style must be PS_COSMETIC. This restriction is lifted for Windows NT.

<p>One of the arguments to <I>CreatePen</I> is a color; rather than a color, <I>ExtCreatePen</I> uses a brush to color the interiors of PS_GEOMETRIC pens. That brush can even be defined by a bitmap.

<p>When you're drawing wide lines, you might also be concerned about the appearance of the ends of the lines. When lines or curves are connected, you might also be concerned about the appearance of the joins between the lines. With pens created by <I>CreatePen</I>, these ends and joins are always rounded. With <I>ExtCreatePen</I>, you have a choice. (Actually, in Windows 98, you have a choice only when you use the pen to stroke a path; Windows NT is more flexible.) The ends of wide lines can be defined using one of the following pen styles in <I>ExtCreatePen</I>:


<P><pre>
PS_ENDCAP_ROUND
PS_ENDCAP_SQUARE
PS_ENDCAP_FLAT
</PRE>

<p>The &quot;square&quot; style is different from the &quot;flat&quot; style in that it extends the line for one-half the width. Similarly, joins between lines in a path can be specified by

<P><pre>
PS_JOIN_ROUND
PS_JOIN_BEVEL
PS_JOIN_MITER
</PRE>

<p>The &quot;bevel&quot; style cuts off the end of the join and the &quot;miter&quot; style turns it into a spike. This can be better illustrated with a program called ENDJOIN, which is shown in Figure 17-12.

<p><B>Figure 17-12.</b> <i>The ENDJOIN Program.</i>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="653"><h3>ENDJOIN.C</h3></A><P><pre>
/*----------------------------------------
   ENDJOIN.C -- Ends and Joins Demo
                (c) Charles Petzold, 1998
  ----------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;EndJoin&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Ends and Joins Demo&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}
LRESULT CALLBACK WndProc (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
     static int  iEnd[] = { PS_ENDCAP_ROUND, PS_ENDCAP_SQUARE, PS_ENDCAP_FLAT } ;
     static int  iJoin[]= { PS_JOIN_ROUND,   PS_JOIN_BEVEL,    PS_JOIN_MITER } ;
     static int  cxClient, cyClient ;
     HDC         hdc ;
     int         i ;
     LOGBRUSH    lb ;
     PAINTSTRUCT ps ;
     
     switch (iMsg)
     {
     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;
          
     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
          
          SetMapMode (hdc, MM_ANISOTROPIC) ;
          SetWindowExtEx (hdc, 100, 100, NULL) ;
          SetViewportExtEx (hdc, cxClient, cyClient, NULL) ;
          
          lb.lbStyle = BS_SOLID ;
          lb.lbColor = RGB (128, 128, 128) ;
          lb.lbHatch = 0 ;
          
          for (i = 0 ; i &lt; 3 ; i++)
          {
               SelectObject (hdc,
                    ExtCreatePen (PS_SOLID | PS_GEOMETRIC |
                                  iEnd [i] | iJoin [i], 10,
                                  &amp;lb, 0, NULL)) ;
               BeginPath (hdc) ;
               
               MoveToEx (hdc, 10 + 30 * i, 25, NULL) ;
               LineTo   (hdc, 20 + 30 * i, 75) ;
               LineTo   (hdc, 30 + 30 * i, 25) ;
               
               EndPath (hdc) ;
               StrokePath (hdc) ;
               
               DeleteObject (
                    SelectObject (hdc,
                         GetStockObject (BLACK_PEN))) ;
               MoveToEx (hdc, 10 + 30 * i, 25, NULL) ;
               LineTo   (hdc, 20 + 30 * i, 75) ;
               LineTo   (hdc, 30 + 30 * i, 25) ;
          }
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, iMsg, wParam, lParam) ;
}
</PRE>
</td></tr></table>

<p>The program draws three V-shaped wide lines using the end and join styles in the order listed above. The program also draws three identical lines using the stock black pen. This shows how the wide line compares with the normal thin line. The results are shown in Figure 17-13.

<p><A HREF="javascript:fullSize('F17zg13x.htm')"> <img src="F17zg13.JPG" width=404 height=285 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 17-13.</b> <i>The ENDJOIN display.</I><!-- /caption -->

<p>I hope it's now apparent why Windows supports a <I>StrokePath</I> function: If you were to draw the two lines individually, GDI would be forced to use the line ends on each of them. Only if they're in a path definition does GDI know that the lines are connected and then use a line join.

<A NAME="654"><h2>Four Sample Programs</h2></A>
<p>Of what good is this? Well, think about it: The characters in outline fonts are defined by a series of coordinate values. These coordinates define straight lines and splines. Thus, the straight lines and curves can become part of a path definition.

<p>And yes, it works! This is demonstrated in the FONTOUT1 program shown in Figure 17-14.

<p><B>Figure 17-14.</b> <i>The FONTOUT1 program.</I>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="655"><h3>FONTOUT1.C</h3></A><P><pre>
/*------------------------------------------
   FONTOUT1.C -- Using Path to Outline Font
                 (c) Charles Petzold, 1998
  ------------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;..\\eztest\\ezfont.h&quot;

TCHAR szAppName [] = TEXT (&quot;FontOut1&quot;) ;
TCHAR szTitle [] = TEXT (&quot;FontOut1: Using Path to Outline Font&quot;) ;

void PaintRoutine (HWND hwnd, HDC hdc, int cxArea, int cyArea)
{
     static TCHAR szString [] = TEXT (&quot;Outline&quot;) ;
     HFONT        hFont ;
     SIZE         size ;

     hFont = EzCreateFont (hdc, TEXT (&quot;Times New Roman&quot;), 1440, 0, 0, TRUE) ;

     SelectObject (hdc, hFont) ;

     GetTextExtentPoint32 (hdc, szString, lstrlen (szString), &amp;size) ;

     BeginPath (hdc) ;
     TextOut (hdc, (cxArea - size.cx) / 2, (cyArea - size.cy) / 2,
                    szString, lstrlen (szString)) ;
     EndPath (hdc) ;

     StrokePath (hdc) ;

     SelectObject (hdc, GetStockObject (SYSTEM_FONT)) ;
     DeleteObject (hFont) ;
}
</PRE>
</td></tr></table>


<p>This program, and the remainder of the programs in this chapter, also use the EZFONT and FONTDEMO files shown earlier.

<p>The program creates a 144-point TrueType font and calls the <I>GetTextExtentPoint32</I> function to obtain the dimensions of the text box. It then calls the <I>TextOut</I> function in a path definition so that the text is centered in the client window. Because the <I>TextOut</I> function is called in a path bracket&#8212;that is, between calls to <I>BeginPath</I> and <I>EndPath</I>&#8212;GDI does not display the text immediately. Instead, the character outlines are stored in the path definition.

<p>After the path bracket is ended, FONTOUT1 calls <I>StrokePath</I>. Because no special pen has been selected into the device context, GDI simply draws the character outlines using the default pen, as shown in Figure 17-15.

<p><A HREF="javascript:fullSize('F17zg15x.htm')"> <img src="F17zg15.JPG" width=404 height=286 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 17-15.</b> <i>The FONTOUT1 display.</I><!-- /caption -->

<p>But what have we here? We've got outlined characters, as we expect, but why is the text string surrounded by a rectangle?

<p>Well, recall that the text background mode is by default OPAQUE rather than TRANSPARENT. That rectangle is the outline of the text box. This clearly demonstrates the two-step approach that GDI uses when drawing text in the default OPAQUE mode. First it draws a filled rectangle, and then it draws the characters. The outline of the text box rectangle thus also becomes part of the path.

<p>Using the <I>ExtCreatePen</I> function, you can outline the characters of a font with something other than the default pen. This is demonstrated in the FONTOUT2 program shown in Figure 17-16.

<p><B>Figure 17-16.</b> <i>The FONTOUT2 program.</I>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="656"><h3>FONTOUT2.C</h3></A><P><pre>
/*------------------------------------------
   FONTOUT2.C -- Using Path to Outline Font
                 (c) Charles Petzold, 1998
  ------------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;..\\eztest\\ezfont.h&quot;

TCHAR szAppName [] = TEXT (&quot;FontOut2&quot;) ;
TCHAR szTitle [] = TEXT (&quot;FontOut2: Using Path to Outline Font&quot;) ;

void PaintRoutine (HWND hwnd, HDC hdc, int cxArea, int cyArea)
{
     static TCHAR szString [] = TEXT (&quot;Outline&quot;) ;
     HFONT        hFont ;
     LOGBRUSH     lb ;
     SIZE         size ;

     hFont = EzCreateFont (hdc, TEXT (&quot;Times New Roman&quot;), 1440, 0, 0, TRUE) ;

     SelectObject (hdc, hFont) ;
     SetBkMode (hdc, TRANSPARENT) ;

     GetTextExtentPoint32 (hdc, szString, lstrlen (szString), &amp;size) ;

     BeginPath (hdc) ;
     TextOut (hdc, (cxArea - size.cx) / 2, (cyArea - size.cy) / 2,
                    szString, lstrlen (szString)) ;
     EndPath (hdc) ;

     lb.lbStyle = BS_SOLID ;
     lb.lbColor = RGB (255, 0, 0) ;
     lb.lbHatch = 0 ;

     SelectObject (hdc, ExtCreatePen (PS_GEOMETRIC | PS_DOT,
                               GetDeviceCaps (hdc, LOGPIXELSX) / 24,
                                   &amp;lb, 0, NULL)) ;
     StrokePath (hdc) ;

     DeleteObject (SelectObject (hdc, GetStockObject (BLACK_PEN))) ;
     SelectObject (hdc, GetStockObject (SYSTEM_FONT)) ;
     DeleteObject (hFont) ;
}
</PRE>
</td></tr></table>


<p>This program creates (and selects into the device context) a red dotted pen with a width of 3 points (1/24th inch) before calling <I>StrokePath</I>. The results when the program runs under Windows NT are shown in Figure 17-17.
<p><A HREF="javascript:fullSize('F17zg17x.htm')"> <img src="F17zg17.JPG" width=404 height=285 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 17-17.</b> <i>The FONTOUT2 display.</I><!-- /caption -->

<p>You can also use paths to define areas for filling. You create the path in the same way as shown in the past two programs, select a filling pattern, and call <I>FillPath</I>. Another function you can call is <I>StrokeAndFillPath</I>, which both outlines a path and fills it with one function call.

<p>The <I>StrokeAndFillPath</I> function is demonstrated in the FONTFILL program shown in Figure 17-18.

<p><B>Figure 17-18.</b> <i>The FONTFILL program.</i>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="657"><h3>FONTFILL.C</h3></A><P><pre>
/*-----------------------------------------
   FONTFILL.C -- Using Path to Fill Font
                 (c) Charles Petzold, 1998
  -----------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;..\\eztest\\ezfont.h&quot;

TCHAR szAppName [] = TEXT (&quot;FontFill&quot;) ;
TCHAR szTitle [] = TEXT (&quot;FontFill: Using Path to Fill Font&quot;) ;

void PaintRoutine (HWND hwnd, HDC hdc, int cxArea, int cyArea)
{
     static TCHAR szString [] = TEXT (&quot;Filling&quot;) ;
     HFONT        hFont ;
     SIZE         size ;

     hFont = EzCreateFont (hdc, TEXT (&quot;Times New Roman&quot;), 1440, 0, 0, TRUE) ;

     SelectObject (hdc, hFont) ;
     SetBkMode (hdc, TRANSPARENT) ;

     GetTextExtentPoint32 (hdc, szString, lstrlen (szString), &amp;size) ;

     BeginPath (hdc) ;
     TextOut (hdc, (cxArea - size.cx) / 2, (cyArea - size.cy) / 2,
                    szString, lstrlen (szString)) ;
     EndPath (hdc) ;

     SelectObject (hdc, CreateHatchBrush (HS_DIAGCROSS, RGB (255, 0, 0))) ;
     SetBkColor (hdc, RGB (0, 0, 255)) ;
     SetBkMode (hdc, OPAQUE) ;

     StrokeAndFillPath (hdc) ;

     DeleteObject (SelectObject (hdc, GetStockObject (WHITE_BRUSH))) ;
     SelectObject (hdc, GetStockObject (SYSTEM_FONT)) ;
     DeleteObject (hFont) ;
}
</PRE>
</td></tr></table>

<p>FONTFILL uses the default pen for outlining the path but creates a red hatched brush using the HS_DIAGCROSS style. Notice that the program sets the background mode to TRANSPARENT when creating the path but then resets it to OPAQUE when filling the path so that it can use a blue background color for the area pattern. The results are shown in Figure 17-19.

<p>You may want to try a few variations on this program to observe the effects. First, if you comment out the first <I>SetBkMode</I> call, you'll get the background of the text box covered with the pattern but not the characters themselves. That's usually not what you want, but you can certainly do it.

<p>Also, when filling characters and using them for clipping, you want to leave the default ALTERNATE polygon-filling mode in effect. My experience indicates that TrueType fonts are constructed so that nothing strange will happen (such as the interiors of <I>O</I>s being filled) if you use the WINDING fill mode, but you'll want to play it safe by sticking with ALTERNATE.

<p><A HREF="javascript:fullSize('F17zg19x.htm')"> <img src="F17zg19.JPG" width=404 height=285 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 17-19.</b> <i>The FONTFILL display.</I><!-- /caption -->

<p>Finally, you can use a path, and hence a TrueType font, to define a clipping region. This is demonstrated in the FONTCLIP program shown in Figure 17-20.

<p><B>Figure 17-20.</b> <i>The FONTCLIP program.</i>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="658"><h3>FONTCLIP.C</h3></A><P><pre>
/*-----------------------------------------------
   FONTCLIP.C -- Using Path for Clipping on Font
                 (c) Charles Petzold, 1998
  -----------------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;..\\eztest\\ezfont.h&quot;

TCHAR szAppName [] = TEXT (&quot;FontClip&quot;) ;
TCHAR szTitle [] = TEXT (&quot;FontClip: Using Path for Clipping on Font&quot;) ;

void PaintRoutine (HWND hwnd, HDC hdc, int cxArea, int cyArea)
{
     static TCHAR szString [] = TEXT (&quot;Clipping&quot;) ;
     HFONT        hFont ;
     int          y, iOffset ;
     POINT        pt [4] ;
     SIZE         size ;

     hFont = EzCreateFont (hdc, TEXT (&quot;Times New Roman&quot;), 1200, 0, 0, TRUE) ;
     SelectObject (hdc, hFont) ;

     GetTextExtentPoint32 (hdc, szString, lstrlen (szString), &amp;size) ;

     BeginPath (hdc) ;
     TextOut (hdc, (cxArea - size.cx) / 2, (cyArea - size.cy) / 2,
                    szString, lstrlen (szString)) ;
     EndPath (hdc) ;

               // Set clipping area

     SelectClipPath (hdc, RGN_COPY) ;

               // Draw Bezier splines

     iOffset = (cxArea + cyArea) / 4 ;

     for (y = -iOffset ; y &lt; cyArea + iOffset ; y++)
     {
          pt[0].x = 0 ;
          pt[0].y = y ;

          pt[1].x = cxArea / 3 ;
          pt[1].y = y + iOffset ;

          pt[2].x = 2 * cxArea / 3 ;
          pt[2].y = y - iOffset ;

          pt[3].x = cxArea ;
          pt[3].y = y ;

          SelectObject (hdc, CreatePen (PS_SOLID, 1,
               RGB (rand () % 256, rand () % 256, rand () % 256))) ;

          PolyBezier (hdc, pt, 4) ;

          DeleteObject (SelectObject (hdc, GetStockObject (BLACK_PEN))) ;
     }

     DeleteObject (SelectObject (hdc, GetStockObject (WHITE_BRUSH))) ;
     SelectObject (hdc, GetStockObject (SYSTEM_FONT)) ;
     DeleteObject (hFont) ;
}
</pre>
</td></tr></table>

<p>This is a program where I've deliberately excluded the <I>SetBkMode</I> call to achieve a different effect. The program draws some text in a path bracket and then calls <I>SelectClipPath</I>. It then draws a series of Bezier spline curves with random colors.

<p>If the FONTCLIP program had called <I>SetBkMode</I> with the TRANSPARENT option, the Bezier curves would have been restricted to the interiors of the character outlines. With the background mode in the default OPAQUE option, the clipping region is restricted to the interior of the text box but not the characters themselves. This is shown inFigure 1721.

<p><A HREF="javascript:fullSize('F17zg21x.htm')"> <img src="F17zg21.JPG" width=404 height=285 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 17-21.</b> <i>The FONTCLIP display.</I><!-- /caption -->

<p>You'll probably want to insert a <I>SetBkMode</I> call into FONTCLIP to see the difference with the TRANSPARENT option.

<p>The FONTDEMO shell program allows you to print as well as display these effects, and even better, you can try some of your own special effects.

</BODY>
</HTML>






