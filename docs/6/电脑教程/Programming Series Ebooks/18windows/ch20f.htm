<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Thread Local Storage</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="735"><h1>Thread Local Storage</h1></A><P>Global variables in a multithreaded program, as well as any allocated memory, are shared among all the threads in the program. Local static variables in a function are also shared among all threads using that function. Local automatic variables in a function are unique to each thread because they are stored on the stack and each thread has its own stack.
<P>It might be necessary to have persistent storage that is unique to each thread. For example, the C <I>strtok</I> function I mentioned earlier in this chapter requires this type of storage. Unfortunately, the C language does not support such a variable. But Windows includes four functions that implement a mechanism to do it, and the Microsoft extensions to C also support it. As we've seen, this is called thread local storage.
<P>Here's how the APIs work:
<P>First define a structure that contains all the data that needs to be unique among the threads. For example,
<P><pre>
typedef struct
{
     int a ;
     int b ;
}
DATA, * PDATA ;
</pre>
<P>The primary thread calls <I>TlsAlloc</I> to obtain an index value:
<P><pre>
dwTlsIndex = TlsAlloc () ;
</pre>
<P>This index value can be stored in a global variable or passed to the <I>Thread</I> function in the argument structure.
<P>The <I>Thread</I> function begins by allocating memory for the data structure and calling <I>TlsSetValue</I> using the index obtained above:
<P><pre>
TlsSetValue (dwTlsIndex, GlobalAlloc (GPTR, sizeof (DATA)) ;
</pre>
<P>This associates a pointer with a particular thread and a particular thread index. Now any function that needs to use this pointer, including the original <I>Thread</I> function itself, can include code like so:
<P><pre>
PDATA pdata ;
...
pdata = (PDATA) TlsGetValue (dwTlsIndex) ;
</pre>
<P>Now it can set or <I>use pdata-&gt;a</I> and <I>pdata-&gt;b</I>. Before the <I>Thread</I> function terminates, it frees the allocated memory:
<P><pre>
GlobalFree (TlsGetValue (dwTlsIndex)) ;
</pre>
<P>When all the threads using this data have terminated, the primary thread frees the index:
<P><pre>
TlsFree (dwTlsIndex) ;
</pre>
<P>This process might be confusing at first, so perhaps it might be helpful to see how thread local storage might be implemented. (I have no knowledge of how Windows actually does it, but the following is plausible.) First, <I>TlsAlloc</I> might simply allocate a block of memory (zero bytes in length) and return an index value that is a pointer to this block. Every time <I>TlsSetValue</I> is called with that index, the block of memory is increased by 8 bytes by reallocating it. Stored in these 8 bytes is the ID of the thread calling the function&#8212;obtained by calling <I>GetCurrentThreadId</I>&#8212;and the pointer passed to the <I>TlsSetValue</I> function. <I>TlsGetValue</I> simply uses the thread ID to search the table and then return the pointer. <I>TlsFree</I> frees up the block of memory. So, as you see, this is something you could probably easily implement yourself, but it's nice to have the facility already done for us.
<P>A Microsoft extension to C makes this even more simple. Just preface any variable that needs to be different for each thread with <I>__declspec (thread)</I>, like so
<P><pre>
__declspec (thread) int iGlobal = 1 ;
</pre>
<P>for static variables external to any function, or like so
<P><pre>
__declspec (thread) static int iLocal = 2 ;
</pre>
<P>for static variables within functions.
</BODY>
</HTML>






