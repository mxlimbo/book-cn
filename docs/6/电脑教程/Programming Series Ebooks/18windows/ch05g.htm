<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Rectangles, Regions, and Clipping</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="136"><h1>Rectangles, Regions, and Clipping</h1></A>
<p>Windows includes several additional drawing functions that work with RECT (rectangle) structures and regions. A region is an area of the screen that is a combination of rectangles, polygons, and ellipses.

<A NAME="137"><h2>Working with Rectangles</h2></A>
<p>These three drawing functions require a pointer to a rectangle structure:

<p><pre>
FillRect (hdc, &amp;rect, hBrush) ;
FrameRect (hdc, &amp;rect, hBrush) ;
InvertRect (hdc, &amp;rect) ;
</pre>

<p>In these functions, the <I>rect</I> parameter is a structure of type RECT with four fields: <I>left</I>, <I>top</I>, <I>right</I>, and <I>bottom</I>. The coordinates in this structure are treated as logical coordinates.

<p><I>FillRect</I> fills the rectangle (up to but not including the right and bottom coordinates) with the specified brush. This function doesn't require that you first select the brush into the device context.

<p><I>FrameRect</I> uses the brush to draw a rectangular frame, but it does not fill in the rectangle. Using a brush to draw a frame may seem a little strange, because with the functions that you've seen so far (such as <I>Rectangle</I>) the border is drawn with the current pen. <I>FrameRect</I> allows you to draw a rectangular frame that isn't necessarily a pure color. This frame is one logical unit wide. If logical units are larger than device units, the frame will be 2 or more pixels wide.

<p><I>InvertRect</I> inverts all the pixels in the rectangle, turning ones to zeros and zeros to ones. This function turns a white area to black, a black area to white, and a green area to magenta.

<p>Windows also includes nine functions that allow you to manipulate RECT structures easily and cleanly. For instance, to set the four fields of a RECT structure to particular values, you would conventionally use code that looks like this:

<p><pre>
rect.left   = xLeft ;
rect.top    = xTop ;
rect.right  = xRight ;
rect.bottom = xBottom ;
</pre>

<p>By calling the <I>SetRect</I> function, however, you can achieve the same result with a single line:

<p><pre>
SetRect (&amp;rect, xLeft, yTop, xRight, yBottom) ;
</pre>

<p>The other eight functions can also come in handy when you want to do one of the following:

<p><ul>

<p><li>     Move a rectangle a number of units along the 
<I>x</I> and <I>y</I> axes:

<p><pre>
OffsetRect (&amp;rect, x, y) ;
</pre>

<p><li>     Increase or decrease the size of a rectangle:

<p><pre>
InflateRect (&amp;rect, x, y) ;
</pre>

<p><li>     Set the fields of a rectangle equal to 0:

<p><pre>
SetRectEmpty (&amp;rect) ;
</pre>

<p><li>     Copy one rectangle to another:

<p><pre>
CopyRect (&amp;DestRect, &amp;SrcRect) ;
</pre>

<p><li>     Obtain the intersection of two rectangles:

<p><pre>
IntersectRect (&amp;DestRect, &amp;SrcRect1, &amp;SrcRect2) ;
</pre>

<p><li>     Obtain the union of two rectangles:

<p><pre>
UnionRect (&amp;DestRect, &amp;SrcRect1, &amp;SrcRect2) ;
</pre>

<p><li>     Determine whether a rectangle is empty:

<p><pre>
bEmpty = IsRectEmpty (&amp;rect) ;
</pre>

<p><li>     Determine whether a point is in a rectangle:

<p><pre>
bInRect = PtInRect (&amp;rect, point) ;
</pre>
</UL>

<p>In most cases, the equivalent code for these functions is simple. For example, you can duplicate the <I>CopyRect</I> function call with a field-by-field structure copy, accomplished by the statement

<p><pre>
DestRect = SrcRect ;
</pre>

<A NAME="138"><h2>Random Rectangles</h2></A>
<p>A fun program in any graphics system is one that runs &quot;forever,&quot; simply drawing a hypnotic series of images with random sizes and colors&#8212; for example, rectangles of a random size and color. You can create such a program in Windows, but it's not quite as easy as it first seems. I hope you realize that you can't simply put a <I>while(TRUE)</I> loop in the WM_PAINT message. Sure, it will work, but the program will effectively prevent itself from processing other messages. The program cannot be exited or minimized.

<p>One acceptable alternative is setting a Windows timer to send WM_TIMER messages to your window function. (I'll discuss the timer in <a href="ch08a.htm#215">Chapter 8</a>.) For each WM_TIMER message, you obtain a device context with <I>GetDC</I>, draw a random rectangle, and then release the device context with <I>ReleaseDC</I>. But that takes some of the fun out of the program, because the program can't draw the random rectangles as quickly as possible. It must wait for each WM_TIMER message, and that's based on the resolution of the system clock.

<p>There must be plenty of &quot;dead time&quot; in Windows&#8212;time during which all the message queues are empty and Windows is just sitting around waiting for keyboard or mouse input. Couldn't we somehow get control during that dead time and draw the rectangles, relinquishing control only when a message is added to a program's message queue? That's one of the purposes of the <I>PeekMessage</I> function. Here's one example of a <I>PeekMessage</I> call:

<p><pre>
PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE) ;

</pre>

<p>The first four parameters (a pointer to a MSG structure, a window handle, and two values indicating a message range) are identical to those of <I>GetMessage</I>. Setting the second, third, and fourth parameters to NULL or 0 indicates that we want <I>PeekMessage</I> to return all messages for all windows in the program. The last parameter to <I>PeekMessage</I> is set to PM_REMOVE if the message is to be removed from the message queue. You can set it to PM_NOREMOVE if the message isn't to be removed. This is why <I>PeekMessage</I> is a &quot;peek&quot; rather than a &quot;get&quot;&#8212;it allows a program to check the next message in the program's queue without actually removing it.

<p><I>GetMessage</I> doesn't return control to a program unless it retrieves a message from the program's message queue. But <I>PeekMessage</I> always returns right away regardless whether a message is present or not. When there's a message in the program's message queue, the return value of <I>PeekMessage</I> is TRUE (nonzero) and the message can be processed as normal. When there is no message in the queue, <I>PeekMessage</I> returns FALSE (0).

<p>This allows us to replace the normal message loop, which looks like this:

<p><pre>
while (GetMessage (&amp;msg, NULL, 0, 0))
{
     TranslateMessage (&amp;msg) ;
     DispatchMessage (&amp;msg) ;
}
return msg.wParam ;
with an alternative message loop like this:
while (TRUE)
{
     if (PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE))
     {
          if (msg.message == WM_QUIT)
               break ;

          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     else
     {
<I>          [other program lines to do some work]</I>
     }
}
return msg.wParam ;
</pre>

<p>Notice that the WM_QUIT message is explicitly checked. You don't have to do this in a normal message loop, because the return value of <I>GetMessage</I> is FALSE (0) when it retrieves a WM_QUIT message. But <I>PeekMessage</I> uses its return value to indicate whether a message was retrieved, so the check of WM_QUIT is required.

<p>If the return value of <I>PeekMessage</I> is TRUE, the message is processed normally. If the value is FALSE, the program can do some work (such as displaying yet another random rectangle) before returning control to Windows.

<p>(Although the Windows documentation notes that you can't use <I>PeekMessage</I> to remove WM_PAINT messages from the message queue, this isn't really a problem. After all, <I>GetMessage</I> doesn't remove WM_PAINT messages from the queue either. The only way to remove a WM_PAINT message from the queue is to validate the invalid regions of the window's client area, which you can do with <I>ValidateRect</I>, <I>ValidateRgn</I>, or a <I>BeginPaint</I> and <I>EndPaint</I> pair. If you process a WM_PAINT message normally after retrieving it from the queue with <I>PeekMessage</I>, you'll have no problems. What you can't do is use code like this to empty your message queue of all messages:

<p><pre>
while (PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE)) ;
</pre>

<p>This statement removes and discards all messages from your message queue except WM_PAINT. If a WM_PAINT message is in the queue, you'll be stuck inside the while loop forever.)

<p><I>PeekMessage</I> was much more important in earlier versions of Windows than it is in Windows 98. This is because the 16-bit versions of Windows employed nonpreemptive multitasking (which I'll discuss in <a href="ch20a.htm#709">Chapter 20</a>). The Windows Terminal program used a <I>PeekMessage</I> loop to check for incoming data from a communications port. The Print Manager program used this technique for printing, and Windows applications that printed also generally used a <I>PeekMessage</I> loop. With the preemptive multitasking of Windows 98, programs can create multiple threads of execution, as we'll see in <a href="ch20a.htm#709">Chapter 20</a>.

<p>Armed only with the <I>PeekMessage</I> function, however, we can write a program that relentlessly displays random rectangles. The program, called RANDRECT, is shown in Figure 5-26.





<p><table width="95%" cellpadding="5" valign="TOP">
<tr><td valign=top><A NAME="139"><h3>RANDRECT.C</h3></A>
<p><pre>
/*------------------------------------------
   RANDRECT.C -- Displays Random Rectangles
                 (c) Charles Petzold, 1998
  ------------------------------------------*/

#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;           // for the rand function

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;
void DrawRectangle (HWND) ;

int cxClient, cyClient ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;RandRect&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;

     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Random Rectangles&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (TRUE)
     {
          if (PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE))
          {
               if (msg.message == WM_QUIT)
                    break ;
               TranslateMessage (&amp;msg) ;
               DispatchMessage (&amp;msg) ;
          }
          else
               DrawRectangle (hwnd) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
     switch (iMsg)
     {
     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;
          
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, iMsg, wParam, lParam) ;
}

void DrawRectangle (HWND hwnd)
{
     HBRUSH hBrush ;
     HDC    hdc ;
     RECT   rect ;
     
     if (cxClient == 0 || cyClient == 0)
          return ;
     
     SetRect (&amp;rect, rand () % cxClient, rand () % cyClient,
                     rand () % cxClient, rand () % cyClient) ;
     
     hBrush = CreateSolidBrush (
                    RGB (rand () % 256, rand () % 256, rand () % 256)) ;
     hdc = GetDC (hwnd) ;
     
     FillRect (hdc, &amp;rect, hBrush) ;
     ReleaseDC (hwnd, hdc) ;
     DeleteObject (hBrush) ;
}     
</PRE></td></tr></table>
<p><B>Figure 5-26.</B> <I>The RANDRECT program.</I>
<p>This program actually runs so fast on today's speedy machines that it no longer looks like a series of random rectangles! The program uses the <I>SetRect</I> and <I>FillRect</I> function I discussed above, basing rectangle coordinates and solid brush colors on random values obtained from the C <I>rand</I> function. I'll show another version of this program using multiple threads of execution in <a href="ch20a.htm#709">Chapter 20</a>.

<A NAME="140"><h2>Creating and Painting Regions</h2></A>
<p>A region is a description of an area of the display that is a combination of rectangles, polygons, and ellipses. You can use regions for drawing or for clipping. You use a region for clipping (that is, restricting drawing to a specific part of your client area) by selecting the region into the device context. Like pens and brushes, regions are GDI objects. You should delete any regions that you create by calling <I>DeleteObject</I>.

<p>When you create a region, Windows returns a handle to the region of type HRGN. The simplest type of region describes a rectangle. You can create a rectangular region in one of two ways:


<p><pre>
hRgn = CreateRectRgn (xLeft, yTop, xRight, yBottom) ;
</pre>

<p>or

<p><pre>
hRgn = CreateRectRgnIndirect (&amp;rect) ;
</pre>

<p>You can also create elliptical regions using

<p><pre>
hRgn = CreateEllipticRgn (xLeft, yTop, xRight, yBottom) ;
</pre>

<p>or

<p><pre>
hRgn = CreateEllipticRgnIndirect (&amp;rect) ;
</pre>

<p>The <I>CreateRoundRectRgn</I> creates a rectangular region with rounded corners.

<p>Creating a polygonal region is similar to using the <I>Polygon</I> function:

<p><pre>
hRgn = CreatePolygonRgn (&amp;point, iCount, iPolyFillMode) ;
</pre>

<p>The point parameter is an array of structures of type POINT, <I>iCount</I> is the number of points, and <I>iPolyFillMode</I> is either ALTERNATE or WINDING. You can also create multiple polygonal regions using <I>CreatePolyPolygonRgn</I>.

<p>So what, you say? What makes these regions so special? Here's the function that unleashes the power of regions:

<p><pre>
iRgnType = CombineRgn (hDestRgn, hSrcRgn1, hSrcRgn2, iCombine) ;
</pre>

<p>This function combines two source regions (<I>hSrcRgn1</I> and <I>hSrcRgn2</I>) and causes the destination region handle (<I>hDestRgn</I>) to refer to that combined region. All three region handles must be valid, but the region previously described by <I>hDestRgn</I> is destroyed. (When you use this function, you might want to make <I>hDestRgn</I> refer initially to a small rectangular region.)

<p>The <I>iCombine</I> parameter describes how the <I>hSrcRgn1</I> and <I>hSrcRgn2</I> regions are to be combined:
<table width="955" cellpadding="5" valign="TOP">
<tr>
<td valign=top><b><i>iCombine Value</i></b></td>
<td valign=top><b><i>New Region</i></b></td>
</tr>
<tr>
<td valign=top>RGN_AND</td>
<td valign=top>Overlapping area of the two source regions</td>
</tr>
<tr>
<td valign=top>RGN_OR</td>
<td valign=top>All of the two source regions</td>
</tr>
<tr><td valign=top>RGN_XOR</td>
<td valign=top>All of the two source regions, excluding the overlapping area</td>
</tr>
<tr>
<td valign=top>RGN_DIFF</td>
<td valign=top>All of <I>hSrcRgn1</I> not in <I>hSrcRgn2</I></td>
</tr>

<tr>
<td valign=top>RGN_COPY</td>
<td valign=top>All of <I>hSrcRgn1</I> (ignores <I>hSrcRgn2)</I></td>
</tr>
</table>

<p>The <I>iRgnType</I> value returned from <I>CombineRgn</I> is one of the following: NULLREGION, indicating an empty region; SIMPLEREGION, indicating a simple rectangle, ellipse, or polygon; COMPLEXREGION, indicating a combination of rectangles, ellipses, or polygons; and ERROR, meaning that an error has occurred.

<p>Once you have a handle to a region, you can use it with four drawing functions:

<p><pre>
FillRgn (hdc, hRgn, hBrush) ;
FrameRgn (hdc, hRgn, hBrush, xFrame, yFrame) ;
InvertRgn (hdc, hRgn) ;
PaintRgn (hdc, hRgn) ;
</pre>

<p>The <I>FillRgn</I>, <I>FrameRgn</I>, and <I>InvertRgn</I> functions are similar to the <I>FillRect</I>, <I>FrameRect</I>, and <I>InvertRect</I> functions. The <I>xFrame</I> and <I>yFrame</I> parameters to <I>FrameRgn</I> are the logical width and height of the frame to be painted around the region. The <I>PaintRgn</I> function fills in the region with the brush currently selected in the device context. All these functions assume the region is defined in logical coordinates.

<p>When you're finished with a region, you can delete it using the same function that deletes other GDI objects:

<p><pre>
DeleteObject (hRgn) ;
</pre>

<A NAME="141"><h2>Clipping with Rectangles and Regions</h2></A>
<p>Regions can also play a role in clipping. The <I>InvalidateRect</I> function invalidates a rectangular area of the display and generates a WM_PAINT message. For example, you can use the <I>InvalidateRect</I> function to erase the client area and generate a WM_PAINT message:

<p><pre>
InvalidateRect (hwnd, NULL, TRUE) ;
</pre>

<p>You can obtain the coordinates of the invalid rectangle by calling <I>GetUpdateRect</I>, and you can validate a rectangle of the client area using the <I>ValidateRect</I> function. When you receive a WM_PAINT message, the coordinates of the invalid rectangle are available from the PAINTSTRUCT structure that is filled in by the <I>BeginPaint</I> function. This invalid rectangle also defines a &quot;clipping region.&quot; You cannot paint outside the clipping region.

<p>Windows has two functions similar to <I>InvalidateRect</I> and <I>ValidateRect</I> that work with regions rather than rectangles:

<p><pre>
InvalidateRgn (hwnd, hRgn, bErase) ;
</pre>

<p>and

<p><pre>
ValidateRgn (hwnd, hRgn) ;
</pre>

<p>When you receive a WM_PAINT message as a result of an invalid region, the clipping region will not necessarily be rectangular in shape.

<p>You can create a clipping region of your own by selecting a region into the device context using either

<p><pre>
SelectObject (hdc, hRgn) ;
</pre>

<p>or

<p><pre>
SelectClipRgn (hdc, hRgn) ;
</pre>

<p>A clipping region is assumed to be measured in device coordinates.

<p>GDI makes a copy of the clipping region, so you can delete the region object after you select it in the device context. Windows also includes several functions to manipulate this clipping region, such as <I>ExcludeClipRect</I> to exclude a rectangle from the clipping region, <I>IntersectClipRect</I> to create a new clipping region that is the intersection of the previous clipping region and a rectangle, and <I>OffsetClipRgn</I> to move a clipping region to another part of the client area.

<A NAME="142"><h2>The CLOVER Program</h2></A>
<p>The CLOVER program forms a region out of four ellipses, selects this region into the device context, and then draws a series of lines emanating from the center of the window's client area. The lines appear only in the area defined by the region. The resulting display is shown in Figure 5-28.

<p>To draw this graphic by conventional methods, you would have to calculate the end point of each line based on formulas involving the circumference of an ellipse. By using a complex clipping region, you can draw the lines and let Windows determine the end points. The CLOVER program is shown in Figure 5-27.





<p><table width="955" cellpadding="5" valign="TOP"><tr><td valign=top>
<A NAME="143"><h3>CLOVER.C</h3></A><pre>
/*--------------------------------------------------
   CLOVER.C -- Clover Drawing Program Using Regions
               (c) Charles Petzold, 1998
  --------------------------------------------------*/

#include &lt;windows.h&gt;
#include &lt;math.h&gt;

#define TWO_PI (2.0 * 3.14159)

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;Clover&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Draw a Clover&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
     static HRGN hRgnClip ;
     static int  cxClient, cyClient ;
     double      fAngle, fRadius ;
     HCURSOR     hCursor ;
     HDC         hdc ;
     HRGN        hRgnTemp[6] ;
     int         i ;
     PAINTSTRUCT ps ;
     
     switch (iMsg)
     {
     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;

          hCursor = SetCursor (LoadCursor (NULL, IDC_WAIT)) ;
          ShowCursor (TRUE) ;
          
          if (hRgnClip)
               DeleteObject (hRgnClip) ;
          
          hRgnTemp[0] = CreateEllipticRgn (0, cyClient / 3,
                                           cxClient / 2, 2 * cyClient / 3) ;
          hRgnTemp[1] = CreateEllipticRgn (cxClient / 2, cyClient / 3,
                                           cxClient, 2 * cyClient / 3) ;
          hRgnTemp[2] = CreateEllipticRgn (cxClient / 3, 0,
                                           2 * cxClient / 3, cyClient / 2) ;
          hRgnTemp[3] = CreateEllipticRgn (cxClient / 3, cyClient / 2,
                                           2 * cxClient / 3, cyClient) ;
          hRgnTemp[4] = CreateRectRgn (0, 0, 1, 1) ;
          hRgnTemp[5] = CreateRectRgn (0, 0, 1, 1) ;
          hRgnClip    = CreateRectRgn (0, 0, 1, 1) ;

          CombineRgn (hRgnTemp[4], hRgnTemp[0], hRgnTemp[1], RGN_OR) ;
          CombineRgn (hRgnTemp[5], hRgnTemp[2], hRgnTemp[3], RGN_OR) ;
          CombineRgn (hRgnClip,    hRgnTemp[4], hRgnTemp[5], RGN_XOR) ;
          
          for (i = 0 ; i &lt; 6 ; i++)
               DeleteObject (hRgnTemp[i]) ;
          
          SetCursor (hCursor) ;
          ShowCursor (FALSE) ;
          return 0 ;
          
     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
          
          SetViewportOrgEx (hdc, cxClient / 2, cyClient / 2, NULL) ;
          SelectClipRgn (hdc, hRgnClip) ;
          
          fRadius = _hypot (cxClient / 2.0, cyClient / 2.0) ;
          
          for (fAngle = 0.0 ; fAngle &lt; TWO_PI ; fAngle += TWO_PI / 360)
          {
               MoveToEx (hdc, 0, 0, NULL) ;
               LineTo (hdc, (int) ( fRadius * cos (fAngle) + 0.5),
                            (int) (-fRadius * sin (fAngle) + 0.5)) ;
          }
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;

     case WM_DESTROY:
          DeleteObject (hRgnClip) ;
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, iMsg, wParam, lParam) ;
}
</pre>
</td></tr></table>

<p><B>Figure 5-27.</B> <I>The CLOVER program.</I>
<p><A HREF="javascript:fullSize('F05zg28x.htm')"> <img src="F05zg28.JPG" width=404 height=284 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 5-28.</B> <I>The CLOVER display, drawn using a complex clipping region.</I><!-- /caption -->

<p>Because regions always use device coordinates, the CLOVER program has to recreate the region every time it receives a WM_SIZE message. Years ago, the machines that ran Windows took several seconds to redraw this figure. Today's fast machines draw it nearly instantaneously.

<p>CLOVER begins by creating four elliptical regions that are stored as the first four elements of the <I>hRgnTemp</I> array. Then the program creates three &quot;dummy&quot; regions:

<p><pre>
hRgnTemp [4] = CreateRectRgn (0, 0, 1, 1) ;
hRgnTemp [5] = CreateRectRgn (0, 0, 1, 1) ;
hRgnClip     = CreateRectRgn (0, 0, 1, 1) ;
</pre>

<p>The two elliptical regions at the left and right of the client area are combined:

<p><pre>
CombineRgn (hRgnTemp [4], hRgnTemp [0], hRgnTemp [1], RGN_OR) ;
</pre>

<p>Similarly, the two elliptical regions at the top and bottom of the client area are combined:

<p><pre>
CombineRgn (hRgnTemp [5], hRgnTemp [2], hRgnTemp [3], RGN_OR) ;
</pre>

<p>Finally these two combined regions are in turn combined into <I>hRgnClip</I>:

<p><pre>
CombineRgn (hRgnClip, hRgnTemp [4], hRgnTemp [5], RGN_XOR) ;
</pre>

<p>The RGN_XOR identifier is used to exclude overlapping areas from the resultant region. Finally the six temporary regions are deleted:

<p><pre>
for (i = 0 ; i &lt; 6 ; i++)
     DeleteObject (hRgnTemp [i]) ;
</pre>

<p>The WM_PAINT processing is simple, considering the results. The viewport origin is set to the center of the client area (to make the line drawing easier), and the region created during the WM_SIZE message is selected as the device context's clipping region:

<p><pre>
SetViewportOrg (hdc, xClient / 2, yClient / 2) ;
SelectClipRgn (hdc, hRgnClip) ;
</pre>

<p>Now all that's left is drawing the lines&#8212;360 of them, spaced 1 degree apart. The length of each line is the variable <I>fRadius</I>, which is the distance from the center to the corner of the client area:

<p><pre>
fRadius = hypot (xClient / 2.0, yClient / 2.0) ;

for (fAngle = 0.0 ; fAngle &lt; TWO_PI ; fAngle += TWO_PI / 360)
{
     MoveToEx (hdc, 0, 0, NULL) ;
     LineTo (hdc, (int) ( fRadius * cos (fAngle) + 0.5),
                  (int) (-fRadius * sin (fAngle) + 0.5)) ;
}
</pre>

<p>During processing of WM_DESTROY, the region is deleted:

<p><pre>
DeleteObject (hRgnClip) ;
</pre>

<p>This is not the end of graphics programming in this book. <a href="ch13a.htm#401">Chapter 13</a> looks at printing, Chapters <a href="ch14a.htm#426">14</a> and <a href="ch15a.htm#473">15</a> at bitmaps, <a href="ch17a.htm#600">Chapter 17</a> at text and fonts, and <a href="ch18a.htm#659">Chapter 18</a> at metafiles.

</BODY>
</HTML>




