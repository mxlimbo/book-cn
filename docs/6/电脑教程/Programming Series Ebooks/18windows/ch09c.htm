<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Controls and Colors</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="247"><h1>Controls and Colors</h1></A>
<p>As you can see in Figure 9-2, the display of many of the buttons doesn't look quite right. The push buttons are fine, but the others are drawn with a rectangular gray background that simply shouldn't be there. This is because the buttons are designed to be displayed in dialog boxes, and in Windows 98 dialog boxes have a gray surface. Our window has a white surface because that's how we defined it in the WNDCLASS structure:

<p><pre>
wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
</PRE>

<p>We've been doing this because we often display text to the client area, and GDI uses the text color and background color defined in the default device context. These are always black and white. To make these buttons look a little better, we must either change the color of the client area to agree with the background color of the buttons or somehow change the button background color to be white.

<p>The first step to solving this problem is understanding Windows' use of &quot;system colors.&quot;

<A NAME="248"><h2>System Colors</h2></A>
<p>Windows maintains 29 system colors for painting various parts of the display. You can obtain and set these colors using <I>GetSysColor</I> and <I>SetSysColors</I>. Identifiers defined in the windows header files specify the system color. Setting a system color with <I>SetSysColors</I> changes it only for the current Windows session.

<p>You can change some (but not all) system colors using the Display section of the Windows Control Panel. The selected colors are stored in the Registry in Microsoft Windows NT and in the WIN.INI file in Microsoft Windows 98. The Registry and WIN.INI file use keywords for the 29 system colors (different from the <I>GetSysColor</I> and <I>SetSysColors</I> identifiers), followed by red, green, and blue values that can range from 0 to 255. The following table shows how the 29 system colors are identified applying the constants used for <I>GetSysColor</I> and <I>SetSysColors</I> and also the WIN.INI keywords. The table is arranged sequentially by the values of the COLOR_ constants, beginning with 0 and ending with 28.

<P> 
<table CELLPADDING="5" WIDTH="95%">
<tr><td valign="top"><B>GetSysColor<I> and </I>SetSysColors</B></td>
<td valign="top"><B><I>Registry Key or WIN.INI Identifer</I></B></td>
<td valign="top"><B><I>Default RGB Value</I></B></td></tr>
<tr><td valign="top">COLOR_SCROLLBAR</td>
<td valign="top">Scrollbar</td>
<td valign="top">C0-C0-C0</td></tr>

<tr><td valign="top">COLOR_BACKGROUND</td>
<td valign="top">Background</td>
<td valign="top">00-80-80</td></tr>
<tr><td valign="top">COLOR_ACTIVECAPTION</td>
<td valign="top">ActiveTitle</td>
<td valign="top">00-00-80</td></tr>
<tr><td valign="top">COLOR_INACTIVECAPTION</td>
<td valign="top">InactiveTitle</td>
<td valign="top">80-80-80</td></tr>
<tr><td valign="top">COLOR_MENU</td>
<td valign="top">Menu</td>
<td valign="top">C0-C0-C0</td></tr>
<tr><td valign="top">COLOR_WINDOW</td>
<td valign="top">Window</td>
<td valign="top">FF-FF-FF</td></tr>
<tr><td valign="top">COLOR_WINDOWFRAME</td>
<td valign="top">WindowFrame</td>
<td valign="top">00-00-00</td></tr>
<tr><td valign="top">COLOR_MENUTEXT</td>
<td valign="top">MenuText</td>
<td valign="top">C0-C0-C0</td></tr>
<tr><td valign="top">COLOR_WINDOWTEXT</td>
<td valign="top">WindowText</td>
<td valign="top">00-00-00</td></tr>
<tr><td valign="top">COLOR_CAPTIONTEXT</td>
<td valign="top">TitleText</td>
<td valign="top">FF-FF-FF</td></tr>
<tr><td valign="top">COLOR_ACTIVEBORDER</td>
<td valign="top">ActiveBorder</td>
<td valign="top">C0-C0-C0</td></tr>
<tr><td valign="top">COLOR_INACTIVEBORDER</td>
<td valign="top">InactiveBorder</td>
<td valign="top">C0-C0-C0</td></tr>
<tr><td valign="top">COLOR_APPWORKSPACE</td>
<td valign="top">AppWorkspace</td>
<td valign="top">80-80-80</td></tr>
<tr><td valign="top">COLOR_HIGHLIGHT</td>
<td valign="top">Highlight</td>
<td valign="top">00-00-80</td></tr>
<tr><td valign="top">COLOR_HIGHLIGHTTEXT</td>
<td valign="top">HighlightText</td>
<td valign="top">FF-FF-FF</td></tr>
<tr><td valign="top">COLOR_BTNFACE</td>
<td valign="top">ButtonFace</td>
<td valign="top">C0-C0-C0</td></tr>
<tr><td valign="top">COLOR_BTNSHADOW</td>
<td valign="top">ButtonShadow</td>
<td valign="top">80-80-80</td></tr>
<tr><td valign="top">COLOR_GRAYTEXT</td>
<td valign="top">GrayText</td>
<td valign="top">80-80-80</td></tr>
<tr><td valign="top">COLOR_BTNTEXT</td>
<td valign="top">ButtonText</td>
<td valign="top">00-00-00</td></tr>
<tr><td valign="top">COLOR_INACTIVECAPTIONTEXT</td>
<td valign="top">InactiveTitleText</td>
<td valign="top">C0-C0-C0</td></tr>
<tr><td valign="top">COLOR_BTNHIGHLIGHT</td>
<td valign="top">ButtonHighlight</td>
<td valign="top">FF-FF-FF</td></tr>
<tr><td valign="top">COLOR_3DDKSHADOW</td>
<td valign="top">ButtonDkShadow</td>
<td valign="top">00-00-00</td></tr>
<tr><td valign="top">COLOR_3DLIGHT</td>
<td valign="top">ButtonLight</td>
<td valign="top">C0-C0-C0</td></tr>
<tr><td valign="top">COLOR_INFOTEXT</td>
<td valign="top">InfoText</td>
<td valign="top">00-00-00</td></tr>
<tr><td valign="top">COLOR_INFOBK</td>
<td valign="top">InfoWindow</td>
<td valign="top">FF-FF-FF</td></tr>
<tr><td valign="top">[no identifier; use value 25]</td>
<td valign="top">ButtonAlternateFace</td>
<td valign="top">B8-B4-B8</td></tr>
<tr><td valign="top">COLOR_HOTLIGHT</td>
<td valign="top">HotTrackingColor</td>
<td valign="top">00-00-FF</td></tr>
<tr><td valign="top">COLOR_GRADIENTACTIVECAPTION</td>
<td valign="top">GradientActiveTitle</td>
<td valign="top">00-00-80</td></tr>
<tr><td valign="top">COLOR_GRADIENTINACTIVECAPTION</td>
<td valign="top">GradientInactiveTitle</td>
<td valign="top">80-80-80</td></tr>
</TABLE>

<p>Default values for these 29 colors are provided by the display driver, and they might be a little different on different machines.

<p>Now for the bad news: Although many of these colors seem self-explanatory (for example, COLOR_BACKGROUND is the color of the desktop area behind all the windows), the use of system colors in recent versions of Windows has become quite chaotic. Back in the old days, Windows was visually much simpler than it is today. Indeed, prior to Windows 3.0, only the first 13 system colors shown above were defined. With the increased use of more visually complex controls using three-dimensional appearances, more system colors were needed.

<A NAME="249"><h2>The Button Colors</h2></A>
<p>This problem is particularly evident for buttons, each of which requires multiple colors. COLOR_BTNFACE is used for the main surface color of the push buttons and the background color of the others. (This is also the system color used for dialog boxes and message boxes.) COLOR_BTNSHADOW is used for suggesting a shadow at the right and bottom sides of the push buttons and the insides of the checkbox squares and radio button circles. For push buttons, COLOR_BTNTEXT is used for the text color; for the others it's COLOR_WINDOWTEXT. Several other system colors are also used for various parts of the button designs.

<p>So if we want to display buttons on the surface of our client area, one way to avoid the color clash is to yield to these system colors. To begin, you use COLOR_BTNFACE for the background of your client area when defining the window class:

<p><pre>
wndclass.hbrBackground = (HBRUSH) (COLOR_BTNFACE + 1) ;
</PRE>

<p>You can try this in the BTNLOOK program. Windows understands that when the value of <I>hbrBackground</I> in the WNDCLASS structure is this low in value, it actually refers to a system color rather than an actual handle. Windows requires that you add 1 when you use these identifiers and are specifying them in the <I>hbrBackground</I> field of the WNDCLASS structure, but doing so has no profound purpose other than to prevent the value from being NULL. If the system color happens to be changed while your program is running, the surface of your client area will be invalidated and Windows will use the new COLOR_BTNFACE value. But now we've caused another problem. When you display text using <I>TextOut</I>, Windows uses values defined in the device context for the text background color (which erases the background behind the text) and the text color. The default values are white (background) and black (text), regardless of either the system colors or the <I>hbrBackground</I> field of the window class structure. So you need to use <I>SetTextColor</I> and <I>SetBkColor</I> to change your text and text background colors to the system colors. You do this after you obtain the handle to a device context:

<p><pre>
SetBkColor (hdc, GetSysColor (COLOR_BTNFACE)) ;
SetTextColor (hdc, GetSysColor (COLOR_WINDOWTEXT)) ;
</PRE>

<p>Now the client-area background, text background, and text color are all consistent with the button colors. However, if the user changes the system colors while your program is running, you'll want to change the text background color and text color. You can do this using the following code:

<p><pre>
case WM_SYSCOLORCHANGE:
     InvalidateRect (hwnd, NULL, TRUE) ;
     break ;
</PRE>



<A NAME="250"><h2>The WM_CTLCOLORBTN Message</h2></A>
<p>We've seen how we can adjust our client area color and text color to the background colors of the buttons. Can we adjust the colors of the buttons to the colors we prefer in our program? Well, in theory, yes, but in practice, no. What you probably don't want to do is use <I>SetSysColors</I> to change the appearance of the buttons. This will affect all programs currently running under Windows; it's something users would not appreciate very much.

<p>A better approach (again, in theory) is to process the WM_CTLCOLORBTN message. This is a message that button controls send to the parent window procedure when the child window is about to paint its client area. The parent window can use this opportunity to alter the colors that the child window procedure will use for painting. (In 16-bit versions of Windows, a message named WM_CTLCOLOR was used for all controls. This has been replaced with separate messages for each type of standard control.)

<p>When the parent window procedure receives a WM_CTLCOLORBTN message, the <I>wParam</I> message parameter is the handle to the button's device context and <I>lParam</I> is the button's window handle. When the parent window procedure gets this message, the button control has already obtained its device context. When processing a WM_CTLCOLORBTN message in your window procedure, you:

<p><ul>

<li> Optionally set a text color using <I>SetTextColor</I>

<p><li> Optionally set a text background color using <I>SetBkColor</I>

<p><li> Return a brush handle to the child window
</UL>

<p>In theory, the child window uses the brush for coloring a background. It is your responsibility to destroy the brush when it is no longer needed.

<p>Here's the problem with WM_CTLCOLORBTN: Only the push buttons and owner-draw buttons send WM_CTLCOLORBTN to their parent windows, and only owner-draw buttons respond to the parent window processing of the message using the brush for coloring the background. This is fairly useless because the parent window is responsible for drawing owner-draw buttons anyway.

<p>Later on in this chapter, we'll examine cases in which messages similar to WM_CTLCOLORBTN but applying to other types of controls are more useful.

<A NAME="251"><h2>Owner-Draw Buttons</h2></A>
<p>If you want to have total control over the visual appearance of a button but don't want to bother with keyboard and mouse logic, you can create a button with the BS_OWNERDRAW style. This is demonstrated in the OWNDRAW program shown in Figure 9-3.



<p><B>Figure 9-3.</B> <I>The OWNDRAW program.</I>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="252"><H3>OWNDRAW.C</H3></A>
<p><pre>
/*----------------------------------------
   OWNDRAW.C -- Owner-Draw Button Demo Program
                (c) Charles Petzold, 1996
  ----------------------------------------*/

#include &lt;windows.h&gt;

#define ID_SMALLER      1
#define ID_LARGER       2
#define BTN_WIDTH        (8 * cxChar)
#define BTN_HEIGHT       (4 * cyChar)

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

HINSTANCE hInst ;
int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;OwnDraw&quot;) ;
     MSG          msg ;
     HWND         hwnd ;
     WNDCLASS     wndclass ;
     
     hInst = hInstance ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = szAppName ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Owner-Draw Button Demo&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ; 
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

void Triangle (HDC hdc, POINT pt[])
{
     SelectObject (hdc, GetStockObject (BLACK_BRUSH)) ;
     Polygon (hdc, pt, 3) ;
     SelectObject (hdc, GetStockObject (WHITE_BRUSH)) ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HWND      hwndSmaller, hwndLarger ;
     static int       cxClient, cyClient, cxChar, cyChar ;
     int              cx, cy ;
     LPDRAWITEMSTRUCT pdis ;
     POINT            pt[3] ;
     RECT             rc ;
     
     switch (message)
     {
     case WM_CREATE :
          cxChar = LOWORD (GetDialogBaseUnits ()) ;
          cyChar = HIWORD (GetDialogBaseUnits ()) ;
          
               // Create the owner-draw pushbuttons
          
          hwndSmaller = CreateWindow (TEXT (&quot;button&quot;), TEXT (&quot;&quot;),
                                      WS_CHILD | WS_VISIBLE | BS_OWNERDRAW,
                                      0, 0, BTN_WIDTH, BTN_HEIGHT,
                                      hwnd, (HMENU) ID_SMALLER, hInst, NULL) ;
          
          hwndLarger  = CreateWindow (TEXT (&quot;button&quot;), TEXT (&quot;&quot;),
                                      WS_CHILD | WS_VISIBLE | BS_OWNERDRAW,
                                      0, 0, BTN_WIDTH, BTN_HEIGHT,
                                      hwnd, (HMENU) ID_LARGER, hInst, NULL) ;
          return 0 ;
          
     case WM_SIZE :
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;

               // Move the buttons to the new center
          
          MoveWindow (hwndSmaller, cxClient / 2 - 3 * BTN_WIDTH  / 2,
                                   cyClient / 2 -     BTN_HEIGHT / 2,
                      BTN_WIDTH, BTN_HEIGHT, TRUE) ;
          MoveWindow (hwndLarger,  cxClient / 2 +     BTN_WIDTH  / 2,
                                   cyClient / 2 -     BTN_HEIGHT / 2,
                      BTN_WIDTH, BTN_HEIGHT, TRUE) ;
          return 0 ;
          
     case WM_COMMAND :
          GetWindowRect (hwnd, &amp;rc) ;
          
               // Make the window 10% smaller or larger
          
          switch (wParam)
          {
          case ID_SMALLER :
               rc.left   += cxClient / 20 ;
               rc.right  -= cxClient / 20 ;
               rc.top    += cyClient / 20 ;
               rc.bottom -= cyClient / 20 ;
               break ;
               
          case ID_LARGER :
               rc.left   -= cxClient / 20 ;
               rc.right  += cxClient / 20 ;
               rc.top    -= cyClient / 20 ;
               rc.bottom += cyClient / 20 ;
               break ;
          }
          
          MoveWindow (hwnd, rc.left, rc.top, rc.right  - rc.left,
                            rc.bottom - rc.top, TRUE) ;
          return 0 ;
          
     case WM_DRAWITEM :
          pdis = (LPDRAWITEMSTRUCT) lParam ;
               
               // Fill area with white and frame it black
               
          FillRect (pdis-&gt;hDC, &amp;pdis-&gt;rcItem,
                    (HBRUSH) GetStockObject (WHITE_BRUSH)) ;
               
          FrameRect (pdis-&gt;hDC, &amp;pdis-&gt;rcItem,
                     (HBRUSH) GetStockObject (BLACK_BRUSH)) ;

               // Draw inward and outward black triangles
          cx = pdis-&gt;rcItem.right  - pdis-&gt;rcItem.left ;
          cy = pdis-&gt;rcItem.bottom - pdis-&gt;rcItem.top  ;

          switch (pdis-&gt;CtlID)
          {
          case ID_SMALLER :
               pt[0].x = 3 * cx / 8 ;  pt[0].y = 1 * cy / 8 ;
               pt[1].x = 5 * cx / 8 ;  pt[1].y = 1 * cy / 8 ;
               pt[2].x = 4 * cx / 8 ;  pt[2].y = 3 * cy / 8 ;
                    
               Triangle (pdis-&gt;hDC, pt) ;
                    
               pt[0].x = 7 * cx / 8 ;  pt[0].y = 3 * cy / 8 ;
               pt[1].x = 7 * cx / 8 ;  pt[1].y = 5 * cy / 8 ;
               pt[2].x = 5 * cx / 8 ;  pt[2].y = 4 * cy / 8 ;
                    
               Triangle (pdis-&gt;hDC, pt) ;
                    
               pt[0].x = 5 * cx / 8 ;  pt[0].y = 7 * cy / 8 ;
               pt[1].x = 3 * cx / 8 ;  pt[1].y = 7 * cy / 8 ;
               pt[2].x = 4 * cx / 8 ;  pt[2].y = 5 * cy / 8 ;
                    
               Triangle (pdis-&gt;hDC, pt) ;
                    
               pt[0].x = 1 * cx / 8 ;  pt[0].y = 5 * cy / 8 ;
               pt[1].x = 1 * cx / 8 ;  pt[1].y = 3 * cy / 8 ;
               pt[2].x = 3 * cx / 8 ;  pt[2].y = 4 * cy / 8 ;
                    
               Triangle (pdis-&gt;hDC, pt) ;
               break ;
                    
          case ID_LARGER :
               pt[0].x = 5 * cx / 8 ;  pt[0].y = 3 * cy / 8 ;
               pt[1].x = 3 * cx / 8 ;  pt[1].y = 3 * cy / 8 ;
               pt[2].x = 4 * cx / 8 ;  pt[2].y = 1 * cy / 8 ;
                    
               Triangle (pdis-&gt;hDC, pt) ;
                    
               pt[0].x = 5 * cx / 8 ;  pt[0].y = 5 * cy / 8 ;
               pt[1].x = 5 * cx / 8 ;  pt[1].y = 3 * cy / 8 ;
               pt[2].x = 7 * cx / 8 ;  pt[2].y = 4 * cy / 8 ;
                    
               Triangle (pdis-&gt;hDC, pt) ;
               pt[0].x = 3 * cx / 8 ;  pt[0].y = 5 * cy / 8 ;
               pt[1].x = 5 * cx / 8 ;  pt[1].y = 5 * cy / 8 ;
               pt[2].x = 4 * cx / 8 ;  pt[2].y = 7 * cy / 8 ;
                    
               Triangle (pdis-&gt;hDC, pt) ;
               pt[0].x = 3 * cx / 8 ;  pt[0].y = 3 * cy / 8 ;
               pt[1].x = 3 * cx / 8 ;  pt[1].y = 5 * cy / 8 ;
               pt[2].x = 1 * cx / 8 ;  pt[2].y = 4 * cy / 8 ;
                    
               Triangle (pdis-&gt;hDC, pt) ;
               break ;
          }
               
               // Invert the rectangle if the button is selected
               
          if (pdis-&gt;itemState &amp; ODS_SELECTED)
               InvertRect (pdis-&gt;hDC, &amp;pdis-&gt;rcItem) ;
               
               // Draw a focus rectangle if the button has the focus
               
          if (pdis-&gt;itemState &amp; ODS_FOCUS)
          {
               pdis-&gt;rcItem.left   += cx / 16 ;
               pdis-&gt;rcItem.top    += cy / 16 ;
               pdis-&gt;rcItem.right  -= cx / 16 ;
               pdis-&gt;rcItem.bottom -= cy / 16 ;
                    
               DrawFocusRect (pdis-&gt;hDC, &amp;pdis-&gt;rcItem) ;
          }
          return 0 ;
               
     case WM_DESTROY :
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</TD></TR></TABLE> 

<p>This program contains two buttons in the center of its client area, as shown in Figure 9-4. The button on the left has four triangles pointing to the center of the button. Clicking the button decreases the size of the window by 10 percent. The button on the right has four triangles pointing outward, and clicking this button increases the window size by 10 percent.

<p>If you need to display only an icon or a bitmap in the button, you can use the BS_ICON or BS_BITMAP style and set the bitmap using the BM_SETIMAGE message. The BS_OWNERDRAW button style, however, allows complete freedom in drawing the button.

<p><A HREF="javascript:fullSize('F09zg04x.htm')"> <img src="F09zg04.JPG" width=404 height=285 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 9-4.</B> <I>The OWNDRAW display.</I><!-- /caption -->

<p>During the WM_CREATE message, OWNDRAW creates two buttons with the BS_OWNERDRAW style; the buttons are given a width of eight times the system font and four times the system font height. (When using predefined bitmaps to draw buttons, it's useful to know that these dimensions create buttons that are 64 by 64 pixels on a VGA.) The buttons are not yet positioned. During the WM_SIZE message, OWNDRAW positions the buttons in the center of the client area by calling <I>MoveWindow</I>.

<p>Clicking on the buttons causes them to generate WM_COMMAND messages. To process the WM_COMMAND message, OWNDRAW calls <I>GetWindowRect</I> to store the position and size of the entire window (not only the client area) in a RECT (rectangle) structure. This position is relative to the screen. OWNDRAW then adjusts the fields of this rectangle structure depending on whether the left or right button was clicked. Then the program repositions and resizes the window by calling <I>MoveWindow</I>. This generates another WM_SIZE message, and the buttons are repositioned in the center of the client area.

<p>If this were all the program did, it would be entirely functional but the buttons would not be visible. A button created with the BS_OWNERDRAW style sends its parent window a WM_DRAWITEM message whenever the button needs to be repainted. This occurs when the button is first created, when it is pressed or released, when it gains or loses the input focus, and whenever else it needs repainting.

<p>During the WM_DRAWITEM message, the <I>lParam</I> message parameter is a pointer to a structure of type DRAWITEMSTRUCT. The OWNDRAW program stores this pointer in a variable named <I>pdis</I>. This structure contains the information necessary for a program to draw the button. (The same structure is also used for owner-draw list boxes and menu items.) The structure fields important for working with buttons are <I>hDC</I> (the device context for the button), <I>rcItem</I> (a RECT structure providing the size of the button), <I>CtlID</I> (the control window ID), and <I>itemState</I> (which indicates whether the button is pushed or has the input focus).

<p>OWNDRAW begins WM_DRAWITEM processing by calling <I>FillRect</I> to erase the surface of the button with a white brush and <I>FrameRect</I> to draw a black frame around the button. Then OWNDRAW draws four black-filled triangles on the button by calling <I>Polygon</I>. That's the normal case.

<p>If the button is currently being pressed, a bit of the <I>itemState</I> field of the DRAWITEMSTRUCT will be set. You can test this bit using the ODS_SELECTED constant. If the bit is set, OWNDRAW inverts the colors of the button by calling <I>InvertRect</I>. If the button has the input focus, the ODS_FOCUS bit of the <I>itemState</I> field will be set. In this case, OWNDRAW draws a dotted rectangle just inside the periphery of the button by calling <I>DrawFocusRect</I>.

<p>A word of warning when using owner-draw buttons: Windows obtains a device context for you and includes it as a field of the DRAWITEMSTRUCT structure. Leave the device context in the same state you found it. Any GDI objects selected into the device context must be unselected. Also, be careful not to draw outside the rectangle defining the boundaries of the button.

</BODY>
</HTML>






