<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Nonclient-Area Mouse Messages</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="191"><h1>Nonclient-Area Mouse Messages</h1></A>
<p>The 10 mouse messages discussed so far occur when the mouse is moved or clicked within the client area of a window. If the mouse is outside a window's client area but within the window, Windows sends the window procedure a &quot;nonclient-area&quot; mouse message. The nonclient area of a window includes the title bar, the menu, and the window scroll bars.

<p>You do not usually need to process nonclient-area mouse messages. Instead, you simply pass them on to <I>DefWindowProc</I> so that Windows can perform system functions. In this respect, the nonclient-area mouse messages are similar to the system keyboard messages WM_SYSKEYDOWN, WM_SYSKEYUP, and WM_SYSCHAR.

<p>The nonclient-area mouse messages parallel almost exactly the client-area mouse messages. The message identifiers include the letters &quot;NC&quot; to indicate &quot;nonclient.&quot; If the mouse is moved within a nonclient area of a window, the window procedure receives the message WM_NCMOUSEMOVE. The mouse buttons generate these messages:

<table CELLPADDING=5 WIDTH="95%"><TR>
<TD VALIGN="TOP"><B><I>Button</I></B></TD>
<TD VALIGN="TOP"><B><I>Pressed</I></B></TD>
<TD VALIGN="TOP"><B><I>Released</I></B></TD>
<TD VALIGN="TOP"><B><I>Pressed (Second Click)</I></B></TD>
</TR>
<TR>
<TD VALIGN="TOP">Left</TD>
<TD VALIGN="TOP">WM_NCLBUTTONDOWN</TD>
<TD VALIGN="TOP">WM_NCLBUTTONUP</TD>
<TD VALIGN="TOP">WM_NCLBUTTONDBLCLK</TD>
</TR>
<TR>
<TD VALIGN="TOP">Middle</TD>
<TD VALIGN="TOP">WM_NCMBUTTONDOWN</TD>
<TD VALIGN="TOP">WM_NCMBUTTONUP</TD>
<TD VALIGN="TOP">WM_NCMBUTTONDBLCLK</TD>
</TR>
<TR>
<TD VALIGN="TOP">Right</TD>
<TD VALIGN="TOP">WM_NCRBUTTONDOWN</TD>
<TD VALIGN="TOP">WM_NCRBUTTONUP</TD>             
<TD VALIGN="TOP">WM_NCRBUTTONDBLCLK</TD>
</TR>
</table>               

<p>The <I>wParam</I> and <I>lParam</I> parameters for nonclient-area mouse messages are somewhat different from those for client-area mouse messages. The <I>wParam</I> parameter indicates the nonclient area where the mouse was moved or clicked. It is set to one of the identifiers beginning with HT (standing for &quot;hit-test&quot;) that are defined in the WINUSER.H.

<p>The <I>lParam</I> parameter contains an <I>x</I>-coordinate in the low word and a <I>y</I>-coordinate in the high word. However, these are screen coordinates, not client-area coordinates as they are for client-area mouse messages. For screen coordinates, the upper-left corner of the display area has <I>x</I> and <I>y</I> values of 0. Values of <I>x</I> increase as you move to the right, and values of <I>y</I> increase as you move down the screen. (See Figure 7-3.)

<p>You can convert screen coordinates to client-area coordinates and vice versa with these two Windows functions:

<p><pre>
ScreenToClient (hwnd, &amp;pt) ;
ClientToScreen (hwnd, &amp;pt) ;
</PRE>

<p>where <I>pt</I> is a POINT structure. These two functions convert the values stored in the structure without preserving the old values. Note that if a screen-coordinate point is above or to the left of the window's client area, the <I>x</I> or <I>y </I>value of the client-area coordinate could be negative.

<p><A HREF="javascript:fullSize('F07zg03x.htm')"> <img src="F07zg03.JPG" width=404 height=329 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 7-3.</B> <I>Screen coordinates and client-area coordinates.</I><!-- /caption -->

<A NAME="192"><h2>The Hit-Test Message</h2></A>
<p>If you've been keeping count, you know that so far we've covered 20 of the 21 mouse messages. The last message is WM_NCHITTEST, which stands for &quot;nonclient hit test.&quot; This message precedes all other client-area and nonclient-area mouse messages. The <I>lParam</I> parameter contains the <I>x</I> and <I>y</I> screen coordinates of the mouse position. The <I>wParam</I> parameter is not used.

<p>Windows applications generally pass this message to <I>DefWindowProc</I>. Windows then uses the WM_NCHITTEST message to generate all other mouse messages based on the position of the mouse. For nonclient-area mouse messages, the value returned from <I>DefWindowProc</I> when processing WM_NCHITTEST becomes the <I>wParam</I> parameter in the mouse message. This value can be any of the <I>wParam</I> values that accompany the nonclient-area mouse messages plus the following:

<p><pre>
HTCLIENT        Client area
HTNOWHERE       Not on any window
HTTRANSPARENT   A window covered by another window
HTERROR         Causes <I>DefWindowProc</I> to produce a beep
</PRE>

<p>If <I>DefWindowProc</I> returns HTCLIENT after it processes a WM_NCHITTEST message, Windows converts the screen coordinates to client-area coordinates and generates a client-area mouse message.

<p>If you remember how we disabled all system keyboard functions by trapping the WM_SYSKEYDOWN message, you may wonder if you can do something similar by trapping mouse messages. Sure! If you include the lines

<p><pre>
case WM_NCHITTEST:
     return (LRESULT) HTNOWHERE ;
</PRE>

<p>in your window procedure, you will effectively disable all client-area and nonclient-area mouse messages to your window. The mouse buttons will simply not work while the mouse is anywhere within your window, including the system menu icon, the sizing buttons, and the close button.

<A NAME="193"><h2>Messages Beget Messages</h2></A>
<p>Windows uses the WM_NCHITTEST message to generate all other mouse messages. The idea of messages giving birth to other messages is common in Windows. Let's take an example. As you may know, if you double-click the system menu icon of a Windows program, the window will be terminated. The double-click generates a series of WM_NCHITTEST messages. Because the mouse is positioned over the system menu icon, <I>DefWindowProc</I> returns a value of HTSYSMENU and Windows puts a WM_NCLBUTTONDBLCLK message in the message queue with <I>wParam</I> equal to HTSYSMENU.

<p>The window procedure usually passes that mouse message to <I>DefWindowProc</I>. When <I>DefWindowProc</I> receives the WM_NCLBUTTONDBLCLK message with <I>wParam</I> equal to HTSYSMENU, it puts a WM_SYSCOMMAND message with <I>wParam</I> equal to SC_CLOSE in the message queue. (This WM_SYSCOMMAND message is also generated when a user selects Close from the system menu.) Again the window procedure usually passes that message to <I>DefWindowProc</I>. <I>DefWindowProc</I> processes the message by sending a WM_CLOSE message to the window procedure.

<p>If the program wants to require confirmation from a user before terminating, the window procedure can trap WM_CLOSE. Otherwise, <I>DefWindowProc</I> processes WM_CLOSE by calling the <I>DestroyWindow</I> function. Among other chores, <I>DestroyWindow</I> sends a WM_DESTROY message to the window procedure. Normally, a window procedure processes WM_DESTROY with the code

<p><pre>
case WM_DESTROY:
     PostQuitMessage (0) ;
     return 0 ;
</PRE>

<p>The <I>PostQuitMessage</I> causes Windows to place a WM_QUIT message in the message queue. This message never reaches the window procedure because it causes <I>GetMessage</I> to return 0, which terminates the message loop and the program.

</BODY>
</HTML>






