<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Drawing Dots and Lines</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="109"><h1>Drawing Dots and Lines</h1></A>
<p>In the first chapter, I discussed how the Windows Graphics Device Interface makes use of device drivers for the graphics output devices attached to your computer. In theory, all that a graphics device driver needs for drawing is a <I>SetPixel</I> function and a <I>GetPixel</I> function. Everything else could be handled with higher-level routines implemented in the GDI module. Drawing a line, for instance, simply requires that GDI call the <I>SetPixel</I> routine numerous times, adjusting the x- and y-coordinates appropriately.

<p>In reality, you can indeed do almost any drawing you need with only <I>SetPixel</I> and <I>GetPixel</I> functions. You can also design a neat and well-structured graphics programming system on top of these functions. The only problem is performance. A function that is several calls away from each <I>SetPixel</I> function will be painfully slow. It is much more efficient for a graphics system to do line drawing and other complex graphics operations at the level of the device driver, which can have its own optimized code to perform the operations. Moreover, some video adapter boards contain graphics coprocessors that allow the video hardware itself to draw the figures.

<A NAME="110"><h2>Setting Pixels</h2></A>
<p>Even though the Windows GPI includes <I>SetPixel</I> and <I>GetPixel</I> functions, they are not commonly used. In this book, the only use of the <I>SetPixel</I> function is in the CONNECT program in <a href="ch07a.htm#182">Chapter 7</a>, and the only use of <I>GetPixel</I> is in the WHATCLR program in <a href="ch08a.htm#215">Chapter 8</a>. Still, they provide a convenient place to begin examining graphics.

<p>The <I>SetPixel</I> function sets the pixel at a specified x- and y-coordinate to a particular color:

<p><pre>
SetPixel (hdc, x, y, crColor) ;
</pre>

<p>As in any drawing function, the first argument is a handle to a device context. The second and third arguments indicate the coordinate position. Mostly you'll obtain a device context for the client area of your window, and <I>x</I> and <I>y</I> will be relative to the upper left corner of that client area. The final argument is of type COLORREF to specify the color. If the color you specify in the function cannot be realized on the video display, the function sets the pixel to the nearest pure nondithered color and returns that value from the function.

<p>The <I>GetPixel</I> function returns the color of the pixel at the specified coordinate position:

<p><pre>
crColor = GetPixel (hdc, x, y) ;
</pre>

<A NAME="111"><h2>Straight Lines</h2></A>
<p>Windows can draw straight lines, elliptical lines (curved lines on the circumference of an ellipse), and Bezier splines. Windows 98 supports seven functions that draw lines:

<p><ul>

<p><li><I>LineTo</I> Draws a straight line.

<p><li><I>Polyline</I> <I>and PolylineTo</I> Draw a series of connected straight lines.

<p><li><I>PolyPolyline</I> Draws multiple polylines.

<p><li><I>Arc</I> Draws elliptical lines.

<p><li><I>PolyBezier</I> <I>and PolyBezierTo</I> Draw Bezier splines.
</ul>

<p>In addition, Windows NT supports three more line-drawing functions:

<p><ul>

<p><li><I>ArcTo and AngleArc</I> Draw elliptical lines.

<p><li><I>PolyDraw</I> Draws a series of connected straight lines and Bezier splines.
</ul>

<p>These three functions are not supported under Windows 98.

<p>Later in this chapter I'll also be discussing some functions that draw lines but that also fill the enclosed area within the figure they draw. These functions are

<p><ul>

<p><li><I>Rectangle</I> Draws a rectangle.

<p><li><I>Ellipse</I> Draws an ellipse.

<p><li><I>RoundRect</I> Draws a rectangle with rounded corners.

<p><li><I>Pie</I> Draws a part of an ellipse that looks like a pie slice.

<p><li><I>Chord</I> Draws part of an ellipse formed by a chord.
</ul>

<p>Five attributes of the device context affect the appearance of lines that you draw using these functions: current pen position (for <I>LineTo</I>, <I>PolylineTo</I>, <I>PolyBezierTo</I>, and <I>ArcTo</I> only), pen, background mode, background color, and drawing mode.

<p>To draw a straight line, you must call two functions. The first function specifies the point at which the line begins, and the second function specifies the end point of the line:

<p><pre>
MoveToEx (hdc, xBeg, yBeg, NULL) ;
LineTo (hdc, xEnd, yEnd) ;
</pre>

<p><I>MoveToEx</I> doesn't actually draw anything; instead, it sets the attribute of the device context known as the &quot;current position.&quot; The <I>LineTo</I> function then draws a straight line from the current position to the point specified in the <I>LineTo</I> function. The current position is simply a starting point for several other GDI functions. In the default device context, the current position is initially set to the point (0, 0). If you call <I>LineTo</I> without first setting the current position, it draws a line starting at the upper left corner of the client area.

<p>A brief historical note: In the 16-bit versions of Windows, the function to set the current position was <I>MoveTo</I>. This function had just three arguments&#8212;the device context handle and x- and y-coordinates. The function returned the previous current position packed as two 16-bit values in a 32-bit unsigned long. However, in the 32-bit versions of Windows, coordinates are 32-bit values. Because the 32-bit versions of C do not define a 64-bit integral data type, this change meant that <I>MoveTo</I> could no longer indicate the previous current position in its return value. Although the return value from <I>MoveTo</I> was almost never used in real-life programming, a new function was required, and this was <I>MoveToEx</I>.

<p>The last argument to <I>MoveToEx</I> is a pointer to a POINT structure. On return from the function, the <I>x</I> and <I>y</I> fields of the POINT structure will indicate the previous current position. If you don't need this information (which is almost always the case), you can simply set the last argument to NULL as in the example shown above.

<p>And now the caveat: Although coordinate values in Windows 98 appear to be 32-bit values, only the lower 16 bits are used. Coordinate values are effectively restricted to -32,768 to 32,767. In Windows NT, the full 32-bit values are used.

<p>If you ever need the current position, you can obtain it by calling

<p><pre>
GetCurrentPositionEx (hdc, &amp;pt) ;
</pre>

<p>where <I>pt</I> is a POINT structure.

<p>The following code draws a grid in the client area of a window, spacing the lines 100 pixels apart starting from the upper left corner. The variable <I>hwnd</I> is assumed to be a handle to the window, <I>hdc</I> is a handle to the device context, and <I>x</I> and <I>y</I> are integers:

<p><pre>
GetClientRect (hwnd, &amp;rect) ;
for (x = 0 ; x &lt; rect.right ; x+= 100)
{
     MoveToEx (hdc, x, 0, NULL) ;
     LineTo (hdc, x, rect.bottom) ;
}
for (y = 0 ; y &lt; rect.bottom ; y += 100)
{
     MoveToEx (hdc, 0, y, NULL) ;
     LineTo (hdc, rect.right, y) ;
}
</pre>

<p>Although it seems like a nuisance to be forced to use two functions to draw a single line, the current position comes in handy when you want to draw a series of connected lines. For instance, you might want to define an array of 5 points (10 values) that define the outline of a rectangle:

<p><pre>
POINT apt[5] = { 100, 100, 200, 100, 200, 200, 100, 200, 100, 100 } ;
</pre>

<p>Notice that the last point is the same as the first. Now you need only use <I>MoveToEx</I> for the first point and <I>LineTo</I> for the successive points:

<p><pre>
MoveToEx (hdc, apt[0].x, apt[0].y, NULL) ;

for (i = 1 ; i &lt; 5 ; i++)
     LineTo (hdc, apt[i].x, apt[i].y) ;
</pre>

<p>Because <I>LineTo</I> draws from the current position up to (but not including) the point in the <I>LineTo</I> function, no coordinate gets written twice by this code. While overwriting points is not a problem with a video display, it might not look good on a plotter or with some drawing modes that I'll discuss later in this chapter.

<p>When you have an array of points that you want connected with lines, you can draw the lines more easily using the <I>Polyline</I> function. This statement draws the same rectangle as in the code shown above:

<p><pre>
Polyline (hdc, apt, 5) ;
</pre>

<p>The last argument is the number of points. We could also have represented this value by <I>sizeof (apt) / sizeof (POINT)</I>. <I>Polyline</I> has the same effect on drawing as an initial <I>MoveToEx</I> followed by multiple <I>LineTo</I> functions. However, <I>Polyline</I> doesn't use or change the current position. <I>PolylineTo</I> is a little different. This function uses the current position for the starting point and sets the current position to the end of the last line drawn. The code below draws the same rectangle as that last shown above:

<p><pre>
MoveToEx (hdc, apt[0].x, apt[0].y, NULL) ;
PolylineTo (hdc, apt + 1, 4) ;
</pre>

<p>Although you can use <I>Polyline</I> and <I>PolylineTo</I> to draw just a few lines, the functions are most useful when you need to draw a complex curve. You do this by using hundreds or even thousands of very short lines. If they're short enough and there are enough of them, together they'll look like a curve. For example, suppose you need to draw a sine wave. The SINEWAVE program in Figure 5-6 shows how to do it.


<p><B>Figure 5-6.</B> <I>The SINEWAVE program.</I>
<table width="95%" cellpadding="5" valign="TOP">
<tr><td valign=top><A NAME="112"><h3>SINEWAVE.C</h3></A>
<p><pre>
/*-----------------------------------------
   SINEWAVE.C -- Sine Wave Using Polyline
                 (c) Charles Petzold, 1998
  -----------------------------------------*/

#include &lt;windows.h&gt;
#include &lt;math.h&gt;

#define NUM    1000
#define TWOPI  (2 * 3.14159)

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;SineWave&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
          
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;Program requires Windows NT!&quot;), 
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Sine Wave Using Polyline&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static int  cxClient, cyClient ;
     HDC         hdc ;
     int         i ;
     PAINTSTRUCT ps ;
     POINT       apt [NUM] ;
     
     switch (message)
     {
     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;
          
     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
          
          MoveToEx (hdc, 0,        cyClient / 2, NULL) ;
          LineTo   (hdc, cxClient, cyClient / 2) ;
          
          for (i = 0 ; i &lt; NUM ; i++)
          {
               apt[i].x = i * cxClient / NUM ;
               apt[i].y = (int) (cyClient / 2 * (1 - sin (TWOPI * i / NUM))) ;
          }
          
          Polyline (hdc, apt, NUM) ;
          return 0 ;
          
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</PRE></td></tr></table>

<p>The program has an array of 1000 POINT structures. As the <I>for</I> loop is incremented from 0 through 999, the <I>x</I> fields of the POINT structure are set to incrementally increasing values from 0 to <I>cxClient</I>. The program sets the <I>y</I> fields of the POINT structure to sine curve values for one cycle and enlarged to fill the client area. The whole curve is drawn using a single <I>Polyline</I> call. Because the <I>Polyline</I> function is implemented at the device driver level, it is faster than calling <I>LineTo</I> 1000 times. The results are shown in Figure 5-7.

<p><img src="F05zg07.JPG" width=404 height=284 ALIGN="BOTTOM">

<p><!-- caption --><B>Figure 5-7.</B> <I>The SINEWAVE display.</I><!-- /caption -->

<A NAME="113"><h2>The Bounding Box Functions</h2></A>
<p>I next want to discuss the <I>Arc</I> function, which draws an elliptical curve. However, the <I>Arc</I> function does not make much sense without first discussing the <I>Ellipse</I> function, and the <I>Ellipse</I> function doesn't make much sense without first discussing the <I>Rectangle</I> function, and if I discuss <I>Ellipse</I> and <I>Rectangle</I>, I might as well discuss <I>RoundRect</I>, <I>Chord</I>, and <I>Pie</I>.

<p>The problem is that the <I>Rectangle</I>, <I>Ellipse</I>, <I>RoundRect</I>, <I>Chord</I>, and <I>Pie</I> functions are not strictly line-drawing functions. Yes, the functions draw lines, but they also fill an enclosed area with the current area-filling brush. This brush is solid white by default, so it may not be obvious that these functions do more than draw lines when you first begin experimenting with them. The functions really belong in the later section &quot;<A HREF="ch05e.htm#121">Drawing Filled Areas</A>&quot;, but I'll discuss them here regardless.

<p>The functions I've listed above are all similar in that they are built up from a rectangular &quot;bounding box.&quot; You define the coordinates of a box that encloses the object&#8212;the bounding box&#8212;and Windows draws the object within this box.

<p>The simplest of these functions draws a rectangle:

<p><pre>
Rectangle (hdc, xLeft, yTop, xRight, yBottom) ;
</pre>

<p>The point (<I>xLeft</I>, <I>yTop</I>) is the upper left corner of the rectangle, and (<I>xRight</I>, <I>yBottom</I>) is the lower right corner. A figure drawn using the <I>Rectangle</I> function is shown in Figure 5-8. The sides of the rectangle are always parallel to the horizontal and vertical sides of the display.

<p><img src="F05zg08.GIF" width=309 height=188 border="0">

<p><!-- caption --><B>Figure 5-8.</B> <I>A figure drawn using the </I>Rectangle<I> function.</I><!-- /caption -->

<p>Programmers who have experience with graphics programming are often familiar with &quot;off-by-one&quot; errors. Some graphics programming systems draw a figure to encompass the right and bottom coordinates, and some draw figures up to (but not including) the right and bottom coordinates. Windows uses the latter approach, but there's an easier way to think about it.

<p>Consider the function call

<p><pre>
Rectangle (hdc, 1, 1, 5, 4) ;
</pre>

<p>I mentioned above that Windows draws the figure within a &quot;bounding box.&quot; You can think of the display as a grid where each pixel is within a grid cell. The imaginary bounding box is drawn on the grid, and the rectangle is then drawn within this bounding box. Here's how the figure would be drawn:

<p><img src="G05zg01.GIF" width=239 height=211 border="0">

<p>The area separating the rectangle from the top and left of the client area is 1 pixel wide.

<p>As I mentioned earlier, <I>Rectangle</I> is not strictly just a line-drawing function. GDI also fills the enclosed area. However, because by default the area is filled with white, it might not be immediately obvious that GDI is filling the area.

<p>Once you know how to draw a rectangle, you also know how to draw an ellipse, because it uses the same arguments:

<p><pre>
Ellipse (hdc, xLeft, yTop, xRight, yBottom) ;
</pre>

<p>A figure drawn using the <I>Ellipse</I> function is shown (with the imaginary bounding box) in Figure 5-9.

<p><img src="F05zg09.jpg" width=309 height=188 border="0">

<p><!-- caption --><B>Figure 5-9.</B> <I>A figure drawn using the </I>Ellipse<I> function.</I><!-- /caption -->

<p>The function to draw rectangles with rounded corners uses the same bounding box as the <I>Rectangle</I> and <I>Ellipse</I> functions but includes two more arguments:

<p><pre>
RoundRect (hdc, xLeft, yTop, xRight, yBottom,
           xCornerEllipse, yCornerEllipse) ;
</pre>

<p>A figure drawn using this function is shown in Figure 5-10.

<p><img src="F05zg10.JPG" width=404 height=214 ALIGN="BOTTOM">

<p><!-- caption --><B>Figure 5-10.</B> <I>A figure drawn using the </I>RoundRect<I> function.</I><!-- /caption -->

<p>Windows uses a small ellipse to draw the rounded corners. The width of this ellipse is <I>xCornerEllipse</I>, and the height is <I>yCornerEllipse</I>. Imagine Windows splitting this small ellipse into four quadrants and using one quadrant for each of the four corners. The rounding of the corners is more pronounced for larger values of <I>xCornerEllipse</I> and <I>yCornerEllipse</I>. If <I>xCornerEllipse</I> is equal to the difference between <I>xLeft</I> and <I>xRight</I>, and <I>yCornerEllipse</I> is equal to the difference between <I>yTop</I> and <I>yBottom</I>, then the <I>RoundRect</I> function will draw an ellipse.

<p>The rounded rectangle in Figure 5-10 was drawn using corner ellipse dimensions calculated with the formulas below.

<p><pre>
xCornerEllipse = (xRight - xLeft) / 4 ;
yCornerEllipse = (yBottom- yTop) / 4 ;
</pre>

<p>This is an easy approach, but the results admittedly don't look quite right because the rounding of the corners is more pronounced along the larger rectangle dimension. To correct this problem, you'll probably want to make <I>xCornerEllipse</I> equal to <I>yCornerEllipse</I> in real dimensions.

<p>The <I>Arc</I>, <I>Chord</I>, and <I>Pie</I> functions all take identical arguments:

<p><pre>
Arc   (hdc, xLeft, yTop, xRight, yBottom, xStart, yStart, xEnd, yEnd) ;
Chord (hdc, xLeft, yTop, xRight, yBottom, xStart, yStart, xEnd, yEnd) ;
Pie   (hdc, xLeft, yTop, xRight, yBottom, xStart, yStart, xEnd, yEnd) ;
</pre>

<p>A line drawn using the <I>Arc</I> function is shown in Figure 5-11; figures drawn using the <I>Chord</I> and <I>Pie</I> functions are shown in Figures 5-12 and 5-13. Windows uses an imaginary line to connect (<I>xStart</I>, <I>yStart</I>) with the center of the ellipse. At the point at which that line intersects the ellipse, Windows begins drawing an arc in a counterclockwise direction around the circumference of the ellipse. Windows also uses an imaginary line to connect (<I>xEnd</I>, <I>yEnd</I>) with the center of the ellipse. At the point at which that line intersects the ellipse, Windows stops drawing the arc.

<p><img src="F05zg11.GIF" width=397 height=215 border="0">

<p><!-- caption --><B>Figure 5-11.</B> <I>A line drawn using the </I>Arc<I> function.</I><!-- /caption -->

<p><img src="F05zg12.jpg" width=397 height=215 border="0">

<p><!-- caption --><B>Figure 5-12.</B> <I>A figure drawn using the </I>Chord<I> function.</I><!-- /caption -->

<p><img src="F05zg13.jpg" width=397 height=215 border="0">

<p><!-- caption --><B>Figure 5-13.</B> <I>A figure drawn using the </I>Pie<I> function.</I><!-- /caption -->

<p>For the <I>Arc</I> function, Windows is now finished, because the arc is an elliptical line rather than a filled area. For the <I>Chord</I> function, Windows connects the endpoints of the arc. For the <I>Pie</I> function, Windows connects each endpoint of the arc with the center of the ellipse. The interiors of the chord and pie-wedge figures are filled with the current brush.

<p>You may wonder about this use of starting and ending positions in the <I>Arc</I>, <I>Chord</I>, and <I>Pie</I> functions. Why not simply specify starting and ending points on the circumference of the ellipse? Well, you can, but you would have to figure out what those points are. Windows' method gets the job done without requiring such precision.

<p>The LINEDEMO program shown in Figure 5-14 draws a rectangle, an ellipse, a rectangle with rounded corners, and two lines, but not in that order. The program demonstrates that these functions that define closed areas do indeed fill them, because the lines are hidden behind the ellipse. The results are shown in Figure 5-15.


<p><B>Figure 5-14.</B> <I>The LINEDEMO program.</I>
<table width="95%" cellpadding="5" valign="TOP"><tr><td valign=top>
<A NAME="114"><h3>LINEDEMO.C</h3></A>
<p><pre>/*--------------------------------------------------
   LINEDEMO.C -- Line-Drawing Demonstration Program
                 (c) Charles Petzold, 1998
  --------------------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;LineDemo&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;Program requires Windows NT!&quot;), 
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Line Demonstration&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static int  cxClient, cyClient ;
     HDC         hdc ;
     PAINTSTRUCT ps ;
     
     switch (message)
     {
     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;
          
     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
          
          Rectangle (hdc,     cxClient / 8,     cyClient / 8,
                     7 * cxClient / 8, 7 * cyClient / 8) ;
          
          MoveToEx  (hdc,        0,        0, NULL) ;
          LineTo    (hdc, cxClient, cyClient) ;
          
          MoveToEx  (hdc,        0, cyClient, NULL) ;
          LineTo    (hdc, cxClient,        0) ;
          
          Ellipse   (hdc,     cxClient / 8,     cyClient / 8,
                     7 * cxClient / 8, 7 * cyClient / 8) ;
          
          RoundRect (hdc,     cxClient / 4,     cyClient / 4,
                     3 * cxClient / 4, 3 * cyClient / 4,
                         cxClient / 4,     cyClient / 4) ;
          
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</PRE></td></tr></table>

<p><img src="F05zg15.JPG" width=404 height=285 ALIGN="BOTTOM">

<p><!-- caption --><B>Figure 5-15.</B> <I>The LINEDEMO display.</I><!-- /caption -->

<A NAME="115"><h2>Bezier Splines</h2></A>
<p>The word &quot;spline&quot; once referred to a piece of flexible wood, rubber, or metal used to draw curves on a piece of paper. For example, if you had some disparate graph points, and you wanted to draw a curve between them (either for interpolation or extrapolation), you'd first mark the points on a piece of graph paper. You'd then anchor a spline to the points and use a pencil to draw the curve along the spline as it bent around the points.

<p>Nowadays, of course, splines are mathematical formulas. They come in many different flavors, but the Bezier spline has become the most popular for computer graphics programming. It is a fairly recent addition to the arsenal of graphics tools available on the operating system level, and it comes from an unlikely source: In the 1960s, the Renault automobile company was switching over from a manual design of car bodies (which involved clay) to a computer-based design. Mathematical tools were required, and Pierre Bezier came up with a set of formulas that proved to be useful for this job.

<p>Since then, the two-dimensional form of the Bezier spline has shown itself to be the most useful curve (after the straight line and ellipse) for computer graphics. In PostScript, the Bezier spline is used for <I>all</I> curves&#8212;even elliptical lines are approximated from Beziers. Bezier curves are also used to define the character outlines of PostScript fonts. (TrueType uses a simpler and faster form of spline.)

<p>A single two-dimensional Bezier spline is defined by four points&#8212;two end points and two control points. The ends of the curve are anchored at the two end points. The control points act as &quot;magnets&quot; to pull the curve away from the straight line between the two end points. This is best illustrated by an interactive program, called BEZIER, which is shown in Figure 5-16.

<p><B>Figure 5-16.</B> <I>The BEZIER program.</I>
<table><tr><td valign=top>
<A NAME="116"><h3>BEZIER.C</h3></A>
<p><pre>/*---------------------------------------
   BEZIER.C -- Bezier Splines Demo
               (c) Charles Petzold, 1998
  ---------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;Bezier&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;Program requires Windows NT!&quot;), 
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Bezier Splines&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

void DrawBezier (HDC hdc, POINT apt[])
{
     PolyBezier (hdc, apt, 4) ;
     
     MoveToEx (hdc, apt[0].x, apt[0].y, NULL) ;
     LineTo   (hdc, apt[1].x, apt[1].y) ;
     
     MoveToEx (hdc, apt[2].x, apt[2].y, NULL) ;
     LineTo   (hdc, apt[3].x, apt[3].y) ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static POINT apt[4] ;
     HDC          hdc ;
     int          cxClient, cyClient ;
     PAINTSTRUCT  ps ;
     
     switch (message)
     {
     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          
          apt[0].x = cxClient / 4 ;
          apt[0].y = cyClient / 2 ;
          
          apt[1].x = cxClient / 2 ;
          apt[1].y = cyClient / 4 ;
          
          apt[2].x =     cxClient / 2 ;
          apt[2].y = 3 * cyClient / 4 ;
          
          apt[3].x = 3 * cxClient / 4 ;
          apt[3].y =     cyClient / 2 ;
          
          return 0 ;

     case WM_LBUTTONDOWN:
     case WM_RBUTTONDOWN:
     case WM_MOUSEMOVE:
          if (wParam &amp; MK_LBUTTON || wParam &amp; MK_RBUTTON)
          {
               hdc = GetDC (hwnd) ;
               
               SelectObject (hdc, GetStockObject (WHITE_PEN)) ;
               DrawBezier (hdc, apt) ;
               
               if (wParam &amp; MK_LBUTTON)
               {
                    apt[1].x = LOWORD (lParam) ;
                    apt[1].y = HIWORD (lParam) ;
               }
               
               if (wParam &amp; MK_RBUTTON)
               {
                    apt[2].x = LOWORD (lParam) ;
                    apt[2].y = HIWORD (lParam) ;
               }
               
               SelectObject (hdc, GetStockObject (BLACK_PEN)) ;
               DrawBezier (hdc, apt) ;
               ReleaseDC (hwnd, hdc) ;
          }
          return 0 ;
          
     case WM_PAINT:
          InvalidateRect (hwnd, NULL, TRUE) ;
          
          hdc = BeginPaint (hwnd, &amp;ps) ;
          
          DrawBezier (hdc, apt) ;
          
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</PRE></td></tr></table>

<p>Because this program uses some mouse processing logic that we won't learn about until <a href="ch07a.htm#182">Chapter 7</a>, I won't discuss its inner workings (which might be obvious nonetheless). Instead, you can use the program to experiment with manipulating Bezier splines. In this program, the two end points are set to be halfway down the client area, and &#188; and &#190; of the way across the client area. The two control points are manipulable, the first by pressing the left mouse button and moving the mouse, the second by pressing the right mouse button and moving the mouse. Figure 5-17 shows a typical display.

<p>Aside from the Bezier spline itself, the program also draws a straight line from the first control point to the first end point (also called the begin point) at the left, and from the second control point to the end point at the right.

<p>Bezier splines are considered to be useful for computer-assisted design work because of several characteristics. First, with a little practice, you can usually manipulate the curve into something close to a desired shape.


<p><A HREF="javascript:fullSize('F05zg17x.htm')"><img src="F05zg17.JPG" width=404 height=284 ALIGN="BOTTOM" border=0 ALT="Click to view at full size."></a>

<p><!-- caption --><B>Figure 5-17.</B> <I>The BEZIER display.</I><!-- /caption -->

<p>Second, the Bezier spline is very well controlled. In some splines, the curve does not pass through any of the points that define the curve. The Bezier spline is always anchored at the two end points. (This is one of the assumptions that is used to derive the Bezier formulas.) Also, some forms of splines have singularities where the curve veers off into infinity. In computer-based design work, this is rarely desired. The Bezier curve never does this; indeed, it is always bounded by a four-sided polygon (called a &quot;convex hull&quot;) that is formed by connecting the end points and control points.

<p>Third, another characteristic of the Bezier spline involves the relationship between the end points and the control points. The curve is always tangential to and in the same direction as a straight line draw from the begin point to the first control point. (This is visually illustrated by the Bezier program.) Also, the curve is always tangential to and in the same direction as a straight line drawn from the second control point to the end point. These are two other assumptions used to derive the Bezier formulas.

<p>Fourth, the Bezier spline is often aesthetically pleasing. I know this is a subjective criterion, but I'm not the only person who thinks so.

<p>Prior to the 32-bit versions of Windows, you'd have to create your own Bezier 
splines using the <I>Polyline</I> function. You would also need knowledge of the following 
parametric equations for the Bezier spline. The begin point is 
(x<SUB>0</SUB>, y<SUB>0</SUB>), and the end point is 
(x<SUB>3</SUB>, y<SUB>3</SUB>). The two control points are 
(x<SUB>1</SUB>, y<SUB>1</SUB>) and (x<SUB>2</SUB>, 
y<SUB>2</SUB>). The curve is drawn for values of 
<I>t</I> ranging from 0 to 1:

<p><I>x(t) = (1 - t)<SUP>3 </SUP>x<SUB>0</SUB> + 3t (1 
- t)<SUP>2</SUP> x<SUB>1</SUB> + 3t<SUP>2</SUP> (1 
- t) x<SUB>2</SUB> + t<SUP>3</SUP> x<SUB>3</SUB>

<p>y(t) = (1 - t)<SUP>3 </SUP>y<SUB>0</SUB> + 3t (1 
- t)<SUP>2</SUP> y<SUB>1</SUB> + 3t<SUP>2</SUP> (1 
- t) y<SUB>2</SUB> + t<SUP>3</SUP> y<SUB>3</SUB></I>

<p>You don't need to know these formulas in Windows 98. To draw one or more connected Bezier splines, you simply call

<p><pre>
PolyBezier (hdc, apt, iCount) ;
</pre>

<p>or

<p><pre>
PolyBezierTo (hdc, apt, iCount) ;
</pre>

<p>In both cases, <I>apt</I> is an array of POINT structures. With <I>PolyBezier</I>, the first four points indicate (in this order) the begin point, first control point, second control point, and end point of the first Bezier curve. Each subsequent Bezier requires only three more points because the begin point of the second Bezier curve is the same as the end point of the first Bezier curve, and so on. The <I>iCount</I> argument is always one plus three times the number of connected curves you're drawing.

<p>The <I>PolyBezierTo</I> function uses the current position for the first begin point. The first and each subsequent Bezier spline requires only three points. When the function returns, the current position is set to the last end point.

<p>One note: when you draw a series of connected Bezier splines, the point of connection will be smooth only if the second control point of the first Bezier, the end point of the first Bezier (which is also the begin point of the second Bezier), and the first control point of the second Bezier are colinear; that is, they lie on the same straight line.

<A NAME="117"><h2>Using Stock Pens</h2></A>
<p>When you call any of the line-drawing functions that I've discussed in this section, Windows uses the &quot;pen&quot; currently selected in the device context to draw the line. The pen determines the line's color, its width, and its style, which can be solid, dotted, or dashed. The pen in the default device context is called BLACK_PEN. This pen draws a solid black line with a width of one pixel. BLACK_PEN is one of three &quot;stock pens&quot; that Windows provides. The other two are WHITE_PEN and NULL_PEN. NULL_PEN is a pen that doesn't draw. You can also create your own customized pens.

<p>In your Windows programs, you refer to pens by using a handle. The Windows header file WINDEF.H defines the type HPEN, a handle to a pen. You can define a variable (for instance, <I>hPen</I>) using this type definition:

<p><pre>
HPEN hPen ;
</pre>

<p>You obtain the handle to one of the stock pens by a call to <I>GetStockObject</I>. For instance, suppose you want to use the stock pen called WHITE_PEN. You get the pen handle like this:

<p><pre>
hPen = GetStockObject (WHITE_PEN) ;
</pre>

<p>Now you must &quot;select&quot; that pen into the device context:

<p><pre>
SelectObject (hdc, hPen) ;
</pre>

<p>Now the white pen is the current pen. After this call, any lines you draw will use WHITE_PEN until you select another pen into the device context or release the device context handle.

<p>Rather than explicitly defining an <I>hPen</I> variable, you can instead combine the <I>GetStockObject</I> and <I>SelectObject</I> calls in one statement:

<p><pre>
SelectObject (hdc, GetStockObject (WHITE_PEN)) ;
</pre>

<p>If you then want to return to using BLACK_PEN, you can get the handle to that stock object and select it into the device context in one statement:

<p><pre>
SelectObject (hdc, GetStockObject (BLACK_PEN)) ;
</pre>

<p><I>SelectObject</I> returns the handle to the pen that had been previously selected into the device context. If you start off with a fresh device context and call

<p><pre>
hPen = SelectObject (hdc, GetStockobject (WHITE_PEN)) ;
</pre>

<p>the current pen in the device context will be WHITE_PEN and the variable <I>hPen</I> will be the handle to BLACK_PEN. You can then select BLACK_PEN into the device context by calling

<p><pre>
SelectObject (hdc, hPen) ;
</pre>

<A NAME="118"><h2>Creating, Selecting, and Deleting Pens</h2></A>
<p>Although the pens defined as stock objects are certainly convenient, you are limited to only a solid black pen, a solid white pen, or no pen at all. If you want to get fancier than that, you must create your own pens.

<p>Here's the general procedure: You create a &quot;logical pen,&quot; which is merely a description of a pen, using the function <I>CreatePen</I> or <I>CreatePenIndirect</I>. These functions return a handle to the logical pen. You select the pen into the device context by calling <I>SelectObject</I>. You can then draw lines with this new pen. Only one pen can be selected into the device context at any time. After you release the device context (or after you select another pen into the device context) you can delete the logical pen you've created by calling <I>DeleteObject</I>. When you do so, the handle to the pen is no longer valid.

<p>A logical pen is a &quot;GDI object,&quot; one of six GDI objects a program can create. The other five are brushes, bitmaps, regions, fonts, and palettes. Except for palettes, all of these objects are selected into the device context using <I>SelectObject</I>.

<p>Three rules govern the use of GDI objects such as pens:

<p><ul>

<p><li>You should eventually delete all GDI objects that you create.

<p><li>Don't delete GDI objects while they are selected in a valid device context.

<p><li>Don't delete stock objects.
</UL>

<p>These are not unreasonable rules, but they can be a little tricky sometimes. We'll run through some examples to get the hang of how the rules work.

<p>The general syntax for the <I>CreatePen</I> function looks like this:

<p><pre>
hPen = CreatePen (iPenStyle, iWidth, crColor) ;
</pre>

<p>The <I>iPenStyle</I> argument determines whether the pen draws a solid line or a line made up of dots or dashes. The argument can be one of the following identifiers defined in WINGDI.H. Figure 5-18 shows the kind of line that each style produces.

<p><img src="F05zg18.GIF" width=322 height=187 border="0">

<p><!-- caption --><B>Figure 5-18.</B> <I>The seven pen styles.</I><!-- /caption -->

<p>For the PS_SOLID, PS_NULL, and PS_INSIDEFRAME styles, the <I>iWidth</I> argument is the width of the pen. An <I>iWidth</I> value of 0 directs Windows to use one pixel for the pen width. The stock pens are 1 pixel wide. If you specify a dotted or dashed pen style with a physical width greater than 1, Windows will use a solid pen instead.

<p>The <I>crColor</I> argument to <I>CreatePen</I> is a COLORREF value specifying the color of the pen. For all the pen styles except PS_INSIDEFRAME, when you select the pen into the device context, Windows converts the color to the nearest pure color that the device can render. The PS_INSIDEFRAME is the only pen style that can use a dithered color, and then only when the width is greater than 1.

<p>The PS_INSIDEFRAME style has another peculiarity when used with functions that define a filled area. For all pen styles except PS_INSIDEFRAME, if the pen used to draw the outline is greater than 1 pixel wide, then the pen is centered on the border so that part of the line can be outside the bounding box. For the PS_INSIDEFRAME pen style, the entire line is drawn inside the bounding box.

<p>You can also create a pen by setting up a structure of type LOGPEN (&quot;logical pen&quot;) and calling <I>CreatePenIndirect</I>. If your program uses a lot of different pens that you initialize in your source code, this method is probably more efficient.

<p>To use <I>CreatePenIndirect</I>, first you define a structure of type LOGPEN:

<p><pre>
LOGPEN logpen ;
</pre>

<p>This structure has three members: <I>lopnStyle</I> (an unsigned integer or UINT) is the pen style, <I>lopnWidth</I> (a POINT structure) is the pen width in logical units, and <I>lopnColor</I> (COLORREF) is the pen color. Windows uses only the <I>x</I> field of the <I>lopnWidth</I> structure to set the pen width; it ignores the <I>y</I> field.

<p>You create the pen by passing the address of the structure to <I>CreatePenIndirect</I>:

<p><pre>
hPen = CreatePenIndirect (&amp;logpen) ;
</pre>

<p>Note that the <I>CreatePen</I> and <I>CreatePenIndirect</I> functions do not require a handle to a device context. These functions create logical pens that have no connection with a device context until you call <I>SelectObject</I>. You can use the same logical pen for several different devices, such as the screen and a printer.

<p>Here's one method for creating, selecting, and deleting pens. Suppose your program uses three pens&#8212;a black pen of width 1, a red pen of width 3, and a black dotted pen. You can first define static variables for storing the handles to these pens:

<p><pre>
static HPEN hPen1, hPen2, hPen3 ;
</pre>

<p>During processing of WM_CREATE, you can create the three pens:

<p><pre>
hPen1 = CreatePen (PS_SOLID, 1, 0) ;
hPen2 = CreatePen (PS_SOLID, 3, RGB (255, 0, 0)) ;
hPen3 = CreatePen (PS_DOT, 0, 0) ;
</pre>

<p>During processing of WM_PAINT (or any other time you have a valid handle to a device context), you can select one of these pens into the device context and draw with it:

<p><pre>
SelectObject (hdc, hPen2) ;
<I>[ line-drawing functions ]</I>
SelectObject (hdc, hPen1) ;
<I>[ line-drawing functions ]</I>
</pre>

<p>During processing of WM_DESTROY, you can delete the three pens you created:

<p><pre>
DeleteObject (hPen1) ;
DeleteObject (hPen2) ;
DeleteObject (hPen3) ;
</pre>

<p>This is the most straightforward method of creating selecting, and deleting pens, but obviously your program must know what pens will be needed. You might instead want to create the pens during each WM_PAINT message and delete them after you call <I>EndPaint</I>. (You can delete them before calling <I>EndPaint</I>, but you have to be careful not to delete the pen currently selected in the device context.)

<p>You might want to create pens on the fly and combine the <I>CreatePen</I> and <I>SelectObject</I> calls in the same statement:

<p><pre>
SelectObject (hdc, CreatePen (PS_DASH, 0, RGB (255, 0, 0))) ;
</pre>

<p>Now when you draw lines, you'll be using a red dashed pen. When you're finished drawing the red dashed lines, you can delete the pen. Whoops! How can you delete the pen when you haven't saved the pen handle? Recall that <I>SelectObject</I> returns the handle to the pen previously selected in the device context. This means that you can delete the pen by selecting the stock BLACK_PEN into the device context and deleting the value returned from <I>SelectObject</I>:

<p><pre>
DeleteObject (SelectObject (hdc, GetStockObject (BLACK_PEN))) ;
</pre>

<p>Here's another method. When you select a pen into a newly created device context, save the handle to the pen that <I>SelectObject</I> returns:

<p><pre>
hPen = SelectObject (hdc, CreatePen (PS_DASH, 0, RGB (255, 0, 0))) ;
</pre>

<p>What is <I>hPen</I>? If this is the first <I>SelectObject</I> call you've made since obtaining the device context, <I>hPen</I> is a handle to the BLACK_PEN stock object. You can now select that pen into the device context and delete the pen you create (the handle returned from this second <I>SelectObject</I> call) in one statement:

<p><pre>
DeleteObject (SelectObject (hdc, hPen)) ;
</pre>

<p>If you have a handle to a pen, you can obtain the values of the LOGPEN structure fields by calling <I>GetObject</I>:

<p><pre>
GetObject (hPen, sizeof (LOGPEN), (LPVOID) &amp;logpen) ;
</pre>

<p>If you need the pen handle currently selected in the device context, call

<p><pre>
hPen = GetCurrentObject (hdc, OBJ_PEN) ;
</pre>

<p>I'll discuss another pen creation function, <I>ExtCreatePen</I>, in <a href="ch17a.htm#600">Chapter 17</a>.


<A NAME="119"><h2>Filling in the Gaps</h2></A>
<p>The use of dotted and dashed pens raises the question: what happens to the gaps between the dots and dashes? Well, what do you want to happen?


<p>The coloring of the gaps depends on two attributes of the device context&#8212;the background mode and the background color. The default background mode is OPAQUE, which means that Windows fills in the gaps with the background color, which by default is white. This is consistent with the WHITE_BRUSH that many programs use in the window class for erasing the background of the window.

<p>You can change the background color that Windows uses to fill in the gaps by calling

<p><pre>
SetBkColor (hdc, crColor) ;
</pre>

<p>As with the <I>crColor</I> argument used for the pen color, Windows converts this background color to a pure color. You can obtain the current background color defined in the device context by calling <I>GetBkColor</I>.

<p>You can also prevent Windows from filling in the gaps by changing the background mode to TRANSPARENT:

<p><pre>
SetBkMode (hdc, TRANSPARENT) ;
</pre>

<p>Windows will then ignore the background color and not fill in the gaps. You can obtain the current background mode (either TRANSPARENT or OPAQUE) by calling <I>GetBkMode</I>.

<A NAME="120"><h2>Drawing Modes</h2></A>
<p>The appearance of lines drawn on the display is also affected by the drawing mode defined in the device context. Imagine drawing a line that has a color based not only on the color of the pen but also on the color of the display area where the line is drawn. Imagine a way in which you could use the same pen to draw a black line on a white surface and a white line on a black surface without knowing what color the surface is. Could such a facility be useful to you? It's made possible by the drawing mode.

<p>When Windows uses a pen to draw a line, it actually performs a bitwise Boolean operation between the pixels of the pen and the pixels of the destination display surface, where the pixels determine the color of the pen and display surface. Performing a bitwise Boolean operation with pixels is called a &quot;raster operation,&quot; or &quot;ROP.&quot; Because drawing a line involves only two pixel patterns (the pen and the destination), the Boolean operation is called a &quot;binary raster operation,&quot; or &quot;ROP2.&quot; Windows defines 16 ROP2 codes that indicate how Windows combines the pen pixels and the destination pixels. In the default device context, the drawing mode is defined as R2_COPYPEN, meaning that Windows simply copies the pixels of the pen to the destination, which is how we normally think about pens. There are 15 other ROP2 codes.

<p>Where do these 16 different ROP2 codes come from? For illustrative purposes, let's assume a monochrome system that uses 1 bit per pixel. The destination color (the color of the window's client area) can be either black (which we'll represent by a 0 pixel) or white (represented by a 1 pixel). The pen also can be either black or white. There are four combinations of using a black or white pen to draw on a black or white destination: a white pen on a white destination, a white pen on a black destination, a black pen on a white destination, and a black pen on a black destination.

<p>What is the color of the destination after you draw with the pen? One possibility is that the line is always drawn as black regardless of the pen color or the destination color. This drawing mode is indicated by the ROP2 code R2_BLACK. Another possibility is that the line is drawn as black except when both the pen and destination are black, in which case the line is drawn as white. Although this might be a little strange, Windows has a name for it. The drawing mode is called R2_NOTMERGEPEN. Windows performs a bitwise OR operation on the destination pixels and the pen pixels and then inverts the result.

<p>The table below shows all 16 ROP2 drawing modes. The table indicates how the pen (P) and destination (D) colors are combined for the result. The column labeled &quot;Boolean Operation&quot; uses C notation to show how the destination pixels and pen pixels are combined.
<p>
<table width="95%" cellpadding="5" valign="TOP">
	<tr>
		<td valign=top><i><b>Pen (P):
			<p>Destination (D):</b></i></td>
		<td valign=top><b><i>1     1     0     0
				<p>1     0     1     0</i></b></td>
		<td valign=top><b><i>Boolean Operation</i></b></td>           
		<td valign=top><b><i>Drawing Mode</i></b></td>
     </tr>          
	<tr>
		<td valign=top>Results:</td>
		<td valign=top>0     0     0     0</td>
		<td valign=top>0</td>
		<td valign=top>R2_BLACK</td>
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>0     0     0     1</td>
		<td valign=top>~(P &#166; D)</td>
		<td valign=top>R2_NOTMERGEPEN</td>
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>0     0     1     0</td>
		<td valign=top>~P &amp; D</td>
		<td valign=top>R2_MASKNOTPEN</td>
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>0     0     1     1</td>
		<td valign=top>~P</td>
		<td valign=top>R2_NOTCOPYPEN</td>
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>0     1     0     0</td>
		<td valign=top>P &amp; ~D</td>
		<td valign=top>R2_MASKPENNOT</td>	
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>0     1     0     1</td>
		<td valign=top>~D</td>
		<td valign=top>R2_NOT</td>
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>0     1     1     0</td>
		<td valign=top>P ^ D</td>
		<td valign=top>R2_XORPEN</td>		
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>0     1     1     1</td>
		<td valign=top>~(P &amp; D)</td>
		<td valign=top>R2_NOTMASKPEN</td>
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>1     0     0     0</td>
		<td valign=top>P &amp; D</td>
		<td valign=top>R2_MASKPEN</td>
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>1     0     0     1</td>
		<td valign=top>~(P ^ D)</td>
		<td valign=top>R2_NOTXORPEN</td>				
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>1     0     1     0</td>
		<td valign=top>D </td>
		<td valign=top>R2_NOP</td>
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>1     0     1     1</td>
		<td valign=top>~P &#166; D</td>
		<td valign=top>R2_MERGENOTPEN</td>
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>1     1     0     0</td>
		<td valign=top>P</td>
		<td valign=top>R2_COPYPEN (default)</td>
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>1     1     0     1</td>
		<td valign=top>P &#166; ~D</td>
		<td valign=top>R2_MERGEPENNOT</td>
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>1     1     1     0</td>
		<td valign=top>P &#166;  D</td>
		<td valign=top>R2_MERGEPEN</td>
	</tr>
	<tr>
		<td valign=top></td>
		<td valign=top>1     1     1     1</td>
		<td valign=top>1</td>
		<td valign=top>R2_WHITE</td>		
	</tr>  
</table>

<p>You can set a new drawing mode for the device context by calling

<p><pre>
SetROP2 (hdc, iDrawMode) ;
</pre>

<p>The <I>iDrawMode</I> argument is one of the values listed in the &quot;Drawing Mode&quot; column of the table. You can obtain the current drawing mode by using the function:

<p><pre>
iDrawMode = GetROP2 (hdc) ;
</pre>

<p>The device context default is R2_COPYPEN, which simply transfers the pen color to the destination. The R2_NOTCOPYPEN mode draws white if the pen color is black and black if the pen color is white. The R2_BLACK mode always draws black, regardless of the color of the pen or the background. Likewise, the R2_WHITE mode always draws white. The R2_NOP mode is a &quot;no operation.&quot; It leaves the destination unchanged.

<p>We've been examining the drawing mode in the context of a monochrome system. Most systems are color, however. On color systems Windows performs the bitwise operation of the drawing mode for each color bit of the pen and destination pixels and again uses the 16 ROP2 codes described in the previous table. The R2_NOT drawing mode always inverts the destination color to determine the color of the line, regardless of the color of the pen. For example, a line drawn on a cyan destination will appear as magenta. The R2_NOT mode always results in a visible pen except if the pen is drawn on a medium gray background. I'll demonstrate the use of the R2_NOT drawing mode in the BLOKOUT programs in <a href="ch07a.htm#182">Chapter 7</a>.

</BODY>
</HTML>






