<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Wide Characters and C</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="25"><h1>Wide Characters and C</h1></A>
<p>To a C programmer, the whole idea of 16-bit characters can certainly provoke uneasy chills. That a <I>char</I> is the same width as a byte is one of the very few certainties of this life. Few programmers are aware that ANSI/ISO 9899-1990, the &quot;American National Standard for Programming Languages&#8212;C&quot; (also known as &quot;ANSI C&quot;) supports character sets that require more than one byte per character through a concept called &quot;wide characters.&quot; These wide characters coexist nicely with normal and familiar characters.

<p>ANSI C also supports multibyte character sets, such as those supported by the Chinese, Japanese, and Korean versions of Windows. However, these multibyte character sets are treated as strings of single-byte values in which some characters alter the meaning of successive characters. Multibyte character sets mostly impact the C run-time library functions. In contrast, wide characters are uniformly wider than normal characters and involve some compiler issues.

<p>Wide characters aren't necessarily Unicode. Unicode is one possible wide-character encoding. However, because the focus in this book is Windows rather than an abstract implementation of C, I will tend to speak of wide characters and Unicode synonymously.

<A NAME="26"><h2>The <I>char</I> Data Type</h2></A>
<p>Presumably, we are all quite familiar with defining and storing characters and character strings in our C programs by using the <I>char</I> data type. But to facilitate an understanding of how C handles wide characters, let's first review normal character definition as it might appear in a Win32 program.

<p>The following statement defines and initializes a variable containing a single character:

<p><pre>
char c = `A' ;
</PRE>

<p>The variable <I>c</I> requires 1 byte of storage and will be initialized with the hexadecimal value 0x41, which is the ASCII code for the letter A.

<p>You can define a pointer to a character string like so:

<p><pre>
char * p ;
</PRE>

<p>Because Windows is a 32-bit operating system, the pointer variable <I>p</I> requires 4 bytes of storage. You can also initialize a pointer to a character string:

<p><pre>
char * p = &quot;Hello!&quot; ;
</PRE>

<p>The variable <I>p</I> still requires 4 bytes of storage as before. The character string is stored in static memory and uses 7 bytes of storage&#8212;the 6 bytes of the string in addition to a terminating 0.

<p>You can also define an array of characters, like this:

<p><pre>
char a[10] ;
</PRE>

<p>In this case, the compiler reserves 10 bytes of storage for the array. The expression <I>sizeof (a)</I> will return 10. If the array is global (that is, defined outside any function), you can initialize an array of characters by using a statement like so:

<p><pre>
char a[] = &quot;Hello!&quot; ;
</PRE>

<p>If you define this array as a local variable to a function, it must be defined as a <I>static</I> variable, as follows:

<p><pre>
static char a[] = &quot;Hello!&quot; ;
</PRE>

<p>In either case, the string is stored in static program memory with a 0 appended at the end, thus requiring 7 bytes of storage.

<A NAME="27"><h2>Wider Characters</h2></A>
<p>Nothing about Unicode or wide characters alters the meaning of the <I>char</I> data type in C. The <I>char</I> continues to indicate 1 byte of storage, and <I>sizeof (char)</I> continues to return 1. In theory, a byte in C can be greater than 8 bits, but for most of us, a byte (and hence a <I>char</I>) is 8 bits wide.

<p>Wide characters in C are based on the <I>wchar_t</I> data type, which is defined in several header files, including WCHAR.H, like so:

<p><pre>
typedef unsigned short wchar_t ;
</PRE>

<p>Thus, the <I>wchar_t</I> data type is the same as an unsigned short integer: 16 bits wide.

<p>To define a variable containing a single wide character, use the following statement:

<p><pre>
wchar_t c = `A' ;
</PRE>

<p>The variable <I>c</I> is the two-byte value 0x0041, which is the Unicode representation of the letter A. (However, because Intel microprocessors store multibyte values with the least-significant bytes first, the bytes are actually stored in memory in the sequence 0x41, 0x00. Keep this in mind if you examine memory storage of Unicode text.)

<p>You can also define an initialized pointer to a wide-character string:

<p><pre>
wchar_t * p = L&quot;Hello!&quot; ;
</PRE>

<p>Notice the capital L (for long) immediately preceding the first quotation mark. This indicates to the compiler that the string is to be stored with wide characters&#8212;that is, with every character occupying 2 bytes. The pointer variable <I>p</I> requires 4 bytes of storage, as usual, but the character string requires 14 bytes&#8212;2 bytes for each character with 2 bytes of zeros at the end.

<p>Similarly, you can define an array of wide characters this way:

<p><pre>
static wchar_t a[] = L&quot;Hello!&quot; ;
</PRE>

<p>The string again requires 14 bytes of storage, and <I>sizeof (a)</I> will return 14. You can index the <I>a</I> array to get at the individual characters. The value <I>a[1]</I> is the wide character `e', or 0x0065.

<p>Although it looks more like a typo than anything else, that L preceding the first quotation mark is very important, and there must not be space between the two symbols. Only with that L will the compiler know you want the string to be stored with 2 bytes per character. Later on, when we look at wide-character strings in places other than variable definitions, you'll encounter the L preceding the first quotation mark again. Fortunately, the C compiler will often give you a warning or error message if you forget to include the L.

<p>You can also use the L prefix in front of single character literals, as shown here, to indicate that they should be interpreted as wide characters.

<p><pre>
wchar_t c = L'A' ;
</PRE>

<p>But it's usually not necessary. The C compiler will zero-extend the character anyway.

<A NAME="28"><h2>Wide-Character Library Functions</h2></A>
<p>We all know how to find the length of a string. For example, if we have defined a pointer to a character string like so:

<p><pre>
char * pc = &quot;Hello!&quot; ;
</PRE>

<p>we can call

<p><pre>
iLength = strlen (pc) ;
</PRE>

<p>The variable <I>iLength</I> will be set equal to 6, the number of characters in the string.

<p>Excellent! Now let's try defining a pointer to a string of wide characters:

<p><pre>
wchar_t * pw = L&quot;Hello!&quot; ;
</PRE>

<p>And now we call <I>strlen</I> again:

<p><pre>
iLength = strlen (pw) ;
</PRE>

<p>Now the troubles begin. First, the C compiler gives you a warning message, probably something along the lines of

<p><pre>
`function' : incompatible types - from `unsigned short *' to `const char *'
</PRE>

<p>It's telling you that the <I>strlen</I> function is declared as accepting a pointer to a <I>char</I>, and it's getting a pointer to an <I>unsigned short</I>. You can still compile and run the program, but you'll find that <I>iLength</I> is set to 1. What happened?

<p>The 6 characters of the character string &quot;Hello!&quot; have the 16-bit values:

<p><pre>
0x0048 0x0065 0x006C 0x006C 0x006F 0x0021
</PRE>

<p>which are stored in memory by Intel processors like so:

<p><pre>
48 00 65 00 6C 00 6C 00 6F 00 21 00
</PRE>

<p>The <I>strlen</I> function, assuming that it's attempting to find the length of a string of characters, counts the first byte as a character but then assumes that the second byte is a zero byte denoting the end of the string.

<p>This little exercise clearly illustrates the differences between the C language itself and the run-time library functions. The compiler interprets the string L&quot;Hello!&quot; as a collection of 16-bit short integers and stores them in the <I>wchar_t</I> array. The compiler also handles any array indexing and the <I>sizeof</I> operator, so these work properly. But run-time library functions such as <I>strlen</I> are added during link time. These functions expect strings that comprise single-byte characters. When they are confronted with wide-character strings, they don't perform as we'd like.

<p>Oh, great, you say. Now every C library function has to be rewritten to accept wide characters. Well, not <I>every</I> C library function. Only the ones that have string arguments. And <I>you</I> don't have to rewrite them. It's already been done.

<p>The wide-character version of the <I>strlen</I> function is called <I>wcslen</I> (&quot;wide-character string length&quot;), and it's declared both in STRING.H (where the declaration for <I>strlen</I> resides) and WCHAR.H. The <I>strlen</I> function is declared like this:

<p><pre>
size_t __cdecl strlen (const char *) ;
</PRE>

<p>and the <I>wcslen</I> function looks like this:

<p><pre>
size_t __cdecl wcslen (const wchar_t *) ;
</PRE>

<p>So now we know that when we need to find out the length of a wide-character string we can call

<p><pre>
iLength = wcslen (pw) ;
</PRE>

<p>The function returns 6, the number of characters in the string. Keep in mind that the character length of a string does not change when you move to wide characters&#8212;only the byte length changes.

<p>All your favorite C run-time library functions that take string arguments have wide-character versions. For example, <I>wprintf</I> is the wide-character version of <I>printf</I>. These functions are declared both in WCHAR.H and in the header file where the normal function is declared.

<A NAME="29"><h2>Maintaining a Single Source</h2></A>
<p>There are, of course, certain disadvantages to using Unicode. First and foremost is that every string in your program will occupy twice as much space. In addition, you'll observe that the functions in the wide-character run-time library are larger than the usual functions. For this reason, you might want to create two versions of your program&#8212;one with ASCII strings and the other with Unicode strings. The best solution would be to maintain a single source code file that you could compile for either ASCII or Unicode.

<p>That's a bit of a problem, though, because the run-time library functions have different names, you're defining characters differently, and then there's that nuisance of preceding the string literals with an L.

<p>One answer is to use the TCHAR.H header file included with Microsoft Visual C++. This header file is not part of the ANSI C standard, so every function and macro definition defined therein is preceded by an underscore. TCHAR.H provides a set of alternative names for the normal run-time library functions requiring string parameters (for example, <I>_tprintf</I> and <I>_tcslen</I>). These are sometimes referred to as &quot;generic&quot; function names because they can refer to either the Unicode or non-Unicode versions of the functions.

<p>If an identifier named _UNICODE is defined and the TCHAR.H header file is included in your program, <I>_tcslen</I> is defined to be <I>wcslen</I>:

<p><pre>
#define _tcslen wcslen
</PRE>

<p>If UNICODE isn't defined, <I>_tcslen</I> is defined to be <I>strlen</I>:

<p><pre>
#define _tcslen strlen
</PRE>

<p>And so on. TCHAR.H also solves the problem of the two character data types with a new data type named TCHAR. If the _UNICODE identifier is defined, TCHAR is <I>wchar_t</I>:

<p><pre>
typedef wchar_t TCHAR ;
</PRE>

<p>Otherwise, TCHAR is simply a <I>char</I>:

<p><pre>
typedef char TCHAR ;
</PRE>

<p>Now it's time to address that sticky L problem with the string literals. If the _UNICODE identifier is defined, a macro called __T is defined like this:

<p><pre>
#define __T(x) L##x
</PRE>

<p>This is fairly obscure syntax, but it's in the ANSI C standard for the C preprocessor. That pair of number signs is called a &quot;token paste,&quot; and it causes the letter L to be appended to the macro parameter. Thus, if the macro parameter is &quot;Hello!&quot;, then <I>L##x</I> is L&quot;Hello!&quot;.

<p>If the _UNICODE identifier is not defined, the __T macro is simply defined in the following way:

<p><pre>
#define __T(x) x
</PRE>

<p>Regardless, two other macros are defined to be the same as __T:

<p><pre>
#define _T(x) __T(x)
#define _TEXT(x) __T(x)
</PRE>

<p>Which one you use for your Win32 console programs depends on how concise or verbose you'd like to be. Basically, you must define your string literals inside the _T or _TEXT macro in the following way:

<p><pre>
_TEXT (&quot;Hello!&quot;) 
</PRE>

<p>Doing so causes the string to be interpreted as composed of wide characters if the _UNICODE identifier is defined and as 8-bit characters if not.

</BODY>
</HTML>






