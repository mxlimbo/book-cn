<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>The Logical Font</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="612"><h1>The Logical Font</h1></A>
<p>Now that we've nailed down the concept of logical inches and logical twips, it's time to talk about logical fonts.

<p>A logical font is a GDI object whose handle is stored in a variable of type HFONT. A logical font is a description of a font. Like the logical pen and logical brush, it is an abstract object that becomes real only as it is a selected into a device context when an application calls <I>SelectObject</I>. For logical pens, for instance, you can specify any color you want for the pen, but Windows converts that to a pure color available on the device when you select the pen into the device context. Only then does Windows know about the color capabilities of the device.

<A NAME="613"><h2>Logical Font Creation and Selection</h2></A>
<p>You create a logical font by calling <I>CreateFont</I> or <I>CreateFontIndirect</I>. The <I>CreateFontIndirect</I> function takes a pointer to a LOGFONT structure, which has 14 fields. The <I>CreateFont</I> function takes 14 arguments, which are identical to the 14 fields of the LOGFONT structure. These are the <I>only</I> two functions that create a logical font. (I mention this because there are multiple functions in Windows for some other font jobs.) Because the 14 fields are difficult to remember, <I>CreateFont</I> is rarely used, so I'll focus on <I>CreateFontIndirect</I>.

<p>There are three basic ways to define the fields of a LOGFONT structure in preparation for calling <I>CreateFontIndirect</I>.

<UL>
<p><li>You can simply set the fields of the LOGFONT structure to the characteristics of the font that you want. In this case, when you call <I>SelectObject</I>, Windows uses a &quot;font mapping&quot; algorithm to attempt to give you the font available on the device that best matches these characteristics. Depending on the fonts available on the video display or printer, the result might differ considerably from what you request.

<p><li>You can enumerate all the fonts on the device and choose from those or even present them to the user with a dialog box. I'll discuss the font enumeration functions later in this chapter. These are not used much these days because the third method does the enumeration for you.

<p><li>You can take the simple approach and call the <I>ChooseFont</I> function, which I discussed a little in <a href="ch11a.htm#331">Chapter 11</a>. You get back a LOGFONT structure that you can use directly for creating the font.
</UL>

<p>In this chapter, I'll use the first and third approaches.

<p>Here is the process for creating, selecting, and deleting logical fonts:

<OL>

<p><li>Create a logical font by calling <I>CreateFont</I> or <I>CreateFontIndirect</I>. These functions return a handle to a logical font of type HFONT.

<p><li>Select the logical font into the device context using <I>SelectObject</I>. Windows chooses a real font that most closely matches the logical font.

<p><li>Determine the size and characteristics of the real font with <I>GetTextMetrics</I> (and possibly some other functions). You can use this information to properly space the text that you write when this font is selected into the device context.

<p><li>After you've finished using the font, delete the logical font by calling <I>DeleteObject</I>. Don't delete the font while it is selected in a valid device context, and don't delete stock fonts.
</OL>

<p>The <I>GetTextFace</I> function lets a program determine the face name of the font currently selected in the device context:

<P><pre>
GetTextFace (hdc, sizeof (szFaceName) / sizeof (TCHAR), szFaceName) ;
</PRE>

<p>The detailed font information is available from <I>GetTextMetrics</I>:

<P><pre>
GetTextMetrics (hdc, &amp;textmetric) ;
</PRE>

<p>where <I>textmetric</I> is a variable of type TEXTMETRIC, a structure with 20 fields.

<p>I'll discuss the fields of the LOGFONT and TEXTMETRIC structures in detail shortly. The structures have some similar fields, so they can be confusing. For now, just keep in mind that LOGFONT is for defining a logical font and TEXTMETRIC is for obtaining information about the font currently selected in the device context.

<A NAME="614"><h2>The PICKFONT Program</h2></A>
<p>With the PICKFONT program shown in Figure 17-1, you can define many of the fields of a LOGFONT structure. The program creates a logical font and displays the characteristics of the real font after the logical font has been selected in a device context. This is a handy program for understanding how logical fonts are mapped to real fonts.

<p><b>Figure 17-1</b> <i>The PICKFONT program.</i>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="615"><h3>PICKFONT.C</h3></A><P><pre>
  /*-----------------------------------------
   PICKFONT.C -- Create Logical Font
                 (c) Charles Petzold, 1998
  -----------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;resource.h&quot;

     // Structure shared between main window and dialog box

typedef struct
{
     int        iDevice, iMapMode ;
     BOOL       fMatchAspect ;
     BOOL       fAdvGraphics ;
     LOGFONT    lf ;
     TEXTMETRIC tm ;
     TCHAR      szFaceName [LF_FULLFACESIZE] ;
}
DLGPARAMS ;

     // Formatting for BCHAR fields of TEXTMETRIC structure

#ifdef UNICODE
#define BCHARFORM TEXT (&quot;0x%04X&quot;)
#else
#define BCHARFORM TEXT (&quot;0x%02X&quot;)
#endif

     // Global variables

HWND  hdlg ;
TCHAR szAppName[] = TEXT (&quot;PickFont&quot;) ;

     // Forward declarations of functions

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;
BOOL    CALLBACK DlgProc (HWND, UINT, WPARAM, LPARAM) ;
void SetLogFontFromFields    (HWND hdlg, DLGPARAMS * pdp) ;
void SetFieldsFromTextMetric (HWND hdlg, DLGPARAMS * pdp) ;
void MySetMapMode (HDC hdc, int iMapMode) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = szAppName ; 
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
               szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;PickFont: Create Logical Font&quot;),
                          WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          if (hdlg == 0 || !IsDialogMessage (hdlg, &amp;msg))
          {
               TranslateMessage (&amp;msg) ;
               DispatchMessage (&amp;msg) ;
          }
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static DLGPARAMS dp ;
     static TCHAR     szText[] = TEXT (&quot;\x41\x42\x43\x44\x45 &quot;)
                                 TEXT (&quot;\x61\x62\x63\x64\x65 &quot;)

                                 TEXT (&quot;\xC0\xC1\xC2\xC3\xC4\xC5 &quot;)
                                 TEXT (&quot;\xE0\xE1\xE2\xE3\xE4\xE5 &quot;) 
#ifdef UNICODE
                                 TEXT (&quot;\x0390\x0391\x0392\x0393\x0394\x0395 &quot;)
                                 TEXT (&quot;\x03B0\x03B1\x03B2\x03B3\x03B4\x03B5 &quot;)

                                 TEXT (&quot;\x0410\x0411\x0412\x0413\x0414\x0415 &quot;)
                                 TEXT (&quot;\x0430\x0431\x0432\x0433\x0434\x0435 &quot;)

                                 TEXT (&quot;\x5000\x5001\x5002\x5003\x5004&quot;) 
#endif
                                 ;
     HDC              hdc ;
     PAINTSTRUCT      ps ;
     RECT             rect ;
     
     switch (message)
     {
     case WM_CREATE:
          dp.iDevice = IDM_DEVICE_SCREEN ;

          hdlg = CreateDialogParam (((LPCREATESTRUCT) lParam)-&gt;hInstance, 
                                    szAppName, hwnd, DlgProc, (LPARAM) &amp;dp) ;
          return 0 ;

     case WM_SETFOCUS:
          SetFocus (hdlg) ;
          return 0 ;

     case WM_COMMAND:
          switch (LOWORD (wParam))
          {
          case IDM_DEVICE_SCREEN:
          case IDM_DEVICE_PRINTER:
               CheckMenuItem (GetMenu (hwnd), dp.iDevice, MF_UNCHECKED) ;
               dp.iDevice = LOWORD (wParam) ;
               CheckMenuItem (GetMenu (hwnd), dp.iDevice, MF_CHECKED) ;

                 SendMessage (hwnd, WM_COMMAND, IDOK, 0) ;
               return 0 ;
          }
          break ;

     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;

               // Set graphics mode so escapement works in Windows NT

          SetGraphicsMode (hdc, dp.fAdvGraphics ? GM_ADVANCED : GM_COMPATIBLE) ;

               // Set the mapping mode and the mapper flag

          MySetMapMode (hdc, dp.iMapMode) ;
          SetMapperFlags (hdc, dp.fMatchAspect) ;

               // Find the point to begin drawing text

          GetClientRect (hdlg, &amp;rect) ;
          rect.bottom += 1 ;
          DPtoLP (hdc, (PPOINT) &amp;rect, 2) ;

               // Create and select the font; display the text

          SelectObject (hdc, CreateFontIndirect (&amp;dp.lf)) ;
          TextOut (hdc, rect.left, rect.bottom, szText, lstrlen (szText)) ;

          DeleteObject (SelectObject (hdc, GetStockObject (SYSTEM_FONT))) ;
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}

BOOL CALLBACK DlgProc (HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
     static DLGPARAMS * pdp ;
     static PRINTDLG    pd = { sizeof (PRINTDLG) } ;
     HDC                hdcDevice ;
     HFONT              hFont ;
     
     switch (message)
     {
     case WM_INITDIALOG:
               // Save pointer to dialog-parameters structure in WndProc

          pdp = (DLGPARAMS *) lParam ;

          SendDlgItemMessage (hdlg, IDC_LF_FACENAME, EM_LIMITTEXT, 
                                    LF_FACESIZE - 1, 0) ;

          CheckRadioButton (hdlg, IDC_OUT_DEFAULT, IDC_OUT_OUTLINE,
                                  IDC_OUT_DEFAULT) ;

          CheckRadioButton (hdlg, IDC_DEFAULT_QUALITY, IDC_PROOF_QUALITY,
                                  IDC_DEFAULT_QUALITY) ;

          CheckRadioButton (hdlg, IDC_DEFAULT_PITCH, IDC_VARIABLE_PITCH,
                                  IDC_DEFAULT_PITCH) ;

          CheckRadioButton (hdlg, IDC_FF_DONTCARE, IDC_FF_DECORATIVE,
                                  IDC_FF_DONTCARE) ;

          CheckRadioButton (hdlg, IDC_MM_TEXT, IDC_MM_LOGTWIPS,
                                  IDC_MM_TEXT) ;

          SendMessage (hdlg, WM_COMMAND, IDOK, 0) ;

                                   // fall through
     case WM_SETFOCUS:
          SetFocus (GetDlgItem (hdlg, IDC_LF_HEIGHT)) ;
          return FALSE ;

     case WM_COMMAND:
          switch (LOWORD (wParam))
          {
          case IDC_CHARSET_HELP:
               MessageBox (hdlg, 
                           TEXT (&quot;0 = Ansi\n&quot;)
                           TEXT (&quot;1 = Default\n&quot;)
                           TEXT (&quot;2 = Symbol\n&quot;)
                           TEXT (&quot;128 = Shift JIS (Japanese)\n&quot;)
                           TEXT (&quot;129 = Hangul (Korean)\n&quot;)
                           TEXT (&quot;130 = Johab (Korean)\n&quot;)
                           TEXT (&quot;134 = GB 2312 (Simplified Chinese)\n&quot;)
                           TEXT (&quot;136 = Chinese Big 5 (Traditional Chinese)\n&quot;)
                           TEXT (&quot;177 = Hebrew\n&quot;)
                           TEXT (&quot;178 = Arabic\n&quot;)

                           TEXT (&quot;161 = Greek\n&quot;)
                           TEXT (&quot;162 = Turkish\n&quot;)
                           TEXT (&quot;163 = Vietnamese\n&quot;)
                           TEXT (&quot;204 = Russian\n&quot;)
                           TEXT (&quot;222 = Thai\n&quot;)
                           TEXT (&quot;238 = East European\n&quot;)
                           TEXT (&quot;255 = OEM&quot;),
                           szAppName, MB_OK | MB_ICONINFORMATION) ;
               return TRUE ;

               // These radio buttons set the lfOutPrecision field

          case IDC_OUT_DEFAULT:   
               pdp-&gt;lf.lfOutPrecision = OUT_DEFAULT_PRECIS ;  
               return TRUE ;

          case IDC_OUT_STRING:
               pdp-&gt;lf.lfOutPrecision = OUT_STRING_PRECIS ;  
               return TRUE ;

          case IDC_OUT_CHARACTER:
               pdp-&gt;lf.lfOutPrecision = OUT_CHARACTER_PRECIS ;  
               return TRUE ;

          case IDC_OUT_STROKE:
               pdp-&gt;lf.lfOutPrecision = OUT_STROKE_PRECIS ;  
               return TRUE ;

          case IDC_OUT_TT:
               pdp-&gt;lf.lfOutPrecision = OUT_TT_PRECIS ;  
               return TRUE ;

          case IDC_OUT_DEVICE:
               pdp-&gt;lf.lfOutPrecision = OUT_DEVICE_PRECIS ;  
               return TRUE ;

          case IDC_OUT_RASTER:
               pdp-&gt;lf.lfOutPrecision = OUT_RASTER_PRECIS ;  
               return TRUE ;

          case IDC_OUT_TT_ONLY:
               pdp-&gt;lf.lfOutPrecision = OUT_TT_ONLY_PRECIS ;  
               return TRUE ;

          case IDC_OUT_OUTLINE:
               pdp-&gt;lf.lfOutPrecision = OUT_OUTLINE_PRECIS ;  
               return TRUE ;

               // These three radio buttons set the lfQuality field

          case IDC_DEFAULT_QUALITY:
               pdp-&gt;lf.lfQuality = DEFAULT_QUALITY ;   
               return TRUE ;

          case IDC_DRAFT_QUALITY:
               pdp-&gt;lf.lfQuality = DRAFT_QUALITY ;  
               return TRUE ;

          case IDC_PROOF_QUALITY:
               pdp-&gt;lf.lfQuality = PROOF_QUALITY ;  
               return TRUE ;

               // These three radio buttons set the lower nibble
               //   of the lfPitchAndFamily field

          case IDC_DEFAULT_PITCH:
               pdp-&gt;lf.lfPitchAndFamily = 
                    (0xF0 &amp; pdp-&gt;lf.lfPitchAndFamily) | DEFAULT_PITCH ; 
               return TRUE ;

          case IDC_FIXED_PITCH:
               pdp-&gt;lf.lfPitchAndFamily = 
                    (0xF0 &amp; pdp-&gt;lf.lfPitchAndFamily) | FIXED_PITCH ; 
               return TRUE ;

          case IDC_VARIABLE_PITCH:
               pdp-&gt;lf.lfPitchAndFamily = 
                    (0xF0 &amp; pdp-&gt;lf.lfPitchAndFamily) | VARIABLE_PITCH ;  
               return TRUE ;

               // These six radio buttons set the upper nibble
               //   of the lfPitchAndFamily field

          case IDC_FF_DONTCARE:
               pdp-&gt;lf.lfPitchAndFamily =
                    (0x0F &amp; pdp-&gt;lf.lfPitchAndFamily) | FF_DONTCARE ;  
               return TRUE ;

          case IDC_FF_ROMAN:
               pdp-&gt;lf.lfPitchAndFamily =
                    (0x0F &amp; pdp-&gt;lf.lfPitchAndFamily) | FF_ROMAN ;  
               return TRUE ;

          case IDC_FF_SWISS:
               pdp-&gt;lf.lfPitchAndFamily =
                    (0x0F &amp; pdp-&gt;lf.lfPitchAndFamily) | FF_SWISS ;  
               return TRUE ;

          case IDC_FF_MODERN:
               pdp-&gt;lf.lfPitchAndFamily =
                    (0x0F &amp; pdp-&gt;lf.lfPitchAndFamily) | FF_MODERN ;  
               return TRUE ;

          case IDC_FF_SCRIPT:
               pdp-&gt;lf.lfPitchAndFamily =
                    (0x0F &amp; pdp-&gt;lf.lfPitchAndFamily) | FF_SCRIPT ;  
               return TRUE ;

          case IDC_FF_DECORATIVE:
               pdp-&gt;lf.lfPitchAndFamily =
                    (0x0F &amp; pdp-&gt;lf.lfPitchAndFamily) | FF_DECORATIVE ;  
               return TRUE ;

               // Mapping mode:

          case IDC_MM_TEXT:
          case IDC_MM_LOMETRIC:
          case IDC_MM_HIMETRIC:
          case IDC_MM_LOENGLISH:
          case IDC_MM_HIENGLISH:
          case IDC_MM_TWIPS:
          case IDC_MM_LOGTWIPS:
               pdp-&gt;iMapMode = LOWORD (wParam) ;
               return TRUE ;

               // OK button pressed
               // -----------------

          case IDOK:
                    // Get LOGFONT structure

               SetLogFontFromFields (hdlg, pdp) ;

                    // Set Match-Aspect and Advanced Graphics flags

               pdp-&gt;fMatchAspect = IsDlgButtonChecked (hdlg, IDC_MATCH_ASPECT) ;
               pdp-&gt;fAdvGraphics = IsDlgButtonChecked (hdlg, IDC_ADV_GRAPHICS) ;

                    // Get Information Context

               if (pdp-&gt;iDevice == IDM_DEVICE_SCREEN)
               {
                    hdcDevice = CreateIC (TEXT (&quot;DISPLAY&quot;), NULL, NULL, NULL) ;
               }
               else
               {
                    pd.hwndOwner = hdlg ;
                    pd.Flags = PD_RETURNDEFAULT | PD_RETURNIC ;
                    pd.hDevNames = NULL ;
                    pd.hDevMode = NULL ;

                    PrintDlg (&amp;pd) ;

                    hdcDevice = pd.hDC ;
               }
                    // Set the mapping mode and the mapper flag

               MySetMapMode (hdcDevice, pdp-&gt;iMapMode) ;
               SetMapperFlags (hdcDevice, pdp-&gt;fMatchAspect) ;

                    // Create font and select it into IC

               hFont = CreateFontIndirect (&amp;pdp-&gt;lf) ;
               SelectObject (hdcDevice, hFont) ;

                    // Get the text metrics and face name

               GetTextMetrics (hdcDevice, &amp;pdp-&gt;tm) ;
               GetTextFace (hdcDevice, LF_FULLFACESIZE, pdp-&gt;szFaceName) ;
               DeleteDC (hdcDevice) ;
               DeleteObject (hFont) ;

                    // Update dialog fields and invalidate main window

               SetFieldsFromTextMetric (hdlg, pdp) ;
               InvalidateRect (GetParent (hdlg), NULL, TRUE) ;
               return TRUE ;
          }
          break ;
     }
     return FALSE ;
}
void SetLogFontFromFields (HWND hdlg, DLGPARAMS * pdp)
{
     pdp-&gt;lf.lfHeight      = GetDlgItemInt (hdlg, IDC_LF_HEIGHT,  NULL, TRUE) ;
     pdp-&gt;lf.lfWidth       = GetDlgItemInt (hdlg, IDC_LF_WIDTH,   NULL, TRUE) ;
     pdp-&gt;lf.lfEscapement  = GetDlgItemInt (hdlg, IDC_LF_ESCAPE,  NULL, TRUE) ;
     pdp-&gt;lf.lfOrientation = GetDlgItemInt (hdlg, IDC_LF_ORIENT,  NULL, TRUE) ;
     pdp-&gt;lf.lfWeight      = GetDlgItemInt (hdlg, IDC_LF_WEIGHT,  NULL, TRUE) ;
     pdp-&gt;lf.lfCharSet     = GetDlgItemInt (hdlg, IDC_LF_CHARSET, NULL, FALSE) ;

     pdp-&gt;lf.lfItalic = 
                    IsDlgButtonChecked (hdlg, IDC_LF_ITALIC) == BST_CHECKED ;
     pdp-&gt;lf.lfUnderline = 
                    IsDlgButtonChecked (hdlg, IDC_LF_UNDER)  == BST_CHECKED ;
     pdp-&gt;lf.lfStrikeOut = 
                    IsDlgButtonChecked (hdlg, IDC_LF_STRIKE) == BST_CHECKED ;

     GetDlgItemText (hdlg, IDC_LF_FACENAME, pdp-&gt;lf.lfFaceName, LF_FACESIZE) ;
}

void SetFieldsFromTextMetric (HWND hdlg, DLGPARAMS * pdp) 
{
     TCHAR   szBuffer [10] ;
     TCHAR * szYes = TEXT (&quot;Yes&quot;) ; 
     TCHAR * szNo  = TEXT (&quot;No&quot;) ;
     TCHAR * szFamily [] = { TEXT (&quot;Don't Know&quot;), TEXT (&quot;Roman&quot;),
                             TEXT (&quot;Swiss&quot;),      TEXT (&quot;Modern&quot;),
                             TEXT (&quot;Script&quot;),     TEXT (&quot;Decorative&quot;), 
                             TEXT (&quot;Undefined&quot;) } ;

     SetDlgItemInt (hdlg, IDC_TM_HEIGHT,   pdp-&gt;tm.tmHeight,           TRUE) ;
     SetDlgItemInt (hdlg, IDC_TM_ASCENT,   pdp-&gt;tm.tmAscent,           TRUE) ;
     SetDlgItemInt (hdlg, IDC_TM_DESCENT,  pdp-&gt;tm.tmDescent,          TRUE) ;
     SetDlgItemInt (hdlg, IDC_TM_INTLEAD,  pdp-&gt;tm.tmInternalLeading,  TRUE) ;
     SetDlgItemInt (hdlg, IDC_TM_EXTLEAD,  pdp-&gt;tm.tmExternalLeading,  TRUE) ;
     SetDlgItemInt (hdlg, IDC_TM_AVECHAR,  pdp-&gt;tm.tmAveCharWidth,     TRUE) ;
     SetDlgItemInt (hdlg, IDC_TM_MAXCHAR,  pdp-&gt;tm.tmMaxCharWidth,     TRUE) ;
     SetDlgItemInt (hdlg, IDC_TM_WEIGHT,   pdp-&gt;tm.tmWeight,           TRUE) ;
     SetDlgItemInt (hdlg, IDC_TM_OVERHANG, pdp-&gt;tm.tmOverhang,         TRUE) ;
     SetDlgItemInt (hdlg, IDC_TM_DIGASPX,  pdp-&gt;tm.tmDigitizedAspectX, TRUE) ;
     SetDlgItemInt (hdlg, IDC_TM_DIGASPY,  pdp-&gt;tm.tmDigitizedAspectY, TRUE) ;

     wsprintf (szBuffer, BCHARFORM, pdp-&gt;tm.tmFirstChar) ;
     SetDlgItemText (hdlg, IDC_TM_FIRSTCHAR, szBuffer) ;

     wsprintf (szBuffer, BCHARFORM, pdp-&gt;tm.tmLastChar) ;
     SetDlgItemText (hdlg, IDC_TM_LASTCHAR, szBuffer) ;

     wsprintf (szBuffer, BCHARFORM, pdp-&gt;tm.tmDefaultChar) ;
     SetDlgItemText (hdlg, IDC_TM_DEFCHAR, szBuffer) ;

     wsprintf (szBuffer, BCHARFORM, pdp-&gt;tm.tmBreakChar) ;
     SetDlgItemText (hdlg, IDC_TM_BREAKCHAR, szBuffer) ;

     SetDlgItemText (hdlg, IDC_TM_ITALIC, pdp-&gt;tm.tmItalic     ? szYes : szNo) ;
     SetDlgItemText (hdlg, IDC_TM_UNDER,  pdp-&gt;tm.tmUnderlined ? szYes : szNo) ;
     SetDlgItemText (hdlg, IDC_TM_STRUCK, pdp-&gt;tm.tmStruckOut  ? szYes : szNo) ;

     SetDlgItemText (hdlg, IDC_TM_VARIABLE, 
               TMPF_FIXED_PITCH &amp; pdp-&gt;tm.tmPitchAndFamily ? szYes : szNo) ;

     SetDlgItemText (hdlg, IDC_TM_VECTOR, 
               TMPF_VECTOR &amp; pdp-&gt;tm.tmPitchAndFamily ? szYes : szNo) ;

     SetDlgItemText (hdlg, IDC_TM_TRUETYPE, 
               TMPF_TRUETYPE &amp; pdp-&gt;tm.tmPitchAndFamily ? szYes : szNo) ;

     SetDlgItemText (hdlg, IDC_TM_DEVICE, 
               TMPF_DEVICE &amp; pdp-&gt;tm.tmPitchAndFamily ? szYes : szNo) ;

     SetDlgItemText (hdlg, IDC_TM_FAMILY, 
               szFamily [min (6, pdp-&gt;tm.tmPitchAndFamily &gt;&gt; 4)]) ;

     SetDlgItemInt  (hdlg, IDC_TM_CHARSET,   pdp-&gt;tm.tmCharSet, FALSE) ;
     SetDlgItemText (hdlg, IDC_TM_FACENAME, pdp-&gt;szFaceName) ;
}

void MySetMapMode (HDC hdc, int iMapMode)
{
     switch (iMapMode)
     {
     case IDC_MM_TEXT:       SetMapMode (hdc, MM_TEXT) ;       break ;
     case IDC_MM_LOMETRIC:   SetMapMode (hdc, MM_LOMETRIC) ;   break ;
     case IDC_MM_HIMETRIC:   SetMapMode (hdc, MM_HIMETRIC) ;   break ;
     case IDC_MM_LOENGLISH:  SetMapMode (hdc, MM_LOENGLISH) ;  break ;
     case IDC_MM_HIENGLISH:  SetMapMode (hdc, MM_HIENGLISH) ;  break ;
     case IDC_MM_TWIPS:      SetMapMode (hdc, MM_TWIPS) ;      break ;
     case IDC_MM_LOGTWIPS:
          SetMapMode (hdc, MM_ANISOTROPIC) ;
          SetWindowExtEx (hdc, 1440, 1440, NULL) ;
          SetViewportExtEx (hdc, GetDeviceCaps (hdc, LOGPIXELSX),
                                 GetDeviceCaps (hdc, LOGPIXELSY), NULL) ;
          break ;
     }
}
</pre>
</td></tr></table>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="616"><h3>PICKFONT.RC</h3></A><P><pre>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;

/////////////////////////////////////////////////////////////////////////////
// Dialog

PICKFONT DIALOG DISCARDABLE  0, 0, 348, 308
STYLE WS_CHILD | WS_VISIBLE | WS_BORDER
FONT 8, &quot;MS Sans Serif&quot;
BEGIN
    LTEXT           &quot;&amp;Height:&quot;,IDC_STATIC,8,10,44,8
    EDITTEXT        IDC_LF_HEIGHT,64,8,24,12,ES_AUTOHSCROLL
    LTEXT           &quot;&amp;Width&quot;,IDC_STATIC,8,26,44,8
    EDITTEXT        IDC_LF_WIDTH,64,24,24,12,ES_AUTOHSCROLL
    LTEXT           &quot;Escapement:&quot;,IDC_STATIC,8,42,44,8
    EDITTEXT        IDC_LF_ESCAPE,64,40,24,12,ES_AUTOHSCROLL
    LTEXT           &quot;Orientation:&quot;,IDC_STATIC,8,58,44,8
    EDITTEXT        IDC_LF_ORIENT,64,56,24,12,ES_AUTOHSCROLL
    LTEXT           &quot;Weight:&quot;,IDC_STATIC,8,74,44,8
    EDITTEXT        IDC_LF_WEIGHT,64,74,24,12,ES_AUTOHSCROLL
    GROUPBOX        &quot;Mapping Mode&quot;,IDC_STATIC,97,3,96,90,WS_GROUP
    CONTROL         &quot;Text&quot;,IDC_MM_TEXT,&quot;Button&quot;,BS_AUTORADIOBUTTON,104,13,56,
                    8
    CONTROL         &quot;Low Metric&quot;,IDC_MM_LOMETRIC,&quot;Button&quot;,BS_AUTORADIOBUTTON,
                    104,24,56,8
    CONTROL         &quot;High Metric&quot;,IDC_MM_HIMETRIC,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,104,35,56,8
    CONTROL         &quot;Low English&quot;,IDC_MM_LOENGLISH,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,104,46,56,8
    CONTROL         &quot;High English&quot;,IDC_MM_HIENGLISH,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,104,57,56,8
    CONTROL         &quot;Twips&quot;,IDC_MM_TWIPS,&quot;Button&quot;,BS_AUTORADIOBUTTON,104,68,
                    56,8
    CONTROL         &quot;Logical Twips&quot;,IDC_MM_LOGTWIPS,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,104,79,64,8
    CONTROL         &quot;Italic&quot;,IDC_LF_ITALIC,&quot;Button&quot;,BS_AUTOCHECKBOX | 
                    WS_TABSTOP,8,90,48,12
    CONTROL         &quot;Underline&quot;,IDC_LF_UNDER,&quot;Button&quot;,BS_AUTOCHECKBOX | 
                    WS_TABSTOP,8,104,48,12
    CONTROL         &quot;Strike Out&quot;,IDC_LF_STRIKE,&quot;Button&quot;,BS_AUTOCHECKBOX | 
                    WS_TABSTOP,8,118,48,12
    CONTROL         &quot;Match Aspect&quot;,IDC_MATCH_ASPECT,&quot;Button&quot;,BS_AUTOCHECKBOX | 
                    WS_TABSTOP,60,104,62,8
    CONTROL         &quot;Adv Grfx Mode&quot;,IDC_ADV_GRAPHICS,&quot;Button&quot;,
                    BS_AUTOCHECKBOX | WS_TABSTOP,60,118,62,8
    LTEXT           &quot;Character Set:&quot;,IDC_STATIC,8,137,46,8
    EDITTEXT        IDC_LF_CHARSET,58,135,24,12,ES_AUTOHSCROLL
    PUSHBUTTON      &quot;?&quot;,IDC_CHARSET_HELP,90,135,14,14
    GROUPBOX        &quot;Quality&quot;,IDC_STATIC,132,98,62,48,WS_GROUP
    CONTROL         &quot;Default&quot;,IDC_DEFAULT_QUALITY,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,136,110,40,8
    CONTROL         &quot;Draft&quot;,IDC_DRAFT_QUALITY,&quot;Button&quot;,BS_AUTORADIOBUTTON,
                    136,122,40,8
    CONTROL         &quot;Proof&quot;,IDC_PROOF_QUALITY,&quot;Button&quot;,BS_AUTORADIOBUTTON,
                    136,134,40,8
    LTEXT           &quot;Face Name:&quot;,IDC_STATIC,8,154,44,8
    EDITTEXT        IDC_LF_FACENAME,58,152,136,12,ES_AUTOHSCROLL
    GROUPBOX        &quot;Output Precision&quot;,IDC_STATIC,8,166,118,133,WS_GROUP
    CONTROL         &quot;OUT_DEFAULT_PRECIS&quot;,IDC_OUT_DEFAULT,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,12,178,112,8
    CONTROL         &quot;OUT_STRING_PRECIS&quot;,IDC_OUT_STRING,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,12,191,112,8
    CONTROL         &quot;OUT_CHARACTER_PRECIS&quot;,IDC_OUT_CHARACTER,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,12,204,112,8
    CONTROL         &quot;OUT_STROKE_PRECIS&quot;,IDC_OUT_STROKE,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,12,217,112,8
    CONTROL         &quot;OUT_TT_PRECIS&quot;,IDC_OUT_TT,&quot;Button&quot;,BS_AUTORADIOBUTTON,
                    12,230,112,8
    CONTROL         &quot;OUT_DEVICE_PRECIS&quot;,IDC_OUT_DEVICE,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,12,243,112,8
    CONTROL         &quot;OUT_RASTER_PRECIS&quot;,IDC_OUT_RASTER,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,12,256,112,8
    CONTROL         &quot;OUT_TT_ONLY_PRECIS&quot;,IDC_OUT_TT_ONLY,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,12,269,112,8
    CONTROL         &quot;OUT_OUTLINE_PRECIS&quot;,IDC_OUT_OUTLINE,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,12,282,112,8
    GROUPBOX        &quot;Pitch&quot;,IDC_STATIC,132,166,62,50,WS_GROUP
    CONTROL         &quot;Default&quot;,IDC_DEFAULT_PITCH,&quot;Button&quot;,BS_AUTORADIOBUTTON,
                    137,176,52,8
    CONTROL         &quot;Fixed&quot;,IDC_FIXED_PITCH,&quot;Button&quot;,BS_AUTORADIOBUTTON,137,
                    189,52,8
    CONTROL         &quot;Variable&quot;,IDC_VARIABLE_PITCH,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,137,203,52,8
    GROUPBOX        &quot;Family&quot;,IDC_STATIC,132,218,62,82,WS_GROUP
    CONTROL         &quot;Don't Care&quot;,IDC_FF_DONTCARE,&quot;Button&quot;,BS_AUTORADIOBUTTON,
                    137,229,52,8
    CONTROL         &quot;Roman&quot;,IDC_FF_ROMAN,&quot;Button&quot;,BS_AUTORADIOBUTTON,137,241,
                    52,8
    CONTROL         &quot;Swiss&quot;,IDC_FF_SWISS,&quot;Button&quot;,BS_AUTORADIOBUTTON,137,253,
                    52,8
    CONTROL         &quot;Modern&quot;,IDC_FF_MODERN,&quot;Button&quot;,BS_AUTORADIOBUTTON,137,
                    265,52,8
    CONTROL         &quot;Script&quot;,IDC_FF_SCRIPT,&quot;Button&quot;,BS_AUTORADIOBUTTON,137,
                    277,52,8
    CONTROL         &quot;Decorative&quot;,IDC_FF_DECORATIVE,&quot;Button&quot;,
                    BS_AUTORADIOBUTTON,137,289,52,8
    DEFPUSHBUTTON   &quot;OK&quot;,IDOK,247,286,50,14
    GROUPBOX        &quot;Text Metrics&quot;,IDC_STATIC,201,2,140,272,WS_GROUP
    LTEXT           &quot;Height:&quot;,IDC_STATIC,207,12,64,8
    LTEXT           &quot;0&quot;,IDC_TM_HEIGHT,281,12,44,8
    LTEXT           &quot;Ascent:&quot;,IDC_STATIC,207,22,64,8
    LTEXT           &quot;0&quot;,IDC_TM_ASCENT,281,22,44,8
    LTEXT           &quot;Descent:&quot;,IDC_STATIC,207,32,64,8
    LTEXT           &quot;0&quot;,IDC_TM_DESCENT,281,32,44,8
    LTEXT           &quot;Internal Leading:&quot;,IDC_STATIC,207,42,64,8
    LTEXT           &quot;0&quot;,IDC_TM_INTLEAD,281,42,44,8
    LTEXT           &quot;External Leading:&quot;,IDC_STATIC,207,52,64,8
    LTEXT           &quot;0&quot;,IDC_TM_EXTLEAD,281,52,44,8
    LTEXT           &quot;Ave Char Width:&quot;,IDC_STATIC,207,62,64,8
    LTEXT           &quot;0&quot;,IDC_TM_AVECHAR,281,62,44,8
    LTEXT           &quot;Max Char Width:&quot;,IDC_STATIC,207,72,64,8
    LTEXT           &quot;0&quot;,IDC_TM_MAXCHAR,281,72,44,8
    LTEXT           &quot;Weight:&quot;,IDC_STATIC,207,82,64,8
    LTEXT           &quot;0&quot;,IDC_TM_WEIGHT,281,82,44,8
    LTEXT           &quot;Overhang:&quot;,IDC_STATIC,207,92,64,8
    LTEXT           &quot;0&quot;,IDC_TM_OVERHANG,281,92,44,8
    LTEXT           &quot;Digitized Aspect X:&quot;,IDC_STATIC,207,102,64,8
    LTEXT           &quot;0&quot;,IDC_TM_DIGASPX,281,102,44,8
    LTEXT           &quot;Digitized Aspect Y:&quot;,IDC_STATIC,207,112,64,8
    LTEXT           &quot;0&quot;,IDC_TM_DIGASPY,281,112,44,8
    LTEXT           &quot;First Char:&quot;,IDC_STATIC,207,122,64,8
    LTEXT           &quot;0&quot;,IDC_TM_FIRSTCHAR,281,122,44,8
    LTEXT           &quot;Last Char:&quot;,IDC_STATIC,207,132,64,8
    LTEXT           &quot;0&quot;,IDC_TM_LASTCHAR,281,132,44,8
    LTEXT           &quot;Default Char:&quot;,IDC_STATIC,207,142,64,8
    LTEXT           &quot;0&quot;,IDC_TM_DEFCHAR,281,142,44,8
    LTEXT           &quot;Break Char:&quot;,IDC_STATIC,207,152,64,8
    LTEXT           &quot;0&quot;,IDC_TM_BREAKCHAR,281,152,44,8
    LTEXT           &quot;Italic?&quot;,IDC_STATIC,207,162,64,8
    LTEXT           &quot;0&quot;,IDC_TM_ITALIC,281,162,44,8
    LTEXT           &quot;Underlined?&quot;,IDC_STATIC,207,172,64,8
    LTEXT           &quot;0&quot;,IDC_TM_UNDER,281,172,44,8
    LTEXT           &quot;Struck Out?&quot;,IDC_STATIC,207,182,64,8
    LTEXT           &quot;0&quot;,IDC_TM_STRUCK,281,182,44,8
    LTEXT           &quot;Variable Pitch?&quot;,IDC_STATIC,207,192,64,8
    LTEXT           &quot;0&quot;,IDC_TM_VARIABLE,281,192,44,8
    LTEXT           &quot;Vector Font?&quot;,IDC_STATIC,207,202,64,8
    LTEXT           &quot;0&quot;,IDC_TM_VECTOR,281,202,44,8
    LTEXT           &quot;TrueType Font?&quot;,IDC_STATIC,207,212,64,8
    LTEXT           &quot;0&quot;,IDC_TM_TRUETYPE,281,212,44,8
    LTEXT           &quot;Device Font?&quot;,IDC_STATIC,207,222,64,8
    LTEXT           &quot;0&quot;,IDC_TM_DEVICE,281,222,44,8
    LTEXT           &quot;Family:&quot;,IDC_STATIC,207,232,64,8
    LTEXT           &quot;0&quot;,IDC_TM_FAMILY,281,232,44,8
    LTEXT           &quot;Character Set:&quot;,IDC_STATIC,207,242,64,8
    LTEXT           &quot;0&quot;,IDC_TM_CHARSET,281,242,44,8
    LTEXT           &quot;0&quot;,IDC_TM_FACENAME,207,262,128,8
END

/////////////////////////////////////////////////////////////////////////////
// Menu

PICKFONT MENU DISCARDABLE 
BEGIN
    POPUP &quot;&amp;Device&quot;
    BEGIN
        MENUITEM &quot;&amp;Screen&quot;,                     IDM_DEVICE_SCREEN, CHECKED
        MENUITEM &quot;&amp;Printer&quot;,                    IDM_DEVICE_PRINTER
    END
END
</pre>
</td></tr></table>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="617"><h3>RESOURCE.H</h3></A><P><pre>
// Microsoft Developer Studio generated include file.
// Used by PickFont.rc

#define IDC_LF_HEIGHT                   1000
#define IDC_LF_WIDTH                    1001
#define IDC_LF_ESCAPE                   1002
#define IDC_LF_ORIENT                   1003
#define IDC_LF_WEIGHT                   1004
#define IDC_MM_TEXT                     1005
#define IDC_MM_LOMETRIC                 1006
#define IDC_MM_HIMETRIC                 1007
#define IDC_MM_LOENGLISH                1008
#define IDC_MM_HIENGLISH                1009
#define IDC_MM_TWIPS                    1010
#define IDC_MM_LOGTWIPS                 1011
#define IDC_LF_ITALIC                   1012
#define IDC_LF_UNDER                    1013
#define IDC_LF_STRIKE                   1014
#define IDC_MATCH_ASPECT                1015
#define IDC_ADV_GRAPHICS                1016
#define IDC_LF_CHARSET                  1017
#define IDC_CHARSET_HELP                1018
#define IDC_DEFAULT_QUALITY             1019
#define IDC_DRAFT_QUALITY               1020
#define IDC_PROOF_QUALITY               1021
#define IDC_LF_FACENAME                 1022
#define IDC_OUT_DEFAULT                 1023
#define IDC_OUT_STRING                  1024
#define IDC_OUT_CHARACTER               1025
#define IDC_OUT_STROKE                  1026
#define IDC_OUT_TT                      1027
#define IDC_OUT_DEVICE                  1028
#define IDC_OUT_RASTER                  1029
#define IDC_OUT_TT_ONLY                 1030
#define IDC_OUT_OUTLINE                 1031
#define IDC_DEFAULT_PITCH               1032
#define IDC_FIXED_PITCH                 1033
#define IDC_VARIABLE_PITCH              1034
#define IDC_FF_DONTCARE                 1035
#define IDC_FF_ROMAN                    1036
#define IDC_FF_SWISS                    1037
#define IDC_FF_MODERN                   1038
#define IDC_FF_SCRIPT                   1039
#define IDC_FF_DECORATIVE               1040
#define IDC_TM_HEIGHT                   1041
#define IDC_TM_ASCENT                   1042
#define IDC_TM_DESCENT                  1043
#define IDC_TM_INTLEAD                  1044
#define IDC_TM_EXTLEAD                  1045
#define IDC_TM_AVECHAR                  1046
#define IDC_TM_MAXCHAR                  1047
#define IDC_TM_WEIGHT                   1048
#define IDC_TM_OVERHANG                 1049
#define IDC_TM_DIGASPX                  1050
#define IDC_TM_DIGASPY                  1051
#define IDC_TM_FIRSTCHAR                1052
#define IDC_TM_LASTCHAR                 1053
#define IDC_TM_DEFCHAR                  1054
#define IDC_TM_BREAKCHAR                1055
#define IDC_TM_ITALIC                   1056
#define IDC_TM_UNDER                    1057
#define IDC_TM_STRUCK                   1058
#define IDC_TM_VARIABLE                 1059
#define IDC_TM_VECTOR                   1060
#define IDC_TM_TRUETYPE                 1061
#define IDC_TM_DEVICE                   1062
#define IDC_TM_FAMILY                   1063
#define IDC_TM_CHARSET                  1064
#define IDC_TM_FACENAME                 1065
#define IDM_DEVICE_SCREEN               40001
#define IDM_DEVICE_PRINTER              40002
</pre>
</td></tr></table>

<p>Figure 17-2 shows a typical PICKFONT screen. The left side of the PICKFONT display is a modeless dialog box that allows you to select most of the fields of the logical font structure. The right side of the dialog box shows the results of <I>GetTextMetrics</I> after the font is selected in the device context. Below the dialog box, the program displays a string of characters using this font. Because the modeless dialog box is so big, you're best off running this program on a display size of 1024 by 768 or larger.

<p><A HREF="javascript:fullSize('F17zg02x.htm')"><IMG SRC="F17zg02.JPG" width=404 height=258 ALIGN="BOTTOM" BORDER=0 ALT="click to view full size"></A>

<P><!-- caption --><B>Figure 17-2.</b> <i>A typical PICKFONT display (Unicode version under Windows NT).</I><!-- /caption -->

<p>The modeless dialog box also contains some options that are not part of the logical font structure. These are the mapping mode, including my Logical Twips mode; the Match Aspect option, which changes the way Windows matches a logical font to a real font; and &quot;Adv Grfx Mode,&quot; which sets the advanced graphics mode in Windows NT. I'll discuss these in more detail shortly.

<p>From the Device menu you can select the default printer rather than the video display. In this case, PICKFONT selects the logical font into the printer device context and displays the TEXTMETRIC structure from the printer. The program then selects the logical font into the window device context for displaying the sample string. Thus, the text displayed by the program might use a different font (a screen font) than the font described by the list of the TEXTMETRIC fields (which is a printer font).

<p>Much of the PICKFONT program contains the logic necessary to maintain the dialog box, so I won't go into detail on the workings of the program. Instead, I'll explain what you're doing when you create and select a logical font.

<A NAME="618"><h2>The Logical Font Structure</h2></A>
<p>To create a logical font, you can call <I>CreateFont</I>, a function that has 14 arguments. Generally, it's easier to define a structure of type LOGFONT,

<P><pre>
LOGFONT lf ;
</PRE>

<p>and then define the fields of this structure. When finish, you call <I>CreateFontIndirect</I> with a pointer to the structure:

<P><pre>
hFont = CreatFontIndirect (&amp;lf) ;
</PRE>

<p>You don't need to set each and every field of the LOGFONT structure. If your logical font structure is defined as a static variable, all the fields will be initialized to 0. The 0 values are generally defaults. You can then use that structure directly without any changes, and <I>CreateFontIndirect</I> will return a handle to a font. When you select that font into the device context, you'll get a reasonable default font. You can be as specific or as vague as you want in the LOGFONT structure, and Windows will attempt to match your requests with a real font.

<p>As I discuss each field of the LOGFONT structure, you may want to test them out using the PICKFONT program. Be sure to press Enter or the OK button when you want the program to use any fields you've entered.

<p>The first two fields of the LOGFONT structure are in logical units, so they depend on the current setting of the mapping mode:

<UL>
<p><li><I>lfHeight</I> This is the desired height of the characters in logical units. You can set <I>lfHeight</I> to 0 for a default size, or you can set it to a positive or negative value depending on what you want the field to represent. If you set <I>lfHeightW</I> to a positive value, you're implying that you want this value to be a height that includes internal leading (but not external leading). In effect, you're really requesting a font that is appropriate for a line spacing of <I>lfHeight</I>. If you set <I>lfHeight</I> to a negative value, Windows treats the absolute value of that number as a desired font height compatible with the point size. This is an important distinction: If you want a font of a particular point size, convert that point size to logical units and set the <I>lfHeight</I> field to the negative of that value. If <I>lfHeight</I> is positive, the <I>tmHeight</I> field of the resultant TEXTMETRIC structure will be roughly that value. (It's sometimes a little off, probably because of rounding.) If <I>lfHeight</I> is negative, it will roughly match the <I>tmHeight</I> field of the TEXTMETRIC structure less the <I>tmInternalLeading</I> field.

<p><li><I>lfWidth</I> This is the desired width of the characters in logical units. In most cases, you'll want to set this value to 0 and let Windows choose a font based solely on the height. Using a nonzero value does not work well with raster fonts, but with TrueType fonts you can easily use this to get a font that has wider or slimmer characters than normal. This field corresponds to the <I>tmAveCharWidth</I> field of the TEXTMETRIC structure. To use the <I>lfWidth</I> field intelligently, first set up the LOGFONT structure with a <I>lfWidth</I> field set to 0, create the logical font, select it into a device context, and then call <I>GetTextMetrics</I>. Get the <I>tmAveCharWidth</I> field, adjust it up or down, probably by a percentage, and then create a second font using that adjusted <I>tmAveCharWidth</I> value for <I>lfWidth</I>.
</UL>

<p>The next two fields specify the &quot;escapement&quot; and &quot;orientation&quot; of the text. In theory, <I>lfEscapement</I> allows character strings to be written at an angle (but with the baseline of each character still parallel to the horizontal axis) and <I>lfOrientation</I> allows individual characters to be tilted. These fields have never quite worked as advertised, and even today they don't work as they should except in one case: you're using a TrueType font, you're running Windows NT, and you call <I>SetGraphicsMode</I> with the CM_ADVANCED flag set. You can accomplish the final requirement in PICKFONT by checking the &quot;Adv Grfx Mode&quot; check box.

<p>To experiment with these fields in PICKFONT, be aware that the units are in tenths of a degree and indicate a counterclockwise rotation. It's easy to enter values that cause the sample text string to disappear! For this reason, use values between 0 and -600 (or so) or values between 3000 and 3600.
<UL>

<p><li><I>lfEscapement</I> This is an angle in tenths of a degree, measured from the horizontal in a counterclockwise direction. It specifies how the successive characters of a string are placed when you write text. Here are some examples:

<P><table cellpadding=5 width="95%">
<tr><td valign="top"><i><b>Value</b></i></td><td valign="top"><i><b>Placement of Characters</b></i></td></tr>
<tr><td valign="top">0</td><td valign="top">Run from left to right (default)</td></tr>
<tr><td valign="top">900</td><td valign="top">Go up</td></tr>
<tr><td valign="top">1800</td><td valign="top">Run from right to left</td></tr>
<tr><td valign="top">2700</td><td valign="top">Go down</td></tr>
</table>

<p>In Windows 98, this value sets both the escapement and orientation of TrueType text. In Windows NT, this value also normally sets both the escapement and orientation of TrueType text, except when you call <I>SetGraphicsMode</I> with the GM_ADVANCED argument, in which case it works as documented.


<p><li><I>lfOrientation</I> This is an angle in tenths of a degree, measured from the horizontal in a counterclockwise direction. It affects the appearance of each individual character. Here are some examples:

<table cellpadding=5 width="95%">
<tr><td valign="top"><i><b>Value</b></i></td><td valign="top"><i><b>Character Appearance</b></i></td></tr>
<tr><td valign="top">0</td><td valign="top">Normal (default)</td></tr>
<tr><td valign="top">900</td><td valign="top">Tipped 90 degrees to the right</td></tr>
<tr><td valign="top">1800</td><td valign="top">Upside down</td></tr>
<tr><td valign="top">2700</td><td valign="top">Tipped 90 degrees to the left</td></tr>
</table>

<p>This field has no effect except with a TrueType font under Windows NT with the graphics mode set to GM_ADVANCED, in which case it works as documented.

<p>The remaining 10 fields follow:


<p><li><I>lfWeight</I> This field allows you to specify boldface. The WINGDI.H header file defines a bunch of values to use with this field:


<table cellpadding=5 width="95%">
<tr><td valign="top"><i><b>Value</b></i></td><td valign="top"><i><b>Identifier</b></i></td></tr>
<tr><td valign="top">0</td><td valign="top">FW_DONTCARE</td></tr>
<tr><td valign="top">100</td><td valign="top">FW_THIN</td></tr>
<tr><td valign="top">200</td><td valign="top">FW_EXTRALIGHT or FW_ULTRALIGHT</td></tr>
<tr><td valign="top">300</td><td valign="top">FW_LIGHT</td></tr>
<tr><td valign="top">400</td><td valign="top">FW_NORMAL or FW_REGULAR</td></tr>
<tr><td valign="top">500</td><td valign="top">FW_MEDIUM</td></tr>
<tr><td valign="top">600</td><td valign="top">FW_SEMIBOLD or FW_DEMIBOLD</td></tr>
<tr><td valign="top">700</td><td valign="top">FW_BOLD</td></tr>
<tr><td valign="top">800</td><td valign="top">FW_EXTRABOLD or FW_ULTRABOLD</td></tr>
<tr><td valign="top">900</td><td valign="top">FW_HEAVY or FW_BLACK</td></tr>
</table>

<p>In reality, this table is much more ambitious than anything that was ever implemented. You can use 0 or 400 for normal and 700 for bold.


<p><li><I>lfItalic</I> When nonzero, this specifies italics. Windows can synthesize italics on GDI raster fonts. That is, Windows simply shifts some rows of the character bitmap to mimic italic. With TrueType fonts, Windows uses the actual italic or oblique version of the font.

<p><li><I>lfUnderline</I> When nonzero, this specifies underlining, which is always synthesized on GDI fonts. That is, the Windows GDI simply draws a line under each character, including spaces.

<p><li><I>lfStrikeOut</I> When nonzero, this specifies that the font should have a line drawn through the characters. This is also synthesized on GDI fonts.

<p><li><I>lfCharSet</I> This is a byte value that specifies the character set of the font. I'll have more to say about this field in the upcoming section, &quot;<A HREF="ch17d.htm#621">Character Sets and Unicode</A>&quot;. In PICKFONT, you can press the button with the question mark to obtain a list of the character set codes you can use.

<p>Notice that the <I>lfCharSet</I> field is the only field where a zero does not indicate a default value. A zero value is equivalent to ANSI_CHARSET, the ANSI character set used in the United States and Western Europe. The DEFAULT_CHARSET code, which equals 1, indicates the default character set for the machine on which the program is running.


<p><li><I>lfOutPrecision</I> This specifies how Windows should attempt to match the desired font sizes and characteristics with actual fonts. It's a rather complex field that you probably won't use much. Check the documentation of the LOGFONT structure for more detail. Note that you can use the OUT_TT_ONLY_PRECIS flag to ensure that you always get a TrueType font.

<p><li><I>lfClipPrecision</I> This field specifies how characters are to be clipped when they lie partially outside the clipping region. This field is not used much and is not implemented in the PICKFONT program.

<p><li><I>lfQuality</I> This is an instruction to Windows regarding the matching of a desired font with a real font. It really has meaning with raster fonts only and should not affect TrueType fonts. The DRAFT_QUALITY flag indicates that you want GDI to scale raster fonts to achieve the size you want; the PROOF_QUALITY flag indicates no scaling should be done. The PROOF_QUALITY fonts are the most attractive, but they might be smaller than what you request. You'll probably use DEFAULT_QUALITY (or 0) in this field.

<p><li><I>lfPitchAndFamily</I> This byte is composed of two parts. You can use the C bitwise OR operator to combine two identifiers for this field. The lowest two bits specify whether the font has a fixed pitch (that is, all characters are the same width) or a variable pitch:

<P><table cellpadding=5 width="95%">
<tr><td valign="top"><i><b>Value</b></i></td><td valign="top"><i><b>Identifier</b></i></td></tr>
<tr><td valign="top">0</td><td valign="top">DEFAULT_PITCH</td></tr>
<tr><td valign="top">1</td><td valign="top">FIXED_PITCH</td></tr>
<tr><td valign="top">2</td><td valign="top">VARIABLE_PITCH</td></tr>
</table>

<p>The upper half of this byte specifies the font family:

<P><table cellpadding=5 width="95%">
<tr><td valign="top"><i><b>Value</b></i></td><td valign="top"><i><b>Identifier</b></i></td></tr>
<tr><td valign="top">0x00</td><td valign="top">FW_DONTCARE</td></tr>
<tr><td valign="top">0x10</td><td valign="top">FF_ROMAN (variable widths, serifs)</td></tr>
<tr><td valign="top">0x20</td><td valign="top">FF_SWISS (variable widths, no serifs)</td></tr>
<tr><td valign="top">0x30</td><td valign="top">FF_MODERN (fixed pitch)</td></tr>
<tr><td valign="top">0x40</td><td valign="top">FF_SCRIPT (mimics handwriting)</td></tr>
<tr><td valign="top">0x50</td><td valign="top">FF_DECORATIVE</td></tr>
</table>

<p><li><I>lfFaceName</I> This is the actual text name of a typeface (such as Courier, Arial, or Times New Roman). This field is a byte array that is LF_FACESIZE (or 32 characters) wide. If you want a TrueType italic or boldface font, you can get it in one of two ways. You can use the complete typeface name (such as Times New Roman Italic) in the <I>lfFaceName</I> field, or you can use the base name (that is, Times New Roman) and set the <I>lfItalic</I> field.
</UL>

<A NAME="619"><h2>The Font-Mapping Algorithm</h2></A>
<p>After you set up the logical font structure, you call <I>CreateFontIndirect</I> to get a handle to the logical font. When you call <I>SelectObject</I> to select that logical font into a device context, Windows finds the real font that most closely matches the request. In doing so, it uses a &quot;font-mapping algorithm.&quot; Certain fields of the structure are considered more important than other fields.

<p>The best way to get a feel for font mapping is to spend some time experimenting with PICKFONT. Here are some general guidelines:

<UL>
<p><li>The <I>lfCharSet</I> (character set) field is very important. It used to be that if you specified OEM_CHARSET (255), you'd get either one of the stroke fonts or the Terminal font because these were the only fonts that used the OEM character sets. However, with the advent of TrueType &quot;Big Fonts&quot;, a single TrueType font can be mapped to different character sets, including the OEM character set. You'll need to use SYMBOL_CHARSET (2) to get the Symbol font or the Wingdings font.

<p><li>A pitch value of FIXED_PITCH in the <I>lfPitchAndFamily</I> field is important because you are in effect telling Windows that you don't want to deal with a variable-width font.

<p><li>The <I>lfFaceName</I> field is important because you're being specific about the typeface of the font that you want. If you leave <I>lfFaceName</I> set to NULL and set the family value in the <I>lfPitchAndFamily</I> field to a value other than FF_DONTCARE, that field becomes important because you're being specific about the font family.

<p><li>For raster fonts, Windows will attempt to match the <I>lfHeight</I> value even if it needs to increase the size of a smaller font. The height of the actual font will always be less than or equal to that of the requested font unless there is no font small enough to satisfy your request. For stroke or TrueType fonts, Windows will simply scale the font to the desired height.

<p><li>You can prevent Windows from scaling a raster font by setting <I>lfQuality</I> to PROOF_QUALITY. By doing so, you're telling Windows that the requested height of the font is less important than the appearance of the font.

<p><li>If you specify <I>lfHeight</I> and <I>lfWeight</I> values that are out of line for the particular aspect ratio of the display, Windows can map to a raster font that is designed for a display or other device of a different aspect ratio. This used to be a trick to get a thin or thick font. (This is not really necessary with TrueType, of course.) In general, you'll probably want to avoid matching with a font for another device, which you can do in PICKFONT by clicking the check box marked Match Aspect. If this box is checked, PICKFONT makes a call to <I>SetMapperFlags</I> with a TRUE argument.
</UL>

<A NAME="620"><h2>Finding Out About the Font</h2></A>
<p>At the right side of the modeless dialog box in PICKFONT is the information obtained from the <I>GetTextMetrics</I> function after the font has been selected in a device context. (Notice that you can use PICKFONT's device menu to indicate whether you want this device context to be the screen or the default printer. The results might be different because different fonts might be available on the printer.) At the bottom of the list in PICKFONT is the typeface name available from <I>GetTextFace</I>.

<p>All the size values that Windows copies into the TEXTMETRIC structure are in logical units except for the digitized aspect ratios. The fields of the TEXTMETRIC structure are as follows:

<UL>
<p><li><I>tmHeight</I> The height of the character in logical units. This is the value that should approximate the <I>lfHeight</I> field specified in the LOGFONT structure, if that value was positive, in which case it represents the line spacing of the font rather than the point size. If the <I>lfHeight</I> field of the LOGFONT structure was negative, the <I>tmHeight</I> field minus the <I>tmInternalLeading</I> field should approximate the absolute value of the <I>lfHeight</I> field.

<p><li><I>tmAscent</I> The vertical size of the character above the baseline in logical units.

<p><li><I>tmDescent</I> The vertical size of the character below the baseline in logical units.

<p><li><I>tmInternalLeading</I> A vertical size included in the <I>tmHeight</I> value that is usually occupied by diacritics on some capital letters. Once again, you can calculate the point size of the font by subtracting the <I>tmInternalLeading</I> value from the <I>tmHeight</I> value.

<p><li><I>tmExternalLeading</I> An additional amount of line spacing beyond <I>tmHeight</I> recommended by the designer of the font for spacing successive lines of text.

<p><li><I>tmAveCharWidth</I> The average width of lowercase letters in the font.

<p><li><I>tmMaxCharWidth</I> The width of the widest character in logical units. For a fixed-pitch font, this value is the same as <I>tmAveCharWidth</I>.

<p><li><I>tmWeight</I> The weight of the font ranging from 0 through 999. In reality, the field will be 400 for a normal font and 700 for a boldface font.

<p><li><I>tmOverhang</I> The amount of extra width (in logical units) that Windows adds to a raster font character when synthesizing italic or boldface. When a raster font is italicized, the <I>tmAveCharWidth</I> value remains unchanged, because a string of italicized characters has the same overall width as the same string of normal characters. For boldfacing, Windows must slightly expand the width of each character. For a boldface font, the <I>tmAveCharWidth</I> value less the <I>tmOverhang</I> value equals the <I>tmAveCharWidth</I> value for the same font without boldfacing.

<p><li><I>tmDigitizedAspectX</I> and <I>tmDigitizedAspectY</I> The aspect ratio for which the font is appropriate. These are equivalent to values obtained from <I>GetDeviceCaps</I> with the LOGPIXELSX and LOGPIXELSY identifiers.

<p><li><I>tmFirstChar</I> The character code of the first character in the font.

<p><li><I>tmLastChar</I> The character code of the last character in the font. If the TEXTMETRIC structure is obtained by a call to <I>GetTextMetricsW</I> (the wide character version of the function), then this value might be greater than 255.

<p><li><I>tmDefaultChar</I> The character code that Windows uses to display characters that are not in the font, usually a rectangle.

<p><li><I>tmBreakChar</I> The character that Windows, and your programs, should use to determine word breaks when justifying text. Unless you're using something bizarre (such as an EBCDIC font), this will be 32&#8212;the space character.

<p><li><I>tmItalic</I> Nonzero for an italic font.

<p><li><I>tmUnderlined</I> Nonzero for an underlined font.

<p><li><I>tmStruckOut</I> Nonzero for a strikethrough font.

<p><li><I>tmPitchAndFamily</I> The four low-order bits are flags that indicate some characteristics about the font, indicated by the following identifiers defined in WINGDI.H:

<P><table cellpadding=5 width="95%">
<tr><td valign="top"><i><b>Value</b></i></td><td valign="top"><i><b>Identifier</b></i></td></tr>
<tr><td valign="top">0x01</td><td valign="top">TMPF_FIXED_PITCH</td></tr>
<tr><td valign="top">0x02</td><td valign="top">TMPF_VECTOR</td></tr>
<tr><td valign="top">0x04</td><td valign="top">TMPF_TRUETYPE</td></tr>
<tr><td valign="top">0x08</td><td valign="top">TMPF_DEVICE</td></tr>
</table>

<p>Despite the name of the TMPF_FIXED_PITCH flag, the lowest bit is 1 if the font characters have a <I>variable</I> pitch. The second lowest bit (TMPF_VECTOR) will be 1 for TrueType fonts and fonts that use other scaleable outline technologies, such as PostScript. The TMPF_DEVICE flag indicates a device font (that is, a font built into a printer) rather than a GDI-based font.

<p>The top four bits of this field indicate the font family and are the same values used in the LOGFONT <I>lfPitchAndFamily</I> field.

<p><li><I>tmCharSet</I> The character set identifier.
</UL>

<A NAME="621"><h2>Character Sets and Unicode</h2></A>
<p>I discussed the concept of the Windows character set in <a href="ch06a.htm#144">Chapter 6</a>, where we had to deal with international issues involving the keyboard. In the LOGFONT and TEXTMETRIC structures, the character set of the desired font (or the actual font) is indicated by a one-byte number between 0 and 255. The character set identifiers are defined in WINGDI.H like so:

<P><pre>
#define ANSI_CHARSET            0
#define DEFAULT_CHARSET         1
#define SYMBOL_CHARSET          2
#define MAC_CHARSET             77
#define SHIFTJIS_CHARSET        128
#define HANGEUL_CHARSET         129
#define HANGUL_CHARSET          129
#define JOHAB_CHARSET           130
#define GB2312_CHARSET          134
#define CHINESEBIG5_CHARSET     136
#define GREEK_CHARSET           161
#define TURKISH_CHARSET         162
#define VIETNAMESE_CHARSET      163
#define HEBREW_CHARSET          177
#define ARABIC_CHARSET          178
#define BALTIC_CHARSET          186
#define RUSSIAN_CHARSET         204
#define THAI_CHARSET            222
#define EASTEUROPE_CHARSET      238
#define OEM_CHARSET             255
</PRE>

<p>The character set is similar in concept to the code page, but the character set is specific to Windows and is always less than or equal to 255.

<p>As with all of the programs in this book, you can compile PICKFONT both with and without the UNICODE identifier defined. As usual, on the companion disc, the two versions of the program are located in the DEBUG and RELEASE directories, respectively.

<p>Notice that the character string that PICKFONT displays towards the bottom of its window is longer in the Unicode version of the program. In both versions, the character string begins with the character codes 0x40 through 0x45 and 0x60 through 0x65. Regardless of the character set you choose (except for SYMBOL_CHARSET), these character codes will display as the first five uppercase and lowercase letters of the Latin alphabet (that is, <I>A</I> through <I>E</I> and <I>a</I> through <I>e</I>).

<p>When running the <I>non-Unicode</I> version of the PICKFONT program, the next 12 characters&#8212;the character codes 0xC0 through 0xC5 and 0xE0 through 0xE5&#8212;will be dependent upon the character set you choose. For ANSI_CHARSET, these character codes correspond to accented versions of the uppercase and lowercase letter <I>A</I>. For GREEK_CHARSET, these codes will correspond to letters of the Greek alphabet. For RUSSIAN_CHARSET, they will be letters of the Cyrillic alphabet. Notice that the font might change when you select one of these character sets. This is because a raster font might not have these characters, but a TrueType font probably will. You'll recall that most TrueType fonts are &quot;Big Fonts&quot; and include characters for several different character sets. If you're running a Far Eastern version of Windows, these characters will be interpreted as double-byte characters and will display as ideographs rather than letters.

<p>When running the <I>Unicode</I> version of PICKFONT under Windows NT, the codes 0xC0 through 0xC5 and 0xE0 through 0xE5 will always (except for SYMBOL_CHARSET) be accented versions of the uppercase and lowercase letter <I>A</I> because that's how these codes are defined in Unicode. The program also displays character codes 0x0390 through 0x0395 and 0x03B0 through 0x03B5. Because of their definition in Unicode, these codes will always correspond to letters of the Greek alphabet. Similarly the program displays character codes 0x0410 through 0x0415 and 0x0430 through 0x0435, which always correspond to letters in the Cyrillic alphabet. However, note that these characters might not be present in a default font. You may have to select the GREEK_CHARSET or RUSSIAN_CHARSET to get them. In this case, the character set ID in the LOGFONT structure doesn't change the actual character set; the character set is always Unicode. The character set ID instead indicates that characters from this character set are desired.

<p>Now select HEBREW_CHARSET (code 177). The Hebrew alphabet is not included in Windows' usual Big Fonts, so the operating system picks Lucida Sans Unicode, as you can verify at the bottom right corner of the modeless dialog box.

<p>PICKFONT also displays character codes 0x5000 through 0x5004, which correspond to a few of the many Chinese, Japanese, and Korean ideographs. You'll see these if you're running a Far Eastern version of Windows, or you can download a free Unicode font that is more extensive than Lucida Sans Unicode. This is the Bitstream CyberBit font, available at <I>http://www.bitstream.com/products/world/cyberbits</I>. (Just to give you an idea of the difference, Lucida Sans Unicode is roughly 300K while Bitstream CyberBit is about 13 megabytes.) If you have this font installed, Windows will select it if you want a character set not supported by Lucida Sans Unicode, such as SHIFTJIS_CHARSET (Japanese), HANGUL_CHARSET (Korean), JOHAB_CHARSET (Korean), GB2312_CHARSET (Simplified Chinese), or CHINESEBIG5_CHARSET (Traditional Chinese).

<p>I'll present a program that lets you view all the characters of a Unicode font later in this chapter.

<A NAME="622"><h2>The EZFONT System</h2></A>
<p>The introduction of TrueType&#8212;and its basis in traditional typography&#8212;has provided Windows with a solid foundation for displaying text in its many varieties. However, some of the Windows font-selection functions are based on older technology, in which raster fonts on the screen had to approximate printer device fonts. In the next section, I'll describe font enumeration, which lets a program obtain a list of all the fonts available on the video display or printer. However, the <I>ChooseFont</I> dialog box (to be discussed shortly) largely eliminates the necessity for font enumeration by a program.

<p>Because the standard TrueType fonts are available on every system, and because these fonts can be used for both the screen and the printer, it's not necessary for a program to enumerate fonts in order to select one, or to blindly request a certain font type that might need to be approximated. A program could simply and precisely select TrueType fonts that it knows to exist on the system (unless, of course, the user has deliberately deleted them). It really should be almost as simple as specifying the name of the font (probably one of the 13 names listed in this book) and its point size. I call this approach EZFONT (&quot;easy font&quot;), and the two files you need are shown in Figure 17-3.

<p><b>Figure 17-3</b> <i>The EZFONT files</i>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="623"><h3>EZFONT.H</h3></A>
<P><pre>

/*----------------------
   EZFONT.H header file
  ----------------------*/

HFONT EzCreateFont (HDC hdc, TCHAR * szFaceName, int iDeciPtHeight,
                    int iDeciPtWidth, int iAttributes, BOOL fLogRes) ;

#define EZ_ATTR_BOLD          1
#define EZ_ATTR_ITALIC        2
#define EZ_ATTR_UNDERLINE     4
#define EZ_ATTR_STRIKEOUT     8
</PRE>
</td></tr></table>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="624"><h3>EZFONT.C</h3></A>
<P><pre>
/*---------------------------------------
   EZFONT.C -- Easy Font Creation
               (c) Charles Petzold, 1998
  ---------------------------------------*/

#include &lt;windows.h&gt;
#include &lt;math.h&gt;
#include &quot;ezfont.h&quot;

HFONT EzCreateFont (HDC hdc, TCHAR * szFaceName, int iDeciPtHeight,
                    int iDeciPtWidth, int iAttributes, BOOL fLogRes)
{
     FLOAT      cxDpi, cyDpi ;
     HFONT      hFont ;
     LOGFONT    lf ;
     POINT      pt ;
     TEXTMETRIC tm ;
     
     SaveDC (hdc) ;
     
     SetGraphicsMode (hdc, GM_ADVANCED) ;
     ModifyWorldTransform (hdc, NULL, MWT_IDENTITY) ;
     SetViewportOrgEx (hdc, 0, 0, NULL) ;
     SetWindowOrgEx   (hdc, 0, 0, NULL) ;
     
     if (fLogRes)
     {
          cxDpi = (FLOAT) GetDeviceCaps (hdc, LOGPIXELSX) ;
          cyDpi = (FLOAT) GetDeviceCaps (hdc, LOGPIXELSY) ;
     }
     else
     {
          cxDpi = (FLOAT) (25.4 * GetDeviceCaps (hdc, HORZRES) /
                                        GetDeviceCaps (hdc, HORZSIZE)) ;
          
          cyDpi = (FLOAT) (25.4 * GetDeviceCaps (hdc, VERTRES) /
                                        GetDeviceCaps (hdc, VERTSIZE)) ;
     }
     
     pt.x = (int) (iDeciPtWidth  * cxDpi / 72) ;
     pt.y = (int) (iDeciPtHeight * cyDpi / 72) ;
     
     DPtoLP (hdc, &amp;pt, 1) ;
     lf.lfHeight         = - (int) (fabs (pt.y) / 10.0 + 0.5) ;
     lf.lfWidth          = 0 ;
     lf.lfEscapement     = 0 ;
     lf.lfOrientation    = 0 ;
     lf.lfWeight         = iAttributes &amp; EZ_ATTR_BOLD      ? 700 : 0 ;
     lf.lfItalic         = iAttributes &amp; EZ_ATTR_ITALIC    ?   1 : 0 ;
     lf.lfUnderline      = iAttributes &amp; EZ_ATTR_UNDERLINE ?   1 : 0 ;
     lf.lfStrikeOut      = iAttributes &amp; EZ_ATTR_STRIKEOUT ?   1 : 0 ;
     lf.lfCharSet        = DEFAULT_CHARSET ;
     lf.lfOutPrecision   = 0 ;
     lf.lfClipPrecision  = 0 ;
     lf.lfQuality        = 0 ;
     lf.lfPitchAndFamily = 0 ;
     
     lstrcpy (lf.lfFaceName, szFaceName) ;
     
     hFont = CreateFontIndirect (&amp;lf) ;
     
     if (iDeciPtWidth != 0)
     {
          hFont = (HFONT) SelectObject (hdc, hFont) ;
          
          GetTextMetrics (hdc, &amp;tm) ;
          
          DeleteObject (SelectObject (hdc, hFont)) ;
          
          lf.lfWidth = (int) (tm.tmAveCharWidth *
                                        fabs (pt.x) / fabs (pt.y) + 0.5) ;
          
          hFont = CreateFontIndirect (&amp;lf) ;
     }
     
     RestoreDC (hdc, -1) ;
     return hFont ;
}
</PRE></td></tr></table>

<p>EZFONT.C has only one function, called <I>EzCreateFont</I>, which you can use like so:

<P><pre>
hFont = EzCreateFont (hdc, szFaceName, iDeciPtHeight, iDeciPtWidth,
                      iAttributes, fLogRes) ;
</PRE>

<p>The function returns a handle to a font. The font can be selected in the device context by calling <I>SelectObject</I>. You should then call <I>GetTextMetrics</I> or <I>GetOutlineTextMetrics</I> to determine the actual size of the font dimensions in logical coordinates. Before your program terminates, you should delete any created fonts by calling <I>DeleteObject</I>.

<p>The <I>szFaceName</I> argument is any TrueType typeface name. The closer you stick to the standard fonts, the less chance there is that the font won't exist on the system.

<p>The third argument indicates the desired point size, but it's specified in &quot;decipoints,&quot; which are 1/10ths of a point. Thus, if you want a point size of 121/2, use a value of 125.

<p>Normally, the fourth argument should be set to zero or made identical to the third argument. However, you can create a TrueType font with a wider or narrower size by setting this argument to something different. This is sometimes called the &quot;em-width&quot; of the font, and it describes the width of the font in points. Don't confuse this with the average width of the font characters or anything like that. Back in the early days of typography, a capital <I>M</I> was as wide as it was high. So, the concept of an &quot;em-square&quot; came into being, and that's the origin of the em-width measurement. When the em-width equals the em-height (the point size of the font), the character widths are as the font designer intended. A smaller or wider em-width lets you create slimmer or wider characters.

<p>You can set the <I>iAttributes</I> argument to one or more of the following values defined in EZFONT.H:

<P><pre>
EZ_ATTR_BOLD
EZ_ATTR_ITALIC 
EZ_ATTR_UNDERLINE
EZ_ATTR_STRIKEOUT
</PRE>

<p>You could use EZ_ATTR_BOLD or EZ_ATTR_ITALIC or include the style as part of the complete TrueType typeface name.

<p>Finally, you set the last argument to TRUE to base the font size on the &quot;logical resolution&quot; returned by the <I>GetDeviceCaps</I> function using the LOGPIXELSX and LOGPIXELSY arguments. Otherwise, the font size is based on the resolution as calculated from the HORZRES, HORZSIZE, VERTRES, and VERTSIZE values. This makes a difference only for the video display under Windows NT.

<p>The <I>EzCreateFont</I> function begins by making some adjustments that are recognized by Windows NT only. These are the calls to the <I>SetGraphicsMode</I> and <I>ModifyWorldTransform</I> functions, which have no effect in Windows 98. The Windows NT world transform should have the effect of modifying the visible size of the font, so the world transform is set to the default&#8212;no transform&#8212;before the font size is calculated.

<p><I>EzCreateFont</I> basically sets the fields of a LOGFONT structure and calls <I>CreateFontIndirect</I>, which returns a handle to the font. The big chore of the <I>EzCreateFont</I> function is to convert a point size to logical units for the <I>lfHeight</I> field of the LOGFONT structure. It turns out that the point size must be converted to device units (pixels) first and then to logical units. To perform the first step, the function uses <I>GetDeviceCaps</I>. Getting from pixels to logical units would seem to involve a fairly simple call to the <I>DPtoLP</I> (&quot;device point to logical point&quot;) function. But in order for the <I>DPtoLP</I> conversion to work correctly, the same mapping mode must be in effect when you later display text using the created font. This means that you should set your mapping mode before calling the <I>EzCreateFont</I> function. In most cases, you use only one mapping mode for drawing on a particular area of the window, so this requirement should not be a problem.

<p>The EZTEST program in Figure 17-4 tests out the EZFONT files but not too rigorously. This program uses the EZTEST files shown above and also includes FONTDEMO files that are used in some later programs in this book.

<p><b>Figure 17-4</b> <i>The EZTEST program</i>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="625"><h3>EZTEST.C</h3></A>
<P><pre>
/*---------------------------------------
   EZTEST.C -- Test of EZFONT
               (c) Charles Petzold, 1998
  ---------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;ezfont.h&quot;

TCHAR szAppName [] = TEXT (&quot;EZTest&quot;) ;
TCHAR szTitle   [] = TEXT (&quot;EZTest: Test of EZFONT&quot;) ;

void PaintRoutine (HWND hwnd, HDC hdc, int cxArea, int cyArea)
{
     HFONT      hFont ;
     int        y, iPointSize ;
     LOGFONT    lf ;
     TCHAR      szBuffer [100] ;
     TEXTMETRIC tm ;

          // Set Logical Twips mapping mode

     SetMapMode (hdc, MM_ANISOTROPIC) ;
     SetWindowExtEx (hdc, 1440, 1440, NULL) ;
     SetViewportExtEx (hdc, GetDeviceCaps (hdc, LOGPIXELSX),
                            GetDeviceCaps (hdc, LOGPIXELSY), NULL) ;

          // Try some fonts

     y = 0 ;

     for (iPointSize = 80 ; iPointSize &lt;= 120 ; iPointSize++)
     {
          hFont = EzCreateFont (hdc, TEXT (&quot;Times New Roman&quot;), 
                                iPointSize, 0, 0, TRUE) ;

          GetObject (hFont, sizeof (LOGFONT), &amp;lf) ;

          SelectObject (hdc, hFont) ;
          GetTextMetrics (hdc, &amp;tm) ;
          TextOut (hdc, 0, y, szBuffer, 
               wsprintf (szBuffer, 
                         TEXT (&quot;Times New Roman font of %i.%i points, &quot;)
                         TEXT (&quot;lf.lfHeight = %i, tm.tmHeight = %i&quot;),
                         iPointSize / 10, iPointSize % 10,
                         lf.lfHeight, tm.tmHeight)) ;

          DeleteObject (SelectObject (hdc, GetStockObject (SYSTEM_FONT))) ;
          y += tm.tmHeight ;
     }
}
</PRE>
</td></tr></table>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="626"><h3>FONTDEMO.C</h3></A>
<P><pre>
/*------------------------------------------------
   FONTDEMO.C -- Font Demonstration Shell Program
                 (c) Charles Petzold, 1998
  ------------------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;..\\EZTest\\EzFont.h&quot;
#include &quot;..\\EZTest\\resource.h&quot;

extern  void     PaintRoutine (HWND, HDC, int, int) ;
LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

HINSTANCE hInst ;

extern TCHAR szAppName [] ;
extern TCHAR szTitle [] ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     TCHAR    szResource [] = TEXT (&quot;FontDemo&quot;) ;
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;
     
     hInst = hInstance ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = szResource ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, szTitle,
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static DOCINFO  di = { sizeof (DOCINFO), TEXT (&quot;Font Demo: Printing&quot;) } ;
     static int      cxClient, cyClient ;
     static PRINTDLG pd = { sizeof (PRINTDLG) } ;
     BOOL            fSuccess ;
     HDC             hdc, hdcPrn ;
     int             cxPage, cyPage ;
     PAINTSTRUCT     ps ;
     
     switch (message)
     {
     case WM_COMMAND:
          switch (wParam)
          {
          case IDM_PRINT:

                    // Get printer DC

               pd.hwndOwner = hwnd ;
               pd.Flags     = PD_RETURNDC | PD_NOPAGENUMS | PD_NOSELECTION ;

               if (!PrintDlg (&amp;pd))
                    return 0 ;

               if (NULL == (hdcPrn = pd.hDC))
               {
                    MessageBox (hwnd, TEXT (&quot;Cannot obtain Printer DC&quot;),
                                szAppName, MB_ICONEXCLAMATION | MB_OK) ;
                    return 0 ;
               }
                    // Get size of printable area of page

               cxPage = GetDeviceCaps (hdcPrn, HORZRES) ;
               cyPage = GetDeviceCaps (hdcPrn, VERTRES) ;

               fSuccess = FALSE ;

                    // Do the printer page

               SetCursor (LoadCursor (NULL, IDC_WAIT)) ;
               ShowCursor (TRUE) ;

               if ((StartDoc (hdcPrn, &amp;di) &gt; 0) &amp;&amp; (StartPage (hdcPrn) &gt; 0))
               {
                    PaintRoutine (hwnd, hdcPrn, cxPage, cyPage) ;
                    
                    if (EndPage (hdcPrn) &gt; 0)
                    {
                         fSuccess = TRUE ;
                         EndDoc (hdcPrn) ;
                    }
               }
               DeleteDC (hdcPrn) ;

               ShowCursor (FALSE) ;
               SetCursor (LoadCursor (NULL, IDC_ARROW)) ;

               if (!fSuccess)
                    MessageBox (hwnd, 
                                TEXT (&quot;Error encountered during printing&quot;),
                                szAppName, MB_ICONEXCLAMATION | MB_OK) ;
               return 0 ;

          case IDM_ABOUT:
               MessageBox (hwnd, TEXT (&quot;Font Demonstration Program\n&quot;)
                                 TEXT (&quot;(c) Charles Petzold, 1998&quot;),
                           szAppName, MB_ICONINFORMATION | MB_OK) ;
               return 0 ;
          }
          break ;
          
     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;
          
     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
          
          PaintRoutine (hwnd, hdc, cxClient, cyClient) ;
          
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_DESTROY :
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</PRE>
</td></tr></table>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="627"><h3>FONTDEMO.RC</h3></A>
<P><pre>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;

/////////////////////////////////////////////////////////////////////////////
// Menu

FONTDEMO MENU DISCARDABLE 
BEGIN
    POPUP &quot;&amp;File&quot;
    BEGIN
        MENUITEM &quot;&amp;Print...&quot;,                   IDM_PRINT
    END
    POPUP &quot;&amp;Help&quot;
    BEGIN
        MENUITEM &quot;&amp;About...&quot;,                   IDM_ABOUT
    END
END
</PRE>
</td></tr></table>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="628"><h3>RESOURCE.H</h3></A>
<P><pre>
// Microsoft Developer Studio generated include file.
// Used by FontDemo.rc

#define IDM_PRINT                       40001
#define IDM_ABOUT                       40002
</PRE>
</td></tr></table>

<p>The <I>PaintRoutine</I> function in EZTEST.C sets its mapping mode to Logical Twips and then creates Times New Roman fonts with sizes ranging from 8 points to 12 points in 0.1 point intervals. The program output may be a little disturbing when you first run it. Many of the lines of text use a font that is obviously the same size, and indeed the <I>tmHeight</I> font on the TEXTMETRIC function reports these fonts as having the same height. What's happening here is a result of the rasterization process. The discrete pixels of the display can't allow for every possible size. However, the FONTDEMO shell program allows printing the output as well. Here you'll find that the font sizes are more accurately differentiated.

<A NAME="629"><h2>Font Rotation</h2></A>
<p>As you may have discovered by experimenting with PICKFONT, the <I>lfOrientation</I> and <I>lfEscapement</I> fields of the LOGFONT structure allow you to rotate TrueType text. If you think about it, this shouldn't be much of a stretch for GDI. Formulas to rotate coordinate points around an origin are well known.

<p>Although <I>EzCreateFont</I> does not allow you to specify a rotation angle for the font, it's fairly easy to make an adjustment after calling the function, as the FONTROT (&quot;Font Rotate&quot;) program demonstrates. Figure 17-5 shows the FONTROT.C file; the program also requires the EZFONT files and the FONTDEMO files shown earlier.

<p><B>Figure 17-5.</b> <i>The FONTROT program.</I>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="630"><h3>FONTROT.C</h3></A><P><pre>
/*----------------------------------------
   FONTROT.C -- Rotated Fonts
                (c) Charles Petzold, 1998
  ----------------------------------------*/
#include &lt;windows.h&gt;
#include &quot;..\\eztest\\ezfont.h&quot;

TCHAR szAppName [] = TEXT (&quot;FontRot&quot;) ;
TCHAR szTitle   [] = TEXT (&quot;FontRot: Rotated Fonts&quot;) ;

void PaintRoutine (HWND hwnd, HDC hdc, int cxArea, int cyArea)
{
     static TCHAR szString [] = TEXT (&quot;   Rotation&quot;) ;
     HFONT        hFont ;
     int          i ;
     LOGFONT      lf ;

     hFont = EzCreateFont (hdc, TEXT (&quot;Times New Roman&quot;), 540, 0, 0, TRUE) ;
     GetObject (hFont, sizeof (LOGFONT), &amp;lf) ;
     DeleteObject (hFont) ;

     SetBkMode (hdc, TRANSPARENT) ;
     SetTextAlign (hdc, TA_BASELINE) ;
     SetViewportOrgEx (hdc, cxArea / 2, cyArea / 2, NULL) ;

     for (i = 0 ; i &lt; 12 ; i ++)
     {
          lf.lfEscapement = lf.lfOrientation = i * 300 ;
          SelectObject (hdc, CreateFontIndirect (&amp;lf)) ;

          TextOut (hdc, 0, 0, szString, lstrlen (szString)) ;

          DeleteObject (SelectObject (hdc, GetStockObject (SYSTEM_FONT))) ;
     }
}
</PRE></td></tr></table>


<p>FONTROT calls <I>EzCreateFont</I> just to obtain the LOGFONT structure associated with a 54-point Times New Roman font. The program then deletes that font. In the <I>for</I> loop, for each angle in 30-degree increments, a new font is created and the text is displayed. The results are shown in Figure 17-6.

<p><A HREF="javascript:fullSize('F17zg06x.htm')"><IMG SRC="F17zg06.JPG" width=404 height=344 ALIGN="BOTTOM" BORDER=0 ALT="click to view full size"></A>

<p><!-- caption --><B>Figure 17-6.</b> <i>The FONTROT display.</I><!-- /caption -->

<p>If you're interested in a more generalized approach to graphics rotation and other linear transformation and you know that your programs will be restricted to running under Windows NT, you can use the XFORM matrix and the world transform functions.

</BODY>
</HTML>





