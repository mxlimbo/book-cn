<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
	<TITLE>Library Basics</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>

<BODY BGCOLOR="#ffffff">
<A NAME="737"><h1>Library Basics</h1></A>

<P>As you've seen, a Windows program is an executable file that generally creates one or 
more windows and uses a message loop to receive user input. Dynamic-link libraries are 
generally not directly executable, and they generally do not receive messages. They are 
separate files containing functions that can be called by programs and other DLLs to perform 
certain jobs. A dynamic-link library is brought into action only when another module 
calls one of the functions in the library.

<P>The term &quot;dynamic linking&quot; refers to the process that Windows uses to link a 
function call in one module to the actual function in the library module. &quot;Static linking&quot; occurs 
during program development when you link various object (.OBJ) modules, run-time library 
(.LIB) files, and usually a compiled resource (.RES) file to create a Windows .EXE file. 
Dynamic linking instead occurs at run time.

<P>KERNEL32.DLL, USER32.DLL, and GDI32.DLL; the various driver files such as 
KEYBOARD.DRV, SYSTEM.DRV, and MOUSE.DRV; and the video and printer drivers are all 
dynamic-link libraries. These are libraries that all Windows programs can use.

<P>Some dynamic-link libraries (such as font files) are termed &quot;resource-only.&quot; 
They contain only data (usually in the form of resources) and no code. Thus, one purpose 
of dynamic-link libraries is to provide functions and resources that can be used by 
many different programs. In a conventional operating system, only the operating system 
itself contains routines that other programs can call on to do a job. In Windows, the process 
of one module calling a function in another module is generalized. In effect, by writing 
a dynamic-link library, you are writing an extension to Windows. Or you can think of 
DLLs, including those that make up Windows, as extensions to your program.

<P>Although a dynamic-link library module can have any extension (such as .EXE 
or .FON), the standard extension is .DLL. Only dynamic-link libraries with the extension 
.DLL will be loaded automatically by Windows. If the file has another extension, the 
program must explicitly load the module by using the 
<I>LoadLibrary</I> or <I>LoadLibraryEx</I> function.

<P>You'll generally find that dynamic libraries make most sense in the context of a 
large application. For instance, suppose you write a large accounting package for Windows 
that consists of several different programs. You'll probably find that these programs use 
many common routines. You could put these common routines in a normal object library 
(with the extension .LIB) and add them to each of the program modules during static linking 
with LINK. But this approach is wasteful, because each of the programs in this package 
contains identical code for the common routines. Moreover, if you change one of the 
routines in this library, you'll have to relink all the programs that use the changed routine. 
If, however, you put these common routines in a dynamic-link library called, for 
instance, ACCOUNT.DLL, you've solved both problems. Only the library module need contain 
the routines required by all the programs, thus requiring less disk space for the files and 
less memory space when running two or more of the applications simultaneously, and you 
can make changes to the library module without relinking any of the individual programs.

<P>Dynamic-link libraries can themselves be viable products. For instance, suppose 
you write a collection of three-dimensional drawing routines and put them in a DLL 
called GDI3.DLL. If you then interest other software developers in using your library, you 
can license it to be included with their graphics programs. A user who has several of 
these programs would need only one GDI3.DLL file.

<A NAME="738"><h3>Library: One Word, Many Meanings</h3></A><P>Part of the confusion surrounding dynamic-link libraries results from the appearance of 
the word &quot;library&quot; in several different contexts. Besides dynamic-link libraries, we'll also 
be talking about &quot;object libraries&quot; and &quot;import libraries.&quot;

<P>An object library is a file with the extension .LIB containing code that is added to 
your program's .EXE file in the process called static linking when you run the linker. For 
example, in Microsoft Visual C++, the normal C run-time object library that you link with your 
program is called LIBC.LIB.

<P>An import library is a special form of an object library file. Like object libraries, 
import libraries have the extension .LIB and are used by the linker to resolve function 
calls in your source code. However, import libraries contain no code. Instead, they provide 
the linker with information necessary to set up relocation tables within the .EXE file for 
dynamic linking. The KERNEL32.LIB, USER32.LIB, and GDI32.LIB files included with 
the Microsoft compiler are import libraries for Windows functions. If you call the 
<I>Rectangle</I> function in a program, GDI32.LIB tells LINK that this function is in the GDI32.DLL 
dynamic-link library. This information goes into the .EXE file so that Windows can perform 
dynamic linking with the GDI32.DLL dynamic-link library when your program is executed.

<P>Object libraries and import libraries are used only during program 
development. Dynamic-link libraries are used during run time. A dynamic library must be present 
on the disk when a program is run that uses the library. When Windows needs to load 
a DLL module before running a program that requires it, the library file must be stored 
in the directory containing the .EXE program, the current directory, the Windows 
system directory, the Windows directory, or a directory accessible through the PATH string 
in the MS-DOS environment. (The directories are searched in that order.)

<A NAME="739"><h3>A Simple DLL</h3></A><P>Although the whole idea of dynamic-link libraries is that they can be used by 
multiple applications, generally you'll initially design a dynamic-link library in connection with 
just one application, perhaps a &quot;test&quot; program that puts the DLL through its paces.

<P>That's what we'll do here. We'll create a DLL called EDRLIB.DLL. The &quot;EDR&quot; of 
this filename stands for &quot;easy drawing routines.&quot; Our version of EDRLIB will contain only 
one function (named <I>EdrCenterText</I>), but you can add other functions to it that simplify 
the drawing functions in your applications. An application named EDRTEST.EXE will 
take advantage of EDRLIB.DLL by calling the function contained in it.

<P>To do this requires an approach a little different than the one we've been 
taking, involving a feature of Visual C++ we haven't examined yet. Visual C++ differentiates between &quot;workspaces&quot; and &quot;projects.&quot; A project is generally associated 
with the creation of an application file (.EXE) or a dynamic-link library (.DLL). A 
workspace can contain one or more projects. Until now, all our workspaces have contained just 
one project. We'll now create a workspace called EDRTEST that will contain two 
projects&#8212;one to create EDRTEST.EXE and the other to create EDRLIB.DLL, the dynamic-link 
library used by EDRTEST.

<P>Let's begin. In Visual C++, select New from the File menu. Select the 
Workspaces tab. (We haven't selected this before.) Select the directory where you want the 
workspace to be in the Location field, and type EDRTEST in the Workspace Name field. Press Enter.

<P>This creates an empty workspace. The Developer Studio will create a 
subdirectory named EDRTEST and the workspace file EDRTEST.DSW (as well as a couple other files).

<P>Now let's create a project in this workspace. Select New from the File menu, 
and select the Projects tab. Whereas in the past you've selected Win32 Application, this time 
select Win32 Dynamic-Link Library. Also, click the radio button Add To Current Workspace. 
That makes this project part of the EDRTEST workspace. Type EDRLIB in the Project Name 
field, but don't press OK just yet. As you type EDRLIB in the Project Name field, Visual C++ alters the Location field to show EDRLIB as a subdirectory of EDRTEST. You don't 
want this! In the Location field, remove the EDRLIB subdirectory so that the project is 
created in the EDRTEST directory. Now press OK. Visual C++ will create a project 
file EDRLIB.DSP and (if you've selected the Export Makefile option on the Build tab of the Tools Options dialog box) a make file EDRLIB.MAK.

<P>Now you're ready to add a couple files to this project. From the File menu, select 
New and then the Files tab. Select C/C++ Header File, and type the filename EDRLIB.H. 
Type in the file shown in Figure 21-1 (or copy it from this book's CD-ROM). Select New 
from the File menu again, and then the Files tab. This time select C++ Source File, and type 
the filename EDRLIB.C. Again type the file shown in Figure 21-1.

<P><B>Figure 21-1.</b> <i>The EDRLIB library.</I>

<P><TABLE cellpadding="5" width="95%"><TR><TD>
<h3>EDRLIB.H</h3>

<P><PRE>
/*----------------------
   EDRLIB.H header file

  ----------------------*/

#ifdef __cplusplus
#define EXPORT extern &quot;C&quot; __declspec (dllexport)
#else
#define EXPORT __declspec (dllexport)
#endif

EXPORT BOOL CALLBACK EdrCenterTextA (HDC, PRECT, PCSTR) ;
EXPORT BOOL CALLBACK EdrCenterTextW (HDC, PRECT, PCWSTR) ;

#ifdef UNICODE
#define EdrCenterText EdrCenterTextW
#else
#define EdrCenterText EdrCenterTextA
#endif
</pre></td></TR>
</table>

<P><TABLE cellpadding="5" width="95%"><TR><TD>
<h3>EDRLIB.C</h3>

<P><PRE>
/*-------------------------------------------------
   EDRLIB.C -- Easy Drawing Routine Library module

               (c) Charles Petzold, 1998
  -------------------------------------------------*/

#include  windows.h&gt;
#include &quot;edrlib.h&quot;

int WINAPI DllMain (HINSTANCE hInstance, DWORD fdwReason, PVOID pvReserved)
{
     return TRUE ;
}

EXPORT BOOL CALLBACK EdrCenterTextA (HDC hdc, PRECT prc, PCSTR pString)
{
     int  iLength ;
     SIZE size ;

     iLength = lstrlenA (pString) ;

     GetTextExtentPoint32A (hdc, pString, iLength, &amp;size) ;

     return TextOutA (hdc, (prc-&gt;right - prc-&gt;left - size.cx) / 2,
                           (prc-&gt;bottom - prc-&gt;top - size.cy) / 2,
                      pString, iLength) ;
}

EXPORT BOOL CALLBACK EdrCenterTextW (HDC hdc, PRECT prc, PCWSTR pString)
{
     int  iLength ;
     SIZE size ;

     iLength = lstrlenW (pString) ;

     GetTextExtentPoint32W (hdc, pString, iLength, &amp;size) ;

     return TextOutW (hdc, (prc-&gt;right - prc-&gt;left - size.cx) / 2,
                           (prc-&gt;bottom - prc-&gt;top - size.cy) / 2,
                      pString, iLength) ;
}
</pre></td></TR>
</table>

<P>At this point you can build EDRLIB.DLL in either a Release or Debug 
configuration. After the build, the RELEASE and DEBUG directories will contain EDRLIB.LIB, which is 
the import library for the dynamic-link library, and EDRLIB.DLL, the dynamic-link library itself.

<P>Throughout this book we've been creating programs that can be compiled 
for Unicode or non-Unicode character strings depending on the definition of the 
UNICODE identifier. When you create a DLL, it should include 
<I>both</I> Unicode and non-Unicode versions of any function that has arguments involving characters or character strings. 
Thus, EDRLIB.C contains functions named 
<I>EdrCenterTextA</I> (the ANSI version) and 
<I>EdrCenterTextW</I> (the wide-character version). 
<I>EdrCenterTextA</I> is defined as taking a PCSTR 
(pointer to <I>const</I> string) parameter and 
<I>EdrCenterTextW</I> is defined as take PCWSTR (pointer 
to <I>const</I> wide string) parameter. The 
<I>EdrCenterTextA</I> function explicitly calls 
<I>lstrlenA</I>, <I>GetTextExtentPoint32A</I>, and 
<I>TextOutA</I>. <I>EdrCenterTextW</I> explicitly calls 
<I>lstrlenW</I>, <I>GetTextExtentPoint32W</I>, and 
<I>TextOutW</I>. The EDRLIB.H file defines 
<I>EdrCenterText</I> to be <I>EdrCenterTextW</I> if the UNICODE identifier is defined and 
<I>EdrCenterTextA</I> if it's not. This is just like the Windows header files.

<P>EDRLIB.H also includes a function named 
<I>DllMain</I>, which takes the place of 
<I>WinMain</I> in a DLL. This function is used to perform initialization and deinitialization, as I'll discuss 
later in this chapter. For our purposes, all we need do right now is return TRUE from 
<I>DllMain</I>.

<P>The only remaining mystery in these two files should be the definition of the 
EXPORT identifier. Functions in a DLL that are used by an application must be &quot;exported.&quot; This 
doesn't involve any tariffs or commerce regulations, just a few keywords that ensure that the 
function name is added to EDRLIB.LIB (so that the linker can resolve the function name 
when linking an application that uses the function) and that the function is visible from 
EDRLIB.DLL. The EXPORT identifier includes the storage-class specifier 
<I>__declspec (dllexport)</I> and also <I>extern &quot;C&quot; 
</I>if the header is being compiled in C++ mode. This prevents the compiler 
from doing the customary &quot;name mangling&quot; of C++ functions and thus allows the DLL to be 
used by both C and C++ programs.

<H3>The Library Entry and Exit Point</H3>

<P>The <I>DllMain</I> function is called when the library first begins and when it terminates. The first parameter to <I>DllMain</I> is the instance handle of the library. If your library uses resources that require an instance handle (such as <I>DialogBox</I>), you should save <I>hInstance</I> as a global variable. The last parameter to <I>DllMain</I> is reserved by the system.
<P>The <I>fdwReason</I> parameter can be one of four values that indicate why Windows is calling the <I>DllMain</I> function. In the following discussion, keep in mind that a single program can be loaded multiple times and run concurrently under Windows. Each time a program is loaded, it is considered a separate process.
<P>A <I>fdwReason</I> value of DLL_PROCESS_ATTACH indicates that the dynamic-link library has been mapped into the address space of a process. This is a cue for the library to do any initialization tasks it requires to service subsequent requests from the process. Such initialization might include memory allocation, for example. During the time that a process is running, <I>DllMain</I> is called with a DLL_PROCESS_ATTACH parameter only once during the lifetime of that process. Any other process using the same DLL causes another call to <I>DllMain</I> with a DLL_PROCESS_ATTACH parameter, but that’s on behalf of the new process.
<P>If the initialization is successful, <I>DllMain</I> should return a nonzero value. Returning zero will cause Windows to not run the program.
<P>When <I>fdwReason</I> has a value of DLL_PROCESS_DETACH, it means that the DLL is no longer needed by the process. This provides an opportunity for the library to clean up after itself. Under the 32-bit versions of Windows often this is not strictly necessary, but it’s a good programming practice.
<P>Similarly, when <I>DllMain</I> is called with an <I>fdwReason</I> parameter of DLL_THREAD_ATTACH, it means that an attached process has created a new thread. When the thread terminates, Windows calls <I>DllMain</I> with an <I>fdwReason</I> parameter of DLL_THREAD_DETACH. Be aware that it’s possible to get a DLL_THREAD_DETACH call without an earlier DLL_THREAD_ATTACH call if the dynamic-link library is attached to a process after the thread has been created.
<P>The thread still exists when <I>DllMain</I> is called with a parameter of DLL_THREAD_DETACH. It can even send the thread messages during this process. But it shouldn’t use <I>PostMessage</I> because the thread might be gone before the message is retrieved.

<H3>The Test Program</H3>
<P>Now let's create a second project in the EDRTEST workspace, this one for a 
program named EDRTEST that will use EDRLIB.DLL. With the EDRTEST workspace 
loaded in Visual C++, select New from the File menu. Select the Projects tab in the 
New dialog box. This time select Win32 Application. Make sure the Add To Current 
Workspace button is checked. Type in the project name EDRTEST. Again, in the Locations field, 
erase the second EDRTEST subdirectory. Press OK, and select An Empty Project from the next dialog box. Press Finish.

<P>From the File menu, select New again. Select the Files tab and C++ Source File. 
Make sure the Add To Project list box shows EDRTEST rather than EDRLIB. Type in the 
filename EDRTEST.C, and type in the file shown in Figure 21-2. This program uses the 
<I>EdrCenterText</I> function to center a text string in its client area.

<P><B>Figure 21-2.</b> <i>The EDRTEST program.</I>

<P><TABLE cellpadding="5" width="95%"><TR><TD>
<h3>EDRTEST.C</h3>

<P><PRE>
/*--------------------------------------------------------
   EDRTEST.C -- Program using EDRLIB dynamic-link library

                (c) Charles Petzold, 1998
  --------------------------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;edrlib.h&quot;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;StrProg&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;

     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;DLL Demonstration Program&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     HDC         hdc ;

     PAINTSTRUCT ps ;
     RECT        rect ;
     
     switch (message)
     {
     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
          
          GetClientRect (hwnd, &amp;rect) ;
          
          EdrCenterText (hdc, &amp;rect, 
                         TEXT (&quot;This string was displayed by a DLL&quot;)) ;
          
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre></td></TR>
</table>

<P>Notice that EDRTEST.C includes the EDRLIB.H header file for the definition of 
the <I>EdrCenterText</I> function, which it calls during the WM_PAINT message.
<P>Before you compile this program, there are a few things you'll want to do. First, 
in the Project menu, choose Select Active Project. You should see EDRLIB and EDRTEST. 
You should select EDRTEST. When you build this workspace, you really want to build 
the program. Also, in the Project menu, select Dependencies. In the Select Project To 
Modify list box, choose EDRTEST. In the Dependent On The Following Project(s) list, 
check EDRLIB. This means that EDRTEST requires the EDRLIB dynamic-link library. 
Whenever you build EDRTEST, EDRLIB will be rebuilt, if necessary, before compiling and 
linking EDRTEST.

<P>From the Project menu, select Settings. Pick the General tab. When you select 
the EDRLIB or EDRTEST projects in the left pane, the Intermediate Files and Output Files 
shown in the right pane should be the RELEASE directory for the Win32 Release configuration 
and the DEBUG directory for the Win32 Debug configuration. Change them if they are not. 
This will ensure that EDRLIB.DLL ends up in the same directory as EDRTEST.EXE and that 
the program will have no problem using the DLL.

<P>Still in the Project Setting dialog box and with EDRTEST selected,  click the C/C++ tab. In Preprocessor 
Definitions, add UNICODE in the Debug configuration, as is customary for the programs in this book.

<P>Now you should be able to build EDRTEST.EXE in both Debug and Release 
configurations. Visual C++ will first compile and link EDRLIB, if necessary. The 
RELEASE and DEBUG directories will contain EDRLIB.LIB (the import library) and EDRLIB.DLL. 
When Developer Studio links EDRTEST, it will include the import library automatically.

<P>It is important to understand that the 
<I>EdrCenterText</I> code is not included in the EDRTEST.EXE file. Instead, there is simply a reference in the executable to the 
EDRLIB.DLL file and the <I>EdrCenterText</I> function. EDRTEST.EXE requires EDRLIB.DLL to run.

<P>When you execute EDRTEST.EXE, Windows performs fixups to functions in 
external library modules. Many of these functions are in the normal Windows dynamic-link 
libraries. But Windows also sees that the program calls a function from EDRLIB, so Windows 
loads the EDRLIB.DLL file into memory and calls EDRLIB's initialization routine. The call 
within EDRTEST to the <I>EdrCenterText</I> function is dynamically linked to the function in EDRLIB.

<P>Including EDRLIB.H in the EDRTEST.C source code file is similar to 
including WINDOWS.H. Linking with EDRLIB.LIB is similar to linking with the Windows import 
libraries (such as USER32.LIB). When your program runs, it links with EDLIB.DLL in the same way 
it links with USER32.DLL. Congratulations! You' ve just created an extension to Windows!

<P>A few words on the subject of dynamic-link libraries before we continue:

<P>First, although I've just categorized a DLL as an extension to Windows, it is also 
an extension to your application program. Everything the DLL does is done on behalf of 
the application. For example, all memory it allocates is owned by the application. Any 
windows it creates are owned by the application. And any files it opens are owned by the 
application. Multiple applications can use the same DLL simultaneously, but under Windows 
these applications are shielded from interfering with each other.

<P>Multiple processes can share the same code in a dynamic-link library. However, 
the data maintained by a DLL is different for each process. Each process has its own 
address space for any data the DLL uses. Sharing memories among processes requires extra 
work, as we'll see in the next section.

<A NAME="740"><h3>Shared Memory in DLLs</h3></A><P>It's very nice that Windows isolates applications that are using the same dynamic-link 
libraries at the same time. However, sometimes it's not preferable. You may want to write a DLL 
that contains some memory that can be shared among various applications, or perhaps 
among multiple instances of the same application. This involves using shared memory, which is 
actually a memory-mapped file.

<P>Let's examine how this works with a 
program called STRPROG (&quot;string program&quot;) and a dynamic-link library called STRLIB (&quot;string 
library&quot;). STRLIB has three exported functions that STRPROG calls. Just to make this 
interesting, one of the functions in STRLIB uses a call-back function defined in STRPROG.

<P>STRLIB is a dynamic-link library module that stores and sorts up to 256 
character strings. The strings are capitalized and maintained by shared memory in STRLIB. 
STRPROG can use STRLIB's three functions to add strings, delete strings, and obtain all the 
current strings from STRLIB. The STRPROG test program has two menu items (Enter and 
Delete) that invoke dialog boxes to add and delete these strings. STRPROG lists in its client 
area all the current strings stored by STRLIB.

<P>This function defined in STRLIB adds a string to STRLIB's shared memory:

<P><pre>
EXPORT BOOL CALLBACK AddString (pStringIn)
</pre>

<P>The argument <I>pStringIn</I> is a pointer to the string. The string is capitalized within 
the <I>AddString</I> function. If an identical string already exists in STRLIB's list of strings, this 
function adds another copy of the string. 
<I>AddString</I> returns TRUE (nonzero) if it is successful 
and FALSE (0) otherwise. A FALSE return value can result if the string has a length of 0, if 
memory could not be allocated to store the string, or if 256 strings are already stored.

<P>This STRLIB function deletes a string from STRLIB's shared memory:

<P><pre>
EXPORT BOOL CALLBACK DeleteString (pStringIn)
</pre>

<P>Again, the argument <I>pStringIn</I> is a pointer to the string. If more than one string 
matches, only the first is removed. 
<I>DeleteString</I> returns TRUE (nonzero) if it is successful and 
FALSE (0) otherwise. A FALSE return value indicates that the length of the string is 0 or that 
a matching string could not be found.

<P>This STRLIB function uses a call-back function located in the calling program 
to enumerate the strings currently stored in STRLIB's shared memory:

<P><pre>
EXPORT int CALLBACK GetStrings (pfnGetStrCallBack, pParam)
</pre>

<P>The call-back function must be defined in the calling program as follows:

<P><pre>
EXPORT BOOL CALLBACK GetStrCallBack (PSTR pString, PVOID pParam)
</pre>

<P>The <I>pfnGetStrCallBack</I> argument to 
<I>GetStrings</I> points to the call-back function. 
<I>GetStrings</I> calls <I>GetStrCallBack</I> once for each string or until the call-back function returns FALSE 
(0). <I>GetStrings</I> returns the number of strings passed to the call-back function. The 
<I>pParam</I> parameter is a far pointer to programmer-defined data.

<P>Of course, this is all complicated by Unicode or, rather, by the necessity of 
STRLIB supporting both Unicode and non-Unicode applications. Like EDRLIB, it has A and W versions of all its functions. Internally, STRLIB stores all 
the strings in Unicode. If a non-Unicode program uses STRLIB (that is, the program calls <I>AddStringA</I>, <I>DeleteStringA</I>, and <I>GetStringsA</I>) the strings are converted to and from Unicode.

<P>The workspace associated with the STRPROG and STRLIB projects is named 
STRPROG. The files are assembled in the same way as the EDRTEST workspace. Figure 21-3 
shows the two files necessary to create the STRLIB.DLL dynamic-link library module.

<P><B>Figure 21-3.</b> <i>The STRLIB library.</I>

<P><TABLE cellpadding="5" width="95%">
<tr><td>
<h3>STRLIB.H</h3>
<P><pre>
/*----------------------
   STRLIB.H header file
  ----------------------*/


#ifdef __cplusplus
#define EXPORT extern &quot;C&quot; __declspec (dllexport)
#else
#define EXPORT __declspec (dllexport)
#endif

     // The maximum number of strings STRLIB will store and their lengths

#define MAX_STRINGS 256
#define MAX_LENGTH 63

     // The callback function type definition uses generic strings

typedef BOOL (CALLBACK * GETSTRCB) (PCTSTR, PVOID) ;

     // Each function has ANSI and Unicode versions

EXPORT BOOL CALLBACK AddStringA (PCSTR) ;
EXPORT BOOL CALLBACK AddStringW (PCWSTR) ;

EXPORT BOOL CALLBACK DeleteStringA (PCSTR) ;
EXPORT BOOL CALLBACK DeleteStringW (PCWSTR) ;

EXPORT int CALLBACK GetStringsA (GETSTRCB, PVOID) ;
EXPORT int CALLBACK GetStringsW (GETSTRCB, PVOID) ;
 
     // Use the correct version depending on the UNICODE identifier

#ifdef UNICODE
#define AddString    AddStringW
#define DeleteString DeleteStringW
#define GetStrings   GetStringsW
#else
#define AddString    AddStringA
#define DeleteString DeleteStringA
#define GetStrings   GetStringsA
#endif
</pre></td></tr>

<tr><td>
<h3>STRLIB.C</h3>

<P><pre>/*------------------------------------------------
   STRLIB.C -- Library module for STRPROG program
               (c) Charles Petzold, 1998

------------------------------------------------*/
#include &lt;windows.h&gt;
#include &lt;wchar.h&gt;       // for wide-character string functions
#include &quot;strlib.h&quot;

     // shared memory section (requires /SECTION:shared,RWS in link options)

#pragma data_seg (&quot;shared&quot;)
int   iTotal = 0 ;
WCHAR szStrings [MAX_STRINGS][MAX_LENGTH + 1] = { ‘\0’ } ;
#pragma data_seg ()

#pragma comment(linker,&quot;/SECTION:shared,RWS&quot;)

int WINAPI DllMain (HINSTANCE hInstance, DWORD fdwReason, PVOID pvReserved)
{
     return TRUE ;
}

EXPORT BOOL CALLBACK AddStringA (PCSTR pStringIn)<BR>
{
     BOOL  bReturn ;
     int   iLength ;
     PWSTR pWideStr ;

          // Convert string to Unicode and call AddStringW

     iLength = MultiByteToWideChar (CP_ACP, 0, pStringIn, -1, NULL, 0) ;
     pWideStr = malloc (iLength) ;
     MultiByteToWideChar (CP_ACP, 0, pStringIn, -1, pWideStr, iLength) ;
     bReturn = AddStringW (pWideStr) ;
     free (pWideStr) ;

     return bReturn ;
}

EXPORT BOOL CALLBACK AddStringW (PCWSTR pStringIn)
{<BR>
     PWSTR pString ;
     int   i, iLength ;
     
     if (iTotal == MAX_STRINGS - 1)
          return FALSE ;
     
     if ((iLength = wcslen (pStringIn)) == 0)
          return FALSE ;
          
          // Allocate memory for storing string, copy it, convert to upper case<BR>

     pString = malloc (sizeof (WCHAR) * (1 + iLength)) ;
     wcscpy (pString, pStringIn) ;
     _wcsupr (pString) ;

          //  Alphabetize the strings
     
     for (i = iTotal ; i &gt; 0 ; i—)

     {
          if (wcscmp (pString, szStrings[i - 1]) &gt;= 0)
               break ;
          
          wcscpy (szStrings[i], szStrings[i - 1]) ;<BR>
     }
     wcscpy (szStrings[i], pString) ;
     iTotal++ ;

     free (pString) ;
     return TRUE ;
}

EXPORT BOOL CALLBACK DeleteStringA (PCSTR pStringIn)<BR>
{
     BOOL  bReturn ;
     int   iLength ;
     PWSTR pWideStr ;

          // Convert string to Unicode and call DeleteStringW

     iLength = MultiByteToWideChar (CP_ACP, 0, pStringIn, -1, NULL, 0) ;
     pWideStr = malloc (iLength) ;
     MultiByteToWideChar (CP_ACP, 0, pStringIn, -1, pWideStr, iLength) ;
     bReturn = DeleteStringW (pWideStr) ;
     free (pWideStr) ;

     return bReturn ;
}

EXPORT BOOL CALLBACK DeleteStringW (PCWSTR pStringIn)
{
     int i, j ;
     
     if (0 == wcslen (pStringIn))
          return FALSE ;
    
     for (i = 0 ; i &lt; iTotal ; i++)
     {
          if (_wcsicmp (szStrings[i], pStringIn) == 0)
               break ;
     }
          // If given string not in list, return without taking action<BR>
     
     if (i == iTotal)
          return FALSE ;
     
          // Else adjust list downward
     
     for (j = i ; j &lt; iTotal ; j++)
          wcscpy (szStrings[j], szStrings[j + 1]) ;
     
     szStrings[iTotal—][0] = ‘\0’ ;
     return TRUE ;
}

EXPORT int CALLBACK GetStringsA (GETSTRCB pfnGetStrCallBack, PVOID pParam)
{
     BOOL bReturn ;
     int  i, iLength ;
     PSTR pAnsiStr ;

     for (i = 0 ; i &lt; iTotal ; i++)
     {
               // Convert string from Unicode

          iLength = WideCharToMultiByte (CP_ACP, 0, szStrings[i], -1, NULL, 0,
                                         NULL, NULL) ;
          pAnsiStr = malloc (iLength) ;
          WideCharToMultiByte (CP_ACP, 0, szStrings[i], -1, pAnsiStr, iLength,
                                          NULL, NULL) ;
                                          
               // Call callback function<BR>

          bReturn = pfnGetStrCallBack (pAnsiStr, pParam) ;
          
          if (bReturn == FALSE)
               return i + 1 ;

          free (pAnsiStr) ;
     }
     return iTotal ;
}

EXPORT int CALLBACK GetStringsW (GETSTRCB pfnGetStrCallBack, PVOID pParam)
{
     BOOL bReturn ;
     int  i ;
     
     for (i = 0 ; i &lt; iTotal ; i++)
     {
          bReturn = pfnGetStrCallBack (szStrings[i], pParam) ;

          if (bReturn == FALSE)
               return i + 1 ;
     }
     return iTotal ;
}
</pre></tr></td>
</TABLE>
<P>
Aside from the <I>DllMain</I> function, STRLIB contains only the six functions that it will export to be used by other programs. All these functions are defined as EXPORT. This causes LINK to list them in the STRLIB.LIB import library.

<A NAME="742"><h3>The STRPROG Program</h3></A><P>The STRPROG program, shown in Figure 21-4, is fairly straightforward. The two 
menu options, Enter and Delete, invoke dialog boxes that allow you to enter a string. 
STRPROG then calls <I>AddString</I> or 
<I>DeleteString</I>. When the program needs to update its client area, 
it calls <I>GetStrings</I> and uses the function 
<I>GetStrCallBack</I> to list the enumerated strings.

<P><B>Figure 21-4.</b> <i>The STRPROG program.</I>

<TABLE cellpadding="5" width="95%">
<tr><td><h3>STRPROG.C</h3>

<P><pre>
/*--------------------------------------------------------
   STRPROG.C -- Program using STRLIB dynamic-link library
                (c) Charles Petzold, 1998

  --------------------------------------------------------*/
#include &lt;windows.h&gt;
#include &quot;strlib.h&quot;
#include &quot;resource.h&quot;

typedef struct
{
     HDC hdc ;
     int xText ;
     int yText ;
     int xStart ;
     int yStart ;
     int xIncr ;
     int yIncr ;
     int xMax ;
     int yMax ;
}
CBPARAM ;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

TCHAR szAppName [] = TEXT (&quot;StrProg&quot;) ;
TCHAR szString [MAX_LENGTH + 1] ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = szAppName ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }

     hwnd = CreateWindow (szAppName, TEXT (&quot;DLL Demonstration Program&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

BOOL CALLBACK DlgProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
     switch (message)
     {
     case WM_INITDIALOG:
          SendDlgItemMessage (hDlg, IDC_STRING, EM_LIMITTEXT, MAX_LENGTH, 0) ;
          return TRUE ;
          
     case WM_COMMAND:
          switch (wParam)
          {
          case IDOK:
               GetDlgItemText (hDlg, IDC_STRING, szString, MAX_LENGTH) ;
               EndDialog (hDlg, TRUE) ;
               return TRUE ;
               
          case IDCANCEL:
               EndDialog (hDlg, FALSE) ;
               return TRUE ;
          }
     }
     return FALSE ;
}

BOOL CALLBACK GetStrCallBack (PTSTR pString, CBPARAM * pcbp)
{
     TextOut (pcbp-&gt;hdc, pcbp-&gt;xText, pcbp-&gt;yText,
              pString, lstrlen (pString)) ;
     
     if ((pcbp-&gt;yText += pcbp-&gt;yIncr) &gt; pcbp-&gt;yMax)
     {
          pcbp-&gt;yText = pcbp-&gt;yStart ;
          if ((pcbp-&gt;xText += pcbp-&gt;xIncr) &gt; pcbp-&gt;xMax)
               return FALSE ;
     }
     return TRUE ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HINSTANCE  hInst ;
     static int        cxChar, cyChar, cxClient, cyClient ;
     static UINT       iDataChangeMsg ;
     CBPARAM           cbparam ;
     HDC               hdc ;
     PAINTSTRUCT       ps ;
     TEXTMETRIC        tm ;
     
     switch (message)
     {
     case WM_CREATE:
          hInst = ((LPCREATESTRUCT) lParam)-&gt;hInstance ;
          hdc   = GetDC (hwnd) ;
          GetTextMetrics (hdc, &amp;tm) ;
          cxChar = (int) tm.tmAveCharWidth ;
          cyChar = (int) (tm.tmHeight + tm.tmExternalLeading) ;
          ReleaseDC (hwnd, hdc) ;

               // Register message for notifying instances of data changes

          iDataChangeMsg = RegisterWindowMessage (TEXT (&quot;StrProgDataChange&quot;)) ;
          return 0 ;
          
     case WM_COMMAND:
          switch (wParam)
          {
          case IDM_ENTER:
               if (DialogBox (hInst, TEXT (&quot;EnterDlg&quot;), hwnd, &amp;DlgProc))
               {
                    if (AddString (szString))
                         PostMessage (HWND_BROADCAST, iDataChangeMsg, 0, 0) ;
                    else
                         MessageBeep (0) ;
               }
               break ;
               
          case IDM_DELETE:
               if (DialogBox (hInst, TEXT (&quot;DeleteDlg&quot;), hwnd, &amp;DlgProc))
               {
                    if (DeleteString (szString))
                         PostMessage (HWND_BROADCAST, iDataChangeMsg, 0, 0) ;
                    else
                         MessageBeep (0) ;
               }
               break ;
          }
          return 0 ;
          
     case WM_SIZE:
          cxClient = (int) LOWORD (lParam) ;
          cyClient = (int) HIWORD (lParam) ;
          return 0 ;

     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
               
          cbparam.hdc   = hdc ;
          cbparam.xText = cbparam.xStart = cxChar ;
          cbparam.yText = cbparam.yStart = cyChar ;
          cbparam.xIncr = cxChar * MAX_LENGTH ;
          cbparam.yIncr = cyChar ;
          cbparam.xMax  = cbparam.xIncr * (1 + cxClient / cbparam.xIncr) ;
          cbparam.yMax  = cyChar * (cyClient / cyChar - 1) ;
               
          GetStrings ((GETSTRCB) GetStrCallBack, (PVOID) &amp;cbparam) ;
              
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
               
     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;

     default:
          if (message == iDataChangeMsg)
               InvalidateRect (hwnd, NULL, TRUE) ;
          break ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
</pre></td></tr>
</table>   

<P><TABLE cellpadding="5" width="95%">
<tr><td>
<h3>STRPROG.RC (excerpts)</h3>

<P><pre>
//Microsoft Developer Studio generated resource script.


#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;

/////////////////////////////////////////////////////////////////////////////
// Dialog

ENTERDLG DIALOG DISCARDABLE  20, 20, 186, 47
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION &quot;Enter&quot;
FONT 8, &quot;MS Sans Serif&quot;
BEGIN
    LTEXT           &quot;&amp;Enter:&quot;,IDC_STATIC,7,7,26,9
    EDITTEXT        IDC_STRING,31,7,148,12,ES_AUTOHSCROLL
    DEFPUSHBUTTON   &quot;OK&quot;,IDOK,32,26,50,14
    PUSHBUTTON      &quot;Cancel&quot;,IDCANCEL,104,26,50,14
END

DELETEDLG DIALOG DISCARDABLE  20, 20, 186, 47
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION &quot;Delete&quot;
FONT 8, &quot;MS Sans Serif&quot;
BEGIN
    LTEXT           &quot;&amp;Delete:&quot;,IDC_STATIC,7,7,26,9
    EDITTEXT        IDC_STRING,31,7,148,12,ES_AUTOHSCROLL
    DEFPUSHBUTTON   &quot;OK&quot;,IDOK,32,26,50,14
    PUSHBUTTON      &quot;Cancel&quot;,IDCANCEL,104,26,50,14
END
/////////////////////////////////////////////////////////////////////////////
// Menu

STRPROG MENU DISCARDABLE 
BEGIN
    MENUITEM &quot;&amp;Enter!&quot;,                     IDM_ENTER
    MENUITEM &quot;&amp;Delete!&quot;,                    IDM_DELETE
END
</pre></td></tr>
</table>

<TABLE cellpadding="5" width="95%">
<tr><td><h3>RESOURCE.H (excerpts)</h3>

<P><pre>
// Microsoft Developer Studio generated include file.
// Used by StrProg.rc


#define IDC_STRING                      1000
#define IDM_ENTER                       40001
#define IDM_DELETE                      40002
#define IDC_STATIC                      -1
</pre></td></tr>
</table>

<P>STRPROG.C includes the STRLIB.H header file; this defines the three functions 
in STRLIB that STRPROG will use.

<P>What's most interesting about this program becomes evident when you run 
multiple instances of STRPROG. STRLIB stores the character strings and their pointers in 
shared memory, which lets all instances of STRPROG share this data. Let's look at how it's done.

<A NAME="743"><h3>Sharing Data Among STRPROG Instances</h3></A><P>Windows erects a wall around the address space of a Win32 process. Normally, data 
in an address space is private, invisible to other processes. But running multiple instances 
of STRPROG shows that STRLIB has no trouble sharing its data with all instances of the 
program. When you add or delete a string in a STRPROG window, the change is 
immediately reflected in the other windows.
<P>STRLIB shares two variables among all its instances: an array of strings and an integer indicating the number of valid strings stored. STRLIB keeps these two variables in a special section of memory that it designates as shared:

<P><PRE>#pragma data_seg (&quot;shared&quot;)
int   iTotal = 0 ;
WCHAR szStrings [MAX_STRINGS][MAX_LENGTH + 1] = { ‘\0’ } ;
#pragma data_seg ()</PRE>

<P>The first <I>#pragma</I> statement creates the data section, here named <I>shared</I>. You can name the section whatever you wish. All initialized variables after the <I>#pragma</I> go into the <I>shared</I> section. The second <I>#pragma</I> statement marks the end of the section. It’s important to specifically initialize the variables; otherwise, the compiler puts them in the normal uninitialized section rather than in <I>shared</I>.
<P>The linker has to be told about <I>shared</I>. In the Project Settings dialog box, select the Link tab. In the Project Options field for STRLIB (in both the Release and Debug configurations), include the following linker argument:
<P>/SECTION:shared,RWS
<P>The <I>RWS</I> letters indicate that the section has read, write, and shared attributes. Or you can specify the linker option directly in the DLL source code, as is done in STRLIB.C:
<P>#pragma comment(linker,&quot;/SECTION:shared,RWS&quot;)
<P>The shared memory section allows the <I>iTotal</I> variable and the <I>szStrings</I> array of strings to be shared among all instances of STRLIB. Because MAX_STRINGS is equal to 256 and MAX_LENGTH is equal to 63, the shared memory section is 32,772 bytes in length—the 4 bytes required for the <I>iTotal</I> variable and 128 bytes each for the 256 pointers.
<P>Using a shared memory section is probably the easiest way to share data among multiple applications. If you need to dynamically allocate shared memory space, you should look into the use of file mapping objects, documented at <I>/Platform SDK/Windows Base Services/Interprocess Communication/File Mapping</I>.
</BODY>
</HTML>





