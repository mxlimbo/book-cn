<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Windows and Multimedia</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="748"><h1>Windows and Multimedia</h1></A>
<P>In one sense, multimedia is all about getting access to various pieces of hardware through device-independent function calls. Let's look at this hardware first and then the structure of the Windows multimedia API.

<A NAME="749"><h2>Multimedia Hardware</h2></A>
<P>Perhaps the most commonly used piece of multimedia hardware is the waveform audio device, commonly known as the sound card or sound board. The waveform audio device converts microphone input or other analog audio input into digitized samples for storage in memory or disk files with the .WAV extension. The waveform audio device also converts the waveform back into analog sound for playing over the PC's speakers.

<P>The sound board usually also contains a MIDI device. MIDI is the industry standard Musical Instrument Digital Interface. Such hardware plays musical notes in response to short binary messages. The MIDI hardware usually can also accept a cable connected to a MIDI input device, such as a music keyboard. And often external MIDI synthesizers can also be attached to the sound board.

<P>The CD-ROM drive attached to most of today's PCs is usually capable of playing normal music CDs. This is known as &quot;CD Audio.&quot; The output from the waveform audio device, MIDI device, and CD Audio device are often mixed together under user control with the Volume Control application.

<P>A couple other common multimedia &quot;devices&quot; don't require any additional hardware. The Video for Windows device (also called the AVI Video device) plays movie or animation files with the .AVI (&quot;audio-video interleave&quot;) extension. The ActiveMovie control plays other types of movies, including QuickTime and MPEG. The video board on a PC may have specialized hardware to assist in playing these movies.

<P>More rare are PC users with certain Pioneer laserdisc players or the Sony series of VISCA video cassette recorders. These devices have serial interfaces and thus can be controlled by PC software. Certain video boards have a feature called &quot;video in a window&quot; that allows an external video signal to appear on the Windows screen along with other applications. This is also considered a multimedia device.

<A NAME="750"><h2>An API Overview</h2></A>
<P>The API support of the multimedia features in Windows is in two major collections. These are known as the &quot;low-level&quot; and the &quot;high-level&quot; interfaces.

<P>The low-level interfaces are a series of functions that begin with a short descriptive prefix and are listed (along with high-level functions) in <I>/Platform SDK/Graphics and Multimedia Services/Multimedia Reference/Multimedia Functions</I>.

<P>The low-level wavefrom audio input and output functions begin with the prefix <I>waveIn</I> and <I>waveOut</I>. We'll be looking at these functions in this chapter. Also examined in this chapter will be <I>midiOut</I> functions to control the MIDI Output device. The API also includes <I>midiIn</I> and <I>midiStream</I> functions.

<P>Also used in this chapter are functions beginning with the prefix <I>time</I> that allow setting a high-resolution preemptive timer routine with a timer interval rate going down to 1 millisecond. This facility is primarily for playing back MIDI sequences. Several other groups of functions involve audio compression, video compression, and animation and video sequences; unfortunately, these will not be covered in this chapter.

<P>You'll also notice in the list of multimedia functions seven functions with the prefix <I>mci</I> that allow access to the Media Control Interface (MCI). This is a high-level, open-ended interface for controlling all multimedia hardware in the Multimedia PC. MCI includes many commands that are common to all multimedia hardware. This is possible because many aspects of multimedia can be molded into a tape recorder-like play/record metaphor. You &quot;open&quot; a device for either input or output, you &quot;record&quot; (for input) or &quot;play&quot; (for output), and when you're done you &quot;close&quot; the device.

<P>MCI itself comes in two forms. In one form, you send messages to MCI that are similar to Windows messages. These messages include bit-encoded flags and C data structures. In the second form, you send text strings to MCI. This facility is primarily for scripting languages that have flexible string manipulation functions but not much support for calling Windows APIs. The string-based version of MCI is also good for interactively exploring and learning MCI, as we'll be doing shortly. Device names in MCI include <I>cdaudio</I>, <I>waveaudio</I>, <I>sequencer</I> (MIDI), <I>videodisc</I>, <I>vcr</I>, <I>overlay</I> (analog video in a window), <I>dat</I> (digital audio tape), and <I>digitalvideo</I>. MCI devices are categorized as &quot;simple&quot; and &quot;compound.&quot; Simple devices (such as <I>cdaudio</I>) don't use files. Compound devices (like <I>waveaudio</I>) do; in the case of waveform audio, these files have a .WAV extension.

<P>Another approach to accessing multimedia hardware involves the DirectX API, which is beyond the scope of this book.

<P>Two other high-level multimedia functions also deserve mention: <I>MessageBeep</I> and <I>PlaySound</I>, which was demonstrated way back in <a href="ch03a.htm#38">Chapter 3</a>. <I>MessageBeep</I> plays sounds that are specified in the Sounds applet of the Control Panel. <I>PlaySound</I> can play a .WAV file on disk, in memory, or loaded as resources. The <I>PlaySound</I> function will be used again later in this chapter.

<A NAME="751"><h2>Exploring MCI with TESTMCI</h2></A>
<P>Back in the early days of Windows multimedia, the software development kit included a C program called MCITEST that allowed programmers to interactively type in MCI commands and learn how they worked. This program, at least in its C version, has apparently disappeared. So, I've recreated it as the TESTMCI program shown in Figure 22-1. The user interface is based on the old MCITEST program but not the actual code, although I can't believe it was much different.

<P><B>Figure 22-1.</b> <i>The TESTMCI program.</I>


<TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="752"><h3>TESTMCI.C</h3></A>
<P><pre>
/*----------------------------------------
   TESTMCI.C -- MCI Command String Tester
                (c) Charles Petzold, 1998
  ----------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;resource.h&quot;

#define ID_TIMER    1

BOOL CALLBACK DlgProc (HWND, UINT, WPARAM, LPARAM) ;

TCHAR szAppName [] = TEXT (&quot;TestMci&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,

                    PSTR szCmdLine, int iCmdShow)

{
     if (-1 == DialogBox (hInstance, szAppName, NULL, DlgProc))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
     }
     return 0 ;
}

BOOL CALLBACK DlgProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HWND hwndEdit ;
     int         iCharBeg, iCharEnd, iLineBeg, iLineEnd, iChar, iLine, iLength ;
     MCIERROR    error ;
     RECT        rect ;
     TCHAR       szCommand [1024], szReturn [1024], 
                 szError [1024], szBuffer [32] ;

     switch (message)
     {
     case WM_INITDIALOG:
               // Center the window on screen

          GetWindowRect (hwnd, &amp;rect) ;
          SetWindowPos (hwnd, NULL, 
               (GetSystemMetrics (SM_CXSCREEN) - rect.right + rect.left) / 2,
               (GetSystemMetrics (SM_CYSCREEN) - rect.bottom + rect.top) / 2,
               0, 0, SWP_NOZORDER | SWP_NOSIZE) ;

          hwndEdit = GetDlgItem (hwnd, IDC_MAIN_EDIT) ;
          SetFocus (hwndEdit) ;
          return FALSE ;

     case WM_COMMAND:
          switch (LOWORD (wParam))
          {
          case IDOK:
                    // Find the line numbers corresponding to the selection

               SendMessage (hwndEdit, EM_GETSEL, (WPARAM) &amp;iCharBeg, 
                                                 (LPARAM) &amp;iCharEnd) ;

               iLineBeg = SendMessage (hwndEdit, EM_LINEFROMCHAR, iCharBeg, 0) ;
               iLineEnd = SendMessage (hwndEdit, EM_LINEFROMCHAR, iCharEnd, 0) ;

                    // Loop through all the lines
               for (iLine = iLineBeg ; iLine &lt;= iLineEnd ; iLine++)
               {
                         // Get the line and terminate it; ignore if blank

                    * (WORD *) szCommand = sizeof (szCommand) / sizeof (TCHAR) ;

                    iLength = SendMessage (hwndEdit, EM_GETLINE, iLine, 
                                                     (LPARAM) szCommand) ;
                    szCommand [iLength] = `\0' ;

                    if (iLength == 0)
                         continue ;

                         // Send the MCI command

                    error = mciSendString (szCommand, szReturn, 
                              sizeof (szReturn) / sizeof (TCHAR), hwnd) ;

                         // Set the Return String field

                    SetDlgItemText (hwnd, IDC_RETURN_STRING, szReturn) ;

                         // Set the Error String field (even if no error)

                    mciGetErrorString (error, szError, 
                                       sizeof (szError) / sizeof (TCHAR)) ;

                    SetDlgItemText (hwnd, IDC_ERROR_STRING, szError) ;
               }
                    // Send the caret to the end of the last selected line

               iChar  = SendMessage (hwndEdit, EM_LINEINDEX,  iLineEnd, 0) ;
               iChar += SendMessage (hwndEdit, EM_LINELENGTH, iCharEnd, 0) ;
               SendMessage (hwndEdit, EM_SETSEL, iChar, iChar) ;
               
                    // Insert a carriage return/line feed combination

               SendMessage (hwndEdit, EM_REPLACESEL, FALSE, 
                                      (LPARAM) TEXT (&quot;\r\n&quot;)) ;
               SetFocus (hwndEdit) ;
               return TRUE ;

          case IDCANCEL:
               EndDialog (hwnd, 0) ;
               return TRUE ;

          case IDC_MAIN_EDIT:
               if (HIWORD (wParam) == EN_ERRSPACE)
               {
                    MessageBox (hwnd, TEXT (&quot;Error control out of space.&quot;),
                                szAppName, MB_OK | MB_ICONINFORMATION) ;
                    return TRUE ;
               }
               break ;
          }
          break ;

     case MM_MCINOTIFY:
          EnableWindow (GetDlgItem (hwnd, IDC_NOTIFY_MESSAGE), TRUE) ;

          wsprintf (szBuffer, TEXT (&quot;Device ID = %i&quot;), lParam) ;
          SetDlgItemText (hwnd, IDC_NOTIFY_ID, szBuffer) ;
          EnableWindow (GetDlgItem (hwnd, IDC_NOTIFY_ID), TRUE) ;

          EnableWindow (GetDlgItem (hwnd, IDC_NOTIFY_SUCCESSFUL),
                              wParam &amp; MCI_NOTIFY_SUCCESSFUL) ;
          
          EnableWindow (GetDlgItem (hwnd, IDC_NOTIFY_SUPERSEDED),
                              wParam &amp; MCI_NOTIFY_SUPERSEDED) ;

          EnableWindow (GetDlgItem (hwnd, IDC_NOTIFY_ABORTED),
                              wParam &amp; MCI_NOTIFY_ABORTED) ;

          EnableWindow (GetDlgItem (hwnd, IDC_NOTIFY_FAILURE),
                              wParam &amp; MCI_NOTIFY_FAILURE) ;

          SetTimer (hwnd, ID_TIMER, 5000, NULL) ;
          return TRUE ;

     case WM_TIMER:
          KillTimer (hwnd, ID_TIMER) ;

          EnableWindow (GetDlgItem (hwnd, IDC_NOTIFY_MESSAGE), FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_NOTIFY_ID), FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_NOTIFY_SUCCESSFUL), FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_NOTIFY_SUPERSEDED), FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_NOTIFY_ABORTED), FALSE) ;
          EnableWindow (GetDlgItem (hwnd, IDC_NOTIFY_FAILURE), FALSE) ;
          return TRUE ;

     case WM_SYSCOMMAND:
          switch (LOWORD (wParam))
          {
          case SC_CLOS
E:
               EndDialog (hwnd, 0) ;
               return TRUE ;
          }
          break ;
     }
     return FALSE ;
}
</pre>
</td></tr></table>

<TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="753"><h3>TESTMCI.RC (excerpts)</h3></A>
<P><pre>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;

/////////////////////////////////////////////////////////////////////////////
// Dialog

TESTMCI DIALOG DISCARDABLE  0, 0, 270, 276
STYLE WS_MINIMIZEBOX | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
CAPTION &quot;MCI Tester&quot;
FONT 8, &quot;MS Sans Serif&quot;
BEGIN
    EDITTEXT        IDC_MAIN_EDIT,8,8,254,100,ES_MULTILINE | ES_AUTOHSCROLL | 
                    WS_VSCROLL
    LTEXT           &quot;Return String:&quot;,IDC_STATIC,8,114,60,8
    EDITTEXT        IDC_RETURN_STRING,8,126,120,50,ES_MULTILINE | 
                    ES_AUTOVSCROLL | ES_READONLY | WS_GROUP | NOT WS_TABSTOP
    LTEXT           &quot;Error String:&quot;,IDC_STATIC,142,114,60,8
    EDITTEXT        IDC_ERROR_STRING,142,126,120,50,ES_MULTILINE | 
                    ES_AUTOVSCROLL | ES_READONLY | NOT WS_TABSTOP
    GROUPBOX        &quot;MM_MCINOTIFY Message&quot;,IDC_STATIC,9,186,254,58
    LTEXT           &quot;&quot;,IDC_NOTIFY_ID,26,198,100,8
    LTEXT           &quot;MCI_NOTIFY_SUCCESSFUL&quot;,IDC_NOTIFY_SUCCESSFUL,26,212,100,
                    8,WS_DISABLED
    LTEXT           &quot;MCI_NOTIFY_SUPERSEDED&quot;,IDC_NOTIFY_SUPERSEDED,26,226,100,
                    8,WS_DISABLED
    LTEXT           &quot;MCI_NOTIFY_ABORTED&quot;,IDC_NOTIFY_ABORTED,144,212,100,8,
                    WS_DISABLED
    LTEXT           &quot;MCI_NOTIFY_FAILURE&quot;,IDC_NOTIFY_FAILURE,144,226,100,8,
                    WS_DISABLED
    DEFPUSHBUTTON   &quot;OK&quot;,IDOK,57,255,50,14
    PUSHBUTTON      &quot;Close&quot;,IDCANCEL,162,255,50,14
END
</pre>
</td></tr></table>

<TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<A NAME="754"><h3>RESOURCE.H (excerpts)</h3></A>
<P><pre>
// Microsoft Developer Studio generated include file.
// Used by TestMci.rc

#define IDC_MAIN_EDIT                   1000
#define IDC_NOTIFY_MESSAGE              1005
#define IDC_NOTIFY_ID                   1006
#define IDC_NOTIFY_SUCCESSFUL           1007
#define IDC_NOTIFY_SUPERSEDED           1008
#define IDC_NOTIFY_ABORTED              1009
#define IDC_NOTIFY_FAILURE              1010
#define IDC_SIGNAL_MESSAGE              1011
#define IDC_SIGNAL_ID                   1012
#define IDC_SIGNAL_PARAM                1013
#define IDC_RETURN_STRING               1014
#define IDC_ERROR_STRING                1015
#define IDC_DEVICES                     1016
#define IDC_STATIC                      -1
</pre>
</TD></TR></TABLE>
<P>Like many of the programs in this chapter, TESTMCI uses a modeless dialog box as its main window. Like all of the programs in this chapter, TESTMCI requires the WINMM.LIB import library to be listed in the Links page of the Projects Settings dialog box in Microsoft Visual C++.

<P>This program uses the two most important multimedia functions. These are <I>mciSendString</I> and <I>mciGetErrorText</I>. When you type something into the main edit window in TESTMCI and press Enter (or the OK button), the program passes the string you typed in as the first argument to the <I>mciSendString</I> command:

<P><pre>
error = mciSendString (szCommand, szReturn, 
                       sizeof (szReturn) / sizeof (TCHAR), hwnd) ;
</pre>

<P>If more than one line is selected in the edit window, the program sends them sequentially to the <I>mciSendString</I> function. The second argument is the address of a string that gets information back from the function. The program displays this information in the Return String section of the window. The error code returned from <I>mciSendString</I> is passed to the <I>mciGetErrorString</I> function to obtain a text error description; this is displayed in the Error String section of TESTMCI's window.

<A NAME="755"><h2>MCITEXT and CD Audio</h2></A>
<P>You can get an excellent feel for MCI command strings by taking control of the CD-ROM drive and playing an audio CD. This is a good place to begin because these command strings are often quite simple and, moreover, you get to listen to some music. You may want to have the MCI command string reference at <I>/Platform SDK/Graphics and Multimedia Services/Multimedia Reference/Multimedia Command Strings</I> handy for this exercise.

<P>Make sure the audio output of your CD-ROM drive is connected to speakers or a headphone, and pop in an audio compact disc, for example, Bruce Springsteen's <I>Born to Run</I>. Under Windows 98, the CD Player application might start up and begin playing the album. If so, end the CD Player. Instead, bring up TESTMCI and type in the command

<P><pre>
open cdaudio
</pre>

<P>and press Enter. The word <I>open</I> is an MCI command and the word <I>cdaudio</I> is a device name that MCI recognizes as the CD-ROM drive. (I'm assuming you have only one CD-ROM drive on your system; getting names of multiple CD-ROM drives requires use of the <I>sysinfo</I> command.)

<P>The Return String area in TESTMCI shows the string that the system sends back to your program in the <I>mciSendString</I> function. If the <I>open</I> command works, this is simply the number 1. The Error String area in TESTMCI shows what the <I>mciGetErrorString</I> returns based on the return value from <I>mciSendString</I>. If <I>mciSendString</I> did not return an error code, the Error String area displays the text &quot;The specified command was carried out.&quot;

<P>Assuming the open command worked, you can now enter

<P><pre>
play cdaudio 
</pre>

<P>The CD will begin playing &quot;Thunder Road,&quot; the first cut on the album. You can pause the CD by entering

<P><pre>
pause cdaudio
</pre>

<P>or

<P><pre>
stop cdaudio
</pre>

<P>For the <I>cdaudio</I> device, these statements do the same thing. You can resume playing with

<P><pre>
play cdaudio
</pre>

<P>So far, all the strings we've used have been composed of a command and the device name. Some commands have options. For example, type

<P><pre>
status cdaudio position
</pre>

<P>Depending how long you've been listening, the Return String area should show something like

<P><pre>
01:15:25
</pre>

<P>What is this? It's obviously not hours, minutes, and seconds because the CD is not that long. To find out what the time format is, type

<P><pre>
status cdaudio time format
</pre>

<P>The Return String area now shows the string

<P><pre>
msf
</pre>

<P>This stands for &quot;minutes-seconds-frames.&quot; In CD Audio, there are 75 frames to the second. The frame part of the time format can range from 0 through 74.

<P>The status command has a bunch of options. You can determine the entire length of the CD in msf format using the command

<P><pre>
status cdaudio length
</pre>

<P>For <I>Born to Run</I>, the Return String area will show

<P><pre>
39:28:19
</pre>

<P>That's 39 minutes, 28 seconds, and 19 frames.

<P>Now try

<P><pre>
status cdaudio number of tracks
</pre>

<P>The Return String area will show

<P><pre>
8
</pre>

<P>We know from the CD cover that the title tune is the fifth track on the <I>Born to Run</I> album. Track numbers in MCI commands begin at 1. We can find out how long the song &quot;Born to Run&quot; is by entering

<P><pre>
status cdaudio length track 5
</pre>

<P>The Return String area shows

<P><pre>
04:30:22
</pre>

<P>We can also determine where on the album this track begins

<P><pre>
status cdaudio position track 5
</pre>

<P>The Return String area shows

<P><pre>
17:36:35
</pre>

<P>With this information we can now skip directly to the title track:

<P><pre>
play cdaudio from 17:36:35 to 22:06:57
</pre>

<P>This command will play the one song and then stop. That last value was calculated by adding 4:30:22 (the length of the track) to 17:36:35. Or, it could be determined by using

<P><pre>
status cdaudio position track 6
</pre>

<P>Or, you can set the time format to tracks-minutes-seconds-frames:

<P><pre>
set cdaudio time format tmsf
</pre>

<P>and then

<P><pre>
play cdaudio from 5:0:0:0 to 6:0:0:0
</pre>

<P>or, more simply,

<P><pre>
play cdaudio from 5 to 6
</pre>

<P>You can leave off trailing components of the time if they are 0. It is also possible to set the time format in milliseconds.

<P>Every MCI command string can include the options <I>wait</I> or <I>notify</I> (or both) at the end of the string. For example, suppose you want to play only the first 10 seconds of the song &quot;Born to Run,&quot; and right after that happens, you want the program to do something else. Here's one way to do it (assuming you've set the time format to tmsf):

<P><pre>
play cdaudio from 5:0:0 to 5:0:10 wait
</pre>

<P>In this case, the <I>mciSendString</I> function <I>does not return</I> until the function has been completed, that is, until the 10 seconds of &quot;Born to Run&quot; have finished playing.

<P>Now obviously, in general, this is not a good thing in a single-threaded application. If you accidentally typed

<P><pre>
play cdaudio wait
</pre>

<P>the <I>mciSendString</I> function will not return control to the program until the entire album has played. If you must use the <I>wait</I> option (and it is handy when blindly running MCI scripts, as I'll demonstrate shortly), use the <I>break</I> command first. This command lets you set a virtual key code that will break the <I>mciSendString</I> command and return control to the program. For example, to set the Escape key to serve this purpose, use

<P><pre>
break cdaudio on 27
</pre>


<P>where 27 is the decimal value of VK_ESCAPE. <I>notify</I> option:

<P><pre>
play cdaudio from 5:0:0 to 5:0:10 notify
</pre>

<P>In this case, the <I>mciSendString</I> function returns immediately, but when the operation specified in the MCI command ends, the window whose handle is specified as the last argument to <I>mciSendString </I>receives an MM_MCINOTIFY message. The TESTMCI program displays the result of this message in the MM_MCINOTIFY group box. To avoid confusion as you may be typing in other commands, the TESTMCI program stops displaying the results of the MM_MCINOTIFY message after 5 seconds.

<P>You can use the <I>wait</I> and <I>notify</I> keywords together, but there's hardly a reason for doing so. Without these keywords, the default behavior is to not wait and to not notify, which is usually what you want.

<P>When you're finished playing around with these commands, you can stop the CD by entering

<P><pre>
stop cdaudio
</pre>

<P>If you don't stop the CD-ROM device before closing it, the CD will continue to play even after you close the device.

<P>You can try something that may or may not work with your hardware:

<P><pre>
eject cdaudio
</pre>

<P>And then finally close the device like so:

<P><pre>
close cdaudio
</pre>

<P>Although TESTMCI cannot save or load text files by itself, you can copy text between the edit control and the clipboard. You can select something in TESTMCI, copy it to the clipboard (using Ctrl-C), copy the text from the clipboard into NOTEPAD, and then save it. Reverse this process to load a series of MCI commands into TESTMCI. If you select a series of commands and press OK (or the Enter key), TESTMCI will execute the commands one at a time. This lets you construct MCI &quot;scripts,&quot; which are simply lists of MCI commands.

<P>For example, suppose you like to listen to the songs &quot;Jungleland&quot; (the last track on the album), &quot;Thunder Road,&quot; and &quot;Born to Run,&quot; in that order. Construct a script like so:

<P><pre>
open cdaudio
set cdaudio time format tmsf
break cdaudio on 27
play cdaudio from 8 wait
play cdaudio from 1 to 2 wait
play cdaudio from 5 to 6 wait
stop cdaudio
eject cdaudio
close cdaudio
</pre>

<P>Without the <I>wait</I> keywords, this wouldn't work correctly because the <I>mciSendString</I> commands would return immediately and the next one would then execute.

<P>At this point, it should be fairly obvious how to construct a simple application that mimics a CD player. Your program can determine the number of tracks and the length of each track and can allow the user to begin playing at any point. (Keep in mind, however, that <I>mciSendString</I> always returns information in text strings, so you'll need to write parsing logic that converts those strings to numbers.) Such a program would almost certainly also use the Windows timer, for intervals of a second or so. During WM_TIMER messages, the program would call

<P><pre>
status cdaudio mode 
</pre>

<P>to see whether the CD is paused or playing. The

<P><pre>
status cdaudio position
</pre>

<P>command lets the program update its display to show the user the current position. But something more interesting is also possible: if your program knows the time positions of key parts of the music, it can synchronize on-screen graphics with the CD. This is excellent for music instruction or for creating your own graphical music videos.

</BODY>
</HTML>






