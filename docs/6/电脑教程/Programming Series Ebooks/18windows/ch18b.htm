<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>The Old Metafile Format</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="660"><h1>The Old Metafile Format</h1></A><P>Metafiles either can exist temporarily in memory or can be saved as disk files. To an 
application, these two processes are quite similar; in particular, all the file I/O that 
would otherwise be involved in saving and loading data to and from disk-based metafiles 
is handled by Windows.

<A NAME="661"><h2>Simple Use of Memory Metafiles</h2></A><P>You create a metafile in the old format by first creating a metafile device context with 
a call to <I>CreateMetaFile</I>. You can then use most of the GDI drawing functions to draw 
on this metafile device context. These GDI calls don't really draw on any real device, 
however. Instead, they are stored within the metafile. When you close the metafile 
device context, you get back a handle to the metafile. You can then &quot;play&quot; this metafile on a 
real device context, which is equivalent to executing the GDI functions in the metafile.
<P><I>CreateMetaFile</I> takes a single argument. This can be either NULL or a filename. If 
NULL, the metafile is stored in memory. If it's a filename&#8212;the extension .WMF, for 
&quot;Windows Metafile,&quot; is customary&#8212;then the metafile is stored in a disk file.
<P>The program METAFILE shown in Figure 18-1 shows how to create a 
memory metafile during the WM_CREATE message and display the image 100 times during 
the WM_PAINT message.

<P><B>Figure 18-1.</B> <I>The METAFILE program.</I>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="662"><P><H3>METAFILE.C</H3></A><P><pre>/*----------------------------------------------
   METAFILE.C -- Metafile Demonstration Program
                 (c) Charles Petzold, 1998
  ----------------------------------------------*/
#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName [] = TEXT (&quot;Metafile&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;

     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;

     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Metafile Demonstration&quot;),
                 WS_OVERLAPPEDWINDOW,
                 CW_USEDEFAULT, CW_USEDEFAULT,
                 CW_USEDEFAULT, CW_USEDEFAULT,
                 NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HMETAFILE hmf ;
     static int       cxClient, cyClient ;
     HBRUSH           hBrush ;
     HDC              hdc, hdcMeta ;
     int              x, y ;
     PAINTSTRUCT      ps ;
     
     switch (message)
     {
     case WM_CREATE:
          hdcMeta = CreateMetaFile (NULL) ;
          hBrush  = CreateSolidBrush (RGB (0, 0, 255)) ;

          Rect
angle (hdcMeta, 0, 0, 100, 100) ;
          
          MoveToEx (hdcMeta,   0,   0, NULL) ;
          LineTo   (hdcMeta, 100, 100) ;
          MoveToEx (hdcMeta,   0, 100, NULL) ;
          LineTo   (hdcMeta, 100,   0) ;
          
          SelectObject (hdcMeta, hBrush) ;
          Ellipse (hdcMeta, 20, 20, 80, 80) ;
          
          hmf = CloseMetaFile (hdcMeta) ;
          
          DeleteObject (hBrush) ;
          return 0 ;
          
     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;
          
     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
          
          SetMapMode (hdc, MM_ANISOTROPIC) ;
          SetWindowExtEx (hdc, 1000, 1000, NULL) ;
          SetViewportExtEx (hdc, cxClient, cyClient, NULL) ;
          
          for (x = 0 ; x &lt; 10 ; x++)
          for (y = 0 ; y &lt; 10 ; y++)
          {
               SetWindowOrgEx (hdc, -100 * x, -100 * y, NULL) ;
               PlayMetaFile (hdc, hmf) ;
          }
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
               
     case WM_DESTROY:
          DeleteMetaFile (hmf) ;
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}</pre>
</TD></TR></TABLE>

<P>This program demonstrates the use of the four metafile functions essential in using 
a memory metafile. The first is 
<I>CreateMetaFile</I>, which the program calls with a NULL 
argument during processing of the WM_CREATE message. The function returns a handle to 
a metafile device context. METAFILE then draws two lines and one blue ellipse using 
this metafile DC. These function calls are stored in a binary form in the metafile. The 
<I>CloseMetaFile</I> function returns a handle to the metafile. Notice that the metafile handle is stored 
in a static variable because it will be used later.
<P>The metafile contains a binary representation of the GDI function calls, which 
are two <I>MoveToEx</I> calls, two <I>LineTo</I> calls, a 
<I>SelectObject</I> call (indicating the blue brush), 
and an <I>Ellipse</I> call. No mapping mode or transform is implied by the coordinates. They 
are simply stored as numbers in the metafile.
<P>During the WM_PAINT message, METAFILE sets up a mapping mode and calls 
<I>PlayMetaFile</I> to draw the object 100 times in the window using 
<I>PlayMetaFile</I>. The coordinates of the function calls in the metafile are interpreted in the context of the current 
transform set up for the destination device context. In calling 
<I>PlayMetaFile</I>, in effect you're repeating all the calls that you made between 
<I>CreateMetaFile</I> and <I>CloseMetaFile</I> when you 
originally created the metafile during the WM_CREATE message.
<P>As with any GDI object, metafile objects should be deleted before a program 
terminates. This occurs during the WM_DESTROY message with the 
<I>DeleteMetaFile</I> function.
<P>The results of the METAFILE program are shown in Figure 18-2.
<P><A HREF="javascript:fullSize('F18zg02x.htm')"> <img src="F18zg02.JPG" width=404 height=284 border=0 ALT="Click to view at full size."> </A>
<P><!-- caption --><B>Figure 18-2.</B> <I>The METAFILE display.</I><!-- /caption -->

<A NAME="663"><h2>Storing Metafiles on Disk</h2></A><P>In the above example, the NULL argument to 
<I>CreateMetaFile</I> meant that we wanted to 
create a metafile stored in memory. We can also create a metafile stored on a disk as a file. 
This method is preferred for large metafiles because it uses less memory space. On the 
down side, a metafile stored on disk requires a disk access every time you play it.
<P>To convert METAFILE to using a disk-based metafile, you need to replace the 
NULL argument to <I>CreateMetaFile</I> with a filename. At the conclusion of the WM_CREATE 
processing, you can call <I>DeleteMetaFile</I> with the metafile handle. The handle has been 
deleted but the disk file remains behind.
<P>During processing of the WM_PAINT message, you can get a metafile handle to 
this disk file by calling <I>GetMetaFile</I>:
<p><pre>hmf = GetMetaFile (szFileName) ;</PRE>
<P>Now you can play this metafile just as before. When processing of the 
WM_PAINT message is over, you can delete the metafile handle:
<p><pre>DeleteMetaFile (hmf) ;</PRE>
<P>When it comes time to process the WM_DESTROY message, you don't have to 
delete the metafile, because it was deleted at the end of the WM_CREATE message and 
at the end of each WM_PAINT message. But you should still delete the disk file like so,
<p><pre>DeleteFile (szFileName) ;</PRE>
<P>unless, of course, you want to keep the file around.
<P>You can make a metafile a programmer-defined resource as discussed in Chapter 
10. You'd simply load it as a data block. If you have a block of data with the contents of 
a metafile, you can create a metafile using
<p><pre>hmf = SetMetaFileBitsEx (iSize, pData) ;</PRE>
<P><I>SetMetaFileBitsEx</I> has a companion function, 
<I>GetMetaFileBitsEx</I>, that copies the contents of a metafile to a block of memory.

<A NAME="664"><h2>Old Metafiles and the Clipboard</h2></A><P>The old metafiles have a nasty flaw. If you have a handle to an old-style metafile, how 
can you determine how large the image will be when you play it? Unless you start digging 
into the internals of the metafile itself, you can't.
<P>Moreover, when a program obtains an old-style metafile from the clipboard, it 
has the most flexibility in working with it if the metafile has been designed to be played 
in an MM_ISOTROPIC or MM_ANISOTROPIC mapping mode. The program that 
receives the metafile can then scale the image by simply setting viewport extents before playing 
the metafile. But if the mapping mode is set to MM_ISOTROPIC or MM_ANISOTROPIC 
<I>within</I> the metafile, the program that receives the metafile is stuck. The program can make 
GDI calls only before or after the metafile is played. It can't make a GDI call in the middle 
of a metafile.
<P>To solve these problems, old-style metafile handles are not directly put into the 
clipboard and retrieved by other programs. Instead, the metafile handle is part of a 
&quot;metafile picture,&quot; which is a structure of type METAFILEPICT. This structure allows the program 
that obtains the metafile picture from the clipboard to set the mapping mode and 
viewport extents itself before playing the metafile.
<P>The METAFILEPICT structure is 16 bytes long and defined like so:
<p><pre>typedef struct tagMETAFILEPICT
{
     LONG mm ;             // mapping mode
     LONG xExt ;           // width of the metafile image
     LONG yExt ;           // height of the metafile image
     LONG hMF ;            // handle to the metafile
}
METAFILEPICT ;</PRE>
<P>For all the mapping modes except MM_ISOTROPIC and MM_ANISOTROPIC, the 
<I>xExt</I> and <I>yExt</I> values are the size of the image in units of the mapping mode given by 
<I>mm</I>. With this information, the program that copies the metafile picture structure from the 
clipboard can determine how much display space the metafile will encompass when it is played. 
The program that creates the metafile can set these values to the largest 
<I>x</I>-coordinates and <I>y</I>-coordinates it uses in the GDI drawing functions that enter the metafile.
<P>For the MM_ISOTROPIC and MM_ANISOTROPIC mapping modes, the 
<I>xExt</I> and <I>yExt</I> fields function differently. You will recall from <a href="ch05a.htm#94">Chapter 5</a> that a program uses the MM_ISOTROPIC or MM_ANISOTROPIC mapping mode when it wants to use arbitrary 
logical units in GDI functions independent of the measurable size of the image. A 
program uses MM_ISOTROPIC when it wants to maintain an aspect ratio regardless of the size 
of the viewing surface and MM_ANISOTROPIC when it doesn't care about the aspect 
ratio. You will also recall from <a href="ch05a.htm#94">Chapter 5</a> that after a program sets the mapping mode 
to MM_ISOTROPIC or MM_ANISOTROPIC, it generally makes calls to 

<I>SetWindowExtEx</I> and <I>SetViewportExtEx</I>. The 
<I>SetWindowExtEx</I> call uses logical units to specify the units the 
program wants to use when drawing. The 
<I>SetViewportExtEx</I> call uses device units based 

on the size of the viewing surface (for instance, the size of the window's client area).
<P>If a program creates an MM_ISOTROPIC or MM_ANISOTROPIC metafile for the 
clipboard, the metafile should not itself contain a call to 
<I>SetViewportExtEx</I> because the device units in that call would be based on the display surface of the program creating the 
metafile and not on the display surface of the program that reads the metafile from the 
clipboard and plays it. Instead, the <I>xExt</I> and 
<I>yExt</I> values should assist the program that obtains 
the metafile from the clipboard in setting appropriate viewport extents for playing the 
metafile. But the metafile itself contains a call to set the window extent when the mapping mode 
is MM_ISOTROPIC or MM_ANISOTROPIC. The coordinates of the GDI drawing 
functions within the metafile are based on these window extents.
<P>The program that creates the metafile and metafile picture follows these rules:
<UL>
<p><li> The <I>mm</I> field of the METAFILEPICT structure is set to specify the mapping mode.
<p><li> For mapping modes other than MM_ISOTROPIC and MM_ANISOTROPIC, 
the <I>xExt</I> and <I>yExt</I> fields are set to the width and height of the image in units 
corresponding to the <I>mm</I> field. For metafiles to be played in an 
MM_ISOTROPIC or MM_ANISOTROPIC environment, matters get a little more complex. For MM_ANISOTROPIC, zero values of <I>xExt</I> and 
<I>yExt</I> are used when the program is suggesting neither a size nor an aspect ratio for the image. For MM_ISOTROPIC 
or MM_ANISOTROPIC, positive values of <I>xExt</I> and 
<I>yExt</I> indicate a suggested width and height of the image in units of 0.01 mm (MM_HIMETRIC units). For MM_ISOTROPIC, negative values of <I>xExt</I> and <I>yExt</I> indicate a suggested aspect ratio of the image but not a suggested size.
<p><li> For the MM_ISOTROPIC and MM_ANISOTROPIC mapping modes, the 
metafile itself contains calls to 
<I>SetWindowExtEx</I> and (possibly) 
<I>SetWindowOrgEx</I>. That is, the program that creates the metafile calls these functions in the 
metafile device context. Generally, the metafile will not contain calls to 
<I>SetMapMode</I>, <I>SetViewportExtEx</I>, or 
<I>SetViewportOrgEx</I>.
<p><li> The metafile should be a memory-based metafile, not a disk-based metafile.
</UL>
<P>Here's some sample code for a program creating a metafile and copying it to 
the clipboard. If the metafile uses the MM_ISOTROPIC or MM_ANISOTROPIC mapping 
mode, the first calls in the metafile should be to set the window extent. (The window extent 
is fixed in the other mapping modes.) Regardless of the mapping mode, the window 
origin can also be set:
<p><pre>hdcMeta = CreateMetaFile (NULL) ;
SetWindowExtEx (hdcMeta, ...) ;
SetWindowOrgEx (hdcMeta, ...) ;</PRE>
<P>The coordinates in the drawing functions of the metafile are based on these 
window extents and the window origin. After the program uses GDI calls to draw on the 
metafile device context, the metafile is closed to get a handle to the metafile:
<p><pre>hmf = CloseMetaFile (hdcMeta) ;</PRE>
<P>The program also needs to define a pointer to a structure of type METAFILEPICT 
and allocate a block of global memory for this structure:
<p><pre>GLOBALHANDLE   hGlobal ;
LPMETAFILEPICT pMFP ;
<I>[other program lines]</I>
hGlobal= GlobalAlloc (GHND | GMEM_SHARE, sizeof (METAFILEPICT)) ;
pMFP = (LPMETAFILEPICT) GlobalLock (hGlobal) ;</PRE>
<P>Next, the program sets the four fields of this structure:
<p><pre>pMFP-&gt;mm   = MM_...  ;
pMFP-&gt;xExt = ...  ;
pMFP-&gt;yExt = ...  ;
pMFP-&gt;hMF  = hmf  ;

GlobalUnlock (hGlobal) ;</PRE>
<P>The program then transfers the global memory block containing the metafile picture 
structure to the clipboard:
<p><pre>OpenClipboard (hwnd) ;
EmptyClipboard () ;
SetClipboardData (CF_METAFILEPICT, hGlobal) ;
CloseClipboard () ;</PRE>
<P>Following these calls, the <I>hGlobal</I> handle (the memory block containing the 
metafile picture structure) and the <I>hmf</I> handle (the metafile itself) become invalid for the 
program that created them.
<P>Now for the hard part. When a program obtains a metafile from the clipboard 
and plays this metafile, the following steps must take place:
<OL>
<p><li> The program uses the <I>mm</I> field of the metafile picture structure to set the mapping mode.
<p><li> For mapping modes other than MM_ISOTROPIC or MM_ANISOTROPIC, 
the program uses the <I>xExt</I> and <I>yExt</I> values to set a clipping rectangle or simply 
to determine the size of the image. For the MM_ISOTROPIC and MM_ANISOTROPIC mapping modes, the program uses 
<I>xExt</I> and <I>yExt</I> to set the viewport extents.
<p><li> The program then plays the metafile.
</OL>
<P>Here's the code. You first open the clipboard, get the handle to the metafile 
picture structure, and lock it:
<p><pre>OpenClipboard (hwnd) ;
hGlobal = GetClipboardData (CF_METAFILEPICT) ;
pMFP = (LPMETAFILEPICT) GlobalLock (hGlobal) ;</PRE>
<P>You can then save the attributes of your current device context and set the 
mapping mode to the <I>mm</I> value of the structure:
<p><pre>SaveDC (hdc) ;
SetMappingMode (pMFP-&gt;mm) ;</PRE>
<P>If the mapping mode isn't MM_ISOTROPIC or MM_ANISOTROPIC, you can set 
a clipping rectangle to the values of <I>xExt</I> and 
<I>yExt</I>. Because these values are in logical 
units, you have to use <I>LPtoDP</I> to convert the coordinates to device units for the clipping 
rectangle. Or you can simply save the values so that you know how large the image is.
<P>For the MM_ISOTROPIC or MM_ANISOTROPIC mapping mode, you use 
<I>xExt</I> and <I>yExt</I> to set the viewport extent. One possible function to perform this task is shown 
below. This function assumes that <I>cxClient</I> and 
<I>cyClient</I> represent the pixel height and 
width of the area in which you want the metafile to appear if no suggested size is implied 
by <I>xExt</I> and <I>yExt</I>.
<p><pre>void PrepareMetaFile (HDC hdc, LPMETAFILEPICT pmfp,
                      int cxClient, int cyClient)
{
     int xScale, yScale, iScale ;

     SetMapMode (hdc, pmfp-&gt;mm) ;

     if (pmfp-&gt;mm == MM_ISOTROPIC &#166;&#166; pmfp-&gt;mm == MM_ANISOTROPIC)
     {
          if (pmfp-&gt;xExt == 0)
               SetViewportExtEx (hdc, cxClient, cyClient, NULL) ;
          else if (pmfp-&gt;xExt &gt; 0)
               SetViewportExtEx (hdc,
                    pmfp-&gt;xExt * GetDeviceCaps (hdc, HORZRES) /
                                 GetDeviceCaps (hdc, HORZSIZE) / 100),
                    pmfp-&gt;yExt * GetDeviceCaps (hdc, VERTRES) /
                                 GetDeviceCaps (hdc, VERTSIZE) / 100),
                    NULL) ;
 
          else if (pmfp-&gt;xExt &lt; 0)
          {
               xScale = 100 * cxClient * GetDeviceCaps (hdc, HORZSIZE) /
                              GetDeviceCaps (hdc, HORZRES) / -pmfp-&gt;xExt ;
               lScale = 100 * cyClient * GetDeviceCaps (hdc, VERTSIZE) /
                              GetDeviceCaps (hdc, VERTRES) / -pmfp-&gt;yExt ;
               iScale = min (xScale, yScale) ;

               SetViewportExtEx (hdc,
                    -pmfp-&gt;xExt * iScale * GetDeviceCaps (hdc, HORZRES) /
                              GetDeviceCaps (hdc, HORZSIZE) / 100,
                    -pmfp-&gt;yExt * iScale * GetDeviceCaps (hdc, VERTRES) /
                              GetDeviceCaps (hdc, VERTSIZE) / 100,
                    NULL) ;
          }
     }
}
</PRE>
<P>This code assumes that both <I>xExt</I> and 
<I>yExt</I> are 0, greater than 0, or less than 0 (which should be the case). If the extents are 0, no size or aspect ratio is suggested. The 
viewport extents are set to the area in which you want to display the metafile. Positive values of 
<I>xExt</I> and <I>yExt</I> are a suggested image size in units of 0.01 mm. The 
<I>GetDeviceCaps</I> function assists in determining the number of pixels per 0.01 mm, and this value is multiplied by the 
extent values in the metafile picture structure. Negative values of 
<I>xExt</I> and <I>yExt</I> indicate a suggested aspect ratio but not a suggested size. The value 
<I>iScale</I> is first calculated based on the aspect ratio of the size in millimeters corresponding to 
<I>cxClient</I> and <I>cyClient</I>. This scaling factor is then used to set a viewport extent in pixels.<P>
With this job out of the way, you can set a viewport origin if you want, play 
the metafile, and return the device context to normal:
<p><pre>PlayMetaFile (pMFP-&gt;hMF) ;
RestoreDC (hdc, -1) ;</PRE>
<P>Then you unlock the memory block and close the clipboard:
<p><pre>GlobalUnlock (hGlobal) ;
CloseClipboard () ;</PRE>
<P>If your program uses enhanced metafiles, you don't have to do this work. The 
Windows clipboard will convert between the old metafile format and the enhanced 
metafile format when one application puts one of these formats into the clipboard and 
another application requests the other format from the clipboard.

</BODY>
</HTML>






