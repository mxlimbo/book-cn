<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>MIDI and Music</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="780"><h1>MIDI and Music</h1></A>
<P>The Musical Instrument Digital Interface (MIDI) was developed in the early 1980s by a consortium of manufacturers of electronic music synthesizers. MIDI is a protocol for connecting electronic music instruments among themselves and with computers. MIDI is an extremely important standard in the field of electronic music. The MIDI specification is maintained by the MIDI Manufacturers Association (MMA), which has a Web site at <I><a href="http://www.midi.org" target="_window2">http://www.midi.org</a></I>.

<A NAME="781"><h2>The Workings of MIDI</h2></A>
<P>MIDI defines a protocol for passing digital commands through a cable. A MIDI cable uses 5-pin DIN connectors, but only three of the connectors are used. One is a shield, another is a current loop, and the third carries the data. The MIDI protocol is unidirectional at 31,250 bits per second. Each byte of data begins with a start bit and ends with a stop bit, for an effective transfer rate of 3,125 bytes per second.

<P>It's important to understand that no actual sounds&#8212;in either an analog or digital format&#8212;are transferred through the MIDI cable. What goes through the cable are generally simple messages, usually 1, 2, or 3 bytes in length.


<P>A simple MIDI configuration could consist of two pieces of MIDI-compatible hardware. One is a MIDI keyboard that makes no sounds by itself but serves solely to generate MIDI messages. This keyboard has a MIDI port labeled &quot;MIDI Out.&quot; You connect a MIDI cable from this port to the &quot;MIDI In&quot; port of a MIDI sound synthesizer. This synthesizer may simply look like a little box with a few buttons on the front.

<P>When you press a key on the keyboard (let's say middle C), the keyboard sends 3 bytes to the MIDI Out port. In hexadecimal, these bytes are

<P><pre>
90 3C 40
</pre>

<P>The first byte (90) indicates a &quot;Note On&quot; message. The second byte is the key number, where 3C is middle C. The third byte is the velocity with which the key is struck and may range from 1 to 127. We happen to be using a keyboard here that is not velocity-sensitive, so it sends an average velocity value. This 3-byte message goes down the MIDI cable into the Midi In port of the synthesizer. The synthesizer responds by playing a tone at middle C.

<P>When you release the key, the keyboard sends another 3-byte message to the MIDI Out port:

<P><pre>
90 3C 00
</pre>

<P>This is the same as the Note On command, but with a zero velocity byte. This zero byte indicates a Note Off command, meaning that the note should be turned off. The synthesizer reponds by stopping the sound.

<P>If the synthesizer is capable of polyphony (that is, playing more than one note at the same time), then you can play chords on the keyboard. The keyboard generates multiple Note On messages, and the synthesizer plays all the notes. When you release the chord, the keyboard sends multiple Note Off messages to the synthesizer.

<P>Generally speaking, the keyboard in this configuration is known as a &quot;MIDI controller.&quot; It is reponsible for generating MIDI messages to control a synthesizer. A MIDI controller does not have to look like a keyboard. There are MIDI wind controllers that look like clarinets or saxophones, MIDI guitar controllers, MIDI string controllers, and MIDI drum controllers. At the very least, all of these controllers generate 3-byte Note On and Note Off messages.

<P>Rather than something that resembles a keyboard or traditional musical instrument, a controller can also be a &quot;sequencer.&quot; This is a piece of hardware that stores sequences of Note On and Note Off messages in memory and then plays them back. Stand-alone sequencers are used much less today than they were some years ago because they have been replaced with computers. A computer equipped with a MIDI board can also generate Note On and Note Off messages to control synthesizers. MIDI authoring software, which lets you compose on screen, can store MIDI messages coming from a MIDI controller, let you manipulate them, and then send the MIDI messages to a synthesizer.

<P>The synthesizer is sometimes also called a &quot;sound module&quot; or &quot;tone generator.&quot; MIDI does not specify how the sounds are actually generated. The synthesizer could be using any one of a variety of different sound generation techniques.

<P>In the real world, only very simple MIDI controllers (such as wind controllers) have only MIDI Out cable ports. Often a keyboard will have a built-in synthesizer, and it will have three MIDI cable ports labeled MIDI In, MIDI Out, and MIDI Thru. The MIDI In port accepts MIDI messages to play the keyboard's internal synthesizer. The MIDI Out port sends MIDI messages from the keyboard to an external synthesizer. The MIDI Thru port is an output port that duplicates the input in the MIDI In port&#8212;whatever comes into the MIDI In port is sent back out to the MIDI Thru port. (The MIDI Thru port does not contain any of the information sent out over the MIDI Out port.)

<P>There are only two ways to connect MIDI hardware by cables: You can connect a MIDI Out on one piece of hardware to MIDI In of another, or you can connect MIDI Thru to MIDI In. The MIDI Thru port allows for the daisy-chaining of MIDI synthesizers.

<A NAME="782"><h2>The Program Change</h2></A>
<P>What kind of sound does the synthesizer make? Is it a piano sound, a violin sound, a trumpet sound, or a flying saucer sound? Generally the various sounds that a synthesizer is capable of producing are stored in ROM or somewhere else. These are generally called &quot;voices&quot; or &quot;instruments&quot; or &quot;patches.&quot; (The word &quot;patch&quot; comes from the days of analog synthesizers when different sounds were configured by plugging patch chords into jacks on the front of the synthesizer.)

<P>In MIDI, the various sounds that a synthesizer is capable of producing are known as &quot;programs.&quot; Changing the program requires sending the synthesizer a MIDI Program Change message,

<P><pre>
C0 pp
</pre>

<P>where <I>pp</I> can range from 0 to 127. Often a MIDI keyboard will have a series of numbered buttons across the top that generate Program Change messages. By pressing these you can control the synthesizer voice from the keyboard. The numbering of these buttons usually begins with 1 rather than 0, so program number 1 corresponds to a Program Change byte of 0.

<P>The MIDI specification does not indicate what program numbers should correspond with what instruments. For example, the first three programs on a Yamaha DX7 synthesizer are called &quot;Warm Strings,&quot; &quot;Mellow Horn,&quot; and &quot;Pick Guitar.&quot; On a Yamaha TX81Z tone generator, they're &quot;Grand Piano,&quot; &quot;Upright Piano,&quot; and &quot;Deep Grand.&quot; On a Roland MT-32 sound module, they're &quot;Acoustic Piano 1,&quot; &quot;Acoustic Piano 2,&quot; and &quot;Acoustic Piano 3.&quot; So, if you don't want to be surprised when you make a program change from a keyboard, you had better know what instrument voice corresponds to each program number in the synthesizer you happen to be using.

<P>This can be a real problem for MIDI files that contain Program Change messages&#8212;these files are not device-independent because their contents will sound different on different synthesizers. However, in recent years, a standard known as &quot;General MIDI&quot; (GM) has standardized the program numbers. General MIDI is supported by Windows. If a synthesizer is not in accordance with the General MIDI specification, program mappings can make it emulate a General MIDI synthesizer.

<A NAME="783"><h2>The MIDI Channel</h2></A>
<P>I've discussed two MIDI messages so far. The first is Note On,

<P><pre>
90 kk vv
</pre>

<P>where <I>kk</I> is the key number (0 to 127) and 
<I>vv</I> is the velocity (0 to 127). A zero 
velocity indicates a Note Off command. The second is the Program Change,

<P><pre>
C0 pp
</pre>

<P>where <I>pp</I> ranges from 0 to 127. These are typical of MIDI messages. The first byte is called the &quot;status&quot; byte. Depending on what the status byte is, it is generally followed by 0, 1, or 2 &quot;data&quot; bytes. (The exception is for &quot;system exclusive&quot; messages that I'll describe shortly.) It is easy to distinguish a status byte from a data byte: the high bit is always 1 for a status byte and 0 for a data byte.

<P>I have not yet discussed the generalized form of these two messages, however. The generalized form of the Note On message is

<P><pre>
9n kk vv
</pre>

<P>and the Program Change is

<P><pre>
Cn pp
</pre>

<P>In both cases, <I>n</I> corresponds to the lower four bits of the status byte and can range from 0 to 15. This is called the MIDI &quot;channel.&quot; Channels are generally numbered beginning with 1, so if <I>n</I> is zero, that means channel 1.

<P>The use of 16 different channels allows a MIDI cable to carry messages for 16 different voices. Generally, you'll find that a particular string of MIDI messages will begin with Program Change messages to set a voice for the various channels being used, followed by multiple Note On and Note Off commands. Later on, there might be other Program Change commands. But at any time, each channel is associated with only one voice.

<P>Let's take a simple example: Suppose the keyboard controller I've been describing is able to generate MIDI messages for two different channels simultaneously&#8212;channel 1 and channel 2. You might begin by pressing buttons on the keyboard to send two Program Change messages to the synthesizer:

<P><pre>
C0 01
C1 05 
</pre>

<P>Channel 1 is now set for program 2, and channel 2 is set for program 6. (Recall that channel numbers and program numbers are 1-based but encoded in a 0-based form in the messages.) Now when you press a key on the keyboard, it sends two Note On messages, one for each channel:

<P><pre>
90 kk vv
91 kk vv
</pre>

<P>This lets you play two instrument voices simultaneously in unison.

<P>An alternative is a &quot;split&quot; keyboard. The lower keys could generate Note On messages on channel 1, and the upper keys could generate Note On messages on channel 2. This lets you play two instruments independently from one keyboard.

<P>The use of 16 channels becomes more powerful when you think about MIDI sequencing software on a PC. Each channel corresponds to a different instrument. If you have a synthesizer that can play 16 different instruments independently, you can orchestrate a composition for a 16-piece band and connnect the MIDI board with the synthesizer using just one MIDI cable.

<A NAME="784"><h2>MIDI Messages</h2></A>
<P>Although the Note On and Program Change messages are the most important messages in any MIDI implementation, this is not all that MIDI can do. Figure 22-9 is a chart of the MIDI channel messages defined in the MIDI specification. As I've noted above, the status byte always has the high bit set and all data bytes that follow the status byte have a high bit equal to 0. This means that status bytes can range from 0x80 through 0xFF, while data bytes range from 0 through 0x7F.

<P><TABLE cellpadding="5" width="95%">
<tr>
<td valign="top"><B><I>MIDI Message</I></B></td>
<td valign="top"><B><I>Data Bytes</I></B></td>
<td valign="top"><B><I>Values</I></B></td>
</tr>
<tr>
<td valign="top">Note Off</td>
<td valign="top">8n <I>kk vv</I></td>
<td valign="top"><I>kk</I> = key number (0-127)
<BR><I>vv</I> = velocity (0-127)</td>
</tr>
<tr>
<td valign="top"><P>Note On</td>
<td valign="top">9n <I>kk vv</I></td>
<td valign="top"><I>kk</I> = key number (0-127)
<BR><I>vv</I> = velocity (1-127, 0 = note off)</td>
</tr>
<tr>
<td valign="top">Polyphonic After Touch</td>
<td valign="top">An <I>kk tt</I></td>     
<td valign="top"><I>kk</I> = key number (0-127)
<BR><I>tt</I> = after touch (0-127)</td>
</tr>
<tr>
<td valign="top"><P>Control Change</td>
<td valign="top">Bn <I>cc xx</I></td>   
<td valign="top"><I>cc</I> = controller (0-121)
<BR><I>xx</I> = value (0-127)</td>
</tr>
<tr>
<td valign="top">Channel Mode Local Control</td>
<td valign="top">Bn 7A<I> xx</I></td>     
<td valign="top"><I>xx</I> = 0 (off), 127 (on)</td>
</tr>
<tr>
<td valign="top">  All Notes Off</td>
<td valign="top">Bn 7B 00</td>     
<td valign="top"></td>
</tr>
<tr>
<td valign="top">  Omni Mode Off</td>
<td valign="top">Bn 7C 00</td>
<td valign="top"></td>     
</tr>
<tr>
<td valign="top">  Omni Mode On</td>
<td valign="top">Bn 7D 00</td>     
<td valign="top"></td>
</tr>
<tr>
<td valign="top">  Mono Mode On</td>
<td valign="top">Bn 7E <I>cc</I></td>     
<td valign="top"><I>cc</I> = number of channels</td>
</tr>
<tr>
<td valign="top">  Poly Mode On</td>
<td valign="top">Bn 7F 00</td>
<td valign="top"></td>
</tr>
<tr>
<td valign="top">Program Change</td>
<td valign="top">Cn <I>pp</I></td>
<td valign="top"><I>pp</I> = program (0-127)</td>
</tr>
<tr>
<td valign="top">Channel After Touch</td>
<td valign="top">Dn <I>tt</I></td>     
<td valign="top"><I>tt</I> = after touch (0-127)</td>
</tr>
<tr>
<td valign="top">Pitch Wheel Change</td>
<td valign="top">En <I>ll hh</I></td>     
<td valign="top"><I>ll</I> = low 7 bits (0-127)   
<BR><I>hh</I> = high 7 bits (0-127)</td></tr>
</table>

<P><B>Figure 22-9.</b> <i>The MIDI Channel Messages (</I>n<I> = channel number, 0 through 15)</I>

<P>The key numbers generally correspond to the traditional notes of Western music, although they don't have to. (For a percussion voice, each key number could be a different percussion instrument, for example.) When the key numbers correspond to a piano-type keyboard, key 60 (in decimal) is middle C. The MIDI key numbers extend 21 notes below and 19 notes above the range of a normal 88-key piano. The velocity number is the velocity with which the key is depressed, which on a piano governs both loudness and the harmonic character of the sound. A particular voice can respond to key velocity in this way or other ways.

<P>The examples I showed earlier used a Note On message with a velocity byte of zero to indicate a Note Off command. There is also a separate Note Off command for keyboards (or other controllers) that implement a key release velocity. This is very rare, however.

<P>There are two &quot;after-touch&quot; messages. After-touch is a feature of some keyboards where you can change the sound in some way by pressing harder on the key after it's already depressed. One message (status byte 0xDn) is an after-touch that applies to all the notes currently being played in a channel; this is the most common. The status byte 0xAn indicates after&#8211;touch that applies to each individual key independently.

<P>Generally keyboards have some dials or switches for further controlling the sound. These are called &quot;controllers,&quot; and any change is indicated by a status byte of 0xBn. Controllers are identified by numbers ranging from 0 to 121. The 0xBn status byte is also used for Channel Mode messages that indicate how a synthesizer should respond to simultaneous notes in the channel.

<P>One very important controller is a wheel that shifts the pitch up and down. This has a separate MIDI message with a status byte of 0xEn.

<P>Missing from the chart in Figure 22-9 are messages that begin with status bytes F0 through FF. These are called system messages because they apply to the entire MIDI system rather than a particular channel. The system messages are generally used for synchronization purposes, triggering sequencers, resetting hardware, and obtaining information.

<P>Many MIDI controllers continually send out status bytes of 0xFE, which is called the Active Sensing message. This simply indicates that the MIDI controller is still attached to the system.

<P>One important system message is the &quot;system exclusive&quot; message that begins with a status byte of 0xF0. This is used for transferring chunks of data to a synthesizer in a manufacturer-dependent and synthesizer-dependent format. (For example, new voice definitions can be passed from a computer to a synthesizer in this way.) The system exclusive message is the only message that can contain more than 2 data bytes. In fact, the number of data bytes is variable, but each data byte must have its high bit set to 0. The status byte 0xF7 indicates an end of the system exclusive message.

<P>System exclusive messages are also used for dumping data (for example, voice definitions) from the synthesizer. The data comes out of the synthesizer through the MIDI Out port. If you're attempting to program for MIDI in a device-independent manner, you should probably avoid using system exclusive messages. But they are quite valuable for defining new synthesizer voices.

<P>A MIDI file (with the extension .MID) is a collection of MIDI messages with timing information. You can play MIDI files using MCI. However, for the remainder of this chapter, I'll be discussing the low-level <I>midiOut</I> functions.

<A NAME="785"><h2>An Introduction to MIDI Sequencing</h2></A>
<P>The low-level MIDI API consists of functions beginning with the prefix <I>midiIn</I>, for reading MIDI sequences coming from an external controller, and <I>midiOut</I>, for playing music on the internal or external synthesizer. Despite the term &quot;low-level,&quot; you don't need to know anything about the hardware interface of the MIDI board when using these functions.

<P>To open a MIDI output device in preparation for playing music, you call <I>midiOutOpen</I>:

<P><pre>
error = midiOutOpen (&amp;hMidiOut, wDeviceID, dwCallBack, 
                     dwCallBackData, dwFlags) ;
					 </pre>
					 
<P>The function returns 0 if successful or an error code if not. If you've specified the function arguments correctly, an error will usually indicate that the MIDI device is already in use by another program.

<P>The first argument is a pointer to a variable of type HMIDIOUT that receives a MIDI output handle for use in subsequent MIDI output functions. The second argument is the device ID. To use one of the real MIDI devices, this argument can range from 0 to one less than the number returned from <I>midiOutGetNumDevs</I>. Or you can use MIDIMAPPER, which is defined in MMSYSTEM.H as &#8211;1. In most cases, you'll probably set the last three arguments of <I>midiOutOpen</I> to NULL or 0.

<P>Once you open a MIDI output device and obtain the handle, you can begin sending MIDI messages to the device. You do this by calling

<P><pre>
error = midiOutShortMsg (hMidiOut, dwMessage) ;
</pre>

<P>The first parameter is the handle obtained from <I>midiOutOpen</I>. The second parameter is a 1-byte, 2-byte, or 3-byte MIDI message packed into a 32-bit DWORD. As I discussed earlier, MIDI messages begin with a status byte, followed by 0, 1, or 2 bytes of data. The status byte forms the least significant byte of <I>dwMessage</I>, the first data byte is the next significant byte, and the second data byte is the next. The most significant byte of <I>dwMessage</I> is 0.

<P>For example, to play a middle C (the note 0x3C) on MIDI channel 5 with a velocity of 0x7F, you need a 3-byte Note On message:

<P><pre>
0x95 0x3C 0x7F
</pre>

<P>The <I>dwMessage</I> parameter to <I>midiOutShortMsg</I> is 0x007F3C95.

<P>The three essential MIDI messages are Program Change (to change the instrument voice for a particular channel), Note On, and Note Off. After opening a MIDI output device, you should always begin with a Program Change message and you should send an equal number of Note On and Note Off messages.

<P>When you're all done playing the music you want to play, you can reset the MIDI output device to make sure that all notes are turned off:

<P><pre>
midiOutReset (hMidiOut) ;
</pre>

<P>You can then close the device:

<P><pre>
midiOutClose (hMidiOut) ;
</pre>

<P>The <I>midiOutOpen</I>, <I>midiOutShortMsg</I>, <I>midiOutReset</I>, and <I>midiOutClose</I> functions are the four essential functions you need for using the low-level MIDI output API.

<P>So, let's play some music! The BACHTOCC program shown in Figure 22-10 plays the first measure of the toccata section of J. S. Bach's famous Toccata and Fugue in D Minor for organ.

<P><B>Figure 22-10.</b> <i>The BACHTOCC Program.     </I>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="786"><h3>BACHTOCC.C</h3></A>
<P><pre>
/*---------------------------------------------------
   BACHTOCC.C -- Bach Toccata in D Minor (First Bar)
                 (c) Charles Petzold, 1998
  ---------------------------------------------------*/

#include &lt;windows.h&gt;

#define ID_TIMER    1

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

TCHAR szAppName[] = TEXT (&quot;BachTocc&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;

     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;

     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, 
                          TEXT (&quot;Bach Toccata in D Minor (First Bar)&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     if (!hwnd)
          return 0 ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

DWORD MidiOutMessage (HMIDIOUT hMidi, int iStatus, int iChannel,
                                      int iData1,  int iData2)
{
     DWORD dwMessage = iStatus | iChannel | (iData1 &lt;&lt; 8) | (iData2 &lt;&lt; 16) ;
     
     return midiOutShortMsg (hMidi, dwMessage) ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static struct
     {
          int iDur ;
          int iNote [2] ;
     }
     noteseq [] = { 110, 69, 81,  110, 67, 79,  990, 69, 81,  220, -1, -1,
                    110, 67, 79,  110, 65, 77,  110, 64, 76,  110, 62, 74,
                    220, 61, 73,  440, 62, 74, 1980, -1, -1,  110, 57, 69,
                    110, 55, 67,  990, 57, 69,  220, -1, -1,  220, 52, 64,
                    220, 53, 65,  220, 49, 61,  440, 50, 62, 1980, -1, -1 } ;
     
     static HMIDIOUT hMidiOut ;
     static int      iIndex ;
     int             i ;
     
     switch (message)
     {
     case WM_CREATE:
               // Open MIDIMAPPER device
          
          if (midiOutOpen (&amp;hMidiOut, MIDIMAPPER, 0, 0, 0))
          {
               MessageBeep (MB_ICONEXCLAMATION) ;
               MessageBox (hwnd, TEXT (&quot;Cannot open MIDI output device!&quot;),
                                 szAppName, MB_ICONEXCLAMATION | MB_OK) ;
               return -1 ;
          }
               // Send Program Change messages for &quot;Church Organ&quot;
          
          MidiOutMessage (hMidiOut, 0xC0,  0, 19, 0) ;
          MidiOutMessage (hMidiOut, 0xC0, 12, 19, 0) ;

          SetTimer (hwnd, ID_TIMER, 1000, NULL) ;
          return 0 ;
          
     case WM_TIMER:
              // Loop for 2-note polyphony
          
          for (i = 0 ; i &lt; 2 ; i++)
          {
                    // Note Off messages for previous note
               
               if (iIndex != 0 &amp;&amp; noteseq[iIndex - 1].iNote[i] != -1)
               {
                    MidiOutMessage (hMidiOut, 0x80,  0,
                                    noteseq[iIndex - 1].iNote[i], 0) ;
                    
                    MidiOutMessage (hMidiOut, 0x80, 12,
                                    noteseq[iIndex - 1].iNote[i], 0) ;
               }
                    // Note On messages for new note
               
               if (iIndex != sizeof (noteseq) / sizeof (noteseq[0]) &amp;&amp;
                    noteseq[iIndex].iNote[i] != -1)
               {
                    MidiOutMessage (hMidiOut, 0x90,  0,
                                    noteseq[iIndex].iNote[i], 127) ;
                    
                    MidiOutMessage (hMidiOut, 0x90, 12,
                                    noteseq[iIndex].iNote[i], 127) ;
               }
          }
          
          if (iIndex != sizeof (noteseq) / sizeof (noteseq[0]))
          {
               SetTimer (hwnd, ID_TIMER, noteseq[iIndex++].iDur - 1, NULL) ;
          }
          else
          {
               KillTimer (hwnd, ID_TIMER) ;
               DestroyWindow (hwnd) ;
          }
          return 0 ;
          
     case WM_DESTROY:
          midiOutReset (hMidiOut) ;
          midiOutClose (hMidiOut) ;
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

<P>The first measure of the Bach D Minor Toccata is shown in Figure 22-11.

<P><A HREF="javascript:fullSize('F22zg11x.htm')"><IMG SRC="F22zg11.JPG" width=404 height=246 ALIGN="BOTTOM" border=0 ALT="Click to view at full size."></a>

<P><!-- caption --><B>Figure 22-11.</b> <i>The first<SUP>t</SUP> measure of Bach's Toccata and Fugue in D Minor.</I><!-- /caption -->

<P>Our job here is to translate this music into a series of numbers&#8212;basically key numbers and timing information that indicate when to send Note On messages (equivalent to an organ key being depressed) and Note Off messages (a key release). Because an organ keyboard is not velocity-sensitive, we can play all the notes using the same velocities. Another simplification is to ignore the difference between staccato playing (that is, leaving a slight pause between successive notes for a sharper, crisper effect) and legato playing (a smoother overlapping blend between successive notes). We'll assume that the ending of one note is followed immediately by the beginning of the next note.

<P>If you can read music, you'll note that the opening of the toccata consists of parallel octaves. So I created a data structure in BACHTOCC called <I>noteseq</I> to store a series of note durations and two key numbers. Unfortunately, continuing the music into the second measure would require a more generalized approach to storing this information. I decided that a quarter note should have a duration of 1760 milliseconds, which means that an eighth note (which has one stem on the note or rest) has a duration of 880 milliseconds, a 16th note (two stems) of 440, a 32nd note (three stems) of 220, and a 64th note (four stems) of 110.

<P>There are two mordents in this first measure&#8212;one over the first note and the other halfway through the measure. These are indicated by squiggly lines with a short vertical line. In baroque music, the mordent sign means that the note should actually be played as three notes&#8212;the indicated note, a note a full tone below it, and then the indicated note. The first two notes should be played quickly, and the third held for the remaining duration. For example, the first note is an A with a mordent. This is played as A, G, A. I decided to make the first two notes of the mordent 64th notes; thus, each has a duration of 110 milliseconds.

<P>There are also four fermatas in this first measure. These are indicated by semicircles with dots in the middle. The fermata sign means that the note should be held longer than its notated duration, generally at the player's discretion. For the fermatas, I decided to increase the note durations by 50 percent.

<P>As you can see, translating even a piece of music seemingly as simple and straightforward as the opening of the D Minor Toccata is not always so simple and straightforward!

<P>The <I>noteseq</I> structure array contains three numbers for every parallel note and rest in the measure. The duration of the note is followed by two MIDI key numbers for the parallel octaves. For example, the first note is an A with a duration of 110 milliseconds. Because middle C has a MIDI key number of 60, the A above middle C has a key number of 69 and the A an octave higher has a key number of 81. Thus, the first three values in the noteseq array are 110, 69, and 81. I've used note values of &#8211;1 to indicate a rest.

<P>During the WM_CREATE message, BACHTOCC sets a Windows timer for 1000 milliseconds&#8212;meaning that the music will begin in 1 second&#8212;and then calls <I>midiOutOpen</I> using the MIDIMAPPER device ID.

<P>BACHTOCC requires only one instrument voice (an organ), so it needs to use only one channel. To simplify the sending of MIDI messages, I've defined a short function in BACHTOCC called <I>MidiOutMessage</I>. This function accepts a MIDI output handle, a status byte, a channel number, and two bytes of data. It assembles these numbers into a packed 32-bit message and calls <I>midiOutShortMsg</I>.

<P>At the end of WM_CREATE processing, BACHTOCC sends a Program Change message to select the &quot;church organ&quot; voice. In the General MIDI voice assignments, the church organ voice is indicated by a data byte of 19 in the Program Change message. The actual playing of notes occurs during the WM_TIMER message. A loop handles the two-note polyphony. If a previous note is still playing, BACHTOCC sends Note Off messages for that note. Then, if the new note is not a rest, it sends Note On messages to channels 0 and 12. It then resets the Windows timer to the duration of the note indicated in the <I>noteseq</I> structure.

<P>After the music concludes, BACHTOCC destroys the window. During the WM_DESTROY message, the program calls <I>midiOutReset</I> and <I>midiOutClose</I> and then terminates the program.

<P>Although BACHTOCC works and the results sound reasonable (if not exactly like a human being playing an organ), using the Windows timer for playing music in this way simply does not work in the general case. The problem is that the Windows timer is based on the PC's system clock and the resolution is not good enough for music. Moreover, the Windows timer is not asynchronous. There can be slight delays getting WM_TIMER messages if another program is busy doing something. WM_TIMER messages could even be discarded if the program cannot handle them immediately. This would start sounding like a real mess.

<P>So, while BACHTOCC shows how to call the low-level MIDI output functions, the use of the Windows timer is clearly inadequate for accurate music reproduction. This is why Windows also includes a supplementary set of timer functions that you can take advantage of when using the low-level MIDI output functions. These functions begin with the prefix <I>time</I>, and you can use them to set a timer with a resolution as low as 1 millisecond. I'll show you how to use these functions in the DRUM program at the end of this chapter.

<A NAME="787"><h2>Playing a MIDI Synthesizer from the PC Keyboard</h2></A>
<P>Since most PC users probably don't have a MIDI keyboard they can attach to their machines, it makes sense to substitute the keyboard everyone <I>does</I> have (the one with all the letters and numbers on the keys) for a musical one. Figure 22-12 shows a program called KBMIDI that lets you use the PC keyboard to play an electronic music synthesizer&#8212;either the one on your sound board or an external synthesizer hooked up to the MIDI Out port. KBMIDI gives you complete control over the MIDI output device (that is, the internal or external synthesizer), the MIDI channel, and the instrument voice. Besides being fun to use, I've found the program useful for exploring how Windows implements MIDI support.

<P><B>Figure 22-12.</b> <i>The KBMIDI Program.</I>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="788"><h3>KBMIDI.C</h3></A>
<P><pre>
/*---------------------------------------
   KBMIDI.C -- Keyboard MIDI Player 
               (c) Charles Petzold, 1998
  ---------------------------------------*/

#include &lt;windows.h&gt;

// Defines for Menu IDs
// --------------------

#define IDM_OPEN    0x100
#define IDM_CLOSE   0x101
#define IDM_DEVICE  0x200
#define IDM_CHANNEL 0x300
#define IDM_VOICE   0x400

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM);

TCHAR    szAppName [] = TEXT (&quot;KBMidi&quot;) ;
HMIDIOUT hMidiOut ;
int      iDevice = MIDIMAPPER, iChannel = 0, iVoice = 0, iVelocity = 64 ;
int      cxCaps, cyChar, xOffset, yOffset ;

     // Structures and data for showing families and instruments on menu
     // ----------------------------------------------------------------

typedef struct
{
     TCHAR * szInst ;
     int    iVoice ;
}
INSTRUMENT ;

typedef struct
{
     TCHAR      * szFam ;
     INSTRUMENT   inst [8] ;
}
FAMILY ;

FAMILY fam [16] = { 
     
     TEXT (&quot;Piano&quot;),

          TEXT (&quot;Acoustic Grand Piano&quot;),        0,
          TEXT (&quot;Bright Acoustic Piano&quot;),       1,
          TEXT (&quot;Electric Grand Piano&quot;),        2,
          TEXT (&quot;Honky-tonk Piano&quot;),            3,
          TEXT (&quot;Rhodes Piano&quot;),                4,
          TEXT (&quot;Chorused Piano&quot;),              5,
          TEXT (&quot;Harpsichord&quot;),                 6,
          TEXT (&quot;Clavinet&quot;),                    7,

     TEXT (&quot;Chromatic Percussion&quot;),

          TEXT (&quot;Celesta&quot;),                     8,
          TEXT (&quot;Glockenspiel&quot;),                9,
          TEXT (&quot;Music Box&quot;),                   10,
          TEXT (&quot;Vibraphone&quot;),                  11,
          TEXT (&quot;Marimba&quot;),                     12,
          TEXT (&quot;Xylophone&quot;),                   13,
          TEXT (&quot;Tubular Bells&quot;),               14,
          TEXT (&quot;Dulcimer&quot;),                    15,

     TEXT (&quot;Organ&quot;),

          TEXT (&quot;Hammond Organ&quot;),               16,
          TEXT (&quot;Percussive Organ&quot;),            17,
          TEXT (&quot;Rock Organ&quot;),                  18,
          TEXT (&quot;Church Organ&quot;),                19,
          TEXT (&quot;Reed Organ&quot;),                  20,
          TEXT (&quot;Accordian&quot;),                   21,
          TEXT (&quot;Harmonica&quot;),                   22,
          TEXT (&quot;Tango Accordian&quot;),             23,

     TEXT (&quot;Guitar&quot;),

          TEXT (&quot;Acoustic Guitar (nylon)&quot;),     24,
          TEXT (&quot;Acoustic Guitar (steel)&quot;),     25,
          TEXT (&quot;Electric Guitar (jazz)&quot;),      26,
          TEXT (&quot;Electric Guitar (clean)&quot;),     27,
          TEXT (&quot;Electric Guitar (muted)&quot;),     28,
          TEXT (&quot;Overdriven Guitar&quot;),           29,
          TEXT (&quot;Distortion Guitar&quot;),           30,
          TEXT (&quot;Guitar Harmonics&quot;),            31,

     TEXT (&quot;Bass&quot;),

          TEXT (&quot;Acoustic Bass&quot;),               32,
          TEXT (&quot;Electric Bass (finger)&quot;),      33,
          TEXT (&quot;Electric Bass (pick)&quot;),        34,
          TEXT (&quot;Fretless Bass&quot;),               35,
          TEXT (&quot;Slap Bass 1&quot;),                 36,
          TEXT (&quot;Slap Bass 2&quot;),                 37,
          TEXT (&quot;Synth Bass 1&quot;),                38,
          TEXT (&quot;Synth Bass 2&quot;),                39,

     TEXT (&quot;Strings&quot;),

          TEXT (&quot;Violin&quot;),                      40,
          TEXT (&quot;Viola&quot;),                       41,
          TEXT (&quot;Cello&quot;),                       42,
          TEXT (&quot;Contrabass&quot;),                  43,
          TEXT (&quot;Tremolo Strings&quot;),             44,
          TEXT (&quot;Pizzicato Strings&quot;),           45,
          TEXT (&quot;Orchestral Harp&quot;),             46,
          TEXT (&quot;Timpani&quot;),                     47,

     TEXT (&quot;Ensemble&quot;),

          TEXT (&quot;String Ensemble 1&quot;),           48,
          TEXT (&quot;String Ensemble 2&quot;),           49,
          TEXT (&quot;Synth Strings 1&quot;),             50,
          TEXT (&quot;Synth Strings 2&quot;),             51,
          TEXT (&quot;Choir Aahs&quot;),                  52,
          TEXT (&quot;Voice Oohs&quot;),                  53,
          TEXT (&quot;Synth Voice&quot;),                 54,
          TEXT (&quot;Orchestra Hit&quot;),               55,

     TEXT (&quot;Brass&quot;),

          TEXT (&quot;Trumpet&quot;),                     56,
          TEXT (&quot;Trombone&quot;),                    57,
          TEXT (&quot;Tuba&quot;),                        58,
          TEXT (&quot;Muted Trumpet&quot;),               59,
          TEXT (&quot;French Horn&quot;),                 60,
          TEXT (&quot;Brass Section&quot;),               61,
          TEXT (&quot;Synth Brass 1&quot;),               62,
          TEXT (&quot;Synth Brass 2&quot;),               63,

     TEXT (&quot;Reed&quot;),

          TEXT (&quot;Soprano Sax&quot;),                 64,
          TEXT (&quot;Alto Sax&quot;),                    65,
          TEXT (&quot;Tenor Sax&quot;),                   66,
          TEXT (&quot;Baritone Sax&quot;),                67,
          TEXT (&quot;Oboe&quot;),                        68,
          TEXT (&quot;English Horn&quot;),                69,
          TEXT (&quot;Bassoon&quot;),                     70,
          TEXT (&quot;Clarinet&quot;),                    71,

     TEXT (&quot;Pipe&quot;),

          TEXT (&quot;Piccolo&quot;),                     72,
          TEXT (&quot;Flute &quot;),                      73,
          TEXT (&quot;Recorder&quot;),                    74,
          TEXT (&quot;Pan Flute&quot;),                   75,
          TEXT (&quot;Bottle Blow&quot;),                 76,
          TEXT (&quot;Shakuhachi&quot;),                  77,
          TEXT (&quot;Whistle&quot;),                     78,
          TEXT (&quot;Ocarina&quot;),                     79,

     TEXT (&quot;Synth Lead&quot;),

          TEXT (&quot;Lead 1 (square)&quot;),             80,
          TEXT (&quot;Lead 2 (sawtooth)&quot;),           81,
          TEXT (&quot;Lead 3 (caliope lead)&quot;),       82,
          TEXT (&quot;Lead 4 (chiff lead)&quot;),         83,
          TEXT (&quot;Lead 5 (charang)&quot;),            84,
          TEXT (&quot;Lead 6 (voice)&quot;),              85,
          TEXT (&quot;Lead 7 (fifths)&quot;),             86,
          TEXT (&quot;Lead 8 (brass + lead)&quot;),       87,

     TEXT (&quot;Synth Pad&quot;),

          TEXT (&quot;Pad 1 (new age)&quot;),             88,
          TEXT (&quot;Pad 2 (warm)&quot;),                89,
          TEXT (&quot;Pad 3 (polysynth)&quot;),           90,
          TEXT (&quot;Pad 4 (choir)&quot;),               91,
          TEXT (&quot;Pad 5 (bowed)&quot;),               92,
          TEXT (&quot;Pad 6 (metallic)&quot;),            93,
          TEXT (&quot;Pad 7 (halo)&quot;),                94,
          TEXT (&quot;Pad 8 (sweep)&quot;),               95,

     TEXT (&quot;Synth Effects&quot;),

          TEXT (&quot;FX 1 (rain)&quot;),                 96,
          TEXT (&quot;FX 2 (soundtrack)&quot;),           97,
          TEXT (&quot;FX 3 (crystal)&quot;),              98,
          TEXT (&quot;FX 4 (atmosphere)&quot;),           99,
          TEXT (&quot;FX 5 (brightness)&quot;),           100,
          TEXT (&quot;FX 6 (goblins)&quot;),              101,
          TEXT (&quot;FX 7 (echoes)&quot;),               102,
          TEXT (&quot;FX 8 (sci-fi)&quot;),               103,
          TEXT (&quot;Ethnic&quot;),
          TEXT (&quot;Sitar&quot;),                       104,
          TEXT (&quot;Banjo&quot;),                       105,
          TEXT (&quot;Shamisen&quot;),                    106,
          TEXT (&quot;Koto&quot;),                        107,
          TEXT (&quot;Kalimba&quot;),                     108,
          TEXT (&quot;Bagpipe&quot;),                     109,
          TEXT (&quot;Fiddle&quot;),                      110,
          TEXT (&quot;Shanai&quot;),                      111,

     TEXT (&quot;Percussive&quot;),

          TEXT (&quot;Tinkle Bell&quot;),                 112,
          TEXT (&quot;Agogo&quot;),                       113,
          TEXT (&quot;Steel Drums&quot;),                 114,
          TEXT (&quot;Woodblock&quot;),                   115,
          TEXT (&quot;Taiko Drum&quot;),                  116,
          TEXT (&quot;Melodic Tom&quot;),                 117,
          TEXT (&quot;Synth Drum&quot;),                  118,
          TEXT (&quot;Reverse Cymbal&quot;),              119,

     TEXT (&quot;Sound Effects&quot;),

          TEXT (&quot;Guitar Fret Noise&quot;),           120,
          TEXT (&quot;Breath Noise&quot;),                121,
          TEXT (&quot;Seashore&quot;),                    122,
          TEXT (&quot;Bird Tweet&quot;),                  123,
          TEXT (&quot;Telephone Ring&quot;),              124,
          TEXT (&quot;Helicopter&quot;),                  125,
          TEXT (&quot;Applause&quot;),                    126,
          TEXT (&quot;Gunshot&quot;),                     127 } ;

     // Data for translating scan codes to octaves and notes
     // ----------------------------------------------------

#define NUMSCANS    (sizeof key / sizeof key[0])

struct
{
     int     iOctave ;
     int     iNote ;
     int     yPos ;
     int     xPos ;
     TCHAR * szKey ;
}
key [] =
{
                                         // Scan  Char  Oct  Note
                                         // ----  ----  ---  ----
         -1, -1, -1, -1, NULL,           //   0   None
         -1, -1, -1, -1, NULL,           //   1   Esc
         -1, -1,  0,  0, TEXT (&quot;&quot;),      //   2     1
          5,  1,  0,  2, TEXT (&quot;C#&quot;),    //   3     2    5    C#
          5,  3,  0,  4, TEXT (&quot;D#&quot;),    //   4     3    5    D#
         -1, -1,  0,  6, TEXT (&quot;&quot;),      //   5     4
          5,  6,  0,  8, TEXT (&quot;F#&quot;),    //   6     5    5    F#
          5,  8,  0, 10, TEXT (&quot;G#&quot;),    //   7     6    5    G#
          5, 10,  0, 12, TEXT (&quot;A#&quot;),    //   8     7    5    A#
         -1, -1,  0, 14, TEXT (&quot;&quot;),      //   9     8
          6,  1,  0, 16, TEXT (&quot;C#&quot;),    //  10     9    6    C#
          6,  3,  0, 18, TEXT (&quot;D#&quot;),    //  11     0    6    D#
         -1, -1,  0, 20, TEXT (&quot;&quot;),      //  12     -
          6,  6,  0, 22, TEXT (&quot;F#&quot;),    //  13     =    6    F#
         -1, -1, -1, -1, NULL,           //  14    Back
          
         -1, -1, -1, -1, NULL,           //  15    Tab
          5,  0,  1,  1, TEXT (&quot;C&quot;),     //  16     q    5    C
          5,  2,  1,  3, TEXT (&quot;D&quot;),     //  17     w    5    D
          5,  4,  1,  5, TEXT (&quot;E&quot;),     //  18     e    5    E
          5,  5,  1,  7, TEXT (&quot;F&quot;),     //  19     r    5    F
          5,  7,  1,  9, TEXT (&quot;G&quot;),     //  20     t    5    G
          5,  9,  1, 11, TEXT (&quot;A&quot;),     //  21     y    5    A
          5, 11,  1, 13, TEXT (&quot;B&quot;),     //  22     u    5    B
          6,  0,  1, 15, TEXT (&quot;C&quot;),     //  23     i    6    C
          6,  2,  1, 17, TEXT (&quot;D&quot;),     //  24     o    6    D
          6,  4,  1, 19, TEXT (&quot;E&quot;),     //  25     p    6    E
          6,  5,  1, 21, TEXT (&quot;F&quot;),     //  26     [    6    F
          6,  7,  1, 23, TEXT (&quot;G&quot;),     //  27     ]    6    G
         -1, -1, -1, -1, NULL,           //  28    Ent
          
         -1, -1, -1, -1, NULL,           //  29    Ctrl
          3,  8,  2,  2, TEXT (&quot;G#&quot;),    //  30     a    3    G#
          3, 10,  2,  4, TEXT (&quot;A#&quot;),    //  31     s    3    A#
         -1, -1,  2,  6, TEXT (&quot;&quot;),      //  32     d
          4,  1,  2,  8, TEXT (&quot;C#&quot;),    //  33     f    4    C#
          4,  3,  2, 10, TEXT (&quot;D#&quot;),    //  34     g    4    D#
         -1, -1,  2, 12, TEXT (&quot;&quot;),      //  35     h
          4,  6,  2, 14, TEXT (&quot;F#&quot;),    //  36     j    4    F#
          4,  8,  2, 16, TEXT (&quot;G#&quot;),    //  37     k    4    G#
          4, 10,  2, 18, TEXT (&quot;A#&quot;),    //  38     l    4    A#
         -1, -1,  2, 20, TEXT (&quot;&quot;),      //  39     ;
          5,  1,  2, 22, TEXT (&quot;C#&quot;),    //  40     `    5    C#
         -1, -1, -1, -1, NULL,           //  41     `
         -1, -1, -1, -1, NULL,           //  42    Shift
         -1, -1, -1, -1, NULL,           //  43     \  (not line continuation)
          3,  9,  3,  3, TEXT (&quot;A&quot;),     //  44     z    3    A
          3, 11,  3,  5, TEXT (&quot;B&quot;),     //  45     x    3    B
          4,  0,  3,  7, TEXT (&quot;C&quot;),     //  46     c    4    C
          4,  2,  3,  9, TEXT (&quot;D&quot;),     //  47     v    4    D
          4,  4,  3, 11, TEXT (&quot;E&quot;),     //  48     b    4    E
          4,  5,  3, 13, TEXT (&quot;F&quot;),     //  49     n    4    F
          4,  7,  3, 15, TEXT (&quot;G&quot;),     //  50     m    4    G
          4,  9,  3, 17, TEXT (&quot;A&quot;),     //  51     ,    4    A
          4, 11,  3, 19, TEXT (&quot;B&quot;),     //  52     .    4    B
          5,  0,  3, 21, TEXT (&quot;C&quot;)      //  53     /    5    C
} ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     MSG      msg;
     HWND     hwnd ;
     WNDCLASS wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hwnd = CreateWindow (szAppName, TEXT (&quot;Keyboard MIDI Player&quot;),
                          WS_OVERLAPPEDWINDOW | WS_HSCROLL | WS_VSCROLL,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     if (!hwnd)
          return 0 ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd); 
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

// Create the program's menu (called from WndProc, WM_CREATE)
// ----------------------------------------------------------

HMENU CreateTheMenu (int iNumDevs)
{
     TCHAR       szBuffer [32] ;
     HMENU       hMenu, hMenuPopup, hMenuSubPopup ;
     int         i, iFam, iIns ;
     MIDIOUTCAPS moc ;
     
     hMenu = CreateMenu () ;
     
          // Create &quot;On/Off&quot; popup menu
     
     hMenuPopup = CreateMenu () ;
     
     AppendMenu (hMenuPopup, MF_STRING, IDM_OPEN, TEXT (&quot;&amp;Open&quot;)) ; 
     AppendMenu (hMenuPopup, MF_STRING | MF_CHECKED, IDM_CLOSE, 
                             TEXT (&quot;&amp;Closed&quot;)) ;
     
     AppendMenu (hMenu, MF_STRING | MF_POPUP, (UINT) hMenuPopup, 
                        TEXT (&quot;&amp;Status&quot;)) ;
     
          // Create &quot;Device&quot; popup menu
     
     hMenuPopup = CreateMenu () ;
     
          // Put MIDI Mapper on menu if it's installed
     
     if (!midiOutGetDevCaps (MIDIMAPPER, &amp;moc, sizeof (moc)))
          AppendMenu (hMenuPopup, MF_STRING, IDM_DEVICE + (int) MIDIMAPPER,
                         moc.szPname) ;
     else
          iDevice = 0 ;
     
          // Add the rest of the MIDI devices
     for (i = 0 ; i &lt; iNumDevs ; i++)
     {
          midiOutGetDevCaps (i, &amp;moc, sizeof (moc)) ;
          AppendMenu (hMenuPopup, MF_STRING, IDM_DEVICE + i, moc.szPname) ;
     }
     
     CheckMenuItem (hMenuPopup, 0, MF_BYPOSITION | MF_CHECKED) ;
     AppendMenu (hMenu, MF_STRING | MF_POPUP, (UINT) hMenuPopup, 
                        TEXT (&quot;&amp;Device&quot;)) ;
     
          // Create &quot;Channel&quot; popup menu
     
     hMenuPopup = CreateMenu () ;
     
     for (i = 0 ; i &lt; 16 ; i++)
     {
          wsprintf (szBuffer, TEXT (&quot;%d&quot;), i + 1) ;
          AppendMenu (hMenuPopup, MF_STRING | (i ? MF_UNCHECKED : MF_CHECKED),
                                  IDM_CHANNEL + i, szBuffer) ;
     }
     
     AppendMenu (hMenu, MF_STRING | MF_POPUP, (UINT) hMenuPopup, 
                        TEXT (&quot;&amp;Channel&quot;)) ;
     
          // Create &quot;Voice&quot; popup menu
     
     hMenuPopup = CreateMenu () ;
     
     for (iFam = 0 ; iFam &lt; 16 ; iFam++)
     {
          hMenuSubPopup = CreateMenu () ;
          
          for (iIns = 0 ; iIns &lt; 8 ; iIns++)
          {
               wsprintf (szBuffer, TEXT (&quot;&amp;%d.\t%s&quot;), iIns + 1,
                                   fam[iFam].inst[iIns].szInst) ;
               AppendMenu (hMenuSubPopup,
                           MF_STRING | (fam[iFam].inst[iIns].iVoice ?
                                             MF_UNCHECKED : MF_CHECKED),
                           fam[iFam].inst[iIns].iVoice + IDM_VOICE,
                           szBuffer) ;
          }
          
          wsprintf (szBuffer, TEXT (&quot;&amp;%c.\t%s&quot;), `A' + iFam,
                              fam[iFam].szFam) ;
          AppendMenu (hMenuPopup, MF_STRING | MF_POPUP, (UINT) hMenuSubPopup,
                                  szBuffer) ;
     }
     AppendMenu (hMenu, MF_STRING | MF_POPUP, (UINT) hMenuPopup, 
                        TEXT (&quot;&amp;Voice&quot;)) ;
     return hMenu ;
}

// Routines for simplifying MIDI output
// ------------------------------------

DWORD MidiOutMessage (HMIDIOUT hMidi, int iStatus, int iChannel,
                      int iData1,  int iData2)
{
     DWORD dwMessage ;
     
     dwMessage = iStatus | iChannel | (iData1 &lt;&lt; 8) | (iData2 &lt;&lt; 16) ;
     
     return midiOutShortMsg (hMidi, dwMessage) ;
}

DWORD MidiNoteOff (HMIDIOUT hMidi, int iChannel, int iOct, int iNote, int iVel)
{
     return MidiOutMessage (hMidi, 0x080, iChannel, 12 * iOct + iNote, iVel) ;
}

DWORD MidiNoteOn (HMIDIOUT hMidi, int iChannel, int iOct, int iNote, int iVel)
{
     return MidiOutMessage (hMidi, 0x090, iChannel, 12 * iOct + iNote, iVel) ;
}

DWORD MidiSetPatch (HMIDIOUT hMidi, int iChannel, int iVoice)
{
     return MidiOutMessage (hMidi, 0x0C0, iChannel, iVoice, 0) ;
}

DWORD MidiPitchBend (HMIDIOUT hMidi, int iChannel, int iBend)
{
     return MidiOutMessage (hMidi, 0x0E0, iChannel, iBend &amp; 0x7F, iBend &gt;&gt; 7) ;
}

// Draw a single key on window
// ---------------------------

VOID DrawKey (HDC hdc, int iScanCode, BOOL fInvert)
{
     RECT rc ;
     rc.left   = 3 * cxCaps * key[iScanCode].xPos / 2 + xOffset ;
     rc.top    = 3 * cyChar * key[iScanCode].yPos / 2 + yOffset ;
     rc.right  = rc.left + 3 * cxCaps ;
     rc.bottom = rc.top  + 3 * cyChar / 2 ;
     
     SetTextColor (hdc, fInvert ? 0x00FFFFFFul : 0x00000000ul) ;
     SetBkColor   (hdc, fInvert ? 0x00000000ul : 0x00FFFFFFul) ;
     
     FillRect (hdc, &amp;rc, GetStockObject (fInvert ? BLACK_BRUSH : WHITE_BRUSH)) ;
     
     DrawText (hdc, key[iScanCode].szKey, -1, &amp;rc,
                    DT_SINGLELINE | DT_CENTER | DT_VCENTER) ;
     
     FrameRect (hdc, &amp;rc, GetStockObject (BLACK_BRUSH)) ;
}

// Process a Key Up or Key Down message
// ------------------------------------

VOID ProcessKey (HDC hdc, UINT message, LPARAM lParam)
{
     int iScanCode, iOctave, iNote ;
     
     iScanCode = 0x0FF &amp; HIWORD (lParam) ;
     
     if (iScanCode &gt;= NUMSCANS)                       // No scan codes over 53
          return ;
     
     if ((iOctave = key[iScanCode].iOctave) == -1)    // Non-music key
          return ;
     
     if (GetKeyState (VK_SHIFT) &lt; 0)
          iOctave += 0x20000000 &amp; lParam ? 2 : 1 ;
     
     if (GetKeyState (VK_CONTROL) &lt; 0)
          iOctave -= 0x20000000 &amp; lParam ? 2 : 1 ;
     
     iNote = key[iScanCode].iNote ;
     
     if (message == WM_KEYUP)                           // For key up
     {
          MidiNoteOff (hMidiOut, iChannel, iOctave, iNote, 0) ;   // Note off
          DrawKey (hdc, iScanCode, FALSE) ;
          return ;
     }
     
     if (0x40000000 &amp; lParam)                          // ignore typematics
          return ;
     
     MidiNoteOn (hMidiOut, iChannel, iOctave, iNote, iVelocity) ; // Note on
     DrawKey (hdc, iScanCode, TRUE) ;                 // Draw the inverted key
}

// Window Procedure
// ----------------

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static BOOL bOpened = FALSE ;
     HDC         hdc ;
     HMENU       hMenu ;
     int         i, iNumDevs, iPitchBend, cxClient, cyClient ;
     MIDIOUTCAPS moc ;
     PAINTSTRUCT ps ;
     SIZE        size ;
     TCHAR       szBuffer [16] ;
     
     switch (message)
     {
     case WM_CREATE:
               // Get size of capital letters in system font
          
          hdc = GetDC (hwnd) ;
          
          GetTextExtentPoint (hdc, TEXT (&quot;M&quot;), 1, &amp;size) ;
          cxCaps = size.cx ;
          cyChar = size.cy ;
          
          ReleaseDC (hwnd, hdc) ;
          
               // Initialize &quot;Volume&quot; scroll bar
          
          SetScrollRange (hwnd, SB_HORZ, 1, 127, FALSE) ;
          SetScrollPos   (hwnd, SB_HORZ, iVelocity, TRUE) ;
          
               // Initialize &quot;Pitch Bend&quot; scroll bar
          
          SetScrollRange (hwnd, SB_VERT, 0, 16383, FALSE) ;
          SetScrollPos   (hwnd, SB_VERT, 8192, TRUE) ;
          
               // Get number of MIDI output devices and set up menu
          
          if (0 == (iNumDevs = midiOutGetNumDevs ()))
          {
               MessageBeep (MB_ICONSTOP) ;
               MessageBox (hwnd, TEXT (&quot;No MIDI output devices!&quot;),
                                 szAppName, MB_OK | MB_ICONSTOP) ;
               return -1 ;
          }
          SetMenu (hwnd, CreateTheMenu (iNumDevs)) ;
          return 0 ;
          
     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          
          xOffset = (cxClient - 25 * 3 * cxCaps / 2) / 2 ;
          yOffset = (cyClient - 11 * cyChar) / 2 + 5 * cyChar ;
          return 0 ;
          
     case WM_COMMAND:
          hMenu = GetMenu (hwnd) ;
          
              // &quot;Open&quot; menu command
          
          if (LOWORD (wParam) == IDM_OPEN &amp;&amp; !bOpened)
          {
               if (midiOutOpen (&amp;hMidiOut, iDevice, 0, 0, 0))
               {
                    MessageBeep (MB_ICONEXCLAMATION) ;
                    MessageBox (hwnd, TEXT (&quot;Cannot open MIDI device&quot;),
                                szAppName, MB_OK | MB_ICONEXCLAMATION) ;
               }
               else
               {
                    CheckMenuItem (hMenu, IDM_OPEN,  MF_CHECKED) ;
                    CheckMenuItem (hMenu, IDM_CLOSE, MF_UNCHECKED) ;
                    
                    MidiSetPatch (hMidiOut, iChannel, iVoice) ;
                    bOpened = TRUE ;
               }
          }
          
               // &quot;Close&quot; menu command
          
          else if (LOWORD (wParam) == IDM_CLOSE &amp;&amp; bOpened)
          {
               CheckMenuItem (hMenu, IDM_OPEN,  MF_UNCHECKED) ;
               CheckMenuItem (hMenu, IDM_CLOSE, MF_CHECKED) ;
               
                    // Turn all keys off and close device
               
               for (i = 0 ; i &lt; 16 ; i++)
                    MidiOutMessage (hMidiOut, 0xB0, i, 123, 0) ;
               
               midiOutClose (hMidiOut) ;
               bOpened = FALSE ;
          }
          
               // Change MIDI &quot;Device&quot; menu command
          
          else if (LOWORD (wParam) &gt;= IDM_DEVICE - 1 &amp;&amp; 
                   LOWORD (wParam) &lt;  IDM_CHANNEL)
          {
               CheckMenuItem (hMenu, IDM_DEVICE + iDevice, MF_UNCHECKED) ;
               iDevice = LOWORD (wParam) - IDM_DEVICE ;
               CheckMenuItem (hMenu, IDM_DEVICE + iDevice, MF_CHECKED) ;
               
                    // Close and reopen MIDI device
               
               if (bOpened)
               {
                    SendMessage (hwnd, WM_COMMAND, IDM_CLOSE, 0L) ;
                    SendMessage (hwnd, WM_COMMAND, IDM_OPEN,  0L) ;
               }
          }
          
               // Change MIDI &quot;Channel&quot; menu command
          
          else if (LOWORD (wParam) &gt;= IDM_CHANNEL &amp;&amp; 
                   LOWORD (wParam) &lt;  IDM_VOICE)
          {
               CheckMenuItem (hMenu, IDM_CHANNEL + iChannel, MF_UNCHECKED);
               iChannel = LOWORD (wParam) - IDM_CHANNEL ;
               CheckMenuItem (hMenu, IDM_CHANNEL + iChannel, MF_CHECKED) ;
               
               if (bOpened)
                    MidiSetPatch (hMidiOut, iChannel, iVoice) ;
          }
          
               // Change MIDI &quot;Voice&quot; menu command
          
          else if (LOWORD (wParam) &gt;= IDM_VOICE)
          {
               CheckMenuItem (hMenu, IDM_VOICE + iVoice, MF_UNCHECKED) ;
               iVoice = LOWORD (wParam) - IDM_VOICE ;
               CheckMenuItem (hMenu, IDM_VOICE + iVoice, MF_CHECKED) ;
               
               if (bOpened)
                    MidiSetPatch (hMidiOut, iChannel, iVoice) ;
          }
          
          InvalidateRect (hwnd, NULL, TRUE) ;
          return 0 ;
          
          // Process a Key Up or Key Down message
          
     case WM_KEYUP:
     case WM_KEYDOWN:
          hdc = GetDC (hwnd) ;
          
          if (bOpened)
               ProcessKey (hdc, message, lParam) ;
          
          ReleaseDC (hwnd, hdc) ;
          return 0 ;
          
          // For Escape, turn off all notes and repaint
          
     case WM_CHAR:
          if (bOpened &amp;&amp; wParam == 27)
          {
               for (i = 0 ; i &lt; 16 ; i++)
                    MidiOutMessage (hMidiOut, 0xB0, i, 123, 0) ;
               
               InvalidateRect (hwnd, NULL, TRUE) ;
          }
          return 0 ;
          
          // Horizontal scroll: Velocity
          
     case WM_HSCROLL:
          switch (LOWORD (wParam))
          {
          case SB_LINEUP:         iVelocity -= 1 ;  break ;
          case SB_LINEDOWN:       iVelocity += 1 ;  break ;
          case SB_PAGEUP:         iVelocity -= 8 ;  break ;
          case SB_PAGEDOWN:       iVelocity += 8 ;  break ;
          case SB_THUMBPOSITION:  iVelocity = HIWORD (wParam) ;  break ;
          default:                return 0 ;
          }
          iVelocity = max (1, min (iVelocity, 127)) ;
          SetScrollPos (hwnd, SB_HORZ, iVelocity, TRUE) ;
          return 0 ;
          
          // Vertical scroll:  Pitch Bend
     
     case WM_VSCROLL:
          switch (LOWORD (wParam))
          {
          case SB_THUMBTRACK:    iPitchBend = 16383 - HIWORD (wParam) ;  break ;
          case SB_THUMBPOSITION: iPitchBend = 8191 ;                     break ;
          default:               return 0 ;
          }
          iPitchBend = max (0, min (iPitchBend, 16383)) ;
          SetScrollPos (hwnd, SB_VERT, 16383 - iPitchBend, TRUE) ;
          
          if (bOpened)
               MidiPitchBend (hMidiOut, iChannel, iPitchBend) ;
          return 0 ;
     
     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
          
          for (i = 0 ; i &lt; NUMSCANS ; i++)
               if (key[i].xPos != -1)
                    DrawKey (hdc, i, FALSE) ;
               
          midiOutGetDevCaps (iDevice, &amp;moc, sizeof (MIDIOUTCAPS)) ;
          wsprintf (szBuffer, TEXT (&quot;Channel %i&quot;), iChannel + 1) ;
     
          TextOut (hdc, cxCaps, 1 * cyChar, 
                        bOpened ? TEXT (&quot;Open&quot;) : TEXT (&quot;Closed&quot;),
                        bOpened ? 4 : 6) ;
          TextOut (hdc, cxCaps, 2 * cyChar, moc.szPname,
                        lstrlen (moc.szPname)) ;
          TextOut (hdc, cxCaps, 3 * cyChar, szBuffer, lstrlen (szBuffer)) ;
          TextOut (hdc, cxCaps, 4 * cyChar,
                        fam[iVoice / 8].inst[iVoice % 8].szInst,
               lstrlen (fam[iVoice / 8].inst[iVoice % 8].szInst)) ;
     
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
               
     case WM_DESTROY :
          SendMessage (hwnd, WM_COMMAND, IDM_CLOSE, 0L) ;
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</td></tr></table>

<P>When you run KBMIDI, the window shows how the keys of the keyboard correspond to the keys of a traditional piano or organ. The Z key at the lower left corner plays an A at 110 Hz. Moving across the bottom row of the keyboard, you reach middle C at the right, with the sharps and flats on the second-to-bottom row. The top two rows continue the scale, from middle C to G#. Thus, the range is 3 octaves. Pressing the Ctrl key drops the entire range by 1 octave, and pressing the Shift key raises it by 1 octave, giving an effective range of 5 octaves.

<P>If you start trying to play immediately, however, you won't hear anything. You first must select Open from the Status menu. This will open a MIDI output device. If the port is successfully opened, pressing a key will send a MIDI Note On message to the synthesizer. Releasing the key generates a Note Off message. Depending on the rollover characteristics of your keyboard, you might be able to play several notes at once.

<P>Select Close from the Status menu to close the MIDI device. This is handy if you want to run some other MIDI software under Windows without terminating the KBMIDI program.

<P>The Device menu lists the installed MIDI output devices. These are obtained from the <I>midiOutGetDevCaps</I> function. One of these will probably be a MIDI Out port to an external synthesizer that might or might not be present. The list also includes the MIDI Mapper device. This is the MIDI synthesizer selected in the Multimedia applet of the Control Panel.

<P>The Channel menu lets you select a MIDI channel from 1 through 16. By default, channel 1 is selected. All MIDI messages that the KBMIDI program generates are sent on the selected channel.

<P>The final menu on KBMIDI is labeled Voice. This is a double-nested menu from which you can select one of the 128 instrument voices defined by the General MIDI specification and implemented in Windows. The 128 instrument voices are divided into 16 instrument families with 8 instruments each. These 128 instrument voices are called the melodic voices because different MIDI key numbers correspond to different pitches.

<P>General MIDI also defines a wide range of nonmelodic percussion instruments. To play the percussion instruments, use the Channel menu to select channel 10. Also select the first instrument voice (Acoustic Grand Piano) from the Voice menu. After you do this, each key plays a different percussion sound. There are 47 different percussion sounds, from MIDI key number 35 (the B two octaves below middle C) to 81 (the A nearly two octaves above middle C). We'll take advantage of the percussion channel in the DRUM program coming up.

<P>The KBMIDI program has horizontal and vertical scroll bars. Because a PC keyboard is not velocity-sensitive, the horizontal scroll bar controls the note velocity. Generally, this corresponds to the volume of the notes that you play. After setting the horizontal scroll bar, all Note On messages will use that velocity.

<P>The vertical scroll bar generates a MIDI message known as &quot;Pitch Bend.&quot; To use this feature, press down one or more keys and manipulate the vertical scroll bar thumb with the mouse. As you raise the scroll bar thumb, the frequency of the note increases, and as you lower it, the frequency decreases. Releasing the scroll bar returns the pitch to normal.

<P>These two scroll bars can be tricky to use: As you manipulate a scroll bar, keyboard messages do not come through the program's message loop. Therefore, if you press a key and begin manipulating one of the scroll bars with the mouse and then release the key before finishing with the scroll bar, the note will continue to sound. Thus, you shouldn't press or release any keys during the time you're manipulating the scroll bars. A similar rule applies to the menu&#8212;do not try to select anything from the menu while a key is depressed. Also, do not change the octave shift using the Ctrl or Shift keys between the time you press a key and release it.

<P>If one or more notes get &quot;stuck&quot; and continue to sound after being released, press the Esc key. This stops the sounds by sending 16 &quot;All Notes Off&quot; messages to the 16 channels of the MIDI synthesizer.

<P>KBMIDI does not have a resource script and instead creates its own menu from scratch. The device names are obtained from the <I>midiOutGetDevCaps</I> function, and the instrument voice families and names are stored in the program in a large data structure.

<P>KBMIDI has a few short functions for simplifying the MIDI messages. I've discussed these messages previously, except for the Pitch Bend message. This message uses two 7-bit values that comprise a 14-bit pitch-bend level. Values between 0 and 0x1FFF lower the pitch, and values between 0x2001 and 0x3FFF raise the pitch.

<P>When you select Open from the Status menu, KBMIDI calls <I>midiOutOpen</I> for the selected device and, if successful, calls its <I>MidiSetPatch</I> function. When changing a device, KBMIDI must close the previous device, if necessary, and then reopen the new device. KBMIDI must also call <I>MidiSetPatch</I> when you change the MIDI device, the MIDI channel, or the instrument voice.

<P>KBMIDI processes WM_KEYUP and WM_KEYDOWN messages to turn notes on and off. A data structure within KBMIDI maps keyboard scan codes to octaves and notes. For example, the Z key on an American English keyboard has a scan code of 44, and the structure identifies this as octave 3 and note 9&#8212;an A. In the <I>MidiNoteOn</I> function in KBMIDI, these are combined to form a MIDI key number of 45 (12 times 3, plus 9). This same data structure is used for drawing the keys on the window: each key has a particular horizontal and vertical position and a text string shown inside the rectangle.

<P>Horizontal scroll bar processing is straightforward: all that need be done is store the new velocity level and set the new scroll bar position. Vertical scroll bar processing to control pitch bend is a little unusual, however. The only scroll bar commands it processes are SB_THUMBTRACK, which occurs when you manipulate the scroll bar thumb with the mouse, and SB_THUMBPOSITION, activated when you release the thumb. On an SB_THUMBPOSITION command, KBMIDI sets the scroll bar position to its middle level and calls <I>MidiPitchBend</I> with a value of 8192.

<A NAME="789"><h2>A MIDI Drum Machine</h2></A>
<P>Some percussion instruments, such as a xylophone or timpani, are termed &quot;melodic&quot; or &quot;chromatic&quot; because they can play tones in different pitches. A xylophone has wooden blocks corresponding to different pitches, and timpani can be tuned. These two instruments, as well as several other melodic percussion instruments, can be selected from the Voice menu in KBMIDI.

<P>However, many other percussion instruments are nonmelodic. They cannot be tuned and usually contain too much noise to be associated with a particular pitch. In the General MIDI specification, these nonmelodic percussion voices are available through channel 10. Different key numbers correspond to 47 different percussion instruments.

<P>The DRUM program shown in Figure 22-13 is a computer drum machine. This program lets you construct a sequence of up to 32 notes using 47 different percussion sounds. The program plays the sequence repetitively at a selectable tempo and volume.

<P><B>Figure 22-13.</b> <i>The DRUM Program.     </I><P>

<P><table cellpadding=5 width="95%"><tr><td>
<h3>DRUM.C</h3>

<P><pre>
/*-------------------------------------
   DRUM.C -- MIDI Drum Machine
             (c) Charles Petzold, 1998
  -------------------------------------*/

#include &lt;windows.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;math.h&gt;
#include &quot;drumtime.h&quot;
#include &quot;drumfile.h&quot;
#include &quot;resource.h&quot;

LRESULT CALLBACK WndProc   (HWND, UINT, WPARAM, LPARAM) ;
BOOL    CALLBACK AboutProc (HWND, UINT, WPARAM, LPARAM) ;
                            
void  DrawRectangle (HDC, int, int, DWORD *, DWORD *) ;
void  ErrorMessage  (HWND, TCHAR *, TCHAR *) ;
void  DoCaption     (HWND, TCHAR *) ;
int   AskAboutSave  (HWND, TCHAR *) ;

TCHAR * szPerc [NUM_PERC] =
{
     TEXT (&quot;Acoustic Bass Drum&quot;), TEXT (&quot;Bass Drum 1&quot;),     
     TEXT (&quot;Side Stick&quot;),         TEXT (&quot;Acoustic Snare&quot;),     
     TEXT (&quot;Hand Clap&quot;),          TEXT (&quot;Electric Snare&quot;),
     TEXT (&quot;Low Floor Tom&quot;),      TEXT (&quot;Closed High Hat&quot;), 
     TEXT (&quot;High Floor Tom&quot;),     TEXT (&quot;Pedal High Hat&quot;),     
     TEXT (&quot;Low Tom&quot;),            TEXT (&quot;Open High Hat&quot;),
     TEXT (&quot;Low-Mid Tom&quot;),        TEXT (&quot;High-Mid Tom&quot;),    
     TEXT (&quot;Crash Cymbal 1&quot;),     TEXT (&quot;High Tom&quot;),           
     TEXT (&quot;Ride Cymbal 1&quot;),      TEXT (&quot;Chinese Cymbal&quot;),
     TEXT (&quot;Ride Bell&quot;),          TEXT (&quot;Tambourine&quot;),      
     TEXT (&quot;Splash Cymbal&quot;),      TEXT (&quot;Cowbell&quot;),            
     TEXT (&quot;Crash Cymbal 2&quot;),     TEXT (&quot;Vibraslap&quot;),
     TEXT (&quot;Ride Cymbal 2&quot;),      TEXT (&quot;High Bongo&quot;),      
     TEXT (&quot;Low Bongo&quot;),          TEXT (&quot;Mute High Conga&quot;),    
     TEXT (&quot;Open High Conga&quot;),    TEXT (&quot;Low Conga&quot;),
     TEXT (&quot;High Timbale&quot;),       TEXT (&quot;Low Timbale&quot;),     
     TEXT (&quot;High Agogo&quot;),         TEXT (&quot;Low Agogo&quot;),          
     TEXT (&quot;Cabasa&quot;),             TEXT (&quot;Maracas&quot;),
     TEXT (&quot;Short Whistle&quot;),      TEXT (&quot;Long Whistle&quot;),    
     TEXT (&quot;Short Guiro&quot;),        TEXT (&quot;Long Guiro&quot;),         
     TEXT (&quot;Claves&quot;),             TEXT (&quot;High Wood Block&quot;),
     TEXT (&quot;Low Wood Block&quot;),     TEXT (&quot;Mute Cuica&quot;),      
     TEXT (&quot;Open Cuica&quot;),         TEXT (&quot;Mute Triangle&quot;),      
     TEXT (&quot;Open Triangle&quot;)
} ;

TCHAR   szAppName  [] = TEXT (&quot;Drum&quot;) ;
TCHAR   szUntitled [] = TEXT (&quot;(Untitled)&quot;) ;
TCHAR   szBuffer [80 + MAX_PATH] ;
HANDLE  hInst ;
int     cxChar, cyChar ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HWND        hwnd ;
     MSG         msg ;
     WNDCLASS    wndclass ;
     
     hInst = hInstance ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (hInstance, szAppName) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = szAppName ;
     wndclass.lpszClassName = szAppName ;
          
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }

     hwnd = CreateWindow (szAppName, NULL,
                          WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU |
                                   WS_MINIMIZEBOX | WS_HSCROLL | WS_VSCROLL,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, szCmdLine) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static BOOL  bNeedSave ;
     static DRUM  drum ;
     static HMENU hMenu ;
     static int   iTempo = 50, iIndexLast ;
     static TCHAR szFileName  [MAX_PATH], szTitleName [MAX_PATH] ;
     HDC          hdc ;
     int          i, x, y ;
     PAINTSTRUCT  ps ;
     POINT        point ;
     RECT         rect ;
     TCHAR      * szError ;
     
     switch (message)
     {
     case WM_CREATE:
               // Initialize DRUM structure
          
          drum.iMsecPerBeat = 100 ;
          drum.iVelocity    =  64 ;
          drum.iNumBeats    =  32 ;
          
          DrumSetParams (&amp;drum) ;
          
               // Other initialization
          
          cxChar = LOWORD (GetDialogBaseUnits ()) ;
          cyChar = HIWORD (GetDialogBaseUnits ()) ;

          GetWindowRect (hwnd, &amp;rect) ;
          MoveWindow (hwnd, rect.left, rect.top, 
                            77 * cxChar, 29 * cyChar, FALSE) ;
          
          hMenu = GetMenu (hwnd) ;
          
               // Initialize &quot;Volume&quot; scroll bar
          
          SetScrollRange (hwnd, SB_HORZ, 1, 127, FALSE) ;
          SetScrollPos   (hwnd, SB_HORZ, drum.iVelocity, TRUE) ;
          
               // Initialize &quot;Tempo&quot; scroll bar
          
          SetScrollRange (hwnd, SB_VERT, 0, 100, FALSE) ;
          SetScrollPos   (hwnd, SB_VERT, iTempo, TRUE) ;
          
          DoCaption (hwnd, szTitleName) ;
          return 0 ;
          
     case WM_COMMAND:
          switch (LOWORD (wParam))
          {
          case IDM_FILE_NEW:
               if (bNeedSave &amp;&amp; IDCANCEL == AskAboutSave (hwnd, szTitleName))
                    return 0 ;
               
                    // Clear drum pattern
               
               for (i = 0 ; i &lt; NUM_PERC ; i++)
               {
                    drum.dwSeqPerc [i] = 0 ;
                    drum.dwSeqPian [i] = 0 ;
               }
               
               InvalidateRect (hwnd, NULL, FALSE) ;
               DrumSetParams (&amp;drum) ;
               bNeedSave = FALSE ;
               return 0 ;
               
          case IDM_FILE_OPEN:
                    // Save previous file
               
               if (bNeedSave &amp;&amp; IDCANCEL ==
                    AskAboutSave (hwnd, szTitleName))
                    return 0 ;
               
                    // Open the selected file
               
               if (DrumFileOpenDlg (hwnd, szFileName, szTitleName))
               {
                    szError = DrumFileRead (&amp;drum, szFileName) ;
                    
                    if (szError != NULL)
                    {
                         ErrorMessage (hwnd, szError, szTitleName) ;
                         szTitleName [0] = `\0' ;
                    }
                    else
                    {
                              // Set new parameters
                         
                         iTempo = (int) (50 *
                              (log10 (drum.iMsecPerBeat) - 1)) ;
                         
                         SetScrollPos (hwnd, SB_VERT, iTempo, TRUE) ;
                         SetScrollPos (hwnd, SB_HORZ, drum.iVelocity, TRUE) ;
                         
                         DrumSetParams (&amp;drum) ;
                         InvalidateRect (hwnd, NULL, FALSE) ;
                         bNeedSave = FALSE ;
                    }
                    
                    DoCaption (hwnd, szTitleName) ;
               }
               return 0 ;
               
          case IDM_FILE_SAVE:
          case IDM_FILE_SAVE_AS:
                    // Save the selected file
               
               if ((LOWORD (wParam) == IDM_FILE_SAVE &amp;&amp; szTitleName [0]) ||
                         DrumFileSaveDlg (hwnd, szFileName, szTitleName))
               {
                    szError = DrumFileWrite (&amp;drum, szFileName) ;
                    
                    if (szError != NULL)
                    {
                         ErrorMessage (hwnd, szError, szTitleName) ;
                         szTitleName [0] = `\0' ;
                    }
                    else
                         bNeedSave = FALSE ;
                    
                    DoCaption (hwnd, szTitleName) ;
               }
               return 0 ;
               
          case IDM_APP_EXIT:
               SendMessage (hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L) ;
               return 0 ;
               
          case IDM_SEQUENCE_RUNNING:
                    // Begin sequence
               
               if (!DrumBeginSequence (hwnd))
               {
                    ErrorMessage (hwnd,
                         TEXT (&quot;Could not start MIDI sequence -- &quot;)
                         TEXT (&quot;MIDI Mapper device is unavailable!&quot;),
                         szTitleName) ;
               }
               else
               {
                    CheckMenuItem (hMenu, IDM_SEQUENCE_RUNNING,   MF_CHECKED) ;
                    CheckMenuItem (hMenu, IDM_SEQUENCE_STOPPED, MF_UNCHECKED) ;
               }
               return 0 ;
               
          case IDM_SEQUENCE_STOPPED:
                    // Finish at end of sequence
               
               DrumEndSequence (FALSE) ;
               return 0 ;
               
          case IDM_APP_ABOUT:
               DialogBox (hInst, TEXT (&quot;AboutBox&quot;), hwnd, AboutProc) ;
               return 0 ;
          }
          return 0 ;
                    
     case WM_LBUTTONDOWN:
     case WM_RBUTTONDOWN:
          hdc = GetDC (hwnd) ;
          
               // Convert mouse coordinates to grid coordinates
          
          x =     LOWORD (lParam) / cxChar - 40 ;
          y = 2 * HIWORD (lParam) / cyChar -  2 ;
               // Set a new number of beats of sequence
          
          if (x &gt; 0 &amp;&amp; x &lt;= 32 &amp;&amp; y &lt; 0)
          {
               SetTextColor (hdc, RGB (255, 255, 255)) ;
               TextOut (hdc, (40 + drum.iNumBeats) * cxChar, 0, TEXT (&quot;:|&quot;), 2);
               SetTextColor (hdc, RGB (0, 0, 0)) ;
               
               if (drum.iNumBeats % 4 == 0)
                    TextOut (hdc, (40 + drum.iNumBeats) * cxChar, 0,
                             TEXT (&quot;.&quot;), 1) ;
               
               drum.iNumBeats = x ;
               
               TextOut (hdc, (40 + drum.iNumBeats) * cxChar, 0, TEXT (&quot;:|&quot;), 2);
               
               bNeedSave = TRUE ;
          }
          
               // Set or reset a percussion instrument beat
          
          if (x &gt;= 0 &amp;&amp; x &lt; 32 &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; NUM_PERC)
          {
               if (message == WM_LBUTTONDOWN)
                    drum.dwSeqPerc[y] ^= (1 &lt;&lt; x) ;
               else
                    drum.dwSeqPian[y] ^= (1 &lt;&lt; x) ;
               
               DrawRectangle (hdc, x, y, drum.dwSeqPerc, drum.dwSeqPian) ;
               
               bNeedSave = TRUE ;
          }
          
          ReleaseDC (hwnd, hdc) ;
          DrumSetParams (&amp;drum) ;
          return 0 ;
          
     case WM_HSCROLL:
               // Change the note velocity
          
          switch (LOWORD (wParam))
          {
          case SB_LINEUP:         drum.iVelocity -= 1 ;  break ;
          case SB_LINEDOWN:       drum.iVelocity += 1 ;  break ;
          case SB_PAGEUP:         drum.iVelocity -= 8 ;  break ;
          case SB_PAGEDOWN:       drum.iVelocity += 8 ;  break ;
          case SB_THUMBPOSITION:
               drum.iVelocity = HIWORD (wParam) ;
               break ;
               
          default:
               return 0 ;
          }
          
          drum.iVelocity = max (1, min (drum.iVelocity, 127)) ;
          SetScrollPos (hwnd, SB_HORZ, drum.iVelocity, TRUE) ;
          DrumSetParams (&amp;drum) ;
          bNeedSave = TRUE ;
          return 0 ;
     
     case WM_VSCROLL:
               // Change the tempo
          
          switch (LOWORD (wParam))
          {
          case SB_LINEUP:         iTempo -=  1 ;  break ;
          case SB_LINEDOWN:       iTempo +=  1 ;  break ;
          case SB_PAGEUP:         iTempo -= 10 ;  break ;
          case SB_PAGEDOWN:       iTempo += 10 ;  break ;
          case SB_THUMBPOSITION:
               iTempo = HIWORD (wParam) ;
               break ;
               
          default:
               return 0 ;
          }
          
          iTempo = max (0, min (iTempo, 100)) ;
          SetScrollPos (hwnd, SB_VERT, iTempo, TRUE) ;
          
          drum.iMsecPerBeat = (WORD) (10 * pow (100, iTempo / 100.0)) ;
          
          DrumSetParams (&amp;drum) ;
          bNeedSave = TRUE ;
          return 0 ;
     
     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
          
          SetTextAlign (hdc, TA_UPDATECP) ;
          SetBkMode (hdc, TRANSPARENT) ;
          
               // Draw the text strings and horizontal lines
          for (i = 0 ; i &lt; NUM_PERC ; i++)
          {
               MoveToEx (hdc, i &amp; 1 ? 20 * cxChar : cxChar,
                             (2 * i + 3) * cyChar / 4, NULL) ;
               
               TextOut (hdc, 0, 0, szPerc [i], lstrlen (szPerc [i])) ;
               
               GetCurrentPositionEx (hdc, &amp;point) ;
               
               MoveToEx (hdc,  point.x + cxChar, point.y + cyChar / 2, NULL) ;
               LineTo   (hdc,       39 * cxChar, point.y + cyChar / 2) ;
          }
          
          SetTextAlign (hdc, 0) ;
          
               // Draw rectangular grid, repeat mark, and beat marks
          
          for (x = 0 ; x &lt; 32 ; x++)
          {
               for (y = 0 ; y &lt; NUM_PERC ; y++)
                    DrawRectangle (hdc, x, y, drum.dwSeqPerc, drum.dwSeqPian) ;
               
               SetTextColor (hdc, x == drum.iNumBeats - 1 ?
                                   RGB (0, 0, 0) : RGB (255, 255, 255)) ;
               
               TextOut (hdc, (41 + x) * cxChar, 0, TEXT (&quot;:|&quot;), 2) ;
               
               SetTextColor (hdc, RGB (0, 0, 0)) ;
               
               if (x % 4 == 0)
                    TextOut (hdc, (40 + x) * cxChar, 0, TEXT (&quot;.&quot;), 1) ;
          }
          
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_USER_NOTIFY:
               // Draw the &quot;bouncing ball&quot;
          
          hdc = GetDC (hwnd) ;
          
          SelectObject (hdc, GetStockObject (NULL_PEN)) ;
          SelectObject (hdc, GetStockObject (WHITE_BRUSH)) ;
          
          for (i = 0 ; i &lt; 2 ; i++)
          {
               x = iIndexLast ;
               y = NUM_PERC + 1 ;
               
               Ellipse (hdc, (x + 40) * cxChar, (2 * y + 3) * cyChar / 4,
                    (x + 41) * cxChar, (2 * y + 5) * cyChar / 4);
               
               iIndexLast = wParam ;
               SelectObject (hdc, GetStockObject (BLACK_BRUSH)) ;
          }
          
          ReleaseDC (hwnd, hdc) ;
          return 0 ;
          
     case WM_USER_ERROR:
          ErrorMessage (hwnd, TEXT (&quot;Can't set timer event for tempo&quot;),
                        szTitleName) ;
          
                                             // fall through
     case WM_USER_FINISHED:
          DrumEndSequence (TRUE) ;
          CheckMenuItem (hMenu, IDM_SEQUENCE_RUNNING,   MF_UNCHECKED) ;
          CheckMenuItem (hMenu, IDM_SEQUENCE_STOPPED, MF_CHECKED) ;
          return 0 ;
          
     case WM_CLOSE:
          if (!bNeedSave || IDCANCEL != AskAboutSave (hwnd, szTitleName))
               DestroyWindow (hwnd) ;
          
          return 0 ;
          
     case WM_QUERYENDSESSION:
          if (!bNeedSave || IDCANCEL != AskAboutSave (hwnd, szTitleName))
               return 1L ;
          
          return 0 ;
          
     case WM_DESTROY:
          DrumEndSequence (TRUE) ;
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}

BOOL CALLBACK AboutProc (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
     switch (message)
     {
     case WM_INITDIALOG:
          return TRUE ;
          
     case WM_COMMAND:
          switch (LOWORD (wParam))
          {
          case IDOK:
               EndDialog (hDlg, 0) ;
               return TRUE ;
          }
          break ;
     }
     return FALSE ;
}

void DrawRectangle (HDC hdc, int x, int y, DWORD * dwSeqPerc, DWORD * dwSeqPian)
{
     int iBrush ;
     
     if (dwSeqPerc [y] &amp; dwSeqPian [y] &amp; (1L &lt;&lt; x))
          iBrush = BLACK_BRUSH ;
     
     else if (dwSeqPerc [y] &amp; (1L &lt;&lt; x))
          iBrush = DKGRAY_BRUSH ;
     
     else if (dwSeqPian [y] &amp; (1L &lt;&lt; x))
          iBrush = LTGRAY_BRUSH ;
     
     else
          iBrush = WHITE_BRUSH ;
     
     SelectObject (hdc, GetStockObject (iBrush)) ;
     
     Rectangle (hdc, (x + 40) * cxChar    , (2 * y + 4) * cyChar / 4,
                     (x + 41) * cxChar + 1, (2 * y + 6) * cyChar / 4 + 1) ;
}

void ErrorMessage (HWND hwnd, TCHAR * szError, TCHAR * szTitleName)
{
     wsprintf (szBuffer, szError,
          (LPSTR) (szTitleName [0] ? szTitleName : szUntitled)) ;
     
     MessageBeep (MB_ICONEXCLAMATION) ;
     MessageBox (hwnd, szBuffer, szAppName, MB_OK | MB_ICONEXCLAMATION) ;
}

void DoCaption (HWND hwnd, TCHAR * szTitleName)
{
     wsprintf (szBuffer, TEXT (&quot;MIDI Drum Machine - %s&quot;),
               (LPSTR) (szTitleName [0] ? szTitleName : szUntitled)) ;
     
     SetWindowText (hwnd, szBuffer) ;
}

int AskAboutSave (HWND hwnd, TCHAR * szTitleName)
{
     int iReturn ;
     
     wsprintf (szBuffer, TEXT (&quot;Save current changes in %s?&quot;),
               (LPSTR) (szTitleName [0] ? szTitleName : szUntitled)) ;
     
     iReturn = MessageBox (hwnd, szBuffer, szAppName,
                           MB_YESNOCANCEL | MB_ICONQUESTION) ;
     
     if (iReturn == IDYES)
          if (!SendMessage (hwnd, WM_COMMAND, IDM_FILE_SAVE, 0))
               iReturn = IDCANCEL ;
          
     return iReturn ;
}
</pre>
</td></tr></table>
<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="790"><h3>DRUMTIME.H</h3></A>
<P><pre>
/*------------------------------------------------------------
   DRUMTIME.H Header File for Time Functions for DRUM Program
  ------------------------------------------------------------*/

#define NUM_PERC         47
#define WM_USER_NOTIFY   (WM_USER + 1)
#define WM_USER_FINISHED (WM_USER + 2)
#define WM_USER_ERROR    (WM_USER + 3)

#pragma pack(push, 2)

typedef struct
{
     short iMsecPerBeat ;
     short iVelocity ;
     short iNumBeats ;
     DWORD dwSeqPerc [NUM_PERC] ;
     DWORD dwSeqPian [NUM_PERC] ;
}
DRUM, * PDRUM ;

#pragma pack(pop)

void DrumSetParams     (PDRUM) ;
BOOL DrumBeginSequence (HWND)  ;
void DrumEndSequence   (BOOL)  ;
</pre>
</td></tr></table>
<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="791"><h3>DRUMTIME.C</h3></A>
<P><pre>
/*-----------------------------------------
   DRUMFILE.C -- Timer Routines for DRUM
                 (c) Charles Petzold, 1998
  -----------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;drumtime.h&quot;

#define minmax(a,x,b) (min (max (x, a), b))

#define TIMER_RES   5

void CALLBACK DrumTimerFunc (UINT, UINT, DWORD, DWORD, DWORD) ;

BOOL     bSequenceGoing, bEndSequence ;
DRUM     drum ;
HMIDIOUT hMidiOut ;
HWND     hwndNotify ;
int      iIndex ;
UINT     uTimerRes, uTimerID ;

DWORD MidiOutMessage (HMIDIOUT hMidi, int iStatus, int iChannel,
                      int iData1, int iData2)
{
     DWORD dwMessage ;
     
     dwMessage = iStatus | iChannel | (iData1 &lt;&lt; 8) | (iData2 &lt;&lt; 16) ;
     
     return midiOutShortMsg (hMidi, dwMessage) ;
}

void DrumSetParams (PDRUM pdrum)
{
     CopyMemory (&amp;drum, pdrum, sizeof (DRUM)) ;
}

BOOL DrumBeginSequence (HWND hwnd)
{
     TIMECAPS tc ;
     
     hwndNotify = hwnd ;           // Save window handle for notification
     DrumEndSequence (TRUE) ;      // Stop current sequence if running
     
          // Open the MIDI Mapper output port
     
     if (midiOutOpen (&amp;hMidiOut, MIDIMAPPER, 0, 0, 0))
          return FALSE ;
     
          // Send Program Change messages for channels 9 and 0
     
     MidiOutMessage (hMidiOut, 0xC0, 9, 0, 0) ;
     MidiOutMessage (hMidiOut, 0xC0, 0, 0, 0) ;
     
          // Begin sequence by setting a timer event
     
     timeGetDevCaps (&amp;tc, sizeof (TIMECAPS)) ;
     uTimerRes = minmax (tc.wPeriodMin, TIMER_RES, tc.wPeriodMax) ;
     timeBeginPeriod (uTimerRes) ;
     
     uTimerID = timeSetEvent (max ((UINT) uTimerRes, (UINT) drum.iMsecPerBeat),
                              uTimerRes, DrumTimerFunc, 0, TIME_ONESHOT) ;
     
     if (uTimerID == 0)
     {
          timeEndPeriod (uTimerRes) ;
          midiOutClose (hMidiOut) ;
          return FALSE ;
     }
     
     iIndex = -1 ;
     bEndSequence = FALSE ;
     bSequenceGoing = TRUE ;
     
     return TRUE ;
}

void DrumEndSequence (BOOL bRightAway)
{
     if (bRightAway)
     {
          if (bSequenceGoing)
         
 {
                    // stop the timer
               if (uTimerID)
                    timeKillEvent (uTimerID) ;
               timeEndPeriod (uTimerRes) ;

                    // turn off all notes
               MidiOutMessage (hMidiOut, 0xB0, 9, 123, 0) ;
               MidiOutMessage (hMidiOut, 0xB0, 0, 123, 0) ;
               
                    // close the MIDI port
               midiOutClose (hMidiOut) ;
               bSequenceGoing = FALSE ;
          }
     }
     else
          bEndSequence = TRUE ;
}

void CALLBACK DrumTimerFunc (UINT  uID, UINT uMsg, DWORD dwUser,
                             DWORD dw1, DWORD dw2)
{
     static DWORD dwSeqPercLast [NUM_PERC], dwSeqPianLast [NUM_PERC] ;
     int          i ;
     
         // Note Off messages for channels 9 and 0
     
     if (iIndex != -1)
     {
          for (i = 0 ; i &lt; NUM_PERC ; i++)
          {
               if (dwSeqPercLast[i] &amp; 1 &lt;&lt; iIndex)
                    MidiOutMessage (hMidiOut, 0x80, 9, i + 35, 0) ;
               
               if (dwSeqPianLast[i] &amp; 1 &lt;&lt; iIndex) 
                    MidiOutMessage (hMidiOut, 0x80, 0, i + 35, 0) ;
          }
     }
     
          // Increment index and notify window to advance bouncing ball
     
     iIndex = (iIndex + 1) % drum.iNumBeats ;
     PostMessage (hwndNotify, WM_USER_NOTIFY, iIndex, timeGetTime ()) ;
     
          // Check if ending the sequence
     
     if (bEndSequence &amp;&amp; iIndex == 0)
     {
          PostMessage (hwndNotify, WM_USER_FINISHED, 0, 0L) ;
          return ;
     }
     
          // Note On messages for channels 9 and 0
     
     for (i = 0 ; i &lt; NUM_PERC ; i++)
     {
          if (drum.dwSeqPerc[i] &amp; 1 &lt;&lt; iIndex)
               MidiOutMessage (hMidiOut, 0x90, 9, i + 35, drum.iVelocity) ;
          
          if (drum.dwSeqPian[i] &amp; 1 &lt;&lt; iIndex)
               MidiOutMessage (hMidiOut, 0x90, 0, i + 35, drum.iVelocity) ;
          
          dwSeqPercLast[i] = drum.dwSeqPerc[i] ;
          dwSeqPianLast[i] = drum.dwSeqPian[i] ;
     }
          // Set a new timer event
     
     uTimerID = timeSetEvent (max ((int) uTimerRes, drum.iMsecPerBeat),
                              uTimerRes, DrumTimerFunc, 0, TIME_ONESHOT) ;
     
     if (uTimerID == 0)
     {
          PostMessage (hwndNotify, WM_USER_ERROR, 0, 0) ;
     }
}
</pre>
</td></tr></table>
<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="792"><h3>DRUMFILE.H</h3></A>
<P><pre>
/*-------------------------------------------------------
   DRUMFILE.H Header File for File I/O Routines for DRUM
  -------------------------------------------------------*/

BOOL    DrumFileOpenDlg (HWND, TCHAR *, TCHAR *) ;
BOOL    DrumFileSaveDlg (HWND, TCHAR *, TCHAR *) ;

TCHAR * DrumFileWrite   (DRUM *, TCHAR *) ;
TCHAR * DrumFileRead    (DRUM *, TCHAR
 *) ;
 </pre>
 </td></tr></table>
 <P><table cellpadding=5 width="95%"><tr><td>
<A NAME="793"><h3>DRUMFILE.C</h3></A>
<P><pre>
/*------------------------------------------
   DRUMFILE.C -- File I/O Routines for DRUM
                 (c) Charles Petzold, 1998
  -----------------------------------------
-*/
#include &lt;windows.h&gt;
#include &lt;commdlg.h&gt;
#include &quot;drumtime.h&quot;
#include &quot;drumfile.h&quot;

OPENFILENAME ofn = { sizeof (OPENFILENAME) } ;

TCHAR * szFilter[] = { TEXT (&quot;Drum Files (*.DRM)&quot;),  
                       TEXT (&quot;*.drm&quot;), TEXT (&quot;&quot;) } ;

TCHAR szDrumID   [] = TEXT (&quot;DRUM&quot;) ;
TCHAR szListID   [] = TEXT (&quot;LIST&quot;) ;
TCHAR szInfoID   [] = TEXT (&quot;INFO&quot;) ;
TCHAR szSoftID   [] = TEXT (&quot;ISFT&quot;) ;
TCHAR szDateID   [] = TEXT (&quot;ISCD&quot;) ;
TCHAR szFmtID    [] = TEXT (&quot;fmt &quot;) ;
TCHAR szDataID   [] = TEXT (&quot;data&quot;) ;
char  szSoftware [] = &quot;DRUM by Charles Petzold, Programming Windows&quot; ;

TCHAR szErrorNoCreate    [] = TEXT (&quot;File %s could not be opened for writing.&quot;);
TCHAR szErrorCannotWrite [] = TEXT (&quot;File %s could not be written to. &quot;) ;
TCHAR szErrorNotFound    [] = TEXT (&quot;File %s not found or cannot be opened.&quot;) ;
TCHAR szErrorNotDrum     [] = TEXT (&quot;File %s is not a standard DRUM file.&quot;) ;
TCHAR szErrorUnsupported [] = TEXT (&quot;File %s is not a supported DRUM file.&quot;) ;
TCHAR szErrorCannotRead  [] = TEXT (&quot;File %s cannot be read.&quot;) ;

BOOL DrumFileOpenDlg (HWND hwnd, TCHAR * szFileName, TCHAR * szTitleName)
{
     ofn.hwndOwner         = hwnd ;
     ofn.lpstrFilter       = szFilter [0] ;
     ofn.lpstrFile         = szFileName ;
     ofn.nMaxFile          = MAX_PATH ;
     ofn.lpstrFileTitle    = szTitleName ;
     ofn.nMaxFileTitle     = MAX_PATH ;
     ofn.Flags             = OFN_CREATEPROMPT ;
     ofn.lpstrDefExt       = TEXT (&quot;drm&quot;) ;
     
     return GetOpenFileName (&amp;ofn) ;
}

BOOL DrumFileSaveDlg (HWND hwnd, TCHAR * szFileName, TCHAR * szTitleName)
{
     ofn.hwndOwner         = hwnd ;
     ofn.lpstrFilter       = szFilter [0] ;
     ofn.lpstrFile         = szFileName ;
     ofn.nMaxFile          = MAX_PATH ;
     ofn.lpstrFileTitle    = szTitleName ;
     ofn.nMaxFileTitle     = MAX_PATH ;
     ofn.Flags             = OFN_OVERWRITEPROMPT ;
     ofn.lpstrDefExt       = TEXT (&quot;drm&quot;) ;
     
     return GetSaveFileName (&amp;ofn) ;
}

TCHAR * DrumFileWrite (DRUM * pdrum, TCHAR * szFileName)
{
     char        szDateBuf [16] ;
     HMMIO       hmmio ;
     int         iFormat = 2 ;
     MMCKINFO    mmckinfo [3] ;
     SYSTEMTIME  st ;
     WORD        wError = 0 ;
     
     memset (mmckinfo, 0, 3 * sizeof (MMCKINFO)) ;
     
          // Recreate the file for writing
     
     if ((hmmio = mmioOpen (szFileName, NULL,
               MMIO_CREATE | MMIO_WRITE | MMIO_ALLOCBUF)) == NULL)
          return szErrorNoCreate ;
     
          // Create a &quot;RIFF&quot; chunk with a &quot;CPDR&quot; type
     
     mmckinfo[0].fccType = mmioStringToFOURCC (szDrumID, 0) ;
     
     wError |= mmioCreateChunk (hmmio, &amp;mmckinfo[0], MMIO_CREATERIFF) ;
     
          // Create &quot;LIST&quot; sub-chunk with an &quot;INFO&quot; type
     
     mmckinfo[1].fccType = mmioStringToFOURCC (szInfoID, 0) ;
     
     wError |= mmioCreateChunk (hmmio, &amp;mmckinfo[1], MMIO_CREATELIST) ;
     
          // Create &quot;ISFT&quot; sub-sub-chunk
     
     mmckinfo[2].ckid = mmioStringToFOURCC (szSoftID, 0) ;
     
     wError |= mmioCreateChunk (hmmio, &amp;mmckinfo[2], 0) ;
     wError |= (mmioWrite (hmmio, szSoftware, sizeof (szSoftware)) !=
                                              sizeof (szSoftware)) ;
     wError |= mmioAscend (hmmio, &amp;mmckinfo[2], 0) ;
     
          // Create a time string
     GetLocalTime (&amp;st) ;
     
     wsprintfA (szDateBuf, &quot;%04d-%02d-%02d&quot;, st.wYear, st.wMonth, st.wDay) ;
     
          // Create &quot;ISCD&quot; sub-sub-chunk
     
     mmckinfo[2].ckid = mmioStringToFOURCC (szDateID, 0) ;
     
     wError |= mmioCreateChunk (hmmio, &amp;mmckinfo[2], 0) ;
     wError |= (mmioWrite (hmmio, szDateBuf, (strlen (szDateBuf) + 1)) !=
                                       (int) (strlen (szDateBuf) + 1)) ;
     wError |= mmioAscend (hmmio, &amp;mmckinfo[2], 0) ;
     wError |= mmioAscend (hmmio, &amp;mmckinfo[1], 0) ;
     
          // Create &quot;fmt &quot; sub-chunk
     
     mmckinfo[1].ckid = mmioStringToFOURCC (szFmtID, 0) ;
     
     wError |= mmioCreateChunk (hmmio, &amp;mmckinfo[1], 0) ;
     wError |= (mmioWrite (hmmio, (PSTR) &amp;iFormat, sizeof (int)) !=
                                                   sizeof (int)) ;
     wError |= mmioAscend (hmmio, &amp;mmckinfo[1], 0) ;
     
          // Create the &quot;data&quot; sub-chunk
     
     mmckinfo[1].ckid = mmioStringToFOURCC (szDataID, 0) ;
     
     wError |= mmioCreateChunk (hmmio, &amp;mmckinfo[1], 0) ;
     wError |= (mmioWrite (hmmio, (PSTR) pdrum, sizeof (DRUM)) !=
                                                sizeof (DRUM)) ;
     wError |= mmioAscend (hmmio, &amp;mmckinfo[1], 0) ;
     wError |= mmioAscend (hmmio, &amp;mmckinfo[0], 0) ;
     
          // Clean up and return
     
     wError |= mmioClose (hmmio, 0) ;
     
     if (wError)
     {
          mmioOpen (szFileName, NULL, MMIO_DELETE) ;
          return szErrorCannotWrite ;
     }
     return NULL ;
}

TCHAR * DrumFileRead (DRUM * pdrum, TCHAR * szFileName)
{
     DRUM     drum ;
     HMMIO    hmmio ;
     int      i, iFormat ;
     MMCKINFO mmckinfo [3] ;
     
     ZeroMemory (mmckinfo, 2 * sizeof (MMCKINFO)) ;
     
         // Open the file
     
     if ((hmmio = mmioOpen (szFileName, NULL, MMIO_READ)) == NULL)
          return szErrorNotFound ;
     
          // Locate a &quot;RIFF&quot; chunk with a &quot;DRUM&quot; form-type
     
     mmckinfo[0].ckid = mmioStringToFOURCC (szDrumID, 0) ;
     
     if (mmioDescend (hmmio, &amp;mmckinfo[0], NULL, MMIO_FINDRIFF))
     {
          mmioClose (hmmio, 0) ;
          return szErrorNotDrum ;
     }
     
          // Locate, read, and verify the &quot;fmt &quot; sub-chunk
     
     mmckinfo[1].ckid = mmioStringToFOURCC (szFmtID, 0) ;
     
     if (mmioDescend (hmmio, &amp;mmckinfo[1], &amp;mmckinfo[0], MMIO_FINDCHUNK))
     {
          mmioClose (hmmio, 0) ;
          return szErrorNotDrum ;
     }
     
     if (mmckinfo[1].cksize != sizeof (int))
     {
          mmioClose (hmmio, 0) ;
          return szErrorUnsupported ;
     }
     
     if (mmioRead (hmmio, (PSTR) &amp;iFormat, sizeof (int)) != sizeof (int))
     {
          mmioClose (hmmio, 0) ;
          return szErrorCannotRead ;
     }
     
     if (iFormat != 1 &amp;&amp; iFormat != 2)
     {
          mmioClose (hmmio, 0) ;
          return szErrorUnsupported ;
     }
     
          // Go to end of &quot;fmt &quot; sub-chunk
     
     mmioAscend (hmmio, &amp;mmckinfo[1], 0) ;
     
          // Locate, read, and verify the &quot;data&quot; sub-chunk
     
     mmckinfo[1].ckid = mmioStringToFOURCC (szDataID, 0) ;
  
     if (mmioDescend (hmmio, &amp;mmckinfo[1], &amp;mmckinfo[0], MMIO_FINDCHUNK))
     {
          mmioClose (hmmio, 0) ;
          return szErrorNotDrum ;
     }
     
     if (mmckinfo[1].cksize != sizeof (DRUM))
     {
          mmioClose (hmmio, 0) ;
          return szErrorUnsupported ;
     }
     
     if (mmioRead (hmmio, (LPSTR) &amp;drum, sizeof (DRUM)) != sizeof (DRUM))
     {
          mmioClose (hmmio, 0) ;
          return szErrorCannotRead ;
     }
     
          // Close the file 
     
     mmioClose (hmmio, 0) ;

          // Convert format 1 to format 2 and copy the DRUM structure data

     if (iFormat == 1)
     {
          for (i = 0 ; i &lt; NUM_PERC ; i++)
          {
               drum.dwSeqPerc [i] = drum.dwSeqPian [i] ;
               drum.dwSeqPian [i] = 0 ;
          }
     }
     
     memcpy (pdrum, &amp;drum, sizeof (DRUM)) ;
     return NULL ;
}
</pre>
</td></tr></table>
<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="794"><h3>DRUM.RC (excerpts)</h3></A>
<P><pre>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;

/////////////////////////////////////////////////////////////////////////////
// Menu

DRUM MENU DISCARDABLE 
BEGIN
    POPUP &quot;&amp;File&quot;
    BEGIN
        MENUITEM &quot;&amp;New&quot;,                        IDM_FILE_NEW
        MENUITEM &quot;&amp;Open...&quot;,                    IDM_FILE_OPEN
        MENUITEM &quot;&amp;Save&quot;,                       IDM_FILE_SAVE
        MENUITEM &quot;Save &amp;As...&quot;,                 IDM_FILE_SAVE_AS
        MENUITEM SEPARATOR
        MENUITEM &quot;E&amp;xit&quot;,                       IDM_APP_EXIT
    END
    POPUP &quot;&amp;Sequence&quot;
    BEGIN
        MENUITEM &quot;&amp;Running&quot;,                    IDM_SEQUENCE_RUNNING
        MENUITEM &quot;&amp;Stopped&quot;,                    IDM_SEQUENCE_STOPPED
        , CHECKED
    END
    POPUP &quot;&amp;Help&quot;
    BEGIN
        MENUITEM &quot;&amp;About...&quot;,                   IDM_APP_ABOUT
    END
END

/////////////////////////////////////////////////////////////////////////////
// Icon

DRUM                    ICON    DISCARDABLE     &quot;drum.ico&quot;

/////////////////////////////////////////////////////////////////////////////
// Dialog

ABOUTBOX DIALOG DISCARDABLE  20, 20, 160, 164
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION &quot;Dialog&quot;
FONT 8, &quot;MS Sans Serif&quot;
BEGIN
    DEFPUSHBUTTON   &quot;OK&quot;,IDOK,54,143,50,14
    ICON            &quot;DRUM&quot;,IDC_STATIC,8,8,21,20
    CTEXT           &quot;DRUM&quot;,IDC_STATIC,34,12,90,8
    CTEXT           &quot;MIDI Drum Machine&quot;,IDC_STATIC,7,36,144,8
    CONTROL         &quot;&quot;,IDC_STATIC,&quot;Static&quot;,SS_BLACKFRAME,8,88,144,46
    LTEXT           &quot;Left Button:\t\tDrum sounds&quot;,IDC_STATIC,12,92,136,8
    LTEXT           &quot;Right Button:\t\tPiano sounds&quot;,IDC_STATIC,12,102,136,8
    LTEXT           &quot;Horizontal Scroll:\t\tVelocity&quot;,IDC_STATIC,12,112,136,8
    LTEXT           &quot;Vertical Scroll:\t\tTempo&quot;,IDC_STATIC,12,122,136,8
    CTEXT           &quot;Copyright (c) Charles Petzold, 1998&quot;,IDC_STATIC,8,48,
                    144,8
    CTEXT           &quot;&quot;&quot;Programming Windows,&quot;&quot; 5th Edition&quot;,IDC_STATIC,8,60,
                    144,8
END
</pre>
</td></tr></table>
<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="795"><h3>RESOURCE.H (excerpts)</h3></A>
<P><pre>
// Microsoft Developer Studio generated include file.
// Used by Drum.rc

#define IDM_FILE_NEW                    40001
#define IDM_FILE_OPEN                   40002
#define IDM_FILE_SAVE                   40003
#define IDM_FILE_SAVE_AS                40004
#define IDM_APP_EXIT                    40005
#define IDM_SEQUENCE_RUNNING            40006
#define IDM_SEQUENCE_STOPPED            40007
#define IDM_APP_ABOUT                   40008
</pre>
</td></tr></table>

<P>When you first run DRUM, you'll see the 47 different percussion instruments listed by name in the left half on the window in two columns. The grid at the right is a two-dimensional array of percussion sound vs. time. Each instrument is associated with a row in the grid. The 32 columns are 32 beats. If you think of these 32 beats as occuring within a measure of 4/4 time (that is, four quarter notes per measure), then each beat corresponds to a 32nd note.

<P>When you select Running from the Sequence menu, the program will attempt to open the MIDI Mapper device. If it's unsuccessful, you'll get a message box. Otherwise, you'll see a little &quot;bouncing ball&quot; skip across the bottom of the grid as each beat is played.

<P>You can click with the left mouse button mouse anywhere within the grid to play a percussion sound during that beat. The square will turn dark gray. You can also add some piano beats using the right mouse button. The square will turn light gray. If you click with both mouse buttons, either together or independently, the square will turn black and the percussion <I>and</I> piano sounds will be heard. Clicking again with either or both buttons will turn off the sound for that beat.

<P>Across the top of the grid is a dot every 4 beats. Those dots simply make it easy to pinpoint your button clicks without too much counting. At the upper righthand corner of the grid is a colon and bar (:|) that together resemble a repeat sign used in traditional music notation. This indicates the length of the sequence. You can click with the mouse anywhere above the grid to put the repeat sign somewhere else. The sequence plays up to, but not including, the beat under the repeat sign. If you want to create a waltz rhythm, for example, you should set the repeat mark for some multiple of 3 beats.

<P>The horizontal scroll bar controls the velocity byte in the MIDI Note On messages. This generally affects the volume of the sounds, although it can also affect timbre in some synthesizers. The program initially sets the velocity scroll bar thumb in the center position. The vertical scroll bar controls the tempo. This is a logarithmic scale, ranging from 1 second per beat when the thumb is at the bottom to 10 milliseconds per beat at the top. The program initially sets the tempo at 100 milliseconds (1/10th second) per beat, with the scroll bar thumb in the center.

<P>The File menu allows you to save and retrieve files with the extension .DRM, which is a format that I invented. These files are fairly small and use the RIFF file format, which is recommended for all new multimedia data files. The About option from the Help menu displays a dialog box containing a very brief summary of the use of the mouse on the grid and the functions of the two scroll bars.

<P>Finally, the Stopped option from the Sequence menu stops the music and closes the MIDI Mapper device after finishing with the current sequence.

<A NAME="796"><h2>The Multimedia <I>time</I> Functions</h2></A>
<P>You'll notice that DRUM.C makes no calls to any multimedia functions. All the real action occurs in the DRUMTIME module.

<P>Although the normal Windows timer is certainly simple to use, it's a disaster for time-critical applications. As we saw in the BACHTOCC program, playing music is one such time-critical application for which the Windows timer is simply inadequate. To provide the accuracy needed for playing MIDI sequences on the PC, the multimedia API includes a high-resolution timer implemented through the use of seven functions beginning with the prefix <I>time</I>. One of these functions is superfluous, and DRUMTIME demonstrates the use of the other six. The timer functions work with a callback function that runs in a separate thread. This callback function is called by the system according to a timer delay value specified by the program.

<P>When dealing with the multimedia timer, you specify two different times, both in milliseconds. The first is the delay time, and the second is called the resolution. You can think of the resolution as a tolerable error. If you specify a delay of 100 milliseconds with a resolution of 10 milliseconds, the actual timer delay can range anywhere from 90 to 110 milliseconds.

<P>Before you begin using the timer, you should obtain the timer device capabilities:

<P><pre>
timeGetDevCaps (&amp;timecaps, uSize) ;
</pre>

<P>The first argument is a pointer to a structure of type TIMECAPS, and the second argument is the size of this structure. The TIMECAPS structure has only two fields, <I>wPeriodMin</I> and <I>wPeriodMax</I>. These are the minimum and maximum resolution values supported by the timer device driver. If you look at these values after calling <I>timeGetDevCaps</I>, you'll find that <I>wPeriodMin</I> is 1 and <I>wPeriodMax</I> is 65535, so this function may not seem crucial. However, it's a good idea to get these resolution values anyway and use them in the other timer function calls.

<P>The next step is to call

<P><pre>
timeBeginPeriod (uResolution) ;
</pre>

<P>to indicate the lowest timer resolution value that your program requires. This value should be within the range given in the TIMECAPS structure. This call allows the timer device driver to best provide for multiple programs that might be using the timer. Every call to <I>timeBeginPeriod</I> must be paired with a later call to <I>timeEndPeriod</I>, which I'll describe shortly.

<P>Now you're ready to actually set a timer event:

<P><pre>
idTimer = timeSetEvent (uDelay, uResolution, CallBackFunc, dwData, uFlag) ;
</pre>

<P>The <I>idTimer</I> returned from the call will be zero if an error occurs. Following this call, the function <I>CallBackFunc</I> will be called from Windows in <I>uDelay</I> milliseconds with an allowable error specified by <I>uResolution</I>. The <I>uResolution</I> value must be greater than or equal to the resolution value passed to <I>timeBeginPeriod</I>. The <I>dwData</I> parameter is program-defined data later passed to <I>CallBackFunc</I>. The last parameter can be either TIME_ONESHOT to get a single call to <I>CallBackFunc</I> in <I>uDelay</I> number of milliseconds or TIME_PERIODIC to get calls to <I>CallBackFunc</I> every <I>uDelay</I> milliseconds.

<P>To stop a one-shot timer event before <I>CallBackFunc</I> is called, or to halt periodic timer events, call

<P><pre>
timeKillEvent (idTimer) ;
</pre>

<P>You don't need to kill a one-shot timer event after <I>CallBackFunc</I> is called. When you're finished using the timer in your program, call

<P><pre>
timeEndPeriod (wResolution) ;
</pre>

<P>with the same argument passed to <I>timeBeginPeriod</I>.

<P>Two other functions begin with the prefix <I>time</I>. The function

<P><pre>
dwSysTime = timeGetTime () ;
</pre>

<P>returns the system time in milliseconds since Windows first started up. The function

<P><pre>
timeGetSystemTime (&amp;mmtime, uSize) ;
</pre>

<P>requires a pointer to an MMTIME structure as the first argument and the size of this structure as the second. Although the MMTIME structure can be used in other circumstances to get the system time in formats other than milliseconds, in this case it always returns the time in milliseconds. So, <I>timeGetSystemTime</I> is superfluous.

<P>The callback function is limited in the Windows function calls it can make. The callback function can call <I>PostMessage</I>, four timer functions (<I>timeSetEvent</I>, <I>timeKillEvent</I>, <I>timeGetTime</I>, and the superfluous <I>timeGetSystemTime</I>), two MIDI output functions (<I>midiOutShortMsg</I> and <I>midiOutLongMsg</I>), and the debugging function <I>OutputDebugStr</I>.

<P>Obviously, the multimedia timer is designed specifically for playing MIDI sequences and has very limited use for anything else. You can, of course, use <I>PostMessage</I> for informing a window procedure of timer events, and the window procedure can do whatever it likes, but it won't be responding with the accuracy of the timer callback itself.

<P>The callback function has five parameters, but only two of them are used: the timer ID number returned from <I>timeSetEvent</I> and the <I>dwData</I> value originally passed as an argument to <I>timeSetEvent</I>.

<P>The DRUM.C module calls the <I>DrumSetParams</I> function in DRUMTIME.C at various times&#8212;when DRUM's window is created, when the user clicks on the grid or manipulates the scroll bars, when the program loads a .DRM file from disk, or when the grid is cleared. The single argument to <I>DrumSetParams</I> is a pointer to a structure of type DRUM, defined in DRUMTIME.H. This structure stores the beat time in milliseconds, the velocity (which generally corresponds to the volume), the number of beats in the sequence, as well as two sets of forty-seven 32-bit integers for storing the grid settings for the percussion and piano sounds. Each bit in these 32-bit integers corresponds to a beat of the sequence. The DRUM.C module maintains a structure of type DRUM in static memory and passes a pointer to it when calling <I>DrumSetParams</I>. <I>DrumSetParams</I> simply copies the contents of the structure.

<P>To start the sequence going, DRUM calls the <I>DrumBeginSequence</I> function in DRUMTIME. The only argument is a window handle. This is used for notification purposes. <I>DrumBeginSequence</I> opens the MIDI Mapper output device and, if successful, sends Program Change messages to select instrument voice 0 for MIDI channels 0 and 9. (These are zero-based, so 9 actually refers to MIDI channel 10, the percussion channel. The other channel is used for the piano sounds.) <I>DrumBeginSequence</I> continues by calling <I>timeGetDevCaps</I> and then <I>timeBeginPeriod</I>. The desired timer resolution defined in the TIMER_RES constant is 5 milliseconds, but I've defined a macro called <I>minmax</I> to calculate a resolution within the limits returned from <I>timeGetDevCaps</I>.

<P>The next call is <I>timeSetEvent</I>, specifying the beat time, the calculated resolution, the callback function <I>DrumTimerFunc</I>, and the constant TIME_ONESHOT. DRUMTIME uses a one-shot timer rather than a periodic timer so that the tempo can be dynamically changed while a sequence is running. After the <I>timeSetEvent</I> call, the timer device driver will call <I>DrumTimerFunc</I> after the delay time has elapsed.

<P>The <I>DrumTimerFunc</I> callback is the function in DRUMTIME.C where most of the heavy action takes place. The variable <I>iIndex</I> stores the current beat in the sequence. The callback begins by sending MIDI Note Off messages for the sounds currently playing. An initial -1 value of <I>iIndex</I> prevents this first happening when the sequence first begins.

<P>Next, <I>iIndex</I> is incremented and its value is delivered to the window procedure in DRUM with a user-defined message called WM_USER_NOTIFY. The <I>wParam</I> message argument is set to <I>iIndex</I> so that <I>WndProc</I> in DRUM.C can move the &quot;bouncing ball&quot; at the bottom of the grid.

<P><I>DrumTimerFunc</I> finishes up by sending Note On messages to the synthesizer for both channels 0 and 9, saving the grid values so that the sounds can be turned off the next time through, and then setting a new one-shot timer event by calling <I>timeSetEvent</I>.

<P>To stop the sequence, DRUM calls <I>DrumEndSequence</I> with a single argument that can be set to either TRUE or FALSE. If TRUE, <I>DrumEndSequence</I> ends the sequence right away by killing any pending timer event, calling <I>timeEndPeriod</I>, sending &quot;all notes off&quot; messages to the two MIDI channels, and then closing the MIDI output port. DRUM calls <I>DrumEndSequence</I> with a TRUE argument when the user has decided to terminate the program.

<P>However, when the user selects Stop from the Sequence menu in DRUM, the program instead calls <I>DrumEndSequence</I> with a FALSE argument. This allows the sequence to complete the current cycle before ending. <I>DrumEndSequence</I> responds to this call by setting the <I>bEndSequence</I> global variable to NULL. If <I>bEndSequence</I> is TRUE and the beat index has been set to zero, <I>DrumTimerFunc</I> posts a user-defined message called WM_USER_FINISHED to <I>WndProc</I>. <I>WndProc</I> must respond to this message by calling <I>DrumEndSequence</I> with a TRUE argument to properly close down the use of the timer and the MIDI port.

<A NAME="797"><h2>RIFF File I/O</h2></A>
<P>The DRUM program can also save and retrieve files containing the information stored in the DRUM structure. These files are in the Resource Interchange File Format (RIFF) recommended for multimedia file types. You can read and write RIFF files by using standard file I/O functions, of course, but an easier approach is provided by functions beginning with the prefix <I>mmio</I> (for &quot;multimedia input/output&quot;).

<P>As we saw when examining the .WAV format, RIFF is a tagged file format, which means that the data in the file is organized in blocks of various lengths (called &quot;chunks&quot;), each of which is identified by a tag. A tag is simply a 4-byte ASCII string. This makes it easy to compare tag names with 32-bit integers. The tag is followed by the length of the chunk and the data for the chunk. Tagged file formats are versatile because the information in the file is not located at fixed offsets from the beginning of the file but is instead identified by tags. Thus, the file format can be enhanced by adding additional tags. When reading the file, programs can easily find the data they need and skip tags they don't need or don't understand.

<P>A RIFF file in Windows consists solely of chunks, which are blocks of information in the file. A chunk is composed of a chunk type, a chunk size, and chunk data. The chunk type is a 4-character ASCII tag. It must have no embedded blanks but is possibly padded at the end with blanks. The chunk size is a 4-byte (32-bit) value that indicates the size of the chunk data. Chunk data must occupy an even number of bytes and is padded at the end with an extra zero byte if necessary. Thus, every component of a chunk is word-aligned with the beginning of the file. The chunk size does not include the 8 bytes required for the chunk type and the chunk size, and it does not reflect the padding of the data.

<P>For some chunk types, the chunk size can be the same regardless of the particular file. This is the case when the chunk data is a fixed-length structure containing information. In other cases, the chunk size is variable depending on the particular file.

<P>There are two special types of chunks, called RIFF chunks and LIST chunks. In a RIFF chunk, the chunk data begins with a 4-character ASCII form type, which is then followed by one or more sub-chunks. The LIST chunk is similar except that the data begins with a 4-character ASCII list type. A RIFF chunk is used for the overall RIFF file, and the LIST chunk is used within the file to consolidate related sub-chunks.

<P>A RIFF file is a RIFF chunk. Thus, a RIFF file begins with the character string &quot;RIFF&quot; and a 32-bit value that indicates the size of the file less 8 bytes. (Actually, the file might be one byte longer if data padding is required.)

<P>The multimedia API includes 16 functions beginning with the prefix <I>mmio</I>, specifically designed for working with RIFF files. Several of these functions are used in DRUMFILE.C to read and write DRUM data files.

<P>To open a file using the <I>mmio</I> functions, the first step is to call <I>mmioOpen</I>. The function returns a handle to the file. The <I>mmioCreateChunk</I> function creates a chunk in the file. This uses an MMCKINFO to define the name and characteristics of the chunk. The <I>mmioWrite</I> function writes the chunk data. After writing the chunk data, you call <I>mmioAscend</I>. The MMCKINFO structure passed to <I>mmioAscend</I> must be the same MMCKINFO structure passed earlier to <I>mmioCreateChunk</I> to create the chunk. The <I>mmioAscend</I> function works by subtracting the <I>dwDataOffset</I> field of the structure from the current file pointer, which will now be at the end of the chunk data, and storing that value before the data. The <I>mmioAscend</I> function also takes care of data padding if the chunk data is not a multiple of two bytes in length.

<P>RIFF files are composed of nested levels of chunks. To make <I>mmioAscend</I> work correctly, you must maintain multiple MMCKINFO structures, each of which is associated with a level in the file. The DRUM data files have three levels. Hence, in the <I>DrumFileWrite</I> function in DRUMFILE.C, I've defined an array of three MMCKINFO structures, which can be referenced as <I>mmckinfo[0]</I>, <I>mmckinfo[1]</I>, and <I>mmckinfo[2]</I>. The <I>mmckinfo[0]</I> structure is used in the first <I>mmioCreateChunk</I> call to create a chunk type of RIFF with a form type of DRUM. This is followed by a second <I>mmioCreateChunk</I> call using <I>mmckinfo[1]</I> to create a chunk type of LIST with a list type of INFO.

<P>A third <I>mmioCreateChunk</I> call using <I>mmckinfo[2]</I> creates a chunk type of ISFT, which identifies the software that created the data file. Following the <I>mmioWrite</I> call to write the string <I>szSoftware</I>, a call to <I>mmioAscent</I> using <I>mmckinfo[2]</I> fills in the chunk size field for this chunk. This is the first completed chunk. The next chunk is also within the LIST chunk. The program proceeds with another <I>mmioCreateChunk</I> call to create a ISCD (&quot;creation data&quot;) chunk, again using <I>mmckinfo[2]</I>. After the <I>mmioWrite</I> call to write the chunk data, a call to <I>mmioAscend</I> using <I>mmckinfo[2]</I> fills in the chunk size. That's the end of this chunk, and it's also the end of the LIST chunk. So, to fill in the chunk size field of the LIST chunk, <I>mmioAscend</I> is called again, this time using <I>mmckinfo[1]</I>, which was originally used to create the LIST chunk.

<P>To create the &quot;fmt &quot; and &quot;data&quot; chunks, <I>mmioCreateChunk</I> uses <I>mmckinfo[1]</I>; the <I>mmioWrite</I> calls are followed by <I>mmioAscend</I>, also using <I>mmckinfo[1]</I>. At this point, all the chunk sizes have been filled in except for the RIFF chunk itself. That requires one more call to <I>mmioAscend</I> using <I>mmckinfo[0]</I>. There's only one more call, and that's to <I>mmioClose</I>.

<P>It may seem as if an <I>mmioAscend</I> call changes the current file pointer, and it certainly might to fill in the chunk size, but by the time the function returns, the file pointer is restored to its position after the end of the chunk data (or perhaps incremented by one byte for data padding). From the application's perspective, all writing to the file is sequential from beginning to end.

<P>After a successful <I>mmioOpen</I> call, nothing can really go wrong except for the running out of disk space. I use the variable <I>wError</I> to accumulate error codes from the <I>mmioCreateChunk</I>, <I>mmioWrite</I>, <I>mmioAscend</I>, and <I>mmioClose</I> calls, each of which could fail if insufficient disk space is available. If that happens, the file is deleted using <I>mmioOpen</I> with the MMIO_DELETE constant and an error message is returned to the caller.

<P>Reading a RIFF file is similar to creating one, except that <I>mmioRead</I> is called instead of <I>mmioWrite</I>, and <I>mmioDescend</I> is called rather than <I>mmioCreateChunk</I>. To &quot;descend&quot; into a chunk means to locate a chunk and put the file pointer after the chunk size (or after the form type or list type for a RIFF or LIST chunk type). To &quot;ascend&quot; from a chunk means to move the file pointer to the end of the chunk data. Neither the <I>mmioDescend</I> nor <I>mmioAscend</I> functions move the file pointer to an earlier position in the file.

<P>An earlier version of the DRUM program was published in <I>PC Magazine</I> in 1992. At that time, Windows supported two different levels of MIDI synthesizers (called &quot;base&quot; and &quot;extended&quot;). Files written from that program have a format identifier of 1. The DRUM program in this chapter sets the format identifier to 2. It can read the earlier format, however, and convert them. This is done in the <I>DrumFileRead</I> routine.

</BODY>
</HTML>






