<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Scroll Bars</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="82"><H1>Scroll Bars</H1></A>
<p>Scroll bars are one of the best features of a graphical user interface. They are easy to use and provide excellent visual feedback. You can use scroll bars whenever you need to display anything&#8212;text, graphics, a spreadsheet, database records, pictures, Web pages&#8212;that requires more space than is available in the window's client area.

<p>Scroll bars are positioned either vertically (for up and down movement) or horizontally (for left and right movement). You can click with the mouse the arrows at each end of a scroll bar or the area between the arrows. A &quot;scroll box&quot; (or &quot;thumb&quot;) travels the length of the scroll bar to indicate the approximate location of the material shown on the display in relation to the entire document. You can also drag the thumb with the mouse to move to a particular location. Figure 4-7 shows the recommended use of a vertical scroll bar for text.

<p><A HREF="javascript:fullSize('F04zg07x.htm')"> <img src="F04zg07.JPG" width=404 height=271 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 4-7.</B> <I>The vertical scroll bar.</I><!-- /caption -->

<p>Programmers sometimes have problems with scrolling terminology because their perspective is different from the user's. A user who scrolls down wants to bring a lower part of the document into view; however, the program actually moves the document up in relation to the display window. The Window documentation and the header file identifiers are based on the user's perspective: scroll up means moving toward the beginning of the document; scroll down means moving toward the end.

<p>It is easy to include a horizontal or vertical scroll bar in your application window. All you need do is include the window style (WS) identifier WS_VSCROLL (vertical scroll) or WS_HSCROLL (horizontal scroll) or both in the third argument to <I>CreateWindow</I>. The scroll bars specified in the <I>CreateWindow</I> function are always placed against the right side or bottom of the window and extend the full length or width of the client area. The client area does not include the space occupied by the scroll bar. The width of the vertical scroll bar and the height of the horizontal scroll bar are constant for a particular video driver and display resolution. If you need these values, you can obtain them (as you may have observed) from the <I>GetSystemMetrics</I> calls.

<p>Windows takes care of processing all mouse messages to the scroll bars. However, scroll bars do not have an automatic keyboard interface. If you want the cursor keys to duplicate some of the functionality of the scroll bars, you must explicitly provide logic for that (as we'll do when we make another version of the SYSMETS program in the next chapter).

<A NAME="83"><h2>Scroll Bar Range and Position</h2></A>
<p>Every scroll bar has an associated &quot;range&quot; and &quot;position.&quot; The scroll bar range is a pair of integers representing a minimum and maximum value associated with the scroll bar. The position is the location of the thumb within the range. When the thumb is at the top (or left) of the scroll bar, the position of the thumb is the minimum value of the range. At the bottom (or right) of the scroll bar, the thumb position is the maximum value of the range.

<p>By default, the range of a scroll bar is 0 (top or left) through 100 (bottom or right), but it's easy to change the range to something that is more convenient for the program:

<p><pre>
SetScrollRange (hwnd, iBar, iMin, iMax, bRedraw) ;
</PRE>

<p>The <I>iBar</I> argument is either SB_VERT or SB_HORZ, <I>iMin</I> and <I>iMax</I> are the new minimum and maximum positions of the range, and you set <I>bRedraw</I> to TRUE if you want Windows to redraw the scroll bar based on the new range. (If you will be calling other functions that affect the appearance of the scroll bar after you call <I>SetScrollRange</I>, you'll probably want to set <I>bRedraw</I> to FALSE to avoid excessive redrawing.)

<p>The thumb position is always a discrete integral value. For instance, a scroll bar with a range of 0 through 4 has five thumb positions, as shown in Figure 4-8.

<p><A HREF="javascript:fullSize('F04zg08x.htm')"> <img src="F04zg08.JPG" width=404 height=285 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 4-8.</B> <I>Scroll bars with five thumb positions.</I><!-- /caption -->

<p>You can use <I>SetScrollPos</I> to set a new thumb position within the scroll bar range:

<p><pre>
SetScrollPos (hwnd, iBar, iPos, bRedraw) ;
</PRE>

<p>The <I>iPos</I> argument is the new position and must be within the range of <I>iMin</I> and <I>iMax</I>. Windows provides similar functions (<I>GetScrollRange</I> and <I>GetScrollPos</I>) to obtain the current range and position of a scroll bar.

<p>When you use scroll bars within your program, you share responsibility with Windows for maintaining the scroll bars and updating the position of the scroll bar thumb. These are Windows' responsibilities for scroll bars:

<ul>

<p><li> Handle all processing of mouse messages to the scroll bar.

<p><li> Provide a reverse-video &quot;flash&quot; when the user clicks the scroll bar.

<p><li> Move the thumb as the user drags the thumb within the scroll bar.

<p><li> Send scroll bar messages to the window procedure of the window containing the scroll bar.
</UL>

<p>These are the responsibilities of your program:

<ul>

<p><li> Initialize the range and position of the scroll bar.

<p><li> Process the scroll bar messages to the window procedure.

<p><li> Update the position of the scroll bar thumb.

<p><li> Change the contents of the client area in response to a change in the scroll bar.
</UL>

<p>Like almost everything in life, this will make a lot more sense when we start looking at some code.

<A NAME="84"><h2>Scroll Bar Messages</h2></A>
<p>Windows sends the window procedure WM_VSCROLL (vertical scroll) and WM_HSCROLL (horizontal scroll) messages when the scroll bar is clicked with the mouse or the thumb is dragged. Each mouse action on the scroll bar generates at least two messages, one when the mouse button is pressed and another when it is released.

<p>Like all messages, WM_VSCROLL and WM_HSCROLL are accompanied by the <I>wParam</I> and <I>lParam</I> message parameters. For messages from scroll bars created as part of your window, you can ignore <I>lParam</I>; that's used only for scroll bars created as child windows, usually within dialog boxes.

<p>The <I>wParam</I> message parameter is divided into a low word and a high word. The low word of <I>wParam</I> is a number that indicates what the mouse is doing to the scroll bar. This number is referred to as a &quot;notification code.&quot; Notification codes have values defined by identifiers that begin with SB, which stands for &quot;scroll bar.&quot; Here's how the notification codes are defined in WINUSER.H:

<p><pre>
#define SB_LINEUP           0
#define SB_LINELEFT         0
#define SB_LINEDOWN         1
#define SB_LINERIGHT        1
#define SB_PAGEUP           2
#define SB_PAGELEFT         2
#define SB_PAGEDOWN         3
#define SB_PAGERIGHT        3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK       5
#define SB_TOP              6
#define SB_LEFT             6
#define SB_BOTTOM           7
#define SB_RIGHT            7
#define SB_ENDSCROLL        8
</PRE>

<p>You use the identifiers containing the words LEFT and RIGHT for horizontal scroll bars, and the identifiers with UP, DOWN, TOP, and BOTTOM with vertical scroll bars. The notification codes associated with clicking the mouse on various areas of the scroll bar are shown in Figure 4-9.

<p><A HREF="javascript:fullSize('F04zg09x.htm')"> <img src="F04zg09.JPG" width=404 height=303 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><B>Figure 4-9.</B> <I>Identifiers for the </I>wParam<I> values of scroll bar messages.</I><!-- /caption -->

<p>If you hold down the mouse button on the various parts of the scroll bar, your program can receive multiple scroll bar messages. When the mouse button is released, you'll get a message with a notification code of SB_ENDSCROLL. You can generally ignore messages with the SB_ENDSCROLL notification code. Windows will not change the position of the scroll bar thumb. Your application does that by calling <I>SetScrollPos</I>.

<p>When you position the mouse cursor over the scroll bar thumb and press the mouse button, you can move the thumb. This generates scroll bar messages with notification codes of SB_THUMBTRACK and SB_THUMBPOSITION. When the low word of <I>wParam</I> is SB_THUMBTRACK, the high word of <I>wParam</I> is the current position of the scroll bar thumb as the user is dragging it. This position is within the minimum and maximum values of the scroll bar range. When the low word of <I>wParam</I> is SB_THUMBPOSITION, the high word of <I>wParam</I> is the final position of the scroll bar thumb when the user released the mouse button. For other scroll bar actions, the high word of <I>wParam</I> should be ignored.

<p>To provide feedback to the user, Windows will move the scroll bar thumb when you drag it with the mouse as your program is receiving SB_THUMBTRACK messages. However, unless you process SB_THUMBTRACK or SB_THUMBPOSITION messages by calling <I>SetScrollPos</I>, the thumb will snap back to its original position when the user releases the mouse button.

<p>A program can process either the SB_THUMBTRACK or SB_THUMBPOSITION messages, but doesn't usually process both. If you process SB_THUMBTRACK messages, you'll move the contents of your client area as the user is dragging the thumb. If instead you process SB_THUMBPOSITION messages, you'll move the contents of the client area only when the user <I>stops</I> dragging the thumb. It's preferable (but more difficult) to process SB_THUMBTRACK messages; for some types of data your program may have a hard time keeping up with the messages.

<p>As you'll note, the WINUSER.H header files includes notification codes of SB_TOP, SB_BOTTOM, SB_LEFT, and SB_RIGHT, indicating that the scroll bar has been moved to its minimum or maximum position. However, you will never receive these notification codes for a scroll bar created as part of your application window.

<p>Although it's not common, using 32-bit values for the scroll bar range is perfectly valid. However, the high word of <I>wParam</I>, which is only a 16-bit value, cannot properly indicate the position for SB_THUMBTRACK and SB_THUMBPOSITION actions. In this case, you need to use the function <I>GetScrollInfo</I> (described later in this chapter) to get this information.

<A NAME="85"><h2>Scrolling SYSMETS</h2></A>
<p>Enough explanation. It's time to put this stuff into practice. Let's start simply. We'll begin with vertical scrolling because that's what we desperately need. The horizontal scrolling can wait. SYSMET2 is shown in Figure 4-10. This program is probably the simplest implementation of a scroll bar you'll want in an application.

<p><B>Figure 4-10.</B> <I>The SYSMETS2 program.</I>

<P>
<TABLE cellpadding=5 width="95%"><TR><td>
<A NAME="86"><H3>SYSMETS2.C</H3></A>
<p><pre>
/*----------------------------------------------------
   SYSMETS2.C -- System Metrics Display Program No. 2
                 (c) Charles Petzold, 1998
  ----------------------------------------------------*/

#include &lt;windows.h&gt;
#include &quot;sysmets.h&quot;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     static TCHAR szAppName[] = TEXT (&quot;SysMets2&quot;) ;
     HWND         hwnd ;
     MSG          msg ;
     WNDCLASS     wndclass ;

     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;

     if (!RegisterClass (&amp;wndclass))  
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;), 
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }

     hwnd = CreateWindow (szAppName, TEXT (&quot;Get System Metrics No. 2&quot;),
                          WS_OVERLAPPEDWINDOW | WS_VSCROLL,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;

     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static int  cxChar, cxCaps, cyChar, cyClient, iVscrollPos ;
     HDC         hdc ;
     int         i, y ;
     PAINTSTRUCT ps ;
     TCHAR       szBuffer[10] ;
     TEXTMETRIC  tm ;

     switch (message)
     {
     case WM_CREATE:
          hdc = GetDC (hwnd) ;

          GetTextMetrics (hdc, &amp;tm) ;
          cxChar = tm.tmAveCharWidth ;
          cxCaps = (tm.tmPitchAndFamily &amp; 1 ? 3 : 2) * cxChar / 2 ;
          cyChar = tm.tmHeight + tm.tmExternalLeading ;

          ReleaseDC (hwnd, hdc) ;

          SetScrollRange (hwnd, SB_VERT, 0, NUMLINES - 1, FALSE) ;
          SetScrollPos   (hwnd, SB_VERT, iVscrollPos, TRUE) ;
          return 0 ;

     case WM_SIZE:
          cyClient = HIWORD (lParam) ;
          return 0 ;

     case WM_VSCROLL:
          switch (LOWORD (wParam))
          {
          case SB_LINEUP:
               iVscrollPos -= 1 ;
               break ;
     
          case SB_LINEDOWN:
               iVscrollPos += 1 ;
               break ;
     
          case SB_PAGEUP:
               iVscrollPos -= cyClient / cyChar ;
               break ;
     
          case SB_PAGEDOWN:
               iVscrollPos += cyClient / cyChar ;
               break ;
     
          case SB_THUMBPOSITION:
               iVscrollPos = HIWORD (wParam) ;
               break ;
     
          default :
               break ;
          }

          iVscrollPos = max (0, min (iVscrollPos, NUMLINES - 1)) ;

          if (iVscrollPos != GetScrollPos (hwnd, SB_VERT))
          {
               SetScrollPos (hwnd, SB_VERT, iVscrollPos, TRUE) ;
               InvalidateRect (hwnd, NULL, TRUE) ;
          }
          return 0 ;

     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
     
          for (i = 0 ; i &lt; NUMLINES ; i++)
          {
               y = cyChar * (i - iVscrollPos) ;
     
               TextOut (hdc, 0, y,
                        sysmetrics[i].szLabel,
                        lstrlen (sysmetrics[i].szLabel)) ;
     
               TextOut (hdc, 22 * cxCaps, y,
                        sysmetrics[i].szDesc,
                        lstrlen (sysmetrics[i].szDesc)) ;
     
               SetTextAlign (hdc, TA_RIGHT | TA_TOP) ;
               TextOut (hdc, 22 * cxCaps + 40 * cxChar, y, szBuffer,
                        wsprintf (szBuffer, TEXT (&quot;%5d&quot;),
                                  GetSystemMetrics (sysmetrics[i].iIndex))) ;
     
               SetTextAlign (hdc, TA_LEFT | TA_TOP) ;
          }
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;

     case WM_DESTROY:
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</TD></TR></TABLE>

<p>The new <I>CreateWindow</I> call adds a vertical scroll bar to the window by including the WS_VSCROLL window style in the third argument:

<p><pre>
WS_OVERLAPPEDWINDOW | WS_VSCROLL
</PRE>

<p>WM_CREATE message processing in the <I>WndProc</I> window procedure has two additional lines to set the range and initial position of the vertical scroll bar:

<p><pre>
SetScrollRange (hwnd, SB_VERT, 0, NUMLINES - 1, FALSE) ;
SetScrollPos (hwnd, SB_VERT, iVscrollPos, TRUE) ;
</PRE>

<p>The <I>sysmetrics</I> structure array has NUMLINES lines of text, so the scroll bar range is set to 0 through NUMLINES - 1. Each position of the scroll bar corresponds to a line of text displayed at the top of the client area. If the scroll bar thumb is at position 0, the first line will be positioned at the top of the client area. For positions greater than zero, other lines appear at the top. When the position is NUMLINES - 1, the last line of text appears at the top of the client area.

<p>To help with processing of the WM_VSCROLL messages, a static variable named <I>iVscrollPos</I> is defined within the window procedure. This variable is the current position of the scroll bar thumb. For SB_LINEUP and SB_LINEDOWN, all we need to do is adjust the scroll position by 1. For SB_PAGEUP and SB_PAGEDOWN, we want to move the text by the context of one screen, or <I>cyClient</I> divided by <I>cyChar</I>. For SB_THUMBPOSITION, the new thumb position is the high word of <I>wParam</I>. The SB_ENDSCROLL and SB_THUMBTRACK messages are ignored.

<p>After the program calculates a new value of <I>iVscrollPos</I> based on the type of WM_VSCROLL message it receives, it makes sure that it is still between the minimum and maximum range value of the scroll bar by using the <I>min</I> and <I>max</I> macros. The program then compares the value of <I>iVscrollPos</I> with the previous position, which is obtained by calling <I>GetScrollPos</I>. If the scroll position has changed, it is updated by calling <I>SetScrollPos</I>, and the entire window is invalidated by a call to <I>InvalidateRect</I>.

<p>The <I>InvalidateRect</I> function generates a WM_PAINT message. When the original SYSMETS1 program processed WM_PAINT messages, the <I>y</I>-coordinate of each line was calculated as

<p><pre>
cyChar * i
</PRE>

<p>In SYSMETS2, the formula is

<p><pre>
cyChar * (i - iVscrollPos)
</PRE>

<p>The loop still displays NUMLINES lines of text, but for nonzero values of <I>iVscrollPos</I> this value is negative. The program is actually displaying the early lines of text above and outside the client area. Windows, of course, doesn't allow these lines to appear on the screen, so everything looks all nice and neat.

<p>I told you we'd start simply. This is rather wasteful and inefficient code. We'll fix it shortly, but first consider how we update the client area after a WM_VSCROLL message.

<A NAME="87"><h2>Structuring Your Program for Painting</h2></A>
<p>The window procedure in SYSMETS2 does not directly repaint the client area after processing a scroll bar message. Instead, it calls <I>InvalidateRect</I> to invalidate the client area. This causes Windows to place a WM_PAINT message in the message queue.

<p>It is best to structure your Windows programs so that you do all your client-area painting in response to a WM_PAINT message. Because your program should be able to repaint the entire client area of the window at any time on receipt of a WM_PAINT message, painting in response to other messages will probably involve code that duplicates the functionality of your WM_PAINT logic.

<p>At first, you may rebel at this dictum because it seems such a roundabout way of doing things. In the early days of Windows, programmers found this concept difficult to master because it was so different from character-mode PC programming. And, as I mentioned earlier, there are frequently times when your program will respond to some keyboard or mouse logic by drawing something immediately. This is done for both convenience and efficiency. But in many cases it's simply unnecessary. After you master the discipline of accumulating all the information you need to paint in response to a WM_PAINT message, you'll be pleased with the results.

<p>As SYSMETS2 demonstrates, a program will often determine that it must repaint a particular area of the display while processing a message other than WM_PAINT. This is where <I>InvalidateRect</I> comes in handy. You can use it to invalidate specific rectangles of the client area or the entire client area.

<p>Simply marking areas of the window as invalid to generate WM_PAINT messages might not be entirely satisfactory in some applications. After you make an <I>InvalidateRect</I> call, Windows places a WM_PAINT message in the message queue and the window procedure eventually processes it. However, Windows treats WM_PAINT messages as low priority, so if a lot of other activity is occurring in the system, it may be awhile before your window procedure receives the WM_PAINT message. Everyone has seen blank, white &quot;holes&quot; in Windows after a dialog box is removed and the program is still waiting to refresh its window.

<p>If you prefer to update the invalid area immediately, you can call <I>UpdateWindow</I> after you call <I>InvalidateRect</I>:

<p><pre>
UpdateWindow (hwnd) ;
</PRE>

<p><I>UpdateWindow</I> causes the window procedure to be called immediately with a WM_PAINT message if any part of the client area is invalid. (<I>UpdateWindow</I> will not call the window procedure if the entire client area is valid.) In this case, the WM_PAINT message bypasses the message queue. The window procedure is called directly from Windows. When the window procedure has finished repainting, it exits and the <I>UpdateWindow</I> function returns control to the code that called it.

<p>You'll note that <I>UpdateWindow</I> is the same function used in <I>WinMain</I> to generate the first WM_PAINT message. When a window is first created, the entire client area is invalid. <I>UpdateWindow</I> directs the window procedure to paint it.

</BODY>
</HTML>






