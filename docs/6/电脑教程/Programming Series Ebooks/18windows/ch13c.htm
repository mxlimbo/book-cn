<HTML>
<HEAD>
	<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
<title>Printing Graphics and Text</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff">
<A NAME="413"><h1>Printing Graphics and Text</h1></A><P>Printing from a Windows program usually involves more overhead than shown in 
the FORMFEED program, as well as some GDI calls to actually print something. Let's write 
a program that prints one page of text and graphics. We'll start with the method shown 
in the FORMFEED program and then add some enhancements. We'll be looking at 
three versions of this program called PRINT1, PRINT2, and PRINT3. To avoid a lot of 
duplicated source code, each of these programs will use the GETPRNDC.C file shown earlier 
and functions contained in the PRINT.C file, which is shown in Figure 13-6.
<P><B>Figure 13-6.</b> <i>The PRINT.C file used in the PRINT1, PRINT2, and PRINT3 programs.</I>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="414"><P><H3>PRINT.C</H3></A><P><PRE>
/*-----------------------------------------------------------
   PRINT.C -- Common routines for Print1, Print2, and Print3
  -----------------------------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;
BOOL PrintMyPage (HWND) ;

extern HINSTANCE hInst ;
extern TCHAR     szAppName[] ;
extern TCHAR     szCaption[] ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;
     
     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))

     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }
     
     hInst = hInstance ;
     
     hwnd = CreateWindow (szAppName, szCaption,
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

void PageGDICalls (HDC hdcPrn, int cxPage, int cyPage)
{
     static TCHAR szTextStr[] = TEXT (&quot;Hello, Printer!&quot;) ;
     
     Rectangle (hdcPrn, 0, 0, cxPage, cyPage) ;
     
     MoveToEx (hdcPrn, 0, 0, NULL) ;
     LineTo   (hdcPrn, cxPage, cyPage) ;
     MoveToEx (hdcPrn, cxPage, 0, NULL) ;
     LineTo   (hdcPrn, 0, cyPage) ;
     
     SaveDC (hdcPrn) ;
     
     SetMapMode       (hdcPrn, MM_ISOTROPIC) ;
     SetWindowExtEx   (hdcPrn, 1000, 1000, NULL) ;
     SetViewportExtEx (hdcPrn, cxPage / 2, -cyPage / 2, NULL) ;
     SetViewportOrgEx (hdcPrn, cxPage / 2,  cyPage / 2, NULL) ;
     
     Ellipse (hdcPrn, -500, 500, 500, -500) ;
     
     SetTextAlign (hdcPrn, TA_BASELINE | TA_CENTER) ;
     TextOut (hdcPrn, 0, 0, szTextStr, lstrlen (szTextStr)) ;
     RestoreDC (hdcPrn, -1) ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static int   cxClient, cyClient ;
     HDC          hdc ;
     HMENU        hMenu ;
     PAINTSTRUCT  ps ;
     
     switch (message)
     {
     case WM_CREATE:
          hMenu = GetSystemMenu (hwnd, FALSE) ;
          AppendMenu (hMenu, MF_SEPARATOR, 0, NULL) ;
          AppendMenu (hMenu, 0, 1, TEXT (&quot;&amp;Print&quot;)) ;
          return 0 ;
          
     case WM_SIZE:
          cxClient = LOWORD (lParam) ;
          cyClient = HIWORD (lParam) ;
          return 0 ;
          
     case WM_SYSCOMMAND:
          if (wParam == 1)
          {
               if (!PrintMyPage (hwnd))
                    MessageBox (hwnd, TEXT (&quot;Could not print page!&quot;),
                                szAppName, MB_OK | MB_ICONEXCLAMATION) ;
               return 0 ;
          }
          break ;
          
     case WM_PAINT :
          hdc = BeginPaint (hwnd, &amp;ps) ;
          
          PageGDICalls (hdc, cxClient, cyClient) ;
          
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_DESTROY :
          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre>
</TD></TR></TABLE>

<P>PRINT.C contains the functions <I>WinMain</I> and 
<I>WndProc</I>, and also a function called 
<I>PageGDICalls</I>, which expects to receive a handle to the printer device context and 
two variables containing the width and height of the printer page. 
<I>PageGDICalls</I> draws a rectangle that encompasses the entire page, two lines between opposite corners of the 
page, an ellipse in the middle of the page (its diameter half the lesser of the printer height 
and width), and the text &quot;Hello, Printer!&quot; in the center of this ellipse.

<P>During processing of the WM_CREATE message, 
<I>WndProc</I> adds a Print option to the system menu. Selecting this option causes a call to 
<I>PrintMyPage</I>, a function that we'll enhance over the course of the three versions of the program. 
<I>PrintMyPage</I> returns TRUE if it successfully prints the page and FALSE if it encounters an error during printing. 
If <I>PrintMyPage</I> returns FALSE, 
<I>WndProc</I> displays a message box to inform you of the error.

<A NAME="415"><h2>Bare-Bones Printing</h2></A><P>PRINT1, the first version of the printing program, is shown in Figure 13-7. After 
compiling PRINT1, you can execute it and then select Print from the system menu. In quick 
succession, GDI saves the necessary printer output in a temporary file, and then the 
spooler sends it to the printer.
<P><B>Figure 13-7.</b> <i>The PRINT1 program.</I>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="416"><P><H3>PRINT1.C</H3></A>
<P><PRE>
/*---------------------------------------
   PRINT1.C -- Bare Bones Printing
               (c) Charles Petzold, 1998
  ---------------------------------------*/

#include &lt;windows.h&gt;

HDC  GetPrinterDC (void) ;              // in GETPRNDC.C
void PageGDICalls (HDC, int, int) ;     // in PRINT.C

HINSTANCE hInst ;
TCHAR     szAppName[] = TEXT (&quot;Print1&quot;) ;
TCHAR     szCaption[] = TEXT (&quot;Print Program 1&quot;) ;

BOOL PrintMyPage (HWND hwnd)
{
     static DOCINFO di = { sizeof (DOCINFO), TEXT (&quot;Print1: Printing&quot;) } ;
     BOOL           bSuccess = TRUE ;
     HDC            hdcPrn ;
     int            xPage, yPage ;
     
     if (NULL == (hdcPrn = GetPrinterDC ()))
          return FALSE ;

     xPage = GetDeviceCaps (hdcPrn, HORZRES) ;
     yPage = GetDeviceCaps (hdcPrn, VERTRES) ;
     
     if (StartDoc (hdcPrn, &amp;di) &gt; 0)
     {
          if (StartPage (hdcPrn) &gt; 0)
          {
               PageGDICalls (hdcPrn, xPage, yPage) ;
               
               if (EndPage (hdcPrn) &gt; 0)
                    EndDoc (hdcPrn) ;
               else
                    bSuccess = FALSE ;
          }
     }
     else
          bSuccess = FALSE ;
     
     DeleteDC (hdcPrn) ;
     return bSuccess ;
}
</pre>
</TD></TR></TABLE>


<P>Let's look at the code in PRINT1.C. If 
<I>PrintMyPage</I> can't obtain a device context 
handle for the printer, it returns FALSE and 
<I>WndProc</I> displays the message box indicating an 
error. If the function succeeds in obtaining the device context handle, it then determines 
the horizontal and vertical size of the page in pixels by calling 
<I>GetDeviceCaps</I>:

<P><PRE>
xPage = GetDeviceCaps (hdcPrn, HORZRES) ;
yPage = GetDeviceCaps (hdcPrn, VERTRES) ;
</pre>

<P>This is not the full size of the paper but rather its printable area. After that call, the 
code in PRINT1's <I>PrintMyPage</I> function is structurally the same as the code in 
FORMFEED, except that PRINT1 calls 
<I>PageGDICalls</I> between the <I>StartPage</I> and 
<I>EndPage</I> calls. Only if the calls to 
<I>StartDoc</I>, <I>StartPage</I>, and 
<I>EndPage</I> are successful does PRINT1 call the 
<I>EndDoc</I> print function.

<A NAME="417"><h3>Canceling Printing with an Abort Procedure</h3></A><P>For large documents, a program should provide the user with a convenient way to 
cancel a print job while the application is still printing. Perhaps the user intended to print 
only one page of a document but instead elected to print all 537 pages. That should be a 
mistake that is correctable before all 537 pages have printed.

<P>Canceling a print job from within an application requires something called an 
&quot;abort procedure.&quot; The abort procedure is a small exported function in your program. You 
give Windows the address of this function as an argument to the 
<I>SetAbortProc</I> function; GDI then calls the procedure repeatedly during printing, in essence asking, &quot;Shall I 
continue printing?&quot;

<P>Let's look first at what's required to add an abort procedure to the printing logic 
and then examine some of the ramifications. The abort procedure is commonly called 
<I>AbortProc</I>, and it takes the following form:

<P><PRE>
BOOL CALLBACK AbortProc (HDC hdcPrn, int iCode)
{

     <I>[other program lines]</I>
}
</pre>

<P>Before printing, you must register the abort procedure by calling 
<I>SetAbortProc</I>:

<P><PRE>
SetAbortProc (hdcPrn, AbortProc) ;
</pre>

<P>You make this call before the <I>StartDoc</I> call. You don't need to &quot;unset&quot; the abort 
procedure after you finish printing.

<P>While processing the <I>EndPage</I> call (that is, while playing the metafile into the 
device driver and creating the temporary printer output files), GDI frequently calls the 
abort procedure. The <I>hdcPrn</I> parameter is the printer device context handle. The 
<I>iCode</I> parameter is 0 if all is going well or is SP_OUTOFDISK if the GDI module has run out of disk 
space because of the temporary printer output files.

<P><I>AbortProc</I> must return TRUE (nonzero) if the print job is to be continued and 
returns FALSE (0) if the print job is to be aborted. The abort procedure can be as simple as this:

<P><PRE>
BOOL CALLBACK AbortProc (HDC hdcPrn, int iCode)
{
     MSG   msg ;

     while (PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return TRUE ;
}
</pre>

<P>This function may seem a little peculiar. In fact, it looks suspiciously like a 
message loop. What's a message loop doing here of all places? Well, it 
<I>is</I> a message loop. You'll note, however, that this message loop calls 
<I>PeekMessage</I> rather than <I>GetMessage</I>. I 
discussed <I>PeekMessage</I> in connection with the RANDRECT program at the end of <a href="ch05a.htm#94">Chapter 5</a>. 
You'll recall that <I>PeekMessage</I> returns control to a program with a message from the 
program's message queue (just like 
<I>GetMessage</I>) but also returns control if there are no 
messages waiting in any program's message queue.


<P>The message loop in the <I>AbortProc</I> function repeatedly calls 
<I>PeekMessage</I> while <I>PeekMessage</I> returns TRUE. This TRUE value means that 
<I>PeekMessage</I> has retrieved a message that can be sent to one of the program's window procedures using 
<I>TranslateMessage</I> and <I>DispatchMessage</I>. When there are no more messages in the program's 
message queue, the return value of 
<I>PeekMessage</I> is then FALSE, so 
<I>AbortProc</I> returns control to Windows.

<A NAME="418"><h3>How Windows Uses <I>AbortProc</I></h3></A><P>When a program is printing, the bulk of the work takes place during the call to 
<I>EndPage</I>. Before that call, the GDI module simply adds another record to the disk-based 
metafile every time the program calls a GDI drawing function. When GDI gets the 
<I>EndPage</I> call, it plays this metafile into the device driver once for each band the device driver defines 
on a page. GDI then stores in a file the printer output created by the printer driver. If the 
spooler isn't active, the GDI module itself must write this printer output to the printer.

<P>During the call to <I>EndPage</I>, the GDI module calls the abort procedure you've 
set. Normally, the <I>iCode</I> parameter is 0, but if GDI has run out of disk space because of 
the presence of other temporary files that haven't been printed yet, the 
<I>iCode</I> parameter is SP_OUTOFDISK. (You wouldn't normally check this value, but you can if you want.) 
The abort procedure then goes into its 
<I>PeekMessage</I> loop to retrieve messages from the 
program's message queue.

<P>If there are no messages in the program's message queue, 
<I>PeekMessage</I> returns FALSE. The abort procedure then drops out of its message loop and returns a TRUE value to 
the GDI module to indicate that printing should continue. The GDI module then continues 
to process the <I>EndPage</I> call.

<P>The GDI module stops the print process if an error occurs, so the main purpose 
of the abort procedure is to allow the user to cancel printing. For that we also need a 
dialog box that displays a Cancel button. Let's take these two steps one at a time. First we'll 
add an abort procedure to create the PRINT2 program, and then we'll add a dialog with a 
Cancel button in PRINT3 to make the abort procedure useful.

<A NAME="419"><h2>Implementing an Abort Procedure</h2></A><P>Let's quickly review the mechanics of the abort procedure. You define an abort 
procedure that looks like this:

<P><PRE>
BOOL CALLBACK AbortProc (HDC hdcPrn, int iCode)
{
     MSG  msg ;

     while (PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return TRUE ;
}
</pre>

<P>To print something, you give Windows a pointer to the abort procedure:

<P><Pre>
SetAbortProc (hdcPrn, AbortProc) ;
</pre>

<P>You make this call before the <I>StartDoc</I> call. And that's it.

<P>Well, not quite. We've overlooked a problem with that 
<I>PeekMessage</I> loop in <I>AbortProc&#8212;</I>a big problem. 
<I>AbortProc</I> is called only while your program is in the midst of 
printing. Some very ugly things can happen if you retrieve a message in 
<I>AbortProc</I> and dispatch it to your own window procedure. A user could select Print from the menu again. But 
the program is already in the middle of the printing routine. A user could load a new file 
into the program while the program is trying to print the previous file. A user could even 
quit your program! If that happens, all your program's windows will be destroyed. You'll 
eventually return from the printing routine, but you'll have nowhere to go except to a 
window procedure that's no longer valid.

<P>This stuff boggles the mind. And your program isn't prepared for it. For this 
reason, when you set an abort procedure, you should first disable your program's window so 
that it can't receive keyboard and mouse input. You do this with

<P><pre>
EnableWindow (hwnd, FALSE) ;
</pre>

<P>This prevents keyboard and mouse input from getting into the message queue. The 
user therefore can't do anything with your program during the time it's printing. When 
printing is finished, you reenable the window for input:

<P><pre>
EnableWindow (hwnd, TRUE) ;
</pre>

<P>So why, you ask, do we even bother with the 
<I>TranslateMessage</I> and <I>DispatchMessage</I> calls in 
<I>AbortProc</I> when no keyboard or mouse messages will get into the message 
queue in the first place? It's true that the 
<I>TranslateMessage</I> call isn't strictly needed (although 
it's almost always included). But we must use 
<I>DispatchMessage</I> in case a WM_PAINT message gets in the message queue. If WM_PAINT isn't processed properly with a 
<I>BeginPaint</I> and <I>EndPaint</I> pair in the window procedure, the message will remain in the queue and 
clog up the works, because <I>PeekMessage</I> will never return a FALSE.

<P>When you disable your window during the time you're printing, your program 
remains inert on the display. But a user can switch to another program and do some 
work there, and the spooler can continue sending output files to the printer.

<P>The PRINT2 program, shown in Figure 13-8, adds to PRINT1 an abort procedure 
and the necessary support&#8212;a call to the 
<I>AbortProc</I> function and two calls to 
<I>EnableWindow</I>, the first to disable the window and the second to reenable it.

<P><B>Figure 13-8.</b> <i>The PRINT2 program.</I>
<TABLE cellpadding=5 width="95%"><TR><TD>
<P><A NAME="420"><P><H3>PRINT2.C</H3></A>
<P><pre>
/*-------------------------------------------
   PRINT2.C -- Printing with Abort Procedure
               (c) Charles Petzold, 1998
  -------------------------------------------*/


#include &lt;windows.h&gt;

HDC  GetPrinterDC (void) ;              // in GETPRNDC.C
void PageGDICalls (HDC, int, int) ;     // in PRINT.C

HINSTANCE hInst ;
TCHAR     szAppName[] = TEXT (&quot;Print2&quot;) ;
TCHAR     szCaption[] = TEXT (&quot;Print Program 2 (Abort Procedure)&quot;) ;

BOOL CALLBACK AbortProc (HDC hdcPrn, int iCode)
{
     MSG msg ;
     
     while (PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return TRUE ;
}

BOOL PrintMyPage (HWND hwnd)
{
     static DOCINFO di = { sizeof (DOCINFO), TEXT (&quot;Print2: Printing&quot;) } ;
     BOOL           bSuccess = TRUE ;
     HDC            hdcPrn ;
     short          xPage, yPage ;
     
     if (NULL == (hdcPrn = GetPrinterDC ()))
          return FALSE ;
     
     xPage = GetDeviceCaps (hdcPrn, HORZRES) ;
     yPage = GetDeviceCaps (hdcPrn, VERTRES) ;
     
     EnableWindow (hwnd, FALSE) ;
     
     SetAbortProc (hdcPrn, AbortProc) ;
     
     if (StartDoc (hdcPrn, &amp;di) &gt; 0)

     {
          if (StartPage (hdcPrn) &gt; 0)
          {
               PageGDICalls (hdcPrn, xPage, yPage) ;
               
               if (EndPage (hdcPrn) &gt; 0)
                    EndDoc (hdcPrn) ;
               else
                    bSuccess = FALSE ;
          }
     }
     else
          bSuccess = FALSE ;
     
     EnableWindow (hwnd, TRUE) ;
     DeleteDC (hdcPrn) ;
     return bSuccess ;
}
</pre>
</TD></TR></TABLE>


<A NAME="421"><h2>Adding a Printing Dialog Box</h2></A><P>PRINT2 is not entirely satisfactory. First, the program doesn't directly indicate when it 
is printing and when it is finished with printing. Only when you poke at the program 
with the mouse and find that it doesn't respond can you determine that it must still be 
processing the <I>PrintMyPage</I> routine. Nor does PRINT2 give the user the opportunity to cancel 
the print job while it is spooling.

<P>You're probably aware that most Windows programs give users a chance to 
cancel a printing operation currently in progress. A small dialog box comes up on the screen; 
it contains some text and a push button labeled Cancel. The program displays this dialog 
box during the entire time that GDI is saving the printer output in a disk file or (if the 
spooler is disabled) while the printer is printing. This is a modeless dialog box, and you must 
supply the dialog procedure.

<P>This dialog box is often called the &quot;abort dialog box,&quot; and the dialog procedure 
is often called the &quot;abort dialog procedure.&quot; To distinguish it more clearly from the 
&quot;abort procedure,&quot; I'll call this dialog procedure the &quot;printing dialog procedure.&quot; The abort 
procedure (with the name <I>AbortProc</I>) and the printing dialog procedure (which I'll 
name <I>PrintDlgProc</I>) are two separate exported functions. If you want to print in a 
professional, Windows-like manner, you must have both of these.

<P>These two functions interact as follows. The 
<I>PeekMessage</I> loop in <I>AbortProc</I> must 
be modified to send messages for the modeless dialog box to the dialog box window 
procedure. <I>PrintDlgProc</I> must process WM_COMMAND messages to check the status of the 
Cancel button. If the Cancel button is pressed, it sets a global variable called 
<I>bUserAbort</I> to TRUE. The value returned from 
<I>AbortProc</I> is the inverse of 
<I>bUserAbort</I>. You will recall that 
<I>AbortProc</I> returns TRUE to continue printing and FALSE to abort printing. In PRINT2 we always 
returned TRUE. Now we'll return FALSE if the user clicks the Cancel button in the printing dialog 
box. This logic is implemented in the PRINT3 program, shown in Figure 13-9.

<P><B>Figure 13-9.</b> <i>The PRINT3 program.</I>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="422"><P><H3>PRINT3.C</H3></A><P><pre>
/*---------------------------------------
   PRINT3.C -- Printing with Dialog Box
               (c) Charles Petzold, 1998
  ---------------------------------------*/

#include &lt;windows.h&gt;

HDC  GetPrinterDC (void) ;              // in GETPRNDC.C
void PageGDICalls (HDC, int, int) ;     // in PRINT.C

HINSTANCE hInst ;
TCHAR     szAppName[] = TEXT (&quot;Print3&quot;) ;
TCHAR     szCaption[] = TEXT (&quot;Print Program 3 (Dialog Box)&quot;) ;

BOOL bUserAbort ;
HWND hDlgPrint ;

BOOL CALLBACK PrintDlgProc (HWND hDlg, UINT message, 
                            WPARAM wParam, LPARAM lParam)
{
     switch (message)
     {
     case WM_INITDIALOG:
          SetWindowText (hDlg, szAppName) ;
          EnableMenuItem (GetSystemMenu (hDlg, FALSE), SC_CLOSE, MF_GRAYED) ;
          return TRUE ;
          
     case WM_COMMAND:
          bUserAbort = TRUE ;
          EnableWindow (GetParent (hDlg), TRUE) ;
          DestroyWindow (hDlg) ;
          hDlgPrint = NULL ;
          return TRUE ;
     }
     return FALSE ;
}

BOOL CALLBACK AbortProc (HDC hdcPrn, int iCode)

{
     MSG msg ;
     
     while (!bUserAbort &amp;&amp; PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE))
     {
          if (!hDlgPrint || !IsDialogMessage (hDlgPrint, &amp;msg))
          {
               TranslateMessage (&amp;msg) ;
               DispatchMessage (&amp;msg) ;
          }
     }
     return !bUserAbort ;
}

BOOL PrintMyPage (HWND hwnd)
{
     static DOCINFO di = { sizeof (DOCINFO), TEXT (&quot;Print3: Printing&quot;) } ;
     BOOL           bSuccess = TRUE ;
     HDC            hdcPrn ;
     int            xPage, yPage ;
     
     if (NULL == (hdcPrn = GetPrinterDC ()))
          return FALSE ;
     
     xPage = GetDeviceCaps (hdcPrn, HORZRES) ;
     yPage = GetDeviceCaps (hdcPrn, VERTRES) ;
     
     EnableWindow (hwnd, FALSE) ;
     
     bUserAbort = FALSE ;
     hDlgPrint = CreateDialog (hInst, TEXT (&quot;PrintDlgBox&quot;), 
                               hwnd, PrintDlgProc) ;
     
     SetAbortProc (hdcPrn, AbortProc) ;
     
     if (StartDoc (hdcPrn, &amp;di) &gt; 0)
     {
          if (StartPage (hdcPrn) &gt; 0)
          {
               PageGDICalls (hdcPrn, xPage, yPage) ;
               
               if (EndPage (hdcPrn) &gt; 0)
                    EndDoc (hdcPrn) ;
               else
                    bSuccess = FALSE ;
          }
     }
     else
          bSuccess = FALSE ;

     if (!bUserAbort)
     {
          EnableWindow (hwnd, TRUE) ;
          DestroyWindow (hDlgPrint) ;
     }
     
     DeleteDC (hdcPrn) ;
     
     return bSuccess &amp;&amp; !bUserAbort ;
}
</pre>
</TD></TR></TABLE>
<P><TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="423"><P><H3>PRINT.RC (excerpts)</H3></A><P><Pre>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;
#include &quot;afxres.h&quot;

/////////////////////////////////////////////////////////////////////////////
// Dialog

PRINTDLGBOX DIALOG DISCARDABLE  20, 20, 186, 63
STYLE DS_MODALFRAME | WS_POPUP | WS_VISIBLE | WS_CAPTION | WS_SYSMENU
FONT 8, &quot;MS Sans Serif&quot;
BEGIN
    PUSHBUTTON      &quot;Cancel&quot;,IDCANCEL,67,42,50,14
    CTEXT           &quot;Cancel Printing&quot;,IDC_STATIC,7,21,172,8
END
</pre>
</TD></TR></TABLE>


<P>If you experiment with PRINT3, you may want to temporarily disable print 
spooling. Otherwise, the Cancel button, which is visible only while the spooler collects data 
from PRINT3, might disappear too quickly for you to actually click on it. Don't be surprised 
if things don't come to an immediate halt when you click the Cancel button, especially 
on a slow printer. The printer has an internal buffer that must drain before the printer 
stops. Clicking Cancel merely tells GDI not to send any more data to the printer's buffer.

<P>Two global variables are added to PRINT3: a BOOL called 
<I>bUserAbort</I> and a handle to the dialog box window called 
<I>hDlgPrint</I>. The <I>PrintMyPage</I> function initializes 
<I>bUserAbort</I> to FALSE, and as in PRINT2, the program's main window is disabled. The pointer 
to <I>AbortProc</I> is used in the 
<I>SetAbortProc</I> call, and the pointer to 
<I>PrintDlgProc</I> is used in a 
<I>CreateDialog</I> call. The window handle returned from 
<I>CreateDialog</I> is saved in <I>hDlgPrint</I>.

<P>The message loop in <I>AbortProc</I> now looks like this:

<P><pre>
while (!bUserAbort &amp;&amp; PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE))
{
     if (!hDlgPrint &#166;&#166; !IsDialogMessage (hDlgPrint, &amp;msg))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
}
return !bUserAbort ;
</pre>

<P>It calls <I>PeekMessage</I> only if 
<I>bUserAbort</I> is FALSE&#8212;that is, if the user hasn't yet aborted 
the printing operation. The <I>IsDialogMessage</I> function is required to send the message to 
the modeless dialog box. As is normal with modeless dialog boxes, the handle to the 
dialog box window is checked before this call is made. 
<I>AbortProc</I> returns the inverse of 
<I>bUserAbort</I>. Initially, <I>bUserAbort</I> is FALSE, so 
<I>AbortProc</I> returns TRUE, indicating that printing is 
to continue. But <I>bUserAbort</I> could be set to TRUE in the printing dialog procedure.
<P>The <I>PrintDlgProc</I> function is fairly simple. While processing WM_INITDIALOG, 
the function sets the window caption to the name of the program and disables the Close 
option on the system menu. If the user clicks the Cancel button, 
<I>PrintDlgProc</I> receives a WM_
COMMAND message:

<P><pre>
case WM_COMMAND :
     bUserAbort = TRUE ;
     EnableWindow (GetParent (hDlg), TRUE) ;
     DestroyWindow (hDlg) ;
     hDlgPrint = NULL ;
     return TRUE ;
</pre>

<P>Setting <I>bUserAbort</I> to TRUE indicates that the user has decided to cancel the 
printing operation. The main window is enabled, and the dialog box is destroyed. (It is 
important that you perform these two actions in this order. Otherwise, some other 
program running under Windows will become the active program, and your program might 
disappear into the background.) As is normal, 
<I>hDlgPrint</I> is set to NULL to prevent 
<I>IsDialogMessage</I> from being called in the message loop.
<P>The only time this dialog box receives messages is when 
<I>AbortProc</I> retrieves messages with 
<I>PeekMessage</I> and sends them to the dialog box window procedure with 
<I>IsDialogMessage</I>. The only time 
<I>AbortProc</I> is called is when the GDI module is processing 
the <I>EndPage</I> function. If GDI sees that the return value from 
<I>AbortProc</I> is FALSE, it returns control from the 
<I>EndPage</I> call back to <I>PrintMyPage</I>. It doesn't return an error code. At 
that point, <I>PrintMyPage</I> thinks that the page is complete and calls the 
<I>EndDoc</I> function. Nothing is printed, however, because the GDI module didn't finish processing the 
<I>EndPage</I> call.

<P>Some cleanup remains. If the user didn't cancel the print job from the dialog 
box, then the dialog box is still displayed. 
<I>PrintMyPage</I> reenables its main window and 
destroys the dialog box:

<P><pre>
if (!bUserAbort)
{
     EnableWindow (hwnd, TRUE) ;
     DestroyWindow (hDlgPrint) ;
}
</pre>

<P>Two variables tell you what happened: 
<I>bUserAbort</I> tells you whether the user 
aborted the print job, and <I>bSuccess</I> tells you whether an error occurred. You can do what you 
want with these variables. <I>PrintMyPage</I> simply performs a logical AND operation to return 
to <I>WndProc</I>:

<P><pre>
return bSuccess &amp;&amp; !bUserAbort ;
</pre>

<A NAME="424"><h2>Adding Printing to POPPAD</h2></A><P>Now we're ready to add a printing facility to the POPPAD series of programs and 
declare POPPAD finished. You'll need the various POPPAD files from <a href="ch11a.htm#331">Chapter 11</a>, plus the 
POPPRNT.C file in Figure 13-10.
<P><B>Figure 13-10.</b> <i>The POPPRNT.C file to add printing capability to POPPAD.</I>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="425"><P><H3>POPPRNT.C</H3></A><P>
<pre>

/*----------------------------------------------
   POPPRNT.C -- Popup Editor Printing Functions
  ----------------------------------------------*/

#include &lt;windows.h&gt;
#include &lt;commdlg.h&gt;
#include &quot;resource.h&quot;

BOOL bUserAbort ;
HWND hDlgPrint ;

BOOL CALLBACK PrintDlgProc (HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
     switch (msg)
     {
     case WM_INITDIALOG :
          EnableMenuItem (GetSystemMenu (hDlg, FALSE), SC_CLOSE, MF_GRAYED) ;
          return TRUE ;
          
     case WM_COMMAND :
          bUserAbort = TRUE ;
          EnableWindow (GetParent (hDlg), TRUE) ;
          DestroyWindow (hDlg) ;

          hDlgPrint = NULL ;
          return TRUE ;
     }
     return FALSE ;
}          

BOOL CALLBACK AbortProc (HDC hPrinterDC, int iCode)
{
     MSG msg ;
     
     while (!bUserAbort &amp;&amp; PeekMessage (&amp;msg, NULL, 0, 0, PM_REMOVE))
     {
          if (!hDlgPrint || !IsDialogMessage (hDlgPrint, &amp;msg))
          {
               TranslateMessage (&amp;msg) ;
               DispatchMessage (&amp;msg) ;
          }
     }
     return !bUserAbort ;
}

BOOL PopPrntPrintFile (HINSTANCE hInst, HWND hwnd, HWND hwndEdit, 
                       PTSTR szTitleName)
{
     static DOCINFO  di = { sizeof (DOCINFO) } ;
     static PRINTDLG pd ;
     BOOL            bSuccess ;
     int             yChar, iCharsPerLine, iLinesPerPage, iTotalLines,
                     iTotalPages, iPage, iLine, iLineNum ;
     PTSTR           pstrBuffer ;
     TCHAR           szJobName [64 + MAX_PATH] ;
     TEXTMETRIC      tm ;
     WORD            iColCopy, iNoiColCopy ;

          // Invoke Print common dialog box
     
     pd.lStructSize         = sizeof (PRINTDLG) ;
     pd.hwndOwner           = hwnd ;
     pd.hDevMode            = NULL ;
     pd.hDevNames           = NULL ;
     pd.hDC                 = NULL ;
     pd.Flags               = PD_ALLPAGES | PD_COLLATE | 
                              PD_RETURNDC | PD_NOSELECTION ;
     pd.nFromPage           = 0 ;
     pd.nToPage             = 0 ;
     pd.nMinPage            = 0 ;
     pd.nMaxPage            = 0 ;
     pd.nCopies             = 1 ;
     pd.hInstance           = NULL ;
     pd.lCustData           = 0L ;
     pd.lpfnPrintHook       = NULL ;
     pd.lpfnSetupHook       = NULL ;
     pd.lpPrintTemplateName = NULL ;
     pd.lpSetupTemplateName = NULL ;
     pd.hPrintTemplate      = NULL ;
     pd.hSetupTemplate      = NULL ;
     
     if (!PrintDlg (&amp;pd))
          return TRUE ;
     
     if (0 == (iTotalLines = SendMessage (hwndEdit, EM_GETLINECOUNT, 0, 0)))
          return TRUE ;

          // Calculate necessary metrics for file 
     
     GetTextMetrics (pd.hDC, &amp;tm) ;
     yChar = tm.tmHeight + tm.tmExternalLeading ;
     
     iCharsPerLine = GetDeviceCaps (pd.hDC, HORZRES) / tm.tmAveCharWidth ;
     iLinesPerPage = GetDeviceCaps (pd.hDC, VERTRES) / yChar ;
     iTotalPages   = (iTotalLines + iLinesPerPage - 1) / iLinesPerPage ;

          // Allocate a buffer for each line of text
     
     pstrBuffer = malloc (sizeof (TCHAR) * (iCharsPerLine + 1)) ;

          // Display the printing dialog box
     
     EnableWindow (hwnd, FALSE) ;
     
     bSuccess   = TRUE ;
     bUserAbort = FALSE ;
     
     hDlgPrint = CreateDialog (hInst, TEXT (&quot;PrintDlgBox&quot;), 
                               hwnd, PrintDlgProc) ;

     SetDlgItemText (hDlgPrint, IDC_FILENAME, szTitleName) ;
     SetAbortProc (pd.hDC, AbortProc) ;

          // Start the document

     GetWindowText (hwnd, szJobName, sizeof (szJobName)) ;
     di.lpszDocName = szJobName ;

     if (StartDoc (pd.hDC, &amp;di) &gt; 0)
     {
               // Collation requires this loop and iNoiColCopy

          for (iColCopy = 0 ;
               iColCopy &lt; ((WORD) pd.Flags &amp; PD_COLLATE ? pd.nCopies : 1) ;
               iColCopy++)
          {
               for (iPage = 0 ; iPage &lt; iTotalPages ; iPage++)
               {
                    for (iNoiColCopy = 0 ;
                         iNoiColCopy &lt; (pd.Flags &amp; PD_COLLATE ? 1 : pd.nCopies);
                         iNoiColCopy++)
                    {
                              // Start the page

                         if (StartPage (pd.hDC) &lt; 0)
                         {
                              bSuccess = FALSE ;
                              break ;
                         }

                              // For each page, print the lines
                         
                         for (iLine = 0 ; iLine &lt; iLinesPerPage ; iLine++)
                         {
                              iLineNum = iLinesPerPage * iPage + iLine ;
                              
                              if (iLineNum &gt; iTotalLines)
                                   break ;
                              
                              *(int *) pstrBuffer = iCharsPerLine ;
                              
                              TextOut (pd.hDC, 0, yChar * iLine, pstrBuffer,
                                       (int) SendMessage (hwndEdit, EM_GETLINE,
                                       (WPARAM) iLineNum, (LPARAM) pstrBuffer));
                         }
                         
                         if (EndPage (pd.hDC) &lt; 0)
                         {
                              bSuccess = FALSE ;
                              break ;
                         }
                         
                         if (bUserAbort)
                              break ;
                    }
                    
                    if (!bSuccess || bUserAbort)
                         break ;
               }
               
               if (!bSuccess || bUserAbort)
                    break ;
          }
     }
     else
          bSuccess = FALSE ;
     
     if (bSuccess)
          EndDoc (pd.hDC) ;
     
     if (!bUserAbort)
     {
          EnableWindow (hwnd, TRUE) ;
          DestroyWindow (hDlgPrint) ;
     }
     
     free (pstrBuffer) ;
     DeleteDC (pd.hDC) ;
     
     return bSuccess &amp;&amp; !bUserAbort ;
}
</pre>
</TD></TR></TABLE>


<P>In keeping with the philosophy of making POPPAD as simple as possible by 
taking advantage of high-level Windows features, the POPPRNT.C file demonstrates how to 
use the <I>PrintDlg</I> function. This function is included in the common dialog box library and 
uses a structure of type PRINTDLG.

<P>Normally, a Print option is included on a program's File menu. When the user 
selects the Print option, a program can initialize the fields of the PRINTDLG structure 
and call <I>PrintDlg</I>.

<P><I>PrintDlg</I> displays a dialog box that allows the user to select a page range to print. 
Thus, this dialog box is particularly suitable for programs such as POPPAD that can print 
multipage documents. The dialog box also provides an edit field to specify the number of copies 
and a check-box labeled &quot;Collate.&quot; Collation affects the page ordering of multiple copies. 
For example, if the document is three pages long and the user requests that three copies 
be printed, the program can print them in one of two orders. Collated copies are in the 
page order 1, 2, 3, 1, 2, 3, 1, 2, 3. Noncollated copies are in the order 1, 1, 1, 2, 2, 2, 3, 3, 3. It's 
up to your program to print the copies in the correct order.

<P>The dialog box also allows the user to select a nondefault printer, and it includes 
a button labeled Properties that invokes a device mode dialog box. At the very least, 
this allows the user to select portrait or landscape mode.

<P>On return from the <I>PrintDlg</I> function, fields of the PRINTDLG structure indicate 
the range of pages to print and whether multiple copies should be collated. The structure 
also provides the printer device context handle, ready to be used.

<P>In POPPRNT.C, the <I>PopPrntPrintFile</I> function (which is called from POPPAD 
when the user selects the Print option from the File menu) calls 
<I>PrintDlg</I> and then proceeds to print the file. 
<I>PopPrntPrintFile</I> then performs some calculations to determine the 
number of characters it can fit on a line and the number of lines it can fit on a page. This 
process involves calls to <I>GetDeviceCaps</I> to determine the resolution of the page and to 
<I>GetTextMetrics</I> for the dimensions of a character.

<P>The program obtains the total number of lines in the document (the variable 
<I>iTotalLines</I>) by sending an EM_GETLINECOUNT message to the edit control. A buffer for 
holding the contents of each line is allocated from local memory. For each line, the first 
word of this buffer is set to the number of characters in the line. Sending the edit control 
an EM_GETLINE message copies a line into the buffer; the line is then sent to the printer 
device context using <I>TextOut</I>. (POPPRNT.C is not smart enough to wrap lines that exceed the 
width of the printer page. We'll examine a technique for wrapping such lines in <a href="ch17a.htm#600">Chapter 17</a>.)
<P>Notice that the logic to print the document includes two 
<I>for</I> loops for the number of copies. The first uses a variable named 
<I>iColCopy</I> and takes effect when the user has specified collated copies; the second uses the 
<I>iNonColCopy</I> variable and takes effect for noncollated copies.



<P>The program breaks from the <I>for</I> loop incrementing the page number if either 
<I>StartPage</I> or <I>EndPage</I> returns an error or if 
<I>bUserAbort</I> is TRUE. If the return value of the 
abort procedure is FALSE, <I>EndPage</I> doesn't return an error. For this reason, 
<I>bUserAbort</I> is tested explicitly before the next page is started. If no error is reported, the call to 
<I>EndDoc</I> is made:

<P><pre>
if (!bError)
     EndDoc (hdcPrn) ;
</pre>

<P>You might want to experiment with POPPAD by printing a multipage file. You 
can monitor progress from the print job window. The file being printed first shows up in 
this window after GDI has finished processing the first 
<I>EndPage</I> call. At that time, the spooler starts sending the file to the printer. If you then cancel the print job from POPPAD, 
the spooler aborts the printing also&#8212;that's a result of returning FALSE from the abort 
procedure. Once the file appears in the print job window, you can also cancel the printing 
by selecting Cancel Printing from the Document menu. In that case, the 
<I>EndPage</I> call in progress in POPPAD returns an error.
<P>Programmers new to Windows often become inordinately obsessed with the 
<I>AbortDoc</I> function. This function is rarely used in printing. As you can see in POPPAD, a user can 
cancel a print job at almost any time, either through POPPAD's printing dialog box or through 
the print job window. Neither requires that the program use the 
<I>AbortDoc</I> function. The only time that 
<I>AbortDoc</I> would be allowed in POPPAD is between the call to 
<I>StartDoc</I> and the first call to 
<I>EndPage</I>, but that code goes so quickly that 
<I>AbortDoc</I> isn't necessary.
<P>Figure 13-11 shows the correct sequence of print function calls for printing a 
multipage document. The best place to check for a 
<I>bUserAbort</I> value of TRUE is after each call 
to <I>EndPage</I>. The <I>EndDoc</I> function is used only when the previous print functions have 
proceeded without error. In fact, once you get an error from any call to a print function, the 
show is over and you can go home.

<P><IMG SRC="F13zg11.GIF" width=353 height=663 ALIGN="BOTTOM">

<P><!-- caption --><B>Figure 13-11.</b> <i>The sequence of function calls for multipage printing.</I><!-- /caption -->
</BODY>
</HTML>






