<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<HTML>
<HEAD>
<LINK REL=StyleSheet HREF="petzoldi.css" TYPE="text/css">
	<TITLE>Miscellaneous DLL Topics</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>

<BODY BGCOLOR="#ffffff">
<A NAME="744"><h1>Miscellaneous DLL Topics</h1></A>

<P>I mentioned earlier that a dynamic library module doesn't receive messages. However, a 
library module can call <I>GetMessage</I> and 
<I>PeekMessage</I>. The messages the library pulls from the 
queue with these functions are actually messages for the program that called the library 
function. In general, the library works on behalf of the program calling it&#8212;a rule that holds for 
most Windows functions that a library calls.

<P>A dynamic library can load resources (such as icons, strings, and bitmaps) either 
from the library file or from the file of the program that calls the library. The functions that 
load resources require an instance handle. If the library uses its own instance handle (which 
is passed to the library during initialization), the library can obtain resources from its 
own file. To load resources from the calling program's .EXE file, the library function 
requires the instance handle of the program calling the function.

<P>Registering window classes and creating windows in a library can be a little 
tricky. Both the window class structure and the 
<I>CreateWindow</I> call require an instance 
handle. Although you can use the library module's instance handle in creating the window 
class and the window, the window messages still go through the message queue of the 
program calling the library when the library creates the window. If you must create window 
classes and windows within a library, it's probably best to use the calling program's instance handle.

<P>Because messages for modal dialog boxes are retrieved outside a program's 
message loop, you can create a modal dialog box in a library by calling 
<I>DialogBox</I>. The instance handle can be that of the library, and the 
<I>hwndParent</I> argument to <I>DialogBox</I> can be set to NULL.

<A NAME="745"><h3>Dynamic Linking Without Imports</h3></A><P>Rather than have Windows perform dynamic linking when your program is first 
loaded into memory, you can link a program with a library module while the program is 
running. 

<P>For instance, you would normally call the 
<I>Rectangle</I> function like this:

<P><pre>Rectangle (hdc, xLeft, yTop, xRight, yBottom) ;
</pre>

<P>This works because the program has been linked with the GDI32.LIB import library, 
which supplied the address of <I>Rectangle</I>.
<P>You can also call <I>Rectangle</I> in a very roundabout manner. You first use 
<I>typedef</I> to define a function type for 
<I>Rectangle</I>:

<P><pre>
typedef BOOL (WINAPI * PFNRECT) (HDC, int, int, int, int) ;
</pre>

<P>You then define two variables:

<P><pre>HANDLE  hLibrary ;
PFNRECT pfnRectangle ;
</pre>

<P>Now you set <I>hLibrary</I> to the handle of the library and 
<I>lpfnRectangle</I> to the address of the 
<I>Rectangle</I> function:

<P><pre>hLibrary = LoadLibrary (TEXT (&quot;GDI32.DLL&quot;))
pfnRectangle = (PFNPRECT) GetProcAddress (hLibrary, TEXT (&quot;Rectangle&quot;))
</pre>

<P>The <I>LoadLibrary</I> function returns NULL if the library file can't be found or if some 
other error occurs. Now you can call the function and then free the library:

<P><pre>pfnRectangle (hdc, xLeft, yTop, xRight, yBottom) ;
FreeLibrary (hLibrary) ;
</pre>

<P>Although this technique of run-time dynamic linking doesn't make much sense 
for the <I>Rectangle</I> function, it can come in handy when you don't know the name of the 
library module until run time.

<P>The code above uses the <I>LoadLibrary</I> and 
<I>FreeLibrary</I> functions. Windows maintains &quot;reference counts&quot; for all library modules. 
<I>LoadLibrary</I> causes the reference count to 
be incremented. The reference count is also incremented when Windows loads any 
program that uses the library. <I>FreeLibrary</I> causes the reference count to be decremented, as 
does the termination of an instance of a program that uses this library. When the reference 
count is 0, Windows can discard the library from memory, because the library is no longer needed.

<A NAME="746"><h3>Resource-Only Libraries</h3></A><P>Any function in a dynamic-link library that a Windows program or another library can 
use must be exported. However, a DLL need not contain any exported functions. What 
would such a DLL contain? The answer is resources.

<P>Let's say you're working on a Windows application that requires a number of 
bitmaps. Normally you would list these in the resource script of the program and load them 
into memory with the <I>LoadBitmap</I> function. But perhaps you want to create several sets 
of bitmaps, each set customized for one of the major display resolutions commonly used 
with Windows. It would make most sense to store these different sets of bitmaps in 
different files, because a user would need only one set of bitmaps on the fixed disk. These files 
are resource-only libraries.

<P>Figure 21-5 shows how to create a resource-only library file called BITLIB.DLL 
that contains nine bitmaps. The BITLIB.RC file lists all the separate bitmap files and assigns 
each one a number. To create BITLIB.DLL, you need nine bitmaps named BITMAP1.BMP, 
BITMAP2.BMP, and so forth. You can use the bitmaps provided on this book's companion 
disc or create them yourself in the Visual C++ program. They are associated with 
numeric IDs of 1 through 9.

<P><B>Figure 21-5.</b> <i>The BITLIB library.</I>

<TABLE cellpadding="5" width="95%">
<tr><td><h3>BITLIB.C</h3>

<P><pre>
/*--------------------------------------------------------------
   BITLIB.C -- Code entry point for BITLIB dynamic-link library
               (c) Charles Petzold,  1998

  --------------------------------------------------------------*/

#include &lt;windows.h&gt;

int WINAPI DllMain (HINSTANCE hInstance, DWORD fdwReason, PVOID pvReserved)
{
     return TRUE ;
}
</pre></td></tr>
</table>

<TABLE cellpadding="5" width="95%">
<tr><td><h3>BITLIB.RC (excerpts)</h3>

<P><pre>
//Microsoft Developer Studio generated resource script.

#include &quot;resource.h&quot;

#include &quot;afxres.h&quot;
/////////////////////////////////////////////////////////////////////////////
// Bitmap

1                       BITMAP  DISCARDABLE     &quot;bitmap1.bmp&quot;
2                       BITMAP  DISCARDABLE     &quot;bitmap2.bmp&quot;
3                       BITMAP  DISCARDABLE     &quot;bitmap3.bmp&quot;
4                       BITMAP  DISCARDABLE     &quot;bitmap4.bmp&quot;
5                       BITMAP  DISCARDABLE     &quot;bitmap5.bmp&quot;
6                       BITMAP  DISCARDABLE     &quot;bitmap6.bmp&quot;
7                       BITMAP  DISCARDABLE     &quot;bitmap7.bmp&quot;
8                       BITMAP  DISCARDABLE     &quot;bitmap8.bmp&quot;
9                       BITMAP  DISCARDABLE     &quot;bitmap9.bmp&quot;
</pre></td></tr>
</table>

Create the BITLIB project in a workspace named SHOWBIT. Create the 
SHOWBIT program, shown in Figure 21-6, in another project named SHOWBIT, the same as 
before. However, don't make BITLIB a dependency of SHOWBIT; otherwise, the link step 
will require a BITLIB.LIB file, and one isn't created because BITLIB has no exported 
functions. Instead, build BITLIB and SHOWBIT separately by alternately setting each of them as 
the Active Project and building.
<P>SHOWBIT.C reads the bitmap resources from BITLIB and displays them in its 
client area. You can cycle through the bitmaps by pressing a key on the keyboard.

<P><B>Figure 21-6.</b> <i>The SHOWBIT program.</I>

<TABLE cellpadding="5" width="95%">
<tr><td><h3>SHOWBIT.C</h3>

<P><pre>
/*-----------------------------------------------------------
   SHOWBIT.C -- Shows bitmaps in BITLIB dynamic-link library
                (c) Charles Petzold, 1998

  -----------------------------------------------------------*/

#include &lt;windows.h&gt;

LRESULT CALLBACK WndProc (HWND, UINT, WPARAM, LPARAM) ;

TCHAR szAppName [] = TEXT (&quot;ShowBit&quot;) ;

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
                    PSTR szCmdLine, int iCmdShow)
{
     HWND     hwnd ;
     MSG      msg ;
     WNDCLASS wndclass ;

     wndclass.style         = CS_HREDRAW | CS_VREDRAW ;
     wndclass.lpfnWndProc   = WndProc ;
     wndclass.cbClsExtra    = 0 ;
     wndclass.cbWndExtra    = 0 ;
     wndclass.hInstance     = hInstance ;
     wndclass.hIcon         = LoadIcon (NULL, IDI_APPLICATION) ;
     wndclass.hCursor       = LoadCursor (NULL, IDC_ARROW) ;
     wndclass.hbrBackground = (HBRUSH) GetStockObject (WHITE_BRUSH) ;
     wndclass.lpszMenuName  = NULL ;
     wndclass.lpszClassName = szAppName ;
     
     if (!RegisterClass (&amp;wndclass))
     {
          MessageBox (NULL, TEXT (&quot;This program requires Windows NT!&quot;),
                      szAppName, MB_ICONERROR) ;
          return 0 ;
     }

     hwnd = CreateWindow (szAppName, 
                          TEXT (&quot;Show Bitmaps from BITLIB (Press Key)&quot;),
                          WS_OVERLAPPEDWINDOW,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          CW_USEDEFAULT, CW_USEDEFAULT,
                          NULL, NULL, hInstance, NULL) ;

     if (!hwnd)
          return 0 ;
     
     ShowWindow (hwnd, iCmdShow) ;
     UpdateWindow (hwnd) ;
     
     while (GetMessage (&amp;msg, NULL, 0, 0))
     {
          TranslateMessage (&amp;msg) ;
          DispatchMessage (&amp;msg) ;
     }
     return msg.wParam ;
}

void DrawBitmap (HDC hdc, int xStart, int yStart, HBITMAP hBitmap)
{
     BITMAP bm ;
     HDC    hMemDC ;
     POINT  pt ;

     hMemDC = CreateCompatibleDC (hdc) ;
     SelectObject (hMemDC, hBitmap) ;
     GetObject (hBitmap, sizeof (BITMAP), &amp;bm) ;
     pt.x = bm.bmWidth ;
     pt.y = bm.bmHeight ;
     
     BitBlt (hdc, xStart, yStart, pt.x, pt.y, hMemDC, 0, 0, SRCCOPY) ;
     
     DeleteDC (hMemDC) ;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
     static HINSTANCE hLibrary ;
     static int       iCurrent = 1 ;
     HBITMAP          hBitmap ;
     HDC              hdc ;
     PAINTSTRUCT      ps ;

     switch (message)
     {
     case WM_CREATE:
          if ((hLibrary = LoadLibrary (TEXT (&quot;BITLIB.DLL&quot;))) == NULL)
          {
               MessageBox (hwnd, TEXT (&quot;Can't load BITLIB.DLL.&quot;),
                           szAppName, 0) ;
               return -1 ;
          }
          return 0 ;
          
     case WM_CHAR:
          if (hLibrary)
          {
               iCurrent ++ ;
               InvalidateRect (hwnd, NULL, TRUE) ;
          }
          return 0 ;
          
     case WM_PAINT:
          hdc = BeginPaint (hwnd, &amp;ps) ;
          
          if (hLibrary)
          {
               hBitmap = LoadBitmap (hLibrary, MAKEINTRESOURCE (iCurrent)) ;

               if (!hBitmap) 
               {
                    iCurrent = 1 ;
                    hBitmap = LoadBitmap (hLibrary, 
                                          MAKEINTRESOURCE (iCurrent)) ;
               }
               if (hBitmap)
               {
                    DrawBitmap (hdc, 0, 0, hBitmap) ;
                    DeleteObject (hBitmap) ;
               }
          }
          EndPaint (hwnd, &amp;ps) ;
          return 0 ;
          
     case WM_DESTROY:
          if (hLibrary)
               FreeLibrary (hLibrary) ;

          PostQuitMessage (0) ;
          return 0 ;
     }
     return DefWindowProc (hwnd, message, wParam, lParam) ;
}
</pre></td></tr>
</table>

<P>During processing of the WM_CREATE message, SHOWBIT gets a handle to BITLIB.DLL:

<P><pre>
if ((hLibrary = LoadLibrary (TEXT (&quot;BITLIB.DLL&quot;))) == NULL)
</pre>

<P>If BITLIB.DLL isn't in the same directory as SHOWBIT.EXE, Windows will search for it 
as discussed earlier in this chapter. If 
<I>LoadLibrary</I> returns NULL, SHOWBIT displays a 
message box reporting the error and returns a -1 from the WM_CREATE message. This 
causes the <I>CreateWindow</I> call in 
<I>WinMain</I> to return NULL, and the program terminates.

<P>SHOWBIT can obtain a handle to a bitmap by calling 
<I>LoadBitmap</I> with the library handle and the number of the bitmap:

<P><pre>hBitmap = LoadBitmap (hLibrary, MAKEINTRESOURCE (iCurrent)) ;
</pre>

<P>This returns an error if the bitmap corresponding to the number 
<I>iCurrent</I> isn't valid or if not enough memory exists to load the bitmap.

<P>While processing the WM_DESTROY message, SHOWBIT frees the library:

<P><pre>FreeLibrary (hLibrary) ;
</pre>

<P>When the last instance of SHOWBIT terminates, the reference count of BITLIB.DLL 
drops to 0 and the memory it occupies is freed. As you can see, this is a simple method of 
implementing a &quot;clip art&quot; program that could load precreated bitmaps (or metafiles or 
enhanced metafiles) into the clipboard for use by other programs.



</BODY>
</HTML>





