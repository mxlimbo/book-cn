<HTML>
<HEAD>
<TITLE>Scenario 4: Call Functions When Asynchronous I/O Requests Complete</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch11d.htm">[Previous]</A> <A HREF="ch12a.htm">[Next]</A><P>

<A NAME="157"><H1>Scenario 4: Call Functions When Asynchronous I/O Requests Complete</H1></A>

<p>The last scenario is a common one: your server application issues
some asynchronous I/O requests. When these requests complete, you want
to have a pool of threads ready to process the completed I/O requests.
This is the architecture that I/O completion ports were originally
designed for. If you were managing your own thread pool, you would
create an I/O completion port and create a pool of threads that wait on
this port. You would also open a bunch of I/O devices and associate
their handles with the completion port. As asynchronous I/O requests
complete, the device drivers would queue the &quot;work items&quot; to
the completion port.</p>
 
<p>This is a great architecture that allows for a few threads to
efficiently handle several work items, and it's fantastic that the
thread pooling functions have this built in, saving you a lot of time
and effort. To take advantage of this architecture, all you have to do
is open your device and associate it with the non-I/O component of the
thread pool. Remember that the non-I/O component's threads all wait
on an I/O completion port. To associate a device with this component,
you call this function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL燘indIoCompletionCallback(
牋燞ANDLE爃Device,
牋燩OVERLAPPED_COMPLETION_ROUTINE爌fnCallback,
牋燯LONG燿wFlags);