<HTML>
<HEAD>
<TITLE>When Not to Create a Thread</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch06b.htm">[Previous]</A> <A HREF="ch06d.htm">[Next]</A><P>

<A NAME="76"><H1>When Not to Create a Thread</H1></A>

<p>So far, I've been singing the praises of multithreaded
applications. While there are a lot of great things about multithreaded
applications, there are also some not-so-nice things. Some developers
out there believe that the way to solve <i>any</i> problem is to divide
it up into threads. They could not be more wrong!</p>

<p>Threads are incredibly useful and have a place, but when you use
threads you can create new problems while trying to solve the old ones.
For example, let's say you're developing a word processing
application and want to allow the printing function to run as its own
thread. This sounds like a good idea because the user can immediately
go back and start editing the document while it's printing. But
wait&#8212;this means that the data in the document might be changed
while the document is printing. Maybe it would be best not to have the
printing take place in its own thread, but this &quot;solution&quot;
seems a bit drastic. How about if you let the user edit another
document but lock the printing document so that it can't be
modified until the printing has been completed? Or here's a third
idea: copy the document to a temporary file, print the contents of the
temporary file, and let the user modify the original. When the
temporary file containing the document has finished printing, delete
the temporary file.</p>

<p>As you can see, threads can solve some problems while creating new
ones. Another common misuse of threads can arise during the development
of an application's user interface. In almost all applications, all
the user interface components (windows) should share the same thread. A
single thread should definitely create all of a window's child
windows. Sometimes creating different windows on different threads is
useful, but these occasions are rare indeed.</p>

<p>Usually, an application has one user interface thread that creates
all windows and has a <i>GetMessage</i> loop. Any other threads in the
process are worker threads that are compute-bound or
I/O-bound&#8212;these threads never create windows. Also, the one user
interface thread usually has a higher priority than the worker threads,
so the user interface is responsive to the user.</p>

<p>While it is unusual for a single process to have multiple user
interface threads, there are some valid uses for this. The Windows
Explorer creates a separate thread for each folder's window. This
allows you to copy files from one folder to another and still explore
other folders on your system. Also, if Explorer has a bug in it, the
thread handling one folder might crash, but you can still manipulate
other folders&#8212;at least until you do the thing that causes the
other folder to crash too. (For more information on threads and the
user interface, see Chapters <a href="ch26a.htm">26</a> and <a href="ch27a.htm">27</a>.)</p>

<p>The moral of this story is that you should use multiple threads
judiciously. Don't use them just because you can. You can still
write many useful and powerful applications using nothing more than the
primary thread assigned to the process.</p>

</BODY>
</HTML>






