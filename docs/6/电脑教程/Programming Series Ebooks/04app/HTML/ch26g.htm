<HTML>
<HEAD>
<TITLE>How Windows Handle ANSI/Unicode Characters and Strings</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch26f.htm">[Previous]</A> <A HREF="ch27a.htm">[Next]</A><P>

<A NAME="358"><H1>How Windows Handle ANSI/Unicode Characters and Strings</H1></A>

<p><div class="note"><blockquote><b>Windows 98</b><hr>
Windows 98 only supports ANSI window classes and ANSI window procedures.
</blockquote></div></p>

<p>When you register a new window class, you must tell the system the address of
the window procedure responsible for processing messages for this class. For
certain messages (such as WM_SETTEXT), the <i>lParam</i> parameter for the
message is a pointer to a string. The system needs to know whether the window
procedure requires that the string be in ANSI or Unicode before dispatching
the message so that the message will be processed correctly.</p>

<p>You tell the system whether a window procedure expects ANSI strings or
Unicode strings depending on which function you use to register the window
class. If you construct the WNDCLASS structure and call <i>RegisterClassA</i>, the
system thinks that the window procedure expects all strings and characters to
be ANSI. Registering the window class with <i>RegisterClassW</i> causes the system
to dispatch only Unicode strings and characters to the window procedure. Of
course, the macro <i>RegisterClass</i> expands to either <i>RegisterClassA</i> or 
<i>RegisterClassW</i>, depending on whether UNICODE is defined when you compile the
source module.</p>

<p>If you have a handle to a window, you can determine what type of characters
and strings the window procedure expects by calling</p>

<p><table cellpadding=5><tr><td><PRE>
BOOL IsWindowUnicode(HWND hwnd);
</pre></td></tr></table></p>

<p>If the window procedure for the specified window expects Unicode, the
function returns TRUE; otherwise, FALSE is returned.</p>

<p>If you create an ANSI string and send a WM_SETTEXT message to a
window whose window procedure expects Unicode strings, the system will
automatically convert the string for you before sending the message. You’ll rarely
need to call the <i>IsWindowUnicode</i> function.</p>

<p>The system will also perform automatic translations if you subclass a window
procedure. Let’s say that the window procedure for an edit control expects
its characters and strings to be in Unicode. Then somewhere in your program
you create an edit control and subclass the window’s procedure by calling</p>

<p><table cellpadding=5 width="95%"><tr><td><PRE>
LONG_PTR SetWindowLongPtrA(
   HWND hwnd, 
   int nIndex, 
   LONG_PTR dwNewLong);
</pre></td></tr></table></p>

<p>or</p>

<p><table cellpadding=5 width="95%"><tr><td><PRE>
LONG_PTR SetWindowLongPtrW(
   HWND hwnd, 
   int nIndex, 
   LONG_PTR dwNewLong);
</pre></td></tr></table></p>

<p>and passing GCLP_WNDPROC as the <i>nIndex</i> parameter and the address to
your subclass procedure as the <i>dwNewLong</i> parameter. But what happens if your
subclass procedure expects ANSI characters and strings? This could potentially
create a big problem. The system determines how to convert the strings and
characters depending on which of the two functions above you use to perform
the subclassing. If you call <i>SetWindowLongPtrA</i>, you’re telling the system that
the new window procedure (your subclass procedure) is to receive ANSI characters
and strings. In fact, if you were to call <i>IsWindowUnicode</i> after calling
<i>SetWindowLongPtrA</i>, you would see that it would return FALSE, indicating
that the subclassed edit window procedure no longer expects Unicode characters
and strings.</p>

<p>But now we have a new problem: how do we ensure that the original
window procedure gets the correct type of characters and strings? The system
needs to have two pieces of information to correctly convert the characters and
strings. The first is the form that the characters and strings are currently in. We
inform the system by calling either <i>CAllWindowsProcA</i> or <i>CallWindowProcW</i>:</p>

<p><table cellpadding=5 width="95%"><tr><td><PRE>
LRESULT CallWindowProcA(
   WNDPROC wndprcPrev, 
   HWND hwnd,
   UINT uMsg, 
   WPARAM wParam, 
   LPARAM lParam);

LRESULT CallWindowProcW(
   WNDPROC wndprcPrev, 
   HWND hwnd,
   UINT uMsg, 
   WPARAM wParam, 
   LPARAM lParam);
</pre></td></tr></table></p>

<p>If the subclass procedure has ANSI strings that it wants to pass to the
original window procedure, the subclass procedure must call <i>CallWindowProcA</i>.
If the subclass procedure has Unicode strings that it wants to pass to the original
window procedure, the subclass procedure must call <i>CallWindowProcW</i>.</p>

<p>The second piece of information that the system needs is the type of characters
and strings that the original window procedure expects. The system gets
this information from the address of the original window procedure. When you
call the <i>SetWindowLongPtrA</i> or the <i>SetWindowLongPtrW</i> function, the system
checks to see whether you are subclassing a Unicode window procedure with
an ANSI subclass procedure or vice versa. If you’re not changing the type of
strings expected, <i>SetWindowLongPtr</i> simply returns the address of the original
window procedure. If you’re changing the type of characters and strings that
the window procedure expects, <i>SetWindowLongPtr</i> doesn’t return the actual
address of the original window procedure; instead, it returns a handle to an
internal subsystem data structure.</p>

<p>This structure contains the address of the original window procedure and
a value that indicates whether that procedure expects Unicode or ANSI strings.
When you call <i>CallWindowProc</i>, the system checks whether you are passing a
handle of one of the internal data structures or the address of a window
procedure. If you’re passing the address of a window procedure, the original
window procedure is called and no character and string conversions need to
be performed.</p>

<p>If, on the other hand, you’re passing the handle of an internal data structure,
the system converts the characters and strings to the appropriate type
(Unicode or ANSI) and then calls the original window procedure.</p>


</body>

</html>







