<html>
<head>
<title>Chapter Eleven -- Thread Pooling</title>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<A HREF="ch10e.htm">[Previous]</A> <A HREF="ch11b.htm">[Next]</A><P>


<font size="+3">Chapter 11</font>

<A NAME="152"><H1>Thread Pooling</H1></A>

<p>In <A HREF="ch08a.htm">Chapter 8</A>, we discussed how to synchronize threads using
mechanisms that allow your threads to remain in user mode. The
wonderful thing about user-mode synchronization is its speed. If you
are concerned about your thread's performance, you should always
start by seeing if a user-mode thread synchronization mechanism will
work for you.</p>

<p>By now, you know that creating multithreaded applications is
difficult. You face two big issues: managing the creation and
destruction of threads and synchronizing the threads' access to
resources. For synchronizing resource access, Windows offers many
primitives to help you: events, semaphores, mutexes, critical sections,
and so on. These are all fairly easy to use. The only thing that would
make things easier is if the system could automatically protect shared
resources. Unfortunately, we have a ways to go before Windows can offer
this protection in a way that makes everybody happy.</p>

<p>Everybody has opinions on how to manage the creation and destruction
of threads. I've created several different implementations of
thread pools myself over the past years, each one fine-tuned for a
particular scenario. Microsoft Windows 2000 offers some new thread
pooling functions to make thread creation, destruction, and general
management easier. This new general-purpose thread pool is definitely
not right for every situation, but it often fits the bill and can save
you countless hours of development time.</p>

<p>The new thread pooling functions let you do the following:</p>

<ul>
<p><li>Call functions asynchronously</li></p>

<p><li>Call functions at timed intervals</li></p>

<p><li>Call functions when single kernel objects become signaled</li></p>

<p><li>Call functions when asynchronous I/O requests complete</li></p>
</ul>

<p>To accomplish these tasks, the thread pool consists of four separate
components. Table 11-1 shows the components and describes the rules
that govern their behavior.</p>

<p>
<b>Table 11-1.</b> <i>Thread pool components and their behavior</i>
</p>

<p>
<table valign="top" cellpadding="5" width="95%">

<tr>
<th colspan="5">Component</th>
</tr>

<tr>
<td valign="top">&nbsp;</td>
<td valign="top"><i>Timer</i></td>
<td valign="top"><i>Wait</i></td>
<td valign="top"><i>I/O</i></td>
<td valign="top"><i>Non-I/O</i></td>
</tr>

<tr>
<td valign="top"><b>Initial Number of Threads</b></td>
<td valign="top">Always 1</td>
<td valign="top">1</td>
<td valign="top">0</td>
<td valign="top">0</td>
</tr>

<tr>
<td valign="top"><b>When a Thread Is Created</b></td>
<td valign="top">When first thread pool timer function is called</td>
<td valign="top">One thread for every 63 registered objects</td>
<td valign="top" colspan="2">The system uses heuristics, but here are some factors that affect the creation of a thread:
<ul>
<p><li>Some time (in seconds) has passed since the threadçˆ“as added</li></p>
<p><li>The WT_EXECUTELONGFUNCTION flag is used </li></p>
<p><li>The number of queued work items exceeds a certain threshold</li></p>
</ul></td>
</tr>

<tr>
<td valign="top"><b>When a Thread is Destroyed</b></td>
<td valign="top">When a process terminates</td>
<td valign="top">When the number of registered wait objects is 0</td>
<td valign="top">When the thread has no pending I/O requests and has been idle for a threshold period (about a minute)</td>
<td valign="top">When the thread is idle for a threshold period (about a minute)</td>
</tr>

<tr>
<td valign="top"><b>How a Thread Waits</b></td>
<td valign="top">Alertable</td>
<td valign="top"><i>WaitForMultipleObjectsEx</i></td>
<td valign="top">Alertable</td>
<td valign="top"><i>GetQueuedCompletionStatus</i></td>
</tr>

<tr>
<td valign="top"><b>What Wakes Up a Thread</b></td>
<td valign="top">Waitable timer is signaled queuing a user APC</td>
<td valign="top">Kernal object becomes signaled</td>
<td valign="top">Queued user APC or completed I/O request</td>
<td valign="top">Posted completion status or completed I/O request (The completion port allows at most 2 * number of CPUs threads to run concurrently)</td>
</tr>
</table>
</p>

<p>When a process initializes, it doesn't have any of the overhead
associated with these components. However, as soon as one of the new
thread pooling functions is called, some of the components are created
for the process and some stay around until the process terminates. As
you can see, the overhead of using the thread pool is not trivial:
quite a few threads and internal data structures become part of your
process. So you must carefully consider what the thread pool will and
won't do for you: don't just blindly use these functions.</p>

<p>OK, enough with the disclaimers. Let's see what this stuff
does.</p>

</BODY>
</HTML>






