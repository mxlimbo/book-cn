<HTML>
<HEAD>
<TITLE>Implementing a Critical Section: The Optex</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch10a.htm">[Previous]</A> <A HREF="ch10c.htm">[Next]</A><P>

<A NAME="144"><H1>Implementing a Critical Section: The Optex</H1></A>

<p>Critical sections have always fascinated me. After all, if  they're just user-mode objects, why can't I implement them myself? Why do I need operating system support to make critical
sections work? Also, if I write my own critical section, I might want to add features to it and enhance it in some way. At the very least, I would want it to track which thread currently owns the resource. A critical section implementation that did so would help me to resolve deadlock problems in my code; I could use a debugger to discover which thread was not releasing the resource.</p>

<p>So without further ado, let's take a look at how critical
sections are implemented. I keep saying that critical sections are
user-mode objects. In reality, this isn't 100 percent true. If a
thread attempts to enter a critical section that is owned by another
thread, the thread is placed in a wait state. The only way for it to
enter a wait state is for it to transition from user mode to kernel
mode. A user-mode thread can stop doing useful work by spinning, but
that is hardly an efficient wait state, hence you should avoid it.</p>

<p>So critical sections must include some kernel object that can cause
a thread to enter an efficient wait state. A critical section is fast
because this kernel object is used only if there is contention for the
critical section. As long as threads can immediately gain access to a
resource, use the resource, and release it without contention from
other threads, the kernel object is not used and the thread never
leaves user mode. In most applications, two (or more) threads rarely
contend for a critical section simultaneously.</p>

<p>The Optex.h and Optex.cpp files (shown in Figure 10-1) show my
implementation of a critical section. I call my critical section an <i>
optex</i> (which stands for <i>optimized mutex</i>) and have
implemented it as a C++ class. Once you understand this code,
you'll see why critical sections are faster than mutex kernel
objects.</p>

<p>Since I implement my own critical section, I can add useful features
to it. For instance, my COptex class allows threads in different
processes to synchronize themselves on it. This is a fantastic
addition&#8212;now I have a high-performance mechanism for communicating
between threads in different processes.</p>

<p>To use my optex, you simply declare a COptex object. There are three
possible constructors for this object:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
COptex::(DWORDç‡¿wSpinCount