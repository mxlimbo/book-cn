<HTML>
<HEAD>
<TITLE>Protection Attributes</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch13f.htm">[Previous]</A> <A HREF="ch13h.htm">[Next]</A><P>

<A NAME="176"><H1>Protection Attributes</H1></A>

<p>Individual pages of physical storage allocated can be assigned
different protection attributes. The protection attributes are shown in
the following table.</p>

<p><table cellpadding=5 width="95%"><tr>
<th>Protection Attribute</th>
<th>Description</th>
</tr><tr>
<td valign="top">PAGE_NOACCESS</td>
<td valign="top">Attempts to read from, write to, or execute code in
this page raise an access violation.</td>
</tr><tr>
<td valign="top">PAGE_READONLY</td>
<td valign="top">Attempts to write to or execute code in this page
raise an access violation.</td>
</tr><tr>
<td valign="top">PAGE_READWRITE</td>
<td valign="top">Attempts to execute code in this page raise an access
violation.</td>
</tr><tr>
<td valign="top">PAGE_EXECUTE</td>
<td valign="top">Attempts to read or write memory in this page raise an
access violation.</td>
</tr><tr>
<td valign="top">PAGE_EXECUTE_READ</td>
<td valign="top">Attempts to write to memory in this page raise an
access violation.</td>
</tr><tr>
<td valign="top">PAGE_EXECUTE_READWRITE</td>
<td valign="top">There is nothing you can do to this page to
raise an access violation.</td>
</tr><tr>
<td valign="top">PAGE_WRITECOPY</td>
<td valign="top">Attempts to execute code in this page raise an access
violation. Attempts to write to memory in this page cause the system to
give the process its own private copy of the page (backed by the paging
file).</td>
</tr><tr>
<td valign="top">PAGE_EXECUTE_WRITECOPY</td>
<td valign="top">There is nothing you can do to this region to
raise an access violation. Attempts to write to memory in this page
cause the system to give the process its own private copy of the page
(backed by the paging file).</td>
</tr></table></p>

<p>The <i>x</i>86 and Alpha CPUs do not support the execute protection
attribute, although the operating system software does support this
attribute. These CPUs treat read access as execute access. This means
that if you assign PAGE_ 
EXECUTE protection to memory, that memory will also have read
privileges. Of course, you should not rely on this behavior because
Windows implementations on other CPUs might very well treat execute
protection as execute-only protection.</p>

<p><div class="note"><blockquote><b>Windows 98</b><HR>
Windows 98 supports only the PAGE_NOACCESS, PAGE_READONLY, and
PAGE_READWRITE protection attributes.
</blockquote></div></p>

<A NAME="177"><H2>Copy-On-Write Access</H2></A>

<p>The protection attributes listed in the preceding table should all
be fairly self-explanatory except the last two: PAGE_WRITECOPY and
PAGE_EXECUTE_ 
WRITECOPY. These attributes exist to conserve RAM usage and paging file
space. Windows supports a mechanism that allows two or more processes
to share a single block of storage. So, if 10 instances of Notepad are
running, all instances share the application's code and data pages.
Having all instances share the same storage pages greatly improves the
performance of the system&#8212;but this does require that all instances
consider the storage to be read-only or execute-only. If a thread in
one instance wrote to the storage modifying it, the storage as seen by
the other instances would also be modified, causing total chaos.</p>

<p>To prevent this chaos, <i>copy-on-write</i> protection is assigned
to the shared block of storage by the operating system. When an .exe or
.dll module is mapped into an address space, the system calculates how
many pages are writable. (Usually, the pages containing code are marked
as PAGE_EXECUTE_READ while the pages containing data are marked
PAGE_READWRITE.) Then, the system allocates storage from the paging
file to accommodate these writable pages. This paging file storage is
not used unless the module's writable pages are actually written
to.</p>

<p>When a thread in one process attempts to write to a shared block,
the system intervenes and performs the following steps:</p>

<ol>
<p><li>  The system finds a free page of memory in RAM. Note that this
free page will be backed by one of the pages allocated in the paging
file when the module was first mapped into the process's address
space. Since the system allocated all the potentially required paging
file space when the module was first mapped, this step cannot possibly
fail.</li></p>

<p><li>  The system copies the contents of the page attempting to be
modified to the free page found in step 1. This free page will be
assigned either PAGE_READWRITE or PAGE_EXECUTE_READWRITE protection.
The original page's protection and data does not change at
all.</li></p>

<p><li>  The system then updates the process's page tables so that
the accessed virtual address now translates to the new page of
RAM.</li></p>
</ol>

<p>After the system has performed these steps, the process can access
its very own private instance of this page of storage. In <A HREF="ch17a.htm">Chapter 17</A>,
sharing storage and copy-on-write protection are covered in much more
detail.</p>

<p>In addition, you should not pass either PAGE_WRITECOPY or PAGE_ 
EXECUTE_WRITECOPY when you are reserving address space or committing
physical storage using the <i>VirtualAlloc</i> function. Doing so will
cause the call to <i>VirtualAlloc</i> to fail; calling <i>
GetLastError</i> returns ERROR_ 
INVALID_PARAMETER. These two attributes are used by the operating
system when it maps .exe and DLL file images.</p>

<p><div class="note"><blockquote><b>Windows 98</b><HR>
Windows 98 does not support copy-on-write protection. When Windows 98
sees that copy-on-write protection has been requested, it immediately
makes copies of the data instead of waiting for an attempted memory
write.
</blockquote></div></p>

<A NAME="178"><H2>Special Access Protection Attribute Flags</H2></A>

<p>In addition to the protection attributes already discussed, there
are three protection attribute flags: PAGE_NOCACHE, PAGE_WRITECOMBINE,
and PAGE_GUARD. You use these three flags by bitwise ORing them with
any of the protection attributes except PAGE_NOACCESS.</p>

<p>The first of these protection attribute flags, PAGE_NOCACHE,
disables caching of the committed pages. This flag is not recommended
for general use&#8212;it exists mostly for hardware device driver
developers who need to manipulate memory buffers.</p>

<p>The second protection attribute flag, PAGE_WRITECOMBINE, is also for
device driver developers. It allows multiple writes to a single device
to be combined together in order to improve performance.</p>

<p>The last protection attribute flag, PAGE_GUARD, allows an
application to receive a notification (via an exception) when a byte on
a page has been written to. There are some clever uses for this flag.
Windows 2000 uses this flag when it creates a thread's stack. See
the section &quot;<A HREF="ch16a.htm#204">A Thread's Stack</A>&quot; in <A HREF="ch16a.htm">Chapter 16</A> for more
information about this flag.</p>

<p><div class="note"><blockquote><b>Windows 98</b><HR>
Windows 98 ignores the PAGE_NOCACHE, PAGE_WRITECOMBINE, and PAGE_GUARD
protection attribute flags.
</blockquote></div></p>

</BODY>
</HTML>






