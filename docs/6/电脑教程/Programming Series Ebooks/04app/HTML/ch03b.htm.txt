<HTML>
<HEAD>
<TITLE>What Is a Kernel Object?</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch03a.htm">[Previous]</A> <A HREF="ch03c.htm">[Next]</A><P>

<A NAME="26"><H1>What Is a Kernel Object?</H1></A>

<p>As a Windows software developer, you create, open, and manipulate
kernel objects regularly. The system creates and manipulates several
types of kernel objects, such as access token objects, event objects,
file objects, file-mapping objects, I/O completion port objects, job
objects, mailslot objects, mutex objects, pipe objects, process
objects, semaphore objects, thread objects, and waitable timer objects.
These objects are created by calling various functions. For example,
the <i>CreateFileMapping</i> function causes the system to create a
file-mapping object. Each kernel object is simply a memory block
allocated by the kernel and is accessible only by the kernel. This
memory block is a data structure whose members maintain information
about the object. Some members (security descriptor, usage count, and
so on) are the same across all object types, but most are specific to a
particular object type. For example, a process object has a process ID,
a base priority, and an exit code, whereas a file object has a byte
offset, a sharing mode, and an open mode.</p>

<p>Because the kernel object data structures are accessible only by the
kernel, it is impossible for an application to locate these data
structures in memory and directly alter their contents. Microsoft
enforces this restriction deliberately to ensure that the kernel object
structures maintain a consistent state. This restriction also allows
Microsoft to add, remove, or change the members in these structures
without breaking any applications.</p>

<p>If we cannot alter these structures directly, how do our
applications manipulate these kernel objects? The answer is that
Windows offers a set of functions that manipulate these structures in
well-defined ways. These kernel objects are always accessible via these
functions. When you call a function that creates a kernel object, the
function returns a handle that identifies the object. Think of this
handle as an opaque value that can be used by any thread in your
process. You pass this handle to the various Windows functions so that
the system knows which kernel object you want to manipulate. We'll
talk a lot more about these handles later in this chapter.</p>

<p>To make the operating system robust, these handle values are
process-relative. So if you were to pass this handle value to a thread
in another process (using some form of interprocess communication), the
calls that this other process would make using your process's
handle value would fail. In the section &quot;<A HREF="ch03d.htm#32">Sharing Kernel ObjectsAcross Process Boundaries</A>&quot; (at the end of this chapter), we'll
look at three mechanisms that allow multiple processes to successfully
share a single kernel object.</p>

<A NAME="27"><H2>Usage Counting</H2></A>

<p>Kernel objects are owned by the kernel, not by a process. In other
words, if your process calls a function that creates a kernel object
and then your process terminates, the kernel object is not necessarily
destroyed. Under most circumstances, the object will be destroyed; but
if another process is using the kernel object your process created, the
kernel knows not to destroy the object until the other process has
stopped using it. The important thing to remember is that a kernel
object can outlive the process that created it.</p>

<p>The kernel knows how many processes are using a particular kernel
object because each object contains a usage count. The usage count is
one of the data members common to all kernel object types. When an
object is first created, its usage count is set to 1. Then when another
process gains access to an existing kernel object, the usage count is
incremented. When a process terminates, the kernel automatically
decrements the usage count for all the kernel objects the process still
has open. If the object's usage count goes to 0, the kernel
destroys the object. This ensures that no kernel object will remain in
the system if no processes are referencing the object.</p>

<A NAME="28"><H2>Security</H2></A>

<p>Kernel objects can be protected with a security descriptor. A
security descriptor describes who created the object, who can gain
access to or use the object, and who is denied access to the object.
Security descriptors are usually used when writing server applications;
you can ignore this feature of kernel objects if you are writing
client-side applications.</p>

<p><div class="note"><blockquote><b>Windows 98</b><HR>
Windows 98 is not designed for use as a server-side operating
system. For this reason, Microsoft did not implement security features
in Windows 98. However, if you are designing software for Windows 98
today, you should still be aware of security issues and use the proper
access information when implementing your application to ensure that it
runs correctly on Microsoft Windows 2000.
</blockquote></div></p>

<p>Almost all functions that create kernel objects have a pointer to a
SECURITY_ATTRIBUTES structure as an argument, as shown here with the
<i>CreateFileMapping</i> function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
HANDLE燙reateFileMapping(
牋燞ANDLE爃File,
牋燩SECURITY_ATTRIBUTES爌sa,