<HTML>
<HEAD>
<TITLE>Scenario 3: Call Functions When Single Kernel Objects Become Signaled</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch11c.htm">[Previous]</A> <A HREF="ch11e.htm">[Next]</A><P>

<A NAME="156"><H1>Scenario 3: Call Functions When Single Kernel Objects Become Signaled</H1></A>

<p>Microsoft discovered that many applications spawn threads simply to
wait for a kernel object to become signaled. Once the object is
signaled, the thread posts some sort of notification to another thread
and then loops back, waiting for the object to signal again. Some
developers even write code in which several threads each wait on a
single object. This is incredibly wasteful of system resources. Sure,
there is a lot less overhead involved in creating threads compared with
creating processes, but threads are not free. Each thread has a stack,
and a lot of CPU instructions are required to create and destroy
threads. You should always try to minimize this.</p>

<p>If you want to register a work item to be executed when a kernel object
is signaled, you can use another new thread pooling function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL燫egisterWaitForSingleObject(
牋燩HANDLE爌hNewWaitObject,