<html>
<head>
<title>Chapter 6 -- Thread Basics</title>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<A HREF="ch05g.htm">[Previous]</A> <A HREF="ch06b.htm">[Next]</A><P>

<font size="+3">Chapter 6</font>

<A NAME="74"><H1>Thread Basics</H1></A>

<p>It is critical that you understand threads because every process
requires at least one thread. In this chapter, I'll go into much
more detail about threads. In particular, I'll explain how
processes and threads differ and what responsibility each has. I'll
also explain how the system uses thread kernel objects to manage the
threads. Like process kernel objects, thread kernel objects have
properties, and we'll examine many of the functions that are
available for querying and changing these properties. I'll also
examine the functions you can use to create or spawn additional threads
in a process.</p>

<p>In <A HREF="ch04a.htm">Chapter 4</A>, we discussed how a process actually consists of two
components: a process kernel object and an address space. Similarly, a
thread consists of two components:</p>

<ul>
<p><li>A kernel object that the operating system uses to manage the
thread. The kernel object is also where the system keeps statistical
information about the thread.</li></p>

<p><li>A thread stack that maintains all the function parameters and
local variables required as the thread executes code. (In <A HREF="ch16a.htm">Chapter 16</A>,
I'll go into detail about how the system manages a thread's
stack.)</li></p>
</ul>


<p>I said in <A HREF="ch04a.htm">Chapter 4</A> that processes are inert. A process never
executes anything; it is simply a container for threads. Threads are
always created in the context of some process and live their entire
life within that process. What this really means is that the thread
executes code within its process's address space and manipulates
data within its process's address space. So if you have two or more
threads running in the context of a single process, the threads share a
single address space. The threads can execute the same code and
manipulate the same data. Threads can also share kernel object handles
because the handle table exists for each process, not each thread.</p>

<p>As you can see, processes use a lot more system resources than
threads do. The reason for this is the address space. Creating a
virtual address space for a process requires a lot of system resources.
A lot of record keeping takes place in the system, and this requires a
lot of memory. Also, since .exe and .dll files get loaded into an
address space, file resources are required as well. A thread, on the
other hand, uses significantly fewer system resources. In fact, a
thread has just a kernel object and a stack; little record keeping is
involved, and little memory is required.</p>

<p>Because threads require less overhead than processes, you should
always try to solve your programming problems using additional threads
and avoid creating new processes. However, don't take this
recommendation as law. Many designs are better implemented using
multiple processes. You should be aware of the tradeoffs, and
experience will guide you.</p>

<p>Before we get into the nitty-gritty details of threads, let's
spend a little time discussing how to appropriately use threads in your
application's architecture.</p>

</BODY>
</HTML>






