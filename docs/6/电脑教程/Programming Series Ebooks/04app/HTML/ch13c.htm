<HTML>
<HEAD>
<TITLE>How a Virtual Address Space Is Partitioned</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch13b.htm">[Previous]</A> <A HREF="ch13d.htm">[Next]</A><P>

<A NAME="163"><H1>How a Virtual Address Space Is Partitioned</H1></A>

<p>Each process's virtual address space is split into partitions.
The address space is partitioned based on the underlying implementation
of the operating system. Partitions vary slightly among the different
Windows kernels. Table 13-1 shows how each platform partitions a
process's address space.</p>

<p>As you can see, the 32-bit Windows 2000 kernel and 64-bit Windows
2000 kernel have nearly identical partitions; what differs are the
partition sizes and locations. On the other hand, you can see that the
partitions under the Windows 98 kernel are rather different. Let's
examine how the system uses each of these partitions.</p>

<P><B>Table 13-1.</B> <I>How a process's address space is partitioned</I></p>

<p><table cellpadding=5 width="95%"><tr>
<th>Partition</th>
<th>32-Bit Windows 2000<br>(<I>x</I>86 and Alpha)</th>
<th>32-Bit Windows 2000<br>(<I>x</I>86 w/3 GB User-Mode)</th>
<th>64-Bit Windows 2000<BR>(Alpha and IA-64)</th>
<th>Windows 98</th>
</tr><tr>
<td valign="top">NULL-Pointer Assignment</td>
<td valign="top">0x00000000<br>0x0000FFFF</td>
<td valign="top">0x00000000<br>0x0000FFFF</td>
<td valign="top">0x00000000'00000000<br>0x00000000'0000FFFF</td>
<td valign="top">0x00000000<BR>0x00000FFF</td>
</tr><tr>
<td valign="top">DOS/16-bit Windows Application Compatibility</td>
<td valign="top">NA</td>
<td valign="top">NA</td>
<td valign="top">NA</td>
<td valign="top">0x00001000<BR>0x003FFFFF</td>
</tr><tr>
<td valign="top">User-Mode</td>
<td valign="top">0x00010000<br>0x7FFEFFFF</td>
<td valign="top">0x00010000<br>0xBFFEFFFF</td>
<td valign="top">0x00000000'00010000<br>0x000003FF'FFFEFFFF</td>
<td valign="top">0x00400000<BR>0x7FFFFFFF</td>
</tr><tr>
<td valign="top">64-KB Off-Limits</td>
<td valign="top">0x7FFF0000<br>0x7FFFFFFF</td>
<td valign="top">0xBFFF0000<br>0xBFFFFFFF</td>
<td valign="top">0x000003FF'FFFF0000<br>0x000003FF'FFFFFFFF</td>
<td valign="top">NA</td>
</tr><tr>
<td valign="top">Shared Memory-Mapped File (MMF)</td>
<td valign="top">NA</td>
<td valign="top">NA</td>
<td valign="top">NA</td>
<td valign="top">0x80000000<BR>0xBFFFFFFF</td>
</tr><tr>
<td valign="top">Kernel-Mode</td>
<td valign="top">0x800000000<BR>0xFFFFFFFF</td>
<td valign="top">0xC0000000<BR>0xFFFFFFFF</td>
<td valign="top">0x00000400'00000000<BR>0xFFFFFFFF'FFFFFFFF</td>
<td valign="top">0xC0000000<BR>0xFFFFFFFF</td>
</tr></table></p>


<p><div class="note"><blockquote><b>NOTE</b><HR>
Microsoft is actively working on 64-bit Windows 2000. As I write this,
however, the system is still under development. You should use the
information in this book regarding 64-bit Windows 2000 to influence the
design and implementation of your current projects. However, be aware
that the details of what I describe in this chapter are quite likely to
change by the time 64-bit Windows 2000 ships. With respect to IA-64
(64-bit Intel Architecture) memory management, the specific virtual
address ranges for partitions and the system's page size are also
likely to change.
</blockquote></div></p>

<A NAME="164"><H2>Null-Pointer Assignment Partition (Windows 2000 and Windows 98)</H2></A>

<p>This partition of the process's address space, is set aside to
help programmers catch NULL-pointer assignments. If a thread in your
process attempts to read from or write to a memory address in this
partition, the CPU raises an access violation. Protecting this
partition is incredibly useful in helping to detect NULL-pointer
assignments.</p>

<p>Error checking is often not performed religiously in C/C++ programs.
For example, the following code performs no error checking:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
int* pnSomeInteger = (int*) malloc(sizeof(int));
*pnSomeInteger = 5;
</pre></td></tr></table></p>

<p>If <i>malloc</i> cannot find enough memory to satisfy the request,
it returns NULL. However, this code doesn't check for that
possibility&#8212;it assumes that the allocation was successful and
proceeds to access memory at address 0x00000000. Because this partition
of the address space is off-limits, a memory access violation occurs
and the process is terminated. This feature helps developers find bugs
in their applications.</p>

<A NAME="165"><H2>MS-DOS/16-Bit Windows Application Compatibility Partition (Windows 98 Only)</H2></A>

<p>This 4-MB region of the process's address space is required by
Windows 98 in order to maintain compatibility with MS-DOS and 16-bit
Windows applications. We should not attempt to read from or write to
this partition from our 32-bit Windows applications. Ideally, the CPU
should raise an access violation if a thread in our process touches
this memory, but for technical reasons, Microsoft was unable to guard
this 4 MB of address space.</p>

<p>In Windows 2000, 16-bit MS-DOS and 16-bit Windows applications run
in their own address space and cannot be affected by 32-bit
applications.</p>

<A NAME="166"><H2>User-Mode Partition (Windows 2000 and Windows 98)</H2></A>

<p>This partition is where the process's private (unshared) address
space resides. One process cannot read from, write to, or in any way
access another process's data residing in this partition. For all
applications, this partition is where the bulk of the process's
data is maintained. Because each process gets its own private, unshared
partition for data, applications are far less likely to be corrupted by
other applications, making the whole system more robust.</p>

<p><div class="note"><blockquote><b>Windows 2000</b><HR>
In Windows 2000, all .exe and DLL modules load in this area. Each process
might load these DLLs at a different address within this partition
(although this is very unlikely). The system also maps all
memory-mapped files accessible to this process within this
partition.</blockquote></div></p>

<p><div class="note"><blockquote><b>Windows 98</b><HR>
In Windows 98, the main Win32 system DLLs (Kernel32.dll, AdvAPI32.dll,
User32.dll, and GDI32.dll) load in the Shared Memory-Mapped File
Partition. The .exe and all other DLL modules load in this user-mode
partition. The shared DLLs will be at the same virtual address for all
processes, but the other DLLs can load these DLLs at different
addresses within the user-mode partition (although this is unlikely).
Also, in Windows 98, memory-mapped files never appear in the user-mode
partition.
</blockquote></div></p>

<p>When I first looked at my 32-bit process's address space, I was
surprised to see that the amount of usable address space was less than
half of my process's overall address space. After all, does the
kernel-mode partition really need the top half of the address space?
Actually, the answer is yes. The system needs this space for the kernel
code, device driver code, device I/O cache buffers, non-paged pool
allocations, process page tables, and so on. In fact, Microsoft is
squeezing the kernel into this 2-GB space. In 64-bit Windows 2000, the
kernel finally gets the room it truly needs.</p>

<A NAME="167"><h3>Getting a 3-GB User-Mode Partition in <i>x</i>86 Windows 2000</h3></A>
<p>Over the years, there has been a large outcry from developers for a
larger user-mode address space. Microsoft, being attentive to this
need, has allowed the <i>x</i>86 version of Windows 2000 Advanced
Server and Windows 2000 Data Center to increase the user-mode partition
to 3 GB. To have all processes use a 3-GB user-mode partition and a
1-GB kernel-mode partition, you need to append the /3GB switch to the
desired entry in your system's BOOT.INI file. The &quot;32Bit
Windows 2000 (x86 w/3GB User-mode)&quot; column in Table 13-1 shows how
the address space looks when the /3GB switch is used.</p>

<p>Before Microsoft added the /3GB switch, an application could never
see a memory pointer where the high bit was set. Some creative
developers took it upon themselves to use this high bit as a flag that
had meaning only to their applications. Then when the application
accessed the memory address, code executed that cleared the high bit of
the pointer before the memory address was used. Well, as you can
imagine, when an application runs in a 3-GB user-mode environment, the
application fails in a blaze of fire.</p>

<p>Microsoft had to create a solution that allowed this application to
work in a 3-GB environment. When the system is about to run an
application, it checks to see if the application was linked with the
/LARGEADDRESSAWARE linker switch. If so, the application is claiming
that it does not do anything funny with memory addresses and is fully
prepared to take advantage of a 3-GB user-mode address space. On the
other hand, if the application was not linked with the
/LARGEADDRESSAWARE switch, the operating system reserves the 1-GB area
between 0x80000000 and 0xBFFFFFFF. This prevents any memory allocations
from being created at a memory address whose high bit is set.</p>

<p>Note that the kernel was squeezed tightly into a 2-GB partition.
When using the /3GB switch, the kernel is barely making it into a 1-GB
partition. Using the /3GB switch reduces the number of threads, stacks,
and other resources that the system can create. In addition, the system
can only use a maximum of 16 GB of RAM vs. the normal maximum of 64 GB
because there isn't enough virtual address space in kernel mode to
manage the additional RAM.</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>
An executable's LARGEADDRESSAWARE flag is checked when the operating
system creates the process's address space. The system ignores this
flag for DLLs. DLLs <i>must</i> be written to behave correctly in a
3-GB user-mode partition or their behavior is undefined.
</blockquote></div></p>

<A NAME="168"><H3>Getting a 2-GB User-Mode Partition in 64-bit Windows 2000</H3></A>

<p>Microsoft realizes that many developers will want to port their
existing 32-bit applications to a 64-bit environment as quickly and
easily as possible. However, there is a lot of source code in which
pointers are assumed to be 32-bit values. Simply rebuilding the
application will cause pointer truncation errors and improper memory
accesses.</p>

<p>However, if the system could somehow guarantee that no memory
allocations would ever be made above 0x00000000'7FFFFFFF, the
application would work fine. Truncating a 64-bit address to a 32-bit
address when the high 33 bits are 0 causes no problem whatsoever. The
system can provide this guarantee by running the application in an <i>
address space sandbox</i> that limits a process's usable address
space to the bottom 2 GB.</p>

<p>By default, when you invoke a 64-bit application, the system
reserves all the user-mode address space starting at
0x0000000'80000000. This ensures that all memory allocations are
created in the bottom 2 GB of the 64-bit address space. This is the
address space sandbox. For most applications, this is more than enough
address space anyway. To allow a 64-bit application to access its full
4-TB (terabyte) user-mode partition, the application must be built
using the /LARGEADDRESSAWARE linker switch.</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>
An executable's LARGEADDRESSAWARE flag is checked when the operating
system creates the process's 64-bit address space. The system
ignores this flag for DLLs. DLLs <i>must</i> be written to behave
correctly in a full 4-TB user-mode partition or their behavior is
undefined.
</blockquote></div></p>

<A NAME="169"><H2>64-KB Off-Limits Partition (Windows 2000 Only)</H2></A>

<p>This 64-KB partition just above the user-mode partition is
off-limits, and any attempt to access memory in this partition causes
an access violation. Microsoft reserves this partition because doing so
makes implementing the operating system easier for Microsoft. When you
pass the address of a block of memory and its length to a Windows
function, the function validates the memory block before performing its
operation. You could easily imagine code like this (running on a 32-bit
Windows 2000 system):</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BYTE  bBuf[70000];
DWORD dwNumBytesWritten;
WriteProcessMemory(GetCurrentProcess(), (PVOID) 0x7FFEEE90, bBuf,
   sizeof(bBuf), &amp;dwNumBytesWritten); 
</pre></td></tr></table></p>

<p>For a function like <i>WriteProcessMemory</i>, the memory region
being written to is validated by kernel-mode code, which can
successfully access memory in the kernel-mode partition (addresses
above 0x80000000 on a 32-bit system). If there is memory at the
0x80000000 address, the above call will succeed in writing data to
memory that should be accessible only by kernel-mode code. To prevent
this while making the validation of such memory regions fast, Microsoft
chose to keep this partition always off-limits; any attempt to read
from or write to memory in this region will always cause an access
violation.</p>

<A NAME="170"><H2>Shared MMF Partition (Windows 98 Only)</H2></A>

<p>This 1-GB partition is where the system stores data that is shared
among all 32-bit processes. For example, the system dynamic-link
libraries&#8212;Kernel32.dll, AdvAPI32.dll, User32.dll, and
GDI32.dll&#8212;are all loaded in this address space partition, making
them easily available to all 32-bit processes simultaneously. These
DLLs are also loaded at the same memory address for every process. In
addition, the system maps all memory-mapped files in this partition.
Memory-mapped files are discussed in more detail in <A HREF="ch17a.htm">Chapter 17</A>.</p>

<A NAME="171"><H2>Kernel-Mode Partition (Windows 2000 and Windows 98)</H2></A>

<p>This partition is where the operating system's code resides. The
code for thread scheduling, memory management, file systems support,
networking support, and all device drivers is loaded in this partition.
Everything residing in this partition is shared among all processes. In
Windows 2000, these components are completely protected. If you attempt
to access memory addresses in this partition, your thread will raise an
access violation, causing the system to display a message box to the
user and killing your application. See Chapters 23, 24, and 25 for more
information about access violations and how to handle them.</p>

<p><div class="note"><blockquote><b>Windows 2000</b><HR>
In 64-bit Windows 2000, the 4-TB user-mode partition looks greatly out of
proportion to the 16,777,212-TB kernel-mode partition. It's not
that the kernel-mode partition requires all of this virtual address
space. It's just that a 64-bit address space is enormous and most
of that address space is unused. The system allows our applications to
use 4 TB and allows the kernel to use what it needs; the majority of
the kernel-mode partition is just not used. Fortunately, the system
does not require any internal data structures to maintain the unused
portions of the kernel-mode partition.
</blockquote></div></p>

<p><div class="note"><blockquote><b>Windows 98</b><HR>
Unfortunately, in Windows 98, the data in this partition is not
protected&#8212;any application can read from or write to this section,
potentially corrupting the operating system.
</blockquote></div></p>

</BODY>
</HTML>






