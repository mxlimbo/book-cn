<HTML>
<HEAD>
<TITLE>Resetting the Contents of Physical Storage </TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch15g.htm">[Previous]</A> <A HREF="ch15i.htm">[Next]</A><P>

<A NAME="200"><H1>Resetting the Contents of Physical Storage </H1></A>

<p>
<div class="note"><blockquote>
<b>WINDOWS 98</b><hr>
Windows 98 does not support the resetting of physical storage.
</blockquote></div>
</p>

<p>When you modify the contents of various pages of physical storage, the system tries to keep the changes in RAM as long as possible. However, while applications are running, a demand might be placed on your system's RAM as pages are being loaded from .exe files, DLL files, and/or the paging file. As the system looks for pages of RAM to satisfy recent load requests, the system will have to swap modified pages of RAM to the system's paging file.</p>
 
<p>Windows 2000 offers a feature that allows an application to improve its performance&#8212;the resetting of physical storage. Resetting storage means that you are telling the system that the data on one or more pages of storage is not modified. If the system is searching for a page of RAM and chooses a modified page, the system must write the page of RAM to the paging file. This operation is slow and hurts performance. For most applications, you want the system to preserve your modified
pages in the system's paging file.</p>
 
<p>However, certain applications use storage for short periods of time and then no longer require that the contents of that storage be preserved. To help performance, an application can tell the system not to preserve desired pages of storage in the system's paging file. This is basically a way for an application to tell the system that a data page has not been modified. So if the system chooses to use a page of RAM for another purpose, the page's contents don't have to be preserved in the paging file, thus increasing performance. An application resets storage by calling <i>VirtualAlloc,</i> passing the MEM_RESET flag in the third parameter.</p>
 
<p>If the pages referenced in the call to <i>VirtualAlloc</i> are in the paging file, the system discards them. The next time the application accesses the storage, new RAM pages that are first initialized to zeroes are used. If you reset pages that are currently in RAM, they are marked as not modified so that they will never be written to the paging file. Note that although the content of the RAM page is <i>not</i> zeroed, you should not continue to read from this page of storage. If the system doesn't need the page of RAM, it will contain the original contents. However, if the system needs the page of RAM, the system can take it. Then when you attempt to access the page's contents, the system will give you a new page that has been zeroed. Since you have no control over this behavior, you must assume that the
contents of the page are garbage after you reset the page.</p>
 
<p>Keep in mind a couple of additional things when you reset storage. First, when you call <i>VirtualAlloc</i>, the base address is usually rounded down to a page boundary and the number of bytes is rounded up to an integral number of pages. Rounding the base address and number of bytes this way would be very dangerous to do when resetting storage; therefore, <i>VirtualAlloc</i> rounds these values in the opposite
direction when you pass MEM_RESET. For example, let's say that you had the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
PINTçˆŒnData