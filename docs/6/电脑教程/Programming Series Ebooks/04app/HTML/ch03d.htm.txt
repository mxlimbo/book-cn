<HTML>
<HEAD>
<TITLE>Sharing Kernel Objects Across Process Boundaries</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch03c.htm">[Previous]</A> <A HREF="ch04a.htm">[Next]</A><P>

<A NAME="32"><H1>Sharing Kernel Objects Across Process Boundaries</H1></A>

<p>Frequently, threads running in different processes need to share
kernel objects. Here are some of the reasons why:</p>

<ul>
<p><li>File-mapping objects allow you to share blocks of data between
two processes running on a single machine.</li></p>

<p><li>Mailslots and named pipes allow applications to send blocks of
data between processes running on different machines connected to the
network.</li></p>

<p><li>Mutexes, semaphores, and events allow threads in different
processes to synchronize their continued execution, as in the case of
an application that needs to notify another application when it has
completed some task.</li></p>
</ul>

<p>Because kernel object handles are process-relative, performing these
tasks is difficult. However, Microsoft had several good reasons for
designing the handles to be process-relative. The most important reason
was robustness. If kernel object handles were system-wide values, one
process could easily obtain the handle to an object that another
process was using and wreak havoc on that process. Another reason for
process-relative handles is security. Kernel objects are protected with
security, and a process must request permission to manipulate an object
before attempting to manipulate it. The creator of the object can
prevent an unauthorized user from touching the object simply by denying
access to it.</p>

<p>In the following section, we'll look at the three different
mechanisms that allow processes to share kernel objects.</p>

<A NAME="33"><H2>Object Handle Inheritance</H2></A>

<p>Object handle inheritance can be used only when processes have a
parent-child relationship. In this scenario, one or more kernel object
handles are available to the parent process, and the parent decides to
spawn a child process, giving the child access to the parent's
kernel objects. For this type of inheritance to work, the parent
process must perform several steps.</p>

<p>First, when the parent process creates a kernel object, the parent
must indicate to the system that it wants the object's handle to be
inheritable. Keep in mind that although kernel object <i>handles</i>
are inheritable, kernel objects themselves are not.</p>

<p>To create an inheritable handle, the parent process must allocate
and initialize a SECURITY_ATTRIBUTES structure and pass the
structure's address to the specific <i>Create</i> function. The
following code creates a mutex object and returns an inheritable handle
to it:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
SECURITY_ATTRIBUTESÁàèa;
sa.nLength