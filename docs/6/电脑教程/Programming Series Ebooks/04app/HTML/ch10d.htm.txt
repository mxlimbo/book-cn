<HTML>
<HEAD>
<TITLE>The Single Writer/Multiple Reader Guard (SWMRG)</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch10c.htm">[Previous]</A> <A HREF="ch10e.htm">[Next]</A><P>

<A NAME="148"><H1>The Single Writer/Multiple Reader Guard (SWMRG)</H1></A>

<p>Many applications have a basic synchronization problem commonly
referred to as a single-writer/multiple-readers scenario. The problem
involves an arbitrary number of threads that attempt to access a shared
resource. Some of these threads (the writers) need to modify the
contents of the data, and some of the threads (the readers) need only
to read the data. Synchronization is necessary because of the following
four rules:</p>

<ol>
<p><li>When one thread is writing to the data, no other thread can
write to the data.</li></p>

<p><li>When one thread is writing to the data, no other thread can read
from the data.</li></p>

<p><li>When one thread is reading from the data, no other thread can
write to the data.</li></p>

<p><li>When one thread is reading from the data, other threads can also
read from the data.</li></p>
</ol>

<p>Let's look at this problem in the context of a database
application. Let's say we have five end users, all accessing the
same database. Two employees are entering records into the database,
and three employees are retrieving records from the database.</p>

<p>In this scenario, rule 1 is necessary because we certainly can't
have both Employee 1 and Employee 2 updating the same record at the
same time. If both employees attempt to modify the same record,
Employee 1's changes and Employee 2's changes might be made at
the same time, and the information in the record might become
corrupted.</p>

<p>Rule 2 prohibits an employee from accessing a record in the database if
another employee is updating that record. If this situation is not
prevented, Employee 4 might read the contents of a record while
Employee 1 is altering the same record. When Employee 4's computer
displays the record, the record will contain some of the old
information and some of the updated information&#8212;this is certainly
unacceptable. Rule 3 is needed to solve the same problem. The
difference in the wording of rules 2 and 3 prevents the situation
regardless of who gains access to the database record first&#8212;an
employee who is trying to write or an employee who is trying to
read.</p>

<p>Rule 4 exists for performance reasons. It makes sense that if no
employees are attempting to modify records in the database, the content
of the database is not changing and therefore any and all employees who
are simply retrieving records from the database should be allowed to do
so. It is also assumed that there are more readers than there are
writers.</p>

<p>OK, you have the gist of the problem. Now the question is, how do we
solve it?</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
<p>The code that I present here is new. Previously, I published solutions to
this problem that were criticized for two reasons. First, my previous
implementations were too slow because they were designed to be useful
in many scenarios. For example, they used more kernel objects so that
threads in different processes could synchronize their access to the
database. Of course, my implementation still worked even in a
single-process scenario, but the heavy use of kernel objects added a
great deal of overhead when all threads were running in a single
process. I must concede that the single-process case is probably much
more common.</p>

<p>The second criticism was that my implementation could
potentially lock out writer threads altogether. From the rules stated
previously, if a lot of reader threads accessed the
database, writer threads could never get access to the resource.</p>

<p>I have addressed both of these issues with the implementation I present
here. It avoids kernel objects as much as possible and uses a critical
section for most of the synchronization.</p></blockquote></div></p>

<p>To simplify things, I have encapsulated my solution in a C++ class,
called CSWMRG (which I pronounce &quot;swimerge&quot;); it stands for
single-writer/multiple-reader guard. The SWMRG.h and SWMRG.cpp files
(in Figure 10-3) show my implementation.</p>

<p>Using a CSWMRG couldn't be easier. You simply create an object of
the CSWMRG C++ class and then call the appropriate member functions as
your application dictates. There are only three methods in the C++
class (not including the constructor and destructor):</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
VOID燙SWMRG::WaitToRead();牋//燙all爐his爐o爂ain爏hared爎ead燼ccess.
VOID燙SWMRG::WaitToWrite();