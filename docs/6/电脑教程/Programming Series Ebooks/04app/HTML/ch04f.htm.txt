<HTML>
<HEAD>
<TITLE>Enumerating the Processes Running in the System</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch04e.htm">[Previous]</A> <A HREF="ch05a.htm">[Next]</A><P>

<A NAME="65"><H1>Enumerating the Processes Running in the System</H1></A>

<p>Many software developers try to write tools or utilities for Windows that require the set of running processes to be enumerated. The Windows API originally had no functions that enumerated the running processes. However, Windows NT has a constantly updating database called the Performance Data database. This database contains a ton of information
and is available through registry functions such as <i>RegQueryValueEx</i> with the HKEY_PERFORMANCE_DATA root key. Few Windows programmers know about the performance database for these reasons:</p>

<ul>
<p><li>It has no functions that are specific to it; it simply uses existing registry functions.</li></p>

<p><li>It is not available on Windows 95 and Windows 98.</li></p>

<p><li>The layout of information in the database is complex; many
developers avoid using it. This prevents knowledge of its existence from spreading by word of mouth.</li></p>
</ul>

<p>To make working with this database easier, Microsoft created a
Performance Data Helper set of functions (contained in PDH.dll). For more information about this library, search for Performance Data Helper in the Platform SDK documentation.</p>

<p>As I mentioned above, Windows 95 and 98 do not offer this performance database. Instead, they have their own set of functions to enumerate processes and information about them. These are in the ToolHelp API. For more information, search for the <i>Process32First</i> and <i>Process32Next</i> functions in the Platform SDK documentation.</p>

<p>To make things more fun, Microsoft's Windows NT team, which doesn't like the ToolHelp functions, did not add them to Windows
NT. Instead, they produced their own Process Status functions to
enumerate processes (contained in PSAPI.dll). For more information, search for the <i>EnumProcesses</i> function in the Platform SDK documentation.</p>

<p>Microsoft might appear to be making life difficult for tool and utility developers, but I'm happy to report that it has added the ToolHelp functions to Windows 2000. Finally, developers have a way to write tools and utilities that have common source code for Windows 95, Windows 98, and Windows 2000!</p>

<A NAME="66"><H2>The Process Information Sample Application</H2></A>

<p>The ProcessInfo application, &quot;04 ProcessInfo.exe&quot;(listed in Figure 4-6), shows how to use the ToolHelp functions to produce a very useful utility. The source code and resource files for the application are in the 04ProcessInfo directory on the companion CD-ROM. When you start the program, the window shown in Figure 4-4 appears.</p>

<p>
<A HREF="javascript:fullSize('F04si04x.htm')"> <img src="images/F04si04.JPG" width=404 height=344 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><b>Figure 4-4.</b> <i>ProcessInfo in action</i><!-- /CAPTION -->
</p>

<p>ProcessInfo first enumerates the set of processes currently running and places each process's name and ID in the top combo box. Then the first process is selected and information about that process is shown in the large read-only edit control. As you can see, the process's ID is shown along with its parent process's ID, the priority class of the process, and the number of threads currently running in the context of the process. Much of the information is beyond the scope of this chapter but will be discussed in later chapters.</p>

<p>When you look at the process list, the VMMap menu item is available. (This item is disabled when you look at the module information.) Selecting the VMMap menu item causes the VMMap sample application (discussed in <A HREF="ch14a.htm">Chapter14</A>) to run. This application walks the address space of the selected process.</p>

<p>The module information portion shows the list of modules
(executables and DLLs) that are mapped into the process's address
space. A fixed module is one that was implicitly loaded when the
process initialized. For explicitly loaded DLLs, the DLL's usage
count is shown. The second field shows the memory address where the module is mapped. If the module is not mapped at its preferred base address, the preferred base address also appears in parentheses. The third field shows the size of the module in bytes, and finally, the full pathname of the module is displayed. The thread information portion shows the set of threads currently running in the context of this process. Each thread's ID and priority is shown.</p>

<p>In addition to the process information, you can choose the Modules! menu item. This causes ProcessInfo to enumerate the set of modules currently loaded throughout the system and places each module's name in the top combo box. Then ProcessInfo selects the first module and displays information about it, as Figure 4-5 shows.</p>

<p>
<A HREF="javascript:fullSize('F04si05x.htm')"> <img src="images/F04si05.JPG" width=404 height=344 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><b>Figure 4-5.</b> <i>ProcessInfo showing all processes that have User32.dll loaded in their address space</i><!-- /CAPTION -->
</p>

<p>When you use the ProcessInfo utility in this way, you can easily determine which processes are using a particular module. As you can see, the module's full pathname is shown at the top. The Process Information section then shows the list of processes that contain the module. In addition to each process's ID and name, the address where the module is loaded in each process is shown.</p>

<p>Basically, all of the information displayed by the ProcessInfo application is produced by calling the various ToolHelp functions. To make working with the ToolHelp functions a little easier, I created a CToolhelp C++ class (contained in the Toolhelp.h file). This C++ class encapsulates a ToolHelp snapshot and makes calling the other ToolHelp functions a bit easier.</p>

<p>The <i>GetModulePreferredBaseAddr</i> function inside ProcessInfo.cpp is particularly interesting:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
PVOID燝etModulePreferredBaseAddr(
牋燚WORD燿wProcessId,