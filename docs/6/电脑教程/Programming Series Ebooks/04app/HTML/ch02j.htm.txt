<HTML>
<HEAD>
<TITLE>Making Your Application ANSI- and Unicode-Ready</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch02i.htm">[Previous]</A> <A HREF="ch03a.htm">[Next]</A><P>

<A NAME="20"><H1>Making Your Application ANSI- and Unicode-Ready</H1></A>

<p>It's a good idea to start converting your application to be
Unicode-ready even if you don't plan to use Unicode right away.
Here are the basic guidelines you should follow:</p>

<ul>
<p><li>Start thinking of text strings as arrays of characters, not as
arrays of <i>char</i>s or arrays of bytes.</li></p>

<p><li>Use generic data types (such as TCHAR and PTSTR) for text
characters and strings.</li></p>

<p><li>Use explicit data types (such as BYTE and PBYTE) for bytes, byte
pointers, and data buffers.</li></p>

<p><li>Use the TEXT macro for literal characters and strings.</li></p>

<p><li>Perform global replaces. (For example, replace PSTR with
PTSTR.)</li></p>

<p><li>Modify string arithmetic problems. For example, functions usually
expect you to pass a buffer's size in characters, not bytes. This
means that you should not pass <i>sizeof(szBuffer)</i> but should
instead pass <i>(sizeof(szBuffer) / sizeof(TCHAR))</i>. Also, if you
need to allocate a block of memory for a string and you have the number
of characters in the string, remember that you allocate memory in
bytes. This means that you must call <i>malloc(nCharacters *
sizeof(TCHAR))</i> and not call <i>malloc(nCharacters)</i>. Of all the
guidelines I've just listed, this is the most difficult one to
remember, and the compiler offers no warnings or errors if you make a
mistake.</li></p>
</ul>

<p>When I was developing the sample programs for the first edition of
this book, I originally wrote them so that they compiled natively as
ANSI-only. Then, when I began to write this chapter, I knew that I
wanted to encourage the use of Unicode and was going to create sample
programs to demonstrate how easy it is to create programs that can be
compiled in both Unicode and ANSI. I decided that the best course of
action was to convert all the sample programs in the book so that they
could be compiled in both Unicode and ANSI.</p>

<p>I converted all the programs in about four hours, which isn't
bad, considering that I didn't have any prior conversion
experience.</p>

<A NAME="21"><H2>Windows String Functions</H2></A>

<p>Windows also offers a set of functions for manipulating Unicode
strings, as described in the following table.</p>

<p><table cellpadding=5 width="95%"><tr>
<th>Function</th>
<th>Description</th>
</tr><tr>
<td valign="top"><i>lstrcat</i></td>
<td valign="top">Concatenates one string onto the end of another</td>
</tr><tr>
<td valign="top"><i>lstrcmp</i></td>
<td valign="top">Performs case-sensitive comparison of two strings</td>
</tr><tr>
<td valign="top"><i>lstrcmpi</i></td>
<td valign="top">Performs case-insensitive comparison of two strings</td>
</tr><tr>
<td valign="top"><i>lstrcpy</i></td>
<td valign="top">Copies one string to another location in memory</td>
</tr><tr>
<td valign="top"><i>lstrlen</i></td>
<td valign="top">Returns the length of a string in characters</td>
</tr></table></p>

<p>These functions are implemented as macros that call either the
Unicode version of the function or the ANSI version of the function,
depending on whether UNICODE is defined when the source module is
compiled. For example, if UNICODE is not defined, <i>lstrcat</i> will
expand to <i>lstrcatA</i>. If UNICODE is defined, <i>lstrcat</i> will
expand to <i>lstrcatW</i>.</p>

<p>Two string functions, <i>lstrcmp</i> and <i>lstrcmpi</i>, behave
differently from their equivalent C run-time functions. The C run-time
functions <i>strcmp</i>, <i>strcmpi</i>, <i>wcscmp</i>, and <i>
wcscmpi</i> simply compare the values of the code points in the
strings; that is, the functions ignore the meaning of the actual
characters and simply check the numeric value of each character in the
first string with the numeric value of the character in the second
string. The Windows functions <i>lstrcmp</i> and <i>lstrcmpi</i>, on
the other hand, are implemented as calls to the Windows function <i>
CompareString</i>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
int燙ompareString(
牋燣CID爈cid,