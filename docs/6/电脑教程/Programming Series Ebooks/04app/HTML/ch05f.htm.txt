<HTML>
<HEAD>
<TITLE>Job Notifications</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch05e.htm">[Previous]</A> <A HREF="ch05g.htm">[Next]</A><P>

<A NAME="72"><H1>Job Notifications</H1></A>

<p>At this point, you certainly know the basics about job objects; the
only thing left to cover is notifications. For example, wouldn't
you like to know when all of the processes in the job terminate or if
all the allotted CPU time has expired? Or maybe you'd like to know
when a new process is spawned within a job or when a process in the job
terminates. If you don't care about these notifications&#8212;and
many applications won't care&#8212;working with jobs is as easy as
what I've already described. If you do care about these events, you
have a little more to do.</p> 
<p>If all you care about is whether all the allotted CPU time has expired,
you can easily get this notification. Job objects are nonsignaled while
the processes in the job have not used up the allotted CPU time. Once
all the allotted CPU time has been used, Windows forcibly kills all the
processes in the job and signals the job object. You can easily trap
this event by calling <i>WaitForSingleObject</i> (or a similar
function). Incidentally, you can reset the job object back to the
nonsignaled state later by calling <i>SetInformationJobObject</i> and
granting the job more CPU time. </p>
<p>When I first started working with jobs, it seemed to me that the job
object should be signaled when no processes are running within it.
After all, process and thread objects are signaled when they stop
running; so it seemed that a job should be signaled when it stops
running. In this way, you could easily determine when a job had run to
completion. However, Microsoft chose to signal the job when the
allotted time expires because that signals an error condition. Since
many jobs start off with one parent process that hangs around until all
its children are done, you can simply wait on the parent process's
handle to know when the entire job is finished. My <i>
StartRestrictedProcess</i> function shows how to determine when the
job's allotted time has expired or when the parent process in the
job has terminated. </p>
<p>Well, I've described how to get some simple notifications, but I
haven't explained what you need to do to get more
&quot;advanced&quot; notifications such as process
creation/termination. If you want these additional notifications, you
must put a lot more infrastructure into your application. In
particular, you must create an I/O completion port kernel object and
associate your job object or objects with the completion port. Then you
must have one or more threads that wait on the completion port for job
notifications to arrive so that they can be processed. </p>
<p>Once you create the I/O completion port, you associate a job with it by
calling <i>SetInformationJobObject</i>, as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
JOBOBJECT_ASSOCIATE_COMPLETION_PORT爅oacp;
joacp.CompletionKey牋=