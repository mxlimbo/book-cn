<HTML>
<HEAD>
<TITLE>Advanced Thread Synchronization</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch08c.htm">[Previous]</A> <A HREF="ch08e.htm">[Next]</A><P>

<A NAME="113"><H1>Advanced Thread Synchronization</H1></A>

<p>The interlocked family of functions is great when you need to
atomically modify a single value. You should definitely try them first.
But most real-life programming problems deal with data structures that
are far more complex than a single 32-bit or 64-bit value. To get
&quot;atomic&quot; access of more sophisticated data structures, you
must leave the interlocked functions behind and use some other features
offered by Windows.</p>

<p>In the previous section, I stressed that you should not use
spinlocks on uniprocessor machines and you should use them cautiously
even on multiprocessor machines. Again, the reason is that CPU time is
a terrible thing to waste. So we need a mechanism that allows our
thread to not waste CPU time while waiting to access a shared
resource.</p>

<p>When a thread wants to access a shared resource or be notified of
some &quot;special event,&quot; the thread must call an operating
system function, passing it parameters that indicate what the thread is
waiting for. If the operating system detects that the resource is
available or that the special event has occurred, the function returns
and the thread remains schedulable. (The thread might not execute right
away; it is schedulable and will be assigned to a CPU using the rules
described in the previous chapter.)</p>

<p>If the resource is unavailable or the special event hasn't yet
occurred, the system places the thread in a wait state, making the
thread unschedulable. This prevents the thread from wasting any CPU
time. While your thread is waiting, the system acts as an agent on your
thread's behalf. The system remembers what your thread wants and
automatically takes it out of the wait state when the resource becomes
available&#8212;the thread's execution is synchronized with the
special event.</p>

<p>As it turns out, most threads are almost always in a wait state.
And the system's power management kicks in when the system detects
that all threads are in a wait state for several minutes.</p>


<A NAME="114"><H2>A Technique to Avoid</H2></A>

<p>Without synchronization objects and the operating system's
ability to watch for special events, a thread would be forced to
synchronize itself with special events by using the technique that I am
about to demonstrate. However, because the operating system has
built-in support for thread synchronization, you should never use this
technique.</p>

<p>In this technique, one thread synchronizes itself with the
completion of a task in another thread by continuously polling the
state of a variable that is shared by or accessible to multiple
threads. The following code fragment illustrates this:</p>


<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
volatile燘OOL爂_fFinishedCalculation