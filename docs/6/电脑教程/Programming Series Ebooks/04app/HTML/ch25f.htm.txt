<HTML>
<HEAD>
<TITLE>Exceptions and the Debugger</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch25e.htm">[Previous]</A> <A HREF="ch25g.htm">[Next]</A><P>

<A NAME="344"><H1>Exceptions and the Debugger</H1></A>

<p>The Microsoft Visual C++ debugger has fantastic support for
debugging exceptions. When a process's thread raises an exception,
the operating system immediately notifies a debugger (if a debugger is
attached). This notification is called a <i>first-chance
notification</i>. Normally, the debugger responds to a first-chance
notification by telling the thread to search for exception filters. If
all of the exception filters return EXCEPTION_CONTINUE_SEARCH, the
operating system notifies the debugger again with a <i>last-chance
notification</i>. These two notifications exist in order to give the
software developer more control over debugging an exception.</p>

<p>You use the debugger's Exceptions dialog box (shown below) to 
tell the debugger how to react to first-chance exception notifications.</p>

<p>
<A HREF="javascript:fullSize('G25si03x.htm')"> <img src="images/G25si03.JPG" width=404 height=200 border=0 ALT="Click to view at full size."> </A>
</p>

<p>As you can see, the dialog box consists of a list of all the
system-defined exceptions. Each exception's 32-bit code is shown,
followed by a text description and the debugger's action. In the
window above, I have selected the access violation exception and
changed its action to Stop Always. Now, whenever a thread in the
debuggee raises an access violation, the debugger receives its
first-chance notification and displays a message box similar to the
following.</p>

<p>
<A HREF="javascript:fullSize('G25si04x.htm')"> <img src="images/G25si04.JPG" width=404 height=112 border=0 ALT="Click to view at full size."> </A>
</p>

<p>At this point, the thread has <i>not</i> had a chance to search for
exception filters. I can now place breakpoints in the code, check
variables, or examine the thread's call stack. No exception filters
have executed yet; the exception has just occurred. If I now use the
debugger to single-step through the code, I am prompted with the
following message box.</p>

<p>
<img src="images/G25si05.JPG" width=320 height=119 border=0>
</p>

<p>Clicking on Cancel returns you to the debugger. Clicking on No tells
the debuggee's thread to retry the CPU instruction that failed. For
most exceptions, retrying the instruction will just raise the exception
again and is not useful. However, for an exception raised with the <i>
RaiseException</i> function, this tells the thread to continue
executing as though the exception was never raised. Continuing in this
manner can be particularly useful for debugging C++ programs: it would
be as though a C++ <i>throw</i> statement never executed. C++ exception
handling is discussed more toward the end of this chapter.</p>

<p>Finally, clicking on Yes allows the debuggee's thread to search
for exception filters. If an exception filter is found that returns
EXCEPTION_EXECUTE_HANDLER or EXCEPTION_CONTINUE_EXECUTION, all is well and the
thread continues executing its code. However, if all filters return
EXCEPTION_CONTINUE_SEARCH, the debugger receives a last-chance
notification and displays a message box similar to the following.</p>

<p>
<A HREF="javascript:fullSize('G25si06x.htm')"> <img src="images/G25si06.JPG" width=404 height=113 border=0 ALT="Click to view at full size."> </A>
</p>

<p>At this point, you must debug the application or terminate it.</p>

<p>I have just shown you what happens if the debugger's action is set
to Stop Always. However, for most exceptions, Stop If Not Handled is
the default action. So, if a thread in the debuggee raises an
exception, the debugger receives a first-chance notification. If the
action is set to Stop If Not Handled, the debugger simply displays a
string in the debugger's Output window indicating that it received
the notification.</p>

<p>
<A HREF="javascript:fullSize('G25si07x.htm')"> <img src="images/G25si07.JPG" width=404 height=208 border=0 ALT="Click to view at full size."> </A>
</p>

<p>If the action for an access violation is set to Stop If Not Handled,
the debugger allows the thread to search for exception filters. Only if
the exception is not handled will the debugger display the message box
shown here.</p>

<p>
<A HREF="javascript:fullSize('G25si08x.htm')"> <img src="images/G25si08.JPG" width=404 height=113 border=0 ALT="Click to view at full size."> </A>
</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>
The important point to remember is that first-chance notifications do <i>
not</i> indicate problems or bugs in the application. In fact, this
notification can only appear when your process is being debugged. The
debugger is simply reporting that an exception was raised, but if the
debugger does not display the message box, a filter handled the
exception and the application continues to run just fine. A last-chance
notification means that your code has a problem or bug that must be
fixed.
</blockquote></div></p>

<p>Before leaving this section, I'd like to point out just one more
thing about the debugger's Exceptions dialog box. This dialog box
fully supports any software exceptions that you yourself define. All
you have to do is enter your unique software exception code number, a
string name for your exception, your preferred action, and then click
on the Add button to add your exception to the list. The window below
illustrates how I made the debugger aware of my own software
exception.</p>

<p>
<A HREF="javascript:fullSize('G25si09x.htm')"> <img src="images/G25si09.JPG" width=404 height=200 border=0 ALT="Click to view at full size."> </A>
</p>

<A NAME="345"><H2>The Spreadsheet Sample Application</H2></A>

<p>The Spreadsheet sample application (&quot;25 Spreadsheet.exe&quot;)
listed in Figure 25-1 shows how to sparsely commit
storage to a reserved address space region using structured exception
handling. The source code and resource files for the application are in
the &quot;25-Spreadsheet&quot; directory on the companion CD-ROM. When
you execute the Spreadsheet sample, the following dialog box
appears.</p>

<p>
<img src="images/g25si10.JPG" width=252 height=293 border=0>
</p>

<p>Internally, the application reserved a region for a two-dimensional
spreadsheet. The spreadsheet contains 256 rows by 1024 columns and each
cell is 1024 bytes in size. If the application were to commit storage
up front for the entire spreadsheet, 268,435,456 bytes, or 256 MB, of
storage would be required. In order to conserve precious storage space,
the application reserves a 256-MB region of address space without
committing any storage backing this region.</p>

<p>Let's say that the user attempts to place the value 12345 in a
cell existing at row 100, column 100 (as shown in the previous window).
When the user clicks on the Write Cell button, the application code
tries to write to that location in the spreadsheet. Of course, this
attempted write raises an access violation. However, since I'm
using SEH in the application, my exception filter detects the attempted
write, displays the &quot;Violation: Attempting to Write&quot; message
at the bottom of the dialog box, commits storage for the cell, and has
the CPU re-execute the instruction that raised the violation. Since
storage has been committed, the value is written to the
spreadsheet's cell.</p>

<p>
<img src="images/g25si11.JPG" width=252 height=293 border=0>
</p>

<p>Let's try another experiment. Try to read the value in the cell
at row 5, column 20. When you attempt to read from this cell, an access
violation is again raised. For an attempted read, the exception filter
doesn't commit storage, but it does display the &quot;Violation:
Attempting to Read&quot; message in the dialog box. The program
gracefully recovers from the failed read by removing the number in the
Value field of the dialog box, as shown here.</p>

<p>
<img src="images/g25si12.JPG" width=252 height=293 border=0>
</p>

<p>For our third experiment, try to read the cell value in row 100,
column 100. Since storage was committed for this cell, no violation
will occur and no exception filter is executed (improving the
performance). The dialog box looks like this.</p>

<p>
<img src="images/g25si13.JPG" width=252 height=293 border=0>
</p>

<p>Now for our fourth and last experiment: Try to write the value 54321
into the cell at row 100, column 101. When you attempt this, no
violation occurs because this cell is on the same storage page as the
cell at (100, 100). We can verify this with the &quot;No Violation
raised&quot; message at the bottom of the dialog box shown here.</p>

<p>
<img src="images/g25si14.JPG" width=252 height=293 border=0>
</p>

<p>I tend to use virtual memory and SEH quite a bit in my own projects.
After a while, I decided to create a templated C++ class, CVMArray,
which encapsulates all of the hard work. You can find the source code
for this C++ class in the VMArray.h file (part of the Spreadsheet
sample shown in Figure 25-1). You can work with the CVMArray class in
two ways. First, you can just create an instance of this class passing
the maximum number of elements in the array to the constructor. The
class automatically sets up a process-wide unhandled exception filter
so whenever any code in any thread accesses a memory address in the
virtual memory array, the unhandled exception filter calls <i>
VirtualAlloc</i> to commit storage for the new element and returns
EXCEPTION_CONTINUE_EXECUTION. Using the CVMArray class in this way allows you to use
sparse storage with just a few lines of code, and you don't have to
sprinkle SEH frames throughout your source code. The only downside to
this approach is that your application can't recover gracefully if
for some reason storage cannot be committed when needed.</p>

<p>The second way to use the CVMArray class is to derive your own C++
class from it. If you use the derived class, you still get all of the
benefits of the base class&#8212;but now you also get to add features of
your own. For example, you can now handle insufficient storage problems
more gracefully by overloading the virtual <i>OnAccessViolation</i>
function. The Spreadsheet sample application shows how a
CVMArray-derived class can add these features.</p>

<p><b>Figure 25-1.</b> <i>The Spreadsheet sample application</i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<p><b>Spreadsheet.cpp</b></p>
<PRE>
/******************************************************************************
Module:牋Spreadsheet.cpp
Notices:燙opyright