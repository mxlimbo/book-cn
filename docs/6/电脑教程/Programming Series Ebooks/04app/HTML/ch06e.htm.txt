<HTML>
<HEAD>
<TITLE>The CreateThread Function</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch06d.htm">[Previous]</A> <A HREF="ch06f.htm">[Next]</A><P>

<A NAME="78"><h1>The <i>CreateThread</i> Function</h1></A>
<p>We've already discussed how a process's primary thread comes
into being when <i>CreateProcess</i> is called. If you want to create
one or more secondary threads, you simply have an already running
thread call <i>CreateThread</i>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
HANDLE燙reateThread(
牋燩SECURITY_ATTRIBUTES爌sa,
牋燚WORD燾bStack,
牋燩THREAD_START_ROUTINE爌fnStartAddr,
牋燩VOID爌vParam,
牋燚WORD爁dwCreate,
牋燩DWORD爌dwThreadID);
</pre></td></tr></table></p> 

<p>When <i>CreateThread</i> is called, the system creates a thread
kernel object. This thread kernel object is not the thread itself but a
small data structure that the operating system uses to manage the
thread. You can think of the thread kernel object as a small data
structure that consists of statistical information about the thread.
This is identical to the way processes and process kernel objects
relate to each other.</p>

<p>The system allocates memory out of the process's address space
for use by the thread's stack. The new thread runs in the same
process context as the creating thread. The new thread therefore has
access to all of the process's kernel object handles, all of the
memory in the process, and the stacks of all other threads that are in
this same process. This makes it really easy for multiple threads in a
single process to communicate with each other.</p>

<p><div class="note"><blockquote><b>NOTE</b><HR> The <i>
CreateThread</i> function is the Windows function that creates a
thread. However, if you are writing C/C++ code, you should never call
<i>CreateThread</i>. Instead, you should use the Visual C++ run-time
library function <i>_beginthreadex</i>. If you do not use
Microsoft's Visual C++ compiler, your compiler vendor will have its
own alternative to <i>CreateThread</i>. Whatever this alternative is,
you must use it. I'll explain what <i>_beginthreadex</i> does and
why it is so important later in this chapter.
</blockquote></div></p>

<p>OK, that's the broad overview. The following sections explain
each of <i>CreateThread</i>'s parameters.</p>

<A NAME="79"><H3><i>psa</i></H3></A>

<p>The <i>psa</i> parameter is a pointer to a SECURITY_ATTRIBUTES
structure. You can (and usually will) pass NULL if you want the default
security attributes for the thread kernel object. If you want any child
processes to be able to inherit a handle to this thread object, you
must specify a SECURITY_ATTRIBUTES structure, whose <i>
bInheritHandle</i> member is initialized to TRUE. See <A HREF="ch03a.htm">Chapter 3</A> for
more information.</p>

<A NAME="80"><H3><i>cbStack</i></H3></A>

<p>The <i>cbStack</i> parameter specifies how much address space the
thread can use for its own stack. Every thread owns its own stack. When
<i>CreateProcess</i> starts a process, it internally calls <i>
CreateThread</i> to initialize the process's primary thread. For
the <i>cbStack</i> parameter, <i>CreateProcess</i> uses a value stored
inside the executable file. You can control this value using the
linker's /STACK switch:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
/STACK:[<i>reserve</i>]燵,<i>commit</i>]
</pre></td></tr></table></p> 

<p>The <i>reserve</i> argument sets the amount of address space the
system should reserve for the thread's stack. The default is 1 MB.
The <i>commit</i> argument specifies the amount of physical storage
that should be initially committed to the stack's reserved region.
The default is one page. As the code in your thread executes, you might
require more than one page of storage. When your thread overflows its
stack, an exception is generated. (See <A HREF="ch16a.htm">Chapter 16</A> for more information
about a thread's stack and stack overflow exceptions; see <a href="ch23a.htm">Chapter
23</a> for more information about general exception handling.) The system
catches the exception and commits another page (or whatever you
specified for the <i>commit</i> argument) to the reserved space, which
allows a thread's stack to grow dynamically as needed.</p>

<p>When you call <i>CreateThread</i>, passing a value other than 0
causes the function to reserve and commit all storage for the
thread's stack. Since all the storage is committed up front, the
thread is guaranteed to have the specified amount of stack storage
available. The amount of reserved space is either the amount specified
by the /STACK linker switch or the value of <i>cbStack</i>, whichever
is larger. The amount of storage committed matches the value you passed
for <i>cbStack</i>. If you pass 0 to the <i>cbStack</i> parameter, <i>
CreateThread</i> reserves a region and commits the amount of storage
indicated by the /STACK linker switch information embedded in the .exe
file by the linker.</p>

<p>The reserve amount sets an upper limit for the stack so that you can
catch endless recursion bugs in your code. For example, let's say
that you're writing a function that calls itself recursively. This
function also has a bug that causes endless recursion. Every time the
function calls itself, a new stack frame is created on the stack. If
the system didn't set a maximum limit on the stack size, the
recursive function would never stop calling itself. All of the
process's address space would be allocated, and enormous amounts of
physical storage would be committed to the stack. By setting a stack
limit, you prevent your application from using up enormous amounts of
physical storage, and you also know much sooner when a bug exists in
your program. (The Summation sample application in <A HREF="ch16a.htm">Chapter 16</A> shows how
to trap and handle stack overflows in your application.)</p>

<A NAME="81"><h3><i>pfnStartAddr</i> and<i> pvParam</i></h3></A>
<p>The <i>pfnStartAddr</i> parameter indicates the address of the
thread function that you want the new thread to execute. A thread
function's <i>pvParam</i> parameter is the same as the <i>
pvParam</i> parameter that you originally passed to <i>
CreateThread</i>. <i>CreateThread</i> does nothing with this parameter
except pass it on to the thread function when the thread starts
executing. This parameter provides a way to pass an initialization
value to the thread function. This initialization data can be either a
numeric value or a pointer to a data structure that contains additional
information.</p>

<p>It is perfectly legal and actually quite useful to create multiple
threads that have the same function address as their starting point.
For example, you can implement a Web server that creates a new thread
to handle each client's request. Each thread knows which client it
is processing because you pass a different <i>pvParam</i> value as you
create each thread.</p>

<p>Remember that Windows is a preemptive multithreading system, which
means that the new thread and the thread that called <i>
CreateThread</i> can execute simultaneously. Because the threads run
simultaneously, problems can occur. Watch out for code like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD燱INAPI燜irstThread(PVOID爌vParam)爗
牋