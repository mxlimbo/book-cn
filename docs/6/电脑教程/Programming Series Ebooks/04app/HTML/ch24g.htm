<HTML>
<HEAD>
<TITLE>GetExceptionInformation</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch24f.htm">[Previous]</A> <A HREF="ch24h.htm">[Next]</A><P>

<A NAME="333"><h1><i>GetExceptionInformation</i></h1></A>
<p>When an exception occurs, the operating system pushes the following
three structures on the stack of the thread that raised the exception:
the EXCEPTION_RECORD structure, the CONTEXT structure, and the
EXCEPTION_POINTERS structure.</p>
 
<p>The EXCEPTION_RECORD structure contains CPU-independent information
about the raised exception, and the CONTEXT structure contains
CPU-dependent information about the raised exception. The
EXCEPTION_POINTERS structure has only two data members that are pointers to the
pushed EXCEPTION_RECORD and CONTEXT data structures:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef struct _EXCEPTION_POINTERS {
   PEXCEPTION_RECORD ExceptionRecord;
   PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;
</pre></td></tr></table></p>

<p>To retrieve this information and use it in your own application, you
will need to call the <i>GetExceptionInformation</i> function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
PEXCEPTION_POINTERS GetExceptionInformation();
</pre></td></tr></table></p>

<p>This intrinsic function returns a pointer to an EXCEPTION_POINTERS
structure.</p>

<p>The most important thing to remember about the <i>
GetExceptionInformation</i> function is that it can be called only in
an exception filter&#8212;because the CONTEXT, EXCEPTION_RECORD, and
EXCEPTION_POINTERS data structures are valid only during the exception
filter processing. Once control has been transferred to the exception
handler, the data on the stack is destroyed.</p>

<p>Though this situation is rarely necessary, if you need to access the
exception information from inside your exception handler block, you
must save the EXCEPTION_RECORD data structure and/or CONTEXT data
structure pointed to by the EXCEPTION_POINTERS structure in one or more
variables that you create. The following code demonstrates how to save
both the EXCEPTION_RECORD and CONTEXT data structures:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
void FuncSkunk() {
   // Declare variables that we can use to save the exception 
   // record and the context if an exception should occur.
   EXCEPTION_RECORD SavedExceptRec;
   CONTEXT SavedContext;

   <img src="images/grayvellip.JPG" width=3 height=13 border="0">

   _ _try {

      <img src="images/grayvellip.JPG" width=3 height=13 border="0">

   }

   _ _except (
      SavedExceptRec = 
         *(GetExceptionInformation())-&gt;ExceptionRecord,
      SavedContext = 
         *(GetExceptionInformation())-&gt;ContextRecord,
      EXCEPTION_EXECUTE_HANDLER) {

      // We can use the SavedExceptRec and SavedContext
      // variables inside the handler code block.
      switch (SavedExceptRec.ExceptionCode) {

         <img src="images/grayvellip.JPG" width=3 height=13 border="0">

      }
   }

   <img src="images/grayvellip.JPG" width=3 height=13 border="0">

}
</pre></td></tr></table></p>

<p>Notice the use of the C language's comma (,) operator in the
exception filter. Many programmers aren't used to seeing this
operator. It tells the compiler to execute the comma-separated
expressions from left to right. When all of the expressions have been
evaluated, the result of the last (or rightmost) expression is
returned.</p>

<p>In <i>FuncSkunk</i>, the left expression will execute, causing the
EXCEPTION_RECORD structure on the stack to be stored in the <i>
SavedExceptRec</i> local variable. The result of this expression is the
value of <i>SavedExceptRec</i>. However, this result is discarded and
the next expression to the right is evaluated. This second expression
causes the CONTEXT structure on the stack to be stored in the <i>
SavedContext</i> local variable. The result of the second expression is
<i>SavedContext</i>, and again, this expression is discarded as the
third expression is evaluated. This is a very simple expression that
evaluates to EXCEPTION_EXECUTE_HANDLER. The result of this rightmost expression is the result of
the entire comma-separated expression.</p>

<p>Because the exception filter evaluated to EXCEPTION_EXECUTE_HANDLER, the code inside the <i>except</i> block executes. At this
point, the <i>SavedExceptRec</i> and <i>SavedContext</i> variables have
been initialized and can be used inside the <i>except</i> block. Keep
in mind it is important that the <i>SavedExceptRec</i> and <i>
SavedContext</i> variables be declared outside the <i>try</i>
block. </p>

<p>As you've probably guessed, the <i>ExceptionRecord</i> member of
the EXCEPTION_POINTERS structure points to an EXCEPTION_RECORD
structure:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef struct _EXCEPTION_RECORD {
   DWORD ExceptionCode;
   DWORD ExceptionFlags;
   struct _EXCEPTION_RECORD *ExceptionRecord;
   PVOID ExceptionAddress;
   DWORD NumberParameters;
   ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
} EXCEPTION_RECORD;
</pre></td></tr></table></p>

<p>The EXCEPTION_RECORD structure contains detailed, CPU-independent
information about the exception that has most recently occurred:</p>

<ul>
<p><li><i>ExceptionCode</i> contains the code of the exception. This is
the same information that is returned from the <i>GetExceptionCode</i>
intrinsic function.</li></p>

<p><li><i>ExceptionFlags</i> contains flags about the exception.
Currently the only two values are 0 (which indicates a continuable
exception) and EXCEPTION_NONCONTINUABLE (which indicates a
noncontinuable exception). Any attempt to continue execution after a
noncontinuable exception causes an EXCEPTION_NONCONTINUABLE_EXCEPTION
exception to be raised.</li></p>

<p><li><i>ExceptionRecord</i> points to an EXCEPTION_RECORD structure
for another unhandled exception. While handling one exception, it is
possible to raise another exception. For example, the code in your
exception filter could attempt to divide a number by 0. Exception
records can be chained to provide additional information when nested
exceptions occur. A nested exception occurs if an exception is
generated during the processing of an exception filter. If there are no
unhandled exceptions, this member will contain NULL.</li></p>

<p><li><i>ExceptionAddress</i> specifies the address of the CPU
instruction that generated the exception.</li></p>

<p><li><i>NumberParameters</i> specifies the number of parameters (0 to
15) associated with the exception. This is the number of defined
elements in the <i>ExceptionInformation</i> array. For almost all
exceptions, this value will be 0.</li></p>

<p><li><i>ExceptionInformation</i> specifies an array of additional
arguments that describe the exception. For almost all exceptions, the
array elements are undefined.</li></p>
</ul>



<p>The last two members of the EXCEPTION_RECORD structure, <i>
NumberParameters</i> and <i>ExceptionInformation</i>, offer the
exception filter some additional information about the exception.
Currently only one type of exception offers additional information:
EXCEPTION_ACCESS_VIOLATION. All other possible exceptions will have the
<i>NumberParameters</i> member set to 0. You examine the <i>
NumberParameters</i> array member to look at the additional information
about a generated exception.</p>

<p>For an EXCEPTION_ACCESS_VIOLATION exception, <i>
ExceptionInformation[0]</i> contains a flag that indicates the type of
operation that caused the access violation. If this value is 0, the
thread tried to read the inaccessible data. If this value is 1, the
thread tried to write to inaccessible data. <i>
ExceptionInformation[1]</i> specifies the address of the inaccessible
data.</p>

<p>By using these members, you can produce exception filters that offer
a significant amount of information about your application. For
example, you might write an exception filter like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
_ _try {

   <img src="images/grayvellip.JPG" width=3 height=13 border="0">

}
_ _except (ExpFltr(GetExceptionInformation()-&gt;ExceptionRecord)) {

   <img src="images/grayvellip.JPG" width=3 height=13 border="0">

}

LONG ExpFltr (PEXCEPTION_RECORD pER) {
   char szBuf[300], *p;
   DWORD dwExceptionCode = pER-&gt;ExceptionCode;

   sprintf(szBuf, &quot;Code = %x, Address = %p&quot;,
      dwExceptionCode, pER-&gt;ExceptionAddress);

   // Find the end of the string.
   p = strchr(szBuf, 0);

   // I used a switch statement in case Microsoft adds
   // information for other exception codes in the future.
   switch (dwExceptionCode) {
      case EXCEPTION_ACCESS_VIOLATION:
         sprintf(p, &quot;Attempt to %s data at address %p&quot;,
            pER-&gt;ExceptionInformation[0] ? &quot;write&quot; : &quot;read&quot;,
            pER-&gt;ExceptionInformation[1]);
         break;

      default:
         break;
   }

   MessageBox(NULL, szBuf, &quot;Exception&quot;, MB_OK | MB_ICONEXCLAMATION);

   return(EXCEPTION_CONTINUE_SEARCH);
}
</pre></td></tr></table></p>

<p>The <i>ContextRecord</i> member of the EXCEPTION_POINTERS structure
points to a CONTEXT structure (discussed in <A HREF="ch07a.htm">Chapter 7</A>). This structure
is platform-dependent; that is, the contents of this structure will
differ from one CPU platform to another.</p>

<p>Basically, this structure contains one member for each of the
registers available on the CPU. When an exception is raised, you can
find out even more information by examining the members of this
structure. Unfortunately, realizing the benefit of such a possibility
requires you to write platform-dependent code that recognizes the
machine it's running on and uses the appropriate CONTEXT structure.
The best way to handle this is to put <i>#ifdef</i>s into your code.
The CONTEXT structures for the various CPUs supported by Windows are in
the WinNT.h file.</p>

</BODY>
</HTML>






