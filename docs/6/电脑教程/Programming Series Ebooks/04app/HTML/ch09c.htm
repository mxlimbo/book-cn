<HTML>
<HEAD>
<TITLE>Successful Wait Side Effects</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch09b.htm">[Previous]</A> <A HREF="ch09d.htm">[Next]</A><P>

<A NAME="125"><H1>Successful Wait Side Effects</H1></A>

<p>For some kernel objects, a successful call to <i>
WaitForSingleObject</i> or <i>WaitForMultipleObjects</i> actually
alters the state of the object. A successful call is one in which the
function sees that the object was signaled and returns a value relative
to WAIT_OBJECT_0. A call is unsuccessful if the function returns
WAIT_TIMEOUT or WAIT_FAILED. Objects never have their state altered for
unsuccessful calls.</p>

<p>When an object has its state altered, I call this a <i>successful wait
side effect</i>. For example, let's say that a thread is waiting on
an auto-reset event object (discussed later in this chapter). When the
event object becomes signaled, the function detects this and can return
WAIT_OBJECT_0 to the calling thread. However, just before the function
returns, the event is set to the nonsignaled state&#8212;the side effect
of the successful wait.</p>

<p>This side effect is applied to auto-reset event kernel objects because
it is one of the rules that Microsoft has defined for this type of
object. Other objects have different side effects, and some objects
have no side effects at all. Process and thread kernel objects have no
side effects at all&#8212;that is, waiting on one of these objects never
alters the object's state. As we discuss various kernel objects in
this chapter, we'll go into detail about their successful wait side
effects.</p>

<p>What makes <i>WaitForMultipleObjects</i> so useful is that it performs
all of its operations atomically. When a thread calls <i>
WaitForMultipleObjects</i>, the function can test the signaled state of
all the objects and perform the required side effects all as a single
operation.</p>

<p>Let's look at an example. Two threads call <i>
WaitForMultipleObjects</i> in exactly the same way:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
HANDLE h[2];
h[0] = hAutoResetEvent1;   // Initially nonsignaled
h[1] = hAutoResetEvent2;   // Initially nonsignaled
WaitForMultipleObjects(2, h, TRUE, INFINITE);
</pre></td></tr></table></p>

<p>When <i>WaitForMultipleObjects</i> is called, both event objects are
nonsignaled; this forces both threads to enter a wait state. Then the
<i>hAutoResetEvent1</i> object becomes signaled. Both threads see that
the event has become signaled, but neither can wake up because the <i>
hAutoResetEvent2</i> object is still nonsignaled. Because neither
thread has successfully waited yet, no side effect happens to the <i>
hAutoResetEvent1</i> object.</p>

<p>Next, the <i>hAutoResetEvent2</i> object becomes signaled. At this
point, one of the two threads detects that both objects it is waiting
for have become signaled. The wait is successful, both event objects
are set to the nonsignaled state, and the thread is schedulable. But
what about the other thread? It continues to wait until it sees that
both event objects are signaled. Even though it originally detected
that <i>hAutoResetEvent1</i> was signaled, it now sees this object as
nonsignaled.</p>

<p>As I mentioned, it's important to note that <i>
WaitForMultipleObjects</i> works atomically. When it checks the state
of the kernel objects, no other thread can alter any object's state
behind its back. This prevents deadlock situations. Imagine what would
happen if one thread saw that <i>hAutoResetEvent1</i> was signaled and
reset the event to nonsignaled and then the other thread saw that <i>
hAutoResetEvent2</i> was signaled and reset this event to nonsignaled.
Both threads would be frozen: one thread would wait for an object that
another thread had gotten, and vice versa. <i>
WaitForMultipleObjects</i> ensures that this never happens.</p>

<p>This brings up an interesting question: If multiple threads wait for
a single kernel object, which thread does the system decide to wake up
when the object becomes signaled? Microsoft's official response to
this question is, &quot;The algorithm is fair.&quot; Microsoft
doesn't want to commit to the internal algorithm used by the
system. All it says is that the algorithm is fair, which means that if
multiple threads are waiting, each should get its own chance to wake up
each time the object becomes signaled.</p>

<p>This means that thread priority has no effect: the highest-priority
thread does not necessarily get the object. It also means that the
thread waiting the longest does not necessarily get the object. And it
is possible for a thread that got the object to loop around and get it
again. However, this wouldn't be fair to the other threads, so the
algorithm tries to prevent this. But there is no guarantee.</p>

<p>In reality, the algorithm Microsoft uses is simply the popular
&quot;first in, first out&quot; scheme. The thread that has waited the
longest for an object gets the object. However, actions can occur in
the system that alter this behavior, making it less predictable. This
is why Microsoft doesn't explicitly state how the algorithm works.
One such action is a thread getting suspended. If a thread waits for an
object and then the thread is suspended, the system forgets that the
thread is waiting for the object. This is a feature because there is no
reason to schedule a suspended thread. When the thread is later
resumed, the system thinks that the thread just started waiting on the
object.</p>

<p>While you debug a process, all threads within that process are
suspended when breakpoints are hit. So debugging a process makes the
&quot;first in, first out&quot; algorithm highly unpredictable because
threads are frequently suspended and resumed.</p>


</BODY>
</HTML>






