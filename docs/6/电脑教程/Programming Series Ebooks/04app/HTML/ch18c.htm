<HTML>
<HEAD>
<TITLE>Reasons to Create Additional Heaps</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch18b.htm">[Previous]</A> <A HREF="ch18d.htm">[Next]</A><P>

<A NAME="236"><H1>Reasons to Create Additional Heaps</H1></A>

<p>In addition to the process's default heap, you can create
additional heaps in your process's address space. You would want to
create additional heaps in your own applications for the following
reasons:</p>

<ul>

<p><li>Component protection</li></p>

<p><li>More efficient memory management</li></p>

<p><li>Local access</li></p>

<p><li>Avoiding thread synchronization overhead</li></p>

<p><li>Quick Free</li></p>

</ul>

<p>Let's examine each reason in detail.</p>


<A NAME="237"><H2>Component Protection</H2></A>

<p>Imagine that your application needs to process two components: a
linked list of NODE structures and a binary tree of BRANCH structures.
You have two source code files: LnkLst.cpp, which contains the
functions that process the linked list of NODEs, and BinTree.cpp, which
contains the functions that process the binary tree of BRANCHes.</p>

<p>If the NODEs and the BRANCHes are stored together in a single heap,
the combined heap might look like Figure 18-1.</p>

<p>Now let's say that a bug in the linked-list code causes the 8
bytes after NODE 1 to be accidentally overwritten, which in turn causes
the data in BRANCH 3 to be corrupted. When the code in BinTree.cpp
later attempts to traverse the binary tree, it will probably fail
because of this memory corruption. Of course, this will lead you to
believe that there is a bug in your binary-tree code when in fact the
bug exists in the linked-list code. Because the different types of
objects are mixed together in a single heap, tracking down and
isolating bugs becomes significantly more difficult.</p>

<p>
<img src="images/F18SI01.JPG" width=158 height=458 border="0">
</p><p>
<!-- CAPTION --><b>Figure 18-1.</b> <i>A single heap that stores NODEs and BRANCHes together</i><!-- /CAPTION -->
</p>

<p>By creating two separate heaps&#8212;one for NODEs and the other for
BRANCHes&#8212;you localize your problems. A small bug in your
linked-list code does not compromise the integrity of your binary tree,
and vice versa. It is still possible to have a bug in your code that
causes a wild memory write to another heap, but this is a far less
likely scenario.</p>


<A NAME="238"><H2>More Efficient Memory Management</H2></A>

<p>Heaps can be managed more efficiently by allocating objects of the
same size within them. For example, let's say that every NODE
structure requires 24 bytes and every BRANCH structure requires 32
bytes. All of these objects are allocated from a single heap. Figure
18-2 shows a fully occupied single heap with several NODE and BRANCH
objects allocated within it. If NODE 2 and NODE 4 are freed, memory in
the heap becomes fragmented. If you then attempt to allocate a BRANCH
structure, the allocation will fail even though 48 bytes are available
and a BRANCH needs only 32 bytes.</p>

<p>If each heap consisted only of objects that were the same size,
freeing an object would guarantee that another object would fit
perfectly into the freed object's space.</p>

<p>
<img src="images/F18SI02.JPG" width=158 height=458 border="0">
</p><p>
<!-- CAPTION --><b>Figure 18-2.</b> <i>A single fragmented heap that contains several NODE and BRANCH objects</i><!-- /CAPTION -->
</p>


<A NAME="239"><H2>Local Access</H2></A>

<p>There is a huge performance penalty whenever the system must swap a
page of RAM to and from the system's paging file. If you keep
accesses to memory localized to a small range of addresses, it is less
likely that the system will need to swap pages between RAM and
disk.</p>

<p>So, in designing an application, it's a good idea to allocate
things close to each other if they will be accessed together. Returning
to our linked list and binary tree example, traversing the linked list
is not related in any way to traversing the binary tree. By keeping all
the NODEs close together (in one heap), you can keep the NODEs in
adjoining pages; in fact, it's likely that several NODEs will fit
within a single page of physical memory. Traversing the linked list
will not require that the CPU refer to several different pages of
memory for each NODE access.</p>

<p>If you were to allocate both NODEs and BRANCHes in a single heap,
the NODEs would not necessarily be close together. In a worst-case
situation, you might be able to have only one NODE per page of memory,
with the remainder of each page occupied by BRANCHes. In this case,
traversing the linked list could cause page faults for each NODE, which
would make the process extremely slow.</p>


<A NAME="240"><H2>Avoiding Thread Synchronization Overhead</H2></A>

<p>As I'll explain shortly, heaps are serialized by default so that
there is no chance of data corruption if multiple threads attempt to
access the heap at the same time. However, the heap functions must
execute additional code in order to keep the heap thread-safe. If you
are performing lots of heap allocations, executing this additional code
can really add up, taking a toll on your application's performance.
When you create a new heap, you can tell the system that only one
thread will access the heap and therefore the additional code will not
execute. However, be careful&#8212;you are now taking on the
responsibility of keeping the heap thread-safe. The system will not be
looking out for you.</p>


<A NAME="241"><H2>Quick Free</H2></A>

<p>Finally, using a dedicated heap for some data structures allows you
to free the entire heap without having to free each memory block
explicitly within the heap. For example, when Windows Explorer walks
the directory hierarchy of your hard drive, it must build a tree in
memory. If you tell Windows Explorer to refresh its display, it could
simply destroy the heap containing the tree and start over (assuming,
of course, that it has used a dedicated heap only for the directory
tree information). For many applications, this can be extremely
convenient&#8212;and they'll run faster too.</p>


</BODY>
</HTML>






