<html>
<head>
<title>Appendix B -- Message Crackers, Child Control Macros, and API
Macros</title>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<A HREF="chaab.htm">[Previous]</A> <A HREF="chabb.htm">[Next]</A><P>


<A NAME="384"><h1>Appendix B -- Message Crackers, Child Control Macros, and API Macros</H1></A>



<p>When I go to conferences, I frequently ask people if they're
using message crackers, and the response is usually &quot;no.&quot;
When I probe further, I discover that they don't know what message
crackers do or even what they are. By using C/C++ with message crackers
to present the sample code in this book, I get to introduce these
little-known but useful macros to many people who might not know about
them.</p>

<p>Message crackers are in the WindowsX.h file supplied with Microsoft
Visual C++. You usually include this file immediately after the
Windows.h file. The WindowsX.h file is nothing more than a bunch of <i>
#define</i> directives that create a set of macros for you to use. The
macros in WindowsX.h are actually divided into three groups: message
crackers, child control macros, and API macros. These macros help you
in the following ways:</p>

<ul>
<p><li>They reduce the amount of casting you need to do in an
application and make the casting that is required error-free. One of
the big problems with programming for Windows in C/C++ has been the
amount of casting required. You hardly ever see a call to a Windows
function that doesn't require some sort of cast. You should avoid
casts because they prevent the compiler from catching potential errors
in your code. A cast tells the compiler, &quot;I know I'm passing
the wrong type here, but that's OK; I know what I'm
doing.&quot; When you do a lot of casting, it's easy to make a
mistake. The compiler should do as much work as possible to help
out.</li></p>

<p><li>They make your code more readable.</li></p>

<p><li>They simplify porting between 16-bit Windows, 32-bit Windows, and
64-bit Windows.</li></p>

<p><li>They're easy to understand. (They're just macros, after all.)</li></p>

<p><li>They're easy to incorporate into existing code. You can leave
old code alone and immediately use the macros in new code. You
don't have to retrofit an entire application.</li></p>

<p><li>You can use them in C and C++ code, although they're not
necessary if you're using a C++ class library.</li></p>

<p><li>If you need a feature that the macros don't support, you can
easily write your own macros based on the ones in the header file.</li></p>

<p><li>You don't need to reference or remember obscure Windows
constructs. For example, many functions in Windows expect a long
parameter where the value in the long's high-word means one thing
and the value in its low-word means something else. Before calling
these functions, you must construct a long value out of the two
individual values. You usually do this by using the MAKELONG macro from
WinDef.h. But I can't tell you how many times I've accidentally
reversed the two values, causing an incorrect value to be passed to a
function. The macros in WindowsX.h come to the rescue.</li></p>
</ul>

</BODY>
</HTML>






