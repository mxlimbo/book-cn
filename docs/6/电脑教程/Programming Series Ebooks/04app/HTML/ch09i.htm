<HTML>
<HEAD>
<TITLE>Other Thread Synchronization Functions</TITLE>
<link rel="STYLESHEET" type="text/css" href="advwin4.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch09h.htm">[Previous]</A> <A HREF="ch10a.htm">[Next]</A><P>

<A NAME="137"><H1>Other Thread Synchronization Functions</H1></A>

<p><i>WaitForSingleObject</i> and <i>WaitForMultipleObjects</i> are the
most commonly used functions for performing thread synchronization.
However, Windows offers a few more functions that have slight
variations. If you understand <i>WaitForSingleObject</i> and <i>
WaitForMultipleObjects</i>, you'll have no trouble understanding
how these other functions work. In this section, I'll briefly
introduce some of them.</p>


<A NAME="138"><H2>Asynchronous Device I/O</H2></A>

<p>Asynchronous device I/O allows a thread to start a read or write
operation without having to wait for the read or write operation to
complete. For example, if a thread needs to load a large file into
memory, the thread can tell the system to load the file into memory.
Then, as the system loads the file, the thread can be busy performing
other tasks&#8212;creating windows, initializing internal data
structures, and so on. When the initialization is complete, the thread
can suspend itself, waiting for the system to notify it that the file
has been read.</p>

<p>Device objects are synchronizable kernel objects, which means that you
can call <i>WaitForSingleObject</i>, passing the handle of a file,
socket, communication port, and so on. While the system performs the
asynchronous I/O, the device object is in the nonsignaled state. As
soon as the operation is complete, the system changes the state of the
object to signaled so that the thread knows that the operation has
completed. At this point, the thread continues execution.</p>


<A NAME="139"><h2><i>WaitForInputIdle</i></h2></A>
<p>A thread can also suspend itself by calling <i>
WaitForInputIdle</i>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD WaitForInputIdle(
   HANDLE hProcess, 
   DWORD dwMilliseconds);
</pre></td></tr></table></p>

<p>This function waits until the process identified by <i>hProcess</i>
has no input pending in the thread that created the application's
first window. This function is useful for a parent process. The parent
process spawns a child process to do some work. When the parent
process's thread calls <i>CreateProcess</i>, the parent's
thread continues to execute while the child process initializes. The
parent's thread might need to get the handle of a window created by
the child. The only way for the parent's thread to know when the
child process has been fully initialized is to wait until the child is
no longer processing any input. So after the call to <i>
CreateProcess</i>, the parent's thread places a call to <i>
WaitForInputIdle</i>.</p>

<p>You can also use <i>WaitForInputIdle</i> when you need to force
keystrokes into an application. Let's say that you post the
following messages to the main window of an application:</p>

<P>
	<TABLE CELLPADDING=5 WIDTH="95%">
	
		<TR>
			<TD CLASS="COLUMNS">WM_KEYDOWN</TD>
			<TD CLASS="COLUMNS">with a virtual key of VK_MENU</TD>
		</TR>

		<TR>
			<TD CLASS="COLUMNS">WM_KEYDOWN</TD>
			<TD CLASS="COLUMNS">with a virtual key of VK_F</TD>
		</TR>

		<TR>
			<TD CLASS="COLUMNS">WM_KEYUP</TD>
			<TD CLASS="COLUMNS">with a virtual key of VK_F</TD>
		</TR>

		<TR>
			<TD CLASS="COLUMNS">WM_KEYUP</TD>
			<TD CLASS="COLUMNS">with a virtual key of VK_MENU</TD>
		</TR>

		<TR>
			<TD CLASS="COLUMNS">WM_KEYDOWN</TD>
			<TD CLASS="COLUMNS">with a virtual key of VK_O</TD>
		</TR>

		<TR>
			<TD CLASS="COLUMNS">WM_KEYUP</TD>
			<TD CLASS="COLUMNS">with a virtual key of VK_O</TD>
		</TR>

	</TABLE>
</P>

<p>This sequence sends Alt+F, O to an application, which, for most
English-language applications, chooses the Open command from the
application's File menu. This command opens a dialog box, but
before the dialog box can appear, Windows must load the dialog box
template from the file and cycle through all the controls in the
template, calling <i>CreateWindow</i> for each one. This can take some
time. So the application that posted the WM_KEY* messages can call <i>
WaitForInputIdle</i>, which causes the application to wait until the
dialog box has been completely created and is ready for user input. The
application can now force additional keys into the dialog box and its
controls so that it can continue doing whatever it needs to do.</p>

<p>Developers who wrote for 16-bit Windows often faced this problem.
Applications wanted to post messages to a window but didn't know
exactly when the window was created and ready. The <i>
WaitForInputIdle</i> function solves this problem.</p>


<A NAME="140"><h2><i>MsgWaitForMultipleObjects(Ex)</i></h2></A>
<p>A thread can call the <i>MsgWaitForMultipleObjects</i> or <i>
MsgWaitForMultipleObjectsEx</i> functions to cause the thread to wait
for its own messages:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD MsgWaitForMultipleObjects(
   DWORD dwCount, 
   PHANDLE phObjects,
   BOOL fWaitAll, 
   DWORD dwMilliseconds, 
   DWORD dwWakeMask);

DWORD MsgWaitForMultipleObjectsEx(
   DWORD dwCount, 
   PHANDLE phObjects,
   DWORD dwMilliseconds, 
   DWORD dwWakeMask, 
   DWORD dwFlags);
</pre></td></tr></table></p>

<p>These functions are similar to the <i>WaitForMultipleObjects</i>
function. The difference is that they allow a thread to be scheduled
when a kernel object becomes signaled or when a window message needs
dispatching to a window created by the calling thread.</p>

<p>A thread that creates windows and performs user-interface related tasks
should use <i>MsgWaitForMultipleObjectsEx</i> instead of <i>
WaitForMultipleObjects</i> because the latter prohibits the
thread's user-interface from responding to the user. This function
is discussed in more detail in <A HREF="ch27a.htm">Chapter 27</A>.</p>


<A NAME="141"><h2><i>WaitForDebugEvent</i></h2></A>
<p>Windows has excellent debugging support built right into the
operating system. When a debugger starts executing, it attaches itself
to a debuggee. The debugger simply sits idle, waiting for the operating
system to notify it of debug events related to the debuggee. A debugger
waits for these events by calling the <i>WaitForDebugEvent</i>
function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
BOOL WaitForDebugEvent(
   PDEBUG_EVENT pde, 
   DWORD dwMilliseconds);
</pre></td></tr></table></p>

<p>When a debugger calls this function, the debugger's thread is
suspended. The system notifies the debugger that a debug event has
occurred by allowing the call to <i>WaitForDebugEvent</i> to return.
The structure pointed to by the <i>pde</i> parameter is filled by the
system before it awakens the thread. This structure contains
information about the debug event that has just occurred.</p>


<A NAME="142"><h2><i>SignalObjectAndWait</i></h2></A>
<p>The <i>SignalObjectAndWait</i> function signals a kernel object and
waits on another kernel object in a single atomic operation:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
DWORD SignalObjectAndWait(
   HANDLE hObjectToSignal, 
   HANDLE hObjectToWaitOn, 
   DWORD dwMilliseconds, 
   BOOL fAlertable);
</pre></td></tr></table></p>

<p>When you call this function, the <i>hObjectToSignal</i> parameter
must identify a mutex, semaphore, or an event. Any other type of object
causes the function to return WAIT_FAILED, and <i>GetLastError</i>
returns ERROR_INVALID_HANDLE. Internally, the function examines the type of object and
performs the equivalent of <i>ReleaseMutex</i>, <i>ReleaseSemaphore</i>
(with a count of 1), or <i>ResetEvent</i>, respectively.</p>

<p>The <i>hObjectToWaitOn</i> parameter can identify any of the following
kernel objects: mutex, semaphore, event, timer, process, thread, job,
console input, and change notification. As usual, the <i>
dwMilliseconds</i> parameter indicates how long the function should
wait for this object to become signaled, and the <i>fAlertable</i> flag
indicates whether the thread should be able to process any queued
asynchronous procedure calls while the thread is waiting.</p>

<p>The function returns one of the following values: WAIT_OBJECT_0,
WAIT_TIMEOUT, WAIT_FAILED, WAIT_ABANDONED (discussed earlier in this
chapter), or WAIT_IO_COMPLETION.</p>

<p>This function is a welcome addition to Windows for two reasons. First,
because you often need to signal one object and wait on another, having
a single function that does both operations saves processing time. Each
time you call a function that causes your thread to jump from user-mode
to kernel-mode code, approximately 1000 CPU cycles need to execute (on
<i>x</i>86 platforms). For example, code such as this causes at least
2000 CPU cycles to execute:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
ReleaseMutex(hMutex);
WaitForSingleObject(hEvent, INFINITE);
</pre></td></tr></table></p>

<p>In high-performance server applications, <i>SignalObjectAndWait</i>
saves a lot of processing time.</p>

<p>Second, without the <i>SignalObjectAndWait</i> function, one thread
cannot know when another thread is in a wait state. This knowledge is
useful for functions such as <i>PulseEvent</i>. As mentioned earlier in
this chapter, <i>PulseEvent</i> signals an event and immediately resets
it. If no threads are currently waiting on the event, no events catch
the pulse. I've seen people write code like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
// Perform some work.

<img src="images/grayvellip.JPG" width=3 height=13 border="0">

SetEvent(hEventWorkerThreadDone);
WaitForSingleObject(hEventMoreWorkToBeDone, INFINITE);
// Do more work.

<img src="images/grayvellip.JPG" width=3 height=13 border="0">
</pre></td></tr></table></p>

<p>A worker thread performs some code and then calls <i>SetEvent</i> to
indicate that the work is done. Another thread executes code like
this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
WaitForSingleObject(hEventWorkerThreadDone);
PulseEvent(hEventMoreWorkToBeDone);
</pre></td></tr></table></p>

<p>The worker thread's code fragment is poorly designed because it
does not work reliably. After the worker thread calls <i>SetEvent</i>,
the other thread might wake up immediately and call <i>PulseEvent</i>.
The worker thread is preempted and hasn't had a chance to return
from its call to <i>SetEvent</i>, let alone call <i>
WaitForSingleObject</i>. The result is that the signaling of the <i>
hEventMoreWorkToBeDone</i> event is missed entirely by the worker
thread.</p>

<p>If you rewrite the worker thread's code to call <i>
SignalObjectAndWait</i> as shown here, the code will work reliably
because the signaling and wait is performed atomically.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
// Perform some work.

<img src="images/grayvellip.JPG" width=3 height=13 border="0">

SignalObjectAndWait(hEventWorkerThreadDone,
   hEventMoreWorkToBeDone, INFINITE, FALSE);
// Do more work.

<img src="images/grayvellip.JPG" width=3 height=13 border="0">
</pre></td></tr></table></p>

<p>When the nonworker thread wakes up, it can be 100 percent sure that
the worker thread is waiting on the <i>hEventMoreWorkToBeDone</i> event
and is therefore guaranteed to see the event pulsed.</p>

<P><DIV CLASS="NOTE"><BLOCKQUOTE>
<B>Windows 98</B><HR>
Windows 98 does not have a useful implementation for this function.
</BLOCKQUOTE></DIV>
</P>


</body>

</html>







