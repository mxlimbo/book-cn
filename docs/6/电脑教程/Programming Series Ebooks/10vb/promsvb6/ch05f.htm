<HTML>
<HEAD>
<TITLE>Working with Files</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch05e.htm", "ch05g.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="184"><h1>Working with Files</h1></A>
<p>Visual Basic has always included many powerful commands for dealing with text 
and binary files. While Visual Basic 6 hasn't extended the set of built-in functions, it 
has nonetheless indirectly extended the potential of the language by adding a new 
and interesting FileSystemObject object that makes it very easy to deal with files 
and directories. In this section, I provide an overview of all the VBA functions and 
statements related to files, with many useful tips so that you can get as much as you 
can from them and stay away from the most recurrent problems.</p>

<A NAME="185"><h2>Handling Files</h2></A>
<p>In general, you can't do many things to a file without opening it. Visual Basic 
lets you delete a file (using the <I>Kill</I> command), move or rename it (using the 
<I>Name ... As</I> command), and copy it elsewhere (using the 
<I>FileCopy</I> command):</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' All file operations should be protected against errors.
' None of these functions works on open files.
On Error Resume Next
' Rename a file--note that you must specify the path in the target,
' otherwise the file will be moved to the current directory.
Name &quot;c:\vb6\TempData.tmp&quot; As &quot;c:\vb6\TempData.$$$&quot;
' Move the file to another directory, possibly on another drive.
Name &quot;c:\vb6\TempData.$$$&quot; As &quot;d:\VS98\Temporary.Dat&quot;
' Make a copy of a file--note that you can change the name during the copy
' and that you can omit the filename portion of the target file.
FileCopy &quot;d:\VS98\Temporary.Dat&quot;, &quot;d:\temporary.$$$&quot;
' Delete one or more files--Kill also supports wildcards.
Kill &quot;d:\temporary.*&quot;
</pre>
</td></tr>
</table></p>

<p>You can read and modify the attributes of a file using the 
<I>GetAttr </I>function and the <I>SetAttr</I> command, respectively. The 
<I>GetAttr</I> function returns a bit-coded 
value, so you need to test its individual bits using intrinsic constants provided by 
VBA. Here's a reusable function that builds a descriptive string with all the attributes 
of the file:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' This routine also works with open files
' and raises an error if the file doesn't exist.
Function GetAttrDescr(filename As String) As String
    Dim result As String, attr As Long
    attr = GetAttr(filename)
    ' GetAttr also works with directories.
    If attr And vbDirectory Then result = result &amp; &quot; Directory&quot;
    If attr And vbReadOnly Then result = result &amp; &quot; ReadOnly&quot;
    If attr And vbHidden Then result = result &amp; &quot; Hidden&quot;
    If attr And vbSystem Then result = result &amp; &quot; System&quot;
    If attr And vbArchive Then result = result &amp; &quot; Archive&quot;
    ' Discard the first (extra) space.
    GetAttrDescr = Mid$(result, 2)
End Function
</pre>
</td></tr>
</table></p>

<p>Similarly, you change the attributes of a file or a directory by passing the 
<I>SetAttr</I> command a combination of values, as in the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Mark a file as Archive and Read-only.
filename = &quot;d:\VS98\Temporary.Dat&quot;
SetAttr filename, vbArchive + vbReadOnly
' Change a file from hidden to visible, and vice versa.
SetAttr filename, GetAttr(filename) Xor vbHidden
</pre>
</td></tr>
</table></p>

<p>You can't use the <I>SetAttr</I> function on open files, and of course you can't 
morph a file into a directory (or vice versa) by flipping the value of the 
<I>vbDirectory </I>bit. You can determine two more pieces of information about a file without opening it: 
its length in bytes and its date and time of creation, which you do with the 
<I>FileLen</I> and <I>FileDateTime</I><B> 
</B>functions, respectively.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Print FileLen(&quot;d:\VS98\Temporary.Dat&quot;)         ' Returns a Long value
Print FileDateTime(&quot;d:\VS98\Temporary.Dat&quot;)    ' Returns a Date value
</pre>
</td></tr>
</table></p>

<p>You can use the <I>FileLen</I> function against open files too, but in this case 
you'll retrieve the length that was current before the file was opened.</p>

<A NAME="186"><h2>Handling Directories</h2></A>
<p>You can learn the name of the current directory using the 
<I>CurDir$</I> function (or its <I>$</I>-less equivalent, 
<I>CurDir</I>). When this function is passed a drive letter, it returns 
the current directory on that particular path. In this example, I assume that Microsoft 
Visual Studio was installed on drive D and that Microsoft Windows NT resides on drive 
C, but you'll probably get different results on your system:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Always use On Error--the current dir might be on a removed floppy disk.
On Error Resume Next
Print CurDir$                   ' Displays &quot;D:\VisStudio\VB98&quot;
' The current directory on drive C:
Print = CurDir$(&quot;c&quot;)            ' Displays &quot;C:\WinNT\System&quot;
</pre>
</td></tr>
</table></p>

<p>You can change both current drive and directory using the 
<I>ChDrive</I> and <I>ChDir</I> commands, respectively. If you execute a 
<I>ChDir</I> command on a drive that's not current, you're actually changing the current directory on that drive only, so you 
must use both commands to ensure you're changing the system's current directory:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Make &quot;C:\Windows&quot; the current directory. 
On Error Resume Next
SaveCurDir = CurDir$
ChDrive &quot;C:&quot;: ChDir &quot;C:\Windows&quot;
' Do whatever you need to do...
' ....
' and then restore the original current directory.
ChDrive SaveCurDir: ChDir SaveCurDir
</pre>
</td></tr>
</table></p>

<p>You can also create and remove subdirectories using the 
<I>MkDir</I> and <I>RmDir</I> commands, respectively:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Create a new folder in the current directory, and then make it current.
On Error Resume Next
MkDir &quot;TempDir&quot;
ChDir CurDir$ &amp; &quot;\TempDir&quot;      ' (Assumes current dir is not the root)
' Do whatever you need to do...
' ....
' then restore the original directory and delete the temporary folder.
' You can't remove directories with files in them.
Kill &quot;*.*&quot;                      ' No need for absolute path.
ChDir &quot;..&quot;                      ' Move to the parent directory.
RmDir CurDir$ &amp; &quot;\TempDir&quot;      ' Remove the temporary directory.
</pre>
</td></tr>
</table></p>

<p>You can rename a directory using the 
<I>Name</I> command, but you can't move a directory elsewhere:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Assumes that &quot;TempDir&quot; is a subdirectory of the current directory
Name &quot;TempDir&quot; As &quot;TempXXX&quot;
</pre>
</td></tr>
</table>
</p>

<A NAME="187"><h2>Iterating Over All Files in a Directory</h2></A>
<p>The VBA's <I>Dir</I> function offers a primitive but effective way to iterate over all the 
files in a directory. You start by calling the 
<I>Dir</I> function with a <I>filespec </I>argument 
(which can include wildcards) and an optional argument that specifies the attributes of 
the files you're interested in. Then at each iteration, you call 
<I>Dir</I> without any argument until it returns an empty string. The following routine returns an array of 
filenames in a given directory and also demonstrates the correct way to set up the loop:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Function GetFiles(filespec As String, Optional Attributes As _
    VbFileAttribute) As String()
    Dim result() As String
    Dim filename As String, count As Long, path2 As String
    Const ALLOC_CHUNK = 50
    ReDim result(0 To ALLOC_CHUNK) As String
    filename = Dir$(filespec, Attributes)
    Do While Len(filename)
        count = count + 1
        If count &gt; UBound(result) Then
            ' Resize the result array if necessary.
            ReDim Preserve result(0 To count + ALLOC_CHUNK) As String
        End If
        result(count) = filename
        ' Get ready for the next iteration.
        filename = Dir$
    Loop
    ' Trim the result array.
    ReDim Preserve result(0 To count) As String
    GetFiles = result
End Function
</pre>
</td></tr>
</table></p>

<p><div class="tip"><blockquote><b>TIP</b><hr>
You can also use the 
<I>Dir$</I> function to indirectly test for the existence of 
a file or a directory, using the following functions:

<p><table><tr><td>
<pre>
Function FileExists(filename As String) As Boolean
    On Error Resume Next
    FileExists = (Dir$(filename) &lt;&gt; &quot;&quot;)
End Function
Function DirExists(path As String) As Boolean
    On Error Resume Next
    DirExists = (Dir$(path &amp; &quot;\nul&quot;) &lt;&gt; &quot;&quot;)
End Function
</pre>
</td></tr>
</table></p>

<p>While the code in <I>FileExists</I> is rather straightforward, you might be 
puzzled by <I>DirExists</I>: where does that 
&quot;<I>\nul</I>&quot; string come from? The explanation 
dates back to MS-DOS days and its special filenames 
&quot;<I>nul</I>&quot;, &quot;<I>con</I>&quot;, and so on. 
These names actually refer to special devices (the null device, the console device, 
and so on) that appear in any directory you search, provided that the directory 
actually exists. This approach works with any directory, whereas using 
<I>Dir$(</I>&quot;<I>*.*</I>&quot;<I>)</I> would fail when you're testing the existence of empty directories.</p>
</blockquote></div></p>

<p>The <I>GetFiles</I> routine can be used to load a bunch of filenames into a 
ComboBox control. This is particularly effective if you set the control's 
<I>Sorted</I> property to True:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim Files() As String, i As Long
' All files in C:\WINDOWS\SYSTEM directory, including system/hidden ones.
Files() = GetFiles(&quot;C:\windows\system\*.*&quot;, vbNormal + vbHidden _
    + vbSystem)
Print &quot;Found &quot; &amp; UBound(Files) &amp; &quot; files.&quot;
For i = 1 To UBound(Files)
    Combo1.AddItem Files(i)
Next
</pre>
</td></tr>
</table></p>

<p>If you include the <I>vbDirectory</I> bit in the 
<I>Attribute</I> argument, the <I>Dir$</I> function 
also returns the names of the directories in its results. You can use this feature to create 
a <I>GetDirectories</I> function that returns the names of all the subdirectories in a given path:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Function GetDirectories(path As String, Optional Attributes As _
    VbFileAttribute, Optional IncludePath As Boolean) As String()
    Dim result() As String
    Dim dirname As String, count As Long, path2 As String
    Const ALLOC_CHUNK = 50
    ReDim result(ALLOC_CHUNK) As String
    ' Build the path name + backslash.
    path2 = path
    If Right$(path2, 1) &lt;&gt; &quot;\&quot; Then path2 = path2 &amp; &quot;\&quot;
    dirname = Dir$(path2 &amp; &quot;*.*&quot;, vbDirectory Or Attributes)
    Do While Len(dirname)
        If dirname = &quot;.&quot; Or dirname = &quot;..&quot; Then
            ' Exclude the &quot;.&quot; and &quot;..&quot; entries.
        ElseIf (GetAttr(path2 &amp; dirname) And vbDirectory) = 0 Then
            ' This is a regular file.
        Else
            ' This is a directory.
            count = count + 1
            If count &gt; UBound(result) Then
                ' Resize the result array if necessary.
                ReDim Preserve result(count + ALLOC_CHUNK) As String
            End If
            ' Include the path if requested.
            If IncludePath Then dirname = path2 &amp; dirname
            result(count) = dirname
        End If
        dirname = Dir$
    Loop
    ' Trim the result array.
    ReDim Preserve result(count) As String
    GetDirectories = result
End Function
</pre>
</td></tr>
</table></p>

<p>A common programming task is to process all files in a directory tree. 
Thanks to the routines I just listed and the ability to create recursive routines, this 
becomes (almost) child's play:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Load the names of all executable files in a directory tree into a ListBox.
' Note: this is a recursive routine.
Sub ListExecutableFiles(ByVal path As String, lst As ListBox)
    Dim names() As String, i As Long, j As Integer
    ' Ensure that there is a trailing backslash.
    If Right(path, 1) &lt;&gt; &quot;\&quot; Then path = path &amp; &quot;\&quot;
    ' Get the list of executable files.
    For j = 1 To 3
        ' At each iteration search for a different extension.
        names() = GetFiles(path &amp; &quot;*.&quot; &amp; Choose(j, &quot;exe&quot;, &quot;bat&quot;, &quot;com&quot;))
        ' Load partial results in the ListBox lst.
        For i = 1 To UBound(names)
            lst.AddItem path &amp; names(i)
        Next
    Next
    ' Get the list of subdirectories, including hidden ones,
    ' and call this routine recursively on all of them.
    names() = GetDirectories(path, vbHidden)
    For i = 1 To UBound(names)
        ListExecutableFiles path &amp; names(i), lst
    Next
End Sub
</pre>
</td></tr>
</table>
</p>

<A NAME="188"><h2>Processing Text Files</h2></A>
<p>Text files are the simplest type of files to process. You open them using the 
<I>Open </I>statement with the <I>For Input</I>, 
<I>For Output</I>, or <I>For 
Appending</I> clause, and then start reading data from them or writing data to them. To open a file&#8212;either text or a 
binary file&#8212;you need a file number, as in the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Error if file #1 is already open
Open &quot;readme.txt&quot; For Input As #1
</pre>
</td></tr>
</table></p>

<p>Within an individual application, you're usually able to assign unique file 
numbers to the different routines that deal with files. However, this approach 
severely hinders code reusability, so I suggest that you use the 
<I>FreeFile</I> function and query Visual Basic about the first available file number:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim fnum As Integer
fnum = FreeFile()
Open &quot;readme.txt&quot; For Input As #fnum
</pre>
</td></tr>
</table></p>

<p>After you open a text file for input, you usually read it one line of text at a 
time using the <I>Line Input</I> statement until the 
<I>EOF</I> (End-Of-File) function returns True. 
Any file routine must also take errors into account, both when it opens the file and 
when it reads its contents. But you can often do a better job if you use the 
<I>LOF</I> function to determine the length of the file and read all characters in one operation with 
the <I>Input$</I> function. Here's a reusable routine that uses this optimized approach:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Function ReadTextFileContents(filename As String) As String
    Dim fnum As Integer, isOpen As Boolean
    On Error GoTo Error_Handler
    ' Get the next free file number.
    fnum = FreeFile()
    Open filename For Input As #fnum
    ' If execution flow got here, the file has been open without error.
    isOpen = True
    ' Read the entire contents in one single operation.
    ReadTextFileContents = Input(LOF(fnum), fnum)
    ' Intentionally flow into the error handler to close the file.
Error_Handler:
    ' Raise the error (if any), but first close the file.
    If isOpen Then Close #fnum
    If Err Then Err.Raise Err.Number, , Err.Description
End Function

' Load a text file into a TextBox control.
Text1.Text = ReadTextFileContents(&quot;c:\bootlog.txt&quot;)
</pre>
</td></tr>
</table></p>

<p>When you want to write data to a file, you open the file using the 
<I>For</I> <I>Output</I> clause if you want to replace the current contents or the 
<I>For Append</I> clause to simply append new data to the file. You usually send output to this output file with 
a series of <I>Print #</I> statements, but it's much faster if you gather your output in a 
string and print that instead. Here's a reusable function that does it all for you:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Sub WriteTextFileContents(Text As String, filename As String, _
    Optional AppendMode As Boolean)
    Dim fnum As Integer, isOpen As Boolean
    On Error GoTo Error_Handler
    ' Get the next free file number.
    fnum = FreeFile()
    If AppendMode Then
         Open filename For Append As #fnum
     Else
         Open filename For Output As #fnum
     End If
     ' If execution flow gets here, the file has been opened correctly.
     isOpen = True
     ' Print to the file in one single operation.
     Print #fnum, Text
     ' Intentionally flow into the error handler to close the file.
Error_Handler:
    ' Raise the error (if any), but first close the file.
    If isOpen Then Close #fnum
    If Err Then Err.Raise Err.Number, , Err.Description
End Sub
</pre>
</td></tr>
</table></p>

<p><img src="images/new.jpg" width=102 height=87 border=0></p>

<p>Even if Visual Basic 6 didn't add any function specifically intended to 
work with text files, its new <I>Split</I> function turns out to be extremely useful for text 
processing. Let's say that your text file contains items to be loaded into a ListBox 
or ComboBox control. You can't use the 
<I>ReadTextFileContents</I> routine that I showed you previously to load it directly in the control, but you can use it to make 
your code more concise:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Sub TextFileToListbox(lst As ListBox, filename As String)
    Dim items() As String, i As Long
    ' Read the file's contents, and split it into an array of strings.
    ' (Exit here if any error occurs.)
    items() = Split(ReadTextFileContents(filename), vbCrLf)
    ' Load all non-empty items into the ListBox.
    For i = LBound(items) To UBound(items)
        If Len(items(i)) &gt; 0 Then lst.AddItem items(i)
    Next
End Sub
</pre>
</td></tr>
</table>
</p>

<A NAME="189"><h2>Processing Delimited Text Files</h2></A>
<p>Delimited text files contain multiple fields in each line of text. Even if no 
serious programmer would ever use delimited text files as the primary means to store 
an application's data, these files nevertheless play an important role because they 
offer a great way to exchange data between different database formats. For 
example, delimited text files are often the only viable way to import and export data to 
mainframe databases. Here's the structure of a simple semicolon-delimited text file. 
(Note that it's customary for the first line of the file to hold the field's names.)</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Name;Department;Salary
John Smith;Marketing;80000
Anne Lipton;Sales;75000
Robert Douglas;Administration;70000
</pre>
</td></tr>
</table></p>

<p>Taken together, the <I>Split</I> and the 
<I>Join</I> functions are especially useful for 
importing and exporting delimited text files. For example, see how easy it is to import 
the contents of a semicolon-delimited data file into an array of arrays:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' The contents of a delimited text file as an array of strings arrays
' NOTE: requires the GetTextFileLines routine
Function ImportDelimitedFile(filename As String, _
    Optional delimiter As String = vbTab) As Variant()
    Dim lines() As String, i As Long
    ' Get all lines in the file.
    lines() = Split(ReadTextFileContents(filename), vbCrLf)
    ' To quickly delete all empty lines, load them with a special char.
    For i = 0 To UBound(lines)
        If Len(lines(i)) = 0 Then lines(i) = vbNullChar
    Next
    ' Then use the Filter function to delete these lines.
    lines() = Filter(lines(), vbNullChar, False)
    ' Create a string array out of each line of text
    ' and store it in a Variant element.
    ReDim values(0 To UBound(lines)) As Variant
    For i = 0 To UBound(lines)
        values(i) = Split(lines(i), delimiter)
    Next
    ImportDelimitedFile = values()
End Function

' An example of using the ImportDelimitedFile routine
Dim values() As Variant, i As Long
values() = ImportDelimitedFile(&quot;c:\datafile.txt&quot;, &quot;;&quot;)
' Values(0)(n) is the name of the Nth field.
' Values(i)(n) is the value of the Nth field on the ith record.
' For example, see how you can increment employees' salaries by 20%.
For i = 1 to UBound(values)
    values(i)(2) = values(i)(2) * 1.2
Next
</pre>
</td></tr>
</table></p>

<p>Using an array of arrays is a particularly good strategy because it makes it 
easy to add new records:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Add a new record.
ReDim Preserve values(0 To UBound(values) + 1) As Variant
values(UBound(values)) = Split(&quot;Roscoe Powell;Sales;80000&quot;, &quot;;&quot;)
</pre>
</td></tr>
</table></p>

<p>or delete existing ones:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Delete the Nth record
For i = n To UBound(values) - 1
    values(i) = values(i + 1)
Next
ReDim Preserve values(0 To UBound(values) _ 1) As Variant
</pre>
</td></tr>
</table></p>

<p>Writing an array of string arrays back to a delimited file is also a simple 
task, thanks to this reusable routine that builds on the 
<I>Join</I> function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Write the contents of an array of string arrays to a delimited
' text file.
' NOTE: requires the WriteTextFileContents routine
Sub ExportDelimitedFile(values() As Variant, filename As String, _
    Optional delimiter As String = vbTab)
    Dim i As Long
    ' Rebuild the individual lines of text of the file.
    ReDim lines(0 To UBound(values)) As String
    For i = 0 To UBound(values)
        lines(i) = Join(values(i), delimiter)
    Next
    ' Create CRLFs among records, and write them.
    WriteTextFileContents Join(lines, vbCrLf), filename
End Sub

' Write the modified data back to the delimited file.
ExportDelimitedFile values(), &quot;C:\datafile.txt&quot;, &quot;;&quot;
</pre>
</td></tr>
</table></p>

<p>All the routines described in this section rely on the assumption that 
the delimited text file is small enough to be held in memory. While this might 
sound like a serious limitation, in practice text files are mostly used to create small 
archives or to move small quantities of data between different database formats. 
If you find that you're having problems because of the size of the array, you 
need to read and write it in chunks using multiple 
<I>Line Input #</I> and <I>Print # </I>statements. In most cases, you can deal with files up to 1 or 2 megabytes in 
size (or even more, depending on how much RAM memory you 
have) without any problem.</p>

<A NAME="190"><h2>Processing Binary Files</h2></A>
<p>To open a binary file, you use the <I>Open</I> statement with the 
<I>For Random</I> or <I>For</I><B> 
</B><I>Binary</I> options. Let me first explain the latter mode, which is the simpler of the 
two. In <I>Binary</I> mode, you write to file using the 
<I>Put</I> statement and read data back 
with the <I>Get</I> statement. Visual Basic determines how many bytes are written or read 
by looking at the structure of the variable you pass as the last argument:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim numEls As Long, text As String
numEls = 12345: text = &quot;A 16-char string&quot;
' Binary files are automatically created if necessary.
Open &quot;data.bin&quot; For Binary As #1
Put #1, , numEls            ' Put writes 4 bytes.
Put #1, , text              ' Put writes 16 bytes (ANSI format).
</pre>
</td></tr>
</table></p>

<p>When reading data back, you must repeat the same sequence of statements 
but it's up to you to correctly dimension variable length strings. You don't need to 
close and reopen a binary file because you can use the 
<I>Seek</I> statement to reposition the file pointer to a specific byte:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Seek #1, 1                  ' Back to the beginning (first byte is byte 1)
Get #1, , numEls            ' All Long values are 4 bytes.
text = Space$(16)           ' Prepare to read 16 bytes.
Get #1, , text              ' Do it.
</pre>
</td></tr>
</table></p>

<p>Alternatively, you can move the file pointer right before writing or reading 
data using a second argument, as in this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Get #1, 1, numEls           ' Same as Seek + Get
</pre>
</td></tr>
</table></p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>
When you open a binary file, Visual Basic automatically creates 
it if it doesn't exist. Therefore, you can't use an 
<I>On Error</I> statement to determine whether the file exists already. In this case, use the 
<I>Dir$</I> function to ascertain that the file actually exists before opening it.
</blockquote></div></p>

<p>You can quickly write an entire array to disk and read it back in one 
single operation; but because you must correctly dimension the array before reading it, 
you'll also have to prefix the data with the number of actual elements, in most cases:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Store a zero-based array of Double.
Put #1, 1, CLng(UBound(arr)) ' First store the UBound value.
Put #1, , arr()              ' Then store all items in one shot.
' read it back
Dim LastItem As Long 
Get #1, 1, LastItem          ' Read the number of items.
ReDim arr2(0 To LastItem) As Double
Get #1, , arr2()             ' Read the array in memory in one operation.
Close #1
</pre>
</td></tr>
</table></p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>
If you read data back using a read sequence different from the 
original write sequence, you'll read wrong data into your variables. In some 
cases, this mistake might cause the Visual Basic environment to crash when trying 
to display the contents of those variables. For this reason, always 
double-check the order of write and read operations. When in doubt, save your work 
before running the code.
</blockquote></div></p>

<p>When you're reading from a binary file, you can't use the 
<I>EOF</I> function to find out when you're at the end of the data; instead, you should test the value 
returned by the <I>LOF</I> function (the length of the file in bytes) and use the 
<I>Seek</I> function to determine when you have read all the data in it:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Do While Seek(1) &lt; LOF(1)
    ' Continue to read.
      ....
Loop
</pre>
</td></tr>
</table></p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>
When storing strings to disk&#8212;either to text or binary 
files&#8212;Visual Basic automatically converts them from Unicode to ANSI, which saves a 
noticeable amount of disk space and lets you exchange data with 16-bit Visual 
Basic applications. If you're writing Unicode-aware programs for the 
international market, however, this behavior gets in the way and can cause loss of data 
because the string you're reading back from a file won't necessarily match the 
one you had stored previously. To fix a problem, you have to move the string into 
a <I>Byte</I> array and save that instead:

<p><table><tr><td>
<pre>
Dim v As Variant, s As String, b() As Byte
s = &quot;This is a string that you want to save in Unicode format&quot;
b() = s: v = b()     ' You need this double step.
Put #1, , v          ' Write that to disk.

' Read it back.
Get #1, 1, v: s = v  ' No need for intermediary Byte array here.
</pre>
</td></tr>
</table></p>
</blockquote></div></p>

<p>Opening a binary file using the <I>For 
Random</I> clause differs from what I have illustrated so far in a number of important respects:</p>

<UL>
<p><li> Data is written to and read from file as if it were a record of fixed 
length. Such a record length can be specified when you open the file (using 
the <I>Len</I> clause in the <I>Open</I> statement), or it's evaluated during individual 
<I>Put</I> and <I>Get</I> statements. If the actual data passed to a 
<I>Put</I> statement is shorter than the expected record length, Visual Basic pads it with random 
characters (more precisely, the current contents of the internal file buffer). 
If it's longer, an error occurs.</li></p>

<p><li> The argument for the <I>Seek</I> command, as well as the second argument 
for <I>Put</I> and <I>Get</I> statements, is meant to be the record number, not the 
absolute byte position in the binary file. The first record in a file is record 1.</li></p>

<p><li> You don't have to worry about storing and retrieving variable-length 
data, including strings and arrays, because the 
<I>Put</I> and <I>Get</I> statements correctly deal with those cases. But I strongly advise that you stay clear of 
UDTs that contain conventional (non-fixed-length) strings and dynamic 
arrays so that the length of the record doesn't depend on its actual contents.</li></p>
</UL>
 
<p>Strings stored to binary files opened with the 
<I>For Random</I> clause are prefixed by a 2-byte value that indicates the number of characters that follow. This means 
that you can't write a string that contains more than 32,767 characters, which is also 
the largest valid record size. To write a longer string, you should use the 
<I>For Binary</I> clause. </p>

<p>One final note: All the code examples seen so far assume that we're 
working in a single-user environment and don't account for issues such as the errors you 
get when opening a file already opened by another user, or the capability to lock all 
or a portion of a data file using the <I>Lock </I>statement (and later unlock it using the 
<I>Unlock </I>statement). For more information, see the Visual Basic documentation.</p>

<p><div class="tip"><blockquote><b>TIP</b><hr>
If you don't want to get involved with lots of additional evaluations 
when writing and reading data in a binary file, you can follow a shorter path using 
an intermediate Variant variable. If you store a value of any type (other than 
object) into a Variant variable and then write the variable to a binary file, Visual 
Basic writes the type of the variable (that is, the 
<I>VarType</I> return value) and then the data. If the variable holds a string or an array, Visual Basic also stores 
enough information to read exactly the necessary number of bytes, freeing you from 
additional read statements:

<p><table><tr><td>
<pre>
Dim v As Variant, s(100) As String, i As Long
' Fill the s() array with data... (omitted)
Open &quot;c:\binary.dat&quot; For Binary As #1
v = s()              ' Store the array in a Variant variable,
Put #1, , v          ' and write that to disk.
v = Empty            ' Release memory.

' Read data back.
Dim v2 As Variant, s2() As String
Get #1, 1, v2        ' Read data in the Variant variable,
s2() = v2            ' and then move it to the real array.
v2 = Empty           ' Release memory. 
Close #1
</pre>
</td></tr>
</table></p>

<p>This approach also works with multidimensional arrays.</p>
</blockquote></div></p>

<A NAME="191"><h2>The FileSystemObject Hierarchy</h2></A>
<p><img src="images/new.jpg" width=102 height=87 border=0></p>

<p> Visual Basic 6 comes with a new library of file commands, which enables 
programmers to easily scan drives and directories, perform basic file operations 
(including copy, delete, move, and so on), and extract information not available through 
regular Visual Basic functions. But in my opinion, the best feature of the new 
commands is that you can do all that using a modern, coherent, object-oriented syntax, 
which makes your code much more readable. All this power is provided in the form of 
the external FileSystemObject hierarchy, embedded in the Microsoft Scripting Library, 
the library that also hosts the Dictionary object. (See <a href="ch04a.htm">Chapter 4</a> for instructions about 
installing and using this library.) The FileSystemObject hierarchy includes many 
complex objects (see Figure 5-1), and each object exposes many interesting 
properties and methods.</p>

<p>
<A HREF="javascript:fullSize('F05ph01x.htm')"> <img src="images/F05ph01.JPG" width=404 height=313 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 5-1.</B> <i>The FileSystemObject hierarchy.</i><!--/caption-->
</p>

<A NAME="192"><h3>The FileSystemObject root object</h3></A>
<p>At the root of the hierarchy is the FileSystemObject object itself. It exposes 
many methods and only one property, <I>Drives</I>, which returns the collection of all the 
drives in the system. The FileSystemObject object (abbreviated as FSO in the 
following text and code) is the only creatable object in the hierarchy&#8212;that is, it's the 
only object that can be declared using the 
<I>New</I> keyword. All the other objects are 
dependent objects that derive from this one and are exposed in the form of methods 
or properties. See how easy it is to fill an array with the list of all the ready drives 
in the system and their capacities:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim fso As New Scripting.FileSystemObject, dr As Scripting.Drive
On Error Resume Next        ' Needed for not-ready drives
For Each dr In fso.Drives
    Print dr.DriveLetter &amp; &quot; [&quot; &amp; dr.TotalSize &amp; &quot;]&quot;
Next
</pre>
</td></tr>
</table></p>

<p>Table 5-3 below summarizes the many methods exposed by 
the FSO object. A few of them are also available (often with different names and 
syntax) as methods of secondary Folder and File objects. Most of these methods add 
functionality to commands already present in Visual Basic. For example, you can 
delete non-empty folders (be <I>very </I>careful!) and copy and rename multiple files and 
directories with one single command. You can also easily extract portions of a 
filename without having to write special routines.</p>

<p><B>Table 5-3.</B> <i>All the methods of the FileSystemObject object.</i>  </p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Syntax</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top"><I>BuildPath (Path</I>,<I> Name)</I></td>
<td valign="top">Returns a complete filename, obtained by concatenating the path (relative or absolute) and name.</td>
</tr>
<tr>
<td valign="top"><I>CopyFile Source</I>, <I>Destination</I>,<I> [Overwrite]</I></td>
<td valign="top">Copies one or more files: <I>Source </I>can include wildcards, and <I>Destination </I>is considered to be a directory if it ends with a backslash. It overwrites existing files unless you set <I>Overwrite </I>to False.</td>
</tr>
<tr>
<td valign="top"><I>CopyFolder Source</I>, <I>Destination</I>, [<I>Overwrite</I>]</td>
<td valign="top">Same as <I>CopyFile</I>, but copies entire folders with their contents (subfolders and files). If <I>Destination </I>doesn't correspond to an existing directory, it's created (but not if <I>Source </I>contains wildcards).</td>
</tr>
<tr>
<td valign="top"><I>CreateFolder(Path) As Folder</I></td>
<td valign="top">Creates a new Folder object and returns it; raises an error if the folder already exists.</td>
</tr>
<tr>
<td valign="top"><I>CreateTextFile(FileName</I>,<I> [Overwrite]</I>, <I>[Unicode]) As TextStream</I></td>
<td valign="top">Creates a new TextFile object and returns it; set <I>Overwrite</I> = False to avoid overwriting an existing file; set <I>Unicode</I> = True to create a Unicode TextFile object.</td>
</tr>
<tr>
<td valign="top"><I>DeleteFile FileSpec</I>,<I> [Force]</I></td>
<td valign="top">Deletes one or more files. <I>FileSpec</I> can include wildcards; set <I>Force</I> = True to force the deletion of read-only files.</td>
</tr>
<tr>
<td valign="top"><I>DeleteFolder(FolderSpec</I>,<I> [Force])</I></td>
<td valign="top">Deletes one or more folders, together with their contents; set <I>Force</I> = True to force the deletion of read-only files.</td>
</tr>
<tr>
<td valign="top"><I>DriveExists(DriveName)</I></td>
<td valign="top">Returns True if a given logical drive exists.</td>
</tr>
<tr>
<td valign="top"><I>FileExists(FileName)</I></td>
<td valign="top">Returns True if a given file exists. (The path can be relative to the current directory.)</td>
</tr>
<tr>
<td valign="top"><I>FolderExists(FolderName)</I></td>
<td valign="top">Returns True if a given folder exists. (The path can be relative to the current directory.)</td>
</tr>
<tr>
<td valign="top"><I>GetAbsolutePathName(Path)</I></td>
<td valign="top">Converts a path relative to the current directory into an absolute path.</td>
</tr>
<tr>
<td valign="top"><I>GetBaseName(Filename)</I></td>
<td valign="top">Extract the base filename (without its path and extension); it doesn't check whether the file and/or the path actually exist.</td>
</tr>
<tr>
<td valign="top"><I>GetDrive(DriveName) As Drive</I></td>
<td valign="top">Returns the Drive object that corresponds to the letter or the UNC path passed as an argument. (It checks that the drive actually exists).</td>
</tr>
<tr>
<td valign="top"><I>GetDriveName(Path)</I></td>
<td valign="top">Extracts the drive from a path.</td>
</tr>
<tr>
<td valign="top"><I>GetExtensionName(FileName)</I></td>
<td valign="top">Extracts the extension string from a filename.</td>
</tr>
<tr>
<td valign="top"><I>GetFile(FileName)</I></td>
<td valign="top">Returns the File object corresponding to the name passed as the argument. (Can be absolute or relative to the current directory.)</td>
</tr>
<tr>
<td valign="top"><I>GetFileName(</I></td>
<td valign="top">Extract the filename (without its path but with its extension); it doesn't check whether the file and/or the path actually exist.</td>
</tr>
<tr>
<td valign="top"><I>GetFolder(FolderName) As Folder</I></td>
<td valign="top">Returns the Folder object corresponding to the path passed as the argument. (Can be absolute or relative to the current directory.)</td>
</tr>
<tr>
<td valign="top"><I>GetParentFolderName(Path)</I></td>
<td valign="top">Returns the name of the parent directory of the directory passed as the argument (or an empty string if the parent directory doesn't exist).</td>
</tr>
<tr>
<td valign="top"><I>GetSpecialFolder(SpecialFolder) As Folder</I></td>
<td valign="top">Returns a Folder object that corresponds to one of the special Windows directories. <I>SpecialFolder </I>can be 0-WindowsFolder, 1-SystemFolder, 2-TemporaryFolder.</td>
</tr>
<tr>
<td valign="top"><I>GetTempName()</I></td>
<td valign="top">Returns the name of a nonexistent file that can be used as a temporary file.</td>
</tr>
<tr>
<td valign="top"><I>MoveFile(Source</I>, <I>Destination)</I></td>
<td valign="top">Same as <I>CopyFile</I>, but it deletes the source file. It can also move among different drives, if this function is supported by the operating system.</td>
</tr>
<tr>
<td valign="top"><I>MoveFolder(Source</I>, <I>Destination)</I></td>
<td valign="top">Same as <I>MoveFile</I>, but works on directories instead.</td>
</tr>
<tr>
<td valign="top"><I>OpenTextFile(FileName</I>,<I> </I><I>[IOMode], [Create]</I>,<I> </I><I>[Format])As TextStream</I></td>
<td valign="top">Opens a text file and returns the corresponding TextStream object. <I>IOMode </I>can be one or a combination (use the OR operator) of the following constants: 1-ForReading, 2-ForWriting, 8-ForAppending; set Create to True if you want to create a new file; Format can be 0-TristateFalse (ANSI), -1-TristateTrue (Unicode) or -2-TristateUseDefault (determined by the system).</td>
</tr>
</table></p>

<A NAME="193"><h3>The Drive object</h3></A>
<p>This object exposes only properties (no methods), all of which are summarized 
in Table 5-4. All the properties are read-only, except 
the <I>VolumeName</I> property. This short code snippet determines the local drives that 
are ready and have at least 100 MB of free space on them:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim fso As New Scripting.FileSystemObject, dr As Scripting.Drive
For Each dr In fso.Drives
    If dr.IsReady Then
        If dr.DriveType = Fixed Or dr.DriveType = Removable Then
            ' 2 ^ 20 equals one megabyte.
            If dr.FreeSpace &gt; 100 * 2 ^ 20 Then
                Print dr.Path &amp; &quot; [&quot; &amp; dr.VolumeName &amp; &quot;] = &quot; _
                    &amp; dr.FreeSpace
            End If
        End If
    End If
Next
</pre>
</td></tr>
</table></p>

<p><B>Table 5-4.</B> <i>All the properties of the Drive object.</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Syntax</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top"><I>AvailableSpace</I></td>
<td valign="top">The free space on the drive, in bytes; it usually coincides with the value returned by the <I>FreeSpace</I> property, unless the operating system supports disk quotas.</td>
</tr>
<tr>
<td valign="top"><I>DriveLetter</I></td>
<td valign="top">The letter associated with the drive or an empty string for network drives not associated with a letter.</td>
</tr>
<tr>
<td valign="top"><I>DriveType</I></td>
<td valign="top">A constant that indicates the type of the drive: 0-Unknown, 1-Removable, 2-Fixed, 3-Remote, 4-CDRom, 5-RamDisk.</td>
</tr>
<tr>
<td valign="top"><I>FileSystem</I></td>
<td valign="top">A string that describes the file system in use: FAT, NTFS, CDFS.</td>
</tr>
<tr>
<td valign="top"><I>FreeSpace</I></td>
<td valign="top">The free space on the drive. (See <I>AvailableSpace.</I>)</td>
</tr>
<tr>
<td valign="top"><I>IsReady</I></td>
<td valign="top">True if the drive is ready, False otherwise.</td>
</tr>
<tr>
<td valign="top"><I>Path</I></td>
<td valign="top">The path associated with the drive, without the backslash (for example, C:).</td>
</tr>
<tr>
<td valign="top"><I>RootFolder</I></td>
<td valign="top">The Folder object that corresponds to the root directory.</td>
</tr>
<tr>
<td valign="top"><I>SerialNumber</I></td>
<td valign="top">A Long number that corresponds to the serial disk number.</td>
</tr>
<tr>
<td valign="top"><I>ShareName</I></td>
<td valign="top">The network shared name for the drive or an empty string if it isn't a network drive.</td>
</tr>
<tr>
<td valign="top"><I>TotalSize</I></td>
<td valign="top">The total capacity of the drive, in bytes.</td>
</tr>
<tr>
<td valign="top"><I>VolumeName</I></td>
<td valign="top">The disk label (can be read and written).</td>
</tr>
</table></p>

<A NAME="194"><h3>The Folder object </h3></A>
<p>The Folder object represents an individual subdirectory. You can obtain a reference 
to such an object in different ways: by using the 
<I>GetFolder</I> or <I>GetSpecialFolder</I> 
methods of the FileSystemObject object, through the 
<I>RootFolder</I> property of a Drive object, through the 
<I>ParentFolder</I> property of a File object or another Folder object, or by 
iterating over the <I>SubFolders</I> collection of another Folder object. The Folder object 
exposes a number of interesting properties (see Table 5-5), but only the 
<I>Attribute</I> and <I>Name</I> properties can be written to. The most intriguing properties are probably the 
<I>SubFolders</I> and <I>Files</I> collections, which let you iterate through subdirectories and files using 
an elegant and concise syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Print the names of all first-level directories on all drives
' together with their short 8.3 names.
Dim fso As New Scripting.FileSystemObject
Dim dr As Scripting.Drive, fld As Scripting.Folder
On Error Resume Next
For Each dr In fso.Drives
    If dr.IsReady Then
        Print dr.RootFolder.Path       ' The root folder.
        For Each fld In dr.RootFolder.SubFolders
            Print fld.Path &amp; &quot; [&quot; &amp; fld.ShortName &amp; &quot;]&quot;
        Next
    End If
Next
</pre>
</td></tr>
</table></p>

<p><B>Table 5-5.</B> <i>All the properties of Folder and File objects.</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Syntax</i></th>
<th><i>Description</i></th>
<th><i>Applies To</i></th>
</tr>
<tr>
<td valign="top"><I>Attributes</I></td>
<td valign="top">The attributes of the file or the folder, as a combination of the following constants: 0- Normal, 1-ReadOnly, 2-Hidden, 4-System, 8-Volume, 16-Directory, 32-Archive, 64-Alias, 2048-Compressed. The attributes Volume, Directory, Alias, and Compressed can't be modified.</td>
<td valign="top">Folder and File</td>
</tr>
<tr>
<td valign="top"><I>DateCreated</I></td>
<td valign="top">Creation date (a read-only Date value).</td>
<td valign="top">Folder and File</td>
</tr>
<tr>
<td valign="top"><I>DateLastAccessed</I></td>
<td valign="top">The date of the last access (a read-only Date value).</td>
<td valign="top">Folder and File</td>
</tr>
<tr>
<td valign="top"><I>DateLastModified</I></td>
<td valign="top">The date of the last modification (a read-only Date value).</td>
<td valign="top">Folder and File</td>
</tr>
<tr>
<td valign="top"><I>Drive</I></td>
<td valign="top">The Drive object where the file or the folder is located.</td>
<td valign="top">Folder and File</td>
</tr>
<tr>
<td valign="top"><I>Files</I></td>
<td valign="top">The collection of all the contained File objects.</td>
<td valign="top">Folder only</td>
</tr>
<tr>
<td valign="top"><I>IsRootFolder</I></td>
<td valign="top">True if this is the root folder for its drive.</td>
<td valign="top">Folder only</td>
</tr>
<tr>
<td valign="top"><I>Name</I></td>
<td valign="top">The name of the folder or the file. Assign a new value to rename the object.</td>
<td valign="top">Folder and File</td>
</tr>
<tr>
<td valign="top"><I>ParentFolder</I></td>
<td valign="top">The parent Folder object.</td>
<td valign="top">Folder and File</td>
</tr>
<tr>
<td valign="top"><I>Path</I></td>
<td valign="top">The path of the Folder or the File. (This is the default property.)</td>
<td valign="top">Folder and File</td>
</tr>
<tr>
<td valign="top"><I>ShortName</I></td>
<td valign="top">The name of the object in 8.3 MS-DOS format.</td>
<td valign="top">Folder and File</td>
</tr>
<tr>
<td valign="top"><I>ShortPath</I></td>
<td valign="top">The path of the object in 8.3 MS-DOS format.</td>
<td valign="top">Folder and File</td>
</tr>
<tr>
<td valign="top"><I>Size</I></td>
<td valign="top">The size in bytes of a File object; the sum of the size of all contained files and sub folders for a Folder object.</td>
<td valign="top">Folder and File</td>
</tr>
<tr>
<td valign="top"><I>SubFolders</I></td>
<td valign="top">The collection of all the subfolders contained in this folder, including system and hidden ones.</td>
<td valign="top">Folder only</td>
</tr>
<tr>
<td valign="top"><I>Type</I></td>
<td valign="top">A string description of the object. For example: <I>fso.GetFolder(&quot;C:\Recycled&quot;).Type</I> returns &quot;Recycle Bin&quot;; for File objects, this value depends on their extensions (for example, &quot;Text Document&quot; for a TXT extension).</td>
<td valign="top">Folder and File</td>
</tr>
</table></p>

<p>The Folder object also exposes a few methods, summarized in Table 5-6. 
Note that you can often achieve similar results using appropriate methods of 
the main FSO object. You can also create a new Folder using the 
<I>Add</I> method applied to the 
<I>SubFolders</I> collection, as shown in the following 
recursive routine, which duplicates the directory structure of one drive onto 
another drive without also copying the contained files:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Call this routine to initiate the copy process.
' NOTE: the destination folder is created if necessary.
Sub DuplicateDirTree(SourcePath As String, DestPath As String)
    Dim fso As New Scripting.FileSystemObject
    Dim sourceFld As Scripting.Folder, destFld As Scripting.Folder
    ' The source folder must exist.
    Set sourceFld = fso.GetFolder(SourcePath)
    ' The destination folder is created if necessary.
    If fso.FolderExists(DestPath) Then
        Set destFld = fso.GetFolder(DestPath)
    Else
        Set destFld = fso.CreateFolder(DestPath)
    End If
    ' Jump to the recursive routine to do the real job.
    DuplicateDirTreeSub sourceFld, destFld
End Sub

Private Sub DuplicateDirTreeSub(source As Folder, destination As Folder)
    Dim sourceFld As Scripting.Folder, destFld As Scripting.Folder
    For Each sourceFld In source.SubFolders
        ' Copy this subfolder into destination folder.
        Set destFld = destination.SubFolders.Add(sourceFld.Name)
        ' Then repeat the process recursively for all
        ' the subfolders of the folder just considered.
        DuplicateDirTreeSub sourceFld, destFld
    Next
End Sub
</pre>
</td></tr>
</table></p>

<p><B>Table 5-6.</B> <i>All the methods of Folder and File objects.</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Syntax</i></th>
<th><i>Description</i></th>
<th><i>Applies To</i></th>
</tr>
<tr>
<td valign="top"><I>Copy Destination, [OverWriteFiles]</I></td>
<td valign="top">Copy the current File or the Folder object to another path; this is similar to FSO's <I>CopyFolder </I>and <I>CopyFile</I> methods, which are also able to copy multiple objects in one operation.</td>
<td valign="top">Folder and File</td>
</tr>
<tr>
<td valign="top"><I>CreateTextFile(FileName, [Overwrite], [Unicode]) As TextStream</I></td>
<td valign="top">Creates a text file in the current Folder and returns the corresponding TextStream object. See the corresponding FSO's method for an explanation of the individual arguments.</td>
<td valign="top">Folder only</td>
</tr>
<tr>
<td valign="top"><I>Delete [Force]</I></td>
<td valign="top">Delete this File or this Folder object (with all its contained subfolders and files). Similar to FSO's <I>DeleteFile</I> and <I>DeleteFolder</I> methods.</td>
<td valign="top">Folder and File</td>
</tr>
<tr>
<td valign="top"><I>Move DestinationPath</I></td>
<td valign="top">Move this File or Folder object to another path; similar to FSO's <I>MoveFile</I> and <I>MoveFolder</I> methods.</td>
<td valign="top">Folder and File</td>
</tr>
<tr>
<td valign="top"><I>OpenAsTextStream([IOMode], [Format]) As TextStream</I></td>
<td valign="top">Open this File object as a text file and return the corresponding TextStream object.</td>
<td valign="top">File only</td>
</tr>
</table></p>

<A NAME="195"><h3>The File object</h3></A>
<p>The File object represents a single file on disk. You can obtain a reference to 
such an object in two ways: by using the 
<I>GetFile</I> method of the FSO object or by 
iterating over the <I>Files</I> collection of its parent Folder object. Despite their different 
natures, File and Folder objects have many properties and methods in common, so I 
won't repeat the descriptions that were given in Tables 5-5 and 5-6.</p>

<p>A limitation of the FSO hierarchy is that you have no direct way to filter 
filenames using wildcards, as you can do with the 
<I>Dir$</I> function. All you can do is iterate 
through the <I>Files</I> collection of a Folder object and test the file's name, extensions, or 
other attributes to see whether you are interested in it as shown below.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' List all the DLL files in the C:\WINDOWS\SYSTEM directory.
Dim fso As New Scripting.FileSystemObject, fil As Scripting.File
For Each fil In fso.GetSpecialFolder(SystemFolder).Files
    If UCase$(fso.GetExtensionName(fil.Path)) = &quot;DLL&quot;  Then
        Print fil.Name
    End If
Next
</pre>
</td></tr>
</table></p>

<p>The FileSystemObject hierarchy doesn't permit many operations on files. 
More specifically, while you can list their properties (including many properties that 
are beyond the current capabilities of native VBA file functions), you can open files 
only in text mode, as I explain in the next section.</p>

<A NAME="196"><h3>The TextStream object</h3></A>
<p>The TextStream object represents a file opened in text mode. You can obtain a 
reference to such an object in the following ways: by using the 
<I>CreateTextFile</I> or the <I>OpenTextFile</I> method of the FSO object, by using the 
<I>CreateTextFile</I> method of a Folder object, or by using the 
<I>OpenAsTextStream</I> method of a File object. The 
TextStream object exposes a number of methods and read-only properties, all of 
which are described in Table 5-7. The 
TextStream<I> </I>object does offer some new features 
in addition to regular VBA file commands&#8212;for example, the ability to keep track of 
the current line and column while reading from or writing to the text file. This feature 
is exploited in this reusable routine that scans all the TXT files in a directory for a 
search string and returns an array of results (actually, an array of arrays) with all the 
files that contain that search string as well as the line number and the column number 
to indicate the position of the string within the file:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' For each TXT file that contains the search string, the function
' returns a Variant element that contains a 3-item array that holds
' the filename, the line number, and the column number.
' NOTE: all searches are case insensitive.
Function SearchTextFiles(path As String, search As String) As Variant()
    Dim fso As New Scripting.FileSystemObject
    Dim fil As Scripting.File, ts As Scripting.TextStream
    Dim pos As Long, count As Long
    ReDim result(50) As Variant

    ' Search for all the TXT files in the directory.    
    For Each fil In fso.GetFolder(path).Files
        If UCase$(fso.GetExtensionName(fil.path)) = &quot;TXT&quot; Then
            ' Get the corresponding TextStream object.
            Set ts = fil.OpenAsTextStream(ForReading)
            ' Read its contents, search the string, close it.
            pos = InStr(1, ts.ReadAll, search, vbTextCompare)
            ts.Close

            If pos &gt; 0 Then
                ' If the string has been found, reopen the file
                ' to determine string position in terms of (line,column).
                Set ts = fil.OpenAsTextStream(ForReading)
                ' Skip all preceding characters to get where 
                ' the search string is.
                ts.Skip pos _ 1 
                ' Fill the result array, make room if necessary.
                count = count + 1
                If count &gt; UBound(result) Then
                    ReDim Preserve result(UBound(result) + 50) As Variant
                End If
                ' Each result item is a 3-element array.
                result(count) = Array(fil.path, ts.Line, ts.Column)
                ' Now we can close the TextStream.
                ts.Close
            End If
        End If
    Next

    ' Resize the result array to indicate number of matches.
    ReDim Preserve result(0 To count) As Variant
    SearchTextFiles = result
End Function

' An example that uses the above routine: search for a name in all
' the TXT files in E:\DOCS directory, show the results in 
' the lstResults ListBox, in the format &quot;filename [line, column]&quot;.
Dim v() As Variant, i As Long
v() = SearchTextFiles(&quot;E:\docs&quot;, &quot;Francesco Balena&quot;)
For i = 1 To UBound(v)
    lstResults.AddItem v(i)(0) &amp; &quot; [&quot; &amp; v(i)(1) &amp; &quot;,&quot; &amp; v(i)(2) &amp; &quot;]&quot;
Next
</pre>
</td></tr>
</table></p>

<p><B>Table 5-7.</B> <i>All the properties and methods of the TextStream object.</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Property or Method</i></th>
<th><i>Syntax</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">Property</td>
<td valign="top"><I>AtEndOfLine</I></td>
<td valign="top">True if the file pointer is at the end of the current line.</td>
</tr>
<tr>
<td valign="top">Property</td>
<td valign="top"><I>AtEndOfFile</I></td>
<td valign="top">True if the file pointer is at the end of file (similar to VBA's <I>EOF</I> function).</td>
</tr>
<tr>
<td valign="top">Method</td>
<td valign="top"><I>Close</I></td>
<td valign="top">Closes the file (similar to VBA's <I>Close</I> statement).</td>
</tr>
<tr>
<td valign="top">Property</td>
<td valign="top"><I>Column</I></td>
<td valign="top">Current column number.</td>
</tr>
<tr>
<td valign="top">Property</td>
<td valign="top"><I>Line</I></td>
<td valign="top">Current line number.</td>
</tr>
<tr>
<td valign="top">Method</td>
<td valign="top"><I>Read(Characters)</I></td>
<td valign="top">Reads a specified number of characters and returns a string (similar to VBA's <I>Input$</I> function).</td>
</tr>
<tr>
<td valign="top">Method</td>
<td valign="top"><I>ReadAll()</I></td>
<td valign="top">Reads the entire file into a string (similar to VBA's <I>Input$</I> function when used with the <I>LOF</I> function).</td>
</tr>
<tr>
<td valign="top">Method</td>
<td valign="top"><I>ReadLine()</I></td>
<td valign="top">Reads the next line of text and returns a string (similar to VBA's <I>Line Input</I> statement).</td>
</tr>
<tr>
<td valign="top">Method</td>
<td valign="top"><I>Skip Characters</I></td>
<td valign="top">Skips over a specified number of characters.</td>
</tr>
<tr>
<td valign="top">Method</td>
<td valign="top"><I>SkipLine</I></td>
<td valign="top">Skips over a line of text.</td>
</tr>
<tr>
<td valign="top">Method</td>
<td valign="top"><I>Write Text</I></td>
<td valign="top">Writes a string of characters, without a trailing Newline character (similar to the <I>Print#</I> command with a trailing semicolon).</td>
</tr>
<tr>
<td valign="top">Method</td>
<td valign="top"><I>WriteBlankLines Lines</I></td>
<td valign="top">Writes the indicated number of blank lines (similar to one or more <I>Print#</I> commands without any argument).</td>
</tr>
<tr>
<td valign="top">Method</td>
<td valign="top"><I>WriteLine [Text]</I></td>
<td valign="top">Writes a string of characters, with a trailing Newline character (similar to the <I>Print#</I> command without a trailing semicolon).</td>
</tr>
</table></p>

</BODY>
</HTML>





