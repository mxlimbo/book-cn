<HTML>
<HEAD>
<TITLE>The Form Object</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch02d.htm", "ch03a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="46"><h1>The Form Object</h1></A>
<p>After this long introductory description of properties, methods, and events that 
are common to most Visual Basic objects, it's time to see the particular features of all 
of them individually. The most important visible object is undoubtedly the Form 
object because you can't display any control without a parent Form. Conversely, you 
can write some moderately useful applications using only forms that have no controls 
on them. In this section, I'll show a number of examples that are centered on 
forms' singular features.</p>

<p>You create a new form at design time using the Add Form command from 
the Project menu or by clicking on the corresponding icon on the standard toolbar. 
You can create forms from scratch, or you can take advantage of the many form 
templates provided by Visual Basic 6. If you don't see the dialog box shown in Figure 2-7, 
invoke the Options command from the Tools menu, click the Environment tab, and 
select the topmost check box on the right.</p>

<p>Feel free to create new form templates when you need them. A form 
template doesn't necessarily have to be a complex form with many controls on it. Even 
an empty form with a group of properties carefully set can save you some precious 
time. For example, see the Dialog Form template provided by Visual Basic. To 
produce your custom form templates, you just have to create a form, add any necessary 
controls and code, and then save it in the \Template\Forms directory. (The complete 
path of Visual Basic's template directory can be read and modified in the Environment 
tab of the Options dialog box.)</p>

<p>
<A HREF="javascript:fullSize('F02ph07x.htm')"> <img src="images/F02ph07.JPG" width=404 height=328 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 2-7.</B> <i>Form templates offered by Visual Basic 6.</i><!--/caption-->
</p>

<A NAME="47"><h2>Basic Form Properties</h2></A>

<p>After creating a form and resizing it to meet your requirements, you'll probably 
want to set a few key properties. 
<I>BorderStyle</I> is one of the properties that largely 
affects the form's behavior. Its default value is 2-Sizable, which creates a resizable 
window. To create a nonresizable form, you should set it to 1-Fixed Single or 3-Fixed 
Dialog: the only difference between the two settings is that the latter can't show 
Minimize and Maximize buttons. If you're creating a floating, toolboxlike form, you should 
use the values 4-Fixed Toolwindow or 5-Sizable Toolwindow. Theoretically, you can 
also use the value 0-None to exclude any type of border and caption, but you'll rarely 
find a use for such borderless forms.</p>

<p>Next you must decide what should appear on the title bar. Apart from 
assigning a suitable string to the form's 
<I>Caption</I> property, you should also decide whether you want the form to support a system menu and a Close button 
(<I>ControlBox</I> property, default is True) and a Minimize and a Maximize button 
(<I>MinButton</I> and <I>MaxButton</I> property, respectively). Selecting the right values for these properties 
is important because you can't change them at run time through code. If you want 
the form to start in maximized state, you can set the 
<I>WindowState</I> property to 
2-Maximized.</p>


<p><div class="tip"><blockquote><b>TIP</b><hr>
To create a captionless resizable window, you must set the 
<I>ControlBox</I>, <I>MinButton</I>, and 
<I>MaxButton</I> properties to False and the 
<I>Caption</I> property to an empty string. If you assign a non-empty string to the 
<I>Caption</I> property at run time, Visual Basic creates the form's title bar on the fly. Assigning it an empty 
string at run time makes the title bar disappear again. You can't move a 
captionless form using the mouse as you normally do with other types of windows.
</blockquote></div></p>

<p>Visual Basic 5 added three important form properties, which are also 
present in Visual Basic 6. You can have the form appear in the center of the screen by 
setting its <I>StartupPosition</I> property to the value 2-Center Screen. And you can make 
your window unmovable by setting the 
<I>Moveable</I> property to False. You can set 
these properties only at design time. The third new property is 
<I>ShowInTaskbar</I>; if you set this property to False, the form isn't shown in the Windows taskbar. Captionless 
forms appear in the taskbar as &quot;blank&quot; forms, so you might want to set the 
<I>ShowInTaskbar</I> property to False for such forms.</p>

<A NAME="48"><h2>Fine-Tuning the Performance of Forms</h2></A>

<p>A few form properties noticeably affect performance. First and foremost, 
the <I>AutoRedraw </I>property dictates whether the form is backed up by a persistent 
bitmap so that when it's covered by another form and then uncovered, Visual Basic 
can quickly restore its contents from the internal bitmap. 
<I>AutoRedraw</I>'s default value is False: setting it to True speeds up refresh operations but also causes a lot of 
memory to be allocated for the persistent bitmap. To give you an idea of what this means 
in practice, for a system with 1024-by-768 screen resolution and 256 colors, a 
persistent bitmap for a resizable form takes 768 KB. On an 800-by-600 pixel, true-color 
system, the persistent bitmap takes 1406 KB. If you have more forms running at the same 
time, you can clearly see that you shouldn't set the 
<I>AutoRedraw</I> property to True, at least not for all the forms. 
<I>AutoRedraw</I> affects performance in another way: Each time 
you perform a graphic method (including printing text and drawing figures), 
Visual Basic creates the output on the hidden persistent bitmap and then copies the bitmap as 
a whole on the visible area of the form. Needless to say, this is slower than 
creating the output directly on the form's surface.</p>

<p><div class="tip"><blockquote><b>TIP</b><hr>
If 
<I>AutoRedraw</I> is set to True, Visual Basic creates a persistent bitmap 
as large as the largest possible size for the form, which means the entire 
screen for resizable windows. Therefore, you can limit the memory overhead 
caused by the persistent bitmap if you create smaller forms and set their 
<I>BorderStyle </I>property to 1-Fixed Single or 3-Fixed Dialog.
</blockquote></div></p>

<p>The <I>ClipControls</I> property also affects performance. If you execute many 
graphic methods&#8212;such as Line, Circle, Point, and Print&#8212;you should set this property to 
False because all your graphic methods are going to execute about twice as fast. When 
you set this property to False, Visual Basic doesn't have to create a 
<I>clipping region</I>. However, if your graphic methods do overlap controls on the form, you're going 
to experience the unpleasant effect shown in Figure 2-8, so be very careful. 
(Compare this figure with Figure 2-9, which shows the same application with the more 
appropriate setting of True for the 
<I>ClipControls</I> property.) If you don't execute graphic 
methods, you might leave it set to True (the default value) because it won't slow down 
the application.</p>

<p>
<img src="images/F02ph08.GIF" width=360 height=273 border=0>
<p>
<!--caption--><B>Figure 2-8.</B> <i>Nasty effects of the ClipControls setting when graphic methods overlap existing controls.</i><!--/caption-->


<p>
<img src="images/F02ph09.GIF" width=360 height=273 border=0>
<p>
<!--caption--><B>Figure 2-9.</B> <i>Running the application shown in Figure 2-8 with the more appropriate setting for the ClipControls property.</i><!--/caption-->


<p>
<img src="images/new.jpg" width=102 height=87 border=0>
</p>

<p>The <I>HasDC</I> property is new to Visual Basic 6. The default value for this 
property is True, which causes Visual Basic to create a permanent device 
context for this form, and this device context exists as long as the form itself is loaded in memory. (A 
<I>device context</I> is a structure used by Windows for drawing on a window's surface.) If 
you set this property to False, Visual Basic creates a device context for the form only 
when strictly needed and discards it as soon as it's not useful anymore. This setting 
reduces the application's requirements in terms of system resources and can therefore 
improve its performance on less powerful machines. On the other hand, it adds a little 
overhead whenever Visual Basic creates and destroys the temporary device context. 
This happens when Visual Basic fires an event in the program's code.</p>

<p><div class="caution"><blockquote><b>CAUTION</b><hr>
You can set the 
<I>HasDC</I> property to False and still run any 
existing Visual Basic application without any problem. If, however, you use 
advanced graphic techniques that bypass Visual Basic and write directly onto the 
form's device context, you shouldn't cache the form's 
<I>hDC</I> property in a module-level or a global variable, because Visual Basic can destroy and re-create the 
form's device context between events. Instead, query the 
<I>hDC</I> property at the beginning of each event procedure.
</blockquote></div></p>

<A NAME="49"><h2>A Form's Life Cycle</h2></A>

<p>To understand how Form objects really work, the best approach is having a look at the sequence of events that they raise. This sequence is shown in the illustration below. I'll describe each event in turn.</p>

<A NAME="50"><h3>The <I>Initialize</I> event</h3></A>

<p>The first event in the life of any form is the 
<I>Initialize</I> event. This event fires as soon as you reference the form's name in your code, even before Visual Basic creates 
the actual window and the controls on its surface. You usually write code in this 
event to correctly initialize the form's variables:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Public CustomerName As String
Public NewCustomer As Boolean

Private Sub Form_Initialize()
    CustomerName = &quot;&quot;      ' This isn't really needed.
    NewCustomer = True     ' This is necessary.
End Sub
</pre>
</td></tr>
</table></p>


<p>When a form is initialized, all its module-level variables 
(<I>CustomerName</I> and <I>NewCustomer</I>, in the preceding example) are assigned their default values. So it 
isn't strictly necessary to assign a value to a variable if the value is 0 or an empty 
string. In the code above, for example, there's no need for the assignment to the 
<I>CustomerName</I> variable, but you might want to leave it there for better readability.</p>

<p>
<A HREF="javascript:fullSize('G02ph01x.htm')"> <img src="images/G02ph01.JPG" width=404 height=536 border=0 ALT = "Click to view at full size."> </A>
</p>

<A NAME="51"><h3>The <I>Load</I> event</h3></A>

<p>What happens after the <I>Initialize</I> event depends on how you referenced the 
form in your code. If you referenced only one of its public variables (or, more 
correctly, its <I>Public</I> properties), as in the following line of code,</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>frmCustomer.CustomerName = &quot;John Smith&quot;
</pre>
</td></tr>
</table></p>


<p>nothing else happens and execution flow goes back to the caller. Your code is 
now able to set the <I>CustomerName</I> variable/property to the new value because in 
the meantime Visual Basic has created a new instance of the 
<I>frmCustomer</I> object. On the other hand, if your code had referenced a form's own property or a control 
on the form itself, Visual Basic can't complete the operation until it actually creates 
the window and its child controls. When this step is completed, a 
<I>Load</I> event is fired:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_Load()
    ' You can initialize child controls. 
    txtName.Text = CustomerName
    If NewCustomer Then chkNewCustomer.Value = vbChecked
End Sub
</pre>
</td></tr>
</table></p>


<p>At this point, the form isn't visible yet. This implies that if you execute 
graphic commands in this event procedure&#8212;including a Print command, which is 
considered a graphic command in Visual Basic&#8212;you won't see anything. Likewise, while 
you can freely read and modify most controls' properties, you should avoid any 
operation that can't be performed on invisible controls. For example, you can't invoke a 
<I>SetFocus</I> method to move the focus on a particular control.</p>

<p>Loading a form doesn't necessarily mean that the form is going to 
become visible. A form becomes visible only if you invoke its 
<I>Show</I> method or if the form is the application's startup form. You can decide to load a form and keep it hidden 
until you set some of its properties, as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The Load method is optional: Visual Basic loads the form
' when you reference the form or one of its controls.
Load frmCustomer
' Directly assign a control's property.
' (Not recommended, but this is just an example.)
frmCustomer.txtNotes.Text = gloCustomerNotes
frmCustomer.Show
</pre>
</td></tr>
</table></p>


<p>Directly referencing a form's control from outside the form itself, as the 
previous code example does, is considered a bad programming technique. I will show 
you how to correctly initialize control properties in <a href="ch09a.htm">Chapter 9</a>.</p>

<A NAME="52"><h3>The <I>Resize</I> event</h3></A>

<p>One instant before the form becomes visible, Visual Basic fires a 
<I>Resize</I> event. You usually take advantage of this event to rearrange the controls on the form so that 
they fit the available space in a nice layout. For example, you might want the 
txtCustomer control to extend to the right border and the multiline txtNotes control to extend 
to both the right and the bottom border:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_Resize()
    txtCustomer.Width = ScaleWidth _ txtCustomer.Left
    txtNotes.Width = ScaleWidth _ txtNotes.Left
    txtNotes.Height = ScaleHeight _ txtNotes.Top
End Sub
</pre>
</td></tr>
</table></p>


<p>The <I>Resize</I> event also fires when the user resizes the form manually and 
when you programmatically alter the form's size.</p>

<A NAME="53"><h3>The <I>Activate</I> event</h3></A>

<p>Soon after the first <I>Resize</I> event comes the 
<I>Activate</I> event. This event also 
fires whenever the form becomes the active form in the current application but not if 
it loses and then regains the focus because the user switched to another 
application. The <I>Activate</I> event is most useful when you need to update the form's contents 
with data that might have been modified in another form. When the focus returns to 
the current form, you refresh its fields:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_Activate()
    ' Refresh displayed information from global variables.
    txtTotalOrders.Text = gloTotalOrders
    ...
End Sub
</pre>
</td></tr>
</table></p>


<A NAME="54"><h3>The <I>Paint </I>event</h3></A>

<p>Another event might fire before the form becomes fully functional&#8212;the 
<I>Paint</I> event. This event doesn't fire if you set the form's 
<I>AutoRedraw</I> property to True. In a 
<I>Paint</I> event procedure, you're expected to redraw the form's contents using 
graphic methods, such as <I>Print</I>, <I>Line</I>, 
<I>Circle</I>, <I>Point</I>, <I>Cls</I>, and so on. Here's an example 
that draws a colorful circular target:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_Paint()
    Dim r As Single, initR As Single
    Dim x As Single, y As Single, qbc As Integer
    
    ' Start with a clean surface.
    Cls                                 
    ' The center of all circles
    x = ScaleWidth / 2: y = ScaleHeight / 2 
    ' Initial radius is the lower of the two values.
    If x &lt; y Then initR = x Else initR = y
    FillStyle = vbFSSolid            ' Circles are filled.
    ' Draw circles, from the outside in. 
    For r = initR To 1 Step -(initR / 16)
        ' Use a different color for each circle.
        FillColor = QBColor(qbc)
        qbc = qbc + 1
        Circle (x, y), r
    Next
    ' Restore regular filling style.
    FillStyle = vbFSTransparent           
End Sub
</pre>
</td></tr>
</table></p>


<p>The <I>Paint</I> event procedure is executed whenever the form needs to be 
refreshed&#8212;for example, when the user closes or moves away a window that 
partially or totally covered the form. The <I>Paint 
</I>event also fires when the user resizes the 
form and uncovers new areas. But it does <I>not 
</I>fire if the user shrinks the form. To complete the example above, you may want to manually force a 
<I>Paint</I> event from within the <I>Resize</I> event so that concentric circles are always in the center of the form:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_Resize()
    Refresh
End Sub
</pre>
</td></tr>
</table></p>

<p><div class="caution"><blockquote><b>CAUTION</b><hr>
You might be tempted to force a 
<I>Paint</I> event by manually calling the 
<I>Form_Paint</I> procedure. Don't do that! The correct and most efficient way 
to repaint a window is to execute its <I>Refresh 
</I>method and let Visual Basic decide the most appropriate moment to do that. Moreover, if you replace the 
<I>Refresh</I> method with a direct call to the 
<I>Form_Paint</I> procedure, in some cases the 
result is that the <I>Paint</I> event procedure is executed twice!
</blockquote></div></p>

<p>After the very first <I>Paint</I> event&#8212;or immediately after the 
<I>Activate</I> event, if the <I>AutoRedraw</I> property is set to True&#8212;the form is finally ready to accept user 
input. If the form doesn't contain any controls or if none of its controls can receive the 
input focus, the form itself receives a <I>GotFocus 
</I>event. You will rarely write code in a form's 
<I>GotFocus</I> event, though, because you can always use the 
<I>Activate</I> event instead.</p>

<A NAME="55"><h3>The <I>Deactivate</I> event</h3></A>

<p>As I mentioned previously, when you switch to another form in your application, 
the form receives a <I>Deactivate</I> event and another 
<I>Activate</I> event when it regains the input focus. The same sequence occurs if you temporarily make a form invisible by 
setting its <I>Visible</I> property to False or by invoking its 
<I>Hide</I> method.</p>

<A NAME="56"><h3>The <I>QueryUnload</I> event</h3></A>

<p>When the form is about to be unloaded, the form object receives a 
<I>QueryUnload</I> event. You can learn why a form is unloading by examining the 
<I>UnloadMode</I> parameter. I have created this code skeleton, which I reuse in my applications as necessary:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_QueryUnload(Cancel As Integer, _
    UnloadMode As Integer)
    Select Case UnloadMode
        Case vbFormControlMenu   ' = 0
            ' Form is being closed by user.
        Case vbFormCode          ' = 1
            ' Form is being closed by code.
        Case vbAppWindows        ' = 2
            ' The current Windows session is ending.
        Case vbAppTaskManager    ' = 3
            ' Task Manager is closing this application.
        Case vbFormMDIForm       ' = 4
            ' MDI parent is closing this form.
        Case vbFormOwner         ' = 5
            ' The owner form is closing.
    End Select
End Sub
</pre>
</td></tr>
</table></p>


<p>You can refuse to unload by setting the 
<I>Cancel</I> parameter to True, as in the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_QueryUnload(Cancel As Integer, _
    UnloadMode As Integer)
    ' Don't let the user close this form.
    Select Case UnloadMode
        Case vbFormControlMenu, vbAppTaskManager
            Cancel = True
    End Select
End Sub
</pre>
</td></tr>
</table></p>


<A NAME="57"><h3>The <I>Unload</I> event</h3></A>

<p>If you don't cancel the unload operation, Visual Basic eventually raises the 
<I>Unload</I> event and gives you a last chance to prevent the closure of the form. In most 
cases, you take this opportunity to alert the user that data needs to be saved:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' This is a module-level variable.
Dim Saved As Boolean

Private Sub Form_Unload(Cancel As Integer)
    If Not Saved Then
        MsgBox &quot;Please save data first!&quot;
        Cancel = True
    End If
End Sub
</pre>
</td></tr>
</table></p>


<p>Unless you canceled the request, Visual Basic destroys all the controls and 
then unloads the form and releases all the Windows resources allocated at load time 
when the <I>Unload</I> event procedure exits. Depending on how you invoked the form, it 
might also fire the form's <I>Terminate </I>event, which is where you put your clean-up code, 
close your files, and so on. The reasons why this event might fire (or not) are 
explained in <a href="ch09a.htm">Chapter 9</a>.</p>

<p><div class="caution"><blockquote><b>CAUTION</b><hr>
When the 
<I>Terminate </I>event is fired, the form object is already 
gone, so you shouldn't reference it or its controls in code. If you accidentally do 
that, no error is raised. Instead, Visual Basic creates another, new instance of the 
form object, which silently remains hidden in memory, unnecessarily consuming a 
lot of system resources.
</blockquote></div></p>

<A NAME="58"><h2>The Controls Collection</h2></A>

<p>Forms expose a special property, the 
Controls collection, which contains all the controls that are currently loaded on the form itself. This collection lets you 
streamline the code in your form modules often and is the key to some programming 
techniques that would be otherwise impossible. For example, see how simple it is to clear 
all the TextBox and ComboBox controls in the form with just four lines of code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>On Error Resume Next
For i = 0 To Controls.Count - 1
    Controls(i).Text = &quot;&quot;
Next
</pre>
</td></tr>
</table></p>


<p>Error handling is necessary here because you must account for all the 
controls on the form that don't support the 
<I>Text</I> property. For example, the Controls 
collection also includes all the menu items on a form, and menu items don't have a 
<I>Text</I> property. So, you must account for these cases when you iterate over the collection. 
Here's an alternative way to loop on all the controls in the collection using the generic 
Control object and a <I>For 
Each&#8230;Next</I> statement:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim ctrl As Control
On Error Resume Next
For Each ctrl In Controls
    ctrl.Text = &quot;&quot;
Next
</pre>
</td></tr>
</table></p>


<p>Both preceding code snippets work with any number of controls on the 
form, and they also work if you cut and paste them in another form module. The 
beauty of the Controls collection is that it makes it possible to create such generic 
routines, which couldn't be written in any other way. Later in this book, you'll see many 
other programming techniques based on the Controls collection.</p>

<A NAME="59"><h2>The Screen Object</h2></A>

<p>Visual Basic forms live on your computer screen. Even if you plan to use only a 
portion of the screen estate for your application, you need in many cases to learn more 
about what's around you. To this end, Visual Basic provides you with a Screen object, 
a global object that corresponds to the visible desktop.</p>

<p>A form's <I>Left</I>, <I>Top</I>, <I>Width</I>, and 
<I>Height</I> properties are expressed in 
<I>twips</I>. Twips are measurement units that can be used for both screen and printer devices. On 
the printer, 1 inch corresponds to 1,440 twips; on the screen, it depends on the 
monitor's size and the video card's current resolution. You can find the current size of the 
screen, in twips, through the <I>Width</I> and 
<I>Height</I> properties of the Screen object. You can 
then use the values of these properties; for example, you can move the current form 
to the bottom right corner of your monitor using this line of code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Move Screen.Width - Width, Screen.Height - Height
</pre>
</td></tr>
</table></p>


<p>Although you can't have the Screen object's properties returned in a 
unit other than twips, you can easily convert these values into pixels using the 
Screen object's <I>TwipsPerPixelX</I> and 
<I>TwipsPerPixelY</I> properties:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Evaluate the screen width and height in pixels.
scrWidth = Screen.Width / Screen.TwipsPerPixelX 
scrHeight = Screen.Height / Screen.TwipsPerPixelY

' Shrink the current form of 10 pixels along the
' x-axis and 20 pixels along the y-axis.
Move Left, Top, Width - 10 * Screen.TwipPerPixelX, _
    Height - 20 * Screen.TwipsPerPixelY
</pre>
</td></tr>
</table></p>


<p>The Screen object also lets you enumerate all the character fonts that are 
available for the screen through its 
<I>Font</I> and <I>FontCount</I> properties:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Load the names of all the screen's fonts in a list box.
Dim i As Integer 
For i = 0 To Screen.FontCount - 1
    lstFonts.AddItem Screen.Fonts(i)
Next
</pre>
</td></tr>
</table></p>


<p>The only two properties of the Screen object that can be written to are 
<I>MousePointer</I> and <I>MouseIcon</I>. (I described these properties earlier in this chapter.) You 
can modify the mouse pointer using the following statement:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Screen.MousePointer = vbHourglass
</pre>
</td></tr>
</table></p>


<p>A value assigned to this property actually affects only the current 
application: If you move the mouse cursor to the desktop or over a window belonging to 
another application, the original mouse cursor is restored. In this sense, therefore, you 
aren't actually dealing with a screen property. This concept also applies to the 
remaining Screen properties, <I>ActiveForm</I> and 
<I>ActiveControl</I>. <I>ActiveForm</I> is a read-only 
property that returns a reference to the active form in the current application; 
<I>ActiveControl </I>returns a reference to the control that has the input focus on the active form. You 
often use these properties together:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' If the current form is frmCustomer, clear the control that has
' the focus. 
' On Error is necessary because you can't be sure that it supports
' the Text property, or even that there actually *is* an active
' control.
On Error Resume Next
If Screen.ActiveForm.Name = &quot;frmCustomer&quot; Then
    Screen.ActiveControl.Text = &quot;&quot;
End If
</pre>
</td></tr>
</table></p>


<p>A form can be the active form without even having the input focus. If you 
have switched to another application, the Screen object continues to return a reference 
to the last form that was current in your application as the active form. Always keep 
in mind that the Screen object can't see beyond the current application's 
boundaries. As far as it's concerned, the current application is the only application running 
on the system. This is a sort of axiom in Win32 programming: No application 
should know anything about, or affect in any way, other applications running on the system.</p>

<A NAME="60"><h2>Printing Text</h2></A>

<p>In most Visual Basic applications, you don't display text directly on a form's 
surface. Instead, you usually make use of Label controls or print your messages inside 
PictureBox controls. But understanding how you can display text in a form can help you in 
many situations because it reveals how Visual Basic deals with text in general. 
Moreover, anything I say here about a form's graphic commands and properties also applies 
to PictureBox controls.</p>

<p>The most important graphic method for showing text is the 
<I>Print</I> method. This command has been part of the Basic language since its early incarnations and 
has survived for all these years without any relevant modification, until it found its 
way into Visual Basic. Because old MS-DOS programs written in Basic heavily relied 
on this command for all their user interfaces, it was essential for Visual Basic to 
support it. Since modern Visual Basic programming doesn't rely on this command 
anymore, however, I'll cover only its basic features.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
Don't look for the 
<I>Print </I>method in the Object Browser because you 
won't find it. The hybrid nature of this command and its contorted syntax&#8212;just 
think of the many separators you can use in a 
<I>Print</I> statement, including commas, semicolons, and 
<I>Tab()</I> functions&#8212;prevented Microsoft engineers from 
including it there. Instead, the <I>Print</I> method is directly implemented in the language 
at run time, at the expense of a more coherent and complete object-oriented 
implementation of the language as a whole.
</blockquote></div></p>

<p>You often use the <I>Print</I> method for a quick-and-dirty output on the form's 
client area. For example, you can show the form's current size and position with 
this simple code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_Resize()
    Cls                ' Resets the printing position to (0,0)
    Print &quot;Left = &quot; &amp; Left &amp; vbTab &amp; &quot;Top = &quot; &amp; Top
    Print &quot;Width = &quot; &amp; Width &amp; vbTab &amp; &quot;Height = &quot; &amp; Height
End Sub
</pre>
</td></tr>
</table></p>

<p><div class="tip"><blockquote><b>TIP</b><hr>
You can use semicolons instead of the &amp; operator and commas 
instead of the vbTab constant. But if you purposely stick to a standard syntax 
and stay clear of special features of the 
<I>Print</I> method, you can easily recycle your arguments and pass them to your custom methods or assign them to 
the <I>Caption</I> property of a Label. This can save you some time later, when 
you want to turn a quick-and-dirty prototype into a regular application.
</blockquote></div></p>

<p>The output from the <I>Print</I> method is affected by the current values of the 
<I>Font</I> and <I>ForeColor</I> properties, which I described earlier in this chapter. By default, 
the <I>BackColor</I> property doesn't affect the 
<I>Print </I>command because the text is usually printed as if it had a transparent background. Most of the time, this situation 
doesn't cause any problems because you often print over a clean form's surface, and it 
accounts for better performance because only the text's pixels must be transferred, 
not the background color. But if you want to print a message and at the same time 
you want to erase a previous message in the same position, you can do it by setting 
the <I>FontTransparent</I> property to False. Otherwise, you'll end up with one message 
on top of another, making both unreadable.</p>

<p>Normally, each Print command resets the <I>x</I>-coordinate of the current 
graphic position to 0 and advances the <I>y</I>-coordinate so that the next string is 
displayed immediately below the previous one. You can learn where the next Print 
command will display its output by querying the form's 
<I>CurrentX</I> and <I>CurrentY</I><B> 
</B>properties. Under normal conditions, the point (0,0) represents the upper left corner in the 
client area (that is, the portion of the form inside its border and below its title bar). 
The <I>x</I>-coordinates increase from left to right, and the 
<I>y</I>-coordinates increase when you go from top to bottom. You can assign a new value to these properties to 
print anywhere on your form:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Show a message centered on the form (more or less).
CurrentX = ScaleWidth / 2
CurrentY = ScaleHeight / 2
Print &quot;I'm here!&quot;
</pre>
</td></tr>
</table></p>


<p>This code, however, doesn't really center the message on the form because 
only the initial printing point is centered while the rest of the string runs toward the 
right border. To precisely center a message on a screen, you must first determine how 
wide and tall it is, which you do using the form's 
<I>TextHeight</I> and <I>TextWidth</I> methods:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>msg = &quot;I'm here, in the center of the form.&quot;
CurrentX = (ScaleWidth _ TextWidth(msg)) / 2
CurrentY = (ScaleHeight - TextHeight(msg)) / 2
Print msg
</pre>
</td></tr>
</table></p>


<p>You often use the <I>TextWidth</I> and 
<I>TextHeight</I> methods to see whether a message can fit within a given area. This strategy is especially useful when you print to a 
form because the <I>Print</I> method doesn't support automatic wrapping for longer lines. 
To see how you can remedy this deficiency, add the following code to a blank form 
and then run the program and resize the form at will. Figure 2-10 illustrates how 
form resizing works.</p>

<p>
<A HREF="javascript:fullSize('F02ph10x.htm')"> <img src="images/F02ph10.JPG" width=404 height=214 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 2-10.</B> <i>Automatic wrapping for longer lines of text.</i><!--/caption-->
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' A routine that formats Print output 
Private Sub Form_Paint()
    Dim msg As String, pos As Long, spacePos As Long
    msg = &quot;You often use the TextWidth and TextHeight methods&quot; _
        &amp; &quot; to check if a message can fit within a given area. &quot; _
        &amp; vbCrLf &amp; &quot; This is especially necessary when you&quot; _
        &amp; &quot; print to a form, because the Print method doesn't&quot; _
        &amp; &quot; support automatic wrapping for long lines, and you&quot; _
        &amp; &quot; need to solve the problem through code.&quot;

    Cls
    Do While pos &lt; Len(msg)
        pos = pos + 1
        If Mid$(msg, pos, 2) = vbCrLf Then
            ' A CR-LF pair, print the string so far and reset variables.
            Print Left$(msg, pos - 1)
            msg = LTrim$(Mid$(msg, pos + 2))
            pos = 0: spacePos = 0
        ElseIf Mid$(msg, pos, 1) = &quot; &quot; Then
            ' A space, remember its position for later.
            spacePos = pos
        End If

        ' Check the message width so far.
        If TextWidth(Left$(msg, pos)) &gt; ScaleWidth Then
            ' The message is too long, so let's split it.
            ' If we just parsed a space, split it there.
            If spacePos Then pos = spacePos
            ' Print the message up to the split point.
            Print Left$(msg, pos - 1)
            ' Discard printed characters, and reset variables.
            msg = LTrim$(Mid$(msg, pos))
            pos = 0: spacePos = 0
        End If
    Loop
    ' Print residual characters, if any.
    If Len(msg) Then Print msg
End Sub

Private Sub Form_Resize()
    Refresh
End Sub
</pre>
</td></tr>
</table></p>


<p>The preceding code works with any font you're using. As an exercise, you 
can build a general routine that accepts any string and any form reference so that 
you can easily reuse it in your applications.</p>

<p>Another problem that you might need to solve is how to determine the 
most appropriate font size for a message so that it fits in a given area. Because you 
can't be sure which sizes are supported by the current font, you usually find the best 
font size using a <I>For&#8230;Next</I> loop. The following simple program creates a digital 
clock, which you can enlarge and shrink as you like. The actual clock update is 
performed by a hidden Timer control:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_Resize()
    Dim msg As String, size As Integer
    msg = Time$
    For size = 200 To 8 Step -2
        Font.Size = size
        If TextWidth(msg) &lt;= ScaleWidth And _
            TextHeight(msg) &lt;= ScaleHeight Then
                ' We've found a font size that is OK.
                Exit For
            End If
    Next
    ' Enable the timer.
    Timer1.Enabled = True
    Timer1.Interval = 1000
End Sub

Private Sub Timer1_Timer()
    ' Just print the current time using current font settings.
    Cls
    Print Time$
End Sub
</pre>
</td></tr>
</table></p>


<A NAME="61"><h2>Graphic Methods</h2></A>

<p>Visual Basic supplies developers with several graphic methods. You can draw 
individual points and lines as well as more complex geometric shapes, such as rectangles, 
circles, and ellipses. You have complete control over line color, width, and style, and 
you can even fill your shapes with a solid color or a pattern.</p>

<p>Undoubtedly, the simplest graphic method to use is 
<I>Cls</I>. It clears the form's surface, fills it with the background color defined by the 
<I>BackColor </I>property, and then moves the current graphic position to the (0,0) coordinates. If you assign a new 
value to the <I>BackColor</I> property, Visual Basic clears the background on its own so that 
you never need to issue a <I>Cls</I> method yourself after you change the form's background color.</p>

<A NAME="62"><h3>Drawing points</h3></A>

<p>A more useful method is <I>PSet</I>, which modifies the color of a single pixel on the 
form surface. In its basic syntax, you simply need to specify the 
<I>x</I> and <I>y</I> coordinates. A third, optional argument lets you specify the color of the pixel, if different from 
the <I>ForeColor</I> value:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>ForeColor = vbRed
PSet (0, 0)                  ' A red pixel
PSet (10, 0), vbCyan         ' A cyan pixel to its right
</pre>
</td></tr>
</table></p>


<p>Like many other graphic methods, <I>PSet </I>supports relative positioning using 
the <I>Step </I>keyword; when you use this keyword, the two values within brackets are 
treated as offsets from the current graphic point (the position on screen that 
<I>CurrentX </I>and <I>CurrentY </I>currently point to). The point you draw with the 
<I>PSet </I>method becomes the current graphic position:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Set a starting position.
CurrentX = 1000: CurrentY = 500
' Draw 10 points aligned horizontally.
For i = 1 To 10
    PSet Step (8, 0)
Next
</pre>
</td></tr>
</table></p>


<p>The output from the <I>PSet</I> method is also affected by another form's 
property, <I>DrawWidth</I>. You can set this property to a value greater than 1 (the default) to 
draw larger points. Note that while all graphic measures are expressed in twips, this 
value is in pixels. When you use a value greater than 1, the coordinates passed to the 
<I>PSet</I> method are considered to be the center of the thicker point (which is actually a 
small circle). Try these few lines of code for a colorful effect:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>For i = 1 To 1000
    ' Set a random point width.
    DrawWidth = Rnd * 10 + 1
    ' Draw a point at random coordinates and with random color.
    PSet (Rnd * ScaleWidth, Rnd * ScaleHeight), _
        RGB(Rnd * 255, Rnd * 255, Rnd * 255)
Next
' Be polite: restore the default value.
DrawWidth = 1
</pre>
</td></tr>
</table></p>


<p>The <I>PSet </I>method's counterpart is the 
<I>Point</I> method, which returns the RGB 
color value of a given pixel. To see this method in action, create a form with a Label1 
control on it, draw some graphics on it (the previous code snippet would be perfect), 
and add the following routine:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_MouseMove (Button As Integer, _
    Shift As Integer, X As Single, Y As Single)
    Label1.Caption = &quot;(&quot; &amp; X &amp; &quot;,&quot; &amp; Y &amp; &quot;) = &quot; _
        &amp; Hex$(Point(X, Y))
End Sub
</pre>
</td></tr>
</table></p>


<p>Run the program, and move the mouse cursor over the colored spots to 
display their coordinates and color values.</p>

<A NAME="63"><h3>Drawing lines and rectangles</h3></A>

<p>The next graphic method that you might use in your Visual Basic application is 
the <I>Line</I> method. It's a powerful command, and its syntax variants let you draw 
straight lines, empty rectangles, and rectangles filled with solid colors. To draw a straight 
line, you need only to provide the coordinates of starting and ending points, plus 
an optional color value. (If you omit a color value, the current 
<I>ForeColor </I>value is used):</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Draw a thick diagonal red &quot;X&quot; across the form.
' The Line method is affected by the current DrawWidth setting.
DrawWidth = 5
Line (0, 0) _ (ScaleWidth, ScaleHeight), vbRed
Line (ScaleWidth, 0) _ (0, ScaleHeight), vbRed
</pre>
</td></tr>
</table></p>


<p>Like the <I>PSet</I> method, the <I>Line</I> method supports the 
<I>Step</I> keyword to specify relative positioning. The 
<I>Step</I> keyword can be placed in front of either pair 
of coordinates, so you can freely mix absolute and relative positioning. If you omit 
the first argument, the line is drawn from the current graphic position:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Draw a triangle.
Line (1000, 2000)- Step (1000, 0)  ' Horizontal line
Line -Step (0, 1000)               ' Vertical line
Line -(1000, 2000)                 ' Close the triangle.
</pre>
</td></tr>
</table></p>


<p>The output of the <I>Line</I> method is affected by another form's property, 
<I>DrawStyle</I>. The default value for this property is 0 
(<I>vbSolid</I>), but you can also draw dotted 
lines in a variety of styles, as you can see in Figure 2-11. Table 2-2 summarizes these styles.</p>

<p>
<img src="images/F02ph11.GIF" width=390 height=349 border=0>
<p>
<!--caption--><B>Figure 2-11.</B> <i>The effects of various settings of the DrawStyle property.</i><!--/caption-->


<p><B>Table 2-2.</B> <i>Constants for the DrawStyle property.</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th><I>Constant</I></th>
<th><I>Value</I></th>
<th><I>Description</I></th>
</tr>
<tr>
<td valign="top">vbSolid</td>
<td valign="top">0</td>
<td valign="top">Solid (default value)</td>
</tr>
<tr>
<td valign="top">vbDash</td>
<td valign="top">1</td>
<td valign="top">Dashed line</td>
</tr>
<tr>
<td valign="top">vbDot</td>
<td valign="top">2</td>
<td valign="top">Dotted line</td>
</tr>
<tr>
<td valign="top">vbDashDot</td>
<td valign="top">3</td>
<td valign="top">Line with alternating dashes and dots</td>
</tr>
<tr>
<td valign="top">vbDashDotDot</td>
<td valign="top">4</td>
<td valign="top">Line with alternating dashes and double dots</td>
</tr>
<tr>
<td valign="top">vbInvisible</td>
<td valign="top">5</td>
<td valign="top">Invisible line</td>
</tr>
<tr>
<td valign="top">vbInsideSolid</td>
<td valign="top">6</td>
<td valign="top">Inside solid</td>
</tr>
</table></p>


<p>Note that the <I>DrawStyle</I> property affects the graphic output only if 
<I>DrawWidth</I> is set to 1 pixel; in all other cases, the 
<I>DrawStyle</I> property is ignored and the line 
is always drawn in solid mode. Adding <I>B</I> as a fourth argument to the 
<I>Line</I> method allows you to draw rectangles; in this case, the two points are the coordinates of 
any two opposite corners:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' A blue rectangle, 2000 twips wide and 1000 twips tall
Line (500, 500)- Step (2000, 1000), vbBlue, B
</pre>
</td></tr>
</table></p>


<p>Rectangles drawn in this way are affected by the current settings of the 
<I>DrawWidth</I> and <I>FillStyle</I> properties.</p>

<p>Finally, you can draw filled rectangles using the <I>BF</I> argument. The capability of creating empty and filled rectangles lets you create interesting effects. For example, you can draw your own 3-D yellow notes floating on your forms using three lines of code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' A gray rectangle provides the shadow.
Line (500, 500)-Step(2000, 1000), RGB(64, 64, 64), BF
' A white rectangle provides the canvas.
Line (450, 450)-Step(2000, 1000), vbYellow, BF
' Complete it with a black border.
Line (450, 450)-Step(2000, 1000), vbBlack, B
</pre>
</td></tr>
</table></p>

<p>Even if you can paint filled rectangles using the <I>BF</I> argument, Visual Basic offers more advanced filling capabilities. You can activate a solid filling style by setting the <I>FillStyle</I> property, the results of which you can see in Figure 2-12. Interestingly, Visual Basic offers a separate color property for the color to be used to fill regions, <I>FillColor</I>, which allows you to draw a rectangle's contour with one color and paint its interior with another color in a single operation. Here's how you can take advantage of this feature to recode the previous example with just two <I>Line</I> methods:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Line (500, 500)-Step(2000, 1000), RGB(64, 64, 64), BF
FillStyle = vbFSSolid   ' We want a filled rectangle.
FillColor = vbYellow    ' This is the paint color.
Line (450, 450)-Step(2000, 1000), vbBlack, B
</pre>
</td></tr>
</table></p>

<p>
<A HREF="javascript:fullSize('F02ph12x.htm')"> <img src="images/F02ph12.JPG" width=404 height=246 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 2-12.</B> <i>The eight styles offered by the FillStyle property.</i><!--/caption-->
</p>

<p>The <I>FillStyle</I> property can be assigned one of several values, as you can see in Table 2-3.</p>

<p><B>Table 2-3.</B> <i>Constants for the FillStyle property.</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th><I>Constant</I></th>
<th><I>Value</I></th>
<th><I>Description</I></th>
</tr>
<tr>
<td valign="top">vbFSSolid</td>
<td valign="top">0</td>
<td valign="top">Solid filling</td>
</tr>
<tr>
<td valign="top">vbFSTransparent</td>
<td valign="top">1</td>
<td valign="top">Transparent (default value)</td>
</tr>
<tr>
<td valign="top">vbHorizontalLine</td>
<td valign="top">2</td>
<td valign="top">Horizontal lines</td>
</tr>
<tr>
<td valign="top">vbVerticalLine</td>
<td valign="top">3</td>
<td valign="top">Vertical lines</td>
</tr>
<tr>
<td valign="top">vbUpwardDiagonal</td>
<td valign="top">4</td>
<td valign="top">Upward diagonal lines</td>
</tr>
<tr>
<td valign="top">vbDownwardDiagonal</td>
<td valign="top">5</td>
<td valign="top">Downward diagonal lines</td>
</tr>
<tr>
<td valign="top">vbCross</td>
<td valign="top">6</td>
<td valign="top">Vertical and horizontal crossing lines</td>
</tr>
<tr>
<td valign="top">vbDiagonalCross</td>
<td valign="top">7</td>
<td valign="top">Diagonal crossing lines</td>
</tr>
</table></p>

<A NAME="64"><h3>Drawing circles, ellipses, and arcs</h3></A>
<p>The last graphic method offered by Visual Basic is <I>Circle</I>, which is also the most complex of the group in that it enables you to draw circles, ellipses, arcs, and even pie slices. Drawing circles is the simplest action you can do with this method because you merely have to specify the circle's center and its radius:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' A circle with a radius of 1000 twips, near the
' upper left corner of the form
Circle (1200, 1200), 1000
</pre>
</td></tr>
</table></p>

<p>The <I>Circle</I> method is affected by the current values of the <I>DrawWidth</I>, <I>DrawStyle</I>, <I>FillStyle</I>, and <I>FillColor</I> properties, which means that you can draw circles with thicker borders and fill them with a pattern. The circle's border is usually drawn using the current <I>ForeColor</I> value, but you can override it by passing a fourth argument:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' A circle with a 3-pixel wide green border 
' filled with yellow solid color
DrawWidth = 3
FillStyle = vbFSSolid
FillColor = vbYellow
Circle (1200, 1200), 1000, vbGreen
</pre>
</td></tr>
</table></p>

<p>The preceding example draws a perfect circle on any monitor and at any screen resolution because Visual Basic automatically accounts for the different pixel density along the <I>x</I>- and <I>y</I>-axes. To draw an ellipse, you must skip two more optional arguments (which I'll explain later) and append an <I>aspect ratio</I> to the end of the command. The aspect ratio is the number you get when you divide the <I>y</I>-radius by the <I>x</I>-radius of the ellipse. To complicate matters, however, the value that you pass as the third argument of the method is always the larger of the two radii. So if you want to draw an ellipse inside a rectangular area, you must take additional precautions. This reusable routine lets you draw an ellipse using a simplified syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub Ellipse(X As Single, Y As Single, RadiusX As Single, _
    RadiusY As Single)
    Dim ratio As Single, radius As Single
    ratio = RadiusY / RadiusX
    If ratio &lt; 1 Then
        radius = RadiusX
    Else
        radius = RadiusY
    End If
    Circle (X, Y), radius, , , , ratio
End Sub
</pre>
</td></tr>
</table></p>

<p>The <I>Circle</I> method also allows you to draw both circle and ellipse arcs, using two arguments, <I>start</I> and <I>end</I>. (These are the arguments we skipped a moment ago.) The values of these arguments are the starting and ending angles formed by imaginary lines that connect that arc's extreme points with the center of the figure. Such angles are measured in radians, in a counterclockwise direction. For example, you can draw one quadrant of a perfect circle in this way:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Const PI = 3.14159265358979
Circle (ScaleWidth / 2, ScaleHeight / 2), 1500, vbBlack, 0, PI / 2
</pre>
</td></tr>
</table></p>

<p>Of course, you can add a <I>ratio </I>argument if you want to draw an ellipse arc. The <I>Circle</I> method can even draw pie slices, that is, arcs that are connected by a radius to the center of the circle or the ellipse. To draw such figures, you must specify a negative value for the <I>start </I>and <I>end </I>arguments. Figure 2-13, which shows a pie chart with an &quot;exploded&quot; portion, was drawn using the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Draw a pie with an &quot;exploded&quot; portion.
' NOTE that you can't specify a Null &quot;negative&quot; value
'      but you can express it as -(PI * 2).
Const PI = 3.14159265358979
FillStyle = vbFSSolid
FillColor = vbBlue
Circle (ScaleWidth / 2 + 200, ScaleHeight / 2 - 200), _
    1500, vbBlack, -(PI * 2), -(PI / 2)
FillColor = vbCyan
Circle (ScaleWidth / 2, ScaleHeight / 2), _
    1500, vbBlack, -(PI / 2), -(PI * 2)
</pre>
</td></tr>
</table></p>

<p>
<img src="images/F02ph13.GIF" width=386 height=271 border=0>
<p>
<!--caption--><B>Figure 2-13.</B> <i>Drawing pie charts.</i><!--/caption-->


<A NAME="65"><h2>The <I>DrawMode</I> Property</h2></A>
<p>As if all the properties and methods you've seen so far weren't enough, you must take into account yet another property of a Form, <I>DrawMode</I>, when you're writing graphic-intensive applications. This property specifies how the figures you're drawing interact with the pixels that are already on the form's surface. By default, all the pixels in your lines, circles, and arcs simply replace whatever is on the form, but this isn't necessarily what you want all the time. In fact, the <I>DrawMode</I> property lets you vary the effects that you get when you blend the pixels coming from the figure being drawn with those already on the form's surface. (Table 2-4 shows you the values that achieve various effects.)</p>


<p><b>Table 2-4.</b> <i>Constants for the</i> DrawMode <i>property.</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th><I>Constant</I></th>
<th><I>Value</I></th>
<th><I>Description</I></th>
<th><I>Bit-op (S=Screen, P=Pen)</I></th>
</tr>
<tr>
<td valign="top">vbBlackness</td>
<td valign="top">1</td>
<td valign="top">The screen color is set to all 0s. (The pen color isn't actually used.)</td>
<td valign="top">S = 0</td>
</tr>
<tr>
<td valign="top">vbNotMergePen</td>
<td valign="top">2</td>
<td valign="top">The OR operator is applied to the pen color and the screen color, and then the result is inverted (by applying the NOT operator).</td>
<td valign="top">S = Not (S Or P)</td>
</tr>
<tr>
<td valign="top">vbMaskNotPen</td>
<td valign="top">3</td>
<td valign="top">The pen color is inverted (using the NOT operator), and then the  AND operator is applied to the result and the screen color.</td>
<td valign="top">S = S And Not P</td>
</tr>
<tr>
<td valign="top">vbNotCopyPen</td>
<td valign="top">4</td>
<td valign="top">The pen color is inverted.</td>
<td valign="top">S = Not P</td>
</tr>
<tr>
<td valign="top">vbMaskPenNot</td>
<td valign="top">5</td>
<td valign="top">The screen color is inverted (using the NOT operator), and then the AND operator is applied to the result and the pen color.</td>
<td valign="top">S = Not S And P</td>
</tr>
<tr>
<td valign="top">vbInvert</td>
<td valign="top">6</td>
<td valign="top">Invert the screen color. (The pen color isn't actually used.)</td>
<td valign="top">S = Not S</td>
</tr>
<tr>
<td valign="top">vbXorPen</td>
<td valign="top">7</td>
<td valign="top">The XOR operator is applied to the pen color and the screen color.</td>
<td valign="top">S = S Xor P</td>
</tr>
<tr>
<td valign="top">vbNotMaskPen</td>
<td valign="top">8</td>
<td valign="top">The AND operator is applied to the pen color and the screen color, and then the result is inverted (using the NOT operator).</td>
<td valign="top">S = Not (S And P)</td>
</tr>
<tr>
<td valign="top">vbMaskPen</td>
<td valign="top">9</td>
<td valign="top">The AND operator is applied to the pen color and the color on the screen.</td>
<td valign="top">S = S And P</td>
</tr>
<tr>
<td valign="top">vbNotXorPen</td>
<td valign="top">10</td>
<td valign="top">The XOR operator is applied to the pen color and the screen color, and then the result is inverted (using the NOT operator).</td>
<td valign="top">S = Not (S Xor P)</td>
</tr>
<tr>
<td valign="top">vbNop</td>
<td valign="top">11</td>
<td valign="top">No operation (actually turns off drawing).</td>
<td valign="top">S = S</td>
</tr>
<tr>
<td valign="top">vbMergeNotPen</td>
<td valign="top">12</td>
<td valign="top">The pen color is inverted (by using the NOT operator), and then the OR operator is applied to the result and the screen color.</td>
<td valign="top">S = S Or Not P</td>
</tr>
<tr>
<td valign="top">vbCopyPen</td>
<td valign="top">13</td>
<td valign="top">Draw a pixel in the color specified by the <I>ForeColor </I>property (default).</td>
<td valign="top">S = P</td>
</tr>
<tr>
<td valign="top">vbMergePenNot</td>
<td valign="top">14</td>
<td valign="top">The screen color is inverted (using the NOT operator), and then the OR operator is applied to the result and the pen color.</td>
<td valign="top">S = Not S Or P</td>
</tr>
<tr>
<td valign="top">vbMergePen</td>
<td valign="top">15</td>
<td valign="top">The OR operator is applied to the pen color and the screen color.</td>
<td valign="top">S = S Or P</td>
</tr>
<tr>
<td valign="top">vbWhiteness</td>
<td valign="top">16</td>
<td valign="top">The screen color is set to all 1s. (The pen color isn't actually used.)</td>
<td valign="top">S = 
-1</td>
</tr>
</table></p>

<p>To understand what each drawing mode really does, you should remember that colors are ultimately represented simply by bits, so the operation of combining the pen color and the color already on the form's surface is nothing but a bit-wise operation on 0s and 1s. If you look at Table 2-4 from this perspective, the contents of the rightmost column make more sense, and you can use it to anticipate the results of your graphic commands. For example, if you draw a yellow point (corresponding to hex value &amp;HFFFF) over a cyan background color (&amp;HFFFF00), you can expect the following results:</p>

<p><table cellpadding=5 width="95%">
<tr>
<td valign="top"><I>vbCopyPen</I></td>
<td valign="top">Yellow (Screen color is ignored.)</td>
</tr>
<tr>
<td valign="top"><I>vbXorPen</I></td>
<td valign="top">Magenta (&amp;HFF00FF)</td>
</tr>
<tr>
<td valign="top"><I>vbMergePen</I></td>
<td valign="top">White (&amp;HFFFFFF)</td>
</tr>
<tr>
<td valign="top"><I>vbMaskPen</I></td>
<td valign="top">Green (&amp;H00FF00)</td>
</tr>
<tr>
<td valign="top"><I>vbNotMaskPen</i></td>
<td valign="top">Magenta (&amp;HFF00FF)</td>
</tr>
</table></p>

<p>Different draw modes can deliver the same result, especially if you're working with solid colors. (See the <I>vbXorPen </I>and <I>vbNotMaskPen </I>examples above.) I can almost hear you asking, &quot;Should we really worry about all these modes?&quot; The answer is no and yes. No, you don't usually need to worry about them if you're writing applications with trivial or no graphic output. Yes, you should at least know what Visual Basic has to offer you when it's time to do some advanced pixel manipulation.</p>

<p>One of the most useful things that you can do with the <I>DrawMode</I> property is <I>rubber banding,</I> the ability to draw and resize new shapes using the mouse without disturbing the underlying graphic. You use rubber banding techniques&#8212;without even knowing it&#8212;whenever you draw a shape in Microsoft Paint or any Windows paint program. Have you ever wondered what really happens when you drag one of the rectangle's corners using the mouse? Is Microsoft Paint actually erasing the rectangle and redrawing it in another position? How can you implement the same feature in your Visual Basic applications? The answer is much simpler than you might think and is based on the <I>DrawMode</I> property.</p>

<p>The trick is that if you apply the XOR operator twice to a value on the screen and the same pen value, after the second XOR command the original color on the screen is restored. (If you are familiar with bit-wise operations, this shouldn't surprise you; if you aren't, experiment with them until you are convinced that I am telling the truth.) Therefore, all you have to do is set <I>DrawMode</I> to the 7-vbXorPen value; then draw the rectangle (or line, circle, arc, and so on) once to show it and a second time to erase it. When the user eventually releases the mouse cursor, you set the <I>DrawMode</I> property to 13-vbCopyPen and draw the final rectangle on the form's surface. The following program lets you experiment with rubber banding: You can draw empty rectangles (with random line width and color) by dragging the left button and filled rectangles by dragging the right mouse button.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Form-level variables
Dim X1 As Single, X2 As Single
Dim Y1 As Single, Y2 As Single
' True if we are dragging a rectangle
Dim dragging As Boolean

Private Sub Form_Load()
    ' Rubber-banding works particularly well on a black background.
    BackColor = vbBlack
End Sub

Private Sub Form_MouseDown(Button As Integer, Shift As Integer, _
    X As Single, Y As Single)
    If Button And 3 Then
        dragging = True
        ' Remember starting coordinates.
        X1 = X: Y1 = Y: X2 = X: Y2 = Y
        ' Select a random color and width.
        ForeColor = RGB(Rnd * 255, Rnd * 255, Rnd * 255)
        DrawWidth = Rnd * 3 + 1
        ' Draw the very first rectangle in Xor mode.
        DrawMode = vbXorPen
        Line (X1, Y1)-(X2, Y2), , B
        If Button = 2 Then
            ' Filled rectangles
            FillStyle = vbFSSolid
            FillColor = ForeColor
        End If
    End If
End Sub

Private Sub Form_MouseMove(Button As Integer, Shift As Integer, _
    X As Single, Y As Single)
    If dragging Then
        ' Delete old rectangle (repeat the same command in Xor mode).
        Line (X1, Y1)-(X2, Y2), , B
        ' Redraw to new coordinates.
        X2 = X: Y2 = Y
        Line (X1, Y1)-(X2, Y2), , B
    End If
End Sub

Private Sub Form_MouseUp(Button As Integer, Shift As Integer, _
    X As Single, Y As Single)
    If dragging Then
        dragging = False
        ' Draw the definitive rectangle.
        DrawMode = vbCopyPen
        Line (X1, Y1)-(X, Y), , B
        FillStyle = vbFSTransparent
    End If
End Sub
</pre>
</td></tr>
</table></p>

<A NAME="66"><h2>The <I>ScaleMode</I> Property</h2></A>
<p>While the twip is the default unit of measurement for Visual Basic when placing and resizing objects on screen, it isn't the only one available. In fact, forms and some other controls that can work as containers&#8212;most notably, PictureBox controls&#8212;expose a <I>ScaleMode</I> property that can be set either at design time or run time with one of the values displayed in Table 2-5.</p>

<P><B>Table 2-5.</B> <i>Constants for the ScaleMode property.</i></P>

<p><table cellpadding=5 width="95%">
<tr>
<th><I>Constant</I></th>
<th><I>Value</I></th>
<th><I>Description</I></th>
</tr>
<tr>
<td valign="top">vbUser</td>
<td valign="top">0</td>
<td valign="top">User-defined scale mode</td>
</tr>
<tr>
<td valign="top">vbTwips</td>
<td valign="top">1</td>
<td valign="top">Twips (1440 twips per logical inch; 567 twips 
per logical centimeter)</td>
</tr>
<tr>
<td valign="top">vbPoints</td>
<td valign="top">2</td>
<td valign="top">Points (72 points per logical inch)</td>
</tr>
<tr>
<td valign="top">vbPixels</td>
<td valign="top">3</td>
<td valign="top">Pixels</td>
</tr>
<tr>
<td valign="top">vbCharacters</td>
<td valign="top">4</td>
<td valign="top">Characters (horizontal = 120 twips per unit; vertical = 240 twips per unit)</td>
</tr>
<tr>
<td valign="top">vbInches</td>
<td valign="top">5</td>
<td valign="top">Inches</td>
</tr>
<tr>
<td valign="top">vbMillimeters</td>
<td valign="top">6</td>
<td valign="top">Millimeters</td>
</tr>
<tr>
<td valign="top">vbCentimeters</td>
<td valign="top">7</td>
<td valign="top">Centimeters</td>
</tr>
<tr>
<td valign="top">vbHimetric</td>
<td valign="top">8</td>
<td valign="top">Himetric (1000 units = 1 centimeter)</td>
</tr>
</table></p>

<p>The form object exposes two methods that let you easily convert between different units of measurement; you use the <I>ScaleX</I> method for horizontal measurements and the <I>ScaleY</I> method for vertical measurements. Their syntax is identical: You pass the value to be converted (the source value), a constant from among those in Table 2-5 that specifies the unit used for the source value (the <I>fromscale </I>argument), and another constant that specifies which unit you want to convert it to (the <I>toscale </I>argument). If you omit the <I>fromscale </I>argument, vbHimetric is assumed; if you omit the <I>toscale </I>argument, the current value of the <I>ScaleMode </I>property is assumed:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' How many twips per pixel along the x-axis?
Print ScaleX(1, vbPixels, vbTwips)

' Draw a 50x80 pixel rectangle in the upper left corner
' of the form, regardless of the current ScaleMode.
Line (0, 0)-(ScaleX(50, vbPixels), ScaleY(80, vbPixels)), _
    vbBlack, B
</pre>
</td></tr>
</table></p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
The <I>ScaleX</I> and <I>ScaleY</I> methods offer the same functionality as the Screen object's <I>TwipsPerPixelX</I> and <I>TwipsPerPixelY</I> properties, work for other measurement units, and don't require that you write the actual conversion code. The only time you should continue to use the Screen's properties is when you are writing code in a BAS module (for example, a generic function or procedure) and you don't have any form reference at hand.
</blockquote></div></p>

<p>The <I>ScaleMode</I> property is closely related to four other properties. <I>ScaleLeft</I> and <I>ScaleTop</I> correspond to the (<I>x,y</I>) values of the upper left pixel in the client area of the form and are usually both set to 0. <I>ScaleWidth</I> and <I>ScaleHeight</I> correspond to the coordinates of the pixel in the bottom right corner in the client area. If you set a different <I>ScaleMode</I>, these two properties immediately reflect the new setting. For example, if you set <I>ScaleMode</I> to 3-vbPixels, you can then query <I>ScaleWidth</I> and <I>ScaleHeight</I> to learn the size of the client area in pixels. Keep in mind that, even if the current <I>ScaleMode</I> is 1-vbTwips, the <I>ScaleWidth</I> and <I>ScaleHeight </I>properties return values that differ from the form's <I>Width</I> and <I>Height</I> properties, respectively, because the latter ones account for the window's borders and title bar, which are outside the client area. If you know the relationship among these quantities, you can derive some useful information about your form:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Run this code from inside a form module.
' Ensure that ScaleWidth and ScaleHeight return twips.
' (Next line is useless if you are using default settings.) 
ScaleMode = vbTwips
' Evaluate the border's width in pixels.
BorderWidth = (Width _ ScaleWidth) / Screen.TwipsPerPixelX / 2

' Evaluate the caption's height in pixels.
' (Assumes that the form has no menu bar)
CaptionHeight = (Height _ ScaleHeight) / _
    Screen.TwipsPerPixelY _ BorderWidth * 2
</pre>
</td></tr>
</table></p>

<p>You can assign the <I>ScaleMode </I>property any value that fits your requirements, but the values that are most frequently used are vbTwips and vbPixels. The latter is useful if you want to retrieve the coordinates of child controls in pixels, which is often necessary if you're performing some advanced graphic command that involves Windows API calls.</p>

<p>The vbUser setting is unique in that you don't usually assign it to the <I>ScaleMode</I> property. Instead, you define a custom coordinate system by setting <I>ScaleLeft</I>, <I>ScaleTop</I>, <I>ScaleWidth</I>, and <I>ScaleHeight</I> properties. When you do it, the <I>ScaleMode</I> property is automatically set to 0-vbUser by Visual Basic. You might need to create a custom coordinate system to simplify the code in an application and have Visual Basic perform all the needed conversions on your behalf. The following program plots a function on a form, using a custom coordinate system. (See the results in Figure 2-14.)</p>

<p>
<A HREF="javascript:fullSize('F02ph14x.htm')"> <img src="images/F02ph14.JPG" width=404 height=206 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 2-14.</B> <i>Plotting a third-degree polynomial function using a custom coordinate system.</i><!--/caption-->
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' The portion of X-Y plane to be plotted
Const XMIN = -5, XMAX = 5, YMIN = -100, YMAX = 100
Const XSTEP = 0.01

Private Sub Form_Resize()
    ' Set a custom graphic coordinate system so that
    ' the visible viewport corresponds to constants above.
    ScaleLeft = XMIN
    ScaleTop = YMAX
    ScaleWidth = XMAX - XMIN
    ScaleHeight = -(YMAX - YMIN)
    ' Force a Paint event.
    Refresh
End Sub

Private Sub Form_Paint()
    Dim x As Single, y As Single
    ' Start with a blank canvas.
    Cls
    ForeColor = vbBlack
    ' Explain what is being displayed.
    CurrentX = ScaleLeft
    CurrentY = ScaleTop
    Print &quot;f(x) = x ^ 3 - 2 * x ^ 2 + 10 * x + 5&quot;
    CurrentX = ScaleLeft
    Print &quot;X-interval: [&quot; &amp; XMIN &amp; &quot;,&quot; &amp; XMAX &amp; &quot;]&quot;
    CurrentX = ScaleLeft
    Print &quot;Y-range: [&quot; &amp; YMIN &amp; &quot;,&quot; &amp; YMAX &amp; &quot;]&quot;
    ' Draw x- and y-axes.
    Line (XMIN, 0)-(XMAX, 0)
    Line (0, YMIN)-(0, YMAX)
    ' Plot the math function.
    ForeColor = vbRed
    For x = XMIN To XMAX Step XSTEP
        y = x ^ 3 - 2 * x ^ 2 + 10 * x + 5
        PSet (x, y)
    Next
End Sub
</pre>
</td></tr>
</table></p>

<p>You should pay attention to several notable things about the preceding code:</p>

<UL>
<p><li>The <I>ScaleHeight</I> property is negative, which is perfectly legal; in fact, when showing a <I>y</I>-axis, you'll often have to set up negative values for this property because by default <I>y</I>-coordinates increase their value going from top to bottom, while you usually need exactly the opposite.</li></p>

<p><li>You can resize the form at will, and it will always display the same portion of the <I>x-y</I> plane, distorting it if necessary.</li></p>

<p><li>Once you have set a custom system in the <I>Resize</I> event procedure, you can reason in terms of <I>x-y</I> coordinates in your own coordinate system, which greatly simplifies the plotting code.</li></p>

<p><li>The <I>Cls</I> graphic method resets the <I>CurrentX </I>and <I>CurrentY</I> coordinates to (0,0), which in this case corresponds to the center of the screen, so you have to manually set <I>CurrentX</I> and <I>CurrentY</I> properties to print in the upper left corner.</li></p>

<p><li>The <I>Print</I> method always resets the <I>CurrentX</I> property to 0, so you have to set it each time you print a line of text.</li></p>
</UL>
 
<A NAME="67"><h2>Palette Support</h2></A>
<p>First, some theory. Most video cards are theoretically able to display 16 million distinct colors. (I say theoretically because we humans can't distinguish most colors from those nearest in the continuum.) Only relatively few <I>true-color </I>video cards are capable, however, of actually showing that many colors in a given instant on the screen, especially at higher screen definitions. (For the sake of simplicity, I omit a description of <I>hi-color </I>cards capable of 65,536 simultaneously displayed colors.) In all other cases, Windows has to resort to <I>palettes</I>.</p>

<p>A palette is a subset of 256 colors among those theoretically supported by the video card. If a video card works in the palette mode, it devotes 1 byte to each pixel on the screen (instead of the 3 bytes that would be necessary to hold 16 million different color values), thus saving a lot of memory and accelerating most graphic operations. Each of the possible 256 values points to another table, where the video card can find the actual RGB value for each color. Each pixel can have a well-defined color, but there can be no more than 256 distinct colors on the screen at a given moment.</p>

<p>Windows reserves for itself 16 colors and leaves the remaining ones available for use by applications. When the foreground application has to display an image, it uses the available palette entries and tries to match the colors in the image. If the image embeds more distinct colors than the number of available colors, the application has to find a decent compromise&#8212;for example, by using the same palette entry for two similar colors. In practice, this isn't a big issue, at least compared with what follows. A more serious problem with palettes, in fact, is that when an application has to display multiple images at the same time, it must arbitrate among different sets of colors. Which one has precedence? What happens to the other images?</p>

<p>Until Visual Basic 5, the solution available to Visual Basic developers wasn't actually a solution. Visual Basic 4 and previous versions simply gave the precedence to the image that was first in z-order&#8212;in other words, the form or the control that had the focus. All the other images on the screen were displayed using a palette that in most cases didn't fit their set of colors, and the results were often obscene. Starting with Visual Basic 5, we finally have a choice.</p>

<p>The key to this new capability is the form's <I>PaletteMode</I> property, which can be assigned&#8212;both at design time and run time&#8212;three different values: 0-vbPaletteModeHalftone, 1-vbPaletteModeUseZOrder, and 2-vbPaletteModeCustom. The <I>Halftone </I>palette is a special fixed palette that contains an assortment of &quot;average&quot; colors; it should provide a reasonable rendering for many images and, above all, should allow multiple images with different palettes to peacefully coexist on the form. (This is the default mode for Visual Basic 5 and 6 forms). The <I>ZOrder </I>mode is the only setting available to previous versions of the language. The Form or PictureBox that has the focus affects the palette used by the video card; it will be shown in the best way possible, but all others probably won't be shown to advantage. The third setting, <I>Custom</I> mode, lets you set up a custom palette. To do so, you assign a bitmap&#8212;at design time or at run time, using the <I>LoadPicture</I> function&#8212;to the <I>Palette</I> property. In this case, the palette associated with the image you provide becomes the palette used by the form.</p>

<p>This concludes the description of all the properties, methods, and events supported by the Form object. Much of this knowledge will be useful in the <a href="ch03a.htm">next chapter</a> too, where I describe the features of all the intrinsic Visual Basic controls.</p>
</BODY>
</HTML>




