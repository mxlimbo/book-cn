<HTML>
<HEAD>
<TITLE>Refining the ActiveX Control</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch17c.htm", "ch17e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="839"><h1>Refining the ActiveX Control</h1></A>
<p>Adding a UserControl object to the current project and placing some 
constituent controls on it is just the first step toward the creation of a full-fledged, 
commercial-quality ActiveX control. In this section, I'll show you how to implement a robust 
user interface, add binding capabilities and property pages, create user-drawn 
controls, and prepare your controls for the Internet.
</p>

<A NAME="840"><h2>Custom Properties</h2></A>
<p>You've already seen how you can add custom properties using pairs of property 
procedures. This section explains how to implement some special types of properties.
</p>

<A NAME="841"><h3>Design-time and run-time properties</h3></A>
<p>Not all properties are available both at design time and at run time, and it's 
interesting to see how you write the code in the UserControl module to limit the 
visibility of properties. The easiest way to create a run time-only property, such as the 
<I>SelText </I>property of a TextBox or the <I>ListIndex 
</I>property of a ListBox, is by ticking the Don't Show In Property Browser option in the Attributes section of the Procedure 
Attributes dialog box. (You can access this dialog box by choosing it from the Tools menu.) 
If this check box is selected, the property doesn't appear in the Properties window 
at design time.
</p>

<p>The problem with this simple approach, however, is that it also hides the 
property in the other property browser that Visual Basic provides, namely the Locals 
window. To have the property listed in the Locals window at run time but not in 
the Properties window, you must raise an error in the 
<I>Property Get </I>procedure at design time, as this code demonstrates:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Public Property Get SelText() As String
    If Ambient.UserMode = False Then Err.Raise 387
    SelText = Text1.SelText
End Property
</pre>
</td></tr>
</table>
</p>

<p>Error 387 &quot;Set not permitted&quot; is the error that by convention you should 
raise in this case, but any error will do the trick. If Visual Basic&#8212;or more generally, 
the host environment&#8212;receives an error when reading a value at design time, the 
property isn't displayed in the properties browser, which is precisely what you want. 
Creating a property that's unavailable at design time and read-only at run time is 
even simpler because you need merely to omit the 
<I>Property Let </I>procedure, as you would do with any read-only property. Visual Basic doesn't show such a property in 
the Properties window because it couldn't be modified in any way.
</p>

<p>Another common situation concerns properties that are available at design 
time and read-only at run time. This is similar to the 
<I>MultiLine </I>and <I>ScrollBars </I>properties of the Visual Basic TextBox control. You can implement such properties by 
raising Error 382 &quot;Set not supported at runtime&quot; in their 
<I>Property Let </I>procedures, as shown in the following code:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' This property is available at design time and read-only at run time.
Public Property Get ScrollBars() As Integer
    ScrollBars = m_ScrollBars 
End Property
Public Property Let ScrollBars(ByVal New_ScrollBars As Integer)
    If Ambient.UserMode Then Err.Raise 382
    m_ScrollBars = New_ScrollBars
    PropertyChanged &quot;ScrollBars&quot;
End Property
</pre>
</td></tr>
</table>
</p>

<p>When you have design-time properties that are read-only at run time, you 
can't call the <I>Property Let </I>procedure from within the 
<I>ReadProperties </I>event procedure because you would get an error. In this case, you're forced to directly assign the 
private member variable or the constituent control's property, or you have to 
provide a module-level Boolean variable that you set to True on entering the 
<I>ReadProperties </I>event and reset to False on exit. You then query this variable before raising errors 
in the <I>Property Let </I>procedure. You can also use the same variable to skip an 
unnecessary call to the <I>PropertyChanged </I>method, as in this code example:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Public Property Let ScrollBars(ByVal New_ScrollBars As Integer)
    ' The ReadingProperties variable is True if this routine is being
    ' called from within the ReadProperties event procedure.
    If Ambient.UserMode <B>
And Not ReadingProperties </B>Then Err.Raise 382
    m_ScrollBars = New_ScrollBars
    <B>If Not ReadingProperties Then </B>
PropertyChanged &quot;ScrollBars&quot;
End Property
</pre>
</td></tr>
</table>
</p>

<A NAME="842"><h3>Enumerated properties</h3></A>
<p>You can define enumerated properties using either 
<I>Enum </I>blocks in code or Visual Basic's own enumerated types. For example, you can modify the code produced 
by the wizard and improve the <I>MousePointer </I>property as follows:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Public Property Get MousePointer() <B>As MousePointerConstants</B>
    MousePointer = Text1.MousePointer
End Property
Public Property Let MousePointer(ByVal New_MousePointer _
    <B>As MousePointerConstants</B>)
    Text1.MousePointer() = New_MousePointer
    PropertyChanged &quot;MousePointer&quot;
End Property
</pre>
</td></tr>
</table>
</p>

<p>Enumerated properties are useful because their valid values appear in the 
Properties window in a combo box, as shown in Figure 17-6. Keep in mind, however, that you should always protect your ActiveX control from invalid assignments in 
code, so the previous routine should be rewritten as follows:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Public Property Let MousePointer(ByVal New_MousePointer _
    As MousePointerConstants)
    Select Case New_MousePointer
        Case vbDefault To vbSizeAll, vbCustom
            Text1.MousePointer() = New_MousePointer
            PropertyChanged &quot;MousePointer&quot;
        Case Else
            Err.Raise 380   ' Invalid Property Value error
    End Select
End Property
</pre>
</td></tr>
</table>
</p>

<p>
<img src="images/F17ph06.GIF" width=337 height=337 border="0">
<p>
<!--caption--><B>Figure 17-6.</B> <i>Use enumerated properties to offer a list of valid values in the Properties window.</i><!--/caption-->

<p>There's a good reason for not defining properties and arguments using 
Visual Basic and VBA enumerated constants, though: If you use the control with 
environments other than Visual Basic, these symbolic constants won't be visible to the 
client application.
</p>

<p><div class="tip"><blockquote>
<b>TIP</b><hr>Sometimes you might want to add spaces and other symbols inside 
an enumerated value to make it more readable in the Properties window. For 
example, the <I>FillStyle </I>property includes values such as 
<I>Horizontal Line </I>or <I>Diagonal Cross</I>. To expose similar values in your ActiveX controls, you have to 
enclose Enum constants within square brackets, as in the following code:

<p>
<table><tr><td>
<pre>Enum MyColors
    Black = 1
    [Dark Gray]
    [Light Gray]
    White 
End Enum
</pre>
</td></tr>
</table>
</p>
</blockquote></div>
</p>

<p><div class="tip"><blockquote>
<b>TIP</b><hr>Here's another idea that you might find useful: If you use an 
enumerated constant name whose name begins with an underscore, such as 
<I>[_HiddenValue]</I>, this value won't appear by default in the Object Browser. However, this 
value does appear in the Properties window, so this trick is especially useful for 
enumerated properties that aren't available at design time.

</blockquote></div>
</p>

<A NAME="843"><h3>Picture and Font properties</h3></A>
<p>Visual Basic deals in a special way with properties that return a Picture or Font 
object. In the former instance, the Properties window shows a button that lets you 
select an image from disk; in the latter, the Properties window includes a button that 
displays a Font common dialog box.
</p>

<p>When working with Font properties, you should keep in mind that they 
return object references. For example, if two or more constituent controls have been 
assigned the same Font reference, changing a font attribute in one of them also changes 
the appearance of all the others. For this reason, 
<I>Ambient.Font </I>returns a copy of the parent form's font so that any subsequent change to the form's font doesn't 
affect the UserControl's constituent controls, and vice versa. (If you want to keep your 
control's font in sync with the form's font, you simply need to trap 
the <I>AmbientChanged </I>event.) Sharing object references can cause some subtle errors in your code. Consider 
the following example:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' Case 1: Label1 and Text1 use fonts with identical attributes.
Set Label1.Font = Ambient.Font
Set Text1.Font = Ambient.Font

' Case 2: Label1 and Text1 point to the *same* font.
Set Label1.Font = Ambient.Font
Set Text1.Font = Label1.Font
</pre>
</td></tr>
</table>
</p>

<p>The two pieces of code look similar, but in the first instance the two 
constituent controls are assigned different copies of the same font, so you can change 
the font attributes of one control without affecting the other. In the latter case, 
both controls are pointing to the same font, so each time you modify a font attribute 
in either control the other one is affected as well.
</p>

<p>It's a common practice to provide all the alternate, old-styled 
<I>Font</I>xxxx properties, namely <I>FontName</I>, 
<I>FontSize</I>, <I>FontBold</I>, 
<I>FontItalic</I>, <I>FontUnderline</I>, and 
<I>FontStrikethru</I>. But you should also make these properties unavailable at design 
time, and you shouldn't save them in the <I>WriteProperties 
</I>event if you also save the <I>Font </I>object. If you decide to save individual 
<I>Font</I>xxxx properties, it's important that 
you retrieve them in the correct order (first 
<I>FontName</I>, and then all the others).
</p>

<p>One more thing to keep in mind when dealing with font properties: You 
can't restrict the choices of the programmer who's using the control to a family of 
fonts&#8212; for example, to nonproportional fonts or to printer fonts&#8212;if the 
<I>Font</I> property is exposed in the Properties window. The only way to restrict font selection is to show 
a Font Common Dialog box from a Property Page. See the &quot;<A HREF="ch17d.htm#862">Property Pages</A>&quot; 
section later in this chapter for details about building property pages.
</p>

<p>
<img src="images/new.jpg" width=102 height=87 border="0">
</p>

<p>Font properties pose a special challenge to ActiveX control programmers. If 
your control exposes a <I>Font</I> property and the client code modifies one or more font 
attributes, Visual Basic calls the <I>Property Get Font 
</I>procedure but not the <I>Property Set Font 
</I>procedure. If the <I>Font </I>property delegates to a single constituent control, this 
isn't usually a problem because the control's appearance is correctly updated. Things 
are different in user-drawn ActiveX controls because in this case your control gets 
no notification that it should be repainted. This problem has been solved in Visual 
Basic 6 with the <I>FontChanged </I>event of the 
StdFont<I> </I>object. Here's a fragment of 
code taken from a Label-like, user-drawn control that correctly refreshes itself when 
the client modifies an attribute of the <I>Font 
</I>property:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private WithEvents UCFont As StdFont

Private Sub UserControl_InitProperties()
    ' Initialize the Font property (and the UCFont object).
    Set Font = Ambient.Font
End Sub

Public Property Get Font() As Font
    Set Font = UserControl.Font
End Property
Public Property Set Font(ByVal New_Font As Font)
    Set UserControl.Font = New_Font
    Set UCFont = New_Font         ' Prepare to trap events.
    PropertyChanged &quot;Font&quot;
    Refresh                       ' Manually perform the first refresh.
End Property

' This event fires when the client code changes a font's attribute.
Private Sub UCFont_FontChanged(ByVal PropertyName As String)
    Refresh                       ' This causes a Paint event.
End Sub
' Repaint the control.
Private Sub UserControl_Paint()
    Cls
    Print Caption;
End Sub
</pre>
</td></tr>
</table>
</p>

<A NAME="844"><h3>Object properties</h3></A>

<p>You can create ActiveX controls with properties that return objects, such as 
a TreeView-like control that exposes a Nodes collection. This is possible 
because ActiveX control projects can include PublicNotCreatable classes, so your control can 
internally create them using the New operator and return a reference to its clients through 
a read-only property. Object properties can be treated as if they were regular 
properties in most circumstances, but they require particular attention when you need to 
make them persistent and reload them in the <I>WriteProperties 
</I>and <I>ReadProperties </I>procedures.
</p>

<p>Even if Visual Basic 6 does support persistable classes, you can't save 
objects that aren't creatable, as in this case. But nothing prevents you from manually 
creating a PropertyBag object and loading it with all the properties of the dependent 
object. Let me demonstrate this technique with an example.
</p>

<p>Suppose that you have an AddressOCX ActiveX control that lets the user 
enter a person's name and address, as shown in Figure 17-7. Instead of many 
properties, this AddressOCX control exposes one object property, named 
<I>Address</I>, whose class is defined inside the same project. Rather than having the main UserControl 
module save and reload the individual properties of the dependent object, you should 
create a Friend property in the PublicNotCreatable class. I usually call this 
property <I>AllProperties</I> because it sets and returns the values of all the properties in one 
Byte array. To serialize the properties into an array, I use a private stand-alone 
PropertyBag object. Following is the complete source code of the Address class module. (For 
the sake of simplicity, properties are implemented as Public variables.)
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' The Address.cls class module
Public Name As String, Street As String
Public City As String, Zip As String, State As String

Friend Property Get AllProperties() As Byte()
    Dim PropBag As New PropertyBag
    PropBag.WriteProperty &quot;Name&quot;, Name, &quot;&quot;
    PropBag.WriteProperty &quot;Street&quot;, Street, &quot;&quot;
    PropBag.WriteProperty &quot;City&quot;, City, &quot;&quot;
    PropBag.WriteProperty &quot;Zip&quot;, Zip, &quot;&quot;
    PropBag.WriteProperty &quot;State&quot;, State, &quot;&quot;
    AllProperties = PropBag.Contents
End Property
Friend Property Let AllProperties(value() As Byte)
    Dim PropBag As New PropertyBag
    PropBag.Contents = value()
    Name = PropBag.ReadProperty(&quot;Name&quot;, &quot;&quot;)
    Street = PropBag.ReadProperty(&quot;Street&quot;, &quot;&quot;)
    City = PropBag.ReadProperty(&quot;City&quot;, &quot;&quot;)
    Zip = PropBag.ReadProperty(&quot;Zip&quot;, &quot;&quot;)
    State = PropBag.ReadProperty(&quot;State&quot;, &quot;&quot;)
End Property
</pre>
</td></tr>
</table>
</p>

<p>Rather than saving and reloading all the individual properties in the 
<I>WriteProperties </I>and <I>ReadProperties </I>event procedures of the main AddressOCX module, you simply 
save and restore the <I>AllProperties </I>property of the Address object.
</p>

<p>
<A HREF="javascript:fullSize('F17ph07x.htm')"> <img src="images/F17ph07.JPG" width=404 height=206 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 17-7.</B> <i>An AddressOCX ActiveX control that exposes each of the Address properties as an individual Address, PublicNotCreatableobject.</i><!--/caption-->
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' The AddressOCX code module (partial listing)
Dim m_Address As New Address

Public Property Get Address() As Address
    Set Address = m_Address
End Property
Public Property Set Address(ByVal New_Address As Address)
    Set m_Address = New_Address
    PropertyChanged &quot;Address&quot;
End Property

Private Sub UserControl_ReadProperties(PropBag As PropertyBag)
    m_Address.AllProperties = PropBag.ReadProperty(&quot;Address&quot;)
End Sub

Private Sub UserControl_WriteProperties(PropBag As PropertyBag)
    Call PropBag.WriteProperty(&quot;Address&quot;, m_Address.AllProperties)
End Sub
</pre>
</td></tr>
</table>
</p>

<p>All the individual constituent controls must refer to the corresponding 
property in the Address object. For example, this is the code in the 
<I>Change </I>event procedure of the txtName control:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub txtName_Change()
    Address.Name = txtName
    PropertyChanged &quot;Address&quot;
End Sub
</pre>
</td></tr>
</table>
</p>

<p>The ActiveX control should also expose a <I>Refresh 
</I>method that reloads all the values from the Address object into the individual fields. Alternatively, you 
might implement an event that the Address object raises in the AddressOCX module 
when any of its properties is assigned a new value. This problem is similar to the one 
I described in the &quot;<A HREF="ch09b.htm#381">Forms as Object Viewers</A>&quot; section of Chapter 9.
</p>

<A NAME="845"><h3>Properties that return UDTs</h3></A>
<p>
<img src="images/new.jpg" width=102 height=87 border="0">
</p>

<p>ActiveX controls can expose properties and methods that return user-defined 
types or that accept UDTs as arguments. Because ActiveX controls are in-process 
COM components, you can always marshal UDTs regardless of the operating system 
version. For more details, see the &quot;<A HREF="ch16c.htm#735">Passing Data Between Applications</A>&quot; section of Chapter 16.
</p>

<p>This feature hasn't been completely ironed out, however. You can't use a 
property that returns a UDT in a <I>With </I>block without crashing the Visual Basic 
environment. I hope this bug will be fixed in a future service pack.
</p>

<A NAME="846"><h3>Special OLE data types </h3></A>
<p>Properties can also return a few special data types. For example, the Wizard 
declares all the color properties using the OLE_COLOR type, as in this code:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Public Property Get BackColor() <B>As OLE_COLOR</B>
    BackColor = Text1.BackColor
End Property
</pre>
</td></tr>
</table>
</p>

<p>When a property is declared as returning an OLE_COLOR value, 
programmers can pick its value from a palette of colors in the Properties window, exactly as 
they can with the <I>ForeColor </I>and <I>BackColor 
</I>properties of Visual Basic's own controls. For any other purpose, an OLE_COLOR property is treated internally as a Long.
</p>

<p>Visual Basic supports three other special data types:
</p>

<UL>
<p><li> OLE_TRISTATE is used for CheckBox-like controls that can be in 
three states. This enumerated property can return the values 
0-Unchecked, 1Checked, and 2-Gray.
</li></p>
<p><li> OLE_OPTEXCLUSIVE is used for OptionButton-like controls. When 
you build an ActiveX control that must behave like an OptionButton, 
you should have it expose a <I>Value </I>property of type OLE_OPTEXCLUSIVE 
and make it the default property for the control. The container ensures 
that when the <I>Value </I>property of one control in a group is assigned the 
True value, the <I>Value </I>properties of all other controls in the group are 
automatically set to False. (You need to call the 
<I>PropertyChanged</I> method in the property's 
<I>Property Let </I>procedure to have this mechanism work correctly.)
</li></p>
<p><li> OLE_CANCELBOOL is used for the <I>Cancel 
</I>argument in event declarations when you want to give clients the opportunity to cancel the 
event notification.
</li></p>
</UL>
 
<A NAME="847"><h3>Procedure IDs</h3></A>
<p>A few ActiveX control properties have special meanings. You define such 
special properties by assigning specific procedure IDs in the Advanced section of the 
Procedure Attributes dialog box.
</p>

<p>As I already explained in the &quot;<A HREF="ch06c.htm#243">Attributes</A>&quot; section of Chapter 6, you can 
make a property or a method the default member of a class by typing 
<I>0 </I>(zero) or by selecting the (default) option from the list in the Procedure ID field. An OLE_
OPTEXCLUSIVE property must be the default property to have the ActiveX 
control correctly behave like an OptionButton control.
</p>

<p>If you have a <I>Text </I>or <I>Caption </I>property, you should assign it the Text or 
Caption procedure ID, respectively. These settings make these properties behave as 
they do in Visual Basic: When the programmer types their values in the Properties 
window, the control is immediately updated. Behind the scenes, the Properties 
window calls the <I>Property Let</I> procedure at each key press instead of calling it only when 
the programmer presses the Enter key. You can use these procedure IDs for any 
property, regardless of its name. However, your control can't have more than two 
properties that behave in this way.
</p>

<p><div class="tip"><blockquote>
<b>TIP</b><hr>Because you can select only one item in the procedure ID field, it 
seems to be impossible to duplicate the behavior of Visual Basic's TextBox and 
Label controls, which expose a <I>Text </I>or <I>Caption 
</I>property that's immediately updated by the Properties window and is the default property at the same time. You 
can work around this problem by defining a hidden property, make it the default 
property, and have it delegate to the <I>Text </I>or 
<I>Caption</I> property:

<p>
<table><tr><td>
<pre>' Make this property the default property, and hide it.
Public Property Get Text_() As String
    Text_ = Text
End Property

Public Property Let Text_(ByVal newValue As String)
    Text = newValue
End Property
</pre>
</td></tr>
</table>
</p>

</blockquote></div>
</p>

<p>You should assign the Enabled procedure ID to the 
<I>Enabled </I>property of your ActiveX control so that it works correctly. This is a necessary step because the 
<I>Enabled </I>property behaves differently from any other property. When you disable a form, 
the form also disables all its controls by setting their Extender's 
<I>Enabled </I>property to False (so that controls appear disabled to the running code), but without setting their 
inner <I>Enabled </I>properties to False (so that controls repaint themselves as if they 
were enabled). To have Visual Basic create an Extender's 
<I>Enabled</I> property, your UserControl module must expose a Public 
<I>Enabled </I>property marked with the Enabled procedure ID:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Public Property Get Enabled() As Boolean
    Enabled = Text1.Enabled
End Property

Public Property Let Enabled(ByVal New_Enabled As Boolean)
    Text1.Enabled() = New_Enabled
    PropertyChanged &quot;Enabled&quot;
End Property
</pre>
</td></tr>
</table>
</p>

<p>The ActiveX Control Interface Wizard correctly creates the delegation code, 
but you have to assign the Enabled procedure ID manually.
</p>

<p>Finally, you can create an About dialog box for displaying copyright 
information about your control by adding a Public 
<I>Sub</I> in its UserControl module and assigning the AboutBox procedure ID to it:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Sub ShowAboutBox()
    MsgBox &quot;The SuperTextBox control&quot; &amp; vbCr _
        &amp; &quot;(C) 1999 Francesco Balena&quot;, vbInformation
End Sub
</pre>
</td></tr>
</table>
</p>

<p>When the ActiveX control exposes a method with this procedure ID, an 
(About)<I> </I>item appear in the Properties window. It's common practice to hide this item so 
that programmers aren't encouraged to call it from code.
</p>

<A NAME="848"><h3>The Procedure Attributes dialog box</h3></A>
<p>A few more fields in the Procedure Attributes dialog box are useful for 
improving the friendliness of your ActiveX controls. Not one of these setting affects the 
functionality of the control.
</p>

<p>I've already described the Don't Show In Property Browser field in the 
&quot;<A HREF="ch17d.htm#841">Design-Time and Run-Time Properties</A>&quot; section earlier in this chapter. When this check 
box is selected, the property won't appear in the Properties window at design time or 
in the Locals window at run time.
</p>

<p>The Use This Page In The Property Browser combo box lets you associate 
the property with one generic property page provided by Visual Basic 
(namely StandardColor, StandardDataFormat, StandardFont, and StandardPicture) or with 
a property page that's defined in the ActiveX control project. When a property is 
associated with a property page, it appears in the Properties window with a 
button that, when clicked, brings up the property page. Property pages are described 
later in this chapter.
</p>

<p>Use the Property Category field to select the category under which you 
want the property to appear in the Categorized tab of the Properties window. Visual 
Basic provides several categories&#8212;Appearance, Behavior, Data, DDE, Font, List, 
Misc, Position, Scale, and Text&#8212;and you can create new ones by typing their names in 
the edit portion of this combo box.
</p>

<p>The User Interface Default attribute can have different meanings, depending 
on whether it's applied to a property or to an event. The property marked with 
this attribute is the one that's selected in the Properties window when you display it 
after creating the control. The event marked with the User Interface Default 
attribute is the one whose template is built for you by Visual Basic in the code window 
when you double-click the ActiveX control on the form's surface.
</p>

<A NAME="849"><h3>Limitations and workarounds</h3></A>

<p>Creating ActiveX controls based on simpler constituent controls is an effective 
approach, but it has its limits as well. The one that bothers me most is that there's 
no simple way to create controls that expand on TextBox or ListBox controls and 
correctly expose all of their original properties. Such controls have a few 
properties&#8212;for example, <I>MultiLine</I>, 
<I>ScrollBars</I>, and <I>Sorted</I>&#8212;which are read-only at run time. 
But when you place an ActiveX control on a form at design time, the ActiveX control 
is already running, so you can't modify those particular properties in the 
Properties window of the application that's using the control.
</p>

<p>You can use a few tricks to work around this problem, but none of them 
offers a definitive solution. For example, sometimes you can simulate the missing 
property with code, such as when you want to simulate a ListBox's 
<I>Sorted </I>property. Another well-known trick relies on an array of constituent controls. For example, you 
can implement the <I>MultiLine </I>property by preparing both a single-line and 
multiline TextBox controls and make visible only the one that matches the current 
property setting. The problem with this approach is that the number of needed controls 
grows exponentially when you need to implement two or more properties in this way. 
You need 5 TextBox controls to implement the <I>MultiLine 
</I>and <I>ScrollBars </I>properties (one for single-line TextBox controls and 4 for all the possible settings of the 
<I>ScrollBar </I>property), and 10 TextBoxes if you also want to implement the 
<I>HideSelection </I>property.
</p>

<p>A third possible solution is to simulate the control that you want to 
implement with simpler controls. For example, you can manufacture a ListBox-like 
ActiveX control based on a PictureBox and a companion VScrollBar. You simulate the 
ListBox with graphic methods of the PictureBox, so you're free to change its graphic 
style, add a horizontal scroll bar, and so on. Needless to say, this solution isn't often simple.
</p>

<p>I want merely to hint of a fourth solution, undoubtedly the most complex 
of the lot. Instead of using a Visual Basic control, you create a control from thin air 
using the <I>CreateWindowEx </I>API function. This is the C way, and following this 
approach in Visual Basic is probably even more complicated than working in C because 
the Visual Basic language doesn't offer facilities, such as pointers, that are helpful 
when you're working at such a low level.
</p>

<p>
<img src="images/new.jpg" width=102 height=87 border="0">
</p>

<p>After hearing all these complaints, you'll be happy to know Visual Basic 6 
has elegantly solved the problem. In fact, the new Windowless control library 
(described in <a href="ch09a.htm">Chapter 9</a>) doesn't expose a single property that's read-only at run time. The 
only drawback of this approach is that in that library controls don't expose an 
<I>hWnd </I>property, so you can't augment their functionality using API calls, which I describe in 
the <a href="chaaa.htm">Appendix</a>.
</p>

<A NAME="850"><h2>Container Controls</h2></A>
<p>You can create ActiveX controls that behave like container controls, as 
PictureBox and Frame controls do. To manufacture a container control, all you have to do is 
set the UserControl's <I>ControlContainer </I>property to True. Keep in mind, however, 
that not all host environments support this feature. If the container doesn't support 
the <I>ISimpleFrame</I> interface, your ActiveX control won't be able to contain other 
controls, even if it works normally as far as other features are concerned. Visual Basic's 
forms support this interface, as do PictureBox and Frame controls. In other words, you 
can place an ActiveX control that works as a container inside a PictureBox or 
Frame control, and it will work without a glitch.
</p>

<p>You can place controls on a container control both at design time (using 
drag-and-drop from the ToolBox) or at run time (through the 
<I>Container </I>property). In both cases, the ActiveX control can find out which controls are placed on its surface 
by querying its <I>ContainedControls </I>property. This property returns a collection that 
holds references to the Extender interface of the contained controls.
</p>

<p>On the companion CD, you'll find a simple container ActiveX control 
named Stretcher, which automatically resizes all the contained controls when it's resized. 
The code that implements this capability is unbelievably simple:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' These properties hold the previous size of the control.
Private oldScaleWidth As Single
Private oldScaleHeight As Single

' To initialize the variables, you need to trap both these events.
Private Sub UserControl_InitProperties()
    oldScaleWidth = ScaleWidth
    oldScaleHeight = ScaleHeight
End Sub

Private Sub UserControl_ReadProperties(PropBag As PropertyBag)
    oldScaleWidth = ScaleWidth
    oldScaleHeight = ScaleHeight
End Sub

Private Sub UserControl_Resize()
    ' When the UserControl resizes, move and resize all container controls.
    Dim xFactor As Single, yFactor As Single
    ' Exit if this is the first resize.
    If oldScaleWidth = 0 Then Exit Sub
    ' This accounts for controls that can't be resized.
    On Error Resume Next
    ' Determine the zoom or factor along both axis.
    xFactor = ScaleWidth / oldScaleWidth
    yFactor = ScaleHeight / oldScaleHeight
    oldScaleWidth = ScaleWidth
    oldScaleHeight = ScaleHeight
    
    ' Resize all controls accordingly.
    Dim ctrl As Object
    For Each ctrl In ContainedControls
        ctrl.Move ctrl.Left * xFactor, ctrl.Top * yFactor, _
            ctrl.Width * xFactor, ctrl.Height * yFactor
    Next
End Sub
</pre>
</td></tr>
</table>
</p>

<p>The ContainedControls collection includes only the contained controls that 
had been placed directly on the UserControl's surface. For example, if the ActiveX 
control contains a PictureBox, which in turn contains a TextBox, the PictureBox appears 
in the ContainedControls collection but the TextBox doesn't. Using Figure 17-8 as 
a reference, this means that the preceding code stretches or shrinks the Frame1 
control contained in the Stretcher ActiveX control, but not the two OptionButton 
controls inside it. To have the resizing code work as well for the innermost controls, you 
need to modify the code in the <I>UserControl_Resize 
</I>event procedure as follows (added statements are in boldface):
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Dim ctrl As Object<B>, ctrl2 As Object</B>
    For Each ctrl In ContainedControls
        ctrl.Move ctrl.Left * xFactor, ctrl.Top * yFactor, _
            ctrl.Width * xFactor, ctrl.Height * yFactor
<B>        For Each ctrl2 In Parent.Controls
            ' Look for controls on the form that are contained in Ctrl.
            If ctrl2.Container Is ctrl Then
                ctrl2.Move ctrl2.Left * xFactor, ctrl2.Top * yFactor,_
                    ctrl2.Width * xFactor, ctrl2.Height * yFactor
            End If
        Next</B>
    Next
</pre>
</td></tr>
</table>
</p>


<p>
<A HREF="javascript:fullSize('F17ph08x.htm')"> <img src="images/F17ph08.JPG" width=404 height=232 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 17-8.</B> <i>The Stretcher ActiveX control resizes all its contained controls, both at design time and at run time.</i><!--/caption-->
</p>

<p>You should know a few other bits of information about container ActiveX 
controls authored in Visual Basic:
</p>

<UL>
<p><li> If the host application doesn't support container controls, any 
reference to the <I>ContainedControls </I>property raises an error. It's OK to return 
errors to the client, except from within event procedures&#8212;such as 
<I>InitProperties </I>or <I>Show&#8212;</I>because they would crash the application.
</li></p>
<p><li> The ContainedControls collection is distinct from the Controls 
collection, which gathers all the constituent controls on the UserControl. If a 
container ActiveX control contains constituent controls, they'll appear on the 
background, below all the controls that the developer put on the 
UserControl's surface at design time.
</li></p>
<p><li> Don't use a transparent background with container controls because 
this setting makes contained controls invisible. (More precisely, 
contained controls will be visible only on the areas where they overlap a 
constituent control.)
</li></p>
</UL>

<p>A problem with container controls is that the UserControl module doesn't 
receive any events when a control is added or removed at design time. If you need 
to react to these actions&#8212;for example, to automatically resize the contained 
control&#8212;you must use a Timer control that periodically queries the 
ContainedControls.Count<I> </I>collection. While this approach isn't elegant or efficient, you 
usually need to activate the Timer only at design time, and therefore you experience no impact on 
the run-time performance.
</p>

<A NAME="851"><h2>Transparent Controls</h2></A>
<p>Visual Basic offers you many ways to create irregularly shaped controls. To begin 
with, if you set the <I>BackStyle </I>property of the UserControl object to 0-Transparent, 
the background of the control&#8212;that is, the portion of the control that isn't occupied 
by constituent controls&#8212;becomes transparent and lets the user see what's behind 
the control itself. When a control has a transparent background, all the mouse events 
go directly to the container form or to the control that happens to be under the 
ActiveX control in the z-order. In addition, Visual Basic ignores the 
<I>BackColor </I>and <I>Picture </I>properties for such an ActiveX control and all the output from graphic methods 
is invisible. Not surprisingly, transparent controls are also more demanding in terms 
of CPU time because, while repainting, Visual Basic has to clip all the areas that 
don't belong to the controls.
</p>

<A NAME="852"><h3>Using Label and Shape controls</h3></A>
<p>If your transparent control includes one or more Label controls that use a 
TrueType font and whose <I>BackStyle </I>property is also set to 0-Transparent, Visual Basic clips 
all the pixels around the characters in the Label. Only the caption of the Label is 
considered to belong to the ActiveX control, and all the other pixels in the Label 
are transparent. For example, if you click inside a letter 
O<I> </I>in the caption, a <I>Click </I>event is raised in the parent form or in the control that shows through. I noticed that 
this feature works decently only with larger font sizes, however.
</p>

<p>You can create a large variety of nonrectangular controls using Shape 
controls as constituent controls. (You can see one example on the companion CD.) If you 
set the Shape control's <I>BackStyle </I>property to 0-Transparent, all the pixels that fall 
outside the Shape control are transparent. For example, to create an elliptical radio 
button, you drop a Shape1 constituent control, set its 
<I>Shape </I>property to 2-Oval, and set both the UserControl's and Shape control's 
<I>BackStyle </I>property to 0-Transparent. Then 
you need only some code that resizes the Shape control when the UserControl 
resizes and that refreshes the control's appearance when the 
<I>Value </I>property changes. Following is a partial listing for the UserControl code module.
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' Change the color when the control is clicked.
Private Sub UserControl_Click()
    Value = True
    RaiseEvent Click
End Sub

Private Sub UserControl_Resize()
    Shape1.Move 0, 0, ScaleWidth, ScaleHeight
End Sub

Public Sub Refresh()
    ' TrueColor and FalseColor are Public properties. 
    Shape1.BackColor = IIf(m_Value, TrueColor, FalseColor)
    Shape1.FillColor = Shape1.BackColor
End Sub

' Value is also the default property.
Public Property Get Value() As OLE_OPTEXCLUSIVE
    Value = m_Value
End Property
Public Property Let Value(ByVal New_Value As OLE_OPTEXCLUSIVE)
    m_Value = New_Value
    Refresh
    PropertyChanged &quot;Value&quot;
End Property
</pre>
</td></tr>
</table>
</p>

<p>The problem with using Shape controls to define irregularly shaped controls 
is that you can't easily use graphic methods to draw over them. The reason is that 
Visual Basic redraws the Shape control after raising the 
<I>Paint </I>event, so the Shape control covers the graphic you've produced in the 
<I>Paint </I>event. An easy way to work around this limitation is to activate a Timer in the 
<I>Paint </I>event and let the drawing occur in the Timer's 
<I>Timer </I>procedure, some milliseconds after the standard 
<I>Paint </I>event. Use this code as a guideline:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub UserControl_Paint()
    Timer1.Interval = 1        ' One millisecond is enough.
    Timer1.Enabled = True
End Sub

Private Sub Timer1_Timer()
    Timer1.Enabled = False     ' Fire just once.
    ' Draw some lines, just to show that it's possible.
    Dim i As Long
    For i = 0 To ScaleWidth Step 4
        Line (i, 0)-(i, ScaleHeight)
    Next
End Sub
</pre>
</td></tr>
</table>
</p>

<p>As far as I know, the only other way to solve this problem is by subclassing 
the UserControl to run some code after the standard processing of the 
<I>Paint </I>event. (Subclassing techniques are described in the <a href="chaaa.htm">Appendix</a>.)
</p>

<A NAME="853"><h3>Using the <I>MaskPicture</I> and <I>MaskColor</I> properties</h3></A>

<p>If the shape of your transparent control is too irregular to be rendered with one 
Shape control (or even with a group of Shape controls), your next best choice is to 
assign a bitmap to the <I>MaskPicture </I>property and then to assign the color that should 
be considered as transparent to the <I>MaskColor 
</I>property. The bitmap is used as a mask, and for each pixel in the bitmap whose color matches 
<I>MaskColor</I>, the corresponding pixel on the UserControl becomes transparent. (Constituent controls are 
never transparent, even if they fall outside the mask region.) You also need to set 
the <I>Backstyle </I>property to 0-Transparent for this technique to work correctly.
</p>

<p>Using this process, you can create ActiveX controls of any shape, including 
ones that have holes in them. Probably the only serious limitation of this approach is 
that you can't easily create a mask bitmap that resizes with the control because you 
can assign the <I>MaskPicture</I> property a bitmap, GIF, or JPEG image, but not a metafile.
</p>

<A NAME="854"><h2>Lightweight Controls</h2></A>
<p>
<img src="images/new.jpg" width=102 height=87 border="0">
</p>

<p>Visual Basic 6 permits you to write lightweight ActiveX controls that consume 
fewer resources at run time and therefore load and unload faster. The UserControl 
object exposes two new properties that let you fine-tune this capability.
</p>

<A NAME="855"><h3>The <I>HasDC</I> and <I>Windowless</I> properties</h3></A>

<p>The <I>HasDC </I>property determines whether the UserControl creates a 
permanent Windows device context or uses a temporary device context when the control is 
redrawn and during event procedures. Setting this property to 
<I>False </I>can improve performance on systems with less memory. For more information about this 
property, see the &quot;<A HREF="ch02e.htm#48">Fine-Tuning the Performance of Forms</A>&quot; section in Chapter 2.
</p>

<p>Setting the <I>Windowless </I>property to True creates an ActiveX control that 
doesn't actually create a window and therefore consumes even fewer resources. A 
windowless control has a couple of limitations, however. It must be user-drawn or 
contain only other windowless controls, and it can't work as a container for other 
controls. You can't place regular constituent controls on a windowless ActiveX control, 
and you can't set the <I>Windowless </I>property to True if the UserControl already includes 
nonwindowless constituent controls. Image, Label, Shape, Line, and Timer are the 
only intrinsic controls that you can place over a windowless UserControl. If you need 
features that these controls don't provide, have a look at the Windowless control 
library mentioned in the &quot;<A HREF="ch17d.htm#849">Limitations and Workarounds</A>&quot; section earlier in this chapter.
</p>

<p>Not all containers support windowless controls. Among the environments 
that do are Visual Basic 5 and 6, Internet Explorer 4 or later, and all the environments 
based on Visual Basic for Applications. 
Interestingly, when a windowless control runs in an environment that doesn't support this feature, the windowless control 
automatically turns into a regular control that's backed up by a real window.
</p>

<p>A windowless control doesn't expose an <I>hWnd 
</I>property, so you can't call API functions to augment its functionality. (In some cases, you can use the 
<I>ContainerHwnd </I>property instead.) Moreover, the 
<I>EditAtDesign </I>and <I>BorderStyle </I>properties are 
disabled for windowless ActiveX controls. The <I>HasDC 
</I>property is usually ignored as well because windowless controls never have a permanent device context. But you 
should set this property to False because if the control runs in an environment that 
doesn't support windowless ActiveX controls, it won't, at least, use resources for a 
permanent device context.
</p>

<A NAME="856"><h3>Transparent windowless controls</h3></A>

<p>You can create a windowless control that has a transparent background by 
setting its <I>BackStyle </I>property to 0-Transparent and assigning a suitable bitmap to 
the <I>MaskPicture</I>. But you should also consider the new 
<I>HitTest </I>event and the <I>HitBehavior </I>and 
<I>ClipBehavior </I>properties.
</p>

<p>Before I show you how to use these new members, you need to understand 
what the four regions associated with a control are. (See Figure 
17-9.) The <I>Mask </I>region is the nontransparent portion of a control, which includes all the 
constituent controls and other areas that contain the output from graphic methods. 
(In regular controls, this is the only existing region.) The 
<I>Outside </I>region is the area outside the Mask region, while the 
<I>Transparent </I>region is any area inside the Mask 
region that doesn't belong to the control (the holes in the control). Finally, the 
<I>Close </I>region is an area that encircles the 
Mask region and whose width is determined by the 
author of the ActiveX control.
</p>

<p>
<A HREF="javascript:fullSize('f17ph09x.htm')"> <img src="images/f17ph09.JPG" width=404 height=140 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 17-9.</B> <i>The four regions associated with a transparent control.</i><!--/caption-->
</p>

<p>The problem with managing mouse actions over a transparent control is 
that Visual Basic doesn't know anything about the Close and Transparent regions, and 
it can only determine whether the mouse cursor is on the Mask region or in the 
Outside region. The problem is even worse when there are multiple overlapping 
controls, each one with its own Close or Transparent region, because Visual Basic 
has to decide which one will receive the mouse event. To let the control decide 
whether it wants to manage the mouse action, Visual Basic fires one or more 
<I>HitTest </I>events in all the controls that are under the mouse cursor, in their z-order. (That is, it 
fires the first event in the control that's on top of all others.) The 
<I>HitTest</I> event receives the <I>x </I>and <I>y 
</I>coordinates of the mouse cursor and a <I>HitTest 
</I>argument:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Sub UserControl_HitTest(X As Single, Y As Single, HitResult As Integer)
    ' Here you manage the mouse activity for the ActiveX control.
End Sub
</pre>
</td></tr>
</table>
</p>

<p>The possible values for <I>HitResult </I>are 0-vbHitResultOutside, 
1-vbHitResultTransparent, 2-vbHitResultClose, and 3-vbHitResultHit. Visual Basic raises the 
<I>HitTest </I>event multiple times, according to the following schema:
</p>


<UL>
<p><li> A first pass is made through the controls from the topmost to the 
bottommost control in the z-order; if any control returns 
<I>HitResult </I>= 3, it receives the mouse event and no more 
<I>HitTest </I>events are raised.
</li></p>
<p><li> If no control returns <I>HitResult </I>= 3, a second pass is performed; if 
any control returns <I>HitResult </I>= 2, it receives the mouse event and no 
more <I>HitTest </I>events are raised.
</li></p>
<p><li> If no control returns <I>HitResult</I> = 2, one more pass is performed; if 
any control returns <I>HitResult </I>= 1, it receives the mouse event.
</li></p>
<p><li> Otherwise, the parent form or the container control receives the 
mouse event.
</li></p>
</UL>

<p>Since Visual Basic knows only about the Mask and Outside regions, the 
value of <I>HitResult </I>that it passes to the 
<I>HitTest </I>event can only be 0 or 3. If you want to 
notify Visual Basic that your control has a Close or Transparent region, you must do so 
by code. In practice, you test the <I>x </I>and 
<I>y </I>coordinates and assign a suitable value 
to <I>HitResult</I>, as shown in the following code:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' A control with a circular transparent hole in it.
Sub UserControl_HitTest(X As Single, Y As Single, HitResult As Integer)
    Const HOLE_RADIUS = 200, CLOSEREGION_WIDTH = 10
    Const HOLE_X = 500, HOLE_Y = 400
    Dim distance As Single
    distance = Sqr((X _ HOLE_X) ^ 2 + (Y _ HOLE_Y) ^ 2)
    If distance &lt; HOLE_RADIUS Then
        ' The mouse is over the transparent hole.
        If distance &gt; HOLE_RADIUS _ CLOSEREGION_WIDTH Then
            HitResult = vbHitResultClose
        Else
            HitResult = vbHitResultTransparent
        End If
    Else
        ' Otherwise use the value passed to the event (0 or 3).
    End If
End Sub
</pre>
</td></tr>
</table>
</p>

<p>Not surprisingly, all these operations can add considerable overhead and 
slow down the application. Moreover, Visual Basic needs to clip the output accounting 
for the mask defined by <I>MaskPicture </I>for constituent controls and the output of 
graphic methods. To keep this overhead to a minimum, you can modify Visual Basic's 
default behavior by means of the <I>ClipBehavior 
</I>and <I>HitBehavior </I>properties.
</p>

<p>The<I> ClipBehavior</I> property affects how Visual Basic clips the output of 
graphic methods. The default value is 1-UseRegion, which means that the output of a 
graphic method is clipped to fit the Mask region. The value 0-None doesn't perform 
clipping at all, and graphic output is visible also on the Mask and Transparent regions.
</p>

<p>The <I>HitBehavior </I>property determines how the 
<I>HitResult </I>argument is evaluated before calling the 
<I>HitTest </I>event. When <I>HitBehavior </I>= 1-UseRegion (the default 
value), Visual Basic sets <I>HitResult </I>= 3 only for points inside the Mask region. If you 
set <I>HitBehavior </I>= 2-UsePaint, Visual Basic also considers the points produced by 
graphic methods in the <I>Paint </I>event. Finally, if 
<I>HitBehavior </I>= 0-None, Visual Basic doesn't 
even attempt to evaluate <I>HitResult </I>and always passes a 0 value to the 
<I>HitTest </I>event.
</p>

<p>If your Mask region isn't complex and you can easily describe it in code, 
you can often improve the performance of your ActiveX control by setting 
<I>HitBehavior </I>= 0-UseNone. In this case, Visual Basic always passes 0 to the 
<I>HitResult </I>argument, and you change it to account for your Mask, Close, and Transparent regions. If 
the Mask region is complex and includes irregular figures, you should set 
<I>ClipBehavior </I>= 0-None, thus saving Visual Basic the overhead needed to distinguish between 
the Mask and Outside regions.
</p>

<p>You can easily create controls with hot spots using 
<I>ClipBehavior </I>= 0-None and <I>HitBehavior 
</I>= 1-UseRegion. In practice, you draw your control over its entire 
client area and use the <I>MaskPicture </I>property to define the areas that react to the mouse.
</p>

<A NAME="857"><h2>Data Binding</h2></A>

<p>You can add data-binding capabilities to an ActiveX control with little more than 
a few mouse clicks. As is not the case for intrinsic controls, you can create controls 
that bind multiple properties to database fields. All you have to do is tick the Property 
Is Data Bound check box in the Data Binding section of the Procedure Attributes 
dialog box, shown in Figure 17-10, for all the properties that you want to make data aware.
</p>

<p>You can create as many data-bound properties as you like, but you must 
select the This Property Binds To DataField option for one of them only. If no 
property is bound to the <I>DataField </I>property, the Extender object won't expose all 
the <I>Data</I>xxxx properties that are necessary to actually bind the control. Because such 
properties are exposed by the Extender object, their availability depends on the host environment.
</p>

<p>
<img src="images/F17ph10.GIF" width=338 height=404 border=0>
<p>
<!--caption--><B>Figure 17-10.</B> <i>The Procedure Attributes dialog box includes all the options for creating data-aware properties.</i><!--/caption-->


<A NAME="858"><H3><I>PropertyChanged</I> and <I>CanPropertyChange</I> methods</H3></A>
<p>To support data binding in code, you don't have to do anything more than you 
already do for persistent properties. In each <I>Property Let 
</I>procedure, you must call the <I>PropertyChanged 
</I>method, which informs Visual Basic that the property has 
changed and that the database field should be updated before the record pointer moves 
to another record. If you omit this call, the database field won't be updated. You 
can also update the field immediately if you select the Update Immediate option in 
the Procedure Attributes dialog box.
</p>

<p>Visual Basic also provides the <I>CanPropertyChange 
</I>method, which queries the data source to determine whether it's safe to update the field. You could use 
the following code in the <I>Property Let </I>procedure of a property called 
<I>CustomerName. </I>(The statements that have been added to the code by the wizard are in boldface.)
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Public Property Let CustomerName(New_CustomerName As String)
<B>    If CanPropertyChange(&quot;CustomerName&quot;) Then    </B>
        txtCustomerName.Text = New_CustomerName
        PropertyChanged &quot;CustomerName&quot;
<B>    End If</B>
End Sub
</pre>
</td></tr>
</table>
</p>

<p>You should be aware, however, that you don't strictly need to call 
the <I>CanPropertyChange </I>method because under Visual Basic 5 and 6 it always 
returns True, even if the database field can't be updated. You should use this function 
only for compatibility with future versions of the language that might implement it. 
For all the properties that call this method before doing the update, you should also 
select the Property Will Call 
<I>CanPropertyChange</I> Before Changing option in the 
Procedure Attributes dialog box. Again, at this time there's no point in doing that, but it 
doesn't cause any harm either. The choice is yours.
</p>

<p>To correctly support data binding, the constituent controls must update 
the corresponding bound property when their contents change. Typically this is done 
in the <I>Change </I>or <I>Click </I>event procedure, as in the following code snippet:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub txtCustomerName_Change()
    PropertyChanged &quot;CustomerName&quot;
End Sub
</pre>
</td></tr>
</table>
</p>

<A NAME="859"><h3>The DataBindings collection</h3></A>

<p>As I mentioned before, only one property can be bound to the 
<I>DataField </I>Extender property. Because you can bind multiple properties, you need to provide 
developers with a method for associating each bound property to the corresponding 
database field. This association can be done either at design time or during execution.
</p>

<p>For each property that you want to make bindable at design time, you 
must select the Show In DataBindings Collection At Design Time option in the 
Procedure Attributes dialog box. If this option is selected for one or more properties, 
the <I>DataBindings </I>item appears in the Properties window. When you click on it, 
Visual Basic brings up the dialog box shown in Figure 17-11. 
Note that it's OK that the property bound to the 
<I>DataField </I>property also appears in the 
DataBindings<I> </I>collection.
</p>

<p>
<img src="images/new.jpg" width=102 height=87 border="0">
</p>

<p>Visual Basic 6 permits you to bind properties in the 
DataBindings<I> </I>collection to fields in different Data Sources, and you can also select a distinct 
<I>DataFormat</I> for each one of them. In Visual Basic 5, you could bind properties only to the same Data Source.
</p>

<p>
<img src="images/F17ph11.GIF" width=401 height=405 border="0">
<p>
<!--caption--><B>Figure 17-11.</B> <i>The DataBindings dialog box lets developers associate properties with database fields at design time.</i><!--/caption-->


<p>All the bound properties appear in the 
DataBindings<I> </I>collection at run time, regardless of whether they appear in the collection at design time. You can't add 
new items to this collection through code, but you can change the database field to 
which a property is bound:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' Bind the CustomerName property to the CompanyName database field.
Customer1.DataBindings(&quot;CustomerName&quot;).DataField = &quot;CompanyName&quot;
</pre>
</td></tr>
</table>
</p>
<p>Another common task for the DataBindings collection is to cancel changes 
in fields so that the database record won't be updated:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Dim dtb As DataBinding
For Each dtb In Customer1.DataBindings
    dtb.DataChanged = False
Next
</pre>
</td></tr>
</table>
</p>


<p>For more information about the DataBindings<I> 
</I>collection, see the online Visual Basic documentation.
</p>

<A NAME="860"><h3>The DataRepeater control</h3></A>

<p>
<img src="images/new.jpg" width=102 height=87 border="0">
</p>

<p>Visual Basic 6 lets you create custom grid-like controls, using the DataRepeater 
control (contained in the Msdatrep.ocx file). This control works as a container of 
other ActiveX controls: It can host any type of controls, but it's especially useful with 
custom ActiveX controls.
</p>

<p>Say that you want to display a table of records, but you don't want to use 
a standard Visual Basic grid control&#8212;such as the DataGrid or Hierarchical 
FlexGrid control&#8212;because you need maximum flexibility for interaction with the user 
or because you want to display information that can't be embedded in a regular 
grid (images, for example). Figure 17-12 shows a custom grid built on the DataRepeater control that displays the Publisher table from the Biblio.mdb database. To create 
such a custom grid, you must execute these basic steps:
</p>


<OL>
<p><li> Create an AddressOCX control that contains all the fields you need; 
this is the object that will be replicated in the DataRepeater control.
</li></p>
<p><li> For all the properties that you want to expose in the DataRepeater 
control&#8212;that is, Name, Street, City, Zip, and State&#8212;make the property 
data bound and have it appear in the DataBindings collection at design time.
</li></p>
<p><li> Save the project, compile it into a stand-alone OCX file, and load the 
client application where you want to display the custom grid.
</li></p>
<p><li> Drop an ADO Data control on the client form, and then set 
its <I>ConnectionString</I> and <I>RecordSource 
</I>properties to point to the table in the database that provides the data. (You can also use any other ADO 
data source, including a DataEnvironment object.)
</li></p>
<p><li> Drop a DataRepeater control on the form, have its 
<I>DataSource</I> property pointing to the ADO Data control, and select the AddressOCX 
ActiveX control from the list that appears when you click on the 
<I>RepeatedControlName.</I> (This list includes all the OCXs that are registered in 
your system.)
</li></p>
<p><li> Bring up the DataRepeater control's custom property page, switch to 
the RepeaterBindings tab, and associate the bound properties exposed by 
the inner ActiveX control with the database fields. You can also set in 
the Format tab the <I>DataFormat </I>property for each field.
</li></p>
</OL>
<p>
<A HREF="javascript:fullSize('F17ph12x.htm')"> <img src="images/F17ph12.JPG" width=404 height=402 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 17-12.</B> <i>The DataRepeater control lets you create custom views of your database tables.</i><!--/caption-->
</p>

<p>The complete source code of the demonstration program is on the companion CD.
</p>

<p>The DataRepeater control has some rough edges, and you must pay 
attention to many details to have it working properly:
</p>

<UL>

<p><li> The UserControl must be compiled into an OCX file; otherwise, it 
can't be hosted in the DataRepeater control. You can't use an intrinsic 
Visual Basic control with a DataRepeater.
</li></p>
<p><li> All the bound properties in the inner ActiveX control should return 
String values; you can then format these values using the DataFormat 
options offered by the DataRepeater control. Moreover, all the properties must 
be visible in the DataBindings collection at design time; otherwise, 
the DataRepeater control won't see them.
</li></p>
<p><li> The constituent controls on the child form should call the 
<I>PropertyChanged </I>method whenever the user changes their values; otherwise, the 
database won't be updated correctly.
</li></p>
<p><li> The DataRepeater control creates only one instance of the control; 
this control is used to let the user edit values for the current record, 
whereas all other rows are just images of the control. You might notice some 
incorrect repaints every now and then.
</li></p>
</UL>

<p>The DataRepeater control exposes several properties, methods, and events 
that augment its potential and flexibility. For example, you can directly access the 
active instance of the child control to set additional properties 
(<I>RepeatedControl </I>property), find the line number of the current record 
(<I>ActiveRow </I>property), change the DataRepeater's appearance (by assigning the 
<I>Caption</I>, <I>CaptionStyle</I>, 
<I>ScrollBars</I>, <I>RowIndicator</I>, and <I>RowDividerStyle 
</I>properties), get or set a bookmark to the 
current or the visible records (using the <I>CurrentRecord 
</I>and <I>VisibleRecords </I>properties), and so on. You can also monitor users' actions&#8212;for example, when they scroll 
the contents of the list (<I>ActiveRowChanged </I>and 
<I>VisibleRecordsChanged </I>events) or select another row 
(<I>CurrentRecordChanged </I>event).
</p>

<p>Interestingly, it's even possible to load a different child ActiveX control at 
run time by assigning a new value to the <I>RepeatedControlName 
</I>property. In this case, you must associate the bound property with fields by using the properties of 
the <I>RepeaterBindings </I>collection. (You can provide the user with a list of bindable 
properties using the <I>PropertyNames </I>property.) Whenever a new child control is 
loaded at run time, the DataRepeater fires a 
<I>RepeatedControlLoaded</I> event, which the programmer can use to correctly initialize the new control.
</p>

<A NAME="861"><h3>What's missing</h3></A>

<p>The data binding mechanism offered by Visual Basic is fairly complete, although 
a few features aren't directly supported and you have to implement them yourself.
</p>

<p>For example, there's no direct support for controls that bind a 
<I>list </I>of values to a secondary Data source, as the DataList and DataCombo controls do. You can 
implement this feature by exposing a custom property&#8212;such as 
<I>RowSource&#8212;</I>to which developers can assign the secondary Data control (or another ADO-compliant 
data source). Here the problem to solve is: You can't display a custom list in the 
Properties window, so how do you let the developer select the data source at design 
time? The answer is based on custom property pages, which are described in the 
next section.
</p>

<p>One thing that at first seems to be impossible is to decide at run time 
which property binds to the DataField Extender property. In this situation, the solution 
is actually simpler than it might appear: Create an additional property that binds 
to DataField and that delegates to one of the other properties exposed by the 
control. This mechanism can be made extremely flexible by means of the new 
<I>CallByName </I>function. For example, let's say that you want to give developers the ability to 
bind any property among those exposed by the Customer control. You need to create 
two additional properties: <I>BoundPropertyName, 
</I>which holds the name of the bound property, and 
<I>BoundValue,</I> which does the actual delegation. This is the code in 
the <I>Property Get </I>and <I>Let </I>procedures for the latter property:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' BoundValue binds directly to DataField, but the value actually stored
' in the database depends on the BoundPropertyName property.
Public Property Get BoundValue() As Variant
    BoundValue = CallByName(Me, BoundPropertyName, vbGet)
End Property

Public Property Let BoundValue (New_BoundValue As Variant)
    CallByName Me, BoundPropertyName, vbLet, New_BoundValue
End Property
</pre>
</td></tr>
</table>
</p>

<p>You should make <I>BoundValue </I>hidden so that developers are discouraged 
from using it directly.
</p>

<A NAME="862"><h2>Property Pages</h2></A>

<p>The majority of ActiveX controls that you find in the Visual Basic package or buy 
from third-party vendors are equipped with one or more custom property pages. In 
this section, you'll see how easy it is to create property pages for your own 
ActiveX controls.
</p>

<p>Even if the Visual Basic's Properties window is usually sufficient to enter 
property values at design time, there are at least three reasons why you should create 
custom property pages. First, they greatly simplify the job of the programmers that are 
using your control because all properties can be grouped in a logical way. Second, and 
more important, property pages give you much greater influence over how properties 
are set at design time. For example, you can't show a combo box in the Properties 
window with a list of values built dynamically, nor can you let developers drop down 
a mini-editor to enter multiple values (as they do when editing the 
<I>List </I>property of ListBox and ComboBox controls). These restrictions are easily overcome with 
property pages. Third, property pages permit you to localize the design-time user 
interface of your controls for different languages.
</p>

<p>So that you can see property pages in action, I created a SuperListBox 
ActiveX control, an expanded ListBox that exposes an 
<I>AllItems </I>property (which returns all the items separated by a carriage return character) and allows you to enter new items 
at run time using a pop-up menu. My control also gives the programmer the ability 
to bind either the <I>Text </I>property or the <I>ListIndex 
</I>property to the DataField, thus overcoming one of the few limitations of the data binding mechanism in Visual Basic. 
This control employs a number of interesting programming techniques&#8212;such as API 
functions to implement a columnar format&#8212;and you might want to browse its source 
code on the companion CD.
</p>

<A NAME="863"><h3>Running the Property Page Wizard</h3></A>

<p>You can add a property page to an ActiveX Control project with the Add 
Property Page command from the Project menu, but you can save a lot of work and time 
using the Property Page Wizard. (You have to install this add-in from the Add-In 
Manager dialog box.) In the first step of the wizard, you can create custom property 
pages, select their order, and decide whether you want to keep standard property 
pages. (See Figure 17-13.) Visual Basic automatically adds the StandardColor, 
StandardFont, and StandardPicture pages (for properties that return OLE_COLOR, StdFont, 
and StdPicture values, respectively), but you can also decide to deactivate them if you want.
</p>

<p>
<A HREF="javascript:fullSize('F17ph13x.htm')"> <img src="images/F17ph13.JPG" width=404 height=303 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 17-13.</B> <i>The first step of the Property Page Wizard is the point at which you create new pages and change the order of selected pages.</i><!--/caption-->
</p>

<p>In the second step of the wizard, you decide on which page each custom 
property will be displayed. All the properties that you leave in the leftmost list box 
(as shown in Figure 17-14) won't be displayed on any property page.
</p>

<p>
<A HREF="javascript:fullSize('F17ph14x.htm')"> <img src="images/F17ph14.JPG" width=404 height=303 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 17-14.</B> <i>In the second step of the Property Page Wizard, you decide which properties will be shown on which page.</i><!--/caption-->
</p>

<p>When you click on the Finish button, the wizard creates one or 
more PropertyPage modules. For each property that you assigned to the page, the 
wizard generates a Label control (whose <I>Caption 
</I>is the name of the property) and a TextBox control that holds the value of the property, or a CheckBox control if the 
property returns a Boolean value. If you want a fancier user interface&#8212;for example, 
ComboBox controls for enumerated properties&#8212;you have to modify what the wizard has 
produced. Figure 17-15 shows the General property page for the SuperListBox 
control after I rearranged the controls and converted a couple of TextBox controls 
into ComboBox controls.
</p>

<p>
<A HREF="javascript:fullSize('F17ph15x.htm')"> <img src="images/F17ph15.JPG" width=404 height=267 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 17-15.</B> <i>The property page generated by the Property Page Wizard, after some retouching.</i><!--/caption-->
</p>

<A NAME="864"><h3>The PropertyPage object</h3></A>
<p>Just browsing the code produced by the wizard is sufficient to understand how 
property pages work. The PropertyPage object is similar to a form and supports many 
of the Form object's properties, methods, and events, including 
<I>Caption</I>, <I>Font</I>, and all the keyboard and mouse events. You might even implement property pages that 
work as drag-and-drop servers or clients if you need to.
</p>

<p>Property pages have their peculiarities, of course. For one, you can control 
the size of the page using the <I>StandardSize 
</I>property, which can be assigned one of the values 0-Custom (the size is determined by the object), 1-Small (101-by-375 
pixels), or 2-Large (179-by-375 pixels). Microsoft suggests that you create custom-sized 
pages that aren't larger than the space that you actually need because values other than 
0-Custom might display incorrectly at different screen resolutions.
</p>

<p>You might notice in Figure 17-15 that the property page doesn't include the 
OK, Cancel, and Apply buttons that you usually find on standard property pages. 
Those buttons, in fact, are provided by the environment, and you don't have to add 
them yourself. The communication between the property page and the environment 
occurs through properties and events of the PropertyPage object. If the project is 
associated with a help file, a Help button is also displayed.
</p>

<p>When the page loads, the PropertyPage object receives the 
<I>SelectionChanged </I>event. In this event, your code should load all the controls in the page with the 
current values of the corresponding properties. The SelectedControls collection returns 
a reference to all the controls in the form that are currently selected and that will 
be affected by the property page. For example, this is the code in the 
<I>SelectionChanged </I>event procedure for the General page of the SuperListBox control:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub PropertyPage_SelectionChanged()
    txtCaption.Text = SelectedControls(0).Caption
    txtAllItems.Text = SelectedControls(0).AllItems
    chkEnabled.Value = (SelectedControls(0).Enabled And vbChecked)
    cboShowPopupMenu.ListIndex = SelectedControls(0).ShowPopupMenu
    cboBoundPropertyName.Text = SelectedControls(0).BoundPropertyName
    Changed = False
End Sub
</pre>
</td></tr>
</table>
</p>

<p>When the contents of any field on the page is modified, the code in its 
<I>Change </I>or <I>Click </I>event should set the PropertyPage's 
<I>Changed </I>property to True, as in these examples:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub txtCaption_Change()
    Changed = True
End Sub

Private Sub cboShowPopupMenu_Click()
    Changed = True
End Sub
</pre>
</td></tr>
</table>
</p>

<p>Setting the <I>Change </I>property to True automatically enables the Apply 
button. When the user clicks on this button (or simply switches to another property 
page), the PropertyPage object receives an <I>ApplyChanges 
</I>event. In this event, you must assign the values on the property page to the corresponding ActiveX control's 
properties, as in the following example:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub PropertyPage_ApplyChanges()
    SelectedControls(0).Caption = txtCaption.Text
    SelectedControls(0).AllItems = txtAllItems.Text
    SelectedControls(0).Enabled = chkEnabled.Value
    SelectedControls(0).ShowPopupMenu = cboShowPopupMenu.ListIndex
    SelectedControls(0).BoundPropertyName = cboBoundPropertyName.Text
End Sub
</pre>
</td></tr>
</table>
</p>

<p>One more custom event is associated with PropertyPage 
objects&#8212;the <I>EditProperties </I>event. This event fires when the property page is displayed 
because the developer clicked on the ellipsis button beside a property name in the 
Properties window. (This button appears if the property has been associated with a 
specific property page in the Procedure Attributes dialog box.) You usually take 
advantage of this property to automatically move the focus on the corresponding control on 
the property page:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub PropertyPage_EditProperty(PropertyName As String)
    Select Case PropertyName
        Case &quot;Caption&quot;
            txtCaption.SetFocus
        Case &quot;AllItems&quot;
            txtAllItems.SetFocus
        ' etc. (other properties omitted...)
    End Select
End Sub
</pre>
</td></tr>
</table>
</p>

<p> You might also want to disable or hide all other controls on the page, but 
this is rarely necessary or useful.
</p>

<A NAME="865"><h3>Working with multiple selections</h3></A>

<p>The code produced by the Property Page Wizard accounts for only the simplest 
situation&#8212;that is, when only one ActiveX control is selected on the form. To build 
robust and versatile property pages, you should make them work also with 
multiple controls. Keep in mind that property pages aren't modal, and therefore the 
developer is allowed to select (or deselect) controls on the form even when the page is 
already visible. Each time a new control is added to or removed from the 
SelectedControls collection, a <I>SelectionChanged 
</I>event fires.
</p>

<p>The standard way to deal with multiple selections is as follows. If the 
selected controls on the form share the same value for a given property, you fill the 
corresponding field on the property page with that common value; otherwise, you 
leave the field blank. This is a modified version of the 
<I>SelectionChanged </I>that accounts for multiple selections:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub PropertyPage_SelectionChanged()
    Dim i As Integer
    ' Use the property of the first selected control.
    txtCaption.Text = SelectedControls(0).Caption
    ' If there are other controls, and their Caption property differs from
    ' the Caption of the first selected control, clear the field and exit.
    For i = 1 To SelectedControls.Count - 1
        If SelectedControls(i).Caption &lt;&gt; txtCaption.Text Then
            txtCaption.Text = &quot;&quot;
            Exit For
        End If
    Next

    ' The AllItems property is dealt with in the same way (omitted ...).
    
    ' The Enabled property uses a CheckBox control. If values differ, use
    ' the special vbGrayed setting. 
    chkEnabled.Value = (SelectedControls(0).Enabled And vbChecked)
    For i = 1 To SelectedControls.Count - 1
        If (SelectedControls(i).Enabled And vbChecked) &lt;&gt; chkEnabled.Value 
            Then
            chkEnabled.Value = vbGrayed
            Exit For
        End If
    Next

    ' The ShowPopupMenu enumerated property uses a ComboBox control.
    ' If values differ, set the ComboBox's ListIndex property to _1.
    cboShowPopupMenu.ListIndex = SelectedControls(0).ShowPopupMenu
    For i = 1 To SelectedControls.Count - 1
        If SelectedControls(i).ShowPopupMenu &lt;&gt; cboShowPopupMenu.ListIndex 
            Then
            cboShowPopupMenu.ListIndex = -1
            Exit For
        End If
    Next

    ' The BoundPropertyName property is dealt with similarly (omitted ...).

    Changed = False
    txtCaption.DataChanged = False
    txtAllItems.DataChanged = False
End Sub
</pre>
</td></tr>
</table>
</p>

<p>The <I>DataChange </I>properties of the two TextBox controls are set to False 
because in the <I>ApplyChange </I>event you must determine whether the developer entered a 
value in either of those fields:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub PropertyPage_ApplyChanges()
    Dim ctrl As Object
    ' Apply changes to Caption property only if the field was modified.
    If txtCaption.DataChanged Then
        For Each ctrl In SelectedControls
            ctrl.Caption = txtCaption.Text
        Next
    End If
    ' The AllItems property is deal with in the same way (omitted ...).
    
    ' Apply changes to the Enabled property only if the CheckBox control
    ' isn't grayed out.
    If chkEnabled.Value &lt;&gt; vbGrayed Then
        For Each ctrl In SelectedControls
            ctrl.Enabled = chkEnabled.Value
        Next
    End If

    ' Apply changes to the ShowPopupMenu property only if an item 
    ' in the ComboBox control is selected.
    If cboShowPopupMenu.ListIndex &lt;&gt; -1 Then
        For Each ctrl In SelectedControls
            ctrl.ShowPopupMenu = cboShowPopupMenu.ListIndex
        Next
    End If
    ' The BoundPropertyName property is dealt with similarly (omitted ...).
End Sub
</pre>
</td></tr>
</table>
</p>

<A NAME="866"><h3>Advanced techniques</h3></A>
<p>I want to mention a few techniques that you can use with property pages and 
that aren't immediately obvious. For example, you don't need to wait for the 
<I>ApplyChanges </I>event to modify a property in selected ActiveX controls: You can update a 
property right in the <I>Change </I>or <I>Click 
</I>event of the corresponding control on the property 
page. You can therefore achieve in the property page the same behavior that you 
can implement in the Properties window by assigning a property the Text or 
Caption procedure ID.
</p>

<p>Another easy-to-overlook feature is that the PropertyPage object can 
invoke Friend properties and methods of the UserControl module because they're in the 
same project. This gives you some additional flexibility: For example, the 
UserControl module can expose one of its constituent controls as a Friend 
<I>Property Get</I> procedure so that the Property Page can directly manipulate its attributes, as you can 
see in the code at below.
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' In the SuperListBox UserControl module
Friend Property Get Ctrl_List1() As ListBox
    Set Ctrl_List1 = List1
End Property
</pre>
</td></tr>
</table>
</p>

<p>A minor annoyance of this approach is that the PropertyPage code accesses 
the UserControl through the SelectedControls collection, which returns a generic 
Object, whereas Friend members can only be accessed through specific object variables. 
You can work around this issue by casting the elements of the collection to specific 
object variables:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' In the PropertyPage module
Dim ctrl As SuperListBox
' Cast the generic control to a specific SuperListBox variable.
Set ctrl = SelectedControls(0)
' Now it is possible to access Friend members.
ctrl.Ctrl_List1.AddItem &quot;New Item&quot;
</pre>
</td></tr>
</table>
</p>

<p>The last technique that I'm showing you is likely to be useful when 
you're developing complex UserControls with many properties and constituent controls, 
such as the Customer ActiveX control that I introduced earlier in this chapter. 
Surprisingly, it turns out that you can use the UserControl even on a property page that's 
associated with itself. Figure 17-16 shows an example of this technique: The General 
property page uses an instance of the Customer ActiveX control to let the developer 
assign the properties of the Customer control itself!
</p>

<p>
<A HREF="javascript:fullSize('F17ph16x.htm')"> <img src="images/F17ph16.JPG" width=404 height=233 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 17-16.</B> <i>A property page that uses an instance of the UserControl object defined in its own project.</i><!--/caption-->
</p>

<p>The beauty of this approach is how little code you need to write in 
the PropertyPage module. This is the complete source code of the property page 
shown in Figure 17-16:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Customer1_Change(PropertyName As String)
    Changed = True
End Sub

Private Sub PropertyPage_ApplyChanges()
    ' Read all properties in one loop.
    Dim propname As Variant
    For Each propname In Array(&quot;CustomerName&quot;, &quot;Address&quot;, &quot;City&quot;, _
        &quot;ZipCode&quot;, &quot;Country&quot;, &quot;Phone&quot;, &quot;Fax&quot;)
        CallByName SelectedControls(0), propname, VbLet, _
            CallByName(Customer1, propname, VbGet)
    Next
End Sub

Private Sub PropertyPage_SelectionChanged()
    ' Assign all properties in one loop.
    Dim propname As Variant
    For Each propname In Array(&quot;CustomerName&quot;, &quot;Address&quot;, &quot;City&quot;, _
        &quot;ZipCode&quot;, &quot;Country&quot;, &quot;Phone&quot;, &quot;Fax&quot;)
        CallByName Customer1, propname, VbLet, _
            CallByName(SelectedControls(0), propname, VbGet)
    Next
End Sub
</pre>
</td></tr>
</table>
</p>

<p>Notice how the code takes advantage of the <I>CallByName 
</I>function to streamline multiple assignments to and from the properties in the UserControl.
</p>

<A NAME="867"><h2>The Tricks of the Masters</h2></A>
<p>At this point, you know everything you need to create ActiveX controls that 
match or even exceed the quality of commercial controls. There are a few advanced 
techniques, however, that even many experienced programmers aren't aware of. As 
I'll prove in this section, you don't always need to know all the intricacies of 
Windows and ActiveX programming to deliver efficient controls because, in most cases, 
Visual Basic is all you need.
</p>

<A NAME="868"><h3>Callback methods </h3></A>

<p>Raising an event in the parent form from within an ActiveX control is easy, but it 
isn't the only method you can use to let the two objects communicate with each 
other. In <a href="ch16a.htm">Chapter 16</a>, I showed you how an object can notify another object that 
something has occurred by using callback methods. Callback methods have 
several advantages over events: They're about 5 or 6 times faster on average and, 
more important, they aren't blocked when the client form is showing a message box in 
an interpreted program.
</p>

<p>On the companion CD, you'll find the complete source code for 
the SuperTimer ActiveX control, which implements a Timer that can communicate with its 
parent form using a callback mechanism based on the 
<I>ISuperTimerCBK</I> interface (a PublicNotCreatable class contained in the ActiveX control project). When a form 
or any other container implements this interface, it can have the SuperTimer control 
send its notifications through that interface's only member, the 
<I>Timer </I>method. This is the source code for a typical form that uses this SuperTimer control:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Implements ISuperTimerCBK

Private Sub Form_Load()
    Set SuperTimer1.Owner = Me
End Sub

Private Sub ISuperTimerCBK_Timer()
    ' Do whatever you want here.
End Sub
</pre>
</td></tr>
</table>
</p>

<p>The SuperTimer control contains a Timer1 constituent control that raises a 
<I>Timer </I>event in the UserControl module; in this procedure, the control decides whether 
it has to raise an event or invoke a callback method:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Public Owner As ISuperTimerCBK

Private Sub Timer1_Timer()
    If Owner Is Nothing Then
        RaiseEvent Timer      ' Fire a regular event.
    Else
        Owner.Timer           ' Fire a callback method.
    End If
End Sub
</pre>
</td></tr>
</table>
</p>

<p>Interestingly, in an interpreted program the 
<I>Timer </I>event in a standard Timer control doesn't fire if the client form is showing a message box. (Timers are 
never blocked in compiled programs, though.) You don't suffer from this limitation if 
you use the ISuperTimerCBK interface of the SuperTimer OCX control, which 
therefore proves to be more powerful than a regular Timer control. (See Figure 17-17.) But 
you have to compile the SuperTimer control into an OCX file for this feature to 
work properly. (When the UserControl module runs in the Visual Basic IDE, modal 
windows in the client applications block events also in the ActiveX control.)
</p>

<p><div class="tip"><blockquote>
<b>TIP</b><hr>The demonstration program of the SuperTimer control displays 
different messages if the application is running in the IDE or as a compiled program. 
The Visual Basic language lacks a function that lets you distinguish between the 
two modes, but you can take advantage of the fact that all the methods of the 
Debug object aren't compiled in EXE programs and therefore are executed 
only when the application is running in the IDE. Here's an example of this technique:

<p>
<table><tr><td>
<pre>Function InterpretedMode() As Boolean
    On Error Resume Next
    Debug Print 1/0                 ' This causes an error
    InterpretedMode = (Err &lt;&gt; 0)    ' but only inside the IDE.
    Err Clear                       ' Clear the error code. 
End Function
</pre>
</td></tr>
</table>
</p>
<p>The preceding code is based on a routine that appeared in the Tech Tips 
supplement of the Visual Basic Programmer's Journal.
</p>
</blockquote></div>
</p>

<p>
<img src="images/F17ph17.GIF" width=403 height=236 border="0">
<p>
<!--caption--><B>Figure 17-17.</B> <i>A compiled SuperTimer control can send callback methods to the parent form even if a message box is being displayed.</i><!--/caption-->


<A NAME="869"><h3>Faster calls with VTable binding</h3></A>
<p>As you know, all references to external ActiveX controls&#8212;but not intrinsic Visual 
Basic controls&#8212;implicitly use their Extender objects. What you probably don't know is 
that all references to the Extender use early ID binding instead of the most efficient 
VTable binding. This means that calling a method in an ActiveX control is slower than 
calling the same method if the object were encapsulated in an ActiveX DLL 
component because objects in DLLs are referenced through VTable binding.
</p>

<p>In general, ID binding doesn't seriously impair the performance of your 
ActiveX control because most properties and methods implement the user interface and 
are sufficiently fast even on low-end machines. But sometimes you might need 
more speed. Say that you have a ListBox control that you want to fill as rapidly as 
possible with data read from a database or an array in memory: in this situation, you need 
to call a property or a method several thousand times, and the overhead of ID 
binding wouldn't be negligible.
</p>

<p>A solution to this problem is conceptually simple. You add a 
PublicNotCreatable class to your ActiveX Control project that exposes the same properties and 
methods as those exposed by the ActiveX control. The class does 
nothing but delegate the execution of the properties and methods to the main UserControl module. 
Whenever the ActiveX control is instantiated, it creates a companion Public object and 
exposes it as a read-only property. The client form can store the return value of this 
property in a specific object variable and call the ActiveX control's members through this 
secondary object. This object doesn't use the Extender object and therefore can be 
accessed through VTable binding instead of ID binding.
</p>

<p>I found that accessing UserControl's properties through this companion 
object can be about 15 times faster than through the regular reference to the ActiveX 
control. On the companion CD, you'll find a demonstration project whose only 
purpose is to show you what kind of performance you can get using this approach. You 
can use it as a model to implement this technique in your own ActiveX control projects.
</p>

<A NAME="870"><h3>Secondary interfaces</h3></A>
<p>An alternative way to use VTable binding for super-fast ActiveX controls is to 
have the ActiveX control implement a secondary interface and have the client form 
access the secondary interface instead of the primary interface. This approach is even 
faster than the one based on a secondary PublicNotCreatable object because you don't 
need a separate class that delegates to the main ActiveX control module. Another 
benefit of this approach is that the same interface can be shared by multiple ActiveX 
controls so that you can implement a VTable-based polymorphism among different but 
related ActiveX controls.
</p>

<p>The implementation of this approach isn't difficult, but beware of one 
difficulty. Say that you create an ActiveX control that contains an 
<I>Implements IControlInterface </I>statement at the beginning of its code module. Your goal is to take advantage of 
this common interface in the client form by assigning a specific ActiveX control 
instance to an interface variable. Unfortunately, the following sequence of statements 
raises an error:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' In the client form
Dim ctrl As IControlInterface
Set ctrl = MyControl1                      ' Error &quot;Type Mismatch&quot;
</pre>
</td></tr>
</table>
</p>

<p>The problem, of course, is that the MyControl1 object in the client code 
uses the ActiveX control's Extender interface, which doesn't inherit the 
IControlInterface interface. To access that interface, you need to bypass the Extender object, as follows:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Set ctrl = MyControl1.Object 
</pre>
</td></tr>
</table>
</p>

<A NAME="871"><h3>Trapping events with multicasting</h3></A>
<p>Multicasting lets you trap events raised by any object that you can reference 
through an object variable. (I described multicasting in <a href="ch07a.htm">Chapter 7</a>, so you might want to 
review those pages before reading what follows.) The good news is that 
multicasting also works with ActiveX controls, even if a control has been compiled into a 
stand-alone OCX file. In other words, your ActiveX control can trap events fired by 
the parent form, or even by other controls on the form itself.
</p>

<p>To give you a taste of what you can do with this technique, I have prepared 
a simple ActiveX control that automatically resizes itself to cover the entire surface 
of its parent form. If it weren't for multicasting, this feature would be extremely 
difficult to implement because it requires you to subclass the parent form to be 
notified when it's being resized. Thanks to multicasting, the amount of code you need 
to implement this feature is amazingly little:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Dim WithEvents ParentForm As Form

Private Sub UserControl_ReadProperties(PropBag As PropertyBag)
    On Error Resume Next         ' In case parent isn't a form.
    Set ParentForm = Parent
End Sub

' This event fires when the parent form resizes.
Private Sub ParentForm_Resize()
    Extender.Move 0, 0, Parent.ScaleWidth, Parent.ScaleHeight
End Sub
</pre>
</td></tr>
</table>
</p>

<p>The multicasting technique has an infinite number of applications. For 
example, you can build an ActiveX control that always displays the sum of the values 
contained in TextBox controls on the form. For this task, you need to trap those controls' 
<I>Change </I>events. When trapping the events of an intrinsic control, your UserControl 
module must declare a <I>WithEvents</I> variable of a specific object type, but when trapping 
events from external ActiveX controls&#8212;for example, a TreeView or MonthView 
control&#8212;you can use a generic VBControlExtender object variable and rely on its 
one-size-fits-all <I>ObjectEvent </I>event.
</p>

</BODY>
</HTML>




