<HTML>
<HEAD>
<TITLE>PictureBox and Image Controls</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch03e.htm", "ch03g.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="91"><h1>PictureBox and Image Controls</h1></A>

<p>Both PictureBox and Image controls let you display an image, so let's compare 
them and see when it makes sense to choose one or the other.</P>

<A NAME="92"><h2>The PictureBox Control</h2></A>

<p>PictureBox controls are among the most powerful and complex items in the Visual 
Basic Toolbox window. In a sense, these controls are more similar to forms than to 
other controls. For example, PictureBox controls support all the properties related to 
graphic output, including<I> AutoRedraw</I>,<I> 
ClipControls</I>,<I> HasDC</I>,<I> 
FontTransparent</I>, <I>CurrentX</I>,<I> 
CurrentY</I>, and all the <I>Draw</I>xxxx, 
<I>Fill</I>xxxx,<I> </I>and <I>Scale</I>xxxx<I> 
</I>properties. PictureBox controls also support all graphic methods, such as 
<I>Cls</I>, <I>PSet</I>, <I>Point</I>, <I>Line</I>, and 
<I>Circle</I> and conversion methods, such as 
<I>ScaleX</I>, <I>ScaleY</I>, <I>TextWidth</I>, and 
<I>TextHeight</I>. In other words, all the techniques that I described for forms can also be used for PictureBox 
controls (and therefore won't be covered again in this section).</P>

<A NAME="93"><h3>Loading images</h3></A>

<p>Once you place a PictureBox on a form, you might want to load an image in it, 
which you do by setting the <I>Picture</I> property in the Properties window. You can load 
images in many different graphic formats, including bitmaps (BMP), device 
independent bitmaps (DIB), metafiles (WMF), enhanced metafiles (EMF), GIF and 
JPEG compressed files, and icons (ICO and CUR). You can decide whether a control 
should display a border, resetting the 
<I>BorderStyle </I>to 0-None if necessary. Another 
property that comes handy in this phase is 
<I>AutoSize</I>: Set it to True and let the control 
automatically resize itself to fit the assigned image.</P>

<p>You might want to set the <I>Align </I>property of a PictureBox control to 
something other than the 0-None value. By doing that, you attach the control to one of the 
four form borders and have Visual Basic automatically move and resize the 
PictureBox control when the form is resized. PictureBox controls expose a 
<I>Resize </I>event, so you can trap it if you need to move and resize its child controls too.</P>
<P>You can do more interesting things at run time. To begin with, you can 
programmatically load any image in the control using the 
<I>LoadPicture</I> function:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Picture1.Picture = LoadPicture(&quot;c:\windows\setup.bmp&quot;)
</pre>
</td></tr>
</table>
</P>


<p>and you can clear the current image using either one of the following statements:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' These are equivalent.
Picture1.Picture = LoadPicture(&quot;&quot;)
Set Picture1.Picture = Nothing
</pre>
</td></tr>
</table>
</P>

<P>
<img src="images/new.jpg" width=102 height=87 border="0">
</P>

<p>The <I>LoadPicture</I> function has been extended in Visual Basic 6 to support 
icon files containing multiple icons. The new syntax is the following:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>LoadPicture(filename, [size], [colordepth], [x], [y])
</pre>
</td></tr>
</table>
</P>


<p>where values in square brackets are optional. If 
<I>filename</I> is an icon file, you can select a particular icon using the 
<I>size </I>or <I>colordepth </I>arguments. Valid sizes are 
0-vbLPSmall, 1-vbLPLarge (system icons whose sizes depend on the video driver), 
2-vbLPSmallShell, 3-vbLPLargeShell (shell icons whose dimensions are affected by the 
<I>Caption Button</I> property as set in the Appearance tab in the screen's Properties dialog box), and 
4-vbLPCustom (size is determined by <I>x</I> and 
<I>y</I>). Valid color depths are 0-vbLPDefault (the icon in the file that best matches current screen settings), 
1-vbLPMonochrome, 2-vbLPVGAColor (16 colors), and 3-vbLPColor (256 colors).</P>

<p>You can copy an image from one PictureBox control to another by 
assigning the target control's <I>Picture</I> property:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Picture2.Picture = Picture1.Picture
</pre>
</td></tr>
</table>
</P>


<A NAME="94"><h3>The <I>PaintPicture</I> method</h3></A>

<p>PictureBox controls are equipped with a very powerful method that enables 
the programmer to perform a wide variety of graphic effects, including zooming, 
scrolling, panning, tiling, flipping, and many fading effects: This is the 
<I>PaintPicture </I>method. (This method is also exposed by form objects, but it's most often used with 
PictureBox controls.) In a nutshell, this method performs a pixel-by-pixel copy from a 
source control to a destination control. The complete syntax of this method is complex 
and rather confusing:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>DestPictBox.PaintPicture SrcPictBox.Picture, destX, destY, [destWidth], _
    [destHeight], [srcX], [srcY2], [srcWidth], [srcHeight], [Opcode])
</pre>
</td></tr>
</table>
</P>


<p>The only required arguments are the source PictureBox control's 
<I>Picture</I> property and the coordinates inside the destination control where the image must be 
copied. The <I>destX </I>/ <I>destY </I>arguments are expressed in the 
<I>ScaleMode</I> of the destination control; by varying 
them, you can make the image appear exactly where you want. 
For example, if the source PictureBox control contains a bitmap 3000 twips wide and 
2000 twips tall, you can center this image on the destination control with this command:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>picDest.PaintPicture picSource.Picture, (picDest.ScaleWidth - 3000) / 2, _
    (picDest.ScaleHeight - 2000) / 2
</pre>
</td></tr>
</table>
</P>


<P><DIV CLASS="TIP"><BLOCKQUOTE><B>TIP</B><HR>
In general, Visual Basic doesn't provide a way to determine the size of 
a bitmap loaded into a PictureBox control. But you can derive this information 
if you set the control's <I>AutoSize</I> property to True and then read the 
control's <I>ScaleWidth</I> and <I>ScaleHeight</I> properties. If you don't want to resize a 
visible control just to learn the dimensions of a bitmap, you can load it into an 
invisible control, or you can use this trick, based on the fact that the 
<I>Picture </I>property returns an StdPicture object, which in turn exposes the 
<I>Height </I>and <I>Width </I>properties:
<p><table><tr><td><pre>
' StdPicture's Width and Height properties are expressed in
' Himetric units. 
With Picture1
    width = CInt(.ScaleX(.Picture.Width, vbHimetric, vbPixels))
    height = CInt(.ScaleY(.Picture.Height, vbHimetric, _
        vbPixels))
End With
</pre></td></tr></table>
</P>
</blockquote></div></p>



<p>By the way, in all subsequent code examples I assume that the source 
PictureBox control's <I>ScaleWidth</I> and 
<I>ScaleHeight</I> properties match the actual bitmap's 
size. By default, the <I>PaintPicture</I> method copies the entire source bitmap. But you 
can copy just a portion of it, passing a value for 
<I>srcWidth</I> and <I>srcHeight</I>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Copy the upper left portion of the source image.
picDest.PaintPicture picSource.Picture, 0, 0, , , , , _
    picSource.ScaleWidth / 2, picSource.ScaleHeight / 2
</pre>
</td></tr>
</table>
</P>


<p>If you're copying just a portion of the source image, you probably want to 
pass a specific value for the <I>srcX </I>and <I>srcY 
</I>values as well, which correspond to the coordinates of the top-left corner of the area that will be copied from the source control:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Copy the bottom-right portion of the source image
' in the corresponding corner in the destination. 
wi = picSource.ScaleWidth / 2
he = picSource.ScaleHeight / 2
picDest.PaintPicture picSource.Picture, wi, he, , , wi, he, wi, he
</pre>
</td></tr>
</table>
</P>


<p>You can use this method to tile a target PictureBox control (or form) 
with multiple copies of an image stored in another control:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Start with the leftmost column.
x = 0
Do While x &lt; picDest.ScaleWidth
    y = 0
    ' For each column, start at the top and work downward.
    Do While y &lt; picDest.ScaleHeight
        picDest.PaintPicture picSource.Picture, x, y, , , 0, 0
        ' Next row
        y = y + picSource.ScaleHeight
    Loop
    ' Next column
    x = x + picSource.ScaleWidth
Loop
</pre>
</td></tr>
</table>
</P>


<p>Another great feature of the 
<I>PaintPicture</I> method lets you resize the image 
while you transfer it, and you can even specify different zoom-in and zoom-out factors 
for the <I>x</I>- and <I>y</I>-axes independently. You just have to pass a value to the 
<I>destWidth </I>and <I>destHeight </I>arguments: If these values are greater than the source image's 
corresponding dimensions, you achieve a zoom-in effect, and if they are less you get a 
zoom-out effect. For example, see how you can double the size of the original image:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>picDest.PaintPicture picSource.Picture, 0, 0, _
    picSource.ScaleWidth * 2, picSource.ScaleHeight * 2
</pre>
</td></tr>
</table>
</P>


<p>As a special case of the syntax of the 
<I>PaintPicture</I> method, the source image can even be flipped along its 
<I>x</I>-axis, <I>y</I>-axis, or both by passing negative values 
for these arguments:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Flip horizontally.
picDest.PaintPicture picSource.Picture, _
    picSource.ScaleWidth, 0, -picSource.ScaleWidth
' Flip vertically.
picDest.PaintPicture picSource.Picture, 0, _
    picSource.ScaleHeight, , -picSource.ScaleHeight
' Flip the image on both axes.
picDest.PaintPicture picSource.Picture, picSource.ScaleWidth, _
    picSource.ScaleHeight, -picSource.ScaleWidth, -picSource.ScaleHeight
</pre>
</td></tr>
</table>
</P>


<p>As you might expect, you can combine all these effects together, 
magnifying, reducing, or flipping just a portion of the source image, and have the result 
appear in any point of the destination PictureBox control (or form). I have prepared a 
demonstration program (see Figure 3-12) that recaps what I have explained so far and also includes the complete source code for many interesting 
dissolve and tiling effects. You should find no problem in reusing all those routines in your 
own applications.</P>
<P>As if all these capabilities weren't enough, we haven't covered the last 
argument of the <I>PaintPicture</I> method yet. The 
<I>opcode </I>argument lets you specify which kind of Boolean operation must be performed on pixel bits as they're transferred from 
the source image to the destination. The values you can pass to this argument are 
the same that you assign to the <I>DrawMode </I>property. The default value is 
13-vbCopyPen, which simply copies the source pixels in the destination control. By playing with 
the other settings, you can achieve many interesting graphical effects, including 
simple animations. For more information about the 
<I>DrawMode</I> property, see <a href="ch02a.htm">Chapter 2</a>.</P>

<p>
<A HREF="javascript:fullSize('F03ph12x.htm')"> <img src="images/F03ph12.JPG" width=404 height=263 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 3-12.</B> <i>The PaintPicture demonstration program shows several graphic effects.</i><!--/caption-->
</p>

<A NAME="95"><h2>The Image Control</h2></A>

<p>Image controls are far less complex than PictureBox controls. They don't 
support graphical methods or the <I>AutoRedraw</I> and the 
<I>ClipControls</I> properties, and they can't work as containers, just to hint at their biggest limitations. Nevertheless, you 
should always strive to use Image controls instead of PictureBox controls because they 
load faster and consume less memory and system resources. Remember that Image 
controls are windowless objects that are actually managed by Visual Basic without 
creating a Windows object. (For an explanation of lightweight windowless controls, 
see <a href="ch02a.htm">Chapter 2</a>.) Image controls can load bitmaps and JPEG and GIF images.</P>

<p>When you're working with an Image control, you typically load a bitmap 
into its <I>Picture</I> property either at design time or at run time using the 
<I>LoadPicture</I> function. Image controls don't expose the 
<I>AutoSize</I> property because by default they 
resize to display the contained image (as it happens with PictureBox controls set at 
<I>AutoSize</I> = True). On the other hand, Image controls support a 
<I>Stretch</I> property that, if True, resizes the image (distorting it if necessary) to fit the control. In a sense, the 
<I>Stretch</I> property somewhat remedies the lack of the 
<I>PaintPicture</I> method for this control. In fact, you can zoom in to or reduce an image by loading it in an Image control 
and then setting its <I>Stretch</I> property to True to change its width and height:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Load a bitmap.
Image1.Stretch = False
Image1.Picture = LoadPicture(&quot;c:\windows\setup.bmp&quot;)
' Reduce it by a factor of two.
Image1.Stretch = True
Image1.Move 0, 0, Image1.Width / 2, Image1.Width / 2
</pre>
</td></tr>
</table>
</P>


<p>Image controls support all the usual mouse events. For this reason, many 
Visual Basic developers have used Image controls to simulate graphical buttons 
and toolbars. Now that Visual Basic natively supports these controls, you'd probably 
better use Image controls only for what they were originally intended.</P>

</BODY>
</HTML>





