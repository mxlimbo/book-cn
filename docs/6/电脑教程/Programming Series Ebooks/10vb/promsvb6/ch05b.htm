<HTML>
<HEAD>
<TITLE>Control Flow</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch05a.htm", "ch05c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="162"><h1>Control Flow</h1></A>
<p>All programming languages must provide one or more ways to execute some 
statements out of the sequence in which they appear in the program listing. Apart 
from calls to Sub and Function procedures, you can gather all the basic control flow 
statements in two groups: <I>branch</I> statements and 
<I>loop</I> statements.</p>

<A NAME="163"><h2>Branch Statements</h2></A>
<p>The main branch statement is the <I>If...Else...Else If...End 
If</I> block. Visual Basic supports several flavors of this statement, including single-line and multiline versions:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Single line version, without Else clause
If x &gt; 0 Then y = x
' Single line version, with Else clause
If x &gt; 0 Then y = x Else y = 0
' Single line, but with multiple statements separated by colons
If x &gt; 0 Then y = x: x = 0 Else y = 0 

' Multiline version of the above code (more readable)
If x &gt; 0 Then
    y = x
    x = 0 
Else
    y = 0 
End If

' An example of If..ElseIf..Else block
If x &gt; 0 Then
    y = x
ElseIf x &lt; 0 Then
    y = x * x
Else              ' X is surely 0, no need to actually test it.
    x = -1
End If
</pre>
</td></tr>
</table></p>

<p>You should be aware that any nonzero value after the 
<I>If</I> keyword is considered to be True and therefore fires the execution of the 
<I>Then</I> block:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' The following lines are equivalent.
If value &lt;&gt; 0 Then Print &quot;Non Zero&quot;
If value Then Print &quot;Non Zero&quot;
</pre>
</td></tr>
</table></p>

<p>Even if this latter notation lets you save some typing, you shouldn't believe 
that it also makes your program faster, at least not necessarily. Benchmarks show that 
if the variable being tested is of type Boolean, Integer, or Long, this shortened 
notation doesn't make your program run faster. With other numeric types, 
however, you can expect some modest speed increment, about 20 percent or less. If you 
feel comfortable with this technique, go ahead and use it, but be aware that in many 
cases the speed improvement isn't worth the decreased readability.</p>

<p>Many advanced optimization techniques become possible when you 
combine multiple conditions using AND and 
OR operators. The following examples show how you can often write more concise and efficient code by rewriting a 
Boolean expression:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' If two numbers are both zero, you can apply the OR operator
' to their bits and you still have zero.
If x = 0 And y = 0 Then ...
If (x Or y) = 0 Then ...

' If either value is &lt;&gt;0, you can apply the OR operator
' to their bits and you surely have a nonzero value.
If x &lt;&gt; 0 Or y &lt;&gt; 0 Then ...
If (x Or y) Then ...

' If two integer numbers have opposite signs, applying the XOR 
' operator to them yields a result that has the sign
'  bit set. (In other words, it is a negative value.)
If (x &lt; 0 And y &gt;= 0) Or (x &gt;= 0 And y &lt; 0) Then ...
If (x Xor y) &lt; 0 Then ...
</pre>
</td></tr>
</table></p>

<p>It's easy to get carried away when you're working with Boolean operators 
and inadvertently introduce subtle bugs into your code. For example, you might 
believe that the following two lines of code are equivalent, but they aren't. (To 
understand why, just think how numbers are represented in binary.)</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Not equivalent: just try with x=3 and y=4, whose binary
' representations are 0011 and 0100 respectively.
If x &lt;&gt; 0 And y &lt;&gt; 0 Then ...
If (x And y) Then ...
' Anyway, you can partially optimize the first line as follows:
If (x &lt;&gt; 0) And y Then ...
</pre>
</td></tr>
</table></p>

<p>Another frequent source of ambiguity is the 
NOT operator, which toggles all the bits in a number. In Visual Basic, this operator returns False only if its 
argument is True (-1), so you should never use it with anything except the Boolean result 
of a comparison or with a Boolean variable:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
If Not (x = y) Then ...  ' The same as x&lt;&gt;y
If Not x Then ...        ' The same as x&lt;&gt;-1, don't use instead of x=0
</pre>
</td></tr>
</table></p>

<p>For more information, see the section &quot;<A HREF="ch05c.htm#169">Boolean and Bit-Wise Operators</A>&quot; 
later in this chapter.</p>

<p>One detail that surprises many programmers coming to Visual Basic from 
other languages is that the <I>If</I> statement doesn't support the so-called 
<I>short-circuit evaluation</I>. In other words, Visual Basic always evaluates the whole expression in the 
<I>If</I> clause, even if it has enough information to determine that it is False or True, as 
in the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' If x&lt;=0, it makes no sense to evaluate Sqr(y)&gt;x
' because the entire expression is guaranteed to be False.
If x &gt; 0 And Sqr(y) &lt; z Then z = 0

' If x=0, it makes no sense to evaluate x*y&gt;100.
' because the entire expression is guaranteed to be True.
If x = 0 Or x * y &gt; 100 Then z = 0
</pre>
</td></tr>
</table></p>

<p>Even though Visual Basic isn't smart enough to optimize the expression 
automatically, it doesn't mean that you can't do it manually. You can rewrite the first 
<I>If</I> statement above as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
If x &gt; 0 Then If Sqr(y) &lt; z Then z = 0 
</pre>
</td></tr>
</table></p>

<p>You can rewrite the second <I>If</I> statement above as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
If x = 0 Then
    z = 0 
ElseIf x * y &gt; 100 Then
    z = 0
End If
</pre>
</td></tr>
</table></p>

<p>The <I>Select Case</I> statement is less versatile than the 
<I>If</I> block in that it can test only one expression against a list of values:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Select Case Mid$(Text, i, 1)
    Case &quot;0&quot; To &quot;9&quot;
        ' It's a digit.
    Case &quot;A&quot; To &quot;Z&quot;, &quot;a&quot; To &quot;z&quot;
        ' It's a letter.
    Case &quot;.&quot;, &quot;,&quot;, &quot; &quot;, &quot;;&quot;, &quot;:&quot;, &quot;?&quot;
        ' It's a punctuation symbol or a space.
    Case Else
        ' It's something else. 
End Select
</pre>
</td></tr>
</table></p>

<p>The most effective optimization technique with the 
<I>Select Case</I> block is to move the most frequent cases toward the top of the block. For instance, in the 
previous example you might decide to test whether the character is a letter before 
testing whether it's a digit. This change will slightly speed up your code if you're 
scanning regular text that's expected to contain more words than numbers.</p>

<p>Surprisingly, the <I>Select Case</I> block has an interesting feature that's missing 
in the more flexible <I>If</I> statement&#8212;namely, the ability to perform short circuit 
evaluation, sort of. In fact, <I>Case</I> subexpressions are evaluated only until they return 
True, after which all the remaining expressions on the same line are skipped. For 
example, in the <I>Case</I> clause that tests for punctuation symbols in the preceding code 
snippet, if the character is a dot all the other tests on that line are never executed. You 
can exploit this interesting feature to rewrite (and optimize) some complex 
<I>If </I>statements composed of multiple Boolean subexpressions:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' This series of subexpressions connected by the AND operator:
If x &gt; 0 And Sqr(y) &gt; x And Log(x) &lt; z Then z = 0
' can be rewritten as:
Select Case False
    Case x &gt; 0, Sqr(y) &gt; x, Log(x) &lt; z
        ' Do nothing if any of the above meets the condition,
        ' that is, is False.
    Case Else
        ' This is executed only if all the above are True.
        z = 0 
End Select

' This series of subexpressions connected by the OR operator:
If x = 0 Or y &lt; x ^ 2 Or x * y = 100 Then z = 0 
' can be rewritten as:
Select Case True
    Case x = 0, y &lt; x ^ 2, x * y = 100
        ' This is executed as soon as one of the above is found
        ' to be True.
        z = 0 
End Select 
</pre>
</td></tr>
</table></p>

<p>As it is for similarly unorthodox optimization techniques, my suggestion is 
to thoroughly comment your code, explaining what you're doing and always 
including the original <I>If</I> statement as a remark. This technique is highly effective for 
speeding up portions of your code, but you should never forget that optimization isn't all 
that important if you're going to forget what you did or if your code looks obscure 
to colleagues who have to maintain it.</p>

<p>Then comes the <I>GoTo</I> statement, deemed to be the main cause of tons of 
spaghetti code that plagues many applications. I must admit, however, that my 
attitude toward this four-letter keyword isn't so negative. In fact, I still prefer one single 
<I>GoTo </I>statement to a chain of <I>Exit Do</I> or 
<I>Exit</I> <I>For</I> statements for getting out of a series 
of nested loops. I suggest this: Use the 
<I>GoTo</I> statement as an exception to the 
regular flow of execution, and always use significant label names and meaningful 
remarks all over the code to explain what you're doing.</p>

<p>The <I>GoSub&#133;Return</I> keyword pair is a little bit better than 
<I>GoTo</I> because it's more structured. In some cases, using 
<I>GoSub</I> to call a piece of code inside the 
current procedure is better than calling an external 
<I>Sub</I> or <I>Function.</I> You can neither pass arguments nor receive return values; but, on the other hand, the called 
code shares all the parameters and local variables with your current procedure, so in 
most cases you don't need to pass anything. You should be aware, however, that 
when you compile to native code, the <I>GoSub</I> keyword is about 6 to 7 times 
<I>slower </I>than a call to an external procedure in the same module, so always benchmark the two 
approaches if you're writing time-critical code.</p>

<A NAME="164"><h2>Loop Statements</h2></A>
<p>The most frequently used looping structure in Visual Basic is undoubtedly 
the <I>For...Next</I> loop:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
For counter = startvalue To endvalue [Step increment]
    ' Statements to be executed in the loop...
Next
</pre>
</td></tr>
</table></p>

<p>You need to specify the <I>Step</I> clause only if 
<I>increment </I>is not equal to 1. You can exit the loop using an 
<I>Exit For</I> statement, but unfortunately Visual Basic doesn't 
provide any sort of &quot;Repeat&quot; command that lets you skip the remaining part of the 
current iteration and restart the loop. The best you can do is use (nested) 
<I>If </I>statements or, if you don't want to make the logic too complex, use a plain 
<I>GoTo</I> keyword that points to the end of the loop. In fact, this is one of the few occasions when a 
single <I>GoTo</I> statement can make your code 
<I>more </I>readable and maintainable:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
For counter = 1 To 100
    ' Do your stuff here ...
    ' if you want to skip over what follows, just GoTo NextLoop.
    If Err Then Goto NextLoop
    ' more code that you don't want to enclose within nested IF blocks
    ' ...
NextLoop:
Next
</pre>
</td></tr>
</table></p>

<p><div class="tip"><blockquote><b>TIP</b><hr>
Always use an Integer or Long variable as the controlling variable of 
a <I>For...Next</I> loop because they're faster than a Single or a Double controlling 
variable, by a factor of 10 or more. If you need to increment a floating-point 
quantity, the most efficient technique is explained in the next example.
</blockquote></div></p>

<p><div class="caution"><blockquote><b>CAUTION</b><hr>
A compelling reason to stay clear of floating-point variables 
as controlling variables in <I>For...Next</I> loops is that, because of rounding errors, 
you can't be completely sure that a floating-point variable is incremented 
correctly when the increment is a fractional quantity, and you might end up with fewer 
or more iterations than expected:

<p><table><tr><td>
<pre>
Dim d As Single, count As Long
For d = 0 To 1 Step 0.1
    count = count + 1
Next
Print count         ' Displays &quot;10&quot; but should be &quot;11&quot;
</pre>
</td></tr>
</table></p>
</blockquote></div></p>

<p>When you want to be absolutely sure that a loop is executed a given 
number of times, use an integer controlling variable and explicitly increment the 
floating-point variable within the loop:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim d As Single, count As Long
' Scale start and end values by a factor of 10 
' so that you can use integers to control the loop.
For count = 0 To 10
    ' Do what you want with the D variable, and then increment it
    ' to be ready for the next iteration of the loop.
    d = d + 0.1
Next
</pre>
</td></tr>
</table></p>

<p>I covered the <I>For Each...Next</I> loop already in <a href="ch04a.htm">Chapter 4</a>, and I won't repeat 
its description here. I just want to show you a neat trick that's based on this type of 
loop and the <I>Array</I> function. This technique permits you to execute a block of 
statements with different values for a controlling variable, which don't need to be in sequence:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Test if Number can be divided by any of the first 10 prime numbers.
Dim var As Variant, NotPrime As Boolean
For Each var In Array(2, 3, 5, 7, 11, 13, 17, 19, 23, 29)
    If (Number Mod var) = 0 Then NotPrime = True: Exit For
Next
</pre>
</td></tr>
</table></p>

<p>The values don't even have to be numeric:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Test if SourceString contains the strings &quot;one&quot;, &quot;two&quot;, &quot;three&quot;, etc.
Dim var2 As Variant, MatchFound As Boolean
For Each var2 In Array(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;)
    If InStr(1, SourceString, var2, vbTextCompare) Then
        MatchFound = True: Exit For
    End If
Next
</pre>
</td></tr>
</table></p>

<p>The <I>Do...Loop</I> structure is more flexible than the 
<I>For...Next</I> loop in that you can place the termination test either at the beginning or the end of the loop. (In the 
latter case, the loop is always executed at least once.) You can use either the 
<I>While</I> clause (repeat while the test condition is True) or the 
<I>Until </I>clause (repeat while the test condition is False). You can exit a 
<I>Do</I> loop at any moment by executing an <I>Exit 
Do</I> statement, but&#8212;as with 
<I>For...Next</I> loops&#8212;VBA doesn't offer a keyword that skips 
over the remaining statements in the loop and immediately restarts the loop.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Example of a Do loop with test condition at the top.
' This loop is never executed if x &lt;= 0.
Do While x &gt; 0
    y = y + 1
    x = x \ 2
Loop

' Example of a Do loop with test condition at the bottom.
' This loop is always executed at least once, even if x &lt;= 0.
Do 
    y = y + 1
    x = x \ 2
Loop Until x &lt;= 0

' Endless loop: requires an Exit Do statement to get out.
Do
     ...
Loop
</pre>
</td></tr>
</table></p>

<p>The <I>While...Wend</I> loop is conceptually similar to the 
<I>Do While...Loop</I>. But you can test the condition only at the beginning of the loop, you don't have an 
<I>Until</I> clause, and you don't even have an 
<I>Exit While</I> command. For these reasons, most 
programmers prefer the more flexible 
<I>Do...Loop</I> structure, and in fact you won't see a 
single <I>While...Wend</I> loop in this entire book.</p>

<A NAME="165"><h2>Other Functions</h2></A>
<p>A few VBA functions are closely related to control flow, even if by themselves 
they don't alter the execution flow. The 
<I>IIf</I> function, for example, can often replace 
an <I>If...Else...End If</I> block, as in the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' These lines are equivalent.
If x &gt; 0 Then y = 10 Else y = 20
y = IIf(x &gt; 0, 10, 20) 
</pre>
</td></tr>
</table></p>

<p>The <I>Choose</I> function lets you select a value in a group; you can use it to 
distinguish among three or more cases. So, instead of this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' The classic three-choices selection
If x &gt; y Then
    Print &quot;X greater than Y&quot;
ElseIf x &lt; y Then
    Print &quot;X less than Y&quot;
Else
    Print &quot;X equals Y&quot;
End If
</pre>
</td></tr>
</table></p>

<p>you can use this shorter version:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Shortened form, based on Sgn() and Choose() functions.
' Note how you keep the result of Sgn() in the range 1-3.
Print &quot;X &quot; &amp; Choose(Sgn(x _ y) + 2, &quot;less than&quot;, &quot;equals&quot;, _
    &quot;greater than&quot;) &amp; &quot; Y&quot;
</pre>
</td></tr>
</table></p>

<p>The <I>Switch</I> function accepts a list of 
<I>(condition, value) </I>pairs and returns the 
first <I>value </I>that corresponds to a <I>condition 
</I>that evaluates as True. See, for example, how you can use this function to replace this 
<I>Select Case</I> block:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Select Case x
    Case Is &lt;= 10: y = 1
    Case 11 To 100: y = 2
    Case 101 To 1000: y = 3
    Case Else: y = 4
End Select
</pre>
</td></tr>
</table></p>

<p>Same effect in just one line.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' The last &quot;True&quot; expression replaces the &quot;Else&quot; clause.
y = Switch(x &lt;= 10, 1, x &lt;= 100, 2, x &lt;= 1000, 3, True, 4)
</pre>
</td></tr>
</table></p>

<p>You should remember two things when you're using this function: First, if 
none of the expressions returns a True value, the 
<I>Switch</I> function returns Null. Second, all the expressions are always evaluated, even though only one value is returned. 
For these reasons, you might get unexpected errors or undesired side effects. (For 
example, if one expression raises an overflow or division-by-zero error.)</p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>
While the <I>IIf</I>, <I>Choose</I>, and <I>Switch</I> functions are sometimes 
useful for reducing the amount of code you have to write, you should be aware 
that they're always slower than the <I>If</I> or 
<I>Select Case</I> structure that they're meant to replace. For this reason, you should never use them in time-critical loops.
</blockquote></div></p>

</BODY>
</HTML>





