<HTML>
<HEAD>
<TITLE>The UserControl Object</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch17b.htm", "ch17d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="817"><h1>The UserControl Object</h1></A>

<p>The UserControl object is the container in which constituent controls are 
placed. In this sense, it's akin to the Form object, and in fact it shares many 
properties, methods, and events with the Form object. For example, you can learn its 
internal dimension using the <I>ScaleWidth </I>and 
<I>ScaleHeight </I>properties, use the 
<I>AutoRedraw </I>property to create persistent graphics on the UserControl's surface, and add 
a border using the <I>BorderStyle </I>property. UserControl objects also support all the 
graphic properties and methods that forms do, including 
<I>Cls</I>, <I>Line</I>, <I>Circle</I>, 
<I>DrawStyle</I>, <I>DrawWidth</I>, <I>ScaleX</I>, and 
<I>ScaleY</I>.
</p>

<p>UserControls support most of the Form object's events, too. For example, 
<I>Click</I>, <I>DblClick</I>, <I>MouseDown</I>, 
<I>MouseMove</I>,<I> </I>and <I>MouseUp </I>events fire when the user 
activates the mouse over the portions of UserControl's surface that aren't covered by 
constituent controls. UserControl objects also support 
<I>KeyDown</I>, <I>KeyUp</I>,<I> </I>and <I>KeyPress 
</I>events, but they fire only when no constituent control can get the focus or when you set 
the UserControl's <I>KeyPreview </I>property to True.
</p>

<A NAME="818"><h2>The Life Cycle of a UserControl Object</h2></A>

<p>UserControl are objects, and as such they receive several events during their 
lifetime. ActiveX controls actually have a double life because they're also alive when 
the environment is in design mode.
</p>

<A NAME="819"><h3>Creation</h3></A>
<p><I>Initialize</I> is the first event that a UserControl receives. In this event, no 
Windows resources have been allocated yet so you shouldn't refer to constituent 
controls, exactly as you avoid references to controls on a form in the form's 
<I>Initialize </I>event. For the same reason, the Extender and AmbientProperties objects aren't available 
in this event. (These objects are described in the following sections.)
</p>

<p>After the <I>Initialize </I>event, the UserControl creates all its constituent controls 
and is ready to be sited on the client form's surface. When the siting completes, 
Visual Basic fires an <I>InitProperties </I>or <I>ReadProperties 
</I>event, depending on whether the control has been just dragged on the form from the Toolbox or the form is 
being reopened from a previous session. During these events, the Extender and the 
Ambient objects are finally available.
</p>

<p>Just before becoming visible, the UserControl module receives the 
<I>Resize </I>event, and then the <I>Show </I>event. This event is more or less equivalent to the 
<I>Activate </I>event, which isn't exposed by UserControl modules. Finally the UserControl module 
receives a <I>Paint </I>event (unless its <I>AutoRedraw 
</I>property is True).
</p>

<p>When a control is re-created at design time because its parent form is 
closed and then reopened, the complete sequence is repeated with the only differences 
being that the <I>InitProperties </I>event never fires and the 
<I>ReadProperties </I>event fires instead, immediately after the 
<I>Resize </I>event.
</p>

<A NAME="820"><h3>Termination</h3></A>
<p>When the developer closes the parent form at design time, or when the 
program switches to run-time mode, Visual Basic destroys the design-time instance 
of the ActiveX control. If the developer modified one or more properties in the control, 
the UserControl module receives a <I>WriteProperties 
</I>event. During this event, Visual Basic doesn't write anything to the FRM file and simply stores values in the 
PropertyBag object kept in memory. This event fires only if the programmer modified the 
attributes of any control on the form (or of the form itself), but not necessarily the 
UserControl you're working with. A control informs you that one of its properties has 
changed and that the FRM file needs to be updated by calling the 
<I>PropertyChanged </I>method. When the control is removed from its container, a 
<I>Hide </I>event occurs. (ActiveX controls in HTML pages receive this event when the user navigates to another page.) 
This event broadly corresponds to a form's <I>Deactivate 
</I>event: The ActiveX control is still in memory, but it isn't visible any longer.
</p>

<p>The last event in the life of an ActiveX control is 
<I>Terminate</I>; during this event, you usually close any open files and return any system resources that you 
allocated in the <I>Initialize </I>event procedure. The code in this event can't access the 
Extender and AmbientProperties objects.
</p>

<A NAME="821"><h3>Other event sequences</h3></A>

<p>When the developer runs the program, Visual Basic destroys the design-time 
instance of the ActiveX control, and creates a run-time instance so that the control can 
receive all the events described previously. The main difference between design-time 
and run-time instances is that the latter ones never receive a 
<I>WriteProperties </I>event.
</p>

<p>When you reopen the project, you start another special sequence of events: 
Now a new instance of the control is created, and it receives all the usual events that 
fire during creation plus a <I>WriteProperties 
</I>event that serves to update the PropertyBag object in memory.
</p>

<p>Finally, when a form module is compiled, Visual Basic creates a hidden 
instance of it and then queries the properties of all its ActiveX controls so that the 
compiled program can use the most recent property values. Each ActiveX control receives 
the <I>Initialize</I>, <I>Resize</I>, 
<I>ReadProperties</I>, <I>Show</I>, 
<I>WriteProperties</I>, <I>Hide</I>, and <I>Terminate 
</I>events. You don't need to perform any special actions during these events. I mention 
this information only because if your code contains breakpoints or 
<I>MsgBox </I>commands, they might interfere with the compilation process.
</p>

<A NAME="822"><h2>The Extender Object</h2></A>

<p>When you created a UserControl module and you placed an instance of it on a 
client form, you might have noticed that the Properties window isn't empty, as 
shown in Figure 17-2. Where did those properties come from?
</p>

<p>It turns out that Visual Basic's forms don't use the ActiveX control 
directly. Instead, they wrap the control within an intermediate object known as the 
Extender object. This object exposes to the programmer all the properties defined in the 
ActiveX control, plus a number of properties that Visual Basic adds for its own purposes. 
For example, <I>Name</I>, <I>Left</I>, 
<I>Top</I>,<I> </I>and <I>Visible </I>are Extender properties and so you don't 
have to implement them in the UserControl module. Other Extender properties are 
<I>Height</I>, <I>Width</I>, <I>Align</I>, 
<I>Negotiate</I>, <I>Tag</I>, <I>Parent</I>, 
<I>Container</I>, <I>ToolTipText</I>, 
<I>DragIcon</I>, <I>DragMode</I>, 
<I>CausesValidation</I>, <I>TabIndex</I>, 
<I>TabStop</I>, <I>HelpContextID</I>,<I> </I>and 
<I>WhatsThisHelpID</I>.
</p>

<p>The Extender object also provides methods and events of its own. For 
example, the <I>Move</I>, <I>Drag</I>, 
<I>SetFocus</I>, <I>ShowWhatsThis, </I>and <I>ZOrder 
</I>methods are provided by the container (and in fact, all of them are related to Extender properties in one way 
or another), as are the <I>GotFocus</I>, 
<I>LostFocus</I>, <I>Validate</I>, 
<I>DragDrop</I>,<I> </I>and <I>DragOver 
</I>events. The perspective of the programmer who uses the ActiveX control is different from 
the perspective of the control's author, who sees fewer properties, methods, and events.
</p>

<p>
<A HREF="javascript:fullSize('G17ph01x.htm')"> <img src="images/G17ph01.JPG" width=404 height=214 border=0 ALT = "Click to view at full size."> </A>
</p>

<A NAME="823"><h3>Reading Extender properties</h3></A>
<p>At times, however, you need to access Extender properties from within the 
UserControl module. You can do this by means of the 
<I>Extender </I>property, which returns an object reference to the same Extender interface that's used by the programmer using 
the control. A typical example of why this might be necessary is when you want 
your ActiveX control to display its <I>Name </I>property, as most Visual Basic controls do as 
soon as they're created. To add this feature to the SuperTextBox ActiveX control, you 
simply need a statement in the <I>InitProperties 
</I>event procedure:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub UserControl_InitProperties()
    On Error Resume Next
    Caption = Extender.Name
End Sub
</pre>
</td></tr>
</table>
</p>

<p>You might wonder why you need an error handler to protect a simple 
assignment like the preceding one. The reason is that you can't anticipate the 
environments in which your ActiveX control will be used, so you have no guarantee that the 
host environment will support the <I>Name </I>property. If it doesn't, the 
<I>Extender.Name </I>reference fails, and the error will prevent developers from using your control in 
those environments. In general, different hosts add different Extender members. Visual 
Basic is probably the most generous environment in terms of Extender properties.
</p>

<p>The Extender object is built at run time by the host environment, so the 
<I>Extender </I>property is defined to return a generic Object. As a result, all the Extender 
members such as <I>Name </I>or <I>Tag </I>are referenced through late binding. This circumstance 
explains why accessing those members tends to slow down the code inside your 
UserControl module and at the same time makes it less robust. Because you can't be sure 
about which members the Extender object will expose at run time, you shouldn't let 
your ActiveX control heavily rely on them, and you should always arrange for your 
control to degrade gracefully when it runs under environments that don't support 
the features you need.
</p>

<p>Finally, keep in mind that a few Extender properties are created only 
under certain conditions. For example, the <I>Align 
</I>and <I>Negotiate </I>properties are exposed 
only if the UserControl's <I>Alignable </I>property is set to True, and the 
<I>Default </I>and <I>Cancel </I>properties exist only if the UserControl's 
<I>DefaultCancel </I>property is True. Likewise, the 
<I>Visible </I>property is unavailable if the <I>InvisibleAtRuntime 
</I>property is True.
</p>

<A NAME="824"><h3>Setting Extender properties</h3></A>

<p>In general, modifying an Extender property from within the UserControl module 
is considered bad programming practice. I found that under Visual Basic 6 all the 
Extender properties can be written to, but this might not be true for other 
environments or for previous versions of Visual Basic itself. In some cases, setting an 
Extender property provides added functionality. For example, see how you can implement 
a method that resizes your ActiveX control to fit its parent form:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Sub ResizeToParent()
    Extender.Move 0, 0, Parent.ScaleWidth, Parent.ScaleHeight
End Sub
</pre>
</td></tr>
</table>
</p>

<p>This routine is guaranteed to work only under Visual Basic because other 
environments might not support the <I>Move </I>Extender method, and also because you 
can't be sure that, if a Parent object actually exists, it also supports the 
<I>ScaleWidth </I>and <I>ScaleHeight </I>properties. If any of the preceding conditions aren't met, this 
method raises an error 438, &quot;Object doesn't support this property or method.&quot;
</p>

<p>From the container's point of view, Extender properties have a higher 
priority than the UserControl's own properties. For example, if the UserControl module 
exposes a <I>Name </I>property, the client code&#8212;at least the client code written in 
Visual Basic&#8212;will actually refer to the Extender property with the same name. For 
this reason, you should carefully pick the names of your custom properties and stay 
clear of those automatically added by the most popular containers, such as Visual 
Basic and the products in the Microsoft Office suite.
</p>

<p><div class="tip"><blockquote>
<b>TIP</b><hr>You might intentionally expose properties that are duplicated in the 
Extender object so that users of your ActiveX control can find that property 
regardless of what programming language they're using. For example, you can 
define a <I>Tag </I>property (of type String or Variant) so that your control provides it 
even when it runs in an environment other than Visual Basic.
</blockquote></div>
</p>


<A NAME="825"><h3>The <I>Object </I>property</h3></A>

<p>This visibility rule raises an interesting question: How can the user of the 
ActiveX control directly access its interface and bypass the Extender object? This is 
possible thanks to the <I>Object </I>property, another Extender property that returns a reference 
to the inner UserControl object. This property is sometimes useful to developers 
who are using the ActiveX control, as in this code:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' Set the Tag property exposed by the UserControl module.
' Raises an error if such property isn't implemented
SuperTextBox1.Object.Tag = &quot;New Tag&quot;
</pre>
</td></tr>
</table>
</p>

<p>You never need to use the <I>Extender.Object 
</I>property from within the UserControl module because it returns the same object reference as the 
<I>Me </I>keyword.
</p>

<A NAME="826"><h2>The AmbientProperties Object</h2></A>

<p>An ActiveX control often needs to gather information about the form on which it 
has been placed. For example, you might want to adapt your ActiveX control to the 
locale of the user or to the font that's used by the parent form. In some cases, you 
can gather this information using the Extender or Parent object (for example, 
using <I>Parent.Font</I>). But there's a better way.
</p>

<A NAME="827"><h3>Conforming to the parent form settings</h3></A>
<p>The UserControl object's <I>Ambient </I>property returns a reference to the 
AmbientProperties object, which in turn exposes several properties that provide 
information about the environment in which the ActiveX control runs. For example, you can 
find out what font is being used by the parent form using the 
<I>Ambient.Font </I>property, and you can determine which colors have been set for the parent form using 
the <I>Ambient.ForeColor </I>and <I>Ambient.BackColor 
</I>properties. This information is especially useful when you create the control and you want to conform to the parent 
form's current settings. See how you can improve the SuperTextBox control so that it 
behaves like Visual Basic's own controls:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub UserControl_InitProperties()
    ' Let the label and the text box match the form's font.
    Set CaptionFont = Ambient.Font
    Set Font = Ambient.Font
    ' Let the label's colors match the form's colors.
    CaptionForeColor = Ambient.ForeColor
    CaptionBackColor = Ambient.BackColor
End Sub
</pre>
</td></tr>
</table>
</p>

<p>The AmbientProperties object is provided by the Visual Basic runtime, 
which always accompanies the ActiveX control, rather than by the Extender object, 
which is provided by the host environment. References to the AmbientProperties object 
rely on early binding, and the Visual Basic runtime automatically supplies a default 
value for those properties that aren't available in the environment. This detail has two 
consequences: Ambient properties are faster than Extender properties, and you don't 
need an error handler when referring to an Ambient property. For example, 
the AmbientProperties object exposes a <I>DisplayName 
</I>property, which returns the name that identifies the control in its host environment and lets you initialize the 
caption of your control:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub UserControl_InitProperties()
    Caption = Ambient.DisplayName
End Sub
</pre>
</td></tr>
</table>
</p>

<p>This code should always be preferred to the method based on the 
<I>Extender.Name </I>property because it delivers a reasonable result under any environment and 
doesn't require an <I>On Error</I> statement.
</p>

<p>Another ambient property that you might find useful is 
<I>TextAlign</I>, which indicates the preferred text alignment for the controls on the form. It returns one of 
the following constants: 0-General, 1-Left, 2-Center, 3-Right, 4-FillJustify. If the host 
environment doesn't provide any information about this feature, 
<I>Ambient.TextAlign </I>returns 0-General (text to the left, numbers to the right).
</p>

<p>If your control contains a PictureBox control, you should set its 
<I>Palette </I>property equal to the <I>Ambient.Palette 
</I>property if possible so that the bitmaps on 
your control don't look strange when the PictureBox constituent control doesn't have 
the input focus.
</p>

<A NAME="828"><h3>The <I>UserMode</I> property</h3></A>
<p>The <I>UserMode </I>property is probably the most important Ambient property because 
it lets the author of the ActiveX control know whether the control is being used by 
the developer (<I>UserMode </I>= False) or the user 
(<I>UserMode </I>= True). Thanks to this property, you can enable different behaviors at design time and run time. If you find 
it difficult to remember the meaning of the return value of this property, just recall 
that the &quot;user&quot; in <I>UserMode </I>is the user. See the &quot;<A HREF="ch06c.htm#227">Read-Only Properties</A>&quot; section later in 
this chapter for an example that shows how this property can be useful.
</p>

<A NAME="829"><h3>The <I>AmbientChanged</I> event</h3></A>
<p>You can immediately find out when an ambient property changes by trapping 
the <I>AmbientChanged </I>event. This event receives a string argument equal to the name 
of the ambient property being changed. For instance, you can allow the 
<I>BackColor </I>property of your UserControl to automatically match the background color of 
the parent form by writing this code:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub UserControl_AmbientChanged(PropertyName As String)
    If PropertyName = &quot;BackColor&quot; Then BackColor = Ambient.BackColor
End Sub
</pre>
</td></tr>
</table>
</p>

<p>Here's an exception: If you change the parent form's 
<I>FontTransparent </I>or <I>Palette</I> properties, the ActiveX controls on the form don't receive any notification. 
The <I>AmbientChanged </I>event is raised both at design time and at run time, so you 
might need to use the <I>Ambient.UserMode </I>property to differentiate between the two cases.
</p>

<p>The <I>AmbientChanged </I>event is most important within user-drawn controls 
that expose a <I>Default </I>property. These controls must repaint themselves when the 
value of this property changes:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub UserControl_AmbientChanged(PropertyName As String)
    If PropertyName = &quot;DisplayAsDefault&quot; Then Refresh
End Sub 
</pre>
</td></tr>
</table>
</p>

<A NAME="830"><h3>Localizing ActiveX controls</h3></A>
<p>The <I>Ambient.LocaleID </I>property returns a Long value that corresponds to the 
locale of the program that's hosting the ActiveX control. This value lets you display 
localized messages in the language of the user&#8212;for example, by loading them from a 
string table, a resource file, or a satellite DLL. But you must account for some rough edges.
</p>

<p>When you compile your application, the Visual Basic locale becomes the 
default locale for the application. But the application that's hosting the control 
might automatically adapt itself to the language of the user and change its locale 
accordingly. Inside the <I>Initialize </I>event procedure of the UserControl, the siting 
procedure hasn't completed yet, so the value returned by the 
<I>LocaleID </I>ambient property reflects the default locale of the Visual Basic version that compiled it. For this reason, if 
you want to use this property to load a table of localized messages, you should 
follow this schema:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub UserControl_Initialize()
    ' Load messages in the default (Visual Basic's) locale.
    LoadMessageTable Ambient.LocaleID
End Sub    

Private Sub UserControl_InitProperties()
    ' Load messages in the user's locale.
    LoadMessageTable Ambient.LocaleID
End Sub

Private Sub UserControl_ReadProperties(PropBag As PropertyBag)
    ' Load messages in the user's locale.
    LoadMessageTable Ambient.LocaleID
End Sub

Private Sub UserControl_AmbientChanged(PropertyName As String)
    ' Load messages in the new user's locale.
    If PropertyName = &quot;LocaleID&quot; Then LoadMessageTable Ambient.LocaleID 
End Sub

Private Sub LoadMessageTable(LocaleID As Long)
    ' Here you load localized strings and resources.
End Sub
</pre>
</td></tr>
</table>
</p>

<p>You need to load the message in both the <I>InitProperties 
</I>and <I>ReadProperties </I>event procedures because the former is invoked when the control is first placed 
on the form's surface, whereas the latter is invoked any time the project is reopened 
or the application is executed.
</p>

<A NAME="831"><h3>Other ambient properties</h3></A>

<p>The <I>Ambient.ScaleMode </I>property returns a string corresponding to the unit 
measure currently used in the container form (for example, 
<I>twip</I>). This value might be useful within messages to the user or the developer. For a way to easily convert from 
the form's and UserControl's units, see the section &quot;<A HREF="ch17c.htm#837">Converting Scale Units</A>.&quot;
</p>

<p>The <I>Ambient.DisplayAsDefault </I>property is useful only within user-drawn 
controls whose <I>DefaultCancel </I>property is True. These controls must display a 
thicker border when their <I>Default </I>extender property becomes True. You usually trap 
changes to this property in the <I>AmbientChanged 
</I>event.
</p>

<p>The <I>Ambient.SupportsMnemonics </I>property returns True if the 
environment supports hot keys, such as those that you indicate in a 
<I>Caption </I>property using the ampersand character. Most containers support this feature, but you can improve 
the portability of your control if you test this property in the 
<I>Show </I>event procedure and filter out ampersand characters in your captions if you find that the 
environment doesn't support hot keys.
</p>

<p>The <I>Ambient.RightToLeft </I>property specifies whether the control should 
display text from right to left, as it might be necessary under Hebrew or Arabic 
versions of Windows. All the remaining ambient properties&#8212;namely, 
<I>MessageReflect</I>, <I>ShowGrabHandles</I>, 
<I>ShowHatching</I>, and <I>UIDead&#8212;</I>are of no practical use with 
controls developed with Visual Basic and can be safely ignored.
</p>

<A NAME="832"><h2>Implementing Features</h2></A>
<p>The UserControl object exposes many properties, methods, and events that have 
no equivalent in form modules. In this section, I describe most of them and briefly 
hint at items that I examine in depth later in the chapter.
</p>

<A NAME="833"><h3>Managing the input focus</h3></A>
<p>Understanding how UserControl objects manage the input focus can be a 
nontrivial task. Several events are related to input focus:
</p>

<UL>
<p><li> The UserControl object's <I>GotFocus 
</I>and <I>LostFocus </I>events. These events can fire only if the UserControl doesn't contain any constituent controls 
that can get the input focus (typically, a user-drawn UserControl). In 
most cases, you don't have to write any code for these events.
</li></p>
<p><li> The constituent controls' <I>GotFocus 
</I>and <I>LostFocus </I>events. These events fire when the focus enters or exits a constituent control.
</li></p>
<p><li> The UserControl's <I>EnterFocus </I>and 
<I>ExitFocus </I>events. These events fire when the input focus enters or exits the UserControl as a whole but 
don't fire when the focus moves from one constituent control to another.
</li></p>
<p><li> The Extender's <I>GotFocus </I>and 
<I>LostFocus </I>events. These are the events that an ActiveX control activates in its container application.
</li></p>
</UL>

<p>The simplest way to see what actually happens at run time is to create a 
trace of all the events as they occur when the user visits the constituent controls by 
pressing the Tab key. I created a simple UserControl named 
<I>MyControl1</I> with two TextBox constituent controls on it&#8212;named 
<I>Text1 </I>and <I>Text2&#8212;</I>and then added 
<I>Debug.Print </I>statements in all the event procedures related to focus management. This is what 
I found in the Immediate window (with some remarks manually added later):
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>UserControl_EnterFocus   ' The user has tabbed into the control.
MyControl1_GotFocus
Text1_GotFocus
Text1_Validate           ' The user has pressed the Tab key a second time.
Text1_LostFocus
Text2_GotFocus
MyControl1_Validate      ' The user has pressed the Tab key a third time.
Text2_LostFocus
UserControl_ExitFocus
MyControl1_LostFocus
...                      ' The user has pressed Tab several times
UserControl_EnterFocus   ' until the focus reenters the UserControl
MyControl1_GotFocus      ' and the sequence is repeated.
Text1_GotFocus
</pre>
</td></tr>
</table>
</p>

<p>As you see, the UserControl object gets an <I>EnterFocus 
</I>just before the ActiveX control raises a <I>GotFocus 
</I>event in its parent form. Similarly, the UserControl 
receives an <I>ExitFocus </I>one instant before the ActiveX control raises a 
<I>LostFocus </I>in the form.
</p>

<p>When the focus shifts from one constituent control to another, the control 
that loses the focus receives a <I>Validate </I>event, but this doesn't happen when the 
focus leaves the UserControl module. To force the 
<I>Validate </I>event of the last control in the UserControl, you must explicitly call the 
<I>ValidateControls </I>method in the 
UserControl's <I>ExitFocus</I>, which isn't really intuitive. If the ActiveX control includes several 
controls, it sometimes doesn't make sense to validate them individually in their 
<I>Validate </I>events. Moreover, if you use the 
<I>ValidateControls </I>method, you might incorrectly force 
the validation of a constituent control when the form is being closed (for example, 
when the user presses Cancel). For all these reasons, it's much better to validate the 
contents of a multifield ActiveX control only upon a request from the parent form, or 
more precisely, in the <I>Validate </I>event that the ActiveX control raises in the parent form. 
If the control is complex, you might simplify the life of programmers by providing 
a method that performs the validation, as in the following piece of code:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub MyControl1_Validate(Cancel As Boolean)
    If MyControl1.CheckSubFields = False Then Cancel = True
End Sub
</pre>
</td></tr>
</table>
</p>

<p><div class="tip"><blockquote>
<b>TIP</b><hr>The Visual Basic documentation omits an important detail about 
focus management inside ActiveX controls with multiple constituent controls. If 
the ActiveX control is the only control on the form that can receive the focus and 
the user presses the Tab key on the last constituent control, the focus won't 
automatically shift on the first constituent control as the user would expect. So to 
have such an ActiveX control behave normally, you should add at least one 
other control on the form. If you don't want to display another control, you should 
resort to the following trick: Create a CommandButton (or any other control 
that can get the focus), move it out of sight using a large negative value for the 
<I>Left </I>or <I>Top </I>property, and then add these statements in its 
<I>GotFocus </I>event procedure:

<p>
<table><tr><td>
<pre>Private Sub Command1_GotFocus()
    MyControl1.SetFocus   ' Manually move the focus
                          ' to the ActiveX control.
End Sub
</pre>
</td></tr>
</table>
</p>
</blockquote></div>
</p>

<A NAME="834"><h3>Invisible controls</h3></A>
<p>The <I>InvisibleAtRuntime </I>property permits you to create controls that are visible 
only at design time, as are the Timer and CommonDialog controls. When 
the <I>InvisibleAtRuntime </I>property is True, the Extender object doesn't expose the 
<I>Visible </I>property. You usually want the controls to have a fixed size at design time, and you 
ensure this result by using the <I>Size </I>method in the UserControl's 
<I>Resize </I>event:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub UserControl_Resize()
    Static Active As Boolean
    If Not Active Then Exit Sub        ' Avoid nested calls.
    Active = True
    Size 400, 400
    Active = False
End Sub
</pre>
</td></tr>
</table>
</p>

<A NAME="835"><h3>Hot keys</h3></A>
<p>If your ActiveX control includes one or more controls that support the 
<I>Caption </I>property, you can assign each of them a hot key using the ampersand character, as 
you would do in a regular Visual Basic form. Such hot keys work as you expect, even 
if the input focus isn't currently on the ActiveX control. As an aside, keep in mind 
that it's considered bad programming practice to provide an ActiveX control with 
fixed captions, both because they can't be localized and because they might conflict 
with other hot keys defined by other controls on the parent form.
</p>

<p>If your ActiveX control doesn't include a constituent control with a 
<I>Caption </I>property, your control responds to the hot keys assigned to the 
<I>AccessKeys </I>property. For example, you might have a user-drawn control that exposes a 
<I>Caption </I>property and you want to activate it if the user types the 
Alt+<I>char</I> key combination, where <I>char 
</I>is the first character in the <I>Caption</I>. In this circumstance, you must assign 
the <I>AccessKeys </I>property in the <I>Property Let 
</I>procedure as follows:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Property Let Caption(New_Caption As String)
    m_Caption = New_Caption
    PropertyChanged &quot;Caption&quot;
    AccessKeys = Left$(New_Caption, 1)
End Property
</pre>
</td></tr>
</table>
</p>

<p>When the user presses a hot key, an <I>AccessKeyPressed 
</I>event fires in the UserControl module. This event receives the code of the hot key, which is 
necessary because you can associate multiple hot keys with the ActiveX control by assigning 
a string of two or more characters to the <I>AccessKeys 
</I>property:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub UserControl_AccessKeyPress(KeyAscii As Integer)
    ' User pressed the Alt + Chr$(KeyAscii) hot key.
End Sub
</pre>
</td></tr>
</table>
</p>

<p>You can create ActiveX controls that behave like Label controls by setting 
the <I>ForwardFocus </I>property to True. When the control gets the input focus, it 
automatically moves it to the control on the form that comes next in the TabIndex order. 
If the <I>ForwardFocus </I>property is True, the UserControl module doesn't receive 
the <I>AccessKeyPress </I>event.
</p>

<A NAME="836"><h3>Accessing the parent's controls</h3></A>
<p>An ActiveX control can access other controls on its parent form in two distinct 
ways. The first approach is based on the Controls collection of the Parent object, as this 
code example demonstrates:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' Enlarge or shrink all controls on the parent form except this one.
Sub ZoomControls(factor As Single)
    Dim ctrl As Object
    For Each ctrl In Parent.Controls
        If Not (ctrl Is Extender) Then
            ctrl.Width = ctrl.Width * factor
            ctrl.Height = ctrl.Height * factor
        End if
    Next
End Sub
</pre>
</td></tr>
</table>
</p>

<p>The items in the Parent.Controls collection are all Extender objects, so if 
you want to sort out the ActiveX control that's running the code you must compare 
each item with the <I>Extender </I>property, not with the 
<I>Me </I>keyword. The problem with this approach is that it works only under Visual Basic (more precisely, only under 
environments for which there is a Parent object that exposes the Controls collection).
</p>

<p>The second approach is based on the <I>ParentControls 
</I>property. Unlike the Parent.Controls<I> </I>collection, this property is guaranteed to work with all containers. 
The items in the Parent.Controls collection contain the parent form itself, but you can 
easily filter it out by comparing each reference with the 
Parent<I> </I>object (if there is one).
</p>

<A NAME="837"><h3>Converting scale units</h3></A>
<p>In the interaction with the container application, the code in the ActiveX control 
often has to convert values from the UserControl's coordinate system to the parent 
form's system by using the <I>ScaleX </I>and <I>ScaleY 
</I>methods. This is especially necessary in mouse events, where the container expects that the 
<I>x </I>and <I>y </I>coordinates of the mouse are measured in its current 
<I>ScaleMode</I>. While you can use the <I>Parent.ScaleMode 
</I>property to retrieve a Visual Basic form's 
<I>ScaleMode</I>, this approach fails if the control 
is running inside another container&#8212;for example, Internet Explorer. Fortunately, 
the <I>ScaleX </I>and <I>ScaleY </I>methods also support the vbContainerPosition constant:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>' Forward the MouseDown event to the container, but convert measure units.
Private Sub UserControl_MouseDown(Button As Integer, Shift As Integer, _
    X As Single, Y As Single)
    RaiseEvent MouseDown(Button, Shift, _
        ScaleX(X, vbTwips, vbContainerPosition), _
        ScaleY(Y, vbTwips, vbContainerPosition))
End Sub
</pre>
</td></tr>
</table>
</p>

<p>When you're raising mouse events from within a constituent control, things 
are a bit more complicated because you also need to keep the control's offset from 
the upper left corner of the UserControl's surface:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Private Sub Text1_MouseDown(Button As Integer, _
    Shift As Integer, X As Single, Y As Single)
    RaiseEvent MouseDown(Button, Shift, _
        ScaleX(Text1.Left + X, vbTwips, vbContainerPosition), _
        ScaleY(Text1.Top + Y, vbTwips, vbContainerPosition))
End Sub
</pre>
</td></tr>
</table>
</p>

<p>The <I>ScaleX </I>and <I>ScaleY </I>methods support an additional enumerated 
constant, vbContainerSize, that you should use when converting a size value (as opposed 
to a coordinate value). The vbContainerPosition and vbContainerSize constants 
deliver different results only when the container uses a custom 
<I>ScaleMode</I>. The ActiveX Control Interface Wizard doesn't address these subtleties, and you must manually 
edit the code that it produces.
</p>

<A NAME="838"><h3>Other properties</h3></A>
<p>If the <I>Alignable </I>property is True, the ActiveX control&#8212;more precisely, its 
Extender object&#8212;exposes the <I>Align </I>property. Similarly, you should set 
<I>DefaultCancel </I>to True if the control has to expose the 
<I>Default </I>and <I>Cancel </I>properties. This setting is 
necessary when the ActiveX control should behave like a standard CommandButton 
and works only if <I>ForwardFocus </I>is False. If the ActiveX control's 
<I>Default </I>property is True and the user presses Enter, the click will be received by the constituent control 
whose <I>Default </I>property is also True. If there aren't any constituent 
controls that support the <I>Default </I>or <I>Cancel 
</I>properties, you can trap the Enter or Escape key in 
the <I>AccessKeyPress </I>event.
</p>

<p>If the <I>CanGetFocus </I>is False, the UserControl itself can't get the input focus 
and the ActiveX control won't expose the <I>TabStop 
</I>property. You can't set this property to False if one or more constituent controls can receive the focus. The opposite 
is also true: You can't place constituent controls that can receive the focus on a 
UserControl whose <I>CanGetFocus </I>property is False.
</p>

<p>The <I>EventsFrozen </I>property is a run-time property that returns True when 
the parent form ignores events raised by the UserControl object. This happens, for 
instance, when the form is in design mode. At run time, you can query this 
property to find out whether your <I>RaiseEvent 
</I>commands will be ignored so that you can 
decide to postpone them. Unfortunately, there's no safe way to find out when the 
container is again ready to accept events, but you can learn when a paused program has 
restarted by watching for a change in the <I>UIDead 
</I>property in the <I>AmbientChanged </I>event.
</p>

<p>You can create controls that can be edited at design time by setting 
the <I>EditAtDesignTime </I>property to True. You can right-click on such controls at 
design time and select the Edit command to enter edit mode. While the control is in 
edit mode, it reacts exactly as it does at run time although it doesn't raise events in 
its container. (The <I>EventsFrozen </I>property returns True.) You exit edit mode when 
you click anywhere on the form outside the control. In general, writing a control that 
can be edited at design time isn't a simple task: for example, you must account for 
all the properties that aren't available at design time and that raise an error if used 
when <I>Ambient.UserMode </I>returns False.
</p>

<p>The <I>ToolboxBitmap </I>property lets you assign the image that will be used in 
the Toolbox window. You should use 16-by-15-pixel bitmaps, but bitmaps of 
different size are automatically scaled. You shouldn't use icons because they don't scale 
well to that dimension. The lower left pixel in the bitmap defines its transparent color.
</p>

<p>The <I>ContainerHwnd </I>property is available only through code and returns 
the Windows handle of the ActiveX control's container. If the control is hosted in 
a Visual Basic program, this property corresponds to the value returned by 
the <I>Extender.Container.hWnd </I>property.
</p>

<p>The UserControl object exposes a few other properties, which let you 
create windowless controls, container controls, and transparent controls. I'll cover them 
later in this chapter.
</p>

</BODY>
</HTML>





