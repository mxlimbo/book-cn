<HTML>
<HEAD>
<TITLE>The DataGrid Control</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch15b.htm", "ch15d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="672"><h1>The DataGrid Control</h1></A>
<P>
<img src="images/new.jpg" width=102 height=87 border="0">
</P>

<p>Probably the most usual way to display data in a database table is with a grid 
control. Visual Basic 6 comes with several grid controls, but only two of them can 
work with the newer ADO Data control and other ADO data sources: the DataGrid 
control and the Hierarchical FlexGrid control. I'll describe the DataGrid control in 
this section and the Hierarchical FlexGrid control in the next section.</P>

<p>Before looking at the individual properties, methods, and events supported 
by the DataGrid control, you should be familiar with its object model. As you can 
see in Figure 15-2, this is a simple object model, with the DataGrid control at the top 
of the hierarchy and the Columns and Splits collections under it. You can split a 
DataGrid control into two or more sections and navigate through them independently or in 
a synchronized manner. The DataGrid control is included in the MSDATGRD.OCX 
file, which must therefore be distributed with any application that uses this control.</P>

<p>
<A HREF="javascript:fullSize('F15ph02x.htm')"> <img src="images/F15ph02.JPG" width=404 height=337 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 15-2.</B> <I>The object model for the DataGrid control.</i><!--/caption-->
</p>

<p><DIV CLASS="NOTE"><BLOCKQUOTE><B>NOTE</B><HR>
The DataGrid is source-code compatible with the older DBGrid 
control, which, though still included in Visual Basic 6, doesn't support the newer 
ADO Data control and data sources. Thanks to this compatibility, the DataGrid 
control can be used as a drop-in substitute for the DBGrid control. The only 
relevant difference between the two controls is that the newer DataGrid control 
doesn't work in unbound mode. But because you can bind this control to any ADO 
data source&#8212;including your own classes, as explained in <a href="ch18a.htm">Chapter 18</a>&#8212;nothing 
prevents you from creating a class that encapsulates an in-memory data 
structure, such as an array of UDTs or a two-dimensional array of Strings or Variants.
</BLOCKQUOTE></DIV></P>

<A NAME="673"><h2>Setting Design-Time Properties</h2></A>

<p>Since the DataGrid control can work only as a bound control to an ADO data 
source, the first thing to do is prepare such a source. This can be a design-time source 
such as an ADO Data control or a DataEnvironment object, or it can be a run-time 
source such as an ADO Recordset or an instance of a custom class that qualifies as a 
data source. Working with design-time sources is definitely preferable, because you 
can retrieve the field structure at design time and adjust column width and other 
attributes in a visual manner, without writing code.</P>

<p><DIV CLASS="NOTE"><BLOCKQUOTE><B>NOTE</B><HR>
You can bind complex controls, such as the DataGrid and 
Hierarchical FlexGrid controls, only to Recordsets based on static or keyset cursors.
</BLOCKQUOTE></DIV></P>

<A NAME="674"><h3>Editing the Column layout</h3></A>

<p>After you have bound the DataGrid control to an ADO Data control or to 
a DataEnvironment's Command object through the DataGrid's 
<I>DataSource </I>property, you can right-click on the control and select the Retrieve Fields menu command. 
This prepares a column layout at design time, with each column taking its caption 
and width directly from the database field to which it maps. You can then right-click 
again on the control and select the Edit menu command, which puts the grid in edit 
mode. In this mode, you can adjust the column width, scroll the grid horizontally by 
using the scroll bar at the bottom, and right-click on the control to display a menu of 
commands. These commands allow you to add and remove columns, split the grid 
into two or more sections, cut and paste columns to rearrange their order, and so on. 
To modify other properties, however, you must right-click once again on the control 
and select the Properties command, which brings up a Property Pages dialog box 
with as many as eight tabs, as shown in Figure 15-3.</P>

<p>Contrary to what the documentation states, it seems impossible in practice 
to have distinct column layouts for different split sections. In fact, if you delete an 
existing column or add a new column to a split, all the other splits are affected as 
well. A possible workaround for this problem is to set a column's 
<I>Visible </I>property to False. Because this attribute can be set on a split-by-split basis (as explained in &quot;<A HREF="ch15c.htm#678">The Layout Tab</A>&quot; section later in this chapter), you can effectively hide a column in all 
the splits where it shouldn't appear.</P>

<p>
<A HREF="javascript:fullSize('F15ph03x.htm')"> <img src="images/F15ph03.JPG" width=404 height=297 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 15-3.</B> <I>The DataGrid control at design time, after displaying its Property Pages dialog box.</i><!--/caption-->
</p>

<A NAME="675"><h3>The General and Keyboard tabs</h3></A>

<p>By default, the grid has no caption, but you can enter a custom string in the 
General tab of the Property Pages dialog box; if a nonempty string is specified for 
the <I>Caption </I>property, it will appear in a gray section above the column headers. 
The <I>AllowAddNew</I>, <I>AllowDelete</I>,<I> 
</I>and <I>AllowUpdate </I>Boolean properties determine 
which operations are allowed on the grid. The <I>ColumnHeaders 
</I>property can be set to False to hide the gray row containing the column headers. Note that in the Font 
tab you can set the <I>HeadFont </I>property, which determines the character font used 
for column headers.</P>

<p>The <I>DefColWidth </I>property is the default width of the grid's columns: If set to 
0 (its default value), the width of each column is the largest value between the 
underlying field's size and the column header's width. The 
<I>HeadLines</I> property is an integer between 0 and 10, and corresponds to the number of rows used for 
column headings; you can use 0 to remove column headers, but it's preferable to set 
the <I>ColumnHeaders </I>property to False to achieve the same result. The 
<I>RowHeight </I>property is the height of each row in twips. The DataGrid control doesn't support 
rows of different heights.</P>

<p>You can set the <I>BorderStyle </I>property to 0-dbgNoBorder to suppress the 
fixed border around the grid. The <I>RowDividerLine 
</I>property determines the style used to draw the dividing lines between the rows and can be one of the following 
enumerated values: 0-dbgNoDividers, 1-dbgBlackLine, 2-dbgDarkGrayLine (the 
default), 3dbgRaised, 4-dbgInset, or 5-dbgUseForeColor. If 3-dbgRaised or 4-dbgInset is 
used, the color of the dividing line depends on the Microsoft Windows settings.</P>

<p>The Keyboard tab allows you to set some properties that affect how keys 
behave when the DataGrid control has the focus. If the 
<I>AllowArrows </I>property is True, the user can visit all the cells in the grid using the arrow keys; if 
<I>WrapCellPointer </I>is also True, pressing the right arrow key at the end of a row moves the focus 
rectangle to the first cell in the next row and pressing the left arrow key at the beginning of 
a row moves the focus rectangle to the last cell in the previous row.</P>

<p>The <I>TabAction </I>property decides what happens when the 
Tab key or Shift+Tab key combination is pressed and 
the DataGrid control is the active control. The 
default action is 0dbgControlNavigation, in which case the next control (or the previous 
control, if Shift+Tab is pressed) on the form receives the focus. If you set this property 
to 1dbgColumnNavigation, pressing the Tab key moves the focus rectangle to the 
next column unless the current cell is the last (or the first, if Shift+Tab is pressed) of its 
row. In this case, pressing this key causes the focus to move to the next (or previous) 
control in the TabIndex order. Finally, the setting 2-dbgGridNavigation is similar to the 
previous one, but the Tab key never moves the focus rectangle to another control and 
the behavior at the beginning or end of the row depends on the 
<I>WrapCellPointer </I>property.</P>

<p>By default, tab and arrow keys never move the focus rectangle to another 
split in the same grid. You can, however, set the 
<I>TabAcrossSplit </I>property to True to let the user navigate through splits by using the Tab key. In this case, the value of 
the <I>WrapCellPointer </I>and <I>TabAction</I> properties are ignored, unless the user presses the 
Tab key when the current cell is in the last column of the rightmost split or presses 
the Shift+Tab key combination when the current cell is in the first column of the leftmost split.</P>

<A NAME="676"><h3>The Columns and Format tabs</h3></A>

<p>The Columns tab allows you to set the <I>Caption 
</I>property of each individual Column object, as well as its 
<I>DataField </I>property, which contains the name of the field in 
the data source to which the column is bound.</P>

<p>The Format tab allows you to set the <I>DataFormat 
</I>property of each Column object, using the same dialog box used for individual bound controls. Typically, 
you use this tab to format numbers, currency values, dates, and times. You can also 
use a custom format, if needed. The settings on this tab are reflected in the 
<I>DataFormat </I>property of individual Column objects at run time. A few other properties of 
Column objects, which will be described later, are set on the Layout tab.</P>

<A NAME="677"><h3>The Splits tab</h3></A>

<p>If the grid is subdivided into two or more split areas, you can set the attributes 
for these areas in the Splits tab. You can't create new splits in this property page, 
but you act on the fields in this page to set each split's appearance and behavior. 
(Creating a new split is described in the &quot;<A HREF="ch15c.htm#674">Editing the Column Layout</A>&quot; section earlier 
in this chapter.)</P>

<p>To modify the attributes of a split, you have to select it in the upper 
drop-down list. If the grid isn't split, there will be only one item in the drop-down list, the 
<I>Split 0 </I>item, and your setting will affect the entire grid control. You can set the 
<I>Locked </I>property to True to turn the DataGrid into a read-only control. The 
<I>AllowFocus </I>property determines whether the split can receive the focus (it's similar to the 
<I>TabStop </I>property of individual Visual Basic controls). The 
<I>AllowSizing </I>property determines whether the split can be interactively resized with the mouse at run time. 
If <I>AllowRowResizing </I>is True, the user can resize rows in this split by using the 
mouse. (Resize operations affect all the rows in all the splits because the DataGrid 
control doesn't support rows with different heights.) The 
<I>RecordSelectors </I>property determines whether there is a gray column for displaying record selectors on the left side of 
the split (or the whole grid).</P>

<p>You can control whether multiple splits vertically scroll together or 
independently of one another by using the <I>ScrollGroup 
</I>property of the Split object, which is an integer greater than or equal to 1. All the splits with the same value scroll 
together, so you can create splits that scroll independently by assigning different values to 
this property. The <I>ScrollBars </I>property affects the presence or absence of scroll bars in 
a particular split and takes one of the following values: 0-dbgNone, 
1dbgHorizontal, 2-dbgVertical, 3-dbgBoth, and 4-dbgAutomatic. (The default is 
4dbgAutomatic&#8212;show a scroll bar only if necessary.) If you have a group of Split objects that scroll 
together and the <I>ScrollBars </I>property of each is set to 4dbgAutomatic, only the rightmost 
split of the group will show a vertical scroll bar.</P>

<p>The <I>MarqueeStyle </I>property determines how the DataGrid control 
highlights the currently selected cell. This property can have one of the following 
values: 0dbgDottedCellBorder (a dotted border around the cell, also known as a focus 
rectangle, is used), 1-dbgSolidCellBorder (a solid border is used, which is usually more 
visible than a dotted border),<I> </I>2-dbgHighlightCell (text and background color are 
inverted), 3-dbgHighlightRow (the entire row is highlighted&#8212;this is useful only when the 
grid or the split isn't editable), 4-dbgHighlightRowRaiseCell (similar to the previous one, 
but the current cell appears to be raised), 5-dbgNoMarquee (the current cell isn't 
highlighted in any way), or 6-dbgFloatingEditor (the default&#8212;the current cell is highlighted 
using a floating editor window with a blinking cursor, as in Microsoft Access).</P>

<p>The <I>AllowRowSizing</I>, <I>MarqueeStyle</I>, and 
<I>RecordSelectors </I>properties are exposed by the DataGrid control as well as its Split objects. Setting one of these 
properties for the DataGrid control has the same effect as setting the same property for all 
its Split objects.</P>

<p>The last two properties shown in the Splits tab work together to determine 
how many columns are visible in the split and whether they are resized to fit in the 
visible area. More precisely, the <I>Size </I>property can be assigned a numeric value 
whose meaning depends on the <I>SizeMode </I>property. If 
<I>SizeMode </I>is 0-dbgScalable, <I>Size </I>contains an integer that corresponds to the width of that split with respect to other 
scalable splits; for example, if you have two splits with 
<I>Size </I>= 1 and <I>Size </I>= 2, respectively, the first split will take one third of the grid's width and the second split will take 
the remaining two thirds. If <I>SizeMode </I>is 1-dbgExact, then 
<I>Size </I>is a floating-point number that corresponds to the split's exact width in twips; this setting ensures that 
the split always has the same width, whether other splits are added or removed.</P>

<A NAME="678"><h3>The Layout tab</h3></A>

<p>In the Layout tab, you can set column attributes on a split-by-split basis. The 
DataGrid control, in fact, allows you to display the same column with different attributes in 
different splits. For example, a column can be read-write in one split and read-only 
in another; or it can be invisible in some of the splits and visible in others. You set 
the read-only attribute with the <I>Locked </I>property and the visibility attribute with the 
<I>Visible </I>property. The <I>AllowSizing </I>Boolean property determines if the right border of 
the column can be dragged to resize the column's width. The 
<I>WrapText </I>Boolean property causes the text in the cell to wrap to the next row if necessary: 
You can use this property with the <I>RowHeight 
</I>property to produce multiline displays. The 
<I>Button </I>property, if set to True, causes a button for a drop-down menu to appear in the cell 
when it gets the focus. When the user clicks on this button, the DataGrid control 
receives a <I>ButtonClick</I> event, to which you typically react by dropping down a list of 
values using a standard ComboBox, a bound ListBox, or even another DataGrid control.</P>

<p>The <I>DividerStyle</I> property affects the style of the vertical line on the right 
border of a column and can be one of the following values: 0-dbgNoDividers, 
1dbgBlackLine, 2-dbgDarkGrayLine (the default), 3-dbgRaised, 4-dbgInset, 
5dbgUseForeColor, or 6-dbgLightGrayLine. The <I>Alignment 
</I>property sets the alignment of the contents of the column and can be 0-dbgLeft, 1-dbgRight, 2-dbgCenter, or 3-dbgGeneral. 
(By default, text is left-aligned and numbers are right-aligned.) The 
<I>Width </I>property specifies the width of each Column object, expressed in the units of the DataGrid's container.</P>

<A NAME="679"><h2>Run-Time Operations</h2></A>

<p>The DataGrid control is complex and is likely to demand some time from you 
before you're familiar with it. I'll outline the most common operations that you 
might want to perform on it, together with a few tricks to get the most out of this object.</P>

<A NAME="680"><h3>Working with the current cell</h3></A>

<p>The most important run-time properties of the DataGrid control are 
<I>Row </I>and <I>Col</I>, which set or return the position of the cell in the focus rectangle. The first row 
and the leftmost column return zero values. Once you make a given cell the current 
cell, you can retrieve and modify its contents using the DataGrid's 
<I>Text </I>property:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Convert the current cell's contents to uppercase.
Private Sub cmdUppercase_Click()
    DataGrid1.Text = UCase$(DataGrid1.Text)
End Sub
</pre>
</td></tr>
</table>
</p>


<p>The <I>EditActive </I>property returns True if the current cell is being edited and 
False otherwise; you can also assign a value to this property to enter or exit edit 
mode programmatically. When the edit mode is entered, a 
<I>ColEdit </I>event is triggered:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Save the current cell value before editing.
Private Sub DataGrid1_ColEdit(ByVal ColIndex As Integer)
    ' SaveText is a module-level variable.
    SaveText = DataGrid1.Text
End Sub
</pre>
</td></tr>
</table>
</p>


<p>You can determine whether the current cell has been modified by querying 
the <I>CurrentCellModified </I>property, and you can also set this property to False and 
then set <I>EditActive </I>to False to completely cancel the edit operation. The 
<I>CurrentCellVisible</I> property is exposed by both the DataGrid and Split objects; it returns True if 
the current cell is visible in the object. If you set a Split's 
<I>CurrentCellVisible </I>property to True, the Split scrolls until the cell becomes visible; if you set the DataGrid 
control's <I>CurrentCellVisible </I>property to True, all the splits scroll to make the cell visible. 
While the current cell is being edited, you can also read and modify the grid's 
<I>SelStart,</I> <I>SelLength, </I>and <I>SelText 
</I>properties, as you would do with a regular TextBox control.</P>

<p>Because the DataGrid control is always bound to an ADO data source, 
the <I>Bookmark </I>property, which sets or returns the bookmark to the current record, is 
often more useful than the <I>Row </I>property. Even more interesting, whenever the user 
moves to another row, the current record in the underlying Recordset object 
automatically changes to reflect the new current cell. Thus, you can retrieve additional fields 
from the Recordset by simply querying the Recordset's 
Fields<I> </I>collection. The following code assumes that the DataGrid control is bound to an ADO Data control:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Display the current product's unit price in Euro currency.
' The RowColChange event fires when a new cell becomes current.
Private Sub DataGrid1_RowColChange(LastRow As Variant, _
    ByVal LastCol As Integer)
    ' The DOLLAR_TO_EURO_RATIO variable is defined elsewhere in the module.
    lblEuroPrice = Adodc1.Recordset(&quot;UnitPrice&quot;) * DOLLAR_TO_EURO_RATIO
End Sub
</pre>
</td></tr>
</table>
</p>


<p>The DataGrid control's <I>Split </I>property returns an integer in the range 0 
through <I>Splits.Count-1</I>, which points to the split section that contains the current cell. You 
can also assign a new value to this property to move the focus to another split. When 
a grid is split into more sections, a few properties of the DataGrid control&#8212;such 
as <I>RecordSelectors </I>and <I>FirstRow</I>&#8212;are equivalent to the same properties exposed by 
the current split. In other words:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The following statements are equivalent.
DataGrid1.RecordSelectors = True
DataGrid1.Splits(DataGrid1.Split).RecordSelectors = True
</pre>
</td></tr>
</table>
</p>


<A NAME="681"><h3>Accessing other cells</h3></A>

<p>There are a few properties that let you retrieve and set the properties of any cell 
in the grid, but you have to use them in a way that isn't always intuitive. Each 
column object exposes the <I>Text </I>and <I>Value 
</I>properties: The former sets or returns the 
text displayed in the column for the current row, while the latter is the actual value 
in the column for the current row before it's formatted for display to the user. 
The Column object also exposes the <I>CellText 
</I>and <I>CellValue </I>methods, which return the contents of a cell in that column for any row, given its bookmark. There are 
several ways to retrieve the bookmark relative to a row, as I'll show you in a moment.</P>

<p><I>VisibleRows </I>and <I>VisibleCols </I>are read-only properties that return the number 
of visible rows and columns, respectively. There are no properties that directly 
return the total number of rows and columns. You can use the 
<I>ApproxCount </I>property, which returns the approximate number of rows; this number might differ from the 
actual value. To retrieve the number of columns, you must query the 
<I>Count </I>property of the Columns<I> </I>collection.</P>

<p>The DataGrid object exposes two methods that let you access the bookmark 
of any row in the control. <I>GetBookmark</I> returns a bookmark of a row relative to the 
current row: <I>GetBookmark(0) </I>is the same as the 
<I>Bookmark</I> property, <I>GetBookmark(-1) </I>is 
the bookmark of the row preceding the current row, 
<I>GetBookmark(1)</I> is the bookmark of the row following the current row, and so on. The other available 
method, <I>RowBookmark</I>,<I> </I>returns the bookmark of any visible row:
<I>RowBookmark(0) </I>is the bookmark of the first visible row, and 
<I>RowBookmark(VisibleRows-1) </I>is the bookmark of the last visible row.</P>

<p>The bookmark of the first row is also returned by the 
<I>FirstRow </I>property. According to the documentation, you can assign a new bookmark to this property 
to programmatically scroll the grid's contents, but I found that I always get an 
&quot;Invalid bookmark&quot; error when I try to assign a value to it. The 
<I>LeftCol </I>property holds the index of the first visible column, so you can programmatically display the upper left 
corner of the grid using the code shown below.</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>DataGrid1.LeftCol = 0
Adodc1.Recordset.MoveFirst
DataGrid1.CurrentCellVisible = True
</pre>
</td></tr>
</table>
</p>


<p>The <I>FirstRow</I>, <I>LeftCol</I>,<I> </I>and 
<I>CurrentCellVisible </I>properties are also exposed by 
the Split object; here, also, assigning a value to the 
<I>FirstRow </I>property without raising an error appears impossible.</P>

<p>You can use the value returned by any of the preceding bookmark methods 
as an argument of the Column object's <I>CellText 
</I>and <I>CellValue </I>methods, described previously. For example, this code displays the difference in the Total field 
between the current row and the row that precedes the current row:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub DataGrid1_RowColChange(LastRow As Variant, _
    ByVal LastCol As Integer)
    Dim gcol As MSDataGridLib.Column
    If DataGrid1.Row &gt; 0 Then
        ' Get a reference to the current column.
        Set gcol = DataGrid1.Columns(&quot;Total&quot;)
        ' Display the difference between the values in the &quot;Total&quot; column
        ' of the current row and the cell immediately above it.
        Label1 = gcol.CellValue(DataGrid1.GetBookmark(-1)) - gcol.Value
    Else
        Label1 = &quot;(First Row)&quot;
    End If
End Sub
</pre>
</td></tr>
</table>
</p>


<A NAME="682"><h3>Managing cell selections</h3></A>

<p>Users can select any number of adjacent columns by clicking on the column 
headers while keeping the Shift key pressed; they can also select any number of 
rows&#8212;even nonadjacent ones&#8212;by clicking on the leftmost gray column while keeping 
the Ctrl key pressed. (Multiple row selection, therefore, requires that the grid's or the 
split's <I>RecordSelectors </I>property is set to True.) The 
<I>SelStartCol </I>and <I>SelEndCol </I>properties set and return the indices for the first and last selected columns, respectively. 
You can clear the column selection by setting these properties to 
<I>-</I>1, or by invoking the <I>ClearSelCols </I>method. These properties and this method are also exposed by 
the Split object.</P>

<p>Because the user can select nonadjacent rows, the system to determine 
which rows are currently highlighted is based on the DataGrid control's 
<I>SelBookmarks </I>collection, which contains the bookmarks of all the selected rows. For example, to 
select the current row, execute the following statement:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>DataGrid1.SelBookmarks.Add DataGrid1.Bookmark
</pre>
</td></tr>
</table>
</p>


<p>You can iterate on all the selected rows using a 
<I>For Each </I>loop. For example, the following code takes advantage of the 
<I>SelChange </I>event&#8212;which fires any time a column or a row is selected or deselected&#8212;to update a Label control with the 
sum of all the cells in the Total column for the rows that are currently selected:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub DataGrid1_SelChange(Cancel As Integer)
    Dim total As Single, bmark As Variant
    For Each bmark In DataGrid1.SelBookmarks
        total = total + DataGrid.Columns(&quot;Total&quot;).CellValue(bmark)
    Next
    lblGrandTotal = total
End Sub
</pre>
</td></tr>
</table>
</p>


<p>There's no method that programmatically clears selected rows; you can do this only by removing all the items in the <I>SelBookmark 
</I>collection, as in the following code:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Do While DataGrid1.SelBookmarks.Count
    DataGrid1.SelBookmarks.Remove 0
Loop
</pre>
</td></tr>
</table>
</p>


<A NAME="683"><h3>Monitoring edit operations</h3></A>

<p>The DataGrid control has a rich collection of events that let you trap nearly every 
user action. Almost all these events are in the form 
<I>Before</I>xxxx and <I>After</I>xxxx, where 
<I>Before</I>xxxx events receive a <I>Cancel</I> parameter that you can set to True to cancel 
the operation. We've already seen the <I>ColEdit 
</I>event, which fires whenever a value in a cell is edited by pressing a key. This event is actually preceded by the 
related <I>BeforeColEdit </I>event, which lets you selectively make a cell read-only:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Refuse to edit a cell in the first column if it already contains a value.
Private Sub DataGrid1_BeforeColEdit(ByVal ColIndex As Integer, _
    ByVal KeyAscii As Integer, Cancel As Integer)
    ' Note how you can test Null values and empty strings at the same time.
    If ColIndex = 0 And DataGrid1.Columns(ColIndex).CellValue _
        (DataGrid1.Bookmark) &amp; &quot;&quot; &lt;&gt; &quot;&quot; Then
        Cancel = True
    End If 
End Sub
</pre>
</td></tr>
</table>
</p>


<p>If you cancel the edit operation in the <I>BeforeColEdit 
</I>event, the control doesn't receive any other event for this operation, which might be disorienting if 
you're accustomed to the ADO way of raising events, where a postnotification event 
fires even if the code in the prenotification event cancels the operation. The 
<I>KeyAscii </I>parameter contains the code of the key pressed to enter edit mode, or 0 if the 
user entered edit mode with a click of the mouse. Because this parameter is passed 
by value, you can't alter it. This isn't a problem, however, because the grid also 
receives all the usual <I>KeyDown</I>, 
<I>KeyPress</I>,<I> </I>and <I>KeyUp </I>events, which let you modify the 
value of the parameter that contains the code for the key the user pressed.</P>

<p>Any time you modify a value in a cell, the DataGrid control receives a 
<I>Change </I>event; if the edit operation actually modifies the value in a cell&#8212;that is, if you 
don't cancel it with the Esc key&#8212;the control also receives the 
<I>BeforeColUpdate</I> and <I>AfterColUpdate</I> events:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub DataGrid1_BeforeColUpdate(ByVal ColIndex As Integer, _
    OldValue As Variant, Cancel As Integer)
    ' Trap invalid values here.
End Sub
</pre>
</td></tr>
</table>
</p>


<p>But watch out for a quirk in the procedure. You can't access the value that 
is about to be entered in the grid by using the 
<I>Text </I>or <I>Value </I>properties of the 
DataGrid or the Column, because within this event procedure these properties return the 
value that was originally in the grid cell&#8212;that is, the same value returned by the 
<I>OldValue </I>parameter. It turns out that the DataGrid's 
<I>Text </I>property returns the string entered by the user only when the 
<I>EditActive </I>property is True, but this property has 
already been reset to False when processing the 
<I>BeforeColUpdate </I>event. The solution is to declare a form-level variable and assign it a value from within the 
<I>Change </I>event. For example, this code correctly checks that the value being entered isn't duplicated 
in any other record of the Recordset:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim newCellText As String

' Remember the most recent value entered by the user.
Private Sub DataGrid1_Change()
    newCellText = DataGrid1.Text
End Sub

' Check that the user isn't entering a duplicate value for that column.
Private Sub DataGrid1_BeforeColUpdate(ByVal ColIndex As Integer, _
    OldValue As Variant, Cancel As Integer)
    Dim rs As ADODB.Recordset, fldName As String
    ' Retrieve the field name for the current column.
    fldName = DataGrid1.Columns(ColIndex).DataField
    ' Search for the new value in the Recordset. Use a clone Recordset
    ' so that the current bookmark doesn't change.
    Set rs = Adodc1.Recordset.Clone
    rs.MoveFirst
    rs.Find fldName &amp; &quot;='&quot; &amp; newCellValue &amp; &quot;'&quot;
    ' Cancel the operation if a match has been found.
    If Not rs.EOF Then Cancel = True
End Sub
</pre>
</td></tr>
</table>
</p>


<p><DIV CLASS="NOTE"><BLOCKQUOTE><B>NOTE</B><HR>
This &quot;quirk&quot; is officially a bug, described in article Q195983 of 
the Microsoft Knowledge Base. However, the workaround shown here is simpler 
than the solution suggested in that article, which relies on the grid's 
<I>hWndEditor </I>property and the <I>GetWindowText 
</I>API function.
</BLOCKQUOTE></DIV></P>

<P>When the user moves to another row, a pair of <I>BeforeUpdate 
</I>and <I>AfterUpdate </I>events fire, and you have an opportunity to perform record-level validation 
and optionally reject the update. Here's the complete sequence of events that fire 
when the user edits a value in a column and then moves to the next or previous grid row:</P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR>
<TD VALIGN="TOP"><I>KeyDown</I></TD>
<TD VALIGN="TOP">The user presses a key.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>KeyPress</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>BeforeColEdit</I></TD>
<TD VALIGN="TOP">The grid enters edit mode.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>ColEdit</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>Change</I></TD>
<TD VALIGN="TOP">Now you can read the new value using the Text property. Here the <I>ActiveEdit </I>property becomes True.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>KeyUp</I></TD>
<TD VALIGN="TOP">The first key is released.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>KeyDown</I></TD>
<TD VALIGN="TOP">Another key is pressed.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>KeyPress</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>Change</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>KeyUp</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"></TD>
<TD VALIGN="TOP">Other keys are pressed.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>BeforeColUpdate</I></TD>
<TD VALIGN="TOP">The user moves to another column.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>AfterColUpdate</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>     
<TD VALIGN="TOP"><I>AfterColEdit</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>RowColChange</I></TD>
<TD VALIGN="TOP">This event fires only when the move is complete.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>BeforeUpdate</I></TD>
<TD VALIGN="TOP">The user moves to another row.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>AfterUpdate</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>RowColChange</I></TD>
<TD VALIGN="TOP">This event fires only when the move is complete.</TD>
</TR>
</TABLE></P>
    

   

<p><DIV CLASS="CAUTION"><BLOCKQUOTE><B>CAUTION</B><HR>
Be very careful with the code you place in the event procedures 
of a DataGrid control. To begin with, a few of these events, such as 
<I>RowColChange</I>, might fire multiple times if the grid is currently split into two or more 
areas, so you should avoid executing the same statements more than once. 
The <I>RowColChange </I>event, moreover, doesn't fire if the current record changes 
programmatically to a row that isn't fully visible; in this case, the grid correctly 
scrolls to make the new current record visible, but the event doesn't fire. This 
problem also occurs when the user moves to a record that isn't fully visible by using 
the buttons of the companion ADO Data control.
</BLOCKQUOTE></DIV></P>

<A NAME="684"><h3>Performing insert and delete operations</h3></A>

<p>The user can delete one or more rows by selecting them and then pressing the 
Delete key. This operation fires the <I>BeforeDelete 
</I>event (where you can cancel the command) and 
<I>AfterDelete </I>event, and then a <I>BeforeUpdate 
</I>and <I>AfterUpdate </I>pair of events. For example, you can write code in the 
<I>BeforeDelete </I>event procedure that checks 
whether the current record is the master record in a master-detail relationship, and 
either cancels the operation (as the following code illustrates) or automatically deletes 
all the related detail records.</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub DataGrid1_BeforeDelete(Cancel As Integer)
    Dim rs As ADODB.Recordset, rsOrderDetails As ADODB.Recordset
    ' Get a reference to the underlying Recordset
    Set rs = Adodc1.Recordset
    ' Use the connection to perform a SELECT command that checks whether
    ' there is at least one record in the Order Details table that has
    ' a foreign key that points to the ProductID value of current record.
    Set rsOrderDetails = rs.ActiveConnection.Execute _
        (&quot;Select * FROM [Order Details] WHERE [Order Details].ProductID=&quot; _
        &amp; rs(&quot;ProductID&quot;))
    ' If EOF = False, there is a match, so cancel the delete command.
    If Not rsOrderDetails.EOF Then Cancel = True
End Sub
</pre>
</td></tr>
</table>
</p>


<p>If you cancel the delete command, the DataGrid control displays an 
error message. You can suppress this and other error messages from the control by 
trapping its <I>Error</I> event:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub DataGrid1_Error(ByVal DataError As Integer, _
    Response As Integer)
    ' DataError = 7011 means &quot;Action canceled&quot;
    If DataError = 7011 Then
        MsgBox &quot;Unable to delete this record because there are &quot; _
            &amp; &quot;records in the Order Details table that point to it.&quot;
        ' Cancel the standard error processing by setting Response = 0.
        Response = 0
    End If
End Sub
</pre>
</td></tr>
</table>
</p>


<p>Upon entry into this event, the <I>DataError 
</I>parameter contains the error code, whereas the 
<I>Response </I>parameter contains 1; you can prevent the grid from 
displaying the standard error message by setting the 
<I>Response</I> parameter to 0, as the previous example demonstrates. You can also test the standard error message by 
means of the DataGrid's <I>ErrorText </I>property.</P>

<P>If the <I>AllowAddNew </I>property is True, the DataGrid control displays a blank 
row at its bottom, marked with an asterisk, and the user can enter a new row&#8212;and 
therefore a new record in the underlying recordset&#8212;simply by typing a character in 
one of the cells in this row. When this happens, the control fires a 
<I>BeforeInsert </I>event, immediately followed by an 
<I>AfterInsert </I>event (unless you cancel the command), 
and then an <I>OnAddNew </I>event. The exact event sequence is as follows:</P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR>
<TD VALIGN="TOP"><I>BeforeInsert</I></TD>
<TD VALIGN="TOP">The user clicks on the last row.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>AfterInsert</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>OnAddNew</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>RowColChange</I></TD>
<TD VALIGN="TOP">This event fires only when the move is complete.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>BeforeColEdit</I></TD>
<TD VALIGN="TOP">The user types a key.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>ColEdit</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>Change</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>Other Change and Key</I>xxx<I> events</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>BeforeColUpdate</I></TD>
<TD VALIGN="TOP">The user moves to another column on the same row.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>AfterColUpdate</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>AfterColEdit</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>RowColChange</I></TD>
<TD VALIGN="TOP">This event fires only when the move is complete. The 
user enters values in other cells on the same row.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>BeforeUpdate</I></TD>
<TD VALIGN="TOP">The user moves to another row.</TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>AfterUpdate</I></TD>
<TD VALIGN="TOP"></TD>
</TR>
<TR>
<TD VALIGN="TOP"><I>RowColChange</I></TD>
<TD VALIGN="TOP">This event fires only when the move is complete.</TD>
</TR>
</TABLE></P>


   

<p>You can monitor the current status using the 
<I>AddNewMode </I>property, which can be assigned one of the following values: 0-dbgNoAddNew (no AddNew 
command is in progress), 1-dbgAddNewCurrent (the current cell is on the last row, but 
no AddNew command is pending), 2-dbgAddNewPending (the current row is in the 
next-to-last row as a result of a pending AddNew command). An AddNew command 
can be initiated either by the user or by code, as the result of assignment to the 
<I>Text </I>or <I>Value </I>properties.</P>

<A NAME="685"><h3>Trapping mouse events</h3></A>

<p>The DataGrid control exposes all the usual mouse events, which are passed the 
mouse coordinates and the state of the shift keys. Unfortunately, the DataGrid control 
doesn't support OLE drag-and-drop operations, so you won't find the usual 
<I>OLE</I>xxxx properties, methods, and events. When working with the mouse, you're likely to use 
three methods exposed by the control: the <I>RowContaining 
</I>method, which returns the visible row over which the mouse cursor is located; the 
<I>ColContaining</I> method, which returns the corresponding column number; and finally the 
<I>SplitContaining </I>method, which returns the split number. If the mouse is outside the grid area&#8212;for 
example, when the mouse is over the record selectors area&#8212;these methods return 
-1. Here is an example that uses the <I>ToolTipText 
</I>property to display a ToolTip with the underlying value of the cell under the mouse, which can be especially useful if the 
column is too narrow to display longer strings:</p>

<p><table cellpadding=5 width="95%"><tr><td><pre>
Private Sub DataGrid1_MouseMove(Button As Integer, Shift As Integer, _
    X As Single, Y As Single)
    Dim row As Long, col As Long
    On Error Resume Next
    row = DataGrid1.RowContaining(Y)
    col = DataGrid1.ColContaining(X)
    If row &gt;= 0 And col &gt;= 0 Then
        DataGrid1.ToolTipText = DataGrid1.Columns(col).CellValue _
            (DataGrid1.RowBookmark(row))
    Else
        DataGrid1.ToolTipText = &quot;&quot;
    End If
End Sub
</pre>
</td></tr>
</table>
</p>


<A NAME="686"><h3>Changing the grid layout</h3></A>

<p>You can programmatically change the layout of a DataGrid control by using one 
of the many properties and methods of the 
Splits and Columns collections. For 
example, you can add a new column using the <I>Columns.Add 
</I>method, as follows:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Add a Product Name column. (It will become the 4th column.)
With DataGrid1.Columns.Add(3)
    .Caption = &quot;Product Name&quot;
    .DataField = &quot;ProductName&quot;
End With
' You need to rebind the grid after adding a bound column.
DataGrid1.ReBind
</pre>
</td></tr>
</table>
</p>


<p>You can also remove a column from the layout, using the 
<I>Columns.Remove </I>method:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Remove the column added by the previous code snippet.
DataGrid1.Columns.Remove 3
</pre>
</td></tr>
</table>
</p>


<p>Adding a split requires that you use the <I>Splits.Add 
</I>method. The argument you pass to this method is the position of the new split (0 for the leftmost split in the grid):</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Add a new split to the left of all existing splits.
DataGrid1.Splits.Add 0
</pre>
</td></tr>
</table>
</p>


<p>After you create a split, you have to decide which columns are visible in 
it. Because each new split inherits all the columns from the grid, removing a 
column from one split would remove it from all the other splits, as described in the 
&quot;<A HREF="ch15c.htm#674">Editing the Column Layout</A>&quot; section earlier in this chapter. Rather than deleting 
unwanted columns, make them invisible, as illustrated by the following code:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Add a new split to the right of the existing split.
With DataGrid1.Splits.Add(1)
    ' Ensure that the two splits divide the grid's width in half.
    ' Assumes that the existing split's SizeMode property is 0-dbgScalable.
    ' (Always set SizeMode before Size!)
    .SizeMode = dbgScalable
    .Size = DataGrid1.Splits(0).Size
    ' This new split can be scrolled independently.
    .ScrollGroup = DataGrid1.Splits(0).ScrollGroup + 1
    ' Hide all the columns except the one labeled &quot;ProductName&quot;.
    For Each gcol In .Columns
        gcol.Visible = (gcol.Caption = &quot;ProductName&quot;)
    Next
End With
</pre>
</td></tr>
</table>
</p>


<A NAME="687"><h3>Dealing with lookup values</h3></A>

<p>Often a value retrieved from a database table isn't meaningful in itself and is 
only useful because it's a foreign key to another table where the real information is. 
For example, the Products table in NWind.mdb includes a SupplierID field, which 
contains the value of a key in the Suppliers table, where you can find the name and 
the address of the supplier for that particular product. When you're displaying the 
Products table in a DataGrid control, you might use a suitable JOIN statement for the 
ADO Data control's <I>RecordSource </I>property so that the grid automatically displays the 
correct supplier name instead of its key.</P>

<P>The ADO binding mechanism, however, provides you with a better 
alternative. The trick is to declare a custom StdDataFormat object, assign it to the 
<I>DataFormat</I> property of a Column object, and then use the 
<I>Format </I>event to transform the numeric key values coming from the data source into more descriptive strings of text. 
The following routine loads all the values from the secondary table (also known as 
the <I>lookup table</I>) into a hidden ComboBox control. The routine then uses the 
contents of that control in the <I>Format </I>event of the custom StdDataFormat object to 
translate the SupplierID key into the supplier's CompanyName field:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim WithEvents SupplierFormat As StdDataFormat

Private Sub Form_Load()
    ' Load all the values from the Supplier lookup table into the
    ' hidden cboSuppliers ComboBox control.
    Dim rs As New ADODB.Recordset
    rs.Open &quot;Suppliers&quot;, Adodc1.Recordset.ActiveConnection
    Do Until rs.EOF
        cboSuppliers.AddItem rs(&quot;CompanyName&quot;)
        ' The SupplierID value goes into the ItemData property.
        cboSuppliers.ItemData(cboSuppliers.NewIndex) = rs(&quot;SupplierID&quot;)
        rs.MoveNext
    Loop
    rs.Close

    ' Assign the custom format object to the SupplierID column.
    Set SupplierFormat = New StdDataFormat
    Set DataGrid1.Columns(&quot;SupplierID&quot;).DataFormat = SupplierFormat
    ' Make the row height equal to the ComboBox's height.
    DataGrid1.RowHeight = cboSuppliers.Height
End Sub

Private Sub SupplierFormat_Format(ByVal DataValue As _
    StdFormat.StdDataValue)
    Dim i As Long
    ' Search the key value in the cboSuppliers ComboBox.
    For i = 0 To cboSuppliers.ListCount - 1
        If cboSuppliers.ItemData(i) = DataValue Then
            DataValue = cboSuppliers.List(i)
            Exit For
        End If
    Next
End Sub
</pre>
</td></tr>
</table>
</p>


<p>Using the ComboBox control as a repository for the contents of the lookup 
table isn't a casual decision. In fact, with some wizardry we can even use the 
ComboBox to let the user select a new value for the SupplierID field. All we have to do is 
make the ComboBox control appear in front of the DataGrid control, exactly over the 
cell edited by the user, and then update the underlying SupplierID field when the 
user selects a new value from the list. For the best visual effect, you also need to trap 
a few events so that the ComboBox is always in the correct position, as in Figure 15-4. Here's the code that does the trick:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub MoveCombo()
    ' In case of error, hide the ComboBox.
    On Error GoTo Error_Handler
    Dim gcol As MSDataGridLib.Column
    Set gcol = DataGrid1.Columns(DataGrid1.col)
    
    If gcol.Caption = &quot;SupplierID&quot; And DataGrid1.CurrentCellVisible Then
        ' Move the ComboBox inside the SupplierID column
        ' if it is the current column and it is visible.
        cboSuppliers.Move DataGrid1.Left + gcol.Left, _
            DataGrid1.Top + DataGrid1.RowTop(DataGrid1.row), gcol.Width
        cboSuppliers.ZOrder
        cboSuppliers.SetFocus
        cboSuppliers.Text = gcol.Text
        Exit Sub
    End If
Error_Handler:
    ' In all other cases, hide the ComboBox.
    cboSuppliers.Move _10000
    If DataGrid1.Visible Then DataGrid1.SetFocus
End Sub

Private Sub cboSuppliers_Click()
    ' Change the value of the underlying grid cell.
    DataGrid1.Columns(&quot;SupplierID&quot;).Value = _
        cboSuppliers.ItemData(cboSuppliers.ListIndex)
End Sub

Private Sub DataGrid1_RowColChange(LastRow As Variant, _
    ByVal LastCol As Integer)
    MoveCombo
End Sub

Private Sub DataGrid1_RowResize(Cancel As Integer)
    MoveCombo
End Sub

Private Sub DataGrid1_ColResize(ByVal ColIndex As Integer, _
    Cancel As Integer)
    MoveCombo
End Sub

Private Sub DataGrid1_Scroll(Cancel As Integer)
    MoveCombo
End Sub

Private Sub DataGrid1_SplitChange()
    MoveCombo
End Sub
</pre>
</td></tr>
</table>
</p>


<p>This code requires that the DataGrid control's 
<I>RowHeight </I>property match the ComboBox's <I>Height 
</I>property. Because the latter is read-only at run time, execute 
the following statement in the <I>Form_Load </I>event procedure:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Have the row height match the ComboBox's height.
DataGrid1.RowHeight = cboSuppliers.Height
</pre>
</td></tr>
</table>
</p>


<p>Another approach to lookup tables is based on the 
<I>Button </I>property of the Column object and the 
<I>ButtonClick </I>event. In this case, however, you get a better 
visual result if you display a ListBox (or DataList) control just under the current cell, 
rather than displaying a ComboBox or DataCombo control over the cell. Since the 
implementation of this latter method is similar to what I've shown previously, I leave it 
to you as an exercise.</P>


<p>
<A HREF="javascript:fullSize('F15ph04x.htm')"> <img src="images/F15ph04.JPG" width=404 height=284 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 15-4.</B> <I>The demonstration application uses lookup fields with drop-down ComboBoxes and supports splits, sort commands, and more.</i><!--/caption-->
</p>

<A NAME="688"><h3>Sorting data</h3></A>

<p>The DataGrid control doesn't offer any built-in functionality for sorting data. 
However, thanks to its <I>HeadClick </I>event and the ADO Recordset's 
<I>Sort </I>property, sorting data is an easy task that requires only a handful of statements:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub DataGrid1_HeadClick(ByVal ColIndex As Integer)
    ' Sort on the clicked column.
    Dim rs As ADODB.Recordset
    Set rs = Adodc1.Recordset
    
    If rs.Sort &lt;&gt; DataGrid1.Columns(ColIndex).DataField &amp; &quot; ASC&quot; Then
        ' Sort in ascending order; this block is executed if the
        ' data isn't sorted, is sorted on a different field,
        ' or is sorted in descending order.
        rs.Sort = DataGrid1.Columns(ColIndex).DataField &amp; &quot; ASC&quot;
    Else
        ' Sort in descending order.
        rs.Sort = DataGrid1.Columns(ColIndex).DataField &amp; &quot; DESC&quot;
    End If
    ' No need to refresh the contents of the DataGrid.
End Sub
</pre>
</td></tr>
</table>
</p>


<p>The only limitation of this approach is that it doesn't work well if the 
column contains lookup values.</P>

</BODY>
</HTML>





