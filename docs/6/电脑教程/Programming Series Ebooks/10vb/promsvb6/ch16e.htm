<HTML>
<HEAD>
<TITLE>Multithreaded ActiveX Components</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch16d.htm", "ch16f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="778"><h1>Multithreaded ActiveX Components</h1></A>
<p>Both Visual Basic 5 and 6 can create multithreaded ActiveX components. 
Components built with the first release of Visual Basic 5, however, could only support 
multithreading if they had no user interface, which is a serious limitation in some cases. 
This restriction was lifted in Service Pack 2.</p>

<A NAME="779"><h2>Threading Models</h2></A>
<p>In a nutshell, multithreading is the ability to execute different code portions of 
an application at the same time. Many popular Windows applications are 
multithreaded. For example, Microsoft Word uses at least two threads, and the Visual Basic 
environment uses five threads. Multiple threads are a good choice when you need to 
execute complex tasks in the background (for example, paginating a document) or 
when you want to keep the user interface responsive even when your application is 
doing something else. Multiple threads are especially necessary when you're 
building <I>scalable </I>remote components that have to serve hundreds of clients at the same time.</p>

<p>There are two main types of threading models: <I>free threading 
</I>and <I>apartment threading</I>. In the free-threading model, each thread can access the entire 
process's data area and all threads share the application's global variables. Free threading 
is powerful and efficient, but it's a nightmare even for most experienced 
programmers because you must arbitrate among all the shared resources, including variables. 
For example, even an innocent statement such as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
If x &gt; 1 Then x = x - 1    ' X should always be greater than 1.
</pre>
</td></tr>
</table></p>

<p>can create problems. Imagine this scenario: Thread A reads the value of the 
<I>x </I>variable and finds that it is 2, but before it executes the Then portion of the 
statement, the CPU switches to Thread B. Thread B happens to be executing the same 
statement (an unlikely but not impossible circumstance), finds that 
<I>x </I>is 2, and therefore decrements it to 1. When Thread A regains the control of the CPU, it decrements the 
variable to 0, which is an invalid value that will probably cause other logic errors 
later in the program's life.</p>

<p>The apartment-threading model solves these problems by encapsulating 
each thread in an <I>apartment</I>. Code executed in a given apartment can't access 
variables belonging to other apartments. Each apartment has its own set of variables, so if 
two threads are accessing the <I>x </I>variable at the same time, they're actually referencing 
two different memory locations. This mechanism neatly solves the synchronization 
problem described earlier, and for this reason the apartment-threading model is 
inherently safer than the free-threading model. In Visual Basic, you can build ActiveX 
components that support the apartment model only.</p>

<A NAME="780"><h2>Multithreaded ActiveX EXE Components</h2></A>
<p>Visual Basic 5 and 6 let you create out-of-process servers that create an 
additional thread when a client instantiates a new object. All you need to do to transform 
a regular ActiveX EXE component into a multithreaded component is select an 
option in the General tab of the Project Properties dialog box. (See Figure 16-18.) There 
are three possible settings. The default setting is the Thread Pool option with 1 
thread; this corresponds to a single-threaded component.</p>

<p>
<img src="images/f16ph18x.gif" width=418 height=377 border=0>
</p><p>
<!--caption--><B>Figure 16-18.</B> <i>Create a multithreaded component with a few mouse clicks in the Project Properties dialog box.</i><!--/caption-->
</p>

<p>If you select the Thread Per Object option, you build a multithreaded 
component that creates a new thread for every object requested by its clients. Because 
all objects are executed in their own threads, no client can ever block another 
client, so these components are highly responsive. The disadvantage of this approach is 
that too many threads can bring even a powerful system to its knees because 
Windows has to spend a lot of time just switching from one thread to the other.</p>

<A NAME="781"><h3>Thread pools</h3></A>
<p>If you select the Thread Pool option and enter a value greater than 1 in the 
Threads field, you build a multithreaded component that's allowed to create only a 
limited number of threads. This is a scalable solution in the sense that you can increase 
the size of the thread pool when you deploy your application on a more powerful 
system. (You need to recompile the application, though.) This setting prevents the 
system from wasting too much time on thread management because the pool can't 
grow larger than the limit you set. To assign threads to objects, the pool uses a 
<I>round robin</I> algorithm, which always tries to assign the first available thread to each new 
request for an object.</p>

<p>Let's say that you created a multithreaded component with a pool size of 
10 threads. When the first client makes a request for an object, COM loads the 
component, which returns the created object in its first thread. When a second client 
makes a request, the component creates an object in a second thread, and so on, until 
the tenth client gets the last available thread in the pool. When the eleventh 
request comes, the component has to return an object in one of the threads that have 
been created previously. The thread used for this new object can't be determined in 
advance because it depends on several factors. For this reason, the round robin 
algorithm is said to be a nondeterministic algorithm.</p>

<p>Here are a few interesting points that concern object pooling. First, when 
there are more objects than threads, each thread can serve more objects, possibly owned 
by different clients. In this situation, a given thread can't execute an object's method if 
it's already serving another object. In other words, an object pool doesn't completely 
prevent objects from blocking one another (as components with one thread per object 
do), even if this problem happens less frequently than with single-threaded components.</p>

<p>Second, once an object has been created in a thread, it must execute in 
that thread; this is a requirement of apartment threading. Therefore, a client might 
be blocked by another client even if the component has some unallocated 
threads. Imagine this scenario: You have a pool with 10 threads, and you instantiate 20 
objects. In an ideal situation, the pool is perfectly balanced and each thread serves 
exactly two objects. But suppose that all the objects served by threads 1 through 9 are 
released while the two objects served by thread 10 aren't. In this case, the pool has 
become highly unbalanced and the two objects will block each other, even if the pool 
has nine available threads.</p>

<p>Finally, even if the apartment model ensures that all apartments have a 
different set of variables, objects in the same thread share the same apartment and 
therefore share the same global values. This might appear to be a cheap way to 
exchange data among objects, but in practice you can't use this technique because you 
can't predict which objects will share the same thread.</p>

<A NAME="782"><h3>The multithreading advantage</h3></A>
<p>Many programmers mistakenly believe that multithreading is always a good 
thing. The truth, however, is that most computers have only one CPU, which has to 
execute all the threads in all the processes in the system. Multithreading is always a 
good thing if you're executing your component on a Windows NT machine with 
multiple CPUs; in this situation, the operating system automatically takes advantage of 
the additional processors to balance the workload. In the most common case, 
however, you're working with a single-processor machine and you might find that 
multithreading can even make your performance worse. This is a somewhat 
counter-intuitive concept, so I'll explain it with an example.</p>

<p>Let's say that you have two threads that execute two different tasks, each 
one taking 10 seconds to complete. In a single-threaded environment, one of the two 
tasks completes in 10 seconds, and the other waits for the first one to complete and 
therefore takes 20 seconds in total. The result is that the average time is 15 seconds 
per task. In a multithreaded environment, the two tasks would execute in parallel 
and will complete more or less at the same time. Unless you have two CPUs, in this 
case the average time is 20 seconds, which is worse than in the single-threaded case.</p>

<p>In summary, multithreading isn't always the best solution. Sometimes, 
however, it clearly offers advantages over single-threading:</p>

<UL>
<p><li> When you're executing tasks of different duration, multithreading is 
often preferable. For example, if you have a task that takes 10 seconds 
and another task that takes only 1 second, in a single-thread environment 
the shorter task might take 1 second or 11 seconds to complete, which 
results in an average time of 6 seconds, while in a multithreaded environment 
it doesn't take more than 2 seconds on average. By comparison, the 
longer task takes 10 or 11 seconds to complete in the single-threaded 
scenario (10.5 seconds on average), whereas it always requires 11 seconds in 
the multithreaded scenario. So the multithreaded scenario is slightly 
disadvantageous for longer tasks, but the user will hardly notice the difference.</li></p>
 
<p><li>When you have some tasks, such as user-interface tasks, that have to 
be responsive, it's better to execute them in a multithreaded environment.</li></p>

<p><li>When you have background tasks with low priority, multithreading is 
also a good choice. A typical example is formatting and spooling a document.</li></p>
</UL>

<p>When you're deciding between single- and multithreading, don't forget 
that Visual Basic applications implicitly use multithreading for some tasks&#8212;for 
example, when printing data. Moreover, some database engines (most notably, the 
Microsoft Jet engine) internally use multithreading.</p>

<A NAME="783"><h3>User-interface issues</h3></A>
<p>Visual Basic 6 lets you create multithreaded components that expose a user 
interface. (You need Service Pack 2 to have this feature work under Visual Basic 5.) You 
can achieve this because all the forms and the ActiveX controls that you create are 
<I>thread safe</I>, which means that multiple instances of them can independently execute 
in different threads. The same is true for ActiveX documents and designers, such 
as the DataEnvironment designer, as well as the majority of the ActiveX controls 
that are in the package&#8212;for example, the MaskEdBox control and all the Windows 
common controls.</p>

<p>But a few ActiveX controls are inherently single-threaded and can't be 
safely used inside multithreaded components&#8212;for example, the Microsoft Chart 
(MSCHRT20.OCX) and Microsoft Data Bound Grid (DBGRID32.OCX) controls. If you attempt to add 
these controls to an ActiveX DLL project whose threading model is Apartment 
Threaded or to an ActiveX EXE project whose threading model is Thread Per Object or 
Thread Pool with a number of threads greater than 1, you get an error and the control 
isn't added to the Toolbox. You also get an error if you have a project that already 
includes one or more single-threaded controls and you change the project type to a value 
that isn't compatible with such controls. When you buy a third-party control, check 
with its vendor to learn whether it supports multithreading.</p>

<p><div class="caution"><blockquote><b>CAUTION</b><hr>
You can force Visual Basic to accept a single-threaded 
ActiveX control in a multithreaded project by manually editing the VBP file. There 
are many reasons not to do that, however. Single-threaded controls running in 
a multithreaded application perform poorly and, above all, can cause many 
problems and unexpected behavior. For example, the Tab key and 
Alt+<I>key </I>combinations don't work as they should, and a click on the control might not 
activate the form. Moreover, there might be some properties (most notably, the 
<I>Picture</I> property) whose values can't be marshaled between different threads, and 
any attempt to do so raises a run-time error.
</blockquote></div></p>

<p>Here are other minor issues concerning forms inside multithreaded components:</p>

<UL>
<p><li> When you use a hidden form variable that Visual Basic creates for 
each form in the application, you're implicitly using a variable that's global 
to the thread but not shared among all the threads. Thus, each thread 
creates a different instance of the form. To avoid confusion, you might 
want to use explicit form variables, as suggested in Chapter 9.</li></p>
 
<p><li>MDI forms aren't allowed in multithreaded EXEs or DLLs because the 
Visual Basic MDI form engine isn't thread safe. For this reason, the Add MDI 
Form command in the Project menu is grayed inside these types of projects.</li></p>

<p><li>A form can be modal only with respect to other forms in the same 
thread, but it's modeless with respect to forms displayed by other threads. 
Consequently, a modal form blocks only the code in its own thread, not 
the code in other threads.</li></p>

<p><li>In a multithreaded component, the <I>Sub 
Main</I> procedure is executed whenever a new thread is created. For this reason, if you need to 
display a form when the component is first created, you can't simply invoke 
a form's <I>Show </I>method from this procedure, and you need to distinguish 
the first component's thread from all the others. See the &quot;<A HREF="ch16e.htm#787">Determining the Main Thread</A>&quot; section later in this chapter.</li></p>

<p><li>DDE between forms works only if the two forms are in the same 
thread. (DDE isn't covered in this book.)</li></p>
</UL>

<A NAME="784"><h3>Unattended execution</h3></A>
<p>If your component doesn't include a form, UserControl, or UserDocument 
module, you can tick the Unattended Execution check box in the General tab of the 
Project Properties dialog box. This indicates that your component is meant to execute 
without any user interaction, a reasonable option when you're creating a component 
to run remotely on another machine.</p>

<p>The Unattended Execution option suppresses any message boxes or other 
kinds of user interface (including error messages) and redirects them to a log file or 
the Windows NT Application Event Log. You can also send your own messages to 
this log file. Using this option is important with remote components because any 
message box would stop the execution of the component until the user closes it, but 
when a component is running remotely no interactive user can actually close the dialog box.</p>

<p>The <I>StartLogging </I>method of the App object lets you select where your 
messages will be sent. Its syntax is as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
App.StartLogging LogFile, LogMode
</pre>
</td></tr>
</table></p>

<p>where <I>LogFile</I> is the name of the file that will be used for logging, and 
<I>LogMode </I>is one of the values listed in Table 16-2. The vbLogOverwrite and vbLogThreadID 
settings can be combined with the other values in the table. When you're sending 
a message to the Windows NT Application Event Log, &quot;VBRunTime&quot; is used as 
the application source and the <I>App.Title </I>property appears in the description. When 
you're running under Windows 95 or 98, messages are sent by default to a file 
named Vbevents.log.</p>

<p><div class="caution"><blockquote><b>CAUTION</b><hr>
Watch out for two bugs. First, if you specify an invalid 
filename, no errors are raised and logged messages silently go to default output. 
Also, the vbLogOverwrite option makes the <I>StartLogging 
</I>method behave as if the vbLogAuto option were specified. So you should always manually delete the 
log file and not rely on the vbLogOverwrite option.
</blockquote></div></p>

<p><B>Table 16-2.</B> <I>All the values for the </I>LogMode <I>argument of the App object's </I>StartLogging <I>method; these are also the possible return values of the </I>LogMode <I>read-only property.</I></p>

<p><table width="95%" cellpadding="5">
<tr>
<th><b><i>Constant</i></b></th>
<th><b><i>Value</i></b></th>
<th><b><i>Description</i></b></th>
</tr>
<tr>
<td valign="TOP">vbLogAuto</td>
<td valign="TOP">0</td>
<td valign="TOP">If running under Windows 95 or 98, messages are logged to the file specified by the <I>LogFile </I>argument; if running under Windows NT, messages are logged to the Windows NT Application Event Log.</td>
</tr>
<tr>
<td valign="TOP">vbLogOff</td>
<td valign="TOP">1</td>
<td valign="TOP">Messages aren't logged anywhere and are simply discarded; message boxes have no effect.</td>
</tr>
<tr>
<td valign="TOP">vbLogToFile</td>
<td valign="TOP">2</td>
<td valign="TOP">Forces logging to file, or turns off logging if no valid file name is passed in the <I>LogFile </I>argument. (In the latter case, the <I>LogMode </I>property is set to vbLogOff.)</td>
</tr>
<tr>
<td valign="TOP">vbLogToNT</td>
<td valign="TOP">3</td>
<td valign="TOP">Forces logging to the Windows NT Application Event Log; if not running under Windows NT or the Event Log is unavailable, it turns off logging and resets the <I>LogMode </I>property to vbLogOff.</td>
</tr>
<tr>
<td valign="TOP">vbLogOverwrite</td>
<td valign="TOP">16</td>
<td valign="TOP">When logging to a file, it re-creates the log file each time the application starts; it has no effect when logging to the Application Event Log. It can be combined with other values in this table using the OR operator.</td>
</tr>
<tr>
<td valign="TOP">vbLogThreadID</td>
<td valign="TOP">32</td>
<td valign="TOP">The current thread ID is added to the beginning of the message in the form &quot;[T:0nnn]&quot;; if this value is omitted, the thread ID is shown only if the message comes from a multithreaded application. It can be combined with other values in this table using the OR operator.
</td>
</tr>
</table></p>

<p>Once you have set up logging, you can log messages using the App 
object's <I>LogEvent </I>method, which has the following syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
App.LogEvent LogMessage, EventType
</pre>
</td></tr>
</table></p>

<p><I>LogMessage </I>is the text of the message, and 
<I>EventType </I>is an optional argument that states the type of the event (one of the following values: 
1-vbLogEventTypeError, 2-vbLogEventTypeWarning, or 4-vbLogEventTypeInformation). For example, 
the following piece of code</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
App.StartLogging &quot;C:\Test.Log&quot;, vbLogAuto 
App.LogEvent &quot;Application Started&quot;, vbLogEventTypeInformation
App.LogEvent &quot;Memory is running low&quot;, vbLogEventTypeWarning
App.LogEvent &quot;Unable to find data file&quot;, vbLogEventTypeError
MsgBox &quot;Press any key to continue&quot;, vbCritical
</pre>
</td></tr>
</table></p>

<p>sends its output to the C:\TEST.LOG file if run under Windows 95 or 98 or to 
the Application Event Log if run under Windows NT. (See Figure 16-19.)</p>

<p>
<A HREF="javascript:fullSize('f16ph19x.htm')"> <img src="images/f16ph19.JPG" width=404 height=146 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 16-19.</B> <i>Logged messages coming from a Visual Basic application as they appear in a log text file (top window) or in the Windows NT Application Event Log (bottom window).</i><!--/caption-->
</p>

<p>You can test the Unattended Execution attribute from code using the 
read-only <I>UnattendedApp </I>property of the App object. Likewise, you can retrieve the current 
log file and log mode using the App object's 
<I>LogPath </I>and <I>LogMode </I>properties, 
respectively. When you've compiled the code using the Unattended Execution attribute, all 
the MsgBox commands send their output to the log file or the Windows NT 
Application Event Log, as if a <I>LogEvent </I>method with the vbLogEventTypeInformation 
argument were issued.</p>

<p>One last note: If you run the program under the Visual Basic IDE, the 
Unattended Execution setting has no effect; all message boxes appear on screen as usual, 
and the <I>App.StartLogging </I>and <I>App.LogEvent 
</I>methods are ignored. To activate logging, you must compile your application to a stand-alone program.</p>

<A NAME="785"><h2>Multithreaded ActiveX DLL Components</h2></A>
<p>You can also create multithreaded ActiveX DLLs using Visual Basic 6. Unlike 
ActiveX EXE servers, however, Visual Basic's DLLs can't create new threads and can only 
use the threads of their clients. For this reason, multithreaded DLLs are most useful 
with multithreaded client applications. Because an ActiveX DLL doesn't actually create 
any thread, the options you have in the Project Properties dialog box are simpler 
than those offered by an ActiveX EXE project. In practice, you only have to decide if 
you want to create a Single Threaded or Apartment Threaded server. (See Figure 16-20.)</p>

<p>Both single- and multithreaded components are thread safe, which means 
that when an object in a thread is called by another thread, the calling thread is 
blocked until the called method returns. This prevents most reentrancy problems and 
greatly simplifies the job of the programmer.</p>

<p>While it's perfectly safe to use a single-threaded DLL with a multithreaded 
client, only one thread in the main application can directly call the methods of an 
object created by the DLL. This particular thread is the first thread created in the 
client application, or more precisely, the first thread that internally called the 
<I>OleInitialize </I>function. All the objects exposed by a single-threaded DLL are created in this 
thread; when they are used from another thread in the client application, arguments 
and return values undergo the so-called <I>cross-thread 
marshaling</I>, which is almost as slow as cross-process marshaling.</p>

<p>
<img src="images/f16ph20x.gif" width=418 height=377 border=0>
</p><p>
<!--caption--><B>Figure 16-20.</B> <i>Selecting the Threading Model option in the Project Properties dialog box.</i><!--/caption-->
</p>

<p>When you don't know how your DLL will be used, selecting an 
Apartment Threaded option is usually the best choice. In fact, a multithreaded DLL can be 
used by single-threaded clients without any problem and without any noticeable 
overhead. In one case a single-threaded DLL can be conveniently used with a 
multithreaded client, namely, when you want to offer a simple way for all the threads in the 
client to communicate and share data with each other. An example of this technique 
is described in the &quot;<A HREF="ch16e.htm#789">Testing a Multithreaded Application</A>&quot; section later in this chapter.</p>

<A NAME="786"><h2>Multithreaded Visual Basic Applications</h2></A>
<p>Many programmers aren't aware that Visual Basic can create multithreaded 
regular applications, not just components. To be honest, creating such multithreaded 
applications isn't as straightforward as using other Visual Basic advanced features, and 
you have to account for a number of important issues.</p>

<p>The trick to creating a multithreaded application is simple: The application 
must be a multithreaded ActiveX EXE server that exposes one or more objects that 
run in different threads. To build such an application, the conditions shown below must be fulfilled.</p>

<UL>
<p><li> The application must be an ActiveX EXE server compiled with the 
Thread Per Object setting.</li></p>
 
<p><li>The code for the task that is intended to run in a different thread is 
embedded in a MultiUse class.</li></p>

<p><li>You create the new object using the <I>CreateObject 
</I>function instead of the <I>New </I>operator.</li></p>
</UL>

<p>When you create an object exposed by the current application using the 
<I>New </I>operator, Visual Basic uses internal instancing, which bypasses COM and creates 
the object using a more efficient mechanism that doesn't undergo any restriction. (In 
fact, you can even create objects from Private or PublicNotCreatable classes.) 
Conversely, when you use <I>CreateObject</I>, Visual Basic always creates the object through COM. 
For this reason, the object should be creatable (MultiUse).</p>

<A NAME="787"><h3>Determining the main thread</h3></A>
<p>As I stated previously, the <I>Sub Main</I> procedure in a multithreaded Visual Basic 
application is executed each time a new thread is created. This isn't usually a problem 
for multithreaded EXE or DLL components, but it's an issue when you're creating 
an ActiveX EXE project that must work as a multithreaded application. In this case, 
it's crucial that you distinguish the first execution from all the subsequent ones: The 
first time the <I>Main </I>procedure executes, the program must create its main window, 
whereas in all other cases the procedure shouldn't display any user interface. More 
precisely, when the procedure is being executed as a result of a request for a new object, 
it should exit as soon as possible to avoid having the request fail with a 
timeout error. For the same reason, you should never execute lengthy operations inside 
the <I>Class_Initialize </I>event procedure.</p>

<p>Understanding whether the <I>Main </I>procedure has never been executed 
before isn't as trivial a task as it might appear at first. You can't simply use a global 
variable as a flag because that variable can't be seen from a thread in another 
apartment. Creating a temporary file in the <I>Main 
</I>procedure isn't a viable solution either 
because the application might terminate with a fatal error and never delete the file.</p>

<p>There are at least two ways to solve this problem. The first one is based on 
the <I>FindWindow </I>API function and is described in the Visual Basic documentation. In 
the following paragraphs, I'll show you an alternative method, which I believe is less 
complex and slightly more efficient because it doesn't require that you create a 
window. This method is based on <I>atom 
objects,</I> which are sort of global variables 
managed by the Windows operating system. The Windows API provides functions that let 
you add a new atom, delete an existing atom, or query for an atom's value.</p>

<p>In the <I>Main </I>procedure of a multithreading application, you test whether a 
given atom exists. If it doesn't exist, this is the first thread of the application, and you 
need to create the atom. To have the mechanism work, you must also destroy the 
atom when you exit the application. This task is ideal for a class that creates the atom 
in its <I>Class_Initialize </I>procedure and destroys it in its 
<I>Class_Terminate </I>procedure. Here's the complete source code of the CThread class in the demonstration application 
on the companion CD:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Private Declare Function FindAtom Lib &quot;kernel32&quot; Alias &quot;FindAtomA&quot; _
    (ByVal atomName As String) As Integer
Private Declare Function AddAtom Lib &quot;kernel32&quot; Alias &quot;AddAtomA&quot; _
    (ByVal atomName As String) As Integer
Private Declare Function DeleteAtom Lib &quot;kernel32&quot; _
    (ByVal atomName As Integer) As Integer
Private atomID As Integer

Private Sub Class_Initialize()
    Dim atomName As String
    ' Build an atom name unique for this instance of the application.
    atomName = App.EXEName &amp; App.hInstance
    ' Create the atom if it doesn't exist already.
    If FindAtom(atomName) = 0 Then atomID = AddAtom(atomName)
End Sub
Private Sub Class_Terminate()
    ' Delete the atom when this thread terminates.
    If atomID Then DeleteAtom atomID
End Sub

Function IsFirstThread() As Boolean
    ' This is the first thread if it was the one which created the atom.
    IsFirstThread = (atomID &lt;&gt; 0)
End Function
</pre>
</td></tr>
</table></p>

<p>The name of the atom is built using the application's name and the 
instance handle (the <I>App.hInstance </I>property). The latter value is different for each 
distinct instance of the same application, which ensures that this method works correctly 
even when the user launches multiple instances of the same executable. The CThread 
class module exposes only one property, 
<I>IsFirstThread</I>. The following code shows how you can use this class in a multithreaded application to understand whether it's 
executing the first thread:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' This is global because it has to live for the entire application's life.
Public Thread As New CThread

Sub Main()
    If Thread.IsFirstThread Then
        ' First thread, refuse to be instantiated as a component.
        If App.StartMode = vbSModeAutomation Then
            Err.Raise 9999, , &quot;Unable to be instantiated as a component&quot;
        End If
        ' Show the user interface.
        frmMainForm.Show
    Else
        ' This is a component instantiated by this same application.
    End If
End Sub
</pre>
</td></tr>
</table>
</p>

<A NAME="788"><h3>Implementing multithreading</h3></A>
<p>Creating a new thread using the <I>CreateObject 
</I>function doesn't suffice to actually implement a multithreaded Visual Basic application. In fact, the 
synchronization mechanism offered by Visual Basic, which usually prevents a series of nasty 
problems, in this case gets in the way. When the program invokes a method of an 
object in another thread, the calling thread is blocked until the method returns. So you 
might have multiple threads, but only one of them is executing at a given time, which 
obviously isn't what you want.</p>

<p>The easy way to work around this issue is using a Timer control to 
&quot;awaken&quot; an object in a separate thread after it has returned the control back to the 
calling thread. You don't need a visible form to achieve this; an invisible form with a 
Timer control on it can do the job. You can take advantage of the new 
<I>CallByName </I>function to create a form module that you can easily reuse in all your applications 
that need this sort of callback mechanism. This is the complete source code of the 
CCallBack form module that encapsulates this functionality:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim m_Obj As Object
Dim m_MethodName As String

Public Sub DelayedCall(obj As Object, Milliseconds As Long, _
    MethodName As String)
    Set m_Obj = obj                       ' Save the arguments.
    m_MethodName = MethodName
    Timer1.Interval = Milliseconds        ' Start the timer.
    Timer1.Enabled = True
End Sub

Private Sub Timer1_Timer()
    Timer1.Enabled = False                ' We need just one call.
    Unload Me
    CallByName m_Obj, m_MethodName, VbMethod     ' Do the callback.
End Sub
</pre>
</td></tr>
</table></p>

<p>The CCallBack form can be used as a class module in other portions of 
the application. On the companion CD, you'll find a sample multithreaded 
application that creates and displays multiple count-down forms. (See Figure 16-21.) This is 
a partial listing of the class that the main application instantiates when it needs to 
create a new count-down form in a separate thread. (The statements that implement 
the callback mechanism are in boldface.)</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Private Declare Sub Sleep Lib &quot;kernel32&quot; (ByVal dwMilliseconds As Long)

Dim frm As frmCountDown
Dim m_Counter As Integer

' The Counter property. Values &gt; 0 display the form and start
' the countdown.
Property Get Counter() As Integer
    Counter = m_Counter
End Property
Property Let Counter(newValue As Integer)
<B>    Dim cbk As New CCallBack
    m_Counter = newValue
    cbk.DelayedCall Me, 50, &quot;Start&quot;</B>
End Property

Sub Start()
    Static active As Boolean
    If active Then Exit Sub             ' Prevent reentrancy.
    active = True
    ' The code that shows the countdown form (omitted...)
    ' ...
    active = False
End Sub
</pre>
</td></tr>
</table></p>

<p>
<A HREF="javascript:fullSize('f16ph21x.htm')"> <img src="images/f16ph21.JPG" width=404 height=263 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 16-21.</B> <i>The sample countdown multithreading application. Note that each window shows a different thread ID in its caption.</i><!--/caption-->
</p>

<p>This is the code in the main form of the count-down sample application:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Private Sub cmdStart_Click()
    Dim x As CCountDown
    ' Create a new CCountDown object in another thread.
    Set x = CreateObject(&quot;MThrApp.CCountDown&quot;)
    ' Set the counter using the value currently in the TextBox control.
    x.Counter = Val(txtSeconds)
    Set x = Nothing
    Beep
End Sub
</pre>
</td></tr>
</table></p>

<p><div class="caution"><blockquote><b>CAUTION</b><hr>
There's an undocumented detail in the way Visual Basic 
implements multithreading that deserves your attention. If the client code sets 
the last reference to the object to Nothing either explicitly or implicitly while the 
object is executing some code, the client has to wait until the routine in the 
object terminates. This is far from being irrelevant. For example, if you delete the 
<I>Set x = Nothing </I>statement in the previous code routine, the 
<I>x </I>variable will be set to Nothing after the 
<I>Beep </I>statement when the object has already been 
awakened by the callback procedure and is currently executing the count-down code. 
This means that the client has to wait as long as 10 seconds until the object can 
be completely destroyed, and during that time the main form can't react to the 
user's actions. You can choose from two ways to work around this problem:

<UL>
<p><li> You explicitly set to Nothing any object reference immediately after the 
other thread is started, and in the call to the 
<I>DelayedCall </I>method of the CCallBack form module, you use a timeout value that's large enough to let the 
main application destroy its reference before the callback fires. This is 
probably the simplest solution, but it can't be used when the main program needs 
a reference to the object in the other thread (for example, to set its 
properties or invoke its methods).</li></p>
 
<p><li>You keep the object alive until you don't need it anymore by using 
global variables instead of local ones. This solution lets you use the object's 
properties and methods, but in this case it's your responsibility to 
understand when the object should be destroyed. Each object that you keep alive 
without any real reason consumes one thread and therefore adds some 
overhead to the system even if the thread isn't active.</li></p>
</UL>&nbsp;
</blockquote></div></p>

<A NAME="789"><h3>Testing a multithreaded application</h3></A>
<p>Debugging a multithreaded application or component isn't as simple as testing 
a regular program. For one thing, you have to compile your application as a 
stand-alone EXE file because the Visual Basic IDE supports only single-threaded applications 
and components. This means that you have to forgo all the amenities offered by 
the environment, including breakpoints, the Watch window, the Locals window, and 
the step-by-step trace capabilities. For this reason, you should thoroughly test the 
logic of your application in the environment before turning to multithreading.</p>

<p>When testing a compiled multithreaded application, you must devise 
alternate debugging strategies. For example, since you can't write values to the 
Immediate window using <I>Debug.Print </I>methods, you have to resort to logging to file or use 
plain MsgBox commands. One good idea is to display the thread ID in your messages 
so that you can learn which particular thread is issuing them:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
MsgBox &quot;Executing the Eval proc&quot;, vbInformation, &quot;Thread: &quot; &amp; App.ThreadID
</pre>
</td></tr>
</table></p>

<p>Single-threaded ActiveX DLL servers offer a better solution to this problem. 
As you might remember, you can safely use single-threaded DLLs with 
multithreaded clients, be they stand-alone applications or other components. For example, you 
can implement a DLL that exposes a CLog object that gathers trace information from 
its clients and redirects it to a window. Implementing such a DLL isn't difficult. 
Here's the source code of the CLog class. (The demonstration application found on 
the companion CD includes the complete version with additional capabilities.)</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' If this property is nonzero, the ThreadID is added to the message.
Public ThreadID As Long

Sub StartLogging(LogFile As String, LogMode As Integer)
    ' Note that this refers to the global hidden form reference.
    ' This form will therefore be shared by all the instances
    ' of the class.
    frmLog.Show
End Sub

Sub LogEvent(ByVal LogText As String)
    If ThreadID Then
        LogText = &quot;[&quot; &amp; Hex$(ThreadID) &amp; &quot;] &quot; &amp; LogText
    End If
    frmLog.LogText.SelStart = Len(frmLog.LogText.Text)
    frmLog.LogText.SelText = LogText &amp; vbCrLf
End Sub
</pre>
</td></tr>
</table></p>

<p>The frmLog form belongs to the ActiveX DLL project and includes the 
txtLog<I> </I>TextBox control that displays the text messages coming from the multithreaded 
client application, a CheckBox control that lets the user activate and deactivate the 
logging, and a CommandButton control that clears the contents of the txtLog 
control. Figure 1622 shows a new version of the sample 
multithreaded application that has been enhanced with trace capabilities. The revised code in 
the main BAS module of the application is shown below.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Public Log As New CLog

Sub Main()
    Log.StartLogging &quot;&quot;, 0            ' Initialize the CLog object.
    Log.ThreadID = App.ThreadID
    Log.LogEvent &quot;Entering Sub Main&quot;
    ' Here is the code that displays the main form (omitted...)
    ' ...
    Log.LogEvent &quot;Exiting Sub Main&quot;
End Sub
</pre>
</td></tr>
</table></p>

<p>
<A HREF="javascript:fullSize('f16ph22x.htm')"> <img src="images/f16ph22.JPG" width=404 height=262 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 16-22.</B> <i>Adding trace capabilities to a multithreaded application using a single-threaded ActiveX DLL. Each message includes the ID of the thread that sent it.</i><!--/caption-->
</p>

<p>For a more sophisticated test session, you might want to tick the Create 
Symbolic Debug Info option in the Compile tab of the Project Properties dialog box, 
and then recompile the application and execute it under a real debugger, such as the 
one included in Microsoft Visual C++.</p>

</BODY>
</HTML>





