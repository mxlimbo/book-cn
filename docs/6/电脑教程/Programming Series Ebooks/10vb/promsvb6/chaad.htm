<HTML>
<HEAD>
<TITLE>The Windows Registry </TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("chaac.htm", "chaae.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="1057"><h1>The Windows Registry </h1></A>

<p>The Windows Registry is the area where the operating system and most 
applications store their configuration values. You must be able to read as well as to write data 
into the Registry, in order to build flexible applications that adapt themselves to 
their environment.
</p>

<A NAME="1058"><h2>Visual Basic Built-In Functions</h2></A>

<p>Unfortunately, the support for the Registry offered by Visual Basic leaves much 
to be desired and is limited to the following four commands and functions:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Save a value.
SaveSetting AppName, Section, Key, Setting
' Read a value. (The Default argument is optional.)
value = GetSetting(AppName, Section, Key, Default)
' Return a list of settings and their values.
values = GetAllSettings(AppName, Section)
' Delete a value. (Section and Key arguments are optional.)
DeleteSetting AppName, Section, Key
</pre>
</td></tr>
</table>
</p>

<p>These four commands can't read and write to any area in the Registry but 
are limited to the <I>HKEY_CURRENT_USER\Software\VB and VBA Program Settings 
</I>subtree of the Registry. For example, you can use the 
<I>SaveSetting </I>function to store the initial function position and size of the main form in the MyInvoicePrg application:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>SaveSetting &quot;MyInvoicePrg&quot;, &quot;frmMain&quot;, &quot;Left&quot;, frmMain.Left
SaveSetting &quot;MyInvoicePrg&quot;, &quot;frmMain&quot;, &quot;Top&quot;, frmMain.Top
SaveSetting &quot;MyInvoicePrg&quot;, &quot;frmMain&quot;, &quot;Width&quot;, frmMain.Width
SaveSetting &quot;MyInvoicePrg&quot;, &quot;frmMain&quot;, &quot;Height&quot;, frmMain.Height
</pre>
</td></tr>
</table>
</p>

<p>You can see the result of this sequence of statements in Figure A-5.
</p>

<p>
<A HREF="javascript:fullSize('F_APH05x.htm')"> <img src="images/F_APH05.JPG" width=404 height=335 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure A-5.</B> <i>All Visual Basic Registry functions read and write values in the</i> HKEY_CURRENT_USER\Software\VB<i> and</i> VBA Program Settings <i>subtree.</i><!--/caption-->
</p>

<p>You can then read back these settings using the 
<I>GetSetting </I>function:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Use the Move method to avoid multiple Resize and Paint events.
frmMain.Move GetSetting(&quot;MyInvoicePrg&quot;, &quot;frmMain&quot;, &quot;Left&quot;, &quot;1000&quot;), _
    GetSetting(&quot;MyInvoicePrg&quot;, &quot;frmMain&quot;, &quot;Top&quot;, &quot;800&quot;), _
    GetSetting(&quot;MyInvoicePrg&quot;, &quot;frmMain&quot;, &quot;Width&quot;, &quot;5000&quot;), _
    GetSetting(&quot;MyInvoicePrg&quot;, &quot;frmMain&quot;, &quot;Height&quot;, &quot;4000&quot;)
</pre>
</td></tr>
</table>
</p>

<p>If the specified key doesn't exist, the <I>GetSetting 
</I>function either returns the values passed to the 
<I>Default </I>argument, or it returns an empty string if that argument 
is omitted. <I>GetAllSettings </I>returns a two dimensional array, which contains all the 
keys and the values under a given section:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim values As Variant, i As Long
values = GetAllSettings(&quot;MyInvoicePrg&quot;, &quot;frmMain&quot;)
' Each row holds two items, the key name and the key value.
For i = 0 To UBound(settings)
    Print &quot;Key =&quot; &amp; values(i, 0) &amp; &quot;  Value = &quot; &amp; values(i, 1)
Next
</pre>
</td></tr>
</table>
</p>

<p>The last keyword of the group, 
<I>DeleteSetting</I>, can delete an individual key, 
or it can delete all the keys under a given section if you omit its last argument:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Delete the &quot;Left&quot; key for the frmMain form.
DeleteSetting &quot;MyInvoicePrg&quot;, &quot;frmMain&quot;, &quot;Left&quot;
' Delete all the settings for the frmMain form.
DeleteSetting &quot;MyInvoicePrg&quot;, &quot;frmMain&quot;
</pre>
</td></tr>
</table>
</p>

<p>The demonstration program shown in Figure A-6 demonstrates how you 
can use the Visual Basic's built-in Registry functions to save and to restore form settings.
</p>

<p>
<img src="images/F_Aph06.GIF" width=398 height=189 border="0">
<p>
<!--caption--><B>Figure A-6.</B> <i>The demonstration program contains reusable routines for saving and restoring form settings to the Registry.</i><!--/caption-->


<A NAME="1059"><h2>The API Functions</h2></A>
<p>While the Visual Basic built-in functions are barely versatile enough for saving 
and restoring program configuration values, they entirely lack the functionality for 
accessing any region of the Registry, which you must have in order to read some 
important settings of the operating system. Luckily, the Windows API contains all the 
functions you need to perform this task.
</p>

<p><div class="warning"><blockquote>
<b>WARNING</b><hr>You must be very careful when you play with the Registry in 
this way because you might corrupt the installation of other applications or the 
operating system itself, and you might even be force to reinstall them. but in 
general, you can't do much harm if you simply read values in the Registry and don't 
write to it. To reduce risks, however, you might want to back up your system 
Registry so that you have a copy to restore if something goes wrong.
</blockquote></div>
</p>

<A NAME="1060"><h3>Predefined keys</h3></A>

<p>Before starting to play with API functions, you must have a broad idea of how 
the Registry is arranged. The system Registry is a hierarchical structure that consists 
of keys, subkeys, and values. More precisely, the Registry has a number of 
predefined top-level keys, which I've summarized in Table A-1.
</p>

<p>
<B>Table A-1.</B> <i>The predefined Registry keys.</i>
</p>

<p>
<table valign="top" cellpadding="5" width="95%">

<tr>
<th><i>Key</i></th>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>

<tr>
<td valign="top">HKEY_CLASSES_ROOT</td>
<td valign="top">&amp;H80000000</td>
<td valign="top">The subtree that contains all the 
information about COM components installed on the 
machine. (It's actually a subtree of the HKEY_LOCAL_MACHINE key but also appears as 
a top-level key.)</td>
</tr>

<tr>
<td valign="top">HKEY_CURRENT_USER</td>
<td valign="top">&amp;H80000001</td>
<td valign="top">The subtree that contains the preferences 
for the current user. (It's actually to a subtree 
of the HKEY_USERS key but also appears as a top-level key.)</td>
</tr>

<tr>
<td valign="top">HKEY_LOCAL_MACHINE</td>
<td valign="top">&amp;H80000002</td>
<td valign="top">The subtree that contains information 
about the physical configuration of the computer, including installed hardware and software.</td>
</tr>

<tr>
<td valign="top">HKEY_USERS</td>
<td valign="top">&amp;H80000003</td>
<td valign="top">The subtree that contains the default user 
configuration and also contains information about the current user.</td>
</tr>

<tr>
<td valign="top">HKEY_PERFORMANCE_DATA</td>
<td valign="top">&amp;H80000004</td>
<td valign="top">The subtree that collects performance 
data; data is actually stored outside the Registry, 
but appears to be part of it. (It's available only in Windows NT.)</td>
</tr>

<tr>
<td valign="top">HKEY_CURRENT_CONFIG</td>
<td valign="top">&amp;H80000005</td>
<td valign="top">The subtree that contains data about the 
current configuration. (It corresponds to a 
subtree of the HKEY_LOCAL_MACHINE key but also appears as a top-level key.)</td>
</tr>

<tr>
<td valign="top">HKEY_DYN_DATA</td>
<td valign="top">&amp;H80000006</td>
<td valign="top">The subtree that collects performance 
data; this portion of the Registry is reinitialized 
at each reboot. (It's available only in 
Windows 95 and 98.)</td>
</tr>
</table>
</p>


<p>Each Registry key has a name, which is a string of up to 260 printable 
characters that can't include backslash characters (\) or wildcards (? and *). Names 
beginning with a period are reserved. Each key can contain subkeys and values. Under 
Windows 3.1, a key could hold only one unnamed value, while 32-bit platforms allow an 
unlimited number of values. (But unnamed values, called the 
<I>default values</I>, are maintained for backward compatibility.)
</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
In general, Windows 9x and Windows NT greatly differ in how they 
deal with the Registry. In Windows NT, you must account for additional security 
issues, and in general you have no guarantee that you can open an existing 
Registry key or value. In this section, I stayed clear of such details and focused on 
those functions that behave the same way for all the Windows platforms. For this 
reason,  I've sometimes used &quot;old&quot; Registry functions instead of newer ones, 
which you recognize by the <I>Ex </I>suffix in their names, a suffix that stands for &quot;Extended.&quot;
</blockquote></div>
</p>

<A NAME="1061"><h3>Working with keys</h3></A>

<p>Navigating the Registry is similar to exploring a directory tree: To reach a given 
file, you must open the directory that contains it. Likewise, you reach a Registry 
subkey from another open key at a higher level in the Registry hierarchy. You must open 
a key before reading its subkeys and its values, and to do that you must supply 
the handle of another open key in the Registry. After you've worked with a key you 
must close it, as you do with files. The only keys that are always open and that don't 
need to be closed are the top-level keys listed in Table A-1. You open a key with 
the <I>RegOpenKeyEx</I> API function:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Declare Function RegOpenKeyEx Lib &quot;advapi32.dll&quot; Alias &quot;RegOpenKeyExA&quot; _
    (ByVal hKey As Long, ByVal lpSubKey As String, ByVal ulOptions As _
     Long, ByVal samDesired As Long, phkResult As Long) As Long
</pre>
</td></tr>
</table>
</p>

<p><I>hKey </I>is the handle of an open key and can be one of the values listed 
in Table A1 or the handle of a key that you've opened previously. 
<I>lpSubKey </I>is the path from the <I>hKey </I>key to the key that you want to open. 
<I>ulOptions </I>is a reserved argument and must be 0. 
<I>samDesired </I>is the type of access you want for the key that 
you want to open and is a symbolic constant such as KEY_READ, KEY_WRITE, 
or KEY_ALL_ACCESS. Finally, <I>phkResult </I>is a Long variable passed by reference, 
which receives the handle of the key opened by the function if the operation is 
successful. You can test the success of the open operation by looking at the return value of 
the <I>RegOpenKeyEx </I>function: A zero value means that the operation succeeded, and 
any non-zero value is an error code. This behavior is common to all the Registry 
API functions, so you can easily set up a function that tests the success state of any 
call. (See the MSDN documentation for the list of error codes.)
</p>

<p>As I mentioned earlier, you must close any open key as soon as you don't 
need it any longer, which you do with the <I>RegCloseKey 
</I>API function. This function takes the handle of the key to be closed as its only argument, and returns 0 if the 
operation is successful:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Declare Function RegCloseKey Lib &quot;advapi32.dll&quot; (ByVal hKey As Long) _
    As Long
</pre>
</td></tr>
</table>
</p>

<p>Frequently, the presence of a subkey is enough to store significant data in 
a key. For example, if the machine has a math coprocessor, Windows creates the 
following key:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>HKEY_LOCAL_MACHINE\HARDWARE\DESCRIPTION\System\FloatingPointProcessor
</pre>
</td></tr>
</table>
</p>

<p>so you can test the presence of the coprocessor using this routine:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Assumes that all symbolic constants are correctly declared elsewhere.
Function MathProcessor() As Boolean
    Dim hKey As Long, Key As String
    Key = &quot;HARDWARE\DESCRIPTION\System\FloatingPointProcessor&quot;
    If RegOpenKeyEx(HKEY_LOCAL_MACHINE, Key, 0, KEY_READ, hKey) = 0 Then
        ' If the open operation succeeded, the key exists.
        MathProcessor = True
        ' Important: close the key before exiting.
        RegCloseKey hKey
    End If
End Function
</pre>
</td></tr>
</table>
</p>

<p>As you might expect, the Registry API includes a function for creating new 
keys, but its syntax is overly complex:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Declare Function RegCreateKeyEx Lib &quot;advapi32.dll&quot; Alias &quot;RegCreateKeyExA&quot;_
    (ByVal hKey As Long, ByVal lpSubKey As String, ByVal Reserved As Long,_
    ByVal lpClass As Long, ByVal dwOptions As Long, _
    ByVal samDesired As Long, ByVal lpSecurityAttributes As Long, _
    phkResult As Long, lpdwDisposition As Long) As Long
</pre>
</td></tr>
</table>
</p>

<p>Most of the arguments have the same names and syntax as those that I've 
already described for the <I>RegOpenKeyEx </I>function, and I won't describe most of the 
new arguments because they constitute a topic too advanced for this context. You can 
pass a Long variable to the <I>lpdwDisposition 
</I>argument, and when the function returns you can test the contents in this variable. The value REG_CREATED_NEW_KEY (1) 
means that the key didn't exist and has been created and opened by this function, 
whereas the value REG_OPENED_EXISTING_KEY (2) means that the key already existed 
and the function just opened it without altering the Registry in any way. To reduce 
the confusion, I use the following routine, which creates a key if necessary and 
returns True if the key already existed:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function CreateRegistryKey(ByVal hKey As Long, ByVal KeyName As String) _
    As Boolean
    Dim handle As Long, disp As Long
    If RegCreateKeyEx(hKey, KeyName, 0, 0, 0, 0, 0, handle, disp) Then
        Err.Raise 1001, , &quot;Unable to create the registry key&quot;
    Else
        ' Return True if the key already existed.
        If disp = REG_OPENED_EXISTING_KEY Then CreateRegistryKey = True
        ' Close the key.
        RegCloseKey handle
    End If
End Function
</pre>
</td></tr>
</table>
</p>

<p>The following code snippet shows how you can use the 
<I>CreateRegistryKey </I>function to create a key with the name of your company under the key HKEY
_CURRENT_USER\Software and another key with the name of your application. 
This is the approach followed by most commercial applications, including all those 
by Microsoft and other leading software companies:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>CreateRegistryKey HKEY_CURRENT_USER, &quot;Software\YourCompany&quot;
CreateRegistryKey HKEY_CURRENT_USER, &quot;Software\YourCompany\YourApplication&quot;
</pre>
</td></tr>
</table>
</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
The <I>CreateRegistryKey 
</I>function, like all other Registry routines 
provided on the companion CD, always closes a key before exiting. This approach 
makes them &quot;safe&quot; but it also imposes a slight performance penalty because each 
call opens and closes a key that you might have to reopen immediately 
afterwards, as in the preceding example. You can't always have it all.
</blockquote></div>
</p>

<p>Finally, you can delete a key from the Registry, using the 
<I>RegDeleteKey </I>API function:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Declare Function RegDeleteKey Lib &quot;advapi32.dll&quot; Alias &quot;RegDeleteKeyA&quot; _
    (ByVal hKey As Long, ByVal lpSubKey As String) As Long
</pre>
</td></tr>
</table>
</p>

<p>Under Windows 95 and 98, this function deletes a key and all its 
subkeys, whereas under Windows NT you get an error if the key being deleted contains 
other keys. For this reason, you should manually delete all the subkeys first:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Delete the keys created in the previous example.
RegDeleteKey HKEY_CURRENT_USER, &quot;Software\YourCompany\YourApplication&quot;
RegDeleteKey HKEY_CURRENT_USER, &quot;Software\YourCompany&quot;
</pre>
</td></tr>
</table>
</p>



<A NAME="1062"><h3>Working with values</h3></A>

<p>In many cases, a Registry key contains one or more values, so you must learn 
how to read the information they contain. To do so, you need the 
<I>RegQueryValueEx </I>API function:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Declare Function RegQueryValueEx Lib &quot;advapi32.dll&quot; Alias _
    &quot;RegQueryValueExA&quot; (ByVal hKey As Long, ByVal lpValueName As String, _
    ByVal lpReserved As Long, lpType As Long, lpData As Any, _
    lpcbData As Long) As Long
</pre>
</td></tr>
</table>
</p>

<p><I>hKey</I> is the handle of the open key that contains the value. 
<I>lpValueName </I>is the name of the value you want to read. (Use an empty string for the default 
value.) <I>lpReserved </I>must be zero. <I>lpType 
</I>is the type of the key. <I>lpData </I>is a pointer to a 
buffer that will receive the data. <I>lpcbData 
</I>is a Long variable passed by reference; on 
entry it has to contain the size in bytes of the buffer, and on exit it contains the number 
of bytes actually stored in the buffer. Most Registry values you'll want to read are of 
type REG_DWORD (a Long value), REG_SZ (a null-terminated string), or 
REG_BINARY (array of bytes).
</p>

<p>The Visual Basic environment stores some of its configuration settings as 
values under the following key:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>HKEY_CURRENT_USER\Software\Microsoft\VBA\Microsoft Visual Basic
</pre>
</td></tr>
</table>
</p>

<p>You can read the FontHeight value to retrieve the size of the font used for 
the code editor, whereas the FontFace value holds the name of the font. Because the 
former value is a Long number and the latter is a string, you need two different coding 
techniques for them. Reading a Long value is simpler because you just pass a Long 
variable by reference to <I>lpData</I> and pass its length in bytes (which is 4 bytes) in 
<I>lpcbData</I>. To retrieve a string value, on the other hand, you must prepare a buffer and pass 
it by value, and when the function returns you must strip off the characters in excess:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim KeyName As String, handle As Long
Dim FontHeight As Long, FontFace As String, FontFaceLen As Long

KeyName = &quot;Software\Microsoft\VBA\Microsoft Visual Basic&quot;
If RegOpenKeyEx(HKEY_CURRENT_USER, KeyName, 0, KEY_READ, handle) Then
    MsgBox &quot;Unable to open the specified Registry key&quot;
Else
    ' Read the &quot;FontHeight&quot; value.
    If RegQueryValueEx(handle, &quot;FontHeight&quot;, 0, REG_DWORD, FontHeight, 4) _
        = 0 Then
        Print &quot;Face Height = &quot; &amp; FontHeight
    End If

    ' Read the &quot;FontFace&quot; value. 
    FontFaceLen = 128                   ' Prepare the receiving buffer.
    FontFace = Space$(FontFaceLen)
    ' Notice that FontFace is passed using ByVal.
    If RegQueryValueEx(handle, &quot;FontFace&quot;, 0, REG_SZ, ByVal FontFace, _
        FontFaceLen) = 0 Then
        ' Trim excess characters, including the trailing Nullchar.
        FontFace = Left$(FontFace, FontFaceLen - 1)
        Print &quot;Face Name = &quot; &amp; FontFace
    End If
    ' Close the Registry key.
    RegCloseKey handle
End If
</pre>
</td></tr>
</table>
</p>

<p>Because you need to read Registry values often, I've prepared a reusable 
function that performs all the necessary operations and returns the value in a Variant. 
You can also specify a default value, which you can use if the specified key or value 
doesn't exist. This tactic is similar to what you do with the Visual Basic's intrinsic 
<I>GetSetting </I>function.
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function GetRegistryValue(ByVal hKey As Long, ByVal KeyName As String, _
    ByVal ValueName As String, ByVal KeyType As Integer, _
    Optional DefaultValue As Variant = Empty) As Variant

    Dim handle As Long, resLong As Long
    Dim resString As String, length As Long
    Dim resBinary() As Byte
    ' Prepare the default result.
    GetRegistryValue = DefaultValue
    ' Open the key, exit if not found.
    If RegOpenKeyEx(hKey, KeyName, 0, KEY_READ, handle) Then Exit Function

    Select Case KeyType
        Case REG_DWORD
            ' Read the value, use the default if not found.
            If RegQueryValueEx(handle, ValueName, 0, REG_DWORD, _
                resLong, 4) = 0 Then
                GetRegistryValue = resLong
            End If
        Case REG_SZ
            length = 1024: resString = Space$(length)
            If RegQueryValueEx(handle, ValueName, 0, REG_SZ, _
                ByVal resString, length) = 0 Then
                ' If value is found, trim characters in excess.
                GetRegistryValue = Left$(resString, length - 1)
            End If
        Case REG_BINARY
            length = 4096
            ReDim resBinary(length - 1) As Byte
            If RegQueryValueEx(handle, ValueName, 0, REG_BINARY, _
                resBinary(0), length) = 0 Then ReDim Preserve resBinary(length-1)As Byte
                GetRegistryValue = resBinary()
            End If
        Case Else
            Err.Raise 1001, , &quot;Unsupported value type&quot;
    End Select
    RegCloseKey handle
End Function
</pre>
</td></tr>
</table>
</p>

<p>To create a new Registry value or to modify the data of an existing value, 
you use the <I>RegSetValueEx </I>API function:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Declare Function RegSetValueEx Lib &quot;advapi32.dll&quot; Alias &quot;RegSetValueExA&quot; _
    (ByVal hKey As Long, ByVal lpValueName As String, _
    ByVal Reserved As Long, ByVal dwType As Long, lpData As Any, _
    ByVal cbData As Long) As Long
</pre>
</td></tr>
</table>
</p>

<p>Let's see how we can add a LastLogin value under the key HKEY
_CURRENT_USER\Software\YourCompany\YourApplication, that we created in 
the previous section:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim handle As Long, strValue As String
' Open the key, check if any error occurred.
If RegOpenKeyEx(HKEY_CURRENT_USER, &quot;Software\YourCompany\YourApplication&quot;,_
    0, KEY_WRITE, handle) Then 
    MsgBox &quot;Unable to open the key.&quot;
Else
    ' We want to add a &quot;LastLogin&quot; value, of type string.
    strValue = FormatDateTime(Now)
    ' Strings must be passed using ByVal.
    RegSetValueEx handle, &quot;LastLogin&quot;, 0, REG_SZ, ByVal strValue, _
        Len(strValue)
    ' Don't forget to close the key.
    RegCloseKey handle
End If
</pre>
</td></tr>
</table>
</p>

<p>On the companion CD, you'll find the source code of the 
<I>SetRegistryValue </I>function, which automatically uses the correct syntax according to the type of value 
you're creating. Finally, by using the 
<I>RegDeleteValue</I> API function, you can delete a 
value under a key that you opened previously:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Declare Function RegDeleteValue Lib &quot;advapi32.dll&quot; Alias &quot;RegDeleteValueA&quot;_
    (ByVal hKey As Long, ByVal lpValueName As String) As Long
</pre>
</td></tr>
</table>
</p>



<A NAME="1063"><h3>Enumerating keys and values</h3></A>

<p>When you're exploring the Registry, you often need to enumerate all the keys or 
all the values under a key. The function you use to enumerate keys is 
<I>RegEnumKey</I>:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Declare Function RegEnumKey Lib &quot;advapi32.dll&quot; _
    Alias &quot;RegEnumKeyA&quot; (ByVal hKey As Long, ByVal dwIndex As Long, _
    ByVal lpName As String, ByVal cbName As Long) As Long
</pre>
</td></tr>
</table>
</p>

<p>You must pass the handle of an open Registry key in the 
<I>hKey </I>argument, and then you repeatedly call this function, passing increasing index values in 
<I>dwIndex</I>. The <I>lpName</I> argument must be a string buffer of at least 260 characters (the 
maximum length for a key name), and <I>lpcbName 
</I>is the length of the buffer. When you exit the routine, the buffer contains a Null-terminated string, so you have to strip all 
the characters in excess. To simplify your job, I've prepared a function that iterates 
on all the subkeys of a given keys and returns an String array that contains the 
names of all the subkeys:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function EnumRegistryKeys(ByVal hKey As Long, ByVal KeyName As String) _
    As String()
    Dim handle As Long, index As Long, length As Long
    ReDim result(0 To 100) As String

    ' Open the key, exit if not found.
    If Len(Keyname) Then
        If RegOpenKeyEx(hKey, KeyName, 0, KEY_READ, handle) Then 
            Exit Function
        End If
        ' Subsequent functions use hKey.
        hKey = handle
    End If
    
    For index = 0 To 999999
        ' Make room in the array.
        If index &gt; UBound(result) Then
            ReDim Preserve result(index + 99) As String
        End If
        length = 260                   ' Max length for a key name.
        result(index) = Space$(length)
        If RegEnumKey(hKey, index, result(index), length) Then Exit For
        ' Trim characters in excess.
        result(index) = Left$(result(index), InStr(result(index), _
            vbNullChar) - 1)
    Next

    ' Close the key, if it was actually opened.
    If handle Then RegCloseKey handle
    ' Trim unused items in the array and return the results to the caller.
    ReDim Preserve result(index - 1) As String
    EnumRegistryKeys = result()
End Function
</pre>
</td></tr>
</table>
</p>

<p>Thanks to the <I>EnumRegistryKey </I>function, it's simple to dig a lot of useful 
information out of the Registry. For example, see how easy it is to fill a ListBox 
control with the names of all the components registered on the machine under 
the HKEY_CLASS_ROOT key:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim keys() As String, i As Long
keys() = EnumRegistryKeys(HKEY_CLASSES_ROOT, &quot;&quot;)
List1.Clear
For i = LBound(keys) To UBound(keys)
    List1.AddItem keys(i)
Next
</pre>
</td></tr>
</table>
</p>

<p>The companion CD includes a demonstration program (shown in Figure 
A-7) that displays the list of installed COM components as well as their CLSIDs and 
the DLL or EXE file that contains each one of them. You can easily expand this first 
version to create your own utilities that track anomalies in the Registry. For example, you 
can list all the DLL and EXE files that aren't in the locations listed in the Registry. 
(COM raises an error when you try to instantiate such components.)
</p>

<p>
<A HREF="javascript:fullSize('F_Aph07x.htm')"> <img src="images/F_Aph07.JPG" width=404 height=231 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure A-7.</B> <i>You can use Registry API routines to list all the components installed on your machine, with their CLSIDs and the locations of their executable files.</i><!--/caption-->
</p>

<p>The Windows API also exposes a function for enumerating all the values 
under a given open key:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Declare Function RegEnumValue Lib &quot;advapi32.dll&quot; Alias &quot;RegEnumValueA&quot; _
    (ByVal hKey As Long, ByVal dwIndex As Long, ByVal lpValueName As _
    String, lpcbValueName As Long, ByVal lpReserved As Long, _
    lpType As Long, lpData As Any, lpcbData As Long) As Long
</pre>
</td></tr>
</table>
</p>

<p>This function returns the type of each value in the 
<I>lpType </I>variable and the contents of the value in 
<I>lpData</I>. The difficulty is that you don't know in advance 
what the type of the value is, and therefore you don't know the kind of 
variable&#8212;Long, String, or Byte array&#8212;you should pass in 
<I>lpData</I>. The solution to this problem is to pass a Byte array and then move the result into a Long variable using the 
<I>CopyMemory </I>API routine or into a String variable using the VBA 
<I>StrConv </I>function. On the companion CD, you'll find the complete source of the 
<I>EnumRegistryValues </I>routine, which encapsulates all these details and returns a two-dimensional array of Variants 
containing all the values' names and data. For example, you can use this routine to 
retrieve all the Microsoft Visual Basic configuration values:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim values() As Variant, i As Long
values() = EnumRegistryValues(HKEY_CURRENT_USER, _
    &quot;Software\Microsoft\VBA\Microsoft Visual Basic&quot;)
For i = LBound(values, 2) To UBound(values, 2)
    ' Row 0 holds the value's name, row 1 holds its value.
    List1.AddItem values(0, i) &amp; &quot; = &quot; &amp; values(1, i)
Next
</pre>
</td></tr>
</table>
</p>



</BODY>
</HTML>





