<HTML>
<HEAD>
<TITLE>Working with Strings</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch05c.htm", "ch05e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="174"><h1>Working with Strings</h1></A>
<p>Visual Basic for Applications includes many powerful string functions, and it's 
sometimes difficult at first glance to determine which one meets your requirements. In 
this section, I briefly describe all the string functions at your disposal, offer some tips 
for selecting the most suitable one in some typical situations, and also provide some 
useful string functions that you can reuse in your applications.</p>

<A NAME="175"><h2>Basic String Operators and Functions</h2></A>
<p>The basic string operator &amp; performs a string concatenation. The result is a 
string consisting of all the characters of the first string followed by all the characters of 
the second string:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Print &quot;ABCDE&quot; &amp; &quot;1234&quot;       ' Displays &quot;ABCDE1234&quot;
</pre>
</td></tr>
</table></p>

<p>Many programmers with roots in QuickBasic still use the + operator for 
performing string concatenation. This is a dangerous practice that impacts code readability 
and might introduce unexpected behaviors when either operand isn't a string.</p>

<p>The next bunch of popular string functions, shown below, includes <I>Left$</I>, <I>Right$,</I><B> 
</B>and <I>Mid$</I>, which extract a substring from the beginning, the 
end, or the middle of the source string.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Text = &quot;123456789&quot;
Print Left$(text, 3)         ' Displays &quot;123&quot;
Print Right$(text, 2)        ' Displays &quot;89&quot;
Print Mid$(text, 3, 4)       ' Displays &quot;3456&quot;
</pre>
</td></tr>
</table></p>

<p><div class="tip"><blockquote><b>TIP</b><hr>
The VBA documentation consistently omits the trailing 
<I>$</I> character in all string functions and invites you to use the new 
<I>$</I>-less functions. <I>Don't do it!</I> A 
<I>$</I>-less function returns a Variant that contains the string result, which means 
in most cases the Variant must be reconverted to a string before it can be reused 
in expressions or assigned to a String variable. This is a time-consuming 
process that gives you nothing in return. Informal benchmarks show that, for 
example, the <I>Left$</I> function is up to twice as fast as its 
<I>$</I>-less counterpart. A similar reasoning applies to other functions that exist in both forms, including 
<I>LCase</I>, <I>UCase</I>, <I>LTrim</I>, 
<I>RTrim</I>, <I>Trim</I>, <I>Chr</I>, 
<I>Format</I>, <I>Space</I>, and <I>String</I>.
</blockquote></div></p>

<p> <I>Mid$</I> can also work as a command in that it lets you modify one or 
more characters inside a string:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Text = &quot;123456789&quot;
Mid$(Text, 3, 4) = &quot;abcd&quot;    ' Now Text = &quot;12abcd789&quot;
</pre>
</td></tr>
</table></p>

<p>The <I>Len</I> function returns the current length of a string. It's often used to 
test whether a string contains any characters:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Print Len(&quot;12345&quot;)          ' Displays &quot;5&quot;
If Len(Text) = 0 Then ...   ' Faster than comparison with an empty string.
</pre>
</td></tr>
</table></p>

<p>To discard unwanted trailing or leading blanks, you can use the 
<I>LTrim$</I>, <I>RTrim$</I>, and <I>Trim$</I> functions:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Text = &quot;  abcde  &quot;
Print LTrim$(Text)           ' Displays &quot;abcde  &quot;
Print RTrim$(Text)           ' Displays &quot;  abcde&quot;
Print Trim$(Text)            ' Displays &quot;abcde&quot;
</pre>
</td></tr>
</table></p>

<p>These functions are especially useful with fixed-length strings that are filled 
with extra spaces to account for their expected length. You can trim those extra 
spaces using the <I>RTrim$</I> function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim Text As String * 10
Text = &quot;abcde&quot;               ' Text now contains &quot;abcde     &quot;.
Print Trim$(Text)            ' Displays &quot;abcde&quot;
</pre>
</td></tr>
</table></p>

<p><div class="caution"><blockquote><b>CAUTION</b><hr>
When a fixed-length string is declared but hasn't been used yet, 
it contains Null characters, not spaces. This means that the 
<I>RTrim$</I> function can't trim such a string:

<p><table><tr><td>
<pre>
Dim Text As String * 10
Print Len(Trim$(Text))       ' Displays &quot;10&quot;, no trimming has occurred.
</pre>
</td></tr>
</table></p>

<p>You can avoid this problem by simply assigning an empty string to all the 
fixed-length strings in your application soon after their declaration and before using 
them.</p>
</blockquote></div></p>

<p>The <I>Asc</I> function returns the character code of the first letter in a string. 
Functionally, it's similar to extracting the first character using the 
<I>Left$</I> function, but <I>Asc</I> is considerably faster:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
If Asc(Text) = 32 Then        ' Test whether the fist char is a space.
If Left$(Text, 1) = &quot; &quot; Then  ' Same effect, but 2 to 3 times slower
</pre>
</td></tr>
</table></p>

<p>When you're using the <I>Asc</I> function, you should ensure that the string isn't 
empty because in that case the function raises an error. In a sense, 
<I>Chr$</I> is the opposite of <I>Asc</I> in that it transforms a numeric code into the corresponding character:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Print Chr$(65)                ' Displays &quot;A&quot;
</pre>
</td></tr>
</table></p>

<p>The <I>Space$</I> and <I>String$</I><B> 
</B>functions are very similar. The former returns a 
string of spaces of the length you want, and the latter returns a string that consists of 
the character specified in the second parameter repeated as many times as you 
indicated in the first parameter:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Print Space$(5)               ' Displays &quot;     &quot; (five spaces)
Print String$(5, &quot; &quot;)         ' Same effect
Print String$(5, 32)          ' Same effect, using the char code
Print String$(50, &quot;.&quot;)        ' A row of 50 dots
</pre>
</td></tr>
</table></p>

<p>Finally the <I>StrComp</I> function lets you compare strings in a case-insensitive 
fashion and returns -1, 0, or 1 if the first argument is less than, equal to, or greater 
than the second argument. The third argument specifies whether the comparison 
should be performed in a case-insensitive way:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Select Case StrComp(first, second, vbTextCompare)
    Case 0
        ' first = second   (e.g. &quot;VISUAL BASIC&quot; vs. &quot;Visual Basic&quot;)
    Case -1
        ' first &lt; second   (e.g. &quot;C++&quot; vs. &quot;Visual Basic&quot;)
    Case 1
        ' first &gt; second   (e.g. &quot;Visual Basic&quot; vs. &quot;Delphi&quot;)
End Select
</pre>
</td></tr>
</table></p>

<p>The <I>StrComp</I> function is sometimes convenient even for case-sensitive 
comparisons because you don't need two separate tests to decide whether a string is less 
than, equal to, or greater than another one.</p>

<A NAME="176"><h2>Conversion Functions</h2></A>
<p>The most frequently used functions for converting strings are 
<I>UCase$</I> and <I>LCase$</I>, which transform their arguments to uppercase and lowercase, respectively:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Text = &quot;New York, USA&quot;
Print UCase$(Text)                 ' &quot;NEW YORK, USA&quot;
Print LCase$(Text)                 ' &quot;new york, usa&quot;
</pre>
</td></tr>
</table></p>

<p>The <I>StrConv</I> function encompasses the functionality of the first two and 
adds more capabilities. You can use it to convert to uppercase, lowercase, and 
propercase (where the first letter of each word is uppercase, and all the others are lowercase):</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Print StrConv(Text, vbUpperCase)   ' &quot;NEW YORK, USA&quot;
Print StrConv(Text, vbLowerCase)   ' &quot;new york, usa&quot;
Print StrConv(Text, vbProperCase)  ' &quot;New York, Usa&quot;
</pre>
</td></tr>
</table></p>

<p>(Valid word separators are spaces, Null characters, carriage returns, and line 
feeds.) The function can also perform ANSI-to-Unicode conversion and back, using 
the <I>vbUnicode</I> and <I>vbFromUnicode</I> symbolic constants. You'll rarely use these 
functions in your regular Visual Basic applications.</p>

<p>The <I>Val</I> function converts a string into its decimal representation. (See also 
the section &quot;<A HREF="ch05c.htm#171">Converting Among Different Numeric Bases</A>,&quot; earlier in this chapter). 
Visual Basic also includes functions that can convert from a string to a numeric value, 
such as <I>CInt</I>,<I> CLng</I>,<I> CSng</I>,<I> 
CDbl</I>,<I> CCur</I>,<I> </I>and<I> CDate</I>. The main difference between them 
and the <I>Val</I> function is that they're locale aware. For example, they correctly 
recognize the comma as the decimal separator in countries where this is the case and 
ignore any thousand separator characters. Conversely, the 
<I>Val</I> function recognizes only the decimal point and stops parsing its argument when it finds any invalid 
characters (including a currency symbol or a comma used for grouping thousand digits).</p>

<p>The <I>Str$</I> function converts a number into its string representation. The 
main difference between <I>Str$</I> and 
<I>CStr</I> is that the former adds a leading space if the 
argument is positive, whereas the latter does not.</p>

<A NAME="177"><h2>Find and Replace Substrings</h2></A>
<p>The <I>InStr </I>function searches for a substring in another string, either in 
case-sensitive or case-insensitive mode. You can't omit the starting index if you want to pass 
the argument that specifies which kind of search you want to perform:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Print InStr(&quot;abcde ABCDE&quot;, &quot;ABC&quot;)     ' Displays &quot;7&quot; (case sensitive)
Print InStr(8, &quot;abcde ABCDE&quot;, &quot;ABC&quot;)  ' Displays &quot;0&quot; (start index &gt; 1)
Print InStr(1, &quot;abcde ABCDE&quot;, &quot;ABC&quot;, vbTextCompare)
                                      ' Displays &quot;1&quot; (case insensitive)
</pre>
</td></tr>
</table></p>

<p>The <I>InStr</I> function is very handy for building other powerful string 
functions that are missing in the VBA language. For example, this is a function that 
searches for the first occurrence of a character among those included in a search table. It's 
useful for extracting words that can be delimited by many different punctuation characters:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Function InstrTbl(source As String, searchTable As String, _
    Optional start As Long = 1, _
    Optional Compare As VbCompareMethod = vbBinaryCompare) As Long
    Dim i As Long
    For i = start To Len(source)
        If InStr(1, searchTable, Mid$(source, i, 1), Compare) Then
            InstrTbl = i
            Exit For
        End If
    Next
End Function
</pre>
</td></tr>
</table></p>

<p><img src="images/new.jpg" width=102 height=87 border=0></p>

<p> Visual Basic 6 lets you perform backward searches, using the new 
<I>InStrRev</I> function. Its syntax is similar to the original 
<I>InStr</I> function, but the order of its arguments is different:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
found = InStrRev(Source, Search, [Start], [CompareMethod])
</pre>
</td></tr>
</table></p>

<p>Here are a few examples. Note that if you omit the 
<I>start </I>argument, the search starts at the end of the string:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Print InStrRev(&quot;abcde ABCDE&quot;, &quot;abc&quot;)    ' Displays &quot;1&quot; (case sensitive)
Print InStrRev(&quot;abcde ABCDE&quot;, &quot;abc&quot;, ,vbTextCompare )  
                                        ' Displays &quot;7&quot; (case insensitive)
Print InStrRev(&quot;abcde ABCDE&quot;, &quot;ABC&quot;, 4, vbTextCompare )
                            ' Displays &quot;1&quot; (case insensitive, start&lt;&gt;0)
</pre>
</td></tr>
</table></p>

<p>Visual Basic also includes a handy string operator, the 
<I>Like </I>operator, which is often a life saver when you're parsing a string and performing complex searches. 
The syntax of this operator is the following:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
result <B>=</B> string Like pattern
</pre>
</td></tr>
</table></p>

<p>where <I>string </I>is the string being parsed and 
<I>pattern </I>is a string made up of special characters that define the search condition. The most frequently used special 
characters are <I>?</I> (any single character), 
<I>*</I> (zero or more characters), and <I>#</I> (any single 
digit). Here are a few examples:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' The Like operator is affected by the current Option Compare setting.
Option Compare Text                 ' Enforce case-insensitive comparisons.
' Check that a string consists of &quot;AB&quot; followed by three digits.
If value Like &quot;AB###&quot; Then ...      ' e.g. &quot;AB123&quot; or &quot;ab987&quot;
' Check that a string starts with &quot;ABC&quot; and ends with &quot;XYZ&quot;.
If value Like &quot;ABC*XYZ&quot; Then ...    ' e.g. &quot;ABCDEFGHI-VWXYZ&quot;
' Check that starts with &quot;1&quot;, ends with &quot;X&quot;, and includes 5 chars.
If value Like &quot;1???X&quot; Then ...      ' e.g. &quot;1234X&quot; or &quot;1uvwx&quot;
</pre>
</td></tr>
</table></p>

<p>You can also specify which characters you want to include (or exclude) in 
the search by inserting a list enclosed in square brackets:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' One of the letters &quot;A&quot;,&quot;B&quot;,&quot;C&quot; followed by three digits
If value Like &quot;[A-C]###&quot; Then ...           ' e.g. &quot;A123&quot; or &quot;c456&quot;
' Three letters, the first one must be a vowel
If value Like &quot;[AEIOU][A-Z][A-Z]&quot; Then...  ' e.g. &quot;IVB&quot; or &quot;OOP&quot;
' At least three characters, the first one can't be a digit.
' Note: a leading &quot;!&quot; symbol excludes a range.
If value Like &quot;[!0-9]??*&quot; Then ...  ' e.g. &quot;K12BC&quot; or &quot;ABHIL&quot;
</pre>
</td></tr>
</table></p>

<p><img src="images/new.jpg" width=102 height=87 border=0></p>

<p> Visual Basic 6 introduces the new 
<I>Replace</I> function, which quickly finds 
and replaces substrings. The syntax of this function isn't straightforward because 
the function includes several optional arguments:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Text = Replace(Source, Find, Replace, [Start], [Count], [CompareMethod])
</pre>
</td></tr>
</table></p>

<p>The simplest form searches substrings in case-sensitive mode and replaces 
all occurrences:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Print Replace(&quot;abc ABC abc&quot;, &quot;ab&quot;, &quot;123&quot;)         ' &quot;123c ABC 123c&quot;
</pre>
</td></tr>
</table></p>

<p>By acting on the other arguments, you can start your search from a 
different position, limit the number of substitutions, and perform a case-insensitive search. 
Note that a value for <I>start </I>greater than 1 actually trims the source argument before 
starting the search:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Print Replace(&quot;abc ABC abc&quot;, &quot;ab&quot;, &quot;123&quot;, 5, 1)                ' &quot;ABC 123c&quot;
Print Replace(&quot;abc ABC abc&quot;, &quot;ab&quot;, &quot;123&quot;, 5, 1, vbTextCompare) ' &quot;123C abc&quot;
</pre>
</td></tr>
</table></p>

<p>You can also use the <I>Replace </I>function in a somewhat unorthodox way to 
count the number of occurrences of a substring inside another string:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Function InstrCount(Source As String, Search As String) As Long
    ' You get the number of substrings by subtracting the length of the 
    ' original string from the length of the string that you obtain by 
    ' replacing the substring with another string that is one char longer.
    InstrCount = Len(Replace(Source, Search, Search &amp; &quot;*&quot;)) - Len(Source)
End Function
</pre>
</td></tr>
</table></p>

<p><img src="images/new.jpg" width=102 height=87 border=0></p>

<p>The new <I>StrReverse</I> function quickly reverses the order of characters in a 
string. This function is rarely useful in itself, but it adds value to other 
string-processing functions:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Replace only the LAST occurrence of a substring.
Function ReplaceLast(Source As String, Search As String, _
    ReplaceStr As String) As String
        ReplaceLast = StrReverse(Replace(StrReverse(Source), _
            StrReverse(Search), StrReverse(ReplaceStr), , 1))
End Function
</pre>
</td></tr>
</table></p>

<p><img src="images/new.jpg" width=102 height=87 border=0></p>

<p>You can use the new <I>Split</I> function to find all the delimited items in a string. 
Its syntax is the following:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
arr() = Split(Source, [Delimiter], [Limit], [CompareMethod])
</pre>
</td></tr>
</table></p>

<p>where <I>delimiter </I>is the character used to delimit individual items. You can pass 
a positive value for the <I>limit </I>argument if you don't want more items than a given 
value, and you can pass the <I>vbTextCompare</I> value to the last argument to perform 
case-insensitive searches. Since the default delimiter character is the space, you can 
easily extract all the words in a sentence using this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Dim words() As String
words() = Split(&quot;Microsoft Visual Basic 6&quot;)
' words() is now a zero-based array with four elements.
</pre>
</td></tr>
</table></p>

<p><img src="images/new.jpg" width=102 height=87 border=0></p>

<p>The <I>Join</I> function is complementary to the 
<I>Split</I> function in that it accepts an array of strings and one delimiter character and rebuilds the original string:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Continuing the preceding example ...
' The delimiter argument is optional here, because it defaults to &quot; &quot;.
Print Join(words, &quot; &quot;)       ' Displays &quot;Microsoft Visual Basic 6&quot;
</pre>
</td></tr>
</table></p>

<p><img src="images/new.jpg" width=102 height=87 border=0></p>

<p>Note that the delimiter argument in both the 
<I>Split </I>and <I>Join </I>functions can be longer than just one character.</p>

<p>Another welcome addition to the VBA language is the 
<I>Filter</I> function, which quickly scans an array searching for a substring and returns another array that 
contains only the items that include (or don't include) the searched substring. The 
syntax for the <I>Filter</I> function is the following:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
arr() = Filter(Source(), Search, [Include], [CompareMethod])
</pre>
</td></tr>
</table></p>

<p>If the <I>Include </I>argument is True or omitted, the result array contains all the 
items in <I>source</I> that contain the <I>search 
</I>substring; if it's False, the result array contains 
only the items that don't contain it. As usual, the 
<I>CompareMethod </I>argument specifies whether the search is case sensitive:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
ReDim s(2) As String
s(0) = &quot;First&quot;: s(1) = &quot;Second&quot;: s(2) = &quot;Third&quot;
Dim res() As String
res = Filter(s, &quot;i&quot;, True, vbTextCompare)
' Print the result array  (&quot;First&quot; and &quot;Third&quot;).
For i = 0 To UBound(res): Print res(i): Next
</pre>
</td></tr>
</table></p>

<p>If no items in the source array meet the search requirements, the 
<I>Filter</I> function delivers a special array that returns _1 when passed to the 
<I>UBound</I> function.</p>

<A NAME="178"><h2>Format Options for Strings</h2></A>
<p>You can also use the <I>Format</I> function to format strings. In this case, you can 
specify only a custom format (no named formats are available for string data) and you 
have a limited choice of special characters, but you can get a lot of flexibility anyway. 
You can specify two sections, one for non-empty string values and one for empty 
string values as shown below.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' By default, placeholders are filled from right to left.
' &quot;@&quot; stands for a character or a space, &quot;&amp;&quot; is a character or nothing.
Print Format(&quot;abcde&quot;, &quot;@@@@@@@&quot;)                          ' &quot;  abcde&quot;
' You can exploit this feature to right align numbers in reports.
Print Format(Format(1234.567, &quot;Currency&quot;), &quot;@@@@@@@@@@@&quot;) ' &quot;  $1,234.57&quot;
' &quot;!&quot; forces left to right fill of placeholders.
Print Format(&quot;abcde&quot;, &quot;!@@@@@@@&quot;)                         ' &quot;abcde  &quot;
' &quot;&gt;&quot; forces to uppercase, &quot;&lt;&quot; forces to lowercase.
Print Format(&quot;abcde&quot;, &quot;&gt;&amp; &amp; &amp; &amp; &amp;&quot;)                       ' &quot;A B C D E&quot;
' This is a good way to format phone numbers or credit-card numbers.
Print Format(&quot;6152127865&quot;, &quot;&amp;&amp;&amp;-&amp;&amp;&amp;-&amp;&amp;&amp;&amp;&quot;)                ' &quot;615-212-7865&quot;
' Use a second section to format empty strings.
' &quot;\&quot; is the escape character.
Print Format(&quot;&quot;, &quot;!@@@@@@@;\n\o\n\e&quot;)                     ' &quot;none&quot;
</pre>
</td></tr>
</table>
</p>

</BODY>
</HTML>





