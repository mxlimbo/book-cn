<HTML>
<HEAD>
<TITLE>System Functions</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("chaab.htm", "chaad.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="1053"><h1>System Functions</h1></A>

<p>Many internal Windows values and parameters are beyond Visual Basic's 
capabilities, but they're just an API function call away. In this section, I show how you 
can retrieve some important system settings and how you can augment Visual 
Basic support for the mouse and the keyboard.
</p>

<A NAME="1054"><h2>Windows Directories and Versions</h2></A>

<p>Even though Visual Basic hides most of the complexities of the operating system, 
as well as the differences among the many Windows versions around, sometimes 
you must distinguish one from another&#8212;for example to account for minor 
differences between Windows 9x and Windows NT. You can do this by examining the 
higher-order bit of the Long value returned by the 
<I>GetVersion </I>API function:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Declare Function GetVersion Lib &quot;kernel32&quot; () As Long

If GetVersion() And &amp;H80000000 Then
    MsgBox &quot;Running under Windows 95/98&quot;
Else
    MsgBox &quot;Running under Windows NT&quot;
End If
</pre>
</td></tr>
</table>
</p>

<p>If you need to determine the actual Windows version, you need 
the <I>GetVersionEx </I>API function, which returns information about the running 
operating system in a UDT:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Type OSVERSIONINFO
    dwOSVersionInfoSize As Long
    dwMajorVersion As Long
    dwMinorVersion As Long
    dwBuildNumber As Long
    dwPlatformId As Long
    szCSDVersion As String * 128
End Type

Private Declare Function GetVersionEx Lib &quot;kernel32&quot; Alias _ 
    &quot;GetVersionExA&quot; (lpVersionInformation As OSVERSIONINFO) As Long

Dim os As OSVERSIONINFO, ver As String
' The function expects the UDT size in the UDT's first element.
os.dwOSVersionInfoSize = Len(os)
GetVersionEx os
ver = os.dwMajorVersion &amp; &quot;.&quot; &amp; Right$(&quot;0&quot; &amp; Format$(os.dwMinorVersion), 2)
Print &quot;Windows Version = &quot; &amp; ver
Print &quot;Windows Build Number = &quot; &amp; os.dwBuildNumber
</pre>
</td></tr>
</table>
</p>

<p>Windows 95 returns a version number 4.00, whereas Windows 98 returns 
version 4.10. (See Figure A-4.) You can use the build number to identify different 
service packs.
</p>

<p>All tips and tricks collections show how you can retrieve the path to the 
main Windows and System directories, which are often useful for locating other files 
that might interest you. These functions are helpful for another reason as well: They 
show you how to receive strings from an API function. In general, no API function 
directly returns a string; instead, all the functions that return a string value to the 
calling program require that you create a receiving string buffer&#8212;typically, a string filled 
with spaces or null characters&#8212;and you pass it to the routine. Most of the time, you 
must pass the buffer's length in another argument so that the API function doesn't 
accidentally write in the buffer more characters than allowed. For example, this is 
the declaration of the <I>GetWindowsDirectory</I> API function:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Declare Function GetWindowsDirectory Lib &quot;kernel32&quot; Alias _
    &quot;GetWindowsDirectoryA&quot; (ByVal lpBuffer As String, _
    ByVal nSize As Long) As Long
</pre>
</td></tr>
</table>
</p>

<p>
<A HREF="javascript:fullSize('F_APH04x.htm')"> <img src="images/F_APH04.JPG" width=404 height=172 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure A-4.</B> <i>The sample program demonstrates several system, keyboard, and mouse API functions.</i><!--/caption-->
</p>

<p>You use this function by allocating a large-enough buffer, and then you pass 
it to the function. The return value of the function is the actual number of 
characters in the result string, and you can use this value to trim off characters in excess:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim buffer As String, length As Integer
buffer = Space$(512)
length = GetWindowsDirectory(buffer, Len(buffer))
Print &quot;Windows Directory = &quot; &amp; Left$(buffer, length)
</pre>
</td></tr>
</table>
</p>

<p>You can use the same method to determine the path of the 
Windows\System directory, using the <I>GetSystemDirectory 
</I>API function:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Declare Function GetSystemDirectory Lib &quot;kernel32&quot; Alias _
    &quot;GetSystemDirectoryA&quot; (ByVal lpBuffer As String, _
    ByVal nSize As Long) As Long

Dim buffer As String, length As Integer
buffer = Space$(512)
length = GetSystemDirectory(buffer, Len(buffer))
Print &quot;System Directory = &quot; &amp; Left$(buffer, length)
</pre>
</td></tr>
</table>
</p>

<p>The <I>GetTempPath </I>API function uses a similar syntax&#8212;although the order 
of arguments is reversed&#8212;and returns a valid directory name for storing temporary 
files, including a trailing backslash character (such as C:\WINDOWS\TEMP\):
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Declare Function GetTempPath Lib &quot;kernel32&quot; Alias &quot;GetTempPathA&quot; _
    (ByVal nBufferLength As Long, ByVal lpBuffer As String) As Long

Dim buffer As String, length As Integer
buffer = Space$(512)
length = GetTempPath (Len(buffer), buffer)
Print &quot;Temporary Directory = &quot; &amp; Left$(buffer, length)
</pre>
</td></tr>
</table>
</p>

<p>The <I>GetUserName </I>function returns the name of the user currently logged in. 
At a first glance this function appears to use the same syntax as the functions I've 
just described. The documentation reveals, however, that it doesn't return the length 
of the result but just a zero value to indicate a failure or 1 to indicate the success of 
the operation. In this situation, you must extract the result from the buffer by 
searching for the Null character that all API functions append to result strings:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Declare Function GetUserName Lib &quot;advapi32.dll&quot; Alias _
    &quot;GetUserNameA&quot; (ByVal lpBuffer As String, nSize As Long) As Long

Dim buffer As String * 512, length As Long
If GetUserName buffer, Len(buffer) Then 
    ' Search the trailing Null character.
    length = InStr(buffer, vbNullChar) - 1
    Print &quot;User Name = &quot; &amp; Left$(buffer, length)
Else
    Print &quot;GetUserName function failed&quot;
End If
</pre>
</td></tr>
</table>
</p>

<p>The <I>GetComputerName </I>API function, which retrieves the name of the 
computer that's executing the program, uses yet another method: You must pass the length 
of the buffer in a <I>ByRef</I> argument. On exit from the function, this argument holds 
the length of the result:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Declare Function GetComputerName Lib &quot;kernel32&quot; Alias _
    &quot;GetComputerNameA&quot; (ByVal lpBuffer As String, nSize As Long) As Long

Dim buffer As String * 512, length As Long
length = Len(buffer)
If GetComputerName(buffer, length) Then
    ' Returns nonzero if successful, and modifies the length argument
    MsgBox &quot;Computer Name = &quot; &amp; Left$(buffer, length)
End If
</pre>
</td></tr>
</table>
</p>



<A NAME="1055"><h2>The Keyboard</h2></A>

<p>Visual Basic's keyboard events let you know exactly which keys are pressed 
and when. At times, however, it's useful to determine whether a given key is pressed 
even when you're not inside a keyboard event procedure. The pure Visual Basic 
solution is to store the value of the pressed key in a module-level or a global variable, 
but it's a solution that negatively impacts the reusability of the code. Fortunately, you 
can easily retrieve the current state of a given key using the 
<I>GetAsyncKeyState</I> function:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Declare Function GetAsyncKeyState Lib &quot;user32&quot; _
    (ByVal vKey As Long) As Integer
</pre>
</td></tr>
</table>
</p>

<p>This function accepts a virtual key code and returns an Integer value whose 
high-order bit is set if the corresponding key is pressed. You can use all the Visual 
Basic vbKey<I>xxxx</I> symbolic constants as arguments to this function. For example, you 
can determine whether any of the shift keys is being pressed using this code:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim msg As String
If GetAsyncKeyState(vbKeyShift) And &amp;H8000 Then msg = msg &amp; &quot;SHIFT &quot;
If GetAsyncKeyState(vbKeyControl) And &amp;H8000 Then msg = msg &amp; &quot;CTRL &quot;
If GetAsyncKeyState(vbKeyMenu) And &amp;H8000 Then msg = msg &amp; &quot;ALT &quot;
' lblKeyboard is a Label control that displays the shift key states.
lblKeyboard.Caption = msg
</pre>
</td></tr>
</table>
</p>

<p>An interesting characteristic of the <I>GetAsynchKeyState 
</I>function is that it works even if the application doesn't have the input focus. This capability lets you build 
a Visual Basic program that reacts to hot keys even if users press them while 
they're working with another application. To use this API function to trap hot keys, you 
need to add some code into a Timer control's <I>Timer 
</I>event procedure and set the Timer's <I>Interval</I> property to a small enough value&#8212;for example, 200 milliseconds:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Detect the Ctrl+Alt+A key combination.
Private Sub Timer1_Timer()
    If GetAsyncKeyState(vbKeyA) And &amp;H8000 Then
        If GetAsyncKeyState(vbKeyControl) And &amp;H8000 Then
            If GetAsyncKeyState(vbKeyMenu) And &amp;H8000 Then
                ' Process the Ctrl+Alt+A hot key here.
            End If
        End If
    End If
End Sub
</pre>
</td></tr>
</table>
</p>

<p>You can streamline your code by taking advantage of the following 
reusable routine, which can test the state of up to three keys:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function KeysPressed(KeyCode1 As KeyCodeConstants, Optional KeyCode2 As _
    KeyCodeConstants, Optional KeyCode3 As KeyCodeConstants) As Boolean
    If GetAsyncKeyState(KeyCode1) &gt;= 0 Then Exit Function
    If KeyCode2 = 0 Then KeysPressed = True: Exit Function
    If GetAsyncKeyState(KeyCode2) &gt;= 0 Then Exit Function
    If KeyCode3 = 0 Then KeysPressed = True: Exit Function
    If GetAsyncKeyState(KeyCode3) &gt;= 0 Then Exit Function
    KeysPressed = True
End Function
</pre>
</td></tr>
</table>
</p>

<p>The three arguments are declared as KeyCodeConstant (an enumerated 
type defined in the Visual Basic runtime library), so that IntelliSense automatically 
helps you write the code for this function. See how you can rewrite the previous 
example that traps the Ctrl+Alt+A hot key:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>If KeysPressed(vbKeyA, vbKeyMenu, vbKeyControl) Then
    ' Process the Ctrl+Alt+A hot key here.
End If
</pre>
</td></tr>
</table>
</p>

<p>You can also modify the current state of a key, say, to programmatically 
change the state of the CapsLock, NumLock, and ScrollLock keys. For an example of 
this technique, see the &quot;<A HREF="ch10g.htm#468">Toggling the State of Lock Keys</A>&quot; section in Chapter 10.
</p>

<A NAME="1056"><h2>The Mouse</h2></A>

<p>The support Visual Basic offers to mouse programming is defective in a few 
areas. As is true for the keyboard and its event procedures, you can derive a few bits 
of information about the mouse's position and the state of its buttons only inside 
a <I>MouseDown</I>, <I>MouseUp</I>, or <I>MouseMove 
</I>event procedure, which makes the creation of reusable routines in BAS modules a difficult task. Even more annoying, mouse 
events are raised only for the control under the mouse cursor, which forces you to write 
a lot of code just to find out where the mouse is in any given moment. 
Fortunately, querying the mouse through an API function is really simple.
</p>

<p>To begin with, you don't need a special function to retrieve the state of 
mouse buttons because you can use the <I>GetAsyncKeyState 
</I>function with the special vbKeyLButton, vbKeyRButton, and vbKeyMButton symbolic constants. Here's a 
routine that returns the current state of mouse buttons in the same bit-coded format 
as the <I>Button</I> parameter received by <I>Mouse</I>xxxx event procedures:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function MouseButton() As Integer
    If GetAsyncKeyState(vbKeyLButton) &lt; 0 Then
        MouseButton = 1
    End If
    If GetAsyncKeyState(vbKeyRButton) &lt; 0 Then 
        MouseButton = MouseButton Or 2
    End If
    If GetAsyncKeyState(vbKeyMButton) &lt; 0 Then
        MouseButton = MouseButton Or 4
    End If
End Function
</pre>
</td></tr>
</table>
</p>

<p>The Windows API includes a function for reading the position of the 
mouse cursor:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Type POINTAPI
    X As Long
    Y As Long
End Type

Private Declare Function GetCursorPos Lib &quot;user32&quot; (lpPoint As POINTAPI) _
    As Long
</pre>
</td></tr>
</table>
</p>

<p>In both cases the coordinates are in pixels and relative to the screen:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Display current mouse screen coordinates in pixels using a Label control.
Dim lpPoint As POINTAPI
GetCursorPos lpPoint
lblMouseState = &quot;X = &quot; &amp; lpPoint.X &amp; &quot;   Y = &quot; &amp; lpPoint.Y
</pre>
</td></tr>
</table>
</p>

<p>To convert screen coordinates to a pair of coordinates relative to the 
client area of a window&#8212;that is, the area of a window inside its border&#8212;you can use 
the <I>ScreenToClient </I>API function:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Declare Function ScreenToClient Lib &quot;user32&quot; (ByVal hWnd As Long, _
    lpPoint As POINTAPI) As Long

' Display mouse screen coordinates relative to current form.
Dim lpPoint As POINTAPI
GetCursorPos lpPoint
ScreenToClient Me.hWnd, lpPoint
lblMouseState = &quot;X = &quot; &amp; lpPoint.X &amp; &quot;   Y = &quot; &amp; lpPoint.Y
</pre>
</td></tr>
</table>
</p>

<p>The <I>SetCursorPos </I>API function lets you move the mouse cursor anywhere 
on the screen, something that you can't do with standard Visual Basic code:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Declare Function SetCursorPos Lib &quot;user32&quot; (ByVal X As Long, _
    ByVal Y As Long) As Long
</pre>
</td></tr>
</table>
</p>

<p>When you use this function, you often need to convert from client 
coordinates to screen coordinates, which you do with the 
<I>ClientToScreen </I>API function. The following code snippet moves the mouse cursor to the center of a push button:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Declare Function ClientToScreen Lib &quot;user32&quot; (ByVal hWnd As Long, _
    lpPoint As POINTAPI) As Long

' Get the coordinates (in pixels) of the center of the Command1 button.
' The coordinates are relative to the button's client area.
Dim lpPoint As POINTAPI
lpPoint.X = ScaleX(Command1.Width / 2, vbTwips, vbPixels)
lpPoint.Y = ScaleY(Command1.Height / 2, vbTwips, vbPixels)
' Convert to screen coordinates.
ClientToScreen Command1.hWnd, lpPoint
' Move the mouse cursor to that point.
SetCursorPos lpPoint.X, lpPoint.Y
</pre>
</td></tr>
</table>
</p>

<p>In some circumstances, for example, during drag-and-drop operations, you 
might want to prevent the user from moving the mouse outside a given region. You 
can achieve this behavior by setting up a rectangular 
<I>clipping area</I> with the <I>ClipCursor </I>API function. You'll often need to clip the mouse cursor to a given window, 
which you can do by retrieving the window's client area rectangle with the 
<I>GetClientRect </I>API function and convert the result to screen coordinates. The following routine 
does everything for you:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Declare Function ClipCursor Lib &quot;user32&quot; (lpRect As Any) As Long

Sub ClipMouseToWindow(ByVal hWnd As Long)
    Dim lpPoint As POINTAPI, lpRect As RECT
    ' Retrieve the coordinates of the upper-left corner of the window.
    ClientToScreen hWnd, lpPoint
    ' Get the client screen rectangle.
    GetClientRect hWnd, lpRect
    ' Manually convert the rectangle to screen coordinates.
    lpRect.Left = lpRect.Left + lpPoint.X
    lpRect.Top = lpRect.Top + lpPoint.Y
    lpRect.Right = lpRect.Right + lpPoint.X
    lpRect.Bottom = lpRect.Bottom + lpPoint.Y
    ' Enforce the clipping.
    ClipCursor lpRect
End Sub
</pre>
</td></tr>
</table>
</p>

<p>Here's an example that uses the previous routine and then cancels the 
clipping effect:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Clip the mouse cursor to the current form's client area.
ClipMouseToWindow Me.hWnd
 ...
' When you don't need the clipping any longer. (Don't forget this!)
ClipCursor ByVal 0&amp;
</pre>
</td></tr>
</table>
</p>

<p>(Remember that a window automatically loses the mouse capture if it 
executes a <I>MsgBox </I>or <I>InputBox </I>statement.) Windows normally sends mouse messages 
to the window under the cursor. The only exception to this rule occurs when the 
user presses a mouse button on a window and then drags the mouse cursor outside it. 
In this situation, the window continues to receive mouse messages until the button 
is released. But sometimes it's convenient to receive mouse notifications even when 
the mouse is outside the window's boundaries.
</p>

<p>Consider the following situation: You want to provide the user with a visual 
clue when the mouse cursor enters the area of a control, for example by changing 
the control's background color. You can achieve this effect simply by changing the 
control's <I>BackColor </I>property in its <I>MouseMove 
</I>event because this event fires as soon as the mouse cursor hovers over the control. Unluckily, Visual Basic doesn't fire an 
event in a control when the mouse cursor exits its client area. Using pure Visual Basic, 
you're forced to write code inside the 
<I>MouseMove</I> events of the forms and of all the 
other controls on the form's surface, or you must have a Timer that periodically 
monitors where the mouse is. In no case is this an elegant or an efficient solution.
</p>

<p>A better approach would be to capture<I> </I>the mouse when the cursor enters 
the control's client area, using the <I>SetCapture 
</I>API function. When a form or a control captures the mouse, it receives mouse messages until the user clicks outside 
the form or the control or until the mouse capture is explicitly relinquished through 
a <I>ReleaseCapture </I>API function. This technique permits you to solve the problem 
by writing code in one single procedure:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Add these declarations to a BAS module.
Private Declare Function SetCapture Lib &quot;user32&quot; (ByVal hWnd As Long) _
    As Long
Private Declare Function ReleaseCapture Lib &quot;user32&quot; () As Long
Private Declare Function GetCapture Lib &quot;user32&quot; () As Long

' Change the BackColor of Frame1 control to yellow when the mouse enters 
' the control's client area, and restore it when the mouse leaves it.
Private Sub Frame1_MouseMove(Button As Integer, Shift As Integer, _
    X As Single, Y As Single)
    ' Set the mouse capture unless the control already has it. 
    ' (The GetCapture API function returns the handle of the window that 
    ' has the mouse capture.)
    If GetCapture &lt;&gt; Frame1.hWnd Then
        SetCapture Frame1.hWnd
        Frame1.BackColor = vbYellow
    ElseIf X &lt; 0 Or Y &lt; 0 Or X &gt; Frame1.Width Or Y &gt; Frame1.Height Then
        ' If the mouse cursor is outside the Frame's client area, release
        ' the mouse capture and restore the BackColor property.
        ReleaseCapture
        Frame1.BackColor = vbButtonFace
    End If
End Sub
</pre>
</td></tr>
</table>
</p>

<p>You can see this technique in action in the demonstration program shown 
in Figure A-4. Anytime the user moves the mouse onto or away from the topmost 
Frame control, its background color changes.
</p>

<p>The <I>WindowsFromPoint </I>API function often comes handy when you're 
working with the mouse because it returns the handle of the window at given 
screen coordinates:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Declare Function WindowFromPointAPI Lib &quot;user32&quot; Alias _
    &quot;WindowFromPoint&quot; (ByVal xPoint As Long, ByVal yPoint As Long) As Long
</pre>
</td></tr>
</table>
</p>

<p>The following routine returns the handle of the window under the mouse 
cursor:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function WindowFromMouse() As Long
    Dim lpPoint As POINTAPI
    GetCursorPos lpPoint
    WindowFromMouse = WindowFromPoint(lpPoint.X, lpPoint.Y)
End Function
</pre>
</td></tr>
</table>
</p>

<p>For example, you can quickly determine from within a form module which control is under the 
mouse cursor using the following approach:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim handle As Long, ctrl As Control
On Error Resume Next
handle = WindowFromMouse()
For Each ctrl In Me.Controls
    If ctrl.hWnd &lt;&gt; handle Then
        ' Not on this control, or hWnd property isn't supported.
    Else
        ' For simplicity's sake, this routine doesn't account for elements
        ' of control arrays.
        Print &quot;Mouse is over control &quot; &amp; ctrl.Name
        Exit For
    End If
Next
</pre>
</td></tr>
</table>
</p>

<p>For more information, see the source code of the demonstration application 
on the companion CD.
</p>

</BODY>
</HTML>





