<HTML>
<HEAD>
<TITLE>The TreeView Control</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch10b.htm", "ch10d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="419"><h1>The TreeView Control</h1></A>

<p> The TreeView control is probably the first Windows common control that 
users become acquainted with because it's the control Windows Explorer is based 
on. Basically, the TreeView control displays a hierarchy of items. A plus sign beside 
an item indicates that it has one or more child items. An item that has child items 
can be expanded to show them or collapsed to hide them. This can be done 
interactively by the user or via code.</p>

<p>The Visual Basic 6 version of the TreeView control has a number of 
improvements and now supports check boxes beside each item and full row 
selection. Moreover, individual nodes can have different 
<I>Bold</I>, <I>Foreground</I>, and 
<I>Background</I> attributes.</p>

<p>The TreeView control exposes a Nodes collection, which in turn includes 
all the Node objects that have been added to the control. Each individual Node 
object exposes a number of properties that let you define the look of the control. 
Typically, a TreeView control has one single root Node object, but you can also create 
multiple Node objects at the root level.</p>

<A NAME="420"><h2>Setting Design-Time Properties</h2></A>

<p>Immediately after creating a TreeView control on a form, you should display its 
Properties dialog box (shown in Figure 10-5), which you do by right-clicking on the 
control and selecting the Properties menu item. Of course, you can also set properties 
that appear in this page at run time, but you rarely need to change the appearance of 
a TreeView control once it has been displayed to the user.</p>

<p>The <I>Style </I>property affects which graphical elements will be used inside 
the control. A TreeView control can display four graphical elements: the text 
associated with each Node object, the picture associated with each Node object, a plus or 
minus sign beside each Node object (to indicate whether the Node is in collapsed 
or expanded state), and the lines that go from each Node object to its child objects. 
The <I>Style</I> property can be assigned one of eight values, each one representing a 
different combination of these four graphical elements. In most cases, you use the 
default value, 7-tvwTreelinesPlusMinusPictureText, which displays all graphical elements.</p>

<p>
<img src="images/F10ph05x.gif" width=422 height=370 border=0>
</p><p>
<!--caption--><B>Figure 10-5.</B> <i>The General tab of the Properties dialog box of a TreeView control.</i><!--/caption-->
</p>

<p>The <I>LineStyle </I>property affects how lines are drawn. The value 
0-tvwTreeLines doesn't display lines among root Node objects (this is the default setting), 
whereas the value 1-tvwRootLines also displays lines among all root Nodes and makes 
them appear as if they were children of a fictitious Node located at an upper level. 
The <I>Indentation </I>property states the distance in twips between vertical dotted lines.</p>

<p>The <I>LabelEdit</I> property affects how the end user can modify the text 
associated with each Node object. If it's assigned the value 0-tvwAutomatic (the default), the 
end user can edit the text by clicking on the Node at run time; if it's assigned the 
value 1-tvwManual, the edit operation can be started only programmatically, by your 
issuing a <I>StartLabelEdit</I> method.</p>

<p>The ImageList combo box lets you select which ImageList control will be 
used to retrieve the images of individual Node objects. The combo box lists all the 
ImageList controls located on the current form.</p>

<p><DIV CLASS="TIP"><BLOCKQUOTE><B>TIP</B><HR>You can associate a TreeView control (or any control) with an 
ImageList control located on another form by making the assignment at run time, as 
shown in this code:
<P><TABLE><TR><TD><PRE>
Private Sub Form_Load()
    Set TreeView1.ImageList = AnotherForm.ImageList1
End Sub
</PRE></TD></TR></TABLE></P>

<p>This technique allows you to use a group of bitmaps and icons in all the forms 
of your application without having to duplicate them and thus shrink the size of 
the EXE file. This way, you save memory and resources at run time.</P>
</BLOCKQUOTE></DIV></P>

<p>The <I>HideSelection</I> property determines whether the selected Node object 
will continue to be highlighted when the TreeView control loses the focus. The 
<I>PathSeparator</I> property states which character or string should be used in the 
<I>FullPath</I> property of the Node object. The default value for the 
<I>PathSeparator</I> property is the backslash character. For example, if you have a root Node labeled 
&quot;<I>Root&quot; </I>and a child Node labeled 
&quot;<I>FirstChild&quot;,</I> the <I>FullPath</I> property of the child Node will 
be &quot;<I>Root\FirstChild&quot;.</I></P>

<p>The <I>Sorted</I> property states whether Nodes in the control are 
automatically sorted in alphabetical order. The documentation omits an important 
detail: This property affects only how root Node objects are sorted but has no effect on the 
order of child Node objects at lower levels. If you want all the branches of the tree to 
be sorted, you should set the <I>Sorted</I> properties of all individual Node items to True.</P>

<P>
<img src="images/new.jpg" width=102 height=87 border="0">
</P>

<p>The TreeView control that comes with Visual Basic 6 adds a few 
interesting properties not available in previous versions of the language. The 
<I>FullRowSelect </I>property, if True, causes a Node of the control to be selected if the user clicks 
anywhere on its row. (By default, this property is False, in which case an item can 
be selected only with a click over it or its plus or minus symbol.)</P>

<p>If you set the <I>Checkboxes </I>property to True, a check box appears beside 
each Node object so that the end user can select multiple Node objects.</P>

<p>By default, you need to double-click on Node items to expand or collapse 
them (or click on the plus or minus sign, if present), and you can expand and collapse 
any number of tree branches independently of one another. But if you set the 
<I>SingleSel </I>property to True, the control's behavior is different: You expand and collapse 
items with a single click&#8212;that is, as soon as you select them. Moreover, when you 
expand a Node, the item that was previously expanded is automatically collapsed.</P>

<p>The <I>Scroll</I> property determines whether the TreeView control displays a 
vertical or horizontal scroll bar if necessary. The default value is True, but you can set 
it to False to disable this behavior (even though, honestly, I can't find a reason 
why you would want to do that).</P>

<p>Finally the <I>HotTracking </I>property lets you create a Web-like user interface. If 
you set this property to True, the cursor changes into a hand when the mouse passes 
over the Node object and the TreeView control underlines the Node's 
<I>Text </I>property.</P>

<A NAME="421"><h2>Run-Time Operations</h2></A>

<p>To fully exploit the potential of the TreeView control, you must learn to deal 
with the Nodes collections and the many properties and methods of Node objects.</P>

<A NAME="422"><h3>Adding Node objects</h3></A>

<p>One of the shortcomings of the TreeView control is that you can't add items at 
design time as you can with ListBox and ComboBox controls. You can add Node objects 
only at run time using the <I>Add</I> method of the Nodes collection.The 
<I>Add </I>method's syntax is the following:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Add([Relative],[Relationship],[Key],[Text],[Image],[SelectedImage]) As Node
</pre>
</td></tr>
</table>
</p>


<p><I>Relative</I> and <I>Relationship </I>indicate where the new Node should be inserted. 
<I>Key </I>is its string key in the Nodes collection, 
<I>Text </I>is the label that will appear in the 
control, and <I>Image </I>is the index or the string key in the companion ImageList control 
of the image that will appear beside the Node. <I>SelectedImage 
</I>is the index or key of the image that will be used when the Node is selected. For example, if you're 
creating a TreeView control that mimics Windows Explorer and its directory objects, you 
might write something like this:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim nd As Node
Set nd  = Add(, , ,&quot;C:\System&quot;, &quot;Folder&quot;, &quot;OpenFolder&quot;)
</pre>
</td></tr>
</table>
</p>


<p>To place the new Node in a given position in the tree, you must provide 
the first two arguments. The first argument specifies an existing item in the Nodes 
collection by its numerical index or string key; the second argument states the 
relationship between the Node being added and its relative. Such a relationship can 
be 0-tvwFirst, in which the new Node becomes the first item at the level of its 
relative&#8212;in other words, it becomes the first sibling of the relative Node. Or the 
relationship can be 1-tvwLast (the new Node becomes the last sibling of the relative Node); 
2-tvwNext (default, the new Node is added immediately after the relative Node, at 
the same level in the hierarchy); 3-tvwPrevious (the new Node is inserted 
immediately before the relative Node, at the same level in the hierarchy); or 4-tvwChild (the 
new Node becomes a child of the relative Node and is inserted after all existing child 
nodes).</P>

<p>Here's an example of a routine that fills a TreeView control with the 
structure of an MDB file&#8212;that is, the tables it contains and the fields for each table. The 
routine accepts a reference to the control in its second argument so that you can 
easily reuse it in your applications. The third argument passed to the routine is a 
Boolean value that states whether system tables should be displayed:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub ShowDatabaseStructure(MdbFile As String, TV As TreeView, _
    ShowSystemTables As Boolean)
    Dim db As DAO.Database, td As DAO.TableDef, fld As DAO.Field
    Dim nd As Node, nd2 As Node
    ' Clear the current contents of the TreeView control.
    TV.Nodes.Clear
    ' Open the database.
    Set db = DBEngine.OpenDatabase(MdbFile)
    ' Add the root Node, and then expand it to show the tables.
    Set nd = TV.Nodes.Add(, , &quot;Root&quot;, db.Name, &quot;Database&quot;)
    nd.Expanded = True

    ' Explore all the tables in the database.
    For Each td In db.TableDefs
        ' Discard system tables if user isn't interested in them.
        If (td.Attributes And dbSystemObject) = 0 Or ShowSystemTables Then
            ' Add the table under the Root object.
            Set nd = TV.Nodes.Add(&quot;Root&quot;, tvwChild, , td.Name, &quot;Table&quot;)
            ' Now add all the fields.
            For Each fld In td.Fields
                Set nd2 = TV.Nodes.Add(nd.Index, tvwChild, , _
                    fld.Name, &quot;Field&quot;)
                Next
            End If
    Next
    db.Close
End Sub
</pre>
</td></tr>
</table>
</p>


<p>Note that the routine doesn't include any error handler: if the file doesn't 
exist or is an invalid or corrupted MDB archive, the error is simply returned to the 
caller. It's usual to show a TreeView control with the root object already expanded in 
order to save the end user a mouse click. The routine does this by setting the root 
Node object's <I>Expanded</I> property to True.</P>

<A NAME="423"><h3>Appearance and visibility</h3></A>
<P>
<img src="images/new.jpg" width=102 height=87 border="0">
</P>

<p>You can control the appearance of individual Node objects by setting their 
<I>ForeColor</I>, <I>BackColor</I>,<I> </I>and <I>Bold 
</I>properties, the effects of which are shown in Figure 10-6. 
This new feature permits you to visually convey more information about each 
Node. Typically, you set these properties when you add an item to the Nodes collection:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>With TV.Nodes.Add(, , , &quot;New Node&quot;)
    .Bold = True
    .ForeColor = vbRed
    .BackColor = vbYellow
End With
</pre>
</td></tr>
</table>
</p>


<p>
<img src="images/F10ph06.GIF" width=257 height=97 border="0">
<p>
<!--caption--><B>Figure 10-6.</B> <i>Effects of the ForeColor, BackColor, and Bold properties of Node objects, as well as of the Checkboxes property of the TreeView control.</i><!--/caption-->


<p>Each Node object has three images associated with it, and the Node's 
current state determines which image is displayed. The 
<I>Image</I> property sets or returns the index of the default image; the 
<I>SelectedImage</I> property sets or returns the index 
of the image used when the Node is selected; the 
<I>ExpandedImage</I> property sets or returns the index of the image used when the Node is expanded. You can set 
the first two properties in the Nodes collection's 
<I>Add</I> method, but you must explicitly assign the 
<I>ExpandedImage</I> property after you've added the item to the collection.</P>

<p>You can learn whether a particular Node is currently visible by querying 
its <I>Visible </I>property. A Node item can be invisible because it belongs to a tree 
branch that's in a collapsed state or because it has scrolled away from the visible portion 
of the control. This property is read-only, but you can force the visibility state of a 
Node by executing its <I>EnsureVisible </I>method:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Scroll the TreeView, and expand any parent Node if necessary.
If aNode.Visible = False Then aNode.EnsureVisible
</pre>
</td></tr>
</table>
</p>


<p>You can learn how many Nodes are visible in the control by executing 
TreeView's <I>GetVisibleCount </I>method.</P>

<p>You have two ways to determine whether a Node is currently the 
selected Node object in the control&#8212;either by querying its 
<I>Selected</I> property or by testing the TreeView's 
<I>SelectedItem</I> property:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Check whether aNode is the Node currently selected (two
' equivalent ways).
' First way:
If aNode.Selected Then MsgBox &quot;Selected&quot;
' Second way:
If TreeView1.SelectedItem Is aNode Then MsgBox &quot;Selected&quot;

' Make aNode the currently selected Node (two equivalent ways).
' First way:
aNode.Selected = True
' Second way:
Set TreeView1.SelectedItem = aNode
</pre>
</td></tr>
</table>
</p>


<A NAME="424"><h3>Showing information about a Node</h3></A>

<p>Users expect the program to do something when they click on a Node object in 
the TreeView control&#8212;for example, to display some information related to that 
object. To learn when a Node is clicked, you have to trap the 
<I>NodeClick</I> event. You can determine which Node has been clicked by looking at the 
<I>Index</I> or <I>Key</I> property of the Node parameter passed to the event procedure. In a typical situation, you store 
information about a Node in an array of String or UDT items:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub TreeView1_NodeClick(ByVal Node As MSComctlLib.Node)
    ' info() is an array of strings that hold nodes' descriptions.
    lblData.Caption = info(Node.Index) 
End Sub
</pre>
</td></tr>
</table>
</p>


<p>The <I>NodeClick</I> event differs from the regular 
<I>Click</I> event in that the latter fires whenever the user clicks on the TreeView control, whereas the former is 
activated only when the user clicks on a Node object.</P>
<P>The previous code snippet has a flaw: In general, the 
<I>Index</I> property of a Node object can't be trusted because it can change when other Node objects are 
removed from the Nodes collection. For this reason, you should rely exclusively on the 
<I>Key</I> property, which is guaranteed not to vary after the Node has been added to 
the collection. For example, you can use the 
<I>Key</I> property to search for an item in a 
standard Collection object, where you store information that's related to the Node. 
Here's a better technique: You store the data in the 
<I>Tag</I> property of the Node object so that you don't have to worry about removing items from the control's Node 
collection. The BrowMdb.vbp project on the companion CD includes a revised version of 
the <I>ShowDatabaseStructure</I> routine to show properties and attributes of all the Field 
and TableDef objects displayed in the TreeView control, as you can see in Figure 10-7.</P>

<p>
<A HREF="javascript:fullSize('F10ph07x.htm')"> <img src="images/F10ph07.JPG" width=404 height=260 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 10-7.</B> <i>A simple browser for Microsoft Jet databases.</i><!--/caption-->
</p>

<A NAME="425"><h3>Editing Node text</h3></A>

<p>By default, the user can click on a Node object to enter Edit mode and 
indirectly change the Node object's <I>Text</I> property. If you don't like this behavior, you can 
set the <I>LabelEdit </I>property to 1-tvwManual. In this case, you can enter Edit mode 
only by programmatically executing a <I>StartLabelEdit 
</I>method.</P>

<p>Regardless of the value of the <I>LabelEdit</I> property, you can trap the instant 
when the user begins editing the current value of the 
<I>Text</I> property by writing code in the <I>BeforeLabelEdit 
</I>event procedure. When this event fires, you can discover which 
Node is currently selected by using the TreeView's 
<I>SelectedItem</I> property, and you can cancel the operation by setting the event's 
<I>Cancel</I> parameter to True:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub TreeView1_BeforeLabelEdit(Cancel As Integer)
    ' Prevent the root Node's Text property from editing.
    If TreeView1.SelectedItem.Key = &quot;Root&quot; Then Cancel = True
End Sub
</pre>
</td></tr>
</table>
</p>


<p>Similarly, you can find out when the user has completed the editing and 
reject, if you want to, the new value of the 
<I>Text</I> property by trapping the 
<I>AfterLabelEdit</I> event. Typically, you use this event to check whether the new value follows any 
syntactical rule enforced by the particular object. For example, you can reject empty 
strings by writing the following code:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub TreeView1_AfterLabelEdit(Cancel As Integer, _
    NewString As String)
    If Len(NewString) = 0 Then Cancel = True
End Sub
</pre>
</td></tr>
</table>
</p>


<A NAME="426"><h3>Using check boxes</h3></A>
<P>
<img src="images/new.jpg" width=102 height=87 border="0">
</P>

<p>To display a check box beside each Node in the TreeView control, you simply 
need to set the control's <I>Checkboxes</I> property to True, either at design time or run 
time. You can then query or modify the state of each Node using its 
<I>Checked</I> property:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Count how many Node objects are checked, and then reset all check boxes.
Dim i As Long, SelCount As Long
For i = 1 To TreeView1.Nodes.Count
    If TreeView1.Nodes(i).Checked Then
        SelCount = SelCount + 1
        TreeView1.Nodes(i).Checked = False
    End If
Next
</pre>
</td></tr>
</table>
</p>


<p>You can enforce tighter control over what happens when a Node is 
checked by writing code in the control's 
<I>NodeChecked</I> event. This event doesn't fire if 
you modify a Node's <I>Checked</I> property using code:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim SelCount As Long     ' The number of selected items

Private Sub TreeView1_NodeCheck(ByVal Node As MSComctlLib.Node)
    ' Display the number of selected Nodes.
    If Node.Checked Then
        SelCount = SelCount + 1
    Else
        SelCount = SelCount _ 1
    End If
    lblStatus = &quot;Selected Items = &quot; &amp; SelCount
End Sub
</pre>
</td></tr>
</table>
</p>


<p><DIV CLASS="TIP"><BLOCKQUOTE><B>TIP</B><HR>If you want to prevent the user from modifying the 
<I>Checked</I> state of a given Node object, you can't simply reset its 
<I>Checked</I> property within the 
<I>NodeCheck</I> event because all changes to this property are lost when the event procedure 
is exited. You can solve this problem by adding a Timer control on the form 
and writing this code:
<P><TABLE><TR><TD><PRE>
Dim CheckedNode As Node            ' A form-level variable

Private Sub TreeView1_NodeCheck(ByVal Node As MSComctlLib.Node)

    ' Prevent the user from checking the first Node.
    If Node.Index = 1 Then
        ' Remember which Node has been clicked on.
        Set CheckedNode = Node
        ' Let the Timer routine do the job.
        Timer1.Enabled = True
    End If
End Sub

Private Sub Timer1_Timer()
    ' Reset the Checked property, and then go to sleep.
    CheckedNode.Checked = False
    Timer1.Enabled = False
End Sub
</PRE></TD></TR></TABLE></P>

<P>This technique is more effective if the Timer's 
<I>Interval</I> property is set to a small value, such as 10 milliseconds.</P>
</BLOCKQUOTE></DIV></P>

<A NAME="427"><h2>Advanced Techniques</h2></A>

<p>The TreeView control is very flexible, but sometimes you have to resort to 
more advanced and less intuitive techniques to leverage its power.</P>

<A NAME="428"><h3>Loading Nodes on demand</h3></A>

<p>Theoretically, you can load thousands of items into a TreeView control, which is 
more than an average user is willing to examine. In practice, loading more than a 
few hundred items makes a program unacceptably slow. Take, for example, the task 
of loading a directory structure into a TreeView control the way Windows Explorer 
does it: This simple job requires a lot of time to scan the system's hard disk, and you 
simply can't have your user wait for this long. In these situations, you might need to 
resort to a <I>load on demand </I>approach.</P>

<p>Loading items on demand means that you don't add Node objects until you 
have to display them, one instant before their parent Node is expanded. You can 
determine when a Node is expanded by trapping the TreeView control's 
<I>Expand </I>event. (You can also find out when a Node object is collapsed by trapping the 
control's <I>Collapse </I>event.) The tricky detail is how to let the user know that a Node has one 
or more child objects without actually adding them. In other words, we need to 
show a plus sign beside each Node item with children.</P>

<p>It is easy to demonstrate that the TreeView common control is able to 
display a plus sign beside a Node without child Nodes: Just run Windows Explorer and 
look at the plus sign beside the icon for the A: floppy drive; it's there even if 
no subdirectories are on the diskette (and even if no diskette is in the A: drive). 
Unfortunately, the ability to display a plus sign without adding child Nodes hasn't 
been exposed in the OCX that comes with Visual Basic and requires some API 
programming. The technique I will show you, however, does the trick without any API call.</P>

<p>To show a plus sign beside a Node, all you have to do is add a child Node, 
<I>any </I>child Node. I'll call this a <I>dummy child 
Node</I>. You need to mark such a dummy Node item in an unambiguous way&#8212;for example, by storing a special value in its 
<I>Text</I> or <I>Tag</I> property. When a Node is eventually expanded, the program checks whether 
the Node has a dummy child item. If so, the code removes the dummy child and 
then adds all the actual child Nodes. As you see, the technique is simple, even if its 
implementation includes some nontrivial code.</P>

<p>Figure 10-8 shows the demonstration program at run time. Its complete 
source code is on the companion CD, so I'll just illustrate its key routines. The form 
contains the <I>tvwDir </I>TreeView control and uses the FileSystemObject hierarchy to 
retrieve the directory structure.</P>

<p>
<img src="images/F10ph08.GIF" width=345 height=352 border="0">
<p>
<!--caption--><B>Figure 10-8.</B> <i>A directory browser program that loads TreeView Nodes on demand.</i><!--/caption-->


<p>The following <I>DirRefresh</I> procedure is invoked from within the 
<I>Form_Load </I>event:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub DirRefresh()
    Dim dr As Scripting.Drive
    Dim rootNode As node, nd As Node
    On Error Resume Next
    
    ' Add the &quot;My Computer&quot; root Node (expanded).
    Set rootNode = tvwDir.Nodes.Add(, , &quot;\\MyComputer&quot;, _
        &quot;My Computer&quot;, 1)
    rootNode.Expanded = True
    ' Add all the drives; display a plus sign beside them.
    For Each dr In FSO.Drives
        ' Error handling is needed to account for not-ready drives.
        Err.Clear
        Set nd = tvwDir.Nodes.Add(rootNode.Key, tvwChild, dr.Path &amp; &quot;\&quot;, _
            dr.Path &amp; &quot; &quot; &amp; dr.VolumeName, 2)
        If Err = 0 Then AddDummyChild nd
    Next
End Sub

Sub AddDummyChild(nd As node)
    ' Add a dummy child Node if necessary.
    If nd.Children = 0 Then
        ' Dummy nodes' Text property is &quot;***&quot;.
        tvwDir.Nodes.Add nd.index, tvwChild, , &quot;***&quot;
    End If
End Sub
</pre>
</td></tr>
</table>
</p>


<p>The previous routine ensures that the form is displayed with the 
&quot;MyComputer&quot; root Node and all the drives below it. When the user expands a Node, the 
following event fires:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub tvwDir_Expand(ByVal node As ComctlLib.node)
    ' A Node is being expanded.
    Dim nd As Node
    ' Exit if the Node had already been expanded or has no children.
    If node.Children = 0 Or node.Children &gt; 1 Then Exit Sub
    ' Also exit if it doesn't have a dummy child Node.
    If node.Child.text &lt;&gt; &quot;***&quot; Then Exit Sub
    ' Remove the dummy child item.
    tvwDir.Nodes.Remove node.Child.index
    ' Add all the subdirs of this Node object.
    AddSubdirs node
End Sub
</pre>
</td></tr>
</table>
</p>


<p>The <I>tvwDir_Expand </I>procedure uses the <I>Children 
</I>property of the Node object, which returns the number of its child Nodes, and the 
<I>Child </I>property, which returns a reference to its first child Node. The 
<I>AddSubdirs</I> procedure adds all the 
subdirectories below a given Node. Because each Node's 
<I>Key</I> property always holds the path corresponding to that Node, it's simple to retrieve the corresponding 
Scripting.Folder object and then iterate on its SubFolders collection:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub AddSubdirs(ByVal node As ComctlLib.node)
    ' Add all the subdirectories under a Node.
    Dim fld As Scripting.Folder
    Dim nd As Node
    ' The path in the Node is held in its key property, so it's easy
    ' to cycle on all its subdirectories.
    For Each fld In FSO.GetFolder(node.Key).SubFolders
        Set nd = tvwDir.Nodes.Add(node, tvwChild, fld.Path, fld.Name, 3)
        nd.ExpandedImage = 4
        ' If this directory has subfolders, add a plus sign.
        If fld.SubFolders.Count Then AddDummyChild nd
    Next
End Sub
</pre>
</td></tr>
</table>
</p>


<p>Even if this code can be used only for loading and displaying a directory 
tree, you can easily modify it to work with any other type of data that you want to 
load on demand into a TreeView control.</P>
<P>A great way to use this technique is for browsing databases in a 
hierarchical format. Take the ubiquitous Biblio.Mdb as an example: You can load all the 
publishers' names in the TreeView control and show their related titles only when the user 
expands a Node. This is much faster than preloading all the data in the control and 
offers a clear view of how records are related. I've provided a sample program that 
uses this technique on the companion CD.</P>

<A NAME="429"><h3>Searching the Nodes collection</h3></A>

<p>When you need to extract information from a TreeView control, you have to 
search the Nodes collection. In most cases, however, you can't simply scan it from the first 
to the last item because this order would reflect the sequence in which Node 
objects were added to the collection and doesn't take into account the relationships among them.</P>

<p>To let you visit all the items in a TreeView control in a hierarchical order, 
each Node object exposes a number of properties that return references to its 
relatives. We have already seen the <I>Child </I>property, which returns a reference to the first 
child, and the <I>Children </I>property, which returns the number of child Nodes. The 
<I>Next </I>property returns a reference to the next Node at the same level (the next sibling 
Node), and the <I>Previous </I>property returns a reference to the previous Node at the same 
level (the previous sibling Node). The <I>FirstSibling 
</I>and the <I>LastSibling </I>properties return a reference to the first and last Node, respectively, that are at the same level as the 
Node being examined. Finally the <I>Parent</I> property returns a reference to the Node 
object one level above, and the <I>Root</I> property returns a reference to the root of the 
hierarchy tree that the Node being queried belongs to. (Remember, there can be 
multiple root Nodes.) You can use these properties to test where a given Node appears in 
the hierarchy. Here are a few examples:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Check whether a Node has no children (two possible approaches).
If Node.Children = 0 Then MsgBox &quot;Has no children&quot;
If Node.Child Is Nothing Then MsgBox &quot;Has no children&quot;
' Check whether a Node is the first child of its parent (two approaches).
If Node.Previous Is Nothing Then MsgBox &quot;First Child&quot; 
If Node.FirstSibling Is Node Then MsgBox &quot;First Child&quot;
' Check whether a Node is the last child of its parent (two approaches).
If Node.Next Is Nothing Then MsgBox &quot;Last Child&quot; 
If Node.LastSibling Is Node Then MsgBox &quot;Last Child&quot;
' Check whether a Node is the root of its own tree (two approaches).
If Node.Parent Is Nothing Then MsgBox &quot;Root Node&quot; 
If Node.Root Is Node Then MsgBox &quot;Root Node&quot; 
' Get a reference to the first root Node in the control.
Set RootNode = TreeView1.Nodes(1).Root.FirstSibling
</pre>
</td></tr>
</table>
</p>


<p>Not surprisingly, the majority of routines you write to search the Nodes 
collection are recursive. Typically, you start with a Node object, get a reference to its 
first child Node, and then recursively call the routine for all its children. The 
following routine is an example of this technique. Its purpose is to build a text string that 
represents the contents of a TreeView control or of one of its subtrees. Each line in 
the string represents a Node object, indented with 0 or more tab characters that 
reflect the corresponding nesting level. The routine can return a string for all the Nodes 
or for just the items that are actually visible (that is, those whose parents are expanded):</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Convert the contents of a TreeView control into a string.
' If a Node is provided, it only searches a subtree.
' If last argument is False or omitted, all items are included.
Function TreeViewToString(TV As TreeView, Optional StartNode As Node, _
    Optional OnlyVisible As Boolean) As String
    Dim nd As Node, childND As Node
    Dim res As String, i As Long
    Static Level As Integer
    
    ' Exit if there are no Nodes to search.
    If TV.Nodes.Count = 0 Then Exit Function
    ' If StartNode is omitted, start from the first root Node.
    If StartNode Is Nothing Then
        Set nd = TV.Nodes(1).Root.FirstSibling
    Else
        Set nd = StartNode
    End If
    
    ' Output the starting Node.
    res = String$(Level, vbTab) &amp; nd.Text &amp; vbCrLf
    ' Then call this routine recursively to output all child Nodes.
    ' If OnlyVisible = True, do this only if this Node is expanded.
    If nd.Children And (nd.Expanded Or OnlyVisible = False) Then
        Level = Level + 1
        Set childND = nd.Child
        For i = 1 To nd.Children
            res = res &amp; TreeViewToString(TV, childND, OnlyVisible)
            Set childND = childND.Next
        Next
        Level = Level - 1
    End If
    
    ' If searching the whole tree, we must account for multiple roots.
    If StartNode Is Nothing Then
        Set nd = nd.Next
        Do Until nd Is Nothing
            res = res &amp; TreeViewToString(TV, nd, OnlyVisible)
            Set nd = nd.Next
        Loop
    End If
    TreeViewToString = res
End Function
</pre>
</td></tr>
</table>
</p>


<p>Figure 10-9 shows a demonstration program that uses this routine and the 
resulting string loaded into Notepad. You can embellish the 
<I>TreeViewToString</I> procedure in many ways. For instance, you can create a routine that prints the contents 
of a TreeView control (including all connecting lines, bitmaps, and so on). Using a 
similar approach, you can build a routine that saves and restores the current state of 
a TreeView control, including the <I>Expanded</I> attribute of all Node objects.</P>

<p>
<A HREF="javascript:fullSize('F10ph09x.htm')"> <img src="images/F10ph09.JPG" width=404 height=217 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 10-9.</B> <i>A demonstration program that uses the </I>TreeViewToString<I> routine.</i><!--/caption-->
</p>

<A NAME="430"><h3>Implementing drag-and-drop</h3></A>

<p>Another common operation that you might want to perform on TreeView 
controls is drag-and-drop, typically to copy or move a portion of a hierarchy. 
Implementing a drag-and-drop routine isn't simple, though. First you have to understand which 
Node the drag operation starts and ends on, and then you have to physically copy or 
move a portion of the Nodes collection. You must also prevent incorrect operations, 
as Windows Explorer does when you try to drag a directory onto one of its subfolders.</P>

<p>The TreeView control does offer a few properties and methods that are 
particularly useful for implementing a drag-and-drop routine. You can use the 
<I>HitTest </I>method to determine which Node object is located at a given pair of coordinates. 
(Typically, you use this method in a 
<I>MouseDown</I> event to pinpoint the source Node of the 
drag operation.) During the drag operation, you use the 
<I>DropHighlight</I> property to highlight the Node that's under the mouse cursor so that you can provide the user 
with a clue to the potential target Node of the operation.</P>

<p>Figure 10-10 shows a demonstration program, provided on the companion 
CD, that lets you experiment with drag-and-drop between TreeView controls or 
within the same TreeView control. The two controls on the form belong to a control 
array, so the same code works whichever is the source or the target control. </P>

<p>
<A HREF="javascript:fullSize('F10ph10x.htm')"> <img src="images/F10ph10.JPG" width=404 height=311 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 10-10.</B> <i>You can use drag-and-drop to move or copy subtrees between controls or even within the same TreeView control.</i><!--/caption-->
</p>

<p>As usual, the drag operation is started in the 
<I>MouseDown </I>event procedure:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The source control
Dim SourceTreeView As TreeView
' The source Node object
Dim SourceNode As Node
' The state of Shift key during the drag-and-drop operation
Dim ShiftState As Integer

Private Sub TreeView1_MouseDown(Index As Integer, _
    Button As Integer, Shift As Integer, x As Single, y As Single)
    ' Check whether we are starting a drag operation.
    If Button &lt;&gt; 2 Then Exit Sub
    ' Set the Node being dragged, or exit if there is none.
    Set SourceNode = TreeView1(Index).HitTest(x, y)
    If SourceNode Is Nothing Then Exit Sub
    ' Save values for later.
    Set SourceTreeView = TreeView1(Index)
    ShiftState = Shift
    ' Start the drag operation.
    TreeView1(Index).OLEDrag
End Sub
</pre>
</td></tr>
</table>
</p>


<p>The <I>OLEStartDrag </I>event procedure is where you decide whether you're 
moving or copying items, depending on the state of the Ctrl key:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub TreeView1_OLEStartDrag(Index As Integer, _
    Data As MSComctlLib.DataObject, AllowedEffects As Long)
    ' Pass the Key property of the Node being dragged.
    ' (This value is not used; we can actually pass anything.)
    Data.SetData SourceNode.Key
    If ShiftState And vbCtrlMask Then
        AllowedEffects = vbDropEffectCopy
    Else
        AllowedEffects = vbDropEffectMove
    End If
End Sub
</pre>
</td></tr>
</table>
</p>


<p>In the <I>OLEDragOver </I>event procedure, you offer feedback to the user by 
highlighting the Node under the mouse in the target control. (The source and the 
target controls might coincide.)</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub TreeView1_OLEDragOver(Index As Integer, _
    Data As MSComctlLib.DataObject, Effect As Long, Button As Integer, _
    Shift As Integer, x As Single, y As Single, State As Integer)
    ' Highlight the Node the mouse is over.
    Set TreeView1(Index).DropHighlight = TreeView1(Index).HitTest(x, y)
End Sub
</pre>
</td></tr>
</table>
</p>


<p>Finally you have to implement the <I>OLEDragDrop 
</I>routine, which is the most complex of the group. First you must figure out whether the mouse is over a 
Node in the target control. If so, the source Node becomes a child of the target Node; 
otherwise, the source Node becomes a root Node in the target control. If the source 
and target controls coincide, you must also ensure that the target Node isn't a 
child or grandchild of the source Node, which would trap you in an endless loop.</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub TreeView1_OLEDragDrop(Index As Integer, _
    Data As MSComctlLib.DataObject, Effect As Long, Button As Integer, _
    Shift As Integer, x As Single, y As Single)
    Dim dest As Node, nd As Node
    ' Get the target Node.
    Set dest = TreeView1(Index).DropHighlight
    
    If dest Is Nothing Then
        ' Add the Node as the root of the target TreeView.
        Set nd = TreeView1(Index).Nodes.Add(, , , SourceNode.Text, _
            SourceNode.Image)
    Else
        ' Check that the destination isn't a descendant of the source
        ' Node.
        If SourceTreeView Is TreeView1(Index) Then
            Set nd = dest
            Do
                If nd Is SourceNode Then
                    MsgBox &quot;Unable to drag Nodes here&quot;, vbExclamation
                    Exit Sub
                End If
                Set nd = nd.Parent
            Loop Until nd Is Nothing
        End If
        Set nd = TreeView1(Index).Nodes.Add(dest.Index, tvwChild, , _ 
            SourceNode.Text, SourceNode.Image)
    End If
    nd.ExpandedImage = 2: nd.Expanded = True

    ' Copy the subtree from source to target control.
    CopySubTree SourceTreeView, SourceNode, TreeView1(Index), nd
    ' If this is a move operation, delete the source subtree.
    If Effect = vbDropEffectMove Then
        SourceTreeView.Nodes.Remove SourceNode.Index
    End If
    Set TreeView1(Index).DropHighlight = Nothing
End Sub
</pre>
</td></tr>
</table>
</p>


<p>The <I>CopySubTree</I> recursive procedure performs the actual Copy command. 
(A move operation consists of a copy operation followed by a delete operation.) 
It accepts a reference to source and target TreeView controls, so you can easily 
recycle it in other applications:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub CopySubTree(SourceTV As TreeView, sourceND As Node, _
    DestTV As TreeView, destND As Node)
    ' Copy or move all children of a Node to another Node.
    Dim i As Long, so As Node, de As Node
    If sourceND.Children = 0 Then Exit Sub
    
    Set so = sourceND.Child
    For i = 1 To sourceND.Children
        ' Add a Node in the destination TreeView control.
        Set de = DestTV.Nodes.Add(destND, tvwChild, , so.Text, _
            so.Image, so.SelectedImage)
        de.ExpandedImage = so.ExpandedImage
        ' Now add all the children of this Node in a recursive manner.
        CopySubTree SourceTV, so, DestTV, de
        ' Get a reference to the next sibling.
        Set so = so.Next
    Next
End Sub
</pre>
</td></tr>
</table>
</p>


<p>You don't need a recursive procedure to delete a subtree because if you 
delete a Node object, all its child nodes are automatically deleted too.</P>

</BODY>
</HTML>





