<HTML>
<HEAD>
<TITLE>Overview of Native Data Types</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04b.htm", "ch04d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="117"><h1>Overview of Native Data Types</h1></A>
<p>Visual Basic for Applications supports several native data types, including integer 
and floating point numbers, strings, date and time values, and so on. You can store 
data in a variable of the proper type, or you can use the Variant data type&#8212;the 
default type in VBA&#8212;which is a sort of jolly data type that's able to host any type of data.
</p>

<A NAME="118"><h2>The Integer Data Type</h2></A>
<p>Integer variables can hold integer values (whole numbers) included in the range 
from -32,768 through 32,767. These variables are also known as 16-bit integers 
because each value of this type takes 2 bytes of memory.
</p>

<p>Integer variables were probably the most used type of variables, at least 
until Visual Basic made its debut on 32-bit Microsoft Windows platforms. For all 
practical purposes, in a 32-bit environment you can use a Long value instead of an Integer 
value without a performance hit, at the same time reducing the probability of an 
overflow error when the value of your variable outgrows the valid range of Integers. One 
of the few occasions when Integers should be preferred to Longs is when you 
create very large arrays. In all other cases, I suggest you use Long values, unless you 
have good reasons not to do so (as when you're calling an external program or a DLL 
that expects an Integer).
</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
You can indirectly specify that an undeclared variable is of type 
Integer by appending a <I>%</I> symbol to its name. However, this feature is 
supported by Visual Basic 6 only for compatibility with older Visual Basic and 
QuickBasic programs. All new applications should exclusively use variables declared in 
an explicit way. The same suggestion of course applies to other data types, 
including Long (&amp;), Single(!), Double(#), Currency(@), and String($).
</blockquote></div>
</p>

<p>All the integer constants in your code are implicitly of type Integer, unless 
their value is outside the range for this data type, in which case they are stored as Long.
</p>

<A NAME="119"><h2>The Long Data Type</h2></A>
<p>Long variables can hold integer values in the range from 
-2,147,483,648 through 2,147,483,647 and are also known as 32-bit integers because each value takes 4 
bytes of memory. As I mentioned previously, you're encouraged to use Longs in 
your applications as the preferred data type for integer values. Long variables are as 
fast as Integer variables, and in most cases they prevent the program from breaking 
when dealing with numbers larger than expected. One example is when you have to 
process strings longer than 32,767 characters: In this case, you must use a Long 
index instead of an Integer variable. Watch out for this quirk when you convert code 
written for older Visual Basic versions.
</p>

<p>As I explained previously, you are strongly advised not to declare Long 
variables with a trailing <I>&amp;</I> character in their names. However, it's common practice 
to append an <I>&amp;</I> symbol to those constants that would be stored as Integer but that 
you want the compiler to explicitly interpret as Long. Sometimes the difference can 
be important:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Result = value And &amp;HFFFF     ' here &amp;HFFFF means -1 
Result = value And &amp;HFFFF&amp;    ' here &amp;HFFFF&amp; means 65535
</pre>
</td></tr>
</table></p>

<p>If you don't want to concentrate on such microscopic details, just declare 
an explicit constant:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Const LOWWORD_MASK As Long = &amp;HFFFF&amp;
</pre>
</td></tr>
</table></p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>
For historical reasons, Visual Basic lets you enforce a particular 
data type as the default data type using the 
Def<I>type</I> directive, so you might be tempted to use the 
<I>DefLng A-Z</I> directive at the beginning of each module to ensure that 
all undeclared variables are Long. My advice is: 
<I>don't do that!</I> Using Def<I>type</I> directives instead of carefully declaring all your variables is a dangerous 
practice. Moreover, Def<I>type</I> directives impair code reusability in that you can't safely 
cut and paste code from one module to another without also copying the directive.
</blockquote></div>
</p>

<A NAME="120"><h2>The Boolean Data Type</h2></A>
<p>Boolean variables are nothing but Integers that can hold only values 0 and -1, 
which stand for False and True, respectively. When you use a Boolean, you are 
actually wasting 15 out of 16 bits in the variable, because this information could be easily 
held in one single bit. That said, I suggest you use Boolean instead of Integer 
variables whenever it makes sense to do so because this increases the readability of your 
code. On a few occasions, I have also experienced a slight improvement in 
performance, but usually it's negligible and shouldn't be a decisive factor.
</p>

<A NAME="121"><h2>The Byte Data Type</h2></A>
<p>Byte variables can hold an integer numeric value in the range 0 through 255. 
They take only one byte (8 bits) each and are therefore the smallest data type allowed 
by Visual Basic. Visual Basic 4 introduced the Byte data type to ease the porting of 
16-bit applications to Windows 95 and Microsoft Windows NT. Specifically, while 
Visual Basic 4 for the 32-bit platform and later versions are source-code compatible 
with Visual Basic 3 and Visual Basic 4 for the 16-bit platform applications, they store 
their strings in Unicode instead of ANSI format. This difference raised a problem with 
strings passed to API functions because Visual Basic 3 programmers used to store binary 
data in strings for passing it to the operating system, but the Unicode-to-ANSI 
automatic conversion performed by Visual Basic makes it impossible to port this code to 
32-bit without any significant change.
</p>

<p>To make a long story short, the Byte data type was added to Visual Basic 
primarily to solve this problem. Apart from this advanced use, you should use Byte 
values only when you're dealing with arrays holding binary data. For individual values, 
an Integer or a Long variable is usually a better choice.
</p>

<A NAME="122"><h2>The Single Data Type</h2></A>
<p>Single variables can hold decimal values in the range from 
-3.402823E38 through -1.401298E-45 for negative values and 1.401298E-45 through 3.402823E38 for 
positive values. They take 4 bytes and are the simplest (and least precise) of the 
floating point data types allowed by Visual Basic.
</p>

<p>Contrary to what many programmers believe, Single variables aren't faster 
than Double variables, at least on the majority of Windows machines. The reason is 
that on most systems, all floating point operations are performed by the math 
coprocessor, and the time spent doing the calculations is independent of the original 
format of the number. This means that in most cases you should go with Double 
values because they offer a better precision, a wider range, fewer overflow problems, 
and no performance hit.
</p>

<p>The Single data type is a good choice when you're dealing with large arrays 
of floating point values, and you can be satisfied with its precision and valid range. 
Another good occasion to use the Single data type is when you're doing intensive 
graphical work on your forms and in PictureBox controls. In fact, all the properties 
and methods that deal with coordinates&#8212;including 
<I>CurrentX/Y</I>, <I>Line</I>, <I>Circle</I>, 
<I>ScaleWidth</I>, <I>ScaleHeight</I>, and so on&#8212;use values of type Single. So you might save Visual 
Basic some conversion work if you store your coordinate pairs in Single variables.
</p>

<A NAME="123"><h2>The Double Data Type</h2></A>
<p>Double variables can hold a floating point value in the range 
-1.79769313486232E308 through -4.94065645841247E-324 for negative values and 
4.9406564581247E-324 through 1.79769313486232E308 for positive values. They take 8 bytes and in 
most cases are the preferable choice when you're dealing with decimal values. A few 
built-in Visual Basic functions return Double values. For example, the 
<I>Val</I> function always returns a Double value, even if the string argument doesn't include a decimal 
point. For this reason, you might want to store the result from such functions in a 
Double variable, which saves Visual Basic an additional conversion at run time.
</p>

<A NAME="124"><h2>The String Data Type</h2></A>
<p>All 32-bit flavors of Visual Basic&#8212;Visual Basic 4 for 32-bit platforms, 5, and 
6&#8212;store strings of characters in Unicode format, while all previous versions used the 
ANSI format. The difference is that Unicode uses two bytes for each character, so 
theoretically a Unicode character can assume as many as 65,536 different values. This 
makes Unicode strings ideal for writing code that displays its messages in non-Latin 
alphabets, such as Chinese, Japanese, and Hebraic. If you don't localize your software 
in these alphabets, you'll probably look at Unicode strings mainly as a way to 
waste memory in your program, especially if you use many long strings. Note that 
Windows NT and some portions of Windows 95/98 use Unicode strings.
</p>

<p>Visual Basic manages two different types of strings: conventional 
variable-length strings and fixed-length strings. You declare them in different ways:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim VarLenStr As String
Dim FixedLenStr As String * 40
</pre>
</td></tr>
</table></p>

<p>The first, obvious difference is that in any given moment a variable-length 
string takes only the memory that it needs for its characters (actually, it takes 10 
additional bytes for holding other information about the string, including its length), 
whereas a fixed-length string always takes a fixed amount of memory (80 bytes, in the 
preceding example).
</p>

<p>If you are a performance-savvy programmer, you should remember that 
conventional strings are <I>usually </I>faster than fixed-length string. This happens because 
all VBA native string functions can deal only with variable-length strings. In a sense, 
a fixed-length string is something that VBA isn't even aware of: When you pass a 
fixed-length string to a VBA function, the compiler generates hidden statements that 
convert that argument into a temporary variable-length string.
</p>

<p>But even with all this overhead, fixed-length strings aren't always going to 
make your programs slower. For one, Visual Basic excels at allocating and releasing 
memory for fixed-length strings, so if your program spends a lot of time assigning new 
values to variables or creates large string arrays, fixed-length strings might prove 
even faster than conventional ones. Just to give you an example, on a 233-KHz 
system Visual Basic 6 takes about 9 seconds to load 100,000 30-character strings into 
a conventional string array, and 0.4 seconds to remove them. Both operations 
are completed almost instantaneously if performed on an array of fixed-length strings.
</p>

<p>String constants are enclosed within quotes, and you can embed quotes 
within the string by doubling them:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Print &quot;&lt;My Name Is &quot;&quot;Tarzan&quot;&quot;&gt;&quot;     ' displays  &lt;My Name Is &quot;Tarzan&quot;&gt;
</pre>
</td></tr>
</table></p>

<p>Visual Basic additionally defines a number of intrinsic string constants, such 
as <I>vbTab</I> (the Tab character) or <I>vbCrLf 
</I>(the carriage return-line feed pair). Using 
these constants usually improves the readability of your code as well as its 
performance because you don't have to use a 
<I>Chr</I> function to create the strings.
</p>

<A NAME="125"><h2>The Currency Data Type</h2></A>
<p>Currency variables can hold decimal values in a 
fixed-point format, in the range from  -922,337,203,685,477.5808 through 922,337,203,685,477.5807. They differ 
from floating-point variables, such as Single and Double, in that they always include 
four decimal digits. You can think of a currency value as a big integer that's 8 bytes 
long and whose value is automatically scaled by a factor of 10,000 
when it's assigned to the variable and when it's read back and displayed to the user.
</p>

<p>Using a fixed-point value has its advantages over floating-point variables. 
For one, Currency values suffer less from the rounding problems that you often 
experience using Double values. When you're adding or subtracting values, 
however, Currency variables don't offer a performance advantage, and multiplying and 
dividing Currency values is about five times slower than doing the same for Double 
values. Keep this in mind if your application does a lot of math.
</p>

<A NAME="126"><h2>The Date Data Type</h2></A>
<p>Date variables can hold any date between January 1, 100, through December 31, 
9999, as well as any time value. They take 8 bytes, exactly like Double variables. This 
isn't a casual resemblance because internally these date/time values are stored as 
floating-point numbers, in which the integer part stores the date information and the 
decimal part stores the time information. (For example, 0.5 means 12 
A.M., 0.75 means 6 P.M., and so on.) Once you know how Date variables store their values, you 
can perform many meaningful math operations on them. For example, you can 
truncate date or time information using the 
<I>Int</I> function, as follows:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>MyVar = Now                    ' MyVar is a Date variable.
DateVar = Int(MyVar)           ' Extract date information.
TimeVar = MyVar - Int(MyVar)   ' Extract time information.
</pre>
</td></tr>
</table></p>

<p>You can also add and subtract dates, as you would do with numbers:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>MyVar = MyVar + 7              ' Advance one week.
MyVar = MyVar - 365            ' Go back one (nonleap) year.
</pre>
</td></tr>
</table></p>

<p>VBA provides many functions for dealing with date and time information in 
more advanced ways, which I'll cover in <a href="ch05a.htm">Chapter 5</a>. You can also define a Date 
constant using the format <I>#mm/dd/yyyy#</I>, with or without a time portion:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>MyVar = #9/5/1996 12.20 am#
</pre>
</td></tr>
</table></p>

<A NAME="127"><h2>The Object Data Type</h2></A>
<p>Visual Basic uses object variables to store reference objects. Note that here we 
are talking about storing a <I>reference </I>to an object, not storing an 
<I>object</I>. The difference is subtle but important, and I'll talk about it at length in <a href="ch06a.htm">Chapter 6</a>. There are 
several types of object variables, but they can be grouped in two broad categories: 
<I>generic </I>object variables and <I>specific 
</I>object variables. Here are a few examples:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Examples of generic object variables
Dim frm As Form            ' A reference to any form
Dim midfrm As MDIForm      ' A reference to any MDI form
Dim ctrl As Control        ' A reference to any control
Dim obj As Object          ' A reference to any object
' Examples of specific object variables
Dim inv As frmInvoice      ' A reference to a specific type of form
Dim txtSalary As TextBox   ' A reference to a specific type of control
Dim cust As CCustomer      ' A reference to an object defined by a
                           ' class module in the current project
Dim wrk As Excel.Worksheet ' A reference to an external object
</pre>
</td></tr>
</table></p>

<p>The most evident difference when dealing with object variables (as 
opposed to regular variables) is that you assign object references to them using the 
<I>Set</I> keyword, as in the following code:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Set frm = Form1
Set txtSalary = Text1
</pre>
</td></tr>
</table></p>

<p>After the assignment, you can use the object variable to access the 
original object's properties and methods:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>frm.Caption = &quot;Welcome to Visual Basic 6&quot;
txtSalary.Text = Format(99000, &quot;currency&quot;)
</pre>
</td></tr>
</table></p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>One of the most common errors that programmers make when 
dealing with object variables is omitting the 
<I>Set</I> command during assignments. What happens if you omit this keyword depends on the object involved. If it 
doesn't support a default property, Visual Basic raises a compile-time error (&quot;Invalid 
use of property&quot;); otherwise, the assignment succeeds, but the result won't be 
the one you expect:

<p>
<table>
<tr><td>
<pre>frm = Form1           ' A missing Set raises a compiler error.
txtSalary = Text1     ' A missing Set assigns Text1's Text property
                      ' to txtSalary's Text property.
</pre>
</td></tr>
</table>
</p>
</blockquote></div>
</p>

<p>Object variables can also be cleared so that they don't point to any 
particular object anymore. You do this by assigning them the special 
Nothing value:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Set txtSalary = Nothing
</pre>
</td></tr>
</table></p>

<A NAME="128"><h2>The Variant Data Type</h2></A>
<p>Variant variables were introduced in Visual Basic 3, but their internal format 
changed in version 4, where their capabilities were greatly enhanced. The Variant format 
is defined by OLE, and so it's highly unlikely that it will be modified again in the 
future. Variant variables can hold any type of data described so far, and then 
some. Variables of this type take 16 bytes, in this format:
</p>

<p>
<A HREF="javascript:fullSize('G04ph01x.htm')"> <img src="images/G04ph01.JPG" width=404 height=46 border=0 ALT = "Click to view at full size."> </A>
</p>

<p>Bytes 0 and 1 hold an integer value that states which type of data is stored 
in bytes 8 through 15. Bytes 2 through 7 are unused (with only one exception, 
the Decimal subtype), and in most cases not all the bytes in the second half of the 
variable are used. For example, if a Variant holds an Integer value, the first two 
bytes contain the value 2-vbInteger, bytes 8 and 9 hold the actual 16-bit value, and all 
other bytes are unused.
</p>

<p>A Variant variable holds a value in its original format and doesn't enforce a 
metaformat that encompasses all the data types supported by Visual Basic. For 
example, when Visual Basic adds numbers held in two Variant variables, it checks their 
type and uses the most efficient math routine possible. And so, if you're adding two 
Variants that hold one Integer and one Long, Visual Basic promotes the Integer to 
Long and then invokes the routine for addition between Longs.
</p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>
Automatic data coercion is always dangerous because you 
might not get the results that you expect. For example, if you use the 
+ operator on two Variants that hold numeric values, Visual Basic interprets the 
+ as the addition operator. If both values are strings, Visual Basic interprets the 
+ as the append operator. When one data type is a string and the other is a number, 
Visual Basic tries to convert the string to a number so that an addition can be 
performed; if this isn't possible, a &quot;Type Mismatch&quot; error is raised. If you want to be sure 
to execute an append operation regardless of the data types involved, use the 
&amp; operator. Finally note that you can't store fixed-length strings in Variant variables.
</blockquote></div>
</p>

<p>Variant is the default data type for Visual Basic. In other words, if you use 
a variable without declaring its type, as in the following line of code:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre> Dim MyVariable
</pre>
</td></tr>
</table></p>

<p>this will be a Variant variable, unless this line is preceded by a 
<I>Def</I>type<I> </I>directive that sets a different default data type. Likewise, if you use a variable without first 
declaring it (and you don't use a 
<I>Def</I>type<I> </I>directive), Visual Basic creates a Variant variable.
</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
If I could give only one suggestion to novice Visual Basic 
programmers, it would be this: <I>Always </I>add an 
<I>Option Explicit</I> directive at the beginning of 
every module in your programs. Even better, enable the Require Variable 
Declaration option in the General tab of the Options dialog box from the Tools 
menu so that Visual Basic automatically adds this directive whenever you create a 
new module. I can't overestimate the importance of having Visual Basic check for 
you that you haven't accidentally misspelled a variable's name. Be aware that 
some template projects create modules that lack the 
<I>Option Explicit </I>directive.
</blockquote></div>
</p>

<p>The type of data actually stored in a Variant variable depends on the last 
assignment to it. You can test the type of the current contents of such a Variable 
using the <I>VarType</I> function:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim v As Variant
v = True
Print VarType(v)     ' Prints &quot;11&quot;, that is vbBoolean
</pre>
</td></tr>
</table></p>

<p>Variant variables can also host special values that don't correspond to any 
data values described so far. The <I>Empty</I><B> 
</B>value is the state of a Variant variable when 
nothing has been assigned to it yet. You can test this special value using the 
<I>IsEmpty</I> function, or you can test the 
<I>VarType</I> function for the value 0-vbEmpty:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim v As Variant
Print IsEmpty(v)     ' Prints &quot;True&quot; (uninitialized variant).
v = &quot;any value&quot;      ' The variant isn't empty anymore.
v = Empty            ' Restore the Empty state using the Empty constant.
</pre>
</td></tr>
</table></p>

<p>The Null value is useful in database programming to mark fields that 
don't contain a value. You can explicitly assign the Null value to a Variant using the 
Null<I> </I>constant, test for a Null value using the 
<I>IsNull</I> function, or compare the return 
value of the <I>VarType</I> function with the value 1-vbNull:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>v = Null             ' Stores a Null value
Print IsNull(v)      ' Prints &quot;True&quot;
</pre>
</td></tr>
</table></p>

<p>Variant variables can also contain an Error value. This is useful, for example, 
if you want a routine to return a meaningful value if it succeeds or an error value if 
it doesn't. In this case, you declare a function that returns a Variant value: if no 
error occurs, you return the result. Otherwise, you use the 
<I>CVErr</I> function to create a Variant of subtype Error:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function Reciprocal(n As Double) As Variant
    If n &lt;&gt; 0 Then
        Reciprocal = 1 / n
    Else
        Reciprocal = CVErr(11)    ' Division By Zero error code
    End If
End Function
</pre>
</td></tr>
</table></p>

<p>You can test the Error subtype using the 
<I>IsError</I> function or by comparing the return value of 
<I>VarType</I> with the value 10-vbError. Error codes must be in the 
range 0 through 65535. To convert the error code into an integer, you can use the 
<I>CLng</I> function. Here's the typical client code for a function that could return an error 
code in a Variant:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim res As Variant
res = Reciprocal(CDbl(Text1.Text))
If IsError(res) Then
    MsgBox &quot;Error #&quot; &amp; CLng(res)
Else
    MsgBox &quot;Result is &quot; &amp; res
End If
</pre>
</td></tr>
</table></p>

<p>I'm reporting this style of error trapping exclusively for the sake of 
completeness. My advice, in fact, is that you should never use this approach for error 
management; rather, you should rely on the Err object, which is able to convey 
more information about errors.
</p>

<p>Variant variables can also host object values. You must assign object values 
using the <I>Set</I> keyword; otherwise, the results are unpredictable, as this short code 
snippet demonstrates:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim v As Variant
Set v = Text1      ' A correct object assignment that uses Set
v.Text = &quot;abcde&quot;   ' This works, because V points to Text1.
v = Text1          ' Wrong object assignment, Set is omitted.
                   ' Actually, it assigns the value of default property
                   ' and is equivalent to v = Text1.Text
Print v            ' Displays &quot;abcde&quot;
v.Text = &quot;12345&quot;   ' Error 424: Object Required
</pre>
</td></tr>
</table></p>

<p>You can test whether a Variant holds an object using the 
<I>IsObject</I> function. Don't use 
<I>VarType</I> to test whether a Variant variable holds an object reference. In fact, 
if the object supports a default property, the 
<I>VarType</I> function returns the type of that property, not the 
<I>vbObject </I>constant.
</p>

<p>
<img src="images/new.jpg" width=102 height=87 border="0">
</p>

<p>Starting with Visual Basic 6, Variant variables can also hold 
<I>user-defined type</I> (UDT) structures, and the 
<I>VarType</I> function can return the new value 
36vbUserDefinedType. But this capability is available only if the 
<I>Type</I> statement that defines the UDT structure appears with the Public scope attribute in a Public class module. 
You can't assign UDT structures to Variant variables within Standard EXE projects because they 
can't expose Public class modules.
</p>

<p>You can use other functions to test the type of the value stored in a 
Variant variable. The <I>IsNumeric</I> function returns True if the value can be successfully 
converted to a number using the <I>CDbl</I> function, even if the native format is 
different. (The Variant variable holds a string, for example.) The 
<I>IsDate</I> function checks whether the value can be successfully converted to a date using the 
<I>CDate</I> function. Finally, the 
<I>TypeName</I> function is similar to 
<I>VarType</I> but returns the current data type as 
a readable string:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>v = 123.45: Print TypeName(v)       ' Displays &quot;Double&quot;
Set v = Text1: Print TypeName(v)    ' Displays &quot;TextBox&quot;
</pre>
</td></tr>
</table></p>

<p>One last point: Variant variables can also hold arrays. For more information, 
read the section about arrays later in this chapter.
</p>

<A NAME="129"><h2>The Decimal Data Type</h2></A>
<p>Decimal is a floating-point data type with a higher precision than Double, but 
it has a smaller range. In fact, you can store values in the range plus or 
minus 79,228,162,514,264,337,593,543,950,335 with no decimal point, or plus or 
minus 7.9228162514264337593543950335 with 28 places to the right of the decimal 
point. The smallest nonzero number is plus or minus 
0.0000000000000000000000000001. Decimal is a singular case among the data types supported by Visual Basic in 
that you can't explicitly declare a variable using 
<I>As Decimal</I>. Instead, you assign a value to a Variant variable using the 
<I>CDec</I> conversion function, for example:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim v As Variant
v = CDec(Text1.Text)
</pre>
</td></tr>
</table></p>

<p>Once you have assigned a Decimal value to a Variant, you can perform all 
the usual math operations. You don't need to ensure that both operands are of 
Decimal type because Visual Basic will do the necessary conversions for you. Decimal is 
an exception among Variant subtypes in that it exploits all the bytes in the 
Variant structure, that is, all 14 bytes that follow the subtype identifier. If you apply 
the <I>VarType</I> function to a Variant containing a Decimal value, you get the return 
value of <I>14-vbDecimal</I>.
</p>

</BODY>
</HTML>





