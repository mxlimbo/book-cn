<HTML>
<HEAD>
<TITLE>Polymorphism</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07b.htm", "ch07d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="289"><h1>Polymorphism</h1></A>
<p>The term <I>polymorphism </I>describes the capability of different objects to expose a similar set of properties and methods. The most obvious and familiar examples of polymorphic objects are Visual Basic's own controls, most of which share property and method names. The advantage of polymorphism is evident when you think of the sort of generic routines that work on multiple objects and controls:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Change the BackColor property for all the controls on the form.
Sub SetBackColor(frm As Form, NewColor As Long)
    Dim ctrl As Control
    On Error Resume Next            ' Account for invisible controls.
    For Each ctrl In frm.Controls
        ctrl.BackColor = NewColor
    Next
End Sub
</pre>
</td></tr>
</table></p>

<A NAME="290"><h2>Leveraging Polymorphism </h2></A>
<p>You can exploit the benefits of polymorphism to write better code in many ways. In this section, I examine the two that are most obvious: procedures with polymorphic arguments and classes with polymorphic methods.</p>

<A NAME="291"><h3>Polymorphic procedures</h3></A>
<p>A polymorphic procedure can do different things depending on which arguments you pass it. In previous chapters, I have often implicitly used this idea, for example, when writing routines that use a <I>Variant </I>argument to process arrays of different types. Let's see now how you can expand on this concept for writing more flexible classes. I'll illustrate a simple CRectangle class, which exposes a number of simple properties (<I>Left</I>,<I> Top</I>,<I> Width</I>,<I> Height</I>,<I> Color</I>, and <I>FillColor</I>) and a <I>Draw</I> method that displays it on a surface. Here's the source code of the class module:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In a complete implementation, we would use property procedures.
Public Left As Single, Top As Single
Public Width As Single, Height As Single
Public Color As Long, FillColor As Long    

Private Sub Class_Initialize()
    Color = vbBlack
    FillColor = -1              ' -1 means &quot;not filled&quot;
End Sub

' A pseudoconstructor method
Friend Sub Init(Left As Single, Top As Single, Width As Single, Height As _
    Single, Optional Color As Variant, Optional FillColor As Variant)
    ' .... code omitted for brevity
End Sub

' Draw this shape on a form, a picture box, or the Printer object.
Sub Draw(pic As Object)
    If FillColor &lt;&gt; -1 Then
        pic.Line (Left, Top)-Step(Width, Height), FillColor, BF
    End If
    pic.Line (Left, Top)-Step(Width, Height), Color, B
End Sub
</pre>
</td></tr>
</table></p>


<p>For the sake of brevity, all the properties are implemented as Public variables, but in a real implementation you would surely use Property procedures to enforce validation rules. The real focal point of this class, however, is the <I>Draw</I> method, which expects an Object argument. This means that we can display the rectangle on any object that supports the <I>Line</I> method:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim rect As New CRect
' Create a white rectangle with a red border.
rect.Init 1000, 500, 2000, 1500, vbRed, vbWhite
' Display it wherever you want.
If PreviewMode Then
    rect.Draw Picture1          ' A picture box
Else
    rect.Draw Printer           ' A printer
End If
</pre>
</td></tr>
</table></p>

<p>This first form of polymorphism is interesting, though limited. In this particular case, in fact, we can't do much more than what we've done because forms, PictureBox controls, and the Printer are the only objects that support the <I>Line</I> method with its exotic syntax. The really important point is that the client application benefits from this capability to simplify its code.</p>

<A NAME="292"><h3>Polymorphic classes</h3></A>
<p>The real power of polymorphism becomes apparent when you create multiple class modules and select the names of their properties and methods in a way that ensures a complete or partial polymorphism among them. For example, you can create a CEllipse class that's completely polymorphic with the CRectangle class, even if the two classes are implemented differently:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The CEllipse class
Public Left As Single, Top As Single
Public Width As Single, Height As Single
Public Color As Long, FillColor As Long    

Private Sub Class_Initialize()
    Color = vbBlack
    FillColor = -1             ' -1 means &quot;not filled&quot;
End Sub

' Draw this shape on a form, a picture box, or the Printer object.
Sub Draw(pic As Object)
    Dim aspect As Single, radius As Single
    Dim saveFillColor As Long, saveFillStyle As Long
    aspect = Height / Width
    radius = IIf(Width &gt; Height, Width / 2, Height / 2)
    If FillColor &lt;&gt; -1 Then
        saveFillColor = pic.FillColor
        saveFillStyle = pic.FillStyle
        pic.FillColor = FillColor
        pic.FillStyle = vbSolid
        pic.Circle (Left + Width / 2, Top + Height / 2), radius, Color, _
            , , aspect
        pic.FillColor = saveFillColor
        pic.FillStyle = saveFillStyle
    Else
        pic.Circle (Left + Width / 2, Top + Height / 2), radius, Color, _
            , , aspect
    End If
End Sub
</pre>
</td></tr>
</table></p>

<p>You can also create classes that are only partially polymorphic with respect to CRectangle. For example, a CLine class might support the <I>Draw</I> method and the <I>Color</I> property but use different names for its other members:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The CLine class
Public X As Single, Y As Single
Public X2 As Single, Y2 As Single
Public Color As Long

Private Sub Class_Initialize()
    Color = vbBlack
End Sub

' Draw this shape on a form, a picture box, or the Printer object.
Sub Draw(pic As Object)
    pic.Line (X, Y)-(X2, Y2), Color
End Sub
</pre>
</td></tr>
</table></p>

<p>Now you have three classes that are polymorphic with one another with respect to their <I>Draw</I> methods and their <I>Color</I> properties. This permits you to create a first version of a very primitive CAD-like application, named Shapes, shown in Figure 7-5. You can do this by using an array or a collection that holds all your shapes so that you can redraw all of them quite easily. To keep the client code as concise and descriptive as possible, you can also define a number of factory methods in a separate BAS module (not shown here because it's not terribly interesting for our purposes):</p>

<p>
<A HREF="javascript:fullSize('F07ph05x.htm')"> <img src="images/F07ph05.JPG" width=404 height=277 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 7-5.</B> <i>Playing with polymorphic shapes.</i><!--/caption-->
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' This is a module-level variable.
Dim Figures As Collection

Private Sub Form_Load()
    CreateFigures
End Sub
Private Sub cmdRedraw_Click()
    RedrawFigures
End Sub

' Create a set of figures.
Private Sub CreateFigures()
    Set Figures = New Collection
    Figures.Add New_CRectangle(1000, 500, 1400, 1200, , vbRed)
    Figures.Add New_CRectangle(4000, 500, 1400, 1200, , vbCyan)
    Figures.Add New_CEllipse(2500, 2000, 1400, 1200, , vbGreen)
    Figures.Add New_CEllipse(3500, 3000, 2500, 2000, , vbYellow)
    Figures.Add New_CRectangle(4300, 4000, 1400, 1200, , vbBlue)
    Figures.Add New_CLine(2400, 1100, 4000, 1100, vbBlue)
    Figures.Add New_CLine(1700, 1700, 1700, 4000, vbBlue)
    Figures.Add New_CLine(1700, 4000, 3500, 4000, vbBlue)
End Sub

' Redraw figures.
Sub RedrawFigures()
    Dim Shape As Object
    picView.Cls
    For Each Shape In Figures
        Shape.Draw picView
    Next
End Sub
</pre>
</td></tr>
</table></p>

<p>While complete polymorphism is always preferable, you can still use a lot of interesting techniques when objects have just a few properties in common. For example, you can quickly turn the contents of the Figures collection into a series of wire-framed objects:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>On Error Resume Next     ' CLine doesn't support the FillColor property.
For Each Shape In Figures
    Shape.FillColor = -1
Next
</pre>
</td></tr>
</table></p>

<p>It's easy to add sophistication to this initial example. For example, you might add support for moving and zooming objects, using the <I>Move</I> and <I>Zoom</I> methods. Here's a possible implementation of these methods for the CRectangle class:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In CRectangle class module...
' Move this object.
Sub Move(stepX As Single, stepY As Single)
    Left = Left + stepX
    Top = Top + stepY
End Sub

' Enlarge or shrink this object on its center.
Sub Zoom(ZoomFactor As Single)
    Left = Left + Width * (1 - ZoomFactor) / 2
    Top = Top + Height * (1 - ZoomFactor) / 2
    Width = Width * ZoomFactor
    Height = Height * ZoomFactor
End Sub
</pre>
</td></tr>
</table></p>

<p>The implementation for the CEllipse class is identical to this code because it's perfectly polymorphic with CRectangle and therefore exposes <I>Left</I>, <I>Top</I>, <I>Width</I>, and <I>Height</I> properties. The CLine class supports both the <I>Move</I> and the <I>Zoom</I> method as well, even if their implementation is different. (See the code on the companion CD for more details.)</p>

<p>Figure 7-6 shows an improved Shapes sample program, which also permits you to move and zoom the objects on the playground. This is the code behind the buttons on the form:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cmdMove_Click(Index As Integer)
    Dim shape As Object
    For Each shape In Figures
        Select Case Index
            Case 0: shape.Move 0, -100    ' Up
            Case 1: shape.Move 0, 100     ' Down
            Case 2: shape.Move -100, 0    ' Left
            Case 3: shape.Move 100, 0     ' Right
        End Select
    Next
    RedrawFigures
End Sub

Private Sub cmdZoom_Click(Index As Integer)
    Dim shape As Object
    For Each shape In Figures
        If Index = 0 Then
            shape.Zoom 1.1                ' Enlarge
        Else
            shape.Zoom 0.9                ' Reduce
        End If
    Next
    RedrawFigures
End Sub
</pre>
</td></tr>
</table></p>

<p>If you want to appreciate what polymorphism can do for your programming habits, just think of the many lines of code you would have written to solve this simple programming task using any other means. And of course consider that you can apply these techniques to more complex business objects, including Documents, Invoices, Orders, Customers, Employees, Products, and so on.</p>

<p>
<A HREF="javascript:fullSize('F07ph06x.htm')"> <img src="images/F07ph06.JPG" width=404 height=284 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 7-6.</B> <i>More fun with polymorphic shapes.</i><!--/caption-->
</p>

<A NAME="293"><h3>Polymorphism and late binding</h3></A>
<p>I haven't yet talked about one aspect of polymorphism in the depth it deserves. The most important trait in common among all the polymorphic examples seen so far is that you have been able to write polymorphic code only because you use <I>generic </I>object variables. For example, the <I>pic </I>argument in the <I>Draw</I> method is declared with <I>As Object</I>, as is the <I>Shape </I>variable in all <I>Click</I> procedures in the preceding code. You might use Variant variables that hold an object reference, but the concept is the same: you are doing polymorphism through late binding.</p>

<p>As you'll recall from <a href="ch06a.htm">Chapter 6</a>, late binding is a technique that has several defects, the most serious being a sloppy performance&#8212;it's even <I>hundreds </I>of times slower than early binding&#8212;and less robust code. Depending on the particular piece of code you're working on, these defects can easily nullify all the benefits you get from polymorphism. Fortunately, Visual Basic offers a solution to this problem&#8212;a great solution, I daresay. To understand how it works, you must be familiar with the concept of <I>interfaces</I>.</p>

<A NAME="294"><h2>Working with Interfaces</h2></A>
<p>When you start using polymorphism in your code, you realize that you're logically subdividing all the properties and methods exposed by your objects into distinct groups. For example, the CRectangle, CEllipse, and CLine classes expose a few members in common (<I>Draw</I>, <I>Move</I>, and <I>Zoom</I>). With real-world objects, which include dozens or even hundreds of properties and methods, creating groups of them isn't just a luxury, it's necessary. A group of related properties and methods is called an <I>interface</I>.</p>

<p>Under Visual Basic 4, any object could have only one interface, the <I>main </I>interface. Starting with version 5, Visual Basic's class modules can include one or more <I>secondary interfaces</I>. This is exactly what you need to better organize your object-oriented code. And you'll see that this innovation has many other beneficial implications.</p>

<A NAME="295"><h3>Creating a secondary interface</h3></A>
<p>In Visual Basic 5 and 6, the definition of a secondary interface requires that you create a separate class module. This module doesn't contain any executable code, just the definition of properties and methods. For this reason, it's often called an <I>abstract class</I>. As with any Visual Basic module, you need to give it a name. It's customary to distinguish interface names from class names by using a leading letter <I>I</I>.</p>

<p>Back to our mini-CAD example: Let's create an interface that gathers the <I>Draw</I>, <I>Move</I>, and <I>Zoom</I> methods&#8212;that is, the members in common to all the shapes we're dealing with. This will be the IShape interface. To add some spice, I am also adding the <I>Hidden</I> property:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The IShape class module
Public Hidden As Boolean

Sub Draw(pic As Object)
    ' (Empty comment to prevent automatic deletion of this routine)
End Sub
Sub Move(stepX As Single, stepY As Single)
    '
End Sub
Sub Zoom(ZoomFactor As Single)
    '
End Sub
</pre>
</td></tr>
</table></p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
You might need to add a comment inside all methods to prevent the editor from automatically deleting empty routines when the program is executed.
</blockquote></div></p>

<p>This class doesn't include any executable statements and only serves as a model for the IShape interface. What really matters are the names of properties and methods, their arguments, and the type of each one of them. For the same reason, you don't need to create pairs of Property procedures because a simple Public variable is usually enough. For only two cases do you need explicit Property procedures:</p>

<UL>
<p><li>You want to specify that a property is read-only: in this case, you explicitly omit the <I>Property Let</I> or <I>Property Set</I> procedure.</li></p>

<p><li>You want to specify that a <I>Variant</I> property can never return an object: in this case, you include the <I>Property Get</I> and <I>Property Let</I> procedures but omit the <I>Property Set</I> procedure.</li></p>
</UL>
 
<p>Interfaces never include <I>Event</I> declarations. Visual Basic takes only Public properties and methods into account when you're using a CLS module as an abstract class that defines a secondary interface.</p>

<A NAME="296"><h3>Implementing the interface</h3></A>
<p>The next step is letting Visual Basic know that the CRectangle, CEllipse, and CLine classes expose the IShape interface. You do this by adding an <I>Implements</I> keyword in the declaration section of each class module:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the CRectangle class module
Implements IShape
</pre>
</td></tr>
</table></p>

<p>Declaring that a class exposes an interface is only half of the job because you now have to actually <I>implement </I>the interface. In other words, you must write the code that Visual Basic will execute when any member of the interface is invoked. The code editor does part of the job on your behalf by creating the code template for each individual routine. The mechanism is similar to the one available for events: In the leftmost combo box, you select the name of the interface (it appeared in the box as soon as you moved the caret away from the <I>Implements</I> statement) and select the name of a method or a property in the rightmost combo box, which you can see in Figure 7-7. Notice this important difference from events, though: When you implement an interface, you must create <I>all </I>the procedures listed in this combo box. If you don't do this, Visual Basic won't even run your application. For this reason, the fastest way to proceed is to select all the items in the rightmost combo box to create all the procedure templates, and then add code to them. Note that all names have been prefixed with IShape_, which solves any name conflict with the methods already in the module, and that all routines have been declared to be Private. This is what you want because if they were Public, they would appear in the main interface. Also note that the <I>Hidden</I> property has generated a pair of Property procedures.</p>

<A NAME="297"><h3>Writing the actual code</h3></A>
<p>To complete the implementation of the interface, you must write code inside the procedure templates. If you don't, the program will run but the object will never respond to the IShape interface.</p>

<p>Interfaces are said to be <I>contracts</I>: If you implement an interface, you implicitly agree to respond to all the properties and methods of that interface in a way that complies with the interface specifications. In this case, you're expected to react to the <I>Draw</I> method with code that displays the object, to the <I>Move</I> method with code that moves the object, and so on. If you fail to do so, you're breaking the interface contract and you're the only one to blame for this.</p>

<p>
<A HREF="javascript:fullSize('F07ph07x.htm')"> <img src="images/F07ph07.JPG" width=404 height=303 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 7-7.</B> <i>Let the code editor create the procedure templates for you.</i><!--/caption-->
</p>

<p>Let's see how you can implement the IShape interface in your CRectangle class. In this case, you already have the code that displays, moves, and scales the object&#8212;namely, the <I>Draw</I>, <I>Move</I>, and <I>Zoom</I> methods in the main interface. One of the goals of secondary interfaces, however, is to get rid of redundant members in the main interface. In line with this, you should delete the <I>Draw</I>, <I>Move</I>, and <I>Zoom</I> methods from CRectangle's primary interface and move their code inside the IShape interface:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' A (private) variable to store the IShape_Hidden property
Private Hidden As Boolean

Private Sub IShape_Draw(pic As Object)
    If Hidden Then Exit Sub
    If FillColor &gt;= 0 Then
        pic.Line (Left, Top)-Step(Width, Height), FillColor, BF
    End If
    pic.Line (Left, Top)-Step(Width, Height), Color, B
End Sub

Private Sub IShape_Move(stepX As Single, stepY As Single)
    Left = Left + stepX
    Top = Top + stepY
End Sub

Private Sub IShape_Zoom(ZoomFactor As Single)
    Left = Left + Width * (1 - ZoomFactor) / 2
    Top = Top + Height * (1 - ZoomFactor) / 2
    Width = Width * ZoomFactor
    Height = Height * ZoomFactor
End Sub

Private Property Let IShape_Hidden(ByVal RHS As Boolean)
    Hidden = RHS
End Property
Private Property Get IShape_Hidden() As Boolean
    IShape_Hidden = Hidden
End Property
</pre>
</td></tr>
</table></p>

<p>This completes the implementation of the IShape interface for the CRectangle class. I won't show here the code for CEllipse and CLine because it's substantially the same, and you'll probably prefer to browse it on the companion CD.</p>

<A NAME="298"><h3>Accessing the secondary interface</h3></A>
<p>Accessing the new interface is simple. All you have to do is declare a variable of the IShape class and assign the object to it:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the client code ...
Dim Shape As IShape    ' A variable that points to an interface
Set Shape = Figures(1) ' Get the first figure in the list.
Shape.Draw picView     ' Call the Draw method in the IShape interface.
</pre>
</td></tr>
</table></p>

<p>The Set command in the previous code is somewhat surprising because you would expect that the assignment would fail with a Type Mismatch error. Instead, the code works because the compiler can ascertain that the Figures(1) object (a CRectangle object in this particular sample program) supports the IShape interface and that a valid pointer can be returned and safely stored in the <I>Shape </I>variable. It's as if Visual Basic queried the source CRectangle object, &quot;Do you support the IShape interface?&quot; If it does, the assignment can be completed, otherwise an error is raised. This operation is referred to as <I>QueryInterface</I>, or <I>QI </I>for short.</p>

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
In <a href="ch06a.htm">Chapter 6</a>, you learned that a class is always paired with a <I>VTable</I> structure, which holds the addresses of all its procedures. A class that implements a secondary interface comes with a secondary <I>VTable</I> structure, which of course points to the procedures of that secondary interface. When a <I>QI </I>command is attempted for a secondary interface, the value returned in the target variable is the address of a memory location inside the instance data area, which in turn holds the address of this secondary <I>VTable</I> structure. (See Figure 7-8.) This mechanism enables Visual Basic to deal with primary and secondary interfaces using the same low-level core routines.
</blockquote></div>

<p>
<A HREF="javascript:fullSize('F07ph08x.htm')"> <img src="images/F07ph08.JPG" width=404 height=337 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 7-8.</B> <i>Secondary interfaces and VTable structures. (Compare this with Figure 6-8.)</i><!--/caption-->
</p>

<p><I>QueryInterface </I>is a symmetrical operation, and Visual Basic lets you do assignments in both directions:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim Shape As IShape, Rect As CRectangle
' You can create a CRectangle object on the fly.
Set Shape = New CRectangle
Set Rect = Shape                 ' This works.
Rect.Init 100, 200, 400, 800     ' Rect points to primary interface.
Shape.Move 30, 60                ' Shape points to its IShape interface.
' Next statement proves that both variables point to the same instance.
Print Rect.Left, Rect.Top        ' Displays &quot;130&quot; and &quot;260&quot;
</pre>
</td></tr>
</table></p>

<A NAME="299"><h3>Refining the client code</h3></A>
<p>If you implement the IShape interface in the CEllipse and CLine classes as well, you'll see that you can call code inside any of these three classes using the <I>Shape </I>variable. In other words, you're doing polymorphism using a variable of a specific type, hence, you can now use early binding.</p>

<p>When two or more classes share an interface, they're said to be <I>polymorphic with each other </I>with respect to that particular interface. This technique lets you speed up the Shapes program and make it more robust at the same time. What's really astonishing is that you can accomplish all this by replacing one single line in the original client code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub RedrawFigures()
<B>    Dim shape As IShape         ' Instead of &quot;As Object&quot;</B>
    picView.Cls
    For Each shape In Figures
        shape.Draw picView
    Next
End Sub
</pre>
</td></tr>
</table></p>

<p>The performance benefit you can get using this approach can vary greatly. This particular routine spends most of its time doing graphics, so the speed improvement might go unnoticed. Most of the time, however, you'll literally see the difference before your eyes.</p>

<A NAME="300"><h3>Playing with VBA keywords </h3></A>
<p>Before diving into another (I hope) fascinating OOP topic, let's see how a few VBA keywords behave when applied to object variables that point to a secondary interface.</p>

<p><b>The <I>Set</I> keyword</b> As you just saw, you can freely assign object variables to each other, even if they're of different types. The only condition is that the source object (the right side of the assignment) must implement the target class (the left side of the assignment) as a secondary interface. The opposite is also possible&#8212;that is, when the source class is an interface implemented by the target class. In both cases, remember that you're assigning a reference to the <I>same</I> object.</p>

<p><b>The <I>TypeName</I> function</b> This function returns the name of the original class of the object pointed to by the object variable, regardless of the type of argument. For example, consider this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim rect As New CRectangle, shape As IShape
Set shape = rect
Print TypeName(shape)     ' Displays &quot;CRectangle&quot;, not &quot;IShape&quot;!
</pre>
</td></tr>
</table></p>

<p><b>The <I>TypeOf...Is</I> statement</b> The <I>TypeOf&#8230;Is</I> statement tests whether an object supports a given interface. You can test for primary and secondary interfaces, as in this example:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim rect As New CRectangle, shape As IShape
Set shape = rect
' You can pass a variable and test a secondary interface.
If TypeOf rect Is IShape Then Print &quot;OK&quot;          ' Displays &quot;OK&quot;
' You can also pass a variable pointing to a secondary interface
' and test the primary interface (or a different secondary interface).
If TypeOf shape Is CRectangle Then Print &quot;OK&quot;     ' Displays &quot;OK&quot;
</pre>
</td></tr>
</table></p>

<p>In <a href="ch06a.htm">Chapter 6</a>, I suggested that you use <I>TypeName</I> instead of a<I> TypeOf&#8230;Is</I> statement. This is correct when you're dealing with primary interfaces exclusively, but when you're testing for a secondary interface you really need <I>TypeOf&#8230;Is</I>.</p>

<p><b>The <I>Is</I> keyword</b> In <a href="ch06a.htm">Chapter 6</a>, I explained that the Is operator simply compares the contents of the involved object variables. This is true only when you're comparing variables that hold pointers to the primary interface: when you compare object variables of different types, Visual Basic is smart enough to understand whether they're pointing to the same instance data area, even if the values stored in the variables are different:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Set shape = rect
Print (rect Is shape)               ' Displays &quot;True&quot;.
</pre>
</td></tr>
</table></p>

<A NAME="301"><h3>Support functions to retrieve secondary interfaces</h3></A>
<p>When you get more involved with secondary interfaces, you'll soon find yourself writing a lot of code just to retrieve the secondary interface of an object. This effort usually requires declaring a variable of the given type and executing a Set command. You might instead find it convenient to write a simple function in a BAS module that does it for you:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function QI_IShape(shape As IShape) As IShape
    Set QI_IShape = shape
End Function
</pre>
</td></tr>
</table></p>

<p>For example, see how you can invoke the <I>Move</I> method in the IShape interface of a CRectangle object:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>QI_IShape(rect).Move 10, 20
</pre>
</td></tr>
</table></p>


<p>In most cases, you don't need a temporary variable even when assigning multiple properties or multiple methods:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>With QI_IShape(rect)
    .Move 10, 20
    .Zoom 1.2
End With
</pre>
</td></tr>
</table></p>

</BODY>
</HTML>





