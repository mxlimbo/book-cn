<HTML>
<HEAD>
<TITLE>Object Hierarchies</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07d.htm", "ch08a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="312"><h1>Object Hierarchies</h1></A>
<p>So far, I have shown you how you can store complex pieces of logic in a class and reuse these pieces elsewhere in your application and in your future projects with very little effort. But what you have seen so far are <I>individual </I>classes that solve particular programming problems. The real power of objects is striking when you use them to create larger cooperative structures, also known as <I>object hierarchies</I>.</p>

<A NAME="313"><h2>Relationships Among Objects</h2></A>
<p>If you want to aggregate multiple objects in larger structures, you need a way to establish relationships among them.</p>

<A NAME="314"><h3>One-to-one relationships</h3></A>
<p>In the world of OOP, establishing a relationship between two objects is as simple as providing the former object with an object property that points to the latter. For example, a typical CInvoice object might expose a <I>Customer</I> property (which points to a Customer object) and two properties, <I>SendFrom</I> and <I>ShipTo</I>, that can contain references to a CAddress object:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the CInvoice class module
Public Customer As CCustomer           ' In a real app, these would
Public SendFrom As CAddress            ' be implemented as pairs
Public ShipTo As CAddress              ' of property procedures.
</pre>
</td></tr>
</table></p>

<p>This code <I>declares </I>that the class is able to support these relationships. You actually <I>create</I> the relationships at run time when you assign a non-Nothing reference to the properties:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim inv As New CInvoice, cust As CCustomer
inv.Number = GetNextInvoiceNumber()    ' A routine defined somewhere else
' For simplicity, let's not worry about how the CUST object is created.
Set cust = GetThisCustomer()           ' This returns a CCustomer object.
Set inv.Customer = cust                ' This creates the relationship.
' You don't always need an explicit variable.
Set inv.SendFrom = GetFromAddress()    ' This returns a CAddress object,
Set inv.ShipTo = GetToAddress()        ' as does this one.
</pre>
</td></tr>
</table></p>

<p>Once the relationship has been established, you can start playing with the infinite possibilities offered by VBA and write code that is extremely concise and elegant:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the CInvoice class module
Sub PrintHeader(obj As Object)
    ' Print the invoice on a form, PictureBox, or the Printer.
    obj.Print &quot;Number &quot; &amp; Number
    obj.Print &quot;Customer: &quot; &amp; Customer.Name
    obj.Print &quot;Send From: &quot; &amp; SendFrom.CompleteAddress
    obj.Print &quot;Ship To: &quot; &amp; ShipTo.CompleteAddress
End Sub
</pre>
</td></tr>
</table></p>


<p>Being able to deal with data already logically grouped in subproperties noticeably improves the quality and style of your code. Because, in most cases, the <I>ShipTo</I> address coincides with the address of the customer, you can offer a reasonable default for that property. You only have to delete the Public <I>ShipTo</I> member in the declaration section and add the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private m_ShipTo As CAddress

Property Get ShipTo() As CAddress
    If m_ShipTo Is Nothing Then
        Set ShipTo = Customer.Address
    Else
        Set ShipTo = m_ShipTo
    End If
End Property
Property Let ShipTo(newValue As CAddress)
    Set m_ShipTo = newValue
End Property
</pre>
</td></tr>
</table></p>

<p>Because you aren't touching the class's interface, the rest of the code&#8212;both inside and outside the class itself&#8212;continues to work without a glitch.</p>

<p>Once the relation is set, there's no way to accidentally invalidate it by tampering with the involved objects. In the CInvoice example, even if you explicitly set the <I>cust </I>variable to Nothing&#8212;or let it go out of scope, which has the same effect&#8212;Visual Basic won't destroy the CCustomer instance, and therefore the relationship between Invoice and Customer will continue to work as before. This isn't magic; it's simply a consequence of the rule that states that an object instance is released only when all the object variables that reference it are set to Nothing. In this case, the <I>Customer</I> property in the CInvoice class keeps that particular CCustomer instance alive until you set the <I>Customer</I> property to Nothing or the CInvoice object itself is destroyed. You don't need to explicitly set the <I>Customer</I> property to Nothing in the <I>Class_Terminate</I> event of the CInvoice class: When an object is released, Visual Basic neatly sets all its object properties to Nothing before proceeding with the actual deallocation. This operation decreases the reference counter of all the referenced objects, which in turn are destroyed if their reference counter goes to 0. In larger object hierarchies, it often happens that destroying an object causes a complex chain of cascading deallocation operations. Fortunately, you don't have to worry about it because it's Visual Basic's business, not yours.</p>

<A NAME="315"><h3>One-to-many relationships</h3></A>
<p>Things are a bit more complex when you create one-to-many relationships among objects. There are countless occasions when one-to-many relationships are necessary. For example, your CInvoice class might have to point to multiple product descriptions. Let's see how this problem can be solved efficiently.</p>

<p>For your object-oriented experiment, you need an auxiliary class, CInvoiceLine, which holds information about a product, ordered quantity, and unit price. What follows is a very simple implementation of it, with no validation at all. (Don't use this implementation in your real invoicing software, <I>please!</I>) The version on the companion CD also has a constructor, a <I>Description</I> property, and other features, but you need just three variables and a property procedure to get started:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' A workable CInvoiceLine class module
Public Qty As Long
Public Product As String
Public UnitPrice As Currency

Property Get Total() As Currency
    Total = Qty * UnitPrice
End Property
</pre>
</td></tr>
</table></p>

<p>You can choose, basically, from two ways to implement such one-to-many relations: You can use an array of object references, or you can use a collection. The array solution is trivial:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' We can't expose arrays as Public members.
Private m_InvoiceLines(1 To 10) As CInvoiceLine

Property Get InvoiceLines(Index As Integer) As CInvoiceLine
    If Index &lt; 1 Or Index &gt; 10 Then Err.Raise 9   ' Subscript out of range
    Set InvoiceLines(Index) = m_InvoiceLines(Index)
End Property
Property Set InvoiceLines(Index As Integer, newValue As CInvoiceLine)
    If Index &lt; 1 Or Index &gt; 10 Then Err.Raise 9   ' Subscript out of range
    Set m_InvoiceLines(Index) = newValue
End Property

' In the client code
' (Assumes that we defined a constructor for the CInvoiceLine class)
Set inv.InvoiceLine(1) = New_CInvoiceLine(10, &quot;Monitor ZX100&quot;, 225.25)
Set inv.InvoiceLine(2) = New_CInvoiceLine(14, &quot;101-key Keyboard&quot;, 19.99)
' etc.
</pre>
</td></tr>
</table></p>

<p>As easy as they are to implement, arrays of object references have a lot of problems, especially because it isn't clear how you can use them effectively when you don't know in advance how many child CInvoiceLine items you need. In fact, I suggest that you use them only if you're absolutely sure that the number of possible related objects is well defined in advance.</p>

<p>The collection solution is more promising because it doesn't pose any limit to the number of related objects, and also because it permits a more natural, OO-like syntax in the client code. Besides, you <I>can </I>declare a collection (unlike an array) as a Public member, so the code in the class module is even simpler:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the CInvoice class
Public InvoiceLines As New Collection

' In the client code (no need to keep track of line index)
inv.InvoiceLines.Add New_CInvoiceLine(10, &quot;Monitors ZX100&quot;, 225.25)
inv.InvoiceLines.Add New_CInvoiceLine(14, &quot;101-key Keyboards&quot;, 19.99)
</pre>
</td></tr>
</table></p>

<p>Using a collection improves the code inside the CInvoice class in other ways as well. See how easily you can enumerate all the lines in an invoice:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub PrintBody(obj As Object)
    ' Print the invoice body on a form, PictureBox, or the Printer.
    Dim invline As CInvoiceLine, Total As Currency
    For Each invline In InvoiceLines
        obj.Print invline.Description
        Total = Total + invline.Total
    Next
    obj.Print &quot;Grand Total = &quot; &amp; Total
End Sub
</pre>
</td></tr>
</table></p>

<p>This solution has one major drawback, though. It leaves the CInvoice class completely at the mercy of the programmer who uses it. To see what I mean, just try out this bogus code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>inv.InvoiceLines.Add New CCustomer          ' No error!
</pre>
</td></tr>
</table></p>

<p>This isn't surprising, of course: Collection objects store their values in Variants, so they accept anything you throw at them. This seemingly innocent detail undermines the robustness of the CInvoice class and completely undoes all our efforts. Must we tolerate it?</p>

<A NAME="316"><h2>Collection Classes </h2></A>
<p>The solution to the robustness problem comes in the form of <I>collection classes</I>. These are special classes that you write in plain Visual Basic code and that closely resemble native Collection objects. Since you are in control of their implementation, you can establish a particular syntax for their methods and check what's being added to the collection. As you'll see, they're so alike that you won't even need to retouch the client code.</p>

<p>Collection classes are an application of the concept of inheritance that I described earlier in this chapter. A collection class keeps a reference to a private collection variable and exposes to the outside a similar interface so that the client code believes it's interacting with a real Collection. To enhance the CInvoice example, you therefore need a special CInvoiceLines collection class. (It's customary for the name of a collection class to be the plural form of the name of the base class.) Now that you have mastered the secrets of inheritance, you should have no problem understanding how the code below works.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The private collection that holds the real data
Private m_InvoiceLines As New Collection

Sub Add(newItem As CInvoiceLine, Optional Key As Variant, _
    Optional Before As Variant, Optional After As Variant)
    m_InvoiceLines.Add newItem, Key
End Sub
Sub Remove(index As Variant)
    m_InvoiceLines.Remove index
End Sub
Function Item(index As Variant) As CInvoiceLine
    Set Item = m_InvoiceLines.Item(index)
End Function
Property Get Count() As Long
    Count = m_InvoiceLines.Count
End Property
</pre>
</td></tr>
</table></p>

<p>You need to do two more things to make your CInvoiceLines collection class perfectly mimic a standard Collection: You must provide support for the default item and for enumeration.</p>

<A NAME="317"><h3>Make <I>Item</I> the default member</h3></A>
<p>Programmers are used to omitting the <I>Item</I> member's name in code when working with Collection objects. To support this feature in your collection class, you just have to make <I>Item</I> the default member of the class, which you do by issuing the Procedure Attributes command from the Tools menu, selecting <I>Item </I>in the uppermost combo box, expanding the dialog box, and typing <I>0</I> (zero) in the ProcID field. Or you can select <I>(default)</I> in the drop-down list. This procedure was explained in more detail in <a href="ch06a.htm">Chapter 6</a>.</p>

<A NAME="318"><h3>Add support for enumeration</h3></A>
<p>No collection class could hope to win the hearts of hardcore Visual Basic developers if it didn't support the <I>For Each</I> statement. Visual Basic lets you add such support, though in a rather cryptic way. First add the following procedure to your class module:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function NewEnum() As IUnknown
    Set NewEnum = m_InvoiceLines.[_NewEnum]
End Function
</pre>
</td></tr>
</table></p>

<p>and then invoke the Procedure Attributes dialog box. Then select the <I>NewEnum</I> member, assign it a ProcID equal to -4, tick the Hide This Member check box, and close the dialog box.</p>

<P><div class="NOTE"><blockquote>
<B>NOTE</B><HR>
Understanding how this weird technique works requires some intimate knowledge of OLE mechanisms, in particular the IEnumVariant interface. Without going into too many details, suffice it to say that when an object appears in a <I>For Each</I> statement, it has to expose an auxiliary <I>enumerator object</I>. OLE conventions dictate that the class must provide this enumerator object through a function whose ProcID is equal to -4. At run time, Visual Basic calls the corresponding procedure and uses the returned enumerator object to progress through the loop iteration.

<p>Unfortunately, you can't manufacture an enumerator object using plain Visual Basic code, but you can borrow the enumerator object exposed by the private Collection object, which is exactly what the <I>NewEnum</I> function shown previously does. Collection objects expose their enumerators using a hidden method named <I>_NewEnum</I> (search for it in the Object Browser with the Show Hidden Members option enabled), which is an invalid name in VBA and must therefore be enclosed in a pair of square brackets. By the way, Dictionary objects don't expose any Public enumerator objects, and for this reason you can't use them as the basis of your collection classes.</p>
</blockquote></div></p>

<A NAME="319"><h3>Testing the collection class</h3></A>
<p>You can now improve the CInvoice class by making it use your new CInvoiceLines class instead of the standard Collection object:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the declaration section of CInvoice
Public InvoiceLines As New CInvoiceLines
</pre>
</td></tr>
</table></p>

<p>The mere fact that the CInvoiceLines class checks the type of object passed to its <I>Add</I> method is enough to morph the CInvoice class into a secure object. Interestingly, you don't strictly need any other changes in code, either inside or outside the class. Just press F5 to see it for yourself.</p>

<A NAME="320"><h3>Improving the collection class</h3></A>
<p>If collection classes were useful only to improve the robustness of your code, they would be worth the effort. But the real fun only begins here. Since you have complete control over what happens inside your class, you can decide to improve it with new methods or modify how existing ones react to their arguments. For example, you can have the <I>Item</I> method return Nothing if the element doesn't exist, instead of obnoxiously raising an error as regular collections do:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function Item(index As Variant) As CInvoiceLine
    On Error Resume Next
    Set Item = m_InvoiceLines.Item(index)
End Function
</pre>
</td></tr>
</table></p>

<p>Or you can add an explicit <I>Exists</I> function as shown below.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function Exists(index As Variant) As Boolean
    Dim dummy As CInvoiceLine
    On Error Resume Next
    Set dummy = m_InvoiceLines.Item(index)
    Exists = (Err = 0)
End Function
</pre>
</td></tr>
</table></p>

<p>You can also supply a handy <I>Clear</I> method:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub Clear()
    Set m_InvoiceLines = New Collection
End Sub
</pre>
</td></tr>
</table></p>

<p>All these custom members are completely generic, and you can often implement them in most of the collection classes you write. Methods and properties that are specific to the particular collection class are undoubtedly more interesting:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Evaluate the total of all invoice lines.
Property Get Total() As Currency
    Dim result As Currency, invline As CInvoiceLine
    For Each invline In m_InvoiceLines
        result = result + invline.Total
    Next
    Total = result
End Property

' Print all invoice lines.
Sub PrintLines(obj As Object)
    Dim invline As CInvoiceLine
    For Each invline In m_InvoiceLines
        obj.Print invline.Description
    Next
End Sub
</pre>
</td></tr>
</table></p>

<p>These new members simplify the structure of the code in the main class:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the CInvoice class
Sub PrintBody(obj As Object)
    InvoiceLines.PrintLines obj
    obj.Print &quot;Grand Total = &quot; &amp; InvoiceLines.Total
End Sub
</pre>
</td></tr>
</table></p>

<p>Of course, the total amount of code doesn't vary, but you have distributed it in a more logical way. Each object is responsible for what happens inside it. In real projects, this approach has many beneficial consequences in code testing, reuse, and maintenance.</p>

<A NAME="321"><h3>Add real constructors to the game</h3></A>
<p>Collection classes offer one additional benefit that object-oriented programmers can't live without: <I>real constructors</I>. I have already explained that the lack of constructor methods is a major defect in the otherwise decent support for encapsulation supplied by Visual Basic.</p>

<p>If you wrap a collection class around a base class&#8212;as CInvoiceLines and CInvoiceLine do, respectively&#8212;you can create a constructor by adding a method to the collection class that creates a new base object and adds it to the collection in one single step. In most cases, this double operation makes a lot of sense. For example, a CInvoiceLine object would have a very hard life outside a parent CInvoiceLines collection. (Have you ever seen a lone invoice line wandering around all by itself in the external world?) It turns out that such a constructor is just a variant of the <I>Add </I>method:</p></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function Create(Qty As Long, Product As String, UnitPrice As Currency) _
    As CInvoiceLine
    Dim newItem As New CInvoiceLine ' Auto-instancing is safe here.
    newItem.Init Qty, Product, UnitPrice
    m_InvoiceLines.Add newItem
    Set Create = newItem            ' Return the item just created.
End Function

' In the client code
inv.InvoiceLines.Create 10, &quot;Monitor ZX100&quot;, 225.25
inv.InvoiceLines.Create 14, &quot;101-key Keyboard&quot;, 19.99
</pre>
</td></tr>
</table></p>

<p>A key difference between the <I>Add</I> and the <I>Create</I> methods is that the latter also returns the object just added to the collection, which is never strictly necessary with <I>Add</I> (because you already have a reference to it). This greatly simplifies how you write your client code. For example, say that the CInvoiceLine object supports two new properties, <I>Color</I> and <I>Notes</I>. Both are optional, and as such they shouldn't be included among the required arguments of the <I>Create</I> method. But you can still set them using a concise and efficient syntax, as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>With inv.InvoiceLines.Create(14, &quot;101-key Keyboard&quot;, 19.99)
    .Color = &quot;Blue&quot;
    .Notes = &quot;Special layout&quot;
End With
</pre>
</td></tr>
</table></p>

<p>Depending on the nature of the specific problem, you can build your collection classes with both the <I>Add</I> and <I>Create</I> methods, or you can just use one of the two. It's important, however, that if you leave the <I>Add</I> method in the collection, you add some form of validation to it. In most cases&#8212;but not always&#8212;you just need to let the class validate itself, as in this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub Add(newItem As CinvoiceLine)
    newItem.Init newItem.Qty, newItem.Product, newItem.UnitPrice
    ' Add to the collection only if no error was raised.
    m_InvoiceLines.Add newItem, Key
End Sub
</pre>
</td></tr>
</table></p>

<p>If you have encapsulated an inner class into its parent collection class in such a robust way, it's impossible for any developer to accidentally or intentionally add an incoherent object to the system. The worst that they can do is create a disconnected CInvoiceLine object, but they won't be able to add it to your self-protected CInvoice object.</p>

<A NAME="322"><h2>Full-Fledged Hierarchies</h2></A>
<p>Once you know how to create efficient collection classes, there isn't much to stop you from building complex and incredibly powerful object hierarchies, such as those exposed by well-known models Microsoft Word, Microsoft Excel, DAO, RDO, ADO, and so on. You already have all the pieces in the right places and only need to take care of details. Let me show you a few recurring problems when building hierarchies and how you can fix them.</p>

<A NAME="323"><h3>Class static data</h3></A>
<p>When you build a complex hierarchy, you're often faced with the following problem: How can all the objects of a given class share a common variable? For example, it would be great if the CInvoice class were able to correctly set its <I>Number</I> property in its <I>Class_Initialize</I> event so that from that point on <I>Number</I> could be exposed as a read-only property. This would improve the formal correctness of the class because it would guarantee that there aren't two invoices with the same number. This problem would be quickly solved if it were possible to define <I>class static variables</I> in the class module, that is, variables that are shared among all the instances of the class itself. But this is beyond the current capabilities of the VBA language.</p>

<p>The easy and obvious solution to this problem is to use a global variable in a BAS module, but that would break the class's encapsulation because anyone could modify this variable. Any other similar approach&#8212;such as storing the value in a file, in a database, in the Registry, and so on&#8212;is subject to the same problem. Fortunately, the solution is really simple: Use a parent collection class to gather all the instances of the class that share the common value. Not only do you solve the specific problem, you can also provide a more robust constructor for the base class itself. In the CInvoice sample program, you can create a CInvoices collection class:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The CInvoices Collection class
Private m_LastInvoiceNumber As Long
Private m_Invoices As New Collection

' The number used for the last invoice (read-only)
Public Property Get LastInvoiceNumber() As Long
    LastInvoiceNumber = m_LastInvoiceNumber
End Property

' Create a new CInvoice item, and add it to the private collection.
Function Create(InvDate As Date, Customer As CCustomer) As CInvoice
    Dim newItem As New CInvoice
    ' Don't increment the internal variable yet!
    newItem.Init m_LastInvoiceNumber + 1, InvDate, Customer
    ' Add to the internal collection, using the number as a key.
    m_Invoices.Add newItem, CStr(newItem.Number)
    ' Increment the internal variable now, if no error occurred.
    m_LastInvoiceNumber = m_LastInvoiceNumber + 1
    ' Return the new item to the caller.
    Set Create = newItem
End Function
' Other procedures in the CInvoices collection class ... (omitted)
</pre>
</td></tr>
</table></p>

<p>Similarly, you can create a CCustomers collection class (not shown here) that creates and manages all the CCustomer objects in the application. Now your client code can create both CInvoice and CCustomer objects in a safe way:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' These variables are shared in the application.
Dim Invoices As New CInvoices
Dim Customers As New CCustomers

Dim inv As CInvoice, cust As CCustomer
' First create a customer.
Set cust = Customers.Create(&quot;Tech Eleven, Inc&quot;)
cust.Address.Init &quot;234 East Road&quot;, &quot;Chicago&quot;, &quot;IL&quot;, &quot;12345&quot;
' Now create the invoice.
Set inv = Invoices.Create(&quot;12 Sept 1998&quot;, cust)
</pre>
</td></tr>
</table></p>

<p>At this point, you can complete your artwork by creating a top-level class named CCompany, which exposes all the collections as properties:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The CCompany class (the company that sends the invoices)
Public Name As String 
Public Address As CAddress
Public Customers As New CCustomers
Public Invoices As New CInvoices
' The next two collections are not implemented on the companion CD.
Public Orders As New COrders           
Public Products As New CProducts       
</pre>
</td></tr>
</table></p>

<p>You enjoy many advantages when you encapsulate classes in this way, a few of which aren't immediately apparent. Just to give you an idea of the potential of this approach, let's say that your boss asks you to add support for multiple companies. It won't be a walk in the park, but you can do it relatively effortlessly by creating a new CCompanies collection class. Since the CCompany object is well isolated from its surroundings, you can reuse entire modules without the risk of unexpected side effects.</p>

<A NAME="324"><h3>Backpointers</h3></A>
<p>When you deal with hierarchies, a dependent object frequently needs access to its parent; for example, to query one of its properties or to invoke its methods. The natural way to do that is to add a <I>backpointer</I> to the inner class. A backpointer is an explicit object reference to its parent object. This can be a Public property or a Private variable.</p>

<p>Let's see how this fits in our sample invoicing application. Say that when an invoice prints itself it should add a warning to the customer if there are any other invoices that must be paid and tell the customer the total sum due. To do this, the CInvoice class must scan its parent CInvoices collection and so needs a pointer to it. By convention, this backpointer is named <I>Parent </I>or <I>Collection</I>, but feel free to use whatever name you prefer. If you want to make this pointer Public, it's essential that it be a read-only property, at least from the outside of the project. (Otherwise, anyone could detach an invoice from the CInvoices collection.) You can achieve this by making the pointer's <I>Property Set</I> procedure with a Friend scope:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the CInvoice class
Public Paid As Boolean
Private m_Collection As CInvoices         ' The actual backpointer

Public Property Get Collection() As CInvoices
    Set Collection = m_Collection
End Property
Friend Property Set Collection(newValue As CInvoices)
    Set m_Collection = newValue
End Property
</pre>
</td></tr>
</table></p>

<p>The parent CInvoices collection class is now responsible for correctly setting up this backpointer, which it does in the <I>Create </I>constructor method:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Inside the CInvoices' Create method (rest of the code omitted)
newItem.Init m_LastInvoiceNumber + 1, InvDate, Customer
<B>Set newItem.Collection = Me</B>
</pre>
</td></tr>
</table></p>

<p>Now the CInvoice class knows how to encourage recalcitrant customers to pay their bills, as you can see in Figure 7-9 and in the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Sub PrintNotes(obj As Object)
    ' Print a note if customer has other unpaid invoices. 
    Dim inv As CInvoice, Found As Long, Total As Currency
    For Each inv In Collection
        If inv Is Me Then
            ' Don't consider the current invoice!
        ElseIf (inv.Customer Is Customer) And inv.Paid = False
		Then
            Found = Found + 1
            Total = Total + inv.GrandTotal
        End If
    Next
    If Found Then
        obj.Print &quot;WARNING: Other &quot; &amp; Found &amp; _
            &quot; invoices still waiting to be paid ($&quot; &amp; Total &amp; &quot;)&quot;
    End If
End Sub
</pre>
</td></tr>
</table></p>

<p>
<A HREF="javascript:fullSize('F07ph09x.htm')"> <img src="images/F07ph09.JPG" width=404 height=386 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 7-9.</B> <i>Don't let the rudimentary user interface fool you: There are as many as eight classes working together to supply you with a skeleton for a robust invoicing application.</i><!--/caption-->
</p>

<A NAME="325"><h3>Circular references</h3></A>
<p>No description of object hierarchies would be complete without an acknowledgment of the circular reference problem. In short, you have a <I>circular reference</I> when two objects point to each other, either directly or indirectly (that is, through intermediate objects). The invoicing hierarchy didn't include a circular reference until you added the <I>Collection </I>backpointer to the CInvoice class. What makes circular references a problem is that the two involved objects will keep each other alive indefinitely. This isn't a surprise; it's just the same old rule that governs the lives of objects.</p>

<p>In this case, unless we take appropriate steps, the reference counter of the two objects will never decrease to 0, even if the main application has released all its references to them. This means that you have to forego a portion of memory until the application comes to an end and wait for Visual Basic to return all its memory to Windows. It isn't just a matter of wasted memory: In many sophisticated hierarchies, the robustness of the entire system often depends on the code inside the <I>Class_Terminate</I> event (for example, to store properties back in the database). When the application ends, Visual Basic correctly calls the <I>Class_Terminate</I> event in all objects that are still alive, but that might happen after the main application has already closed its own files. The likely result is a corrupted database.</p>

<p>Now that I have warned you about all the possible nasty consequences of circular references, let me scare you even more: Visual Basic doesn't offer any definitive solution to this problem. You have only two half-solutions, both of which are largely unsatisfactory: You avoid circular references in the first place, and you manually undo all circular references before your application destroys the object reference.</p>

<p>In the invoicing example, you can avoid backpointers if you let the inner CInvoice class access its parent collection using a global variable. But you know that this is forbidden behavior that would break class encapsulation and would compromise the application's robustness. The second solution&#8212;manually undoing all circular references&#8212;is often too difficult when dealing with complex hierarchies. Above all, it would force you to add tons of error-handling code, just to be sure that no object variable is automatically set to Nothing by Visual Basic before you have the opportunity to resolve all the existing circular references.</p>

<p>The only good news I can tell you is that this problem can be solved, but it requires some really advanced, low-level programming techniques based on the concept of <I>weak object pointers</I>. This technique is well beyond the scope of this book, and for this reason I won't show any code here. However, the bravest of you might have a look at the CInvoice class on the companion CD. I have bracketed these special advanced sections using <I>#If</I> directives, so you can easily see what happens using regular and weak object pointers. You probably need to review how objects are stored in memory and what an object variable really is (see <a href="ch06a.htm">Chapter 6</a>), but the comments in the code should help you understand what the code actually does. Be sure to study this technique before using it in your own applications because when you play with objects at this low level, any mistake causes a GPF.</p>

<A NAME="326"><h2>The Class Builder Add-In</h2></A>
<p>Visual Basic 6 comes with a revamped version of the Class Builder Add-In. This is a major utility that lets you design the structure of a class hierarchy, create new classes and collection classes, and define their interfaces down to the attributes of each property, method, or event. (See Figure 7-10.) The new version adds support for enumerated properties and optional arguments of any data type, as well as a few minor enhancements.</p>

<p>The Class Builder Add-In is installed by the Visual Basic 6 setup routine, so you just have to open the Add-In Manager dialog box and double-click on the VB6 Class Builder Utility. When you close the window, a new item in the Add-In menu lets you invoke the utility.</p>

<p>
<A HREF="javascript:fullSize('F07ph10x.htm')"> <img src="images/F07ph10.JPG" width=404 height=282 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 7-10.</B> <i>The Class Builder Add-In. A child class (CPoint, in this case) always corresponds to a property in its parent class (CLine).</i><!--/caption-->
</p>

<p>Using the Class Builder Add-In is very simple, and I won't show in detail how you create new classes and their properties and methods. Its user interface is so clear that you won't have any problem using it. Instead, I focus on a few key points that can help you get the most from this utility.</p>

<UL>
<p><li>You should use the Class Builder Add-In from the very start of your design process. This is important, because even if the add-in is able to recognize all the classes in the current project, it can establish the relationships among them only if you created them from within the add-in.</li></p>

<p><li>You can create top-level classes or dependent classes, depending on which item in the leftmost pane is highlighted when you invoke the New command from the File menu. If you create a child class, the Add-In automatically inserts in the parent a property that points to the new class. You can move a class around in the hierarchy by using drag-and-drop in the leftmost pane.</li></p>

<p><li>While the Class Builder doesn't support inheritance, you can create a class that's based on another existing class. In this case, the Class Builder copies all the necessary code from the existing class into the new class module.</li></p>

<p><li>The Class Builder utility is particularly useful for building collection classes: You simply point to the class that's to be contained in the collection, and the Add-In correctly creates the collection class with a suitable <I>Add</I> method, an <I>Item</I> default method, support for enumeration, and so on.</li></p>

<p><li>Finally, you have some degree of control over how child objects are created inside parent classes. You can have them instantiated in the parent <I>Initialize</I> event (which slows down the parent's creation but makes access more efficient), or you can have child objects created in the <I>Property Get</I> procedure of the parent if necessary (which speeds up the parent's creation but adds overhead to each access).</li></p>
</UL>
 
<p>A drawback of the Class Builder is that you have no control over the code it generates. For example, it uses particular naming conventions for arguments and variables and adds a lot of pretty useless remarks, which you'll probably want to delete as soon as you can. Another issue is that once you begin to use it in a project, you're virtually forced to invoke it any time you want to add a new class&#8212;otherwise, it won't be able to correctly place the new class in the hierarchy. Even with these limitations, you'll find that creating hierarchies with the Class Builder Add-In is so simple that you can easily get carried away.</p>

<p>This chapter concludes our journey in object-oriented land. If you care about well-designed software and code reuse, you'll surely agree with me that OOP is a fascinating technology. When working with Visual Basic, however, a firm understanding of how classes and objects work is necessary to tackle many other technologies, including database, client/server, COM, and Internet programming. I'll frequently use, in the remaining sections of this book, all the concepts you've encountered in this chapter.</p>
</BODY>
</HTML>





