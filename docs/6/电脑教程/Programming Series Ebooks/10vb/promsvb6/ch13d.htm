<HTML>
<HEAD>
<TITLE>The Field Object</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch13c.htm", "ch13e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="589"><h1>The Field Object</h1></A>
<p>The Recordset object exposes the Fields collection, which in turn contains one or more Field objects. Each Field object represents one column in the data source and exposes 12 properties and 2 methods.</p>

<A NAME="590"><h2>Properties</h2></A>
<p>The properties of a Field object can be divided into two distinct groups: properties that describe the attributes and the characteristics of the field (and that are available also when the Recordset is closed) and properties that describe the contents of a field in the current record. (These properties are available only when the Recordset is open and the current record isn't invalid.)</p>

<A NAME="591"><h3>Describing the field's characteristics</h3></A>
<p>All the properties that describe the Field object's characteristics (which are also known as <I>metadata </I>properties) are read/write if you're adding the Field object to a stand-alone Recordset and read-only after the Recordset has been opened.</p>

<p>The <I>Name </I>property is the name of the database column the Field object takes data from and writes data to. Because this property is also the key associated with the Field object in the Fields collection, you can refer to a particular field in one of three ways, using the following syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Full syntax
rs.Fields(&quot;LastName&quot;).Value = &quot;Smith&quot;
' Fields is the Recordset's default property.
rs(&quot;LastName&quot;).Value = &quot;Smith&quot;  
' Value is the Field's default property.
rs(&quot;LastName&quot;) = &quot;Smith&quot;
</pre>
</td></tr></table></p>

<p>You usually enumerate the fields in a Recordset using a <I>For&#8230;Next </I>or <I>For Each&#8230;Next </I>loop:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>For i = 0 To rs.Fields.Count _ 1
    lstFieldNames.AddItem rs.Fields(i).Name
Next
</pre>
</td></tr></table></p>

<p>The <I>Type </I>property returns an enumerated constant that defines which kind of values can be stored in the field. All the types that ADO supports are listed in Table 13-5, but you should be aware that not all OLE DB providers and database engines support all these data types. The <I>Type</I> property also indirectly affects <I>NumericScale</I>, <I>Precision</I>, and <I>DefinedSize</I>.</p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>
A few constants in Table 13-5 apply only to Parameter objects (which are described later in this chapter)&#8212;at least, this is what the Visual Basic documentation states. I found, however, that some of these values are also used for Field objects. For example, the <I>Type </I>property of a string field in an MDB database returns the value adVarChar.
</blockquote></div></p>

<p><B>Table 13-5.</B> <i>The constants used for the Type property of the Field, Parameter, and Property objects.</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Constant</i></th>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">adEmpty</td>
<td valign="top">0</td>
<td valign="top">No value specified</td>
</tr>
<tr>
<td valign="top">adSmallInt</td>
<td valign="top">2</td>
<td valign="top">2-byte signed integer</td>
</tr>
<tr>
<td valign="top">adInteger</td>
<td valign="top">3</td>
<td valign="top">4-byte signed integer</td>
</tr>
<tr>
<td valign="top">adSingle</td>
<td valign="top">4</td>
<td valign="top">Single-precision floating point value</td>
</tr>
<tr>
<td valign="top">adDouble</td>
<td valign="top">5</td>
<td valign="top">Double-precision floating point value</td>
</tr>
<tr>
<td valign="top">adCurrency</td>
<td valign="top">6</td>
<td valign="top">Currency value</td>
</tr>
<tr>
<td valign="top">adDate</td>
<td valign="top">7</td>
<td valign="top">Date value (stored in a Double value, in the same format as Visual Basic's Date variables)</td>
</tr>
<tr>
<td valign="top">adBSTR</td>
<td valign="top">8</td>
<td valign="top">Null-terminated Unicode string</td>
</tr>
<tr>
<td valign="top">adIDispatch</td>
<td valign="top">9</td>
<td valign="top">Pointer to an <I>IDispatch</I> interface of an OLE object</td>
</tr>
<tr>
<td valign="top">adError</td>
<td valign="top">10</td>
<td valign="top">32-bit error code</td>
</tr>
<tr>
<td valign="top">adBoolean</td>
<td valign="top">11</td>
<td valign="top">Boolean value</td>
</tr>
<tr>
<td valign="top">adVariant</td>
<td valign="top">12</td>
<td valign="top">Variant value</td>
</tr>
<tr>
<td valign="top">adIUnknown</td>
<td valign="top">13</td>
<td valign="top">Pointer to an <I>IUnknown</I> interface of an OLE object</td>
</tr>
<tr>
<td valign="top">adDecimal</td>
<td valign="top">14</td>
<td valign="top">Numeric value with fixed precision and scale</td>
</tr>
<tr>
<td valign="top">adTinyInt</td>
<td valign="top">16</td>
<td valign="top">1-byte signed integer</td>
</tr>
<tr>
<td valign="top">adUnsignedTinyInt</td>
<td valign="top">17</td>
<td valign="top">1-byte unsigned integer</td>
</tr>
<tr>
<td valign="top">adUnsignedSmallInt</td>
<td valign="top">18</td>
<td valign="top">2-byte unsigned integer</td>
</tr>
<tr>
<td valign="top">adUnsignedInt</td>
<td valign="top">19</td>
<td valign="top">4-byte unsigned integer</td>
</tr>
<tr>
<td valign="top">adBigInt</td>
<td valign="top">20</td>
<td valign="top">8-byte signed integer</td>
</tr>
<tr>
<td valign="top">adUnsignedBigInt</td>
<td valign="top">21</td>
<td valign="top">8-byte unsigned integer</td>
</tr>
<tr>
<td valign="top">adGUID</td>
<td valign="top">72</td>
<td valign="top">Globally Unique Identifier (GUID)</td>
</tr>
<tr>
<td valign="top">adBinary</td>
<td valign="top">128</td>
<td valign="top">Binary value</td>
</tr>
<tr>
<td valign="top">adChar</td>
<td valign="top">129</td>
<td valign="top">String value</td>
</tr>
<tr>
<td valign="top">adWChar</td>
<td valign="top">130</td>
<td valign="top">Null-terminated Unicode character string</td>
</tr>
<tr>
<td valign="top">adNumeric</td>
<td valign="top">131</td>
<td valign="top">Exact numeric value with fixed precision and scale</td>
</tr>
<tr>
<td valign="top">adUserDefined</td>
<td valign="top">132</td>
<td valign="top">User-defined variable</td>
</tr>
<tr>
<td valign="top">adDBDate</td>
<td valign="top">133</td>
<td valign="top">Date value in format &quot;yyyymmdd&quot;</td>
</tr>
<tr>
<td valign="top">adDBTime</td>
<td valign="top">134</td>
<td valign="top">Time value in format &quot;hhmmss&quot;</td>
</tr>
<tr>
<td valign="top">adDBTimeStamp</td>
<td valign="top">135</td>
<td valign="top">Date and time stamp in format &quot;yyyymmddhhmmss&quot; plus a fraction in billionths</td>
</tr>
<tr>
<td valign="top">adChapter</td>
<td valign="top">136</td>
<td valign="top">Chapter (a dependent Recordset in a hierarchical Recordset)</td>
</tr>
<tr>
<td valign="top">adVarNumeric</td>
<td valign="top">139</td>
<td valign="top">Variable-length exact numeric value with fixed precision and scale</td>
</tr>
<tr>
<td valign="top">adVarChar</td>
<td valign="top">200</td>
<td valign="top">String value (Parameter object only)</td>
</tr>
<tr>
<td valign="top">adLongVarChar</td>
<td valign="top">201</td>
<td valign="top">Long variable-length character string (Parameter object only)</td>
</tr>
<tr>
<td valign="top">adVarWChar</td>
<td valign="top">202</td>
<td valign="top">Null-terminated Unicode character string (Parameter object only)</td>
</tr>
<tr>
<td valign="top">adLongVarWChar</td>
<td valign="top">203</td>
<td valign="top">Long variable-length Unicode character string (Parameter object only)</td>
</tr>
<tr>
<td valign="top">adVarBinary</td>
<td valign="top">204</td>
<td valign="top">Binary value (Parameter object only)</td>
</tr>
<tr>
<td valign="top">adLongVarBinary</td>
<td valign="top">205</td>
<td valign="top">Long variable-length binary data (Parameter object only)</td>
</tr>
</table></p>

<p>The <I>DefinedSize </I>property returns the maximum capacity that was defined when the field was created. The <I>NumericScale </I>property indicates the scale of numeric values (in other words, the number of digits to the right of the decimal point that will be used to represent the value). The <I>Precision </I>property is the degree of precision for numeric values in a numeric Field object (that is, the maximum total number of digits used to represent the value). The <I>Attributes </I>property is a bit-field value that returns information about the field. It can contain one or more of the constants listed in Table 13-6.</p>

<p><B>Table 13-6.</B> <i>Constants used for the Attributes 
property of the Field object.</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Constant</i></th>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">adFldMayDefer</td>
<td valign="top">2</td>
<td valign="top">A deferred field&#8212;that is, a field whose value is retrieved only when the field is explicitly referenced in the code. BLOB and CLOB fields are often fields of this type.</td>
</tr>
<tr>
<td valign="top">adFldUpdatable</td>
<td valign="top">4</td>
<td valign="top">The field is updatable.</td>
</tr>
<tr>
<td valign="top">adFldUnknownUpdatable</td>
<td valign="top">8</td>
<td valign="top">The provider can't determine whether the field is writable.</td>
</tr>
<tr>
<td valign="top">adFldFixed</td>
<td valign="top">&amp;H10</td>
<td valign="top">The field contains fixed-length data.</td>
</tr>
<tr>
<td valign="top">adFldIsNullable</td>
<td valign="top">&amp;H20</td>
<td valign="top">The field accepts Null values.</td>
</tr>
<tr>
<td valign="top">adFldMayBeNull</td>
<td valign="top">&amp;H40</td>
<td valign="top">The field can contain Null values (but doesn't necessarily accept them).</td>
</tr>
<tr>
<td valign="top">adFldLong</td>
<td valign="top">&amp;H80</td>
<td valign="top">The field is a long binary field (for example, a BLOB or a CLOB), and you can use the <I>AppendChunk </I>and <I>GetChunk </I>methods on it.</td>
</tr>
<tr>
<td valign="top">adFldRowID</td>
<td valign="top">&amp;H100</td>
<td valign="top">The field contains a record identifier that can't be written to and that has no meaningful value except for identifying the row (for example, a record number or a unique identifier).</td>
</tr>
<tr>
<td valign="top">adFldRowVersion</td>
<td valign="top">&amp;H200</td>
<td valign="top">The field contains some kind of date stamp or time stamp that is used to track record updates.</td>
</tr>
<tr>
<td valign="top">adFldCacheDeferred</td>
<td valign="top">&amp;H1000</td>
<td valign="top">The field is cached the first time it is read from the database, and all subsequent reads fetch the data from the cache.</td>
</tr>
<tr>
<td valign="top">adFldKeyColumn</td>
<td valign="top">&amp;H8000</td>
<td valign="top">The field is part of the key.</td>
</tr>
</table></p>

<A NAME="592"><h3>Describing the field's value</h3></A>
<p>The <I>Value </I>property sets or returns the contents of the field. It is also the default property of the Field object, so you can omit it if you want to:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>rs.Fields(&quot;BirthDate&quot;) = #4/12/1955#
</pre>
</td></tr></table></p>

<p>The <I>ActualSize</I> property is a read-only property that returns the number of bytes taken by the current value in the field. Don't confuse this property with the <I>DefinedSize </I>property, which returns the declared maximum length of the field. This property is especially useful with BLOB and CLOB fields. If the provider can't determine the size of the field, it returns that value -1. (The Visual Basic documentation states that in this case this property returns the constant adUnknown; however, this constant doesn't appear in the ADODB type library.)</p>

<p>The <I>OriginalValue</I> property returns the value that was in the field before any changes were made. If you're in immediate update mode, this is the value that the <I>CancelUpdate </I>method uses to restore the field's contents; if you're in batch update mode, this is the value that was valid after the last <I>UpdateBatch </I>method and is also the value that the <I>CancelBatch </I>method uses to restore the field's contents.</p>

<p>The <I>UnderlyingValue </I>property is the value that is currently stored in the database. This value might be different from the <I>OriginalValue </I>property if another user has updated the field since you last read it. A <I>Resync </I>method would assign this value to the <I>Value </I>property. You typically use this property together with the <I>OriginalValue </I>property to resolve conflicts arising from batch updates.</p>

<p>You can assign the <I>DataFormat </I>property a StdDataFormat object so that you can control how values coming from the data source are formatted in the field. For more information on this property, see the section, &quot;<a href="ch08d.htm#346">The <I>DataFormat</I> Property</a>&quot; in Chapter 8.</p>

<A NAME="593"><h2>Methods</h2></A>
<p>The Field object supports only two methods, both of which are used only with large binary fields such as BLOB or CLOB fields. (These are the fields whose <I>Attributes </I>property has the adFldLong<I> </I>bit set.) Because these fields can be several kilobytes&#8212;or even hundreds of kilobytes&#8212;long, writing to them and reading them back in smaller chunks is often more practical.</p>

<p>The <I>AppendChunk </I>method writes a chunk of data to a Field and expects a Variant argument that contains the data to be written. Usually, you write the contents of a file in chunks of 8 KB or 16 KB, and in most cases, you want to store a large amount of data that you have in a file, such as a long document or a bitmap. Here's a reusable routine that moves the contents of a file into a field that supports the <I>AppendChunk </I>method:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub FileToBlob(fld As ADODB.Field, FileName As String, _
    Optional ChunkSize As Long = 8192)
    Dim fnum As Integer, bytesLeft As Long, bytes As Long
    Dim tmp() As Byte
    ' Raise an error if the field doesn't support GetChunk.
    If (fld.Attributes And adFldLong) = 0 Then
        Err.Raise 1001, , &quot;Field doesn't support the GetChunk method.&quot;
    End If
    ' Open the file; raise an error if the file doesn't exist.
    If Dir$(FileName) = &quot; &quot; Then Err.Raise 53, ,#&quot;File not found&quot;
    fnum = FreeFile
    Open FileName For Binary As fnum
    ' Read the file in chunks, and append data to the field.
    bytesLeft = LOF(fnum)
    Do While bytesLeft
        bytes = bytesLeft
        If bytes &gt; ChunkSize Then bytes = ChunkSize
        ReDim tmp(1 To bytes) As Byte
        Get #1, , tmp
        fld.AppendChunk tmp
        bytesLeft = bytesLeft - bytes
    Loop
    Close #fnum
End Sub
</pre>
</td></tr></table></p>

<p>The first time you call this method for a given field, it overwrites the current contents of the field; each subsequent call to this method simply appends data to the current value of the field. If you read or write another field in the record and then go back and restart appending data with the <I>AppendChunk </I>method, ADO assumes that you're appending a brand new value and overwrites the field's contents. ADO also overwrites the contents of the field when you start to work with another field in a Recordset clone, but not when you work with a field in another Recordset that isn't a clone of the current one.</p>

<p>You can use the <I>GetChunk </I>method to read back the data stored in a Field that contains a long binary value. This method takes one argument: the number of bytes that must be read from the Field object. The problem with this method is that if you read too many bytes, ADO will pad the returned string with spaces. Such spaces are usually something you don't want to retrieve, especially when you're working with images or other binary data. For this reason, you should test the <I>ActualSize </I>property to ensure that you don't read more bytes than necessary. I've prepared a reusable routine that does this testing for you automatically:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Sub BlobToFile(fld As ADODB.Field, FileName As String, _
    Optional ChunkSize As Long = 8192)
    Dim fnum As Integer, bytesLeft As Long, bytes As Long
    Dim tmp() As Byte
    ' Raise an error if the field doesn't support GetChunk.
    If (fld.Attributes And adFldLong) = 0 Then
        Err.Raise 1001, , &quot;Field doesn't support the GetChunk method.&quot;
    End If
' Delete the file if it exists already, and then open a new one for writing.
    If Dir$(FileName) &lt;&gt; &quot;&quot; Then Kill FileName
    fnum = FreeFile
    Open FileName For Binary As fnum
    ' Read the field's contents, and write the data to the file 
    ' chunk by chunk.
    bytesLeft = fld.ActualSize
    Do While bytesLeft
        bytes = bytesLeft
        If bytes &gt; ChunkSize Then bytes = ChunkSize
        tmp = fld.GetChunk(bytes)
        Put #fnum, , tmp
        bytesLeft = bytesLeft - bytes
    Loop
    Close #fnum
End Sub
</pre>
</td></tr></table></p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
The <I>FileToBlob</I> and <I>BlobtoFile</I> routines are included in the library of functions in the companion CD, as are most of the other routines int hsi chapter and <a href="ch14a.htm">Chapter 14</a>.
</blockquote></div></p>

<p>Multiple <I>GetChunks </I>methods continue to retrieve data starting from where the previous <I>GetChunk </I>method left off. But if you read or write the value of another field in the same Recordset (or in a clone of the Recordset), the next time you execute a <I>GetChunk</I> method on the original field ADO will restart from the beginning of the field. Also, remember that BLOB fields should be the last fields in SELECT queries against SQL Server data sources.</p>

<A NAME="594"><h2>The Fields Collection</h2></A>
<p>You can use the Fields collection in two distinct ways. The simplest and most intuitive way is by iterating on its items to retrieve information about the fields of a Recordset&#8212;for example, when you want to create a list of field names and values:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Error trapping accounts for values, such as BLOB fields, that
' can't be converted to strings.
On Error Resume Next      
For i = 0 To rs.Fields.Count - 1
    lstFields.AddItem rs.Fields(i).Name &amp; &quot; = &quot; &amp; rs.Fields(i).Value
Next
</pre>
</td></tr></table></p>

<p>The Fields collection also supports the <I>Append </I>method, which creates a new Field object and appends it to the collection. This method is useful when you want to manufacture a Recordset object in memory without necessarily connecting it to a data source (not immediately at least). You can use this method only with client-side Recordsets (<I>CursorLocation </I>= adUseClient) and only if the Recordset is closed and isn't currently associated with a Connection (<I>ActiveConnection </I>= Nothing). The <I>Append </I>method has the following syntax:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Append(Name, Type, [DefinedSize], [Attrib]) As Field
</pre>
</td></tr></table></p>

<p>The arguments define the properties of the Field object being created. The following reusable routine creates a new stand-alone Recordset that has the same field structure of another Recordset:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function CopyFields(rs As ADODB.Recordset) As ADODB.Recordset
    Dim newRS As New ADODB.Recordset, fld As ADODB.Field
    For Each fld In rs.Fields
        newRS.Fields.Append fld.Name, fld.Type, fld.DefinedSize, _
            fld.Attributes
    Next
    Set CopyFields = newRS
End Function
</pre>
</td></tr></table></p>

<p>Here's another routine that creates a new stand-alone record that not only duplicates the field structure of an existing Recordset but also duplicates all the records that it contains (but without being a clone Recordset):</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function CopyRecordset(rs As ADODB.Recordset) As ADODB.Recordset
    Dim newRS As New ADODB.Recordset, fld As ADODB.Field
    Set newRS = CopyFields(rs)
    newRS.Open     ' You must open the Recordset before adding new records.
    rs.MoveFirst
    Do Until rs.EOF
        newRS.AddNew                        ' Add a new record.
        For Each fld In rs.Fields           ' Copy all fields' values.
            newRS(fld.Name) = fld.Value     ' Assumes no BLOB fields
        Next
        rs.MoveNext
    Loop 
    Set CopyRecordset = newRS
End Function
</pre>
</td></tr></table></p>

<p>The Fields collection also supports the <I>Delete </I>method, which removes a field in a stand-alone record before opening it, and the <I>Refresh </I>method.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>
Alas, it seems that you can't create hierarchical stand-alone Recordsets. In fact, if you try to create a Field whose <I>Type</I> property is adChapter, an error arises.
</blockquote></div></p>

</BODY>
</HTML>





