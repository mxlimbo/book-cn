<HTML>
<HEAD>
<TITLE>Common Properties </TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch02a.htm", "ch02c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="23"><h1>Common Properties </h1></A>

<p>At first glance, it might seem that Visual Basic 6 supports countless properties 
for various objects. Fortunately, there's a set of properties many objects of different 
classes share. In this section, we'll examine these common properties.</p>

<A NAME="24"><H2>The <I>Left</I>, <I>Top</I>, <I>Width</I>, and <I>Height</I> Properties</H2></A>
<p>All visible objects&#8212;forms and controls&#8212;expose these properties, which affect 
the object's position and size. These values are always relative to the object's 
container&#8212;that is, the screen for a form and the parent form for a control. A control can also 
be contained in another control, which is said to be its 
<I>container: </I>In this case, <I>Top</I> and 
<I>Left</I> properties are relative to such a container control. By default, these 
properties are measured in <I>twips,</I> a unit that lets you create resolution-independent 
user interfaces, but you can switch to another unit, for example, pixels or inches, by 
setting the container's <I>ScaleMode</I> property. 
But you can't change the unit used for forms because they have no container: 
<I>Left</I>, <I>Top</I>, <I>Width</I>, and 
<I>Height</I> properties for forms are always measured in twips. For more information about the twip 
measurement unit, see the section &quot;<A HREF="ch02e.htm#66">The <I>ScaleMode</I> Property</A>&quot; later in this chapter.</p>

<p>While you can enter numeric values for these properties right in the 
Properties window at design time, you often set them in a visual manner by moving and 
resizing the control on its parent form. Keep in mind that Visual Basic also offers many 
interactive commands in the Format menu that let you resize, align, and space 
multiple controls in one operation. You can also access and modify these 
properties through code to move or resize objects at run time:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Double a form's width, and move it to the
' upper left corner of the screen.
Form1.Width = Form1.Width * 2
Form1.Left = 0 
Form1.Top = 0
</pre>
</td></tr>
</table></p>


<p>Note that while all controls&#8212;even invisible ones&#8212;expose these four 
properties at design time in the Properties window, controls that are inherently 
invisible&#8212;Timer controls, for example&#8212;don't support these properties at run time, and you 
can't therefore read or modify them through code.</p>

<p><div class="caution"><blockquote><b>CAUTION</b><hr>
Controls don't necessarily have to support all four properties in 
a uniform manner. For example, ComboBox controls' 
<I>Height</I> property can be read but not written to, both at design time and run time. As far as I know, this is 
the only example of a property that appears in the Properties window but can't 
be modified at design time. This happens because the height of a ComboBox 
control depends on the control's Font attributes. Remember this exception when 
writing code that modifies the <I>Height</I> property for all the controls in a form.
</blockquote></div></p>

<A NAME="25"><h2>The <I>ForeColor</I> and <I>BackColor</I> Properties</h2></A>

<p>Most visible objects expose <I>ForeColor</I> and 
<I>BackColor</I> properties, which affect the 
color of the text and the color of the background, respectively. The colors of a few 
controls&#8212;scroll bars, for example&#8212;are dictated by Microsoft Windows, however, and you 
won't find <I>ForeColor</I> and <I>BackColor</I> entries in the Properties window. In other cases, 
the effect of these properties depends on other properties: for example, setting 
the <I>BackColor</I> property of a Label control has no effect if you set the 
<I>BackStyle</I> property of that Label to 0-Transparent. CommandButton controls are peculiar in that 
they expose a <I>BackColor</I> property but not a 
<I>ForeColor</I> property, and the background 
color is active only if you also set the 
<I>Style</I> property to 1-Graphical. (Because the default 
value for the <I>Style</I> property is 0-Standard, it might take you a while until you 
understand why the <I>BackColor</I> property doesn't affect the background color in the usual manner.)</p>

<p>When you're setting one of these two properties in the Properties window, 
you can select either a standard Windows color or a custom color using the System tab 
in the first case and the Palette tab in the second, as you can see in Figure 2-1. My 
first suggestion is always use a standard color value unless you have a very good 
reason to use a custom color. System colors display well on any Windows machine, are 
likely to conform to your customers' tastes, and contribute to making your application 
look well integrated in the system. My second suggestion is if you want to use custom 
colors, develop a consistent color scheme and use it throughout your application. I 
also have a third suggestion: Never mix standard and custom colors on the same 
form, and don't use a standard color for the 
<I>ForeColor</I> property and a custom color for 
the <I>BackColor</I> property of the same control (or vice versa), because the user might 
change the system palette in a way that makes the control completely unreadable.</p>

<p>You can choose from several ways to assign a color in code. Visual Basic 
provides a set of symbolic constants that correspond to all the colors that appear in 
the System tab in the Properties window at design time:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Make Label1 appear in a selected state.
Label1.ForeColor = vbHighlightText
Label1.BackColor = vbHighlight
</pre>
</td></tr>
</table></p>


<p>All the symbolic constants are shown in Table 2-1, but you can also browse 
them in the Object Browser window, after clicking the SystemColorConstants item in 
the leftmost list box. (If you don't see it, first select &lt;All libraries&gt; or VBRUN in the 
top ComboBox control). Note that all the values of these constants are negative.</p>

<p>
<A HREF="javascript:fullSize('F02ph01x.htm')"> <img src="images/F02ph01.JPG" width=404 height=306 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 2-1.</B> <i>Two different ways to set the ForeColor and BackColor properties at design time.</i><!--/caption-->
</p>

<p><b>Table 2-1.</b> <i>Visual Basic constants for system colors.</i></p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Constant</i></th>
<th><i>Hex Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">vb3DDKShadow</td>
<td valign="top">&amp;H80000015</td>
<td valign="top">Darkest shadow</td>
</tr>
<tr>
<td valign="top">vb3Dface</td>
<td valign="top">&amp;H8000000F</td>
<td valign="top">Dark shadow color for 3-D display elements</td>
</tr>
<tr>
<td valign="top">vb3Dhighlight</td>
<td valign="top">&amp;H80000014</td>
<td valign="top">Highlight color for 3-D display elements</td>
</tr>
<tr>
<td valign="top">vb3Dlight</td>
<td valign="top">&amp;H80000016</td>
<td valign="top">Second lightest of the 3-D colors after vb3Dhighlight</td>
</tr>
<tr>
<td valign="top">vb3Dshadow</td>
<td valign="top">&amp;H80000010</td>
<td valign="top">Color of automatic window shadows</td>
</tr>
<tr>
<td valign="top">vbActiveBorder</td>
<td valign="top">&amp;H8000000A</td>
<td valign="top">Active window border color</td>
</tr>
<tr>
<td valign="top">vbActiveTitleBar</td>
<td valign="top">&amp;H80000002</td>
<td valign="top">Active window caption color</td>
</tr>
<tr>
<td valign="top">vbActiveTitleBarText</td>
<td valign="top">&amp;H80000009</td>
<td valign="top">Text color in active caption, size box, scroll bar arrow box</td>
</tr>
<tr>
<td valign="top">vbApplicationWorkspace</td>
<td valign="top">&amp;H8000000C</td>
<td valign="top">Background color of multiple-document interface (MDI) applications</td>
</tr>
<tr>
<td valign="top">vbButtonFace</td>
<td valign="top">&amp;H8000000F</td>
<td valign="top">Face shading on command buttons</td>
</tr>
<tr>
<td valign="top">vbButtonShadow</td>
<td valign="top">&amp;H80000010</td>
<td valign="top">Edge shading on command buttons</td>
</tr>
<tr>
<td valign="top">vbButtonText</td>
<td valign="top">&amp;H80000012</td>
<td valign="top">Text color on push buttons</td>
</tr>
<tr>
<td valign="top">vbDesktop</td>
<td valign="top">&amp;H80000001</td>
<td valign="top">Desktop color</td>
</tr>
<tr>
<td valign="top">vbGrayText</td>
<td valign="top">&amp;H80000011</td>
<td valign="top">Grayed (disabled) text</td>
</tr>
<tr>
<td valign="top">vbHighlight</td>
<td valign="top">&amp;H8000000D</td>
<td valign="top">Background color of items selected in a control</td>
</tr>
<tr>
<td valign="top">vbHighlightText</td>
<td valign="top">&amp;H8000000E</td>
<td valign="top">Text color of items selected in a control</td>
</tr>
<tr>
<td valign="top">vbInactiveBorder</td>
<td valign="top">&amp;H8000000B</td>
<td valign="top">Inactive window border color</td>
</tr>
<tr>
<td valign="top">vbInactiveCaptionText</td>
<td valign="top">&amp;H80000013</td>
<td valign="top">Color of text in an inactive caption</td>
</tr>
<tr>
<td valign="top">vbInactiveTitleBar</td>
<td valign="top">&amp;H80000003</td>
<td valign="top">Inactive window caption color</td>
</tr>
<tr>
<td valign="top">vbInactiveTitleBarText</td>
<td valign="top">&amp;H80000013</td>
<td valign="top">Text color in inactive window caption, size box, scroll bar arrow box</td>
</tr>
<tr>
<td valign="top">vbInfoBackground</td>
<td valign="top">&amp;H80000018</td>
<td valign="top">Background color of ToolTips</td>
</tr>
<tr>
<td valign="top">vbInfoText</td>
<td valign="top">&amp;H80000017</td>
<td valign="top">Color of text in ToolTips</td>
</tr>
<tr>
<td valign="top">vbMenuBar</td>
<td valign="top">&amp;H80000004</td>
<td valign="top">Menu background color</td>
</tr>
<tr>
<td valign="top">vbMenuText</td>
<td valign="top">&amp;H80000007</td>
<td valign="top">Text color in menus</td>
</tr>
<tr>
<td valign="top">vbScrollBars</td>
<td valign="top">&amp;H80000000</td>
<td valign="top">Scroll bar gray area color</td>
</tr>
<tr>
<td valign="top">vbTitleBarText</td>
<td valign="top">&amp;H80000009</td>
<td valign="top">Text color in active caption, size box, scroll bar arrow box</td>
</tr>
<tr>
<td valign="top">vbWindowBackground</td>
<td valign="top">&amp;H80000005</td>
<td valign="top">Window background color</td>
</tr>
<tr>
<td valign="top">vbWindowFrame</td>
<td valign="top">&amp;H80000006</td>
<td valign="top">Window frame color</td>
</tr>
<tr>
<td valign="top">vbWindowText</td>
<td valign="top">&amp;H80000008</td>
<td valign="top">Text color in windows</td>
</tr>
</table></p>

<p>When you're assigning a custom color, you can use one of the symbolic 
constants that Visual Basic defines for the most common colors 
(<I>vbBlack</I>, <I>vbBlue</I>, <I>vbCyan</I>, 
<I>vbGreen</I>, <I>vbMagenta</I>, <I>vbRed</I>, 
<I>vbWhite</I>, and <I>vbYellow</I>), or you can use a 
numeric decimal or hexadecimal constant:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' These statements are equivalent.
Text1.BackColor = vbCyan
Text1.BackColor = 16776960 
Text1.BackColor = &amp;HFFFF00
</pre>
</td></tr>
</table></p>


<p>You can also use an <I>RGB</I> function to build a color value composed of its 
red, green, and blue components. Finally, to ease the porting of existing 
QuickBasic applications, Visual Basic supports the 
<I>QBColor</I> function:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' These statements are equivalent to the ones above.
Text1.BackColor = RGB(0, 255, 255)    ' red, green, blue values
Text1.BackColor = QBColor(11)
</pre>
</td></tr>
</table></p>


<A NAME="26"><h2>The <I>Font</I> Property</h2></A>

<p>Forms and those controls that can display strings of characters expose the 
<I>Font</I> property. At design time, you set font attributes using a common dialog box, 
which you can see in Figure 2-2. Dealing with fonts at run time, however, is less simple 
because you must account for the fact that Font is a compound object, and you 
must assign its properties separately. Font objects expose the 
<I>Name</I>, <I>Size</I>, <I>Bold</I>, 
<I>Italic</I>, <I>Underline</I>, and 
<I>Strikethrough</I> properties.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Text1.Font.Name = &quot;Tahoma&quot;
Text1.Font.Size = 12
Text1.Font.Bold = True
Text1.Font.Underline = True
</pre>
</td></tr>
</table></p>


<p>
<img src="images/F02ph02.GIF" width=397 height=342 border=0>
<p>
<!--caption--><B>Figure 2-2.</B> <i>At design time the Font dialog box lets you modify all font attributes at once and preview the result.</i><!--/caption-->


<P><div class="TIP"><blockquote>
<B>TIP</B><HR>
You can use the 
<I>Set</I> command to assign whole Font objects to 
controls (thus avoiding having to set individual font attributes for each control), as 
you can see in the following code fragment:

<p><table><tr><td>
<PRE>
' Assign to Text2 the same font as used by Text1.
Set Text2.Font = Text1.Font
</PRE>
</td></tr></table></p>

<p>It should be made clear, however, that the preceding code actually assigns 
the <I>same </I>Font objects to both controls. This means that if you later change 
Text1's font attributes, the appearance of Text2 will also be affected. This behavior 
is perfectly consistent with the Font object's nature, even though the reasons for 
it will become clear only later in <a href="ch06a.htm">Chapter 6</a>. You can take advantage of this 
approach&#8212;for example, if all the controls in your form always use the same 
font&#8212;but you should absolutely avoid it when the controls in question are 
supposed to have independent font attributes.</p>
</blockquote></div></p>

<p>Visual Basic 6 still supports old-style Font properties such as 
<I>FontName</I>,<I> FontSize</I>,<I> 
FontBold</I>,<I> FontItalic</I>,<I> 
FontUnderline</I>, and <I>FontStrikethru</I>, but you can modify 
them only through code because they don't appear in the Properties window at design 
time. You can use the syntax that you like most because the two forms are perfectly 
interchangeable. In this book, however, I mostly follow the newer object-oriented syntax.</p>

<p>The <I>Font.Size</I> property (or the equivalent 
<I>FontSize</I> property) is peculiar because in general you can't be sure that Visual Basic is able to create a font of that 
particular size, especially if you aren't working with a TrueType font. The short code 
snippet below proves this.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Text1.Font.Name = &quot;Courier&quot;
Text1.Font.Size = 22
Print Text1.Font.Size  ' Prints 19.5
</pre>
</td></tr>
</table></p>


<p>Note that no error is raised if you specify a font size that isn't actually available.</p>

<p><div class="caution"><blockquote><b>CAUTION</b><hr>In general, Visual Basic doesn't raise errors when you try to 
assign invalid font names. In this case, the effect is somewhat unpredictable. For 
example, try the following code:

<p><table><tr><td>
<PRE>
' Warning: you may get different results on your system.
Print Font.Name       ' Displays &quot;Ms Sans Serif&quot;
Font.Name = &quot;xyz&quot;
Print Font.Name       ' Displays &quot;Arial&quot; 
</PRE>
</td></tr></table></p>

</blockquote></div></p>


<A NAME="27"><h2>The <I>Caption</I> and <I>Text</I> Properties</h2></A>

<p>The <I>Caption</I> property is a string of characters that appears inside a control (or in 
the title bar of a form) and that the user can't directly modify. Conversely, the 
<I>Text</I> property corresponds to the &quot;contents&quot; of a control and is usually editable by the end 
user. No intrinsic control exposes both a 
<I>Caption</I> and a <I>Text</I> property, so in practice a 
look at the Properties window can resolve your doubts as to what you're working 
with. Label, CommandButton, CheckBox, OptionButton, Data, and Frame controls 
expose the <I>Caption</I> property, whereas TextBox, ListBox, and ComboBox controls expose 
the <I>Text</I> property.</p>

<p>The <I>Caption</I> property is special in that it can include an ampersand (&amp;) 
character to associate a hot key with the control. The 
<I>Text</I> property, when present, is always the default property for the control, which means that it can be omitted in code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' These statements are equivalent.
Text2.Text = Text1.Text
Text2 = Text1
</pre>
</td></tr>
</table></P>


<p><div class="note"><blockquote><b>NOTE</b><hr>Specifying or omitting the name of the default property in code is 
mostly a matter of personal taste. I always try to specify the name of all the 
properties referenced in code because doing so tends to make the code more 
readable. However, if you have long lines of code, specifying all the default properties 
can sometimes make the code <I>less </I>readable and can force you to horizontally 
scroll through the code window. This consideration has been followed in this book: 
Most of the time, I specify the default property, but don't be surprised if 
I sometimes omit it, especially in longer listings.

<p>While we are on this topic, note that many programmers mistakenly 
believe that using default properties can make their code run faster. This is a 
leftover notion from Visual Basic 3 days, but it hasn't been true since Visual 
Basic 4 changed the internal implementation of controls.</p> 
</blockquote></div></p>

<p>In general, if a control exposes the 
<I>Text</I> property it also supports the 
<I>SelText</I>, <I>SelStart</I>, and 
<I>SelLength</I> properties, which return information about the portion of 
text that's currently selected in the control.</p>

<A NAME="28"><h2>The <I>Parent </I>and <I>Container</I> Properties</h2></A>

<p>The <I>Parent</I> property is a run time_only property (that is, you don't see it in 
the Properties window), which returns a reference to the form that hosts the control. 
The <I>Container</I> property is also a run time_only property, which returns a reference to 
the container of the control. These two properties are correlated, in that they 
return the same object&#8212;the parent form&#8212;when a control is placed directly on the form 
surface.</p>

<p>While you can't move a control from one form to another using the 
<I>Parent</I> property (which is read-only), you can move a control to another container by 
assigning a different value to its 
<I>Container</I> property (which is a read-write 
property). Because you're assigning objects and not plain values, you must use the 
<I>Set</I> keyword:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Move Text1 into the Picture1 container. 
Set Text1.Container = Picture1
' Move it back on the form's surface.
Set Text1.Container = Form1
</pre>
</td></tr>
</table></p>


<A NAME="29"><h2>The <I>Enabled</I> and <I>Visible</I> Properties</h2></A>

<p>By default, all controls and forms are both visible and enabled at run time. For 
a number of reasons, however, you might want to hide them or show them in a 
disabled state. For example, you might use a hidden DriveListBox control simply to 
enumerate all the drives in the system. In this case, you set the 
<I>Visible</I> property of the DriveListBox control to False in the Properties window at design time. More frequently, 
however, you change these properties at run time:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Enable or disable the Text1 control when
' the user clicks on the Check1 CheckBox control.
Private Sub Check1_Click()
    Text1.Enabled = (Check1.Value = vbChecked)
End Sub
</pre>
</td></tr>
</table></p>


<p>Disabled controls don't react to user's actions, but otherwise they're 
fully functional and can be manipulated through code. Invisible controls are 
automatically disabled, so you never need to set both these properties to False. All mouse 
events for disabled or invisible controls are passed to the underlying container or to 
the form itself.</p>

<p>If an object works as a container for other objects&#8212;for instance, a Form is 
a container for its controls and a Frame control can be a container for a group 
of OptionButton controls&#8212;setting its 
<I>Visible</I> or <I>Enabled</I> properties indirectly affects 
the state of its contained objects. This feature can often be exploited to reduce the 
amount of code you write to enable or disable a group of related controls.</p>

<p><div class="tip"><blockquote>
<b>TIP</b><hr>
Most controls change their appearance when they're disabled. 
Generally speaking, this is a useful practice because the user can understand at first 
glance which controls he or she can act on. If you have a good reason to disable a 
control but still display it in an active state, you can place the control inside a 
container (a Frame or a PictureBox, for example) and then set the container's 
<I>Enabled</I> property to False. Visual Basic will disable all contained controls, but they 
will continue to appear in an enabled state. This trick works better if you also set 
the container's <I>BorderStyl</I>e property to 0-None. 
</blockquote></div></p>

<p>Some programmers set the <I>Enabled</I> properties to False for TextBox or 
ComboBox controls that must work in a read-only mode. This is reminiscent of the way 
things worked under Visual Basic 3 and previous versions. But these controls now 
expose a <I>Locked</I> property that, if True, makes the controls completely functional, except 
that users can't modify their <I>Text</I> property. This means that users can scroll through 
their content but can't accidentally modify it.</p>

<A NAME="30"><h2>The <I>hWnd</I> Property</h2></A>

<p>The <I>hWnd </I>property doesn't appear in the Properties window because its value 
is available only at run time. Moreover, it's a read-only property, and therefore you 
can't assign a value to it. The <I>hWnd</I> property returns the 32-bit integer value that 
Windows uses internally to identify a control. This value is absolutely meaningless in 
standard Visual Basic programming and only becomes useful if you invoke Windows 
API routines (which I'll cover in <a href="chaaa.htm">Appendix A</a>). Even if you're not going to use this 
property in your code, it's good for you to know that not all controls support it and it's 
important to understand why.</p>

<p>Visual Basic controls&#8212;both intrinsic controls and external Microsoft 
ActiveX controls&#8212;can be grouped in two categories: 
<I>standard </I>controls and <I>windowless </I>(or 
<I>lightweight</I>) controls. To grasp the difference between the two groups, let's 
compare the PictureBox control (a standard control) and the Image control (a 
windowless control). Even though they appear similar at a first glance, behind the scenes 
they are completely different.</p>

<p>When you place a standard control on the form, Visual Basic asks the 
operating system to create an instance of that control's class, and in return Windows passes 
back to Visual Basic the internal <I>handle </I>to that control, which the language then 
exposes to the programmer through the <I>hWnd</I> property. All subsequent operations 
that Visual Basic performs on that control&#8212;resizing, font setting, and so on&#8212;are 
actually delegated to Windows. When the application raises an event 
(such as resizing), Visual Basic runtime calls an internal Windows API function and passes it the 
handle so that Windows knows which control is to be affected.</p>

<p>Lightweight controls such as Image controls, on the other hand, don't 
correspond to any Windows object and are entirely managed by Visual Basic itself. In a 
sense, Visual Basic just simulates the existence of that control: It keeps track of all 
the lightweight controls and redraws them each time the form is refreshed. For this 
reason, lightweight controls don't expose an 
<I>hWnd</I> property because there aren't any Windows handles associated with them. Windows doesn't even know a control is there.</p>

<p>From a practical point of view, the distinction between standard and 
lightweight controls is that the former consume system resources and memory while the 
latter don't. For this reason, you should always try to replace standard controls with 
lightweight controls. For example, use an Image control instead of a PictureBox 
control unless you really need some of PictureBox's specific features. To give you an 
idea of what this means in practice, a form with 100 PictureBox controls loads 
<I>10 times slower</I> than a form with 100 Image controls.</p>

<p>To understand whether a control is lightweight, see whether it supports 
the <I>hWnd</I> property. If it does, it surely is a standard control. A trip to the Object 
Browser reveals that the TextBox, CommandButton, OptionButton, CheckBox, Frame, 
ComboBox, and OLE controls, as well as both scroll bar controls and the ListBox control 
and all its variations, are standard controls. The Label, Shape, Line, Image, and 
Timer controls don't expose the <I>hWnd</I> property and should be therefore 
considered lightweight controls. But note that a missing 
<I>hWnd</I> property in an external ActiveX control doesn't necessarily mean that the control is windowless because the 
control's creator might decide not to expose the window's handle to the outside. For 
more information about standard and windowless controls, see the description of 
the <I>ZOrder</I> method later in this chapter.</p>

<A NAME="31"><h2>The <I>TabStop</I> and <I>TabIndex</I> Properties</h2></A>

<p>If a control is able to receive the input focus, it exposes the 
<I>TabStop</I> property. Most intrinsic controls support this property, including TextBox, OptionButton, 
CheckBox, CommandButton, OLE, ComboBox, both types of scroll bars, the ListBox control, 
and all its variations. In general, intrinsic lightweight controls don't support this 
property because they can never receive the input focus. The default value for this 
property is True, but you can set it to False either at design time or run time.</p>

<p>If a control supports the <I>TabStop</I> property, it also supports the 
<I>TabIndex</I> property, which affects the Tab order sequence&#8212;that is, the sequence in which the 
controls are visited when the user presses the Tab key repeatedly. (See the section 
&quot;<A HREF="ch01c.htm#17">Setting the Tab Order</A>&quot; in Chapter 1.) The 
<I>TabIndex</I> property is also supported by Label 
and Frame controls, but since these two controls don't support the 
<I>TabStop</I> property, the resulting effect is that when the user clicks on a Label or a Frame control (or 
presses the hot key specified in the Label or Frame 
<I>Caption</I> property), the input focus goes to the control that follows in the Tab order sequence. You can exploit this feature 
to use Label and Frame controls to provide hot keys to other controls:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' Let the user press the Alt+N hot key
' to move the input focus on the Text1 control.
Label1.Caption = &quot;&amp;Name&quot;
Text1.TabIndex = Label1.TabIndex + 1
</pre>
</td></tr>
</table></p>


<A NAME="32"><h2>The <I>MousePointer</I> and <I>MouseIcon</I> Properties</h2></A>

<p>These properties affect the shape of the mouse cursor when it hovers over a 
control. Windows permits a very flexible mouse cursor management in that each form 
and each control can display a different cursor, and you can also set an 
application-wide mouse cursor using the Screen global object. Nevertheless, the rules that affect 
the actual cursor used aren't straightforward:</p>

<UL>
<p><li>If the <I>Screen.MousePointer</I> property is set to a value different from 0-vbDefault, the mouse cursor reflects this value and no other 
properties are considered. But when the mouse floats over a different application 
(or the desktop), the cursor appearance depends on 
<I>that </I>application's current state, not yours.</li></p>

<p><li>If <I>Screen.MousePointer</I> is 0 and the mouse cursor is over a control, 
Visual Basic checks that control's 
<I>MousePointer</I> property; if this value is 
different from 0-vbDefault, the mouse cursor is set to this value.</li></p>

<p><li>If <I>Screen.MousePointer</I> is 0 and the mouse is over a form's surface or 
it's over a control whose <I>MousePointer</I> property is 0, Visual Basic uses 
the value stored in the form's <I>MousePointer</I> property.</li></p>
</UL>
 
<p>If you want to show an hourglass cursor, wherever the user moves the 
mouse, use this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
' A lengthy routine
Screen.MousePointer = vbHourglass
...
' Do your stuff here
...
' but remember to restore default pointer.
Screen.MousePointer = vbDefault
</pre>
</td></tr>
</table></p>


<p>Here's another example:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Show a crosshair cursor when the mouse is over the Picture1
' control and an hourglass elsewhere on the parent form.
Picture1.MousePointer = vbCrosshair
MousePointer = vbHourglass
</pre>
</td></tr>
</table></p>


<p>The <I>MouseIcon</I> property is used to display a custom, user-defined mouse 
cursor. In this case, you must set the 
<I>MousePointer</I> to the special value 99-vbCustom and 
then assign an icon to the <I>MouseIcon</I> property:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Display a red Stop sign mouse cursor. The actual path may differ,
' depending on the main directory where you installed Visual Basic. 
MousePointer = vbCustom
MouseIcon = LoadPicture(&quot;d:\vb6\graphics\icons\computer\msgbox01.ico&quot;)
</pre>
</td></tr>
</table></p>


<p>You don't need to load a custom mouse cursor at run time using the 
<I>LoadPicture</I> command. For example, you can assign it to the 
<I>MouseIcon</I> property at design time in the Properties window, as you can see in Figure 2-3, and activate it only 
when needed by setting the <I>MousePointer</I> property to 99-vbCustom. If you need to 
alternate among multiple cursors for the same control but don't want to distribute 
additional files, you can load additional ICO files in hidden Image controls and switch 
among them at run time.</p>

<p>
<A HREF="javascript:fullSize('F02ph03x.htm')"> <img src="images/F02ph03.JPG" width=404 height=327 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 2-3.</B> <i>Visual Basic 6 comes with a lot of ready-to-go custom cursors, icons, and bitmaps in the \GRAPHICS subdirectory.</i><!--/caption-->
</p>

<A NAME="33"><h2>The <I>Tag</I> Property</h2></A>

<p>All controls support the <I>Tag</I> property, without exception. This is true even for 
ActiveX controls, including any third-party controls. How can I be so certain that all 
controls support this property? The reason is that the property is provided by Visual Basic 
itself, not by the control. <I>Tag</I> isn't the only property provided by Visual Basic to any 
control: <I>Index</I>,<I> Visible</I>,<I> 
TabStop</I>,<I> TabIndex</I>,<I> ToolTipText</I>, 
<I>HelpContextID</I>, and <I>WhatsThisHelpID</I> properties all belong to the same category. These properties are collectively 
known as <I>extender properties</I>. Note that a few extender properties are available only 
under certain conditions. For example, 
<I>TabStop</I> is present only if the control can 
actually receive the focus. The <I>Tag</I> property is distinctive because it's guaranteed to be 
always available, and you can reference it in code without any risk of raising a run-time 
error.</p>

<p>The <I>Tag</I> property has no particular meaning to Visual Basic: 
It's simply a container for any data related to the control that you want to store. For example, 
you might use it to store the initial value displayed in a control so that you can 
easily restore it if the user wants to undo his or her changes.</p>

<A NAME="34"><h2>Other Properties </h2></A>

<p>The <I>Value</I> property is common to several intrinsic controls, namely 
CheckBox, OptionButton, CommandButton, and scroll bar controls, as well as to many 
external ActiveX controls. The meaning of this property varies from control to control, but 
in all cases it's a numerical or Boolean property.</p>

<p>The <I>Index</I> property is the key to building 
<I>control arrays,</I> a nifty Visual Basic feature that helps you create more versatile programs. (I explain control arrays 
more fully in <a href="ch03a.htm">Chapter 3</a>.) If you don't want to create a control array, just leave this 
property blank in the Properties window at design time. Note that this property is 
read-only at run time for controls that belong to a control array. Note that Visual Basic 
raises an error if you reference the <I>Index</I> property of a control that doesn't belong to 
a control array.</p>

<p>Most intrinsic controls support the 
<I>Appearance</I> property, which can be 
assigned at design time only and is read-only at run time. By default, Visual Basic 
creates controls with a three-dimensional aspect, unless you modify the value of this 
property to 0-Flat. You might decide to do so for visual consistency with older programs. 
For all your new applications, you should simply forget about the 
<I>Appearance</I> property and leave it at its default value (1-3D).</p>

<p>You can have Visual Basic automatically attach a control to the border of 
its parent window by setting its <I>Align</I> property to a non-Null value. Only two 
intrinsic controls support this property&#8212;PictureBox and Data controls&#8212;but several 
external ActiveX controls can be aligned in this way. Possible values for this property are 
0-None, 1-Align Top, 2-Align Bottom, 3-Align Left, and 4-Align Right.</p>

<p>The <I>BorderStyle</I> property is supported by a few intrinsic controls, namely 
the TextBox, Label, Frame, PictureBox, Image, and OLE controls. You can set this 
property to 0-None to suppress a border around the controller to 1-Fixed Single to draw 
it. Forms also support this property, but they allow different settings (as you'll see 
later in this chapter).</p>

<p><I>ToolTips </I>are those tiny, usually yellow windows that appear in most 
Windows applications when you move the mouse over a control or an icon and keep the 
mouse pointer still for a second or two. (Figure 2-4 shows you helpful advice from a 
ToolTip.) Until Visual Basic 4, developers had to create special routines or buy third-party 
tools to add this functionality to their programs. In Visual Basic 5 and 6, you only have 
to assign a string to the <I>ToolTipText</I> property of the control. Unfortunately, form 
objects don't support this property. Note that you have no control over the position or 
size of ToolTip windows and can modify their foreground and background color only 
on a systemwide basis. (Open the Control Panel window, double-click on the 
Display icon, and then move to the Appearance tab of the Display Properties dialog box 
where you can change the font and the background color of your ToolTips.)</p>

<p>
<img src="images/F02ph04.GIF" width=310 height=161 border=0>
<p>
<!--caption--><B>Figure 2-4.</B> <i>A tiny ToolTip tells you to enter your name.</i><!--/caption-->


<p>The <I>DragMode</I> and 
<I>DragIcon</I> properties (as well as the 
<I>Drag</I> method) were used to drag controls on the form, but they have been superseded by the 
<I>OLE</I>xxxx methods and properties. The old properties are still included for backward compatibility, 
but you shouldn't use them if you want to make your application conform to 
Windows 95 standards. OLE Drag and Drop properties, methods, and events are described in 
the &quot;<A HREF="ch09d.htm#400">Using Drag-and-Drop</A>&quot; section of Chapter 9.</p>

<p>You use <I>LinkMode</I>,<I> LinkTopic</I>,<I> 
LinkItem</I>, and <I>LinkTimeout </I>properties (as 
well as <I>LinkPoke</I>, <I>LinkExecute</I>, 
<I>LinkRequest</I>, and <I>LinkSend</I> methods) to enable a control or form to communicate through DDE (Dynamic Data Exchange) protocol with 
other controls or forms, possibly in another application. Before the advent of OLE and 
COM, Dynamic Data Exchange was the preferred way for two Windows programs 
to communicate. These days, you shouldn't use this technique because these 
properties have been maintained only for backward compatibility with applications written 
in previous versions of Visual Basic. I won't cover DDE in this book.</p>

</BODY>
</HTML>





