<HTML>
<HEAD>
<TITLE>The Command Object</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch13d.htm", "ch13f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="595"><h1>The Command Object</h1></A>
<p>The ADO Command object defines a command or a query that you can execute on a data source. Command objects are useful when you plan to execute the same command or query several times (on the same or on a different data source) and when you want to run stored procedures or parameterized queries. Recall from earlier in this chapter that you can execute SQL queries and commands using the <I>Execute </I>method of a Connection object or the <I>Open </I>method of a Recordset object. In a real application, you're more likely to use Command objects for these tasks. When you're working with SQL Server, for example, Command objects automatically reuse the temporary stored procedure that SQL Server creates the first time you execute it, and you can pass different arguments each time you execute the query.</p>

<p>You can create stand-alone Command objects that aren't associated with a Connection object, and you can then establish the connection by assigning a valid connection object to the <I>ActiveConnection </I>property. By doing so, you can reuse the same command on multiple connections.</p>

<A NAME="596"><h2>Properties</h2></A>
<p>The Command object supports nine properties, but only two of them are really necessary for carrying out a query or a command.</p>

<A NAME="597"><h3>Setting the query</h3></A>
<p>The most important property of the Command object is <I>CommandText</I>, which sets or returns the SQL command or query, the name of a table, or the name of a stored procedure. If you use an SQL query, it should be in the dialect of the database engine you're connecting to. Depending on the string that you assign to this property and on the particular provider you're using, ADO might change the contents of this property. For this reason, after assigning a value to <I>CommandText</I>, you might be wise to read it back to check the actual value that will be used for the query. Here's an example of how you use this property:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim cmd As New ADODB.Command
cmd.CommandText = &quot;SELECT * FROM Employees WHERE BirthDate &gt; #1/1/1960&quot;
</pre>
</td></tr>
</table></p>

<p>If you're going to repeat the query or the command with different arguments, it's convenient to prepare a parameterized Command object, which you do by inserting ? (question mark) symbols in the <I>CommandText </I>property:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim cmd As New ADODB.Command
cmd.CommandText = &quot;SELECT * FROM Employees WHERE BirthDate &gt; ? &quot; _
    &amp; &quot;AND HireDate &gt; ?&quot;
</pre>
</td></tr>
</table></p>

<p>The <I>CommandText </I>property tells the Command object what to do, and the <I>ActiveConnection</I> property specifies on which data source the command should be carried out. This property can be assigned a connection string (that follows the syntax of the <I>ConnectionString </I>of the Connection object) or a Connection object that already points to a data source. When you set this property to Nothing, you disconnect the Command object and release all the resources allocated on the server. If you attempt to run the <I>Execute </I>method before assigning a connection string or a Connection object to this property, a run-time error occurs. An error also occurs if you assign a closed Connection object to this property. Some providers require you to set this property to Nothing before switching to another connection.</p>

<p>You can share the connection among multiple ADO Command objects only if you assign the same Connection object to their <I>ActiveConnection </I>properties. Simply assigning the same connection string creates distinct connections. Here's an 
example that leverages this capability:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Edit this constant to match your directory structure.
Const DBPATH = &quot;C:\Program Files\Microsoft Visual Studio\Vb98\NWind.mdb&quot;
' Create the first Command object.
Dim cmd As New ADODB.Command, rs As New ADODB.Recordset
cmd.ActiveConnection = &quot;Provider=Microsoft.Jet.OLEDB.3.51;&quot; _
    &amp; &quot;Data Source= &quot; &amp; DBPATH
cmd.CommandText = &quot;SELECT FirstName, LastName FROM Employees&quot;
Set rs = cmd.Execute()
' Create a second Command object on the same database connection.
Dim cmd2 As New ADODB.Command, rs2 As New ADODB.Recordset
Set cmd2.ActiveConnection = cmd.ActiveConnection
cmd2.CommandText = &quot;SELECT * FROM Customers&quot;
Set rs2 = cmd2.Execute()
</pre>
</td></tr>
</table></p>

<p>Setting the <I>ActiveConnection </I>property to Nothing can affect the Parameters collection. More precisely, if the provider has populated the Parameters collection automatically, the collection will be cleared when the <I>ActiveConnection </I>is set to Nothing. If the Parameters collection has been manually populated through code, setting the <I>ActiveConnection </I>to Nothing doesn't affect it.</p>

<A NAME="598"><h3>Optimizing the execution</h3></A>
<p>The <I>CommandType </I>property lets you optimize execution speed by indicating what the <I>CommandText </I>string contains. It can be one of the following enumerated constants:</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">1-adCmdText</td>
<td valign="top">The text of an SQL query.</td>
</tr>
<tr>
<td valign="top">2-adCmdTable</td>
<td valign="top">A database table.</td>
</tr>
<tr>
<td valign="top">4-adCmdStoredProc</td>
<td valign="top">A stored procedure.</td>
</tr>
<tr>
<td valign="top">8-adCmdUnknown</td>
<td valign="top">The provider will determine the correct type (the default).</td>
</tr>
<tr>
<td valign="top">512-adCmdTableDirect</td>
<td valign="top">A database table opened directly.</td>
</tr>
</table></p>

<p>If you don't specify a value for this property, or if you use adCmdUnknown, you force ADO to figure out by itself what the <I>CommandText </I>string is, an operation that usually adds considerable overhead. The adCmdStoredProc option can also improve performance because it prevents ADO from creating a temporary stored procedure before executing the query. If the value you assign to the <I>CommandType </I>property doesn't match the type of the <I>CommandText </I>string, a run-time error occurs.</p>

<p>The <I>Prepared </I>property lets you leverage the real power of the Command object. When this property is True, the provider creates a compiled (prepared) version of the query passed in the <I>CommandText </I>property and then uses it to run the query each time this command is reexecuted. Creating a compiled procedure takes some time, so you should set this property to True only if you plan to execute the query two or more times. If the data source doesn't support prepared statements, what happens depends on the provider: It can raise an error, or it can just ignore the assignment.</p>

<p>The <I>CommandTimeout </I>property sets or returns the number of seconds ADO will wait when a command executes before raising an error. The default value is 30 seconds. If you set this property to 0, ADO will wait forever. This value isn't inherited from the <I>CommandTimeout</I> property of the Connection object to which the Command object is connected. In addition, not all providers support this property.</p>

<p><I>State </I>is a read-only property that can be queried to understand what the Command is currently doing. It can return the value 0-adStateClosed (the Command object is inactive) or 4-adStateExecuting (the Command object is executing a command).</p>

<A NAME="599"><h2>Methods</h2></A>
<p>The most important method of the Command object is the <I>Execute</I> method, which runs the query or the command stored in the <I>CommandText </I>property. This method is similar to the Connection object's <I>Execute</I> method, but the syntax is slightly different because the text of the query can't be passed as an argument:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Execute([RecordsAffected], [Parameters], [Options]) As Recordset
</pre>
</td></tr></table></p>

<p>If the <I>CommandText </I>property contains a row-returning query, the <I>Execute</I> method returns an open Recordset (which doesn't necessarily contain any row, however). Conversely, if the <I>CommandText </I>property specifies an action query, this method returns a closed Recordset. In the latter case, you can effectively use <I>Execute </I>as a procedure instead of as a function and ignore its return value.</p>

<p>If you pass a Long variable as the <I>RecordsAffected </I>argument, the <I>Execute </I>method returns in the variable the number of records that were affected by the action query command. This argument is optional, so you aren't obliged to pass anything, and it doesn't return any meaningful value with row-returning queries. If you're running a parameterized command or query, <I>Parameters </I>is a Variant that contains the value of a parameter or an array of all the expected parameters:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Edit this constant to match your directory structure.
Const DBPATH = &quot;C:\Program Files\Microsoft Visual Studio\Vb98\NWind.mdb&quot;
Dim cmd As New ADODB.Command, rs As New ADODB.Recordset
cmd.ActiveConnection = &quot;Provider=Microsoft.Jet.OLEDB.3.51;&quot; _
    &amp; &quot;Data Source= &quot; &amp; DBPATH
cmd.CommandText = &quot;SELECT * FROM Employees WHERE BirthDate &gt; ? &quot; _
    &amp; &quot;AND HireDate &gt; ?&quot;
cmd.CommandType = adCmdText
' You can pass multiple parameters without using a temporary array.
Set rs = cmd.Execute(, Array(#1/1/1960#, #1/1/1994#))
</pre>
</td></tr>
</table></p>

<p>The parameters you pass in this way are valid only for the current execution of the command, and they don't affect the Parameters collection. If you omit one or more arguments in the <I>Execute </I>method, ADO uses the corresponding values in the Parameters collection. Here's an example that passes only the second argument and implicitly uses the first item in the Parameters collection:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Set rs = cmd.Execute(, Array(, #1/1/1994#))
</pre>
</td></tr>
</table></p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>
Although you can pass any number of parameters using this method, you can't retrieve output parameters in this way. If you want to execute a stored procedure with output parameters, you can retrieve their values only by using the Parameters collection.
</blockquote></div></p>

<p>The <I>Option </I>argument can contain the same value that you assign to the <I>CommandType </I>property plus one or more of the following constants:</p>

<p><table cellpadding=5 width="95%">
<tr>
<th><i>Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">16-adAsyncExecute</td>
<td valign="top">Runs the command asynchronously in a separate thread</td>
</tr>
<tr>
<td valign="top">32-adAsyncFetch</td>
<td valign="top">Fetches the results asynchronously for Recordsets based on client-side cursors</td>
</tr>
<tr>
<td valign="top">64-adAsyncFetchNonBlocking</td>
<td valign="top">Similar to adAsyncFetch, but the calling program is never blocked</td>
</tr>
<tr>
<td valign="top">128-adExecuteNoRecords</td>
<td valign="top">Specifies that a command of type adCmdText or adCmdStoredProc is an action query and doesn't return a Recordset</td>
</tr>
</table></p>

<p>There are subtle differences among the adAsyncExecute<I>, </I>adAsyncFetch, and adAsyncFetchNonBlocking options. All of them execute the command asynchronously and set AffectedRecords to -1 because when the method returns, the command hasn't completed yet and ADO doesn't know how many records will be affected. If you specify adAsyncExecute, the command is executed asynchronously, and when the provider completes it, ADO fires an <I>ExecutionComplete </I>event in your program. If you specify adAsyncFetch on a Recordset based on a client-side cursor, when the execution of the command completes, ADO starts fetching the result rows asynchronously: When the code asks for a row that hasn't been retrieved yet, the application is blocked until the data is available (and when this occurs, a <I>FetchComplete </I>event fires). The adAsyncFetchNonBlocking option is similar to adAsyncFetch but with an important difference: When the code asks for a row that hasn't been retrieved yet, the application isn't blocked and the Recordset's <I>EOF </I>property is set to True. The code can therefore try again later or wait for the <I>FetchComplete </I>event to determine when data is finally available.</p>

<p>You can cancel the execution of an asynchronous operation by using the Command object's <I>Cancel </I>method. This method raises an error if no asynchronous option was specified for the most recent <I>Execute </I>method.</p>

<p>The third method the Command object supports is <I>CreateParameter</I>. With this method, you can create the Parameters collection entirely in code, without a round-trip to the server. The syntax of this method is as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>CreateParameter([Name], [Type], [Direction], [Size], [Value]) As Parameter
</pre>
</td></tr>
</table></p>

<p>Each argument you pass to this method is assigned to a property of the Parameter object being created. We'll go over these properties in more detail in the next section.</p>

</BODY>
</HTML>





