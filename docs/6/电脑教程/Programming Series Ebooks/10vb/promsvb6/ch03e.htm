<HTML>
<HEAD>
<TITLE>ListBox and ComboBox Controls</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch03d.htm", "ch03f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="85"><h1>ListBox and ComboBox Controls</h1></A>

<p>ListBox and ComboBox controls share many properties, methods, and events. 
ListBox controls are somewhat more powerful, so let's start with them. Explaining 
ComboBox controls afterward will be a walk in the park.</P>

<A NAME="86"><h2>ListBox Controls</h2></A>

<p>Once you have dropped a ListBox control on a form's surface, you might need 
to assign a few properties. For example, you set the 
<I>Sorted</I> attribute to True to create ListBox controls that automatically sort their items in alphabetical order. By acting 
on the <I>Columns</I> property, you create a different type of list box, with several 
columns and a horizontal scroll bar, as you can see in Figure 3-6, instead of the default 
list box with a single column and a vertical scroll bar along its right border. You can 
make assignments for both these properties only at design time, and you can't change 
the style of the ListBox control while the program is running.</P>

<p>
<A HREF="javascript:fullSize('F03ph06x.htm')"> <img src="images/F03ph06.JPG" width=404 height=292 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 3-6.</B> <i>Effects of different settings for the Column property.</i><!--/caption-->
</p>

<p>The <I>IntegralHeight</I> property is seldom modified, but it deserves some 
explanation because it indirectly gets in the way during regular programming. By 
default, Visual Basic automatically adjusts the height of ListBox controls so that they 
display entire rows; no item is shown only partially. The exact height assigned to the 
control depends on several factors, including current font attributes. This behavior 
is usually OK, and you normally don't have to worry about this issue. But if you 
want to resize the control to align it with other controls on the form or with the 
form's border, this feature might prevent you from doing such an adjustment. In this 
case, you should set the <I>IntegralHeight</I> property to False in the Properties window: 
Visual Basic won't enforce a particular height and you're free to resize the control as 
you prefer. Unfortunately, you can't modify this property at run time.</p>
<p>If you know at design time which items must appear in the ListBox control, 
you can save some code and enter the items right in the Properties window, in the 
List property mini-editor, as you can see in Figure 3-7. 
But if you're going to enter more than four or five items, you'd probably better add them 
via code at run time.</P>

<p>
<img src="images/F03ph07.GIF" width=263 height=428 border="0">
<p>
<!--caption--><B>Figure 3-7.</B> <i>Entering items at design time.(Press Ctrl+Enter to move to the next line.)</i><!--/caption-->

 

<p>Both ListBox and ComboBox controls expose the 
<I>AddItem</I> method, which lets you add items when the program is executing. You usually use this method in 
the <I>Form_Load</I> event procedure:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_Load()
    List1.AddItem &quot;First&quot;
    List1.AddItem &quot;Second&quot;
    List1.AddItem &quot;Third&quot;
End Sub
</pre>
</td></tr>
</table>
</P>


<p>In real-world applications, you rarely load individual items in this way. 
Most often your data is already stored in an array or in a database, and you have to 
scan the source of your data with a 
<I>For&#8230;Next</I> loop, as in the following code:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' MyData is an array of strings.
For i = LBound(MyData) To UBound(MyData)
    List1.AddItem MyData(i)
Next
</pre>
</td></tr>
</table>
</P>


<p><DIV CLASS="TIP"><BLOCKQUOTE><B>TIP</B><HR>
If you want to load many items in a list box but don't want to create an 
array, you can resort to Visual Basic's 
<I>Choose</I> function, as follows:
<p><table><tr><td><PRE>
For i = 1 To 5
    List1.AddItem Choose(i, &quot;America&quot;, &quot;Europe&quot;, &quot;Asia&quot;, _

        &quot;Africa&quot;, &quot;Australia&quot;)&quot;

Next
</pre></td></tr></table>
</P>
<P>Some special cases don't even require you to list individual items:</P>
<p><table><tr><td><PRE>
' The names of the months (locale-aware)
For i = 1 To 12

    List1.AddItem MonthName(i)
Next

' The names of the days of the week (locale-aware)
For i = 1 To 7
    List1.AddItem WeekDayName(i)
Next
</pre></td></tr></table>
</P>
<p><I>MonthName</I> and <I>WeekDayName</I> are new Visual Basic string functions, described in <a href="ch05a.htm">Chapter 5</a>.</p>
</BLOCKQUOTE></DIV></P>

<P>If you want to load dozens or hundreds of items, a better approach is to 
store them in a text file and have your program read the file when the form loads. 
This way you can later change the contents of your ListBox controls without 
recompiling the source code:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_Load()
    Dim item As String 
    On Error Goto Error_Handler
    Open &quot;listbox.dat&quot; For Input As #1
    Do Until EOF(1)
        Line Input #1, item
        List1.AddItem item
    Loop
    Close #1
    Exit Sub
Error_Handler:
    MsgBox &quot;Unable to load Listbox data&quot;
End Sub       
</pre>
</td></tr>
</table>
</P>


<p>Sometimes you need to add an item in a given position, which you do by 
passing a second argument to the <I>AddItem</I> method. (Note that indexes are zero-based.)</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Add at the very beginning of the list.
List1.AddItem &quot;Zero&quot;, 0
</pre>
</td></tr>
</table>
</P>


<p>This argument has precedence over the 
<I>Sorted</I> attribute, so you can actually insert some items out of order even in sorted ListBox controls. Removing items is 
easy with the <I>RemoveItem</I> or 
<I>Clear</I> methods:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Remove the first item in the list.
List1.RemoveItem 0
' Quickly remove all items (no need for a For...Next loop).
List1.Clear
</pre>
</td></tr>
</table>
</P>


<p>The most obvious operation to be performed at run time on a filled 
ListBox control is to determine which item has been selected by the user. The 
<I>ListIndex</I> property returns the index of the selected item (zero-based), while the 
<I>Text</I> property returns the actual string stored in the ListBox. The 
<I>ListIndex </I>property returns -1 if the user hasn't selected any element yet, so you should test for this condition first:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>If List1.ListIndex = -1 Then
    MsgBox &quot;No items selected&quot;
Else
    MsgBox &quot;User selected &quot; &amp; List1.Text &amp; &quot; (#&quot; &amp; List1.ListIndex &amp; &quot;)&quot;
End If
</pre>
</td></tr>
</table>
</P>


<p>You can also assign a value to the 
<I>ListIndex</I> property to programmatically 
select an item, or set it to -1 to deselect all items:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Select the third item in the list.
List1.ListIndex = 2
</pre>
</td></tr>
</table>
</P>


<p>The <I>ListCount</I> property returns the number of items in the control. You can 
use it with the <I>List</I> property to enumerate them:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>For i = 0 To List1.ListCount -1
    Print &quot;Item #&quot; &amp; i &amp; &quot; = &quot; &amp; List1.List(i)
Next
</pre>
</td></tr>
</table>
</P>


<A NAME="87"><h3>Reacting to user actions</h3></A>

<p>If your form doesn't immediately react to a user's selections on the ListBox 
control, you don't have to write any code to handle its events. But this is true only for 
trivial Visual Basic applications. In most cases, you'll have to respond to the 
<I>Click</I> event, which occurs whenever a new element has been selected (with the mouse, with 
the keyboard, or programmatically):</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub List1_Click()
    Debug.Print &quot;User selected item #&quot; &amp; List1.ListIndex
Next
</pre>
</td></tr>
</table>
</P>


<p>The logic behind your user interface might require that you monitor the 
<I>DblClick</I> event as well. As a general rule, double-clicking on a ListBox control's item 
should have the same effect as selecting the item and then clicking on a push button 
(often the default push button on the form). Take, for example, the mutually 
exclusive ListBox controls shown in Figure 3-8, a type of user interface that you see in 
many Windows applications. Implementing this structure in Visual Basic is straightforward:</P>

<p>
<A HREF="javascript:fullSize('F03ph08x.htm')"> <img src="images/F03ph08.JPG" width=404 height=195 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 3-8.</B> <i>A pair of mutually exclusive ListBox controls. You can move items around using the buttons in the middle or by double-clicking them.</i><!--/caption-->
</p>

 

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cmdMove_Click()
    ' Move one item from left to right.
    If lstLeft.ListIndex &gt;= 0 Then
        lstRight.AddItem lstLeft.Text
        lstLeft.RemoveItem lstLeft.ListIndex
    End If
End Sub

Private Sub cmdMoveAll_Click()
    ' Move all items from left to right.
    Do While lstLeft.ListCount
        lstRight.AddItem lstLeft.List(0)
        lstLeft.RemoveItem 0
    Loop
End Sub

Private Sub cmdBack_Click()
    ' Move one item from right to left.
    If lstRight.ListIndex &gt;= 0 Then
        lstLeft.AddItem lstRight.Text
        lstRight.RemoveItem lstRight.ListIndex
    End If
End Sub

Private Sub cmdBackAll_Click()
    ' Move all items from right to left.
    Do While lstRight.ListCount
        lstLeft.AddItem lstRight.List(0)
        lstRight.RemoveItem 0
    Loop
End Sub

Private Sub lstLeft_DblClick()
    ' Simulate a click on the Move button.
    cmdMove.Value = True
End Sub

Private Sub lstRight_DblClick()
    ' Simulate a click on the Back button.
    cmdBack.Value = True
End Sub
</pre>
</td></tr>
</table>
</P>


<p>The <I>Scroll</I> event comes in handy when you need to synchronize a ListBox 
control with another control, often another list box; in such cases, you usually want 
to scroll the two controls together, so you need to know when either one is 
scrolled. The <I>Scroll</I> event is often used in conjunction with the 
<I>TopIndex</I> property, which sets or returns the index of the first visible item in the list area. Using the 
<I>Scroll</I> event together with the 
<I>TopIndex</I> property, you can achieve really interesting visual 
effects, such as the one displayed in Figure 3-9. The trick is that the leftmost ListBox 
control is partially covered by the other control. Its companion scroll bar is never seen 
by users, who are led to believe that they're acting on a single control. For the best 
effect, you need to write code that keeps the two controls always in sync, and you 
achieve that by trapping <I>Click</I>, 
<I>MouseDown</I>, <I>MouseMove</I>, and 
<I>Scroll</I> events. The following code synchronizes two lists, 
<I>lstN</I> and <I>lstSquare</I>:</P>

<p>
<img src="images/F03ph09.GIF" width=199 height=337 border="0">
<p>
<!--caption--><B>Figure 3-9.</B> <i>You don't need a grid control to simulate a simple table; two partially overlapping ListBox controls will suffice.</i><!--/caption-->


<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub lstN_Click()
    ' Synchronize list boxes.
    lstSquare.TopIndex = lstN.TopIndex
    lstSquare.ListIndex = lstN.ListIndex
End Sub
Private Sub lstSquare_Click()
    ' Synchronize list boxes.
    lstN.TopIndex = lstSquare.TopIndex
    lstN.ListIndex = lstSquare.ListIndex
End Sub

Private Sub lstN_MouseDown(Button As Integer, Shift As Integer, _
    X As Single, Y As Single)
    Call lstN_Click
End Sub
Private Sub lstSquare_MouseDown(Button As Integer, _
    Shift As Integer, X As Single, Y As Single)
    Call lstSquare_Click
End Sub

Private Sub lstN_MouseMove(Button As Integer, Shift As Integer, _
    X As Single, Y As Single)
    Call lstN_Click
End Sub
Private Sub lstSquare_MouseMove(Button As Integer, _
    Shift As Integer, X As Single, Y As Single)
    Call lstSquare_Click
End Sub

Private Sub lstN_Scroll()
    lstSquare.TopIndex = lstN.TopIndex
End Sub
Private Sub lstSquare_Scroll()
    lstN.TopIndex = lstSquare.TopIndex
End Sub
</pre>
</td></tr>
</table>
</P>


<A NAME="88"><h3>The <I>ItemData </I>property</h3></A>

<p>The information you place in a ListBox control is rarely independent from the 
rest of the application. For example, the customer's name that you see on screen is 
often related to a corresponding CustomerID number, a product name is associated 
with its description, and so on. The problem is that once you load a value into the 
ListBox control you somehow disrupt such relationships; the code in event procedures 
sees only <I>ListIndex</I> and <I>List</I> properties. How can you retrieve the CustomerID value 
that was originally associated with the name that the user has just clicked on? The 
answer to this question is provided by the 
<I>ItemData</I> property, which lets you associate a 
32bit integer value with each item loaded in the ListBox control, as in the code below.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Add an item to the end of the list.
lstCust.AddItem CustomerName
' Remember the matching CustomerID.
lstCust.ItemData(lstCust.ListCount  -1) = CustomerId
</pre>
</td></tr>
</table>
</P>


<p>Note that you must pass an index to the <I>ItemData 
</I>property: Because the 
item you have just added is now the last one in the ListBox control, its index 
is 
<I>ListCount-1</I>. Unfortunately, this simple approach doesn't work with sorted 
ListBox controls, which can place new items anywhere in the list. In this case, you use 
the <I>NewIndex</I> property to find out where an item has been inserted:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Add an item to the end of the list.
lstCust.AddItem CustomerName
' Remember the matching ID. (This also works with Sorted list boxes.)
lstCust.ItemData(lstCust.NewIndex) = CustomerId
</pre>
</td></tr>
</table>
</P>


<p>In real-world applications, associating a 32-bit integer value with an item in 
a ListBox control is often inadequate, and you usually need to store more 
complex information. In this case, you use the 
<I>ItemData</I> value as an index into another 
structure, for example, an array of strings or an array of records. Let's say you have a 
list of product names and descriptions:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Type ProductUDT
    Name As String
    Description As String
    Price As Currency
End Type
Dim Products() As ProductUDT, i As Long

Private Sub Form_Load()
    ' Load product list from database into Products.
    ' ... (code omitted)
    ' Load product names into a sorted ListBox.
    For i = LBound(Products) To UBound(Products)
        lstProducts.AddItem Products(i).Name
        ' Remember where this product comes from.
        lstProducts.ItemData(lstProducts.NewIndex) = i
    Next
End Sub

Private Sub lstProducts_Click()
    ' Show the description and price of the item
    ' currently selected, using two companion labels.
    i = lstProducts.ItemData(lstProducts.ListIndex)
    lblDescription.Caption = Products(i).Description
    lblPrice.Caption = Products(i).Price
End Sub
</pre>
</td></tr>
</table>
</P>


<A NAME="89"><h3>Multiple-selection ListBox controls</h3></A>

<p>The ListBox control is even more flexible than I've shown so far because it lets 
users select multiple items at the same time. To enable this feature, you assign 
the <I>MultiSelect</I> property the values 1-Simple or 2-Extended. In the former case, you 
can select and deselect individual items only by using the Spacebar or the mouse. 
In extended selection, you can also use the Shift key to select ranges of items. 
Most popular Windows programs use extended selection exclusively, so you shouldn't 
use the value 1-Simple unless you have a good reason to do so. The 
<I>MultiSelect</I> property can't be changed when the program is running, so this is a design-time decision.</P>
<P>Working with a multiple selection ListBox control isn't different from 
interacting with a regular ListBox in the sense that you still use the 
<I>ListIndex</I>,<I> ListCount</I>, <I>List</I>, and 
<I>ItemData</I> properties. In this case, the most important piece of information is 
held in the <I>SelCount</I> and <I>Selected</I> properties. The 
<I>SelCount</I> property simply returns the number of items that are currently selected. You usually test it within a 
<I>Click</I> event:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub lstProducts_Click()
    ' The OK button should be enabled only if the
    ' user has selected at least one product.
    cmdOK.Enabled = (lstProducts.SelCount &gt; 0)
End Sub
</pre>
</td></tr>
</table>
</P>


<p>You retrieve the items that are currently selected using the 
<I>Selected</I> property. For example, this routine prints all selected items:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Print a list of selected products.
Dim i As Long
For i = 0 To lstProducts.ListCount -1
    If lstProducts.Selected(i) Then Print lstProducts.List(i)
Next
</pre>
</td></tr>
</table>
</P>


<p>The <I>Select</I> property can be written to, which is sometimes necessary to 
clear the current selection:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>For i = 0 To lstProducts.ListCount -1
    lstProducts.Selected(i) = False
Next
</pre>
</td></tr>
</table>
</P>


<p>Visual Basic 5 introduced a new variant of multiple selection ListBox 
controls, which let users select items by flagging a check box, as you see in Figure 3-10. To enable this capability, you set the ListBox control's 
<I>Style </I>property to 1-Checkbox at design time. (You can't change it at run time.) ListBox 
controls with check boxes are always multiselect, and the actual value of the 
<I>MultiSelect </I>property is ignored. These ListBox controls let the user select and deselect one 
item at a time, so it's often convenient to provide the user with two buttons&#8212;Select 
All and Clear All (and sometimes Invert Selection too).</P>

<p>
<A HREF="javascript:fullSize('F03ph10x.htm')"> <img src="images/F03ph10.JPG" width=404 height=281 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 3-10.</B> <i>Two variants for multiple selection ListBox controls.</i><!--/caption-->
</p>

<p>Apart from their appearance, there's nothing special about ListBox controls 
set as Style = 1-Checkbox, in that you can set and query the selected state of items 
through the <I>Selected</I> property. However, selecting and deselecting multiple items through 
code doesn't happen as quickly as you might believe. For example, this is the code 
for handling the <I>Click</I> event of the Select All button:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cmdSelectAll_Click()
    Dim i As Long, saveIndex As Long, saveTop As Long
    ' Save current state.
    saveIndex = List2.ListIndex
    saveTop = List2.TopIndex
    ' Make the list box invisible to avoid flickering.
    List2.Visible = False
    ' Change the select state for all items.
    For i = 0 To List2.ListCount - 1
        List2.Selected(i) = True
    Next
    ' Restore original state, and make the list box visible again.
    List2.TopIndex = saveTop
    List2.ListIndex = saveIndex
    List2.Visible = True
End Sub
</pre>
</td></tr>
</table>
</P>


<p>The code for the Clear All and Invert All buttons is similar, except for the 
statement inside the <I>For&#8230;Next</I> loop. This approach is necessary because writing to 
the <I>Selected</I> property also affects the 
<I>ListIndex</I> property and causes a lot of 
flickering. Saving the current state in two temporary variables solves the former problem, 
while making the control temporarily invisible solves the latter.</P>

<p>Interestingly, making the control invisible doesn't actually hide it, not 
immediately at least. If you operate on a control and want to avoid flickering or other 
disturbing visual effects, make it invisible, do your stuff, and then make it visible 
again before the procedure ends. If the procedure doesn't include any 
<I>DoEvents</I> or <I>Refresh</I> statement, the screen isn't updated and the user will never notice that the control 
has been made temporarily invisible. To see how the code would work without 
resorting to this technique, add a <I>DoEvents</I> or a 
<I>Refresh</I> statement to the preceding code, immediately before the 
<I>For&#8230;Next</I> loop.</P>

<p>ListBox controls with Style = 1-Checkbox offer an additional event, 
<I>ItemCheck</I>, that fires when the user selects or deselects the check box. You can use this 
event to refuse to select or deselect a given item:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub List2_ItemCheck(Item As Integer)
    ' Refuse to deselect the first item.
    If Item = 0 And List2.Selected(0) = False Then
        List2.Selected(0) = True
        MsgBox &quot;You can't deselect the first item&quot;, vbExclamation
    End If
End Sub
</pre>
</td></tr>
</table>
</P>


<A NAME="90"><h2>ComboBox Controls</h2></A>

<p>ComboBox controls are very similar to ListBox controls, so much of what I 
have explained so far applies to them as well. More precisely, you can create 
ComboBox controls that automatically sort their items using the 
<I>Sorted</I> property, you can add items at design time using the 
<I>List</I> item in the Properties window, and you can set a 
ComboBox control's <I>IntegralHeight</I> property as your user interface dictates. Most 
run-time methods are common to both kinds of controls too, including 
<I>AddItem</I>, <I>RemoveItem</I>, and 
<I>Clear</I>, as are the <I>ListCount</I>,<I> 
ListIndex</I>, <I>List</I>, <I>ItemData</I>,<I> 
TopIndex</I>, and <I>NewIndex</I> properties and the 
<I>Click</I>, <I>DblClick</I>, and <I>Scroll</I> events. ComboBox controls don't 
support multiple columns and multiple selections, so you don't have to deal with 
the <I>Column</I>,<I> MultiSelect</I>,<I> 
Select</I>, and <I>SelCount</I> properties and the 
<I>ItemCheck</I> event.</P>
<P>The ComboBox control is a sort of mixture between a ListBox and a 
TextBox control in that it also includes several properties and events that are more typical 
of the latter, such as the <I>SelStart</I>,<I> 
SelLength</I>,<I> SelText</I>, and<I> Locked</I> properties and 
the <I>KeyDown</I>, <I>KeyPress</I>, and 
<I>KeyUp</I> events. I've already explained many things that 
you can do with these properties and won't repeat myself here. Suffice it to say 
that you can apply to ComboBox controls most of the techniques that are valid for 
TextBox controls, including automatic formatting and deformatting of data in 
<I>GotFocus</I> and <I>LostFocus</I> event procedures and validation in 
<I>Validate</I> event procedures.</P>
<P>The most characteristic ComboBox control property is 
<I>Style</I>, which lets you pick one among the three styles available, as you can see in Figure 3-11. When you set Style = 0-DropDown Combo, what you get is the classic 
combo; you can enter a value in the edit area or select one from the drop-down list. The 
setting <I>Style</I> = 1-Simple Combo is similar, but the list area is always visible so that in this 
case you really have a compounded TextBox plus ListBox control. By default, Visual 
Basic creates a control that's only tall enough to show the edit area, and you must 
resize it to make the list portion visible. Finally, 
<I>Style</I> = 2-Dropdown List suppresses the edit area and gives you only a drop-down list to choose from.</P>

<p>
<img src="images/F03ph11.GIF" width=277 height=299 border="0">
<p>
<!--caption--><B>Figure 3-11.</B> <i>Three different styles for ComboBox controls. The drop-down list variant doesn't allow direct editing of the  contents.</i><!--/caption-->


<P>When you have a ComboBox control with <I>Style</I> = 0-Dropdown Combo 
or 2-Dropdown List, you can learn when the user is opening the list portion by 
trapping the <I>DropDown</I> event. For example, you can fill the list area just one instant 
before the user sees it (a sort of just-in-time data loading):</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Combo1_DropDown()
    Dim i As Integer
    ' Do it only once.
    If Combo1.ListCount = 0 Then
        For i = 1 To 100
            Combo3.AddItem &quot;Item #&quot; &amp; i
        Next
    End If
End Sub
</pre>
</td></tr>
</table>
</P>


<p>The ComboBox control supports the <I>Click</I> and 
<I>DblClick</I> events, but they relate only to the list portion of the control. More precisely, you get a 
<I>Click</I> event when the user selects an item from the list, and you get a 
<I>DblClick</I> event only when an item in the list is double-clicked. The latter can occur only when 
<I>Style</I> = 1-Simple Combo, though, and you'll never get this event for other types of ComboBox controls.</P>

<p><div class="note"><blockquote><b>NOTE</b><hr>
For reasons that, honestly, are beyond my imagination, 
<I>MouseDown</I>, <I>MouseUp</I>, and 
<I>MouseMove</I> events aren't supported by the ComboBox 
intrinsic controls. Don't ask me why. Ask Microsoft.
</blockquote></div></P>

<p>ComboBox controls with <I>Style</I> = 1-Simple Combo possess an intriguing 
feature, called <I>extended matching</I>. As you type a string, Visual Basic scrolls the list 
portion so that the first visible item in the list area matches the characters in the edit area. </P>

<p>Drop-down list controls pose special problems in programming. For 
example, they never raise <I>Change</I> and keyboard-related events. Moreover, you can't 
reference all the properties that are related to activity in the edit area, such as 
<I>SelStart</I>,<I> SelLength</I>, and 
<I>SelText</I>. (You get error 380&#8212;&quot;Invalid property value.&quot;) The 
<I>Text </I>property can be read and can also be written to, provided that the value you assign is among the 
items in the list. (Visual Basic performs a case-insensitive search.) If you try to assign a 
string that isn't in the list, you get a run-time error 
(383&#8212;&quot;<I>Text</I> property is read-only&quot;), 
which isn't really appropriate because the 
<I>Text</I> property can sometimes be assigned).</P>

</BODY>
</HTML>





