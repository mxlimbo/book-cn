<HTML>
<HEAD>
<TITLE>Standard Usage of Forms</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch09a.htm", "ch09c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="372"><H1>Standard Usage of Forms</H1></A>
<p>In <a href="ch02a.htm">Chapter 2</a>, I described the many properties, methods, and events of Visual 
Basic forms. In this chapter, I illustrate how forms fit into the object-oriented 
programming paradigm and how you can exploit them to build effective and bug-free applications.
</p>

<A NAME="373"><H2>Forms as Objects</H2></A>
<p>The first step in getting the most out of Visual Basic forms is recognizing what 
they really are. In all versions from Visual Basic 4 on, in fact, a form is nothing but a 
class module plus a designer. As you might recall from <a href="ch02a.htm">Chapter 2</a>, 
<I>designers </I>are modules integrated into the Visual Basic environment that let programmers visually 
design characteristics of objects to be instantiated at run time.
</p>
<p>The form designer lets you define the aspect of your form at design time 
by placing child controls on its surface and setting their properties. When you 
launch the application, the Visual Basic runtime translates these pieces of information 
into a series of calls to Windows API functions that create the main window and then 
all its child controls. Translated into C or C++ code, a typical Visual Basic form with 
some controls on it would require several hundred lines of code, which gives you an 
idea why Visual Basic has quickly become the most popular language for 
building Windows software.
</p>
<p>It's easy to prove that a form is nothing but an object with a user interface. 
Say that you have a form in your application named frmDetails. You can instantiate it 
as if it were a regular object using a standard New operator:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim frm As frmDetails
Set frm = New frmDetails
frm.Show
</pre>
</td></tr>
</table>
</p>
<p>A consequence of forms being objects is that they can expose 
properties, methods, and events exactly as regular objects do. For instance, you can add to a 
form module one or more Public Property procedures that encapsulate values 
contained in the form's child controls, as in the following code:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Inside the frmDetails form 
Public Property Get Total() As Currency
    Total = CCur(txtTotal.Text)
End Property
</pre>
</td></tr>
</table>
</p>
<p>Similarly, you can define Public methods that let the main application ask 
the form object to perform an action, for example, to print its contents on the printer:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Note that Sub, Function, and Property procs are Public by default.
Sub PrintOrders()
    ' Here you place the code that prints the form's contents.
End Sub
</pre>
</td></tr>
</table>
</p>
<p>From outside the form module, you access the form's properties and 
methods as you would do with any object:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim Total As Currency
Total = frm.Total()
frm.PrintOrders
</pre>
</td></tr>
</table>
</p>
<p>The most important difference between form modules and regular class 
modules is that the former can't be made Public and accessed from another 
application through COM.
</p>

<A NAME="374"><h3>Hidden global form variables</h3></A>

<p>The notion that a form is a special type of object leads to an apparent paradox. 
As you know, to use an object you must first initialize it. But you can (and usually 
do) reference a form directly without any prior explicit initialization. For example, in 
the following code snippet you don't need to explicitly create the frmDetails form:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cmdDetails_Click()
    frmDetails.Show
End Sub
</pre>
</td></tr>
</table>
</p>
<p>Since forms are objects, why doesn't this statement raise error 91: &quot;Object 
variable or With block variable not set&quot;? The reason is mostly historical. When 
Visual Basic 4 was released, Microsoft engineers were faced with the issue of backward 
compatibility with Visual Basic 3 and previous versions for which the preceding code 
was OK. Clearly, if Visual Basic 4 couldn't have imported existing Visual Basic 3 
projects, it would have been a flop. The solution the engineers came up with is both 
simple and elegant. For each form in the current application, the compiler defines a 
hidden global variable, whose name coincides with that of the form class:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>' (Note: you will never actually see these declarations.)
Public frmDetails As New frmDetails
Public frmOrders As New frmOrders
' (Same for every other form in the application)
</pre>
</td></tr>
</table>
</p>
<p>When your code references the <I>frmDetails</I> entity, you aren't referring to the 
frmDetails form <I>class</I>, you're referring to a 
<I>variable </I>whose name happens to be the same as 
its class. Because this variable is declared to be auto-instancing, Visual Basic creates 
a new instance of that particular form class as soon as your code references the variable.
</p>
<p>This ingenious trick, based on a hidden global form variable, has 
permitted developers to painlessly port their existing Visual Basic 3 applications to Visual 
Basic 4 and later versions. At the same time, as you'll see in a moment, these 
hidden variables introduce a few potential problems that you need to be aware of.
</p>

<A NAME="375"><h3>The &quot;clean form instance&quot; problem</h3></A>

<p>To illustrate a problem that often manifests itself when working with forms, I'll 
create a simple frmLogin form, which asks the end user for his or her name and 
password and refuses to unload if the password isn't the correct one. This simple 
form has only two public properties, 
<I>UserName</I> and <I>Password</I>, which are set to the 
contents of the txtUserName and txtPassword controls, respectively, in the 
<I>Unload</I> event procedure. This is the complete source code of the frmLogin form module:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Public UserName As String
Public Password As String

Private Sub cmdOK_Click()
    ' Unload this form only if password is OK.
    If LCase$(txtPassword) = &quot;balena&quot; Then Unload Me
End Sub

Private Sub Form_Load()
    ' Move property values into form fields.
    txtUserName = UserName
    txtPassword = Password
End Sub

Private Sub Form_Unload(Cancel As Integer)
    ' Move field contents back into public properties.
    UserName = txtUserName
    Password = txtPassword
End Sub
</pre>
</td></tr>
</table>
</p>
<p>You can display the frmLogin form and read its properties to retrieve 
values entered by the end user:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Code in frmMain form
Private Sub cmdShowLogin_Click()
frmLogin.Show vbModal
' Execution gets here only if password is OK.
MsgBox frmLogin.UserName &amp; &quot; logged in.&quot;
End Sub
</pre>
</td></tr>
</table>
</p>
<p>To test that this form works correctly, run the main form, click on 
its cmdShowLogin button, and then enter the correct user name and password. 
(Mine is shown in Figure 9-1). When the frmMain form regains control, it greets you 
with a message box. Apparently, everything works as it should. But if you click again 
on the Login button, the frmLogin form appears again; however, this time the user 
name and password fields are already filled with the values from the previous call. This 
isn't what I'd call a secure way to manage passwords!
</p>

<p>
<A HREF="javascript:fullSize('f09ph01x.htm')"> <img src="images/f09ph01.JPG" width=404 height=258 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-1.</B> <i>The Login demo application.</i><!--/caption-->
</p>

<p>To understand what has happened, add the following statements to the 
frmLogin form module:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub Form_Initialize()
    Debug.Print &quot;Initialize event&quot;
End Sub
Private Sub Form_Terminate()
    Debug.Print &quot;Terminate event&quot;
End Sub
</pre>
</td></tr>
</table>
</p>
<p>If you now run the program and repeat the same sequence of actions that I 
just described, you'll see that the 
<I>Initialize</I> event is called as soon as you reference 
the <I>frmLogin</I> variable in code, whereas the 
<I>Terminate</I> event is never invoked. In other words, the second time you show the frmLogin form, you're actually using the 
same instance created the first time. The form has been unloaded normally, but Visual 
Basic hasn't released the instance data area associated with the form instance&#8212;that is, 
the area where Private and Public variables are stored. For this reason, the value 
of <I>UserName</I> and <I>Password</I> properties persist from the first call, and you'll find them 
in the two TextBox controls. In a real application, this behavior can lead to bugs that 
are very difficult to discover because they aren't immediately visible in the user interface.
</p>
<p>You can work around this issue by forcing Visual Basic into releasing the 
form instance so that the next time you reference the form a new instance will be 
created. You can choose from two methods to achieve this. The most obvious one is to 
set the form variable to Nothing after returning from the 
<I>Show</I> method:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cmdShowLogin_Click()
    frmLogin.Show vbModal
    MsgBox frmLogin.UserName &amp; &quot; logged in.&quot;
    <B>' Set the hidden global form variable to Nothing.</B>
    <B>Set frmLogin = Nothing</B>
End Sub
</pre>
</td></tr>
</table>
</p>
<p>The other method is a more object-oriented way to achieve the same result. 
You simply need to explicitly create a local form variable with the same name as the 
hidden global variable so that the local variable takes precedence over the global variable:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cmdShowLogin_Click()
    <B>Dim frmLogin As New frmLogin</B>
    frmLogin.Show vbModal
    MsgBox frmLogin.UserName &amp; &quot; logged in.&quot;
End Sub
</pre>
</td></tr>
</table>
</p>
<p>If you now run the program, you'll see that when the form variable goes out of 
scope Visual Basic correctly invokes the form's 
<I>Form_Terminate</I> event, which is a 
confirmation that the instance is correctly 
destroyed: An interesting benefit of this technique is 
that you can create multiple instances of any nonmodal form, as you can see in Figure 9-2.
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cmdShowDocument_Click()
    Dim TextBrowser As New TextBrowser
    TextBrowser.Filename = txtFilename.Text
    ' Show the form, making it a child form of this one. 
    TextBrowser.Show, Me
End Sub
</pre>
</td></tr>
</table>
</p>

<p>
<A HREF="javascript:fullSize('f09ph02x.htm')"> <img src="images/f09ph02.JPG" width=404 height=300 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-2.</B> <i>Using explicit form variables, you can create and display multiple instances of the same form. All child forms are shown in front of their parent form, even if the parent form has the focus.</i><!--/caption-->
</p>

<p><div class="tip"><blockquote>
<b>TIP</b><hr>The <I>Show</I> method supports a second, optional argument that permits 
you to specify the parent form of the form being shown. When you pass a value 
to this argument, you achieve two interesting effects: the child form is always 
shown in front of its parent, even if the parent has the focus, and when the parent 
form is closed or minimized, all its child forms are also automatically closed or 
minimized. You can take advantage of this feature to create floating forms that host a 
toolbar, a palette of tools, a group of icons, and so on. This technique is most effective 
if you set the <I>BorderStyle</I> property of the child form to 4-Fixed ToolWindow 
or 5-Sizable ToolWindow.

</blockquote></div>
</p>
<p>You can find the complete source code of the frmTextBrowser form module 
on the companion CD. Note that in this case you're working with modeless 
forms. Consequently, when the form variable goes out of scope the form is still visible, 
which prevents Visual Basic from releasing the instance data area. When eventually the 
end user unloads the form, the Visual Basic runtime fires the 
<I>Form_Terminate</I> event immediately after the 
<I>Form_Unload</I> event. This seems to break the rule that any 
object is released as soon as the program destroys the last reference to it, but we 
haven't really destroyed the last reference, as I'll explain next.
</p>

<A NAME="376"><h3>The Forms collection</h3></A>

<p>The Forms collection is a global collection that contains all the currently loaded 
forms. This means that all loaded forms are referenced by this collection, and this 
additional reference keeps the form alive even if the main application has released all the 
references to a form. You can exploit the Forms collection to retrieve a reference to 
any form, even though the application has set to Nothing all the other references to 
it. All you need is the following function:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Function GetForm(formName As String) As Form
    Dim frm As Form
    For Each frm In Forms
        If StrComp(frm.Name, formName, vbTextCompare) = 0 Then
            Set GetForm = frm
            Exit Function
        End If
    Next
End Function
</pre>
</td></tr>
</table>
</p>
<p>If there are multiple occurrences of the same form, the preceding 
function returns the first reference to it in the Forms collection. You can use this function 
to reference a form by its name, as in this code:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>GetForm(&quot;frmLogin&quot;).Caption = &quot;Login Form&quot;
</pre>
</td></tr>
</table>
</p>
<p>You should be aware that the <I>GetForm</I> function returns a reference to a 
generic Form object. It therefore exposes the interface common to all forms, which 
includes properties such as <I>Caption</I> and 
<I>ForeColor</I> and methods such as <I>Move</I> and 
<I>Show</I>. You can't use this interface to access any custom method or property you have 
defined for a particular form class. Instead, you must 
<I>cast</I> the generic Form reference to a specific variable:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim frm As frmLogin
Set frm = GetForm(&quot;frmLogin&quot;) = &quot;Login Form&quot;
username = frm.UserName
</pre>
</td></tr>
</table>
</p>

<A NAME="377"><h2>Reusable Forms</h2></A>

<p>The notion that forms are objects suggests that you can reuse them exactly as 
you reuse class modules. You can reuse forms many ways, the simplest one being to 
store them as templates, as I suggested in <a href="ch02a.htm">Chapter 2</a>. But you can take advantage of 
more advanced and flexible techniques for form code reuse. I'll describe these 
techniques in the following sections.
</p>

<A NAME="378"><h3>Using custom properties and methods</h3></A>

<p>Many business applications show a calendar for the user to select one or more 
dates. Visual Basic comes with a MonthView Microsoft ActiveX control (see <a href="ch11a.htm">Chapter 11</a>), 
but a custom form has its advantages: Just to name a few, you can customize its size, 
the language used for months and the names of days of the week, and colors used 
for holidays. In general, a custom form gives you the greatest flexibility and control 
over the user interface. On the companion CD, you'll find the complete source code 
for the frmCalendar form module shown in Figure 9-3. The buttons with day 
numbers are arranged in an array of OptionButton controls whose 
<I>Style</I> property is set to 1-Graphical.
</p>

<p>
<A HREF="javascript:fullSize('f09ph03x.htm')"> <img src="images/f09ph03.JPG" width=404 height=292 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-3.</B> <i>A custom Calendar form that communicates with the main application through custom properties, methods, and events.</i><!--/caption-->
</p>

<p>The frmCalendar form exposes several properties that let you customize 
its interface, such as <I>DialogTitle</I> (the caption of the dialog box), 
<I>FirstDayOfWeek</I>, and 
<I>SaturdayIsHoliday</I> (useful for customizing the appearance of the calendar). There 
are also properties for retrieving the date selected by the user: 
<I>CancelPressed</I> (True if the end user hasn't selected any date), 
<I>SelectedDate</I> (a read/write Date value), 
<I>Day</I>, <I>Month</I>, and <I>Year</I> (read-only properties that return a given component of 
<I>SelectedDate</I>). The module exposes a single method, 
<I>ShowMonth</I>, that displays a given month in the dialog box, and optionally highlights a particular day:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cmdCalendar_Click()
    Dim Calendar As New frmCalendar
    Calendar.DialogTitle = &quot;Select a new date for the appointment&quot;
    ' Highlight the current day/month/year.
    Calendar.ShowMonth Year(Now), Month(Now), Day(Now)
    ' Show the calendar as a modal dialog.
    Calendar.Show vbModal
    ' Get the result if the user didn't press Cancel.
    If Not Calendar.CancelPressed Then
        AppointmentDate = Calendar.SelectedDate
    End If
End Sub
</pre>
</td></tr>
</table>
</p>
<p>In general, when working with a form as an object, you should provide the 
form with an interface that lets you avoid accessing the form's native properties. For 
example, the frmCalendar form module exposes the 
<I>DialogTitle</I> property, and client code should use it instead of the standard 
<I>Caption</I> property. This way, the client doesn't break the form object encapsulation, which in turn makes it possible for 
you to have control of what happens inside the form module. Alas, while you can 
build really robust class modules, you have no way to prevent the application from 
directly accessing the form's native properties or the controls on the form's surface. 
Nevertheless, you should exercise this discipline if you want to enjoy all the benefits 
of using forms as objects.
</p>

<A NAME="379"><h3>Adding custom events</h3></A>

<p>In the previous code example, the frmCalendar form is displayed as a modal 
dialog box, which pauses the execution of the program until the dialog box is closed. 
When the dialog box closes, you can query the form's properties to retrieve the end 
user's choices. In many circumstances, however, you might want to display a form as 
a modeless dialog box. In this case, you need a way to learn when the user closes 
the form so that you can query its 
<I>SelectedDate</I> property. You can accomplish this 
by adding a couple of custom events to the form module:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Event DateChanged(newDate As Date) 
Event Unload(CancelPressed As Boolean)
</pre>
</td></tr>
</table>
</p>
<p>These custom events increase the usability of the frmCalendar module. To 
trap these custom events, you need a module-level 
<I>WithEvents</I> variable in the form that's showing the calendar dialog box, as you would for a regular object:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the frmMain form
Dim WithEvents Calendar As New frmCalendar

Private Sub cmdCalendar_Click()
    Set Calendar = New frmCalendar
    Calendar.DialogTitle = &quot;Select a new date for the appointment&quot;
    Calendar.ShowMonth Year(Now), Month(Now), Day(Now)
    Calendar.Show           ' Show as a modeless dialog box.
End Sub

Private Sub Calendar_DateChanged(newDate As Date)
    ' Show the date currently selected on a Label control.
    lblStatus.Caption = Format(newDate, &quot;Long Date&quot;)
End Sub

Private Sub Calendar_Unload(CancelPressed As Boolean)
    If CancelPressed Then
        MsgBox &quot;Command canceled&quot;, vbInformation
    Else
        MsgBox &quot;Selected date: &quot; &amp; Format$(Calendar.SelectedDate, _
            &quot;Long Date&quot;), vbInformation
    End If
    ' We don't need this variable any longer.
    Set Calendar = Nothing
End Sub
</pre>
</td></tr>
</table>
</p>
<p><div class="note"><blockquote><b>NOTE</b><hr>
You might wonder why you need a custom 
<I>Unload </I>event: since the <I>Calendar</I> variable is referencing the frmCalendar form, you might think it 
capable of trapping its <I>Unload</I> event. This assumption isn't correct because, in fact, 
the <I>Calendar</I> variable is pointing to the frmCalendar interface, whereas the 
<I>Unload</I> event as well as other form events such as 
<I>Resize</I>, <I>Load</I>, <I>Paint</I>, and so on 
are exposed by the <I>Form</I> interface and can't be trapped by the 
<I>frmCalendar</I> variable. If you want to trap standard form events, you should assign the form 
reference to a generic <I>Form</I> variable. In this particular case, adding a custom 
<I>Unload</I> event simplifies the structure of the client code.
</blockquote></div>
</p>
<p>As they do for regular class modules, custom events add a lot of flexibility 
to form modules. Adding a <I>Change</I>-like event&#8212;such as the 
<I>DateChanged</I> event in the frmCalendar<I> 
</I>module&#8212;lets you keep the application in sync with data entered by 
the end user in the form. You can add many other types of events, for instance a 
<I>Progress</I> event, for when the form module performs lengthy operations. For more 
information about events, see <a href="ch07a.htm">Chapter 7</a>.
</p>

<A NAME="380"><h3>Parameterized forms</h3></A>

<p>You can push the usability of form modules even further with the concept of 
<I>parameterized forms, </I>a name that I use for forms whose appearance heavily depends on 
how the main application sets the properties or invokes the methods of the form 
before actually showing it. To see what I mean, have a look at Figure 9-4: the two 
Options forms are actually the same form module, which adjusts itself according to what 
the main application has requested.
</p>
<p>Parameterized forms are difficult to build, for two main reasons. First, you 
need to provide a reasonable set of properties and methods that let the client 
code customize the form appearance and contents and eventually retrieve all the 
values entered by the user. Second, you have to write a lot of code within the form to 
create controls on the fly and automatically place them in their appropriate 
positions on the form.
</p>

<p>
<A HREF="javascript:fullSize('f09ph04x.htm')"> <img src="images/f09ph04.JPG" width=404 height=272 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-4.</B> <i>Two distinct instances of a parameterized Options form.</i><!--/caption-->
</p>
<p>The frmOptions form exposes three key methods, which let you add a 
Frame control, a CheckBox control, and an OptionButton control:
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cdmOptionsOne_Click()
    Dim frm As New frmOptions

    ' Add a Frame control _ the first argument to this and following 
    ' methods is a unique ID code for the control being created.
    frm.AddFrame &quot;F1&quot;, &quot;First Group&quot;
    ' Each subsequent AddOption and AddCheck method adds 
    ' a control inside the current frame, until another AddFrame
    ' method is issued.
    frm.AddOption &quot;O1&quot;, &quot;&amp;1. First&quot;, True   ' Set the value to True.
    frm.AddOption &quot;O2&quot;, &quot;&amp;2. Second&quot;
    frm.AddOption &quot;O3&quot;, &quot;&amp;3. Third&quot;

    ' Add a second frame, with three radio buttons and two check boxes.
    frm.AddFrame &quot;F2&quot;, &quot;Second Group&quot;
    frm.AddOption &quot;O4&quot;, &quot;&amp;4. Fourth&quot;, True  ' Set the value to True.
    frm.AddOption &quot;O5&quot;, &quot;&amp;5. Fifth&quot;
    frm.AddOption &quot;O6&quot;, &quot;&amp;6. Sixth&quot;
    ' Tick this check box control.
    frm.AddCheck &quot;C1&quot;, &quot;&amp;7. Check one&quot;, True  
    frm.AddCheck &quot;C2&quot;, &quot;&amp;8. Check two&quot;
    ' Show the form as a modal dialog.
    frm.Show vbModal
</pre>
</td></tr>
</table>
</p>
<p>The form module exposes the <I>Value</I> method, which returns the value of 
a control given its ID code. You can use it as you would use the 
<I>Value</I> property for CheckBox and OptionButtons controls, or you can pass it the ID code of a 
Frame control to learn which OptionButton control is selected inside the frame itself:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>    ' Continuing the cmdOptionsOne_Click procedure...
    If frm.CancelPressed Then
        MsgBox &quot;Command canceled&quot;, vbInformation
    Else
        MsgBox &quot;Option button in first frame: &quot; &amp; frm.Value(&quot;F1&quot;) _
            &amp; vbCr &amp;  &quot;Option button in second frame: &quot; _
            &amp; frm.Value(&quot;F2&quot;) &amp; vbCr _
            &amp; &quot;First checkbox : &quot; &amp; frm.Value(&quot;C1&quot;) &amp; vbCr _
            &amp; &quot;Second checkbox: &quot; &amp; frm.Value(&quot;C2&quot;) &amp; vbCr, _
            vbInformation, &quot;Result of Options form&quot;
    End If
End Sub
</pre>
</td></tr>
</table>
</p>
<p>Have a look at the source code of the frmOptions form module to see how 
it resizes each Frame control to account for all its contained controls. You can also 
see how the form itself is resized to account for all the Frame controls on it.
</p>
<p>You can build a huge number of parameterized forms like the 
frmOptions module. For example, you can use forms for showing custom message boxes 
with any number of buttons, any icon, any font for the main message text, and so on. 
The greatest advantage of parameterized forms is that you build them once and reuse 
them for forms and dialog boxes that behave in the same or a similar way, even if 
their appearance is different. This has a beneficial impact on the size of the EXE file 
and on the memory needed at run time.
</p>

<A NAME="381"><h2>Forms as Object Viewers</h2></A>

<p>You can look at forms in yet another way. If your application extensively uses 
class modules for storing and processing data, you might build forms that work as 
specialized <I>object viewers</I>. For example, if you have a CPerson class module that 
holds personal data, you might build a frmPerson form module that exposes one 
custom object property&#8212;<I>Person</I>, of type CPerson. This approach greatly simplifies the 
structure of the client code because it just needs to assign one single property instead 
of many distinct, simpler properties (in this case, 
<I>Name</I>, <I>Address</I>, <I>City</I>, and 
<I>Married</I>):
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The client code that uses the frmPerson form
Dim Person1 As New CPerson
' Initialize properties for this instance.
Person1.Name = &quot;John Smith&quot;
Person1.Address = &quot;12345 West Road&quot;
...
' Display it on screen.
Dim frm As New frmPerson
Set frm.Person = Person1
frm.Show
</pre>
</td></tr>
</table>
</p>
<p>The frmPerson form module has to correctly assign values to its fields when 
the <I>Person</I> property is set, as you can see in Figure 9-5 and in the code that follows it.
</p>

<p>
<A HREF="javascript:fullSize('f09ph05x.htm')"> <img src="images/f09ph05.JPG" width=404 height=304 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-5.</B> <i>Using forms as object viewers. The two form instances that display the same CPerson object are automatically synchronized.</i><!--/caption-->
</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Inside the frmPerson form module
Private WithEvents ThisPerson As CPerson

Property Get Person() As CPerson
    Set Person = ThisPerson
End Property
Property Set Person(newValue As CPerson)
    ' Initialize the private object and form fields.
    Set ThisPerson = newValue
    With ThisPerson
        txtName.Text = .Name
        txtAddress.Text = .Address
        txtCity.Text = .City
        chkMarried.Value = Abs(.Married)    ' Assign zero or one.
    End With
End Property
</pre>
</td></tr>
</table>
</p>
<p>Another advantage of this technique is that the client code doesn't 
directly address the properties of the CPerson object. Thanks to this detail, you must add 
or remove statements in the frmPerson module if the interface exposed by this 
class changes, but you don't have to modify the code in the client application that 
instantiates the frmPerson module showing the object.
</p>
<p>A third, more interesting advantage of this approach is this: Because the 
form has a direct link with the class that holds the data, the form can delegate all the 
data validation chores to the class itself, which is the right thing to do in an object-
oriented application. The validation process usually occurs when the user clicks 
on the OK button:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the frmPerson form module...
Private Sub cmdOK_Click()
    On Error Resume Next
    ' Assign (and implicitly validate) the Name property.
    ThisPerson.Name = txtName.Text
    If Err Then
        ' If the class raised an error
        MsgBox Err.Description
        txtName.SetFocus
        Exit Sub
    End If

    ' Similar code for the Address, City, and Married properties.
    ...
End Sub
</pre>
</td></tr>
</table>
</p>
<p>Forms used as object viewers have a fourth advantage, which is, in my 
opinion, also the most important and intriguing one. Since each form holds a 
reference to the actual object, you can have multiple forms pointing to the same object. 
This ensures that all form instances access the same data and that they don't display 
inconsistent values. To see what I mean, run the ObjView.Vbp sample application, 
click two or more times on the John Smith button, modify data in a form, and then 
click on OK to see the new value automatically propagated to all the other form 
instances. By selecting a different option in the Notification frame on the main form, you 
can also have new values propagated to other forms whenever the user exits each 
field (field-level notification) or even when the user presses a key (key-level 
notification). I added this capability to the demonstration program just to show you that it's 
possible to do it. But in most real-world applications, record-level notification is the 
most appropriate choice.
</p>
<p>To implement this fourth feature, the CPerson class raises an event 
whenever one of its properties changes, as shown here:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the CPerson class module...
Event Change(PropertyName As String)
' A private variable that holds the value of the Name property
Private m_Name As String

Property Let Name(newValue As String)
    ' It's very important that the new value always be checked.
    If newValue = &quot;&quot; Then Err.Raise 5, , &quot;Invalid Value for Name property&quot;
    If m_Name &lt;&gt; newValue Then
        m_Name = newValue
        PropertyChanged &quot;Name&quot;
    End If
End Property

' Similar code for Property Let Address/City/Married
... 

' This private method simply raises a Change event in client code.
Private Sub PropertyChanged(PropertyName As String)
    RaiseEvent Change(PropertyName)
End Sub
</pre>
</td></tr>
</table>
</p>
<p>The frmPerson form module can trap the 
<I>Change</I> event because its <I>ThisPerson</I> Private instance pointing to the CPerson object is declared using the 
<I>WithEvents </I>keyword:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub ThisPerson_Change(PropertyName As String)
    Select Case PropertyName
        Case &quot;Name&quot;
            txtName.Text = ThisPerson.Name
        Case &quot;Address&quot;
            txtAddress.Text = ThisPerson.Address
        Case &quot;City&quot;
            txtCity.Text = ThisPerson.City
        Case &quot;Married&quot;
            chkMarried.Value = Abs(ThisPerson.Married)
    End Select
End Sub
</pre>
</td></tr>
</table>
</p>
<p>Here are a couple of final notes about using forms as object viewers:
</p>
<UL>
<p><li> In your application, you can have forms from different classes pointing 
to the same object. For example, you can have a frmPerson form module 
that shows essential information about a person and a frmPerson2 form 
module that displays the same information plus additional confidential 
data. You can use both forms in the same application and open them so 
that they refer to the same CPerson instance at the same time. When you 
have multiple forms that display the same object, this technique 
dramatically reduces the amount of code because all the validation logic, as well as 
the code that reads data from a database and stores it back, is located in 
the class module and doesn't need to be duplicated in each form module.
</li></p>
<p><li> You can have the same form module work as a viewer for multiple classes, 
 as long as such classes have a common secondary interface. For 
example, your application can deal with CPerson, CCustomer, and CEmployee 
objects. If all of these objects implement the IPersonalData secondary 
interface, which gathers all the properties that are common to them, you can 
build a frmPersonalData form module that exposes a 
<I>PersonalData</I> property:</li></p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Inside the frmPersonalData form module...
Private PersData As IPersonalData

Property Get PersonalData() As IPersonalData
    Set PersonalData = PersData
End Property

Property Set PersonalData(newValue As IPersonalData)
    Set PersData = newValue
    ' Initialize fields on the form.

    With PersData

        txtName = .Name

        ...

    End With
End Property
</pre>
</td></tr></table>
</p>
<p>You can't receive events from the classes, however, because 
events aren't exposed by secondary interfaces. So you can use a single form 
that points to a secondary interface of multiple classes only when you 
don't need to keep multiple instances of the form in sync. You don't need 
to account for synchronization issues when all the forms are shown 
as modal dialog boxes.
</p>
</ul>

 
<A NAME="382"><h2>Dynamic Control Creation</h2></A>

<p>
<img src="images/new.jpg" width=102 height=87 border="0">
</p>
<p>Dynamic control creation is one of the most exciting, new features of Visual Basic 
6 and overcomes a serious limitation of the previous versions of the language. 
Using this new capability, you can create new controls on a form at run time by 
specify-ing their class name. This mechanism is much more flexible than the one 
based on control arrays (described in <a href="ch03a.htm">Chapter 3</a>). In fact, creating a control at run 
time using control arrays forces you to place an instance of each type of control on 
the form at design time. This isn't necessary using Visual Basic 6's dynamic 
control creation features.
</p>

<A NAME="383"><h3>The <I>Add </I>method of the Controls collection</h3></A>

<p>Under Visual Basic 6, the Controls collection has been enhanced to support the 
<I>Add</I> method, which lets you dynamically create controls at run time. This method 
uses the following syntax:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Set controlRef = Controls.Add(ProgID, Name [,Container])
</pre>
</td></tr>
</table>
</p>
<p>where ProgID is the class name of the control in the format 
<I>libraryname.controlname</I>, and <I>Name </I>is the name you want to assign to the control (and which will be 
returned by its <I>Name</I> property). This name must be unique: If another control in the 
collection has the same name, Visual Basic raises an error 727&#8212;&quot;There is already a control 
with the name 'ctrlname'&quot;. <I>Container </I>is an optional reference to a container control 
(for example, a PictureBox or a Frame control) inside which you want to place the 
control being created. If you omit this argument, the control is placed on the form's 
surface. <I>ControlRef </I>is an object variable that you use to reference the control's 
properties, invoke its methods, and trap its events. You can see from the following code 
how easy it is to create a CommandButton control and place it near the lower right 
corner of the form:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim WithEvents cmdCalendar As CommandButton

Private Sub Form_Load()
    Set cmdCalendar = Controls.Add(&quot;VB.CommandButton&quot;, &quot;cmdButton&quot;)
    ' Assumes that form's ScaleMode is twips.
    cmdCalendar.Move ScaleWidth - 1400, ScaleHeight - 800, 1000, 600
    cmdCalendar.Caption = &quot;&amp;Calendar&quot;
    ' All controls are created invisible.
    cmdCalendar.Visible = True
End Sub
</pre>
</td></tr>
</table>
</p>
<p>Because you have declared <I>cmdCalendar</I> using the 
<I>WithEvents</I> clause, you can react to its events. For example, you can display a custom calendar when the 
user clicks on the button you just created:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub cmdCalendar_Click()
    Dim frm As New frmCalendar
    frm.ShowMonth Year(Now), Month(Now)
    frm.Show vbModal
End Sub
</pre>
</td></tr>
</table>
</p>
<p>You can remove any control added dynamically using the Controls 
collection's <I>Remove</I> method, whose only argument is the name of the control (that is, the 
string passed as a second argument to the 
<I>Add</I> method):
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Controls.Remove &quot;cmdButton&quot;
</pre>
</td></tr>
</table>
</p>
<p>You get an error if the control specified doesn't exist on the form or if it 
wasn't added dynamically at run time.
</p>

<A NAME="384"><h3>Adding an external ActiveX control</h3></A>

<p>Adding an external ActiveX control is similar to adding an intrinsic Visual Basic 
control. But you must pay particular attention to two important details.
<UL>
<p><li> For some external ActiveX controls, you can't use the ProgID as 
you read it in the object browser. When you try to use it, you get a 
run-time error. Fortunately, the error message clearly reports the correct 
ProgID. (See Figure 9-6.) For example, the TreeView control's actual ProgID 
is &quot;MSComCtlLib.TreeCtrl.2&quot;, and this is the string you must pass as the 
first argument to the <I>Controls.Add</I> method.
</li></p>
<p>
<img src="images/f09ph06.GIF" width=371 height=201 border="0">
<p>
<!--caption--><B>Figure 9-6.</B> <i>The error message you get when you try to add a TreeView control using the ProgID string as found in the Object Browser.</i><!--/caption-->

<p><li> If you dynamically add an ActiveX control that's never been used on 
any form of the current project, Visual Basic raises a run-time error. (See 
Figure 97.) This happens because the Visual Basic compiler usually 
discards all the information about controls that are present in the Toolbox but 
not referenced in the project. This step optimizes the performance and 
reduces the size of the executable file. To circumvent this error, uncheck the 
Remove Information About Unused ActiveX Controls box in the Make 
tab of the Project Properties dialog box.
</li></p>
<p>
<img src="images/f09ph07.GIF" width=371 height=201 border="0">
<p>
<!--caption--><B>Figure 9-7.</B> <i>You get this error message when you try to load an ActiveX control that appears in the Toolbox but isn't referenced in any other form of the application.</i><!--/caption-->

</UL>

<p><div class="note"><blockquote><b>NOTE</b><hr>
You can dynamically add any type of intrinsic Visual Basic control, 
except menu items. Unfortunately, this limitation prevents developers from 
devising customizable menu structures with top-level menus and submenus built 
on the fly.
</blockquote></div></p>

<A NAME="385"><H3>The Windowless Controls Library</H3></A>
<p>
<img src="images/new.jpg" width=102 height=87 border="0"></p>
</p>
<p>Visual Basic 6 comes with a new library of windowless controls that exactly 
duplicate the appearance and the features of most Visual Basic intrinsic controls. This 
library isn't mentioned in the main language documentation, and it must be 
installed manually from the Common\Tools\VB\Winless directory. This folder contains 
the Mswless.ocx ActiveX control and the Ltwtct98.chm file with its documentation. 
To install the library, you first copy this directory on your hard disk. Before you can 
use the control, you must register it using the Regsvr32.exe utility or from within 
Visual Basic, and then double-click on the Mswless.reg file, which creates the Registry 
keys that make the ActiveX control available to the Visual Basic environment.
</p>
<p>Once you have completed the registration step, you can load the library 
into the IDE by pressing the Ctrl+T key and selecting the Microsoft Windowless 
Controls 6 item from the list of available ActiveX controls. After you do this, you'll find that 
a number of new controls have been added to the Toolbox. The library contains 
a replacement for the TextBox, Frame, CommandButton, CheckBox, 
OptionButton, ComboBox, ListBox, and the two ScrollBar controls. It doesn't include Label, 
Timer, or Image controls because the Visual Basic versions are already windowless. Nor 
does it contain PictureBox and OLE controls, which are containers and can't therefore 
be rendered as windowless controls.
</p>
<p>The controls in the Windowless Controls Library don't support the 
<I>hWnd </I>property. As you might remember from <a href="ch02a.htm">Chapter 2</a>, this property is the handle of the 
window on which the control is based. Since these controls are windowless, there's 
no such window and therefore the <I>hWnd</I> property doesn't make any sense. Other 
properties are missing, namely those that have to do with DDE communications. 
(DDE is, however, an outdated technology and isn't covered in this book.) Another 
difference is that the WLOption control (the windowless counterpart of the 
OptionButton intrinsic control) supports the new 
<I>Group </I>property, which serves to create 
groups of mutually exclusive radio buttons. (You can't create a group of radio buttons 
by placing them in a WLFrame control because this control doesn't work as a container.)
</p>
<p>Apart from the <I>hWnd</I> property and the <I>Group 
</I>property, the controls in the library are perfectly compatible with Visual Basic's intrinsic controls in the sense 
that they expose the same properties, methods, and events as their Visual Basic 
counterparts. Interestingly, the library's controls offer a number of property pages that 
let the programmer set the properties in a logical manner, as you can see in Figure 
9-8.
</p>
<p>
<A HREF="javascript:fullSize('f09ph08x.htm')"> <img src="images/f09ph08.JPG" width=404 height=375 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-8.</B> <i>You can set the properties of controls in the Windowless library using handy property pages. Notice how the new controls appear in the Toolbox.</i><!--/caption-->
</p>
<p>The real advantage of using the controls in the Windowless library is that at 
run time they aren't subject to many of the limitations that the intrinsic controls are. 
In fact, <I>all </I>their properties can be modified during execution, including the 
<I>MultiLine</I> and <I>ScrollBars</I> properties of the WLText control, the 
<I>Sorted</I> and <I>Style</I> properties of the WLList and WLCombo controls, and the 
<I>Alignment</I> property of the WLCheck and WLOption controls.
</p>
<p>The ability to modify any property at run time makes the Windowless library 
a precious tool when you're dynamically creating new controls at run time using 
the <I>Controls.Add</I> method. When you add a control, it's created with all properties set 
to their default values. This situation means that you can't use the 
<I>Controls.Add</I> method to create multiline intrinsic TextBox controls or sorted ListBox or ComboBox 
controls. The only solution is to use the Windowless Controls Library:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim WithEvents TxtEditor As MSWLess.WLText

Private Sub Form_Load()
    Set TxtEditor = Controls.Add(&quot;MSWLess.WLText&quot;, &quot;txtEditor&quot;)
    TxtEditor.MultiLine = True
    TxtEditor.ScrollBars = vbBoth
    TxtEditor.Move 0, 0, ScaleWidth, ScaleHeight
    TxtEditor.Visible = True
End Sub
</pre>
</td></tr>
</table>
</p>


<A NAME="386"><h3>Unreferenced controls</h3></A>

<p>So far, I've described what you have to do to add controls that are referenced at 
design time in the Toolbox. But you can do more with the dynamic control creation 
feature than I've shown you so far; its greater power lies in letting you create ActiveX 
controls that aren't referenced in the Toolbox. You can provide support for versions of 
ActiveX controls that don't exist yet at compile time, for example by storing the control's 
name in an INI file that you edit when delivering a new version of the control. This 
adds tremendous flexibility to your applications and lets you transform your forms 
into generic ActiveX control containers.
</p>
<p>The first issue you must resolve when working with controls not referenced 
in the Toolbox is design-time licensing. Even if you're not actually using the control 
at design time, to dynamically load it at run time you must prove that you're 
legally allowed to do so. If there weren't any restrictions to dynamically creating 
ActiveX controls at run time, any programmer could &quot;borrow&quot; ActiveX controls from 
other commercial software and use them in his or her applications without actually 
purchasing the license for the controls. This is an issue only for ActiveX controls that 
aren't referenced in the Toolbox at design time; if you can load a control in the 
Toolbox, you surely own a design-time license for the control.
</p>
<p>To dynamically create an ActiveX control not referenced in the Toolbox 
at compile time, you must exhibit your design-time license at run time. In this 
context, a license is a string of characters or digits that comes with the control and is 
stored in the system Registry when you install the control on your machine. Visual 
Basic doesn't force you to search for this string in the Registry because you can find it 
by means of the <I>Add</I> method of the Licenses collection:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>' This statement works only if the MSWLess library is
' *NOT* currently referenced in the Toolbox.
Dim licenseKey As String
licenseKey = Licenses.Add(&quot;MSWLess.WLText&quot;)
</pre>
</td></tr>
</table>
</p>
<p>After you have the license string, you must devise a way to make it 
available to the application at run time. The easier method is storing it in a file:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Open &quot;MSWLess.lic&quot; For Output As #1
Print #1, licenseKey
Close #1
</pre>
</td></tr>
</table>
</p>
<p>The preceding code must be executed just once during the design process, 
and after you've generated the LIC file you can throw the code away. The application 
reads this file back into the Licenses collection, again using the 
<I>Add</I> method but this time with a different syntax:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Open &quot;MSWLess.lic&quot; For Input As #1
Line Input #1, licenseKey
Close #1
Licenses.Add &quot;MSWLess.WLText&quot;, licenseKey
</pre>
</td></tr>
</table>
</p>
<p>The Licenses collection also supports the 
<I>Remove</I> method, but you will rarely need to invoke it.</P>

<A NAME="387"><H3>Late-bound properties, methods, and events</H3></A>
<p>Once you resolve the licensing issue, you're ready to face another problem that 
comes up when you're working with ActiveX controls not referenced in the Toolbox 
at compile time. As you might imagine, if you don't know what control you'll load 
at run time, you can't assign the return value of the 
<I>Controls.Add</I> method to an object variable of a specific type. This means that you have no simple way to access 
properties, methods, or events of your freshly added control.</P>

<P>The solution offered by Visual Basic 6 is a special type of object variable 
named <I>VBControlExtender</I>. This represents a generic ActiveX control inside the Visual 
Basic IDE:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim WithEvents TxtEditor As VBControlExtender

Private Sub Form_Load()
    ' Add the license key to the Licenses collection (omitted).
    Set TxtEditor = Controls.Add(&quot;MSWLess.WLText&quot;, &quot;TxtEditor&quot;)
    TxtEditor.Move 0, 0, ScaleWidth, ScaleHeight
    TxtEditor.Visible = True
    TxtEditor.Text = &quot;My Text Editor&quot;
End Sub
</pre>
</td></tr>
</table>
</p>
<p>Trapping events from an ActiveX control not referenced in the Toolbox is a 
bit more complex than accessing properties and methods. In fact, the 
VBControlExtender object can't expose the events of the control it will host at run time. Instead, it 
supports only a single event, named 
<I>ObjectEvent</I>, which is invoked for all the events 
raised by the original ActiveX control. The 
<I>ObjectEvent</I> event receives one argument, an EventInfo object that in turn contains a collection of EventParameter objects. 
This collection enables the programmer to learn what arguments were passed to the event.
</p>
<p>
<A HREF="javascript:fullSize('g09ph01x.htm')"> <img src="images/g09ph01.JPG" width=404 height=144 border=0 ALT = "Click to view at full size."> </A></p>

<P>Inside the <I>ObjectEvent</I> event procedure, you usually test the 
<I>EventInfo</I>.<I>Name</I> property to discern which event was fired, and then you read, and sometimes 
modify, the value of each of its parameters:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub TxtEditor_ObjectEvent(Info As EventInfo)
    Select Case Info.Name
        Case &quot;KeyPress&quot;
            ' The Escape key clears the editor.
            If Info.EventParameters(&quot;KeyAscii&quot;) = 27 Then
                TxtEditor.Object.Text = &quot;&quot;
            End If
        Case &quot;DblClick&quot;
            ' Just to prove that we can trap any event
            MsgBox &quot;Why have you double-clicked me?&quot;
    End Select
End Sub
</pre>
</td></tr>
</table>
</p>
<p>Events trapped in this way are called <I>late-bound 
events</I>. There's a group of <I>extender 
events</I> that you don't trap inside the <I>ObjectEvent 
</I>event. These extender events (one of which is shown in the following code snippet) are available as regular 
events of the VBControlExtender object. This group of events includes 
<I>GotFocus</I>, <I>LostFocus</I>, <I>Validate</I>, 
<I>DragDrop</I>, and <I>DragOver</I>. For more information about extender 
properties, methods, and events, see <a href="ch17a.htm">Chapter 17</a>.
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private Sub TxtEditor_GotFocus()
    ' Highlight textbox's contents on entry.
    TxtEditor.Object.SelStart = 0
    TxtEditor.Object.SelLength = 9999
End Sub
</pre>
</td></tr>
</table>
</p>

<A NAME="388"><h2>Data-Driven Forms</h2></A>

<p>Visual Basic's new dynamic control creation capabilities enable developers to 
create true <I>data-driven forms,</I> which are forms whose appearance is completely 
determined at run time by data read from a file or&#8212;if you're building a form that displays 
data from a database table&#8212;by the structure of the database itself. Imagine what 
degree of flexibility you get if you're able to modify the appearance of a Visual Basic 
form at run time without having to recompile the application:
</p>
<UL>
<p><li> You can add and remove fields to the database and have the form 
automatically update itself.
</li></p>
<p><li> You can provide your users with the ability to customize the 
application's user interface in terms of colors, fonts, field position and size, new 
buttons that display other tables, and so on.
</li></p>
<p><li> You can easily implement policies to make given fields invisible or 
read-only, depending on which user is currently logged in. For example, 
you can give access to confidential information only to people authorized 
to read it, and you can hide it from others.
</li></p>
</UL>
<p>To implement data-driven forms, however, you must first solve a problem. 
When you don't know in advance how many controls you're going to add to the form, 
how can you trap events from them? This problem arises because the 
<I>WithEvents</I> keyword is unable to trap events from an array of objects. As you'll see, this issue can be 
resolved, but the solution probably isn't as simple as you might think it should 
be. However, the technique that I'll describe is both interesting and flexible and can 
not only help you build data-driven forms but also more generally trap events from 
an undetermined number of objects, a problem I left unresolved in <a href="ch07a.htm">Chapter 7</a>.
</p>

<A NAME="389"><h3>Trapping events from an array of controls</h3></A>

<p>To trap events coming from an undetermined number of controls dynamically 
created at run time&#8212;or, in general, from an undetermined number of objects&#8212;you 
need to build two support classes, the first one a collection class that contains all the 
instances of the second class. In the sample program that you'll find on the 
companion CD, these classes are named ControlItems and ControlItem, respectively. 
The relationships among these classes and the main form are summarized in 
Figure 9-9.
</p>
<p>
<A HREF="javascript:fullSize('f09ph09x.htm')"> <img src="images/f09ph09.JPG" width=404 height=325 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-9.</B> <i>You need two auxiliary classes and some tricky code to trap events raised by an array of controls dynamically created at run time.</i><!--/caption-->
</p>
<p>The events can be trapped as follows:
</p>
<OL>
<p><li> The main application holds a reference to an instance of the 
ControlItems collection class in a variable named 
<I>CtrlArray</I>. This variable is declared using the 
<I>WithEvents</I> clause because it will raise events in the main application.
</li></p>
<p><li> After the form creates a new control, it passes a reference to that 
control to the <I>Add</I> method of the 
ControlItems<I> </I>collection class. This reference 
can be of a specific class (if you know at design time which type of 
controls you're creating) or it can be of a VBControlExtender object if you 
want to exploit late-bound events.
</li></p>
<p><li> The <I>Add</I> method of the 
ControlItems<I> </I>collection class creates a new 
instance of the ControlItem class and passes it a reference to the control just 
created on the form. It also passes a reference to itself.
</li></p>
<p><li> The ControlItem class instance stores the reference to the control 
in a <I>WithEvents</I> Public variable. It also stores a reference to the 
parent ControlItems collection class in the Private 
<I>Parent</I> object variable.
</li></p>
<p><li> When the control eventually raises an event, the ControlItem class 
traps it and can therefore pass the event to the parent collection classes. 
This notification is performed by calling a Friend method in the 
ControlItems collection class. In general, you should provide one such method for 
each possible event trapped by the dependent class because each event has 
a different set of arguments.
</li></p>
<p><li> Inside the notification event, the ControlItems class can finally raise 
an event in the parent form. The first argument passed to this event is a 
reference to the control that raised the event or a reference to the 
ControlItem object that trapped it.
</li></p>
</OL>
<p>As you can see, it's a long trip just to intercept an event. But now that you 
know how to do it, you can apply this technique in many interesting ways.
</p>

<A NAME="390"><H3>Database-driven data-entry forms</H3></A>
<p>One of the many possible applications of dynamic control creation are forms 
that automatically map themselves to the structure of a database table or query. This 
is especially useful when you're writing large business applications with dozens or 
hundreds of queries, and you don't want to create customized forms for each one. 
This technique dramatically reduces development time and shrinks the size of the 
executable file as well as its requirements in terms of memory and resources.
</p>
<p>On the companion CD, you'll find a complete Visual Basic application 
whose main form adapts itself to the structure of a database table of SQL SELECT query, 
as you can see in Figure 9-10.
</p>
<p>
<A HREF="javascript:fullSize('f09ph10x.htm')"> <img src="images/f09ph10.JPG" width=404 height=313 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 9-10.</B> <i>All the controls on this form are dynamically created at run time, based on the structure of an ADO recordset. The program creates different controls according to the type of the database field and also provides validation for each.</i><!--/caption-->
</p>
<p>Space constraints prevent me from showing the complete source code in 
print, so I'll include only the most interesting routines:
</p>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The collection of controls added dynamically (module-level
' variable)
Dim WithEvents ControlItems As ControlItems

' This is the most interesting routine, which actually
' creates the controls and passes them to the ControlItems
' collection class.
Sub LoadControls(rs As ADODB.Recordset)
    Dim index As Long, fieldNum As Integer
    Dim field As ADODB.field
    Dim ctrl As Control, ctrlItem As ControlItem, ctrlType As String
    Dim Properties As Collection, CustomProperties As Collection
    Dim top As Single, propItem As Variant
    Dim items() As String
     
    ' Start with a fresh ControlItems collection.
    Set ControlItems = New ControlItems
    ' Initial value for Top property
    top = 100

    ' Add controls corresponding to fields.
    ' This demo program supports only a few field types.
    For Each field In rs.Fields
        ctrlType = &quot;&quot;
        Set Properties = New Collection
        Set CustomProperties = New Collection
        Select Case field.Type
            Case adBoolean
                ctrlType = &quot;MSWLess.WLCheck&quot;
                Properties.Add &quot;Caption=&quot;
            Case adSmallInt   ' As Integer
                ctrlType = &quot;MSWLess.WLText&quot;
            Case adInteger    ' As Long
                ctrlType = &quot;MSWLess.WLText&quot;
                CustomProperties.Add &quot;IsNumeric=-1&quot;
                CustomProperties.Add &quot;IsInteger=-1&quot;
            Case adSingle, adDouble, adCurrency
                ctrlType = &quot;MSWLess.WLText&quot;
                CustomProperties.Add &quot;Numeric=-1&quot;
            Case adChar, adVarChar  ' As String
                ctrlType = &quot;MSWLess.WLText&quot;
                Properties.Add &quot;Width=&quot; &amp; _
                    (field.DefinedSize * TextWidth(&quot;W&quot;))
            Case adLongVarChar   ' (Memo field)
                ctrlType = &quot;MSWLess.WLText&quot;
                Properties.Add &quot;Width=99999&quot;  ' Very large width
                Properties.Add &quot;Height=2000&quot;
                Properties.Add &quot;Multiline=-1&quot;
                Properties.Add &quot;ScrollBars=2&quot;  'vbVertical
            Case adDate
                ctrlType = &quot;MSWLess.WLText&quot;
                Properties.Add &quot;Width=1000&quot;
                CustomProperties.Add &quot;IsDate=-1&quot;
            Case Else
                ' Ignore other field data types.
        End Select

        ' Do nothing if this field type is not supported (ctrlType=&quot;&quot;).
        If ctrlType &lt;&gt; &quot;&quot; Then
            fieldNum = fieldNum + 1
            ' Create the label control with database field name.
            Set ctrl = Controls.Add(&quot;VB.Label&quot;, &quot;Label&quot; &amp; fieldNum)
            ctrl.Move 50, top, 1800, 315
            ctrl.Caption = field.Name
            ctrl.UseMnemonic = False
            ctrl.BorderStyle = 1
            ctrl.Alignment = vbRightJustify
            ctrl.Visible = True
            ' Create the control, and move it to the correct position.
            Set ctrl = Controls.Add(ctrlType, &quot;Field&quot; &amp; fieldNum)
            ctrl.Move 1900, top, 2000, 315

            ' If the field is not updatable, lock it. 
            If (field.Attributes And adFldUpdatable) = 0 Then
                On Error Resume Next
                ctrl.Locked = True
                ' If the control doesn't support the Locked property,
                ' disable it.
                If Err Then ctrl.Enabled = False
                On Error GoTo 0
            End If

            ' Set other properties of the field.
            For Each propItem In Properties
                ' Split property's name and value.
                items() = Split(propItem, &quot;=&quot;)
                CallByName ctrl, items(0), VbLet, items(1)
            Next
            ' Link it to the Data control, and make it visible.
            Set ctrl.DataSource = Adodc1
            ctrl.DataField = field.Name
            ctrl.Visible = True

            ' Add this control to the ControlItems collection.
            Set ctrlItem = ControlItems.Add(ctrl)
            ' Move the actual width into the custom Width property.
            ' This is used in the Form_Resize event.
            ctrlItem.Properties.Add ctrl.Width, &quot;Width&quot;
            ' Set its other custom properties.
            For Each propItem In CustomProperties
                ' Split property name and value.
                items() = Split(propItem, &quot;=&quot;)
                ctrlItem.Properties.Add items(1), items(0)
            Next
            ' Increment top.
            top = top + ctrl.Height + 80
        End If
    Next
    ' Force a Form_Resize event to resize longer controls.
    Call Form_Resize
    Adodc1.Refresh
End Sub

' A control added dynamically is asking for validation.
' Item.Control is a reference to the control.
' Item.GetProperty(propname) returns a custom property.
Private Sub ControlItems_Validate(Item As ControlItem, _
    Cancel As Boolean)
    If Item.GetProperty(&quot;IsNumeric&quot;) Then
        If Not IsNumeric(Item.Control.Text) Then
            MsgBox &quot;Please enter a valid number&quot;
            Cancel = True: Exit Sub
        End If
    End If
    If Item.GetProperty(&quot;IsInteger&quot;) Then
        If CDbl(Item.Control.Text) &lt;&gt; Int(CDbl(Item.Control.Text)) Then
            MsgBox &quot;Please enter a valid Integer number&quot;
            Cancel = True: Exit Sub
        End If
    End If
    If Item.GetProperty(&quot;IsDate&quot;) Then
        If Not IsDate(Item.Control.Text) Then
            MsgBox &quot;Please enter a valid date&quot;
            Cancel = True: Exit Sub
        End If
    End If
End Sub
</pre>
</td></tr>
</table>
</p>
<p>Many points in the <I>LoadControls</I> routine are worth a closer look. First, it 
uses the Windowless Controls Library because it needs to modify properties such 
as TextBox control's <I>Multiline</I> (for example, for memo fields). Second, to streamline 
the structure of the code and make it easily extendable, each 
<I>Case</I> clause in the main <I>Select</I> block simply adds property names and values to a Properties collection: after 
the control is actually created, it uses the 
<I>CallByName</I> command to assign all the properties in a 
<I>For Each</I> loop. Third, it creates the 
<I>CustomProperties</I> collection, where it stores information that can't be directly assigned to the control's properties. 
This includes the &quot;<I>IsNumeric&quot;</I>, 
&quot;<I>IsInteger&quot;</I>, and &quot;<I>IsDate&quot; 
</I>custom attributes, which are later used when the code in the main form validates the value in the field.
</p>
<p>Please refer to the complete project on the companion CD for the 
complete source code of the main form and the ControlItems and ControlItem class modules.
</p>

</BODY>
</HTML>





