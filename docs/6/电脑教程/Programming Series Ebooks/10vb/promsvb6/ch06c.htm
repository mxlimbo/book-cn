<HTML>
<HEAD>
<TITLE>Properties, Methods, and Events</TITLE>
<LINK REL=STYLESHEET HREF="Library.css" TYPE="text/css">


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06b.htm", "ch06d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>


<A NAME="225"><h1>Properties, Methods, and Events</h1></A>

<p>It's time to see how you can put all the capabilities you've seen so far to good use. I'll continue to develop the original CPerson class as an example and expand it as I introduce new concepts.</p>

<A NAME="226"><h2>Read-Only and Write-Only Properties</h2></A>

<p>If you look at how Visual Basic defines its own objects (forms, controls, and so on), you'll notice that not all properties can be both read from and written to. For example, you can't modify the <I>MultiSelect </I>property of a ListBox control at run time, and you can't modify the height of a ComboBox control even at design time. Depending on the nature of your class, you might have many good reasons to limit the access to your properties, making them read-only or (less frequently) write-only.</p>

<A NAME="227"><h3>Read-only properties</h3></A>

<p>Say that you want to add an <I>Age</I> property to your CPerson class. It depends on the <I>BirthDate</I> property, so it should be a read-only property. In Visual Basic, you can make a property read-only by simply omitting its <I>Property Let</I> procedure:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Property Get Age() As Integer
    Age = Year(Now) - Year(BirthDate)
End Property
</pre>
</td></tr>
</table>
</p>

<p>To prove that you now have a read-only property, try to execute this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>pers.Age = 50
</pre>
</td></tr>
</table>
</p>


<p>The Visual Basic compiler traps this logical error as soon as you try to run 
your program and won't compile the program until you correct or delete the statement.

<A NAME="228"><h3>Write-only properties</h3></A>
<p>Occasionally, you might even want to create write-only properties. A typical example is a <I>Password</I> property exposed by an imaginary LoginDialog object. The property can be assigned to validate the login process but shouldn't be readable so as not to compromise the security of the application itself. In Visual Basic, such a write-only property can be easily implemented by writing a <I>Property Let</I> procedure while omitting the corresponding <I>Property Get</I> routine:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private m_Password As String

Property Let Password(ByVal newValue As String)
    ' Validate the password, raise error if not valid.
    ' ...
    ' If all is OK, assign to Private member variable.
    m_Password = newValue
End Property
</pre>
</td></tr>
</table>
</p>

<p>To be honest, I don't often find anything very useful for this particular Visual Basic feature to do, so I have reported it mostly for the sake of completeness. Write-only properties are often confusing and are perceived as unnatural by most developers. If need dictates a write-only property, I prefer to create a method that accepts the value as an argument (<I>SetPassword</I>, in this particular example).</p>

<A NAME="229"><h3>Write-once/read-many properties</h3></A>
<p>Write-once/read-many properties are a bit more interesting and useful than pure 
write-only properties. For example, the LoginDialog object described in the previous 
paragraph might expose a <I>UserName</I> property of this type. Once a user logs in, your 
code assigns his or her name to this property; the rest of the application can then read 
it but can't modify it. Here's another example: in an <I>Invoice</I> class, the <I>Number</I> property might be rendered as a write-once/read-many property because once you assign a number to an invoice, arbitrarily changing it might cause serious problems in your accounting system.</p>

<p>Visual Basic doesn't offer a native system to implement such write-once/read-many properties, but it's easy to do that with some additional lines of code. Let's say that you want to provide our CPerson class with an <I>ID</I> property that can be assigned only once but read as many times as you need. Here's a possible solution, based on a Static local variable:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private m_ID As Long

Public Property Get ID() As Long
    ID = m_ID
End Property
Public Property Let ID(ByVal newValue As Long)
    Static InitDone As Boolean
    If InitDone Then Err.Raise 1002, , &quot;Write-once property&quot;
    InitDone = True
    m_ID = newValue
End Property
</pre>
</td></tr>
</table>
</p>

<p>Here's an alternative solution, which spares you the additional Static variable but consumes some additional bytes in memory (16 bytes instead of 6):</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private m_ID As Variant

Public Property Get ID() As Long
    ID = m_ID
End Property
Public Property Let ID(ByVal newValue As Long)
    If Not IsEmpty(m_ID) Then Err.Raise 1002, , &quot;Write-once property&quot;
    m_ID = newValue
End Property
</pre>
</td></tr>
</table>
</p>


<p>In both cases, the interface that the class exposes to the outside is the same. (<I>ID</I> is a Long property.) This is another example of how a good encapsulation scheme lets you vary the internal implementation of a class without affecting the code that uses it.</p>

<A NAME="230"><h3>Read-only properties vs. methods</h3></A>

<p>From the point of view of the client code (that is, the code that actually uses your class), a read-only property is similar to a function. In fact, in all cases a read-only property can be invoked only in expressions and can never appear to the left of an assignment symbol. So this raises a sort of semantic problem: When is it preferable to implement a read-only property and when is a function better? I can't offer rigid rules, just a few suggestions:</p>
<UL>

<p><li> Most programmers expect properties to be quick shortcuts to values stored in the class. If the routine that you're building serves mostly to <I>return </I>a value stored inside the class or can be quickly and easily reevaluated, create a property because this is probably the way the client code will look at it anyway. If the routine serves mostly to <I>evaluate </I>a complex value, use a function.</li></p>

<p><li> If you can find it useful to call the routine and discard its return value 
(in other words, it's more important what the routine does than what it returns), write a function. VBA lets you call a function as if it were a Sub, which isn't possible with a <I>Property 
Get</I> procedure.</li></p>

<p><li> If you can imagine that in the future the value returned by the routine could be assigned to, use a <I>Property Get</I> procedure, and reserve for yourself the chance to add a <I>Property Let</I> routine when it's needed.</li></p>
</UL>

<p><div class="note"><blockquote><b>NOTE</b><hr>
What happens when you try to assign a value to a read-only property is slightly different from when you try to assign to a function. In the former case, you receive a plain error&#8212;&quot;Can't assign to read-only property&quot;&#8212;whereas in the latter, you get a more cryptic &quot;Function call on left-hand side of assignment must return Variant or Object.&quot; The real meaning of this strange message will be clear when I cover object properties later in this chapter.
</blockquote></div>
</p>

<p>Let's take the <I>CompleteName</I> member of the CPerson class as an example. It has been implemented as a method, but most programmers would undoubtedly think of it as a read-only property. Moreover&#8212;and this is the really important point&#8212;nothing prevents you from morphing it into a read/write property:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Property Get CompleteName() As String
    CompleteName = FirstName &#38;; &quot; &quot; &#38;; LastName
End Property
Property Let CompleteName(ByVal newValue As String)
    Dim items() As String
    items() = Split(newValue)
    ' We expect exactly two items (no support for middle names).
    If UBound(items) &lt;&gt; 1 Then Err.Raise 5
    ' If no error, assign to the &quot;real&quot; properties.
    FirstName = items(0): LastName = items(1)
End Property
</pre>
</td></tr>
</table>
</p>

<p>You have increased the usability of the class by letting the client code assign the<I>FirstName</I> and <I>LastName</I> properties in a more natural way, for example, directly from a field on the form:

<p><table cellpadding=5 width="95%"><tr><td>
<pre>pers.CompleteName = txtCompleteName.Text
</pre>
</td></tr>
</table>
</p>


<p>And of course you can still assign individual 
<I>FirstName </I>and <I>LastName</I> properties without the risk of creating inconsistencies with the <I>CompleteName</I> property. This is another of those cute little things you can do with classes.</p>

<A NAME="231"><h3>Properties with arguments</h3></A>

<p>So far, I've illustrated <I>Property Get</I> procedures with no arguments and their 
matching <I>Property Let</I> procedures with just one argument, the value being assigned to 
the procedure. Visual Basic also lets you create Property procedures that accept 
any number of arguments, of any type. This concept is also used by Visual Basic for 
its own controls: for example, the <I>List</I> property of ListBox controls accepts a 
numerical index. </p>

<p>Let's see how this concept can be usefully applied to the CPerson sample 
class. Suppose you need a <I>Notes</I> property, but at the same time you don't want to 
limit yourself to just one item. The first solution that comes to mind is using an array 
of strings. Unfortunately, if you declare a Public array in a class module as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Public Notes(1 To 10) As String        ' Not valid!
</pre>
</td></tr>
</table>
</p>

<p>the compiler complains with the following message, &quot;Constants, fixed-length 
strings, arrays, user-defined types, and Declare statements not allowed as Public member 
of object modules.&quot; But you can create a Private member array and expose it to 
the outside using a pair of Property procedures:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' A module-level variable
Private m_Notes(1 To 10) As String

Property Get Notes(Index As Integer) As String
    Notes = m_Notes (Index)
End Property
Property Let Notes(Index As Integer, ByVal newValue As String)
    ' Check for subscript out of range error.
    If Index &lt; LBound(m_Notes) Or Index &gt; UBound(m_Notes) Then Err.Raise 9
    m_Notes(Index) = newValue
End Property
</pre>
</td></tr>
</table>
</p>


<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>
You might be tempted not to check the <I>Index</I> argument in the <I>Property Let</I> procedure in the preceding code, relying instead on the default behavior of Visual Basic that would raise an error anyway. Think about it again, and try to imagine what would happen if you later decide to optimize your code by setting the Remove Array Bounds Checks optimization for the compiler. (The answer is easy: Can you spell &quot;G-P-F&quot;?) 
</blockquote></div>
</p>

<p>Now you can assign and retrieve up to 10 distinct notes for the same 
person, as in this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>pers.Notes(1) = &quot;Ask if it's OK to go fishing next Sunday&quot;
Print pers.Notes(2) ' Displays &quot;&quot; (not initialized)
</pre>
</td></tr>
</table>
</p>

<p>You can improve this mechanism by making <I>Index</I> an optional argument that defaults to the first item in the array, as in the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Property Get Notes(Optional Index As Integer = 1) As String
    ' ... (omitted: no need to change code inside the procedure)
End Property
Property Let Notes(Optional Index As Integer = 1, _
    ByVal newValue As String)
    ' ... (omitted : no need to change code inside the procedure)
End Property

' In the client code, you can omit the index for the default note.
pers.Notes = &quot;Ask if it's OK to go fishing next Sunday&quot;
' You can always display all notes with a simple For-Next loop.
For i = 1 To 10: Print pers.Notes(i): Next
</pre>
</td></tr>
</table>
</p>


<p>You can also use optional Variant arguments and the <I>IsMissing</I> function, as you would do for regular procedures in a form or standard module. In practice, this is rarely required, but it's good to know that you can do it if you need to.</p>

<A NAME="232"><h3>Properties as Public variables in a class</h3></A>

<p>I have already described the convenience of using <I>Property Get</I> and <I>Let </I>procedures instead of plain Public variables in a class: You get more control, you can validate data assigned to the property, you can trace the execution flow, and so on. But here's one more interesting detail that you should be aware of. Even if you declare a Public variable, what Visual Basic actually does is create a hidden pair of Property procedures for you and calls them whenever you reference the property from outside the class:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Inside the CPerson class
Public Height As Single  ' Height in inches

' Outside the class
pers.Height = 70.25      ' This calls a hidden Property Let procedure.
</pre>
</td></tr>
</table>
</p>


<p>Apart from a slight performance hit&#8212;invoking a procedure is surely slower 
than accessing a variable&#8212;this Visual Basic behavior doesn't appear to be a detail 
worth mentioning. Unfortunately, this isn't the case. Let's suppose that you want to 
convert all your measurements into centimeters, so you prepare a simple procedure that 
does the job with its <I>ByRef</I> argument:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In a standard BAS module
Sub ToCentimeters (value As Single)
    ' Value is received by reference, therefore it can be changed.
    value = value * 2.54
End Sub
</pre>
</td></tr>
</table>
</p>


<p>You think you can legitimately expect an easy conversion for your objects' 
properties, as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>ToCentimeters pers.Height                ' Doesn't work!
</pre>
</td></tr>
</table>
</p>

<p>The reason the preceding approach fails should be clear, now that you know that Public variables are implemented as hidden procedures. In fact, when you pass the <I>pers.Height </I>value to the <I>ToCentimeters </I>procedure you're passing the result of an expression, not an actual memory address. Therefore, the routine has no address to which to deliver the new value, and the result of the conversion is lost.</p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>Microsoft changed the way the Public variables in class 
modules are implemented. In Visual Basic 4, these variables weren't encapsulated 
in hidden property procedures; therefore, they could be modified if passed to 
a procedure through a <I>ByRef</I> argument. This implementation detail changed 
when Visual Basic 5 was released, and many Visual Basic 4 programmers had to 
rework their code to comply with the new style by creating a temporary 
variable that actually receives the new value:

<p><table><tr><td>
<pre>
' The fix that VB4 developers had to apply when porting to VB5
Dim temp As Single
temp = pers.Height
ToCentimeter temp
pers.Height = temp
</pre>
</td></tr></table>
</p>

<p>This code is neither elegant nor efficient. Worse, since this technique 
isn't clearly documented, many programmers had to figure it out on their own. If 
you are about to port some Visual Basic 4 code to versions 5 or 6, don't be 
caught off guard.</p>
</blockquote></div>
</p>

<p>Anyway, here's yet another untold episode of the story. What I have 
described so far is what happens when you reference the Public variable from 
<I>outside </I>the class. If you invoke the external procedure from inside the class module and pass it your variable, everything works as expected. In other words, you can write this code 
in the CPerson class:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Inside the CPerson class
ToCentimeter Height                ' It works!
</pre>
</td></tr>
</table>
</p>

<p>and the <I>Height</I> property will be correctly updated. In this case, the value passed 
is the address of the variable, not the return value of a hidden procedure. This point 
is important if you want to move code from outside the class to inside the class (or 
vice versa) because you must be prepared to deal with subtle issues like this one.</p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>One last note, just to add confusion to confusion: If you prefix 
the properties in your class module with the <I>Me 
</I>keyword, they're again seen as properties instead of variables and Visual Basic invokes the hidden procedure 
instead of using the variable address. Therefore, this code won't work even inside 
the class module:

<p><table><tr><td>
<pre> ToCentimeter Me.Height             ' It doesn't work!
</pre>
</td></tr>
</table>
</p>
</blockquote></div>
</p>

<A NAME="233"><h2>Advanced Uses of Methods</h2></A>

<p>You already know a lot about methods. There are, however, a few more interesting details that you should be aware of concerning how methods can be used within a class module.</p>


<A NAME="234"><h3>Saving results for subsequent calls</h3></A>

<p>Let's say that you have a function that returns a complex value&#8212;for example, the 
grand total of an invoice&#8212;and you don't want to reevaluate it each time the client code 
makes a request. On the other hand, you don't want to store it somewhere and run the risk that its value becomes obsolete because some other property of the invoice changes. This is similar to the decision that a database developer has to make: Is it better to create a <I>GrandTotal </I>field that contains the actual value (thus putting the consistency of the database at stake and also wasting some disk space) or to evaluate the total each time you need it (thus wasting CPU time each time you do it)?</p>
<p>Class modules offer a simple and viable alternative that applies equally well to all dependent values, be they implemented as functions or read-only properties. As an example, reconsider the <I>ReverseName</I> function in the CPerson<I> </I>class, and pretend that it takes a lot of processing time to evaluate its result. Here's how you can modify this function to keep the overhead to a minimum without modifying the interface that the class exposes to the outside. (Added statements are in boldface.)</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre><B>' A private member variable
Private m_ReverseName As Variant</B>

Property Let FirstName(ByVal newValue As String)
    ' Raise an error if an invalid assignment is attempted.
    If newValue = &quot;&quot; Then Err.Raise 5    ' Invalid procedure argument
    ' Else store in the Private member variable.
    m_FirstName = newValue
<B>    m_ReverseName = Empty</B>
End Property

Property Let LastName(ByVal newValue As String)
    ' Raise an error if an invalid assignment is attempted.
    If newValue = &quot;&quot; Then Err.Raise 5    ' Invalid procedure argument
    ' Else store in the Private member variable.
    m_LastName = newValue
<B>    m_ReverseName = Empty</B>
End Property

Function ReverseName() As String
<B>    If IsEmpty(m_ReverseName) Then
        m_ReverseName = LastName &#38;; &quot;, &quot; &#38;; FirstName
    End If
    ReverseName = m_ReverseName</B>
End Function
</pre>
</td></tr>
</table>
</p>


<p>In other words, you store the return value in a Private Variant variable 
before returning to the client and reuse that value if possible in all subsequent calls. 
The trick works because each time either <I>FirstName</I> or <I>LastName</I> (the <I>independent 
</I>properties) are assigned a new value, the Private variable is cleared, which forces it to 
be reevaluated the next time the <I>ReverseName</I> function is invoked. Examine this 
simple client code and try to figure out how difficult it would have been to 
implement equivalent logic using other techniques:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' This line takes some microseconds the first time it is executed.
If pers.ReverseName &lt;&gt; &quot;Smith, John&quot; Then 
    ' If this line is executed, it internally resets m_ReverseName.
    pers.FirstName = &quot;Robert&quot;
End If
' In all cases, the next statement will be as fast as possible.
Print pers.ReverseName
</pre>
</td></tr>
</table>
</p>

<p>Of course, we might have also reevaluated the <I>m_ReverseName</I> value right in the <I>Property 
Let</I> procedures of <I>FirstName </I>and <I>LastName</I>, but that would undermine our main purpose, which is to avoid unnecessary overhead or postpone it as long as possible. In a real-world application, this difference might involve unnecessarily opening a database, reestablishing a remote connection, and so on, so it's apparent that the advantages of this technique shouldn't be underestimated.</p>

<A NAME="235"><h3>Simulating class constructors</h3></A>

<p>So far, I've explained that a class can be considered robust if it always contains 
valid data. The primary way to achieve this goal is to provide Property procedures 
and methods that permit the outside code to transform the internal data only from 
one valid state to another valid state. In this reasoning, however, is a dangerous 
omission: What happens if an object is used immediately after its creation? You can provide 
some useful initial and valid values in the <I>Class_Initialize</I> event procedure, but this 
doesn't ensure that all the properties are in a valid state:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Set pers = New CPerson
Print pers.CompleteName            ' Displays an empty string.
</pre>
</td></tr>
</table>
</p>

<p>In more mature OOPLs such as C++, this issue is solved by the language's ability to define a <I>constructor method</I>. A constructor method<I> </I>is a special procedure defined in the class module and executed whenever a new instance is created. Because you define the syntax of the constructor method, you can force the client code to pass all the values that are needed to create the object in a robust state from its very beginning, or refuse to create the object at all if values are missing or invalid. </p>

<p>Alas, Visual Basic completely lacks constructor methods, and you can't prevent users of your class from using the object as soon as they create it. The best you can do is create a <I>pseudo-constructor </I>method that correctly initializes all the properties and let other programmers know that they can initialize the object in a more concise and robust way:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Friend Sub Init(FirstName As String, LastName As String)
    Me.FirstName = FirstName
    Me.LastName = LastName
End Sub
</pre>
</td></tr>
</table>
</p>


<p>Your invitation should be gladly accepted because now the client code 
can initialize the object in fewer steps:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Set pers = New CPerson
pers.Init &quot;John&quot;, &quot;Smith&quot;
</pre>
</td></tr>
</table>
</p>


<p>Two issues are worth noting in the preceding code. First, the scope of 
the method is Friend: This doesn't make any difference in this particular case, but it 
will become important when and if the class becomes Public and accessible from 
the outside, as we'll see in <a href="ch16a.htm">Chapter 16</a>. In Standard EXE projects, Friend and Public 
are synonymous; using the former doesn't hurt, and you'll save a lot of work if you 
later decide to transform the project into an ActiveX component.</p>

<p>The second noteworthy point is that arguments have the same names as the properties they refer to, which makes our pseudo-constructor easier to use for the programmer who already knows the meaning of each property. To avoid a name conflict, inside the procedure you refer to the real properties using the <I>Me</I> keyword. This is slightly less efficient but preserves the data encapsulation and ensures that any validation code will be properly executed when the constructor routine assigns a value to properties.</p>

<p>The concept of constructors can be refined by using optional arguments. The key properties of our CPerson class are undoubtedly <I>FirstName</I> and <I>LastName</I>, but in many cases the client code will also set <I>BirthDate</I> and <I>ID.</I> So why not take this opportunity to make life easier for the programmer who uses the class?</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Friend Sub Init(FirstName As String, LastName As String, _
    Optional ID As Variant, Optional BirthDate As Variant)
    Me.FirstName = FirstName
    Me.LastName = LastName
    If Not IsMissing(ID) Then Me.ID = ID
    If Not IsMissing(BirthDate) Then Me.BirthDate = BirthDate
End Sub
</pre>
</td></tr>
</table>
</p>


<p> In this case, you must adopt optional arguments of type Variant because it 
is essential that you use the <I>IsMissing</I> function and bypass the assignment of values 
that were never provided by the client:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>pers.Init &quot;John&quot;, &quot;Smith&quot;, , &quot;10 Sept 1960&quot;
</pre>
</td></tr>
</table>
</p>


<p>You can do one more thing to improve the class's usability and acceptance 
by other programmers. This point is really important because if you convince the 
user of your class to call the constructor you provide&#8212;and you must choose this 
&quot;softer&quot; approach, since you can't force them to&#8212;your code and the entire application will be more robust. The trick I'm suggesting is that you write a constructor function 
in a BAS module in your application:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Public Function New_CPerson(FirstName As String, LastName As String, _
    Optional ID As Variant, Optional BirthDate As Variant) As CPerson
    ' You don't even need a temporary local variable.
    Set New_CPerson = New CPerson
    New_CPerson.Init FirstName, LastName, ID, BirthDate
End Function
</pre>
</td></tr>
</table>
</p>


<p>Procedures of this type are sometimes called 
<I>factory methods</I>. Now see how this can streamline the portion of the client code that creates an instance of the class:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim pers As CPerson
' Creation, initialization, and property validation in one step!
Set pers = New_CPerson(&quot;John&quot;, &quot;Smith&quot;, , &quot;10 Sept 1960&quot;)
</pre>
</td></tr>
</table>
</p>


<p><div class="tip"><blockquote><b>TIP</b><hr>
You can reduce the typing and the guesswork when using these 
sort-of constructors if you gather them into a single BAS module and give this 
module a short name, such as <I>Class</I> or 
<I>Factory</I>. (You can't use <I>New</I>, sorry.) Then 
when you need to type the name of a constructor method, you just type 
<I>Class</I> and let Microsoft IntelliSense guide you through the list of constructor methods 
contained in that module. You can use this approach anytime you don't remember the 
name of a procedure in a module.
</blockquote></div>
</p>

<p>Creating all your objects by means of explicit constructors has other 
benefits as well. For example, you can easily add some trace statements in the 
<I>New_CPerson</I> routine that keeps track of how many objects were created, the initial values of 
properties, and so on. Don't underestimate this capability if you're writing complex 
applications that use many class modules and object instances.</p>

<A NAME="236"><h2>Advanced Uses of Properties</h2></A>

<p>I want to tell you more about properties that can make your classes even more useful and powerful.</p>

<A NAME="237"><h3>Enumerated properties</h3></A>

<p>Some properties are intended to return a well-defined subset of integer numbers. 
For example, you could implement a <I>MaritalStatus </I>property that can be assigned the values 1 (NotMarried), 2 (Married), 3 (Divorced), and 4 (Widowed). The best solution possible under Visual Basic 4 was to define a group of constants and consistently use them in the code both inside and outside the class. This practice, however, forced the developer to put the <I>CONST</I> directives in a separate BAS module, which broke the self-containment of the class.</p>

<p>Visual Basic 5 solved this issue by adding a new <I>Enum</I> keyword to the VBA language and thus the ability to create 
<I>enumerated values</I>. An <I>Enum </I>structure is nothing but a group of related constant values that automatically take distinct values:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the declaration section of the class
Enum MaritalStatusConstants
    NotMarried = 1
    Married
    Divorced
    Widowed
End Enum
</pre>
</td></tr>
</table>
</p>


<p>You don't need to assign an explicit value to all the items in the <I>Enum</I> structure: for all the subsequent omitted values, Visual Basic just increments the preceding value. (So in the previous code, Married is assigned the value 2, Divorced is 3, and so on.) If you also omit the first value, Visual Basic starts at 0. But because 0 is the default value for any integer property when the class is created, I always prefer to stay clear of it so that I can later trap any value that hasn't been initialized properly.</p>

<p>After you define an <I>Enum</I> structure, you can create a Public property of 
the corresponding type:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private m_MaritalStatus As MaritalStatusConstants

Property Get MaritalStatus() As MaritalStatusConstants
    MaritalStatus = m_MaritalStatus
End Property
Property Let MaritalStatus(ByVal newValue As MaritalStatusConstants)
    ' Refuse invalid assignments. (Assumes that 0 is always invalid.)
    If newValue &lt;= 0 Or newValue &gt; Widowed Then Err.Raise 5
    m_MaritalStatus = newValue
End Property
</pre>
</td></tr>
</table>
</p>


<p>The benefit of using enumerated properties becomes apparent when you 
write code that uses them. In fact, thanks to IntelliSense, as soon as you press the 
equal sign key (or use any other math or Boolean operator, for that matter), the Visual 
Basic editor drops down a list of all the available constants, as you can see in Figure 
6-3. Moreover, all the <I>Enum</I>s you define immediately appear in the Object Browser, 
so you can check the actual value of each individual item there.</p>

<p>
<A HREF="javascript:fullSize('F06ph03x.htm')"> <img src="images/F06ph03.JPG" width=404 height=243 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 6-3.</B> <i>Use IntelliSense to speed up your typing when working with Enum properties.</i><!--/caption-->
</p>

<p>Here are a few details you must account for when dealing with 
<I>Enum</I> values:</p>
<UL>

<p><li> All variables and arguments are internally managed as Longs. As far 
as Visual Basic is concerned, they <I>are </I>Longs and their symbolic names 
are just a convenience for the programmer.</li></p>

<p><li> For the same reason, you can assign an enumerated variable or property any valid 32-bit integer value without raising an error. If you want to enforce a better validation, you must explicitly validate the input data in all your <I>Property Let</I> procedures, as you do with any other property.</li></p>

<p><li> <I> Enum</I> structures aren't exclusively used with properties. In fact, you 
can also create methods that accept enumerated values as one of their arguments or that return enumerated values.</li></p>

<p><li> <I>     Enum</I> blocks can be Public or Private to a class, but it rarely makes 
sense to create a Private <I>Enum</I> because it couldn't be used for any argument 
or return value of a Public property or method. If the class is itself Public&#8212;in an ActiveX EXE or DLL project, for example&#8212;programmers who use the class can browse all the public <I>Enum</I>s in the class using a standard Object Browser.</li></p>

<p><li> It isn't essential that the <I>Enum</I> block be physically located in the same class module that uses it. For example, a class module can include an <I>Enum</I> used by other classes. But if you're planning to make your class Public (see previous point), it's important that all the 
<I>Enum</I>s that it uses are defined in other Public classes. If you put them in a Private 
module or a standard BAS module, you'll get a compile error when you run the application, which you can see in Figure 6-4.</li></p>
</UL>

<p>
<A HREF="javascript:fullSize('F06ph04x.htm')"> <img src="images/F06ph04.JPG" width=404 height=117 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 6-4.</B> <i>You can't use Enum values in a Public class if the Enum block is located in a form module, in a Private class, or in a standard BAS module.</i><!--/caption-->
</p>


<UL>

<p><li> Never forget that <I>Enum</I>s are just shortcuts for creating constants. 
This means that all the enumerated constants defined within an 
<I>Enum </I>block should have unique names in their scope. (Because 
<I>Enums </I>are typically Public structures, their scope is often the entire application.)
</li></p>
</UL>

<p>The last point is especially important, and I strongly advise you to devise a method for generating unique names for all your enumerated constants. If you fail to do that, the compiler refuses to compile your application and raises the &quot;Ambiguous name detected: &lt;itemname&gt;&quot; error. The easy way to avoid this problem is to add to all the enumerated constants a unique 2- or 3-letter prefix, for example:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Enum SexConstants
    sxMale = 1
    sxFemale
End Enum
</pre>
</td></tr>
</table>
</p>


<p>The other way to avoid trouble is to use the complete 
<I>enumname.constantname </I>syntax whenever you refer to an ambiguous 
<I>Enum</I> member, as in the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>pers.MaritalStatus = MaritalStatusConstants.Married
</pre>
</td></tr>
</table>
</p>


<p><I>Enum</I> values don't need to be in an increasing sequence. In fact, you can 
provide special values out of the expected order to signal some special conditions, 
as in the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In a hypothetical Order class
Enum OrderStatusConstants
    osShipping = 1
    osBackOrder 
    osError = -9999   ' Tip: use negative values for such special cases.
End Enum
</pre>
</td></tr>
</table>
</p>


<p>Another common example of enumerated properties whose values aren't 
in sequence are <I>bit-fielded </I>properties, as in this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Enum FileAttributeConstants
    Normal = 0              ' Actually means &quot;no bit set&quot;
    ReadOnly = 1            ' Bit 0
    Hidden = 2              ' Bit 1
    System = 4              ' Bit 2 
    Directory = 16          ' Bit 3
    Archive = 32            ' Bit 4
End Enum
</pre>
</td></tr>
</table>
</p>


<p>While enumerated properties are very useful and permit you to store some descriptive information in just 4 bytes of memory, you shouldn't forget that sooner or later you'll have to extract and interpret this information and sometimes even show it to your users. For this reason, I often add to my classes a read-only property that returns the textual description of an enumerated property:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Property Get MaritalStatusDescr() As String
    Select Case m_MaritalStatus
        Case NotMarried: MaritalStatusDescr = &quot;NotMarried&quot;
        Case Married: MaritalStatusDescr = &quot;Married&quot;
        Case Divorced: MaritalStatusDescr = &quot;Divorced&quot;
        Case Widowed
            If Sex = Male Then     ' Be precise for your users.
                MaritalStatusDescr = &quot;Widower&quot;
            ElseIf Sex = Female Then
                MaritalStatusDescr = &quot;Widow&quot;
            End If
<B>        Case Else
            Err.Raise 5            ' Defensive programming!</B>
    End Select
End Property
</pre>
</td></tr>
</table>
</p>


<p>It seems a lot of work for such a little piece of information, but you'll be 
glad that you did it every time you have to show the information on screen or in a 
printed report. You might wonder why I added a <I>Case Else</I> block (shown in boldface). After all, the <I>m_MaritalStatus</I> variable can't be assigned a value outside its range 
because it's protected by the <I>Property Let MaritalStatus</I> procedure, right? But you should 
never forget that a class is often an evolving entity, and what's true today might 
change tomorrow. All the validation code that you use for testing the valid range of 
such properties might become obsolete without your even noticing it. For example, 
what happens if you later add a fifth <I>MaritalStatus</I> constant? Are you really going to 
hunt through your code for possible bugs each and every time you add a new enumerated value? Explicitly testing all the values in a <I>Select Case</I> block and rejecting those that fall through the <I>Case Else</I> clause is a form of defensive programming that you should always exercise if you don't want to spend more time debugging the code later.</p>

<p>Here's an easy trick that lets you safely add new constants without also modifying the validation code in the corresponding <I>Property Let</I> procedure. Instead of testing against the largest constant, just define it explicitly in the <I>Enum</I> structure:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Enum MaritalStatusConstants
    NotMarried = 1
    Married
    Divorced
    Widowed
    MARITALSTATUS_MAX = Widowed    ' Uppercase is easier to spot.
End Enum

Property Let MaritalStatus(ByVal newValue As MaritalStatusConstants)
    ' Refuse invalid assignments. (Assumes that 0 is always invalid.)
    If newValue &lt;= 0 Or newValue &gt; MARITALSTATUS_MAX Then Err.Raise 5
    m_MaritalStatus = newValue
End Property
</pre>
</td></tr>
</table>
</p>


<p>When you then append constants to the <I>Enum</I> block, you need to make the MARITALSTATUS_MAX item point to the new highest value. If you add a comment, as in the preceding code, you can hardly miss it.</p>

<A NAME="238"><h3>Properties that return objects</h3></A>

<p>Visual Basic's own objects might expose properties that return object values. 
For example, forms and all visible controls expose a <I>Font</I> property, which in turn returns a Font object. You realize that this is a special case because you can append a dot to the property name and have IntelliSense tell you the names of the properties of the object:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Form1.Font.Bold = True
</pre>
</td></tr>
</table>
</p>


<p>What Visual Basic does with its own objects can also be done with your custom classes. This adds a great number of possibilities to your object-oriented programs. For example, your CPerson<I> </I>class still lacks an <I>Address</I> property, so it's time to add it. In most cases, a single 
<I>Address</I> string doesn't suffice to point exactly to where a person lives, and you usually need several pieces of related information. Instead of adding multiple properties to the CPerson object, create a new CAddress class:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The CAddress class module
Public Street As String
Public City As String
Public State As String
Public Zip As String
Public Country As String
Public Phone As String
Const Country_DEF = &quot;USA&quot;  ' A default for Country property

Private Sub Class_Initialize()
    Country = Country_DEF
End Sub
Friend Sub Init(Street As String, City As String, State As String, _
    Zip As String, Optional Country As Variant, Optional Phone As Variant)
    Me.Street = Street
    Me.City = City
    Me.State = State
    Me.Zip = Zip
    If Not IsMissing(Country) Then Me.Country = Country
    If Not IsMissing(Phone) Then Me.Phone = Phone
End Sub
Property Get CompleteAddress() As String
    CompleteAddress = Street &#38;; vbCrLf &#38;; City &#38;; &quot;, &quot; &#38;; State &#38;; &quot; &quot; &#38;; Zip _
        &#38;; IIf(Country &lt;&gt; Country_DEF, Country, &quot;&quot;)
End Property
</pre>
</td></tr>
</table>
</p>


<p>For the sake of simplicity, all properties have been declared Public items, 
so this class isn't particularly robust. In a real-world example, a lot of nice things 
could be done to make this class a great piece of code, such as checking that the 
<I>City</I>, <I>State</I>, and <I>Zip</I> properties are compatible with one another. (You probably need a lookup search against a database for this.) You could even automatically provide an area 
code for the <I>Phone</I> property. I gladly leave these enhancements as an exercise to 
readers. For now, let's focus on how you can exploit this new class together with 
CPerson. Adding a new <I>HomeAddress</I> property to our CPerson class requires just one line 
of code in the declaration section of the module:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the CPerson class module
Public HomeAddress As CAddress
</pre>
</td></tr>
</table>
</p>


<p>Now you can create a CAddress object, initialize its properties, and then 
assign it to the <I>HomeAddress</I> property just created. Thanks to the 
<I>Init</I> pseudo-constructor, you can considerably reduce the amount of code that's actually needed in the client:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim addr As CAddress
Set addr = New CAddress
addr.Init &quot;1234 North Rd&quot;, &quot;Los Angeles&quot;, &quot;CA&quot;, &quot;92405&quot;
Set pers.HomeAddress = addr
</pre>
</td></tr>
</table>
</p>


<p>While this approach is perfectly functional and logically correct, it's 
somehow unnatural. The problem stems from having to explicitly create a CAddress 
object before assigning it to the <I>HomeAddress</I> property. Why not work directly with 
the <I>HomeAddress</I> property?</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Set pers.HomeAddress = New CAddress
pers.HomeAddress.Init &quot;1234 North Rd&quot;, &quot;Los Angeles&quot;, &quot;CA&quot;, &quot;92405&quot;
</pre>
</td></tr>
</table>
</p>


<p>When you work with nested object properties, you'll like the 
<I>With...End With</I> clause:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>With pers.HomeAddress
    .Street = &quot;1234 North Rd&quot;
    .City = &quot;Los Angeles&quot;
    ' etc.
End With
</pre>
</td></tr>
</table>
</p>


<p>As I showed you previously, you can provide an independent 
constructor method in a standard BAS module (not shown here) and do without a separate 
<I>Set </I>statement:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Set pers.HomeAddress = New_CAddress(&quot;1234 North Rd&quot;, &quot;Los Angeles&quot;, _
    &quot;CA&quot;, &quot;92405&quot;)
</pre>
</td></tr>
</table>
</p>


<A NAME="239"><h3><I>Property Set</I> procedures</h3></A>

<p>A minor problem that you have to face is the lack of control over what can be assigned to the <I>HomeAddress</I> property. How can you be sure that no program will compromise the robustness of your CPerson object by assigning an incomplete or invalid CAddress object to the <I>HomeAddress</I> property? And what if you need to make the <I>HomeAddress</I> property read-only?</p>

<p>As you see, these are the same issues that you faced when working with regular, nonobject properties, which you resolved thanks to <I>Property Get</I> and <I>Property Let</I> procedures. So it shouldn't surprise you to learn that you can do the same with object properties. The only difference is that you use a third type of property procedure, the <I>Property Set</I> procedure, instead of the <I>Property Let</I> procedure:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim m_HomeAddress As CAddress      ' A module-level private variable.

Property Get HomeAddress() As CAddress
    Set HomeAddress = m_HomeAddress
End Property
Property Set HomeAddress(ByVal newValue As CAddress)
    Set m_HomeAddress = newValue
End Property
</pre>
</td></tr>
</table>
</p>


<p>Because you're dealing with object references, you must use the 
<I>Set </I>keyword in both procedures. A simple way to ensure that the CAddress object being 
assigned to the <I>HomeAddress </I>property is valid is to try out its 
<I>Init</I> method with all the required properties:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Property Set HomeAddress(ByVal newValue As CAddress)
    With newValue
        .Init .Street, .City, .State, .Zip
    End With
    ' Do the assignment only if the above didn't raise an error.
    Set m_HomeAddress = newValue
End Property
</pre>
</td></tr>
</table>
</p>


<p>Unfortunately, protecting an object property from invalid assignments isn't 
as simple as it appears. If the innermost class&#8212;<I>CAddress</I> in this case&#8212;doesn't 
protect itself in a robust way, the outermost class can do little or nothing. To explain 
why, just trace this apparently innocent statement:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>pers.HomeAddress.Street = &quot;&quot;  ' An invalid assignment raises no error.
</pre>
</td></tr>
</table>
</p>


<p>At first, you might be surprised to see that execution doesn't flow through 
the <I>Property Set HomeAddress</I> procedure; instead, it goes through the 
<I>Property Get</I> <I>HomeAddress</I> procedure, which seems nonsensical because we are 
<I>assigning </I>a value, not reading it. But if we look at the code from a compiler's standpoint, things are different. The language parser scans the line from left to right: it first finds a reference to a property exposed by the CPerson class (that is, <I>pers.HomeAddress</I>) and tries to resolve it to determine what it's pointing to. For this reason, it has to evaluate 
the corresponding <I>Property Get</I> procedure. The result is that you can't effectively use 
the <I>Property Get HomeAddress</I> procedure to protect the CPerson<I> </I>class module from invalid addresses: you must protect the CAddress dependent class itself. In a sense, 
this is only fair because each class should be responsible for itself.</p>

<p>Let's see how you can use the CAddress<I> </I>class to improve the CPerson class 
even further. You have already used it for the <I>HomeAddress </I>property, but there are other possible applications:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In the declaration section of CPerson
Private m_WorkAddress As CAddress
Private m_VacationAddress As CAddress
' Corresponding Property Get/Set are omitted here....
</pre>
</td></tr>
</table>
</p>


<p>It's apparent that you have achieved a lot of functionality with minimal 
effort. Not only have you dramatically reduced the amount of code in the CPerson class 
(you need only three pairs of <I>Property Get/Set</I> procedures), you also simplified its 
structure because you don't have a large number of similar properties with confusing names (<I>HomeAddressStreet</I>, <I>WorkAddressStreet</I>, and so on). But above all, you 
have the logic for the CAddress entity in one single place, and it has been 
automatically propagated elsewhere in the application, without your having to set up distinct 
validation rules for each distinct type of address property. Once you have assigned 
all the correct addresses, see how easy it is to display all of them:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>On Error Resume Next
' The error handler skips unassigned (Nothing) properties.
Print &quot;Home: &quot; &#38;; pers.HomeAddress.CompleteAddress
Print &quot;Work: &quot; &#38;; pers.WorkAddress.CompleteAddress
Print &quot;Vacation: &quot; &#38;; pers.VacationAddress.CompleteAddress
</pre>
</td></tr>
</table>
</p>


<A NAME="240"><h3>Variant properties</h3></A>

<p>Properties that return Variant values aren't different from other properties: You 
just need to declare a Public Variant member and you're done. But things are a bit 
more complex if the property can receive either a regular value or an object value. 
For example, say that you want to implement a <I>CurrentAddress</I> property, but you want to keep it more flexible and capable of storing either a CAddress object or a simpler string, as in this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The client code can assign a regular string
pers.CurrentAddress = &quot;Grand Plaza Hotel, Rome&quot;
' or a reference to another CAddress object (requires Set).
Set pers.CurrentAddress = pers.VacationAddress
</pre>
</td></tr>
</table>
</p>


<p>While this sort of flexibility adds a lot of power to your class, it also reduces 
its robustness because nothing keeps a programmer from adding a nonstring value 
or an object of a class other than CAddress. To be more in control of what is 
actually assigned to this property, you need to arbitrate all accesses to it through 
Property procedures. But in this case, you need <I>three </I>distinct Property procedures:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Private m_CurrentAddress As Variant

Property Get CurrentAddress() As Variant
    If IsObject(m_CurrentAddress) Then
        Set CurrentAddress = m_CurrentAddress   ' Return a CAddress object.
    Else
        CurrentAddress = m_CurrentAddress       ' Return a string.
    End If
End Property

Property Let CurrentAddress(ByVal newValue As Variant)
    m_CurrentAddress = newValue
End Property

Property Set CurrentAddress(ByVal newValue As Variant)
    Set m_CurrentAddress = newValue
End Property
</pre>
</td></tr>
</table>
</p>


<p>The <I>Property Let</I> procedure is invoked when a regular value is assigned to 
the property, while the <I>Property Set</I> procedure comes into play when the client 
assigns an object with a <I>Set</I> command. Note how the 
<I>Property Get</I> procedure returns a value to the caller code: It has to test whether the private variable currently contains 
an object, and it must use a <I>Set</I> command if it does. The <I>Property Let</I> and <I>Set </I>pair lets you enforce a better validation scheme:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Property Let CurrentAddress(ByVal newValue As Variant)
    ' Check that it is a string value.
    If VarType(newValue) &lt;&gt; vbString Then Err.Raise 5
    m_CurrentAddress = newValue
End Property

Property Set CurrentAddress(ByVal newValue As Variant)
    ' Check that it is a CAddress object.
    If TypeName(newValue) &lt;&gt; &quot;CAddress&quot; Then Err.Raise 5
    Set m_CurrentAddress = newValue
End Property
</pre>
</td></tr>
</table>
</p>

<p>Here's a technique that lets you save some code and slightly improve run-time performances. The trick is to declare the type of the object you're expecting right in the parameter list of the <I>Property Set</I> procedure, as in this code:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Property Set CurrentAddress(ByVal newValue As CAddress)
    Set m_CurrentAddress = newValue
End Property
</pre>
</td></tr>
</table>
</p>

<p>You can't use this approach in all circumstances; for example, you can't use 
it when you're willing to accept two or more objects of different types. In that 
case, it's best to use an <I>As Object</I> parameter:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Property Set CurrentAddress(ByVal newValue As Object)
    If TypeName(newValue) &lt;&gt; &quot;CAddress&quot; And TypeName(newValue) &lt;&gt; _
        &quot;COtherType&quot; Then Err.Raise 5
    Set m_CurrentAddress = newValue
End Property</pre>
</td></tr>
</table>
</p>

<p>As far as Visual Basic is concerned, the 
<I>real</I> type is determined by the value declared in the 
<I>Property Get</I> procedure. In fact, that's the type reported in 
the Object Browser.</p>

<A NAME="241"><h3>Properties in BAS modules</h3></A>

<p>While this fact is undocumented in Visual Basic manuals, you can create 
Property procedures in standard BAS modules as well. This capability makes a few 
interesting techniques possible. You can use a pair of Property procedures to encapsulate 
a global variable and arbitrate all accesses to it. Let's say that you have a global 
<I>Percent </I>variable:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' In a standard BAS module
Public Percent As Integer
</pre>
</td></tr>
</table>
</p>


<p>For really robust code, you want to be sure that all values assigned to it are 
in the proper 0 through 100 range, but you don't want to test all the assignment 
statements in your code. The solution is easy, as you'll see in the next section.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim m_Percent As Integer

Property Get Percent() As Integer
    Percent = m_Percent
End Property
Property Let Percent(newValue As Integer)
    If newValue &lt; 0 Or newValue &gt; 100 Then Err.Raise 5
    m_Percent = newValue
End Property
</pre>
</td></tr>
</table>
</p>

<p>Other interesting variations of this technique are read-only and 
write-once/read-many global variables. You can also use this technique to work around the 
inability of Visual Basic to declare string constants that contain 
<I>Chr$</I> functions and concatenation operators:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' You can't do this with a CONST directive.
Property Get DoubleCrLf() As String
    DoubleCrLf = vbCrLf &#38;; vbCrLf
End Property
</pre>
</td></tr>
</table>
</p>


<p>Finally, you can use Property procedures in BAS modules to trace what happens to the global variables in your code. Let's say that your code incorrectly assigns a wrong value to a global variable, and you want to understand when this happens. Just replace the variable with a pair of Property procedures, and add <I>Debug.Print</I> statements as required (or print values to a file, if you want). When you have fixed all the problems, delete the procedures and restore the original global variable. The best thing about all this is that you won't need to edit a single line of code in the rest of your application.</p>

<A NAME="242"><h2>The <I>CallByName</I> Function</h2></A>
<p><img src="images/new.jpg" width=102 height=87 border="0"></p>

<p>Visual Basic 6 includes a welcome addition to the VBA language, in the form of 
the <I>CallByName</I> function. This keyword lets you reference an object's method or 
property by passing its name in an argument. Its syntax is as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>result = CallByName(object, procname, calltype [,arguments..])
</pre>
</td></tr>
</table>
</p>


<p>where <I>procname </I>is the name of the property or method, and 
<I>calltype </I>is one of the following constants: 1-vbMethod, 2-vbGet, 4-vbLet, 8-vbSet. You must pass any argument the method is expecting, and you should avoid retrieving a return value if 
you're invoking a Sub method or a <I>Property Let/Get</I> procedure. Here are a few examples:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim pers As New CPerson
' Assign a property.
CallByName pers, &quot;FirstName&quot;, vbLet, &quot;Robert&quot;
' Read it back.
Print &quot;Name is &quot; &#38;; CallByName(pers, &quot;FirstName&quot;, vbGet)
' Invoke a function method with one argument.
width = CallByName(Form1, &quot;TextWidth&quot;, vbMethod, &quot;ABC&quot;)
</pre>
</td></tr>
</table>
</p>

<p>Here are a couple of noteworthy bits of information about this function, 
both of which affect its usefulness:</p>
<UL>

<p><li> While adding a lot of flexibility when dealing with an object, neither 
the <I>CallByName</I> function nor the VBA language as a whole is able to 
<I>retrieve </I>the list of the properties and methods exposed by an object. So in 
this sense the <I>CallByName</I> function is only a half-solution to the 
problem because you have to build the property names yourself. If you know 
these names in advance, you might invoke your properties and methods 
directly, using the familiar dot syntax.</li></p>

<p><li> The <I>CallByName</I> function invokes the object's member using a late 
binding mechanism (see &quot;<A HREF="ch06d.htm#254">The Binding Mechanism</A>&quot; later in this chapter), 
which is considerably slower than regular access through the dot syntax.</li></p>
</UL>


<p>As a general rule, you should never use the <I>CallByName</I> function when you can reach the same result using the regular dot syntax. There are times, however, when this function permits you to write very concise and highly parameterized code. One interesting application is quickly setting a large number of properties for controls on a form. This might be useful when you give your users the ability to customize a form and you then need to restore the last configuration in the 
<I>Form_Load</I> event. I have prepared a couple of reusable procedures that do the job:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Returns an array of &quot;Name=Values&quot; strings 
' Supports only nonobject properties, without indices
Function GetProperties(obj As Object, ParamArray props() As Variant) _
    As String()
    Dim i As Integer, result() As String
    On Error Resume Next
    ' Prepare the result array.
    ReDim result(LBound(props) To UBound(props)) As String
    ' Retrieve all properties in turn.
    For i = LBound(props) To UBound(props)
        result(i) = vbNullChar
        ' If the call fails, this item is skipped.
        result(i) = props(i) &#38;; &quot;=&quot; &#38;; CallByName(obj, props(i), vbGet)
    Next
    ' Filter out invalid lines.
    GetProperties = Filter(result(), vbNullChar, False)
End Function

' Assign a group of properties in one operation.
' Expects an array in the format returned by GetProperties
Sub SetProperties(obj As Object, props() As String)
    Dim i As Integer, temp() As String
    For i = LBound(props) To UBound(props)
        ' Get the Name-Value components.
        temp() = Split(props(i), &quot;=&quot;)
        ' Assign the property.
        CallByName obj, temp(0), vbLet, temp(1)
    Next
End Sub
</pre>
</td></tr>
</table>
</p>


<p>When you're using <I>GetProperties</I>, you have to provide a list of the 
properties you're interested in, but you don't need a list when you restore the properties 
with a call to <I>SetProperties</I>:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim saveprops() As String
saveprops() = GetProperties(txtEditor, &quot;Text&quot;, &quot;ForeColor&quot;, &quot;BackColor&quot;)
...
SetProperties txtEditor, saveprops()
</pre>
</td></tr>
</table>
</p>


<A NAME="243"><h2>Attributes</h2></A>

<p>You can't entirely define a class in the code window. In fact, you must specify a 
few important attributes in a different way. These attributes might concern the class 
module as a whole or its individual members (that is, its properties and methods).</p>

<A NAME="244"><h3>Class module attributes</h3></A>

<p>The attributes of the class module itself are conceptually simpler because you 
can edit them through the Properties window, as you might for any other source 
code module that can be hosted in the Visual Basic environment. But in contrast to 
what happens with form and standard modules, what you see in the Properties 
window when you press the F4 key depends on the type of the project. (See Figure 6-5.) 
There are six attributes: <I>Name</I>, 
<I>DataBindingBehavior</I>, 
<I>DataSourceBehavior</I>, <I>Instancing</I>, 
<I>MTSTransactionMode</I>, and <I>Persistable</I>. They will be covered in detail in 
subsequent chapters.</p>

<p>
<img src="images/F06ph05.GIF" width=258 height=263 border="0">
<p>
<!--caption--><B>Figure 6-5.</B> <i>Only a Public class module in an ActiveX DLL project exposes all possible class attributes in the Properties window.</i><!--/caption-->


<A NAME="245"><h3>The default member of a class</h3></A>

<p>Most Visual Basic controls and intrinsic objects expose a default property or 
method. For example, the TextBox control's default property is 
<I>Text</I>; the Error object's default property is 
<I>Number</I>; Collections have a default 
<I>Item</I> method; and so on. Such items are said to be 
<I>default members</I> because if you omit the member name in an 
expression, Visual Basic will implicitly assume you meant to refer to that particular 
member. You can implement the same mechanism even with your own classes by 
following this procedure:</p>
<OL>

<p><li> Click in the code editor on the property or method definition, invoke 
the Procedure Attributes command from the Tools menu, and then select 
the name of the item in the topmost combo box if it isn't already displayed.</li></p>

<p><li> Alternatively, press F2 to open the Object Browser, select the class 
module name in the leftmost pane; in the rightmost pane, 
right-click the item that must become the default 
member, and then select the Properties command from the pop-up menu that appears, as you can see in Figure 6-6.</li></p>


<p>
<A HREF="javascript:fullSize('F06ph06x.htm')"> <img src="images/F06ph06.JPG" width=404 height=337 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><B>Figure 6-6.</B> <i>Selecting the Properties menu command from the Object Browser.</i><!--/caption-->
</p>


<p><li> Once the item you're interested in is highlighted in the topmost 
Name combo box, click on the Advanced button to expand the Procedure 
Attributes dialog box. (See Figure 6-7.)</li></p>


<p>
<img src="images/F06ph07.GIF" width=338 height=404 border="0">
<p>
<!--caption--><B>Figure 6-7.</B> <i>The expanded view of the Procedure Attributes dialog box.</i><!--/caption-->



<p><li> In the Procedure ID combo box, select the (default) item; 
alternatively, you can just type <I>0</I> (zero) in the edit area of the combo box.</li></p>

<p><li> Click the OK button to make your decision permanent, and close the 
dialog box. In the Object Browser, you'll notice that a small, round 
indicator has appeared next to the member's name. This is the confirmation that 
it has become the default member of the class.</li></p>
</OL>

<p>A class can't expose more than one default property or method. If you try 
to create a second default item, Visual Basic complains and asks you to confirm 
your decision. In general, it isn't a good idea to change the default member of a 
class because this amendment could break all the client code written previously.</p>

<p>While I certainly agree that providing a default property to a class module 
tends to make it more easily usable, I want to warn you against some potential 
problems that can arise from using this feature. Let's go back to our CPerson class and 
its <I>HomeAddress</I> and <I>WorkAddress</I> properties. As you know, you can assign one 
object property to another, as in this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Set pers.HomeAddress = New CAddress
Set pers.WorkAddress = New CAddress
pers.HomeAddress.Street = &quot;2233 Ocean St.&quot;
...
Set pers.WorkAddress = pers.HomeAddress   ' This person works at home.
</pre>
</td></tr>
</table>
</p>


<p>Since the preceding code uses the <I>Set</I> command, both properties are 
actually pointing to the same CAddress object. This is important because it implies that 
no additional memory has been allocated to store this duplicate data and also 
because you can then freely modify the address properties through any of the two 
CPerson properties without introducing any inconsistencies:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>pers.HomeAddress.Street = &quot;9876 American Ave&quot;
Print pers.WorkAddress.Street   ' Correctly displays &quot;9876 American Ave&quot;
</pre>
</td></tr>
</table>
</p>


<p>Now see what happens if you mistakenly omit the 
<I>Set</I> keyword in the original assignment:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>pers.WorkAddress = pers.HomeAddress   ' Error 438 &quot;Object doesn't support
                                      ' this property or method&quot;
</pre>
</td></tr>
</table>
</p>


<p>Don't be alarmed by this (admittedly cryptic) error message: You made a logic error in your code, and Visual Basic has spotted it for you at run time, which is a good thing. Alas, this helpful error disappears if the class exposes a default property. To see it for yourself, make <I>Street</I> the default item of the class, and then run this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Set pers.HomeAddress = New CAddress
Set pers.WorkAddress = New CAddress
pers.HomeAddress.Street = &quot;2233 Ocean St.&quot;
pers.WorkAddress = pers.HomeAddress   ' No error! But has it worked?
</pre>
</td></tr>
</table>
</p>


<p>Instead of rejoicing about the absence of an error message, see how the 
two properties are now related to each other:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>'Change the Street property of one object.
pers.HomeAddress.Street = &quot;9876 American Ave&quot;
Print pers.WorkAddress.Street        ' Still displays &quot;2233 Ocean St.&quot;
</pre>
</td></tr>
</table>
</p>


<p>In other words, the two properties aren't pointing to the same object 
anymore. The assignment without the <I>Set</I> command has cheated the compiler into 
thinking that we were asking it to assign the values of the default 
<I>Street </I>property (which is a legal operation) and that we weren't interested in creating a new reference to the same object.</p>

<p>In short, by adding a default property you have deprived yourself of an 
important cue about the correctness of your code. My personal experience is that 
missing <I>Set </I>commands are subtle bugs that are rather difficult to exterminate. Keep this in 
mind when you're deciding to create default properties. And if you're determined to 
create them, always double-check your <I>Set </I>keywords in code.</p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>
You might notice that if the object property on the left side of 
the assignment is Nothing, Visual Basic correctly raises error 91 even if we omit 
the <I>Set</I> keyword. This doesn't happen, however, if the target property had 
been declared to be auto-instancing because in that case Visual Basic would 
create an object for you. This is just further proof that auto-instancing objects 
should always be looked at with suspicion. 
</blockquote></div>
</p>

<A NAME="246"><h3>A useful example</h3></A>

<p>Now that I have warned you against using default properties, I want to show you 
a case in which they could turn out to be very useful. But first I need to introduce 
the concept of <I>sparse matrices</I>. A sparse matrix is a large, two-dimensional (or 
multidimensional) array that includes a relatively small number of nonzero items. A 
1000-by-1000 array with just 500 nonzero items can be considered a great example of 
a sparse matrix. Sparse matrices have several common applications in math and 
algebra, but you can also find a use for them in business applications. For example, you 
might have a list of 1000 cities and a two-dimensional array that stores the distance 
between any two cities. Let's assume further that we use 0 (or some other special value) 
for the distance between cities that aren't directly connected. Large sparse arrays raise 
a serious memory overhead problem: a two-dimensional array of Single or Long 
values with 1000 rows and 1000 columns takes nearly 4 MB, so you can reasonably 
expect that it will noticeably slow your application on less powerful machines.</p>

<p>One simple solution to this problem is to store only the nonzero elements, together with their row and column indices. You need 8 additional bytes for each element to do this, but in the end you're going to save a lot of memory. For example, if only 10,000 items are nonzero (filling factor = 1:100), your sparse array will 
consume less than 120 KB&#8212;that is, about 33 times less than the original array&#8212;so 
this seems to be a promising approach. You might believe that implementing a 
sparse array in Visual Basic requires quite a bit of coding, so I bet you'll be surprised to 
learn how simple it is when you're using a class module:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The complete source code of the CSparseArray class
Private m_Value As New Collection

Property Get Value(row As Long, col As Long) As Single
    ' Returns an item, or 0 if it doesn't exist.
    On Error Resume Next
    Value = m_Value(GetKey(row, col))
End Property

Property Let Value(row As Long, col As Long, newValue As Single)
    Dim key As String
    key = GetKey(row, col)
    ' First destroy the value if it's in the collection.
    On Error Resume Next
    m_Value.Remove key
    ' Then add the new value, but only if it's not 0.
    If newValue &lt;&gt; 0 Then m_Value.Add newValue, key
End Property

' A private function that builds the key for the private collection.
Private Function GetKey(row As Long, col As Long) As String
    GetKey = row &#38;; &quot;,&quot; &#38;; col
End Function
</pre>
</td></tr>
</table>
</p>


<p>Make sure that the <I>Value </I>property&#8212;the only public member of this 
class&#8212;is also its default property, which dramatically simplifies how the client uses the 
class. See how easy it is using your brand-new, resource-savvy data structure instead of 
a regular matrix:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre><B>Dim mat As New CSparseArray </B>
' The rest of the application that uses the matrix isn't unchanged.
mat(1, 1) = 123             ' Actually using mat's Value property!
</pre>
</td></tr>
</table>
</p>


<p>In other words, thanks to a default property you have been able to change 
the inner workings of this application (and, it's to be hoped, to optimize it too) 
<I>by</I> <I>changing only one line in the client 
code!</I> This should be a convincing argument in 
favor of default properties.</p>

<p>Actually, the CSparseArray class is even more powerful than it appears. In 
fact, while its original implementation uses Long values for the <I>row</I> and <I>col</I> arguments and a Single return value, you might decide to use Variant values for the two indices 
and for the return value. This first amendment permits you to create arrays<I> </I>that use strings as indices to data with no effort, as in this code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' The distance between cities
Dim Distance As New CSparseArray
Distance(&quot;Los Angeles&quot;, &quot;San Bernardino&quot;) = 60
</pre>
</td></tr>
</table>
</p>


<p>Using a Variant return type doesn't waste more memory than before because the internal <I>m_Values</I> collection allocates a Variant for each value anyway.</p>

<p>Before concluding this section, let me hint at another special type of array, the so-called <I>symmetrical array</I>. In this type of two-dimensional array, <I>m(i,j)</I> always matches <I>m(j,i)</I>, so you can always save some memory by storing the value just once. The <I>Distance </I>matrix is a great example of a symmetrical array because the distance between two cities doesn't depend on the order of the cities themselves. When you're dealing with a regular Visual Basic array, it's up to you to remember that it's symmetrical and that you must therefore store the same value twice, which means more code, memory, and chances for errors. Fortunately, now that you have encapsulated everything in a class module, you just need to edit one private routine:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>' Note that row and col are now Variants.
Private Function GetKey(row As Variant, col As Variant) As String
    ' Start with the lesser of the two--a case-insensitive comparison
    ' is needed because collections search their keys in this way.
    If StrComp(row, col, vbTextCompare) &lt; 0 Then
        ' Using a nonprintable delimiter is preferable.
        GetKey = row &#38;; vbCr &#38;; col
    Else
        GetKey = col &#38;; vbCr &#38;; row
    End If
End Function
</pre>
</td></tr>
</table>
</p>


<p>This is enough to make this client code work as expected:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>Dim Distance As New CSparseMatrix
Distance(&quot;Los Angeles&quot;, &quot;San Bernardino&quot;) = 60
Print Distance(&quot;San Bernardino&quot;, &quot;Los Angeles&quot;)   ' Displays &quot;60&quot;
</pre>
</td></tr>
</table>
</p>


<A NAME="247"><h3>Other attributes</h3></A><p>You might have noticed that the Procedure Attributes dialog box in Figure 6-7 contains many more fields than I have explained so far. The majority of 
the corresponding attributes are somewhat advanced and won't be covered in this 
chapter, but there are three that are worth some additional explanation in this context.</p>

<p><B>Description</B> You can associate a textual description with any property and 
method defined in your class module. This description is then reported in the Object 
Browser and provides the users of your class with some information about how each 
member can be used. The description text is visible even when you compile the class into 
a COM component and another programmer browses its interface from outside 
the current process.</p>

<p><B>HelpContextID</B> You can provide a help file that contains a longer description for all the classes, properties, methods, events, controls, and so on exposed by your project. If you do so, you should also specify a distinct ID for each item in the project. When the item is selected in the rightmost pane of the Object Browser, a click on the ? icon automatically takes you to the corresponding help page. The name of the help file can be entered in the Project Properties dialog box.</p>

<p><B>Hide This Member</B> If you select this option, the property or method in the class module won't be visible in the Object Browser when the class is browsed from 
outside the project. This setting has no effect within the current project, and it 
makes sense to use it only in project types other than Standard EXE. Note that &quot;hiding&quot; 
an item doesn't mean that it's absolutely invisible to other programmers. In fact, 
even the simple Object Browser that comes with Visual Basic includes a Show Hidden 
Members menu command (which you can see in Figure 6-6) that lets 
you discover undocumented features in other libraries (including VB and VBA's own 
libraries). The decision to hide a given item should be intended just as a suggestion to 
users of your class, meaning something like, &quot;Don't use this item because it isn't 
supported and could disappear in future versions of the product.&quot;</p>

<p><div class="caution"><blockquote>
<b>CAUTION</b><hr>
None of the class attributes&#8212;including those described in this 
section and others that I describe in forthcoming chapters&#8212;are stored in 
source code, so they aren't copied and pasted among different class modules when 
you copy the code of the procedure they're connected to. Even worse, they 
aren't even preserved when you use cut-and-paste operations to rearrange the 
order of methods and properties inside the same class module. If you want to 
move code in your class modules without also losing all the attributes that are 
invisibly connected to it, you have to first copy the code where you want to place it and 
then delete it from its original location. This isn't an issue when you're just 
renaming a property or a method.
</blockquote></div>
</p>

<p><div class="tip"><blockquote>
<b>TIP</b><hr>
Oddly, Visual Basic documentation doesn't mention that class 
modules also support their own <I>Description</I> and 
<I>HelpContextID</I> attributes and therefore doesn't explain how you can modify them. The trick is simple: Right-click on 
the class name in the leftmost pane of the Object Browser, and select the 
Properties command from the pop-up menu.
</blockquote></div>
</p>

</BODY>
</HTML>





