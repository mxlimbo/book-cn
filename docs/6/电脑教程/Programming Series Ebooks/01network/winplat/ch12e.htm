<HTML>
<HEAD>
<TITLE>Programming QOS</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch12d.htm" , "ch12f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="389"><H1>Programming QOS</H1></A>

<p>Central to QOS is the initiation of an RSVP session. It's not until the RSVP PATH and RESV messages have been sent and processed that bandwidth is reserved for the process. Knowing when RSVP messages are generated is important to applications. For senders, three parameters must be known before a PATH message is generated:</p>

<ul>
<p><li> Sending <i>FLOWSPEC</i> member</li></p>

<p><li> Source IP address and port</li></p>

<p><li> Destination IP address, port, and protocol</li></p>
</ul>



<p>The <i>FLOWSPEC</i> member is known whenever a QOS-enabled function is called, such as <i>WSAConnect</i>, <i>WSAJoinLeaf</i>, <i>WSAIoctl</i> (with the <i>SIO_SET_QOS</i> option), and so on. The source IP address and port will not be known until the socket is bound locally, either implicitly (such as by connecting) or explicitly by bind. Finally, the application needs the data's destination. This information is gathered upon either a connect call or, in the case of connectionless UDP, the setting of the <i>QOS_DESTADDR</i> object in the provider-specific data passed using the <i>SIO_SET_QOS</i> ioctl command.</p>

<p>Similarly, for an RSVP RESV message to be generated, three things must be known:</p>

<ul>
<p><li> Receiving <i>FLOWSPEC</i> member</li></p>

<p><li> Address and port of each sender</li></p>

<p><li> Local address and port of the receiving socket</li></p>
</ul>



<p>The receiving <i>FLOWSPEC</i> member is obtained from any of the QOS-enabled Winsock functions. The address and port of each sender depend on the filter style, which can be set manually via the <i>RSVP_RESERVE_INFO</i> provider-specific structure, discussed earlier. Otherwise, this information is obtained from a PATH message. Of course, depending on the socket type, it is not always necessary to have already received a PATH statement to obtain the sender's address to generate RESV messages. The wildcard filter style used in multicasting is an example of this. The RESV message sent applies to all senders in the session. The local address and port are self-explanatory for unicast and UDP receivers but not for multicast receivers. In the case of multicast receivers, the local address and port are the multicast address and its corresponding port number.</p>

<p>In this section, we'll first cover the different socket types and their interaction with the QOS service provider and RSVP messages. Then we'll take a look at how the QOS service provider notifies applications of certain events. Understanding these concepts is central to writing successful QOS-enabled applications. Programming such applications is a matter of knowing how to obtain QOS guarantees as well as knowing when those guarantees are put into effect and when and how they can change.</p>

<A NAME="390"><H2>RSVP and Socket Types</H2></A>

<p>We now have a basic understanding of how PATH and RESV RSVP messages are generated. In the following sections, we'll look at the different types of sockets&#8212;UDP, TCP, and multicast UDP&#8212;and how they interact with the QOS service provider to generate PATH and RESV messages.</p>

<A NAME="391"><H3>Unicast UDP</H3></A>

<p>Because you have the option of using either connected or unconnected UDP sockets, setting QOS on unicast UDP sockets presents quite a few options. In the case of the UDP sender, the sending <i>FLOWSPEC</i> is obtained from one of the QOS-invoking functions. The local address and port are obtained either from an explicit bind call or from an implicit bind done by <i>WSAConnect</i>. The last piece is the address and port of the receiving application, which can be specified either in <i>WSAConnect</i> or via the <i>QOS_DESTADDR</i> provider-specific structure passed through the <i>SIO_SET_QOS</i> option. Be aware that if <i>SIO_SET_QOS</i> is used to set QOS, the socket must be bound beforehand.</p>

<p>For the UDP receiver, <i>WSAConnect</i> can be called to limit the receiving application to a single sender. Additionally, applications can specify a <i>QOS_DESTADDR</i> structure with the <i>SIO_SET_QOS</i> ioctl command. Otherwise, the <i>SIO_SET_QOS</i> can be called without providing any kind of destination address. In this case, a RESV message will be generated with the wildcard filter style. In fact, specifying the destination address via <i>WSAConnect</i> or via the <i>QOS_DESTADDR</i> structure should be done only if you want the application to receive data from only one sender that uses the fixed filter style.</p>

<p>The UDP receiver can actually call both <i>WSAConnect</i> and the <i>SIO_SET_QOS</i> ioctl command in any order. If <i>SIO_SET_QOS</i> is called before <i>WSAConnect</i>, a RESV message is created with the wildcard filter first. Once the connect call is made, the previous RESV session is torn down and a new one is generated with the fixed filter style. Alternatively, calling <i>SIO_SET_QOS</i> after <i>WSAConnect</i> and a fixed filter RESV message does not negate the RSVP session and generate a wildcard filter style. Instead it simply updates the QOS parameters associated with the existing RSVP session.</p>

<A NAME="392"><H3>Unicast TCP</H3></A>

<p>TCP sessions have two possibilities. First, the sender can be the client who connects to the server and sends data. The second possibility is that the server that the client connects to might be the sender. In the case of the client, QOS parameters can be specified directly in the <i>WSAConnect</i> call, which will result in PATH messages being sent. The ioctl command <i>SIO_SET_QOS</i> can also be called before calling connect, but until one of the connect calls knows the destination address, no PATH messages will be generated.</p>

<p>In the case in which the sender is the server, the server calls <i>WSAAccept</i> to accept the client connection. This function does not provide a means of setting QOS on the accepted socket. If QOS is set before a call to <i>WSAAccept</i> by using <i>SIO_SET_QOS</i>, any accepted socket inherits the QOS levels set on the listening socket. Note that if the sender uses the conditional function in <i>WSAAccept</i>, the function should pass QOS values set on the connecting client. However, this is not the case. The QOS service provider passes junk, which is the behavior on both Windows 98 and Windows 2000. The exception is that if the <i>lpSQOS</i> parameter is non-null under Windows 98, some kind of QOS values must be set via the <i>SIO_SET_QOS</i> ioctl command within the conditional function; otherwise, the <i>WSAAccept</i> call fails even if <i>CF_ACCEPT</i> is returned. QOS can also be set on the client socket after it has been accepted.</p>

<p>Let's look at receiving TCP applications. The first case is calling <i>WSAConnect</i> with a receiving <i>FLOWSPEC</i>. When this occurs, the QOS service provider creates a RESV request. If QOS parameters are not supplied to <i>WSAConnect</i>, the <i>SIO_SET_QOS</i> ioctl command can be set at a later time (resulting in a RESV message). The last combination is the server being the receiver, which is similar to the sending case. QOS can be set on the listening socket before a <i>WSAAccept</i> call, in which case the client socket inherits the same QOS levels. Otherwise, QOS can be set in the conditional function or after the socket has been accepted. In either case, the QOS service provider generates a RESV message as soon as a PATH message arrives.</p>

<A NAME="393"><H3>Multicast</H3></A>

<p>Multicast senders behave the same way as UDP senders except that <i>WSAJoinLeaf</i> is used to become a member of the multicast group, as opposed to calling <i>WSAConnect</i> with the destination address. QOS can be set with <i>WSAJoinLeaf</i> or separately through an <i>SIO_SET_QOS</i> call. The multicast session address is used to compose the RSVP session object included in the RSVP PATH message.</p>

<p>In the case of the multicast receiver, no RESV messages will be generated until the multicast address is specified via the <i>WSAJoinLeaf</i> function. Because the multicast receiver doesn't specify a peer address, the QOS provider generates RESV messages with the wildcard filter style. The QOS service provider does not prohibit a socket from joining multiple multicast groups. In this case, the service provider sends RESV messages for all groups that have a matching PATH message. The QOS parameters supplied to each <i>WSAJoinLeaf</i> will be used in each RESV message, but if <i>SIO_SET_QOS</i> is called on the socket after joining multiple groups, the new QOS parameters will be applied to all multicast groups joined.</p>

<p>When a sender sends data to a multicast group, only data sent to the multicast group that the sender joined results in QOS being applied to that data. In other words, if you join one multicast group and use <i>sendto/WSASendTo</i> with any other multicast group as the destination, QOS is not applied to that data. Additionally, if a socket joins a multicast group specifying a particular direction (for example, using <i>JL_SENDER_ONLY</i> or <i>JL_RECEIVER_ONLY</i> in the <i>dwFlags</i> parameter to <i>WSAJoinLeaf</i>), QOS is applied accordingly. A socket set as a receiver only will not gain any QOS benefits for sent data.</p>



<A NAME="394"><H2>QOS Notifications</H2></A>

<p>Thus far, you have learned how to invoke QOS for TCP, UDP, and multicast UDP sockets and the corresponding RSVP events that occur depending on whether you're sending or receiving. However, the completion of these RSVP messages is not strictly tied to the API calls that invoke them. That is, issuing a <i>WSAConnect</i> call for a TCP receiving socket generates a RESV message, but the RESV message is independent of the actual API call in that the call returns without any assurances that the reservation is approved and network resources are allocated. Because of this, a new asynchronous event has been added, <i>FD_QOS</i>, which is posted to a socket. Typically, an <i>FD_QOS</i> event notification will be posted in the following events.</p>

<ul>
<p><li> Notification of the acceptance or rejection of the application's QOS request</li></p>

<p><li> Significant changes in the QOS provided by the network (as opposed to previously negotiated values)</li></p>

<p><li> Status regarding whether a QOS peer is ready to send or receive data for a particular flow</li></p>
</ul>



<A NAME="395"><h3>Registering for <i>FD_QOS</i> notifications</h3></A>
<p>To take advantage of these notifications, an application must register to be notified when an <i>FD_QOS</i> event occurs. There are a couple ways to do this. First you can use either <i>WSAEventSelect</i> or <i>WSAAsyncSelect</i> and include the <i>FD_QOS</i> flag in the bitwise ORing of event flags. However, an application is eligible to receive the <i>FD_QOS</i> event only if a call has already been made to one of the QOS invoking functions. Note that in some cases an application might want to receive the <i>FD_QOS</i> event without having to set QOS levels on a socket. This can be accomplished by setting up a <i>QOS</i> structure whose sending and receiving <i>FLOWSPEC</i> members contain either the <i>QOS_NOT_SPECIFIED</i> or the <i>SERVICETYPE_NOTRAFFIC</i> flag. The only catch is that the <i>SERVICE_NO_QOS_SIGNALING</i> flag must be ORed with the <i>SERVICETYPE_NOTRAFFIC</i> flag for the direction of QOS in which you want to receive event notification.</p>

<p>If you need exact information on how to call the two asynchronous select functions, consult <a href="ch08a.htm">Chapter 8</A>, which covers them in great detail. If you use <i>WSAEventSelect</i> once the event has been triggered, call the <i>WSAEnumNetworkEvents</i> function to obtain additional status codes that might be available. This function is also covered in <a href="ch08a.htm">Chapter 8</A>, but we'll review it here since it's short, simple, and important to QOS applications. Pass the socket handle, the event handle, and a <i>WSANETWORKEVENTS</i> object into the call, which will return and set event information into the supplied structure. This structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _WSANETWORKEVENTS
{
    long   lNetworkEvents;
    int    iErrorCode[FD_MAX_EVENTS];
} WSANETWORKEVENTS, FAR * LPWSANETWORKEVENTS;
</pre>
</td></tr></table>
</p>

<p>The <i>lNetworkEvents</i> field will be set to a bitwise ORing of all the event flags triggered. To detect the occurrence of a particular event, simply AND (with the &amp; operator) this field with the event flag. If the result is nonzero, that event was triggered. The <i>iErrorCode</i> array is used to indicate errors or, in the case of QOS, status information. If an event is triggered, a flag corresponding to that event is used to index into this array. If the value of the array index is 0, no error occurred; otherwise, the value is an index to the array element that contains the error code. For example, if the <i>FD_QOS</i> event was triggered, use the <i>FD_QOS_BIT</i> flag to index into the <i>iErrorCode</i> array to check for any errors or status information. All other Winsock asynchronous events (<i>FD_READ_BIT</i>, <i>FD_WRITE_BIT</i>, and so on) have similarly defined index flags.</p>

<A NAME="396"><H3>RSVP notifications</H3></A>

<p>We mentioned earlier that there are a couple of ways to receive QOS notifications. This information actually ties into this section: obtaining the results of a QOS event. If you have registered to receive <i>FD_QOS</i> notifications with either <i>WSAAsyncSelect</i> or <i>WSAEventSelect</i> and you actually receive an <i>FD_QOS</i> event notification, you must perform a call to <i>WSAIoctl</i> with the <i>SIO_GET_QOS</i> ioctl option to find out what triggered the event. You don't actually have to register for <i>FD_QOS</i> events&#8212;you can simply call <i>WSAIoctl</i> with the <i>SIO_GET_QOS</i> command using overlapped I/O. This also requires that you specify a completion routine, which is invoked once the QOS service provider detects a change in QOS. Once the callback occurs, a QOS structure will be available in the output buffer.</p>

<p>In either case, once a change in QOS has occurred, your application can be notified of this change by registering for <i>FD_QOS</i> or by using overlapped I/O and <i>SIO_GET_QOS</i>. If you register for <i>FD_QOS</i>, you also want to call <i>WSAIoctl</i> with the <i>SIO_GET_QOS</i> ioctl command upon event notification. For both methods, the QOS structure returned contains QOS information for only a single direction. That is, the <i>FLOWSPEC</i> structure for the invalid direction has its <i>ServiceType</i> field set to <i>SERVICETYPE_NOCHANGE</i>. Additionally, more than one QOS event might have occurred, in which case you should call <i>WSAIoctl</i> and <i>SIO_GET_QOS</i> in a loop until <i>SOCKET_ERROR</i> is returned and <i>WSAGetLastError</i> returns <i>WSAEWOULDBLOCK</i>. The final concern when calling <i>SIO_GET_QOS</i> is the buffer size. When an <i>FD_QOS</i> event has been triggered, it is possible that provider-specific objects will be returned. In fact, the <i>RSVP_STATUS_INFO</i> structure will
most often be returned, provided the buffer is large enough. See the earlier entry on <i>WSAIoctl</i> for information on how to find the right-size buffer.</p>

<p>If your application uses one of the asynchronous event functions, a particularly important issue is that once an <i>FD_QOS</i> event occurs, you must <i>always</i> perform an <i>SIO_GET_QOS</i> operation to reenable <i>FD_QOS</i> notifications.</p>

<p>You now know how to receive QOS event notifications and obtain new QOS parameters as a result of these events, but what types of notifications will occur? The first and most obvious reason for a QOS event is a change in the <i>FLOWSPEC</i> parameters for a given flow. For example, if you set up a socket with best effort service, periodically the QOS service provider will send notification to your application indicating the current conditions on the network. Additionally, if you specify controlled load as well as other parameters, the QOS parameters for token bucket size and token rate might change slightly from what you requested once the reservation occurs. Your application should compare the <i>FLOWSPEC</i> returned once a QOS notification occurs to what you originally requested to ensure that it is sufficient for your application to continue. Also remember that throughout the life of a QOS-enabled socket, you can always perform a <i>SIO_SET_QOS</i> to change any of the parameters, which will result in
a QOS notification for the peer or peers associated with your current RSVP session. A robust application should be able to handle these conditions.</p>

<p>In addition to updating QOS parameters, QOS event notification signals other occurrences, such as notification of senders or receivers. The possible events are listed in Table 12-6. There are two ways to obtain these status codes. The first is as a part of the <i>RSVP_STATUS_INFO</i> object. When a QOS event occurs and a call is made to <i>SIO_GET_QOS</i>, it is possible that a <i>RSVP_STATUS_INFO</i> object will be returned as part of the provider-specific buffer. Second, if you use <i>WSAEventSelect</i> to register for events, these codes can be returned in the <i>WSANETWORKEVENTS</i> structure returned from <i>WSAEnumNetworkEvents</i>. The codes defined in Table 12-6 can be found in the <i>iErrorCode</i> array, indexed by <i>FD_QOS_BIT</i>. The first five codes listed are not error codes. They return valuable information concerning the status of the QOS connection. The other status codes listed in the table are QOS errors of concern, but they won't prevent you from sending and receiving
data&#8212;they merely indicate an error in the QOS session. Of course, data sent in this situation will not carry any of the requested QOS guarantees.</p>

<p><b><i>WSA_QOS_RECEIVERS</i> and <i>WSA_QOS_NO_RECEIVERS</i></b></p>

<p>In the case of unicast, after a sender starts up and receives the first RESV message, a <i>WSA_QOS_RECEIVERS</i> is passed up to the application. If the receiver performs any of the steps to disable QOS, the result is a RESV teardown message. Once the sender receives this, <i>WSA_QOS_NO_RECEIVERS</i> is passed up to the application. Of course, with unicast many receivers simply close the socket, generating both an <i>FD_CLOSE</i> event and the <i>WSA_QOS_NO_RECEIVERS</i> event. In most cases, an application's response is simply to close the sending socket.</p>

<p>In the case of multicast, the sending application receives <i>WSA_QOS_RECEIVERS</i> whenever the number of receivers changes and is nonzero. In other words, a single multicast sender receives <i>WSA_QOS_RECEIVERS</i> every time a QOS receiver joins the group, as well as every time a receiver drops out of a group&#8212;as long as at least one receiver remains.</p>

<p><b><i>WSA_QOS_SENDERS</i> and <i>WSA_QOS_NO_SENDERS</i></b></p>

<p>The senders notification is similar to the receivers event except that it deals with the receipt of the PATH message. For unicast receivers after startup, the receipt of the first PATH message generates <i>WSA_QOS_SENDERS</i>, while the PATH teardown message initiates a <i>WSA_QOS_NO_SENDERS</i> message.</p>

<p>Likewise, multicast receivers receive the <i>WSA_QOS_SENDERS</i> notification whenever the number of senders decrements or increments and is nonzero. Once the number of senders reaches 0, the <i>WSA_QOS_NO_SENDERS</i> message is passed to the application.</p>

<p><b><i>WSA_QOS_REQUEST_CONFIRMED</i></b></p>

<p>This last status message is issued to receiving QOS applications if they ask to be notified when a reservation request has been confirmed. Within the <i>RSVP_STATUS_INFO</i> structure is a field, <i>ConfirmRequest</i>, which if set to nonzero informs the QOS service provider to notify the application when the reservation request has been confirmed. This object is a provider-specific option that can be passed along with a QOS structure to the <i>SIO_SET_QOS</i> ioctl command.</p>

<A NAME="397"><H2>QOS Templates</H2></A>

<p>Winsock provides several predefined QOS structures, referred to as templates, that an application can query by name. These templates define the QOS parameters for some common audio and video codecs, such as G711 and H263QCIF. The function <i>WSAGetQOSByName</i> is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL WSAGetQOSByName(
    SOCKET s,
    LPWSABUF lpQOSName,
    LPQOS lpQOS
);
</pre>
</td></tr></table>
</p>

<p>If you don't know the name of the installed templates, you can use this function to first enumerate all template names. This is accomplished by providing a sufficiently large buffer in <i>lpQOSName</i> with its first character set to the null character and passing a null pointer for <i>lpQOS</i>, as in the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
WSABUF  wbuf;
char    cbuf[1024];

cbuf[0] = '\0';
wbuf.buf = cbuf;
wbuf.len = 1024;
WSAGetQOSByName(s, &amp;wbuf, NULL);
</pre>
</td></tr></table>
</p>

<p>Upon return, the character buffer is filled with an array of strings separated by a null character, and the entire list is terminated by another null character. This means the last string entry will have two consecutive null characters. From here you can get the names of all the installed templates and query for a specific one. The following code looks up the G711 template:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
QOS     qos;
WSABUF  wbuf;

wbuf.buf = &quot;G711&quot;;
wbuf.len = 4;
WSAGetQOSByName(s, &amp;wbuf, &amp;qos);
</pre>
</td></tr></table>
</p>

<p>In the event that the requested QOS template does not exist, the lookup returns <i>FALSE</i> and the error is <i>WSAEINVAL</i>. Upon success, the function returns <i>TRUE</i>. The example <i>Qostemplate.c</i> on the accompanying CD illustrates how to enumerate the installed QOS templates.</p>

<p>Additionally, you can install your own QOS template so that other applications can query for it by name. Two functions&#8212;<i>WSCInstallQOSTemplate</i> and <i>WSCRemoteQOSTemplate</i>&#8212;do this. The first function installs a QOS template, and the second removes it. The prototypes are</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL WSCInstallQOSTemplate(
    const LPGUID lpProviderId,
    LPWSABUF lpQOSName,
    LPQOS lpQOS
);

BOOL WSCRemoveQOSTemplate(
    const LPGUID lpProviderId,
    LPWSABUF lpQOSName
);
</pre>
</td></tr></table>
</p>

<p>These two functions are fairly self-explanatory. To install a template, call <i>WSCInstallQOSTemplate</i> with a GUID, the name of the template, and the QOS parameters. The GUID is a unique identifier for this template that can be generated by such utilities as Uuidgen.exe. To remove the template, simply supply the template name&#8212;along with the same GUID used in the installation process&#8212;to <i>WSCRemoveQOSTemplate</i>. Both functions return <i>TRUE</i> when successful.</p>

</BODY>
</HTML>




