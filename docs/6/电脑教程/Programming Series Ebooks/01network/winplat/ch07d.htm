<HTML>
<HEAD>
<TITLE>Connection-Oriented Protocols</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07c.htm" , "ch07e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="139"><H1>Connection-Oriented Protocols</H1></A>

<p>In this first section, we'll cover the Winsock functions necessary for both receiving connections and establishing connections. We'll first discuss how to listen for client connections and explore the process for accepting or rejecting a connection. Then we'll describe how to initiate a connection to a server. Finally, we will discuss how data is transferred in a connection session.</p>

<A NAME="140"><H2>Server API Functions</H2></A>

<p>A server is a process that waits for any number of client connections with the purpose of servicing their requests. A server must listen for connections on a well-known name. In TCP/IP, this name is the IP address of the local interface and a port number. Every protocol has a different addressing scheme and therefore a different naming method. The first step in Winsock is to bind a socket of the given protocol to its wellknown name, which is accomplished with the <i>bind</i> API call. The next step is to put the socket into listening mode, which is performed (appropriately enough) with the <i>listen</i> API function. Finally, when a client attempts a connection, the server must accept the connection with either the <i>accept</i> or the <i>WSAAccept</i> call. In the next few sections, we will discuss each API call that is required for binding and listening and for accepting a client connection. Figure 7-1 illustrates the basic calls a server and a client must perform in order to establish a communication
channel.</p>

<p>
<A HREF="javascript:fullSize('F07JI01x.htm')"> <img src="images/F07JI01.JPG" width=404 height=238 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 7-1.</b> <i>Winsock basics for server and client</i><!-- /caption -->
</p>

<A NAME="141"><h3><i>bind</i></h3></A>
<p>Once the socket of a particular protocol is created, you must bind the socket to a well-known address. The <i>bind</i> function associates the given socket with a well-known address. This function is declared as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int bind(
<b>    </b> SOCKET<i>                     </i> s,<b> 
    </b> const struct sockaddr FAR* name,<b> 
    </b> int<i>                        </i> namelen
);
</pre>
</td></tr></table>
</p>

<p>The first parameter, <i>s</i>, is the socket on which you want to wait for client connections. The second parameter is of type <i>struct sockaddr</i>, which is simply a generic buffer. You must actually fill out an address buffer specific to the protocol you are using and cast that as a <i>struct sockaddr</i> when calling <i>bind</i>. The Winsock header file defines the type <i>SOCKADDR</i> as <i>struct sockaddr</i>. We'll use this type throughout the chapter for brevity. The third parameter is simply the size of the protocol-specific address structure being passed. For example, the following code illustrates how this is done on a TCP connection:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SOCKET               s;    
struct sockaddr_in   tcpaddr;
int                  port = 5150;

s = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

tcpaddr.sin_family = AF_INET;
tcpaddr.sin_port = htons(port);    
tcpaddr.sin_addr.s_addr = htonl(INADDR_ANY);

bind(s, (SOCKADDR *)&amp;tcpaddr, sizeof(tcpaddr));
</pre>
</td></tr></table>
</p>

<p>If the structure <i>sockaddr_in</i> looks mysterious to you, consult the TCP/IP addressing section in <a href="ch06a.htm">Chapter 6</A>. From the example, you'll see a stream socket being created, followed by setting up the TCP/IP address structure on which client connections will be accepted. In this case, the socket is being bound to the default IP interface on port number 5150. The call to <i>bind</i> formally establishes this association of the socket with the IP interface and port.</p>

<p>On error, <i>bind</i> returns <i>SOCKET</i>_<i>ERROR</i>. The most common error encountered with <i>bind</i> is <i>WSAEADDRINUSE</i>. When you're using TCP/IP, the <i>WSAEADDRINUSE</i> error indicates that another process is already bound to the local IP interface and port number or that the IP interface and port number are in the <i>TIME_WAIT</i> state. If you call <i>bind</i> again on a socket that is already bound, <i>WSAEFAULT</i> will be returned.</p>

<A NAME="142"><h3><i>listen</i></h3></A>
<p>The next piece of the equation is to put the socket into listening mode. The <i>bind</i> function merely associates the socket with a given address. The API function that tells a socket to wait for incoming connections is <i>listen</i>, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int listen(
<b>    </b> SOCKET<i> </i> s,<b> 
    </b> int<i>    </i> backlog
);
</pre>
</td></tr></table>
</p>

<p>Again, the first parameter is a bound socket. The <i>backlog</i> parameter specifies the maximum queue length for pending connections. This is important when several simultaneous requests are made to the server. For example, let's say the backlog parameter is set to 2. If three client requests are made at the same time, the first two will be placed in a &quot;pending&quot; queue so that the application can service their requests. The third connection request will fail with <i>WSAECONNREFUSED</i>. Note that once the server accepts a connection, the connection request is removed from the queue so that others can make a request. The <i>backlog</i> parameter is silently limited to a value determined by the underlying protocol provider. Illegal values are replaced with their nearest legal values. Additionally, there is no standard provision for finding the actual backlog value.</p>

<p>The errors associated with <i>listen</i> are fairly straightforward. By far the most common is <i>WSAEINVAL,</i> which usually indicates that you forgot to call <i>bind</i> before <i>listen</i>. Otherwise, it is possible to receive the <i>WSAEADDRINUSE</i> error on the <i>listen</i> call as opposed to the <i>bind</i> call. This error occurs most often on the <i>bind</i> call.</p>

<A NAME="143"><h3><i>accept</i> and <i>WSAAccept</i></h3></A>
<p>Now you're ready to accept client connections. This is accomplished with either the <i>accept</i> or the <i>WSAAccept</i> function. The prototype for <i>accept</i> is</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SOCKET accept(
     SOCKET  s, 
     struct sockaddr FAR*  addr, 
     int FAR*  addrlen
);
</pre>
</td></tr></table>
</p>

<p>Parameter <i>s</i> is the bound socket that is in a listening state. The second parameter should be the address of a valid <i>SOCKADDR_IN</i> structure, while <i>addrlen</i> should be a reference to the length of the <i>SOCKADDR_IN</i> structure. For a socket of another protocol, substitute the <i>SOCKADDR_IN</i> with the <i>SOCKADDR</i> structure corresponding to that protocol. A call to <i>accept</i> services the first connection request in the queue of pending connections. When the <i>accept</i> function returns, the <i>addr</i> structure contains the IP address information of the client making the connection request, while the <i>addrlen</i> parameter indicates the size of the structure. Additionally, <i>accept</i> returns a new socket descriptor that corresponds to the accepted client connection. For all subsequent operations with this client, the new socket should be used. The original listening socket is still used to accept other client connections and is still in listening mode.</p>

<p>Winsock 2 introduced the function <i>WSAAccept</i>, which has the ability to conditionally accept a connection based on the return value of a condition function. The prototype for this new function is</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SOCKET WSAAccept(
     SOCKET  s, 
     struct sockaddr FAR *  addr, 
     LPINT  addrlen, 
     LPCONDITIONPROC  lpfnCondition, 
     DWORD  dwCallbackData
);
</pre>
</td></tr></table>
</p>

<p>The first three parameters are the same as the Winsock 1 version of <i>accept</i>. The <i>lpfnCondition</i> argument is a pointer to a function that is called upon a client request. This function determines whether to accept the client's connection request. The prototype for this function is</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int CALLBACK ConditionFunc(
    LPWSABUF lpCallerId,
    LPWSABUF lpCallerData,
    LPQOS lpSQOS,
    LPQOS lpGQOS,
    LPWSABUF lpCalleeId,
    LPWSABUF lpCalleeData,
    GROUP FAR * g,
    DWORD dwCallbackData
);
</pre>
</td></tr></table>
</p>

<p>The <i>lpCallerId</i> parameter is a value parameter that contains the address of the connecting entity. The <i>WSABUF</i> structure is commonly used by many Winsock 2 functions. It is declared as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct __WSABUF { 
    u_long     len; 
    char FAR * buf;
} WSABUF, FAR * LPWSABUF;
</pre>
</td></tr></table>
</p>

<p>Depending on its use, the <i>len</i> field refers either to the size of the buffer pointed to by the <i>buf</i> field or to the amount of data contained in the data buffer <i>buf</i>.</p>

<p>For <i>lpCallerId</i>, the <i>buf</i> pointer points to an address structure for the given protocol on which the connection is made. To correctly access the information, simply cast the <i>buf</i> pointer to the appropriate <i>SOCKADDR</i> type. In the case of TCP/IP, this is, of course, a <i>SOCKADDR_IN</i> structure that will contain the IP address of the client making the connection. Most network protocols can be expected to support caller ID information at connection-request time.</p>

<p>The <i>lpCallerData</i> parameter contains any connection data sent by the client along with the connection request. If caller data was not specified, this parameter is <i>NULL</i>. Be aware that most network protocols, such as TCP, do not support connect data. Whether a protocol supports connect or disconnect data can be determined by consulting its entry in the Winsock catalog with the <i>WSAEnumProtocols</i> function. See <a href="ch05a.htm">Chapter 5</A> for the specifics.</p>

<p>The next two parameters, <i>lpSQOS</i> and <i>lpGQOS</i>, specify any quality of service (QOS) parameters that are being requested by the client. Both parameters reference a QOS structure that contains information regarding bandwidth requirements for both sending and receiving data. If the client is not requesting QOS, these parameters will be <i>NULL</i>. The difference between these two parameters is that <i>lpSQOS</i> refers to a single connection, while <i>lpGQOS</i> is used for socket groups. Socket groups are not implemented or supported in Winsock 1 or 2. (See <A HREF="ch12a.htm">Chapter 12</A> for further details about QOS.)</p>

<p>The <i>lpCalleeId</i> is another <i>WSABUF</i> structure containing the local address to which the client has connected. Again, the <i>buf</i> field of this structure points to a <i>SOCKADDR</i> object of the appropriate address family. This information is useful in the event that the server is running on a multihomed machine. Remember that if a server binds to the address <i>INADDR_ANY</i>, connection requests are serviced on any network interface. This parameter will contain the specific interface on which the connection occurred.</p>

<p>The <i>lpCalleeData</i> parameter is the complement of <i>lpCallerData</i>. The <i>lpCalleeData</i> parameter points to a <i>WSABUF</i> structure that the server can use to send data back to the client as a part of the connection request process. If the service provider supports this option, the <i>len</i> field indicates the maximum number of bytes the server can send back to the client as a part of this connection request. In this case, the server would copy any number of bytes up to this amount into the <i>buf</i> portion of the <i>WSABUF</i> structure and update the <i>len</i> field to indicate the number of bytes being transferred. If the server does not want to return any connect data, the conditional accept function should set the <i>len</i> field to 0 before returning. If the provider does not support connect data, the <i>len</i> field will be 0. Again, most protocols do not support data exchange upon accept. In fact, none of the currently supported protocols on any Win32 platform support this
feature.</p>

<p>Once the server has processed parameters passed into the conditional function, the server must indicate whether to accept, reject, or defer the client's connection request. If the server is accepting the connection, the conditional function should return <i>CF_ACCEPT</i>. Upon rejection, the function should return <i>CF_REJECT</i>. If for some reason the decision cannot be made at this time, <i>CF_DEFER</i> can be returned. When the server is prepared to handle this connection request, it should call <i>WSAAccept</i>. Note that the condition function runs in the same thread as the <i>WSAAccept</i> function and should return as soon as possible. Also be aware that for the protocols supported by the current Win32 platforms, the conditional accept function does not imply that the client's connection request is delayed until a value is returned from this conditional function. In most cases, the underlying network stack has already accepted the connection at the time the conditional accept function is
called. If the value <i>CF_REJECT</i> is returned, the underlying stack simply closes the connection. We won't go into the detailed usage of the conditional acceptance function now, as this information will be more useful in <A HREF="ch12a.htm">Chapter 12</A>.</p>

<p>If an error occurs, <i>INVALID_SOCKET</i> is returned. The most common error encountered is <i>WSAEWOULDBLOCK</i> if the listening socket is in asynchronous or nonblocking mode and there is no connection to be accepted. When a conditional function returns <i>CF_DEFER</i>, <i>WSAAccept</i> returns the error <i>WSATRY_AGAIN</i>. If the condition function returns <i>CF_REJECT</i>, the <i>WSAAccept</i> error is <i>WSAECONNREFUSED</i>.</p>

<A NAME="144"><H2>Client API Functions</H2></A>

<p>The client is much simpler and involves fewer steps to set up a successful connection. There are only three steps for a client:</p>

<ol>
<p><li>Create a socket with <i>socket</i> or <i>WSASocket</i>.</li></p>

<p><li>Resolve the server's name (dependent on underlying protocol).</li></p>

<p><li>Initiate the connection with <i>connect</i> or <i>WSAConnect</i>.</li></p>
</ol>

<p>You already know from <a href="ch06a.htm">Chapter 6</A> how to create the socket and resolve an IP host name, so the only remaining step is establishing a connection. <a href="ch06a.htm">Chapter 6</A> also covers the various name-resolution methods for other protocol families.</p>

<p>
<div class="sidebar"><blockquote>
<b>TCP States</b>
<p>As a Winsock programmer, you are not required to know the actual TCP states, but by knowing them you will gain a better understanding of how the Winsock API calls effect change in the underlying protocol. Additionally, many programmers run into a common problem when closing sockets; the TCP states surrounding a socket closure are of the most interest.</p>

<p>The start state of every socket is the CLOSED state. When a client initiates a connection, it sends a SYN packet to the server and puts the client socket in the SYN_SENT state. When the server receives the SYN packet, it sends a SYN-and-ACK packet, which the client responds to with an ACK packet. At this point, the client's socket is in the ESTABLISHED state. If the server never sends a SYN-ACK packet, the client times out and reverts to the CLOSED state.</p>

<p>When a server's socket is bound and is listening on a local interface and port, the state of the socket is LISTEN. When a client attempts a connection, the server receives a SYN packet and responds with a SYN-ACK packet. The state of the server's socket changes to SYN_RCVD. Finally, the client sends an ACK packet, which causes the state of the server's socket to change to ESTABLISHED.</p>

<p>Once the application is in the ESTABLISHED state, there are two paths for closure. If your application initiates the closure, the closure is known as an active socket closure; otherwise, the socket closure is passive. Figure 7-2 illustrates both an active and a passive closure. If you actively initiate a closure, your application sends a FIN packet. When your application calls <i>closesocket</i> or <i>shutdown</i> (with <i>SD_SEND</i> as its second argument), your application sends a FIN packet to the peer, and the state of your socket changes to FIN_WAIT_1. Normally, the peer responds with an ACK packet, and your socket's state becomes FIN_WAIT_2. If the peer also closes the connection, it sends a FIN packet and your computer responds by sending an ACK packet and placing your socket in the TIME_WAIT state.</p>

<p>The TIME_WAIT state is also called the 2MSL wait state. MSL stands for Maximum Segment Lifetime and represents the amount of time a packet can exist on the network before being discarded. Each IP packet has a time-to-live (TTL) field, which when decremented to 0 causes the packet to be discarded. Each router on the network that handles the packet decrements the TTL by 1 and passes the packet on. Once an application enters the TIME_WAIT state, it remains there for twice the MSL time. This allows TCP to re-send the final ACK in case it's lost, causing the FIN to be retransmitted. After the 2MSL wait state completes, the socket goes to the CLOSED state.</p>

<p>On an active close, two other paths lead to the TIME_WAIT state. In our previous discussion, only one side issues a FIN and receives an ACK response, but the peer is still free to send data until it too closes. This is where the other two paths come into play. In one path&#8212;the simultaneous close&#8212;a computer and its peer at the other side of a connection issue a close at the same time: the computer sends a FIN packet to the peer and receives a FIN packet from the peer. Then the computer sends an ACK packet in response to the peer's FIN packet and changes its socket to the CLOSING state. Once the computer receives the last ACK packet from the peer, the computer's socket state becomes TIME_WAIT. </p>

<p>
<A HREF="javascript:fullSize('F07JI02x.htm')"> <img src="images/F07JI02.JPG" width=404 height=181 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 7-2.</b> <i>TCP socket closure states</i><!-- /caption -->
</p>

<p>The other path for an active closure is just a variation on the simultaneous close: the socket transitions from the FIN_WAIT_1 state directly to the TIME_WAIT state. This occurs when an application sends a FIN packet but shortly thereafter receives a FIN-ACK packet from the peer. In this case, the peer is acknowledging the application's FIN packet and sending its own, to which the application responds with an ACK packet.</p>

<p>The major effect of the TIME_WAIT state is that while a TCP connection is in the 2MSL wait state, the socket pair defining that connection cannot be reused. A socket pair is the combination of local IP_local port and remote IPremote port. Some TCP implementations do not allow the reuse of any port number in a socket pair in the TIME_WAIT state. Microsoft's implementation does not suffer from this deficiency. However, if a connection is attempted in which the socket pair is already in the TIME_WAIT state, the connection attempt will fail with error <i>WSAEADDRINUSE</i>. One way around this (besides waiting for the socket pair that is using that local port to leave the TIME_WAIT state) is to use the socket option <i>SO_REUSEADDR</i>. <a href="ch09a.htm">Chapter 9</A> covers the <i>SO_REUSEADDR</i> option in detail.</p>

<p>The last point of discussion for socket states is the passive closure. In this scenario, an application receives a FIN packet from the peer and responds with an ACK packet. At this point, the application's socket changes to the CLOSE_WAIT state. Because the peer has closed its end, it can't send any more data, but the application still can until it also closes its end of the connection. To close its end of the connection, the application sends its own FIN, causing the application's TCP socket state to become LAST_ACK. After the application receives an ACK packet from the peer, the application's socket reverts to the CLOSED state.</p>

<p>For more information regarding the TCP/IP protocol, consult RFC 793. This RFC and others can be found at 
<a href="http://www.rfc-editor.org" target="_window2">http://www.rfc-editor.org</a>.</p>
</blockquote></div>
</p>

<A NAME="145"><h3><i>connect</i> and <i>WSAConnect</i></h3></A>
<p>The only new step is the connect. This is accomplished by calling either <i>connect</i> or <i>WSAConnect</i>. First we'll look at the Winsock 1 version of this function, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int connect(
    SOCKET s,
    const struct sockaddr FAR* name,
    int namelen
);
</pre>
</td></tr></table>
</p>

<p>The parameters are fairly self-explanatory: <i>s</i> is the valid TCP socket on which to establish the connection, <i>name</i> is the socket address structure (<i>SOCKADDR_IN</i>) for TCP that describes the server to connect to, and <i>namelen</i> is the length of the <i>name</i> variable. The Winsock 2 version is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSAConnect(
    SOCKET s,
    const struct sockaddr FAR * name, 
    int namelen, 
    LPWSABUF lpCallerData, 
    LPWSABUF lpCalleeData, 
    LPQOS lpSQOS, 
    LPQOS lpGQOS
);
</pre>
</td></tr></table>
</p>

<p>The first three parameters are exactly the same as the <i>connect</i> API function. The next two, <i>lpCallerData</i> and <i>lpCalleeData,</i> are string buffers used to send and receive data at the time of the connection request. The <i>lpCallerData</i> parameter is a pointer to a buffer that holds data the client sends to the server with the connection request. The <i>lpCalleeData</i> parameter points to a buffer that will be filled with any data sent back from the server at the time of connection setup. Both of these variables are <i>WSABUF</i> structures, so the <i>len</i> field needs to be set to the length of data in the <i>buf</i> field that is to be transferred in the case of <i>lpCallerData.</i> For <i>lpCalleeData</i>, the <i>len</i> field refers to the length of the buffer in <i>buf</i> that can receive data back from the server. The last two parameters, <i>lpSQOS</i> and <i>lpGQOS</i>, refer to QOS structures that define the bandwidth requirements for both sending and receiving data on the
connection to be established. The parameter <i>lpSQOS</i> is used to specify requirements for the socket <i>s</i>, while <i>lpGQOS</i> specifies the requirements for socket groups. Socket groups are not currently supported. A null value for <i>lpSQOS</i> indicates no application-specific QOS.</p>

<p>If the computer you're attempting to connect to does not have a process listening on the given port, the <i>connect</i> call fails with the error <i>WSAECONNREFUSED</i>. The other error you might encounter is <i>WSAETIMEDOUT</i>, which occurs if the destination you're trying to reach is unavailable (either because of a communication-hardware failure on the route to the host or because the host is not currently on the network).</p>

<A NAME="146"><H2>Data Transmission</H2></A>

<p>Sending and receiving data is what network programming is all about. For sending data on a connected socket, there are two API functions: <i>send</i> and <i>WSASend</i>. The second function is specific to Winsock 2. Likewise, two functions are for receiving data on a connected socket: <i>recv</i> and <i>WSARecv</i>. The latter is also a Winsock 2 call.</p>

<p>An important thing to keep in mind is that all buffers associated with sending and receiving data are of the simple <i>char</i> type. That is, there are no UNICODE versions of these functions. This is especially significant on Windows CE, as it uses UNICODE by default. In situations in which you are using UNICODE, you have the option of sending a character string as is or casting it as a <i>char *</i>. The catch is that if you use the string length function to tell the Winsock API functions how many characters to send or receive, you must multiply this value by 2 because each character occupies 2 bytes of the string array. The other option is to use <i>WideCharToMultiByte</i> to convert UNICODE to ASCII before passing the string data to the Winsock API functions.</p>

<p>Additionally, the error code returned by all send and receive functions is <i>SOCKET_ERROR</i>. Once an error is returned, call <i>WSAGetLastError</i> to obtain extended error information. The most common errors encountered are <i>WSAECONNABORTED</i> and <i>WSAECONNRESET</i>. Both of these deal with the connection being closed&#8212;either through a timeout or through the peer closing the connection. Another common error is <i>WSAEWOULDBLOCK</i>, which is normally encountered when either nonblocking or asynchronous sockets are used. This error basically means that the specified function cannot be completed at this time. In <a href="ch08a.htm">Chapter 8</A>, we will describe various Winsock I/O methods that can help you avoid some of these errors.</p>

<A NAME="147"><h3><i>send</i> and <i>WSASend</i></h3></A>
<p>The first API function to send data on a connected socket is <i>send</i>, which is prototyped as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int send(
    SOCKET s, 
    const char FAR * buf, 
    int len, 
    int flags
);
</pre>
</td></tr></table>
</p>

<p>The <i>SOCKET</i> parameter is the connected socket to send the data on. The second parameter, <i>buf</i>, is a pointer to the character buffer that contains the data to be sent. The third parameter, <i>len</i>, specifies the number of characters in the buffer to send. Finally, the <i>flags</i> parameter can be either 0, <i>MSG_DONTROUTE</i>, or <i>MSG_OOB</i>. Alternatively, the <i>flags</i> parameter can be a bitwise ORing of any of those flags. The <i>MSG_DONTROUTE</i> flag tells the transport not to route the packets it sends. It is up to the underlying transport to honor this request (for example, if the transport doesn't support this option, it will be ignored). The <i>MSG_OOB</i> flag signifies that the data should be sent out of band.</p>

<p>On a good return, <i>send</i> returns the number of bytes sent; otherwise, if an error occurs, <i>SOCKET_ERROR</i> is returned. A common error is <i>WSAECONNABORTED,</i> which occurs when the virtual circuit terminates because of a timeout failure or a protocol error. When this occurs, the socket should be closed, as it is no longer usable. The error <i>WSAECONNRESET</i> occurs when the application on the remote host resets the virtual circuit by executing a hard close or terminating unexpectedly, or when the remote host is rebooted. Again, the socket should be closed after this error occurs. The last common error is <i>WSAETIMEDOUT</i>, which occurs when the connection is dropped because of a network failure or the remote connected system going down without notice.</p>

<p>The Winsock 2 version of the <i>send</i> API function, <i>WSASend</i>, is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSASend(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesSent,
    DWORD dwFlags,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionROUTINE
);
</pre>
</td></tr></table>
</p>

<p>The socket is a valid handle to a connection session. The second parameter is a pointer to one or more <i>WSABUF</i> structures. This can be either a single structure or an array of such structures. The third parameter indicates the number of <i>WSABUF</i> structures being passed. Remember that each <i>WSABUF</i> structure is itself a character buffer and the length of that buffer. You might wonder why you would want to send more than one buffer at a time. This is called scatter-gather I/O and will be discussed later in this chapter; however, in the case of data sent using multiple buffers on a connected socket, each buffer is sent from the first to the last <i>WSABUF</i> structure in the array. The <i>lpNumberOfBytesSent</i> is a pointer to a <i>DWORD</i> that on return from the <i>WSASend</i> call contains the total number of bytes sent. The <i>dwFlags</i> parameter is equivalent to its counterpart in <i>send</i>. The last two parameters, <i>lpOverlapped</i> and <i>lpCompletionROUTINE</i>, are used for
overlapped I/O. Overlapped I/O is one of the asynchronous I/O models supported by Winsock and is discussed in detail in <a href="ch08a.htm">Chapter 8</a>.</p>

<p>The <i>WSASend</i> function sets <i>lpNumberOfBytesSent</i> to the number of bytes written. The function returns 0 on success and <i>SOCKET_ERROR</i> on any error, and generally encounters the same errors as the <i>send</i> function.</p>

<A NAME="148"><h3><i>WSASendDisconnect</i></h3></A>
<p>This function is rather specialized and not generally used. The function prototype is</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSASendDisconnect (
    SOCKET s, 
    LPWSABUF lpOUT boundDisconnectData
);
</pre>
</td></tr></table>
</p>

<p>
<div class="sidebar"><blockquote>
<b>Out-of-Band Data</b>
<p>When an application on a connected stream socket needs to send data that is more important than regular data on the stream, it can mark the important data as out-of-band (OOB) data. The application on the other end of a connection can receive and process OOB data through a separate logical channel that is conceptually independent of the data stream.</p> 

<p>In TCP, OOB data is implemented via an urgent 1-bit marker (called URG) and a 16-bit pointer in the TCP segment header that identify a specific downstream byte as urgent data. Two specific ways of implementing urgent data currently exist for TCP. RFC 793, which describes TCP and introduces the concept of urgent data, indicates that the urgent pointer in the TCP header is a positive offset to the byte that follows the urgent data byte. However, RFC 1122 describes the urgent offset as pointing to the urgent byte itself.</p>

<p>The Winsock specification uses the term OOB to refer to both protocol-independent OOB data and TCP's implementation of OOB data (urgent data). In order to check whether pending data contains urgent data, you must call the <i>ioctlsocket</i> function with the <i>SIOCATMARK</i> option. <a href="ch09a.htm">Chapter 9</A> discusses how to use <i>SIOCATMARK</i>.</p>

<p>Winsock provides several methods for obtaining the urgent data. Either the urgent data is inlined so that it appears in the normal data stream, or in-lining can be turned off so that a discrete call to a receive function returns only the urgent data. The socket option <i>SO_OOBINLINE</i>, also discussed in detail in <a href="ch09a.htm">Chapter 9</A>, controls the behavior of OOB data.</p>

<p>Telnet and Rlogin use urgent data for several reasons. However, unless you plan on writing your own Telnet or Rlogin, you should stay away from urgent data. It's not well defined and might be implemented differently on platforms other than Win32. If you require a method of signaling the peer for urgent reasons, implement a separate control socket for this urgent data and reserve the main socket connection for normal data transfers.</p>
</blockquote></div>
</p>

<p>The function initiates a shutdown of the socket and sends disconnect data. Of course, this function is available only to those transport protocols that support graceful close and disconnect data. None of the transport providers currently support disconnect data. The <i>WSASendDisconnect</i> function behaves like a call to the <i>shutdown</i> function with an <i>SD_SEND</i> argument, but it also sends the data contained in its <i>boundDisconnectData</i> parameter. Subsequent sends are not allowed on the socket. Upon failure, <i>WSASendDisconnect</i> returns <i>SOCKET_ERROR</i>. This function can encounter some of the same errors as the <i>send</i> function.</p>

<A NAME="149"><h3><i>recv</i> and <i>WSARecv</i></h3></A>
<p>The <i>recv</i> function is the most basic way to accept incoming data on a connected socket. This function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int recv(
    SOCKET s, 
    char FAR* buf, 
    int len, 
    int flags
);
</pre>
</td></tr></table>
</p>

<p>The first parameter, <i>s</i>, is the socket on which data will be received. The second parameter, <i>buf</i>, is the character buffer that will receive the data, while <i>len</i> is either the number of bytes you want to receive or the size of the buffer, <i>buf</i>. Finally, the <i>flags</i> parameter can be one of the following values: 0, <i>MSG_PEEK</i>, or <i>MSG_OOB</i>. Additionally, you can bitwise OR any one of these flags together. Of course, 0 specifies no special actions. <i>MSG_PEEK</i> causes the data that is available to be copied into the supplied receive buffer, but this data is not removed from the system's buffer. The number of bytes pending is also returned.</p>

<p>Message peeking is bad. Not only does it degrade performance, as you now need to make two system calls (one to peek and one without the <i>MSG_PEEK</i> flag to actually remove the data), but it is also unreliable under certain circumstances. The data returned might not reflect the entire amount available. Also, by leaving data in the system buffers, the system has less and less space to contain incoming data. As a result, the system reduces the TCP window size for all senders. This prevents your application from achieving the maximum possible throughput. The best thing to do is to copy all the data you can into your own buffer and manipulate it there. You have seen the <i>MSG_OOB</i> flag before in the discussion on sending data. Refer to the previous section for more information.</p>

<p>There are some considerations when using <i>recv</i> on a message- or datagram-based socket. In the event that the data pending is larger than the supplied buffer, the buffer is filled with as much data as it will contain. In this event, the <i>recv</i> call generates the error <i>WSAEMSGSIZE.</i> Note that the message-size error occurs with message-oriented protocols. Stream protocols buffer incoming data and will return as much data as the application requests, even if the amount of pending data is greater. Thus, for streaming protocols you will not encounter the <i>WSAEMSGSIZE</i> error.</p>

<p>The <i>WSARecv</i> function adds some new capabilities over <i>recv,</i> such as overlapped I/O and partial datagram notifications. The definition of <i>WSARecv</i> is</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSARecv(
    SOCKET s, 
    LPWSABUF lpBuffers, 
    DWORD dwBufferCount, 
    LPDWORD lpNumberOfBytesRecvd, 
    LPDWORD lpFlags, 
    LPWSAOVERLAPPED lpOverlapped, 
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionROUTINE
);
</pre>
</td></tr></table>
</p>

<p>Parameter <i>s</i> is the connected socket. The second and third parameters are the buffers to receive the data. The <i>lpBuffers</i> parameter is an array of <i>WSABUF</i> structures, while <i>dwBufferCount</i> indicates the number of <i>WSABUF</i> structures in the array. The <i>lpNumberOfBytesReceived</i> parameter points to the number of bytes received by this call if the receive operation completes immediately. The <i>lpFlags</i> parameter can be one of the values <i>MSG_PEEK</i>, <i>MSG_OOB</i>, or <i>MSG_PARTIAL</i> or a bitwise ORed combination of those values. The <i>MSG_PARTIAL</i> flag has several different meanings depending on where it is used or encountered. For message-oriented protocols, this flag is set upon return from <i>WSARecv</i> (if the entire message could not be returned in this call because of insufficient buffer space). In this case, subsequent <i>WSARecv</i> calls set this flag until the entire message is returned, when the <i>MSG_PARTIAL</i> flag is cleared. If this flag is
passed as an input parameter, the receive operation should complete as soon as data is available, even if it is only a portion of the entire message. The <i>MSG_PARTIAL</i> flag is used only with message-oriented protocols, not with streaming ones. Additionally, not all protocols support partial messages. The protocol entry for each protocol contains a flag indicating whether it supports this feature. See <a href="ch05a.htm">Chapter 5</A> for more information. The <i>lpOverlapped</i> and <i>lpCompletionROUTINE</i> parameters are used in overlapped I/O operations, discussed in <a href="ch08a.htm">Chapter 8</A>.</p>

<A NAME="150"><h3><i>WSARecvDisconnect</i></h3></A>
<p>This function is the opposite of <i>WSASendDisconnect</i> and is defined as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSARecvDisconnect(
    SOCKET s, 
    LPWSABUF lpInboundDisconnectData
);
</pre>
</td></tr></table>
</p>

<p>Like its sending counterpart, the parameters are the connected socket handle and a valid <i>WSABUF</i> structure with the data to be received. The data received can only be disconnect data sent by a <i>WSASendDisconnect</i> on the other side; it cannot be used to receive normal data. Additionally, once the data is received, this function disables reception from the remote party, which is equivalent to calling the <i>shutdown</i> function with <i>SD_RECV</i>.</p>

<A NAME="151"><h3><i>WSARecvEx</i></h3></A>
<p>The <i>WSARecvEx</i> function is a Microsoft-specific extension of Winsock 1 and is identical to the <i>recv</i> function except that the <i>flags</i> parameter is passed by reference. This allows the underlying provider to set the <i>MSG_PARTIAL</i> flag. The function prototype is as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int PASCAL FAR WSARecvEx(
    SOCKET s, 
    char FAR * buf, 
    int len, 
    int *flags
);
</pre>
</td></tr></table>
</p>

<p>The <i>MSG_PARTIAL</i> flag is returned in the <i>flags</i> parameter if the data received is not a complete message. This flag is of interest for message-oriented (nonstream) protocols. If the <i>MSG_PARTIAL</i> flag is passed as a part of the <i>flags</i> parameter and a partial message is received, the call returns immediately with that data. If the supplied receive buffer is not large enough to hold an entire message, <i>WSARecvEx</i> fails with the <i>WSAEMSGSIZE</i> error and the remaining data is truncated. Note that the difference between a <i>MSG</i>_<i>PARTIAL</i> flag and a <i>WSAEMSGSIZE</i> error is that with the error, the whole message arrives but the supplied data buffer is too small to receive it. The <i>MSG_PEEK</i> and <i>MSG_OOB</i> flags can also be used with <i>WSARecvEx</i>.</p>

<A NAME="152"><H2>Stream Protocols</H2></A>

<p>Because most connection-oriented protocols are also streaming protocols, we'll mention stream protocols here. The main thing to be aware of with <i>any</i> function that sends or receives data on a stream socket is that you are not guaranteed to read or write the amount of data you request. Let's say you have a character buffer with 2048 bytes of data you want to send with the <i>send</i> function. The code to send this is</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
char sendbuff[2048];
int  nBytes = 2048;

// Fill sendbuff with 2048 bytes of data

// Assume s is a valid, connected stream socket
ret = send(s, sendbuff, nBytes, 0);
</pre>
</td></tr></table>
</p>

<p>It is possible for <i>send</i> to return having sent less than 2048 bytes. The <i>ret</i> variable will be set to the number of bytes sent because the system allocates a certain amount of buffer space for each socket to send and receive data. In the case of sending data, the internal buffers hold data to be sent until such time as the data can be placed on the wire. Several common situations can cause this. For example, simply transmitting a huge amount of data will cause these buffers to become filled quickly. Also, for TCP/IP, there is what is known as the window size. The receiving end will adjust this window size to indicate how much data it can receive. If the receiver is being flooded with data, it might set the window size to 0 in order to catch up with the pending data. This will force the sender to stop until it receives a new window size greater than 0. In the case of our <i>send</i> call, there might only be buffer space to hold 1024 bytes, in which case you would have to resubmit the remaining
1024 bytes. The following code ensures that all your bytes are sent.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
char sendbuff[2048];
int  nBytes = 2048,
     nLeft,
     idx;

// Fill sendbuff with 2048 bytes of data

// Assume s is a valid, connected stream socket
nLeft = nBytes;
idx = 0;
while (nLeft &gt; 0)
{
    ret = send(s, &amp;sendbuff[idx], nLeft, 0);
    if (ret == SOCKET_ERROR)
    {
        // Error
    }
    nLeft -= ret;
    idx += ret;
}
</pre>
</td></tr></table>
</p>

<p>The foregoing holds true for receiving data on a stream socket but is less significant. Because stream sockets are a continuous stream of data, when an application reads it isn't generally concerned with how much data it should read. If your application requires discrete messages over a stream protocol, you might have to do a little work. If all the messages are the same size, life is pretty simple, and the code for reading, say, 512-byte messages would look like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
char    recvbuff[1024];
int     ret,
        nLeft,
        idx;

nLeft = 512;
idx = 0;
while (nLeft &gt; 0)
{
    ret = recv(s, &amp;recvbuff[idx], nLeft, 0);
    if (ret == SOCKET_ERROR)
    {
        // Error
    }
    idx += ret;
    nLeft -= ret;
}
</pre>
</td></tr></table>
</p>

<p>Things get a little complicated if your message sizes vary. It is necessary to impose your own protocol to let the receiver know how big the forthcoming message will be. For example, the first 4 bytes written to the receiver will always be the integer size in bytes of the forthcoming message. The receiver will start every read by looking at the first 4 bytes, converting them to an integer, and determining how many additional bytes that message comprises.</p>

<p>
<div class="sidebar"><blockquote>
<b>Scatter-Gather I/O</b>
<p>Scatter-gather support is a concept originally introduced in Berkeley Sockets with the functions <i>recv</i> and <i>writev</i>. This feature is available with the Winsock 2 functions <i>WSARecv</i>, <i>WSARecvFrom</i>, <i>WSASend</i>, and <i>WSASendTo</i>. It is most useful for applications that send and receive data that is formatted in a very specific way. For example, messages from a client to a server might always be composed of a fixed 32-byte header specifying some operation, followed by a 64-byte data block and terminated with a 16-byte trailer. In this example, <i>WSASend</i> can be called with an array of three <i>WSABUF</i> structures, each corresponding to the three message types. On the receiving end, <i>WSARecv</i> is called with three <i>WSABUF</i> structures, each containing data buffers of 32 bytes, 64 bytes, and 16 bytes.</p>

<p>When using stream-based sockets, scatter-gather operations simply treat the supplied data buffers in the <i>WSABUF</i> structures as one contiguous buffer. Also, the receive call might return before all buffers are full. On message-based sockets, each call to a receive operation receives a single message up to the buffer size supplied. If the buffer space is insufficient, the call fails with <i>WSAEMSGSIZE</i> and the data is truncated to fit the available space. Of course, with protocols that support partial messages, the <i>MSG_PARTIAL</i> flag can be used to prevent data loss.</p></blockquote></div>
</p>

<A NAME="153"><H2>Breaking the Connection</H2></A>

<p>Once you are finished with a socket connection, you must close the connection and release any resources associated with that socket handle. To actually release the resources associated with an open socket handle, use the <i>closesocket</i> call. Be aware, however, that <i>closesocket</i> can have some adverse affects&#8212;depending on how it is called&#8212;that can lead to data loss. For this reason, a connection should be gracefully terminated with the <i>shutdown</i> function before a call to the <i>closesocket</i> function. These two API functions are discussed next.</p>

<A NAME="154"><h3><i>shutdown</i></h3></A>
<p>To ensure that all data an application sends is received by the peer, a well-written application should notify the receiver that no more data is to be sent. Likewise, the peer should do the same. This is known as a graceful close and is performed by the <i>shutdown</i> function, defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int shutdown(
    SOCKET s, 
    int how
);
</pre>
</td></tr></table>
</p>

<p>The <i>how</i> parameter can be <i>SD_RECEIVE</i>, <i>SD_SEND</i>, or <i>SD_BOTH</i>. For <i>SD_RECEIVE</i>, subsequent calls to any receive function on the socket are disallowed. This has no effect on the lower protocol layers. Additionally for TCP sockets, if data is queued for receive or if data subsequently arrives, the connection is reset. However, on UDP sockets incoming data is still accepted and queued. For <i>SD_SEND</i>, subsequent calls to any send function are disallowed. For TCP sockets, this causes a FIN packet to be generated after all data is sent and acknowledged by the receiver. Finally, specifying <i>SD_BOTH</i> disables both sends and receives.</p>

<A NAME="155"><h3><i>closesocket</i></h3></A>
<p>The <i>closesocket</i> function closes a socket and is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int closesocket (SOCKET s);
</pre>
</td></tr></table>
</p>

<p>Calling <i>closesocket</i> releases the socket descriptor and any further calls using the socket fail with <i>WSAENOTSOCK.</i> If there are no other references to this socket, all resources associated with the descriptor are released. This includes discarding any queued data.</p>

<p>Pending asynchronous calls issued by any thread in this process are canceled without posting any notification messages. Pending overlapped operations are also canceled. Any event, completion routine, or completion port that is associated with the overlapped operation is performed but will fail with the error <i>WSA_OPERATION_ABORTED</i>. Asynchronous and nonblocking I/O models are discussed in greater depth in <a href="ch08a.htm">Chapter 8</A>. Additionally, one other factor influences the behavior of <i>closesocket</i>: whether the socket option <i>SO_LINGER</i> has been set. Consult the description for the <i>SO_LINGER</i> option in <a href="ch09a.htm">Chapter 9</A> for a complete explanation.</p>

<A NAME="156"><H2>Putting It All Together</H2></A>

<p>You might be a bit overwhelmed by the multitude of functions for sending and receiving data, but in reality most applications only need either <i>recv</i> or <i>WSARecv</i> for receiving data and either <i>send</i> or <i>WSASend</i> for sending. The other functions are specialized with unique features not commonly used (or supported by the transport protocols). With this said, we'll discuss a simple client/server example using the principles and functions we've covered so far. Figure 7-3 contains the code for a simple echo server. This application creates a socket, binds to a local IP interface and port, and listens for client connections. Upon receipt of a client connection request, a new socket is created that is passed into a client thread that is spawned. The thread simply reads data and sends it back to the client.</p>

<p><b>Figure 7-3.</b> <i>Echo server code</i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
// Module Name: Server.c
//
// Description:
//    This example illustrates a simple TCP server that accepts 
//    incoming client connections. Once a client connection is 
//    established, a thread is spawned to read data from the 
//    client and echo it back (if the echo option is not 
//    disabled).
//
// Compile:
//    cl -o Server Server.c ws2_32.lib
//
// Command line options:
//    server [-p:x] [-i:IP] [-o]
//           -p:x      Port number to listen on
//           -i:str    Interface to listen on
//           -o        Receive only; don't echo the data back
//
#include &lt;winsock2.h&gt;

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define DEFAULT_PORT        5150
#define DEFAULT_BUFFER      4096

int    iPort      = DEFAULT_PORT; // Port to listen for clients on

BOOL   bInterface = FALSE,   // Listen on the specified interface
       bRecvOnly  = FALSE;   // Receive data only; don't echo back
char   szAddress[128];       // Interface to listen for clients on

//
// Function: usage
//
// Description:
//    Print usage information and exit
//
void usage()
{
    printf(&quot;usage: server [-p:x] [-i:IP] [-o]\n\n&quot;);
    printf(&quot;       -p:x      Port number to listen on\n&quot;);
    printf(&quot;       -i:str    Interface to listen on\n&quot;);
    printf(&quot;       -o        Don't echo the data back\n\n&quot;);
    ExitProcess(1);
}
  
//
// Function: ValidateArgs
//
// Description:
//    Parse the command line arguments, and set some global flags 
//    to indicate what actions to perform
//
void ValidateArgs(int argc, char **argv)
{
    int i;

    for(i = 1; i &lt; argc; i++)
    {
        if ((argv[i][0] == '-') || (argv[i][0] == '/'))
        {
            switch (tolower(argv[i][1]))
            {
                case 'p':
                    iPort = atoi(&amp;argv[i][3]);
                    break;
                case 'i':
                    bInterface = TRUE;
                    if (strlen(argv[i]) &gt; 3)
                        strcpy(szAddress, &amp;argv[i][3]);
                    break;
                case 'o':
                    bRecvOnly = TRUE;
                    break;
                default:
                    usage();
                    break;
            }
        }
    }
}

//
// Function: ClientThread
//
// Description:
//    This function is called as a thread, and it handles a given
//    client connection.  The parameter passed in is the socket 
//    handle returned from an accept() call.  This function reads
//    data from the client and writes it back.
//
DWORD WINAPI ClientThread(LPVOID lpParam)
{
    SOCKET        sock=(SOCKET)lpParam;
    char          szBuff[DEFAULT_BUFFER];
    int           ret,
                  nLeft,
                  idx;

    while(1)
    {
        // Perform a blocking recv() call
        //
        ret = recv(sock, szBuff, DEFAULT_BUFFER, 0);
        if (ret == 0)        // Graceful close
            break;
        else if (ret == SOCKET_ERROR)
        {
            printf(&quot;recv() failed: %d\n&quot;, WSAGetLastError());
            break;
        }
        szBuff[ret] = '\0';
        printf(&quot;RECV: '%s'\n&quot;, szBuff);
        //
        // If we selected to echo the data back, do it 
        //
        if (!bRecvOnly)
        {
            nLeft = ret;
            idx = 0;
            //
            // Make sure we write all the data
            //
            while(nLeft &gt; 0)
            {
                ret = send(sock, &amp;szBuff[idx], nLeft, 0);
                if (ret == 0)
                    break;
                else if (ret == SOCKET_ERROR)
                {
                    printf(&quot;send() failed: %d\n&quot;, 
                        WSAGetLastError());
                    break;
                }
                nLeft -= ret;
                idx += ret;
            }
        }
    }
    return 0;
}

//
// Function: main
//
// Description:
//    Main thread of execution. Initialize Winsock, parse the
//    command line arguments, create the listening socket, bind
//    to the local address, and wait for client connections.
//
int main(int argc, char **argv)
{
    WSADATA       wsd;
    SOCKET        sListen,
                  sClient;
    int           iAddrSize;
    HANDLE        hThread;
    DWORD         dwThreadId;
    struct sockaddr_in local,
                       client;

    ValidateArgs(argc, argv);
    if (WSAStartup(MAKEWORD(2,2), &amp;wsd) != 0)
    {
        printf(&quot;Failed to load Winsock!\n&quot;);
        return 1;
    }

    // Create our listening socket
    //
    sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);
    if (sListen == SOCKET_ERROR)
    {
        printf(&quot;socket() failed: %d\n&quot;, WSAGetLastError());
        return 1;
    }
    // Select the local interface, and bind to it
    //
    if (bInterface)
    {
        local.sin_addr.s_addr = inet_addr(szAddress);
        if (local.sin_addr.s_addr == INADDR_NONE)
            usage();
    }
    else
        local.sin_addr.s_addr = htonl(INADDR_ANY);
    local.sin_family = AF_INET;
    local.sin_port = htons(iPort);

    if (bind(sListen, (struct sockaddr *)&amp;local, 
            sizeof(local)) == SOCKET_ERROR)
    {
        printf(&quot;bind() failed: %d\n&quot;, WSAGetLastError());
        return 1;
    }
    listen(sListen, 8);
    //
    // In a continuous loop, wait for incoming clients. Once one 
    // is detected, create a thread and pass the handle off to it.
    //
    while (1)
    {
        iAddrSize = sizeof(client);
        sClient = accept(sListen, (struct sockaddr *)&amp;client,
                        &amp;iAddrSize);        
        if (sClient == INVALID_SOCKET)
        {        
            printf(&quot;accept() failed: %d\n&quot;, WSAGetLastError());
            break;
        }
        printf(&quot;Accepted client: %s:%d\n&quot;, 
            inet_ntoa(client.sin_addr), ntohs(client.sin_port));

        hThread = CreateThread(NULL, 0, ClientThread, 
                    (LPVOID)sClient, 0, &amp;dwThreadId);
        if (hThread == NULL)
        {
            printf(&quot;CreateThread() failed: %d\n&quot;, GetLastError());
            break;
        }
        CloseHandle(hThread);
    }
    closesocket(sListen);
    
    WSACleanup();
    return 0;
}
</pre>
</td></tr></table>
</p>

<p>The client for this example, provided in Figure 7-4, is even more basic. The client creates a socket, resolves the server name passed into the application, and connects to the server. Once the connection is made, a number of messages are sent. After each send, the client waits for an echo response from the server. The client prints all data read from the socket.</p>

<p>The echo client and server don't fully illustrate the streaming nature of TCP. This is because a read operation follows every write operation, at least in the client's case. Of course, it is the other way around for the server. Thus, each call to the read function by the server will almost always return the full message that the client sent. Don't be misled by this. If the client's messages become large enough to exceed the maximum transmission unit for TCP, the message will be broken up into separate packets on the wire, in which case the receiver needs to perform a receive call multiple times. In order to better illustrate streaming, run the client and the server with the -o option. This causes the client to only send data and the receiver to only read data. Execute the server like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
server -p:5150 -o
</pre>
</td></tr></table>
</p>

<p>and the client like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
client -p:5150 -s:IP -n:10 -o
</pre>
</td></tr></table>
</p>

<p>What you'll most likely see is that the client calls <i>send</i> 10 times, but the server reads all 10 messages in one or two <i>recv</i> calls.</p>

<p><b>Figure 7-4.</b> <i>Echo client code</i> </p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
// Module Name: Client.c
//
// Description:
//    This sample is the echo client. It connects to the TCP server,
//    sends data, and reads data back from the server. 
//
// Compile:
//    cl -o Client Client.c ws2_32.lib
//
// Command Line Options:
//    client [-p:x] [-s:IP] [-n:x] [-o]
//           -p:x      Remote port to send to
//           -s:IP     Server's IP address or host name
//           -n:x      Number of times to send message
//           -o        Send messages only; don't receive
//  
#include &lt;winsock2.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define DEFAULT_COUNT       20
#define DEFAULT_PORT        5150
#define DEFAULT_BUFFER      2048
#define DEFAULT_MESSAGE     &quot;This is a test of the emergency \
broadcasting system&quot;

char  szServer[128],          // Server to connect to
      szMessage[1024];        // Message to send to sever
int   iPort     = DEFAULT_PORT;  // Port on server to connect to
DWORD dwCount   = DEFAULT_COUNT; // Number of times to send message
BOOL  bSendOnly = FALSE;         // Send data only; don't receive

//
// Function: usage:
//
// Description:
//    Print usage information and exit
//
void usage()
{
    printf(&quot;usage: client [-p:x] [-s:IP] [-n:x] [-o]\n\n&quot;);
    printf(&quot;       -p:x      Remote port to send to\n&quot;);
    printf(&quot;       -s:IP     Server's IP address or host name\n&quot;);
    printf(&quot;       -n:x      Number of times to send message\n&quot;);
    printf(&quot;       -o        Send messages only; don't receive\n&quot;);
    ExitProcess(1);
}

//
// Function: ValidateArgs
//
// Description:
//    Parse the command line arguments, and set some global flags 
//    to indicate what actions to perform
//
void ValidateArgs(int argc, char **argv)
{
    int                i;

    for(i = 1; i &lt; argc; i++)
    {
        if ((argv[i][0] == '-') || (argv[i][0] == '/'))
        {
            switch (tolower(argv[i][1]))
            {
                case 'p':        // Remote port
                    if (strlen(argv[i]) &gt; 3)
                        iPort = atoi(&amp;argv[i][3]);
                    break;
                case 's':       // Server
                    if (strlen(argv[i]) &gt; 3)
                        strcpy(szServer, &amp;argv[i][3]);
                    break;
                case 'n':       // Number of times to send message
                    if (strlen(argv[i]) &gt; 3)
                        dwCount = atol(&amp;argv[i][3]);
                    break;
                case 'o':       // Only send message; don't receive
                    bSendOnly = TRUE;
                    break;
                default:
                    usage();
                    break;
            }
        }
    }
}

// 
// Function: main
//
// Description:
//    Main thread of execution. Initialize Winsock, parse the 
//    command line arguments, create a socket, connect to the 
//    server, and then send and receive data
//
int main(int argc, char **argv)
{
    WSADATA       wsd;
    SOCKET        sClient;
    char          szBuffer[DEFAULT_BUFFER];
    int           ret,
                  i;

    struct sockaddr_in server;
    struct hostent    *host = NULL;

    // Parse the command line, and load Winsock
    //
    ValidateArgs(argc, argv);
    if (WSAStartup(MAKEWORD(2,2), &amp;wsd) != 0)
    {
        printf(&quot;Failed to load Winsock library!\n&quot;);
        return 1;
    }
    strcpy(szMessage, DEFAULT_MESSAGE);
    //
    // Create the socket, and attempt to connect to the server
    //
    sClient = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sClient == INVALID_SOCKET)
    {
        printf(&quot;socket() failed: %d\n&quot;, WSAGetLastError());
        return 1;
    }
    server.sin_family = AF_INET;
    server.sin_port = htons(iPort);
    server.sin_addr.s_addr = inet_addr(szServer);
    //
    // If the supplied server address wasn't in the form 
    // &quot;aaa.bbb.ccc.ddd,&quot; it's a host name, so try to resolve it
    //
    if (server.sin_addr.s_addr == INADDR_NONE)
    {
        host = gethostbyname(szServer);
        if (host == NULL)
        {
            printf(&quot;Unable to resolve server: %s\n&quot;, szServer);
            return 1;
        }
        CopyMemory(&amp;server.sin_addr, host-&gt;h_addr_list[0],
            host-&gt;h_length);
    }
    if (connect(sClient, (struct sockaddr *)&amp;server, 
        sizeof(server)) == SOCKET_ERROR)
    {
        printf(&quot;connect() failed: %d\n&quot;, WSAGetLastError());
        return 1;
    }
    // Send and receive data 
    //
    for(i = 0; i &lt; dwCount; i++)
    {
        ret = send(sClient, szMessage, strlen(szMessage), 0);
        if (ret == 0)
            break;
        else if (ret == SOCKET_ERROR)
        {
            printf(&quot;send() failed: %d\n&quot;, WSAGetLastError());
            break;
        }
        printf(&quot;Send %d bytes\n&quot;, ret);
        if (!bSendOnly)
        {
            ret = recv(sClient, szBuffer, DEFAULT_BUFFER, 0);
            if (ret == 0)        // Graceful close
                break;
            else if (ret == SOCKET_ERROR)
            {
                printf(&quot;recv() failed: %d\n&quot;, WSAGetLastError());
                break;
            }
            szBuffer[ret] = '\0';
            printf(&quot;RECV [%d bytes]: '%s'\n&quot;, ret, szBuffer);
        }
    }
    closesocket(sClient);

    WSACleanup();
    return 0;
}
</pre>
</td></tr></table>
</p>

</BODY>
</HTML>




