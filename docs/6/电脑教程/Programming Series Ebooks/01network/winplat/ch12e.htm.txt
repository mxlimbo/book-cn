<HTML>
<HEAD>
<TITLE>Programming QOS</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch12d.htm" , "ch12f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="389"><H1>Programming QOS</H1></A>

<p>Central to QOS is the initiation of an RSVP session. It's not until the RSVP PATH and RESV messages have been sent and processed that bandwidth is reserved for the process. Knowing when RSVP messages are generated is important to applications. For senders, three parameters must be known before a PATH message is generated:</p>

<ul>
<p><li> Sending <i>FLOWSPEC</i> member</li></p>

<p><li> Source IP address and port</li></p>

<p><li> Destination IP address, port, and protocol</li></p>
</ul>



<p>The <i>FLOWSPEC</i> member is known whenever a QOS-enabled function is called, such as <i>WSAConnect</i>, <i>WSAJoinLeaf</i>, <i>WSAIoctl</i> (with the <i>SIO_SET_QOS</i> option), and so on. The source IP address and port will not be known until the socket is bound locally, either implicitly (such as by connecting) or explicitly by bind. Finally, the application needs the data's destination. This information is gathered upon either a connect call or, in the case of connectionless UDP, the setting of the <i>QOS_DESTADDR</i> object in the provider-specific data passed using the <i>SIO_SET_QOS</i> ioctl command.</p>

<p>Similarly, for an RSVP RESV message to be generated, three things must be known:</p>

<ul>
<p><li> Receiving <i>FLOWSPEC</i> member</li></p>

<p><li> Address and port of each sender</li></p>

<p><li> Local address and port of the receiving socket</li></p>
</ul>



<p>The receiving <i>FLOWSPEC</i> member is obtained from any of the QOS-enabled Winsock functions. The address and port of each sender depend on the filter style, which can be set manually via the <i>RSVP_RESERVE_INFO</i> provider-specific structure, discussed earlier. Otherwise, this information is obtained from a PATH message. Of course, depending on the socket type, it is not always necessary to have already received a PATH statement to obtain the sender's address to generate RESV messages. The wildcard filter style used in multicasting is an example of this. The RESV message sent applies to all senders in the session. The local address and port are self-explanatory for unicast and UDP receivers but not for multicast receivers. In the case of multicast receivers, the local address and port are the multicast address and its corresponding port number.</p>

<p>In this section, we'll first cover the different socket types and their interaction with the QOS service provider and RSVP messages. Then we'll take a look at how the QOS service provider notifies applications of certain events. Understanding these concepts is central to writing successful QOS-enabled applications. Programming such applications is a matter of knowing how to obtain QOS guarantees as well as knowing when those guarantees are put into effect and when and how they can change.</p>

<A NAME="390"><H2>RSVP and Socket Types</H2></A>

<p>We now have a basic understanding of how PATH and RESV RSVP messages are generated. In the following sections, we'll look at the different types of sockets&#8212;UDP, TCP, and multicast UDP&#8212;and how they interact with the QOS service provider to generate PATH and RESV messages.</p>

<A NAME="391"><H3>Unicast UDP</H3></A>

<p>Because you have the option of using either connected or unconnected UDP sockets, setting QOS on unicast UDP sockets presents quite a few options. In the case of the UDP sender, the sending <i>FLOWSPEC</i> is obtained from one of the QOS-invoking functions. The local address and port are obtained either from an explicit bind call or from an implicit bind done by <i>WSAConnect</i>. The last piece is the address and port of the receiving application, which can be specified either in <i>WSAConnect</i> or via the <i>QOS_DESTADDR</i> provider-specific structure passed through the <i>SIO_SET_QOS</i> option. Be aware that if <i>SIO_SET_QOS</i> is used to set QOS, the socket must be bound beforehand.</p>

<p>For the UDP receiver, <i>WSAConnect</i> can be called to limit the receiving application to a single sender. Additionally, applications can specify a <i>QOS_DESTADDR</i> structure with the <i>SIO_SET_QOS</i> ioctl command. Otherwise, the <i>SIO_SET_QOS</i> can be called without providing any kind of destination address. In this case, a RESV message will be generated with the wildcard filter style. In fact, specifying the destination address via <i>WSAConnect</i> or via the <i>QOS_DESTADDR</i> structure should be done only if you want the application to receive data from only one sender that uses the fixed filter style.</p>

<p>The UDP receiver can actually call both <i>WSAConnect</i> and the <i>SIO_SET_QOS</i> ioctl command in any order. If <i>SIO_SET_QOS</i> is called before <i>WSAConnect</i>, a RESV message is created with the wildcard filter first. Once the connect call is made, the previous RESV session is torn down and a new one is generated with the fixed filter style. Alternatively, calling <i>SIO_SET_QOS</i> after <i>WSAConnect</i> and a fixed filter RESV message does not negate the RSVP session and generate a wildcard filter style. Instead it simply updates the QOS parameters associated with the existing RSVP session.</p>

<A NAME="392"><H3>Unicast TCP</H3></A>

<p>TCP sessions have two possibilities. First, the sender can be the client who connects to the server and sends data. The second possibility is that the server that the client connects to might be the sender. In the case of the client, QOS parameters can be specified directly in the <i>WSAConnect</i> call, which will result in PATH messages being sent. The ioctl command <i>SIO_SET_QOS</i> can also be called before calling connect, but until one of the connect calls knows the destination address, no PATH messages will be generated.</p>

<p>In the case in which the sender is the server, the server calls <i>WSAAccept</i> to accept the client connection. This function does not provide a means of setting QOS on the accepted socket. If QOS is set before a call to <i>WSAAccept</i> by using <i>SIO_SET_QOS</i>, any accepted socket inherits the QOS levels set on the listening socket. Note that if the sender uses the conditional function in <i>WSAAccept</i>, the function should pass QOS values set on the connecting client. However, this is not the case. The QOS service provider passes junk, which is the behavior on both Windows 98 and Windows 2000. The exception is that if the <i>lpSQOS</i> parameter is non-null under Windows 98, some kind of QOS values must be set via the <i>SIO_SET_QOS</i> ioctl command within the conditional function; otherwise, the <i>WSAAccept</i> call fails even if <i>CF_ACCEPT</i> is returned. QOS can also be set on the client socket after it has been accepted.</p>

<p>Let's look at receiving TCP applications. The first case is calling <i>WSAConnect</i> with a receiving <i>FLOWSPEC</i>. When this occurs, the QOS service provider creates a RESV request. If QOS parameters are not supplied to <i>WSAConnect</i>, the <i>SIO_SET_QOS</i> ioctl command can be set at a later time (resulting in a RESV message). The last combination is the server being the receiver, which is similar to the sending case. QOS can be set on the listening socket before a <i>WSAAccept</i> call, in which case the client socket inherits the same QOS levels. Otherwise, QOS can be set in the conditional function or after the socket has been accepted. In either case, the QOS service provider generates a RESV message as soon as a PATH message arrives.</p>

<A NAME="393"><H3>Multicast</H3></A>

<p>Multicast senders behave the same way as UDP senders except that <i>WSAJoinLeaf</i> is used to become a member of the multicast group, as opposed to calling <i>WSAConnect</i> with the destination address. QOS can be set with <i>WSAJoinLeaf</i> or separately through an <i>SIO_SET_QOS</i> call. The multicast session address is used to compose the RSVP session object included in the RSVP PATH message.</p>

<p>In the case of the multicast receiver, no RESV messages will be generated until the multicast address is specified via the <i>WSAJoinLeaf</i> function. Because the multicast receiver doesn't specify a peer address, the QOS provider generates RESV messages with the wildcard filter style. The QOS service provider does not prohibit a socket from joining multiple multicast groups. In this case, the service provider sends RESV messages for all groups that have a matching PATH message. The QOS parameters supplied to each <i>WSAJoinLeaf</i> will be used in each RESV message, but if <i>SIO_SET_QOS</i> is called on the socket after joining multiple groups, the new QOS parameters will be applied to all multicast groups joined.</p>

<p>When a sender sends data to a multicast group, only data sent to the multicast group that the sender joined results in QOS being applied to that data. In other words, if you join one multicast group and use <i>sendto/WSASendTo</i> with any other multicast group as the destination, QOS is not applied to that data. Additionally, if a socket joins a multicast group specifying a particular direction (for example, using <i>JL_SENDER_ONLY</i> or <i>JL_RECEIVER_ONLY</i> in the <i>dwFlags</i> parameter to <i>WSAJoinLeaf</i>), QOS is applied accordingly. A socket set as a receiver only will not gain any QOS benefits for sent data.</p>



<A NAME="394"><H2>QOS Notifications</H2></A>

<p>Thus far, you have learned how to invoke QOS for TCP, UDP, and multicast UDP sockets and the corresponding RSVP events that occur depending on whether you're sending or receiving. However, the completion of these RSVP messages is not strictly tied to the API calls that invoke them. That is, issuing a <i>WSAConnect</i> call for a TCP receiving socket generates a RESV message, but the RESV message is independent of the actual API call in that the call returns without any assurances that the reservation is approved and network resources are allocated. Because of this, a new asynchronous event has been added, <i>FD_QOS</i>, which is posted to a socket. Typically, an <i>FD_QOS</i> event notification will be posted in the following events.</p>

<ul>
<p><li> Notification of the acceptance or rejection of the application's QOS request</li></p>

<p><li> Significant changes in the QOS provided by the network (as opposed to previously negotiated values)</li></p>

<p><li> Status regarding whether a QOS peer is ready to send or receive data for a particular flow</li></p>
</ul>



<A NAME="395"><h3>Registering for <i>FD_QOS</i> notifications</h3></A>
<p>To take advantage of these notifications, an application must register to be notified when an <i>FD_QOS</i> event occurs. There are a couple ways to do this. First you can use either <i>WSAEventSelect</i> or <i>WSAAsyncSelect</i> and include the <i>FD_QOS</i> flag in the bitwise ORing of event flags. However, an application is eligible to receive the <i>FD_QOS</i> event only if a call has already been made to one of the QOS invoking functions. Note that in some cases an application might want to receive the <i>FD_QOS</i> event without having to set QOS levels on a socket. This can be accomplished by setting up a <i>QOS</i> structure whose sending and receiving <i>FLOWSPEC</i> members contain either the <i>QOS_NOT_SPECIFIED</i> or the <i>SERVICETYPE_NOTRAFFIC</i> flag. The only catch is that the <i>SERVICE_NO_QOS_SIGNALING</i> flag must be ORed with the