<HTML>
<HEAD>
<TITLE>RasDial</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch16d.htm" , "ch16f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="487"><h1><i>RasDial</i></h1></A>
<p>When a RAS client application is ready to make a connection to a remote computer, it must call the <i>RasDial</i> function. <i>RasDial</i> is quite complex, offering many call parameters that are used for dialing, authenticating, and establishing a remote connection to a RAS server. <i>RasDial</i> is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
DWORD RasDial( 
    LPRASDIALEXTENSIONS lpRasDialExtensions,
    LPCTSTR lpszPhonebook,
    LPRASDIALPARAMS lpRasDialParams,
    DWORD dwNotifierType,
    LPVOID lpvNotifier,
    LPHRASCONN lphRasConn
);
</pre>
</td></tr></table>
</p>

<p>The <i>lpRasDialExtensions</i> parameter is an optional pointer to a <i>RASDIALEXTENSIONS</i> structure that causes your application to enable extended features for <i>RasDial</i>. On Windows 95, Windows 98, and Windows CE, this parameter is ignored and should be set to <i>NULL</i>. The <i>RASDIALEXTENSIONS</i> structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct tagRASDIALEXTENSIONS {
   DWORD      dwSize;
   DWORD      dwfOptions; 
   HWND       hwndParent;
   ULONG_PTR  reserved; 
#if (WINVER &gt;= 0x500) 
   ULONG_PTR  reserved1; 
   RASEAPINFO RasEapInfo;
#endif
} RASDIALEXTENSIONS; 
</pre>
</td></tr></table>
</p>

<p>Notice that this structure is sized differently during compilation based on the value of <i>WINVER</i>, as described earlier. The above fields are described as follows:</p>

<ul>
<p><li><b><i>dwSize</i></b> Should be set to the size (in bytes) of the <i>RASDIALEXTENSIONS</i> structure.</li></p>

<p><li><b><i>dwfOptions</i></b> Allows you to set bit flags for using <i>RasDial</i> extensions. Table 16-1 describes these flags.</li></p>
</ul>

<p><b>Table 16-1.</b>  RasDial <i>bit flags of the extension features</i></p>

<table cellpadding=5 width="95%">
<tr><th valign="top"><i>Flag</i></th> <th valign="top"><i>Description</i></th></tr>

<tr><td valign="top"><i>RDEOPT_UsePrefixSuffix</i></td> 
<td valign="top">Makes <i>RasDial</i> use the prefix and suffix associated with the specified dialing device.</td></tr>

<tr><td valign="top"><i>RDEOPT_PausedStates</i></td> 
<td valign="top">Allows <i>RasDial</i> to enter a paused operating state so that users can retry logons, change passwords, and set callback numbers.</td></tr>

<tr><td valign="top"><i>RDEOPT_IgnoreModemSpeaker</i></td> 
<td valign="top">Makes <i>RasDial</i> ignore the modem speaker settings in the RAS phonebook.</td></tr>

<tr><td valign="top"><i>RDEOPT_SetModemSpeaker</i></td> 
<td valign="top">Turns on the modem speaker if <i>RDEOPT_IgnoreModemSpeaker</i> is set.
</td></tr>

<tr><td valign="top"><i>RDEOPT_IgnoreSoftwareCompression</i></td> 
<td valign="top">Makes <i>RasDial</i> ignore software compression settings.</td></tr>

<tr><td valign="top"><i>RDEOPT_SetSoftwareCompression</i></td> 
<td valign="top">Turns on software compression if <i>RDEOPT_IgnoreSoftwareCompression</i> is set.</td></tr>

<tr><td valign="top"><i>RDEOPT_PauseOnScript</i></td> 
<td valign="top">Used internally by <i>RasDialDlg.</i> You should not set this flag.</td>
</tr>
</table>

<ul>
<p><li><b><i>hwndParent</i></b> Is not used and should be set to <i>NULL.</i></li></p>

<p><li><b><i>reserved</i></b> Is not used and should be set to 0.</li></p>

<p><li><b><i>reserved1</i></b> Is reserved for future use on Windows 2000 and should be set to 0.</li></p>

<p><li><b><i>RasEapInfo</i></b> On Windows 2000, allows you to specify Extensible Authentication Protocol (EAP) information. The details of EAP are beyond the scope of this book.</li></p>
</ul>

<p>The <i>lpszPhonebook</i> parameter of <i>RasDial</i> identifies the path to a phonebook file on Windows 2000 and Windows NT. This parameter must be <i>NULL</i> on Windows 95, Windows 98, and Windows CE because the phonebook is stored in the system Registry. A phonebook is a collection of RAS dialing properties that define how to set up a RAS connection. However, you are not required to use a phonebook to make a RAS connection. <i>RasDial</i> features enough dialing parameters to allow you to set up a basic connection. We will discuss the details of a RAS phonebook later in this chapter.</p>

<p>The <i>RASDIALPARAMS</i> structure pointer <i>lpRasDialParams</i> defines dialing and user authentication parameters that the <i>RasDial</i> function uses to establish a remote connection. It's defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _RASDIALPARAMS {
    DWORD dwSize;
    TCHAR szEntryName[RAS_MaxEntryName + 1]; 
    TCHAR szPhoneNumber[RAS_MaxPhoneNumber + 1]; 
    TCHAR szCallbackNumber[RAS_MaxCallbackNumber + 1]; 
    TCHAR szUserName[UNLEN + 1]; 
    TCHAR szPassword[PWLEN + 1]; 
    TCHAR szDomain[DNLEN + 1] ; 
#if (WINVER &gt;= 0x401) 
    DWORD dwSubEntry; 
    DWORD dwCallbackId; 
#endif
} RASDIALPARAMS;
</pre>
</td></tr></table>
</p>

<p>The fields of <i>RASDIALPARAMS</i> are described as follows:</p>

<ul>
<p><li><b><i>dwSize</i></b> Should be set to the size (in bytes) of a <i>RASDIALPARAMS</i> structure. This allows RAS to internally determine what <i>WINVER</i> version you compiled with.</li></p>

<p><li><b><i>szEntryName</i></b> A string that allows you to identify a phonebook entry contained in the phonebook file listed in the <i>lpszPhonebook</i> parameter of <i>RasDial</i>. This is an important parameter because phonebook entries enable you to fine-tune RAS connection properties such as selecting a modem or selecting a framing protocol. However, specifying a phonebook entry to use <i>RasDial</i> is optional. If this field is an empty string (&quot;&quot;), <i>RasDial</i> will select the first available modem installed on your system and will rely on the next parameter, <i>szPhoneNumber</i>, to dial a connection.</li></p>

<p><li><b><i>szPhoneNumber</i></b> A string representing a phone number that overrides the number contained in the phonebook entry specified in the <i>szEntryName</i> field.</li></p>

<p><li><b><i>szCallbackNumber</i></b> Allows you to specify a phone number the RAS server can call you back on. If the RAS server permits you to have a callback number, the server will terminate your original connection and call back your client using the callback number you specified. This is a nice feature because it lets your server know where a user is connecting from.</li></p>

<p><li><b><i>szUserName</i></b> A string that identifies a logon name used to authenticate a user on a RAS server.</li></p>

<p><li><b><i>szPassword</i></b> A string that identifies the password used to authenticate a user on a RAS server.</li></p>

<p><li><b><i>szDomain</i></b> Identifies the Windows 2000 or Windows NT domain where the user account is located.</li></p>

<p><li><b><i>dwSubEntry</i></b> Optionally allows you to specify the initial phonebook subentry to dial for a RAS multilink connection. (We'll describe RAS phonebook subentries and multilink connections in
&quot;<a href="ch16f.htm#498">Multilink Phonebook Subentries.</a>&quot;)</li></p>

<p><li><b><i>dwCallbackId</i></b> Allows you to pass an application-defined value to a <i>RasDialFunc2</i> callback function (which we'll also describe later). If you're not using a <i>RasDialFunc2</i> callback function, this field is not used.</li></p>
</ul>

<p>The next <i>RasDial</i> parameters, <i>dwNotifierType</i> and <i>lpvNotifier</i>, determine the operating mode of <i>RasDial</i> (whether it can be called synchronously or asynchronously). The final <i>RasDial</i> parameter, <i>lphRasConn</i>, is a pointer to a RAS connection handle of type <i>HRASCONN</i>. Before you call <i>RasDial</i>, you must set this parameter to <i>NULL</i>. If <i>RasDial</i> completes successfully, a reference handle to the RAS connection is returned.</p>

<p>Let's begin by demonstrating how to call <i>RasDial</i>. As we mentioned, <i>RasDial</i> can execute in two operating modes: <i>synchronous</i> and <i>asynchronous</i>. In synchronous mode, <i>RasDial</i> blocks until it either completes a connection or fails to do so. In asynchronous mode, <i>RasDial</i> completes a connection immediately, allowing your application to perform other actions while connecting.</p>

<A NAME="488"><H2>Synchronous Mode</H2></A>

<p>If the <i>lpvNotifier</i> parameter of <i>RasDial</i> is set to <i>NULL</i>, <i>RasDial</i> will operate synchronously. When the <i>lpvNotifier</i> parameter is <i>NULL</i>, the <i>dwNotifierType</i> parameter is ignored. Calling <i>RasDial</i> synchronously is the easiest way to use this function; however, you won't be able to monitor the connection as you can in asynchronous mode, which we will describe in a moment. Figure 16-1 demonstrates how to call <i>RasDial</i> synchronously. Notice that this code listing does not specify a phonebook or a phonebook entry. Instead, it demonstrates how simple forming a RAS connection is.</p>

<p><b>Figure 16-1.</b>  <i>Calling </i>RasDial<i> synchronously</i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
RASDIALPARAMS RasDialParams;
HRASCONN hRasConn;
DWORD Ret;

// Always set the size of the RASDIALPARAMS structure

RasDialParams.dwSize = sizeof(RASDIALPARAMS);
hRasConn = NULL;

// Setting this field to an empty string will allow
// RasDial to use default dialing properties

lstrcpy(RasDialParams.szEntryName, &quot;&quot;);

lstrcpy(RasDialParams.szPhoneNumber, &quot;867-5309&quot;);
lstrcpy(RasDialParams.szUserName, &quot;jenny&quot;);
lstrcpy(RasDialParams.szPassword, &quot;mypassword&quot;);
lstrcpy(RasDialParams.szDomain, &quot;mydomain&quot;);

// Call RasDial synchronously (the fifth parameter
// is set to NULL)
Ret = RasDial(NULL, NULL, &amp;RasDialParams, 0, NULL, &amp;hRasConn);
   
if (Ret != 0)
{
    printf(&quot;RasDial failed: Error = %d\n&quot;, Ret);
}
</pre>
</td></tr></table>
</p>

<A NAME="489"><H2>Asynchronous Mode</H2></A>

<p>Calling <i>RasDial</i> asynchronously is a lot more complicated than calling this function in synchronous mode. If the <i>lpvNotifier</i> parameter of <i>RasDial</i> is not set to <i>NULL</i>, <i>RasDial</i> will operate asynchronously&#8212;meaning the call returns immediately but the connection proceeds. Calling <i>RasDial</i> asynchronously is the preferred method for making a RAS connection because you can monitor the connection's progress. The <i>lpvNotifier</i> parameter can be either a pointer to a function that is called when a connection activity occurs in <i>RasDial</i> or a window handle that receives progress notification via Windows messages. The <i>dwNotifierType</i> parameter of <i>RasDial</i> determines the type of function or window handle that is passed into <i>lpvNotifier</i>. Table 16-2 describes the values that you can specify in <i>dwNotifierType</i>.</p>

<p><b>Table 16-2.</b> RasDial <i>asynchronous notification methods</i></p>

<table cellpadding=5 width="95%"><tr><th valign="top"><i>Notifier Type</i></th> <th valign="top"><i>Meaning</i></th></tr>

<tr><td valign="top">0</td> <td valign="top">The <i>lpvNotifier</i> parameter causes <i>RasDial</i> to use the <i>RasDialFunc</i> function pointer to manage connection events.</td></tr>

<tr><td valign="top">1</td> <td valign="top">The <i>lpvNotifier</i> parameter causes <i>RasDial</i> to use the <i>RasDialFunc1</i> function pointer to manage connection events.</td></tr>

<tr><td valign="top">2</td> <td valign="top">The <i>lpvNotifier</i> parameter causes <i>RasDial</i> to use the <i>RasDialFunc2</i> function pointer to manage connection events.</td></tr>

<tr><td valign="top">0xFFFFFFFF</td> <td valign="top">The <i>lpvNotifier</i> parameter makes <i>RasDial</i> send a window message during connection events.</td></tr>
</table>

<p>Table 16-2 shows the three function prototypes that you can supply to <i>RasDial</i> in the <i>lpvNotifier</i> parameter for receiving callback notification of connection events: <i>RasDialFunc</i>, <i>RasDialFunc1</i>, and <i>RasDialFunc2</i>. The first one, <i>RasDialFunc</i>, is prototyped as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
VOID WINAPI RasDialFunc(
    UINT unMsg,
    RASCONNSTATE rasconnstate,
    DWORD dwError
);
</pre>
</td></tr></table>
</p>

<p>The <i>unMsg</i> parameter receives the type of event that has occurred. Currently this event can be only <i>WM_RASDIALEVENT</i>, which means that this parameter is not useful. The <i>rasconnstate</i> parameter receives the connection activity that the <i>RasDial</i> function is about to start. Table 16-3 defines the possible connection activities. The <i>dwError</i> parameter receives a RAS error code if one of the connection activities experiences failure.</p>

<p>Table 16-3 shows three operating states associated with connection activities in an asynchronous <i>RasDial</i> call: running, paused, and terminal. The running state indicates that the <i>RasDial</i> call is still in progress, and each running-state activity offers progress status information.</p>

<p>The paused state indicates that <i>RasDial</i> needs more information to establish the connection. By default, the paused state is disabled. You can enable this notification process by setting the <i>RDEOPT_PausedStates</i> flag in the <i>RASDIALEXTENSIONS</i> structure that we mentioned earlier. When a paused state activity occurs, it indicates one of the conditions listed below.</p>

<ul>
<p><li> The user needs to supply new logon credentials because the authentication failed.</li></p>

<p><li> The user needs to provide a new password because his or her password has expired.</li></p>

<p><li> The user needs to provide a callback number.</li></p>
</ul>

<p><b>Table 16-3.</b> <i>RAS connection activities</i></p>

<table cellpadding=5 width="95%">
<tr><th valign="top"><i>Activity</i></th> 
<th valign="top"><i>State</i></th> 
<th valign="top"><i>Description</i></th></tr>

<tr><td valign="top"><i>RASCS_OpenPort</i></td> 
<td valign="top">Running</td> 
<td valign="top">A communication port is about to be opened.</td></tr>

<tr><td valign="top"><i>RASCS_PortOpened</i></td> 
<td valign="top">Running</td> 
<td valign="top">The communication port is open.</td></tr>

<tr><td valign="top"><i>RASCS_ConnectDevice</i></td> 
<td valign="top">Running</td> 
<td valign="top">A device is about to be connected.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ DeviceConnected</i></td> 
<td valign="top">Running</td> 
<td valign="top">The device has successfully connected.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ AllDevicesConnected</i></td> 
<td valign="top">Running</td> 
<td valign="top">A physical link has been established.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ Authenticate</i></td> 
<td valign="top">Running</td> 
<td valign="top">The RAS authentication process has started.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ AuthNotify</i></td> 
<td valign="top">Running</td> 
<td valign="top">An authentication event has occurred.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ AuthRetry</i></td> 
<td valign="top">Running</td> 
<td valign="top">The client has requested another authentication attempt.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ AuthCallback</i></td> 
<td valign="top">Running</td> 
<td valign="top">The server has requested a callback number.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ AuthChangePassword</i></td> 
<td valign="top">Running</td> 
<td valign="top">The client has requested to change the password on the RAS account.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ AuthProject</i></td> 
<td valign="top">Running</td> 
<td valign="top">The protocol projection is starting.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ AuthLinkSpeed</i></td> 
<td valign="top">Running</td> 
<td valign="top">The link speed is being calculated.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ AuthAck</i></td> 
<td valign="top">Running</td> 
<td valign="top">An authentication request is being acknowledged.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ ReAuthenticate</i></td> 
<td valign="top">Running</td> 
<td valign="top">The authentication process after a callback is starting.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ Authenticated</i></td> 
<td valign="top">Running</td>
<td valign="top">The client has successfully completed the authentication.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ PrepareForCallback</i></td> 
<td valign="top">Running</td> 
<td valign="top">The line is about to disconnect to prepare for a callback.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ WaitForModemReset</i></td> 
<td valign="top">Running</td> 
<td valign="top">The client is waiting for the modem to reset before preparing for a callback.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ WaitForCallback</i></td> 
<td valign="top">Running</td>
<td valign="top">The client is waiting for an incoming call from the server.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ Projected</i></td> 
<td valign="top">Running</td> 
<td valign="top">The protocol projection is complete.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ StartAuthentication</i></td>
<td valign="top">Running</td> 
<td valign="top">User authentication is being started or retried. (This applies to Windows 95 and Windows 98 only.)</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ CallbackComplete</i></td> 
<td valign="top">Running</td> 
<td valign="top">The client has been called back. (This applies to Windows 95 and Windows 98 only.)</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ LogonNetwork</i></td> 
<td valign="top">Running</td> 
<td valign="top">The client is logging on to a remote network. (This applies to Windows 95 and Windows 98 only.)</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ SubEntryConnected</i></td> 
<td valign="top">Running</td> 
<td valign="top">A subentry of a multilink phonebook entry has connected. The <i>dwSubEntry</i> parameter of <i>RasDialFunc2</i> will contain an index of the subentry connected.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ SubEntryDisconnected</i></td> 
<td valign="top">Running</td> 
<td valign="top">A subentry of a multilink phonebook entry has disconnected. The <i>dwSubEntry</i> parameter of <i>RasDialFunc2</i> will contain an index of the subentry disconnected.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ RetryAuthentication</i></td> 
<td valign="top">Paused</td> 
<td valign="top"><i>RasDial</i> is awaiting new user credentials.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ CallbackSetByCaller</i></td> 
<td valign="top">Paused</td> 
<td valign="top"><i>RasDial</i> is awaiting a callback number from the client.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_ PasswordExpired</i></td> 
<td valign="top">Paused</td> 
<td valign="top"><i>RasDial</i> expects the user to supply a new password.</td>
</tr>

<tr>
<td valign="top"><i>RASCS_InvokeEapUI</i></td> 
<td valign="top">Paused</td> 
<td valign="top">On Windows 2000, <i>RasDial</i> is awaiting a custom user interface to obtain EAP information.</td>
</tr>

<tr><td valign="top"><i>RASCS_ Connected</i></td> 
<td valign="top">Terminal</td> 
<td valign="top">The RAS connection succeeded and is active.</td></tr>

<tr><td valign="top"><i>RASCS_ Disconnected</i></td> 
<td valign="top">Terminal</td> 
<td valign="top">The RAS connection failed or is inactive.</td></tr>
</table>

<p>These activities pertain to information in the <i>RASDIALPARAMS</i> structure described earlier in this chapter. When a paused state activity occurs, <i>RasDial</i> will notify your callback function (or window procedure). If the paused state is disabled, RAS will send an error to your notification function and <i>RasDial</i> will fail. If enabled, the <i>RasDial</i> function will be in a paused state that allows your application to supply the necessary information through a <i>RASDIALPARAMS</i> structure. When <i>RasDial</i> is paused, you can resume by calling it again with the original call's connection handle (<i>lphRasConn</i>) and notification function (<i>lpvNotifier</i>), or you can simply end the paused operation by calling <i>RasHangUp</i> (described later in this chapter). If you resume the paused connection, you will have to supply the necessary user input via the <i>RASDIALPARAMS</i> structure passed to the resumed <i>RasDial</i> call.</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>
Do not resume the paused state by calling <i>RasDial</i> directly from a notification handler function such as <i>RasDialFunc</i>. <i>RasDial</i> is not designed to handle this situation, so you should resume <i>RasDial</i> directly from your application thread.
</blockquote></div></p>

<p>The final state&#8212;terminal&#8212;indicates that the <i>RasDial</i> connection has either succeeded or failed. It can also indicate that the <i>RasHangUp</i> function closed the connection.</p>

<p>Now that you have a basic understanding of how you can monitor the connection of an asynchronous <i>RasDial</i> call, we'll demonstrate how to set up a simple program that calls <i>RasDial</i> asynchronously. Figure 16-2 shows this procedure. You'll also find an asynchronous <i>RasDial</i> example on the companion CD.</p>

<p><b>Figure 16-2</b> <i>Calling</i> RasDial <i>asynchronously</i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
void main(void)
{
    DWORD Ret;
    RASDIALPARAMS RasDialParams;
    HRASCONN hRasConn;

    // Fill in the RASDIALPARAMS structure with call parameters
    // as was done in the synchronous example
    ...

    if ((Ret = RasDial(NULL, NULL, &amp;RasDialParams, 0, 
        &amp;RasDialFunc, &amp;hRasConn)) != 0)
    {
        printf(&quot;RasDial failed with error %d\n&quot;, Ret);
        return;
    }

    // Perform other tasks while RasDial is processing
    ...
}

// Callback function RasDialFunc()
void WINAPI RasDialFunc(UINT unMsg, RASCONNSTATE rasconnstate, 
    DWORD dwError)
{
    char szRasString[256]; // Buffer for error string

    if (dwError)
    {
        RasGetErrorString((UINT)dwError, szRasString, 256);
        printf(&quot;Error: %d - %s\n&quot;,dwError, szRasString);
        return;
    }

    // Map each of the states of RasDial, and display on the
    // screen the next state that RasDial is entering

    switch (rasconnstate)
    {
        case RASCS_ConnectDevice: 
            printf (&quot;Connecting device...\n&quot;);
            break;
        case RASCS_DeviceConnected:
            printf (&quot;Device connected.\n&quot;);
            break;

        // Add other connection activities here
        ...

        default:
            printf (&quot;Unmonitored RAS activity.\n&quot;);
            break;
    }
}
</pre>
</td></tr></table>
</p>

<p>Table 16-2 also mentioned two other callback notification functions: <i>RasDialFunc1</i> and <i>RasDialFunc2</i>. These functions are prototyped as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
VOID WINAPI RasDialFunc1(
    HRASCONN hrasconn, 
    UINT unMsg, 
    RASCONNSTATE rascs, 
    DWORD dwError,
    DWORD dwExtendedError
);

DWORD WINAPI RasDialFunc2(
    DWORD dwCallbackId, 
    DWORD dwSubEntry,
    HRASCONN hrasconn,
    UINT unMsg,
    RASCONNSTATE rascs,
    DWORD dwError,
    DWORD dwExtendedError
);
</pre>
</td></tr></table>
</p>

<p>The <i>RasDialFunc1</i> function is just like the <i>RasDialFunc</i> function discussed earlier except that it features two additional parameters: <i>hrasconn</i> and <i>dwExtendedError</i>. The <i>hrasconn</i> parameter is the handle to the connection that <i>RasDial</i> returned. The <i>dwExtendedError</i> parameter allows you to retrieve extended error information when the following types of errors occur in the <i>dwError</i> parameter during the connection.</p>

<ul>
<p><li><b><i>ERROR_SERVER_NOT_RESPONDING</i></b> <i>dwExtendedError</i> receives a NetBIOS-specific error code that occurred.</li></p>

<p><li><b><i>ERROR_NETBIOS_ERROR</i></b> <i>dwExtendedError</i> receives a NetBIOS-specific error code that occurred.</li></p>

<p><li><b><i>ERROR_AUTH_INTERNAL</i></b>  <i>dwExtendedError</i> receives an internal diagnostic error code. These error codes are not documented.</li></p>

<p><li><b><i>ERROR_CANNOT_GET_LANA</i></b> <i>dwExtendedError</i> receives a routing RAS-specific error code.</li></p>
</ul>

<p>The <i>RasDialFunc2</i> function is just like <i>RasDialFunc1</i> except that it features two additional parameters: <i>dwCallbackId</i> and <i>dwSubEntry</i>. The <i>dwCallbackId</i> parameter contains an application-defined value that was originally set in the <i>dwCallbackId</i> field of a <i>RASDIALPARAMS</i> structure passed to the <i>RasDial</i> call we described earlier. The <i>dwSubEntry</i> parameter receives the subentry phonebook index that caused the callback to the <i>RasDialFunc2</i> function.</p>

<A NAME="490"><H2>Status Notification</H2></A>

<p>RAS features a stand-alone function named <i>RasConnectionNotification</i> that allows your application to determine when an asynchronous RAS connection has been created or terminated. <i>RasConnectionNotification</i> is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
DWORD RasConnectionNotification( 
    HRASCONN hrasconn,
    HANDLE hEvent,
    DWORD dwFlags
);
</pre>
</td></tr></table>
</p>

<p>The <i>hrasconn</i> parameter is a connection handle returned from <i>RasDial</i>. The <i>hEvent</i> parameter is an event handle that your application creates using the <i>CreateEvent</i> function. The <i>dwFlags</i> parameter can be set to a combination of the following connection activity flags:</p>

<ul>
<p><li><b><i>RASCN_Connection</i></b> Notifies you that a RAS connection has been created. If the <i>hrasconn</i> parameter is set to <i>INVALID_HANDLE_VALUE</i>, the event is signaled when any RAS connection occurs.</li></p>

<p><li> <b><i>RASCN_Disconnection</i></b> Notifies you that a RAS connection has been terminated. If the <i>hrasconn</i> parameter is set to <i>INVALID_HANDLE_VALUE</i>, the event is signaled when any connection ends.</li></p>

<p><li> <b><i>RASCN_BandwidthAdded</i></b> On a multilink connection, the event is signaled when a subentry connects.</li></p>

<p><li> <b><i>RASCN_BandwidthRemoved</i></b> On a multilink connection, the event is signaled when a subentry disconnects.</li></p>
</ul>

<p>Note that these flags function in the same way as the connection activity flags described in Table 16-3. If any of these activities occur during your connection, your event will become signaled. Your application should use Win32 wait functions, such as <i>WaitForSingleObject</i>, to determine when the object becomes signaled.</p>

<A NAME="491"><H2>Closing a Connection</H2></A>

<p>Closing a connection established by <i>RasDial</i> is simple. All you have to do is call <i>RasHangUp</i>, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
DWORD RasHangUp( 
    HRASCONN hrasconn
);
</pre>
</td></tr></table>
</p>

<p>The <i>hrasconn</i> parameter is a handle returned from <i>RasDial</i>. Although this function is easy to use, you have to consider how connections are managed internally in RAS. A connection uses a modem port, and it takes time for the port to reset internally when a connection shuts down. Therefore, you should wait until the port connection closes completely. To do this, you can call <i>RasGetConnectionStatus</i> to determine when your connection is reset. <i>RasGetConnectionStatus</i> is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
DWORD RasGetConnectStatus(
    HRASCONN hrasconn,
    LPRASCONNSTATUS lprasconnstatus
);
</pre>
</td></tr></table>
</p>

<p>The <i>hrasconn</i> parameter is a handle returned from <i>RasDial</i>. The <i>lprasconnstatus</i> parameter is a <i>RASCONNSTATUS</i> structure that receives the current connection status. A <i>RASCONNSTATUS</i> structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _RASCONNSTATUS 
{ 
    DWORD dwSize; 
    RASCONNSTATE rasconnstate; 
    DWORD dwError; 
    TCHAR szDeviceType[RAS_MaxDeviceType + 1]; 
    TCHAR szDeviceName[RAS_MaxDeviceName + 1]; 
} RASCONNSTATUS; 
</pre>
</td></tr></table>
</p>

<p>These fields are defined as follows:</p>

<ul>
<p><li><b><i>dwSize</i></b> Should be set to the size (in bytes) of <i>RASCONNSTATUS</i></li></p>

<p><li><b><i>rasconnstate</i></b> Receives one of the connection activities defined in Table 16-3</li></p>

<p><li><b><i>dwError</i></b> Receives a specific RAS error code if <i>RasGetConnectStatus</i> does not return 0</li></p>

<p><li><b><i>szDeviceType</i></b> Receives a string representing the type of device used on the connection</li></p>

<p><li><b><i>szDeviceName</i></b> Receives the name of the current device</li></p>
</ul>

<p>We recommend that you check the state of your connection until you receive the <i>RASCS_ Disconnected</i> activity status. Obviously, you might have to call <i>RasGetConnectionStatus</i> several times until the connection is reset. Once the connection is reset, you can exit your application or make another connection.</p>

</BODY>
</HTML>



