<HTML>
<HEAD>
<TITLE>Terminating QOS</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch12c.htm" , "ch12e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="377"><H1>Terminating QOS</H1></A>

<p>In the previous section, you learned how to invoke QOS on a socket. Next we'll examine the termination of QOS guarantees. Each of the following events causes a termination of RSVP and Traffic Control processing for a socket:</p>

<ul>
<p><li> Closing a socket via the <i>closesocket</i> function</li></p>

<p><li> Shutting down a socket via the <i>shutdown</i> function</li></p>

<p><li> Calling <i>WSAConnect</i> with a null peer address</li></p>

<p><li> Calling <i>WSAIoctl</i> and <i>SIO_SET_QOS</i> with the <i>SERVICETYPE_NOTRAFFIC</i> or the <i>SERVICE_TYPE_BESTEFFORT</i> service type</li></p>
</ul>



<p>Except for the second item in the list, these events are self-explanatory. Remember that the <i>shutdown</i> function can signal the cessation of either sending or receiving data, which will result in the termination of the flow of data for only that direction. In other words, if <i>shutdown</i> is called with <i>SD_SEND</i>, QOS will still be in effect for data being received.</p>

<A NAME="378"><H2>Provider-Specific Objects</H2></A>

<p>The provider-specific objects covered in this section are passed as part of the <i>ProviderSpecific</i> field of the <i>QOS</i> structure. Either they return QOS information to your application via the <i>FD_QOS</i> event or you can pass them along with the other QOS parameters to a <i>WSAIoctl</i> call with the <i>SIO_SET_QOS</i> option to refine the behavior of QOS.</p>

<p>Every provider-specific object contains a <i>QOS_OBJECT_HDR</i> structure as its first member. This structure identifies the type of the provider-specific object. This is necessary because these provider objects are most commonly returned within the <i>QOS</i> structure after a call to <i>SIO_GET_QOS</i>. Using the <i>QOS_OBJECT_HDR</i>, your application can identify each object and decode its significance. The object header is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct  
{
    ULONG   ObjectType;
    ULONG   ObjectLength; 
} QOS_OBJECT_HDR, *LPQOS_OBJECT_HDR;
</pre>
</td></tr></table>
</p>

<p><i>ObjectType</i> identifies the type of preset provider-specific object, while <i>ObjectLength</i> tells how long the entire object is, including the object header and the provider-specific object. An object type can be one of the flags listed in Table 12-3.</p>

<p><b>Table 12-3.</b> <i>Object types</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th><i>Provider Object</i>  </th>
<th><i>Object Structure</i>  </th></tr>
<tr>
<td valign="top"><i>QOS_OBJECT_PRIORITY</i>  </td>
<td valign="top"><i>QOS_PRIORITY</i>  </td></tr>
<tr>
<td valign="top"><i>QOS_OBJECT_SD_MODE</i>  </td>
<td valign="top"><i>QOS_SD_MODE</i>  </td></tr>
<tr>
<td valign="top"><i>QOS_OBJECT_TRAFFIC_CLASS</i>  </td>
<td valign="top"><i>QOS_TRAFFIC_CLASS</i>  </td></tr>
<tr>
<td valign="top"><i>QOS_OBJECT_DESTADDR</i>  </td>
<td valign="top"><i>QOS_DESTADDR</i>  </td></tr>
<tr>
<td valign="top"><i>QOS_OBJECT_SHAPER_QUEUE_DROP_MODE</i>  </td>
<td valign="top"><i>QOS_SHAPER_QUEUE_LIMIT_DROP_MODE</i>  </td></tr>
<tr>
<td valign="top"><i>QOS_OBJECT_SHAPER_QUEUE_LIMIT</i>  </td>
<td valign="top"><i>QOS_SHAPER_QUEUE_LIMIT</i>  </td></tr>
<tr>
<td valign="top"><i>RSVP_OBJECT_STATUS_INFO</i>  </td>
<td valign="top"><i>RSVP_STATUS_INFO</i>  </td></tr>
<tr>
<td valign="top"><i>RSVP_OBJECT_RESERVE_INFO</i>  </td>
<td valign="top"><i>RSVP_RESERVE_INFO</i>  </td></tr>
<tr>
<td valign="top"><i>RSVP_OBJECT_ADSPEC</i>  </td>
<td valign="top"><i>RSVP_ADSPEC</i>  </td></tr>
<tr>
<td valign="top"><i>RSVP_OBJECT_POLICY_INFO</i>  </td>
<td valign="top"><i>RSVP_POLICY_INFO</i>  </td></tr>
<tr>
<td valign="top"><i>QOS_OBJECT_END_OF_LIST</i>  </td>
<td valign="top">None. No more objects.  </td></tr>
</table></p>

<A NAME="379"><H3>QOS priority</H3></A>

<p>QOS priority defines the absolute priority of the flow. The priority levels themselves range from 0 to 7, lowest to highest. The <i>QOS_PRIORITY</i> structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _QOS_PRIORITY 
{
    QOS_OBJECT_HDR  ObjectHdr;
    UCHAR           SendPriority
    UCHAR           SendFlags; 
    UCHAR           ReceivePriority; 
    UCHAR           Unused;
} QOS_PRIORITY, *LPQOS_PRIORITY;
</pre>
</td></tr></table>
</p>

<p>These priority values determine the local priority (internal to the sending host computer) of the corresponding flow's traffic relative to traffic from other flows. The default priority for a flow is 3. This priority is used in combination with the <i>ServiceType</i> parameter of <i>FLOWSPEC</i> to determine the priority that should be applied to the flow internal to the Packet Scheduler. <i>SendFlags</i> and <i>ReceivePriority</i> are not currently used but might be used in the future.</p>

<A NAME="380"><H3>QOS shape discard mode</H3></A>

<p>This <i>QOS</i> object defines how the Packet Shaper element of Traffic Control processes the data of a given flow. This property most often comes into play when dealing with flows that do not conform to the parameters given in <i>FLOWSPEC</i>. That is, if an application is sending data at a rate faster than what is specified in the <i>TokenRate</i> field of the sending <i>FLOWSPEC</i>, it is considered nonconforming. This object defines how the local system handles this occurrence. The <i>QOS_SD_MODE</i> structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _QOS_SD_MODE 
{
    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            ShapeDiscardMode;
} QOS_SD_MODE, *LPQOS_SD_MODE;
</pre>
</td></tr></table>
</p>

<p>The <i>ShapeDiscardMode</i> field can be one of the values specified in Table 12-4.</p>

<p>You might be wondering why you would want to use the <i>TC_NONCONF_DISCARD</i> mode when it might result in the dropping of data before it even gets sent on the wire. One such use is in sending audio or video data. In most cases, the <i>FLOWSPEC</i> structure is set up to reflect the sending of a packet whose size is equal to one frame of video or a small segment of audio. If for some reason the packet does not conform, is it better for an application to wait until it does conform (as is the case with <i>TC_NONCONF_SHAPE</i>), or should the application drop the packet altogether and move on to the next one? For time-critical data such as video, it is often better to drop the frame and move on.</p>

<p><b>Table 12-4.</b> <i>QOS shape discard mode flags</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th><i>Flag</i>  </th>
<th> <i>Description</i> </th></tr>
<tr>
<td valign="top"><i>TC_NONCONF_BORROW</i>  </td>
<td valign="top">The flow receives the resources remaining after all higher-priority flows have been serviced. Flows of this type are not subjected to either the Shaper or the Sequencer. If a value for <i>TokenRate</i> is specified, packets can be nonconforming and will be demoted to less than best-effort priority.  </td></tr>
<tr>
<td valign="top"><i>TC_NONCONF_SHAPE</i>  </td>
<td valign="top">A value for <i>TokenRate</i> must be specified. Nonconforming packets will be retained in the Packet Shaper until they become conforming.  </td></tr>
<tr>
<td valign="top"><i>TC_NONCONF_DISCARD</i>  </td>
<td valign="top">A value for <i>TokenRate</i> must be specified. Nonconforming packets will be discarded.  </td></tr>
</table></p>


<A NAME="381"><H3>QOS traffic class</H3></A>

<p>The <i>QOS_TRAFFIC_CLASS</i> structure can carry an 802.1p traffic class parameter provided to the host by a Layer 2 network device. The structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _QOS_TRAFFIC_CLASS 
{
    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            TrafficClass;
} QOS_TRAFFIC_CLASS, *LPQOS_TRAFFIC_CLASS;
</pre>
</td></tr></table>
</p>

<p>Hosts stamp the MAC headers of corresponding transmitted packets with the <i>TrafficClass</i> value specified in the structure. Despite the structure's inclusion in Qos.h, applications are not allowed to set their own priority.</p>

<A NAME="382"><H3>QOS destination address</H3></A>

<p>The <i>QOS_DESTADDR</i> structure is used to specify the destination address for a connectionless sending socket without using a <i>WSAConnect</i> call. No RSVP PATH or RESV messages will be sent until the destination address of a connectionless socket is known. The destination address can be set with the <i>SIO_SET_QOS</i> ioctl command. The structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _QOS_DESTADDR 
{
    QOS_OBJECT_HDR         ObjectHdr; 
    const struct sockaddr *SocketAddress;
    ULONG                  SocketAddressLength;
} QOS_DESTADDR, *LPQOS_DESTADDR;
</pre>
</td></tr></table>
</p>

<p>The <i>SocketAddress</i> field references the <i>SOCKADDR</i> structure that defines the endpoint's address for the given protocol. <i>SocketAddressLength</i> is simply the size of the <i>SOCKADDR</i> structure.</p>

<A NAME="383"><H3>QOS shaper queue limit drop mode</H3></A>

<p>This structure defines any overriding of the default schema used to drop packets when a flow's shaper queue limit is reached. Remember that the Traffic Shaper module of Traffic Control can be configured to discard any excess data pending if the currently queued data does not conform to the <i>FLOWSPEC</i> structure. The structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _QOS_SHAPER_QUEUE_LIMIT_DROP_MODE 
{
    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            DropMode;
}  QOS_SHAPER_QUEUE_LIMIT_DROP_MODE, 
  *LPQOS_SHAPER_QUEUE_LIMIT_DROP_MODE;
</pre>
</td></tr></table>
</p>

<p>The two possible values for <i>DropMode</i> are described in Table 12-5.</p>

<p><b>Table 12-5.</b> <i>Shaper queue limit drop modes</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th><i>Flag</i>  </th>
<th><i>Meaning</i>  </th></tr>
<tr>
<td valign="top"><i>QOS_SHAPER_DROP_FROM_HEAD</i>  </td>
<td valign="top">Drop packets from the head of the queue (the default behavior).  </td></tr>
<tr>
<td valign="top"><i>QOS_SHAPER_DROP_INCOMING</i>  </td>
<td valign="top">Drop any incoming packets once the queue limit is reached.  </td></tr>
</table></p>


<A NAME="384"><H3>QOS shaper queue limit</H3></A>

<p>The shaper queue limit structure allows the default per-flow limit on the shaper queue size to be overridden. The structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _QOS_SHAPER_QUEUE_LIMIT 
{
    QOS_OBJECT_HDR   ObjectHdr;
    ULONG            QueueSizeLimit;
} QOS_SHAPER_QUEUE_LIMIT, *LPQOS_SHAPER_QUEUE_LIMIT;
</pre>
</td></tr></table>
</p>

<p><i>QueueSizeLimit</i> is the size of the shaper queue in bytes. Setting a larger shaper queue size can prevent data from being dropped by allowing data to be queued without running out of buffer space.</p>

<A NAME="385"><H3>RSVP status info</H3></A>

<p>The RSVP status info object is used to return RSVP-specific error and status information. The structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _RSVP_STATUS_INFO {
    QOS_OBJECT_HDR     ObjectHdr;
    ULONG            StatusCode;
    ULONG            ExtendedStatus1;
    ULONG            ExtendedStatus2;
} RSVP_STATUS_INFO, *LPRSVP_STATUS_INFO;
</pre>
</td></tr></table>
</p>

<p>The <i>StatusCode</i> field is the RSVP message returned. The possible codes are described in Table 12-6. The other two fields, <i>ExtendedStatus1</i> and <i>ExtendedStatus2</i>, are reserved for provider-specific information.</p>

<p><b>Table 12-6.</b> <i>RSVP status info codes</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th><i>Flag</i>  </th>
<th><i>Meaning</i>  </th></tr>
<tr>
<td valign="top"><i>WSA_QOS_RECEIVERS</i>  </td>
<td valign="top">At least one RESV message has arrived.  </td></tr>
<tr>
<td valign="top"><i>WSA_QOS_SENDERS</i>  </td>
<td valign="top">At least one PATH message has arrived.  </td></tr>
<tr>
<td valign="top"><i>WSA_NO_QOS_RECEIVERS</i>  </td>
<td valign="top">There are no receivers.  </td></tr>
<tr>
<td valign="top"><i>WSA_NO_QOS_SENDERS</i>  </td>
<td valign="top">There are no senders.  </td></tr>
<tr>
<td valign="top"><i>WSA_QOS_REQUEST_CONFIRMED</i>  </td>
<td valign="top">The reserve has been confirmed.  </td></tr>
<tr>
<td valign="top"><i>WSA_QOS_ADMISSION_FAILURE</i>  </td>
<td valign="top">Request failed due to lack of resources.  </td></tr>
<tr>
<td valign="top"><i>WSA_QOS_POLICY_FAILURE</i>  </td>
<td valign="top">Request rejected for administrative reasons or bad credentials.  </td></tr>
<tr>
<td valign="top"><i>WSA_QOS_BAD_STYLE</i>  </td>
<td valign="top">Unknown or conflicting style.  </td></tr>
<tr>
<td valign="top"><i>WSA_QOS_BAD_OBJECT</i>  </td>
<td valign="top">There is a problem with some part of the <i>RSVP_FILTERSPEC</i> structure or the provider-specific buffer in general. (This object will be discussed shortly.)  </td></tr>
<tr>
<td valign="top"><i>WSA_QOS_TRAFFIC_CTRL_ERROR</i>  </td>
<td valign="top">There is a problem with some part of the <i>FLOWSPEC</i> structure.  </td></tr>
<tr>
<td valign="top"><i>WSA_QOS_GENERIC_ERROR</i>  </td>
<td valign="top">General error.  </td></tr>
<tr>
<td valign="top"><i>ERROR_IO_PENDING</i>   </td>
<td valign="top">Overlapped operation is canceled.  </td></tr>
</table></p>


<p>Typically, an application receives an <i>FD_QOS</i> event and calls <i>SIO_GET_QOS</i> to obtain a QOS structure containing an <i>RSVP_STATUS_INFO</i> object when an RSVP message is received. For example, for a QOS-enabled UDP-based receiver, an <i>FD_QOS</i> event containing a <i>WSA_QOS_SENDERS</i> message is generated to indicate that someone has requested the QOS service to send data to the receiver.</p>

<A NAME="386"><H3>RSVP reserve info</H3></A>

<p>The RSVP reserve info object is used for storing RSVP-specific information for fine-tuning interactions via the Winsock 2 QOS APIs and the provider-specific buffer. A <i>RSVP_RESERVE_INFO</i> object overrides the default reservation style and is used by a QOS receiver. The object is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _RSVP_RESERVE_INFO 
{
    QOS_OBJECT_HDR    ObjectHdr;
    ULONG             Style;
    ULONG             ConfirmRequest;
    ULONG             NumPolicyElements;
    LPRSVP_POLICY     PolicyElementList;
    ULONG             NumFlowDesc;
    LPFLOWDESCRIPTOR  FlowDescList;
} RSVP_RESERVE_INFO, *LPRSVP_RESERVE_INFO;
</pre>
</td></tr></table>
</p>

<p>The <i>Style</i> field specifies the filter type that should be applied to this receiver. Table 12-7 lists the filter types available and the default filter types used by different types of receivers. Each filter style will be discussed in greater detail shortly. If the <i>ConfirmRequest</i> field is nonzero, notification will be sent once the RESV request has been received for receiving applications. <i>NumPolicyElements</i> is related to the <i>PolicyElementList</i> field. It contains the number of <i>RSVP_POLICY</i> objects that are contained in the <i>PolicyElementList</i> field. (We define <i>RSVP_POLICY</i> a little bit later in this chapter.) Let's take a look at the different filter styles and the characteristics of each.</p>

<p><b><i>RSVP_DEFAULT_STYLE</i></b></p>

<p>This flag tells the QOS service provider to use the default style. Table 12-7 lists the default styles for the different possible receivers. Unicast receivers use fixed filter, whereas wildcard is for multicast receivers. UDP receivers that call <i>WSAConnect</i> also use fixed filter.</p>

<p><b>Table 12-7.</b> <i>Default filter styles</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th><i>Filter Style</i>  </th>
<th><i>Default Users</i>  </th></tr>
<tr>
<td valign="top">Fixed filter  </td>
<td valign="top">Unicast receivers<br>
 Connected UDP receivers  </td></tr>
<tr>
<td valign="top">Wildcard  </td>
<td valign="top">Multicast receivers<br>
 Unconnected UDP receivers  </td></tr>
<tr>
<td valign="top">Shared explicit  </td>
<td valign="top">None  </td></tr>
</table></p>


<p><b><i>RSVP_FIXED_FILTER_STYLE</i></b></p>

<p>Normally this style establishes a single flow with QOS guarantees between the receiver and a single source. This is the case for a unicast receiver and connected UDP receivers: <i>NumFlowDesc</i> is set to 1, and <i>FlowDescList</i> contains the sender's address. However, it is also possible to set up a multiple fixed filter style that allows a receiver to reserve mutually exclusive flows from multiple, explicitly identified sources. For example, if your receiver intends to receive data from three senders and needs guaranteed bandwidth of 20 Kbps for each, use the multiple fixed filter style. In this example, <i>NumFlowDesc</i> would be set to 3, while <i>FlowDescList</i> would contain three addresses, one for each <i>FLOWSPEC</i>. It is also possible to assign varying levels of QOS to each sender; they do not all have to be equal. Note that unicast receivers and connected UDP receivers cannot use multiple fixed filters. Figure 12-1 shows the relationship between <i>FLOWDESCRIPTOR</i> and <i>
RSVP_FILTERSPEC</i> structures.</p>

<p>
<A HREF="javascript:fullSize('F12ji01x.htm')"> <img src="images/F12ji01.JPG" width=404 height=149 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 12-1.</b> <i>Multiple fixed filter style</i><!-- /caption -->
</p>

<p><b><i>RSVP_WILDCARD_STYLE</i></b></p>

<p>Multicast receivers and unconnected UDP receivers use the wildcard style. To use this style for TCP connections or for connected UDP receivers, set <i>NumFlowDesc</i> to 0 and <i>FlowDescList</i> to <i>NULL</i>. This is the default filter style for unconnected UDP receivers and multicast applications because the sender's address is unknown.</p>

<p><b><i>RSVP_SHARED_EXPLICIT_STYLE</i></b></p>

<p>This style is somewhat similar to multiple fixed filter style except that network resources, instead of being allocated for each sender, are shared among all senders. In this case, <i>NumFlowDesc</i> is 1 and <i>FlowDescList</i> contains the list of sender addresses. Figure 12-2 illustrates this style.</p>

<p>
<A HREF="javascript:fullSize('F12ji02x.htm')"> <img src="images/F12ji02.JPG" width=404 height=159 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 12-2.</b> <i>Shared explicit style</i><!-- /caption -->
</p>

<p>We've introduced the last two fields, <i>NumFlowDesc</i> and <i>FlowDescList</i>, in our discussion of RSVP styles. How you use these two fields depends on the style. <i>NumFlowDesc</i> defines the number of <i>FLOWDESCRIPTOR</i> objects in the <i>FlowDescList</i> field. This structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _FLOWDESCRIPTOR 
{
    FLOWSPEC             FlowSpec;
    ULONG                NumFilters;
    LPRSVP_FILTERSPEC    FilterList;
} FLOWDESCRIPTOR, *LPFLOWDESCRIPTOR;
</pre>
</td></tr></table>
</p>

<p>This object is used to define the types of filters per <i>FLOWSPEC</i> given by <i>FlowSpec</i>. Again, the <i>NumFilters</i> field contains the number of <i>RSVP_FILTERSPEC</i> objects present in the <i>FilterList</i> array. The <i>RSVP_FILTERSPEC</i> object is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _RSVP_FILTERSPEC {
    FilterType   Type;
    union {
        RSVP_FILTERSPEC_V4      FilterSpecV4;
        RSVP_FILTERSPEC_V6      FilterSpecV6;
        RSVP_FILTERSPEC_V6_FLOW FilterSpecV6Flow;
        RSVP_FILTERSPEC_V4_GPI  FilterSpecV4Gpi;
        RSVP_FILTERSPEC_V6_GPI  FilterSpecV6Gpi;
    };
} RSVP_FILTERSPEC, *LPRSVP_FILTERSPEC;
</pre>
</td></tr></table>
</p>

<p>The first field, <i>Type</i>, is a simple enumeration of the following values:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef enum {
        FILTERSPECV4 = 1,
        FILTERSPECV6,
        FILTERSPECV6_FLOW,
        FILTERSPECV4_GPI,
        FILTERSPECV6_GPI,
        FILTERSPEC_END
} FilterType;
</pre>
</td></tr></table>
</p>

<p>This enumeration specifies the object present in the union. Each of these filter specs is defined below.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _RSVP_FILTERSPEC_V4 {
    IN_ADDR_IPV4    Address;
    USHORT          Unused;
    USHORT          Port;
} RSVP_FILTERSPEC_V4, *LPRSVP_FILTERSPEC_V4;

typedef struct _RSVP_FILTERSPEC_V6 {
    IN_ADDR_IPV6    Address;
    USHORT          UnUsed;
    USHORT          Port;
} RSVP_FILTERSPEC_V6, *LPRSVP_FILTERSPEC_V6;

typedef struct _RSVP_FILTERSPEC_V6_FLOW {
    IN_ADDR_IPV6    Address;
    UCHAR           UnUsed;
    UCHAR           FlowLabel[3];
} RSVP_FILTERSPEC_V6_FLOW, *LPRSVP_FILTERSPEC_V6_FLOW;

typedef struct _RSVP_FILTERSPEC_V4_GPI {
    IN_ADDR_IPV4    Address;
    ULONG           GeneralPortId;
} RSVP_FILTERSPEC_V4_GPI, *LPRSVP_FILTERSPEC_V4_GPI;

typedef struct _RSVP_FILTERSPEC_V6_GPI {
    IN_ADDR_IPV6    Address;
    ULONG           GeneralPortId;
} RSVP_FILTERSPEC_V6_GPI, *LPRSVP_FILTERSPEC_V6_GPI;
</pre>
</td></tr></table>
</p>

<A NAME="387"><H3>RSVP Adspec</H3></A>

<p>The <i>RSVP_ADSPEC</i> object defines the information carried in the RSVP Adspec. This RSVP object typically indicates which service types are available (controlled load or guaranteed), whether a non-RSVP hop has been encountered by the PATH message, and the minimum MTU along the path. The structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _RSVP_ADSPEC  
{
    QOS_OBJECT_HDR     ObjectHdr;
    AD_GENERAL_PARAMS  GeneralParams;                      
    ULONG              NumberOfServices; 
    CONTROL_SERVICE    Services[1]; 
} RSVP_ADSPEC, *LPRSVP_ADSPEC;
</pre>
</td></tr></table>
</p>

<p>The first field of interest is <i>GeneralParams</i>, which is a structure of type <i>AD_GENERAL_PARAMS</i>. This structure is exactly as it sounds&#8212;it defines some general characterization parameters. The definition of this object is</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _AD_GENERAL_PARAMS
{
    ULONG       IntServAwareHopCount;
    ULONG       PathBandwidthEstimate;
    ULONG       MinimumLatency;
    ULONG       PathMTU;
    ULONG       Flags;
} AD_GENERAL_PARAMS, *LPAD_GENERAL_PARAMS;
</pre>
</td></tr></table>
</p>

<p>The <i>IntServAwareHopCount</i> is the number of hops that conform to Integrated Services (IntServ) requirements. <i>PathBandwidthEstimate</i> is the minimum bandwidth available from sender to receiver. <i>MinimumLatency</i> is the sum of minimum latencies, in microseconds, of the packet forwarding processes in the routers. <i>PathMTU</i> is the maximum transmission unit&#8212;end-to-end&#8212;that will not incur any fragmentation. The <i>Flags</i> field is not currently used.</p>

<A NAME="388"><H3>RSVP policy info</H3></A>

<p>The last provider object we'll take a look at is the RSVP policy info. This object is rather nebulous&#8212;it contains any number of policy elements from RSVP that are not defined. The structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _RSVP_POLICY_INFO  {
    QOS_OBJECT_HDR     ObjectHdr;
    ULONG              NumPolicyElement; 
    RSVP_POLICY        PolicyElement[1]; 
} RSVP_POLICY_INFO, *LPRSVP_POLICY_INFO;
</pre>
</td></tr></table>
</p>

<p>The <i>NumPolicyElement</i> field gives the number of <i>RSVP_POLICY</i> structures present in the <i>PolicyElement</i> array. This structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _RSVP_POLICY {
    USHORT  Len;
    USHORT  Type;
    UCHAR   Info[4];
} RSVP_POLICY, *LPRSVP_POLICY;
</pre>
</td></tr></table>
</p>

<p>The <i>RSVP_POLICY</i> structure is data transported by RSVP on behalf of the policy component and is not particularly relevant to our needs.</p>

</BODY>
</HTML>




