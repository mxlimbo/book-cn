<HTML>
<HEAD>
<TITLE>Examples</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch12e.htm" , "ch12g.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="398"><H1>Examples</H1></A>

<p>In this section, we'll take a look at three programming examples of how to use QOS. The first example, which uses TCP, is the most straightforward because it is connection-oriented. The second example uses UDP and does not use any connect calls. The last example uses multicast UCP. In all three examples, we will use <i>WSAEventSelect</i> because it's a bit simpler than <i>WSAAsyncSelect</i>. While we include the entire TCP unicast example, we include only important code snippets for the UDP and multicasting examples because many of the concepts are the same, no matter what type of socket is used. See the accompanying CD for the entire example. All three examples rely on a couple of support routines, <i>PrintQos</i> and <i>FindProtocolInfo</i>, which are defined in the files Printqos.c and Provider.c, respectively. The former routine simply prints out the contents of a QOS structure, while the latter finds a protocol from the provider catalog with the required attributes, such as QOS.</p>

<A NAME="399"><H2>Unicast TCP</H2></A>

<p>The example for unicast TCP QOS is given in Figure 12-3. The code for this example can be found in the Chapter 12 folder as Qostcp.c. The example is a bit long, but not particularly complicated. Most of the code is nothing more than the usual <i>WSAEventSelect</i> code that we introduced in <a href="ch08a.htm">Chapter 8</A>. The only exception is what we do in the case of an <i>FD_QOS</i> event. The main function doesn't do anything out of the ordinary. The arguments are parsed, a socket is created, and either the <i>Server</i> or the <i>Client</i> function is called&#8212;depending on whether the application is called as the server or the client. Let's examine the client connection first.</p>

<p>In all three examples, a command line parameter tells the example when to set QOS: before connection, during connection, after connection, or after the peer requests QOS to set QOS locally. (The command line parameters for Qostp.c are listed in Table 12-8.) If QOS is selected to be set before connection (for the client), bind the socket to a random port and then call <i>SIO_SET_QOS</i> with a sending QOS <i>FLOWSPEC</i>. Note that it isn't really necessary to bind before calling <i>SIO_SET_QOS</i> because the peer's address is not known until a connect call is made, and an RSVP session cannot be initiated until the peer's address is known.</p>

<p>If the user elects to set QOS during connection, the example code passes the QOS structure into the <i>WSAConnect</i> call. This call initiates an RSVP session and connects the client to the specified server. Otherwise, the user specifies that the example should wait for the peer to set QOS, and no QOS structure is passed to <i>WSAConnect</i>. Instead the code takes the sending QOS structure, ORs in the <i>SERVICE_NO_QOS_SIGNALING</i> flag to the <i>ServiceType</i> field in the <i>FLOWSPEC</i> structures, and calls <i>WSAIoctl</i> with the <i>SIO_SET_FLAG</i> ioctl command. This tells the QOS service provider not to invoke Traffic Control but to still look for RSVP messages.</p>

<p>After QOS is set, the events that the client wants to be notified of are registered, including <i>FD_QOS</i>. Notice that QOS must be set on the socket beforehand in order for the application to request receiving <i>FD_QOS</i>. Once this occurs, the client waits in a loop on <i>WSAWaitForMultipleEvents</i>, which unblocks when one of the selected events is signaled. Once an event occurs, the events are enumerated along with any errors in <i>WSAEnumNetworkEvents</i>.</p>

<p>For the most part, Qostcp.c handles the other events, such as <i>FD_READ</i>, <i>FD_WRITE</i>, and <i>FD_CLOSE</i>, in the same way as the <i>WSAEventSelect</i> example code in <a href="ch08a.htm">Chapter 8</A>. The only item of note is in the <i>FD_WRITE</i> event. One of the command line options is to wait until an RSVP PATH message has been received before sending the data. This is especially relevant if the data being transmitted is likely to exceed the best-effort bandwidth available on the network. The <i>AbleToSend</i> function calls <i>SIO_CHK_QOS</i> to determine whether the QOS parameters requested are within the available best-effort limits. If so, it should be OK to start sending data; otherwise, wait for a confirmation to send data.</p>

<p>In our client's case, we want to receive the <i>WSA_QOS_RECEIVERS</i> message to indicate the receipt of a RESV message. This can be indicated upon receipt of an <i>FD_QOS</i> event. At this point, we call the <i>SIO_CHK_QOS</i> command to obtain status information. This <i>WSA_QOS_RECEIVERS</i> flag can be returned in two ways. First the flag can be returned in the <i>iErrorCode</i> field of the <i>WSANETWORKEVENTS</i> structure as the element indexed by <i>FD_QOS_BIT</i>. Second an <i>RSVP_STATUS_INFO</i> structure can be returned in the buffer passed to <i>WSAIoctl</i> using the <i>SIO_GET_QOS</i> ioctl command. This structure too might contain the <i>WSA_QOS_RECEIVERS</i> flag in its <i>StatusCode</i> field.ç‡Ÿf the wait to send flag has been specified, we check the error field from <i>WSANETWORKEVENTS</i> to see whether an <i>RSVP_STATUS_INFO</i> structure has been returned. If the flag is present, we send data. That's all! The code necessary to support QOS for the client is
straightforward.</p>

<p>The server side of the example is a bit more complicated, but only because it needs to manage zero or more client connections. The listening socket and the client sockets are handled in a single array, <i>sc</i>. Array element 0 is the listening socket, while the rest are possible client connections. The global variable <i>nConns</i> contains the number of current clients. Whenever a client connection finishes, all active sockets are compacted toward the beginning of the socket array. There is also a corresponding array of event handles.</p>

<p>The server first binds the listening socket and sets receiving QOS if the user chooses to set QOS before accepting client connections. Any QOS parameters set on the listening socket are copied to the client connection (unless the server is using <i>AcceptEx</i>). The listening socket registers to receive only <i>FD_ACCEPT</i> events. The rest of the server routine is a loop that waits for events on the array of socket handles. At first the only socket in the array is the listening socket, but as more client connections are established there will be more sockets and their corresponding events. If <i>WSAWaitForMultipleEvents</i> unblocks as a result of an event and indicates the event handle in array element 0, the event is occurring on the listening socket. If so, the code calls <i>WSAEnumNetworkEvents</i> to find out which event is occurring. If the event is occurring on a client socket, the code calls the handler routine <i>HandleClientEvents</i>.</p>

<p>On the listening socket, the event of interest is <i>FD_ACCEPT</i>. When this event happens, <i>WSAAccept</i> is called with a conditional function. Remember that the QOS parameters passed into the conditional function can't be trusted, and if the QOS parameter is non-null on Windows 98, some sort of QOS must be set. Windows 2000 does not have that limitation; QOS can be set at any time. If the user specifies that QOS be set during the accept call, this occurs within the conditional function. Once the client socket is accepted, a corresponding event handle is created and the appropriate events are registered for the socket.</p>

<p>The function <i>HandleClientEvents</i> handles any events occurring on the client sockets. The read and write events are straightforward&#8212;the only exception is whether to wait for the reservation confirmation before sending. If the user specifies to wait for the reservation confirmation to arrive before sending data, the client waits for the <i>WSA_QOS_RECEIVERS</i> message to be returned in an <i>FD_QOS</i> event. If the message returns, the sending of the data doesn't occur until <i>FD_QOS</i> is received. Usually the most significant aspect of this example is the setting of QOS on the socket and the <i>FD_QOS</i> handler.</p>

<p><b>Figure 12-3.</b> <i>Unicast TCP example (Qostcp.c)</i> </p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
//ç‡¤odule:ç‡ªostcp.c
//
#include