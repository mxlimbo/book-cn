<HTML>
<HEAD>
<TITLE>Ipconfig</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("chaba.htm" , "chabc.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="528"><H1>Ipconfig</H1></A>

<p>The Ipconfig.exe utility presents two pieces of information: IP configuration information and IP configuration parameters specific to each network adapter installed on your machine. To retrieve IP configuration information, use the <i>GetNetworkParams</i> function, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
DWORD GetNetworkParams(
    PFIXED_INFO pFixedInfo,
    PULONG pOutBufLen
);
</pre>
</td></tr></table>
</p>

<p>The <i>pFixedInfo</i> parameter receives a pointer to a buffer that receives a <i>FIXED_INFO</i> data structure your application must provide to retrieve the IP configuration information. The <i>pOutBufLen</i> parameter is a pointer to a variable that specifies the size of the buffer you passed in the <i>pFixedInfo</i> parameter. If your buffer is not large enough, <i>GetNetworkParams</i> returns <i>ERROR_BUFFER_OVERFLOW</i> and sets the <i>pOutBufLen</i> parameter to the required buffer size.</p>

<p>The <i>FIXED_INFO</i> structure used in <i>GetNetworkParams</i> is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct 
{
    char            HostName[MAX_HOSTNAME_LEN + 4] ;
    char            DomainName[MAX_DOMAIN_NAME_LEN + 4];
    PIP_ADDR_STRING CurrentDnsServer;
    IP_ADDR_STRING  DnsServerList;
    UINT            NodeType;
    char            ScopeId[MAX_SCOPE_ID_LEN + 4];
    UINT            EnableRouting;
    UINT            EnableProxy;
    UINT            EnableDns;
} FIXED_INFO, *PFIXED_INFO;
</pre>
</td></tr></table>
</p>

<p>The fields are defined as follows:</p>

<ul>
<p><li><b><i>HostName</i></b> Represents your computer's name as recognized by DNS.</li></p>

<p><li><b><i>DomainName</i></b> Specifies the DNS domain your computer belongs to.</li></p>

<p><li><b><i>CurrentDnsServer</i></b> Contains the IP address of the current DNS server.</li></p>

<p><li><b><i>DnsServerList</i></b> Is a linked list containing the DNS servers that your machine uses.</li></p>

<p><li><b><i>NodeType</i></b> Specifies how the system resolves NetBIOS names over an IP network. Table B-1 contains the possible values.</li></p>

<p><li><b><i>ScopeId</i></b> Identifies a string value that is appended to a NetBIOS name to logically group two or more computers for NetBIOS communication over TCP/IP.</li></p>

<p><li><b><i>EnableRouting</i></b> Specifies whether the system will route IP packets between the networks it is connected to.</li></p>

<p><li><b><i>EnableProxy</i></b> Specifies whether the system will act as a WINS proxy agent on a network. A WINS proxy agent answers broadcast queries for names that it has resolved through WINS and allows a network of b-node computers to connect to servers on other subnets registered with WINS.</li></p>

<p><li><b><i>EnableDns</i></b> Specifies whether NetBIOS will query DNS for names that cannot be resolved by WINS, broadcast, or the <i>LMHOSTS</i> file.</li></p>
</ul>

<p><b>Table B-1.</b> <i>Possible node type values</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th><i>Value</i>  </th>
<th><i>Description</i>  </th></tr>
<tr>
<td valign="top"><i>BROADCAST_NODETYPE</i>  </td>
<td valign="top">Known as b-node NetBIOS name resolution, in which the system uses IP broadcasting to perform NetBIOS name registration and name resolution.  </td></tr>
<tr>
<td valign="top"><i>PEER_TO_PEER_NODETYPE</i>  </td>
<td valign="top">Known as p-node NetBIOS name resolution, in which the system uses point-to-point communication with a NetBIOS name server (such as WINS) to register and resolve computer names to IP addresses.  </td></tr>
<tr>
<td valign="top"><i>MIXED_NODETYPE</i>  </td>
<td valign="top">Known as m-node (mixed node) NetBIOS name resolution, in which the system uses both the b-node and p-node techniques just described. The b-node method is used first; if it fails, the p-node method is used next.  </td></tr>
<tr>
<td valign="top"><i>HYBRID_NODETYPE</i>  </td>
<td valign="top">Known as h-node (hybrid node) NetBIOS name resolution, in which the system uses both the b-node and p-node techniques. The p-node method is used first; if it fails, the b-node method is used next.  </td></tr>
</table></p>



<p>The <i>DnsServerList</i> field of a <i>FIXED_INFO</i> structure is an <i>IP_ADDR_STRING</i> structure that represents the beginning of a linked list of IP addresses. This field is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _IP_ADDR_STRING 
{
    struct _IP_ADDR_STRING* Next;
    IP_ADDRESS_STRING       IpAddress;
    IP_MASK_STRING          IpMask;
    DWORD                   Context;
} IP_ADDR_STRING, *PIP_ADDR_STRING;
</pre>
</td></tr></table>
</p>

<p>The <i>Next</i> field identifies the next DNS server IP address in the list. If <i>Next</i> is set to <i>NULL</i>, it indicates the end of the list. The <i>IpAddress</i> field is a string of characters that represents an IP address as a dotted decimal string. The <i>IpMask</i> field is a string of characters that represents the subnet mask associated with the IP address listed in <i>IpAddress</i>. The final field, <i>Context</i>, identifies the IP address with a unique value on the system.</p>

<p>The Ipconfig.exe utility is also capable of retrieving IP configuration information specific to a network interface. A network interface can be a hardware Ethernet adapter or even a RAS dial-up adapter. You can retrieve adapter information by calling <i>GetAdaptersInfo</i>, which is defined below.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
DWORD GetAdaptersInfo ( 
    PIP_ADAPTER_INFO pAdapterInfo, 
    PULONG pOutBufLen 
);
</pre>
</td></tr></table>
</p>

<p>Use the <i>pAdapterInfo</i> parameter to pass a pointer to an application-provided buffer that receives an <i>ADAPTER_INFO</i> data structure with the adapter configuration information. The <i>pOutBufLen</i> parameter is a pointer to a variable that specifies the size of the buffer you passed in the <i>pAdapterInfo</i> parameter. If your buffer is not large enough, <i>GetAdaptersInfo</i> returns <i>ERROR_BUFFER_OVERFLOW</i> and sets the <i>pOutBufLen</i> parameter to the required buffer size.</p>

<p>The <i>IP_ADAPTER_INFO</i> structure is actually a list of structures containing IP configuration information specific to every network adapter available on your machine. <i>IP_ADAPTER_INFO</i> is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _IP_ADAPTER_INFO 
{ 
    struct _IP_ADAPTER_INFO* Next; 
    DWORD           ComboIndex; 
    char            AdapterName[MAX_ADAPTER_NAME_LENGTH + 4]; 
    char            Description[MAX_ADAPTER_DESCRIPTION_LENGTH + 4]; 
    UINT            AddressLength; 
    BYTE            Address[MAX_ADAPTER_ADDRESS_LENGTH]; 
    DWORD           Index; 
    UINT            Type; 
    UINT            DhcpEnabled; 
    PIP_ADDR_STRING CurrentIpAddress; 
    IP_ADDR_STRING  IpAddressList; 
    IP_ADDR_STRING  GatewayList; 
    IP_ADDR_STRING  DhcpServer; 
    BOOL            HaveWins; 
    IP_ADDR_STRING  PrimaryWinsServer; 
    IP_ADDR_STRING  SecondaryWinsServer; 
    time_t          LeaseObtained; 
    time_t          LeaseExpires; 
} IP_ADAPTER_INFO, *PIP_ADAPTER_INFO;
</pre>
</td></tr></table>
</p>

<p>The fields of the structure are defined as follows:</p>

<ul>
<p><li><b><i>Next</i></b> Identifies the next adapter in the buffer. A <i>NULL</i> value indicates the end of the list.</li></p>

<p><li><b><i>ComboIndex</i></b> Is not used and will be set to 0.</li></p>

<p><li><b><i>AdapterName</i></b> Identifies the name of the adapter.</li></p>

<p><li><b><i>Description</i></b> Is a simple description of the adapter.</li></p>

<p><li><b><i>AddressLength</i></b> Identifies how many bytes make up the physical address of the adapter in the <i>Address</i> field.</li></p>

<p><li><b><i>Address</i></b> Identifies the physical address of the adapter.</li></p>

<p><li><b><i>Index</i></b> Identifies a unique internal index number of the network interface that this adapter is assigned to.</li></p>

<p><li><b><i>Type</i></b> Specifies the type of the adapter as a numeric value. Table B-2 defines the adapter types supported.</li></p>
</ul>

<p><b>Table B-2.</b> <i>Adapter types</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th><i>Adapter Type Value</i>  </th>
<th><i>Description</i>  </th></tr>
<tr>
<td valign="top"><i>MIB_IF_TYPE_ETHERNET</i>  </td>
<td valign="top">Ethernet adapter  </td></tr>
<tr>
<td valign="top"><i>MIB_IF_TYPE_FDDI</i>  </td>
<td valign="top">FDDI adapter  </td></tr>
<tr>
<td valign="top"><i>MIB_IF_TYPE_LOOPBACK</i>  </td>
<td valign="top">Loopback adapter  </td></tr>
<tr>
<td valign="top"><i>MIB_IF_TYPE_OTHER</i>  </td>
<td valign="top">Other type of adapter  </td></tr>
<tr>
<td valign="top"><i>MIB_IF_TYPE_PPP</i>  </td>
<td valign="top">PPP adapter  </td></tr>
<tr>
<td valign="top"><i>MIB_IF_TYPE_SLIP</i>  </td>
<td valign="top">Slip adapter  </td></tr>
<tr>
<td valign="top"><i>MIB_IF_TYPE_TOKENRING</i>  </td>
<td valign="top">Token Ring adapter  </td></tr>
</table></p>

<ul>
<p><li> <b>DhcpEnabled</b> Specifies whether DHCP is enabled on this adapter.</li></p>

<p><li> <b>CurrentIpAddress</b> Is not used and will be set to a NULL value.</li></p>

<p><li> <b>IpAddressList</b> Specifies a list of IP addresses assigned to the adapter.</li></p>

<p><li> <b>GatewayList</b> Specifies a list of IP addresses representing the default gateway.</li></p>

<p><li> <b>DhcpServer</b> Specifies a list with only one element representing the IP address of the DHCP server used.</li></p>

<p><li> <b>HaveWins</b> Specifies whether the adapter uses a WINS server.</li></p>

<p><li> <b>PrimaryWinsServer</b> Specifies a list with only one element representing the IP address of the primary WINS server used.</li></p>

<p><li> <b>SecondaryWinsServer</b> Specifies a list with only one element representing the IP address of the secondary WINS server used.</li></p>

<p><li> <b>LeaseObtained</b> Identifies when the lease for the IP address was obtained from a DHCP server.</li></p>

<p><li> <b>LeaseExpires</b> Identifies when the lease on the IP address obtained from DHCP expires.</li></p>
</ul>



<A NAME="529"><H2>Releasing and Renewing IP Addresses</H2></A>

<p>The Ipconfig.exe utility also features the ability to release and renew IP addresses obtained from the DHCP server by specifying the /release and /renew command line parameters. If you want to programmatically release an IP address, you can call the <i>IPReleaseAddress</i> function, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
DWORD IpReleaseAddress ( 
    PIP_ADAPTER_INDEX_MAP AdapterInfo
);
</pre>
</td></tr></table>
</p>

<p>If you want to renew an IP address, you can call the <i>IPRenewAddress</i> function, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
DWORD IpRenewAddress ( 
    PIP_ADAPTER_INDEX_MAP AdapterInfo
);
</pre>
</td></tr></table>
</p>

<p>Each of these two functions features an <i>AdapterInfo</i> parameter that is an <i>IP_ADAPTER_INDEX_MAP</i> structure, which identifies the adapter to release or renew the address for. The <i>IP_ADAPTER_INDEX_MAP</i> structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _IP_ADAPTER_INDEX_MAP
{
    ULONG Index;
    WCHAR Name[MAX_ADAPTER_NAME];
}IP_ADAPTER_INDEX_MAP, *PIP_ADAPTER_INDEX_MAP;
</pre>
</td></tr></table>
</p>

<p>The fields of this structure are defined as follows:</p>

<ul>
<p><li><b><i>Index</i></b> Identifies the internal index of the network interface that the adapter is assigned to.</li></p>

<p><li><b><i>Name</i></b> Identifies the name of the adapter.</li></p>
</ul>



<p>You can retrieve the <i>IP_ADAPTER_INDEX_MAP</i> structure for a particular adapter by calling the <i>GetInterfaceInfo</i> function, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
DWORD GetInterfaceInfo ( 
    IN PIP_INTERFACE_INFO pIfTable, 
    OUT PULONG dwOutBufLen 
);
</pre>
</td></tr></table>
</p>

<p>The <i>pIfTable</i> parameter is a pointer to an <i>IP_INTERFACE_INFO</i> application buffer that will receive interface information. The <i>dwOutBufLen</i> parameter is a pointer to a variable that specifies the size of the buffer you passed in the <i>pIfTable</i> parameter. If the buffer is not large enough to hold the interface information, <i>GetInterfaceInfo</i> returns the error <i>ERROR_INSUFFICIENT_BUFFER</i> and sets the <i>dwOutBufLen</i> parameter to the required buffer size.</p>

<p>The <i>IP_INTERFACE_INFO</i> structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _IP_INTERFACE_INFO
{
    LONG                 NumAdapters;
    IP_ADAPTER_INDEX_MAP Adapter[1];
} IP_INTERFACE_INFO,*PIP_INTERFACE_INFO;
</pre>
</td></tr></table>
</p>

<p>Its fields are defined as follows:</p>

<ul>
<p><li><b><i>NumAdapters</i></b> Identifies the number of adapters in the <i>Adapter</i> field.</li></p>

<p><li><b><i>Adapter</i></b> Is an array of <i>IP_ADAPTER_INDEX_MAP</i> structures, defined above.</li></p>
</ul>



<p>Once you have obtained the <i>IP_ADAPTER_INDEX_MAP</i> structure for a particular adapter, you can release or renew the DHCP-assigned IP address using the <i>IPReleaseAddress</i> and <i>IPRenewAddress</i> functions we just described.</p>

<A NAME="530"><H2>Changing IP Addresses</H2></A>

<p>The Ipconfig.exe utility does not allow you to change an IP address for a network adapter (except in the case of DHCP). However, two functions will allow you to add or delete an IP address for a particular adapter: the <i>AddIpAddress</i> and <i>DeleteIpAddress</i> IP Helper functions. These functions require you to understand adapter index numbers and IP context numbers. In Windows, every network adapter has a unique index ID (which we described earlier), and every IP address has a unique context ID. Adapter index IDs and IP context numbers can be retrieved using <i>GetAdaptersInfo</i>. The <i>AddIpAddress</i> function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
DWORD AddIPAddress ( 
    IPAddr Address,
    IPMask IpMask,
    DWORD IfIndex,
    PULONG NTEContext,
    PULONG NTEInstance
);
</pre>
</td></tr></table>
</p>

<p>The <i>Address</i> parameter specifies the IP address to add as an unsigned long value. The <i>IpMask</i> parameter specifies the subnet mask for the IP address as an unsigned long value. The <i>IfIndex</i> parameter specifies the adapter index to add the address to. The <i>NTEContext</i> parameter receives the context value associated with the IP address added. The <i>NTEInstance</i> parameter receives an instance value associated with an IP address.</p>

<p>If you want to programmatically delete an IP address for an adapter, you can call <i>DeleteIpAddress</i>, which is defined below.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
DWORD DeleteIPAddress ( 
    ULONG NTEContext
);
</pre>
</td></tr></table>
</p>

<p>The <i>NTEContext</i> parameter identifies a context value associated with an IP address. This value can be obtained from <i>GetAdaptersInfo</i>, which we described earlier in the chapter.</p>

</BODY>
</HTML>



