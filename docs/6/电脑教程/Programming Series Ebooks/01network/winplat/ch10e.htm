<HTML>
<HEAD>
<TITLE>Querying a Service</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch10d.htm" , "ch10f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="318"><H1>Querying a Service</H1></A>

<p>Now that you know how to register a service within a name space, you'll take a look at how a client can query the name space for a given service so that the client can obtain information about the service for communication purposes. Name resolution is quite a bit simpler than service registration, even though name resolution uses three functions for querying: <i>WSALookupServiceBegin</i>, <i>WSALookupServiceNext</i>, and <i>WSALookupServiceEnd.</i></p>

<p>The first step when performing a query is to call <i>WSALookupServiceBegin</i>, which initiates the query by setting up the constraints within which the query will act. The function prototype is as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
INT WSALookupServiceBegin (
    LPWSAQUERYSET lpqsRestrictions, 
    DWORD dwControlFlags, 
    LPHANDLE lphLookup
);
</pre>
</td></tr></table>
</p>

<p>The first parameter is a <i>WSAQUERYSET</i> structure that places constraints on the query, such as limiting the name spaces to query. The second parameter, <i>dwControlFlags</i>, determines the depth of the search. Table 10-7 contains the various possible flags and their meanings. These flags affect how the query behaves as well as which data is returned from the query. The last parameter is of type <i>HANDLE</i> and is initialized upon function return. The return value is 0 on success; otherwise, <i>SOCKET_ERROR</i> is returned. If one or more parameters are invalid, <i>WSAGetLastError</i> returns <i>WSAEINVAL</i>. If the name is found in the name space but no data matches the given restrictions, the error is <i>WSANO_DATA</i>. If the given service does not exist, <i>WSASERVICE_NOT_FOUND</i> is the error.</p>

<p><b>Table 10-7.</b> <i>Control flags</i></p>

<p>
<table cellpadding=5 width="95%">
<tr><th><i>Flag</i></th>
<th><i>Meaning</i></th></tr>
<tr><td valign="top"><i>LUP_DEEP</i></td>
<td valign="top">In hierarchical name spaces, query deep as opposed to the first level.</td></tr>
<tr><td valign="top"><i>LUP_CONTAINERS</i></td>
<td valign="top">Retrieve container objects only. This flag pertains to hierarchical name spaces only.</td></tr>
<tr><td valign="top"><i>LUP_NOCONTAINERS</i></td>
<td valign="top">Do not return any containers. This flag pertains to hierarchical name spaces only.</td></tr>
<tr><td valign="top"><i>LUP_FLUSHCACHE</i></td>
<td valign="top">Ignore cached information, and query the name space directly. Note that not all name providers cache queries.</td></tr>
<tr><td valign="top"><i>LUP_FLUSHPREVIOUS</i></td>
<td valign="top">Instruct the name provider to discard the information set previously returned. This flag is typically used after <i>WSALookupServiceNext</i> returns <i>WSA_NOT_ENOUGH_MEMORY</i>. The information that was too big for the supplied buffer is discarded, and the next information set is to be retrieved.</td></tr>
<tr><td valign="top"><i>LUP_NEAREST</i></td>
<td valign="top">Retrieve the results in order of distance. Note that it is up to the name provider to calculate this distance metric, as there is no specific provision for this information when a service is registered. Name providers are not required to support this concept.</td></tr>
<tr><td valign="top"><i>LUP_RES_SERVICE</i></td>
<td valign="top">Specifies that the local address be returned in the <i>CSADDR_INFO</i> structure.</td></tr>
<tr><td valign="top"><i>LUP_RETURN_ADDR</i></td>
<td valign="top">Retrieve the addresses as <i>lpcsaBuffer.</i></td></tr>
<tr><td valign="top"><i>LUP_RETURN_ALIASES</i></td>
<td valign="top">Retrieve only alias information. Each alias will be returned in successive calls to <i>WSALookupServiceNext</i> and will have the <i>RESULT_IS_ALIAS</i> flag set.</td></tr>
<tr><td valign="top"><i>LUP_RETURN_ALL</i></td>
<td valign="top">Retrieve all available information.</td></tr>
<tr><td valign="top"><i>LUP_RETURN_BLOB</i></td>
<td valign="top">Retrieve the private data as <i>lpBlob.</i></td></tr>
<tr><td valign="top"><i>LUP_RETURN_COMMENT</i></td>
<td valign="top">Retrieve the comment as <i>lpszComment.</i></td></tr>
<tr><td valign="top"><i>LUP_RETURN_NAME</i></td>
<td valign="top">Retrieve the name as <i>lpszServiceInstanceName.</i></td></tr>
<tr><td valign="top"><i>LUP_RETURN_TYPE</i></td>
<td valign="top">Retrieve the type as <i>lpServiceClassId.</i></td></tr>
<tr><td valign="top"><i>LUP_RETURN_VERSION</i></td>
<td valign="top">Retrieve the version as <i>lpVersion</i>.</td></tr>
</table></p>

<p>When you make a call to <i>WSALookupServiceBegin</i>, a handle for the query is returned that you pass to <i>WSALookupServiceNext</i>, which returns the data to you. The function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
INT WSALookupServiceNext (
    HANDLE hLookup, 
    DWORD dwControlFlags, 
    LPDWORD lpdwBufferLength, 
    LPWSAQUERYSET lpqsResults
);
</pre>
</td></tr></table>
</p>

<p>The handle <i>hLookup</i> is returned from <i>WSALookupServiceBegin</i>. The <i>dwControlFlags</i> parameter has the same meaning as in <i>WSALookupServiceBegin</i> except that only <i>LUP_FLUSHPREVIOUS</i> is supported. The parameter <i>lpdwBufferLength</i> is the length of the buffer passed as <i>lpqsResults</i>. Because the <i>WSAQUERYSET</i> structure could contain binary large object (BLOB) data, it is often required that you pass a buffer larger than the structure itself. If the buffer size is insufficient for the data to be returned, the function call fails with <i>WSA_NOT_ENOUGH_MEMORY</i>.</p>

<p>Once you have initiated the query with <i>WSALookupServiceBegin</i>, call <i>WSALookupServiceNext</i> until the error <i>WSA_E_NO_MORE</i> (10110) is generated. One note of caution: in earlier implementations of Winsock, the error code for no more data is <i>WSAENOMORE</i> (10102), so robust code should check for both error codes. Once all the data has been returned or you have finished querying, call <i>WSALookupServiceEnd</i> with the <i>HANDLE</i> variable used in the queries. The function is</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
INT WSALookupServiceEnd ( HANDLE hLookup );
</pre>
</td></tr></table>
</p>

<A NAME="319"><H2>Forming a Query</H2></A>

<p>Let's look at how you can query the service you registered in the previous section. The first thing to do is set up a <i>WSAQUERYSET</i> structure that defines the query. Look at the following code:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
WSAQUERYSET    qs;
GUID        guid = SVCID_NETWARE(200);
AFPROTOCOLS      afp[2] = {{AF_IPX,  NSPROTO_IPX}, {AF_INET, IPPROTO_UDP}};
HANDLE        hLookup;
int        ret;

memset(&amp;qs, 0, sizeof(qs));
qs.dwSize = sizeof (WSAQUERYSET);
qs.lpszServiceInstanceName = &quot;Widget Server&quot;;
qs.lpServiceClassId = &amp;guid;
qs.dwNameSpace = NS_ALL;
qs.dwNumberOfProtocols = 2; 
qs.lpafpProtocols = afp;

ret = WSALookupServiceBegin(&amp;qs, LUP_RETURN_ADDR | LUP_RETURN_NAME,
         &amp;hLookup);
if (ret == SOCKET_ERROR)
    // Error
</pre>
</td></tr></table>
</p>

<p>Remember that all service lookups are based on the service class GUID that the service you are searching for is based on. The variable <i>guid</i> is set to the service class ID of our server. You first initialize <i>qs</i> to 0 and set the <i>dwSize</i> field to the size of the structure. The next step is to give the name of the service you are searching for. The service name can be the exact name of the server, or you can specify a wildcard (*) that will return all services of the given service class GUID. Next you tell the query to search all name spaces by using the <i>NS_ALL</i> constant. Last you set up the protocols that our client is capable of connecting with, which are IPX and UDP/IP. This is done by using an array of two <i>AFPROTOCOLS</i> structures.</p>

<p>Now you are ready to begin the query, so you must call <i>WSALookupServiceBegin</i>. The first parameter is our <i>WSAQUERYSET</i> structure, while the next parameters are flags defining which data should be returned if a matching service is found. Here you specify that you want addressing information and the service name by logically ORing the two flags <i>LUP_RETURN_ADDR</i> and <i>LUP_RETURN_NAME</i>. The flag <i>LUP_RETURN_NAME</i> is necessary only if you're specifying the wildcard (*) for the service name; otherwise, you already know the name of the service. The last parameter is a <i>HANDLE</i> variable that identifies this particular query. It will be initialized upon successful return.</p>

<p>Once the query is successfully opened, you call <i>WSALookupServiceNext</i> until <i>WSA_E_NO_MORE</i> is returned. Each successful call returns information about a service that matches our criteria. Here is what the code looks like for this step:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
char          buff[sizeof(WSAQUERYSET) + 2000];
DWORD         dwLength, dwErr;
WSAQUERYSET  *pqs = NULL;
SOCKADDR     *addr;
int           i;

pqs = (WSAQUERYSET *)buff;
dwLength = sizeof(WSAQUERYSET) + 2000;
while (1)
{
    ret = WSALookupServiceNext(hLookup, 0, &amp;dwLength, pqs);
    if (ret == SOCKET_ERROR)
    {
        if ((dwErr = WSAGetLastError()) == WSAEFAULT)
        {
            printf(&quot;Buffer too small; required size is: %d\n&quot;, dwLength);
            break;
        }
        else if ((dwErr == WSA_E_NO_MORE) || (dwErr = WSAENOMORE))
            break;
        else
        {
            printf(&quot;Failed with error: %d\n&quot;, dwErr);
            break;
        }
    }
    for (i = 0; i &lt; pqs-&gt;dwNumberOfCsAddrs; i++)
    {
        addr = (SOCKADDR *)pqs-&gt;lpcsaBuffer[i].RemoteAddr.lpSockaddr;
        if (addr-&gt;sa_family == AF_INET)
        {
            SOCKADDR_IN *ipaddr = (SOCKADDR_IN *)addr;
            printf(&quot;IP address:port = %s:%d\n&quot;, inet_ntoa(addr-&gt;sin_addr),
            addr-&gt;sin_port);
        }
        else if (addr-&gt;sa_family == AF_IPX)
        {
            SOCKADDR_IPX *ipxaddr = (SOCKADDR_IPX *)addr;
            printf(&quot;%02X%02X%02X%02X.%02X%02X%02X%02X%02X%02X:%04X&quot;, 
                (unsigned char)ipxaddr-&gt;sa_netnum[0],
                (unsigned char)ipxaddr-&gt;sa_netnum[1],
                (unsigned char)ipxaddr-&gt;sa_netnum[2],
                (unsigned char)ipxaddr-&gt;sa_netnum[3],
                (unsigned char)ipxaddr-&gt;sa_nodenum[0],
                (unsigned char)ipxaddr-&gt;sa_nodenum[1],
                (unsigned char)ipxaddr-&gt;sa_nodenum[2],
                (unsigned char)ipxaddr-&gt;sa_nodenum[3],
                (unsigned char)ipxaddr-&gt;sa_nodenum[4],
                (unsigned char)ipxaddr-&gt;sa_nodenum[5],
                ntohs(ipxaddr-&gt;sa_socket));
        }
    }
}
WSALookupServiceEnd(hLookup);
</pre>
</td></tr></table>
</p>

<p>The example code is straightforward, although a bit simplified. Calling <i>WSALookupServiceNext</i> requires only a valid handle to a query, the length of the return buffer, and the return buffer itself. You don't need to specify any control flags, as the only valid flag for this function is <i>LUP_FLUSHPREVIOUS</i>. If our supplied buffer is too small and this flag is set, the results from this call are discarded. However, in this example we don't use <i>LUP_FLUSHPREVIOUS</i>, and if our buffer is too small, the <i>WSAEFAULT</i> error is generated. If this occurs, <i>lpdwBufferLength</i> is set to the required size. Our example uses a fixed-size buffer equal to the size of the <i>WSAQUERYSET</i> structure plus 2000 bytes. Since all you are asking for are service names and addresses, this should be a sufficient size. Of course, in production code your applications should be prepared to handle the <i>WSAEFAULT</i> error.</p>

<p>Once you successfully call <i>WSALookupServiceNext</i>, the buffer is filled with a <i>WSAQUERYSET</i> structure containing the results. In our query, you asked for names and addresses; the fields of <i>WSAQUERYSET</i> that are of most interest are <i>lpszServiceInstanceName</i> and <i>lpcsaBuffer</i>. The former contains the name of the service, while the latter is an array of <i>CSADDR_INFO</i> structures that contains addressing information for the service. The parameter <i>dwNumberOfCsAddrs</i> tells us exactly how many addresses have been returned. In the example code, all we do is simply print out the addresses. Check only for IPX and IP addresses to print because those are the only address families you requested when you opened the query.</p>

<p>If our query used a wildcard (*) for the service name, each call to <i>WSALookupServiceNext</i> would return a particular instance of that service running somewhere on the network&#8212;provided, of course, that multiple instances are actually registered and running. Once all instances of the service have been returned, the error <i>WSA_E_NO_MORE</i> is generated, and you break out of the loop. The last thing you do is call <i>WSALookupServiceEnd</i> on the query handle. This releases any resources allocated for the query.</p>

<A NAME="320"><H2>Querying DNS</H2></A>

<p>Earlier we mentioned that the DNS namespace is static, which means you cannot dynamically register your service; however, you can still use the Winsock name resolution functions to perform a DNS query. Performing a DNS query is actually a bit more complicated than performing a normal query for a service that you have registered because the DNS name space provider returns the query information in the form of a BLOB. Why does it do this? Remember from the <a href="ch06a.htm">Chapter 6</A> discussion of <i>gethostbyname</i> that a name lookup returns a <i>HOSTENT</i> structure that contains not only IP addresses but also aliases. That information doesn't quite fit into the fields of the <i>WSAQUERYSET</i> structure.</p>

<p>The tricky thing about BLOB data is that the format of the data is not well documented, which makes directly querying DNS challenging. First let's take a look at how to open the query. The file Dnsquery.c on the companion CD contains the entire example code for querying DNS directly; however, we'll take a look at it piece by piece. The following code illustrates initializing the DNS query:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
WSAQUERYSET  qs;
AFPROTOCOLS  afp [2] = {{AF_INET, IPPROTO_UDP},{AF_INET, IPPROTO_TCP}};
GUID         hostnameguid = SVCID_INET_HOSTADDRBYNAME;
DWORD        dwLength = sizeof(WSAQUERYSET) + sizeof(HOSTENT) + 2048;
HANDLE       hQuery;

qs = (WSAQUERYSET *)buff;
memset(&amp;qs, 0, sizeof(qs));
qs.dwSize = sizeof(WSAQUERYSET);
qs.lpszServiceInstanceName = argv[1];
qs.lpServiceClassId = &amp;hostnameguid;
qs.dwNameSpace = NS_DNS;
qs.dwNumberOfProtocols = 2;
qs.lpafProtocols = afp;

ret = WSALookupServiceBegin(&amp;qs, LUP_RETURN_NAME | LUP_RETURN_BLOB,
    &amp;hQuery);
if (ret == SOCKET_ERROR)
    // Error
</pre>
</td></tr></table>
</p>

<p>Setting up the query is quite similar to our previous example. The most noticeable change is that we use the predefined GUID <i>SVCID_INET_HOSTADDRBYNAME</i>. This is the GUID that identifies host name queries. The <i>lpszServiceInstanceName</i> is the host name that we want to resolve. Because we are resolving host names through DNS, we need to specify only <i>NS_DNS</i> for <i>dwNameSpace</i>. Finally, <i>lpafProtocols</i> is set to an array of two <i>AFPROTOCOLS</i> structures, which defines the TCP/IP and UDP/IP protocols as those that our query is interested in.</p>

<p>Once you establish the query, you can call <i>WSALookupServiceNext</i> to return data.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
char         buff[sizeof(WSAQUERYSET) + sizeof(HOSTENT) + 2048)];
DWORD        dwLength = sizeof(WSAQUERYSET) + sizeof(HOSTENT) + 2048;
WSAQUERYSET *pqs;
HOSTENT     *hostent;

pqs = (WSAQUERYSET *)buff;
pqs-&gt;dwSize = sizeof(WSAQUERYSET);
ret = WSALookupServiceNext(hQuery, 0, &amp;dwLength, pqs);
if (ret == SOCKET_ERROR)
    // Error
WSALookupServiceEnd(hQuery);

hostent = pqs-&gt;lpBlob-&gt;pBlobData;
</pre>
</td></tr></table>
</p>

<p>Because a DNS name space provider returns the host information in the form of a BLOB, you need to supply a sufficiently large buffer. That is why you use a buffer equal in size to a <i>WSAQUERYSET</i> structure, plus a <i>HOSTENT</i> structure, plus 2048 bytes for good measure. Again, if this were insufficient, the call would fail with <i>WSAEFAULT</i>. In a DNS query, all the host information is returned within the <i>HOSTENT</i> structure, even if a host name is associated with multiple IP addresses. That is why you don't need to call <i>WSALookupServiceNext</i> multiple times.</p>
<p>Now comes the tricky part&#8212;decoding the <i>BLOB</i> structure returned by the query. From <a href="ch06a.htm">Chapter 6</A>, you know the <i>HOSTENT</i> structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct hostent {
char FAR * h_name; 
char FAR * FAR * h_aliases; 
short h_addrtype; 
short h_length; 
char FAR * FAR * h_addr_list;
} HOSTENT;
</pre>
</td></tr></table>
</p>

<p>When the <i>HOSTENT</i> structure is returned as the BLOB data, the pointers within the structure are actually offsets into memory where the data actually lies. The offsets are from the start of the BLOB data. This requires you to fix up the pointers to reference the absolute memory location before you can actually access the data. Figure 10-2 shows the <i>HOSTENT</i> structure and memory layout returned. The DNS query is performed on the host name &quot;riven,&quot; which has a single IP address and no aliases. Each field in the structure has the offset value. In order to correct this so the fields reference the right location, you need to add the offset value to the address of the head of the <i>HOSTENT</i> structure. This needs to be performed on the <i>h_name</i>, <i>h_aliases</i>, and <i>h_addr_list</i> fields. Additionally, the <i>h_aliases</i> and <i>h_addr_list</i> fields are an array of pointers. Once you obtain the correct pointer to the array of pointers, each 32-bit field in the references location is made up of offsets. If you take a look at the <i>h_addr_list</i> field in Figure 10-2, you'll see that the initial offset is 16 bytes, which references the byte after the end of the <i>HOSTENT</i> structure. This is the array of pointers to the 4-byte IP address. However, the first pointer in the array is an offset of 28 bytes. To reference the correct location, take the address of the <i>HOSTENT</i> structure and add 28 bytes, which points to a 4-byte location with the data 0x9D36B9BA, which is the IP address 157.54.185.186. You then take the 4 bytes after the entry with the offset of 28 bytes, which is 0. This signifies the end of the array of pointers. If multiple IP addresses were associated with this host name, another offset would be present and you would fix the pointer exactly as in the first case. The same procedure is done to fix the <i>h_aliases</i> pointer and the array of pointers it references. In this example, there are no aliases for our host. The first entry in the array is 0, which indicates that you don't have to do any further work for that field. The last field is the <i>h_name</i> field, which is easy to correct; simply add the offset to the address of the <i>HOSTENT</i> structure, and it points to the start of a null-terminated string.</p>

<p>
<A HREF="javascript:fullSize('f10ji02x.htm')"> <img src="images/f10ji02.jpg" width=404 height=120 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 10-2. </b> HOSTENT <i>BLOB format </i><!-- /caption -->
</p>

<p>The code needed to fix these offsets into real addresses is simple, although quite a bit of pointer arithmetic is involved. To fix the <i>h_name</i> field, a simple offset adjustment such as the following will do:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
hostent-&gt;h_name = (PCHAR)((DWORD_PTR)hostent-&gt;h_name) + (PCHAR)hostent;
</pre>
</td></tr></table>
</p>

<p>To fix the array of pointers, as in the <i>h_aliases</i> and <i>h_addr_list</i> fields, requires a bit more code, but only to traverse the array and fix the references until a null entry is hit. The code looks like this:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
PCHAR  *addr;

if (hostent-&gt;h_aliases)
{
    addr = hostent-&gt;h_aliases = (PCHAR)((DWORD_PTR)hostent-&gt;h_aliases + 
(PCHAR)hostent);
   while (addr)
   {
        addr = (PCHAR)((DWORD_PTR)addr + (PCHAR *)hostent);
        addr++;
    }
}
</pre>
</td></tr></table>
</p>

<p>The code simply steps through each array entry and adds the starting address of the <i>HOSTENT</i> structure to the given offset, which becomes the value for that entry. Of course, once you hit an array entry whose value is 0, you stop. The same process needs to be applied to the <i>h_addr_list</i> field as well. Once the offsets are fixed, you can use the <i>HOSTENT</i> structure as you normally would.</p>

</BODY>
</HTML>




