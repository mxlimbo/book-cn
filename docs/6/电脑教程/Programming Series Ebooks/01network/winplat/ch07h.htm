<HTML>
<HEAD>
<TITLE>Other Address Families</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07g.htm" , "ch07i.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="169"><H1>Other Address Families</H1></A>

<p>All the Winsock API functions introduced in this chapter are protocol-independent. That is, the usage presented here can easily be applied to the other protocols supported by Win32 platforms. The following sections merely describe the sample client/server code for the other protocol families found on the companion CD-ROM.</p>

<A NAME="170"><H2>AppleTalk</H2></A>

<p>A single AppleTalk sample is provided to illustrate basic client/server techniques. The sample supports both the AppleTalk PAP and ADSP protocols. The PAP protocol is a message-oriented, connectionless, unreliable protocol similar to UDP, but with two notable exceptions. First it supports partial messages, which means that a call to <i>WSARecvEx</i> will possibly return with only part of a datagram message. You must check for the <i>MSG_PARTIAL</i> flag on return to see whether additional calls are required to obtain the full message. The second exception is that you must set a socket option specific to the PAP protocol before every read. The option, <i>SO_PRIME_READ</i>, which is used with the <i>setsockopt</i> function, is discussed in <a href="ch09a.htm">Chapter 9</A>. Take a look at the <i>Atalk.c</i> sample on the CD, which illustrates how to check for the <i>MSG_PARTIAL</i> flag and how to use the <i>SO_PRIME_READ</i> option.</p>

<p>The ADSP protocol is a connection-oriented, streaming, reliable protocol&#8212; much like TCP. The basic API calls for AppleTalk remain similar to the ones in the UDP and TCP examples presented in this chapter. The only differences will be specific to name resolution. Remember that for AppleTalk, you must bind to an empty address first before looking up or registering an AppleTalk name. This is discussed in more detail in the AppleTalk addressing section in <a href="ch06a.htm">Chapter 6</A>.</p>

<p>The AppleTalk protocol has one limitation. Support for AppleTalk originated in Winsock 1.1, and when Winsock 2 was developed, it appears that AppleTalk was not fully &quot;hooked&quot; into the new functions. Using any of the <i>WSASend</i> or <i>WSARecv</i> functions might result in flaky results, such as negative byte count returns. This problem is actually described in the Knowledge Base article Q164565. The only exception is <i>WSARecvEx</i>, which is simply a <i>recv</i> call except that the <i>flags</i> parameter is in/out and can be queried for the <i>MSG_PARTIAL</i> flag upon return.</p>

<A NAME="171"><H2>IrDA</H2></A>

<p>The infrared protocol is a recent addition that is available on Windows CE, Windows 98, and Windows 2000. It offers only one protocol type, which is a connection-oriented, streaming, reliable protocol. Again, the only major difference in the code is the name resolution, which is significantly different from name resolution in IP. You should be aware of one other difference: because Windows CE supports only the Winsock 1.1 specification, you can use only Winsock 1.1 functions on infrared sockets on a Windows CE platform. On Windows 98 and Windows 2000, you can also use the functions specific to Winsock 2. The sample code uses only Winsock 1.1 functions. Of course, on Windows 98 and Windows 2000 you must load the Winsock 2.2 library or greater, as the support for the <i>AF_IRDA</i> address family is not available in earlier versions.</p>

<p>The sample code for infrared sockets is found in the following files: <i>Ircommon.h</i>, <i>Ircommon.c</i>, <i>Irclient.c</i>, and <i>Irserver.c</i>. The first two files simply define two common functions, one for sending data and the other for receiving data, which are used by both the client and the server. The client side is detailed in <i>Irclient.c</i>, which is straightforward. First all devices in range are enumerated. Then a connection attempt is made to each one with the given service name. The first device to accept the connection request is taken. Subsequently the client sends data and reads it back. On the server side of the equation is the file <i>Irserver.c</i>. The server simply creates an infrared socket, binds the specified service name to the socket, and waits for client connections. For each client, a thread is spawned to receive data and send it back to the client.</p>

<p>Note that these examples are written with Windows 98 and Windows 2000 in mind. Like the TCP/IP samples, these examples require only slight modifications to run on Windows CE. Regarding Windows CE, the two main points are that there is no support for console applications, and all functions (other than Winsock) use UNICODE strings.</p>

<A NAME="172"><H2>NetBIOS</H2></A>

<p>We've presented several Winsock NetBIOS examples. As you learned in <a href="ch01a.htm">Chapter 1</A>, NetBIOS is capable of using several different transports, which is still the case with Winsock. In <a href="ch06a.htm">Chapter 6</A>, you learned how to enumerate the NetBIOS-capable transports and how to create sockets based on any one of these. Each protocol-to-adapter combination has two entries: one <i>SOCK_DGRAM</i> and one <i>SOCK_SEQPACKET</i> type. These correspond to connectionless datagram and stream sockets that are quite similar to UDP and TCP sockets. Besides name resolution, the NetBIOS Winsock interface is no different from what is presented earlier in this chapter. Remember that a well-written server should listen on all available LANAs and that the client should attempt to connect on all LANAs on its end.</p>

<p>The first examples on the CD are <i>Wsnbsvr.c</i> and <i>Wsnbclnt.c</i>. These examples use the <i>SOCK_SEQPACKET</i> socket type, which for all practical purposes appears to the programmer to be stream-oriented. The server creates a socket for each LANA, which is enumerated with the <i>WSAEnumProtocols</i> function, and binds it to the server's well-known name. Once a client connection is made, the server creates a thread to handle the connection. From there, the thread simply reads incoming data and echoes it back to the client. Similarly, the client attempts to connect on all LANAs. After the first connect succeeds, the other sockets are closed. The client then sends data to the server and the server reads it back.</p>

<p>The other example is <i>Wsnbdgs.c</i>, which is a datagram, or <i>SOCK_DGRAM</i>, example. This example includes the code for both sending and receiving datagram messages. This is a connectionless protocol, so the message sent to the server is sent on all available transports (since you really don't have any idea beforehand which transport or transports will be able to reach the server). Additionally, this example supports unique, group, and broadcast data (all discussed in <a href="ch01a.htm">Chapter 1</A>).</p>

<A NAME="173"><H2>IPX/SPX</H2></A>

<p>The IPX/SPX example, <i>Sockspx.c</i>, illustrates how to use the IPX protocol as well as stream and sequential packet SPXII. This single sample incorporates both the sender and the receiver for all three protocols. The particular protocol used is specified via the -p command line option. The sample is straightforward and easy to follow. The main function parses the command line arguments and then calls either the <i>Server</i> or the <i>Client</i> function. For the connection-oriented SPXII protocol, this means that the server binds the socket to the internal network address and waits for client connections while the client attempts to connect to the server that is specified on the command line. Once the connection is established, data is sent and received in the normal fashion.</p>

<p>For the connectionless IPX protocol, the example is even simpler. The server simply binds to the internal network and waits for incoming data by calling the <i>recvfrom</i> function. The client sends data to the recipient specified on the command line via the <i>sendto</i> function.</p>

<p>Two sections of the example might need a bit of explanation. First is the function <i>FillIpxAddress</i>, which is responsible for encoding an ASCII IPX address specified on the command line into a <i>SOCKADDR_IPX</i> structure. As you saw in <a href="ch06a.htm">Chapter 6</A>, IPX represents its addresses as hexadecimal strings, which means that each hexadecimal character in the address actually occupies 4 bits within the various address fields of the <i>SOCKADDR_IPX</i> structure. <i>FillIpxAddress</i> takes the IPX address and calls another function, <i>AtoH</i>, which actually performs the conversion.</p>

<p>The second function that needs explanation is <i>EnumerateAdapters,</i> which is executed if the -m flag is given on the command line. This function uses the socket option <i>IPX_MAX_ADAPTER_NUM</i> to find out how many local IPX addresses are available and then calls the <i>IPX_ADDRESS</i> socket option to obtain each address. These socket options and their parameters are discussed in <a href="ch09a.htm">Chapter 9</A>. We use these options because our example uses straight IPX addresses and does not perform any name resolution. <A HREF="ch10a.htm">Chapter 10</A> examines the name registration and name resolution that are possible for IPX.</p>

<A NAME="174"><H2>ATM</H2></A>

<p>The ATM protocol is accessible from Winsock on Windows 98 and Windows 2000. The ATM sample is contained in the files <i>Wsockatm.c</i>, <i>Support.c</i>, and <i>Support.h</i>. The latter two files simply contain support routines used by <i>Wsockatm.c</i>, such as local ATM address enumeration and ATM address encoding. ATM addresses are hexadecimal encoded, just like IPX addresses, and we use the same <i>AtoH</i> function. We also use the socket ioctl command <i>SIO_GET_NUMBER_OF_ATM_DEVICES</i> to get the number of local ATM interfaces and then use the ioctl command <i>SIO_GET_ATM_ADDRESS</i> to retrieve the actual address. These ioctl commands are covered in <a href="ch09a.htm">Chapter 9</A>.</p>

<p>Otherwise, both the client and server sides are implemented within <i>Wsockatm.c</i>. Because ATM supports only connection-oriented communication, the sample isn't very long and the majority of the code is given in the <i>main</i> function. The server will bind to an explicit local interface and wait for client connections, which are handled in the same thread as the listening socket. This means the server will only be able to service one client at a time. We designed the sample this way on purpose, to keep the code simple. On the other hand, the client calls <i>connect</i> with the server's ATM address. Once the connection is established, data is sent on the connection.</p>

<p>A few words of caution when using the ATM protocol: you will notice that after the <i>WSAAccept</i> call is made within the server, the address of the client is printed out. However, at the time the server receives the connection request, the client's address is not known. This is because the connection is not fully established when the <i>accept</i> function is triggered. This is also true on the client side. When the client makes a call to connect to the server, it will succeed even though the connection has not been fully established. This means that upon completion of a <i>connect</i> or an <i>accept</i> call, an attempt to send data immediately might silently fail until the connection is fully established. Unfortunately, there is no way for the application to determine at what point the connection becomes valid. Additionally, ATM supports only hard closes. That is, when the application calls <i>closesocket</i>, the connection is immediately terminated. For protocols that do not support graceful
close, any data pending on the socket at either end is normally discarded at the point <i>closesocket</i> is called. This is perfectly acceptable behavior; however, the ATM provider is nice to developers. When data is pending on the socket and one party has closed its socket, Winsock still returns the data queued for receiving on the socket.</p>

</BODY>
</HTML>




