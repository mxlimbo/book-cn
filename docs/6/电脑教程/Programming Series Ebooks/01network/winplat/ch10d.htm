<HTML>
<HEAD>
<TITLE>Registering a Service</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch10c.htm" , "ch10e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="314"><H1>Registering a Service</H1></A>

<p>The next step is to find out how to set up your own service and make it available and known to other machines on the network. This is known as registering an instance of your service with the name space provider so that it can either be advertised or queried by clients that want to communicate with it. Registering a service is actually a two-step process. The first step is to install a <i>service class</i> that describes the characteristics of your service.</p>

<p>It is important to distinguish between a service class and the actual service itself. For example, the service class describes which name spaces your service is to be registered with as well as certain characteristics about the service, such as whether it is connection-oriented or connectionless. The service class in no way describes how a client can establish a connection. Once the service class is registered, you register an actual instance of your service that references the correct service class to which it belongs. Once this occurs, a client can perform a query to find out where your service instance is running and therefore can attempt a communication.</p>

<A NAME="315"><H2>Installing a Service Class</H2></A>

<p>Before you register an instance of a service, you need to define the service class to which your service will belong. A service class defines what name spaces a service belonging to this class is registered with. The Winsock function that registers a service class is <i>WSAInstallServiceClass</i>, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
INT WSAInstallServiceClass (LPWSASERVICECLASSINFO lpServiceClassInfo);
</pre>
</td></tr></table>
</p>

<p>The single parameter <i>lpServiceClassInfo</i> points to a <i>WSASERVICECLASSINFO</i> structure that defines the attributes of this class. The structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _WSAServiceClassInfo {
    LPGUID              lpServiceClassId;
    LPTSTR              lpszServiceClassName;
    DWORD               dwCount;
    LPWSANSCLASSINFO    lpClassInfos;
} WSASERVICECLASSINFO, *PWSASERVICECLASSINFO, LPWSASERVICECLASSINFO;
</pre>
</td></tr></table>
</p>

<p>The first field is a GUID that uniquely identifies this particular service class. There are a couple ways to generate a GUID to use here. One way is to use the utility Uuidgen.exe and create a GUID for this service class. The problem with this method is that if you need to refer back to this GUID, you pretty much have to hardcode its value into a header file somewhere. This is where the second solution is useful. Within the header file Svcguid.h, several macros generate a GUID based on a simple attribute. For example, if you install a service class for SAP that will be used to advertise your IPX application, you can use the <i>SVCID_NETWARE</i> macro. The only parameter is the SAP ID number you assign to your &quot;class&quot; of applications. A number of SAP IDs are predefined in NetWare, such as 0x4 for file servers and 0x7 for a print server. Using this method, all you need is the easy-to-remember SAP ID to generate the GUID for the corresponding service class. Additionally, several macros exist that accept a port number as a parameter and return the GUID of the corresponding service. Take a look at the header file Svcguid.h, which contains other useful macros for the reverse operation&#8212;extracting the service port number from a GUID. Table 10-2 lists the most commonly used macros for generating GUIDs from simple protocol attributes such as port numbers or SAP IDs. The header file also contains constants for well-known port numbers for services such as FTP and Telnet.</p>

<p><b>Table 10-2.</b> <i>Common service ID macros</i></p>

<p>
<table cellpadding=5 width="95%">
<tr><th><i>Macro</i></th>
<th><i>Description</i></th></tr>
<tr><td valign="top"><i>SVCID_TCP(Port)</i></td>
<td valign="top">Generates a GUID from TCP port number</td></tr>
<tr><td valign="top"><i>SVCID_DNS(RecordType)</i></td>
<td valign="top">Generates a GUID from a DNS record type</td></tr>
<tr><td valign="top"><i>SVCID_UDP(Port)</i></td>
<td valign="top">Generates a GUID from UDP port number</td></tr>
<tr><td valign="top"><i>SVCID_NETWARE(SapId)</i></td>
<td valign="top">Generates a GUID from SAP ID number</td></tr>
</table></p>

<p>The second field of the <i>WSASERVICECLASSINFO</i> structure, <i>lpszServiceClassName</i>, is simply a string name for this particular service class. The last two fields are related. The <i>dwCount</i> field refers to the number of <i>WSANSCLASSINFO</i> structures passed in the <i>lpClassInfos</i> field. These structures define the name spaces and protocol characteristics that apply to the actual services that register under this service class. The structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _WSANSClassInfo {
    LPSTR   lpszName;
    DWORD   dwNameSpace;
    DWORD   dwValueType;
    DWORD   dwValueSize;
    LPVOID  lpValue;
}WSANSCLASSINFO, *PWSANSCLASSINFO, *LPWSANSCLASSINFO;
</pre>
</td></tr></table>
</p>

<p>The <i>lpszName</i> field defines the attribute that the service class possesses. Table 10-3 lists the various attributes available. Every attribute listed has a value type of <i>REG_DWORD</i>.</p>

<p><b>Table 10-3.</b> <i>Service types</i></p>

<p>
<table cellpadding=5 width="95%">
<tr><th><i>String Value</i></th>
<th><i>Constant Define</i></th>
<th><i>Name Space</i></th>
<th><i>Description</i></th></tr>
<tr><td valign="top">&quot;SapId&quot;</td>
<td valign="top"><i>SERVICE_TYPE_VALUE_SAPID</i></td>
<td valign="top"><i>NS_SAP</i></td>
<td valign="top">SAP ID</td></tr>
<tr><td valign="top">&quot;ConnectionOriented&quot;</td>
<td valign="top"><i>SERVICE_TYPE_VALUE_CONN</i></td>
<td valign="top">Any</td>
<td valign="top">Indicates whether service is connection-oriented or connectionless</td></tr>
<tr><td valign="top">&quot;TcpPort&quot;</td>
<td valign="top"><i>SERVICE_TYPE_VALUE_TCPPORT</i></td>
<td valign="top"><i>NS_DNS</i><br><i>NS_NTDS</i></td>
<td valign="top">TCP port</td></tr>
<tr><td valign="top">&quot;UdpPort&quot;</td>
<td valign="top"><i>SERVICE_TYPE_VALUE_UDPPORT</i></td>
<td valign="top"><i>NS_NTDS<br>NS_DNS</i></td>
<td valign="top">UDP port</td></tr>
</table></p>

<p>The <i>dwNameSpace</i> is the name space for which this attribute applies. Table 10-3 also lists the name spaces to which the various service types usually apply. The last three fields, <i>dwValueType</i>, <i>dwValueSize</i>, and <i>lpValue</i> all describe the actual value associated with the service type. The <i>dwValueType</i> field signifies the type of data associated with this entry and therefore can be one of the registry type values. For example, if the value is a <i>DWORD</i>, the value type is <i>REG_DWORD</i>. The next field, <i>dwValueSize</i>, is simply the size of the data passed as <i>lpValue,</i> which is a pointer to the data.</p>

<p>The following code example illustrates how to install a service class named &quot;Widget Server Class.&quot;</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
WSASERVICECLASSINFO    sci;
WSANSCLASSINFO        aNameSpaceClassInfo[4];
DWORD            dwSapId = 200,
                dwUdpPort = 5150,
                dwZero = 0;
int            ret;

memset(&amp;sci, 0, sizeof(sci));
    
SET_NETWARE_SVCID(&amp;sci.lpServiceClassId, dwSapId);
sci.lpszServiceClassName = (LPSTR)&quot;Widget Server Class&quot;;
sci.dwCount = 4;
sci.lpClassInfos = aNameSpaceClassInfo;

memset(aNameSpaceClassInfo, 0, sizeof(WSANSCLASSINFO) * 4);
// NTDS name space setup
aNameSpaceClassInfo[0].lpszName = SERVICE_TYPE_VALUE_CONN;
aNameSpaceClassInfo[0].dwNameSpace = NS_NTDS;
aNameSpaceClassInfo[0].dwValueType = REG_DWORD;
aNameSpaceClassInfo[0].dwValueSize = sizeof(DWORD);
aNameSpaceClassInfo[0].lpValue = &amp;dwZero;

aNameSpaceClassInfo[1].lpszName = SERVICE_TYPE_VALUE_UDPPORT;
aNameSpaceClassInfo[1].dwNameSpace = NS_NTDS;
aNameSpaceClassInfo[1].dwValueType = REG_DWORD;
aNameSpaceClassInfo[1].dwValueSize = sizeof(DWORD);
aNameSpaceClassInfo[1].lpValue = &amp;dwUdpPort;

// SAP name space setup
aNameSpaceClassInfo[2].lpszName = SERVICE_TYPE_VALUE_CONN;
aNameSpaceClassInfo[2].dwNameSpace = NS_SAP;
aNameSpaceClassInfo[2].dwValueType = REG_DWORD;
aNameSpaceClassInfo[2].dwValueSize = sizeof(DWORD);
aNameSpaceClassInfo[2].lpValue = &amp;dwZero;

aNameSpaceClassInfo[3].lpszName = SERVICE_TYPE_VALUE_SAPID;
aNameSpaceClassInfo[3].dwNameSpace = NS_SAP;
aNameSpaceClassInfo[3].dwValueType = REG_DWORD;
aNameSpaceClassInfo[3].dwValueSize = sizeof(DWORD);
aNameSpaceClassInfo[3].lpValue = &amp;dwSapId;

ret = WSAInstallServiceClass(&amp;sci);
if (ret == SOCKET_ERROR)
{
    printf(&quot;WSAInstallServiceClass() failed %d\n&quot;, WSAGetLastError());
}
</pre>
</td></tr></table>
</p>

<p>The first noticeable thing this example does is to pick a GUID that this class will be registered under. The services you are designing all belong to the class &quot;Widget Server Class&quot, and this service class describes the general attributes belonging to an instance of the service. In this example, we chose to register this class with the NetWare SAP ID of 200. This is only for convenience. We could have picked an arbitrary GUID or even the GUID based on the UDP port number. Additionally, the service can use the UDP protocol, in which case the clients are listening on port 5150.</p>

<p>The next step of note is setting the <i>dwCount</i> field of the <i>WSASERVICECLASSINFO</i> to 4. In this example, you will register this service class with both the SAP name space (<i>NS_SAP</i>) and the Windows NT domain space (<i>NS_NTDS</i>). The odd thing you'll notice is that we use four <i>WSANSCLASSINFO</i> structures, even though we are registering the service class with only two name spaces. This is because we define two attributes for each name space and each attribute requires a separate <i>WSANSCLASSINFO</i> structure. For each name space, we define whether the service will be connection-oriented. In this example, the name space is connectionless, as we set the value for <i>SERVICE_TYPE_VALUE_CONN</i> to be a Boolean 0. For the Windows NT domain space, we also set the UDP port number this service normally runs under by using the service type <i>SERVICE_TYPE_VALUE_UDPPORT</i>. For the SAP name space, we set the SAP ID of our service with service type <i>SERVICE_TYPE_VALUE_SAPID</i>.</p>

<p>For every <i>WSANSCLASSINFO</i> entry, you must set the name space identifier to which this service type applies, as well as the type and size of the value. Table 10-3 contains the types required for the service types, which all turn out to be <i>DWORD</i> in the example. The last step is simply to call <i>WSAInstallServiceClass</i> and pass the <i>WSASERVICECLASSINFO</i> structure as the parameter. If <i>WSAInstallServiceClass</i> is successful, the function returns 0; otherwise, it returns <i>SOCKET_ERROR</i>. If <i>WSASERVICECLASSINFO</i> is invalid or improperly formed, <i>WSAGetLastError</i> returns <i>WSAEINVAL</i>. If the service class already exists, <i>WSAGetLastError</i> returns <i>WSAEALREADY</i>. In this case, a service class can be removed by calling <i>WSARemoveServiceClass</i>, which is declared as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
INT WSARemoveServiceClass( LPGUID lpServiceClassId );
</pre>
</td></tr></table>
</p>

<p>This function's only parameter is a pointer to the GUID that defines the given service class.</p>

<A NAME="316"><H2>Service Registration</H2></A>

<p>Once you have a service class installed that describes the general attributes of your service, you can register an instance of your service so that it is available for lookup by other clients on remote machines. The Winsock function to register an instance of a service is <i>WSASetService</i>.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
INT WSASetService (
    LPWSAQUERYSET lpqsRegInfo,  
    WSAESETSERVICEOP essOperation,  
    DWORD dwControlFlags
);
</pre>
</td></tr></table>
</p>

<p>The first parameter, <i>lpqsRegInfo</i>, is a pointer to a <i>WSAQUERYSET</i> structure that defines the particular service. We'll discuss what goes in this structure shortly. The <i>essOperation</i> parameter specifies the action to take place, such as registration or deregistration. Table 10-4 describes the three valid flags.</p>

<p>The third parameter, <i>dwControlFlags</i>, is either 0 or the flag <i>SERVICE_MULTIPLE</i>. This flag is used if multiple addresses will be registered under the given service instance. For example, say you have a service that you want to run on five machines. The <i>WSAQUERYSET</i> structure passed into <i>WSASetService</i> would reference five <i>CSADDR_INFO</i> structures, each describing the location of one instance of the service. This requires the <i>SERVICE_MULTIPLE</i> flag to be set. Additionally, at some later point you can deregister a single instance of the service by using the <i>RNRSERVICE_DELETE</i> service flag. Table 10-5 gives the possible combinations of the operation and control flags and describes the result of the command, depending on whether the service already exists.</p>

<p><b>Table 10-4.</b> <i>Set service flags</i></p>

<p>
<table cellpadding=5 width="95%">
<tr><th><i>Operation Flag</i></th>
<th><i>Meaning</i></th></tr>
<tr><td valign="top"><i>RNRSERVICE_REGISTER</i></td>
<td valign="top">Register the service. For dynamic name providers, this means to begin actively advertising the service. For persistent name providers, this means updating the database. For static name providers, this does nothing.</td></tr>
<tr><td valign="top"><i>RNRSERVICE_DEREGISTER</i></td>
<td valign="top">Remove the entire service from the registry. For dynamic name providers, this means to stop advertising the service. For persistent name providers, this means removing the service from the database. For static name providers, this does nothing.</td></tr>
<tr><td valign="top"><i>RNRSERVICE_DELETE</i></td>
<td valign="top">Remove only the given instance of the service from the name space. A service might be registered that contains multiple instances (using the <i>SERVICE_MULTIPLE</i> flag upon registration), and this command removes only the given instance of the service (as defined by a <i>CSADDR_INFO</i> structure). Again, this applies only to dynamic and persistent name providers.</td></tr>
</table></p>

<p><b>Table 10-5.</b> WSASetService <i>flag combinations</i></p>

<p>
<table cellpadding=5 width="95%">
<tr><th colspan="3"><i>RNRSERVICE_REGISTER</i></th></tr>
<tr><th><i>Flags</i></th><th colspan="2"><i>Meaning</i></th></tr>
<tr><td valign="top">&nbsp;</td>
<td valign="top"><i>If the Service Already Exists</i></td>
<td valign="top"><i>If the Service Does Not Exist</i></td></tr>
<tr><td valign="top">none</td>
<td valign="top">Overwrite the existing service instance.</td>
<td valign="top">Add a new service entry on the given address.</td></tr>
<tr><td valign="top"><i>SERVICE_MULTIPLE</i></td>
<td valign="top">Update the service instance by adding the new addresses.</td>
<td valign="top">Add a new service entry on the given addresses.</td></tr>

<tr><th colspan="3"><i>RNRSERVICE_DEREGISTER</i></th></tr>
<tr><th><i>Flags</i></th><th colspan="2"><i>Meaning</i></th></tr>
<tr><td valign="top">&nbsp;</td>
<td valign="top"><i>If the Service Already Exists</i></td>
<td valign="top"><i>If the Service Does Not Exist</i></td></tr>
<tr><td valign="top">none</td>
<td valign="top">Remove all instances of the service, but do not remove the service. (Basically, <i>WSAQUERYSET</i> remains, but the number of <i>CSADDR_INFO</i> structures is 0.)</td>
<td valign="top">This is an error, and <i>WSASERVICE_NOT_FOUND</i> is returned.</td></tr>
<tr><td valign="top"><i>SERVICE_MULTIPLE</i></td>
<td valign="top">Update the service by removing the given addresses. The service remains registered, even if no addresses remain.</td>
<td valign="top">This is an error, and <i>WSASERVICE_NOT_FOUND</i> is returned.</td></tr>

<tr><th colspan="3"><i>RNRSERVICE_DELETE</i></th></tr>
<tr><th><i>Flags</i></th><th colspan="2"><i>Meaning</i></th></tr>
<tr><td valign="top">&nbsp;</td>
<td valign="top"><i>If the Service Already Exists</i></td>
<td valign="top"><i>If the Service Does Not Exist</i></td></tr>
<tr><td valign="top">none</td>
<td valign="top">The service is removed completely from the name space.</td>
<td valign="top">This is an error, and <i>WSASERVICE_NOT_FOUND</i> is returned.</td></tr>
<tr><td valign="top"><i>SERVICE_MULTIPLE</i></td>
<td valign="top">Update the service by removing the given addresses. If no addresses remain, the service is completely removed from the name space.</td>
<td valign="top">This is an error, and <i>WSASERVICE_NOT_FOUND</i> is returned.</td></tr>
</table></p>

<p>Now that you have an understanding of what <i>WSASetService</i> does, let's take a look at the <i>WSAQUERYSET</i> structure that needs to be filled out and passed into the function. This structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _WSAQuerySetW {
    DWORD           dwSize;
    LPTSTR          lpszServiceInstanceName;
    LPGUID          lpServiceClassId;
    LPWSAVERSION    lpVersion;
    LPTSTR          lpszComment;
    DWORD           dwNameSpace;
    LPGUID          lpNSProviderId;
    LPTSTR          lpszContext;
    DWORD           dwNumberOfProtocols;
    LPAFPROTOCOLS   lpafpProtocols;
    LPTSTR          lpszQueryString;
    DWORD           dwNumberOfCsAddrs;
    LPCSADDR_INFO   lpcsaBuffer;
    DWORD           dwOutputFlags;
    LPBLOB          lpBlob;
} WSAQUERYSETW, *PWSAQUERYSETW, *LPWSAQUERYSETW;
</pre>
</td></tr></table>
</p>

<p>The <i>dwSize</i> field should be set to the size of the <i>WSAQUERYSET</i> structure. The <i>lpszServiceInstanceName</i> field contains a string identifier naming this instance of the server. The <i>lpServiceClassId</i> field is the GUID for the service class to which this service instance belongs. The <i>lpVersion</i> field is optional. You can use it to supply version information that could be useful when a client queries for a service. The <i>lpszComment</i> field is also optional. You can specify any kind of comment string here. The <i>dwNameSpace</i> field specifies the name spaces to register your service with. If you're using only a single name space, use only that value; otherwise, use <i>NS_ALL</i>. It is possible to reference a custom name space provider. (Writing your own name space is discussed in <A HREF="ch14a.htm">Chapter 14</A>.) For a custom name space provider, the <i>dwNameSpace</i> field is set to 0 and <i>lpNSProviderId</i> specifies the GUID representing the custom provider. The <i>lpszContext</i> field specifies the starting point of the query in a hierarchical name space such as NDS.</p>

<p>The <i>dwNumberOfProtocols</i> and <i>lpafpProtocols</i> fields are optional parameters used to narrow the search to return only the supplied protocols. The <i>dwNumberOfProtocols</i> field references the number of <i>AFPROTOCOLS</i> structures contained in the <i>lpafpProtocols</i> array. The structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _AFPROTOCOLS {
    INT iAddressFamily;
    INT iProtocol;
} AFPROTOCOLS, *PAFPROTOCOLS, *LPAFPROTOCOLS;
</pre>
</td></tr></table>
</p>

<p>The first field, <i>iAddressFamily</i>, is the address family constant, such as <i>AF_INET</i> or <i>AF_IPX</i>. The second field, <i>iProtocol</i>, is the protocol from the given address family, such as <i>IPPROTO_TCP</i> or <i>NSPROTO_IPX</i>.</p>

<p>The next field in the <i>WSAQUERYSET</i> structure, <i>lpszQueryString</i>, is optional and used only by name spaces supporting enriched Structured Query Language (SQL) queries such as Whois++. This parameter is used to specify that string.</p>

<p>The next two fields are the most important when registering a service. The <i>dwNumberOfCsAddrs</i> field simply provides the number of <i>CSADDR_INFO</i> structures passed in <i>lpcsaBuffer</i>. The <i>CSADDR_INFO</i> structure defines the address family and the actual address at which the service is located. If multiple structures are present, multiple instances of the service are available. The structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _CSADDR_INFO { 
    SOCKET_ADDRESS LocalAddr; 
    SOCKET_ADDRESS RemoteAddr; 
    INT            iSocketType; 
    INT            iProtocol; 
} CSADDR_INFO;

typedef struct _SOCKET_ADDRESS {
    LPSOCKADDR lpSockaddr;
    INT        iSockaddrLength;
} SOCKET_ADDRESS, *PSOCKET_ADDRESS, FAR * LPSOCKET_ADDRESS;
</pre>
</td></tr></table>
</p>

<p>Additionally, the definition of <i>SOCKET_ADDRESS</i> is included. When registering a service, you can specify the local and remote addresses. The local address field (<i>LocalAddr</i>) is used to specify the address that an instance of this service should bind to, while the remote address field (<i>RemoteAddr</i>) is the address a client should use in a <i>connect</i> or a <i>sendto</i> call. The other two fields, <i>iSocketType</i> and <i>iProtocol</i>, specify the socket type (for example, <i>SOCK_STREAM</i>, <i>SOCK_DGRAM</i>) and the protocol family (for example, <i>AF_INET</i>, <i>AF_IPX</i>) for the given addresses.</p>

<p>The last two fields of the <i>WSAQUERYSET</i> structure are <i>dwOutputFlags</i> and <i>lpBlob</i>. These two fields are generally not needed for service registration; they are more useful when querying for a service instance (covered in the next section). Only the name space provider can return a <i>BLOB</i> structure. That is, when registering a service you cannot add your own <i>BLOB</i> structure to be returned in client queries.</p>

<p>Table 10-6 lists the fields of the <i>WSAQUERYSET</i> structure and identifies which are required or optional depending on whether a query or a registration is being performed.</p>

<A NAME="317"><H3>Service registration example</H3></A>

<p>In this section, we'll show you how to register your own service under both the SAP and NTDS name spaces. The Windows NT domain space is quite powerful, which is why we want to include it in our example. However, be aware of the following features. First the Windows NT domain space requires Windows 2000 since it is based on the Active Directory. This also means that the Windows 2000 workstation on which you hope to register and/or look up services must have a machine account in that domain in order to access the Active Directory. The other feature to note is that the Windows NT domain space is capable of registering socket addresses from any protocol family. This means that your IP and IPX services can all be registered in the same name space. It also means that there is a dynamic way of adding and removing IPbased services. Figure 10-1 illustrates the basic steps required to register an instance of a service. For the sake of simplicity, no error checking is performed.</p>

<p><b>Table 10-6.</b> WSAQUERYSET <i>fields</i></p>

<p>
<table cellpadding=5 width="95%">
<tr><th><i>Field</i></th>
<th><i>Query</i></th>
<th><i>Registration</i></th></tr>
<tr><td valign="top"><i>dwSize</i></td>
<td valign="top">Required</td>
<td valign="top">Required</td></tr>
<tr><td valign="top"><i>lpszServiceInstanceName</i></td>
<td valign="top">String or &quot;*&quot; required</td>
<td valign="top">Required</td></tr>
<tr><td valign="top"><i>lpServiceClassId</i></td>
<td valign="top">Required</td>
<td valign="top">Required</td></tr>
<tr><td valign="top"><i>lpVersion</i></td>
<td valign="top">Optional</td>
<td valign="top">Optional</td></tr>
<tr><td valign="top"><i>lpszComment</i></td>
<td valign="top">Ignored</td>
<td valign="top">Optional</td></tr>
<tr><td valign="top"><i>dwNameSpace</i><br><i>lpNSProviderId</i></td>
<td valign="top">One of these two fields must be specified</td>
<td valign="top">One of these two fields must be specified</td></tr>
<tr><td valign="top"><i>lpszContext</i></td>
<td valign="top">Optional</td>
<td valign="top">Optional</td></tr>
<tr><td valign="top"><i>dwNumberOfProtocols</i></td>
<td valign="top">Zero or more</td>
<td valign="top">Zero or more</td></tr>
<tr><td valign="top"><i>lpafpProtocols</i></td>
<td valign="top">Optional</td>
<td valign="top">Optional</td></tr>
<tr><td valign="top"><i>lpszQueryString</i></td>
<td valign="top">Optional</td>
<td valign="top">Ignored</td></tr>
<tr><td valign="top"><i>dwNumberOfCsAddrs</i></td>
<td valign="top">Ignored</td>
<td valign="top">Required</td></tr>
<tr><td valign="top"><i>lpcsaBuffer</i></td>
<td valign="top">Ignored</td>
<td valign="top">Required</td></tr>
<tr><td valign="top"><i>dwOutputFlags</i></td>
<td valign="top">Ignored</td>
<td valign="top">Optional</td></tr>
<tr><td valign="top"><i>lpBlob</i></td>
<td valign="top">Ignored, can be returned by the query</td>
<td valign="top">Ignored</td></tr>
</table></p>

<p><b>Figure 10-1.</b> <i>The WSASetService example</i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SOCKET             socks[2];
WSAQUERYSET        qs;
CSADDR_INFO        lpCSAddr[2];
SOCKADDR_IN        sa_in;
SOCKADDR_IPX       sa_ipx;
IPX_ADDRESS_DATA   ipx_data;
GUID               guid = SVCID_NETWARE(200);
int                ret, cb;

memset(&amp;qs, 0, sizeof(WSAQUERYSET));
qs.dwSize = sizeof(WSAQUERYSET);
qs.lpszServiceInstanceName = (LPSTR)&quot;Widget Server&quot;;
qs.lpServiceClassId = &amp;guid;
qs.dwNameSpace = NS_ALL;
qs.lpNSProviderId = NULL;
qs.lpcsaBuffer = lpCSAddr;
qs.lpBlob = NULL;
//
// Set the IP address of our service
//
memset(&amp;sa_in, 0, sizeof(sa_in));
sa_in.sin_family = AF_INET;
sa_in.sin_addr.s_addr =  htonl(INADDR_ANY);
sa_in.sin_port = 5150;

socks[0] = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
ret = bind(socks[0], (SOCKADDR *)&amp;sa_in, sizeof(sa_in));

cb = sizeof(sa_in);
getsockname(socks[0], (SOCKADDR *)&amp;sa_in, &amp;cb);
        
lpCSAddr[0].iSocketType = SOCK_DGRAM;
lpCSAddr[0].iProtocol = IPPROTO_UDP;
lpCSAddr[0].LocalAddr.lpSockaddr = (SOCKADDR *)&amp;sa_in; 
lpCSAddr[0].LocalAddr.iSockaddrLength = sizeof(sa_in);
lpCSAddr[0].RemoteAddr.lpSockaddr = (SOCKADDR *)&amp;sa_in;
lpCSAddr[0].RemoteAddr.iSockaddrLength = sizeof(sa_in);
//
// Set up the IPX address for our service
//            
memset(sa_ipx.sa_netnum, 0, sizeof(sa_ipx.sa_netnum));
memset(sa_ipx.sa_nodenum, 0, sizeof(sa_ipx.sa_nodenum));
sa_ipx.sa_family = AF_IPX;
sa_ipx.sa_socket = 0;

socks[1] = socket(AF_IPX, SOCK_DGRAM, NSPROTO_IPX);

ret = bind(socks[1], (SOCKADDR *)&amp;sa_ipx, sizeof(sa_ipx));

cb = sizeof(IPX_ADDRESS_DATA);
memset (&amp;ipx_data, 0, cb);
ipx_data.adapternum = 0;

ret = getsockopt(socks[1], NSPROTO_IPX, IPX_ADDRESS, 
    (char *)&amp;ipx_data, &amp;cb);

cb = sizeof(SOCKADDR_IPX);
getsockname(socks[1], (SOCKADDR *)sa_ipx, &amp;cb);

memcpy(sa_ipx.sa_netnum, ipx_data.netnum, sizeof(sa_ipx.sa_netnum));
memcpy(sa_ipx.sa_nodenum, ipx_data.nodenum, sizeof(sa_ipx.sa_nodenum));

lpCSAddr[1].iSocketType = SOCK_DGRAM;
lpCSAddr[1].iProtocol = NSPROTO_IPX;
lpCSAddr[1].LocalAddr.lpSockaddr = (struct sockaddr *)&amp;sa_ipx; 
lpCSAddr[1].LocalAddr.iSockaddrLength = sizeof(sa_ipx);
lpCSAddr[1].RemoteAddr.lpSockaddr = (struct sockaddr *)&amp;sa_ipx;
lpCSAddr[1].RemoteAddr.iSockaddrLength = sizeof(sa_ipx);
            
qs.dwNumberOfCsAddrs = 2;
    
ret = WSASetService(&amp;qs, RNRSERVICE_REGISTER, 0L);
</pre>
</td></tr></table>
</p>

<p>The example code in Figure 10-1 illustrates how to set an instance of a service so that a client of that service can find out the address that it requires to communicate with the service. The first order of business is to initialize the <i>WSAQUERYSET</i> structure. We also need to give a name to the instance of our service. In this case, we simply call it &quot;Widget Server.&quot; The other critical step is to use the same GUID we used to register our service class. Whenever you register an instance of a service, that service must belong to a service class. In this case, we use the &quot;Widget Service Class&quot; (defined in the previous section), whose GUID is <i>SVCID_NETWARE(200)</i>. The next step is to set the name spaces in which we are interested. Since our service runs over both IPX and UDP, we specify <i>NS_ALL</i>. Because we're specifying a preexisting name space, <i>lpNSProviderId</i> must be set to <i>NULL</i>.</p>

<p>The next step is to set up the <i>SOCKADDR</i> structures within the <i>CSADDR_INFO</i> array that <i>WSASetService</i> passes as the <i>lpcsaBuffer</i> field of the <i>WSAQUERYSET</i> structure. You'll notice that in our example we actually create the sockets and bind them to a local address before we set up the <i>SOCKADDR</i> structure. This is because we need to find the exact local address to which clients need to connect. For example, when creating our UDP socket for the server, we bind to <i>INADDR_ANY</i>, which doesn't give us the actual IP address until we call <i>getsockname</i>. Using the information returned from <i>getsockname</i>, we can build a <i>SOCKADDR_IN</i> structure. Within the <i>CSADDR_INFO</i> structure, we set the socket type and the protocol. The other two fields are the local and remote address information. The local address is the address that a server should bind to, while the remote address is the address that a client should use to connect to the service.</p>

<p>After setting up the <i>SOCKADDR_IN</i> structure for our UDP-based server, we set up the IPX-based service. In <a href="ch06a.htm">Chapter 6</A>, you saw that servers should bind to the internal network number by setting the network and node number to 0. Again, this doesn't give you the address that clients need, so call the socket option <i>IPX_ADDRESS</i> to obtain the actual address. In filling the <i>CSADDR_INFO</i> structure for IPX, use <i>SOCK_DGRAM</i> and <i>NSPROTO_IPX</i> for the socket type and the protocol, respectively. The last step is to set the <i>dwNumberOfCsAddrs</i> field in the <i>WSAQUERYSET</i> structure to 2, as there are two addresses&#8212;UDP and IPX&#8212;that clients can use to establish a connection. Finally, call <i>WSASetService</i> with our <i>WSAQUERYSET</i> structure, the <i>RNRSERVICE_REGISTER</i> flag, and no control flags. You do not specify the <i>SERVICE_MULTIPLE</i> control flag so that if you choose to deregister our service, all instances of the service (both the IPX and UDP addresses)
will be deregistered.</p>

<p>There is one consideration that the above example does not take into account: multihomed machines. If you create a UDP-based server that binds to <i>INADDR_ANY</i> on a multihomed machine, the client can connect to the server on any of the available interfaces. In the case of IP, <i>getsockname</i> is not sufficient; you must obtain all local IP interfaces. There are a number of methods of obtaining this information, depending on the platform you are on. One method common to all platforms is calling <i>gethostbyname</i> to return a list of IP addresses for our name. Under Winsock 2, you can also call the ioctl command <i>SIO_GET_INTERFACE_LIST</i>. For Windows 2000, the ioctl <i>SIO_ADDRESS_LIST_QUERY</i> is available. Finally, the IP helper functions discussed in Appendix B can be used as well. Simple TCP/IP name resolution and <i>gethostbyname</i> are presented in <a href="ch06a.htm">Chapter 6</A>, while ioctl commands are found in <a href="ch09a.htm">Chapter 9</A>. In addition, Rnrcs.c (on the companion CD) is a full-fledged example that addresses multihomed machines.</p>

</BODY>
</HTML>




