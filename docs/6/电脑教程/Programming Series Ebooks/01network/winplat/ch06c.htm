<HTML>
<HEAD>
<TITLE>Infrared Sockets</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06b.htm" , "ch06d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="107"><H1>Infrared Sockets</H1></A>

<p>Infrared sockets, or IrSock, are an exciting new technology first introduced on the Windows CE platform. Infrared sockets allow two PCs to communicate with each other through an infrared serial port. Infrared sockets are now available on Windows 98 and Windows 2000. Infrared sockets differ from traditional sockets in that infrared sockets are designed to take into account the transient nature of portable computing. Infrared sockets present a new name resolution model that will be discussed in the next section.</p>

<A NAME="108"><H2>Addressing</H2></A>

<p>Because most computers with Infrared Data Association (IrDA) devices are likely to move around, traditional name-resolution schemes don't work well. Conventional resolution methods assume static resources such as name servers, which cannot be used when a person is moving a handheld PC or laptop computer running a network client. To circumvent this problem, IrSock is designed to browse in-range resources in an ad hoc manner without the overhead of a large network, and it doesn't use standard Winsock name service functions or even IP addressing. Instead, the name service has been incorporated into the communication stream, and a new address family has been introduced to support services bound to infrared serial ports. The IrSock address structure includes a service name that describes the application used in bind and connect calls, and a device identifier that describes the device on which the service runs. This pair is analogous to the IP address and port number tuple used by conventional TCP/IP sockets. The IrSock address structure is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct sockaddr_irda {
    u_short    irdaAddressFamily;
    u_char     irdaDeviceID[4];
    char       irdaServiceName[25];
} SOCKADDR_IRDA;
</pre>
</td></tr></table>
</p>

<p>The <i>irdaAddressFamily</i> field is always set to <i>AF_IRDA</i>. The <i>irdaDeviceID</i> is a four-character string that uniquely identifies the device on which a particular service is running. This field is ignored when an IrSock server is created. However, the field is significant for a client because it specifies the IrDA device to connect to. (There can be multiple devices in range.) Finally, the <i>irdaServiceName</i> field is the name of the service that the application either will register itself with or is trying to connect to.</p>

<A NAME="109"><H2>Name Resolution</H2></A>

<p>Addressing can be based on IrDA Logical Service Access Point Selectors (LSAP-SELs) or on services registered with the Information Access Services (IAS). The IAS abstracts a service from an LSAP-SEL into a user-friendly text service name, in much the same way that an Internet domain name server maps names to numeric IP addresses. You can use either an LSAP-SEL or a user-friendly name to successfully connect, but user-friendly names require name resolution. For the most part, you shouldn't use the direct LSAP-SEL &quot;address&quot; because the address space for IrDA services is limited. The Win32 implementation allows LSAP-SEL integer identifiers in the range of 1 to 127. Essentially an IAS server can be thought of as a WINS server because it associates an LSAP-SEL with a textual service name.</p>

<p>An actual IAS entry has three fields of importance: class name, attribute, and attribute value. For example, let's say a server wishes to register itself under the service name <i>MyServer</i>. This is accomplished when the server issues the bind call with the appropriate <i>SOCKADDR</i>_<i>IRDA</i> structure. Once this occurs, an IAS entry is added with the class name <i>MyServer</i>, the attribute IrDA:TinyTP:LsapSel, and an attribute value of, say, 3. The attribute value is the next unused LSAP-SEL assigned by the system upon registration. The client, on the other hand, passes in a <i>SOCKADDR</i>_<i>IRDA</i> structure to the connect call. This initiates an IAS lookup for a service with the class name <i>MyServer</i> and the attribute IrDA:TinyTP:LsapSel. The IAS query will return the value 3. You can formulate your own IAS query by using the socket option <i>IRLMP_IAS_QUERY</i> in the <i>getsockopt</i> call.</p>

<p>If you want to bypass IAS altogether (which is not recommended), you can specify an LSAP-SEL address directly for a server name or an endpoint to which a client wants to connect. You should bypass IAS only to communicate with legacy IrDA devices that don't provide any kind of IAS registration (such as infrared-capable printers). You can bypass the IAS registration and lookup by specifying the service name in the <i>SOCKADDR_IRDA</i> structure as LSAP-SEL-<i>xxx</i>, where <i>xxx</i> is the attribute value between 1 and 127. For a server, this would directly assign the server to the given LSAP-SEL address (assuming the LSAP-SEL address is unused). For a client, this bypasses the IAS lookup and causes an immediate attempt to connect to whatever service is running on that LSAP-SEL.</p>

<A NAME="110"><H2>Enumerating IrDA Devices</H2></A>

<p>Because infrared devices move in and out of range, a method of dynamically listing all available infrared devices within range is necessary. This section describes how to accomplish that. Let's begin with a few platform discrepancies between the Windows CE implementation and the Windows 98 and Windows 2000 implementation. Windows CE supported IrSock before the other platforms and provided minimal information about infrared devices. Later, Windows 98 and Windows 2000 provided support for IrSock, but they added additional &quot;hint&quot; information returned by the enumeration request. (This hint information will be discussed shortly.) As a result, the Af_irda.h header file for Windows CE contains the original, minimal structure definitions; however, the new header file for the other platforms contains conditional structure definitions for each platform that now supports IrSock. We recommend that you use the later Af_irda.h header file for consistency.</p>

<p>The way to enumerate nearby infrared devices is by the <i>IRLMP_ENUM_DEVICES</i> command for <i>getsockopt</i>. A <i>DEVICELIST</i> structure is passed as the <i>optval</i> parameter. There are two structures, one for Windows 98 and Windows 2000 and one for Windows CE. They are defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _WINDOWS_DEVICELIST
{
    ULONG                       numDevice;
    WINDOWS_IRDA_DEVICE_INFO    Device[1];
} WINDOWS_DEVICELIST, *PWINDOWS_DEVICELIST, FAR *LPWINDOWS_DEVICELIST;

typedef struct _WCE_DEVICELIST
{
    ULONG                       numDevice;
    WCE_IRDA_DEVICE_INFO        Device[1];
} WCE_DEVICELIST, *PWCE_DEVICELIST;
</pre>
</td></tr></table>
</p>

<p>The only difference between the Windows 98 and Window 2000 structure and the Windows CE structure is that 
the Windows 98 and Windows 2000 structure contains an array of <i>WINDOWS_IRDA_DEVICE_INFO</i> structures as 
opposed to an array of <i>WCE_IRDA_DEVICE_INFO</i> structures. A conditional <i>#define</i> directive declares <i>DEVICELIST</i> as the appropriate structure depending 
on the target platform. Likewise, two declarations for the <i>IRDA_DEVICE_INFO</i> structures exist:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _WINDOWS_IRDA_DEVICE_INFO
{
    u_char  irdaDeviceID[4];
    char    irdaDeviceName[22];
    u_char  irdaDeviceHints1;
    u_char  irdaDeviceHints2;
    u_char  irdaCharSet;
} WINDOWS_IRDA_DEVICE_INFO, *PWINDOWS_IRDA_DEVICE_INFO, 
  FAR *LPWINDOWS_IRDA_DEVICE_INFO;

typedef struct _WCE_IRDA_DEVICE_INFO
{
    u_char  irdaDeviceID[4];
    char    irdaDeviceName[22];
    u_char  Reserved[2];
} WCE_IRDA_DEVICE_INFO, *PWCE_IRDA_DEVICE_INFO;
</pre>
</td></tr></table>
</p>

<p>Again, a conditional <i>#define</i> directive declares <i>IRDA_DEVICE_INFO</i> to the correct structure definition depending on the target platform.</p>

<p>As mentioned earlier, the function to use for the actual enumeration of infrared devices is <i>getsockopt</i> with the option <i>IRLMP_ENUM_DEVICES</i>. The following piece of code lists the device IDs of all infrared devices nearby.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
SOCKET      sock;
DEVICELIST  devList;
DWORD       dwListLen=sizeof(DEVICELIST);

sock = WSASocket(AF_IRDA, SOCK_STREAM, 0, NULL, 0, 
    WSA_FLAG_OVERLAPPED);
...
devList.numDevice = 0;
dwRet = getsockopt(sock, SOL_IRLMP, IRLMP_ENUMDEVICES, 
    (char *)&amp;devList, &amp;dwListLen);
</pre>
</td></tr></table>
</p>

<p>Before you pass a <i>DEVICELIST</i> structure into the <i>getsockopt</i> call, don't forget to set the <i>numDevice</i> field to 0. A successful enumeration will set the <i>numDevice</i> field to a value greater than 0 and set an equal number of <i>IRDA_DEVICE_INFO</i> structures in the <i>Device</i> field. Also, in an actual application you probably want to perform <i>getsockopt</i> more than once in order to check for devices that just moved into range. For example, attempting to discover an infrared device in five tries or less is a good heuristic. Simply place the call in a loop with a short call to the <i>Sleep</i> function after each unsuccessful enumeration.</p>

<p>Now that you know how to enumerate infrared devices, creating a client or a server is simple. The server side of the equation is a bit simpler because it looks like a &quot;normal&quot; server. That is, no extra steps are required. The general steps for an IrSock server are</p>

<ol>
<p><li> Create a socket of address family <i>AF_IRDA</i> and socket type <i>SOCK_STREAM</i>.</li></p>

<p><li> Fill out a <i>SOCKADDR_IRDA</i> structure with the service name of the server.</li></p>

<p><li> Call <i>bind</i> with the socket handle and the <i>SOCKADDR_IRDA</i> structure.</li></p>

<p><li> Call <i>listen</i> with the socket handle and the backlog limit.</li></p>

<p><li> Block on an <i>accept</i> call for incoming clients.</li></p>
</ol>

<p>The steps for a client are a bit more involved, as you must enumerate infrared devices. The following steps are necessary for an IrSock client:</p>
<ol>
<p><li> Create a socket of address family <i>AF_IRDA</i> and socket type <i>SOCK_STREAM</i>.</li></p>

<p><li> Enumerate available infrared devices by calling <i>getsockopt</i> with the <i>IRLMP_ENUM_DEVICES</i> option.</li></p>

<p><li> For each device returned, fill out a <i>SOCKADDR_IRDA</i> structure with the device ID returned and the service name you want to connect to.</li></p>

<p><li> Call the <i>connect</i> function with the socket handle and the <i>SOCKADDR_IRDA</i> structure. Do this for each structure filled out in step 3 until a connect succeeds.</li></p>
</ol>

<A NAME="111"><H2>Querying IAS</H2></A>

<p>There are two ways to find out whether a given service is running on a particular device. The first method is to actually attempt a connection to the service; the other is to query IAS for the given service name. Both methods require you to enumerate all infrared devices, and attempt a query (or connection) with each device until one of them succeeds or you have exhausted every device. Perform a query by calling <i>getsockopt</i> with the <i>IRLMP_IAS_QUERY</i> option. A pointer to an <i>IAS_QUERY</i> structure is passed as the <i>optval</i> parameter. Again, there are two <i>IAS_QUERY</i> structures, one for Windows 98 and Windows 2000, and another for Windows CE. Here are the definitions of each structure:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _WINDOWS_IAS_QUERY
{
     u_char    irdaDeviceID[4];
     char      irdaClassName[IAS_MAX_CLASSNAME];
     char      irdaAttribName[IAS_MAX_ATTRIBNAME];
     u_long    irdaAttribType;
     union
    {
        LONG   irdaAttribInt;
        struct
        {
            u_long   Len;
            u_char   OctetSeq[IAS_MAX_OCTET_STRING];
        } irdaAttribOctetSeq;
        struct
        {
            u_long   Len;
            u_long   CharSet;
            u_char   UsrStr[IAS_MAX_USER_STRING];
        } irdaAttribUsrStr;
    } irdaAttribute;
} WINDOWS_IAS_QUERY, *PWINDOWS_IAS_QUERY, 
  FAR *LPWINDOWS_IAS_QUERY;

typedef struct _WCE_IAS_QUERY
{
    u_char     irdaDeviceID[4];
    char       irdaClassName[61];
    char       irdaAttribName[61];
    u_short    irdaAttribType;
    union
    {
        int    irdaAttribInt;
        struct
        {
            int      Len;
            u_char   OctetSeq[1];
            u_char   Reserved[3];
        } irdaAttribOctetSeq;
        struct
        {
            int      Len;
            u_char   CharSet;
            u_char   UsrStr[1];
            u_char   Reserved[2];
        } irdaAttribUsrStr;
    } irdaAttribute;
} WCE_IAS_QUERY, *PWCE_IAS_QUERY;
</pre>
</td></tr></table>
</p>

<p>As you can see, the two structure definitions are similar except for the lengths of certain character arrays.</p>

<p>Performing a query for the LSAP-SEL number of a particular service is simple: set the <i>irdaClassName</i> field to the property string for <i>LSAP-SELs</i>, which is &quot;IrDA:IrLMP:LsapSel&quot;, and set the <i>irdaAttributeName</i> field to the service name you want to query for. Additionally, you have to set the <i>irdaDeviceID</i> field with a valid device within range.</p>

<A NAME="112"><H2>Creating a Socket</H2></A>

<p>Creating an infrared socket is simple. Few options are required because IrSock supports only connection-oriented streams. The following code illustrates how to create an infrared socket using either the <i>socket</i> or the <i>WSASocket</i> call. You must use <i>socket</i> for Windows CE because of its Winsock 1.1 limitation.</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
s = socket(AF_IRDA, SOCK_STREAM, 0);

s = WSASocket(AF_IRDA, SOCK_STREAM, 0, NULL, 0,
    WSA_FLAG_OVERLAPPED);
</pre>
</td></tr></table>
</p>

<p>If you want to be specific, you can pass <i>IRDA_PROTO_SOCK_STREAM</i> as the protocol parameter of either function. However, the protocol parameter isn't required because the transport catalog has only one entry of address family <i>AF_IRDA.</i> Specifying <i>AF_IRDA</i> causes that transport entry to be used by default.</p>

<A NAME="113"><H2>Socket Options</H2></A>

<p>Many <i>SO_</i> socket options aren't meaningful to IrDA. Only <i>SO_LINGER</i> is specifically supported. The IrSock-specific socket options are of course supported only on sockets of the address family <i>AF_IRDA</i>. These options are also covered in <a href="ch09a.htm">Chapter 9</A>, which summarizes all socket options and their parameters.</p>

</BODY>
</HTML>




