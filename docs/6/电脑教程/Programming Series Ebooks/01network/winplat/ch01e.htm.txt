<HTML>
<HEAD>
<TITLE>Datagram Operations</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch01d.htm" , "ch01f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="16"><H1>Datagram Operations</H1></A>

<p>Datagrams are connectionless methods of communication. A sender merely addresses each packet with its destination NetBIOS name and sends it on its way. No checking is performed to ensure data integrity, order of arrival, or reliability.</p>

<p>There are three ways to send a datagram. The first is to direct the datagram at a specific (unique or group) name. This means that only one process can receive that datagram&#8212;the process that registered the destination name. The second method is to send a datagram to a group name. Only those processes that registered the given group name will be able to receive the message. Finally, the third way to send a datagram is to broadcast it to the entire network. Any process on any workstation on the local area network can receive the datagram. Sending a datagram to either a unique or a group name uses the <i>NCBDGSEND</i> command, while broadcasts use the <i>NCBDGSENDBC</i> command.</p>

<p>Using any of the datagram send commands is a simple process. Set the <i>ncb_num</i> field to the name number returned from an <i>NCBADDNAME</i> command or an <i>NCBADDGRNAME</i> command. This is the number that identifies the message sender. Set <i>ncb_buffer</i> to the address of the buffer with the data you need to send, and set <i>ncb_length</i> to the number of bytes to send. Next, set the <i>ncb_lana_num</i> field to the LANA over which you want the datagram to be transmitted. The last step is to set <i>ncb_callname</i> to the name of the destination NetBIOS name. This can be a unique name or a group name. If you are sending broadcast datagrams, you perform all of the above steps except for the last one: since all workstations will receive the message, no <i>ncb_callname</i> is required.</p>

<p>Of course, in each of the sender scenarios mentioned above, there must be a corresponding datagram receive command to actually receive the data. Datagrams are connectionless; if a datagram reaches a client but the client does not have a receive command already pending, the data is lost and there is no way for the client to recover that data (unless the server resends the data). That is the disadvantage of sending datagrams. However, datagrams are much faster than connection-based methods because they don't require the overhead of error checking, connection setup, and so on.</p>

<p>There are also three methods for receiving datagrams. The first two receive types use the <i>NCBDGRECV</i> command. First, you can issue a datagram receive command for messages destined for a specific name&#8212;unique or group. Second, you can issue a datagram receive command for any datagram destined for any name in the process's NetBIOS name table. Third, you can issue a receive command for a broadcast datagram with the <i>NCBDGRECVBC</i> command.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>It is not possible to post a receive command for datagrams destined for a name registered by a different process unless both processes have registered a group name, in which case both processes can receive the same message.</blockquote></div></p>

<p>To issue a receive command, set the <i>ncb_num</i> field to the name number returned from a successful <i>NCBADDNAME</i> or <i>NCBADDGRNAME</i> call. This name number specifies which name you are listening on for incoming datagrams. If you set this field to 0xFF, you will receive datagrams destined for any name in this process's NetBIOS name table. Additionally, create a buffer to receive data and set <i>ncb_buffer</i> to the buffer's address. Set <i>ncb_length</i> to the size of the buffer. Finally, set <i>ncb_lana_num</i> to the LANA number on which to wait for datagrams. When a successful call to <i>Netbios</i> with the <i>NCBDGRECV</i> command (or the <i>NCBDGRECVBC</i> command) returns, <i>ncb_length</i> will contain the actual number of bytes received and <i>ncb_callname</i> will contain the NetBIOS name of the sending process.</p>

<p>The code in Figure 1-7 contains basic datagram functions. All the sends are blocking calls&#8212;once the command is issued and the data is on the wire, the function returns, and you shouldn't experience blocking because of data overload. The receive calls are asynchronous events because we do not know what LANA numbers data will come in on. The code is similar to that for the session-oriented server using events. For each LANA, the code posts an asynchronous <i>NCBDGRECV</i> (or <i>NCBDGRECVBC</i>) and waits until one succeeds, at which point it checks all posted commands, prints the messages for those that succeed, and cancels those commands that are still pending. The example provides functions for both directed and broadcast sends and receives. The program can be compiled into a sample application that can be configured to send or receive datagrams. The program accepts several command line parameters that allow the user to specify the number of datagrams to send or receive, the delay between sends, the use of broadcasts instead of directed datagrams, the receipt of datagrams for any name, and so on.</p>

<p><b>Figure 1-7.</b> <i>NetBIOS datagram sample (Nbdgram.c) </i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
//ç‡¦bdgram.c

#include