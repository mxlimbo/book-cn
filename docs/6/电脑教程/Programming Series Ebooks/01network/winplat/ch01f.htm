<HTML>
<HEAD>
<TITLE>Miscellaneous NetBIOS Commands</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch01e.htm" , "ch01g.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="17"><H1>Miscellaneous NetBIOS Commands</H1></A>

<p>All of the commands discussed so far deal in some way with setting up a session, sending or receiving data through a session or a datagram, and related subjects. A few commands deal exclusively in getting information. These commands are the adapter status command (<i>NCBASTAT</i>) and the find name command (<i>NCBFINDNAME</i>), which are discussed in the following sections. The final section deals with matching LANA numbers to their protocols in a programmatic fashion. (This is not actually a NetBIOS function; we'll discuss it because it can gather useful NetBIOS information for you.)</p>

<A NAME="18"><h2>Adapter Status (<i>NCBASTAT</i>)</h2></A>
<p>The adapter status command is useful for obtaining information about the local computer and its LANA numbers. Using this command is also the only way to programmatically find the machine's MAC address from Windows 95 and Windows NT 4. With the advent of the IP Helper functions for Windows 2000 and Windows 98 (discussed in Appendix A), there is a more generic interface for finding the MAC address; however, for the other Win32 platforms, using the adapter status command is your only valid option.</p>

<p>The command and its syntax are fairly easy to understand, but two ways of calling the function affect what data is returned. The adapter status command returns an <i>ADAPTER_STATUS</i> structure followed by a number of <i>NAME_BUFFER</i> structures. The structures are defined as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _ADAPTER_STATUS {
    UCHAR   adapter_address[6];
    UCHAR   rev_major;
    UCHAR   reserved0;
    UCHAR   adapter_type;
    UCHAR   rev_minor;
    WORD    duration;
    WORD    frmr_recv;
    WORD    frmr_xmit;
    WORD    iframe_recv_err;
    WORD    xmit_aborts;
    DWORD   xmit_success;
    DWORD   recv_success;
    WORD    iframe_xmit_err;
    WORD    recv_buff_unavail;
    WORD    t1_timeouts;
    WORD    ti_timeouts;
    DWORD   reserved1;
    WORD    free_ncbs;
    WORD    max_cfg_ncbs;
    WORD    max_ncbs;
    WORD    xmit_buf_unavail;
    WORD    max_dgram_size;
    WORD    pending_sess;
    WORD    max_cfg_sess;
    WORD    max_sess;
    WORD    max_sess_pkt_size;
    WORD    name_count;
} ADAPTER_STATUS, *PADAPTER_STATUS;
typedef struct _NAME_BUFFER {
    UCHAR   name[NCBNAMSZ];
    UCHAR   name_num;
    UCHAR   name_flags;
} NAME_BUFFER, *PNAME_BUFFER;

</pre>
</td></tr></table>
</p>

<p>The fields of most interest are MAC address (<i>adapter_address</i>), maximum datagram size (<i>max_dgram_size</i>), and maximum number of sessions (<i>max_sess</i>). Also, the <i>name_count</i> field tells you how many <i>NAME_BUFFER</i> structures were returned. The maximum number of NetBIOS names per LANA is 254, so you have a choice of providing a buffer large enough for all names or calling the adapter status command once with <i>ncb_length</i> equal to 0. When the <i>Netbios</i> function returns, it provides the necessary buffer size.</p>

<p>The fields required to call <i>NCBASTAT</i> are <i>ncb_command</i>, <i>ncb_buffer</i>, <i>ncb_length</i>, <i>ncb_lana_num</i>, and <i>ncb_callname</i>. If the first character of <i>ncb_callname</i> is an asterisk (*), a status command is executed, but only those NetBIOS names added by the calling process are returned. However, if you call <i>Netbios</i> with an adapter status command, add a unique name to the current process's name table, and then use that name in the <i>ncb_callname</i> field, all NetBIOS names are registered in the local process's name table, as well as any names registered by the system. You can also perform an adapter status query on a machine other than the one the command is executed on. To do this, set the <i>ncb_callname</i> field to the machine name of the remote workstation.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr>Remember that all Microsoft machine names have their 16th byte set to 0 and should be padded with spaces.</blockquote></div></p>

<p>The sample program Astat.c is a simple adapter status program that runs the given query on all LANA adapters. Also, by using the /l:LOCALNAME flag, the command is executed on the local machine but provides the entire name table. The /r:REMOTENAME flag executes a remote query for the given machine name.</p>

<p>A few things should be considered when using the adapter status command. First, a multihomed machine will have more than one MAC address. Since NetBIOS provides no way to find which adapters and protocols a LANA is bound to, it is up to you to sort out the values returned. Also, if Remote Access Service (RAS) is installed, the system will allocate LANA numbers for those connections as well. While the RAS connections are unconnected, an adapter status on those LANAs will return all zeros for the MAC address. If a RAS connection is established, the MAC address is the same MAC address RAS assigns to all its virtual network devices. Finally, when you perform a remote adapter status query, you must perform it over a transport protocol that both machines have in common. For example, the system command <i>Nbtstat</i> (which is a command line version of <i>NCBASTAT</i>) issues its query over the TCP/IP transport only. If the remote machine doesn't have TCP/IP as one of its protocols, the command will fail.</p>

<A NAME="19"><h2>Find Name (<i>NCBFINDNAME</i>)</h2></A>
<p>The find name command, available only on Windows NT and Windows 2000, tells you who, if anyone, has a given NetBIOS name registered. In order to perform a successful find name query, the process must add its own unique name to the name table. The required fields for this command are command, LANA number, buffer, and buffer length. The query will return a <i>FIND_NAME_HEADER</i> structure and any number of <i>FIND_NAME_BUFFER</i> structures, which are defined as follows:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _FIND_NAME_HEADER {
    WORD    node_count;
    UCHAR   reserved;
    UCHAR   unique_group;
} FIND_NAME_HEADER, *PFIND_NAME_HEADER;

typedef struct _FIND_NAME_BUFFER {
    UCHAR   length;
    UCHAR   access_control;
    UCHAR   frame_control;
    UCHAR   destination_addr[6];
    UCHAR   source_addr[6];
    UCHAR   routing_info[18];
} FIND_NAME_BUFFER, *PFIND_NAME_BUFFER;

</pre>
</td></tr></table>
</p>

<p>As with the adapter status command, if the <i>NCBFINDNAME</i> command is executed with a buffer length of 0, the <i>Netbios</i> function will return the required length with the error <i>NRC_BUFLEN</i>.</p>

<p>The <i>FIND_NAME_HEADER</i> structure that a successful query returns indicates whether the name is registered as a unique name or a group name. If the field <i>unique_group</i> is 0, it is a unique name. The value 1 indicates a group name. The <i>node_count</i> field indicates how many <i>FIND_NAME_BUFFERS</i> structures were returned. The <i>FIND_NAME_BUFFER</i> structure returns quite a bit of information, most of which is useful at the protocol level. However, we're interested in the fields <i>destination_addr</i> and <i>source_addr</i>. The <i>source_addr</i> field contains the MAC address of the network adapter that has registered the name, while the <i>destination_addr</i> field contains the MAC address of the adapter that performed the query.</p>

<p>A find name query can be issued on any LANA number on the local machine. The data returned should be identical on all valid LANA numbers for the local network. (For example, you can execute a find name command on a RAS connection to determine whether a name is registered on the remote network.) Under Windows NT 4, you will find the following bug: when a find name query is executed over TCP/IP, <i>Netbios</i> returns bogus information. Therefore, if you plan to use this query under Windows NT 4, be sure to pick a LANA corresponding to a transport other than TCP/IP.</p>

<A NAME="20"><H2>Matching Transports to LANA Numbers</H2></A>

<p>This last section discusses matching transport protocols such as TCP/IP and NetBEUI to their LANA numbers. Because there are different potential problems to deal with depending on which transport your application is using, it's nice to be able to find these transports programmatically. This isn't possible with a native NetBIOS call, but it is possible with Winsock 2 under Windows NT 4 and Windows 2000. The Winsock 2 function <i>WSAEnumProtocols</i> returns information about available transport protocols. (See Chapters <a href="ch05a.htm">5</a> and <a href="ch06a.htm">6</a> for more information about <i>WSAEnumProtocols</i>.) Although Winsock 2 is available on Windows 95 and by default on Windows 98, the protocol information stored on these platforms does not contain any NetBIOS information, which is what we're looking for.</p>

<p>We won't discuss Winsock 2 in great detail, as this is the subject of Part II of this book. The basic steps involved are loading Winsock 2 through the <i>WSAStartup</i> function, calling <i>WSAEnumProtocols</i>, and inspecting the <i>WSAPROTOCOL_INFO</i> structures returned from the call. The sample Nbproto.c on this book's companion CD contains code for performing this query.</p>

<p>The <i>WSAEnumProtocols</i> function takes a buffer to a block of data and a buffer-length parameter. First call the function with a null buffer address and 0 for the length. The call will fail, but the buffer-length parameter will contain the size of the buffer required. Once you have the proper size, call the function again. <i>WSAEnumProtocols</i> returns the number of protocols it found. The <i>WSAPROTOCOL_INFO</i> structure is large and contains a lot of fields, but the ones we're interested in are <i>szProtocol</i>, <i>iAddressFamily,</i> and <i>iProtocol</i>. If <i>iAddressFamily</i> is equal to <i>AF_NETBIOS</i>, the absolute value of <i>iProtocol</i> is the LANA number for the protocol given in the string <i>szProtocol</i>. Additionally, the <i>ProviderId</i> GUID can be used to match the returned protocol to certain predefined GUIDs for protocols.</p>

<p>There is only one &quot;gotcha&quot; with this method. Under Windows NT and Windows 2000, the <i>iProtocol</i> field for any protocol installed on LANA 0 is the value 0x80000000. This is because protocol 0 is reserved for special use; any protocol assigned LANA 0 will always have the value 0x80000000, so it is a matter of simply checking for this value.</p>

</BODY>
</HTML>




