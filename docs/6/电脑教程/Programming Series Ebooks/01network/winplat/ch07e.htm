<HTML>
<HEAD>
<TITLE>Connectionless Protocols</title>
<link rel="STYLESHEET" type="text/css" href="Library.css">


</head>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07d.htm" , "ch07f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>



<A NAME="157"><H1>Connectionless Protocols</H1></A>

<p>Connectionless protocols behave differently than connection-oriented protocols, so the method for sending and receiving data is substantially different. First we'll discuss the receiver (or server, if you prefer) because the connectionless receiver requires little change when compared with the session-oriented servers. Following that we'll look at the sender.</p>

<A NAME="158"><H2>Receiver</H2></A>

<p>For a process to receive data on a connectionless socket, the steps are simple. First create the socket with either <i>socket</i> or <i>WSASocket</i>. Next bind the socket to the interface on which you wish to receive data. This is done with the <i>bind</i> function (exactly like the session-oriented example). The difference with connectionless sockets is that you do not call <i>listen</i> or <i>accept</i>. Instead, you simply wait to receive the incoming data. Because there is no connection, the receiving socket can receive datagrams originating from any machine on the network. The simplest of the receive functions is <i>recvfrom</i>, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int recvfrom(
    SOCKET s,
    char FAR* buf,
    int len,
    int flags,
    struct sockaddr FAR* from,
    int FAR* fromlen
);
</pre>
</td></tr></table>
</p>

<p>The first four parameters are the same as <i>recv</i>, including the possible values for <i>flags</i>&#8212;<i>MSG_OOB</i> and <i>MSG_PEEK</i>. The same warnings for using the <i>MSG_PEEK</i> flag also apply to connectionless sockets. The <i>from</i> parameter is a <i>SOCKADDR</i> structure for the given protocol of the listening socket, with <i>fromlen</i> pointing to the size of the address structure. When the API call returns with data, the <i>SOCKADDR</i> structure is filled with the address of the workstation that sent the data.</p>

<p>The Winsock 2 version of the <i>recvfrom</i> function is <i>WSARecvFrom</i>. The prototype for this function is</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSARecvFrom(
    SOCKET s,
    LPWSABUF lpBuffers,
    DWORD dwBufferCount,
    LPDWORD lpNumberOfBytesRecvd,
    LPDWORD lpFlags,
    struct sockaddr FAR * lpFrom,
    LPINT lpFromlen,
    LPWSAOVERLAPPED lpOverlapped,
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionROUTINE
);
</pre>
</td></tr></table>
</p>

<p>The difference is the use of <i>WSABUF</i> structures for receiving the data. You can supply one or more <i>WSABUF</i> buffers to <i>WSARecvFrom</i> with <i>dwBufferCount</i> indicating this. By supplying multiple buffers, scatter-gather I/O is possible. The total number of bytes read is returned in <i>lpNumberOfBytesRecvd</i>. When you call <i>WSARecvFrom</i>, the <i>lpFlags</i> parameter can be 0 for no options, <i>MSG_OOB</i>, <i>MSG_PEEK</i>, or <i>MSG_PARTIAL</i>. These flags can be ORed together. If <i>MSG_PARTIAL</i> is specified when the function is called, the provider knows to return data even if only a partial message has been received. Upon return, the flag <i>MSG_PARTIAL</i> is set if only a partial message was received. Upon return, <i>WSARecvFrom</i> will set the <i>lpFrom</i> parameter (a pointer to a <i>SOCKADDR</i> structure) to the address of the sending machine. Again, <i>lpFromLen</i> points to the size of the <i>SOCKADDR</i> structure, except that in this function it is a pointer to
a <i>DWORD</i>. The last two parameters, <i>lpOverlapped</i> and <i>lpCompletionROUTINE</i>, are used for overlapped I/O (which we'll discuss in the <a href="ch08a.htm">next chapter</a>).</p>

<p>Another method of receiving (and sending) data on a connectionless socket is to establish a connection. This might sound strange, but it's not quite what it sounds like. Once a connectionless socket is created, you can call <i>connect</i> or <i>WSAConnect</i> with the <i>SOCKADDR</i> parameter set to the address of the remote machine to communicate with. No actual connection is made, however. The socket address passed into a connect function is associated with the socket so that <i>recv</i> and <i>WSARecv</i> can be used instead of <i>recvfrom</i> or <i>WSARecvFrom</i> because the data's origin is known. The ability to connect a datagram socket is handy if you intend to communicate with only one endpoint at a time in your application.</p>

<A NAME="159"><H2>Sender</H2></A>

<p>To send data on a connectionless socket, there are two options. The first, and simplest, is to create a socket and call either <i>sendto</i> or <i>WSASendTo</i>. We'll cover <i>sendto</i> first, which is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int sendto(
    SOCKET s,
    const char FAR * buf,
    int len,
    int flags,
    const struct sockaddr FAR * to,
    int tolen
);
</pre>
</td></tr></table>
</p>

<p>The parameters are the same as <i>recvfrom</i> except that <i>buf</i> is the buffer of data to send and <i>len</i> indicates how many bytes to send. Also, the <i>to</i> parameter is a pointer to a <i>SOCKADDR</i> structure with the destination address of the workstation to receive the data. The Winsock 2 function <i>WSASendTo</i> can also be used. This function is defined as</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
int WSASendTo(
    SOCKET s,                                               
    LPWSABUF lpBuffers,                                     
    DWORD dwBufferCount,                                    
    LPDWORD lpNumberOfBytesSent,                            
    DWORD dwFlags,                                          
    const struct sockaddr FAR * lpTo,                       
    int iToLen,                                             
    LPWSAOVERLAPPED lpOverlapped,                           
    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionROUTINE
);
</pre>
</td></tr></table>
</p>

<p>Again, <i>WSASendTo</i> is similar to its ancestor. This function takes a pointer to one or more <i>WSABUF</i> structures with data to send to the recipient as the <i>lpBuffers</i> parameter, with <i>dwBufferCount</i> indicating how many structures are present. You can send multiple <i>WSABUF</i> structures to enable scatter-gather I/O. Before returning, <i>WSASendTo</i> sets the fourth parameter, <i>lpNumberOfBytesSent</i>, to the number of bytes actually sent to the receiver. The <i>lpTo</i> parameter is a <i>SOCKADDR</i> structure for the given protocol, with the recipient's address. The <i>iToLen</i> parameter is the length of the <i>SOCKADDR</i> structure. The last two parameters, <i>lpOverlapped</i> and <i>lpCompletionROUTINE</i>, are used for overlapped I/O (discussed in <a href="ch08a.htm">Chapter 8</A>).</p>

<p>As with receiving data, a connectionless socket can be connected to an endpoint address and data can be sent with <i>send</i> and <i>WSASend</i>. Once this association is established, you cannot go back to using <i>sendto</i> or <i>WSASendTo</i> with an address other than the address passed to one of the connect functions. If you do attempt to send data to a different address, the call will fail with <i>WSAEISCONN</i>. The only way to disassociate the socket handle from that destination is to call <i>closesocket</i> on the handle and create a new socket.</p>

<A NAME="160"><H2>Message-Based Protocols</H2></A>

<p>Just as most connection-oriented protocols are also streaming, connectionless protocols are almost always message-based. Thus, there are some considerations when you're sending and receiving data. First, because message-based protocols preserve data boundaries, data submitted to a send function blocks until completed. For asynchronous or nonblocking I/O modes, if a send cannot be completely satisfied, the send function returns with the error <i>WSAEWOULDBLOCK</i>. This means that the underlying system was not able to process that data and you should attempt the send call again at a later time. This scenario will be discussed in greater detail in the <a href="ch08a.htm">next chapter</a>. The main thing to remember is that with message-based protocols, the write can occur only as an autonomous action.</p>

<p>On the flip side, a call to a receive function must supply a sufficiently large buffer. If the supplied buffer is not large enough, the receive call fails with the error <i>WSAEMSGSIZE</i>. If this occurs, the buffer is filled to its capacity, but the remaining data is discarded. The truncated data cannot be retrieved. The only exception is for protocols that do support partial messages, such as the AppleTalk PAP protocol. Prior to returning, the <i>WSARecvEx</i> function sets its in-out <i>flag</i> parameter to <i>MSG_PARTIAL</i> when it receives only part of a message.</p>

<p>For datagrams based on protocols supporting partial messages, consider using one of the <i>WSARecv</i> functions. When you make a call to <i>recv</i>, there is no notification that the data read is only a partial message. It is up to the programmer to implement a method for the receiver to determine whether the entire message has been read. Subsequent calls to <i>recv</i> return other pieces of the datagram. Because of this limitation, it can be convenient to use the <i>WSARecvEx</i> function, which allows the setting and reading of the <i>MSG_PARTIAL</i> flag to indicate whether the entire message was read. The Winsock 2 functions <i>WSARecv</i> and <i>WSARecvFrom</i> also support this flag. See the descriptions for <i>WSARecv</i>, <i>WSARecvEx</i>, and <i>WSARecvFrom</i> for additional information about this flag.</p>

<p>Finally, let's take a look at one of the more frequently asked questions concerning sending UDP/IP messages on machines with multiple network interfaces: what happens when a UDP socket is bound explicitly to a local IP interface and datagrams are sent? With UDP sockets, you don't really bind to the network interface; you create an association whereby the IP interface that is bound becomes the source IP address of UDP datagrams sent. The routing table actually determines which physical interface the datagram is transmitted on. If you do not call <i>bind</i> but instead either use <i>sendto</i>/<i>WSASendTo</i> or perform a connect first, the network stack automatically picks the best local IP address based on the routing table. What this means is that if you explicitly bind first, the source IP address could be incorrect. That is, the source IP might not be the IP address of the interface on which the datagram was actually sent.</p>

<A NAME="161"><H2>Releasing Socket Resources</H2></A>

<p>Because there is no connection with connectionless protocols, there is no formal shutdown or graceful closing of the connection. When the sender or the receiver is finished sending or receiving data, it simply calls the <i>closesocket</i> function on the socket handle. This releases any associated resources allocated to the socket.</p>

<A NAME="162"><H2>Putting It All Together</H2></A>

<p>Now that we have covered the necessary steps for sending and receiving data on a connectionless socket, let's look at some actual code that performs this procedure. Figure 7-5 shows the first example, a connectionless receiver. The code illustrates how to receive a datagram on either the default interface or a specified local interface.</p>

<p><b>Figure 7-5.</b> <i>Connectionless receiver</i></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
// Module Name: Receiver.c
//
// Description:
//    This sample receives UDP datagrams by binding to the specified
//    interface and port number and then blocking on a recvfrom() 
//    call
//
// Compile:
//    cl -o Receiver Receiver.c ws2_32.lib
//
// Command Line Options:
//    sender [-p:int] [-i:IP][-n:x] [-b:x]
//           -p:int   Local port
//           -i:IP    Local IP address to listen on
//           -n:x     Number of times to send message
//           -b:x     Size of buffer to send
//
#include &lt;winsock2.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define DEFAULT_PORT            5150
#define DEFAULT_COUNT           25
#define DEFAULT_BUFFER_LENGTH   4096

int   iPort    = DEFAULT_PORT;          // Port to receive on
DWORD dwCount  = DEFAULT_COUNT,         // Number of messages to read
      dwLength = DEFAULT_BUFFER_LENGTH; // Length of receiving buffer
BOOL  bInterface = FALSE;               // Use an interface other than
                                        // default
char  szInterface[32];            // Interface to read datagrams from

//
// Function: usage:
//
// Description:
//    Print usage information and exit
//
void usage()
{
    printf(&quot;usage: sender [-p:int] [-i:IP][-n:x] [-b:x]\n\n&quot;);
    printf(&quot;       -p:int   Local port\n&quot;);
    printf(&quot;       -i:IP    Local IP address to listen on\n&quot;);
    printf(&quot;       -n:x     Number of times to send message\n&quot;);
    printf(&quot;       -b:x     Size of buffer to send\n\n&quot;);
    ExitProcess(1);
}

//
// Function: ValidateArgs
//
// Description:
//    Parse the command line arguments, and set some global flags to
//    indicate what actions to perform
//
void ValidateArgs(int argc, char **argv)
{
    int                i;

    for(i = 1; i &lt; argc; i++)
    {
        if ((argv[i][0] == '-') || (argv[i][0] == '/'))
        {
            switch (tolower(argv[i][1]))
            {
                case 'p':   // Local port
                    if (strlen(argv[i]) &gt; 3)
                        iPort = atoi(&amp;argv[i][3]);
                    break;
                case 'n':   // Number of times to receive message
                    if (strlen(argv[i]) &gt; 3)
                        dwCount = atol(&amp;argv[i][3]);
                    break;
                case 'b':   // Buffer size
                    if (strlen(argv[i]) &gt; 3)
                        dwLength = atol(&amp;argv[i][3]);
                    break;
                case 'i':    // Interface to receive datagrams on
                    if (strlen(argv[i]) &gt; 3)
                    {
                        bInterface = TRUE;
                    strcpy(szInterface, &amp;argv[i][3]);
                    }
                    break;
                default:
                    usage();
                    break;
            }
        }
    }
}

//
// Function: main
//
// Description:
//    Main thread of execution. Initialize Winsock, parse the command
//    line arguments, create a socket, bind it to a local interface 
//    and port, and then read datagrams.
//
int main(int argc, char **argv)
{
    WSADATA        wsd;
    SOCKET         s;
    char          *recvbuf = NULL;
    int            ret,
                   i;
    DWORD          dwSenderSize;
    SOCKADDR_IN    sender,
                   local;

    // Parse arguments and load Winsock
    //
    ValidateArgs(argc, argv);

    if (WSAStartup(MAKEWORD(2,2), &amp;wsd) != 0)
    {
        printf(&quot;WSAStartup failed!\n&quot;);
        return 1;
    }
    // Create the socket, and bind it to a local interface and port
    //
    s = socket(AF_INET, SOCK_DGRAM, 0);
    if (s == INVALID_SOCKET)
    {
        printf(&quot;socket() failed; %d\n&quot;, WSAGetLastError());
        return 1;
    }
    local.sin_family = AF_INET;
    local.sin_port = htons((short)iPort);
    if (bInterface)
        local.sin_addr.s_addr = inet_addr(szInterface);
    else
        local.sin_addr.s_addr = htonl(INADDR_ANY);
    if (bind(s, (SOCKADDR *)&amp;local, sizeof(local)) == SOCKET_ERROR)
    {
        printf(&quot;bind() failed: %d\n&quot;, WSAGetLastError());
        return 1;
    }
    // Allocate the receive buffer
    //
    recvbuf = GlobalAlloc(GMEM_FIXED, dwLength);
    if (!recvbuf)
    {
        printf(&quot;GlobalAlloc() failed: %d\n&quot;, GetLastError());
        return 1;
    }
    // Read the datagrams
    //
    for(i = 0; i &lt; dwCount; i++)
    {
        dwSenderSize = sizeof(sender);
        ret = recvfrom(s, recvbuf, dwLength, 0, 
                (SOCKADDR *)&amp;sender, &amp;dwSenderSize);
        if (ret == SOCKET_ERROR)
        {
            printf(&quot;recvfrom() failed; %d\n&quot;, WSAGetLastError());
            break;
        }
        else if (ret == 0)
            break;
        else
        {
            recvbuf[ret] = '\0';
            printf(&quot;[%s] sent me: '%s'\n&quot;, 
                inet_ntoa(sender.sin_addr), recvbuf);
        }
    }
    closesocket(s);

    GlobalFree(recvbuf);
    WSACleanup();
    return 0;
}
</pre>
</td></tr></table>
</p>

<p>Receiving a datagram is easy. First you create a socket, and then you bind the socket to the local interface. If you bind to the default interface, you can find its IP address by using the <i>getsockname</i> function. This function simply returns the <i>SOCKADDR_IN</i> structure associated with the given socket passed to it, indicating the interface on which the socket is bound. After that, it's just a matter of making calls to <i>recvfrom</i> in order to read the incoming data. Note that we're using <i>recvfrom</i> because we are not concerned with partial messages; the UDP protocol does not support partial messages. In fact, when the TCP/IP stack receives pieces of a larger datagram message, it waits until all parts have been assembled. If the pieces are out of order or one or more pieces are missing, the stack discards the whole message.</p>

<p>Figure 7-6 provides the code for the next example, a connectionless sender. The sender example has quite a few more options than the receiver does. The necessary parameters are the IP address and port of the remote recipient. The -c option specifies whether to make a call to <i>connect</i> first; the default behavior is not to make that call. Again, the steps are simple. First create the socket. If the -c option is present, make a call to <i>connect</i> with the remote recipient's address and port number. This is followed by calls to <i>send</i>. If no connect is performed, simply start sending data to the recipient after socket creation with the <i>sendto</i> function.</p>

<p><b>Figure 7-6.</b> <i>Connectionless sender</i> </p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
// Module Name: Sender.c
//
// Description:
//    This sample sends UDP datagrams to the specified recipient.
//    The -c option first calls connect() to associate the 
//    recipient's IP address with the socket handle so that the 
//    send() function can be used as opposed to the sendto() call.
//
// Compile:
//    cl -o Sender Sender.c ws2_32.lib
//
// Command line options:
//    sender [-p:int] [-r:IP] [-c] [-n:x] [-b:x] [-d:c]
//           -p:int   Remote port
//           -r:IP    Recipient's IP address or host name
//           -c       Connect to remote IP first
//           -n:x     Number of times to send message
//           -b:x     Size of buffer to send
//           -d:c     Character to fill buffer with
//
#include &lt;winsock2.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define DEFAULT_PORT            5150
#define DEFAULT_COUNT           25
#define DEFAULT_CHAR            'a'
#define DEFAULT_BUFFER_LENGTH   64

BOOL  bConnect = FALSE;                 // Connect to recipient first
int   iPort    = DEFAULT_PORT;          // Port to send data to
char  cChar    = DEFAULT_CHAR;          // Character to fill buffer 
DWORD dwCount  = DEFAULT_COUNT,         // Number of messages to send
      dwLength = DEFAULT_BUFFER_LENGTH; // Length of buffer to send
char  szRecipient[128];                 // Recipient's IP or host name

//
// Function: usage
//
// Description:
//    Print usage information and exit
//
void usage()
{
    printf(&quot;usage: sender [-p:int] [-r:IP] &quot;
           &quot;[-c] [-n:x] [-b:x] [-d:c]\n\n&quot;);
    printf(&quot;       -p:int   Remote port\n&quot;);
    printf(&quot;       -r:IP    Recipient's IP address or host name\n&quot;);
    printf(&quot;       -c       Connect to remote IP first\n&quot;);
    printf(&quot;       -n:x     Number of times to send message\n&quot;);
    printf(&quot;       -b:x     Size of buffer to send\n&quot;);
    printf(&quot;       -d:c     Character to fill buffer with\n\n&quot;);
    ExitProcess(1);
}

//
// Function: ValidateArgs
//
// Description:
//    Parse the command line arguments, and set some global flags to
//    indicate what actions to perform
//
void ValidateArgs(int argc, char **argv)
{
    int i;

    for(i = 1; i &lt; argc; i++)
    {
        if ((argv[i][0] == '-') || (argv[i][0] == '/'))
        {
            switch (tolower(argv[i][1]))
            {
                case 'p':        // Remote port
                    if (strlen(argv[i]) &gt; 3)
                        iPort = atoi(&amp;argv[i][3]);
                    break;
                case 'r':        // Recipient's IP addr
                    if (strlen(argv[i]) &gt; 3)
                        strcpy(szRecipient, &amp;argv[i][3]);
                    break;
                case 'c':        // Connect to recipient's IP addr
                    bConnect = TRUE;
                    break;
                case 'n':        // Number of times to send message
                    if (strlen(argv[i]) &gt; 3)
                        dwCount = atol(&amp;argv[i][3]);
                    break;
                case 'b':        // Buffer size
                    if (strlen(argv[i]) &gt; 3)
                        dwLength = atol(&amp;argv[i][3]);
                    break;
                case 'd':        // Character to fill buffer
                    cChar = argv[i][3];
                    break;
                default:
                    usage();
                    break;
            }
        }
    }
}

//
// Function: main
//
// Description:
//    Main thread of execution. Initialize Winsock, parse the command
//    line arguments, create a socket, connect to the remote IP
//    address if specified, and then send datagram messages to the
//    recipient.
//
int main(int argc, char **argv)
{
    WSADATA        wsd;
    SOCKET         s;
    char          *sendbuf = NULL;
    int            ret,
                   i;
    SOCKADDR_IN    recipient;

    // Parse the command line and load Winsock
    //
    ValidateArgs(argc, argv);

    if (WSAStartup(MAKEWORD(2, 2), &amp;wsd) != 0)
    {
        printf(&quot;WSAStartup failed!\n&quot;);
        return 1;
    }
    // Create the socket
    //
    s = socket(AF_INET, SOCK_DGRAM, 0);
    if (s == INVALID_SOCKET)
    {
        printf(&quot;socket() failed; %d\n&quot;, WSAGetLastError());
        return 1;
    }
    // Resolve the recipient's IP address or host name
    //
    recipient.sin_family = AF_INET;
    recipient.sin_port = htons((short)iPort);
    if ((recipient.sin_addr.s_addr = inet_addr(szRecipient))
        == INADDR_NONE)
    {
        struct hostent *host=NULL;

        host = gethostbyname(szRecipient);
        if (host)
            CopyMemory(&amp;recipient.sin_addr, host-&gt;h_addr_list[0],
                host-&gt;h_length);
        else
        {
            printf(&quot;gethostbyname() failed: %d\n&quot;, WSAGetLastError());
            WSACleanup();
            return 1;
        }
    }
    // Allocate the send buffer
    //
    sendbuf = GlobalAlloc(GMEM_FIXED, dwLength);
    if (!sendbuf)
    {
        printf(&quot;GlobalAlloc() failed: %d\n&quot;, GetLastError());
        return 1;
    }
    memset(sendbuf, cChar, dwLength);
    //
    // If the connect option is set, &quot;connect&quot; to the recipient
    // and send the data with the send() function
    //
    if (bConnect)
    {
        if (connect(s, (SOCKADDR *)&amp;recipient, 
                sizeof(recipient)) == SOCKET_ERROR)
        {
            printf(&quot;connect() failed: %d\n&quot;, WSAGetLastError());
            GlobalFree(sendbuf);
            WSACleanup();
            return 1;
        }
        for(i = 0; i &lt; dwCount; i++)
        {
            ret = send(s, sendbuf, dwLength, 0);
            if (ret == SOCKET_ERROR)
            {
                printf(&quot;send() failed: %d\n&quot;, WSAGetLastError());
                break;
            }
            else if (ret == 0)
                break;
            // Send() succeeded!
        }
    }
    else
    {
        // Otherwise, use the sendto() function
        //
        for(i = 0; i &lt; dwCount; i++)
        {

            ret = sendto(s, sendbuf, dwLength, 0, 
                    (SOCKADDR *)&amp;recipient, sizeof(recipient));
            if (ret == SOCKET_ERROR)
            {
                printf(&quot;sendto() failed; %d\n&quot;, WSAGetLastError());
                break;
            }
            else if (ret == 0)
                break;
            // sendto() succeeded!
        }
    }
    closesocket(s);

    GlobalFree(sendbuf);
    WSACleanup();
    return 0;
}
</pre>
</td></tr></table>
</p>

</BODY>
</HTML>




