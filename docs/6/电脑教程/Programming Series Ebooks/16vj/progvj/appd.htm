<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>Class Information</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("appc.htm", "appe.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="26"><H1>Class Information</H1></A>

<A NAME="27"><H2>Defining a Class</H2></A>

<p>You can define your own types by using the keyword 
<I>class</I>.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>The keyword <I>class</I> is the only way Java provides for you to 
create a new type. Java has no equivalent to 
<I>typedef</I>, <I>struct</I>, or <I>enum 
</I>(enumerated types).</blockquote></div>


<p>A user type definition takes the following form:

<p><pre>
class CMyClass
{
    // the members of the class go here
}
</PRE>

<p>The <I>class</I> keyword is followed by the class name. The class name must be 
a valid Java identifier. (The same naming rules apply for classes as for variable 
names, as described in the section &quot;<A HREF="appb.htm#6">Identifiers</A>&quot;). The members of the class 
can appear in any order within the class body.

<p>There are two types of members to a class: data members and member functions.

<A NAME="28"><H3>Defining data members</H3></A>

<p>Data members are used to describe the data properties of the class. Data 
members are declared using the same rules as local variables.

<A NAME="29"><H3>Defining member functions</H3></A>

<p>Members of a Java class can also be functions. Member functions in Java are 
commonly known as methods of the class, or simply as methods.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
All functions in Java are methods.
</blockquote></div>

<p>A method definition consists of the following:
<UL>
<p><LI> The type of the object that the method returns. If the method returns 
no object, then the return type is <I>void</I>.
<p><LI> The name of the method. A method name can be any valid Java identifier.
<p><LI> Parentheses containing the parameter list. The parameter list is a 
comma-separated list of declarations of the arguments to the method. If the 
method takes no arguments, the argument list is empty.
<p><LI> Braces following the argument list contain the body of the method.
</UL>

<p><div class="note"><blockquote>
<b>NOTE</b><hr>A separate definition and declaration of a method isn't 
supported as it is in C++. In addition, defining a method within the class doesn't imply 
that the method is an inline function, and the 
<I>inline</I> keyword isn't supported in Java. The decision to expand a method inline is left to the compiler.
</blockquote></div>


<p>When a method is called, control passes to the open brace of the method. 
You can have the code exit from any point by using the keyword 
<I>return</I>. In the absence of encountering a 
<I>return</I> statement, the method exits upon reaching the closed 
brace. If the method returns something other than 
<I>void</I>, then a <I>return</I> statement, 
followed by an expression indicating the value to return, is required.

<p>The following example declares a <I>TV</I> class containing a <I>channel</I> data member, and a  
<I>tune()</I> method that changes the channel:

<p><pre>
/**
 * Represents a color television.
 */
class TV
{
    int channel;

    /**
     * Change the channel of the television.
     */
    void tune(int newChannel)
    {
        channel = newChannel;
    }
}
</PRE>

<p>The Javadoc comments add the documentation for the 
<I>TV</I> class and the <I>tune()</I> method to the statement completion. (The Javadoc comments are not included 
in subsequent examples, to save space.)

<A NAME="30"><H3>Scope</H3></A>

<p>By default, members of a class are not accessible from classes that are outside of 
the class's own domain. Attaching the keyword 
<I>public</I> makes members available from all classes.

<A NAME="31"><H3>Overloading methods</H3></A>

<p>Java differentiates methods from each other by more than just their name. A 
method's fully qualified name includes its name, its class, and its arguments. Two methods 
can have the same name, as long as their fully qualified names are different. This is 
called function overloading (not to be confused with method overriding, which we'll 
discuss later).

<p>Even though you have a <I>tune()</I> method in the class 
<I>TV</I>, you can still have a separate method 
<I>tune()</I> in the class <I>Radio</I>.

<p>Within a class, two methods can have the same name as long as they can 
be discriminated between on the basis of their arguments. In a given class 
<I>Bank,</I> you could have a  method <I>int</I> 
<I>tune()</I>  that returns the current channel, and a method 
<I>tune(int)</I> that retunes the TV.

<A NAME="32"><H2>Objects</H2></A>

<p>People sometimes get fast and loose with the terms &quot;class&quot; and &quot;object.&quot; A 
class describes a type of thing. The class <I>TV 
</I>might be used to represent TVs. (Sometimes people use the terms &quot;class&quot; and &quot;type&quot; interchangeably&#8212;that's okay.) On the 
other hand, <I>myTV</I> refers to the TV object sitting in my living room. In this case, you 
can also say that <I>myTV</I> is an instance of 
<I>TV.</I>

<A NAME="33"><H3>References to objects</H3></A>

<p>Java programs access objects by means of a reference. The following example 
declares two references:

<p><pre>
TV myTV = new TV();
TV yourTV;
yourTV = myTV;
</PRE>

<p>The first declaration creates a reference 
<I>myTV</I> to an object of class <I>TV</I>. The memory for that object comes from a pool of available memory known as the 
heap. The second declaration creates a reference 
<I>yourTV,</I> which points to nothing (technically, it points to the 
<I>null</I> object). After the assignment, 
<I>yourTV</I> and <I>myTV</I> point to the same 
<I>TV</I> object.

<p>Members of the class <I>TV</I> are accessed through reference. The following 
demonstrates the principle:

<p><pre>
class TV
{
    int channel;
    void tune(int newChannel)
    {
        channel = newChannel;
    }
}
class LivingRoom
{
    TV tv = new TV();
    void tuneTV(int channel)
    {
        tv.channel = channel;
        tv.tune(channel);
    }
}
</PRE>

<p>The two references to the members of <I>tv</I> in the 
<I>tuneTV()</I> method have the same effect&#8212;one accesses the data member 
<I>channel</I> directly, while the other uses the access method 
<I>tune()</I> to change the channel. Since numerous internal steps can 
be required to tune a TV other than simply changing the 
<I>channel</I> variable, it's preferable to use the access method.

<A NAME="34"><h3>What is <I>this</I>?</h3></A>
<p>Notice that the reference to <I>channel</I> within the 
<I>TV</I> <I>tune()</I> method isn't qualified to any particular object. The 
<I>tune()</I> methods set the <I>channel</I> variable of whichever 
object it's called with.

<p><pre>
TV myTV = new TV();
TV sonsTV = new TV();
myTV.tune(HISTORY_CHANNEL);
sonsTV.tune(MTV);
</PRE>

<p>The first call tunes <I>myTV</I> to 
<I>HISTORY_CHANNEL,</I> while the second call 
tunes my <I>sonsTV</I> to <I>MTV</I>. 
(<I>HISTORY_CHANNEL</I> and <I>MTV</I> are both constants defined 
somewhere else).

<p>A reference to a class member from within a method in the same class 
refers to the current object. A reference to the current object is called 
<I>this</I>.

<A NAME="35"><H3>Garbage collection</H3></A>

<p>Objects to which there is no longer a reference can't be accessed. The memory 
for such lost objects is recovered by a background task known as the garbage 
collector. For example:

<p><pre>
TV myTV = new TV();
TV sonsTV = new TV();
myTV = sonsTV;
</PRE>

<p>By assigning <I>sonsTV</I> to <I>myTV,</I> the object originally referenced by 
<I>myTV</I> is lost. It will eventually be returned to the heap.

<A NAME="36"><H3>Static members of a class</H3></A>

<p>Members of a class can be declared independently.

<p><pre>
class TV
{
    static int numberOfTVs
}
</PRE>

<p>The static data member <I>numberOfTVs</I> is shared by all objects of the class 
<I>TV</I>. Static members can be accessed by means of the class name 
<I>TV.numberOfTVs</I> or an object name 
<I>myTV.numberOfTVs</I>.

<p>Since static members belong to the class 
<I>TV</I> and not any particular <I>TV</I> object, static methods have no 
<I>this</I> reference.

<A NAME="37"><H3>The constructor</H3></A>

<p>A special method that is invoked automatically whenever a class object is created 
is called a constructor. Its job is to initialize the object to a valid starting state. 
The constructor method carries the name of the class and has no return type.

<p><pre>
class TV
{
    int channel;

    TV(int initialChannel)
    {
        channel = initialChannel;
    }
}

class LivingRoom
{
    TV myTV = new TV(HISTORY_CHANNEL);
}
</PRE>

<p>The declaration within <I>LivingRoom</I> creates a 
<I>TV</I> object initially tuned to 
<I>HISTORY_CHANNEL</I>.

<A NAME="38"><H2>Class Inheritance</H2></A>

<p>One class can inherit the properties of another class. For example, a 
<I>ColorTV</I> class might inherit many of the properties of a generic 
<I>TV </I>class&#8212;each of these classes could have a 
<I>channel</I> property as well as a <I>tune()</I> method. The 
<I>ColorTV</I> class could have extra properties as well, such as 
<I>hue</I> and <I>colorIntensity</I>.

<A NAME="39"><H3>Inheritance in Java</H3></A>

<p>One class inherits from another class using the 
<I>extends</I> keyword. In practice, this appears as follows:

<p><pre>
class ColorTV extends TV
{
    int color;

    /**
      * Set the color property.
      * @param r - the red component of the color (0-255)
      * @param g - the green component of the color (0-255)
      * @param b - the blue component of the color (0-255)
      */
    void setColor(r, g, b)
    {
        color = new Color(r, g, b);
    }
}
</PRE>

<p>In this example, the class <I>ColorTV</I> extends the base class 
<I>TV</I> by adding the <I>color</I> property and the 
<I>setColor()</I> method. The <I>ColorTV</I> class inherits the 
<I>channel</I> property and the <I>tune()</I> method.

<p>Note that even though <I>ColorTV</I> extends the 
<I>TV </I>class,<I> </I>a <I>ColorTV</I> object is a 
<I>TV </I>object. A <I>ColorTV</I> object can be used anywhere a 
<I>TV</I> object is called for.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
The <I>@param</I> directive defines the meaning of the method 
arguments to the statement completion feature.
</blockquote></div>

<A NAME="40"><H3>Overriding base class methods</H3></A>

<p>A subclass can override a method in the base class. For example, the class 
<I>TV</I> can define a method <I>selfAdjust(),</I> which adjusts the 
<I>TV</I> according to default values. Since this method doesn't include color, the class 
<I>ColorTV</I> would define its own class 
<I>selfAdjust()</I>. The 
<I>ColorTV.selfAdjust()</I> method overrides the 
<I>TV.selfAdjust()</I> method.

<p>Consider the following method:

<p><pre>
void someFunction(TV tv)
{
    tv.selfAdjust();
}
</PRE>

<p>The call to <I>selfAdjust()</I> is dependent upon the exact type of 
<I>tv</I>. If <I>tv</I> is an object of class 
<I>TV</I>, the method <I>TV.selfAdjust()</I> is invoked, but if 
<I>tv</I> is actually of class <I>ColorTV,</I> 
<I>ColorTV.selfAdjust()</I> is invoked instead.

<P><B>Invoking methods in the base class</B>

<P>Notice in the previous example that 
<I>ColorTV.selfAdjust()</I> might not completely 
replace the functions in <I>TV.selfAdjust()</I>; it might merely add extra properties 
related to color. It's possible for the method 
<I>ColorTV.selfAdjust()</I> to invoke the 
<I>TV.selfAdjust()</I> method as follows:

<p><pre>
class ColorTV extends TV
{
    /**
      * Set properties to their default values.
      */
    void selfAdjust()
    {
        // invoke selfAdjust() in the base class
        super.selfAdjust();

        .
        .
        .
    }
}
</PRE>

<p>The keyword <I>super</I> is the same as 
<I>this,</I> but it is of the same class as the 
base class.

<A NAME="41"><H3>Abstract classes</H3></A>

<p>An abstract class is a class that can't be instantiated with an object. For example, 
there is no <I>tv</I> object that is actually of type 
<I>TV</I>. Perhaps all <I>TV</I> objects must be 
members of the class <I>BWTV</I>, 
<I>ColorTV</I>, or <I>HDTV</I>. In this case, the 
<I>TV</I> class is abstract and can't be instantiated with an object.

<p>In the same sense, an abstract method is one that you can't define except 
in one of the base classes. For example, 
<I>tune()</I> would be an abstract method if the 
<I>BWTV</I>, <I>ColorTV,</I> and <I>HDTV </I>objects were all tuned differently. An abstract method is 
declared abstract and has no method body.

<p>A class that contains an abstract method must be abstract.

<A NAME="42"><H3>Final classes and methods</H3></A>

<p>A method marked <I>final</I> in a base class can't be overridden in any class that 
extends the base class. A data member declared 
<I>final</I> can't be modified once it has been initialized. A data member that is 
<I>public</I>, <I>final</I>, and <I>static</I> is treated the same as 
a constant in other languages:

<p><pre>
class TV
{
    public final static int HISTORY_CHANNEL = 20;
    .
    .
    .
}
</PRE>

<A NAME="43"><H2>Arrays</H2></A>

<A NAME="44"><H3>Arrays of intrinsic types</H3></A>

<p>The following code declares a reference to an array of integers:

<p><pre>
int array[];
</PRE>

<p>The brackets following <I>array</I> indicate that this is a reference to an array; 
however, no number within the brackets is required (or allowed), because the 
declaration itself doesn't allocate the space for the array. You can place the bracket 
before or after the reference name. Thus, the following code is also allowed (and is 
more common):

<p><pre>
int[] array;
</PRE>

<p>The memory for the array is allocated off of the heap:

<p><pre>
int[] array = new int[5];   // allocate room for five integers
</PRE>

<p>You can use an initialization list when declaring an array as follows:

<p><pre>
int[]array = new int[]{0, 1, 2, 3, 4};
</PRE>

<p>This statement allocates an array of five integers off of the heap, and 
assigns them the values 0 through 4.

<p>Elements within an array are accessed using the brackets as well:

<p><pre>
// initialize the array to zeros
for (int i = 0; i &lt; 5; i++)
{
    array[i] = 0;
}
</PRE>

<p>Java checks the range of every subscript. Thus, if 
<I>i</I> were not in the range of 
0 through 5, the statement a<I>rray[i]</I> would generate an 
<I>ArrayIndexOutOfBoundsException</I> error.

<A NAME="45"><H3>Arrays of objects</H3></A>

<p>The declaration of an array creates room for the array, but it doesn't initialize 
the elements of the array. The following does NOT create an array of five 
<I>TV</I> objects:

<p><pre>
TV [] tvArray = new TV [5];
</PRE>

<p>Instead, this creates an array of five references to 
<I>TV</I> objects, all of which point to the null object.
You can use a loop to allocate each of the 
<I>TV</I> objects individually, as follows:

<p><pre>
TV[] tvArray = new TV[5];
for (int i = 0; i &lt; 5; i++)
{
    tvArray[i] = new TV();
}
</PRE>

<p>The objects in an array can also be initialized when you allocate them, as 
follows:

<p><pre>
TV[] tvArray = new TV[]  {new BWTV(),
                          new ColorTV(128, 128, 128),
                          new HDTV(),
                          null, null};
</PRE>

<p>The first three objects declared are different subtypes of 
<I>TV</I>. The final two entries refer to the 
<I>null</I> object, which is of all class types.

<A NAME="46"><h3>The <I>Array</I> class</h3></A>
<p>An array is an object of class <I>Array</I>. All arrays have the public data property 
<I>length,</I> which contains the number of elements defined in the array.

<A NAME="47"><H2>Inner Classes</H2></A>

<p>Class definitions can be nested as shown in the following example:

<p><pre>
class ColorTV extends TV
{
    class Tuner extends Receiver
    {
        float frequency;
        void tune(float frequency)
        {
        }
    }
}
</PRE>

<p>The class <I>Tuner</I> is an inner class to the class 
<I>ColorTV</I>. The members of <I>ColorTV</I> (including 
<I>this</I>) are accessible to the members of 
<I>Tuner</I>. The reverse isn't true, however. Notice that inner classes can extend other classes.

<A NAME="48"><H2>Interfaces</H2></A>

<p>A Java class can't extend more than one class. Java does offer a related concept called interfaces, which relieves much of the necessity for multiple inheritance.

<p>Except for the appearance of the keyword 
<I>interface</I> instead of the keyword 
<I>class</I>, the declaration of an interface is similar to that of a class in which all of the 
methods are abstract. An interface allows you to describe a set of capabilities that a class 
must implement. For example, consider the following interface definition:

<p><pre>
interface ITunable
{
    void tune(int);
    String receive();
}
</PRE>

<p>This interface definition represents a promise to implement the method 
<I>tune()</I>. (Beginning the name of an interface with a capital 'I' is a coding convention.)

<P>The <I>ITunable</I> interface could be used in a method as follows:

<p><pre>
class ReceiveNews extends News
{
    void display(ITunable rcvr)
    {
        // first tune the receiver
        rcvr.tune(NEWS_CHANNEL);

        //receive the news currently available
        String s;
        while((s = rcvr.receive).length != 0)
        {
            .
            .
            .
        }
    }
}
</PRE>

<p>Here, the class <I>ReceiveNews</I> is prepared to receive as an argument to its 
<I>display()</I> method any class that implements the 
<I>tune()</I> and <I>receive()</I> methods to receive 
and display the news. The class <I>TV()</I> could be used if it were prepared to implement 
those two methods:

<p><pre>
class TV extends HouseHoldDevice implements ITunable
{
    void tune(int channel)
    {
        .
        .
        .
    }

    String receive()
    {
        .
        .
        .
    }
}

class NewsRoom
{
    ReceiveNews rcvr = new ReceiveNews();
    TV tv = new TV();

    void work()
    {
        // use the TV to receive the news
        rcvr.display(tv);
    }
}
</PRE>

<p>Here, the class <I>TV</I> extends the class 
<I>HouseHoldDevice</I> in order to inherit the properties necessary to work within the house. At the same time, 
<I>TV</I> implements the <I>ITunable</I> interface by implementing the 
<I>tune()</I> and <I>receive()</I> methods.

<p>The class <I>NewsRoom</I> contains a data member 
<I>rcvr</I> of class <I>ReceiveNews,</I> which it uses to display the news. The method 
<I>NewsRoom.work()</I> calls 
<I>ReceiveNews.display(),</I> passing it a 
<I>TV</I> object. This is allowed because 
<I>ReceiveNews.display()</I> knows that 
<I>TV</I> implements both the <I>tune()</I> and 
<I>receive()</I> methods, since <I>TV</I> implements 
the <I>ITunable</I> interface.

<p>A class that implements an interface, but which doesn't override all of 
the methods of the interface, must be abstract.

</BODY>
</HTML>





