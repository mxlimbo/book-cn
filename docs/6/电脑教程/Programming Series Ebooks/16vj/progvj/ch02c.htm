<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>The I/O Package</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch02b.htm", "ch02d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="95"><H1>The I/O Package</H1></A>

<p>From the programmer's standpoint, the WFC <I>ms.com.wfc.io</I> package consists of two families of classes: the <I>IByteStream </I>family and the <I>IReader/IWriter</I> family. The <I>IByteStream</I> family, which includes the file I/O class <I>File</I>, provides the basic read and write operations and is the more fundamental of the two. The <I>IReader/IWriter</I> family provides the extra features necessary for the manipulation of ANSI text.

<p>Any Java program you want to perform WFC file I/O should import <I>com.ms.wfc.io</I> rather than the conventional <I>java.io</I> package. You should not try to import both the <I>wfc.io</I> and <I>java.io</I> packages in the same program since several classes have the same name in both packages&#8212;for example, the class <I>File</I>.


<A NAME="96"><h2>The <I>IByteStream</I> Family</h2></A>
<p>The most fundamental class in the <I>IByteStream</I> family is the <I>File</I> class, which is demonstrated in the following WFCEcho1 application.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
All the sample applications in this chapter are located in the Windows Applications subfolder on the companion CD.
</blockquote></div>

<A NAME="97"><H3>WFCEcho1</H3></A>

<p>The following program is the WFC equivalent of the Echo1 program presented in Chapter 1. This program relies on the class <I>File</I> to handle all of its I/O needs.

<p><pre>
/**
 * WFCEcho1 - copies the file args[0] to the file args[1]
 *            using the WFC I/O package.
 */
import com.ms.wfc.io.*;

public class WFCEcho1
{
    // standard input and output 
    static File in  = File.openStandardInput();
    static File out = File.openStandardOutput();
    
    /**
     * The main entry point for the application. 
     *
     * @param arg[0] - the input file
     * @param arg[1] - the output file
     */
    public static void main(String[] args)
    {
        // make sure that the user understands what
        // to do
        if (args.length != 2)
        {
            print(&quot;Enter: wfcEcho1 source dest\n&quot;);
            print(&quot;to copy &lt;source&gt; to &lt;dest&gt;\n&quot;);
            System.exit(-1);
        }

        // catch any problems at the bottom of the
        // program - no matter what the problem, we'll
        // output an error message and terminate
        try
        {
            // if the output file exists, make sure it's okay
            // to overwrite it
            okayToCopy(args[1]);
            
            // it's okay, so copy away
            File.copyOver(args[0], args[1]);
        }
        
        // catch any exception thrown
        catch(Exception e)
        {
            print(&quot;Error:&quot; + e.getMessage() + &quot;\n&quot;);
        }
    }
    
    /**
     * Check the argument to see whether it exists, and then
     * whether it's okay to overwrite it. If not, it throws an
     * exception. 
     *
     * @param outputFileName - the file name to overwrite
     */
    private static void okayToCopy(String outputFileName)
        throws Exception
    {
        // first check whether the file exists
        if (File.exists(outputFileName))
        {
            // it does, so check whether it's okay to overwrite it
            print(&quot;File exists. Overwrite? [Y or N]&quot;);
            String answer = read();
            if (!answer.equalsIgnoreCase(&quot;Y&quot;))
            {
                throw new Exception(&quot;Copy failed&quot;);
            }
        }
    }
    
    /**
     * Print a message to standard output.
     * 
     * @param outString - string to output
     */
    private static void print(String s)
    {
        out.writeStringCharsAnsi(s);
    }
  
    /**
     * Read a single character from standard input.
     */
    private static String read()
    {
        // keep reading until we see a character
        char[] cArray = new char[1];
        do
        {
            cArray[0] = (char)in.readByte(); 
        } while(!Character.isLetter(cArray[0]));
        
        // convert the character into a string
        return new String(cArray);
    }
}
</PRE>

<p>If you ignore for a minute the code to write messages to standard output and to read from standard input, the code to perform the actual echo function is simple. First, the <I>File</I> class provides a <I>File.copyOver(src,</I> <I>dest)</I> method that copies the <I>src</I> file to the <I>dest</I> file.

<P>The only logic we have to provide in WFCEcho1 is the <I>okayToCopy()</I> method. Just like its predecessor in the Echo1 program in Chapter 1, <I>okayToCopy() </I>checks whether the destination file exists, and if it does, checks whether it's okay to write over the destination file. The <I>File</I> class makes even this job a little easier. The <I>File.exists(name)</I> method returns <I>true</I> if a file of <I>name</I> exists. Since the <I>exists()</I> method is static, it's not necessary to create a <I>File</I> object before calling its <I>exists()</I> method.


<A NAME="98"><h3>What is <I>File</I>, anyway?</h3></A>
<p>When I'm trying to understand a class, I like to see where it fits in the package hierarchy. Figure 2-1 shows the chain of <I>com.ms.wfc.io</I> classes of which <I>File</I> is a member.

<p><A HREF="javascript:fullSize('F02gh01x.htm')"> <img src="images/F02gh01.JPG" width=404 height=234 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><b>Figure 2-1.</b> <i>The WFC I/O File class hierarchy.</I><!-- /caption -->

<p>You can see that <I>File</I> extends a class called <I>DataStream</I>. Much like the Java standard <I>InputDataStream</I> and <I>OutputDataStream</I> classes, the WFC <I>DataStream</I> class provides formatting capability. This class provides methods to output <I>chars</I>, <I>ints</I>, <I>floats</I>, <I>doubles</I>, and <I>String</I>s as well as <I>bytes</I>. You will also notice that <I>File</I> has two brethren, the <I>BufferedStream</I> and <I>MemoryStream</I> classes. <I>BufferedStream</I> provides a buffering capability, and <I>MemoryStream</I> allows file I/O to a byte array in memory.


<DIV CLASS="NOTE">
<BLOCKQUOTE>
<B>NOTE</B>
<HR>The <I>DataStream</I> class, with its formatting capabilities, is much like the C++ <I>ios</I> class upon which most of the C++ <I>iostream</I> classes are built.
</BLOCKQUOTE>
</DIV>


<A NAME="99"><H3>Interface-based packaging</H3></A>

<p>The WFC package is interface-based, as opposed to other Java packages, which tend to be class-based. For example, notice that the <I>File</I> class extends the <I>DataStream </I>class; <I>DataStream</I> implements the <I>IDataStream</I> interface; and <I>IDataStream</I> in turn extends the interface <I>IbyteStream</I>. The methods of other WFC classes will (almost) never require a <I>File</I> object, or even a <I>DataStream</I> object. Instead, the methods of other classes require an object that implements the <I>IDataStream</I> interface or, more often, the <I>IByteStream</I> interface. Of course, you are free to pass a <I>File</I> object to such a method since the <I>File</I> object implements these interfaces. However, you might want to write your own class to implement one of these interfaces without basing your class on <I>DataStream</I>. This enables you to avoid the excess baggage of inheritance by implementing just those features required by the interface.

<P>
<DIV CLASS="NOTE">
<BLOCKQUOTE>
<B>NOTE</B>
<HR>A class implements an interface using the <I>implements</I> keyword. An interface looks like a class prototype declaration except that it does not have any data members. Implementing an interface represents a promise to provide a function in your class for each of the prototype declarations in the interface. See Appendix A for more details.
</BLOCKQUOTE>
</DIV>

<p>
<DIV CLASS="NOTE">
<BLOCKQUOTE>
<B>NOTE</B>
<HR>Interface names under WFC always begin with a capital I. WFC avoids giving a class a name beginning with I. This makes interface names easy to pick out of a classy crowd.
</BLOCKQUOTE>
</DIV>


<A NAME="100"><h3>Standard I/O with the <I>File </I>class</h3></A>
<p>Notice how the WFCEcho1 program uses the class <I>File</I> to access standard I/O.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
We'll see later in this chapter that the <I>IReader/IWriter</I> group of classes is better for accessing standard I/O.
</blockquote></div>

<p>The public static methods <I>File.openStandardInput()</I> and <I>File.openStandardOutput()</I> return a <I>File</I> object that is tied to the program's standard input and output. The <I>okayToCopy()</I> method in<I> </I>WFCEcho1 defines two local functions that access these standard <I>File</I> objects: <I>print(),</I> which performs output, and <I>read(),</I> which performs input.

<P>
<DIV CLASS="NOTE">
<BLOCKQUOTE>
<B>NOTE</B>
<HR>Like a file class in other languages such as C++, the single WFC class <I>File</I> is capable of both input and output.
</BLOCKQUOTE>
</DIV>

<p>The <I>print()</I> function is straightforward enough. The method <I>File.writeStringCharsAnsi()</I> outputs the <I>String</I> class object in ANSI format as required by the system console. The similarly named method <I>File.writeString()</I> outputs the string in Java's Unicode 16-bit format.

<p>The <I>read()</I> function is slightly more complicated. This function uses the <I>File.readByte()</I> method to read individual keystrokes until it sees a letter. Like <I>File.writeString()</I>, the <I>File.readChar()</I> method reads Java 16-bit Unicode characters that require two 8-bit keystrokes. Therefore, <I>read()</I> calls <I>readByte()</I> instead of <I>readChar()</I>.

<p>The <I>read()</I> function calls <I>readByte()</I> in a loop to read 8-bit characters (bytes) until it sees a character that is a letter. This loop is sort of a kludge: the <I>isLetter()</I> test makes sure that the program isn't confused by some stray carriage return or line feed left in the input buffer from a previous invocation of the program.


<A NAME="101"><h2>The <I>IReader/IWriter</I> Group</h2></A>
<p>The<I> File</I> class looks downright clumsy when it accesses the keyboard for input. This is because <I>File</I> is not designed to handle ANSI input and output. A group of classes that implement the <I>IReader</I> and <I>IWriter</I> interfaces is much more adept at performing text I/O.


<A NAME="102"><H3>WFCEcho2</H3></A>

<p>In the following WFCEcho2 application, the <I>okayToCopy()</I> method is rewritten to use the proper <I>IReader-based</I> and <I>IWriter</I>-based classes. Only the <I>okayToCopy()</I> method is shown here because most of the remainder of the program has not changed. The entire WFCEcho2 application is on the companion CD-ROM.

<p><pre>
    /**
     * Check the argument to see whether it exists, and then
     * whether it's okay to overwrite it. If not, it throws an
     * exception. 
     *
     * @param outputFileName - the file name to overwrite
    */
    private static void okayToCopy(String outputFileName)
        throws Exception
    {
        // first check whether the file exists
        if (File.exists(outputFileName))
        {
            // it does, so check whether it's okay to overwrite it
            Text.out.writeLine(&quot;File exists. Overwrite? [Y or N]&quot;);
            String answer = Text.in.readLine();
            if (!answer.equalsIgnoreCase(&quot;Y&quot;))
            {
                throw new Exception(&quot;Copy failed&quot;);
            }
        }
    }
</PRE>

<p>The first thing you will notice is the absence of the <I>print()</I> method. It has been replaced by a direct call to <I>Text.out.writeLine()</I>. The class <I>Text</I> is a placeholder for the public static members <I>in</I>, <I>out,</I> and <I>err</I>. <I>Text.out</I> is an object of class <I>TextWriter</I> that is tied to standard output. The <I>TextWriter</I> class is ready made to handle ANSI character output to the screen and to the printer through the <I>writeLine()</I> and <I>write()</I> methods. The <I>writeLine()</I> method tacks a newline character onto its output, whereas <I>write()</I> does not.

<P>The <I>TextWriter</I> class, with its superior string-handling methods, is nice. However, the <I>File</I> class did okay in outputting ANSI characters; it was in performing ANSI character input that the <I>File</I> class fell down. The <I>TextReader</I> class is a big improvement over <I>File</I> for reading ANSI text strings. In WFCEcho2, I can use the single call to <I>Text.in.readLine()</I> to return a <I>String</I> object containing the entire line, without resorting to the tricks I had to use in WFCEcho1. The basic logic of the <I>okayToCopy()</I> method is identical to its predecessor.


<A NAME="103"><h3>Where do <I>TextReader</I> and <I>TextWriter</I> fit?</h3></A>
<p>Figure 2-2 shows the hierarchy of the <I>IReader </I>and<I> IWriter</I> groups. The <I>IReader</I> interface defines the methods necessary to perform basic ANSI text output. The abstract class <I>Reader</I> implements these methods without knowing what type of object it is reading from. The concrete class <I>TextReader</I> extends the <I>Reader</I> class to read from a file. An underlying <I>File</I> class data member performs the output. Similarly, the class <I>StringReader</I> reads ANSI text from a Java <I>String</I> class.

<p><A HREF="javascript:fullSize('F02gh02x.htm')"> <img src="images/F02gh02.JPG" width=404 height=194 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><b>Figure 2-2.</b> <i>The hierarchy of the </I>IReader <I>and</I> IWriter<I> groups.</I><!-- /caption -->

<P>
<DIV CLASS="NOTE">
<BLOCKQUOTE>
<B>NOTE</B>
<HR>The relationship between <I>TextReader</I> and <I>Reader</I> isn't unlike that of <I>ifstream</I> and <I>ios</I> in C++, with <I>File</I> playing the role of the C++ <I>filebuffer</I>. <I>TextReader</I> uses <I>Reader</I> to perform formatting chores and <I>File</I> to perform the actual input.
</BLOCKQUOTE>
</DIV>


<p>In a similar vein, the abstract class <I>Writer</I> implements the <I>IWriter</I> interface. The concrete <I>TextWriter</I> class uses the class <I>File</I> to extend <I>Writer</I>'s formatting capabilities to files. <I>StringWriter</I> performs the same trickery on Java strings.


<A NAME="104"><H2>Combining the Two Groups</H2></A>

<p><I>TextReader</I> and <I>TextWriter</I> each provide a simple constructor that takes as input the name of the file to be read or written. These default constructors take care of the chore of creating a <I>File</I> object and storing it away locally. When using these constructors, however, you must be willing to live with these default creation and storage options.

<p>Fortunately, you don't have to live with these default constructors. You can construct the <I>File</I> object yourself and pass the result to the <I>TextReader</I> or <I>TextWriter</I> constructor. This combination gives you the control provided by the <I>File</I> class with the advanced text handling capabilities of the <I>TextReader</I> and <I>TextWriter</I> classes.


<A NAME="105"><H3>WFCEcho3</H3></A>

<p>The WFCEcho3 program demonstrates how to combine the <I>File</I> class with the <I>TextReader </I>and <I>TextWriter</I> classes. Just to prove that we haven't lost any capability when compared with the standard Java <I>io</I> classes, WFCEcho3 performs Echo2's trick of capitalizing each word in the provided text.

<p><pre>
/**
 * WFCEcho3 - copies the file args[0] to the file args[1]
 *            using the WFC I/O package. This time capitalize 
 *            the output (the way we did in Echo2) by extending
 *            the TextWriter class and overriding write(String)
 *            and writeLine(String).
 */
import com.ms.wfc.io.*;

public class WFCEcho3
{
    // class variables
    TextReader  inText;   // used to read the input file
    TextWriter  outText;  // used to write to output file
    
    /**
     * The main entry point for the application. 
     *
     * @param arg[0] - the input file
     * @param arg[1] - the output file
     */
    public static void main(String[] args)
    {
        // make sure that the user understands what
        // to do
        if (args.length != 2)
        {
            Text.out.writeLine(&quot;Enter: wfcecho3 source dest&quot;);
            Text.out.writeLine(&quot;to copy &lt;source&gt; to &lt;dest&gt;&quot;);
            System.exit(-1);
        }

        // catch any problems at the bottom of the
        // program - no matter what the problem, we'll
        // output an error message and terminate
        try
        {
            // copy the file
            WFCEcho3 wfc = new WFCEcho3(args[0], args[1]);
            wfc.copyOver();
        }
        
        // catch any exception thrown
        catch(Exception e)
        {
            Text.out.writeLine(&quot;Error:&quot; + e.getMessage());
        }
    }
    
    /**
     * Open the specified input and output files as Text files.
     * 
     * @param in - name of input file
     * @param out - name of output file
     */
    public WFCEcho3(String in, String out)
        throws Exception 
    {
        // first open the input file and convert
        // it into a TextReader
        File inFile = new File(in, FileMode.OPEN, 
                               FileAccess.READ);
        inText = new TextReader(inFile);
        
        // now the output file - prompt before overwriting
        File outFile = null;
        try
        {
            outFile = new File(out,FileMode.CREATE_NEW, FileAccess.WRITE);
        }
        catch(IOException e)
        {
            okayToOverwrite(out);
            outFile = new File(out, FileMode.CREATE, FileAccess.WRITE);
        }
        outText = new CapTextWriter(outFile);
    }
        
    /**
     * Copy the file one line at a time.
     */
    public void copyOver()
        throws Exception
    {
        // read a line at a time and then
        // write it back out; once we read a
        // null, we've hit end-of-file
        String s;
        while((s = inText.readLine()) != null)
        {
            outText.writeLine(s);
        }
        outText.flush();
    }

    /**
     * Make sure it's okay to overwrite the existing file. 
     *
     * @param outputFileName - the file name to overwrite
     */
    private static void okayToOverwrite(String outputFileName)
        throws Exception
    {
        // prompt the user   
        Text.out.writeLine(&quot;File exists. Overwrite? [Y or N]&quot;);
        String answer = Text.in.readLine();
        if (!answer.equalsIgnoreCase(&quot;Y&quot;))
        {
            throw new Exception(&quot;Copy failed&quot;);
        }
    }
}
</PRE>

<p>Just as in Echo2, this program creates a class object and then uses that object to perform the copy operation in the following two statements:

<p><pre>
// copy the file
WFCEcho3 wfc = new WFCEcho3(args[0], args[1]); 
wfc.copyOver();
</PRE>


<A NAME="106"><H3>The constructor</H3></A>

<p>The <I>WFCEcho3</I> class constructor uses the following statement to create a <I>TextReader</I> object from a manually created <I>File</I> object:

<p><pre>
File inFile = new File(in, FileMode.OPEN, FileAccess.READ);
inText = new TextReader(inFile);
</PRE>

<p>The first argument, <I>in</I>, contains the name of the file to open. The second argument, <I>FileMode.OPEN</I>, says that we want to open an existing file. If the file doesn't exist, it won't be created and an IOException will be thrown. The class <I>FileMode</I> is a placeholder for all of the different mode constants. The third argument, <I>FileAccess.READ</I>, says that we are opening the file in <I>READ</I> mode (as opposed to in <I>WRITE</I> or <I>READWRITE</I> mode). Opening a file in <I>READ</I> mode allows other applications to read the file at the same time. An optional fourth argument uses the <I>FileShare</I> placeholder to specify whether it's okay to share the file with other computers on the LAN. The next line passes the constructed file object to the <I>TextReader(File)</I> constructor.

<p>The following lines from WFCEcho3 create a <I>TextWriter</I> object from a manually generated <I>File</I> object:

<p><pre>
File outFile = null;
try
{
    outFile = new File(out,FileMode.CREATE_NEW, FileAccess.WRITE);
}
catch(IOException e)
{
    okayToOverwrite(out);
    outFile = new File(out, FileMode.CREATE, FileAccess.WRITE);
}
outText = new CapTextWriter(outFile);
</PRE>

<p>This code segment first tries to create a new file in write mode using the <I>CREATE_NEW</I> mode. In <I>CREATE_NEW</I> mode, the constructor throws an exception if the file can't be created, perhaps because it already exists. The <I>WFCEcho3()</I> constructor catches that exception and retries the request using the <I>CREATE</I> mode, if <I>okayToOverwrite()</I> approves. Unlike <I>CREATE_NEW</I>, <I>CREATE</I> will delete the output file if it exists.

<P>The <I>okayToOverwrite()</I> method is identical to its predecessors.


<A NAME="107"><H3>Copying</H3></A>

<p>WFCEcho3 implements its own <I>copyOver()</I> method, which copies the contents of the source file to the destination file. It does this by reading the <I>TextReader</I> object one line at a time using the <I>readLine()</I> function and writing each line out to the <I>TextWriter</I> object using <I>writeLine()</I>. The fact that <I>readLine()</I> strips the newline character at the end of each line is of no consequence because <I>writeLine()</I> compensates by adding a newline character.

<P>The <I>copyOver()</I> method continues to read and write until the <I>String</I> returned by <I>readLine()</I> is a <I>null</I>, indicating that the function has hit the end of the file.

<p>Once control has exited the loop, <I>copyOver()</I> still has one important task to perform. Before returning, <I>copyOver()</I> calls <I>TextWriter.flush()</I>. Both <I>TextReader</I> and <I>TextWriter</I> are buffered, meaning that text is accumulated into conveniently sized blocks to improve program performance. This is particularly important when reading something as small as individual lines from a text file. Calling <I>flush()</I> forces any buffered output to disk. If you forget to call <I>flush()</I>, you are likely to lose the last few bytes of your output.

<p>Alternatively, you can call <I>TextWriter.setAutoFlush(true)</I>. Setting autoflush to <I>true</I> forces <I>TextWriter</I> to flush its buffer after every call to <I>writeLine()</I>. While this will relieve you of the need to call <I>flush()</I>, the increased disk activity will most likely greatly reduce your application's performance.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
Remember to set autoflush to <I>true</I> for small output files or for output files that are not accessed often, or to call <I>flush()</I> at the end to force all output buffers to disk.
</blockquote></div>

<p><I>Text.out</I> flushes the buffer by default. Thus, if you are performing large amounts of output to standard output you probably want to set autoflush to <I>false.</I>


<DIV CLASS="NOTE">
<BLOCKQUOTE>
<B>NOTE</B>
<HR><I>TextWriter</I> doesn't support the C++ <I>iostream</I> equivalent <I>tie()</I>, by which the output file is automatically flushed when the program reads from the &quot;tied&quot; input file.
</BLOCKQUOTE>
</DIV>


<A NAME="108"><H3>Capitalization</H3></A>

<p>If you look more closely at the code snippet from the <I>WFCEcho3</I> constructor, the output <I>File</I> object is used to create a <I>CapTextWriter</I> class rather than a <I>TextWriter </I>class.

<p>The class <I>CapTextWriter</I> extends <I>TextWriter</I> by capitalizing any text passed to its <I>write()</I> or <I>writeLine()</I> method. This class appears in the following code:

<p><pre>
/**
 * CapTextWrite - a TextWriter that capitalizes
 *                output through write(String) or
 *                writeLine(String).
 */
import com.ms.wfc.io.*;

public class CapTextWriter extends TextWriter
{
    String specialChars = &quot; -.;\t\n&quot;;
    
    /**
     * Constructor.
     * 
     * @param outFile - File object to use for output
     */
    public CapTextWriter(File outFile)
    {
        super(outFile);
    }

    /**
     * Write a line of text after capitalizing each word.
     * 
     * @param s - the string to output
     */
    public void writeLine(String s)
    {
        super.writeLine(toUpper(s));
    }
    
    /**
     * Write a line of text after capitalizing each word.
     * 
     * @param s - the string to output
     */
    public void write(String s)
    {
        super.write(toUpper(s));
    }
    
    /**
     * Capitalize the buffer provided.
     *
     * @param s - string to capitalize
     */
    String toUpper(String s)
    {
        // first convert the string into a string buffer
        StringBuffer sb = new StringBuffer(s);
        
        // loop through the new buffer, capitalizing any
        // alphanumeric character that appears after a special
        // character
        boolean cap = true;
        int length = sb.length();
        for (int i = 0; i &lt; length; i++)
        {
            char c = sb.charAt(i);
                
            // if we're supposed to cap this letter&#8230;
            if (cap)
            {
                // and if this is a letter&#8230;
                if (Character.isLetter(c));
                {
                    // then capitalize and restore it
                    c = Character.toUpperCase(c);
                    sb.setCharAt(i, c);
                   
                    // okay, it's done
                    cap = false;
                }
            }
            else
            {
                // (not in cap mode)
                // look for one of the special characters
                cap = (specialChars.indexOf((int)c) != -1);
            }
        }
        
        // now convert that back into a string for output
        return sb.toString();
    }
}
</PRE>

<p>Notice that this class is declared <I>public</I>. Being declared <I>public</I> means this class can be used by any other class that needs capitalization of output. It also means, however, that <I>CapTextWriter</I> must reside in its own <I>CapTextWriter.java</I> file.


<A NAME="109"><H3>Adding a file to your project</H3></A>

<p>To create a new Java file and make it part of an existing project, activate Project Explorer and right-click the project name. From the context menu, select Add, and from the submenu, choose Add Class. Visual J++ will prompt you for the class name. In this case, providing the name <I>CapTextWriter</I> provides you with an empty Java source file and attaches that file to the project.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
Adding a file to the project ensures that the file is recompiled whenever the project is rebuilt and the file has changed.
</blockquote></div>

<p>If the Java file you want to add to the project already exists, select Add from the context menu. Choose Add Class, select the Existing tab, and select the Java file to add.


<A NAME="110"><h3>Converting text to upper case in <I>CapTextWriter</I></h3></A>
<p>The constructor for the <I>CapTextWriter</I> class does nothing more than pass its argument to the base class constructor.

<P>
<DIV CLASS="NOTE">
<BLOCKQUOTE>
<B>NOTE</B>
<HR>When used as a function, <I>super()</I> invokes the base class constructor. When used in this way, <I>super()</I> can be called only from the constructor and it must be the first line of the constructor.
</BLOCKQUOTE>
</DIV>

<p><I>CapTextWriter</I> defines the method <I>toUpper(String)</I> to convert the <I>String</I> passed to it into an equivalent <I>String</I> but with each word capitalized. The <I>toUpper()</I> method uses the same logic as the <I>toUpper()</I> method in the Echo2 program. It first converts the input <I>String</I> into a <I>StringBuffer</I> object. <I>StringBuffer</I> is more efficient to use when you are modifying the text string often. In addition, the <I>StringBuffer</I> class provides the convenient <I>charAt()</I> and <I>setCharAt()</I> methods.

<p>Just as in Echo2, <I>toUpper()</I> loops through each character in the <I>StringBuffer</I> object. If the <I>cap</I> flag is <I>true</I> and the character is a letter, <I>toUpper()</I> converts the character to upper case and writes it back into the <I>StringBuffer</I> object before setting <I>cap</I> to <I>false</I>.

<p>If <I>cap</I> is false, <I>toUpper()</I> uses the <I>String.indexOf()</I> method to compare the retrieved character to a string of characters it knows to be word separators. If the index returned by <I>indexOf()</I> is <I>-1</I>, the character was not one of the separator characters and <I>cap</I> is set to <I>false </I>again. If the index is anything other than <I>-1</I>, the character was a word separator and <I>cap</I> is set to <I>true.</I>

<p>The <I>CapTextWriter</I> class calls <I>toUpper()</I> on the <I>String</I> input. It then overrides the <I>write()</I> and <I>writeLine()</I> methods by calling <I>super.write()</I> and <I>super.writeLine()</I> to perform the actual output<I>.</I>

<P>
<DIV CLASS="NOTE">
<BLOCKQUOTE>
<B>NOTE</B>
<HR>When used in this way, <I>super</I> is a <I>this</I> pointer that has been converted to the current class's base class. Thus, if <I>this</I> is of class <I>CapTextWriter,</I> <I>super</I> points to the current object but is of class <I>TextWriter</I>. The absence of a <I>super</I> pointer in C++ forces the C++ programmer to refer to the base class by name from within the code. This is a source of errors when the base class changes. The Java programmer never has to refer to the base class except in the <I>extends</I> statement.
</BLOCKQUOTE>
</DIV>



<A NAME="111"><H2>Outputting Different Object Types</H2></A>

<p>The <I>Writer</I> class supports the output of various object types. This is demonstrated in the following code.

<p><pre>
/**
 * WriteTest1 - outputs several types of objects
 *              using the Writer class.
 */
import com.ms.wfc.io.*;

public class WriteTest1
{
    /**
     * The main entry point for the application. 
     */
    public static void main (String[] args)
    {
        TextWriter out = Text.out;
        out.setAutoFlush(true);
        
        out.writeLine(&quot;This is a String&quot;);
        out.write(&quot;This is an int = &quot;);
        out.writeLine(10);
        
        out.write(&quot;This is a double = &quot;);
        out.writeLine(10.10);
        
        out.write(&quot;This is a Student = &quot;);
        out.writeLine(new Student(&quot;Jenny&quot;, &quot;Davis&quot;, 12, 3.5));
  
        try
        {
            Thread.currentThread().sleep(2000);
        }
        catch(Exception e)
        {
        }
    }
}

class Student
{
    String firstName;
    String lastName;
    int    semesterHours;
    double gradePointAverage;
    
    Student(String firstName,
            String lastName,
            int    semesterHours,
            double gradePointAverage)
    {
        this.firstName = firstName;
        this.lastName  = lastName;
        this.semesterHours = semesterHours;
        this.gradePointAverage = gradePointAverage;
    }
}
</PRE>

<p>Both <I>write()</I> and <I>writeLine()</I> are overloaded for each of the intrinsic variable types plus <I>String</I> and <I>Object</I>. Providing a <I>writeLine(Object)</I> allows the <I>Student</I> object created in the above example to be passed to <I>writeLine()</I>. However, as you can see in Figure 2-3, the output is not what you might expect.

<P><A HREF="javascript:fullSize('F02gh03x.htm')"> <img src="images/F02gh03.JPG" width=404 height=234 border=0 ALT="Click to view at full size."> </A>

<P><!-- caption --><B>Figure 2-3.</b> <i>The output from 
</I>writeLine(Object)<I> is disappointing.</I><!-- /caption -->

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
The call to <I>sleep()</I> delays the program long enough to allow the user to see the output before the program terminates and the MS-DOS window is closed. This delay isn't necessary when you execute the program from the command line.
</blockquote></div>


<A NAME="112"><h3>Extending <I>writeLine()</I></h3></A>
<p>Fortunately, <I>writeLine(Object)</I> calls <I>Object.toString()</I> to create a string it then passes to <I>writeLine(String)</I>. This means that by overriding the <I>toString()</I> method you can extend <I>writeLine()</I> to output any new class you might define.

<P>The following code snippet from the WriteTest2 example shows <I>Student</I> extended by the addition of a <I>toString()</I> method. Figure 2-4 shows the output from WriteTest2.

<p><pre>
class Student
{
    String firstName;
    String lastName;
    int    semesterHours;
    double gradePointAverage;
    
    Student(String firstName,
            String lastName,
            int    semesterHours,
            double gradePointAverage)
    {
        this.firstName = firstName;
        this.lastName  = lastName;
        this.semesterHours = semesterHours;
        this.gradePointAverage = gradePointAverage;
    }
    
    public String toString()
    {
        StringWriter sw = new StringWriter();
        sw.write(lastName + &quot;, &quot; + firstName);
        sw.write(&quot; - &quot; 
                 + gradePointAverage + &quot;/&quot; 
                 + semesterHours
                 + &quot; [GPA/semesterHours]&quot;);
        return new String(sw.getStringBuffer());
    }
}
</PRE>

<p><A HREF="javascript:fullSize('F02gh04x.htm')"> <img src="images/F02gh04.JPG" width=404 height=234 border=0 ALT="Click to view at full size."> </A>

<P><!-- caption --><B>Figure 2-4.</b> <i>The output from </I>writeLine(Object)<I> with </I>Student.toString()<I> added.</I><!-- /caption -->


</BODY>
</HTML>




