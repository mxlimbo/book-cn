<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>WFC-Style Controls</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch13a.htm", "ch13c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="432"><H1>WFC-Style Controls</H1></A>

<p>Let's write a new control that we'll call WeightEdit. This control will look like an Edit control, but it will include a new property, <I>weight</I>. The <I>weight</I> property will have three possible values: Light, Normal, and Bold. Initially, we'll require the user to enter an integer value to indicate his or her preference: <I>0</I> for Light, <I>1</I> for Normal, and <I>2</I> for Bold. Any other value will be ignored. Later on, we'll be sophisticated enough to offer the user a drop-down menu from which to choose the values <I>Light</I>, <I>Normal</I>, and <I>Bold</I>.

<p>To keep things simple, the WeightEdit control will support only a single line of text, and the other properties of the Edit control won't be supported. (Later in this chapter, you'll find out how you can waive this restriction.)

<A NAME="433"><H2>The Integer WeightEdit Control</H2></A>

<p>Let's begin with the integer-based WeightEdit<I> </I>control. The plan is first to create a form for our WeightEdit<I> </I>control. After that, we'll need to define the <I>weight</I> property and add an <I>onPaint()</I> method capable of displaying the value of the <I>text</I> property in a Light, Normal, or Bold font, based on the value of <I>weight</I>. In this initial version of our WeightEdit control, the <I>weight</I> property will contain an integer value.

<p>We'll add the <I>weight</I> property to the Properties window to allow the application programmer to set the value of this newly created property at design time. To complete the WeightEdit control, we'll add an edit capability to allow the user to modify the text displayed in the control.

<p>To demonstrate our WFC-style WeightEdit control, we'll add it to the Toolbox and then use it in a test application.

<A NAME="434"><H3>Creating the control framework using the Control Wizard</H3></A>

<p>Begin by choosing New Project from the Visual J++ File menu. Select Components from the Visual J++ Projects folder in the left pane of the New Project window. From there, select Control in the right pane and name the project WeightEdit . Your window should look like the one shown in Figure 13-1.

<p>Once your window looks like the one in Figure 13-1, click Open to create the project for the WeightEdit control. Opening the project using the Project Explorer reveals a single file with the rather nondescriptive name Control1.java. Double-clicking this file opens a form much like the one that the Windows Application Wizard generates. Close the form before proceeding to the next section.


<p><A HREF="javascript:fullSize('f13gh01x.htm')"> <img src="images/f13gh01.jpg" width=404 height=249 border=0 ALT="Click to view at full size."> </A>
<p><!-- caption --><b>Figure 13-1.</b> <i>You can create a WFC-style control by starting the Control Wizard from the New Project window.</i><!-- /caption -->

<A NAME="435"><H3>The Code</H3></A>

<p>To open the Control1.java file, select Code from the View menu. You'll notice three significant differences between this source file and the source files that we have seen in previous chapters:

<UL>
<p><li> There is no <I>main()</I> method because this file is intended never to run by itself, but always to run as part of a larger program
<p><li> An ActiveX-style globally unique identifier (GUID) appears commented out as the last line of <I>Control1</I>'s header comments.
<p><li> The class <I>Control1</I> extends the class <I>UserControl,</I> rather than extending the class <I>Form</I> as a Windows EXE program would. The class <I>UserControl</I> extends the class <I>Control</I>, so any new class we create that extends <I>UserControl </I>will be a WFC-style control.
</UL>

<p>The GUID is a number that would uniquely identify this control were we to convert it into an ActiveX component. Because we plan to leave WeightEdit as a WFC-style control, however, we can leave the GUID commented out.

<A NAME="436"><H3>Creating the WeightEdit framework</H3></A>

<p>Rather than stick with the name Control1.java, let's rename the file to match the name of the project. First close the source listing. Now rename Control1.java<I> </I>by right-clicking the file in the Project Explorer window and choosing Rename. Change Control1.java to WeightEdit.java.

<p>Open the WeightEdit file again. Within the source file window, rename the class <I>WeightEdit</I>. Change the name of the constructor to match. Also change the line <I>this.setText(&quot;Control1&quot;)</I> in the <I>initForm()</I> method to <I>this.setText(&quot;WeightEdit&quot;)</I>. Save the file.

<p>Double-click WeightEdit in Project Explorer to open the control in the Forms Designer. The title bar of the Forms Designer will have the title WeightEdit.java [Form]. This form will be the basis of our new control.

<p>Because our WeightEdit control supports only a single line of text, resize the form to the height of a normal font (or slightly larger) and to the length of about half that of the default length of the Forms Designer window. The actual size is unimportant because the final WeightEdit control will be resizable. Leave the remaining properties in the Properties window at their default values.

<p>The resulting code so far should look like this:

<p><pre>
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;

/**
 * This class is a visual component. The entry point for class execution
 * is the constructor.
 * 
 * This class can be used as an ActiveX control. Check the checkbox 
 * for this class on the Project Properties COM Classes tab, or remove 
 * the // from the next line:
// * @com.register ( clsid=xxx, typelib=xxx )
 */
public class WeightEdit extends UserControl
{
    public WeightEdit()
    {
        // Required for Visual J++ Form Designer support
        initForm();

        // TODO: Add any constructor code after initForm call
    }

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
    Container components = new Container();

    private void initForm()
    {
        this.setSize(new Point(267, 28));
        this.setText(&quot;WeightEdit&quot;);
    }
    // NOTE: End of form designer support code

    public static class ClassInfo extends UserControl.ClassInfo
    {
        // TODO: Add your property and event infos here
    }
}
</PRE>

<p>Notice that the <I>clsid</I> and <I>typelib</I> values have been replaced with <I>xxx</I> in this listing because these values are unique for each instance of <I>WeightEdit</I>.

<p>To make sure that everything still works, build the project. No errors should occur. (Of course, our control doesn't do anything yet!)

<A NAME="437"><h3>Defining the <I>weight</I> property</h3></A>
<p>To support the <I>weight</I> property, we'll need to define an integer data member named <I>weight</I> within the <I>WeightEdit</I> class. For convenience, let's add three constants representing the three legal values of <I>weight</I>. Set <I>LIGHT </I>to <I>0</I>, <I>NORMAL </I>to <I>1</I>, and <I>BOLD </I>to <I>2</I>. Add the following code to the <I>WeightEdit</I> class to define the <I>weight</I> property:

<p><pre>
public class WeightEdit extends UserControl
{
    // the different legal values of weight
    private final static int LIGHT  = 0;
    private final static int NORMAL = 1;
    private final static int BOLD   = 2;
    
    // the weight control value - start with weight NORMAL
    private int weight = NORMAL;
    
    public WeightEdit()
    {
    .
    .
    .
}
</PRE>

<A NAME="438"><H3>Displaying text using the proper weight</H3></A>

<p>To change the way an object displays text, we'll need to write our own <I>onPaint()</I> method using the font weight specified by the local <I>weight</I> value. (For now, let's not worry about how the <I>weight</I> value is updated.) The following <I>onPaint()</I> method&#8212;added to our <I>WeightEdit</I> class&#8212;paints text using our <I>weight</I> value:

<p><pre>
    // handle changes to the control
    protected void onPaint(PaintEvent pe)
    {
        Graphics g = pe.graphics;

        // set the font for the display
        Font f = this.getFont();
        int w;
        switch(weight)
        {
            case LIGHT: w = FontWeight.EXTRALIGHT;
                        break;
            case BOLD:  w = FontWeight.BOLD;
                        break;
            default:    w = FontWeight.NORMAL;
        }
        
        Font fw = new Font(f, w, false, false, false);
        g.setFont(fw);
        
        // get the text to display
        String s = this.getText();
        
        // draw text in the middle of a rectangle
        // of the specified size
        Rectangle r = getClientRect();
        g.drawString(s, r, 
                     TextFormat.HORIZONTALCENTER|
                     TextFormat.VERTICALCENTER);
    }
</PRE>

<p>This <I>onPaint()</I> method starts just as any other <I>onPaint() </I>method does, by retrieving the <I>Graphics</I> object from the <I>PaintEvent</I>. From there, this method sets the value <I>w </I>to the appropriate font weight, depending on the weight values specified by the <I>weight</I> property. A new font, <I>fw</I>,<I> </I>is created from the existing font but with the new font weight. The <I>Graphics</I> object is then updated with this font using the method <I>setFont()</I>.

<p>The call to <I>Control.getText() </I>retrieves the current string. The <I>onPaint()</I> method then displays the text in the middle of the rectangle specified by the size of the <I>WeightEdit </I>control.

<A NAME="439"><H3>Saving the user-entered text</H3></A>

<p>Fortunately, the <I>Control</I> class has a <I>text</I> property. Although the <I>text</I> property means different things to different types of controls, we can use this property to save the text the user entered. As we saw in the <I>onPaint()</I> method, the <I>Control</I> class contains a <I>getText()</I> method that we can use without customizing it. However, we'll need to override the <I>setText()</I> method to add a call to <I>invalidate().</I> The method <I>invalidate()</I> will force the new text string to be repainted with our <I>onPaint()</I> method, which reflects the weight factor. We'll also want to override the <I>onResize()</I> method to repaint the text, to keep the user-entered text in the middle of the control's area:

<p><pre>
    /**
     * Display the string again whenever it changes.
     */
    public void setText(String s)
    {
        super.setText(s);
        
        invalidate();
    }
    
    /**
     * Repaint the window when it is resized.
     */
    protected void onResize(Event e)
    {
        super.onResize(e);
        invalidate();
    }
</PRE>

<A NAME="440"><H3>Updating the weight value</H3></A>

<p>It's all very nice to define a <I>weight</I> property, but a property isn't much use if the user can't set it. To allow the user to set the property, add the following access methods:

<p><pre>
    //---------the following defines the property methods----
    
    /**
     * Return the font weight.
     */
    public int getWeight()
    {
        return weight;
    }
    
    /**
     * Set the font weight.
     */
    public void setWeight(int w)
    {
        // if the new font weight is valid&#8230;
        if (w &gt;= LIGHT &amp;&amp; w &lt;= BOLD)
        {
            // update the weight
            this.weight = w;
        }
        
        // make sure the display is updated with the
        // current weight
        this.invalidate();
    }

    /**
     * Reset the weight to its default value.
     */
    public void resetWeight()
    {
        weight = NORMAL;
    }
</PRE>

<p>The Visual J++ 6 property editor uses access methods that follow the pattern <I>getX()</I> and <I>setX()</I> to access the property <I>x</I>. The <I>resetX()</I> method sets the initial value of the <I>x</I> property.

<A NAME="441"><H3>Adding weight to the property editor</H3></A>

<p>If you look toward the bottom of the WeightEdit source file, you'll see an inner class named <I>ClassInfo</I>. This class is the key to adding a property or set of properties to the property editor. Update the <I>ClassInfo</I> class as follows:

<p><pre>
    public static class ClassInfo extends UserControl.ClassInfo
    {
        // add our property to the property list
        public static final PropertyInfo weightProperty
            = new PropertyInfo
                              (
                               WeightEdit.class,
                               &quot;weight&quot;,
                               int.class
                               );
        public void getProperties(IProperties props)
        {
            super.getProperties(props);
            props.add(weightProperty);
        }
      }
</PRE>

<p>The first line defines a static data member of class <I>PropertyInfo</I>. This object ties the property named <I>weight</I> to the current class file, WeightEdit.class, and defines this property to be of type <I>int</I>. This object definition tells the property editor the name to display in the Properties window (<I>weight</I>), the name of the class <I>(WeightEdit</I>) that contains the <I>getWeight()</I> and <I>setWeight()</I> methods, and the type of the <I>weight</I> property (<I>int</I>).

<p>The class <I>ClassInfo</I> overrides the method <I>getProperties()</I>. The <I>getProperties()</I> method is what the property editor calls to find the properties to display in the Properties window. This new version of <I>getProperties()</I> starts by retrieving the previously defined properties through the call to <I>super.getProperties()</I>. To this list of properties, <I>getProperties()</I> adds the newly created property <I>weightProperty</I>.

<A NAME="442"><H3>Supporting user input</H3></A>

<p>So far, what we've really defined is a control equivalent to a label. We now need to add some code that will allow the user to edit the control.

<P>Open <I>WeightEdit</I> in the Forms Designer. Select the WeightEdit control, and in the Properties window double-click the active properties <I>keyPress</I>, c<I>lick</I>, <I>mouseEnter</I>, and <I>mouseLeave</I>. Update the resulting event handlers as follows:

<p><pre>
// ----the following code creates the actual property editor---

    // maintain a flag indicating whether the user has clicked
    // within the control and whether or not the mouse is still there     
    boolean selected = false;
    boolean clicked = false;
    private static final char BACKSPACE = (char)8;
    
    /**
     * Process the keypress by adding the key to the
     * displayed text if the control is currently active.
     */
    private void WeightEdit_keyPress(Object source, KeyPressEvent e)
    {
        // if the object is selected&#8230;
        if (clicked)
        {
            // then update the string
            String s = this.getText();
            char c = e.getKeyChar();
            if (c == BACKSPACE)
            {
                int length = s.length();
                s = s.substring(0, length - 1);
            }
            else
            {
                s = s + c;
            }
            setText(s);
        }
    }

    /**
     * If the mouse is within the control,
     * then set the clicked flag.
     */
    private void WeightEdit_click(Object source, Event e)
    {
        if (selected)
        {
            clicked = true;
        }
    }

    /**
     * Set the selected flag, indicating that the mouse is
     * within the area of the control.
     */
    private void WeightEdit_mouseEnter(Object source, Event e)
    {
        selected = true;
    }

    /**
     * Clear the selected and clicked flags as the mouse leaves
     * the control to indicate that the control is no longer active.
     */
    private void WeightEdit_mouseLeave(Object source, Event e)
    {
        selected = false;
        clicked = false;
    }
</PRE>

<p>Let's start our discussion of the preceding code with the <I>WeightEdit_mouseEnter()</I> method. The <I>WeightEdit_mouseEnter() </I>method is called when the mouse pointer enters the area designated as the WeightEdit control. This method sets the <I>selected</I> data member to <I>true</I>, indicating that the mouse pointer is within the control. The method <I>WeightEdit_mouseLeave()</I> is invoked when the mouse pointer leaves the control. This method sets <I>selected</I> to <I>false</I> to indicate that the mouse pointer has left the WeightEdit control. (It also sets <I>clicked</I> to <I>false</I>, but we won't go over the significance of that until later in this discussion.)

<p>When the user clicks the mouse, the method <I>WeightEdit_click</I> first checks the flag <I>selected</I>. If this flag is set to <I>true</I>, the method sets the flag <I>clicked</I> to <I>true</I>. Thus, the <I>clicked</I> flag is set to <I>true</I> when the mouse is clicked within the control and the mouse pointer has yet to leave the area of the control.

<p>The <I>WeightEdit_keyPress()</I> method is invoked when the user presses a key. If the <I>clicked</I> flag isn't set, the key input is ignored. If <I>clicked</I> is set, <I>WeightEdit</I> processes the character. This control is a very simple editor (hardly worthy of the name editor): any character entered is appended to the string no matter where the user clicks within the WeightEdit control. The only character that gets special attention is the Backspace key, which deletes the last character in the string, again regardless of where the user clicks within the control. (The point of this editor is to show you the principles of creating a control. We don't want to get bogged down in detailed editor code.)

<p>The string created by <I>WeightEdit_keyPress()</I> is displayed in the WeightEdit editor control by calling <I>setText()</I>. Keep in mind that our overriding <I>setText()</I> method updates the <I>text</I> field in the <I>Control</I> class before invalidating the display, so that the <I>onPaint()</I> method displays the resulting string to the user.

<A NAME="443"><H3>Viewing the total result</H3></A>

<p>In case you're confused, I'll show you the entire WeightEdit listing here:

<p><pre>
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;

import com.ms.lang.*;

/**
 * The WeightEdit class extends Control by adding the
 * weight property. 
// * @com.register ( clsid=xxx, typelib=xxx )
 */
public class WeightEdit extends UserControl
{
    // the different legal values of weight
    private final static int LIGHT  = 0;
    private final static int NORMAL = 1;
    private final static int BOLD   = 2;
    
    // the weight control value - start with weight NORMAL
    private int weight = NORMAL;
    
    public WeightEdit()
    {
        // Required for Visual J++ Form Designer support
        initForm();
    }

    /**
     * Display the string again whenever it changes.
     */
    public void setText(String s)
    {
        super.setText(s);
        
        invalidate();
    }
    
    /**
     * Repaint the window when it is resized.
     */
    protected void onResize(Event e)
    {
        super.onResize(e);
        invalidate();
    }
    
    /**
     * Reflect the weight property.
     */
    // handle changes to the control
    protected void onPaint(PaintEvent pe)
    {
        Graphics g = pe.graphics;

        // set the font for the display
        Font f = this.getFont();
        int w;
        switch(weight)
        {
            case LIGHT: w = FontWeight.EXTRALIGHT;
                        break;
            case BOLD:  w = FontWeight.BOLD;
                        break;
            default:    w = FontWeight.NORMAL;
        }
        
        Font fw = new Font(f, w, false, false, false);
        g.setFont(fw);
        
        // get the text to display
        String s = this.getText();
        
        // draw text in the middle of a rectangle
        // of the specified size
        Rectangle r = getClientRect();
        g.drawString(s, r, 
                     TextFormat.HORIZONTALCENTER|
                     TextFormat.VERTICALCENTER);
    }

    //---------the following defines the property methods----
    
    /**
     * Return the font weight.
     */
    public int getWeight()
    {
        return weight;
    }
    
    /**
     * Set the font weight.
     */
    public void setWeight(int w)
    {
        // if the new font weight is valid&#8230;
        if (w &gt;= LIGHT &amp;&amp; w &lt;= BOLD)
        {
            // then update the weight
            this.weight = w;
        }
        
        // make sure the display is updated with the
        // current weight
        this.invalidate();
    }

    /**
     * Reset the weight to its default value.
     */
    public void resetWeight()
    {
        weight = NORMAL;
    }

    // ----the following code creates the actual property editor---

    // maintain a flag indicating whether the user has clicked
    // within the control and whether or not the mouse is still there    
    boolean selected = false;
    boolean clicked = false;
    private static final char BACKSPACE = (char)8;
    
    /**
     * Process the keypress by adding the key to the
     * displayed text if the control is currently active.
     */
    private void WeightEdit_keyPress(Object source, KeyPressEvent e)
    {
        // if the object is selected&#8230;
        if (clicked)
        {
            // update the string
            String s = this.getText();
            char c = e.getKeyChar();
            if (c == BACKSPACE)
            {
                int length = s.length();
                s = s.substring(0, length - 1);
            }
            else
            {
                s = s + c;
            }
            setText(s);
        }
    }

    /**
     * If the mouse is within the control, 
     * set the clicked flag.
     */
    private void WeightEdit_click(Object source, Event e)
    {
        if (selected)
        {
            clicked = true;
        }
    }

    /**
     * Set the selected flag, indicating that the mouse is
     * within the area of the control.
     */
    private void WeightEdit_mouseEnter(Object source, Event e)
    {
        selected = true;
    }

    /**
     * Clear the selected and clicked flags as the mouse leaves
     * the control to indicate that the control is no longer active.
     */
    private void WeightEdit_mouseLeave(Object source, Event e)
    {
        selected = false;
        clicked = false;
    }

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
    Container components = new Container();

    private void initForm()
    {
        this.setBackColor(Color.CONTROL);
        this.setSize(new Point(235, 28));
        this.setText(&quot;&quot;);
        this.addOnClick(new EventHandler(this.WeightEdit_click));
        this.addOnKeyPress(
              new KeyPressEventHandler(this.WeightEdit_keyPress));
        this.addOnMouseEnter(
              new EventHandler(this.WeightEdit_mouseEnter));
        this.addOnMouseLeave(
              new EventHandler(this.WeightEdit_mouseLeave));
    }
    // NOTE: End of form designer support code

    /**
     * Add weight to the properties defined for this control.
     */
    public static class ClassInfo extends UserControl.ClassInfo
    {
        // add our property to the property list
        public static final PropertyInfo weightProperty
            = new PropertyInfo
                              (
                               WeightEdit.class,
                               &quot;weight&quot;,
                               int.class
                               );
        public void getProperties(IProperties props)
        {
            super.getProperties(props);
            props.add(weightProperty);
        }
      }
}
</PRE>

<A NAME="444"><H3>Adding the WeightEdit control to the Toolbox</H3></A>

<p>Once you've compiled the <I>WeightEdit</I> class, you must still add the control to the Toolbox before other programs can use it. Before closing <I>WeightEdit</I>, select the General section in the Toolbox. (You can put the WeightEdit tool in any section of the Toolbox, but I prefer to place newly created tools within the General area.)

<p>Right-click within the Toolbox, and choose Customize Toolbox. Select the WFC Controls tab in the Customize Toolbox window. You'll see a list of WFC controls that you can add to the Toolbox. Controls that are checked already appear in the Toolbox. These are the WFC controls that you've been using in the examples in this book up until now.

<p>Scroll toward the bottom of the list. Somewhat remarkably (at least to me), there it is, our WeightEdit control, at the bottom of the list. Select the check box next to the WeightEdit entry as shown in Figure 13-2, then choose OK to add the control to the Toolbox. (It will appear in the Toolbox as an outline of a WFC-style control icon&#8212;without a target program, this control and all others are not selectable.)

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
If the control doesn't appear in the Customize Toolbox window, try closing the WeightEdit solution by choosing Close All from the File menu and then reloading the solution.
</blockquote></div>

<p><A HREF="javascript:fullSize('f13gh02x.htm')"> <img src="images/f13gh02.jpg" width=404 height=280 border=0 ALT="Click to view at full size."> </A>
<p><!-- caption --><B>Figure 13-2.</b> <i>The Customize Toolbox window shows our WeightEdit control being added to the Toolbox.</I><!-- /caption -->

<p><div class="note"><blockquote>
<b>Handling Errors in User-Defined Controls</b><hr>I've found that changes to a user-defined control often don't take effect until the project containing the control has been closed and reopened. I've also found that if I've made a mistake in creating a control such as WeightEdit, I might not discover it until I've tried to use the control in an application. The most common error that occurs in creating user-defined controls is forgetting to provide both a <I>getX()</I> and a <I>setX()</I> method, or providing one that is declared incorrectly (for example, declaring a <I>void</I> <I>setX()</I> method instead of the correct <I>void</I> <I>setX(int)</I>). Unfortunately, if you do have such an error when using a user-defined control, the Forms Designer gets confused and removes the declaration from the form's <I>initForm()</I> method.

<p>For example, let's say that your <I>initForm()</I> method originally looked like this:

<p><pre>
Control control = new Control();
WeightEdit weightEdit1 = new WeightEdit();
void initForm()
{
    .
    .
    .
}
</PRE>

<p>After the usage error, your form code will look like this:

<p><pre>
Control control = new Control();
void initForm()
{
    .
    .
    .
}
</PRE>

<p>The references to <I>weightEdit1</I> within the <I>initForm()</I> code remain, however, so not only does the application code not compile but you can't even open the form in the Forms Designer. (You get this &quot;helpful&quot; message: &quot;Unable to show the form designer&#8230;Fix the error, and then try to view the form again.&quot;)

<p>Thus, if you make a mistake in your user-defined control, you'll need to take three steps to fix the error:
<OL>
<p><li> Fix the problem in the user-defined control code.
<p><li> Close and reopen the project containing the control.
<p><li> Add the declaration of the user-defined control object back into the <I>initForm()</I> code.
</OL>

<p>Using this round about-solution, you'll be able to fix any problems that arise in the code generated by the Forms Designer.
</blockquote></div>

<A NAME="445"><H3>Using the WeightEdit control within the Forms Designer </H3></A>

<p>To add the WeightEdit control to a program, you'll first need to create a program. With the WeightEdit solution still open, choose Add Project from the File menu, and then select Windows Application. Enter the name <I>WeightEditTest</I>, make sure the Add To Current Solution option is selected, and choose Open. You've just added a new project to the solution.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
A solution consists of one or more projects. Each of these projects acts as an independent program, with one exception: Only one project can contain the <I>main()</I> method with which to start. You must indicate which project contains this method by using the Project Properties dialog box.
</blockquote></div>

<p>Open the WeightEditTest project in Project Explorer to reveal a conventional Windows executable-style Form1.java file. Double-click this file to open the form in the Forms Designer.

<p>Once you've opened the form, return to the General section of the Toolbox. Notice that WeightEdit is now available. Drop a WeightEdit control onto the form. The resulting form window should look like the one shown in Figure 13-3.

<p><img src="images/f13gh03.jpg" width=377 height=224 border="0">
<p><!-- caption --><B>Figure 13-3.</b> <i>The WeightEdit control looks like this in an application.</I><!-- /caption -->

<p>Now open the Properties window, and select the WeightEdit control. Notice that the <I>text</I> property displays the default display text for the control. Also notice the appearance of our newly added <I>weight</I> property with the initial value of <I>1</I>. (The default of 1 came from the control's <I>resetWeight()</I> method.) The Properties window with these settings is shown in Figure 13-4.

<p>The <I>text</I> property in the Properties window is synchronized with the text displayed within the WeightEdit control. To demonstrate this synchronization, click the WeightEdit control on the form and begin typing. (Be sure to leave the mouse pointer within the control while you're typing.) Notice that the <I>text</I> property within the Properties window automatically updates. Now click the <I>text</I> property and type something new. Notice that the contents of the WeightEdit control update as you type. This automatic updating is a direct result of using the <I>getText()</I> and <I>setText()</I> methods of the <I>Control</I> class to retrieve and update the text.

<p><img src="images/f13gh04.jpg" width=239 height=442 border="0">
<p><!-- caption --><B>Figure 13-4.</b> <i>The Properties window shows an updated </I>text<I> property and the new </I>weight<I> property.</I><!-- /caption -->

<p>While still in the Forms Designer, and with the WeightEdit control selected, set the <I>weight</I> property in the Properties window to <I>2</I>. The display immediately converts to Bold. Now set the value to <I>0</I>, and the display turns to Light. (Some display drivers can't display the text with a Light font type to look any different than text with a Normal font type.)

<A NAME="446"><H3>Using the WeightEdit control</H3></A>

<p>Set the WeightEdit control to whatever initial text and weight you prefer. Now compile the Form1 application. We're going to run the application from within the integrated development environment (IDE), but first you must tell Visual J++ which project within the solution contains the application. Point at the WeightEditTest project in Project Explorer, and hold down the right mouse button. From the drop-down menu, choose Set As StartUp Project.

<p>When you run WeightEditTest, you'll see a WeightEdit control appearing within the form with the text you entered at the weight you specified in the Properties window. Click the text with the mouse pointer, and begin typing (or hitting the Backspace key) with the mouse pointer still at the position where you clicked. Whatever you type is appended to the text. (Remember that the text is appended to the end no matter where in the string you click. I warned you this control wasn't much of an editor, but it does demonstrate the principles of creating and using a user-defined control.)

<p>Figure 13-5 shows the program with text displayed in the WeightEdit control in the middle of the form.

<p><img src="images/f13gh05.jpg" width=372 height=160 border="0">
<p><!-- caption --><b>Figure 13-5.</b> <i>The WeightEditTest program runs with our newly defined WeightEdit control.</i><!-- /caption -->

<A NAME="447"><H3>Making the WeightEdit control available in other solutions</H3></A>

<p>The WeightEdit<I> </I>control was available to WeightEditTest from within the IDE because the two were built together as part of the same project. It would be clumsy if we had to include the WeightEdit project within a solution every time we wanted to use the control. In addition, if you attempt to run the test application by double-clicking the WeightEditTest.exe file, you'll notice that the program fails and displays an error message indicating that it couldn't find the WeightEdit.class files.

<p>When a Visual J++ application begins, it looks in a number of different places for the .class files needed to run Toolbox controls. It always looks in the current directory first. If it doesn't find the .class files there, it next looks in the directory \Windows\Java\Classes.

<p>Copy the two .class files from the WeightEdit directory to the \Windows\Java\Classes directory. WeightEditTest.exe now runs properly directly from Windows or from the IDE. In addition, you can now remove the WeightEdit project from the common solution we've been working with, and recompile and run the result. WeightEditTest continues to run from the IDE even without WeightEdit in the same solution.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
You'll find this version of the WeightEdit control on the companion CD in the subdirectory Custom Controls\Integer WFC-Style WeightEdit. 
</blockquote></div>

<A NAME="448"><H2>The Enumerated WeightEdit Control</H2></A>

<p>As neat as the integer version of the WeightEdit control is, it would be that much better if the user were provided with the options <I>Light</I>, <I>Normal</I>, and <I>Bold</I> rather than the integer values <I>0</I>, <I>1</I>, and <I>2</I>. In this section, we'll change the integer version of the WeightEdit control so that it uses an enumerated <I>weight</I> property.

<A NAME="449"><h3>Exposing the <I>weight</I> property values</h3></A>
<p>In the integer version of the WeightEdit control, we defined the different legal values of the <I>weight</I> property in a set of <I>static final</I> integers that were private to the <I>WeightEdit</I> class. By being private, no outside program could access these values.

<p>To make the weight constants available to the Properties window, we'll need to make these properties public. Even this isn't enough. The class that contains the properties must also extend the class <I>Enum</I>.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
Recall that the class <I>Enum</I> provides enumerated sequences of values.
</blockquote></div>

<p>Because the enumerated weight<I> </I>class must be declared public, and because two public classes can't reside in the same source file, we'll need to create a separate Visual J++ source file in the WeightEdit project. To create a new public class under the WeightEdit project, choose Add Class from the Project menu and name this new class <I>WeightValues</I> (though the name isn't really important).

<p>Open the new class in Visual J++, and append the <I>extends</I> <I>Enum</I> statement to the class declaration. You'll need to import <I>com.ms.wfc.core.Enum</I> to gain access to the <I>Enum</I> class. Now move the weight constants that were defined in the <I>WeightEdit</I> class to this new class and change their declarations from private to public. In addition, add the public static method <I>valid()</I>.<I> </I>This new method returns <I>true</I> if the integer passed to it is a legal weight value and <I>false</I> otherwise. The Properties window and user programs use this method to filter out illegal input from the user.

<p>Once you're finished, the <I>WeightValues</I> class should look like this:

<p><pre>
import com.ms.wfc.core.Enum;

/**
 * Define the names of the different weights.
 */
public class WeightValues extends Enum
{
    // the different legal values of weight
    public final static int LIGHT  = 0;
    public final static int NORMAL = 1;
    public final static int BOLD   = 2;
    
    public static boolean valid(int i)
    {
        return (i &lt;= LIGHT) &amp;&amp; (i &lt;= BOLD);
    }
}
</PRE>

<A NAME="450"><h3>Making changes to the <I>WeightEdit</I> class</h3></A>
<p>All references within the <I>WeightEdit</I> class to these constants must now be changed to refer to this class. For example, you must change the previous reference to <I>NORMAL</I> (or 1) to <I>WeightValues.NORMAL</I>. You can also use the new <I>valid()</I> method to replace the line <I>if (w &gt;= LIGHT &amp;&amp; w &lt;= BOLD)</I> in the <I>setWeight()</I> method with the line <I>if (WeightValues.valid(w))</I>.

<p>The only other change we need to make is to the <I>PropertyInfo</I> object within the <I>WeightEdit</I> class. You must edit the <I>ClassInfo</I> inner class to appear as follows:

<p><pre>
    public static class ClassInfo extends UserControl.ClassInfo
    {
        // add our property to the property list
        public static final PropertyInfo weightProperty
            = new PropertyInfo
                              (
                               WeightEdit.class,
                               &quot;weight&quot;,
                               WeightValues.class
                               );
        public void getProperties(IProperties props)
        {
            super.getProperties(props);
            props.add(weightProperty);
        }
      }
</PRE>

<p>Nothing has changed within <I>ClassInfo,</I> other than the fact that the <I>weightProperty</I> declaration now refers to <I>WeightValues.class</I> for the type of values to expect rather than to <I>int.class</I>. The class passed to the <I>PropertyInfo</I> constructor is where the property editor looks to find the names of the enumerated constants.

<A NAME="451"><H3>Using the enumerated WeightEdit control</H3></A>

<p>Return to the Toolbox, and remove the WeightEdit control by right-clicking it and selecting Delete Item. (Don't worry, the file won't be deleted.) Now recompile the entire solution. (The WeightEditTest project will be recompiled, too, which is unnecessary but doesn't hurt.) Close the solution, and reopen it to make the changes take effect.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
Keep in mind that you might need to close the solution and reopen it before changes to user-defined controls take effect..
</blockquote></div>

<p>Reopen the <I>WeightEditTest</I> class in the Forms Designer. Select the Properties window, and then select the WeightEdit control. (If you've deleted the control, just add it to the form again.) If you examine the <I>weight</I> property, rather than seeing the value <I>1</I>, as you did before, you'll see the enumerated value <I>Normal</I>.<I> </I>Even better, if you select the <I>weight</I> property, a drop-down list that displays the valid values for <I>weight</I> in text form appears, as shown in Figure 13-6. Other than that, the enumerated WeightEdit control works exactly the same as the integer WeightEdit control.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
You'll find this version of the WeightEdit control on the companion CD in the subdirectory Custom Controls\Enumerated WFC-Style WeightEdit.
</blockquote></div>

<p><img src="images/f13gh06.jpg" width=239 height=442 border="0">
<p><!-- caption --><b>Figure 13-6.</b> <i>Enumerated weight values are passed on to the Properties window.</i><!-- /caption -->

<A NAME="452"><H2>Adding Events to WeightEdit</H2></A>

<p>Not only can you add properties, such as <I>weight</I>, to a user-defined control, but you can also add user-defined events, using a technique similar to the one we've just discussed for adding properties. Let's add a <I>WeightEvent</I> that occurs when the weight changes.

<p>Adding a new event involves the following steps:

<OL>
<p><li> Create the event class.
<p><li> Define a delegate for the event class.
<p><li> Add the event to the Properties window.
<p><li> Update the WeightEdit control to generate the new event.
</OL>

<A NAME="453"><h3>Defining the <I>WeightEvent</I> class</h3></A>
<p>Before we can start, we must define an event class and a purpose. Let's call this class We<I>ightEvent,</I> and say that we want it to report changes in the font weight of a WeightEdit control.

<p>Because user code must be able to access <I>WeightEvent</I>, we must declare the class public. Therefore, we must define <I>WeightEvent</I> in its own WeightEvent.java file. In addition, if the user code is to access the value of the new weight, we must also declare the <I>weight</I> property public. (If you prefer, you can leave the <I>weight</I> property private, and provide a public <I>getWeight()</I> method.)

<p>Select the WeightEdit project in Visual J++ Project Explorer. Now choose Add Class from the Project menu. Name the class <I>WeightEvent</I>. Update the class as follows:

<p><pre>
import com.ms.wfc.core.Event;

/**
 * This event is thrown when the weight of
 * the WeightEdit class changes.
 */
public class WeightEvent extends Event
{
     // the new weight
    public int weightChange;
    
    /**
     * Create an event to announce a change
     * in the weight property.
     * @param weightChange - the new weight value
     */
    public WeightEvent(int weightChange)
    {
        this.weightChange = weightChange;
    }
}
</PRE>

<p><I>WeightEvent</I> is a true event because it extends the <I>Event</I> class. The <I>Event</I> class contains no data, and its constructor takes no arguments. The <I>WeightEvent</I> class has one data member, <I>wieghtChange</I>, to store the new weight, and its constructor accepts one argument, the value to be stored in <I>weightChange</I>.

<A NAME="454"><h3>Defining a <I>WeightEvent</I> delegate</h3></A>
<p>Each new event requires a set of access methods in the same way that a new data property requires a pair of <I>getX()</I> and <I>setX()</I> methods. If you examine the event methods already supported by different types of controls in the Visual J++ 6 subset of the MSDN help library, you'll notice that for each event type <I>X</I> there is an <I>addOnX</I> method, and a <I>removeOnX()</I> method, and sometimes an <I>onX()</I> method.

<p>The <I>add</I> method adds a delegate to the list of delegates prepared to handle the event. The <I>remove</I> method removes the specified delegate from the list.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
A delegate is an object that contains a reference to a method. All delegates are subclassed from the abstract class <I>Delegate</I>.
</blockquote></div>

<p>The <I>onX()</I> method calls each of the registered delegates, passing them the <I>X</I> event. Our new <I>WeightEvent</I> is no different.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
The order in which the delegates are invoked isn't specified and isn't the order in which they are added. In addition, if one of the delegate methods throws an exception, execution of the delegate list is halted. Control passes up the stack until the first error-handling catch of the proper type to match the thrown object is encountered.
</blockquote></div>

<p>Following the same pattern, we'll need to add the methods 
<I>addOnWeightEvent()</I>, 
<I>removeOnWeightEvent()</I>, and 
<I>onWeightEvent()</I> to our <I>WeightEdit</I> 
class. Before we can do this, however, we need to define a 
<I>WeightEventDelegate</I> class. We must declare this delegate class public; if we don't, the user-created delegate 
functions won't be able to process the events sent to them. As mentioned earlier, 
because <I>WeightEvent </I>is public, we are forced to create a new source file, 
WeightEventDelegate.java, that contains the public 
<I>WeightEventDelegate</I> class.

<p>Here is the <I>WeightEventDelegate</I> class file:

<p><pre>
/**
 * Handle the WeightEvent.
 */
import com.ms.wfc.core.*;

public final multicast delegate 
    void WeightEventDelegate(Object sender, WeightEvent e);
</PRE>

<p>As you can see, this file is nothing more than the declaration of a 
multicast delegate designed to handle the 
<I>WeightEvent</I> class. The delegate must be 
declared <I>multicast</I> to support the distinct possibility that two or more delegates will 
attach themselves to the <I>WeightEvent</I> event.

<A NAME="455"><h3>Adding the <I>WeightEvent</I> handlers to <I>WeightEdit</I></h3></A>
<p>In some ways, the changes we need to make to our principal class, 
<I>WeightEdit</I>, to incorporate the new event are predictable. As mentioned earlier, 
<I>WeightEdit</I> must provide an 
<I>addOnWeightEvent()</I> method, a 
<I>removeOnWeightEvent()</I> method, and an 
<I>onWeightEvent()</I> method. These methods are shown in the following code, 
which is extracted from the full <I>WeightEdit</I> code listing:

<p><pre>
    // initially, the WeightEvent has no existing handlers;
    // these are added by calling addOnWeightEvent()
    private WeightEventDelegate allWeightDelegates = null;
    
    /**
     * Provide a method to add new delegates to the list of
     * delegates to notify of the WeightEvent.
     */
    public void addOnWeightEvent(WeightEventDelegate addHandler)
    {
        allWeightDelegates = (WeightEventDelegate)
                                  Delegate.combine(
                                      allWeightDelegates,
                                      addHandler);
    }
    
    /**
     * Remove a WeightEvent handler.
     */
    public void removeOnWeightEvent(WeightEventDelegate rmvHandler)
    {
        if (allWeightDelegates != null)
        {
            allWeightDelegates = (WeightEventDelegate)
                                      Delegate.remove(
                                          allWeightDelegates, 
                                          rmvHandler);
        }
    }
    
    /**
     * Run the WeightEvent.
     */
    protected void onWeightEvent(WeightEvent event)
    {
        // if there is any WeightEvent delegate&#8230;
        if (allWeightDelegates != null)
        {
            // then process it
            allWeightDelegates.invoke(this, event);
        }
    }
</PRE>

<p>The data member <I>allWeightDelegates</I> is a listing of all the method delegates 
that are interested in receiving the 
<I>WeightEvent</I> event. Initially, this list is 
<I>null</I>. Although the name of this data member isn't important, the names of the following 
three methods are critical.

<p>The <I>addOnWeightEvent()</I> method takes a <I>WeightEventDelegate 
</I>object as its argument. The 
<I>addOnWeightEvent()</I> method adds the argument 
<I>addHandler</I> to the list 
<I>allWeightDelegates</I> by passing both a reference to the list, and the new 
delegate <I>addHandler,</I> to the 
<I>Delegate.combine()</I> method. The result is a new list 
containing the previous delegates plus 
<I>addHandler</I>.<I> </I>This list is saved back into 
<I>allWeightDelegates</I>. We declare the 
<I>addOnWeightEvent()</I> method public so that all classes 
have access to it.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
The 
<I>Delegate</I> class is part of the Microsoft Software Development 
Kit (SDK) for Java. The class has few methods, all of which are devoted to 
event-type operations, such as the 
<I>combine()</I> method used in our 
<I>addOnWeightEvent()</I> method. The 
<I>Delegate</I> class is included in the package 
<I>com.ms.lang</I>, which means that you'll need to add the statement 
<I>import com.ms.lang.*</I> to the beginning of 
<I>WeightEdit</I>. 
</blockquote></div>

<p>Similarly, <I>removeOnWeightEvent()</I> uses the 
<I>Delegate.remove()</I> method to 
remove a <I>WeightEventDelegate</I> object from the list. You also need to declare 
this method public.

<p>The <I>onWeightEvent()</I> method is invoked when the 
<I>WeightEvent</I> occurs. This method starts by examining the 
<I>allWeightDelegates</I> delegate list. If 
<I>allWeightDelegates</I> is not <I>null</I>, 
<I>onWeightEvent()</I> calls 
<I>allWeightDelegates.invoke()</I>, which invokes 
each attached <I>WeightEventDelegate</I> object.

<A NAME="456"><h3>Adding <I>WeightEvent</I> to the active properties list</h3></A>
<p>Adding the <I>addWeightEvent()</I>, 
<I>removeWeightEvent()</I>, and 
<I>onWeightEvent()</I> methods to 
<I>WeightEdit</I> is necessary but insufficient to allow user programs to implement 
these methods. We must also add the 
<I>WeightEvent</I> property to the active properties 
displayed in the Properties window. To do this, we need to add another property to 
the <I>ClassInfo</I> inner class, as we did when we added the 
<I>weight</I> data property to the Properties list.

<p>The following listing is the entire 
<I>ClassInfo</I> class containing the code for the 
new property addition:

<p><pre>
    public static class ClassInfo extends UserControl.ClassInfo
    {
        //------------------add the data properties-------------
        // add our property to the property list
        public static final PropertyInfo weightProperty
            = new PropertyInfo
                              (
                               WeightEdit.class,
                               &quot;weight&quot;,
                               WeightValues.class
                               );
        public void getProperties(IProperties props)
        {
            super.getProperties(props);
            props.add(weightProperty);
        }
        
        //------------------add the event properties----------
        public static final EventInfo weightEvent
                      = new EventInfo(
                                      WeightEdit.class,
                                      &quot;weightEvent&quot;,
                                      WeightEventDelegate.class
                                      );
        
        public void getEvents(IEvents events)
        { 
            super.getEvents(events);
            events.add(weightEvent);
        }
      }
</PRE>

<p>The data properties section is completely unchanged from the code we 
added earlier to the <I>WeightEdit </I>class. Following that, however, is the declaration of a 
<I>weightEvent</I> object of class 
<I>EventInfo</I>. The <I>EventInfo</I> constructor attaches the event 
named <I>weightEvent</I> to the <I>WeightEdit </I>class, which contains the 
<I>weightEvent</I> handler. The last argument specifies the delegate that will handle the 
<I>weightEvent</I>.

<p>When Visual J++ calls the <I>getEvents()</I> method to get the list of events, 
<I>getEvents()</I> adds our <I>weightEvent</I> object to those events already defined.

<A NAME="457"><h3>Updating <I>WeightEdit</I> to generate a <I>WeightEvent</I></h3></A>
<p>Creating a new w<I>eightEvent</I> object means nothing if 
<I>WeightEdit</I> doesn't generate it when the weight is updated. Let's consider this question for a moment: When 
would an event to inform the system that the weight has changed be sent? The answer 
is, obviously, when the weight is changed, which is in the 
<I>setWeight()</I> method. The following change (shown in boldface) to 
<I>setWeight()</I> is all that is needed to send 
the <I>WeightEvent</I> event notification to the system:

<p><pre>
    /**
     * Sets the font weight.
     */
    public void setWeight(int w)
    {
        // if the new font weight is valid&#8230;
        if (WeightValues.valid(w))
        {
            // update the weight
            this.weight = w;
            
<B>            // notify the world of the change in weight
            onWeightEvent(new WeightEvent(w));</B>
        }
        
        // make sure the display is updated with the
        // current weight
<I>    </I>    this.invalidate();
    }
</PRE>

<p>As you can see, the only change to 
<I>setWeight()</I> is the addition of a call to 
<I>onWeightEvent()</I> if the weight changes. Even if the value hasn't changed, you 
should still call <I>onWeightEvent() </I>to inform other classes that a weight change was attempted.

<p>The call to <I>onWeightEvent()</I> passes an object of class 
<I>WeightEvent</I>&#8212;which contains the new weight 
<I>w</I>&#8212;to all classes that have previously declared their 
interest in this event by calling 
<I>addOnWeightEvent()</I>. Refer to the 
<I>WeightEvent</I> constructor and the 
<I>onWeightEvent()</I> method if this line of code isn't clear.

<A NAME="458"><H3>Adding the new WeightEdit control to the Toolbox</H3></A>

<p>Save the modified files, and compile the solution. In the General section of 
the Toolbox, right-click to open the context menu and choose Customize Toolbox. 
To add the WeightEdit control to the Toolbox, select WeightEdit from the list of 
available controls on the WFC Controls tab of the Customize Toolbox dialog box.

<A NAME="459"><h3>Viewing <I>weightEvent</I> in the active Properties window</h3></A>
<p>To know whether our <I>WeightEvent</I> works as planned, we must first check the list 
of events in the Properties window to make sure that our event is included.

<p>First open the <I>WeightEditTest</I> form in the Forms Designer. Now open the 
Properties window. Select the WeightEdit control in the middle of the 
<I>WeightEditTest</I> form. (If you've previously deleted the 
<I>WeightEdit</I> object from the form, just add it 
back and select it.) Now examine the list of active properties. You should be able to 
find the <I>weightEvent</I> event listed among the other events. (Events are easier to find if 
you list them in alphabetical order.)

<p>Figure 13-7 shows the event properties for the WeightEdit control. Our 
new weight event appears in the list. So far, so good.

<p><img src="images/f13gh07.jpg" width=281 height=476 border="0">
<p><!-- caption --><b>Figure 13-7.</b> <i>This list of event properties for the 
</I>WeightEdit<I> class shows our new </I>weightEvent<I> event.</i><!-- /caption -->

<A NAME="460"><h3>Using <I>WeightEvent</I> in a program</h3></A>
<p>Now comes the final test. Let's process the weight event in our test program.

<p>Still looking at the <I>WeightEditTest</I> form, open the Properties window, and 
select the <I>WeightEdit </I>object. Now double-click the 
<I>weightEvent</I> property. This should create an empty method in your 
<I>WeightEditTest</I> class as follows:

<p><pre>
void weightEdit1_weightEvent(Object source, WeightEvent e)
{

}
</PRE>

<p>Save the form, and then look through the code the Forms Designer 
generated. You'll find a new call to 
<I>addOnWeightEvent()</I>. This method adds a 
<I>WeightEventDelegate</I> object that references the newly created 
<I>weightEdit1_weightEvent() </I>method to the list of delegates interested in processing the weight event.

<p>To prove that <I>weightEdit1_weightEvent()</I> does get invoked when the 
weight changes, let's add a call to 
<I>setText()</I> that changes the text in the WeightEdit 
control to a description of what the new weight value is. This will make it instantly 
obvious that the <I>weightEdit1_weightEvent()</I> method is called. Remember that it's 
<I>setWeight()</I>, not <I>setText()</I>, that invokes the 
<I>WeightEvent</I>.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
If the event handler makes a call to a method that invokes the 
event being processed, the program will hang in an endless loop until it eventually 
runs out of stack and crashes.  
</blockquote></div>

<p>The following code should do the trick:

<p><pre>
   /**
     * Update the text to reflect the new weight whenever a
     * weightEvent occurs.
     */
    private void weightEdit1_weightEvent(Object source, WeightEvent e)
    {
        int newWeight = e.weightChange;
        weightEdit1.setText(&quot;Weight changed to &quot; +
                            newWeight);
    }
</PRE>

<p>This code is fine for processing the 
w<I>eightEvent</I> when it occurs, but something has to trigger the event. In other words, some method has to change the 
<I>weight</I> property.

<p>Even though this technique isn't very sophisticated, let's just add a 
double-click method to the <I>WeightEditTest </I>code to update the weight. With the WeightEdit 
control selected in Forms Designer, double-click the 
<I>doubleClick</I> active property to create the 
<I>weightEdit1_doubleClick()</I> method. Next modify the method as follows:

<p><pre>
    /**
     * Change the weight whenever the user double-clicks the
     * WeightEdit control (simply to test the weightEvent
     * active property).
     */
    private void weightEdit1_doubleClick(Object source, Event e)
    {
        int w = weightEdit1.getWeight();
        w++;
        if (w &gt; 2)
        {
            w = 0;
        }
        weightEdit1.setWeight(w);
    }
</PRE>

<p>This version gets the current weight of the 
<I>weightEdit1</I> object by calling 
<I>getWeight()</I>. From there, it increments the weight until it becomes larger than 2, at 
which point it resets the weight back to 0. It then calls 
<I>setWeight()</I> to update the weight with the new value. This call to 
<I>setWeight() </I>generates a <I>weightEvent</I> that the 
previously registered 
<I>weightEdit1_weightEvent()</I> method should process. Now recompile 
the entire solution.

<A NAME="461"><H3>Giving the final test</H3></A>

<p>Run the WeightEditTest program. Change the 
<I>weightEdit1</I> text in your form to something like that shown in Figure 13-5. Make note of the font weight. Now double-click the <I>weightEdit1</I> object. The weight changes instantly. Even more 
important, the text changes to display a string indicating the new weight. This test 
proves that our <I>weightEdit1_weightEvent()</I> method is being invoked as planned. My 
results are shown in Figure 13-8.

<p><img src="images/f13gh08.jpg" width=372 height=160 border="0">
<p><!-- caption --><B>Figure 13-8.</b> <i>The </I>weightEdit1<I> object looks like this after it's been double-clicked.</I><!-- /caption -->

<p>Double-click the object again, and you'll notice that both the value and 
the weight continue to change. The user-defined WeightEdit WFC control works.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
You'll find this version of the WeightEdit control on the companion 
CD in the subdirectory Custom Controls\Active WFC-Style WeightEdit. 
</blockquote></div>

</BODY>
</HTML>




