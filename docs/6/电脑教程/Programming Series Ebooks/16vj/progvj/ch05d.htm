<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>The Complete WindowedApp Solution</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch05c.htm", "ch05e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="168"><H1>The Complete WindowedApp Solution</H1></A>

<p>The complete Windows version of WindowedApp follows.

<p><pre>
import com.ms.wfc.app.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;
import com.ms.wfc.html.*;

import com.ms.wfc.io.*;

/**
 * This class can take a variable number of parameters on the command
 * line. Program execution begins with the main() method. The class
 * constructor is not invoked unless an object of type 'Form1' is
 * created in the main() method.
 */
public class Form1 extends Form
{
    public Form1(String[] args)
    {
        // Required for Visual J++ Form Designer support
        initForm();

        // I added the following call and the
        // next two functions manually
        processArgs(args);
    }
    
    /**
     * This function processes the input arguments
     * to the program.
     */
    void processArgs(String[] args)
    {
        // if an argument is present&#8230;
        if (args.length == 1)
        {
            // open it as a file name
            TextReader tr = new TextReader(args[0]);
 
            // read a line at a time; add each line
            // to an array of strings
            String s;
            String[] accum = new String[1];
            for (int offset = 0;
                 (s = tr.readLine()) != null;
                 offset++)
            {
                // if the array is not big enough&#8230;
                if (offset &gt;= accum.length)
                {
                    // double its size
                    accum = expand(accum);
                }
                accum[offset] = s;
            }
            
            // now store the lines in the
            // text edit area
            edit2.setLines(accum);
            
            // and save the name of the file
            edit1.setText(args[0]);
        }
    }
    
    /**
     * Double the length of the array passed.
     * 
     * @param array - the array of Strings to expand
     */
    public static String[] expand(String[] array)
    {
        // allocate an array twice as big
        String[] newArray = new String[2*array.length];

        // null out the array first
        for (int i = 0; i &lt; newArray.length; i++)
        {
            newArray[i] = null;
        }
        
        // then copy over members from the source array
        for (int i = 0; i &lt; array.length; i++)
        {
            newArray[i] = array[i];
        }
        return newArray;
    }

    /**
     * Form1 overrides dispose so it can clean up the
     * component list.
     */
    public void dispose()
    {
        super.dispose();
        components.dispose();
    }
    
    /**
     * This method is invoked when the user clicks Cancel.
     */
     private void button2_click(Object source, Event e)
     {
         dispose();
         Application.exit();
     }

     /**
      * This method is invoked by the Submit button to
      * save the contents of the text edit window
      * into a file.
      */
      private void button1_click(Object source, Event e)
      {
          String fileName = edit1.getText();
          if (!fileName.equals(&quot;&quot;))
          {
              TextWriter tw = new TextWriter(fileName, false);
              
              // get the contents of the text edit field
              // and save to the disk
              String[] array = edit2.getLines();
              for (int i = 0; i &lt; array.length; i++)
              {
                  tw.writeLine(array[i]);
              }
              tw.close();
          }
      }

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
      Container components = new Container();
      Label fileNameLabel = new Label();
      Edit edit1 = new Edit();
      Label label1 = new Label();
      Edit edit2 = new Edit();
      Button button1 = new Button();
      Button button2 = new Button();

      private void initForm()
      {
          fileNameLabel.setFont(
              new Font(&quot;MS Sans Serif&quot;, 14.0f,
                       FontSize.CHARACTERHEIGHT,
                       FontWeight.BOLD,
                       false, false, false));
          fileNameLabel.setLocation(new Point(20, 20));
          fileNameLabel.setSize(new Point(80, 20));
          fileNameLabel.setTabIndex(0);
          fileNameLabel.setTabStop(false);
          fileNameLabel.setText(&quot;File Name&quot;);

          edit1.setAnchor(ControlAnchor.TOPLEFTRIGHT);
          edit1.setLocation(new Point(100, 10));
          edit1.setSize(new Point(180, 20));
          edit1.setTabIndex(1);
          edit1.setText(&quot;&quot;);

          label1.setFont(
              new Font(&quot;MS Sans Serif&quot;, 14.0f,
                       FontSize.CHARACTERHEIGHT,
                       FontWeight.BOLD,
                       false, false, false));
          label1.setLocation(new Point(20, 50));
          label1.setSize(new Point(40, 20));
          label1.setTabIndex(2);
          label1.setTabStop(false);
          label1.setText(&quot;Text&quot;);

          edit2.setAnchor(ControlAnchor.ALL);
          edit2.setLocation(new Point(20, 70));
          edit2.setSize(new Point(260, 160));
          edit2.setTabIndex(3);
          edit2.setText(&quot;&quot;);
          edit2.setMultiline(true);

          button1.setAnchor(ControlAnchor.BOTTOMLEFT);
          button1.setLocation(new Point(30, 240));
          button1.setSize(new Point(75, 23));
          button1.setTabIndex(4);
          button1.setText(&quot;Submit&quot;);
          button1.addOnClick(new EventHandler(this.button1_click));

          button2.setAnchor(ControlAnchor.BOTTOMRIGHT);
          button2.setLocation(new Point(200, 240));
          button2.setSize(new Point(75, 23));
          button2.setTabIndex(5);
          button2.setText(&quot;Cancel&quot;);
          button2.addOnClick(new EventHandler(this.button2_click));

          this.setText(&quot;WindowedApp (Windows Version)&quot;);
          this.setAcceptButton(button1);
          this.setAutoScaleBaseSize(new Point(5, 13));
          this.setCancelButton(button2);
          this.setClientSize(new Point(292, 273));

          this.setNewControls(new Control[] {
                              button2, 
                              button1, 
                              edit2, 
                              label1, 
                              edit1, 
                              fileNameLabel});
      }

    /**
     * The main entry point for the application. 
     *
     * @param args - Array of parameters passed to the application
     * via the command line.
     */
    public static void main(String args[])
    {
        Application.run(new Form1(args));
    }
}
</pre>

<p>As always in a Visual J++ application, even a Windows 
application, control begins with <I>main().</I> (The 
<I>main()</I> function is at the bottom of the source file.) 
This function creates a new instance of our main form class, 
<I>Form1</I>, passing the input arguments as arguments to the constructor. The 
class <I>Form1</I> extends the WFC class <I>Form</I>.

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
<I>Form</I> is the WFC class that most corresponds to 
    the AWT <I>Frame</I> class. 
</blockquote></div>

<p>The first statement in Form1 is a call to <I>initForm(), 
</I>whose code constructs the form you built with the Forms 
Designer.

<P>Immediately following is a call to the function 
<I>processArgs()</I>. If an argument is provided to the program 
when it is first started, <I>processArgs()</I> assumes it is 
a file name and reads the contents of the file into the multiline Edit control. 
The details of how it does this are discussed below.

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
     The function <I>processArgs()</I> and the helper 
    function immediately following it are the only two functions in this program 
    that I added completely without the help of the Visual J++ 6 Rapid 
    Application Development (RAD) tools. All of the other functions in this 
    program were built either wholly or in part by the Windows Application 
    builder or the Forms Designer. 
</blockquote></div>

<A NAME="169"><h2>The <I>initForm()</I> 
Method</h2></A>
<p>On the one hand, as a programmer you might not be 
interested in the contents of the <I>initForm()</I> method 
at all. After all, you didn't create it and you shouldn't edit it except by 
means of the Forms Designer. Nevertheless, I think it is important to understand 
how the code generated by automatic tools like the Forms Designer works. You can 
learn a lot from the code generated by the experts. In addition, you never know 
when you might need to do the same coding tasks without the help of the Forms 
Designer.

<P>Immediately preceding the <I>initForm()</I> method are all of the data members that <I>initForm()</I> references. Unless you change their names in the Properties 
window, they carry fairly mundane names like <I>edit1</I>, 
<I>edit2</I>, and so forth. (As you saw with the label <I>fileNameLabel</I>, you are free to change object names to 
anything meaningful to you.) Since these objects appear with initializers, they 
are actually constructed prior to <I>initForm()</I> being 
called.

<P></P><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>
     Initializers execute as part of the constructor. They are invoked after the 
    constructor for the base class has been called and before the first 
    statement in the constructor. 
</BLOCKQUOTE></DIV>

<p>You can see that the objects are formatted within 
<I>initForm()</I> in the order you created them in the Forms 
Designer. In this example, the first object created was the <I>fileNameLabel</I> object. The first method called on this object is <I>setFont()</I>. This call creates a new font using the 
parameters provided in the Properties window.

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
     It is possible to change the font when using AWT, but the choice of fonts 
    and font properties is very limited<I>.</I> 
</blockquote></div>

<p>The<I> initForm()</I> method then 
sets the location of the label and its size. The class <I>Point</I> is nothing more than a holder for an x and a y value. The tab 
order is set by <I>setTabIndex()</I>. This is the order in 
which objects gain focus when the user presses the tab key. Control starts with 
element 0 and continues to element 1, 2, and so on until wrapping around back to 
0 again. Finally, the call to <I>setText()</I> sets the 
actual label itself.

<P>The remaining objects within the form are initialized 
following the same pattern. Once all of the objects have been initialized, the 
following statement is used to attach all of the individual objects to the <I>Form1</I> object at once:

<p><pre>
this.setNewControls(new Control[] {
                              button2, 
                              button1, 
                              edit2, 
                              label1, 
                              edit1, 
                              fileNameLabel});
</pre>

<p>This statement creates an array of <I>Control</I> objects and initializes that array to references to the 
controls&#8212;<I>button2</I>, <I>button1</I>, <I>edit2</I>, and so on&#8212;that we 
created during the design phase. The resulting array of controls is passed to <I>setNewControls(),</I> which attaches each control to 
<I>this</I>, the <I>Form1</I> object.

<P></P><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>
     This &quot;allocate array off the heap and initialize&quot; statement is a 
    Visual J++ extension to C++. 
</BLOCKQUOTE></DIV>

<A NAME="170"><h3>Editing <I>initForm()</I></h3></A>
<p>Now that I've told you that you shouldn't edit 
<I>initForm()</I>, let me tell you that it is possible to do. 
As long as the Forms Designer is open, the area of code including <I>initForm()</I> is darkened and the Visual J++ Text editor 
won't let you touch it. However, once you close the Forms Designer you are free 
to change this function any way you want.

<p>If you are careful and stick with the pattern of calls 
the Forms Designer has established, the changes you make in the Text editor will 
be picked up the next time you open the Forms Designer. To prove this point, 
let's close the Forms Designer. Now scroll into the <I>initForm()</I> method and change a property. I chose to add the following 
two lines to the edit2 section:

<p><pre>
edit2.setAcceptsTab(true);
edit2.setWordWrap(false);
</pre>

<p>The first statement enables tab processing, which by 
default is disabled, and the second turns off word wrap.

<p>Try changing something that is visible in the Forms 
Designer. I chose to change the title of <I>Form1</I> by 
editing the call <I>this.setText()</I>.

<p>Now reopen the Forms Designer and select the object you 
edited. You'll notice that your changes are now visible in the Forms Designer. 
If you made the changes that I did, you'll see that the title of the form has 
been updated in the Forms Designer and that the <I>acceptsTab</I> and 
<I>wordWrap</I> properties of the <I>edit2 </I>Edit control in the Properties window have 
changed.

<p>I wouldn't advise adding any extraneous code within 
<I>initForm(),</I> because the Designer won't know what to do 
with it, but if you prefer to edit object properties in the Text editor rather 
than use the Properties window, feel free.

<A NAME="171"><h2>The <I>processArgs()</I> 
Method</h2></A>
<p>The second method called by the <I>Form1</I> constructor is the <I>processArgs()</I> 
method. As the name implies, this method processes the arguments passed to the 
program. If an argument isn't provided, the method exits without doing anything.

<P>If there is a single argument, <I>processArgs()</I> assumes the argument is the name of a text file to read 
and passes the name to <I>TextReader,</I> which in turn 
creates a text reader object to read the input file. This it does by calling <I>readLine()</I> in a loop that executes until 
<I>readLine()</I> returns a <I>null,</I> indicating that 
there are no more lines of text to read. As each line is read in, it is added to 
an array of strings. If there is no more room in the array, the locally-defined 
method 
<I>expand()</I> is called to double the size of the 
array.

<P>Once the input file has been read into an array of 
strings, this array is written into the edit box by means of the call <I>edit2.setLines()</I>. Finally, the name of the file is 
written into the file name edit field.

<P>The <I>expand()</I> function doubles 
the size of the string array passed it. First, it allocates a new array of 
strings twice the size of the array passed to it. It then copies the contents of 
the input array into the new array before returning a reference to the new 
array.

<A NAME="172"><H2>Event Handlers</H2></A>

<p>If you look closely at the objects being initialized in 
<I>initForms(),</I> you'll see that there is a significant 
difference between how the two buttons and the rest of the objects are 
initialized. The two buttons include a call to 
<I>addOnClick()</I>, passing it something called an 
<I>EventHandler</I>. To understand this call, you need to know something about 
event processing under AWT version 1.0, AWT version 1.1, and WFC.

<A NAME="173"><H3>AWT Version 1.0 event handling</H3></A>

<p>The AWT that accompanied the original release of Java had 
a simple event-handling scheme. When an action occurred, such as a mouse button 
click or a keystroke, an object of class <I>Event</I> was 
created. This object was passed to the <I>handleEvent()</I> 
method of the <I>Component</I> object that was being pointed 
at or that had focus at the time of the event.

<p>The programmer had the options of handling the event 
there or letting the default <I>Component.handleEvent()</I> 
method take care of it. The default method would first try to give someone else 
a chance by passing the event to whatever <I>Container</I> 
object the component was attached to. Thus, a <I>Button</I> 
object would pass the event to the 
<I>Frame</I> object to 
which it was attached. This &quot;bubbling up of events&quot; enabled the 
programmer to handle all events in one central location.

<p>If the event was not handled in any of the 
<I>handleEvent()</I> methods, <I>Container.handleEvent()</I> would do one of the following:

<UL>
<P><LI>For certain types of events, such as a window 
    minimize or a window maximize event, it would handle the event.

<P></P><LI>For action events, it would pass the event on to the 
<I>Container.action()</I> method, which by default 
    repeated the process of passing the event to any parent container's <I>action()</I> method.

<P></P><LI>For the most common event types&#8212;like 
    keystrokes, mouse down events, mouse up events, and so on&#8212;<I>handleEvent()</I> would call for each event a 
    specially-named method that was designed to handle just that event. For 
    example, the mouse down event would result in the object's <I>mouseDown()</I> method being invoked. Again, the default action was to 
    bubble the event up to the parent container for processing.</LI>
</UL>

<p>For example, the following program uses the <I>action()</I> method of the parent frame to detect a button 
being clicked:

<p><pre>
import java.awt.*;
public class Class1 extends Frame
{
    Button okButton;
    Button cancelButton;
    
    public void init()
    {
        add(okButton = new Button(&quot;OK&quot;));
        add(cancelButton = new Button(&quot;Cancel&quot;));
        setVisible(true);
    }

    /**
        * Gets called whenever an object within the frame
        * is &quot;activated.&quot;
     */
    public boolean action(Event e, Object o)
    {
        // check to see which object was activated
        if (e.target == okButton)
        {
            // handle the OK button here&#8230;
            return true; // indicates we've handled event
        }
        if (e.target == cancelButton)
        {
            // handle the Cancel button here&#8230;
            return true;
        }
        
        // return false to indicate we haven't handled
        // the event
        return false;
    }
}
</pre>

<p>The <I>action()</I> method in the 
frame class receives action events that occur within the frame. The method must 
then test which object received the action event. In this case, we are 
interested only in the two buttons, since these are the only objects we added to 
the frame.

<P>The problem with this approach is that it isn't very 
neat. The single <I>action()</I> method can get pretty 
complicated if there are a lot of components in the frame. Worse yet, it 
disperses the button logic across the application. Pretty soon the single <I>action()</I> method contains logic for menu items, along 
with check boxes, radio buttons, and other object types all mixed together.

<P>A more modular means of handling the action event within 
the button object is as follows:

<p><pre>
import java.awt.*;

public class Class1 extends Frame
{
    public void init()
    {
        // TODO: Add initialization code here
        add(new OKButton());
        add(new CancelButton());
        setVisible(true);
    }
}

class OKButton extends Button
{
    OKButton()
    {
        super(&quot;OK&quot;);
    }
    
    public boolean action(Event e, Object o)
    {
        // handle the OK button here
        return true; // indicates we've handled event
    }
}

class CancelButton extends Button
{
    CancelButton()
    {
        super(&quot;Cancel&quot;);
    }
    
    public boolean action(Event e, Object o)
    {
        // handle the Cancel button here
        return true; // indicates we've handled event
    }
}
</pre>

<p>Here the action event handler has been moved to the 
component by creating a separate subclass for each button, with each subclass 
having its own <I>action()</I> method. This approach is 
modular in that it keeps each button's event handling code together with the 
rest of the button's logic and separate from the event handling code of other 
components. Thus, <I>CancelButton.action()</I> contains the 
code to handle the Cancel button and nothing more. The primary drawback with 
this approach is that it ends up creating a lot of subclasses.

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
     This event-handling approach that uses the 
<I>handleEvent() </I>and <I>action()</I> methods is 
    still supported in Visual J++ 6. In fact, this is the method we used for 
    event processing in <A HREF="ch04a.htm">Chapter 4</A>. 
    However, both 
<I>handleEvent()</I> and <I>action()</I> are marked as deprecated, which means that although the 
    method is still present it might be removed in future versions of the 
    language. 
</blockquote></div>

<A NAME="174"><H3>AWT 1.1 event delegation</H3></A>

<p>Seeing the benefits of modular event processing, the 
authors of Java version 1.1 formalized this concept somewhat in a mechanism 
known as <I>event delegation</I>.

<P>Event delegation uses an event-processing model based on 
special interfaces known as <I>listeners</I>. For example, 
the action event can be handled by any class that implements the <I>ActionListener</I> interface. To implement the <I>ActionListener</I> interface, a class has only to provide the function <I>actionPerformed()</I>. Other listener interfaces are 
provided for other classes of events, each with its own version of the <I>actionPerformed()</I> method to be implemented.

<P>Event delegation gives the programmer increased 
flexibility. The listener for a given component can be in a separate class. In 
some cases, multiple components can share the same listener. More often, the 
listener is an inner class within the component itself, as shown in the 
following example.

<p><pre>
import java.awt.*;
import java.awt.event.*;

public class Class1 extends Frame
{
    public static void main(String[] args)
    {
        (new Class1()).init();
    }
    
    public void init()
    {
        add(&quot;West&quot;, new OKButton());
        add(&quot;East&quot;, new CancelButton());
        setVisible(true);
    }
}

class OKButton extends Button
{
    class OKActionListener implements ActionListener
    {
        public void actionPerformed(ActionEvent ae)
        {
            // handle the OK button action here
        }
    }
    
    OKButton()
    {
        super(&quot;OK&quot;);

        // add an object to the list of listeners for
        // an action on this object
        addActionListener(new OKActionListener());
    }
}

class CancelButton extends Button
{
    class CancelActionListener implements ActionListener
    {
        public void actionPerformed(ActionEvent ae)
        {
            // handle the Cancel button action here
        }
    }
    
    CancelButton()
    {
        super(&quot;Cancel&quot;);
        addActionListener(new CancelActionListener());
    }
    
}
</pre>

<p>Here you can see that the OK and Cancel buttons each 
define their own inner classes to implement the <I>ActionListener</I> interface. The call to <I>addActionListener()</I> tells AWT to invoke the class's listener when an 
action occurs on that button. Inner classes were a new feature with version 1.1 
of the Java standard, added specifically to support event delegation.

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
     A listener doesn't have to be an inner class. Using an inner class keeps 
    all of the component logic together. 
</blockquote></div>

<p>Listeners are even more modular than their predecessor. 
The action processing code can be both bundled up within the button class and at 
the same time segregated into an inner class.

<A NAME="175"><h3>The problems with <I>handleEvent()</I> and event delegation</h3></A>
<p>Both of the event-handling mechanisms we've been 
discussing have problems. The <I>handleEvent()</I> 
mechanism, although simple, suffers from numerous deficiencies. First, there is 
the problem of function complexity that I already mentioned. Second, the event 
linkage is completely static. That is to say, the decision where a particular 
event will be processed is made at compile time and can't be changed while the 
program executes.

<P>Event delegation solves both of these problems. First, it 
encourages the programmer to handle the event in the object closest to where the 
event occurred. Second, the action listeners can be added and removed during 
program execution using the <I>addOnXXX()</I> and <I>removeOnXXX()</I> methods, where <I>XXX</I> is the name of the event. Third, multiple action listeners can be 
added to the same event, resulting in a sort of multicast capability.

<P>There are several problems with event delegation, 
however. First, event delegation results in the creation of multiple, often 
trivially small classes to handle events for the different objects. A large form 
with a large number of objects requires more code to define listeners than to 
actually do the work. This situation is somewhat relieved by the addition of 
inner classes, but not completely. To use event delegation, the Forms Designer 
would need to create and keep track of numerous small listener classes.

<P>Second, to use event delegation, tools must have access 
to the source code. This isn't a problem for programmer tools such as the Forms 
Designer; however, more and more users are looking for fourth-generation and 
fifth-generation tools that enable dynamic linking of objects by the user.

<A NAME="176"><H2>Delegates</H2></A>

<p>In response to some of the problems with the conventional 
and event delegation models for event handling, Visual J++ 6 has introduced a 
new event-handling mechanism that Microsoft calls <I>delegates</I>.

<A NAME="177"><H3>What is a delegate?</H3></A>

<p>A delegate is a class that can be used to reference an 
object/method combination. It is easier to explain a delegate by example than 
with words. The following code, from the DelegateDemo application on the 
companion CD, declares a delegate called <I>FunctionDelegate</I>, assigns a method to the delegate, and finally, 
invokes that method through the delegate.

<p><pre>
import com.ms.wfc.io.*;

// declare a delegate for a function that accepts two
// ints and returns an int (this actually creates
// a subclass of the class Delegate)
delegate int FunctionDelegate(int a, int b);

public class Class1
{
    // declare an object of type FunctionDelegate
    FunctionDelegate f;
    
    public static void main (String[] args)
    {
        (new Class1()).test();
    }

    /**
     * This function compares its two arguments, outputs
     * an indication of which is greater, and then returns
     * the greater of the two values. (No consideration is
     * made for equal values.)
     * This function is only intended as a test of
     * FunctionDelegate.
     */
    int targetFunction(int a, int b)
    {
        Text.out.writeLine(&quot;A is &quot; +
                           ((a &gt; b) ? &quot;greater&quot; : &quot;less&quot;) +
                           &quot; than B&quot;);
        return (a &gt; b) ? a : b;
    }
    
    Class1()
    {
        // create a new object of class FunctionDelegate
        // with the function targetFunction() and the
        // current object
        f = new FunctionDelegate(this.targetFunction);
    }
    
    /**
     * This function simply tests FunctionDelegate.
     */
    void test()
    {
        int a = 10;
        int b = 20;
        
        Text.out.writeLine(&quot;A = &quot;
                           + a
                           + &quot;, B = &quot;
                           + b);
        Text.out.writeLine(&quot;Invoking delegate&quot;);
        int result = f.invoke(a, b);
        Text.out.writeLine(&quot;Delegate returned &quot;
                           + result);
    }
}
</pre>

<p>This example defines a delegate named <I>FunctionDelegate</I>, which extends the class <I>Delegate</I>. <I>Class1</I> includes a data member 
<I>f</I> of class <I>FunctionDelegate</I>. 
The constructor for <I>Class1</I> creates a new <I>FunctionDelegate</I> object with the object/method 
combination of <I>this.targetFunction()</I>.

<P>Let's stop for just a minute and analyze what has 
happened so far. The keyword <I>delegate</I> is unique to 
Visual J++ 6; it isn't a part of the standard Java language and isn't ever 
likely to be given Sun Microsystem's pronouncements on the subject. (If you care 
about my opinion, see the sidebar at the end of this section.)

<P>The following assignment creates an object of class 
<I>FunctionDelegate</I> and initializes it with the 
object/method combination of <I>this</I> and <I>targetFunction</I>.

<p><pre>
f = new FunctionDelegate(this.targetFunction)
</pre>

<p>The <I>this</I> object is of class <I>Object</I> and the object <I>targetFunction</I> is of class <I>Method</I>. (The 
class <I>Method</I> was introduced to the Java language by 
Sun Microsystems as part of the language reflection package 
[java.lang.reflect].)

<P>Notice that the prototype of <I>targetFunction()</I> matches the declaration of <I>FunctionDelegate</I> exactly. In other words, <I>FunctionDelegate</I> was declared to accept methods that take two integers 
as arguments and return an integer. That's exactly what was passed when the 
object <I>f</I> was created.

<P></P><DIV CLASS="caution"><BLOCKQUOTE>
<B>CAUTION</B>
<HR>
     The delegate declaration must exactly match the type of the method passed 
    to the delegate class constructor. (Note, however, that the type of the 
    target object isn't specified.) 
</BLOCKQUOTE></DIV>

<p>Having created a delegate object <I>f</I>, we can invoke the object/method pair pointed at by <I>f</I> using the method <I>invoke()</I>. This is exactly 
what the function 
<I>test()</I> does. First, <I>test()</I> defines a couple of integers, <I>a</I> and <I>b</I>. It then invokes the object and method referenced 
by <I>f</I> and passes them the arguments <I>a</I> and <I>b</I>. The output of this simple test 
program is shown in Figure 5-8.

<P><A HREF="javascript:fullSize('f05gh08x.htm')"> <img src="images/f05gh08.jpg" width=404 height=254 border=0 ALT="Click to view at full size."></A>

<P><!-- caption --><B>Figure 5-8.</B> <i>The output of the 
DelegateDemo program, which declares and then invokes a delegate.</i><!-- /caption -->

<P></P><DIV CLASS="sidebar"><BLOCKQUOTE>
<P><B>What About the <I>Delegate</I> Keyword?</B>

<P>Personally, I am a little ambivalent about the 
    introduction of the <I>delegate</I> keyword. I've never 
    been a big supporter of religious wars of language purity; but still, it's 
    not good to add new keywords to a language, especially a language designed 
    to be portable like Java. It's actually worse than you might think. The 
    implementation of delegates requires additions to the Java Virtual Machine 
    (VM). Thus, code generated using the delegate keyword won't execute on 
    another vendor's VM.

<P>On the other hand, Sun Microsystems isn't above such 
    shenanigans. After all, Sun introduced the inner class feature primarily to 
    make their newly introduced event delegation less objectionable. Further, 
    the Visual J++ delegate feature does make it easier to write event handlers. 
    Gone is the need to construct an entire class just so you can tie a single 
    function to an event. And of course, there's always the argument that you 
    don't have to use delegates. But WFC uses delegates, so as soon as you adopt 
    WFC you are in Windows territory anyway.

<P>In effect, Microsoft has introduced to the Java 
    language a type-safe, object-oriented way of defining C++ callback 
    functions. Recent C++ converts to Java will love this feature&#8212;and Java 
    purists will hate it. I would love to see the delegates feature become part 
    of standard Java, but until it does I remain 
ambivalent.</P>
</BLOCKQUOTE></DIV>

<A NAME="178"><H3>Delegates and WFC event handling</H3></A>

<p>WFC uses delegates as a means of registering event 
handlers. For example, WFC includes a delegate class <I>MouseEventHandler</I>. The <I>Control</I> class 
prewires the mouse events, such as mouse down, mouse up, and mouse move, to 
invoke any registered <I>MouseEventHandler</I> objects. An 
application program registers a <I>MouseEventHandler</I> by 
calling <I>addOnXxx()</I>, where <I>Xxx</I> represents the type of event. (For every <I>addOnXxx()</I>, there is a corresponding <I>RemoveOnXxx()</I> that removes the handler delegate.)

<p>Returning to our <I>WindowedApp</I> 
example, let's look at this statement:

<p><pre>
button1.addOnClick(new EventHandler(this.button1_click));
</pre>

<p>This line of code creates an <I>EventHandler</I> delegate object with the current object (<I>this</I>) and the method 
<I>button1_click()</I> and 
registers the delegate object (perhaps as one of several) to handle the <I>onClick</I> event emanating from <I>button1</I>.

<A NAME="179"><H3>How is a delegate different from a C callback 
function?</H3></A>

<p>Visual C++ programmers will immediately recognize 
delegates as the Java equivalent of a callback function in C. Some operating 
systems use this callback mechanism to enable a program to register a function 
to handle a particular event. (The XWindows/Motif system makes significant use 
of callback functions.)

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
     In C one could make the following declaration: <I>void 
    addOnClick(int (*)(int, int));</I>. This declares a method <I>addOnClick()</I> that takes as its argument the address of a function. 
    That function takes two integers and returns an integer. (Presumably this 
    would be the function to handle the <I>onClick</I> 
    event.) 
</blockquote></div>

<p>Both callbacks and delegates are an efficient means for 
handling such events; however, delegates are superior to C callback functions in 
several ways. First, delegates are type safe. Theoretically, C callback 
functions are also type safe, but because you can recast a pointer in C, in 
practice programmers always seem to pass invalid program addresses. Java doesn't 
allow recasting. The method passed to the delegate's constructor must match the 
delegate's declaration. In addition, the <I>Delegate</I> 
class checks to make sure that what it's being passed is actually a method.

<P>Second, callback functions are not inherently 
object-oriented. For example, Motif makes no provisions for the object half of 
the object/method pair in its callback mechanism. This is a constant nuisance to 
the C++ programmer. Delegates are built to store both the object and the method.

<P>Finally, delegates are secure. A less-trusted piece of 
code can't use a delegate to gain access to more-trusted code. (Trusted and 
untrusted code types will be discussed in the section on applet security in <A HREF="ch14a.htm">Chapter 14</A>. All application code is 
trusted.)

<A NAME="180"><H2>Multithreading</H2></A>

<p>There is still one more aspect of the WindowedApp 
application that remains unexplained: the last function in the file but the very 
first to execute, 
<I>main()</I>. The <I>main()</I> function contains a single statement:

<p><pre>
Application.run(new Form1(args));
</pre>

<p>The constructor for <I>Form1</I> 
creates the form as edited by the Forms Designer. The resulting <I>Form</I> object is passed to 
<I>Application.run()</I>. This function enters the Windows message dispatch 
loop, which fields Windows messages and dispatches them by means of the 
event-handling mechanism described earlier. Control remains in this message 
dispatch loop until the 
<I>Form</I> calls <I>Application.exit()</I> to terminate the program.

<p>If you are a seasoned Windows programmer, this last 
paragraph will make perfect sense to you. If it does not, don't panic. I will 
present a complete discussion of <I>Application</I> and 
multithreading in <A HREF="ch10a.htm">Chapter 
10</A>.</p>

</BODY>
</HTML>




