<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>Mixing Graphics Objects  and WFC Components</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch09d.htm", "ch09f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="291"><H1>Mixing Graphics Objects  and WFC Components</H1></A>

<p>Up until now, the <I>Graphics</I> object and corresponding 
<I>paint()</I> method have been presented as a mutually exclusive alternative to the use of WFC components. 
There is at least one case, however, where the use of the custom 
<I>paint()</I> method must be mixed with the use of components.

<p>One of the methods of the <I>Graphics</I> class, 
<I>drawFocusRect()</I>, is designed to draw a focus rectangle. The focus rectangle is the rapidly updated, dotted rectangle 
that some software packages use to signify that the user has selected an area of the 
screen, or to signify that a control has focus.

<p>It might be desirable in some applications to use a focus rectangle to 
enable the user to select and manipulate WFC components. The following 
SelectComponents program does exactly that: it allows the user to select a few WFC components 
and drag them about within the form almost as if they were still under the control of 
the Forms Designer. The program will also demonstrate that all the while the 
components are being dragged about, they are still completely functional.

<A NAME="292"><H2>The Forms Designer Work</H2></A>

<p>Create a standard Visual J++ Windows application. Call it SelectComponents. Set 
the <I>text</I> property of the form to 
<I>Select</I> <I>Components</I> to match the name of the application.

<p>We will need to add a few WFC components for the user to select. Arrange 
four Button controls vertically on the form, leaving the default names for each. Below 
the four buttons, place an Edit control. Change the 
<I>name</I> property of the Edit control to 
<I>edit.</I> Set the initial <I>text</I> property of the control to 
<I>Drag</I> <I>mouse</I> <I>to</I> <I>select</I> 
<I>objects</I>, to indicate to the user what the purpose of the application is. In addition, set the 
<I>click</I> property of each button to point to a method that will simply display the 
message &quot;button<I>x</I> clicked&quot; in the Edit control, where 
<I>x</I> is the number of the button. We'll 
use this later to prove that even though they have been moved, the buttons 
continue to work.

<p>The completed form in the Forms Designer is shown in Figure 9-12.

<p><img src="images/F09gh12.JPG" width=318 height=363 border="0">
<P><!-- caption --><B>Figure 9-12.</b> <i>The completed Forms Designer work for
SelectComponents.</I><!-- /caption -->

<A NAME="293"><H2>The Code</H2></A>

<p>The code for SelectComponents is involved and somewhat lengthy. To simplify 
the program as much as possible, I have broken the source code up into a number 
of simpler classes. With the support of these helper classes, the actual Form1.java 
source listing becomes almost simple.

<A NAME="294"><h3>The <I>ControlLoc</I> class</h3></A>
<p>Looking ahead, it's clear that SelectComponents will need to be able to keep 
track of the <I>Control</I> objects the user selects with the focus rectangle.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
I'm not so clever that I can look ahead to determine exactly what I 
will need in a class. Such development is in practice iterative. I first 
created <I>ControlLoc</I> guessing what I would need. As development progressed, I 
returned to add capabilities that I hadn't anticipated initially.
</blockquote></div>

<p>To make tracking selected objects easier, create the following 
<I>ControlLoc</I> class.

<p><pre>
import com.ms.wfc.ui.*;

/**
 * Retain a control and its original location.
 */
public class ControlLoc
{
    Control c = null;
    Point   originalLoc = null;

    /**
     * Save the control and its original location.
     */
    ControlLoc(Control c)
    {
        this.c           = c;
        this.originalLoc = c.getLocation();
    }

    /**
     * Get the control.
     */
    Control getControl()
    {
        return c;
    }

    /**
     * Get original location of the control.
     */
    Point getOriginalLocation()
    {
        return new Point(originalLoc);
    }

    /**
     * Set the current location of the control.
     */
    void setLocation(Point loc)
    {
        c.setLocation(loc);
    }
}
</PRE>

<p>The <I>ControlLoc</I> class represents a <I>Control 
</I>object, <I>c</I>, and the object's original location on the screen, 
<I>originalLoc</I>. The methods of 
<I>ControlLoc</I> are straightforward. There's a constructor that saves the
control and queries its location using 
the <I>Control.getLocation()</I> method, to establish the original location.
In addition, the methods <I>ControlLoc.getControl()</I> and 
<I>ControlLoc.getOriginalLocation()</I> allow 
querying of the data members. The method 
<I>ControlLoc.setLocation()</I> updates the 
current location of the control on the screen.

<A NAME="295"><h3>The <I>ControlLocList</I> class</h3></A>
<p>It's also clear that the <I>ControlLoc</I> objects created to keep track of the controls 
selected by the focus rectangle will need to be maintained in a list. To simplify this chore, 
create the following <I>ControlLocList</I> class.

<p><pre>
import com.ms.wfc.ui.*;
import com.ms.wfc.util.List;

/**
 * Maintain a list of ControlLoc objects.
 */
public class ControlLocList
{
    List list = new List();
                         
    /**
     * Add a control.
     */
    public void addControl(Control c)
    {
        list.addItem(new ControlLoc(c));
    }
    
    /**
     * Reset the list to empty.
     */
    public void reset()
    {
        list.setSize(0);
    }
    
    /**
     * Retrieve a ControlLoc by index.
     */
    public ControlLoc getControlLoc(int index)
    {
        return (ControlLoc)list.getItem(index);
    }
    
    /**
     * Get the number of ControlLocs in the list.
     */
    public int getSize()
    {
        return list.getSize();
    }
}
</PRE>

<p>This class uses the <I>List</I> class to maintain the actual list. The 
methods <I>addControl()</I>, <I>reset()</I>, 
<I>getControlLoc()</I>, and <I>getSize() </I>provide simplified access to 
this list of <I>ControlLoc</I> objects.

<A NAME="296"><h3>The <I>SelectedControls</I> class</h3></A>
<p>Now that we have a class for maintaining information about a selected control 
and a class for maintaining a list of the selected controls, we can set about writing a 
class for selecting control objects. This class 
<I>SelectedControls</I> appears as follows:

<p><pre>
import com.ms.wfc.ui.*;

/**
 * Selected controls are those WFC controls that fall
 * within the focus rectangle.
 */
public class SelectedControls
{
    // create a container for selected controls
    private ControlLocList selectedControls = 
                                        new ControlLocList();
    
    /**
     * Add the controls that hang off the parent and are
     * within the rectangle r to the list of selected
     * controls. (Mark them by setting them to boldface.) 
     */
    public void findControls(Control parent, Rectangle r)
    {
        // first clear out the list
        selectedControls.reset();
        
        // now add back all the objects within the rectangle
        add(parent, r);
    }

    private void add(Control parent, Rectangle r)
    {
        int limit = parent.getControlCount();
        for (int i = 0; i &lt; limit; i++)
        {
            // get the bounding rectangle for this control
            Control child = parent.getControl(i);
            Rectangle childR = child.getClientRect();
            Point loc = child.getLocation();
            childR.x = loc.x;
            childR.y = loc.y;
  
            // if it's within the focus rectangle&#8230;
            if (isWithin(childR, r))
            {
                // mark it and add it to the list
                setHighlight(child, true);
                selectedControls.addControl(child);
            }
            else
            {
                setHighlight(child, false);
            }
            
            // add any components hanging off this component
            add(child, r);
        }
    }
 
    /**
     * Either highlight or unhighlight the Control c.
     */
    private void setHighlight(Control c, boolean on)
    {
        Font font = c.getFont();
        if (font == null)
        {
            return;
        }
        // if highlight is on&#8230;
        if (on)
        {
            // set the font to bold;&#8230;
            font = new Font(font, FontWeight.BOLD,
                            false, false, false);
            c.setFont(font);
        }
        // otherwise,&#8230;
        else
        {
            // set to normal
            font = new Font(font, FontWeight.NORMAL,
                            false, false, false);
            c.setFont(font);
        }
    }
    

    /**
     * Move the selected objects by delta.
     */
    Point controlPt = new Point();
    public void move(Point delta)
    {
        int size = selectedControls.getSize();
        for (int i = 0; i &lt; size; i++)
        {
            ControlLoc cl = selectedControls.getControlLoc(i);
            controlPt = cl.getOriginalLocation();
            controlPt.x += delta.x;
            controlPt.y += delta.y;
            cl.setLocation(controlPt);
        }
    }

    /**
     * Return true if first rectangle is completely within second.
     */
    static boolean isWithin(Rectangle childR, Rectangle parentR)
    {
        if (childR.x &lt; parentR.x)
        {
            return false;
        }
        if (childR.y &lt; parentR.y)
        {
            return false;
        }
        if ((childR.x + childR.width) &gt; (parentR.x + parentR.width))
        {
            return false;
        }
        if ((childR.y + childR.height) &gt; (parentR.y + parentR.height))
        {
            return false;
        }
        return true;
    }   
}
</PRE>

<p>The <I>findControls(parent, r)</I> method is perhaps the most important of the 
methods in this class. This method searches all of the WFC controls that are
attached to the <I>parent</I> control object<I>. </I>Each of the controls it
finds that are completely within 
the focus rectangle <I>r </I>is added to the 
<I>ControlLocList</I> data member called 
<I>selectedControls</I>.

<p>The<I> findControls()</I> method starts by first resetting the 
<I>selectedControls</I> list to empty. It then calls the 
<I>SelectedControls.add() </I>method. The 
<I>add()</I> method loops through all of the child controls of 
<I>parent</I> using the method 
<I>Control.getControl()</I>. 
For each child that it finds, <I>add()</I> calculates the smallest rectangle
that surrounds 
the child component. This is the bounding rectangle. The 
<I>add()</I> method calls 
<I>SelectedControls.isWithin()</I> to determine whether the child's bounding rectangle 
is completely within the focus rectangle <I>r</I>. If it is, the control is highlighted by 
calling <I>SelectedControls.setHighlight()</I> and the control is added to the 
<I>selectedControls</I> list.

<p>The <I>isWithin(childR, parentR)</I> method returns 
<I>true</I> if the rectangle <I>childR</I> is completely within the focus rectangle 
<I>parentR</I>. The logic is straightforward, 
although a little monotonous. If the child rectangle's left edge is to the left of the parent's 
left edge (<I>childR.x &lt; parentR.x</I>), the method returns 
<I>false</I>. Likewise, if the child rectangle's upper edge is above the parent's 
(<I>childR.y &lt; parentR.y</I>), the method returns 
<I>false</I>. Similar checks are made of the right and bottom edges. After all edges have 
been checked, if the method still hasn't found any part of the child rectangle to be 
outside the parent rectangle, the method returns 
<I>true</I>. This is demonstrated in Figure 9-13.

<p>As you can see in the Figure 9-13 example, component A is outside the 
focus window W because <I>childR.x</I> is less than 
<I>parentR.x</I>. Component B is outside W 
because <I>childR.y</I> is less than 
<I>parentR.y</I>. In the case of component C, both 
<I>(childR.x + childR.width)</I> is greater than 
<I>(parentR.x + parentR.width)</I> and <I>(childR.y 
+ childR.height)</I> is greater than <I>(parentR.y + 
parentR.height)</I>. Component D is completely within the focus window.

<p><A HREF="javascript:fullSize('F09gh13x.htm')"> <img src="images/F09gh13.JPG" width=404 height=283 border=0 ALT="Click to view at full size."> </A>
<P><!-- caption --><B>Figure 9-13.</b> <i>Only control D is within the focus window W.</I><!-- /caption -->

<p>The method <I>setHighlight()</I> either highlights or unhighlights a control to 
indicate to the user whether the control has been selected. Although there are 
several possible ways to indicate a selection, I chose to boldface the control's font (if the 
control has a font).

<p>Finally, the method <I>move()</I> is provided to move all of the selected controls 
by some delta. This method will prove important once the user has selected 
several controls with the focus rectangle and wants to move them.

<A NAME="297"><h3>The <I>FocusRectangle</I> class</h3></A>
<p>The final support class is 
<I>FocusRectangle</I>. As its name implies, this class helps 
maintain the focus rectangle itself. The code for this class appears as follows:

<p><pre>
import com.ms.wfc.ui.*;

/**
 * Represent a focus rectangle.
 */
public class FocusRectangle
{
    // the actual rectangle
    private Rectangle frame;
    
    // the mouse location at the time the rectangle
    // was started
    private Point originalLoc;
    
    // the upper left corner of the focus
    // rectangle prior to it being moved
    private Point upperLeft;

    /**
     * Create a focus rectangle at the specified
     * mouse location.
     */
    public FocusRectangle(Point mouseLoc)
    {
        originalLoc = new Point(mouseLoc);
        upperLeft   = new Point(originalLoc);
        frame = new Rectangle(mouseLoc.x,
                              mouseLoc.y,
                              0,
                              0);
    }
 
    /**
     * Move the focus rectangle by the specified amount.
     */
    public void move(Point delta)
    {
        frame.x = upperLeft.x + delta.x;
        frame.y = upperLeft.y + delta.y;
    }
    
    /**
     * Resize the frame based on mouse movement.
     */
    public void resize(Point mouseLoc)
    {
        // if mouse moved down&#8230;
        if (mouseLoc.y &gt; originalLoc.y)
        {
            // then keep the top of the focus area set
            // to the first mouse location and move the bottom down
            frame.y      = originalLoc.y;
            frame.height = mouseLoc.y - originalLoc.y;
        }
        // if mouse moved up&#8230;
        else
        {
            // set the top to the current mouse location and
            // calculate the bottom of the frame to be the first
            // mouse location
            frame.y      = mouseLoc.y;
            frame.height = originalLoc.y - mouseLoc.y;
        }
        
        // repeat for width
        if (mouseLoc.x &gt; frame.x)
        {
            frame.x      = originalLoc.x;
            frame.width  = mouseLoc.x - originalLoc.x;
        }
        else
        {
            frame.x      = mouseLoc.x;
            frame.width  = originalLoc.x - mouseLoc.x;
        }
        
        // update the upper left corner
        upperLeft.x = frame.x;
        upperLeft.y = frame.y;
    }

    /**
     * Retrieve the rectangle.
     */
    public Rectangle getRectangle()
    {
        return frame;
    }
}
</PRE>

<p>The program creates the focus rectangle as soon as the user holds down 
the left mouse button and begins to drag it within the form. Accordingly, the 
<I>FocusRectangle()</I> constructor saves the starting location of the mouse in 
<I>originalLoc</I>. It also creates at that location a rectangle called 
<I>frame</I> that has a height and width of 0.

<p>The <I>FocusRectangle.resize()</I> method is called as the user drags the mouse 
to resize the focus rectangle. The logic for this method is slightly more complicated 
than you might expect, because it must take into consideration the fact that the user 
might create a focus rectangle by dragging the mouse in any direction: up or down, 
and left or right. (The logic would be much simpler if the user were forced to start at 
the upper left corner and drag the mouse down and to the right in order to create a 
focus rectangle.)

<p>Like the <I>SelectedControls</I> class, the 
<I>FocusRectangle</I> class provides a 
<I>move()</I> method that will be needed to move the focus rectangle&#8212;once it has been 
created&#8212;together with the components that it encompasses.

<A NAME="298"><h3>The <I>Form1</I> class</h3></A>
<p>With all of these support classes, the actual 
<I>Form1</I> class is fairly small, consisting primarily of event handlers.

<p><pre>
import com.ms.wfc.app.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;
import com.ms.wfc.html.*;

import com.ms.wfc.io.*;

public class Form1 extends Form
{
    public Form1()
    {
        // Required for Visual J++ Form Designer support
        initForm();
    }

    // the following represents the focus rectangle
    FocusRectangle focusRectangle = null;
    Point mouseLoc                = new Point();

    // members to support the moving of the selected objects
    boolean   controlsMoving          = false;
    Point     mouseOriginalLoc        = null;
    SelectedControls selectedControls = new SelectedControls();
    
    /**
     * Start the building of the focus area, or if there is
     * already a focus area and the mouse is within it, start
     * moving the objects within the focus area.
     */
    private void mouseDown(Object source, MouseEvent e)
    {
        // ignore anything but left mouse button
        if ((e.button &amp; MouseButton.LEFT) == 0)
        {
            return;
        }
        
        // if there is a focus area&#8230;
        if (focusRectangle != null)
        {
            // and the mouse is within the focus area&#8230;
            Rectangle r = new Rectangle(e.x, e.y, 0, 0);
            if (SelectedControls.isWithin(
                               r,
                               focusRectangle.getRectangle()))
            {
                // start dragging the objects within
                // the focusRectangle
                controlsMoving   = true;
                mouseOriginalLoc = new Point(e.x, e.y);
                return;
            }
        }
 
        // we aren't dragging; start building a focus area
        mouseLoc.x = e.x;
        mouseLoc.y = e.y;
        focusRectangle = new FocusRectangle(mouseLoc);
    }

    /**
     * If we are in drag control mode, then drag the controls.
     * If we are in focus mode, then resize the focus area.
     */
    private void mouseMove(Object source, MouseEvent e)
    {
        if ((e.button &amp; MouseButton.LEFT) == 0)
        {
            return;
        }
        
        if (controlsMoving)
        {
            dragControls(e);
            return;
        }
        
        if (focusRectangle != null)
        {
            dragFocusArea(e);
        }
    }

    /**
     * If we have been moving an object, then restart the
     * focus area. Restart dragging the selected objects.
     */
    private void mouseUp(Object source, MouseEvent e)
    {
        if (controlsMoving)
        {
            focusRectangle = null;
        }
        controlsMoving = false;
        invalidate();
    }
    
    /**
     * Drag the selected controls.
     */
    Point mouseDelta = new Point();
    private void dragControls(MouseEvent e)
    {
        // calculate how far the mouse has moved since
        // the dragging started
        mouseDelta.x = e.x - mouseOriginalLoc.x;
        mouseDelta.y = e.y - mouseOriginalLoc.y;

        // first move the selected controls
        selectedControls.move(mouseDelta);
        
        // now move the focus area
        focusRectangle.move(mouseDelta);
        
        // repaint the form
        invalidate();        
    }

    /**
     * Resize the focus area as a result of mouse movement.
     */
    void dragFocusArea(MouseEvent e)
    {
        // resize the focusRectangle
        mouseLoc.x = e.x;
        mouseLoc.y = e.y;
        focusRectangle.resize(mouseLoc);
                
        // find out which objects are enclosed
        selectedControls.findControls(this,
                             focusRectangle.getRectangle());

        // now force a repaint to update the focus rectangle
        invalidate();
    }

    /**
     * Repaint current form.
     */
    private void Form1_paint(Object source, PaintEvent e)
    {
        // if there is a focus rectangle&#8230;
        Graphics g = e.graphics;
        if (focusRectangle != null)
        {
            // then draw it
            g.drawFocusRect(focusRectangle.getRectangle());
        }
    }

    /**
     * Output the button's name to the edit window.
     */
    private void button_click(Object source, Event e)
    {
        Button button = (Button)source;
        String name = button.getText();
        edit.setText(name + &quot; clicked&quot;);
    }

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
    Container components = new Container();
    Button button1 = new Button();
    Button button2 = new Button();
    Button button3 = new Button();
    Button button4 = new Button();
    Edit edit = new Edit();

    private void initForm()
    {
        // &#8230;created by the Forms Designer&#8230;
    }

    /**
     * The main entry point for the application. 
     */
    public static void main(String args[])
    {
        Application.run(new Form1());
    }
}
</PRE>

<p>When the user clicks the left mouse button, the system is in one of two 
states. One state is when there is no focus rectangle, in which case the 
SelectComponents program assumes the user is creating one. A second state is when there is a 
focus rectangle already created by a previous 
<I>MouseDown</I> event, in which case the program assumes the user is trying to move the focus rectangle and the components 
that it encompasses.

<p>This dichotomy is reflected in the 
<I>Form1.mouseDown()</I> method. If there is a focus rectangle already 
(<I>focusRectangle!= null</I>), and the mouse pointer location 
is within it, <I>mouseDown()</I> sets the 
<I>controlsMoving</I> flag to <I>true</I> in order to start the 
drag process. If there is no focus rectangle, the method creates one. This method 
begins the creation and resizing of the focus rectangle.

<p>Similarly, <I>Form1.mouseMove()</I> has two parts. 
The<I> </I>method<I> </I>first checks the 
<I>controlsMoving</I> flag. If this is set, 
<I>mouseMove()</I> calls 
<I>Form1.dragControls()</I>, which calls 
<I>selectedControls.move()</I> and 
<I>focusRectangle.move()</I> to move the focus rectangle 
and any selected controls. If a focus rectangle exists and the 
<I>controlsMoving</I> flag is false, 
<I>mouseMove()</I> calls <I>Form1.dragFocusArea(). 
</I>The <I>dragFocusAre</I>a<I>()</I> method resizes 
the focus rectangle and then recalculates which controls are now included within 
the resized focus rectangle by calling 
<I>selectedControls.findControls()</I>.

<p>The <I>Form1.mouseUp()</I> method clears the 
<I>controlsMoving</I> flag to indicate that the user is no longer moving the
controls. If the 
<I>controlsMoving</I> flag was set, it also clears the 
<I>focusRectangle</I> to make the focus rectangle disappear.

<p>The <I>Form1_paint()</I> method is simple. The WFC controls that are on the 
form know how to repaint themselves. All that 
<I>Form1_paint()</I> must draw is the focus rectangle, if it exists.

<p>The <I>button_click()</I> method was created to handle the click event
for each of the buttons, to demonstrate that these buttons still work even
after the user has moved them about.

<A NAME="299"><H2>The Results</H2></A>

<p>Figure 9-14 shows the SelectComponents application running with the focus 
rectangle, which has been drawn to encompass two of the four buttons. Figure 9-15 shows 
the buttons after being dragged to a new location. Even in their new locations, all 
four of the buttons remain functional.

<p><img src="images/F09gh14.JPG" width=256 height=284 border="0">
<P><!-- caption --><B>Figure 9-14.</b> <i>Creating a focus rectangle encompassing
the top two buttons.</I><!-- /caption -->

<p><img src="images/F09gh15.JPG" width=256 height=284 border="0">
<P><!-- caption --><B>Figure 9-15.</b> <i>Moving the button controls by dragging the
focus rectangle.</I><!-- /caption -->

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
To drag the focus area, the user must click on an area within the 
focus rectangle but outside any of the controls. If you click within a control 
such as the button, WFC will field the mouse down event before 
<I>SelectComponts</I> gets a chance to interpret it.
</blockquote></div>

</BODY>
</HTML>




