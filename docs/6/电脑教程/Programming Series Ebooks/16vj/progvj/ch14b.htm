<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>Applet Basics</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch14a.htm", "ch14c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="472"><H1>Applet Basics</H1></A>

<p>In this section, we'll go over applet basics. We'll start with a series of simple examples that demonstrate the principles of applet development. We'll use this opportunity 
to study such diverse but interrelated technologies as HTML files, browsers, Just-in-Time (JIT) compilers, and machine-independent code. We'll expand on this knowledge in later sections of the chapter.

<A NAME="473"><H2>Overview</H2></A>

<p>You can run Visual J++ 6 .EXE applications on any of the Microsoft Win32 operating systems without the help of external files or tools. By contrast, Java applets exist 
only in the context of an HTML file. You run an applet by using a Web browser to open an HTML page that is linked to that applet.

<P><DIV CLASS="sidebar"><BLOCKQUOTE>
<P><B>The Java Virtual Machine</B>

<p>Normal executable files (.EXE files) such as those generated by Visual C++ contain machine code designed to run on the base processor; in the case of the PC, this code is 80x86 machine code. The Pentium processor uses the same machine instructions as the other members of the 80x86 family.

<p>All Java compilers, including Visual J++ 6, compile Java source code into a special machine language called Virtual Machine (VM) byte code. This machine language is called <I>virtual</I> because the VM doesn't really exist. Instead, each Java-equipped browser has an interpreter inside it capable of executing VM byte codes on the base machine. In other words, a browser for a PC executes the VM byte codes on an 80x86_equipped machine. A Macintosh browser interprets VM byte codes into PowerPC instructions. A browser on a 
UNIX workstation interprets VM byte codes into the native machine instructions for the workstation's processor.

<p>The use of VM byte codes is almost a necessity for applets to run on the Web, because the applet programmer never knows what type of browser might access the Web page. Using VM byte codes provides platform independence so that the applet executes in the same way no matter what base machine it's running on. In addition, the format of the VM byte codes provides program integrity. If anyone were to place a virus in a .class file stored on the base machine, the browser would instantly detect the fact that the file had been edited and would refuse to execute it.

<p>Finally, VM-based executables are much smaller than normal .EXE files. You might have noticed how small the Visual J++ 6_generated .EXE files are compared to conventional .EXE files such as those generated by Visual C++. This size difference is largely because C++ programs link support functions, such as those that make up the standard C++ library, into the .EXE files. By contrast, Java programs leave the standard Java support classes in the VM 
environment. All that is contained in the .class file are the instructions the programmer writes. This size difference is important when the .class file is being transmitted 
through a conventional modem.

<p>The downside of using VM byte codes is that interpreting this virtual language is much slower than executing native code. To address this problem, the Microsoft JIT compiler (which is part of the Java VM) compiles the VM byte codes into 80x86 machine code and then executes the native machine code. Although the JIT compilation process takes a small amount of time, the resulting code is about as fast as a conventional (non-Java) .EXE program. (Refer back to 
Chapter 1, where we compared the execution speed of a Visual J++ 6 application to that of a C++ program.)

<p>To further enhance the Visual J++ 6 experience, Microsoft has placed the VM along with the JIT compiler in the Win32 operating system. This allows Visual J++ 6_generated .EXE files to use the same JIT compiler that applets use.
</BLOCKQUOTE></DIV>

<p>Let's use the simple &quot;Hello, world&quot; applet to examine the relationship 
between an HTML page, an applet, and you&#8212;the programmer.

<A NAME="474"><H2>The &quot;Hello, world&quot; Applet</H2></A>

<p>Our first applet must be the famous &quot;Hello, world&quot; applet. Not only does convention demand this, but also such a simple applet allows us to concentrate on the details of how applets are loaded and executed rather than on how an applet is coded.

<p>It would be easy enough to build the &quot;Hello, world&quot; example using the Visual J++ 6 Applet Wizard. In fact, it's a little tricky to convince Visual J++ not to use 
the Applet Wizard. However, the applet code the Applet Wizard creates is overkill for an applet as simple as this one. Furthermore, I believe that you should learn to do things manually before using automatic tools. (For example, it's a good idea to learn to multiply by hand before using a calculator.) Without this background, you'll find it difficult to get a feel for what the Applet Wizard is doing for you.

<A NAME="475"><H3>Creating the &quot;Hello, world&quot; project</H3></A>

<p>From the File menu, choose New Project. Select Visual J++ 
Projects<I> </I>in the left pane of the New Project window to reveal the single option Empty Project in the right 
pane. Choose Empty Project.

<p>Create a new subdirectory named Applets under the directory in which you're storing your Visual J++ programs. Enter this directory into the Location edit box. (If you prefer, you can use the Browse feature.) Finally, enter the project name HelloWorld. When your window looks similar to the one shown in Figure 14-1 (depending on the path to your Applets directory), click Open. You now have a solution with a single empty project.

<p><A HREF="javascript:fullSize('f14gh01x.htm')"> <img src="images/f14gh01.jpg" width=404 height=249 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><b>Figure 14-1.</b> <i>Creating an empty project.</i><!-- /caption -->

<A NAME="476"><H3>Adding an applet to the project</H3></A>

<p>Before we can do anything, we need to add an applet to the project. With the HelloWorld project highlighted in Project Explorer, choose Add Item from the Project 
menu. From the New tab in the Add Item window, select Class and enter the class name HelloWorld. Visual J++ 6 adds the file HelloWorld.java, which contains an empty class, to the previously empty project.

<p>Enter the following boldface code into the class you've just created:

<p><pre>
<B>import java.applet.Applet;
import java.awt.Graphics;</B>

public class HelloWorld<B> extends Applet</B>
{
<B>    public void paint(Graphics g)
    {
        g.drawString(&quot;Hello, world&quot;, 10, 10);
    }</B>
}
</PRE>

<p>Let's not analyze the code just yet. We'll wait until you've seen it execute.

<A NAME="477"><H3>Creating the &quot;Hello, world&quot; HTML file</H3></A>

<p>To run our new applet, we'll need an HTML file from which it can run. Select Add Item again. This time, select Web Page. Enter HelloWorld.htm in the Name text box, and click Open.

<p>A new HTML file-specific editor appears. This editor looks a little like the Forms Designer we've used in earlier chapters. Notice the three tabs along the bottom of the editor: Design, Source, and Quick View.

<p>The purpose of the Design tab is roughly the same for HTML files as the Forms Designer's purpose is for WFC-based applications. It allows you to drag tools from the HTML section of the Toolbox onto the HTML page. (The tools in the HTML section are not the Java tools we've used up until now.) As you'll see later, certain aspects of the HTML file limit what the HTML Designer can do.

<p>The Source tab plays the role of the Visual J++ 6 source code editor. It allows you to examine and edit the HTML source statements. And finally, the Quick View tab allows you to view many (but not all) of the features present in the HTML file without the sometimes tedious process of opening a browser.

<p>Notice that in Design view the HTML page appears to be empty. Select Source view, however, and you'll see a series of HTML tags. These default system-generated tags represent merely the framework of an HTML page and have no displayable content.

<P><DIV CLASS="caution"><BLOCKQUOTE>
<B>CAUTION</B>
<HR>If you're running Visual J++ 6 in SDI mode, you might not see the actual features of the applet displayed in the IDE viewers, especially in the file I/O examples later in this chapter. You might have better luck previewing your applets in MDI mode.
</blockquote></div>

<P><DIV CLASS="sidebar"><BLOCKQUOTE>
<P><B>Introduction to HTML</B>

<p>Entire books are devoted to HTML. I couldn't possibly cover the entire topic in just a few lines. Fortunately, we need only a few HTML tags for the applets in this chapter. The initial HTML framework Visual J++ 6 creates for us 
looks like this:

<p><pre>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META NAME=&quot;GENERATOR&quot; Content=&quot;Microsoft Visual Studio 6.0&quot;&gt;
&lt;TITLE&gt;&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;

&lt;P&gt;&amp;nbsp;&lt;/P&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<p>All HTML tags are bracketed using angle brackets (&lt;&gt;). In addition, tags that surround a block of information in the HTML file begin with a tag and end with the same tag preceded by a slash. Thus, the &lt;HTML&gt; tag at the beginning of the HTML file is bracketed with the &lt;/HTML&gt; tag at the end. (The HTML tags in this example are all uppercase, but HTML tags are not case sensitive.)

<P>Any HTML file has two main sections: the head and the body. The head includes only a few tags that apply to the entire file. The &lt;TITLE&gt; tag defines the name that appears in the browser's title bar when the page is displayed. The browser ignores the &lt;META&gt; tag, which informs you and any HTML editor you might use how the HTML file was created. (You might see &lt;META&gt; tags with attributes other than the NAME attribute shown in this code, but the browser universally ignores them.)

<P>The display tags begin after the &lt;BODY&gt; tag. The tag &lt;P&gt; introduces a paragraph, &lt;BR&gt; breaks a sentence (like a newline character), and &lt;HR&gt; draws a horizontal line across the page. Any text that appears outside angle brackets is displayed in the browser.

<p>The HTML-interpreting browser treats all white space the same. White space includes a space, tab, vertical tab, and a new line. Specifically, entering a newline character at the end of a series of text doesn't force the start of a new line (as in a simple text editor) or a paragraph (as in Microsoft Word).

<p>The following HTML file generates the results shown in Figure 14-2.

<p><pre>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META NAME=&quot;GENERATOR&quot; Content=&quot;Microsoft Visual Studio 6.0&quot;&gt;
&lt;TITLE&gt;Hello, world&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;HR&gt;
Hello, world
&lt;HR&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<p><A HREF="javascript:fullSize('f14gh02x.htm')"> <img src="images/f14gh02.jpg" width=404 height=284 border=0 ALT="Click to view at full size."> </A>

<P><!-- caption --><B>Figure 14-2.</b> <i>The output from a simple HTML file in the Internet Explorer 4 browser.</I><!-- /caption -->
</BLOCKQUOTE></DIV>

<P>In the early years of HTML, the &lt;APPLET&gt; tag was used to include calls to applets in an HTML file. Although the &lt;APPLET&gt; tag is still supported, today the more flexible &lt;OBJECT&gt; tag is the preferred way to include applet calls in an HTML file.

<p>To execute our HelloWorld applet, modify the default HTML framework contained in the HelloWorld.htm file so that it looks like the following:

<p><pre>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META NAME=&quot;GENERATOR&quot; Content=&quot;Microsoft Visual Studio 6.0&quot;&gt;
&lt;TITLE&gt;First Applet&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;HR&gt;
&lt;OBJECT CODE=&quot;HelloWorld.class&quot;
        HEIGHT=100
        WIDTH=100&gt;
&lt;/OBJECT&gt;
&lt;HR&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<p>This &lt;OBJECT&gt; tag specifies that the applet code resides in the file HelloWorld.class. (The name of the .class file is case sensitive because Java is case sensitive.) The HEIGHT and WIDTH attributes specify the initial size in pixels of the window in which the applet is to appear (normally referred to as the applet window). The &lt;/OBJECT&gt; tag closes the applet command. Later in this chapter, we'll see the types of commands that can appear between the &lt;OBJECT&gt; and &lt;/OBJECT&gt; tags.

<A NAME="478"><H3>Executing the result</H3></A>

<p>To execute the applet, we first need to set the launch properties. From the Project menu, choose HelloWorld Properties. In the When Project Runs, Load drop-down list, select HelloWorld.htm and choose OK. Now compile the project by selecting the Build option from the Debug menu. Click Start in the Debug menu to run the program. Visual J++ 6 opens the browser to execute the HelloWorld.htm file. The results are shown in Figure 14-3.

<p>Notice the gray box. This is the 100-by-100-pixel applet window specified within the &lt;OBJECT&gt; tags. The <I>Hello, world</I> message appears at the top of this applet window. In addition, the two horizontal lines specified by the &lt;HR&gt; tags in the HTML file surround the applet window.

<p><img src="images/f14gh03x.jpg" width=405 height=353 border=0> 

<p><!-- caption --><b>Figure 14-3.</b> <i>The HelloWorld applet executing within Internet Explorer 4.</i><!-- /caption -->

<A NAME="479"><H3>Loading an applet</H3></A>

<p>Let's go through the steps involved in loading and executing the HelloWorld applet. First the browser loads the HelloWorld HTML file. The &lt;OBJECT&gt; tag within the HTML file indicates to the browser that it is to load an executable file. The CODE attribute indicates that the name of the file to load is HelloWorld.class and that it contains 
VM byte codes. Unless told otherwise, the browser assumes that the .class file is located in the same directory on the same server as the HTML file.

<p>Once the HelloWorld.class file is loaded, the browser begins executing it. In Internet Explorer, the .class file is first compiled using the JIT compiler, and the resulting machine code is executed. Other browsers might take the same approach, or they might simply use an interpreter to execute the byte codes directly.

<p>Because the applet refers to other classes, they are loaded as well. The browser begins by looking through the built-in classes that make up the standard Java library. (In the case of machines executing Microsoft VM for Java, these built-in classes include WFC). For example, the <I>Applet</I> class is always present on the client side. If 
the browser can't find the class among the built-in classes, it then inspects the cached files. If the browser can't find the class there either, it looks back on the server for the .class file.

<p>An interesting property of applets is that classes, especially user-defined classes, aren't loaded until execution absolutely requires it. This minimizes the amount 
of information being passed over a potentially slow modem&#8212;there's no need to pass the byte codes for a class that is never accessed.

<A NAME="480"><H3>Examining the HelloWorld applet code</H3></A>

<p>Let's examine the HelloWorld applet source code to see how it works. The <I>HelloWorld</I> class extends the <I>Applet </I>class. This base class of all applets provides a number of methods that establish the interface between the Java code and the browser.

<p>One of these interface methods is the method  <I>paint()</I>. Java invokes this method whenever the browser signals that the applet window needs to be redrawn.

<p>When the browser first displays the HTML page, the applet window is invalid and requires repainting. The Java core within the browser invokes the <I>paint()</I> method to create the display.

<p>A window can be invalidated in other ways, such as when the user minimizes and then restores the browser. Parts of the applet window might be invalidated even if the user simply scrolls the HTML page.

<p>Our version of <I>paint()</I> prints the &quot;Hello, world&quot; message.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
The <I>paint()</I> method in applets plays the same role as the <I>paint()</I> method in applications, but with applets the browser (instead of Win32) performs the <I>paint()</I> calls .
</blockquote></div>

<p>See Chapter 9, <A HREF="ch09a.htm">The <I>Graphics Class</I></A>, for a discussion of overriding the <I>paint()</I> method in WFC applications.

<A NAME="481"><H3>Examining the Visual J++ 6 HTML editor</H3></A>

<p>Now that our applet is compiled and working, let's return to the applet editor. In Design mode, select within the two horizontal lines. An applet window containing the &quot;Hello, world&quot; message appears.


<p>Now switch to Source mode. You can see the normal HTML tags, but again the &lt;OBJECT&gt; tag is replaced by the applet output, as shown in Figure 14-4. (You can select View Controls As Text from the View menu to force the source code editor to display the &lt;OBJECT&gt; tag rather than the applet output.)

<p>Finally, the Quick View mode displays the HTML output very much like it would look in an Internet browser.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
The applet window might initially appear as a blank box. You can make the applet appear in the window by clicking inside this box.
</blockquote></div>

<p><IMG SRC="images/f14gh04.jpg" width=391 height=395 BORDER="0">

<p><!-- caption --><b>Figure 14-4.</b> <i>The HTML editor showing the applet output in Source mode.</i><!-- /caption -->

<A NAME="482"><H2>Applet Special Methods</H2></A>

<p>All Java applications share one unique method: 
<I>public void main(String[])</I>. Application execution always begins with this method. In effect, this method forms 
the handoff link from Win32 into the application. (There are many links from the application back into Win32. For example, all the Visual J++ 6 methods that perform Win32 API calls must call into Win32.)

<p>Rather than having just a single <I>main()</I> method, applets have numerous methods that the browser can use to hand control to the applet. One example is the <I>paint()</I> method we saw in the HelloWorld applet. Four other methods are key to a browser's communication with an applet.

<A NAME="483"><H3>Special methods</H3></A>

<p>The four methods that have particular importance in the birth and death of an applet are <I>init()</I>, <I>start()</I>, <I>stop()</I>, and <I>destroy()</I>. The following sequence demonstrates how the browser uses these methods:
<OL>
<P><li> The browser loads the .class file referenced by the HTML file. The class constructor is invoked immediately after the class is loaded.

<P><li> The browser lays out the objects defined in the HTML file in the browser. This step includes creating the applet window.

<P><li> The browser invokes <I>init()</I> to allow the applet to initialize any objects that are to appear in the applet window.

<P><li> The browser invokes <I>start()</I> immediately prior to displaying the HTML file that contains the applet.

<P><li> The HTML file is displayed.

<P><li> The browser invokes <I>stop()</I> immediately after the HTML page that contains the applet is replace by a new HTML page. (Generally, this replacement occurs because the user has navigated to a new HTML page.)

<P><li> The browser invokes the <I>destroy()</I> method prior to stopping the applet and reclaiming the memory occupied by the applet.
</OL>

<p>At the time the class constructor is invoked, the browser isn't prepared for the program to display any objects. Our applet performs in the <I>init()</I> method much of the work our WFC applications performed in the class constructor through the call to <I>initForm()</I>.

<p>The dichotomy between the <I>init()</I>/<I>destroy()</I> and the <I>start()</I>/<I>stop()</I> methods might not be clear. The browser invokes the <I>init()</I> method followed by the <I>start()</I> method when the HTML page is first displayed. As the user moves to the next HTML page, the browser invokes the <I>stop()</I> method to place the applet in a dormant state; however, the actions taken by the <I>init()</I> method remain valid. The browser can hold 
off calling <I>destroy()</I> as long as the HTML file is still on the &quot;back&quot; list.

<p>If the user returns to the HTML page containing the HTML file by clicking the browser's &quot;back&quot; button, the browser calls the <I>start()</I> method to &quot;reenergize&quot; the applet. This process saves execution time by avoiding unnecessary calls to the relatively expensive <I>init()</I> method.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
Although recommended, this sequence is not enforced. Some 
browsers call <I>destroy()</I> whenever the user leaves the HTML page containing the applet, for whatever reason. These browsers must call <I>init()</I> if the user redisplays the HTML page.
</blockquote></div>

<A NAME="484"><H3>Demonstrating the special methods</H3></A>

<p>The use of the special methods <I>init()</I>, 
<I>start()</I>, <I>stop()</I>, and <I>destroy()</I> is demonstrated in the following SpecialMethods applet. Let's create an applet in the Applets subdirectory using the same technique described for the HelloWorld<I> </I>applet: create an empty project and then add a class named <I>SpecialMethods</I> and an HTML file named SpecialMethods.htm.

<A NAME="485"><H3>The code</H3></A>

<p>Edit the SpecialMethods.java file so that it looks like the following:

<p><pre>
import java.applet.Applet;
import java.awt.*;
/**
 * Demonstrate the special methods init(),
 * start(), stop(), and destroy().
 */
public class SpecialMethods extends Applet
{
    // declare a counter for each method
    public static int inits    = 0;
    public static int starts   = 0;
    public static int stops    = 0;
    public static int destroys = 0;
    public static int paints   = 0;

    /**
     * Display the number of each event.
     */
    public void paint(Graphics g)
    {
        // count the number of paints
        paints++;
        
        // get the font height
        FontMetrics fm = g.getFontMetrics();
        int height = fm.getHeight();
        
        // add a tad to the font height and vertically
        // space each line by that much
        height += 5;
        int yOffset = 0;
        yOffset += height;
        g.drawString(&quot;inits = &quot;    + inits,    10, yOffset);
        yOffset += height;
        g.drawString(&quot;starts = &quot;   + starts,   10, yOffset);
        yOffset += height;
        g.drawString(&quot;stops  = &quot;   + stops,    10, yOffset);
        yOffset += height;
        g.drawString(&quot;destroys = &quot; + destroys, 10, yOffset);
        yOffset += height;
        g.drawString(&quot;paints = &quot;   + paints,   10, yOffset);
    }

    /**
     * The following methods increment the respective
     * counters.
     */
    public void init()
    {
        inits++;
        invalidate();
    }
    public void start()
    {
        starts++;
        invalidate();
    }
    public void stop()
    {
        stops++;
        invalidate();
    }
    public void destroy()
    {
        destroys++;
        invalidate();
    }
}
</PRE>

<p>You can see that the four methods at the bottom of the class do nothing more than increment their respective counters and then invalidate the applet window. 
The <I>paint()</I> method displays all these counters and its own counter.

<p>The <I>paint()</I> method begins by incrementing its counter. The <I>paint()</I> method continues by retrieving the <I>FontMetrics</I> object from the <I>Graphics</I> object <I>g</I> passed to it. This <I>FontMetrics</I> object contains an assortment of information about the current font, including its height, width, style (such as italics), and so forth. The <I>paint()</I> method takes the font height and adds 5 pixels. This resulting <I>height</I> value is used as the interline spacing for each line as <I>paint()</I> goes down the list, outputting each counter. (The 5 pixels are added to provide a certain amount of blank space between lines.)

<A NAME="486"><H3>The HTML file</H3></A>

<p>Edit the default SpecialMethods.htm file in Source mode to appear as follows:

<p><pre>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META NAME=&quot;GENERATOR&quot; Content=&quot;Microsoft Visual Studio 6.0&quot;&gt;
&lt;TITLE&gt;&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;

&lt;P&gt;
&lt;OBJECT CODE = &quot;SpecialMethods.class&quot;
        HEIGHT = 150
        Width  = 100&gt;
&lt;/OBJECT&gt;
&lt;/P&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<A NAME="487"><H3>The result</H3></A>

<p>Compile the project, and then view the SpecialMethods.htm file in Internet Explorer 4 or some other browser. The <I>inits</I>, <I>starts</I>, and <I>paints</I> counters are initially displayed as 1, and the <I>stops</I> and 
<I>destroys</I> counters appear as 0.

<P>You'll find it encouraging that the paint count displays a value of 1 under Internet Explorer 4. This implies that the applet was painted only a single time during the display of the HTML page. Even as you resize the browser, the <I>paints</I> counter value stays at 1, until you resize the browser to the point that the applet window is partially obscured, at which time the <I>paints</I> counter value begins to increase. As soon as you stop resizing, the <I>paints</I> counter immediately stops updating. Throughout 
the entire resizing exercise, the <I>inits</I>, <I>starts</I>, <I>stops</I>, and <I>destroys</I> counters remain at their initial values.

<P>Navigate to another page and return to the SpecialMethods page using the browser's back button. Figure 14-5 shows the resulting display.

<P>As you can see from the counters, Internet Explorer 4 destroys the applet whenever the user jumps to another page and then restarts the applet when the user returns.

<P><A HREF="javascript:fullSize('f14gh05x.htm')"> <img src="images/f14gh05.jpg" width=404 height=331 border=0 ALT="Click to view at full size."> </A>

<P><!-- caption --><B>Figure 14-5.</b> <i>The SpecialMethods applet displaying the number of times that each special method has been invoked.</I><!-- /caption -->

<A NAME="488"><H2>Displaying Abstract Windowing Toolkit Objects</H2></A>

<p>In Chapter 4, <A HREF="ch04a.htm">Generic Windowed Applications</A>, you saw how windowed applications can use the machine-independent Abstract Windowing Toolkit (AWT). AWT is also available for applet use. In fact, you might argue that AWT was designed 
specifically for applets to use. The classes that make up AWT are already present in every Java-enabled browser.

<P><DIV CLASS="sidebar"><BLOCKQUOTE>
<P><B>Applets and WFC</B>

<p>Under normal circumstances, you shouldn't access WFC from applets. WFC is not part of the standard Java library that is accessible to all browsers; WFC is accessible only to Internet Explorer version 4 or higher. Thus, if your 
applet refers to a WFC class, the browser will be forced to load large sections of the WFC library over the Internet (assuming that you placed the WFC classes in a directory on the server where the browser could find them). The time 
required to perform such a download would be unacceptable to the user.

<P>Internet Explorer 4 does have access to the WFC classes. Thus, if you have complete control of the user community, such as would be the case in a small intranet community, restricting all users to a single version of a single 
browser might be acceptable. From my experience on the intranet of even a medium-sized company, however, this restriction is impractical.
</BLOCKQUOTE></DIV>

<p>AWT use in applets isn't that much different from AWT use in applications. The following AWTApplet applet demonstrates the principle. This applet opens two labeled text fields, one above the other. Below the text fields is a button the user can click to transfer the contents of the upper text field to the lower text field. (For now, the button does nothing; we'll add functionality to it in the next section).

<A NAME="489"><H3>The code</H3></A>

<p>To create the AWTApplet applet, you begin by creating an empty project named AWTApplet1. (We'll add more features to later versions.) Add a class named AWTApplet and an HTML file named AWTApplet.htm. Update the AWTApplet.java source file as follows:

<p><pre>
import java.applet.Applet;
import java.awt.*;

public class AWTApplet extends Applet
{
    TextField tfSource = new TextField();
    TextField tfTarget = new TextField();
    Button    button   = new Button(&quot;Transfer&quot;);
    
    public void init()
    {
        // create two text field panels
        Panel sPanel = createTextFieldPanel(
                            &quot;Source&quot;,
                            tfSource);
        Panel tPanel = createTextFieldPanel(
                            &quot;Target&quot;,
                            tfTarget);

        // and a button panel
        Panel bPanel = createButtonPanel(button);

        // set them in a single-column grid layout
        // (this will lay them out vertically)
        GridLayout gridLayout = new GridLayout();
        gridLayout.setColumns(1);
        gridLayout.setRows(0);
        gridLayout.setVgap(10);
        this.setLayout(gridLayout);
        this.add(sPanel);
        this.add(tPanel);
        this.add(bPanel);
    }

    /**
     * Create a panel with a label and a text field
     * offset from the left and right boundaries.
     */
    Panel createTextFieldPanel(String label, TextField t)
    {
        Panel panel = new Panel();
        panel.setLayout(new BorderLayout());

        Panel subPanel = new Panel();
        subPanel.setLayout(new BorderLayout());
        subPanel.add(&quot;North&quot;, new Label(label));
        subPanel.add(&quot;South&quot;, t);
        
        panel.add(&quot;West&quot;, new Label(&quot; &quot;));
        panel.add(&quot;East&quot;, new Label(&quot; &quot;));
        panel.add(&quot;Center&quot;, subPanel);
        
        return panel;
    }

    /**
     * Create a panel with a single button in the
     * center.
     */
    Panel createButtonPanel(Button button)
    {
        // establish a 3x3 grid layout
        // (the following is crude, but it does the
        // job without resorting to the more complicated
        // GridBagLayout)
        Panel panel = new Panel();
        panel.setLayout(new GridLayout(3, 3));
        
        // fill the first row with blanks
        panel.add(new Label(&quot;  &quot;));
        panel.add(new Label(&quot;  &quot;));
        panel.add(new Label(&quot;  &quot;));

        // on the second row, put the button in the center
        panel.add(new Label(&quot;  &quot;));
        panel.add(button);
        panel.add(new Label(&quot;  &quot;));

        // fill the third row with blanks
        panel.add(new Label(&quot;  &quot;));
        panel.add(new Label(&quot;  &quot;));
        panel.add(new Label(&quot;  &quot;));

        return panel;
    }
}
</PRE>

<p>The code for this applet looks a lot more complicated than it really is. (This seeming complexity is typical of AWT applets.) The <I>init()</I> method begins by creating a panel containing the source <I>TextField</I> object and an identical panel containing the target <I>TextField</I> object. We'll eventually copy the contents of the source field to the target field. Finally, the applet creates a panel containing the Transfer button.

<P>The <I>init() </I>method uses a <I>GridLayout</I> layout manager to create the display. The purpose of this layout manager is to create spreadsheet-like grids with columns 
of equal width and rows of equal height. The <I>init()</I> method of our AWTApplet applet specifies a single column, and as many rows as are required (designated by the <I>setRows(0)</I> command.). Creating a grid with only a single column creates what is essentially a vertical layout.

<P>The <I>AWTApplet.createTextFieldPanel()</I> method is perhaps the most complicated of the methods in this class. This method creates an inner panel (<I>subpanel</I>) in which it places the label and the <I>TextField</I> object. The method then places this inner panel in the center of an outer panel (<I>panel</I>) that contains an empty label on the left and another label on the right. These empty labels place a small space on the left and right between the applet boundary and the label/text field panel.

<P>The <I>AWTApplet.createButtonPanel()</I> method is crude but effective. This method creates a 3-by-3 grid layout and places the button in the middle. This placement gives the button a pleasing appearance with suitable space around it in the applet window.

<A NAME="490"><H3>The HTML file</H3></A>

<p>The HTML file for AWTApplet has the standard features you've seen in other applets:

<p><pre>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META NAME=&quot;GENERATOR&quot; Content=&quot;Microsoft Visual Studio 6.0&quot;&gt;
&lt;TITLE&gt;&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;

&lt;P&gt;
&lt;OBJECT CODE = &quot;AWTApplet.class&quot;
        HEIGHT = 200
        WIDTH  = 300&gt;
&lt;/OBJECT&gt;        
&lt;/P&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<A NAME="491"><H3>The result</H3></A>

<p>When viewed from the Designer after compiling, the Source window appears as shown in Figure 14-6.

<p><A HREF="javascript:fullSize('f14gh06x.htm')"> <img src="images/f14gh06.jpg" width=404 height=359 border=0 ALT="Click to view at full size."> </A>

<P><!-- caption --><B>Figure 14-6.</b> <i>The appearance of the Designer's Source window when viewing AWTApplet.</I><!-- /caption -->

<A NAME="492"><H2>Handling Events</H2></A>

<p>Our AWTApplet applet is fine so far, but is somewhat unimpressive because the Transfer button doesn't do anything. To activate the Transfer button, we must add an 
event handler, which is what we'll do for the AWTApplet2 project.

<A NAME="493"><H3>The code</H3></A>

<p>The code for the event-capable version of the AWTApplet applet is shown below. The majority of the code in this version is the same as that in its predecessor and isn't shown here.

<p><pre>
import java.applet.Applet;
import java.awt.*;
import java.awt.event.*;

public class AWTApplet extends Applet
{
    TextField tfSource = new TextField();
    TextField tfTarget = new TextField();
    Button    button   = new Button(&quot;Transfer&quot;);
    
    public void init()
    {
        // &#8230;the same as previous version&#8230;
        
        // add the transfer button event code
        addTransfer();
    }

	.
	.
	.

    /**
     * Add the transfer capability to the specified event.
     */
    void addTransfer()
    {
        // make the target field read-only
        tfTarget.setEditable(false);

        // now add a transfer action listener to perform
        // the transfer 
        button.addActionListener(new TransferActionListener());
    }

    /**
     * Implement the ActionListener interface.
     */
    class TransferActionListener implements ActionListener
    {
        /**
         * Transfer text from the source text field to
         * the target text field.
         */
        public void actionPerformed(ActionEvent ae)
        {
            String s = tfSource.getText();
            tfTarget.setText(s);
        }
    }
}
</PRE>

<p>The call to <I>AWTApplet.addTransfer()</I> in <I>init()</I> activates the transfer button. The <I>addTransfer()</I> method begins by making the target text field read-only. The method then adds an <I>ActionListener</I> interface to the transfer button. An 
<I>ActionEvent</I> object is created when the user clicks the button. The <I>ActionListener</I> interface plus the 
<I>ActionEvent</I> are defined in the <I>java.awt.event</I> package.

<P>The inner class <I>TransferActionListener</I> implements the <I>ActionListener</I> interface by providing an 
<I>actionPerformed()</I> method. This method reads the text out of the source text field and stores it into the target text field.

<A NAME="494"><H3>The result</H3></A>

<p>The AWTApplet2 project uses the same HTML as AWTApplet1. Figure 14-7 shows AWTApplet when viewed from the Quick View mode of the Applet HTML editor. To create this display, I entered text into the source text field and clicked the 
Transfer button to copy the contents of the source text field to the target text field.

<P><IMG SRC="images/f14gh07.jpg" width=348 height=298 BORDER="0">

<P><!-- caption --><B>Figure 14-7.</b> <i>The results of the event-capable AWTApplet.</I><!-- /caption -->

<P><DIV CLASS="sidebar"><BLOCKQUOTE>
<P><B>Listeners</B>

<P>The <I>ActionListener</I> approach is a means of event handling we discussed briefly in Chapter 5, <A HREF="ch05a.htm">Microsoft Windows Applications</A>. WFC prefers the easier-to-use delegate approach. However, AWT uses the listener approach introduced 
in Java 1.1.

<P>In the listener approach, for every action that can befall an AWT control, there is a method with the following syntax:

<p><pre>
&lt;control&gt;.add&lt;X&gt;Listener(my&lt;X&gt;Listener)
</PRE>

<p><I>X</I> represents the name of some action type, and 
<I>my&lt;X&gt;Listener</I> represents an object of some locally defined class <I>My&lt;X&gt;Listener</I>, which implements the <I>&lt;X&gt;Listener</I> interface. An 
<I>&lt;X&gt;Listener</I> interface generally defines a single method of the form <I>public void &lt;X&gt;Performed(&lt;X&gt;Event)</I>. The most common value of <I>&lt;X&gt;</I> is <I>Action</I>, which is demonstrated in the AWTApplet2 code statement shown here:

<p><pre>
button.addActionListener(new TransferActionListener());
</PRE>

<p>The action events are loosely defined as what the control receives when the user activates the control. Thus, the action event for a button is invoked when the user clicks the button.

<P>This approach to event handling is powerful and flexible. The primary disadvantage of this approach compared with the delegate approach is the need to implement a separate class for each event handled. (Refer to <A HREF="ch05a.htm">Chapter 5</A> for more on delegates.)
</BLOCKQUOTE></DIV>

<A NAME="495"><H2>Passing Arguments to the Applet</H2></A>

<p>As you saw in Part II, you can pass information to applications in several ways. The most straightforward way is through the array of strings passed to <I>main() </I>via the command line. An applet has no command line. However, you can pass arguments to the applet from the HTML file via the HTML &lt;PARAM&gt; tag. The &lt;PARAM&gt; tag defines a parameter by name and assigns it a string value. The applet can query this parameter by its name to read the value.

<P>To demonstrate the use of the &lt;PARAM&gt; tag, the following ParamDisplay applet displays the name the HTML file passes to it in the TEXT parameter in the font and point size specified in the FONT and SIZE parameters.

<A NAME="496"><H3>The code</H3></A>

<p>The key to this applet&#8212;and any other applet that reads parameter data from the HTML file&#8212;is the <I>getParameter(String name)</I> method. This method accepts the name of the parameter and returns the corresponding value as a <I>String</I>.

<p>If the parameter with the name passed to <I>getParameter()</I> isn't in the HTML file, the method returns <I>null</I>. Because the applet programmer generally has no control over the HTML files that call the applet, the applet must account for the fact that any given parameter might not be present in the HTML file. If a specific parameter is missing from the HTML file, the applet must assign a default value.

<p>The following ParamDisplay applet demonstrates how this works:

<p><pre>
import java.applet.Applet;
import java.awt.*;

public class ParamDisplay extends Applet
{
    // define the names of the parameters
    String textName = &quot;TEXT&quot;;
    String fontName = &quot;FONT&quot;;
    String sizeName = &quot;SIZE&quot;;
    
    // define the default values for each
    String textDefault = &quot;No text&quot;;
    String fontDefault = &quot;Courier&quot;;
    int    sizeDefault = 12;

    // now declare the actual values
    String text;
    String font;
    int    size;
    
    // resulting font
    Font f;
    
    public void init()
    {
        // get the text to display
        text = this.getParameter(textName);
        if (text == null)
        {
            text = textDefault;
        }
        
        // next the font
        font = this.getParameter(fontName);
        if (font == null)
        {
            font = fontDefault;
        }
        
        // finally the size, which must be converted
        // from string to integer
        String sSize;
        sSize = this.getParameter(sizeName);
        size = sizeDefault;
        if (sSize != null)
        {
            size = Integer.parseInt(sSize);
        }
        
        // create a font using those parameters
        Font f = new Font(font, Font.PLAIN,size);
    }

    /**
     * Paint the text specified in the HTML
     * file with the specified font and size.
     */
    public void paint(Graphics g)
    {
        if (f != null)
        {
            g.setFont(f);
        }
        int yOffset = size + 10;
        g.drawString(text, 10, yOffset);
    }
}
</PRE>

<p>If we take the TEXT parameter as an example, the 
<I>textName</I> variable is assigned the value 
<I>TEXT</I>. A default value for this parameter is provided in the string <I>textDefault</I>. The resulting string is stored in <I>text</I>.

<P>As the applet starts, the browser invokes 
<I>init()</I>. This method calls <I>getParameter()</I> to retrieve the value of the parameter named <I>textName</I> and stores the result in <I>text</I>. If the value returned by <I>getParameter()</I> is <I>null</I>, <I>init()</I> assigns <I>text</I> the default value stored in <I>textDefault</I>.

<P>This pattern is repeated for each parameter. The only complication is that the font size must be converted from a string into an integer using the static method <I>Integer.parseInt()</I>.

<P>Once <I>init()</I> has read all the HTML parameters, it creates a <I>Font</I> object using the values in the 
<I>font</I> and <I>size</I> variables. The <I>paint()</I> method uses this <I>Font</I> object to format the string passed in the text parameter when the string is displayed.

<A NAME="497"><H3>The HTML file</H3></A>

<p>To test ParamDisplay, create the following HTML file:

<p><pre>
&lt;HTML&gt;
&lt;HEAD&gt;
&lt;META NAME=&quot;GENERATOR&quot; Content=&quot;Microsoft Visual Studio 6.0&quot;&gt;
&lt;TITLE&gt;&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;

&lt;P&gt;
&lt;OBJECT CODE = &quot;ParamDisplay.class&quot;
        HEIGHT = 100
        WIDTH = 400&gt;
&lt;param name = &quot;TEXT&quot; value = &quot;This is the text param&quot;&gt;
&lt;param name = &quot;SIZE&quot; value = &quot;28&quot;&gt;
&lt;/OBJECT&gt;
&lt;/P&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>

<p>Most of the HTML file is identical to previous versions. The &lt;OBJECT&gt; tag differs in this HTML file, however, with the addition of the &lt;PARAM&gt; tag for TEXT 
and SIZE. Notice the absence of the FONT parameter.

<A NAME="498"><H3>The result</H3></A>

<p>The output from ParamDisplay using the previous HTML file appears in Figure 14-8. Here the string size and font size specified in the HTML file are combined with the default font type of <I>COURIER</I> to create the applet display shown.

<P><A HREF="javascript:fullSize('f14gh08x.htm')"> <img src="images/f14gh08.jpg" width=404 height=186 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><b>Figure 14-8.</b> <i>The output from the ParamDisplay applet using specified TEXT and SIZE parameters but default FONT.</i><!-- /caption -->

</BODY>
</HTML>




