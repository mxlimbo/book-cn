<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>The Debug Class</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch03a.htm", "ch03c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="115"><h1>The <I>Debug</I> Class</h1></A>
<p>Debugging is one of those topics that books and language developers never 
seem to give enough attention to. A good debugging environment aids the 
programmer by providing a more user-friendly environment within which to develop 
products faster, and aids users by helping to produce a more bug-free product.

<p>Visual J++ 6 supports debugging in three ways: with its first-rate debugger, 
with its conditional compilation feature, and with its implementation of the 
WFC <I>Debug</I> class.

<A NAME="116"><H2>The Visual J++ 6 Debugger</H2></A>

<p>The Visual J++ 6 debugger provides numerous capabilities. Even if you are 
familiar with the features of other debuggers, you will find it worthwhile to quickly 
review the features of the Visual J++ 6 debugger. A thorough explanation of the proper 
use of a debugger is beyond the scope of this book, but I'll touch on some of the 
most commonly used features.

<A NAME="117"><H3>Setting breakpoints</H3></A>

<p>The most important capability of any debugger is the ability to set breakpoints. 
A breakpoint is a flag indicating that program execution is to stop at a particular 
line of code. You can set breakpoints only on executable statements; that excludes 
declarations, <I>import</I> statements, <I>package</I> statements, and comments.

<p>The simplest way to set a breakpoint is to place the cursor on the line that 
you want to be a breakpoint and then click the Insert Breakpoint button on the 
Debug toolbar. (Selecting Insert Breakpoint from the Debug menu or pressing the F9 
key works just as well.) A solid red circle in the left margin of the Text editor indicates 
a breakpoint.

<p>You can set more than one breakpoint before executing the program. As 
soon as execution reaches any breakpoint that you have set, your program is paused 
and the Microsoft Visual Studio window reappears. A yellow arrow points to the 
breakpoint where your program is paused.

<A NAME="118"><H3>Stepping through the program</H3></A>

<p>Once your program is paused at a breakpoint, you can continue program 
execution by clicking the Continue button on the Debug toolbar or by choosing Continue 
from the Debug menu. Alternatively, you can step through the program. Stepping 
means the program executes one statement at a time, pausing after each statement.

<p>An issue arises when you are stepping through a program. When the 
debugger reaches a function call, does it treat the call as a single statement or does it step 
into the function and pause at each statement in the function? The debugger enables 
you to choose how to deal with function calls by providing two commands. The Step 
Over command treats the function call as a single statement, executing every 
instruction within the function without pausing until control returns to the calling method. 
(Step Over is something of a misnomer since the debugger doesn't step over anything.) 
The Step Into command causes the program to step into the function, pass control to 
the first statement of the function, and pause execution.

<p>For statements that call functions whose source code isn't accessible, Step 
Over and Step Into are the same. For example, with library functions Step 
Into doesn't step into the function because it can't. In this case, Step Into acts just like Step Over.

<p>To terminate execution of a program that is paused, either click the End 
button on the Debug toolbar or choose End from the Debug menu.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
A Microsoft Windows-based program that has been paused by the debugger looks like it has crashed; its window won't refresh even when it 
gains focus.
</blockquote></div>

<A NAME="119"><H3>Displaying debug information</H3></A>

<p>Being able to pause the program isn't much use if you can't see what your 
program is doing. Fortunately, the Visual J++ debugger provides several windows to give 
insight into the program's inner workings. You can open any of these windows by 
selecting Debug Windows from the View menu and then selecting the appropriate 
command from the submenu.

<p>To view the values of simple variables while a program is paused, you 
place the mouse pointer on the variable you are curious about. If the variable is in 
scope, after a second or two its value appears. However, this method works only for 
simple variables&#8212;variables of an intrinsic type. Besides, going around pointing at 
each variable can get tiresome if you're debugging a large function.

<p>If you want to see all of the variables defined in your function, open the 
Locals window. This window displays all variables that are local to the current 
function along with their current value and type. As you step through your program, 
values that change are highlighted in red. The Watch window is similar to the Locals 
window, except the Watch window enables you to select what it displays and it 
isn't limited to variables local to the current function. Both windows allow you to 
expand objects to see the values of the objects' data members.

<p>Another useful display window is the Call Stack window. This window 
displays the name of the current function along with the value of the arguments passed to 
it. Below that, the Call Stack window displays the function that called the current 
function and the arguments passed to it. The Call Stack window repeats this process 
until it reaches the first function. (In the case of a console application, the first function 
is always <I>main().</I>) Double-clicking any function moves the display to the point 
where that function was called. A solid green arrow in the left margin points to the call.

<p>Figure 3-1 shows the Visual J++ debugger with the Locals, Watch, and Call 
Stack windows visible at one time. In the background, you can see the Text editor 
window with the source code of the class being debugged. Currently, the program 
is paused on the breakpoint line designated by an arrow.

<p>The lower left corner of the figure shows the Watch window with a Watch 
set on <I>this, </I>which has been partially expanded to display many of the internal 
data members. In the lower right is the Locals window showing the local variables. 
The call stack trace is in the upper right in the Call Stack window.

<p><A HREF="javascript:fullSize('f03gh01x.htm')"> <img src="images/f03gh01.jpg" width=404 height=303 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><b>Figure 3-1.</b> <i>The Visual J++ debugger showing the main debug windows open simultaneously on the program WFCEcho3.</I><!-- /caption -->

<A NAME="120"><H3>Setting conditional breakpoints</H3></A>

<p>Often you will want to set a breakpoint that stops the program only when 
certain conditions are true. For example, if a problem occurs only after the program 
has processed most of the records in a large data file, you wouldn't want to hit a 
breakpoint at every record; you would want to pause only on the first record that 
creates the problem. A conditional breakpoint can make debugging much simpler in 
instances such as this.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
The program always stops when a regular breakpoint is encountered. The program stops when it encounters a conditional breakpoint only when a series of conditions are true.
</blockquote></div>

<p>To set a conditional breakpoint, first you set a breakpoint in the normal 
fashion. Then you choose Breakpoints from the Debug menu. Select the breakpoint 
you want to edit, and then choose Properties; the dialog box shown in Figure 3-2 is 
displayed. This figure shows that the breakpoint on line 16 won't pause the 
program until the tenth time the program passes through line 16 of <I>CapTextWriter.toUpper()</I> and the value of the variable 
<I>cap</I> is <I>true</I>.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
In the Java Breakpoint Properties dialog box, the Condition box 
can contain any Boolean expression. For conditions too complicated to be 
easily expressed in a breakpoint condition, you can write your own static Boolean 
function to invoke from the Condition box.
</blockquote></div>

<p><img src="images/f03gh02x.jpg" width=425 height=368 border=0> 

<p><!-- caption --><b>Figure 3-2.</b> <i>The Java Breakpoint Properties dialog box showing a conditional breakpoint.</I><!-- /caption -->

<p>You can see the details of a breakpoint from the Text editor by pointing at 
the breakpoint symbol on the left with the mouse pointer. After a second or two, a 
small window pops up displaying the details of the breakpoint.

<P><DIV CLASS="sidebar"><BLOCKQUOTE>
<P><B>Conditional Breakpoints: How Does Visual J++ Do That?</B>

<p>A conditional breakpoint isn't exactly what it seems. Program execution 
pauses every time control reaches a breakpoint whether the breakpoint is 
conditional or not. If the breakpoint is unconditional, control passes to the Text 
editor immediately. If the breakpoint is conditional, Visual J++ first evaluates the 
conditional expression and the hit count. If the conditional expression or the 
hit count are not satisfied, Visual J++ immediately continues running the program.

<p>The net effect is that if a condition isn't met, the conditional 
breakpoint slows program execution somewhat. Exactly how much it slows down 
depends on how often the conditional breakpoint is hit. For example, a 
conditional breakpoint set in a small loop will probably slow the program down a lot. 
Using conditional breakpoints is still a lot better than stepping through code by 
hand, but program execution speed is something to keep in mind.
</BLOCKQUOTE></DIV>

<A NAME="121"><H3>Setting a break on exception</H3></A>

<p>Another type of breakpoint is designed to alleviate a frustrating situation that can 
arise when you test your program. Let's say you know that under a given set of inputs 
your program aborts by throwing an exception. (If your program handles the 
exception, it might not abort, but the condition causing the exception still might be 
unexpected.) You know which exception is being thrown and the input that causes it, but you 
don't know what condition is causing it to be thrown.

<p>The break-on-exception breakpoint handles this situation by pausing 
program execution immediately when an exception is thrown. The settings you choose 
when you set the breakpoint determine whether the program pauses if the exception 
is handled.

<p>To set a break-on-exception breakpoint, choose Java Exceptions from the 
Debug menu. From the list of exception classes, select the type of exception you want 
to trap. If you select Break Into The Debugger, the exception you've selected, plus 
all subclasses of that exception, are marked with a white &quot;X&quot; in a red ball, as shown 
in Figure 3-3. (Normally the ball is gray.)

<p>When the exception you've selected occurs, the debugger immediately 
takes control. You can see at which line the exception was thrown, the value of all 
variables (by means of the Locals and Watch windows), and a trace of how control 
got to the exception in the first place (by means of the Call Stack window).

<p><A HREF="javascript:fullSize('f03gh03x.htm')"> <img src="images/f03gh03.jpg" width=404 height=343 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><b>Figure 3-3.</b> <i>The Java Exceptions dialog box showing a break-on-exception breakpoint for the </I>IOException<I> class.</I><!-- /caption -->

<A NAME="122"><H2>Conditional Compilation</H2></A>

<p>It is often useful to add code during debugging that should not be included in 
the final release version. One common reason for adding this extra code is to display 
data that would be inconvenient to view through the debugger. Visual J++ provides 
for this need by including the <I>#if</I>, <I>#endif</I>, and <I>#define </I>conditional directives.

<p>The <I>#if</I> directive must be followed by a Boolean expression. If the 
expression evaluates to <I>false</I>, any code appearing between 
<I>#if</I> and <I>#endif</I> is excluded from compilation. The 
<I>#if</I> directive is unlike a normal <I>if</I> statement in that the 
expression following <I>#if</I> can only be defined as one of the following types:

<UL>
<P><LI>Intrinsic constants.
<P><LI>Constants that have been defined using the <I>#define</I> directive.
<P><LI>Constants that have been defined among the Project Properties in 
the Conditional Compilation Symbols text box on the Compile tab.
</UL>

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
This feature is called conditional compilation because the 
compilation of code between <I>#if</I> and 
<I>#endif</I> is conditional upon the value of the 
expression following the <I>#if.</I> I should stress that conditional compilation is a 
compile-time test involving constants defined by means of either a compiler switch or 
the <I>#define</I> expression.
</blockquote></div>

<P><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>No Java compiler prior to Visual 
J++ 6 shares this useful conditional compilation feature with its 
C++ cousin.</BLOCKQUOTE></DIV>


<p>Defining conditional compilation constants in the Project Properties dialog 
box is the most useful of the three options. For example, the constant 
<I>DEBUG</I> is automatically defined for the Debug configuration, as shown in Figure 3-4.

<p>Defining <I>DEBUG</I> as shown in Figure 3-4 is equivalent to using the 
following statement:

<p><pre>
#define DEBUG
</PRE>

<p>This in turn is equivalent to the following statement:

<p><pre>
#define DEBUG true
</PRE>

<p>Visual J++ assumes that the value of an undefined compile-time constant is 
<I>false</I>.

<p><A HREF="javascript:fullSize('f03gh04x.htm')"> <img src="images/f03gh04.jpg" width=404 height=376 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><b>Figure 3-4.</b> <i>The Compile tab of the Project Properties dialog box enables the programmer to define compile-time constants quickly.</I><!-- /caption -->

<p>Since <I>DEBUG</I> is defined under the Debug configuration but not under the Release configuration, I can easily add the following boldface code to the 
<I>toUpper()</I> function:

<p><pre>
/**
 * Capitalize the buffer provided.
 *
 * @param s - string to capitalize
*/
String toUpper(String s)
{
<B>    #if DEBUG
        Text.out.writeLine(&quot;Capitalizing:&quot; + s);
    #endif</B>
            
    // first convert the string into a string buffer
    StringBuffer sb = new StringBuffer(s);

    // and so on&#8230;
}
</PRE>

<p>The call to <I>writeLine()</I> is included in the compiled executable file under 
the Debug configuration but isn't included under the Release configuration.

<A NAME="123"><h2>Using the <I>Debug</I> Class</h2></A>
<p>The classes within the Java libraries, including the classes in the WFC library, are 
very good about testing for and detecting erroneous conditions. It is uncommon for a 
Java program to simply crash without an exception being thrown that gives some 
indication of the problem.

<p>You should follow this example in classes that you write. For example, 
the <I>CapTextWriter.toUpper(String)</I> method from the WFCEcho3 program discussed 
in <A HREF="ch02a.htm">Chapter 2</A> accepts an input <I>String,</I> which it then converts to uppercase. 
Unfortunately, <I>toUpper()</I> doesn't test the assumption that it will be passed a valid 
<I>String</I> object; it trusts the program to do the right thing. What if the program passes a 
<I>null</I> instead?

<P><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>Unlike in C++, a <I>null</I> is the only invalid value that the program could pass.
</blockquote></div>

<p>The following shows the <I>CapTextWriter</I> class updated to test for and 
handle invalid input.

<p><pre>
/**
 * CapTextWrite - a TextWriter that capitalizes
 *                output through write(String) or
 *                writeLine(String).
 */
import com.ms.wfc.io.*;
import com.ms.wfc.core.*;
import com.ms.wfc.util.Debug;

public class CapTextWriter extends TextWriter
{
    String specialChars = &quot; -.;\t\n&quot;;
    
    /**
     * Constructor.
     * 
     * @param outFile - File object to use for output
     */
    public CapTextWriter(File outFile)
    {
        super(outFile);
    }

    /**
     * Write a line of text after capitalizing each word.
     * 
     * @param s - the string to output
     */
    public void writeLine(String s)
    {
        // the following code outputs a message to the debug
        // console if a null value is passed
        Debug.assert(s != null, &quot;Null string passed to writeLine&quot;);
        assert(s != null, &quot;Null string passed to writeLine&quot;);
        super.writeLine(toUpper(s));
    }
    
    /**
     * Write a line of text after capitalizing each word.
     * 
     * @param s - the string to output
     */
    public void write(String s)
    {
        Debug.assert(s != null, &quot;Null string passed to write&quot;);
        assert(s != null, &quot;Null string passed to write&quot;);
        super.write(toUpper(s));
    }
    
    /**
     * If the condition c is false, throw an exception
     * containing the text s.
     *
     * @param c - condition to test
     * @param s - string to output
     */
    void assert(boolean c, String s)
        throws WFCInvalidArgumentException 
    {
        if (!c)
        {
            throw new WFCInvalidArgumentException(s);
        }
    }
    
    /**
     * Capitalize the buffer provided.
     *
     * @param s - string to capitalize
     */
    String toUpper(String s)
    {
        // same as before&#8230;
    }
}
</PRE>

<p>If the Boolean value is <I>false</I>, <I>Debug.assert(boolean, String)</I> outputs the <I>String</I> to the debugger's output window. The locally defined 
<I>assert(boolean, String)</I> throws an exception containing the message string if the Boolean assertion is 
<I>false</I>.

<P><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>Notice that <I>assert()</I> throws the exception <I>WFCInvalidArgumentException</I>. This is the exception thrown by 
<I>TextWriter.writeLine()</I>. If a method that overrides another method throws an exception, it must throw the same 
exception class or a subclass of that exception class.
</blockquote></div>

<p>The DebugTest application tests the updated <I>CapTextWriter</I> class while simultaneously demonstrating another 
<I>Debug</I> helper method.

<p><pre>
/**
 * DebugTest - demonstrate the features of the Debug class.
 */
import com.ms.wfc.io.*;
import com.ms.wfc.util.Debug;

public class DebugTest
{
    /**
     * The main entry point for the application. 
     */
    public static void main (String[] args)
    {
        try
        {
            try
            {
                // create a CapTextFile on standard output
                CapTextWriter out = 
                    new CapTextWriter(File.openStandardOutput());
                out.setAutoFlush(true);
        
                // try a legal test message
                out.writeLine(&quot;this is a test string&quot;);

                // output object information to debug output
                out.writeLine(Debug.getObjectText(out));
        
                // now try a null message
                String s = null;
                out.writeLine(s);
            }
            catch(Exception e)
            {
                Debug.printException(e);
 
                Text.out.writeLine();
                Text.out.writeLine(&quot;Exception message follows:&quot;);
                Text.out.writeLine(e.getMessage());
                
                Text.out.writeLine();
                Text.out.writeLine(&quot;Stack traceback follows:&quot;);
                e.printStackTrace();
                
                Thread.sleep(2000);
            }
        }
        catch(Exception e)
        {
        }
    }
}
</PRE>

<p>The program begins by creating a <I>CapTextWriter</I> object on standard output. Setting automatic flushing to 
<I>true</I> ensures that any valid output occurs before the program terminates.

<P>Armed with this output object, the program first outputs a valid string. It 
follows this by outputting debug information to the debugger's output window. This has effect only when the program is running under the debugger; 
otherwise, <I>Debug.getObjectText()</I> returns an empty string.

<P>The program then purposely sets a String variable to <I>null</I> and passes this to <I>writeLine()</I>.

<P>The exception thrown from <I>writeLine()</I> is caught on the line after the call. 
First, the <I>catch</I> phrase outputs exception information to the debug window. Again, 
this <I>Debug</I> function has no effect unless executed under the debugger. Next the 
exception handler outputs the exception message followed by an exception stack trace.

<p>The output from this program is shown in Figure 3-5.

<p><div class="note"><blockquote>
<b>NOTE</b>
<hr>I ran this program by invoking <I>jview</I> <I>/vst DebugTest.class. </I>Doing 
this generates slightly more detailed stack trace output (the <I>/vst</I> stands for verbose stack trace). This works only if the application was compiled with the 
debug setting enabled.
</blockquote></div>

<p><A HREF="javascript:fullSize('f03gh05x.htm')"> <img src="images/f03gh05.jpg" width=404 height=268 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><b>Figure 3-5.</b> <i>The output from the DebugTest program showing the detailed stack traceback.</I><!-- /caption -->

</BODY>
</HTML>




