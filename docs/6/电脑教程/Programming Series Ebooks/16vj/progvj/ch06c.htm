<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>List Boxes</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06b.htm", "ch06d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="190"><H1>List Boxes</H1></A>

<p>Another type of simple input control is the list box. The 
Toolbox offers three types of list boxes: the combo box, the list box, and the 
checked list box. The examples in this section demonstrate the combo box and 
list box controls.

<A NAME="191"><H2>The ComboBox Control</H2></A>

<p>The combo box control is the simplest of the list box 
control types. The class <I>ComboBox</I> displays a 
single-line, read-only box with an arrow on the right. When the user clicks the 
arrow, the combo box drops down a list of objects the user can pick from. When 
the user chooses from the list, it disappears and the selected object is 
displayed in the combo box output window.

<p>The combo box list can be static or calculated. The 
values for a static list are known at the time that you write the code. You can 
use the Properties window to specify the items in a static list. The values for 
a calculated list are determined at run time by the application.

<A NAME="192"><H3>Displaying a static list of strings</H3></A>

<p>The simplest combo box is one that contains a static list 
of <I>String</I> objects. The following example application, 
ComboBox1, demonstrates a <I>ComboBox</I> object containing 
the months of the year. When the user selects one of the months, the application 
displays the selection in the combo box and in a separate edit box immediately 
above the combo box. The output from the resulting application is shown in 
Figure 6-4.

<p><img src="images/f06gh04.jpg" width=240 height=267 border="0">
<p><!-- caption --><b>Figure 6-4.</b> <i>The ComboBox1 demo 
showing the months of the year displayed in a combo box list.</i><!-- /caption -->

<p>The Forms Designer work to create ComboBox1 is 
straightforward. First drag an Edit control to the Forms Designer and set its <I>readOnly</I> property to <I>true</I>. 
Next drag a ComboBox control from the Toolbox to the Forms Designer and change 
its <I>name</I> property to <I>inputComboBox</I>. I set both objects' font properties to 14-point boldface 
to make the display stand out better. Adding a couple of labels almost completes 
the Forms Designer work.

<p>The final task in the Forms Designer is to add the months 
of the year to the combo box list. To do this, select the <I>items</I> property of the ComboBox control in the Properties window. 
Clicking the ellipsis button in the property setting box for this property opens 
the String List Editor. Enter the months of the year as shown in Figure 6-5.

<p><A HREF="javascript:fullSize('f06gh05x.htm')"> <img src="images/f06gh05.jpg" width=404 height=270 border=0 ALT="Click to view at full size."></A>
<p><!-- caption --><B>Figure 6-5.</B> <i>Entering static 
strings into the combo box using the String List Editor.</i><!-- /caption -->

<p>Now all that is left to do for the ComboBox1 application 
is to add an event handler to copy the month selected in the combo box to the 
output edit box. Double clicking the ComboBox control in the Forms Designer 
creates the method <I>inputComboBox_selectedIndexChanged()</I>. Add the functionality to this 
event handler as shown in the following code listing of ComboBox1:

<p><pre>
import com.ms.wfc.app.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;
import com.ms.wfc.html.*;

/**
 * This class displays a static combo box.
 */
public class Form1 extends Form
{
    public Form1()
    {
        // Required for Visual J++ Form Designer support
        initForm();
    }

    /**
     * Form1 overrides dispose so it can clean up the
     * component list.
     */
    public void dispose()
    {
        super.dispose();
        components.dispose();
    }

    /**
     * This method is invoked when the user selects a month
     * from the combo box.
     */
    private void inputComboBox_selectedIndexChanged(Object source,
                                                    Event e)
    {
        // get the index of the selected object
        int index = inputComboBox.getSelectedIndex();

        // get a list of the objects contained in the combo box
        Object[] list = inputComboBox.getItems();

        // pick the one that was selected, and convert it into a string
        String s = list[index].toString();

        // display the resulting string in the output edit window
        outputEdit.setText(s);    
    }

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
    Container components = new Container();
    Edit outputEdit = new Edit();
    ComboBox inputComboBox = new ComboBox();
    Label label1 = new Label();
    Label label2 = new Label();

    private void initForm()
    {
        this.setText(&quot;ComboBox Demo&quot;);
        this.setAutoScaleBaseSize(new Point(5, 13));
        this.setClientSize(new Point(232, 139));

        outputEdit.setFont(new Font(&quot;MS Sans Serif&quot;, 14.0f,
                                    FontSize.CHARACTERHEIGHT,
                                    FontWeight.BOLD,
                                    false, false, false));
        outputEdit.setLocation(new Point(40, 30));
        outputEdit.setSize(new Point(160, 23));
        outputEdit.setTabIndex(0);
        outputEdit.setText(&quot;&quot;);
        outputEdit.setReadOnly(true);

        inputComboBox.setFont(new Font(&quot;MS Sans Serif&quot;, 14.0f,
                                       FontSize.CHARACTERHEIGHT,
                                       FontWeight.BOLD,
                                       false, false, false));
        inputComboBox.setLocation(new Point(40, 90));
        inputComboBox.setSize(new Point(160, 24));
        inputComboBox.setTabIndex(1);
        inputComboBox.setText(&quot;&quot;);
        inputComboBox.setItems(new Object[] {
                               &quot;January&quot;, 
                               &quot;February&quot;, 
                               &quot;March&quot;, 
                               &quot;April&quot;, 
                               &quot;May&quot;, 
                               &quot;June&quot;, 
                               &quot;July&quot;, 
                               &quot;August&quot;, 
                               &quot;September&quot;, 
                               &quot;October&quot;, 
                               &quot;November&quot;, 
                               &quot;December&quot;});
        inputComboBox.addOnSelectedIndexChanged(
            new EventHandler(this.inputComboBox_selectedIndexChanged));

        label1.setLocation(new Point(20, 10));
        label1.setSize(new Point(90, 20));
        label1.setTabIndex(2);
        label1.setTabStop(false);
        label1.setText(&quot;Month Selected:&quot;);

        label2.setLocation(new Point(20, 70));
        label2.setSize(new Point(100, 20));
        label2.setTabIndex(3);
        label2.setTabStop(false);
        label2.setText(&quot;Select a Month:&quot;);

        this.setNewControls(new Control[] {
                            label2, 
                            label1, 
                            inputComboBox, 
                            outputEdit});
    }

    /**
     * The main entry point for the application. 
     *
     * @param args Array of parameters passed to the application
     * via the command line.
     */
    public static void main(String args[])
    {
        Application.run(new Form1());
    }
}
</pre>

<p>The <I>inputComboBox_selectedIndexChanged()</I> method is invoked whenever the 
user selects a new item from the combo box. The index to which the event refers 
is the index of the currently selected object. The first list item bears the 
index 0, the next index 1, and so forth.

<p>The <I>inputComboBox_selectedIndexChanged()</I> method starts by querying the 
combo box as to what index the user just chose.

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
     At the moment the <I>selectedIndexChanged()</I> method 
    is invoked, WFC has updated the index to reflect the newly selected value 
    but has not updated the text. Calling <I>inputComboBox.getSelectedText()</I> or <I>getText()</I> at this point returns the text associated with the 
    previous index value. 
</blockquote></div>

<p>The <I>inputComboBox_selectedIndexChanged()</I> method then queries the combo box 
for a list of the objects it contains. The member of this list at the index 
position returned from <I>getSelectedIndex()</I> is the 
object the user has just chosen. ComboBox1 converts the selected <I>Object</I> into a <I>String</I> by calling the method <I>toString()</I>. Finally, the resulting string is copied 
into the <I>outputEdit</I> Edit control by calling the <I>setText()</I> method.

<A NAME="193"><H3>Why does WFC update the index but not the text?</H3></A>

<p>It might seem curious that at the point the <I>inputComboBox_selectedIndexChanged()</I> method is called 
the index has been updated but the text has not. WFC does this to allow the <I>inputComboBox_selectedIndexChanged()</I> method to perform 
error checking before the user is possibly presented with incorrect output. For 
example, suppose that in the current program state, the month of February is not 
allowed because the user has already set the day to 30 or 31.

<p>The following addition to the <I>inputComboBox_selectedIndexChanged()</I> method makes it impossible for the 
user to select February:

<p><pre>
// if February is selected&#8230;
if (index == 1)
{
    // substitute January instead
    index = 0;
    inputComboBox.setIndex(index);
}
</pre>

<p>The call to <I>setIndex()</I> resets 
the index within the combo box. With this addition, whenever the user selects 
the month of February (index == 1) the function resets the selection to January 
(index == 0) instead. Once the <I>inputComboBox_selectedIndexChanged()</I> method is completed, the combo box 
displays the new text based upon the resulting value of the index. In this case, 
the month of January is displayed.

<p>If WFC updated the text before calling <I>inputComboBox_selectedIndexChanged()</I>, the user would see an annoying 
flicker as February is displayed and then quickly replaced by January. By 
waiting to update the display until after the <I>inputComboBox_selectedIndexChanged()</I> method has completed, WFC is sure 
of the text that the program wants to display.

<A NAME="194"><H3>Populating the combo box with different object 
types</H3></A>

<p>Just because strings are the most common combo box 
occupants doesn't mean that <I>String</I> is the only class 
you can store in a combo box. In fact, you can add any type of object that you 
want to a combo box as long as the type you select provides a <I>toString()</I> method that returns something the user will recognize. The 
presence of the <I>toString()</I> method is important 
because the value it returns gets displayed in the combo box list.

<p>For example, the ComboBox2 example application below 
displays a combo box listing different tree types. When the user selects a tree 
type, the application displays the relative wood density and growth rate for 
that tree type in the output edit box previously used to display the selected 
month. The output from this application is shown in Figure 6-6.

<p><img src="images/f06gh06.jpg" width=240 height=187 border="0">
<p><!-- caption --><B>Figure 6-6.</B> <i>The ComboBox2 
application demonstrates that the objects added to a combo box list are not 
limited to strings.</i><!-- /caption -->

<p>The program listing for ComboBox2 is shown here (with the 
automatically generated <I>initForm()</I> method and <I>dispose()</I> method removed from the listing for brevity's 
sake).

<p><pre>
import com.ms.wfc.app.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;
import com.ms.wfc.html.*;

import java.lang.reflect.*;

/**
 * This class displays a static combo box containing TreeType
 * objects. This class also demonstrates the use of the Java
 * reflection features in displaying the name of the enumerated
 * types.
 */
public class Form1 extends Form
{
    public Form1()
    {
        // Required for Visual J++ Form Designer support
        initForm();

        // populate the list with a few different types of trees
        Object[] list = new Object[]
        {
        new TreeType(&quot;Maple&quot;, TreeHardness.SOFT, TreeGrowthRate.FAST),
        new TreeType(&quot;Oak&quot;,   TreeHardness.HARD, TreeGrowthRate.SLOW),
        new TreeType(&quot;Birch&quot;, TreeHardness.SOFT, TreeGrowthRate.MEDIUM)
        };
        inputComboBox.setItems(list);
    }
    .
    .
    .

     /**
     * This method is invoked when the user selects a month
     * from the combo box.
     */
    private void inputComboBox_selectedIndexChanged(Object source,
                                                    Event e)
    {
        // get the index of the selected object
        int index = inputComboBox.getSelectedIndex();
        
        // get a list of the items contained in the combo box
        Object[] list = inputComboBox.getItems();
        
        // index the object selected, and convert it into a string
        // String s = list[index].toString();
        TreeType t = (TreeType)list[index];
        String s   = t.properties();
           
        
        // output the string in the output edit object
        outputEdit.setText(s);    
    }

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
    Container components = new Container();
    Edit outputEdit = new Edit();
    ComboBox inputComboBox = new ComboBox();
    Label label1 = new Label();
    Label label2 = new Label();

    private void initForm()
    {
        // &#8230;created by the Forms Designer&#8230;
    }

    /**
     * The main entry point for the application. 
     * &#8230;
     */
    public static void main(String args[])
    {
        Application.run(new Form1());
    }
}

/**
 * This class describes the relevant properties of a type of tree.
 */
class TreeType
{
    String name;
    int    hardness;
    int    growthRate;
    
    TreeType(String name, int hardness, int growthRate)
    {
        this.name       = name;
        this.hardness   = hardness;
        this.growthRate = growthRate;
    }
    
    public String toString()
    {
        return name;
    }
    
    public String properties()
    {
        Class c;
        Field f;
        
        // convert the hardness into a string:
        // use the reflection classes Class and Field
        c = TreeHardness.class;   // get the class object
        f = c.getDeclaredFields()[hardness]; // get a list
                                  // of the constants
        String hl = f.toString(); // convert that into a string
        hl = hl.substring(hl.indexOf(&quot;.&quot;) + 1); // keep just the name

        // repeat the process for the growth rate
        c = TreeGrowthRate.class;  
        f = c.getDeclaredFields()[growthRate];
        String gr = f.toString();
        gr = gr.substring(gr.indexOf(&quot;.&quot;) + 1);
        
        return hl + &quot;, &quot; + gr;
    }
    
}

class TreeHardness extends Enum
{
    public static final int SOFT   = 0;
    public static final int MEDIUM = 1;
    public static final int HARD   = 2;

    public static boolean valid(int value)
    {
        return (value &gt;= SOFT) &amp;&amp; (value &lt;= HARD);
    }
}

class TreeGrowthRate extends Enum
{
    public static final int SLOW   = 0;
    public static final int MEDIUM = 1;
    public static final int FAST   = 2;

    public static boolean valid(int value)
    {
        return (value &gt;= SLOW) &amp;&amp; (value &lt;= FAST);
    }
}
</pre>

<p>Once the form has been initialized by the <I>initForm()</I> method, the <I>Form1</I> constructor 
adds three <I>TreeType</I> objects to the combo box list. 
You must program this code manually because it isn't possible to add 
user-defined types to a combo box using the Properties window.

<p>The <I>TreeType</I> class contains 
nothing more than a tree type name, a wood hardness value, and a growth-rate 
value. The <I>toString()</I> method for <I>TreeType</I> returns the tree name.

<p>The <I>properties()</I> method 
displays the hardness and growth rate as a string, but it does so in a very 
interesting way: <I>properties() </I>uses Java's reflection 
classes.

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
     The <I>java.lang.reflection</I> package allows a method 
    to ask questions about another class. 
</blockquote></div>

<p>First <I>properties()</I> fetches the <I>Class</I> object that describes <I>TreeHardness</I>. It then asks the class for a list of all its declared 
fields. The <I>getDeclaredFields()</I> method returns an 
array of <I>Field</I> objects.

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
<I>Fields</I> is another word for <I>data members</I>. <I>Declared</I> <I>fields</I> are fields that are declared in the class. This does not 
    include any fields inherited from a base class. 
</blockquote></div>

<p>The enumerated class <I>TreeHardness</I> has only the members <I>SOFT</I>, <I>MEDIUM,</I> and <I>HARD</I>, so <I>getDeclaredFields()</I> returns an array containing three <I>Field</I> objects, one for each data member. (See the 
sidebar &quot;What's an Enumeration Class?&quot; for an explanation of 
enumerated classes.) Because we specified an index, <I>[hardness]</I>, in our call to <I>getDeclaredFields()</I>, the method returns the field corresponding to the 
current hardness setting rather than returning the entire array.

<p></p><div class="sidebar"><blockquote>
<P><b>What's an Enumeration 
    Class?</b>
<hr>
<P>You might be wondering why I bothered to create a <I>TreeHardness</I> and a <I>TreeGrowthRate</I> class just to hold a few <I>public static final int</I> definitions. There are several points about 
    the <I>TreeHardness</I> and <I>TreeGrowthRate</I> classes worth noting. 

<OL>
<p><LI>Each class extends <I>Enum</I>. 

<p></p><LI>Each class contains a list of <I>public static final int</I> constants. 

<p></p><LI>Each class contains the static method <I>boolean</I> <I>valid(int). 
        </I>This method returns <I>true</I> if the integer 
        passed it represents one of the valid values for that property. A class 
        that fulfills these requirements is known as an enumeration type.</LI>
</OL>

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
        There is no <I>enum</I> keyword in Java as there is 
        in C++.</blockquote></div>


<p>Defining your constants within enumeration types has 
    several advantages. First, as you are defining the <I>TreeType</I> class, the Statement Completion feature will help you out. 
    As soon as you type <I>new TreeType(</I>, Statement 
    Completion gives you a list of arguments. The name of the argument should 
    indicate the name of the class to use in describing it. Thus, the second 
    argument to the <I>TreeType</I> constructor is called <I>hardness,</I> which prompts me to use the <I>TreeHardness</I> class. Once I have typed <I>TreeHardness.</I>, Statement Completion drops down a 
    list of possible values including <I>SOFT</I>, <I>MEDIUM</I>, and <I>HARD</I> (along 
    with some methods and properties inherited from the base class).

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
         It's a standard Java coding convention to use all capital letters in 
        the names of members of type <I>public static final 
        int</I>. 
</blockquote></div>

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
         The <I>public static final int</I> data member 
        takes the place of a <I>const</I> data member in 
        C++. 
</blockquote></div>

<p>The ComboBox2 example application uses the same 
    reflection mechanism to display the available fields that the smart editor 
    uses. Later we'll see that when we define our own controls the Toolbox has 
    access to the enumerated properties of the object using this same reflection 
    mechanism.</p>
</blockquote></div>

<p>The call to <I>f.toString()</I> 
returns the name of the field as a string&#8212;<I>SOFT</I>, <I>MEDIUM</I>, or <I>HARD</I>. 
Unfortunately for us, the name that <I>f.toString()</I> 
returns includes the name of the class. I added a call to <I>substring()</I> on the next line to strip off the class name by removing 
everything prior to the &quot;.&quot; that normally separates the class name 
from the member's name.

<p>The <I>properties()</I> method 
repeats the process for the growth rate before tacking the two property values 
together and returning the result as a string.

<p>The <I>inputComboBox_selectedIndexChanged()</I> method that handles the combo box 
selection is the same here as in the earlier ComboBox1 example, except that it 
calls the <I>TreeType.properties()</I> method rather than 
the <I>toString()</I> method. (With the <I>toString()</I> call left in place, the program would still work, but only 
the name of the tree type and not its properties would appear in the output 
window)

<A NAME="195"><H3>Populating the combo box list dynamically</H3></A>

<p>At the time you're writing a program, it isn't always 
possible to know what is to go into a combo box. Sometimes a combo box list must 
be calculated when the program runs. For example, the following ComboBox3 code 
populates a combo box with the names of the files in the current directory.

<p><pre>
import com.ms.wfc.app.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;
import com.ms.wfc.html.*;

import com.ms.wfc.io.*;

/**
 * This class displays a combo box whose contents are
 * calculated at run time from the list of files in the
 * current directory.
 */
public class Form1 extends Form
{
    public Form1()
    {
        // Required for Visual J++ Form Designer support
        initForm();
        
        // populate the combo box with a list of all file names
        // in the current directory
        inputComboBox.setItems(File.getFiles(&quot;*.*&quot;));
    }
    

    // &#8230;rest of the program is same as ComboBox1&#8230;
</pre>

<p>The <I>public</I> <I>static</I> method <I>File.getFiles()</I> returns a list 
of all of the files and directories that match the filter passed to it. The <I>File.getFiles() </I>method returns this list as an array of <I>String</I> objects containing the names of the files. 
This array is ideal, since this is exactly what we need to pass to the <I>setItems()</I> method. Setting the <I>sorted</I> property of the <I>ComboBox</I> object to <I>true</I> in the Properties window ensures that the files' 
names appear in alphabetical order in the combo box list. The output of 
executing this program in the test directory is shown in Figure 6-7.

<p><img src="images/f06gh07.jpg" width=240 height=267 border="0">
<p><!-- caption --><B>Figure 6-7.</B> <i>The contents of the 
combo box must often be calculated at run time, as in this file list.</i><!-- /caption -->

<A NAME="196"><H2>The ListBox Control</H2></A>

<p>As powerful as it is, the combo box has one serious 
limitation: only one member from the drop-down list can be selected at a time. 
The ListBox control doesn't suffer from this limitation. Visually the list box 
is rather different from the combo box. A list box has no drop-down list; its 
list remains visible at all times. Fortunately, you can set the size of the list 
box in the Forms Designer. If there are more objects in the list box than can be 
displayed at one time, the list box automatically displays a vertical scroll 
bar. In addition, the list box has no output window where the currently selected 
item is displayed; instead, selected items are displayed in inverse video.

<p>The ListBox control has three modes of operation: One 
(also known as Single Select) mode, Multi Simple mode, and Multi Extended mode. 
In Single Select mode, only one item can be selected at a time. In Multi Simple 
mode, the user clicks on an item to select it. Clicking the same item again 
deselects it. The user can select any number of items but must select each item 
individually.

<p>Multi Extended mode is the same mode used in Windows 
Explorer and most other programs that use a list box. With this type of list box 
the user can select large blocks of items. Clicking one item and then clicking a 
second while holding down the Shift key automatically selects the two items and 
all of the items in between. In addition, the user can select or deselect 
individual items by holding down the Control key. (In effect, as long as the 
user presses the Control key, the list box operates in Multi Simple mode.)

<p>From the programmer's point of view, the list box is very 
similar to the check box. In Single Select mode, the list box works the same as 
the combo box: calling <I>getSelectedIndex()</I> from within 
the event handler returns the index of the selected item.

<p>Usually it's preferable to operate list boxes in Multi 
Simple or Multi Extended mode. In either of these modes, the event handler must 
be prepared to read a list of selected items, as shown in the following code.

<p><pre>
private void selectListBox_selectedIndexChanged(Object source, Event e)
{
    Object[] list = selectListBox.getSelectedItems();

    // &#8230;operate on the list&#8230;
}
</pre>

<p>Using this approach might mean entering a <I>for</I> loop to iterate through the items in the list.

<A NAME="197"><H3>Multiselect list boxes</H3></A>

<p>The following example, ListBoxDemo, is a file deletion 
utility that uses the ListBox control to allow the user to select the files to 
delete. (ListBoxDemo does not actually delete the files selected.) After 
creating a Windows-based project in the normal way, I used the Forms Designer to 
create the display shown in Figure 6-8.

<p><img src="images/f06gh08.jpg" width=254 height=239 border="0">
<p><!-- caption --><b>Figure 6-8.</b> <i>The ListBoxDemo 
program demonstrating how the list box can enable the selection of multiple 
items.</i><!-- /caption -->

<p>The source code for the ListBoxDemo application is as 
follows. (I left out sections of code, such as those created by the Forms 
Designer, for brevity).

<p><pre>
import com.ms.wfc.app.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;
import com.ms.wfc.html.*;

import com.ms.wfc.io.*;

/**
 * This ListBoxDemo uses a list box to select files to
 * &quot;delete.&quot; (Uncomment the call to File.delete() if
 * you want the application to actually delete anything.)
 */
public class Form1 extends Form
{
    String currentPath = &quot;.&quot;;
    
    public Form1()
    {
        // Required for Visual J++ Form Designer support
        initForm();

        updateSelectListBox(&quot;*.*&quot;);
    }
	
    .
    .
    .

    private void filterEdit_textChanged(Object source, 
                                        Event e)
    {
        String s = filterEdit.getText();
        currentPath = File.getDirectory(s);
        updateSelectListBox(s);       
    }
    
    private void updateSelectListBox(String filter)
    {
        // get a list of the files; ignore any errors
        // that might arise if the directory doesn't exist
        Object[] list = new Object[0];
        try
        {
            list = File.getFiles(filter);
        }
        catch(Exception e)
        {
        }
        
        // update the select list box with the file names
        selectListBox.setItems(list);
        
        // update the select list box
        selectListBox_selectedIndexChanged(null, null);
    }

    private void selectListBox_selectedIndexChanged(
                                        Object source, 
                                        Event e)
    {
        Object[] list = selectListBox.getSelectedItems();

        String[] fileArray = new String[list.length];
        for (int i = 0; i &lt; list.length; i++)
        {
            // if the files selected are not in the
            // default directory, convert the filename
            // into the full path
            String filePath =   currentPath
                              + &quot;\\&quot;
                              + (String)list[i];
            // if the file is a directory&#8230;
            if (File.isDirectory(filePath))
            {
                // put an asterisk on the front
                filePath = &quot;*&quot; + filePath;
            }
            else
            {
                filePath = &quot; &quot; + filePath;
            }
            
            fileArray[i] = filePath;
        }
        
        outputEdit.setLines(fileArray);
    }

    private void deleteButton_click(Object source, Event e)
    {
        String[] list = outputEdit.getLines();
        
        for(int i = 0; i &lt; list.length; i++)
        {
            // the following function deletes the file
            // without putting it into the Recycle Bin
            // File.delete(list[i]);
        }

        filterEdit_textChanged(null, null);
    }

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
    Container components = new Container();
    Edit outputEdit = new Edit();
    ListBox selectListBox = new ListBox();
    Button deleteButton = new Button();
    Edit filterEdit = new Edit();
    Label label1 = new Label();
    Label label2 = new Label();
    Label label3 = new Label();

    private void initForm()
    {
        // &#8230;built automatically by Forms Designer&#8230;
    }

    /**
     * The main entry point for the application. 
     * &#8230;
     */
    public static void main(String args[])
    {
        Application.run(new Form1());
    }
}
</pre>

<p>Once <I>initForm()</I> has created 
the form with the associated ListBox control, the <I>Form1() 
 </I>constructor calls the <I>updateSelectListBox()</I> 
method to populate the list box with a list of file names. Passing the filter 
*.* instructs <I>updateSelectListBox()</I> to select all 
files in the current directory. The <I>updateSelectListBox() 
 </I>method gets a list of the files that pass the current filter by calling <I>File.getFiles()</I>. By catching any exception thrown, <I>updateSelectListBox()</I> ignores any errors that <I>getFiles()</I> might detect. (For example,<I> getFiles()</I> throws an exception if the directory specified doesn't 
exist.) The resulting list, which might be empty, is passed to the <I>selectListBox</I> object for display.

<p>As the user selects items from the file selection list 
box, WFC automatically invokes <I>selectListBox_selectedIndexChanged()</I>. This function gets a list of the 
selected items by calling <I>getSelectedItems()</I>. Knowing 
that these are the names of files, <I>selectListBox_selectedIndexChanged()</I> iterates through the list adding 
the full path to each file. In addition, if a file is a directory the function 
adds an asterisk to the front of the file name. The resulting list of file names 
is displayed in the <I>outputEdit</I> object by calling <I>setLines()</I>.

<p>The <I>deleteButton_click()</I> 
method is invoked when the user chooses the Delete button. This function gets a 
list of the files to be deleted from the <I>outputEdit</I> 
object by calling <I>getLines()</I>. It then loops through 
this list &quot;deleting&quot; each file.

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
     Since deleting files is too dangerous in a simple demo for a book, I've 
    commented out the call to <I>File.delete().</I> If you 
    would like this utility to actually delete the selected files, uncomment the 
    call to <I>File.delete()</I> and recompile the program. 
    However, be advised that <I>File.delete()</I> deletes 
    each file or directory immediately and does not move the file to the Recycle 
    Bin. 
</blockquote></div>

</BODY>
</HTML>




