<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>Containers</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch03b.htm", "ch03d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="124"><H1>Containers</H1></A>

<p>As their name implies, containers are objects that contain 
other objects. You are familiar with the most common of all containers, the 
array. A positive feature of arrays is that they are efficient, both in how they 
are allocated and in how they are accessed. A negative feature is that arrays 
are not convenient: they are fixed in size and they are not indexed, so it is 
difficult to find specific elements within an array.

<p>The WFC <I>util</I> package provides a 
number of other container types. No single container type solves all of the 
problems of the array&#8212;there is no perfect container. However, each 
container class provides some unique advantage. In addition, the utility package 
provides a number of utilities that aid in sorting the contents of a container.

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
     As WFC grows, other forms of containers will likely be added to those 
    currently present. 
</blockquote></div>

<A NAME="125"><H2>Arrays</H2></A>

<p>Mechanisms for creating an array and accessing its members 
are built into the Java language. There is no keyword for sorting an array, 
however. Fortunately, the 
<I>ArraySorter</I> class is 
provided to sort arrays of objects.

<P>Since we will need something to sort, let's begin by 
defining a <I>Student</I> class.

<A NAME="126"><h3>Creating the <I>Student</I> 
class</h3></A>
<p>The following <I>Student</I> class is 
the most rudimentary class I could devise to define a student. This class is 
stored in the file Student.java.

<p><pre>
/**
 * A generic Student class.
 */
public class Student
{
    String name = null;
    int    ssNumber = 0;

    /**
     * Create a real student.
     * 
     * @param name - the name of the student to create
     * @param ssNumber - the Social Security number
     */
    Student(String name, int ssNumber)
    {
        this.name     = name;
        this.ssNumber = ssNumber;
    }

    /**
     * Retrieve the Social Security number.
     */
    int getSSNumber()
    {
        return ssNumber;
    }

    /**
     * Convert Student into an informative string.
     */
    public String toString()
    {
        String s = name + &quot;(&quot; + ssNumber + &quot;)&quot;;
        return s;
    }
}
</pre>

<p>The <I>Student</I> class must of course 
have a <I>name</I> member to record the student's name. Since 
students at our school are registered by Social Security number, the <I>Student</I> class needs an <I>ssNumber</I> 
data member as well. The <I>Student</I> constructor 
initializes these two data fields, while the 
<I>getSSNumber()</I> and <I>toString()</I> methods allow 
access to the values stored in the data fields. A host of other fields and 
associated methods might be required by a real student class, but these will do 
for the examples in this chapter.

<A NAME="127"><H3>Sorting an array of objects</H3></A>

<p>Sorting arrays of information is a common problem&#8212;so 
common, in fact, that <I>com.ms.wfc.util</I> includes an <I>ArraySorter</I> class. This class can sort an array of any 
type of objects as long as you can provide a comparison function. You do this by 
creating a class that implements the <I>IComparer</I> 
interface. This interface defines only a single method, <I>int</I> <I>compare(Object o1, Object o2).</I>This method 
returns a value of 1 if <I>o1</I> is greater than <I>o2</I>, -1 if <I>o2</I> is greater than <I>o1</I>, and 0 if the two values are equal. Exactly what is 
meant by the phrase &quot;<I>o1</I> is greater than <I>o2</I>&quot; is up to you to define.

<P>The following SortStudent program creates an array of <I>Student</I> objects and then sorts it using the 
<I>ArraySorter</I> class.

<p><pre>
import com.ms.wfc.io.*;
import com.ms.wfc.util.*;

/**
 * Sort a Student class using the ArraySorter class.
 */
public class SortStudent
{
    /**
     * The main entry point for the application. 
     *
     * @param args Array of parameters passed to the application
     * via the command line.
     */
    public static void main (String[] args)
    {
        // create an array of students
        Student[] array = new Student[]
                    {
                      new Student(&quot;Shepherd, James&quot;, 234567890),
                      new Student(&quot;Smith, Harold&quot;,   123456789),
                      new Student(&quot;Davis, Stephen&quot;, 345678901)
                    };

        // output the unsorted array
        output(&quot;Unsorted array&quot;, array);
        
        // sort the array
        ArraySorter.sort(array, new StudentComparer());
        
        // now output again
        output(&quot;Sorted array&quot;, array);
    }
    
    /**
     * Output an array.toString() to standard output.
     * 
     * @param msg - message to tack onto output
     * @param array - array to output
     */
    static void output(String msg, Object[] array)
    {
        Text.out.writeLine(msg);
        for (int i = 0; i &lt; array.length; i++)
        {
            Text.out.writeLine(array[i].toString());
        }
        Text.out.writeLine();
    }
}

/**
 * A class to provide the Student comparer method.
 */
class StudentComparer implements IComparer
{
    /**
     * Compares two students by comparing their ssNumbers.
     * 
     * @param o1 - first student
     * @param o2 - second student
     * @return 1, 0, or -1 depending on relationship of o1 to o2
     */
    public int compare(Object o1, Object o2)
    {
        Student s1 = (Student)o1;
        Student s2 = (Student)o2;
        
        if (s1.ssNumber &lt; s2.ssNumber)
        {
            return -1;
        }
        if (s1.ssNumber &gt; s2.ssNumber)
        {
            return 1;
        }
        return 0;
    }
}
</pre>

<p>As always, control begins with the method <I>main()</I>. The program begins by creating an array of three 
<I>Student</I> objects.

<P></P><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>
     The definition of the <I>array</I> variable demonstrates 
    a syntax unique to Java. The first line declares an array of class <I>Student[]</I>. The calls to <I>new</I> 
    within the braces initializes the array to contain three 
<I>Student</I> objects. 
</BLOCKQUOTE></DIV>

<P></P><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>
     I used the Add Class command on the Project menu to add the Student.java 
    file to the project. This ensures that there is always an up-to-date copy of <I>Student.class</I> in the same directory as the 
    remainder of the project. 
</BLOCKQUOTE></DIV>

<p>Once it is created, the array is output to standard output 
using the local static <I>output() method</I>. The array of <I>Student</I> objects is then sorted by invoking the sole 
method of <I>ArraySorter</I>, the public static method <I>sort()</I>. The first argument is the array of <I>Student</I> objects. The second argument is an object that 
implements the <I>IComparer</I> interface<I>.</I>

<P>The class <I>StudentComparer</I> 
implements the <I>IComparer</I> interface by providing a <I>compare(Object, Object)</I> function capable of sorting 
students. The <I>compare()</I> function begins by casting the 
<I>o1</I> and <I>o2</I> objects into the <I>Student</I> objects <I>s1</I> and <I>s2</I>. This cast is justified because we know that this 
class is used only on arrays of 
<I>Student </I>objects. Once 
the two objects <I>s1</I> and <I>s2</I> 
have been created, 
<I>compare()</I> returns a -1, 0, or 1 
based on a comparison of the objects' Social Security number values.

<P>The <I>output()</I> method is then 
called again to output the sorted array and demonstrate that <I>ArraySorter</I> worked as planned.

<P>The output of the <I>SortStudent</I> 
program is shown in Figure 3-6.

<P><A HREF="javascript:fullSize('f03gh06x.htm')"> <img src="images/f03gh06.jpg" width=404 height=234 border=0 ALT="Click to view at full size."></A>

<P><!-- caption --><B>Figure 3-6.</B> <i>The </i>ArraySorter<I> class makes it easy to sort arrays of objects, like the 
 </I>Student<I> objects shown here.</I><!-- /caption -->

<P></P><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>
     C++ programmers will recognize this definition of an interface with a 
    single method as Java's replacement for function pointers. The Java approach 
    is both more type safe and safer. You'll see Java defining an interface with 
    a single method again in the discussion of event handlers in Part II. 
</BLOCKQUOTE></DIV>

<A NAME="128"><H3>Sorting an array of strings</H3></A>

<p>In the <I>StudentSort</I> example, I 
chose to sort the students by Social Security number. The most common approach 
to sorting, however, is to put objects in alphabetical order based on their 
string representation. Accordingly, the WFC 
<I>util</I> 
package includes the 
<I>StringSorter</I> class. This class 
serves a number of functions related to sorting strings.

<p>You can use the <I>StringSorter</I> 
class to sort arrays of 
<I>String</I> objects as follows:

<p><pre>
// create an array
String[] stringArray = {&quot;array1&quot;,
                        &quot;array3&quot;,
                        &quot;array2&quot;
                       };

// now sort the array
StringSorter.sort(stringArray);
</pre>

<p>The <I>StringSorter</I> class can also 
be used to sort other types of objects. For objects other than <I>String</I> objects, <I>StringSorter.sort()</I> invokes 
the 
<I>toString()</I> method to convert the objects to <I>String</I> objects and then sorts the objects based on the 
returned strings.

<p>For example, the following code segment would sort the 
students in alphabetical order based on their names followed by Social Security 
number, since this is the value returned by <I>Student.toString()</I>.

<p><pre>
// declare an array of Students
Student[] array = new Student[]
                  {
                      new Student(&quot;Shepherd, James&quot;, 234567890),
                      new Student(&quot;Smith, Harold&quot;,   123456789),
                      new Student(&quot;Davis, Stephen&quot;, 345678901)
                  };

// now sort them based on value returned by toString()
StringSorter.sort(array);
</pre>

<p>The <I>StringSorter.sort()</I> method 
provides other syntaxes, some of which allow for the inclusion of sort options. 
The options are defined as <I>final static</I> fields within 
the <I>StringSorter</I> class itself. Since these fields are 
defined as bit fields, multiple options can be combined with an OR ( | ) 
operator to increase the amount of control the application program has over the 
sort.

<p>For example, the following call is identical to the 
previous example except it sorts the <I>Student</I> objects 
based on the name values without regard to case or any special symbols that 
might appear in their names.

<p><pre>
StringSorter.sort(array, StringSorter.IGNORECASE |
                         StringSorter.IGNORESYMBOLS);
</pre>

<p>The <I>StringSorter</I> class can 
handle a large percentage of array sorting problems.

<A NAME="129"><H2>Lists</H2></A>

<p>A list is similar to an array except that a list isn't a 
fixed size. In many applications, the program doesn't know beforehand how many 
objects it needs to contain.

<P>There are two flavors of lists. The generic list is 
contained in <I>java.util.Vector</I>. The version specific to 
WFC is 
<I>com.ms.wfc.util.List</I>. Although the methods of 
these classes are not identical, they share most of the same features.

<P>A common use for a list might be in a program that reads 
student names from a file. Such a program doesn't know how many student names 
are in the file until it has gone through the process of reading them. With a 
list, the program can read each student name and add it to the list. With an 
array, the program would have to make two passes through the file: an initial 
pass to count the number of student names so that the program would know how big 
to allocate the array, followed by a second pass to actually read the names and 
assign them to the array.

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
     For really large data files, your application should use a database rather 
    than a list. 
</blockquote></div>

<A NAME="130"><H3>Sorting lists of students</H3></A>

<p>The following example reads student information from the 
keyboard and then sorts it. This version uses a list because it doesn't know how 
many students the user is likely to enter.

<p><pre>
import com.ms.wfc.io.*;
import com.ms.wfc.util.*;

/**
 * Add a series of Student objects to a list and then output
 * the list.
 */
public class StudentList
{
    /**
     * The main entry point for the application. 
     */
    public static void main (String[] args)
    {
        // create an empty list
        List list = new List();
        
        // enter Student objects until user enters null
        for (;;)
        {
            Text.out.writeLine(
                &quot;Enter student name (blank line to terminate)&quot;);
            String name = Text.in.readLine();
            if (name.equals(&quot;&quot;))
            {
                break;
            }
            Text.out.writeLine(&quot;Enter Social Security number:&quot;);
            int ssNumber = Integer.parseInt(Text.in.readLine());
                
            Student s = new Student(name, ssNumber);
            list.addItem(s);
        }
        
        // output the list
        output(&quot;Unsorted list&quot;, list);
        
        // now sort the list
        list.sort(new StudentComparer());
        
        // output the sorted list
        output(&quot;Sorted list&quot;, list);
    }
    /**
     * Output the contents of a list to standard output.
     * 
     * @param label - message to tack onto output
     * @param list - list to output
     */
    static void output(String label, List list)
    {
        Text.out.writeLine();
        Text.out.writeLine(label);
        int length = list.getSize();
        for (int i = 0; i &lt; length; i++)
        {
            Object o = list.getItem(i);
            Text.out.writeLine(o.toString());
        }
    }
}

/**
 * A class to provide the Student comparer method.
 */
class StudentComparer implements IComparer
{
    // same as in StudentSort example&#8230;
}
</pre>

<p>The program begins by creating an empty list. It then 
enters a loop that prompts the user for the student's name. If the user enters 
an empty line, control exits from the loop. Once the program has read the name, 
it then prompts for and reads the student's Social Security number, which it 
converts into an integer. The name and Social Security number are used to create 
a <I>Student</I> object which is appended to the list by 
calling 
<I>list.addItem()</I>. (Note that the program is not 
tolerant of illegal input.) Once the list has been created, <I>main()</I> continues as in the previous example by displaying the unsorted 
list, sorting the list, and then displaying the sorted list.

<P>The <I>List.sort()</I> method is 
similar to the <I>ArraySorter.sort()</I> method in that it 
relies on a user-defined 
<I>IComparer</I> object to sort 
whatever type of object is contained in the list. The <I>StudentComparer</I> class used in this example is identical to the version 
used in the SortStudent example.

<P>One other difference between lists and arrays is in the 
way that the elements of the list are accessed in the 
<I>output() </I>method. <I>List.getItem(i)</I> returns the <I>i</I>th member in the list, whereas an array would be 
accessed directly, as in 
<I>Array[i]</I>.

<P>Figure 3-7 shows the output from a trial run of the 
StudentList example.

<P><A HREF="javascript:fullSize('f03gh07x.htm')"> <img src="images/f03gh07.jpg" width=404 height=234 border=0 ALT="Click to view at full size."></A>

<P><!-- caption --><b>Figure 3-7.</b> <i>An example run of 
StudentList showing the sorted output following the unsorted output.</i><!-- /caption -->

<A NAME="131"><h3>Using <I>StringSorter</I> to sort 
lists</h3></A>
<p>In the StudentList example, I could have sorted the list 
by simply changing the <I>StudentComparer</I> class as 
follows:

<p><pre>
/**
 * The following StudentComparer sorts the students by
 * name while ignoring the case of the letters used.
 */
class StudentComparer implements IComparer
{
    public int compare(Object o1, Object o2)
    {
        return StringSorter.compare(o1.toString(),
                                    o2.toString(),
                                    StringSorter.IGNORECASE);
    }
}
</pre>

<p>This version of <I>StudentComparer</I> 
uses the 
<I>StringSorter.compare()</I> routine to perform a 
comparison of the string returned by 
<I>Student.toString()</I> while ignoring the case.

<A NAME="132"><H3>Enumerating through a list</H3></A>

<p>In the two student program examples, you might have 
noticed how it was necessary to modify the <I>output()</I> 
function to match the particular type of container we were using. Wouldn't it be 
nice if there was a way to access all types of containers irrespective of their 
internal details? In fact, there is.

<P>The <I>IEnumerator</I> interface 
provides universal access to all types of containers. This interface provides 
three methods for navigating the contents of a container, as shown in the 
following table.

<P>
<TABLE CELLPADDING="5" WIDTH="95%">
<TR>
<td valign=top><B><I>Method</I></B></td>
<td valign=top><B><I>Description</I></B></td>
</TR>

<TR>
<td valign=top><I>hasMoreItems()</I> </td>
<td valign=top>Returns <I>true</I> as long as the enumerator isn't pointing to the last 
            member.</td>
</TR>

<TR>
<td valign=top><I>nextItem()</I></td>
<td valign=top>Returns a reference to the object 
            pointed at by the enumerator, and moves the enumerator to the next 
            object in the container.</td>
</TR>

<TR>
<td valign=top><I>reset()</I></td>
<td valign=top>Resets the enumerator to the 
            beginning of the container.</td>
</TR>
</TABLE>

<P>The following version of <I>output()</I> works for arrays, lists, and other types of containers:

<p><pre>
static void output(String label, IEnumerator enum)
{
    Text.out.writeLine();
    Text.out.writeLine(label);
    while(enum.hasMoreItems())
    {
        Object o = enum.nextItem();
        Text.out.writeLine(o.toString());
    }
}
</pre>

<p>Rather than accept a reference to the container itself, 
this version of 
<I>output()</I> accepts an enumerator that 
has been initialized to point to the container. After outputting the preamble, <I>output()</I> iterates through the container using 
<I>nextItem()</I> until <I>hasMoreItems()</I> 
returns 
<I>false</I>.

<P>To invoke this version of <I>output(),</I> the array-based 
<I>SortStudent</I> class 
would use the following:

<p><pre>
// create an enumerator for the array
output(&quot;Sorted list&quot;, new ArrayEnumerator(array));
</pre>

<p>The list-based <I>StudentList</I> would 
make the following call:

<p><pre>
// pass a List enumerator to output
output(&quot;Sorted list&quot;, list.getItemEnumerator());
</pre>

<p>The actual class of enumerator being passed to <I>output()</I> is different in the two cases, but since both 
implement the 
<I>IEnumerator</I> interface, <I>output()</I> doesn't care.

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
     Arrays are handled differently than other types of containers, because 
    arrays are an intrinsic part of Java and can't be subclassed. All other 
    container types work like <I>List</I> by providing a 
<I>getEnumerator()</I>-type method. 
</blockquote></div>

<A NAME="133"><H2>Hash Tables</H2></A>

<p>Neither the array nor the list are convenient for looking 
up items. In the case of the unsorted student list, if the user wanted to look 
up a student by Social Security number, the program would be forced to perform a 
linear search until the Social Security number is found.

<P>The <I>HashTable</I> class is 
particularly convenient and computationally quick for looking up items. The 
following example program demonstrates the use of the 
<I>HashTable</I> class to store <I>Student</I> objects and 
then recall them rapidly:

<p><pre>
import com.ms.wfc.io.*;
import com.ms.wfc.util.*;

/**
 * Add a series of Student objects to a hashed dictionary.
 */
public class StudentHash
{
    /**
     * The main entry point for the application. 
     */
    public static void main (String[] args)
    {
        // create a default-sized hash table
        HashTable table = new HashTable();
        
        // enter Student objects until user enters null
        for (;;)
        {
            // get the Student object
            Text.out.writeLine(
                &quot;Enter student name (blank line to terminate)&quot;);
            String name = Text.in.readLine();
            if (name.equals(&quot;&quot;))
            {
                break;
            }
            Text.out.writeLine(&quot;Enter Social Security number:&quot;);
            int ssNumber = Integer.parseInt(Text.in.readLine());
            Student student = new Student(name, ssNumber);
            
            // add it to the table using the Social
            // Security number as the key
            Integer key = new Integer(student.getSSNumber());
            table.setValue(key, student);
        }
        
        // now look up entries in the hash table by Social
        // Security number
        for(;;)
        {
            // get the Social Security number
            Text.out.writeLine(&quot;Enter S. S. number to look up entry:&quot;);
            String keyString = Text.in.readLine();
            if (keyString.equals(&quot;&quot;))
            {
                break;
            }
            
            // look up the student by number entered
            Integer key = new Integer(keyString);
            Student s = (Student)table.getValue(key);
            
            // output the student value returned
            if (s == null)
            {
                Text.out.writeLine(&quot;Entry not found&quot;);
            }
            else
            {
                Text.out.writeLine(s.toString());
            }
        }
    }
}
</pre>

<p>This version reads entries similarly to its list-based 
predecessor. To add the student entries to the container, this version uses the 
<I>HastTable.setValue(Object key, Object value)</I> method. 
The <I>key</I> argument will be used to look up the 
<I>value</I> argument later. Since we want to look up students 
by Social Security number, the program uses the <I>int</I> 
returned from <I>getSSNumber()</I> as the key; however, since 
the key must be an object, the program must first convert the <I>int</I> into an <I>Integer</I>.

<P>Once the student information has been stored in the hash 
table, the program uses <I>HastTable.getValue(key)</I> to 
look up the student. The Social Security number read from the user entry is 
converted into an <I>Integer</I> object, which is passed to 
<I>getValue()</I>. If <I>getValue()</I> 
returns a <I>null</I>, no student was found with that Social 
Security number.</P>

</BODY>
</HTML>




