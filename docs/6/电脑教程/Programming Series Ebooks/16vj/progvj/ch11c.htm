<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>J/Direct Revealed</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch11b.htm", "ch11d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="355"><H1>J/Direct Revealed</H1></A>

<p>As simple as the two previous applications might seem to the Java programmer, J/Direct performed several important and nontrivial tasks to make our Beep and SetSystemTime examples execute properly. Let's talk about the steps that J/Direct must perform to enable a call from a Visual J++ 6 program to a C function residing in a DLL.

<A NAME="356"><H2>DLL Loading</H2></A>

<p>The most obvious problem that J/Direct solves is the otherwise difficult task of loading the necessary DLLs. A DLL is a library of routines that isn't necessarily resident 
in memory. A DLL is loaded into memory immediately before a program that needs it begins to run. The memory occupied by the DLL can be reclaimed by the operating system when the DLL is no longer referenced by any currently running 
application. (This might seem obvious to Windows programmers, but there was no equivalent to the DLL in operating systems developed prior to Windows.)

<P>As explained previously, the Win32 API functions J/Direct accesses are located within Windows DLLs. J/Direct can also be instructed to access user-defined functions, as long as these functions reside within a DLL. In both cases, J/Direct 
can't assume that a target DLL is memory-resident. Therefore, before J/Direct can perform the conversion call from Visual J++ 6 to C or C++, it must make sure that the 
target DLL is memory-resident.

<P>Thus, when the <I>button1_click()</I> method invokes <I>Win32.Beep() </I>in the previous Beep application, J/Direct checks whether KERNEL32.DLL is already memory-
resident. (Remember that <I>Win32.Beep() </I>is part of KERNEL32.DLL.) If KERNEL32.DLL isn't in memory, J/Direct makes the system calls necessary to load it.

<A NAME="357"><H2>Marshaling</H2></A>

<p>Once J/Direct has loaded the proper DLL into memory, and before J/Direct can call the C function from Visual J++ 6, J/Direct must convert any arguments to the function from the Java data type to the equivalent C or C++ data type. Once the call to the C or C++ function is complete, J/Direct must convert these arguments plus the return value back into Java data types. This process of converting data types from the calling language to the target language and back is called 
<I>marshaling</I>.

<p>The following table shows the data type conversions J/Direct performs to marshal arguments from Java to C and back. The capitalized native data types are common Windows <I>#define</I> constants for intrinsic C types. (Calls to C++ functions work the same as calls to C functions, but calls to C++ methods aren't supported by J/Direct.)

<p><B>Conversion of data types between Java and 32-bit native functions</B>

<P>
<TABLE CELLPADDING=5 WIDTH="95%">
 
<TR>
<TD VALIGN="TOP"><B><I>Java Data Type</I></B></TD>
<TD VALIGN="TOP"><B><I>Native Function<BR> Data Type</I></B></TD>
<TD VALIGN="TOP"><B><I>Comments</I></B></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>void</I></TD>
<TD VALIGN="TOP"><I>void</I></TD>
<TD VALIGN="TOP">This is a return type only. However, J/Direct does handle functions that have no arguments.</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>byte</I></TD>
<TD VALIGN="TOP"><I>BYTE</I> or <I>char</I></TD>
<TD VALIGN="TOP">&nbsp;</TD>  
</TR>

<TR>
<TD VALIGN="TOP"><I>short</I></TD>
<TD VALIGN="TOP"><I>short</I> or <I>WORD</I>  </TD>   
<TD VALIGN="TOP">&nbsp;</TD>  
</TR>

<TR>
<TD VALIGN="TOP"><I>int</I></TD>
<TD VALIGN="TOP"><I>int</I>, <I>unsigned int</I>, <I>long, unsigned long</I>, <I>UINT</I>,<I> ULONG</I>, or <I>DWORD</I></TD>
<TD VALIGN="TOP">J/Direct maps signed and unsigned to the same type because Java doesn't support unsigned.</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>char</I></TD>
<TD VALIGN="TOP"><I>unsigned short</I>, <I>TCHAR</I></TD>
<TD VALIGN="TOP">A C char value is normally 8 bits; a TCHAR corresponds to the Unicode style 16-bit char value.</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>long</I></TD>
<TD VALIGN="TOP"><I>__int64</I></TD>
<TD VALIGN="TOP">__int64 is a special Visual C++ 64-bit type.</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>float</I></TD>
<TD VALIGN="TOP"><I>float</I></TD>
<TD VALIGN="TOP">&nbsp;</TD>  
</TR>

<TR>
<TD VALIGN="TOP"><I>double</I></TD>
<TD VALIGN="TOP"><I>double</I></TD>
<TD VALIGN="TOP">&nbsp;</TD>  
</TR>

<TR>
<TD VALIGN="TOP"><I>boolean</I></TD>
<TD VALIGN="TOP"><I>int</I>, <I>BOOL</I></TD>
<TD VALIGN="TOP">C uses the rule that 0 is false and all else is true.</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>String</I></TD>
<TD VALIGN="TOP"><I>const TCHAR*</I>, <I>LPCTSTR</I></TD>
<TD VALIGN="TOP">Not allowed by J/Direct as a return type.</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>StringBuffer</I></TD>
<TD VALIGN="TOP"><I>TCHAR*</I>, <I>LPTSTR</I>     </TD>
<TD VALIGN="TOP">Not allowed by J/Direct as a return type. Set the <I>StringBuffer</I> capacity to hold the largest possible return value.</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>java[]</I></TD>
<TD VALIGN="TOP"><I>C*</I></TD>
<TD VALIGN="TOP"><I>java</I> is the Java intrinsic type, and <I>C</I> is the C intrinsic type; that is, int[] maps to DWORD*</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>Object</I></TD>
<TD VALIGN="TOP"><I>struct*</I></TD>
<TD VALIGN="TOP">J/Direct maps a pointer to a C structure to a reference to a static class; J/Direct can't handle the passing of structures by value.</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>com.ms.dll.Callback</I></TD>
<TD VALIGN="TOP">function pointer     </TD>
<TD VALIGN="TOP">&nbsp;</TD>  
</TR>
</TABLE>

<p>To marshal an intrinsic type, such as a <I>char</I> to a <I>short</I>, J/Direct simply casts the argument from one type to the other. There are numerous problems with marshaling more complex objects, and these problems are outlined in the following sections.

<A NAME="358"><H2>Passing Pointers</H2></A>

<p>Many C functions return a value to the caller by using pointers to intrinsic values as arguments. Let's call these types of pointers <I>intrinsic pointers</I> (in contrast to pointers to structure objects). For example, functions like the following aren't uncommon in C:

<p><pre>
void divideInt(int numerator, int denominator,
               int* pResult, int* pRemainder)
{
    *pResult    = numerator / denominator;
    *pRemainder = numerator % denominator;
}
</PRE>

<p>The function <I>divideInt()</I> accepts two simple integers and two pointers to integers. The results of dividing <I>numerator</I> by <I>denominator</I> are returned to the caller through the intrinsic pointers <I>pResult</I> and <I>pRemainder</I>. Java has no direct equivalent to the C intrinsic pointer&#8212;the nearest match is an array of length 1. If the <I>divideInt()</I> function were part of the MATH.DLL dynamic-link library, the following Java 
<I>isPrime()</I> function would call the <I>divideInt()</I> function, properly receiving the returned integer values in the arrays <I>result</I> and <I>remainder</I>:

<p><pre>
class MyMath
{
    /** dll.import(&quot;MATH&quot;) */
    private static native void divideInt(int numerator,
                                         int denominator,
                                         int[] result,
                                         int[] remainder);

    public static boolean isPrime(int n, int d)
    {
        int[] result    = new int[1];
        int[] remainder = new int[1];
  
        // make the call
        divideInt(n, d, result, remainder);

        // prime if remainder is 0
        return remainder[0] == 0;
    }
}
</PRE>

<p>Declaring the variables <I>result</I> and <I>remainder</I> to be arrays of length 1 signals J/Direct to pass these references as pointers and to allocate space for the integer returned. The value returned is always in array element zero.

<A NAME="359"><H2>Handling C Structures</H2></A>

<p>A C structure presents J/Direct with a number of problems. The Java class doesn't correspond directly to the C structure. When a Visual J++ 6 method passes to a C function a reference to a class object, J/Direct must take the following steps:

<OL>
<P><LI>It creates a C structure that has the same data members as the Visual J++ 6 class. (We'll talk more about this later.)

<P><LI>It assigns to each data member from the Java class the corresponding data member in the C structure.

<P><LI>It passes a pointer to the C structure.

<P><LI>It reverses the process on the way back from the native function to Visual J++ 6.
</OL>

<p>As simple as this sounds, several problems that we'll discuss in the following sections can arise during the creation and assignment steps.

<A NAME="360"><H2>Handling Strings</H2></A>

<p>The <I>String</I> class is the most commonly used class in the Java library. Unfortunately, the Java <I>String</I> object is quite different from the C ASCIIZ string. The Java 
<I>String</I> class contains not only the string itself but a length data member. In addition, Java assigns no particular meaning to any given character. In contrast, the C string has no length. Instead, C strings use the character 0x0 to indicate the end of the string. When converting a Java string into a C ASCIIZ string, J/Direct must add a 0x0 character to the end of the character string data before passing it to the C function. (The application code must make sure that none of the characters in the string are 0x0.) Upon return, J/Direct counts the number of characters up to the 0x0 character and uses this as the length of the <I>String</I> object.

<P>In addition, the Java <I>String</I> class always refers to Unicode characters. In contrast, C strings can be Unicode or ANSI characters.

<P><DIV CLASS="warning"><BLOCKQUOTE>
<B>WARNING</B>
<HR>The Win32 TCHAR is a 16-bit character type. J/Direct doesn't support the conversion of a <I>String</I> object to simple 8-bit <I>char*</I> type C strings. For this conversion, the programmer should convert the <I>String</I> object into a byte array using the <I>String</I> method <I>getBytes(),</I> and then pass the byte array rather than 
the <I>String</I>.
</blockquote></div>

<p>Finally, the Win32 API defines different functions to handle ANSI TCHAR strings than to handle Unicode TCHAR strings. By default, J/Direct assumes the ANSI version. Thus, when Java calls the following method, J/Direct converts the <I>String</I> object into a null-terminated ANSI character array:

<p><pre>
/** @dll.import(&quot;USER32&quot;) */
static native int MessageBox(int hwnd, String text, 
                             String title, int sytle);
</PRE>

<p>There are three different types of Win32 functions. Older Win32 functions carry a generic name such as <I>MessageBox()</I>. This generic function handles ANSI 
character arrays. More recent Win32 functions come in two forms. A function with a name like <I>MessageBoxA() </I>also processes an ANSI character array. A function like <I>MessageBoxW() </I>handles the equivalent task for Unicode character arrays.

<p>The <I>dll.import()</I> directive by default accepts the ANSI version, so by default you can use <I>MessageBox()</I> or <I>MessageBoxA()</I>. The <I>dll.import()</I> directive also enables you to specify the <I>MessageBoxW()</I> Unicode API version by using the following code:

<p><pre>
/** @dll.import(&quot;USER32&quot;, unicode) */
static native int MessageBox(int hwnd, String text, 
                             String title, int sytle);
</PRE>

<p>Unfortunately, neither the ANSI version nor the Unicode version is ideal for all Win32 platforms. ANSI mode is required by Windows 95 and Windows 98, which don't support Unicode, but it is inefficient for Windows NT, which defaults to Unicode. (Windows NT does grudgingly support ANSI mode.)

<p>The <I>dll.import()</I> directive's <I>auto</I> modifier provides a way out of this ANSI vs. Unicode problem. The <I>auto</I> modifier directs J/Direct to use the optimum type of conversion for the current operating system, as shown in the following code:

<p><pre>
/** dll.import(&quot;USER32&quot;, auto) */
public static native void MessageBox(int hwndOwner, String text, 
                                     String title, int style);
</PRE>

<p>For example, the following method <I>openMB(String text) 
</I>calls the method <I>MessageBox()</I> to display the specified text using the optimum method for the host version of Windows.

<p><pre>
class ShowMessageBox
{
     public static void openMB(String text)
     {
         MessageBox(0, text, &quot;Message&quot;, 0);
     }

     /** dll.import(&quot;USER32&quot;, auto) */
     private static native int MessageBox(int hnd, String text,
                                          String title, int style);
 }
</PRE>

<p>Since this character mode decision is made at run time, a Visual J++ 6 program written using the <I>auto</I> directive always invokes the most efficient Win32 API function for the current version of Windows.

<A NAME="361"><H2>Matching C Structure Details</H2></A>

<p>The C programmer has more control over the layout of C structures than the Java programmer does. Fortunately for Java programmers, Visual J++ accounts for this situation with modifiers to the <I>dll.struct()</I> directive<I>.</I>

<A NAME="362"><H3>Packing</H3></A>

<p>One consideration in laying out C structures is <I>packing</I>. Most CPUs can only access memory one word at a time, and different processors in the Intel series define 
&quot;word&quot; differently. Pentium processors and faster processors access memory on 4-byte (32-bit) boundaries. If an integer is located on an address that is a multiple of 4 
bytes, the entire integer can be read in a single memory read. This is called an <I>aligned read</I>. If the integer is stored at an address that isn't a multiple of 4 bytes, the CPU must perform two reads and combine the necessary parts of these two words into one. This is called an <I>unaligned read</I>. Obviously, an unaligned read is slower than an aligned read.

<p>To avoid this slowdown, the Microsoft Visual C++ compiler enables you to specify that integers be packed on 4-byte boundaries. To see the results of this decision, consider the structure definition below.

<p><pre>
struct X
{
    char a;
    int  b;
};
</PRE>

<p>Suppose char <I>a,</I> which is 1 byte in length, is at address 100. You might think that int <I>b</I> would be at address 101, but this normally is not the case. By default, 
the Visual C++ compiler would put <I>b</I> at address 104, thereby ensuring word alignment and optimum access performance.

<P>The down side of packing for performance is that it wastes space. Thus, Visual C++ enables you to change the packing size to decrease the memory storage requirements. This option might be important when a program contains a large number of structure objects that are accessed infrequently. In such a case, the memory concerns outweigh the performance degradation.

<P>Java has no such control over the packing size. With Java, you must live with whatever the packing rules might be. At the same time, J/Direct must allow the Visual J++ 6 programmer to access a Visual C++ structure no matter how it is packed.

<P>The <I>pack</I> modifier enables you to match J/Direct conversion to the packing of the structure in memory:

<p><pre>
/** @dll.struct(pack = n) */
</PRE>

<p>In this code, <I>n</I> is either 1, 2, 4, or 8, and the unit of <I>n</I> is byte. The default value of <I>pack</I> is 8, to match the <I>pack</I> pragma default in Visual C++. The default value of <I>pack</I> for structures within the Win32 API is also 8.

<A NAME="363"><H3>Fixed length arrays within a structure</H3></A>

<p>A second problem in converting Java classes to C and C++ structures lies in the way Java and C create data members. It's possible in C to declare a fixed-length array within a structure, whereas in Java you declare a reference to an array. J/Direct handles this discrepancy with the <I>dll.structmap()</I> directive. Consider the following example, which demonstrates the use of <I>dll.structmap()</I>. The C structure is defined as follows:

<p><pre>
structure Sample
{
    TCHAR array1[32];
    float array2[15];
};
</PRE>

<p>You would use the <I>dll.struct()</I> directive with 
<I>dll.structmap()</I> to describe this structure to J/Direct:

<p><pre>
// example class name
class Win32
{
    /** dll.struct() */
    class Sample
    {
        /** @dll.structmap([type=TCHAR[32]]) */
        String array1;

        /** @dll.structmap([type=FIXEDARRAY, size=15]) */
        float[] array2;
    };
}
</PRE>

<p>The data member <I>array1</I> is declared as a 32-character <I>String,</I> while <I>array2</I> is declared as a fixed array containing 15 elements of <I>float </I>data type.

<A NAME="364"><H2>Accessing Win32 Error Codes</H2></A>

<p>Most Win32 API functions return error codes as an integer value, with 0 indicating that no error occurred. Some Win32 API functions signal an error by returning a value of <I>false</I>&#8212;indicating the operation failed&#8212;and storing the integer code into a global variable called <I>errno</I> to indicate the specific error that occurred. (This is particularly true of the older functions that make up the C function library.)

<P>When calling functions that use <I>errno</I>, you should not attempt to access the global error indicator directly. After the error has occurred, J/Direct might make further Win32 calls that could write over the error indicator in <I>errno</I> before returning control to your Visual J++ 6 method.

<P>The <I>dll.import() </I>directive modifier <I>setLastError</I> instructs J/Direct to capture the error code immediately after it invokes the Win32 API call. When using the <I>setLastError</I> modifier, the static method <I>com.ms.dll.DllLib.getLastWin32Error() </I>returns the 
error code.

<A NAME="365"><h3>The <I>setLastError</I> modifier</h3></A>
<p>The following code is a short example of how to use the <I>setLastError</I> modifier.

<p><pre>
class Win32
{
    /** @dll.struct() */
    class WIN32_FIND_DATA
    {
        &#8230;define the structure here&#8230;
    }

       /** @dll.import(&quot;KERNEL32&quot;, setLastError) */
       static native boolean FindNextFile(int hFindFile,
                                          Win32.WIN32_FIND_DATA wfd);
    }

    class MyCode
    {
       // declare the WIN32_FIND_DATA structure
        Win32.WIN32_FIND_DATA wfd = new Win32.WIN32_FIND_DATA();

        // keep the error code
        int errCode;

        /**
         * Find the next file by using a Win32 API call; set error code.
         */
        boolean findNextFile(int hFindFile)
        {
            // assume no error
            errCode = 0;

            // invoke the method
            boolean f = Win32.FindNextFile(hFindFile, wfd);

            // if it didn't work&#8230;
            if (f == false)
            {
                // capture the error code from Win32 call
                errCode = com.ms.dll.DllLib.getLastWin32Error();
            }
            return f;
        }
    }
</PRE>

<p>In this example, the class <I>WIN32_FIND_DATA</I> was either created by the J/Direct Call Builder or carefully constructed by hand to match the WIN32_FIND_DATA structure declared in the windows.h include file. The structure's contents aren't listed here. The Win32 API function <I>FindNextFile()</I> is declared to accept the integer variable <I>hFindFile</I> (the variable's meaning and purpose are irrelevant for this example) and a <I>WIN32_FIND_DATA</I> object. In addition, the function declaration instructs J/Direct to capture any error that might occur while calling the API function.

<P>The class <I>MyCode</I> contains a method, <I>findNextFile(),</I> which invokes the Win32 API call 
<I>FindNextFile()</I> using the <I>WIN32_FIND_DATA</I> object <I>wfd</I>. If <I>find NextFile()</I> returns <I>false</I> indicating that an error occurred in the C 
function <I>FindNextFile()</I>, the method <I>findNextFile()</I> captures the error code by calling <I>com.ms.dll.DllLib.getLastWin32Error()</I>.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
Don't capture the Win32 API error code if the value returned 
indicates that the function worked properly. Many API calls do not set the error code unless something goes wrong.
</blockquote></div>

<A NAME="366"><H2>Garbage Collection</H2></A>

<p>There are several other problems that J/Direct must overcome when calling a C function from Visual J++ 6 and that are unrelated to class and struct issues. One problem is Java's garbage collector.

<P>The garbage collector is a background process that returns unused objects to the pool of unused memory. This pool is called the <I>heap</I> in both the Java and C++ languages.

<P>To make more efficient use of the heap, Java moves objects around in memory during the garbage collection process. When an object is moved in memory, the garbage collector updates the references to the object accordingly. This makes the change in an object's memory address invisible to other Java classes.

<P>C has no concept that corresponds with garbage collection. You are expected to direct your program to return objects once they are no longer in use. In 
addition, C expects its objects to stay put in memory. C would consider moving objects about in memory to be decidedly unfriendly.

<P>J/Direct solves this problem by storing interface objects in a special section of the heap where objects aren't repacked by the garbage collector.

<A NAME="367"><H2>Name Mangling</H2></A>

<p>Another concern in accessing C or C++ functions is that the name of a C or C++ function is different in the source file than it is in the object file. C simply adds an underscore to the name of the function when it puts the function in the object file. Thus, <I>myFunction(int) </I>in the source file becomes <I>_myFunction </I>in the object file. In the case of C++, the differences in function names are more severe. Thus, <I>myFunction(int)</I> might become <I>myFunction$i</I>. The suffix <I>$i</I> in the C++ function name indicates the number and the types of the function arguments.

<P>This process of changing function names is called <I>name mangling</I>. Fortunately, J/Direct understands the way C and C++ mangle names and takes care of tracking function names for you.

<A NAME="368"><H2>Aliasing</H2></A>

<p>Aliasing enables you to assign Java-like names to Win32 API functions. You or the creators of the language might have established naming conventions for the names of methods. For example, by convention Java method names begin with a small letter, and Java class names begin with a capital letter. The names of Win32 API functions begin with a capital letter.

<P>You can change the name of the C function you are calling to a name more to your liking by creating an alias, as shown in the code below.

<p><pre>
/** dll.import(&quot;USER32&quot;, auto, entrypoint=&quot;MessageBox&quot;) */
public static native int messageBox(int hnd, String text,
                                    String title, int style);
</PRE>

<A NAME="369"><H2>Handling Callbacks</H2></A>

<p>It's not uncommon for C functions to make use of what is known as a <I>callback function</I>. This concept is explained in the following section.

<A NAME="370"><H3>Declaring callbacks in C</H3></A>

<p>Consider the following C example of a generic sort routine. (This example shows neither the struct MO nor the <I>#define LENGTH</I>.)

<p><pre>
// the order function can put an array of MO objects in any order
// as long as you can provide a pointer to a function that compares
// the objects. This pointer to a function is often called a
// callback.
void order(int (*pCompare)(MO* p1, MO* p2), MO* pArray, int length);

// compareMO - compare two MO objects
int compareMO(MO* p1, MO* p2)
{
    .
    .
    .
}

void myProg()
{
    struct mo[LENGTH];
    .
    .
    .
    // order the array of MO objects
    order(compareMO, mo, LENGTH);
}
</PRE>

<p>In this code, the <I>order()</I> function sorts an array of <I>MO</I> objects using the <I>compareMO()</I> function to establish the sequencing of objects.

<p>To be more specific, the first argument to <I>order()</I> is a function that takes two pointers to <I>MO</I> objects and returns an <I>int</I> value that indicates whether or not <I>p1</I> comes before <I>p2</I> in the sorted list.

<P>When calling <I>order()</I>, the <I>myProg()</I> function provides a pointer to the function <I>compareMO()</I>, whose declaration matches exactly the declaration of the pointer required by <I>order()</I>. Somewhere within its logic, the <I>order()</I> function will invoke this programmer-provided <I>compareMO()</I> function indirectly through the function 
pointer provided.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
The C callback is similar in concept to the Visual J++ 6 delegate. A delegate is the Visual J++ 6 analog to a function pointer. The delegate is associated with a method before it is passed to an <I>addX() </I>method such as <I>addOnClick()</I>. When the <I>onClick()</I> event occurs, Visual J++ 6 invokes the delegate method.
</blockquote></div>

<p>The term callback comes from the fact that the <I>order()</I> function calls back to the <I>compare()</I> function.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
There are many other uses for callback functions, but they all involve passing a pointer to a function to another function.
</blockquote></div>

<A NAME="371"><H3>Handling callbacks in J/Direct</H3></A>

<p>The following example demonstrates how to declare a function in Visual J++ 6 that accepts a callback function:

<p><pre>
// some application programmer defined class
class MyDLL
{
    /** @dll.struct() */
    static class MO
    {
        int value;
    }
    
    /** @dll.import(&quot;MyDLL&quot;) */
    static native void order(com.ms.dll.Callback compare,
                             MO[] objs, int length);
}
</PRE>

<p>In this example, <I>compare</I> is a callback method that is being passed to the C function <I>order()</I>.

<P>The callback function must be a nonstatic method named <I>callback()</I>. It must be a method of a class that extends the class <I>Callback</I>. The arguments to the method <I>callback()</I> must match those required by the calling function&#8212;in this case, <I>order()</I>:

<p><pre>
class MyCallbackClass extends com.ms.dll.Callback
{
    int callback(MyDLL.MO mo1, MyDLL.MO mo2)
    {
        // &#8230;whatever comparison&#8230;
    }
}
</PRE>

<p>A Visual J++ program would invoke the <I>order()</I> function as follows:

<p><pre>
MyDLL.order(new MyCallbackClass(), MyDLL.MO, MyDLL.MO.length);
</PRE>

<p>In this case you, the Visual J++ 6 programmer, have passed an object of class <I>MyCallbackClass</I> to J/Direct. J/Direct constructs a callback function which it 
passes on to the C function <I>order()</I>. When <I>order()</I> calls the provided callback function, J/Direct passes the call on to <I>MyCallbackClass.callback()</I>.

<A NAME="372"><H3>Callback example</H3></A>

<p>The following example shows a class <I>MyFunc,</I> whose constructor declares an array of <I>MyDLL.MO</I> objects. The constructor then sorts the objects using the native method <I>order()</I> by means of a Java callback function:

<p><pre>
class MyFunc extends com.ms.dll.Callback
{
    // declare an array of MO objects
    MyDLL.MO[] mo = new MyDLL.MO[]
                       {
                            new MyDLL.MO(),
                            new MyDLL.MO(),
                            new MyDLL.MO()
                       };
    
    /**
     * Sort the MO objects using the native order function.
     */
    public MyFunc()
    {
        // sort the array mo using the method callback()
        // to perform the comparisons (this is legal since
        // the current class extends Callback)
        MyDLL.order(this, mo, mo.length);
    }
    
    /**
     * Provide the callback function that performs the comparison.
     * (This function must match exactly the requirements of
     * the callback function as defined by order().)
     */
    int callback(MyDLL.MO mo1, MyDLL.MO mo2)
    {
        if (mo1.value &gt; mo2.value)
        {
            return 1;
        }
        if (mo1.value &lt; mo2.value)
        {
            return -1;
        }
        return 0;
    }
}
</PRE>

</BODY>
</HTML>




