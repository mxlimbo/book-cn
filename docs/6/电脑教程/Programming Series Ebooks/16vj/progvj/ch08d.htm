<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>Putting It All Together with FileMgr</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch08c.htm", "ch08e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="251"><H1>Putting It All Together with FileMgr</H1></A>

<p>Both the ListViewDemo and TreeViewDemo applications were intended as 
simple demos of the ListView and TreeView controls. Even so, the ListViewDemo 
program uses the list view to effectively give the user access to the contents of a 
directory, and the TreeViewDemo program demonstrates how the tree view control gives 
the user a good overview of their directory structure. If we combine these two 
programs, we can generate a powerful disk copy utility. In fact, this utility would closely 
resemble Windows Explorer, which comes with 32-bit versions of Windows.

<P>We'll create such a utility, called FileMgr<I>, 
</I>as an example of an almost-real-world application. FileMgr will have a TreeView control on the left and a ListView 
control on the right. The tree view will be used to display the directory hierarchy. As the 
user selects a directory in the tree view, the display of the list view on the right will 
immediately update to display the files in that directory. The user will be able to 
select any number of files from the list view and drag them over to the tree view. 
Dropping the selected files on one of the nodes will cause the FileMgr application to 
copy the files to the directory at the specified node. Once the files are copied, the user 
will be given the option of deleting the source files. An edit window across the 
bottom of the FileMgr window will be used to display the copy and delete commands as 
they are carried out.

<A NAME="252"><H2>The Forms Designer Work</H2></A>

<p>Begin by copying a TreeView control to the left side and a ListView control to 
the right side of the form created by the Windows Application builder. Place an 
Edit control along the bottom. Expand the TreeView and ListView controls so that 
they take up most of the available space in the form, leaving a comfortable margin 
between all three controls. The TreeView control doesn't need as much room 
horizontally as the ListView control. Therefore, I assigned about one third of the 
horizontal space to the TreeView control and two thirds to the ListView control. You might 
want to peek ahead to Figure 8-8 to see what these controls look like in 
the Forms Designer.

<P>Anchor the TreeView control to the top, bottom, and left of the form 
window. Anchor the ListView control to the top, bottom, and right of the form. Anchoring 
these two controls to both the top and bottom will let the Windows Foundation 
Classes for Java (WFC) take care of resizing the controls vertically as the form is 
resized; however, we will resize them horizontally to maintain the 
1/3 to 2/3 ratio. Finally, anchor the Edit control to the left, right,
and bottom of the form.

<A NAME="253"><H3>Setting the TreeView control properties</H3></A>

<p>First, rename the <I>TreeView</I> object to 
<I>treeView</I>. Since the white background of the TreeView control looks a bit garish compared to the gray background of the 
form, set the TreeView control's background color to 
<I>Control </I>(gray). Since we plan to implement in-process drag-and-drop, set the control's 
<I>allowDrop</I> flag to <I>true</I>.

<P>I didn't worry about using images in the TreeViewDemo demo 
application; however, in this more realistic application we will need to adorn our TreeView 
control with images. 

<P>You can assign two different images to a TreeView control. One image is 
used for the currently selected node and the other for all other nodes. Normally, a 
small image of a partially opened folder is used for the selected node and an image of 
a closed folder is used for the rest. To find such an image, I searched my hard disk 
for all .ico (icon) files. The two files named OPENFOLD.ICO and CLSDFOLD.ICO 
appeared to be exactly what I wanted. I created a subdirectory of the project 
directory named images and copied these two files into that directory. If you can't find 
suitable images either lying about on your hard disk or somewhere on the Internet, 
you can create them in Microsoft Paint or some other graphics program. Make the images 
16-by-16 pixels in size. Of course, you can always use the images included with 
this application on the companion CD-ROM.

<P>Drag an ImageList control from the Toolbox, and drop it somewhere on 
the Forms Designer. Add the two folder images to the ImageList using the Image Editor. 

<P>Returning to the TreeView control, set its <I>imageList 
</I>property<I> </I>to <I>imageList </I>(the name of the image list you just 
created);<I> </I>set its <I>imageIndex</I> property to be the 
index of the closed folder image in the image list; and set its 
<I>selectedImageIndex</I> property to be the index of the open folder image.

<A NAME="254"><H3>Setting the ListView control properties</H3></A>

<p>First rename the ListView control to 
<I>listView</I>. Again set the background color to 
<I>Control</I> to match the background of the TreeView control and the form. Set the control's 
<I>view</I> property to <I>Report</I>; this will ensure that the file details appear next to the file 
name. Add three column headers, and set their text to 
<I>File</I> <I>Name</I>, <I>File</I> <I>Size</I>, and 
<I>Last</I> <I>Modified</I>. Leave the column properties as they are except for the File Size column. 
Since this column will be used to display numbers, set its 
<I>textAlign</I> property to<I> Right</I> rather than the 
default<I> Left</I>.

<P>Set the <I>fullRowSelect</I> property of the ListView to 
<I>true</I>. That way, when the user selects any one of the properties the entire row will be selected. I set the 
<I>gridLines</I> property to <I>true</I> because I prefer to see the gray gridlines; however, you can set 
this property as you please.

<P>Since I personally think that icons don't add that much to the file list, I did 
not bother to define an image list for the ListView control.

<A NAME="255"><H3>Setting the Edit control properties</H3></A>

<p>Rename the Edit control to <I>edit</I>. Clear its 
<I>text</I> property setting so that it is blank. 
Since this Edit control is used only to receive output, set the 
<I>readOnly</I> property to <I>true</I>. Finally, I set the background color to 
<I>Control</I> to match the other two controls and the form.

<P>The resulting form in the Forms Designer is shown in Figure 8-8.
 
<P><A HREF="javascript:fullSize('F08gh08x.htm')"> <img src="images/F08gh08.JPG" width=404 height=375 border=0 ALT="Click to view at full size."> </A>
<p><!-- caption --><b>Figure 8-8.</b> <i>The FileMgr application in the Forms Designer.</i><!-- /caption -->

<A NAME="256"><H2>The Code</H2></A>

<p>The code for FileMgr appears in all its glory as follows:

<p><pre>
import com.ms.wfc.app.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;
import com.ms.wfc.html.*;

import com.ms.wfc.io.*;
import com.ms.wfc.util.*;

/**
 * This class can take a variable number of parameters on the command
 * line. Program execution begins with the main() method. The class
 * constructor is not invoked unless an object of type 'Form1' is
 * created in the main() method.
 */
public class Form1 extends Form
{
    String directory;
    
    public Form1(String[] args)
    {
        // Required for Visual J++ Form Designer support
        initForm();

        // start either from the current directory
        // or from the path specified in the argument list
        directory = File.getCurrentDirectory();
        if (args.length == 1)
        {
            directory = args[0];
        }
        
        // now populate the treeView with the directory
        // tree starting at the current directory
        treeView.addNode(expandTreeNode(&quot;&quot;, directory));
        
        // populate the list with the files in the
        // current directory
        createList();
    }

    /**
     * Create the fileView list.
     */
    private static final ListItem[] clear = new ListItem[0];
    void createList()
    {
        // first clear out the list view contents by passing
        // it a zero length array of list items
        listView.setItems(clear);
        
        // reset background color after clearing the list
        listView.setBackColor(Color.CONTROL);
        // now create a list of just the files (no directories)
        List fileList = createSortedList(directory, false);
        
        // now add them to the list view
        addFilesToListView(fileList);
    }
    
    /**
     * Expand the directory dirName within path.
     */
    TreeNode expandTreeNode(String path, String dirName)
    {
        // create a node with that directory name
        TreeNode node = new MyTreeNode(dirName, path);

        // combine the path with the directory name
        path = File.combine(path, dirName);
        
        // create the directory list
        List dirList = createSortedList(path, true);
        
        // add the directories (don't add the files)
        addDirsToNode(path, node, dirList);
        return node;
    }

    /**
     * Add a list of directories to the node pointed to by path.
     */
    void addDirsToNode(String path, TreeNode node, List list)
    {
        // iterate through the list of directories
        IEnumerator itemEnumerator = list.getItemEnumerator();
        while (itemEnumerator.hasMoreItems())
        {
            // get the directory name from the list item
            ListItem li = (ListItem)itemEnumerator.nextItem();
            String dirName = li.getText();
 
            // now add a new node with that name; expand the
            // node to include the contents of the directory
            // as well
            node.addNode(expandTreeNode(path, dirName));
        }
    }

    /**
     * Add the list of ListItem objects to listView.
     */
    void addFilesToListView(List list)
    {
        // iterate through the list
        IEnumerator itemEnumerator = list.getItemEnumerator();
        while (itemEnumerator.hasMoreItems())
        {
            // add each file name to the node
            ListItem li = (ListItem)itemEnumerator.nextItem();
            listView.addItem(li);
        }
    }

    /**
     * Create a list of ListItems containing either the
     * names of the directories or the files contained in
     * the directory specified by path.
     */
    static final String[] nullStringArray = new String[]{null, null};
    List createSortedList(String path, boolean wantDirectory)
    {
        List list = new List();
        
        // create a FileEnumerator in order to iterate 
        // through the current path
        FileEnumerator fe = 
                 new FileEnumerator(File.combine(path, &quot;*.*&quot;));
        for(;fe.hasMoreFiles(); fe.getNextFile())
        {
            String fileName = fe.getName();
            
            // ignore the &quot;.&quot; and &quot;..&quot; directories
            if (fileName.equals(&quot;.&quot;) ||
                fileName.equals(&quot;..&quot;))
            {
                continue;
            }

            // ignore those things that we don't want
            if (File.isDirectory(File.combine(path, fileName))
                == wantDirectory)
            {
                // add the entry to the list (we only need
                // the file size and time of last modification
                // for the files, not the directories)
                String[] info = nullStringArray;
                if (wantDirectory == false)
                {
                    // this is a file, get the extra information
                    info = new String[2];
                    info[0] = Long.toString(fe.getSize());
                    Time t  = fe.getLastWriteTime();
                    info[1] = t.toString();
                }
                list.addItem(new ListItem(fileName, -1, info));
            }
        }
        
        // now sort the list
        list.sort(new FileNameComparer());
        
        return list;
    }
 
    /**
     * Implement the IComparer interface to support List.sort().
     */
    class FileNameComparer implements IComparer
    {
        /**
         * Compare o1 to o2; return -1, 0, or 1.
         */
        public int compare(Object o1, Object o2)
        {
            String f1 = ((ListItem)o1).getText();
            String f2 = ((ListItem)o2).getText();

            return StringSorter.compare(f1, f2,
              StringSorter.STRINGSORT | StringSorter.IGNORECASE);
        }
    }

    .
    .
    .

    /**
     * As the form resizes, allocate 1/3 of the horizontal
     * space to the treeView and 2/3 to the listView.
     */
    private void Form1_resize(Object source, Event e)
    {
        // get the size of the form (don't let it get smaller
        // than some minimum)
        Point formSize = getSize();
        if (formSize.x &lt; 100)
        {
            formSize.x = 100;
        }
        
        // divide the width 1/3 vs. 2/3
        int treeWidth = (formSize.x - 30) / 3;
        int listWidth = treeWidth * 2;
        
        // set the treeWidth
        Point treeSize = treeView.getSize();
        treeSize.x = treeWidth;
        treeView.setSize(treeSize);
        
        // now position and size the listView
        // (positioning is necessary because the listView
        // is right justified in the form)
        Point listSize = listView.getSize();
        listSize.x = listWidth;
        listView.setSize(listSize);
        
        Point listLoc = listView.getLocation();
        listLoc.x = treeWidth + 20;
        listView.setLocation(listLoc);        
    }

    /**
     * As the selected tree element changes, update the
     * right side of the display.
     */
    private void treeView_afterSelect(Object source, TreeViewEvent e)
    {
        MyTreeNode tn = (MyTreeNode)treeView.getSelectedNode();
        directory = tn.getFullPath();
        createList();
    }

    /**
     * Begin the drag operation by copying the selected files
     * onto the Clipboard using the &quot;FileName&quot; descriptor.
     */
    TreeNode previousNode = null;
    private void listView_itemDrag(Object source, ItemDragEvent e)
    {
        // save the currently selected node so that we can return
        // there after the drag-and-drop operation is done
        previousNode = treeView.getSelectedNode();
        
        // now get the selected files and store them into a
        // MemoryStream (the way Windows Explorer does it)
        ListItem[] selected = listView.getSelectedItems();
        MemoryStream ms = new MemoryStream();
        for (int i = 0; i &lt; selected.length; i++)
        {
            String fileName = selected[i].getText();
            fileName = File.combine(directory, fileName) + &quot;;&quot;;
            byte[] buffer = fileName.getBytes();
            ms.writeBytes(buffer);
        }

        // store the MemoryStream onto the Clipboard with the
        // type name &quot;FileMgr&quot;
        DataObject dobj = new DataObject(&quot;FileMgr&quot;, ms);
        
        // now perform the drag-and-drop operation
        doDragDrop(dobj, DragDropEffect.COPY);
        
        // clear out the previousNode field
        previousNode = null;
    }

    /**
     * Process the drop operation by reading the FileName
     * entries out and copying them to the selected directory.
     */
    private void treeView_dragDrop(Object source, DragEvent e)
    {
        // read the filenames out of the DragEvent
        IDataObject data = e.data;
        MemoryStream ms = (MemoryStream)data.getData(&quot;FileMgr&quot;);
        byte[] buffer = ms.toByteArray();
        String files = new String(buffer);
        
        // loop through the files passed
        int start = 0;
        int end;
        String targetDirectory = directory;
        while ((end = files.indexOf(&quot;;&quot;, start)) != -1)
        {
            // get the next file
            String file = files.substring(start, end);
            
            // create the destination file name by extracting
            // the file name from the source path and prepending
            // the target directory name
            String dest = File.combine(targetDirectory,
                                       File.getName(file));
            
            // now perform the copy - alert if it fails
            try
            {
                String s = file + &quot;-&gt;&quot; + dest;
                edit.setText(&quot;copying &quot; + s);
                File.copy(file, dest);
                edit.setText(&quot;copied &quot; + s);
        
            }
            catch (Exception ex)
            {
                MessageBox.show(&quot;Copy failed&quot;, &quot;Error&quot;,
                                MessageBox.ICONERROR | 
                                MessageBox.OK);
            }
            
            // return the display to the source node
            if (previousNode != null)
            {
                treeView.setSelectedNode(previousNode);
            }
        
            if (MessageBox.show(&quot;Delete &quot; + file + &quot;?&quot;,
                                &quot;Confirmation&quot;,
                                MessageBox.ICONQUESTION | 
                                MessageBox.YESNO)
                == DialogResult.YES)
            {
                try
                {
                    // File.delete(file);
                    edit.setText(&quot;deleted &quot; + file);
                }
                catch (Exception ex)
                {
                    MessageBox.show(&quot;Delete failed&quot;, &quot;Error&quot;,
                                    MessageBox.ICONERROR | 
                                    MessageBox.OK);
                }
            
                // refresh source directory list
                createList();
            }
 
            // start looking again after the previous &quot;;&quot;
            start = end + 1;
        }
    }

    /**
     * As the mouse drags over a tree node, make the tree node active
     * so the user can see its contents.
     */
    private static Point point = new Point();
    private void treeView_dragOver(Object source, DragEvent e)
    {
        // get the location of the mouse pointer on the screen
        point.x = e.x;
        point.y = e.y;
   
        // now convert this into the location within the
        // treeView object
        point = treeView.pointToClient(point);

        // find the node at that location&#8230;
        TreeNode node = treeView.getNodeAt(point);
        if (node != null)
        {
            // and make it active
            treeView.setSelectedNode(node);
        }
    }

    /**
     * Delete the files selected in the listView.
     */
    private void listView_keyDown(Object source, KeyEvent e)
    {
        if (e.getKeyCode() == Key.DELETE)
        {
            // delete all of the files currently selected
            // in the listView
            ListItem[] list = listView.getSelectedItems();
            for (int i = 0; i &lt; list.length; i++)
            {
                String fileName = list[i].getText();
                fileName = File.combine(directory, fileName);
                edit.setText(&quot;deleting &quot; + fileName);
                // File.delete(fileName);
                edit.setText(&quot;deleted &quot; + fileName);
            }
            
            // refresh the listView
            createList();
        }
    }

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
    Container components = new Container();
    TreeView treeView = new TreeView();
    ListView listView = new ListView();
    ColumnHeader columnHeader1 = new ColumnHeader();
    ColumnHeader columnHeader2 = new ColumnHeader();
    ColumnHeader columnHeader3 = new ColumnHeader();
    Edit edit = new Edit();
    ImageList imageList = new ImageList();

    private void initForm()
    {
        // &#8230;generated by the Forms Designer&#8230;
    }

    /**
     * The main entry point for the application. 
     *
     * @param args Array of parameters passed to the application
     * via the command line.
     */
    public static void main(String args[])
    {
        Application.run(new Form1(args));
    }
}

class MyTreeNode extends TreeNode
{
    String path;
    
    MyTreeNode(String name, String path)
    {
        super(name);
        this.path = File.combine(path, name);
    }
    
    String getPath()
    {
        return path;
    }
}
</PRE>

<p>As you might have expected, the first part of FileMgr looks like a 
combination of the code for ListViewDemo and TreeViewDemo. The 
<I>Form1()</I> constructor starts by calling 
<I>initForm()</I>. It then initializes the 
<I>directory</I> string variable, which contains a reference to the current directory, returned from 
<I>File.getCurrentDirectory()</I>, or the argument passed to the program if there is one. (As always, supporting the 
single argument is primarily to support someone dragging a directory onto the program. 
I don't really expect anyone to type in a directory path when executing the 
program from the command line of an MS-DOS box.) The 
<I>Form1()</I> constructor then populates the tree view by calling 
<I>addNode()</I> and passing it the base directory, and 
populates the list view by calling 
<I>createList()</I>.

<P>These first few functions work more or less the same as their cousins 
shown earlier in this chapter. I did convert 
<I>createSortedList()</I> back to creating a single list 
of either the directories or the files in a directory and not both. This is because the 
tree view needs the directories and the list view needs the files, but neither needs 
both. Generating a list of both directories and files seemed to slow down the 
population of the tree view unnecessarily.

<P>Notice also that <I>createSortedList()</I> creates a list of 
<I>ListItem</I> objects since this is what the list view requires. In the case of the tree view, 
<I>addFilesToNode()</I> doesn't use the 
<I>ListItem</I> objects other than to call 
<I>ListItem.getText()</I> to retrieve the file 
name of each list item.

<A NAME="257"><H3>Resizing the two views dynamically</H3></A>

<p>Starting with <I>Form1_resize(),</I> we run into all new code. The anchoring 
mechanism built into WFC is great at handling the resizing of objects within a form as the 
user resizes the form, but it can't handle all circumstances under which objects need 
to be resized. In particular, I wanted the tree view to always occupy the left third of 
the form and the list view to occupy the right two-thirds. To maintain this ratio, I had 
to write my own function<I>. </I>Notice that I am only concerned with the horizontal 
sizing; WFC can handle the vertical resizing of the two views just fine.

<P>Using the Properties window of the Forms Designer, I attached 
<I>Form1_resize() </I>to the resize event of 
<I>Form1</I>. This event occurs repeatedly as the form is 
resized. <I>Form1_resize()</I> begins by asking the form exactly how large it is. The function 
then makes sure that the horizontal size of the function is not less than 100. This sets 
the minimum width of the application to 100 pixels&#8212;anything less than that and 
you really can't see either the tree view elements or the list view elements.

<P>Once the minimum has been established, 
<I>Form1_resize()</I> calculates the width of the tree view and of the list view, assigning the results to the variables 
<I>treeWidth</I> and <I>listWidth</I>.<I> </I>The widths are calculated by taking one-third and two-thirds of 
the form width minus 30. The function subtracts 30 from the form width because it 
knows that there is a 10-pixel-wide border on both the left and right side of the form 
plus it intends to put a similar 10-pixel border between the two lists.

<P>Setting the width of the <I>treeView</I> object is merely a matter of asking the 
<I>treeView</I> object how big it is now, and then replacing the current width with the 
calculated width.

<P>Setting the width of the <I>listView</I> object is a little more complicated, because 
in addition to setting its width, 
<I>Form1_resize()</I> must position the <I>listView 
</I>object 10 pixels to the right of the right border of the 
<I>treeView</I> object. The extra 10 pixels are to maintain a 10-pixel border between the two views.

<A NAME="258"><H3>Updating the file list dynamically</H3></A>

<p>I created the <I>treeView_afterSelect()</I> method to handle the 
<I>afterSelect</I> event of the <I>treeView</I> object. This event occurs when the user selects a new node in the tree 
view hierarchy. The &quot;after&quot; in the event name comes into play because this method 
is invoked after WFC has updated the display to reflect the selection.

<P>The <I>treeView_afterSelect() </I>method asks the 
<I>treeView</I> which node is selected by calling 
<I>getSelectedNode()</I>. You'll notice that I've coded 
<I>treeView_afterSelect() </I>to 
convert the <I>TreeNode</I> object returned from 
<I>getSelectedNode()</I> into something called 
<I>MyTreeNode</I> before using it.

<A NAME="259"><h3>What is <I>MyTreeNode</I>?</h3></A>
<p>Just as the <I>ListView</I> class is normally populated by 
<I>ListItem</I> objects, so the <I>TreeView</I> class is populated by objects of class 
<I>TreeNode</I>. It is the text associated with 
the <I>TreeNode</I> that is displayed in the tree view. The problem is that the 
<I>TreeNode</I> object contains only the name of the directory. When the user selects a 
<I>TreeNode</I>, however, we need the entire path to that directory in order to know how to display the 
contents of that directory in the list view on the right.

<P>One solution to this problem would be to store the entire path in the 
<I>TreeNode</I> object before we attach it to the 
<I>TreeView </I>object. This is not satisfactory, 
however, because doing so would cause the 
<I>TreeView</I> object to display this path 
information on every node. Such information would be annoying because it would be 
redundant. The path to a particular directory is made obvious by the tree view display itself.

<P>A better solution is to create our own class that extends 
<I>TreeNode</I> by storing the path information that we need. The class 
<I>MyTreeNode,</I> defined at the bottom of the Form1.java file, adds a data member 
<I>path</I> and a method <I>getPath()</I> that 
returns the path information to the base 
<I>TreeNode</I> class. In every other respect, 
<I>MyTreeNode</I> is a <I>TreeNode</I>, so it has the ability to be attached to a 
<I>TreeView</I>.

<P>This class creation is an important trick to remember.

<div class="tip"><blockquote><b>TIP</b><hr>
It is perfectly legal to extend a WFC class to add your own data 
members or methods and then use that class in place of the base class.
</blockquote></div>

<p>As the tree nodes are being constructed, 
<I>Form1.expandTreeNode()</I> adds 
<I>MyTreeNode</I> objects containing both the directory name and the path to that directory to 
the tree view. Thus, when the user selects a node he or she is actually selecting an 
object of class <I>MyTreeNode</I>. (Remember that because 
<I>MyTreeNode</I> extends the class 
<I>TreeNode</I>, an object of class 
<I>MyTreeNode</I> is also of class <I>TreeNode</I>.) The 
method <I>treeView_afterSelect()</I> calls the method 
<I>getSelectedNode()</I> which returns a 
<I>TreeNode </I>class; however, since the objects returned are the same 
<I>MyTreeNode</I> objects we added earlier, 
<I>treeView_afterSelect()</I> can convert the node back into a 
<I>MyTreeNode. </I>In this way, 
<I>treeView_afterSelect()</I> can retrieve the path information stored in the 
object previously. It can use the path information to create the list
view file display.

<A NAME="260"><H3>Handling drag-and-drop</H3></A>

<p>The next three methods in 
FileMgr&#8212;<I>listView_itemDrag()</I>, 
<I>treeView_dragDrop()</I>, and 
<I>treeView_dragOver()</I>&#8212;support the dragging of files from
the list view to a directory in the tree view<I>. </I>(FileMgr does not
support the dragging of directories.)

<P>I used the Properties window to attach 
<I>listView_itemDrag()</I> to the <I>itemDrag</I> event of the ListView control. This event occurs when the user selects one or 
more files in the list view and then begins moving the mouse with the left mouse 
button held down, thereby initiating the drag operation. You saw how to implement a 
drop method in <A HREF="ch06a.htm">Chapter 6</A> with the RTFEditor application by calling 
<I>getData()</I> with the data object passed in the 
<I>DragEvent</I> object to return an array of 
<I>String</I> objects. The 
<I>listView_itemDrag()</I> method in effect reverses that process. First, 
<I>listView_itemDrag()</I> fetches a list of the items currently selected in the list view by calling 
<I>getSelectedItems()</I>. It then creates a 
<I>MemoryStream</I> object to which it writes the full path name of 
each file followed by a semicolon to act as a file name terminator.

<div class="note"><blockquote><b>NOTE</b><hr>
Remember, the <I>MemoryStream</I> class in Visual 
J++ is equivalent to the <I>strstream </I>class in 
C++; they are both memory buffers that act like files.</blockquote></div>


<p>Once all the file names have been written to the buffer, a 
<I>DataObject</I> object of type FileMgr is created to contain the 
<I>MemoryStream </I>object. The <I>DataObject</I> is 
then passed to the function <I>doDragDrop(),</I> which initiates the drag operation.

<P>It is the method <I>doDragDrop()</I> that changes the cursor to indicate to the 
user that a drag-and-drop operation is in process. Control does not return from the 
<I>doDragDrop()</I> call until the user has released the left mouse button.

<P>Similarly, I used the Properties window to assign the 
<I>treeView_dragDrop()</I> method to handle the 
<I>dragDrop</I> event of the tree view. This event occurs when 
the user lets go of the left mouse button to &quot;drop&quot; the dragged files. The 
<I>treeView_dragDrop()</I> method is similar to the 
<I>dragDrop()</I> method in <A HREF="ch06a.htm">Chapter 6</A>. The 
<I>treeView_dragDrop()</I> method first gets the 
<I>DataObject</I> object out of the 
<I>DragEvent</I> event passed to it. It then gets the FileMgr memory stream from which it begins 
reading file names under the assumption that the file names are terminated with a 
semicolon. Each file is then copied to the currently selected directory using the 
<I>File.copy()</I> method. Once the file has been successfully copied, 
<I>treeView_dragDrop() </I>displays a message box giving the user the option of deleting the source file. Whether the 
file is deleted or not, the source directory is redisplayed in the list view to show the 
user any changes.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
The delete operation has been commented out so you don't 
inadvertently delete important files. If you would like to enable this feature, 
uncomment the call to <I>File.delete()</I>.
</blockquote></div>

<p>The final key function to the drag-and-drop operation is the 
<I>treeView_dragOver()</I> method. I used the Properties window to assign this method to handle the 
<I>dragOver</I> event of the TreeView control. The 
<I>dragOver</I> event occurs repeatedly as the 
user moves the mouse within the tree view during a drag operation. Contained within 
the <I>DragEvent</I> passed to 
<I>treeView_dragOver()</I> are the screen coordinates of the 
mouse as it moves. For our purposes, we would like the program to use these 
coordinates to highlight which tree node the mouse is pointing at. That way, the user has 
positive feedback as to which node she is about to drop the file(s) on.

<P>The mouse coordinates contained in the 
<I>DragEvent</I> object are relative to the upper-left corner of the screen. Before 
<I>treeView_dragOver()</I> can use them, it must call 
<I>treeView.pointToClient()</I> to transform the screen-relative mouse coordinates 
to coordinates relative to the tree view. (This transformation involves subtracting 
the coordinates of the upper left-hand corner of the frame within the screen and 
then subtracting the location of the tree view within the frame.) The 
<I>treeView_dragOver()</I> method then calls 
<I>getNodeAt()</I>, passing the transformed mouse coordinates, to 
find out which tree node the user is pointing at with the mouse. If the user is 
not pointing at a tree node, <I>getNodeAt()</I> returns a 
<I>null</I>. If <I>getNodeAt()</I> returns a 
<I>null</I>, <I>treeView_dragOver()</I> returns without taking any action. However, if 
<I>getNodeAt()</I> does return a tree node, 
<I>treeView_dragOver()</I> makes this the selected node by 
calling <I>setSelectedNode()</I>. This method will highlight the node, change its image from 
the closed folder to the open folder, and update the ListView control to display the 
files in the directory corresponding to that node.

<A NAME="261"><H3>Handling the Delete key</H3></A>

<p>To complete the FileMgr capabilities, I added one further feature. If the user 
presses the Delete key with the mouse pointer in the list view, FileMgr will delete any 
files selected. I did this both because I felt that the application needed such a 
function and to demonstrate the handling of key events.

<P>To implement this functionality, use the Properties window to define 
the <I>listView_keyDown()</I> method to handle the event that occurs when the user 
presses a key. Since this method is attached to the ListView control, this event will only 
be passed to the list view if the mouse pointer is somewhere within the list view's 
display area.

<P>The <I>KeyEvent</I> object passed to 
<I>listView_keyDown()</I> includes several data 
fields of interest, including the <I>keyData</I> field, which contains the ANSI equivalent of 
the key that was pressed. For example, 
<I>keyData</I> contains an &quot;a&quot; when the A key is 
pressed. However, the <I>keyDown</I> event also occurs for keys that have no ANSI equivalent, 
such as the Shift key or the Control key. The Delete key falls into this category.

<P>For these keys, the programmer must rely on the key code. The key code is 
a unique number assigned to each key on the PC keyboard. (Actually, it's 
semi-unique, if that's a word, since if your keyboard has two Delete keys, as most do, then 
both will have the same key code.) Rather than memorize these key codes, 
programmers should used the enumeration class 
<I>Key</I> which contains constants representing a complete list of all of the key codes, including those for ANSI character keys like 
the A key.
<P>The member <I>Key.DELETE</I> refers to the key code for the Delete key. Our 
implementation of the <I>listView_keyDown()</I> method ignores any key besides the Delete 
key. Once the Delete key is detected, the function iterates through the selected files 
in the list view and deletes them using the 
<I>File.delete()</I> function.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
Once again, this function has been commented out to avoid 
accidental deletion of critical files. If you want to enable this feature, uncomment the 
call to <I>File.delete()</I>.
</blockquote></div>

<A NAME="262"><H3>The completed program</H3></A>

<p>Figure 8-9 shows the complete program displaying my \temp directory. You can 
see the file structure displayed on the left. Most of the folders are displayed with the 
closed folder icon; however, the currently selected folder, EyeControl, is displayed with 
the open folder icon. The display on the right shows the contents of that folder. The 
edit box at the bottom of the applications shows that I have just copied the 
Form1.java file from \temp\EyeControl to \temp.
 
<P><A HREF="javascript:fullSize('F08gh09x.htm')"> <img src="images/F08gh09.JPG" width=404 height=271 border=0 ALT="Click to view at full size."> </A> 
<p><!-- caption --><B>Figure 8-9.</b> <i>The completed FileMgr program displaying the contents of my 
\temp directory.</I><!-- caption -->

<A NAME="263"><h3>Why use the <I>IEnumerator </I>interface?</h3></A>
<p>Back in <I>addDirsToNode() </I>and 
<I>addFilesToListView()</I> you might have noticed the 
use of the <I>IEnumerator</I> interface, whereas in programs in previous chapters (such 
as ComboBox1 in <A HREF="ch06a.htm">Chapter 6</A>) I simply called 
<I>list.getItems()</I> to return an array of the objects contained within the list and then manipulated that list. The use of 
<I>IEnumerator</I> in the examples in this chapter has been primarily for educational 
purposes, but it has certain advantages.

<P>The fact that the <I>List.getItems()</I> call returns an array of objects leads one 
to believe that a <I>List</I> is implemented as an array. This might be, but is not 
necessarily the case. Suppose I created a list class that maintained its contents in a linked list 
or a push down stack or any number of other possible data structures. It might be a 
slow process to create an array of references to these objects. Thus, while the 
<I>getItems()</I> function returns a data structure that is convenient for the programmer to use 
(an array), it might not be convenient for the list class to generate.

<P>The <I>IEnumerator</I> interface is completely generic. It makes few 
assumptions about the underlying data structure of the list. Whether an array, a linked list, or 
a push down stack, the programmer of the list class should be able to generate 
an efficient enumeration class which implements the three methods required 
by <I>IEnumerator</I>:
<UL>
<P><LI><I>hasMoreItems()</I>&#8212;determines whether the program has reached the 
end of the list.
<P><LI><I>nextItem()</I>&#8212;retrieves the current object and moves to the next object.
<P><LI><I>reset()</I>&#8212;starts over from the beginning of the list.
</UL>

<p>Thus, while using <I>IEnumerator</I> might not be quite as convenient for the 
application programmer, it allows the library programmer the flexibility to implement 
the underlying list in the most efficient means possible.

</BODY>
</HTML>




