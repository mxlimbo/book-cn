<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>Buttons</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06a.htm", "ch06c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="183"><H1>Buttons</H1></A>

<p>The simplest input controls of all are buttons. There are three types of buttons: the simple button, the radio button, and the check box. The following ButtonDemo applications demonstrate all three button types.

<A NAME="184"><H2>Reading Button Values</H2></A>

<p>The ButtonDemo1 program, whose code is shown later in this chapter, outputs a single test string in one of three different fonts. In addition, the test string can be formatted as boldface or italic. These settings are controlled using buttons of different types.

<p>Since the choice of font is mutually exclusive, I chose to set the font using a set of three radio buttons. The boldface and italic properties are independent, so I chose to use a separate check box for each of these options. A Submit button at the bottom causes the button settings to take effect. An edit box across the top of the window displays a test string in the selected font type and format.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
Use check boxes to set properties that are both binary (&quot;on&quot; or &quot;off&quot;) and independent of each other. Use radio buttons to set properties that are mutually exclusive. Use a regular push button to take some action.
</blockquote></div>

<A NAME="185"><H3>The Forms Designer work</H3></A>

<p>To begin, create the button demonstration application using the Windows Application builder. (Choose New Project from the File menu. The default project type is Windows Application.) Give this first version of the program the name ButtonDemo1. Open the Project Explorer window and double-click on Form1.java to bring up the Forms Designer. From this point, start dragging objects from the Toolbox to the Forms Designer. Figure 6-1 shows the Forms Designer and the Properties window for one of the buttons during the later stages of developing the ButtonDemo1 application.

<p>The check boxes are straightforward to create. Select the CheckBox tool in the Toolbox, and place it in the Forms Designer. Once you've placed the check box, just start typing the label; the Forms Designer will automatically update the check box's <I>text</I> property in the Properties window. I also chose to change the name by editing the <I>name</I> property in the Properties window. It's a good idea to use names that are a combination of the button label and the button type. Thus, <I>checkBox1</I> becomes <I>boldCheckBox</I> and <I>checkBox2</I> becomes <I>italicsCheckBox</I>.

<p>For the radio buttons, you will first need to build a group box. A group box groups radio buttons both visually and logically. The group box groups radio buttons visually by placing a small box around them. It groups the radio buttons logically in that the radio buttons contained within a group box are mutually exclusive: choosing one radio button causes all other radio buttons in the same group box to not be chosen.

<p>Select the GroupBox control in the Toolbox and drag it to the Forms Designer. Now resize the group box to be large enough to hold three radio buttons and their labels.

<p><A HREF="javascript:fullSize('f06gh01x.htm')"> <img src="images/f06gh01.jpg" width=404 height=241 border=0 ALT="Click to view at full size."> </A>
<p><!-- caption --><b>Figure 6-1.</b> <i>The ButtonDemo1 application in the Forms Designer during the final stages of construction.</I><!-- /caption -->

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
When initially placing objects in the Forms Designer, don't worry too much about their exact dimensions. You can always resize things once you get all the objects in place on the form. In addition, there are two ways to place any control in a form: you can either drag the control from the Toolbox and drop it on the form, or you can click the control and then click within the form. There is no difference.
</blockquote></div>

<p>Once the group box is in place, you can begin adding radio button controls. For this application, you will need three radio buttons, each titled with the name of a font. Making sure that the radio boxes are properly aligned is easy when you have the Snap To Grid feature of the Forms Designer enabled. You will also need to set one of the radio buttons to be initially chosen&#8212;by default, radio buttons are not chosen.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
Users are accustomed to seeing one (and only one) radio button in a set selected at all times. Starting the application with none selected is confusing.
</blockquote></div>

<p>I selected the first radio button, the Courier button, to be initially chosen by setting the <I>checked</I> property to <I>true</I> in the Properties window, as shown in Figure 6-1.

<p>An Edit control across the top and a Submit button near the bottom finishes the design of the ButtonDemo1 application's form.

<A NAME="186"><H3>The code</H3></A>

<p>After adding functionality, the code for the ButtonDemo1 application is as follows:

<p><pre>
import com.ms.wfc.app.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;
import com.ms.wfc.html.*;

/**
 * This class demonstrates the different button types.
 */
public class Form1 extends Form
{
    public Form1()
    {
        // Required for Visual J++ Form Designer support
        initForm();

        // at startup act like the Submit button has been
        // pushed; this will create the initial font and
        // update the outputEdit field with the test message
        submitButton_click(null, null);
    }

    /**
     * Form1 overrides dispose so it can clean up the
     * component list.
     */
    public void dispose()
    {
        super.dispose();
        components.dispose();
    }

    /**
     * Handle the Submit button by reading the button settings,
     * creating a font to match, and then updating the
     * text in the outputEdit object with that font.
     */
    private void submitButton_click(Object source, Event e)
    {
        // create a font based on the button settings
        // first; read the check boxes
        boolean bold = boldCheckBox.getChecked();
        boolean italics = italicsCheckBox.getChecked();
        
        // convert the weight check box into an integer
        // by choosing the appropriate weight from the list
        // of possibilities
        int weight = bold ? FontWeight.BOLD : FontWeight.NORMAL;
        
        // now find which radio button is selected; get a
        // list of all the radio buttons attached to the
        // Font group box, and loop through to see which one is
        // checked
        String fontName = null;
        Control[] control = fontGroupBox.getControls();
        for (int i = 0; i &lt; control.length; i++)
        {
            // if this radio button is checked&#8230;
            RadioButton rb = (RadioButton)control[i];
            if (rb.getChecked())
            {
                // then use the name on the button as
                // the font name
                fontName = rb.getText();
            }
        }

        // create a font with the data
        Font font = new Font(fontName, 14, FontSize.POINTS,
                             weight, italics, false, false);
        
        // now update the outputEdit field with the font
        outputEdit.setText(&quot;This is a test string.&quot;);
        outputEdit.setFont(font);   
    }

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
    Container components = new Container();
    Edit outputEdit = new Edit();
    CheckBox boldCheckBox = new CheckBox();
    CheckBox italicsCheckBox = new CheckBox();
    GroupBox fontGroupBox = new GroupBox();
    RadioButton courierRadioButton = new RadioButton();
    RadioButton arialRadioButton = new RadioButton();
    RadioButton haettenschweillerRadioButton = new RadioButton();
    Button submitButton = new Button();

    private void initForm()
    {
        this.setText(&quot;Button Demo&quot;);
        this.setAutoScaleBaseSize(new Point(5, 13));
        this.setClientSize(new Point(245, 184));

        outputEdit.setLocation(new Point(20, 10));
        outputEdit.setSize(new Point(200, 20));
        outputEdit.setTabIndex(0);
        outputEdit.setText(&quot;&quot;);
        outputEdit.setReadOnly(true);

        boldCheckBox.setLocation(new Point(20, 50));
        boldCheckBox.setSize(new Point(50, 25));
        boldCheckBox.setTabIndex(1);
        boldCheckBox.setText(&quot;Bold&quot;);

        italicsCheckBox.setLocation(new Point(20, 80));
        italicsCheckBox.setSize(new Point(50, 25));
        italicsCheckBox.setTabIndex(2);
        italicsCheckBox.setText(&quot;Italics&quot;);

        fontGroupBox.setLocation(new Point(90, 40));
        fontGroupBox.setSize(new Point(130, 90));
        fontGroupBox.setTabIndex(3);
        fontGroupBox.setTabStop(false);
        fontGroupBox.setText(&quot;Font&quot;);

        courierRadioButton.setLocation(new Point(10, 20));
        courierRadioButton.setSize(new Point(100, 25));
        courierRadioButton.setTabIndex(0);
        courierRadioButton.setTabStop(true);
        courierRadioButton.setText(&quot;Courier&quot;);
        courierRadioButton.setChecked(true);

        arialRadioButton.setLocation(new Point(10, 40));
        arialRadioButton.setSize(new Point(100, 25));
        arialRadioButton.setTabIndex(1);
        arialRadioButton.setText(&quot;Arial&quot;);

        haettenschweillerRadioButton.setLocation(new Point(10, 60));
        haettenschweillerRadioButton.setSize(new Point(110, 25));
        haettenschweillerRadioButton.setTabIndex(2);
        haettenschweillerRadioButton.setText(&quot;Haettenschweiller&quot;);

        submitButton.setLocation(new Point(80, 150));
        submitButton.setSize(new Point(75, 23));
        submitButton.setTabIndex(4);
        submitButton.setText(&quot;Submit&quot;);
        submitButton.addOnClick(
                       new EventHandler(this.submitButton_click));

        this.setNewControls(new Control[] {
                            submitButton, 
                            fontGroupBox, 
                            italicsCheckBox, 
                            boldCheckBox, 
                            outputEdit});
        fontGroupBox.setNewControls(new Control[] {
                                    haettenschweillerRadioButton,
                                    arialRadioButton, 
                                    courierRadioButton});
    }

    /**
     * The main entry point for the application. 
     *
     * @param args Array of parameters passed to the application
     * via the command line.
     */
    public static void main(String args[])
    {
        Application.run(new Form1());
    }
}
</PRE>

<p>As always, the <I>initForm()</I> method is created automatically by the Forms Designer. In one way, this <I>initForm()</I> method is different from the versions we have seen so far:<I> </I>it contains a hierarchy of objects. Instead of adding the radio buttons to the form, this <I>initForm()</I> adds them to the <I>fontGroupBox</I> object. The <I>fontGroupBox</I> object is then added to the form.

<p>Grouping the radio buttons in the <I>fontGroupBox</I> container is what makes the radio buttons mutually exclusive. This also enables us to read the radio button values out of the container, as you will see later.

<p>Double-clicking the Submit button in the Forms Designer created and registered the <I>submitButton_click()</I> method, and then I manually added the functionality for the button to the method. This method first reads the two check boxes <I>boldCheckBox</I> and <I>italicsCheckBox</I>. The Boolean <I>bold</I> value is then turned into an integer font <I>weight</I> value by using the enumerated class <I>FontWeight.</I>

<p>To determine which font radio button is selected, <I>submitButton_click()</I> loops through the radio buttons contained in the <I>fontGroupBox</I> container. It does this by first calling the <I>fontGroupBox.getControls() </I>function. This function returns an array containing references to the objects contained within the <I>fontGroupBox </I>object. Since we didn't add anything but radio buttons to the group box, all of these <I>Control</I> objects are of type <I>RadioButton</I>. As soon as the loop finds a button whose <I>getChecked()</I> method returns <I>true</I>, the function reads the name of the button by calling <I>getText()</I>. The name of the button is the name of the font we want to be applied.

<p>Armed with this information, <I>submitButton_click()</I> creates a <I>Font</I> object. It then applies the font and font format to the text in the <I>outputEdit</I> Edit control. An example of output from this program is shown in Figure 6-2.

<p><img src="images/f06gh02.jpg" width=253 height=211 border="0">
<p><!-- caption --><B>Figure 6-2.</b> <i>Output from ButtonDemo1 showing a particularly attractive 
font selection.</I><!-- /caption -->

<A NAME="187"><H2>Handling Button Updates Automatically</H2></A>

<p>In many applications, you would like the button settings to take effect immediately rather than after the user clicks on a submit button of some type. The ButtonDemo2 application beginning below updates the ButtonDemo1 functionality so that clicking any of the check boxes or radio buttons causes the displayed text to be updated immediately. Accordingly, the Submit button has been removed. Note that the <I>initForm()</I> function isn't included in the following code but is present in the code contained on the companion CD.

<p><pre>
import com.ms.wfc.app.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;
import com.ms.wfc.html.*;

/**
 * This class demonstrates the different button types.
 */
public class Form1 extends Form
{
    // maintain the state of the object
    boolean italics;
    boolean bold;
    String  fontName = &quot;Courier&quot;;
    
    public Form1()
    {
        // Required for Visual J++ Form Designer support
        initForm();

        // update the output to display the initial state
        updateState();
    }

    /**
     * Form1 overrides dispose so it can clean up the
     * component list.
     */
    public void dispose()
    {
        super.dispose();
        components.dispose();
    }

    /**
     * Update the output edit field to reflect the current
     * state.
     */
    private void updateState()
    {
        // convert the weight into an integer
        // by choosing the appropriate weight
        // from the list of possibilities
        int weight = bold ? FontWeight.BOLD : FontWeight.NORMAL;
        
        // create a font from the current state
        Font font = new Font(fontName, 14, FontSize.POINTS,
                             weight, italics, false, false);
        
        // now update the outputEdit field with the font
        outputEdit.setText(&quot;This is a test string.&quot;);
        outputEdit.setFont(font);   
    }

    private void boldCheckBox_click(Object source, Event e)
    {
        CheckBox cb = (CheckBox)source;
        bold = cb.getChecked();
        updateState();
    }

    private void italicsCheckBox_click(Object source, Event e)
    {
        CheckBox cb = (CheckBox)source;
        italics = cb.getChecked();
        updateState();
    }

    private void radioButton_checkedChanged(Object source, Event e)
    {
        RadioButton rb = (RadioButton)source;
        if (rb.getChecked())
        {
            fontName = rb.getText();
        }
        updateState();
    }

    /**
     * NOTE: The following code is required by the Visual J++ form
     * designer.  It can be modified using the form editor.  Do not
     * modify it using the code editor.
     */
    Container components = new Container();
    Edit outputEdit = new Edit();
    CheckBox boldCheckBox = new CheckBox();
    CheckBox italicsCheckBox = new CheckBox();
    GroupBox fontGroupBox = new GroupBox();
    RadioButton courierRadioButton = new RadioButton();
    RadioButton arialRadioButton = new RadioButton();
    RadioButton haettenschweillerRadioButton = new RadioButton();

    private void initForm()
    {
        // &#8230;created by Forms Designer&#8230;
    }

    /**
     * The main entry point for the application. 
     * &#8230;
     */
    public static void main(String args[])
    {
        Application.run(new Form1());
    }
}
</PRE>

<p>This version contains several data members that represent the state of the object. The variable <I>italics</I> is <I>true</I> when the font is to be italicized. Similarly, the variables <I>bold</I> and <I>fontName</I> represent further font state information.

<p>The event handler that previously handled the Submit button is now somewhat simplified because it no longer reads the button settings directly. In addition, I renamed the handler to <I>updateState()</I>. The <I>updateState()</I> method updates the output edit text to reflect the current state of the form object as stored in its data members.

<p>The event handlers such as <I>boldCheckBox_click()</I> and <I>italicsCheckBox_click()</I> are called when the user selects or clears the check box. These methods update the state of the object by updating the appropriate data member and then invoking <I>updateState()</I> to reflect the new state information in the output text.

<A NAME="188"><H3>Using the active properties page of the Properties window</H3></A>

<p>The same approach of using one method per button could have been applied to the radio buttons as well; however, a large number of radio buttons can result in a lot of very small event handler functions. As a demonstration of another approach, I included in ButtonDemo2 the function <I>radioButton_checkedChanged()</I> to handle a change in state of any of the radio buttons. To use a common function to handle multiple buttons, you can't use the simpler double-click method to establish the event handler. Double-clicking a button causes the Forms Designer to create a unique handler for that button.

<p>To establish an existing function as an event handler or to establish an event handler for an object other than the object's default event, you must use the active properties page of the Properties window. Open the Properties window, and click the object to make the properties of the object visible. Now click the Events button (with the lightning bolt symbol) at the top of the Properties window. This switches the Properties window display to show the events this object receives. These are the active properties of the object, as opposed to the passive data properties of the object we have been viewing up until now.

<p>For the previous example, I chose to attach my <I>radioButton_checkedChanged()</I> method to the <I>checkedChanged</I> event of each of the radio buttons. This event occurs whenever the selection state of the button changes&#8212;that is to say, when a button goes from checked to unchecked or the other way around. To attach the method to the event, click the <I>checkedChanged</I> event property and click on the arrow in the property setting box. This displays all of the methods in Form1.java that have the proper prototype to handle the <I>checkedChanged</I> event&#8212;that is, all methods that return a <I>void</I> and take an <I>Object</I> and an <I>Event</I> as arguments. I selected my <I>radioButton_checkedChanged()</I> method from the drop-down list, as shown in Figure 6-3. This list also includes the event handlers for the bold and italics buttons, since their prototypes also match the requirements for the <I>checkedChanged</I> event. If you have yet to write the method you want to attach to the button, you can alternatively type what will be the function name into the property setting box.

<p><img src="images/f06gh03.jpg" width=351 height=427 border="0">
<p><!-- caption --><B>Figure 6-3.</b> <i>The Properties window showing the active properties of the object&#8212;the events that object receives.</I><!-- /caption -->

<p>The <I>radioButton_checkedChanged()</I> method is only slightly more complicated than its check box equivalents. The <I>checkedChanged</I> event occurs when the radio button is being checked either on or off. This would be important if we were saving the state of the radio buttons as a set of Boolean variables. However, since we are only saving the name of the currently checked radio button we want to ignore the event triggered on the radio button as it goes from on to off; hence the <I>rb.getChecked()</I> test at the beginning of the <I>radioButton_checkedChanged()</I> method.

<p>The output from ButtonDemo2 appears identical to its predecessor except for the absence of the Submit button.

<A NAME="189"><H3>The state approach to handling events</H3></A>

<p>The state event-handling approach used by ButtonDemo2 is common: record the states of the buttons and menu selections within data members of the object and then use a single <I>updateState()</I> method to output that state information. This approach has the following advantages:

<UL>
<p><LI> It divides the input code (the event handlers) from the output code (the <I>updateState()</I> method), which makes code easier to understand and maintain.

<p><LI> It results in a smaller program since it avoids duplication of the output code in each of the handlers.

<p><LI> It leaves the state of the object recorded so that other functions can refer to this information easily without having to read the buttons and menu options by name.
</UL>

</BODY>
</HTML>




