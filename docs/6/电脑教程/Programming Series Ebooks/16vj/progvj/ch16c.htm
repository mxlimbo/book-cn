<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>Client-Side DHTML</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch16b.htm", "ch16d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="553"><H1>Client-Side DHTML</H1></A>

<p>Client-side use of the <I>wfc.html</I> package provides the Java programmer with significant capabilities, such as the ability to manipulate HTML objects. While the code for client-side applications is similar to that of a WFC applet, the results look and feel like conventional HTML rather than like applet output.

<p>This power comes at a price. The <I>html</I> package can be accessed on the client side only by Microsoft Internet Explorer version 4 or later. This means that HTML pages that utilize the <I>html</I> package on the client side can't run on the Internet unless you can limit access to Internet Explorer 4 users.

<p>Thus, a company might apply client-side DHTML for intranet pages used by its sales force, because the company can control which Web browsers are used. In such a situation, client-side DHTML can also provide a significant increase in performance for intranet sites. For Internet sites, however, accessing the <I>html</I> package from the client side isn't practical.

<p>Client-side DHTML is most easily explained by example. The following SimpleClientSide example application demonstrates the principles of the <I>html</I> package. Following that is a more involved example demonstrating access to a client database.

<A NAME="554"><H2>The SimpleClientSide Application</H2></A>

<p>The SimpleClientSide example application modifies two fields on an existing HTML page while adding two more. The application also demonstrates the user interaction capability for both the existing objects and the added objects.

<A NAME="555"><H3>The HTML editor work</H3></A>

<p>From within the Visual J++ 6 environment, choose New Project from the File menu. In the New Project window, select Web Pages from the Visual J++ Projects folder. Now choose Code-behind HTML. Provide the name <I>SimpleClientSide</I> as the project name within a DHTML directory, and choose Open.

<p>From within Project Explorer, open the Page1.htm file. The HTML editor opens in Design mode. In this mode, you can edit the HTML page visually. This initial HTML page display contains a warning that only the Microsoft Virtual Machine for Java beyond a certain version can display client-side DHTML, followed by the string &quot;This is bound text.&quot;

<p>Switch the HTML editor into Source mode. In this mode, the editor displays the underlying HTML code. The &lt;BODY&gt; section of our initial HTML file is broken 
into three parts. The first part contains the version warning, bracketed between &lt;HR&gt; tags. Delete this part. Retain the second part that begins with the &lt;OBJECT&gt; tag, and retain the final part that begins with the HTML comment &lt;!-- Insert HTML here --&gt;.

<p>Return the HTML editor to Design mode, to update the HTML file with your edits. (This time, only the sentence &quot;This is bound text.&quot; should be displayed.) Select 
the HTML section of the Toolbox. You'll see that all of the HTML tools are enabled. Drag a Line Break control to the editor, and drop it immediately underneath the existing string. (Direct positioning of controls isn't supported by DHTML. The HTML editor does support a special mode called Absolute mode, in which objects can be placed anywhere within the display window by means of a special COM object. In Absolute mode, however, client-side DHTML isn't supported.)

<p>Now drag a Button control to the HTML editor below the Line Break control. With the Button still selected, open the Properties window. Change the <I>value</I> property of the Button control to <I>Change Bound Text</I>.

<p>Finally, drag a Paragraph Break control to the right of the Button or underneath the Button, to provide extra space following the button and any subsequent objects.

<p>Now switch the HTML editor back to Source mode, and if the space command (<I>&amp;nbsp</I>) is present, delete it. The resulting source code should appear as follows (I have edited this section slightly so that it fits on the book page):

<p><pre>
&lt;!-- Insert HTML here --&gt;
&lt;SPAN id=&quot;bindText&quot;&gt;This is bound text.&lt;/SPAN&gt;
&lt;BR&gt;
&lt;INPUT id=button1 name=&quot;button1&quot; type=button value=&quot;Change Bound Text&quot;&gt;
&lt;P&gt;&lt;/P&gt;
</PRE>

<p>Display the result in the Quick View mode of the HTML editor. The Quick View mode of the editor provides a rapid way of viewing what the DHTML file will look like when viewed by the Internet Explorer browser. Figure 16-1 shows the result.

<p><IMG SRC="images/f16gh01.jpg" width=344 height=197 BORDER="0">

<p><!-- caption --><b>Figure 16-1.</b> <i>The initial appearance of the edited Page1.htm file.</i><!-- /caption -->

<p>Close the HTML editor.

<A NAME="556"><H3>The wizard-generated code</H3></A>

<p>Open the Class1.java file in the Text editor. The code generated by the Code-behind HTML Wizard appears as follows (I have edited the comments to fit within the book page):

<p><pre>
import com.ms.wfc.html.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;

public class Class1 extends DhDocument 
{
    DhText createdText;
    DhText boundText;
    
    public Class1() 
    {
        // Required for Visual J++ Form Designer support
        initForm();        

        // TODO: Add any constructor code after initForm call
    }

    /**
     * Class1 overrides dispose so it can clean up the
     * component list.
     */
    public void dispose() 
    {
        super.dispose();
    }

    /**
     * Add all your initialization code here. The code here can add 
     * elements, set bindings to existing elements, set new properties 
     * and event handlers on elements. The underlying HTML document is 
     * not available at this stage, so any calls that rely on the 
     * document being present should be added to the onDocumentLoad()
     * function below (client-only).
     */
    private void initForm() 
    {
        createdText = new DhText();
        createdText.setText(&quot;Created Text&quot;);
                
        boundText = new DhText();
        boundText.setID(&quot;bindText&quot;);
        boundText.setBackColor(Color.LIGHTGRAY);

        /**
         * setBoundElements() will take a list of elements that already 
         * are present in the HTML document, and binds them to the 
         * DhElement list.
         */
        setBoundElements(new DhElement[] {boundText});

        /**
         * setNewElements() takes a list of DhElements and adds them
         * to the HTML document.
         */
        setNewElements(new DhElement[] {createdText});
    }
    
    /**
     * Client-side only.
     * 
     * Here, the underlying HTML document is available for inspection. 
     * Add any code that wants to get properties of elements or inspect
     * the document in any other way.
     */
    protected void onDocumentLoad(Object sender, Event e) 
    {
    }
}
</PRE>

<p>Let's examine this code for a second. You can see that the class <I>Class1</I> extends the class <I>DhDocument</I>. The names of all classes in the 
<I>html</I> package begin with the letters 
<I>Dh</I>. For the most part, the remainder of an 
<I>html</I> class name is the same as the WFC equivalent. For example, the class name for an <I>html</I> button is <I>DhButton,</I> whereas the WFC class name would be 
<I>Button</I>.

<P>The class <I>DhDocument</I> describes the HTML document. (The class <I>DhWindow</I> describes the browser window in which the document resides. Parallel concepts 
are found in JScript.)

<P>The <I>Class1</I> constructor immediately invokes the 
<I>initForm()</I> method, in much the same fashion as the constructor for a WFC-generated class.

<P>The <I>initForm()</I> method contains example code to perform two different tasks: adding objects to the DHTML file and binding the code to objects already present. Unfortunately, the code for these two functions is intertwined in the system-generated listing. Let me display the two tasks separately to better explain each.

<P>Adding DHTML objects is implemented by the following code:

<p><pre>
    private void initForm() 
    {
        createdText = new DhText();
        createdText.setText(&quot;Created Text&quot;);
                
        /**
         * setNewElements() takes a list of DhElements and adds them
         * to the HTML document.
         */
        setNewElements(new DhElement[] {createdText});
    }
</PRE>

<p>Here, you can see that <I>initForm()</I> creates an object of class <I>DhText</I>. This is the DHTML equivalent of the WFC <I>Text</I> object. The <I>text</I> property of the <I>DhText</I> object is then set to <I>Created 
Text</I>.

<P>The call to <I>setNewElements</I> adds an array of 
<I>DhElement</I> objects to the HTML display. In this case, the array contains a single element, the <I>createdText</I> object. The class <I>DhText</I> extends the class <I>DhElement,</I> as do all other <I>Dh</I> component classes.

<P>The second task is represented by the following portion of <I>initForm()</I>:

<p><pre>
    private void initForm() 
    {
        boundText = new DhText();
        boundText.setID(&quot;bindText&quot;);
        boundText.setBackColor(Color.LIGHTGRAY);

        /**
         * setBoundElements() will take a list of elements that already 
         * are present in the HTML document, and binds them to the 
         * DhElement list.
         */
        setBoundElements(new DhElement[] {boundText});
    }
</PRE>

<p>This portion begins by creating a <I>DhText</I> object just as we did before. Rather than set the properties of this object directly, however, this code uses the <I>setID()</I> method to attach to the text object <I>bindText</I>, which already appears in the Page1.htm file. Look back to the Page1.htm file to see that the initial text string is contained within &lt;SPAN&gt; tags carrying the <I>id</I> value <I>bindText</I>.

<P>A string of text doesn't allow for the definition of properties such as the <I>id </I>property. To address this limitation, DHTML allows for the inclusion of the &lt;SPAN&gt; tags, which can encompass a section of code and which do have an <I>id</I> property. Defining a property within the &lt;SPAN&gt; tags applies that property to the entire span of DHTML text.

<P>The <I>setID()</I> method scans the DHTML document looking for a text span with the ID <I>bindText</I>. Once found, this text is then bound to the <I>boundText</I> object. The <I>boundText.setBackColor()</I> method changes the background color property of the text span to <I>LIGHTGRAY</I>. (This is a rather subtle change. For a more dramatic effect, try setting a different property, such as font, and redisplaying the result in the Quick 
View window. You'll see this type of setting demonstrated later in this section.)

<A NAME="557"><H3>The user-defined code</H3></A>

<p>Edit the Class1.java file so it looks as follows:

<p><pre>
import com.ms.wfc.html.*;
import com.ms.wfc.core.*;
import com.ms.wfc.ui.*;

/**
 * Demonstrate html package principles by adding a few
 * simple HTML tags and then updating them dynamically.
 */
public class Class1 extends DhDocument 
{
    DhText createdText;
    DhText boundText;
    
    public Class1() 
    {
        // Required for Visual J++ Form Designer support
        initForm();        
    }

    /**
     * Class1 overrides dispose so it can clean up the
     * component list.
     */
    public void dispose() 
    {
        super.dispose();
    }

    /**
     * Bind to a few existing elements and add a few more.
     */
    private void initForm()
    {
        // attach to the text span and update the font
        boundText = new DhText();
        boundText.setID(&quot;bindText&quot;);
        Font font = new Font(boundText.getFont(), 18, FontSize.PIXELS);
        boundText.setFont(font);

        // attach to the boundButton id
        DhButton boundButton = new DhButton();
        boundButton.setID(&quot;button1&quot;);
        boundButton.addOnClick(
                      new EventHandler(this.onBoundButtonClick)
                              );
        
        // --- created stuff ---
        // add some initial tags
        DhRawHTML start = new DhRawHTML(&quot;&lt;P&gt;&quot;);
        
        // add a new text string
        createdText = new DhText();
        createdText.setText(&quot;Created Text&quot;);

        // now add a break
        DhRawHTML raw = new DhRawHTML(&quot;&lt;BR&gt;&quot;);

        // finally attach a button
        DhButton button2 = new DhButton(&quot;Say Hello&quot;);
        button2.addOnClick(new EventHandler(this.onButtonClick));
        
        // now attach some ending text
        DhRawHTML end = new DhRawHTML(&quot;&lt;/P&gt;&quot;);
        
        /**
         * setBoundElements() will take a list of elements that already
         * are present in the HTML document, and binds them to the
         * DhElement list.
         */
        setBoundElements(new DhElement[] {boundText, boundButton});

        /**
         * setNewElements() takes a list of DhElements and adds them
         * to the HTML document.
         */
        setNewElements(new DhElement[] {start, 
                                        createdText, 
                                        raw, 
                                        button2,
                                        end});
    }
    
    public void onButtonClick(Object o, Event e)
    {
        createdText.setText(&quot;Clicked&quot;);
        
    }
    
    public void onBoundButtonClick(Object o, Event e)
    {
        boundText.setText(&quot;Bound clicked&quot;);
    }
    
    /**
     * Client-side only.
     */
    protected void onDocumentLoad(Object sender, Event e) 
    {
    }
}
</PRE>

<p>This version of <I>initForm()</I> starts out as before, by binding <I>Class1 </I>to the existing <I>bindText</I> object we defined in our HTML file. Rather than set the background color, this version changes the font to an 18-point font, which is much larger than the 
original font.

<P>The next section of <I>initForm()</I> binds an object 
<I>boundButton</I> to the <I>button1</I> object we added using the HTML editor. This section adds an event handler 
<I>onBoundButtonClick()</I> to the <I>boundButton</I> object. Notice that the mechanism for adding an event handler to a DHTML object is identical to the mechanism used to add an event handler to a WFC object in a Windows application. A newly created <I>EventHandler</I> delegate is passed to the <I>addOnClick()</I> method. The <I>onBoundButtonClick()</I> method must follow the format required by the <I>EventHandler</I> delegate.

<P>Looking ahead, the <I>onBoundButtonClick()</I> method changes the text of the <I>boundText</I> object to &quot;Bound clicked&quot;.

<P>The &quot;created stuff&quot; section goes through the steps of creating a <I>DhText</I> object and a <I>DhButton</I> object, and then attaching an <I>onButtonClick()</I> method to the button. The calls to 
<I>DhRawHTML()</I> allow you to create <I>DhElement</I> objects containing raw DHTML commands. These objects can be inserted into the DHTML stream along with more sophisticated <I>html</I> package objects.

<P>The <I>setBoundElements()</I> method adds the bound objects to the <I>DhDocument</I> container. The 
<I>setNewElements()</I> method adds the newly created elements to the DHTML file and to the <I>DhDocument</I> container.

<A NAME="558"><H3>The result</H3></A>

<p>Build the resulting SimpleClientSide project. Notice that Visual J++ 6 creates and signs the CAB file referenced in the Page1.htm file. Display Page1.htm in the HTML editor in Quick View mode. Before the HTML file is displayed, a dialog box appears to make sure that the user agrees to allow the SimpleClientSide application full access. A page containing client-side DHTML must be accepted as trusted by the user, because the browser doesn't know the intent of the SimpleClientSide.cab object. Choose Yes to proceed.

<p>Figure 16-2 shows the output of the Quick View window as the Page1.htm page appears initially. Figure 16-3 shows the Quick View window after both buttons have been chosen.

<P><IMG SRC="images/f16gh02.jpg" width=305 height=200 BORDER="0">

<P><!-- caption --><B>Figure 16-2.</b> <i>The initial appearance of the SimpleClientSide application window.</i><!-- /caption -->

<P><IMG SRC="images/f16gh03.jpg" width=322 height=221 BORDER="0">

<P><!-- caption --><B>Figure 16-3.</b> <i>The appearance of the SimpleClientSide application window after both buttons have been clicked.</I><!-- /caption -->

<P>The change from Figure 16-2 to Figure 16-3 demonstrates the principles of DHTML better than anything we've seen so far. Choosing either button results in an immediate change in the corresponding HTML text without the aid of the server and without the use of an applet. Try executing Page1.htm from within Internet Explorer, and then view the HTML source code from the browser. You'll see that there is no trace in the source HTML code of the second section of text or the second button, nor is there a trace of the text as modified after you choose either of the buttons&#8212;and yet these changes are displayed in the browser. Both of these facts are a result of the ability of the CAB file application to modify the browser display dynamically.

<A NAME="559"><H3>A comment</H3></A>

<p>While the SimpleClientSide application demonstrates that it's possible to create new HTML objects (<I>createdText = new DhText()</I>), binding to existing objects 
(<I>boundText.setID(&quot;bindText&quot;)</I>) seems more fruitful. It's much easier to create an HTML file using your favorite HTML editor than it is to create the code to display HTML pages dynamically. (There is nothing magical about the HTML editor in Design mode. You can use whatever editor you prefer, as long as it assigns each object an 
ID. Even if the editor doesn't assign each object an ID, you can add it by hand.)

<p>Once the HTML objects have been created, it's relatively simple to bind to them and then add the necessary <I>addOnX()</I> methods to support the functionality you want.

<p>(Notice that I have been avoiding using the term &quot;applet&quot; when describing the SimpleClientSide application. SimpleClientSide isn't an applet, even though it's referenced from an HTML page.)

<A NAME="560"><H2>Accessing a Database Using Client-side DHTML</H2></A>

<p>While it is certainly interesting to see the Dynamic HTML changes in SimpleClientSide, the application doesn't do anything particularly interesting. The following DataClientSide application represents a practical use of the 
<I>html</I> package. This application reads a local database at run time, and displays the results in a DHTML table.

<A NAME="561"><H3>The HTML editor work</H3></A>

<p>Use the Code-behind HTML wizard to create the DataClientSide application in your DHTML directory. In Source mode, remove the warning section from the Page1.htm file. Also remove the &lt;SPAN&gt; tag that contains the &quot;This is bound text.&quot; string. Leave the &lt;OBJECT&gt; tags.

<A NAME="562"><H3>The database access code</H3></A>

<p>While it would be possible to write the entire DataClientSide application in a single class, the application will be easier for you to grasp if it's divided into at least two classes. Add the following <I>TableDatabaseConnection</I> class to your project to provide simple access to a Microsoft Access 97 database. This class is very similar both in concept and structure to those created in Chapter 12, <A HREF="ch12a.htm#393">Accessing Databases</A>. (If you don't understand this class, return to <A HREF="ch12a.htm">Chapter 12</A> for a more detailed discussion.)

<p><pre>
import com.ms.wfc.html.*;
import com.ms.wfc.core.*;
import com.ms.wfc.data.*;
import com.ms.wfc.data.ui.*;

/**
 * Extends DataSource to form a convenient database connection to
 * a DhTable object.
 */
public class TableDatabaseConnection extends DataSource
{
   /**
     * Build datasource
     * @param pathName     the path to a Microsoft Access 97 database
     * @param databaseName the name of the file (including extension)
     * @param tableName    table to extract from the database
     * @param fields       fields to read from that table
     */
    public  TableDatabaseConnection(String   pathName,
                                    String   databaseName,
                                    String   tableName,
                                    String[] fields)
    {
        // construct the connection string to the specified file
        String s = &quot;PROVIDER=MSDASQL;dsn=MS Access 97 Database;&quot; +
                   &quot;uid=;pwd=;DBQ=&quot;
                   + pathName
                   + &quot;\\&quot;
                   + databaseName;
        setConnectionString(s);
        
        // set up the query
        setCommandText(buildQuery(tableName, fields));

        // initialize miscellaneous settings
        setCursorLocation(
                com.ms.wfc.data.AdoEnums.CursorLocation.CLIENT);
        setLockType(com.ms.wfc.data.AdoEnums.LockType.OPTIMISTIC);
        setSort(null);
        setStayInSync(true);
        setUserId(null);
        setPassword(null);
    }
    
    /**
     * Build a SQL query from the table name and the field names.
     */
    static private String buildQuery(String tableName, String[] fields)
    {
        // start with select statement
        String s = &quot;select &quot;;
        
        // now tack on the field names with a comma in between
        // each name (but no comma after the last field)
        int i = 0;
        while(true)
        {
            s += fields[i++];
            if (i &gt;= fields.length)
            {
                break;
            }
            s += &quot;,&quot;;
        }
        
        // add the table name
        s += &quot; from &quot; + tableName;
        
        // return the SQL select statement
        return s;
    }
    
    /**
     * Build a DataBinding array that binds the fields in the
     * database table to the columns in the repeater row of the table
     * @param fields  field names from the database table to bind to
     * @param columns columns in the repeater row to bind to
     */
    public static DataBinding[] buildDataBindings(String[] fields, 
                                                  DhCell[] columns)
    {
        // create a set of data bindings consisting of
        // a data binding for each field
        DataBinding[] dataBindings = new DataBinding[fields.length];
        for(int i = 0; i &lt; dataBindings.length; i++)
        {
            dataBindings[i] = new DataBinding(columns[i],
                                              &quot;Text&quot;,
                                              fields[i],
                                              null);
        }

        // return the data bindings
        return dataBindings;
    }
}
</PRE>

<p>The <I>TableDatabaseConnection</I> constructor begins by creating an Access 97 access string from the <I>pathname</I> and <I>databaseName</I> values. (The <I>databaseName</I> value is the name of the database file). This connection string is passed to <I>DataSource.setConnectionString() </I>to become the command string used by the base <I>DataSource</I> class to access the database.

<P>The constructor continues by using the <I>buildQuery()</I> method to create a SQL query from the table name and the field names passed to the constructor. The resulting query is passed to the <I>DataSource.setCommandText()</I> method to be used as the database query. The remaining calls in the constructor set <I>DataSource</I> properties.

<P>The <I>buildQuery()</I> method takes as arguments the 
<I>tableName</I> string and the <I>fields</I> array of strings containing the field names, and constructs a query from them. Suppose, for example, that the <I>tableName</I> value was &quot;A&quot; and that the <I>fields</I> array contained the strings &quot;B&quot;, &quot;C&quot;, and 
&quot;D&quot;. From this, <I>buildQuery()</I> would create the following SQL query:

<p><pre>
SELECT B,C,D FROM A
</PRE>

<p>The final method in the class, <I>buildDataBindings</I>, creates and returns an array of <I>DataBinding</I> objects. The length of this array is the same as the number of strings in the <I>fields </I>array. Each <I>DataBinding</I> object binds a field name to a <I>DhCell </I>class. (We don't yet know what a <I>DhCell</I> class is, but for now suffice it to say that it's the equivalent of a <I>text</I> field in the examples in <A HREF="ch12a.htm">Chapter 12</A>. If you aren't familiar with the concept of a data binding, you can return to <A HREF="ch12a.htm">Chapter 12</A> for a more complete discussion.)

<A NAME="563"><H3>The Class1 code</H3></A>

<p>Armed with the <I>TableDatabaseConnection</I> class, the DataClientSide <I>Class1 </I>class is relatively simple. The only new concept presented by this code is the way that 
HTML tables are constructed using the <I>DhTable</I>, <I>DhRow</I>, and <I>DhCell</I> classes:

<p><pre>
import com.ms.wfc.html.*;
import com.ms.wfc.core.*;
import com.ms.wfc.data.*;
import com.ms.wfc.data.ui.*;

/**
 * Demonstrate accessing a local database via the WFC html package.
 */
public class Class1 extends DhDocument 
{
    // --------------define the database information------------------
    // path to the database
    String   pathName = &quot;C:\\ProgramVJ\\&quot; + 
                        &quot;Windows Database Applications\\Databases&quot;;
        
    // the database name
    String   databaseName = &quot;MyCompany.mdb&quot;;    
        
    // define the table name
    String   tableName = &quot;Customers&quot;;
    
    // define the fields to extract from the database table
    String[] fields = new String[]
                               {&quot;ContactFirstName&quot;,
                                &quot;ContactLastName&quot;,
                                &quot;PhoneNumber&quot;};
    // ---------------end of database info----------------------------
    
    
    // class constructor
    public Class1() 
    {
        // Required for Visual J++ Form Designer support
        initForm();    
    }
    

    /**
     * Class1 overrides dispose so it can clean up the
     * component list.
     */
    public void dispose() 
    {
        super.dispose();
    }

    /**
     * Create a table from the contents of a client-side database.
     */
    private void initForm() 
    {
        // create data source designed for connection to
        // a DhTable
        DataSource dataSource = new TableDatabaseConnection(
                                                        pathName,
                                                        databaseName,
                                                        tableName,
                                                        fields);

        // --- create a table using that data ---
        // start the table
        DhTable dhtable = new DhTable();
        dhtable.setPageSize(10);
        dhtable.setBorder(3);

        // generate the header row
        DhRow headerRow = new DhRow();
        DhCell headerCol = new DhCell(&quot;Header&quot;);
        headerCol.setColSpan(3);
        headerCol.setAlign(DhAlignment.CENTER);
        
        headerRow.add(headerCol);
        dhtable.setHeaderRow(headerRow);
                
        // now create a template row
        DhRow repeaterRow = new DhRow();
        DhCell[] columns = new DhCell[fields.length];
        for(int i = 0; i &lt; columns.length; i++)
        {
            columns[i] = new DhCell();
            repeaterRow.add(columns[i]);
        }

        // attach the template row to the table
        dhtable.setRepeaterRow(repeaterRow);

        // attach the data source to the table
        dhtable.setDataSource(dataSource);
        
        // attach the database to the columns of the table
        DataBinding[] dataBindings = 
                TableDatabaseConnection.buildDataBindings(fields, 
                                                          columns);
        dhtable.setDataBindings(dataBindings);
        
        // start the datasource
        dataSource.begin();

        /**
         * setNewElements() takes a list of DhElements and adds them
         * to the HTML document.
         */
        setNewElements(new DhElement[] {dhtable});
    }
    
    /**
     * Client-side only.
     * 
     * Here, the underlying HTML document is available for inspection. 
     * Add any code that wants to get properties of elements or inspect
     * the document in any other way.
     */
    protected void onDocumentLoad(Object sender, Event e) 
    {
    }
}
</PRE>

<p>The data members of <I>Class1</I> define the path to the database and the table to access within that database. (This application accesses the same Customers table of the MyCompany database that we used in <A HREF="ch12a.htm">Chapter 12</A>. Because we're using the same database in this chapter as we used in <A HREF="ch12a.htm">Chapter 12</A>, you can compare the output of this application with the output of the ToolboxADO example in <A HREF="ch12a.htm">Chapter 12</A>.) 
The values in the <I>fields</I> array specify that the application is to access the first name, last name, and phone number of each customer in the Customers table.

<P>The only method we modified from its default version is the <I>initForm()</I> method. The <I>initForm()</I> method begins by establishing a <I>DataSource</I> object using the 
<I>TableDatabaseConnection</I> class described previously. The <I>initForm()</I> method continues by creating a 
<I>DhTable</I> object that will access the entries present in the Customers database table.

<P>To understand the way <I>DhTable</I> works, you must first understand how an HTML table is constructed. An HTML table is defined with the &lt;TABLE&gt; tag. The first row of the table&#8212;the header row&#8212;is contained within the span of a &lt;THEAD&gt; tag. The table header is optional. Below the header appears a sequence of rows. Each row is defined by a &lt;TR&gt; tag. Each column within the row is defined by a &lt;TD&gt; tag. The &lt;TD&gt; elements are called <I>cells</I> rather than columns, since they really represent a data entry within the row rather than an entire column. Each row can have a different number of cells than its neighbors.

<P>The code for a DHTML table is analogous to the HTML code. The table is defined by the <I>DhTable</I> class. In our <I>Class1</I> example the first few method calls that follow the creation of the <I>DhTable</I> object set the maximum page size to 10 rows, and set the border width to three pixels.

<P>The next block of code defines the header row to consist of a single cell that spans three columns and contains the centered text &quot;Header.&quot; As you'll see shortly, since the entire table has only three columns, this effectively places a banner across the top of the entire table.

<P>Normally, the next sequence would be to add a number of 
<I>DhRow</I> objects to the table, each with a set of 
<I>DhCell</I> objects attached. However, building a table with an unknown number of entries adds a certain wrinkle. To handle this case, <I>DhTable</I> allows you to define a &quot;repeater&quot; row, sometimes called a <I>template</I> row. This row is repeated for each entry in the database up to the page size defined earlier. The <I>initForm()</I> method constructs this template row by creating a cell for each entry in the <I>fields</I> array. Thus, the ContactFirstName, ContactLastName, and PhoneNumber database fields are each assigned a column in the resulting HTML table. The template row is added to the table using the <I>setRepeaterRow()</I> method. (A normal row would be added to a table using the conventional <I>add()</I> method.)

<P>Once the repeater row has been defined, the <I>DataSource</I> created previously is attached to the HTML table. An array of <I>DataBinding</I> objects, one object for each field in the database, is created using the <I>buildDataBindings()</I> method defined earlier in the 
<I>TableDatabaseConnection</I> class. This <I>dataBindings</I> array is also attached to the table.

<P>Finally the flow of data is started by calling 
<I>dataSource.begin()</I>, and the HTML table is attached to the DHTML page using the <I>setNewElements()</I> method.

<P>(You'll notice how the <I>DhTable</I> class uses the <I>DataSource</I> and the <I>DataBinding</I> classes in the same way as the <I>DataBinder</I> class did in <A HREF="ch12a.htm">Chapter 12</A>.)

<A NAME="564"><H3>The result</H3></A>

<p>The result of executing the DataClientSide application in Quick View mode of the HTML editor is shown in Figure 16-4. While the output of this example application lacks the window dressings a real-world DHTML application would have, this example clearly demonstrates the results you can obtain by using the <I>html</I> package with a client-side database: the DataClientSide application modified an existing DHTML file in real-time in order to display the contents of a client-side database.

<P><IMG SRC="images/f16gh04.jpg" width=276 height=356 BORDER="0">

<P><!-- caption --><B>Figure 16-4.</b> <i>The DataClientSide application displays the contents of the Customers table with a </I>DhTable<I> object.</I><!-- /caption -->

</BODY>
</HTML>





