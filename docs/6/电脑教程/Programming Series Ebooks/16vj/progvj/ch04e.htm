<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>The AWT Solution</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04d.htm", "ch04f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="150"><H1>The AWT Solution</H1></A>

<p>Now that you are armed with some knowledge of component layout managers and event handling, let's return to solving the original problem. The AWT-based solution to the problem posed by Figure 4-1 is shown in the WindowedApp program beginning below.

<p><pre>
/**
 * This class implements a windowed application using the
 * Abstract Windowing Toolkit.
 */
import java.awt.*;
import java.io.*;

public class WindowedApp extends Frame
{
    // topEdit - the edit field for the file name
    TextField topEdit     = new TextField();
    
    // edit - the multiline text area
    TextArea  edit        = new TextArea();
    
    // we'll need two buttons
    Button    okButton    = new Button(&quot;OK&quot;);           
    Button    cancelButton= new Button(&quot;Cancel&quot;);
    
    // panels are invisible containers that you can place in
    // a frame to achieve (more or less) the grouping effect
    // of the text fields and buttons that you desire
    Panel     topPanel    = new Panel(new BorderLayout());
    Panel     centerPanel = new Panel(new BorderLayout());
    Panel     bottomPanel = new Panel(new BorderLayout());
    Panel     bottomLeftPanel  = new Panel(new BorderLayout());
    Panel     bottomRightPanel = new Panel(new BorderLayout());

    /**
     * The main entry point for the application. 
     *
     * @param args Array of parameters passed to the application
     * via the command line.
     */
    public static void main (String[] args)
    {
        // create a WindowedApp and then call its init()
        // method; this makes the application solution as much
        // like an applet as possible
        (new WindowedApp(args)).init();
    }
    
    /**
     * Constructor - if arguments are passed to the program,
     * assume that the first argument is the name of a file
     * to load into the edit window.
     */
    public WindowedApp(String[] args)
    {
        // if there's an argument, this is an input file
        if (args.length == 1)
        {
            try
            {
                // open an input file with the argument provided
                FileReader fr = new FileReader(args[0]);
            
                // now read the contents of the file and store
                // it into the edit buffer&#8230;
                int input;
                String s = new String();
                while ((input = fr.read()) != -1)
                {
                    char c = (char)input;
                    s = s + c;
                }
                s = convertFrom(s);
                edit.setText(s);

                // and store the name into the file name text line
                topEdit.setText(args[0]);
            }
            
            // if there's an error, just report it and give up any
            // hope of opening the file
            catch(Exception e)
            {
                System.out.println(&quot;Can't open input file&quot;);
            }
        }
    }            

    /**
     * Set up the WindowedApp window.
     */
    public void init()
    {
        // start by resizing the frame and setting its title
        // (leave the frame resizable)
        setSize(300, 150);
        setTitle(&quot;AWT Application&quot;);
        
        // first, handle the file name text field -
        // put the label on the left, a small space on the
        // right, and the text field in the middle
        topPanel.add(&quot;West&quot;, new Label(&quot;File Name:&quot;));
        topPanel.add(&quot;Center&quot;, topEdit);
        topPanel.add(&quot;East&quot;, new Label(&quot;&quot;));
        
        // create two buttons at the bottom;
        // put each in its own panel with a
        // little space on each side        
        bottomLeftPanel.add(&quot;West&quot;, new Label(&quot;&quot;));
        bottomLeftPanel.add(&quot;East&quot;, new Label(&quot;&quot;));
        bottomLeftPanel.add(&quot;Center&quot;, okButton);
        
        bottomRightPanel.add(&quot;West&quot;, new Label(&quot;&quot;));
        bottomRightPanel.add(&quot;East&quot;, new Label(&quot;&quot;));
        bottomRightPanel.add(&quot;Center&quot;, cancelButton);

        // now place the two button panels in the bottom
        // panel - use a grid layout, because this divides
        // the available space up evenly between the two
        // buttons (one row, two columns)
        bottomPanel.setLayout(new GridLayout(1, 2));
        bottomPanel.add(&quot;West&quot;, bottomLeftPanel);
        bottomPanel.add(&quot;East&quot;, bottomRightPanel);
        
        // put the text entry field in the center panel -
        // put the label at the top and let the text area
        // take up the rest of the space
        centerPanel.add(&quot;North&quot;, new Label(&quot;Edit:&quot;));
        centerPanel.add(&quot;Center&quot;, edit);
 
        // establish a border layout manager for the frame
        // and then add the three panels
        setLayout(new BorderLayout());
        add(&quot;North&quot;, topPanel);
        add(&quot;South&quot;, bottomPanel);
        add(&quot;Center&quot;, centerPanel);
        
        // put a little space on either side of the edit area
        add(&quot;West&quot;, new Label(&quot;&quot;));
        add(&quot;East&quot;, new Label(&quot;&quot;));
        
        // finally, now that we're all ready,
        // show the frame (frames are created hidden)
        setVisible(true);
    }

    /**
     * Process the OK button.
     */
    void processOK()
    {
        // if there's a file name in the text field, 
        // write the contents of the edit field to that file
        String sFileName = topEdit.getText();
        if (sFileName != null)
        {
            try
            {
                // read the text field
                String s = edit.getText();
                s = convertTo(s);
        
                // write the contents of the text field
                // to a file using the file writer
                FileWriter fw = new FileWriter(sFileName);
                fw.write(s);
                fw.close();

                // verify that all went well
                System.out.println(&quot;File &quot; + sFileName + &quot; saved&quot;);
            }
            catch(Exception e)
            {
                // notify error message
                System.out.println(&quot;Output error: &quot; + e.getMessage());
            }
        }
        
        // exit program
        processCancel();
    }
    
    /**
     * Convert output for display on MS-DOS terminal by adding
     * carriage returns after every newline character.
     */
    String convertTo(String s)
    {
        int offset = 0;
        while ((offset = s.indexOf(&quot;\n&quot;, offset)) != -1)
        {
            StringBuffer sb = new StringBuffer(s);
            sb.insert(++offset, '\r');
            s = sb.toString();
        }
        return s;
    }
    
    /**
     * Convert input by stripping carriage returns.
     */
    String convertFrom(String s)
    {
        int offset = 0;
        String cr = &quot;\r&quot;;
        while((offset = s.indexOf(cr, offset)) != -1)
        {
            String s1 = s.substring(0, offset);
            String s2 = s.substring(offset + 1, s.length());
            s = s1 + s2;
        }
        return s;
    }
    
    /**
     * Process Cancel button by terminating program.
     */
    void processCancel()
    {
        System.out.println(&quot;Program terminating&quot;);
        System.exit(0);
    }
    
    /**
     * Events are passed to the window to inform it of every
     * action that occurs to the window. We are interested in
     * the following events:
     * WINDOW_DESTROY - occurs when user clicks the x window dressing
     * OK button - save file and exit
     * Cancel button - just exit
     */
    public boolean handleEvent(Event e)
    {
        // if the event target is a button&#8230;
        if (e.target instanceof Button)
        {
            // check for OK button&#8230;
            if (e.target == okButton)
            {
                processOK();
                return true; // return true to indicate that
                             // we've handled the event
            }
            
            // now check for Cancel button
            if (e.target == cancelButton)
            {
                processCancel();
                return true; // control will never get here
            }
        }
        
        // if this is a Window destroy event&#8230;
        if (e.id == Event.WINDOW_DESTROY)
        {
            // then process it like a Cancel
            processCancel();
            return true;    // control will never reach here
        }
        
        // OK, we don't know what it is - 
        // pass it on to the base class for default processing
        return super.handleEvent(e);
    }
}
</PRE>

<p>As always, execution begins with the <I>main()</I> method. This method creates a <I>WindowedApp</I> object and then uses this object to call <I>init()</I>.

<P>
<DIV CLASS="NOTE">
<BLOCKQUOTE>
<B>NOTE</B>
<HR>This construct of creating an object by calling 
<I>new</I> and then immediately using the object to invoke a method is a direct application of the 
C++ philosophy that every expression has a type and a value (even though this 
construct isn't actually supported in C++).
</BLOCKQUOTE>
</DIV>

<p>Again please note that the statements in the <I>init()</I> method could have been placed directly in the constructor; however, the type of work done by <I>init()</I> must be separated from the constructor in applets, so Java programmers routinely separate it in applications as well.

<p>The class initialization performs the following steps:

<OL>
<p><li> It invokes the constructor of the super class. In this case, <I>Frame.Frame()</I> builds the base frame object.

<p><li> It constructs each of the member objects. This includes <I>topEdit</I>, <I>edit</I>, <I>okButton</I>, <I>cancelButton</I>, and a number of <I>Panel</I> objects. Each of the panels is created with <I>BorderLayout</I> as its layout manager. (The default for a <I>Panel</I> object is the <I>FlowLayout</I> layout manager.)

<p><li> It executes the code contained in the constructor. In this case, the constructor code checks to see if a file name was provided as an argument to the application. If it was, the constructor opens that file using a <I>FileReader</I> object.

<p><li> It reads the contents of the file one character at a time until the end-of-file character is reached. Each character is returned as an <I>int</I> and so must be converted into a character before being added to the string <I>s</I>.

<p><li> Once input is complete, the constructor stores the accumulated string <I>s</I> into the <I>edit</I> object using the <I>setText()</I> method.

<p><li> It then assigns the file name to the <I>topEdit</I> object.
</OL>

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
The file name text area is of type <I>TextField</I>, whereas the edit area is of type <I>TextArea</I>. A <I>TextField</I> type is designed to accommodate a single line of text, whereas the considerably more sophisticated <I>TextArea</I> type can handle multiple lines of text.
</blockquote></div>

<p>The <I>init()</I> method starts by sizing the frame to some convenient size. It then sets the title of the frame. This title appears on the frame's title bar.

<p>To understand the remainder of <I>init()</I>, you'll need to understand the plan of attack. This plan is shown in Figure 4-7. First the overall frame is divided into three panels. The upper panel contains the file name label and the file name edit box. Adding a null label to the right side of the panel keeps the edit box from extending all the way to the right edge of the frame.

<p>On the bottom are the two buttons OK and Cancel. These are each placed in their own panel so that they can be surrounded by null labels, to give a little separation between the buttons and their surroundings. The button panels are attached to a common <I>bottomPanel</I> object using a <I>GridLayout</I> layout manager. <I>GridLayout</I> will divide the available horizontal space equally between the two buttons.

<p><A HREF="javascript:fullSize('F04gh07x.htm')"> <img src="images/F04gh07.JPG" width=404 height=352 border=0 ALT="Click to view at full size."> </A>

<p><!-- caption --><b>Figure 4-7.</b> <i>The plan of attack for laying out the components for WindowedApp.</I><!-- /caption -->

<p>Finally, the text box is placed in the middle of the center panel with null labels on both sides for separation.


<A NAME="151"><H3>Event handling</H3></A>

<p>All of the event handling in WindowedApp is performed in the <I>handleEvent()</I> method, rather than by processing the button input in the <I>action()</I> method.

<p>The <I>target</I> field of the <I>Event</I> passed to <I>handleEvent()</I> references the object that first received the event. Thus, if the <I>target</I> is an instance of <I>Button</I>, this event must have originated from clicking one of the buttons.

<DIV CLASS="NOTE">
<BLOCKQUOTE>
<B>NOTE</B>
<HR>The <I>instanceof</I> keyword replaces the dynamic cast mechanism in C++; it returns <I>true</I> if the object on the left is an instance of the class on the right. This includes any base classes. Thus, an object that is an instance of <I>Button</I> is automatically an instance of <I>Component</I>. All objects are instances of <I>Object</I>.
</BLOCKQUOTE>
</DIV>

<p>If the event target is the <I>okButton </I>object, the program calls <I>processOK()</I>. If the event target is the <I>cancelButton</I> object, the program passes control to <I>processCancel()</I>. The program checks for the <I>WINDOW_DESTROY</I> event that would originate from clicking the close window button. The program handles the close window button exactly like the <I>cancelButton</I> object.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
Calling functions to handle the various events rather than handling them in place is a good idea because it keeps the <I>handleEvent()</I> method as simple as possible.
</blockquote></div>

<p>The <I>processCancel()</I> method outputs a termination message prior to calling <I>System.exit()</I> to terminate the application.

<p>The <I>processOK()</I> method begins by getting the file name from the <I>topEdit</I> text area. If the file name isn't <I>null</I>&#8212;that is, if there is a file name&#8212;the program creates a <I>FileWriter</I> object to handle output. The <I>FileWriter</I> constructor throws an exception if anything goes wrong during the opening process. WindowedApp catches this exception, outputs an error message, and continues processing.

<p>Once the <I>FileWriter</I> object has been created, the program fetches the contents of the edit area and writes it to the <I>FileWriter </I>object.

<A NAME="152"><H3>Converting to and from</H3></A>

<p>The methods <I>convertTo()</I> and <I>convertFrom()</I> are present to fix an AWT problem with the <I>FileReader</I> and <I>FileWriter </I>objects. The <I>FileWriter</I> object converts the <I>String</I> passed to it into a series of ANSI characters by ignoring the upper byte of each character. This would be fine for a UNIX machine; however, for a Windows machine, one further conversion is necessary. The newline character (&quot;\n&quot;) must also be converted into a newline-carriage return (&quot;\n\r&quot;).

<p>The<I> convertTo()</I> method handles this conversion by searching recursively for newline characters using the <I>String.indexOf() </I>method. When the <I>indexOf()</I> method returns an offset of -1, the function knows that the conversion is complete. Until then, <I>convertTo()</I> inserts a carriage return at the offset following the offset that was returned. The next search begins with the character following the carriage return that was just inserted<I>. </I>The<I> convertTo()</I> method returns the resulting string.

<p>The <I>convertFrom()</I> method takes the opposite tack, using a loop to search for carriage returns. Every time a carriage return is found, <I>convertFrom()</I> breaks the string into two strings, the first containing the characters before the carriage return and the second containing the characters after the carriage return. The program then concatenates the two strings. This process is repeated in a loop until the method returns the resulting string with all carriage returns removed.

<A NAME="153"><H2>The Result</H2></A>

<p>The output from the AWT-based WindowedApp is shown in Figures 4-8 through 4-10. To get a feel for the output's dynamic characteristics, I have shown it in various sizes.

<p><IMG SRC="images/F04gh08.JPG" width=300 height=150 BORDER=0>

<p><!-- caption --><b>Figure 4-8.</b> <i>The long awaited output from WindowedApp in its default size.</i><!-- /caption -->

<P><img src="images/F04gh09x.JPG" width=416 height=218 border=0> 

<p><!-- caption --><b>Figure 4-9.</b> <i>The output from WindowedApp expanded to roughly twice its original size.</i><!-- /caption -->

<p><IMG SRC="images/F04gh10.JPG" width=185 height=131 BORDER=0>

<p><!-- caption --><b>Figure 4-10.</b> <i>The output from WindowedApp shrunk to about half its size.</I><!-- /caption -->

<p>You can see that as the window expands the text box components and buttons expand and reposition to retain their proportionality. This is a direct result of the <I>BorderLayout</I> layout manager, which ties the objects to the frame borders. We carefully placed the labels within the layout scheme so that they retain their original size and position irrespective of the size of the window.

<p>If you continue to shrink the window, the text box shrinks proportionally until there is no longer enough room to display all of the text. At this point, the <I>TextArea</I> object displays scroll bars to allow access to all of the text, as shown in Figure 4-10.

<p><div class="note"><blockquote>
<b>NOTE</b><hr>
While it might be tempting to use the <I>TextArea</I> object for displaying large amounts of text, this won't work. The <I>TextArea</I> object size is limited in the size of <I>String</I> that it can accept. To build an editor capable of handling large files, you will need to perform dynamic file manipulations that are beyond the scope of this book.
</blockquote></div>

</BODY>
</HTML>




