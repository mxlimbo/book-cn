<HTML>
<HEAD><LINK REL="STYLESHEET" TYPE="text/css" HREF="Library.css">
<TITLE>Common Console Application Features</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch01c.htm", "ch01e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>
<A NAME="81"><H1>Common Console Application Features</H1></A>

<p>Although it's difficult to make sweeping statements 
about all console applications, I can say that many console applications perform 
both file I/O and the parsing of arguments to the program. In this section, 
we'll look at example programs that demonstrate both of these features.

<A NAME="82"><h2>A Simple Replacement for MS-DOS <I>copy</I>: Echo1</h2></A>
<p>The following console program, Echo1, performs a very 
simple operation. Echo1 accepts two arguments that it assumes are file names. 
Echo1 opens the file represented by the first argument and copies it to the file 
represented by the second argument.

<p><pre>
/**
 * Echo1 - Copies the file args[0] to the file args[1].
 */
import java.io.*;

public class Echo1
{
    /**
     * The main entry point for the application. 
     *
     * @param arg[0] - the input file
     * @param arg[1] - the output file
     */
    public static void main (String[] args)
    {
        // make sure that the user understands what
        // to do
        if (args.length != 2)
        {
            System.out.println(&quot;Enter: echo1 source dest&quot;);
            System.out.println(&quot;to copy &lt;source&gt; to &lt;dest&gt;&quot;);
            System.exit(-1);
        }

        // catch any problems at the bottom of the
        // program - no matter what the problem, we'll
        // output an error message and terminate
        try
        {
            // open the two files:
            // first the input file; an error here is fatal
            FileInputStream fin = new FileInputStream(args[0]);
            BufferedInputStream in = new BufferedInputStream(fin);
            
            // now the output file - first let's see whether the 
            // file exists
            okayToCopy(args[1]);
            
            // must be okay - open the target file, if it
            // exists, and truncate it
            FileOutputStream out= 
                                 new FileOutputStream(args[1], false);
            
            // now perform the copy
            byte[] buffer = new byte[1024];
            while(in.available() &gt; 0)
            {
                int bytesRead = in.read(buffer);
                out.write(buffer, 0, bytesRead);
            }
        }
        
        // catch any exception thrown
        catch(IOException e)
        {
            System.out.println(&quot;Error:&quot; + e.getMessage());
        }
    }
    
    /**
     * Check the argument to see whether it exists. If so, is it
     * okay to overwrite it? If not, it throws an exception. 
     *
     * @param outputFileName - the file name to overwrite
     */
    private static void okayToCopy(String outputFileName)
        throws IOException
    {
        // first check whether the file exists
        File file = new File(outputFileName);
        if (file.exists())
        {
            // it does, so check whether it's okay to overwrite it    
            System.out.println(&quot;File exists. Overwrite? [Y or N]&quot;);
            byte[] answer = new byte[1]; // read in a single byte
            System.in.read(answer);
            if (answer[0] != 'Y' &amp;&amp; answer[0] != 'y')
            {
                throw new IOException(&quot;Copy failed&quot;);
            }
        }
    }
}
</pre>

<A NAME="83"><H3>Changing the main class name</H3></A>

<p>Notice that in the previous example I have stopped 
calling the main class 
<I>Class1</I>. Instead, I renamed 
the main class to match the project name. To rename the main class, you start in 
the usual way by using the Console Application Wizard to create the Echo1 
project, as we did with the HelloWorld1 project at the beginning of this 
chapter. As usual, the wizard creates the one and only Java source file and 
names it Class1. First you rename the file in the Project to Echo1. This 
necessitates that you change the class name to <I>Echo1</I> 
as well.

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
     There can be only one public class per Java source file and its name must <I>exactly</I> match that of the Java source file in 
    which it resides. As we will see in Part II, this is necessary so that 
    browsers can find applet classes quickly and easily. 
</blockquote></div>

<p>Unfortunately, changing the names isn't enough. If you 
compile the Echo1 program after changing the project name and class name, the 
compiler claims that it can no longer find <I>Class1</I>. 
This is because the Console Application Wizard directs the Project file to start 
debugging with <I>Class1</I>. (Visual J-- 1.x used to ask 
the user for the class name the first time the program was run. This turned out 
to be a nuisance, so now the Wizard sets the class name.)

<p>To change the class name in the Echo1 project, you 
right-click the Echo1 project in Project Explorer and choose Echo1 Properties. 
From there, you select the Launch tab. In the When Project Runs, Load: list box, 
select the only class available, <I>Echo1</I>, and then 
choose OK. The resulting Properties page is shown in Figure 1-14.

<p><A HREF="javascript:fullSize('f01gh14x.htm')"> <img src="images/f01gh14.jpg" width=404 height=376 border=0 ALT="Click to view at full size."></A>

<p>
<!-- caption --><b>Figure 1-14.</b> <i>The project 
Properties window after the launch class has been changed from </i>Class1<I> to </I>Echo1<I>.</I><!-- /caption -->

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
     Even though <I>Echo1</I> was the only option 
    available, you must still manually select it and apply it. This option won't 
    be available until you have edited the name to <I>Echo1</I> in the Java source file. 
</blockquote></div>

<A NAME="84"><H3>The Echo1 source code </H3></A>

<p>Echo1 begins by importing the <I>java.io</I> package. This is where the file I/O classes reside.

<p></p><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>
     Importing a package is the Java equivalent to including a C++ <I>#include</I> file at compile time and adding the 
    corresponding library at link time. The package informs Visual J++ of our 
    intent to access classes from the <I>java.io</I> 
    package. 
</BLOCKQUOTE></DIV>

<p>Once Echo1 begins execution, it immediately checks to 
see whether the user has provided two arguments. It does that by checking the 
length of the <I>args</I> argument.

<P></P><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>
     The <I>args</I> argument to <I>main()</I> is an array of <I>String</I> objects, 
    each one corresponding to an argument to the program. 
</BLOCKQUOTE></DIV>

<p>If the user doesn't know what a console application 
does, it is common to simply run it without any arguments. In that case, it is 
important that the program provide the user some help by explaining what 
arguments it expects and what it does with them.

<p>Before the program begins the actual copy operation, it 
opens up a <I>try</I> block. Most of Java's file operations 
throw an <I>IOException </I>when something goes wrong, so 
we better be prepared to catch these exceptions.

<p>The first order of business before we can actually copy 
anything is to open the input file. The program does this by creating a <I>FileInputStream</I> object with the input file name. The <I>FileInputStream</I> constructor opens the file provided. If 
the file doesn't exist, it throws an <I>IOException</I> 
explaining as much.

<p>Notice how the program follows this up by wrapping the <I>FileInputStream</I> class in a <I>BufferedInputStream</I>. Doing this is almost always a good idea. The <I>FileInputStream</I> class isn't buffered, which means that 
every time a read is performed the class must go back to the disk to get the 
data. The 
<I>BufferedInputStream</I> class adds a buffer to 
reduce the number of disk reads. Thus, if the program reads a single byte, the <I>BufferedInputStream</I> class reads an entire block. 
(The actual size of the block is dependent on the operating system and the 
underlying disk, but it's some natural size, usually a multiple of 1024 bytes.) 
The <I>BufferedInputStream</I> class returns a single byte 
to the caller and retains the remaining data. When the program asks for another 
byte, the class returns the next byte from the buffer without going back to the 
disk. Since memory operations are much faster than disk accesses, <I>BufferedInputStream </I>can speed up I/O access 
considerably.

<p>The <I>false</I> value passed to 
the <I>FileOutputStream()</I> constructor indicates that 
the program doesn't want to append a file if the output file already exists. 
Instead, it wants to truncate any existing output file. Before the program opens 
the output file, however, it invokes the static method 
<I>okayToCopy()</I> to see whether it's okay to overwrite an existing file. 
The method <I>okayToCopy()</I> accepts the name of the 
output file. It throws an <I>IOException</I> if it isn't 
okay to overwrite an existing file.

<P></P><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>
     Unlike C++, a method must use the <I>throws</I> 
    keyword to declare any exceptions that it, or any method it calls, might 
    throw. 
</BLOCKQUOTE></DIV>

<p>The <I>okayToCopy()</I> method 
first checks for the presence of the target file by creating a <I>File</I> object. You might think that a <I>File</I> 
object is used to perform I/O, but its real use is for testing the properties of 
a file on the disk. The method <I>File.exists()</I> returns <I>true</I> if the <I>File</I> object 
is pointing to an existing file.

<p>If the target file does exist, the program asks the user 
whether it should be overwritten or not. If the user enters anything other than <I>y</I> or <I>Y</I>, the program 
throws an <I>IOException</I> and thereby saves the target 
file from extinction. (This exception is handled back at the end of <I>main()</I>.) Otherwise, the <I>okayToCopy()</I> method returns to the caller.

<p>Once the source and target files have been opened, 
there's nothing left but the <I>while</I> loop that 
performs the read and write operations. The method 
<I>InputStream.available()</I> returns a count of the number of bytes 
available to be read in the input file. The <I>InputStream.read()</I> method reads up to the number of <I>buffer</I> bytes. The return value is the number of bytes actually read. 
The call to <I>OutputStream.write()</I> writes the number 
of bytes from <I>buffer</I> that are indicated by <I>bytesRead</I>, starting at offset 0.

<A NAME="85"><H2>The More Sophisticated Echo2</H2></A>

<p>The Echo2 program presents several enhancements to the 
Echo1 program. First, the second argument&#8212;the destination file&#8212;is 
optional. If it isn't present, output goes to standard output. Further, Echo2 
accepts the <I>/C</I> switch, which if present indicates 
that the input is a text string that is to be capitalized before being output to 
the destination stream.

<p>While this may not sound like much, I have also added 
several techniques to Echo2 that you can use in other applications.

<A NAME="86"><h3>The <I>Echo2</I> class</h3></A>
<p>The following code represents the <I>Echo2</I> class:

<p><pre>
/**
 * Echo2 - Copies the first argument to the second.
 *         If output file is not given, output goes to
 *         standard output. If /C switch is present,
 *         attach a filter to convert each word to
 *         uppercase.
 */
import java.io.*;

public class Echo2
{
    // global data
    // input file object
    InputStream in = null;
    
    // output file object
    OutputStream out = null;
    
    /**
     * The main entry point for the application. 
     *
     * @param arg[0] - the input file (optional)
     * @param arg[1] - the output file
     */
    public static void main (String[] args)
    {
        // start parsing arguments
        try
        {
            boolean caps = false;
            String input = null;
            String output= null;
        
            int nextArg = 0;
            // first look for switches
            if (args[nextArg].equalsIgnoreCase(&quot;/C&quot;))
            {
                caps = true;
                nextArg++;
            }
        
            // save input argument
            input = args[nextArg++];
            
            // the output file name is optional -
            // an exception here is okay
            try
            {
                output = args[nextArg++];
            }
            catch(Exception e)
            {
            }

            // create an object to do all the work
            new Echo2(caps, input, output).copy();
        }
        catch(IOException e)
        {
            print(&quot;Error:&quot; + e.getMessage());
        }
        catch(Exception e)
        {
            print(&quot;Enter: echo2 [/C] source [dest]&quot;);
            print(&quot;to copy &lt;source&gt; to &lt;dest&gt;&quot;);
            print(&quot;If dest is absent, output is to standard output&quot;);
            print(&quot;/C -&gt; capitalize each word&quot;);
        }        
    }
    
    /**
     * The Echo2 constructor sets up the files.
     * By providing an object, the program now has a place
     * to store things.
     * @param capitalize - TRUE-&gt;capitalize each word on output
     * @param input      - the name of the input file (null-&gt;none)
     * @param output     - the name of the output file
     */
    Echo2(boolean capitalize, String input, String output)
        throws IOException
    {
        // open the two files:
        // first the input file; an error here is fatal
        FileInputStream fin = new FileInputStream(input);
        in = new BufferedInputStream(fin);
                            
        // must be okay - use either standard output or the
        // specified output file as output
        out = System.out;  // the default is standard output
        if (output != null)
        {
            okayToCopy(output);
            out = new FileOutputStream(output, false);
        }

        // if we are to convert to upper case, then&#8230;
        if (capitalize)
        {
            out = new CapFilterOutputStream(out);
        }
    }
    
    /**
     * Perform the copy operation. 
     *
     */
    void copy()
        throws IOException
    {
        byte[] buffer = new byte[1024];
        while(in.available() &gt; 0)
        {
            int bytesRead = in.read(buffer);
            out.write(buffer, 0, bytesRead);
        }
    }
    
    /**
     * Write input to standard output. 
     *
     * @param outputFileName - the file name to overwrite
     */
    static void print(String outString)
    {
        System.out.println(outString);
    }
    
    /**
     * Check the argument to see whether it exists and whether it's
     * okay to overwrite it. If not, it throws an exception. 
     *
     * @param outputFileName - the file name to overwrite
     */
    private static void okayToCopy(String outputFileName)
        throws IOException
    {
        // first check whether the file exists
        File file = new File(outputFileName);
        if (file.exists())
        {
            // it does, so check whether it's okay to overwrite it    
            System.out.println(&quot;File exists. Overwrite? [Y or N]&quot;);
            byte[] answer = new byte[1]; // read in a single byte
            System.in.read(answer);
            if (answer[0] != 'Y' &amp;&amp; answer[0] != 'y')
            {
                throw new IOException(&quot;Copy failed&quot;);
            }
        }
    }
}
</pre>

<p>The <I>main()</I> function in Echo2 
looks quite a bit different from its Echo1 ancestor. This is primarily because 
Echo2 must be flexible enough to handle a varied number of arguments.

<P>Echo2 first initializes each of the three variables it 
intends to read from the argument list. The program then defines the index 
<I>nextArg</I> to be used in scanning through the argument 
list. Echo2 compares the first argument to the <I>&quot;/C&quot;</I> string using <I>String.equalsIgnoreCase()</I>. If this function call returns <I>true</I>, the program knows that the <I>/C</I> switch is present. In this case, the program sets the <I>caps</I> flag to <I>true</I> and then 
increments <I>nextArg</I> to point to the next argument.

<P></P><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>
     The two argument variables, <I>input</I> and <I>output</I>, are initialized to <I>null</I>. <I>null</I> isn't numerically 
    equivalent to 0, as it is in C++, but is a unique value. 
</BLOCKQUOTE></DIV>

<p>The program assumes the next argument to be the name of 
the input file. If either of these first two arguments are not present, <I>args[]</I> will be referenced beyond the end of the array, 
which will cause Java to throw an <I>ArrayIndexOutOfBoundsException</I>. This exception will be caught at the 
bottom of <I>main()</I> by the <I>catch(Exception)</I> catch phrase.

<P>Next the program attempts to reference the second file 
name, except this time an <I>ArrayIndexOutOfBoundsException</I> does not represent an error because the 
second file name is optional. Therefore, the program catches the possible 
exception on the spot. In that event, <I>output</I> retains 
its 
<I>null</I> value.

<p>Once the arguments have been parsed, <I>main()</I> creates an object of the class <I>Echo2</I> and then immediately passes that object to 
<I>Echo2.copy()</I>.

<P></P><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<HR>
     Under Java, it is perfectly legal to allocate an object off the heap and 
    then immediately use it as the object of a method call. 
</BLOCKQUOTE></DIV>

<A NAME="87"><h3>Why create an <I>Echo2</I> 
object?</h3></A>
<p>The <I>main()</I> method is static 
and therefore has no object associated with it. This isn't a problem with 
programs that consist of only a single function, like Echo1. However, in larger 
object-oriented programs it is more convenient to store information in the data 
members of a class object. Creating an object in the static member <I>main()</I> provides just such a place to store information.

<p>The constructor for the <I>Echo2</I> class performs and looks a lot like the file creation logic in 
Echo1. The primary difference is that Echo2 first assigns 
<I>System.out</I> to the output object <I>out</I>. If an 
output file name is present, the output object is replaced by a <I>FileOutputStream</I> opened on that output file. This works because <I>PrintStream</I>&#8212;the class of 
<I>System.out&#8212;</I>and <I>FileOutputStream</I> both 
extend a common base class, <I>OutputStream</I>.

<p>Finally, Echo2 creates a <I>CapFilterOutputStream</I> object to perform the capitalization function.

<p></p><div class="note"><blockquote>
<b>NOTE</b><hr>
<I>CapFilterOutputStream</I> extends the base class <I>FilterOutputStream</I>. You can use subclasses of <I>FilterOutputStream</I> to perform conversion operations 
    on data being sent out of an output stream. 
</blockquote></div>

<p>The <I>copy()</I> and <I>okayToCopy()</I> methods are basically identical to their 
Echo1 equivalents.

<A NAME="88"><h3>The <I>CapFilterOutputStream</I> 
class</h3></A>
<p>Now all that's left is to present the <I>CapFilterOutputStream</I> class (located in the Echo2 program) that 
performs the capitalization operation. The source code is as follows:

<p><pre>
/**
 * CapFilterOutputStream - A filter output stream
 *                         that converts its output to
 *                         uppercase.
 */
class CapFilterOutputStream extends FilterOutputStream
{
    // the list of characters which cause capitalization
    static String specialChars = &quot; .-\t&quot;;
    
    // the output stream to use for actual output
    OutputStream os = null;
           
    CapFilterOutputStream(OutputStream os)
    {
        super(os);
        this.os = os;
    }
        
    /**
     * Write the buffer in capitalized form. 
     *
     * @param buffer - buffer to write
     * @param offset - where to start
     * @param length - number of bytes to write
     */
    public void write(byte[] buffer, int offset, int length)
        throws IOException
    {
        // make a string buffer out of the byte array -
        // here we are assuming a text byte array
        // (we use StringBuffer because you can write
        // directly to it)
        String s = new String(buffer, offset, length);
        StringBuffer sb = new StringBuffer(s);

        // convert the StringBuffer into uppercase according
        // to the rules of this class
        toUpper(sb);
            
        // now convert the string back into an array of bytes,
        // and write it out using the base class' method
        buffer = sb.toString().getBytes();
        os.write(buffer, 0, buffer.length);
    }
    
    /**
     * Write the buffer in capitalized form. 
     *
     * @param buffer - buffer to write
     */
    public void write(byte[] buffer)
        throws IOException
    {
        write(buffer, 0, buffer.length);
    }
        
    /**
     * Capitalize the buffer provided.
     *
     * @param buffer - buffer to write
     * @param offset - where to start
     * @param length - number of bytes to write
     */
    static void toUpper(StringBuffer sb)
    {
        // loop through the new buffer, capitalizing any
        // alphanumeric that appears after a special
        // character
        boolean cap = true;
        int length = sb.length();
        for (int i = 0; i &lt; length; i++)
        {
            char c = sb.charAt(i);
                
            // if we're supposed to cap this letter&#8230;
            if (cap)
            {
                // and if this is a letter&#8230;
                if (Character.isLetter(c));
                {
                    // then capitalize and restore it
                    c = Character.toUpperCase(c);
                    sb.setCharAt(i, c);
                   
                    // okay, it's done
                    cap = false;
                }
            }
            else
            {
                // (not in cap mode)
                // look for one of the special characters
                cap = (specialChars.indexOf((int)c) != -1);
            }
        }
    }
}
</pre>

<p>The <I>CapFilterOutputStream</I> 
class extends the <I>FilterOutputStream</I> class by 
overriding the <I>write()</I> method.

<P></P><DIV CLASS="tip"><BLOCKQUOTE>
<B>TIP</B>
<HR>
     It is something of a Java standard that when you extend a class, the name 
    of the new class should contain the name of the base class in addition to 
    some prefix to indicate what the new class does. In this case, <I>CapFilterOutputStream</I> extends <I>FilterOutputStream</I> to provide capitalization. That way, a 
    programmer who uses your class knows immediately what your class does and 
    what class it's based on. 
</BLOCKQUOTE></DIV>

<P></P><div CLASS="note"><blockquote>
<B>NOTE</B>
<HR>
     The term <I>extend</I>, when used for class 
    inheritance, is the Java equivalent of the colon in C++. 
</blockquote></div>

<p>The <I>CapFilterOutputStream</I> 
class starts by defining a string of special characters. The program assumes 
that these characters divide words. As a result, the program capitalizes the 
first letter appearing after any one of these characters.

<p>The <I>CapFilterOutputStream</I> 
class overrides the <I>write(byte[], int, int)</I> method 
to implement the capitalization. The <I>write()</I> method 
begins by converting the byte buffer passed to it into a <I>StringBuffer</I>. (There are several methods for character manipulation 
provided by the <I>StringBuffer</I> class.) Then it calls <I>toUpper()</I> to capitalize the 
<I>StringBuffer</I> and uses the <I>write()</I> method 
of its base class to perform the actual I/O.

<p>The <I>toUpper()</I> method loops 
through the <I>StringBuffer sb</I> one character at a time. 
If the capitalization flag <I>cap</I> is set to <I>true</I> and the character is a letter, the character is 
converted to uppercase and restored to the <I>StringBuffer</I>. If the flag isn't set, the character is looked up in the 
set of <I>specialChars</I>. If the <I>indexOf()</I> method returns a -1, the <I>c</I> 
character isn't one of the special characters. If <I>indexOf()</I> returns anything other than -1, the <I>c</I> character is one of the special characters.

<p>The output in Figure 1-15 shows the results of running 
Echo2.

<p><A HREF="javascript:fullSize('f01gh15x.htm')"> <img src="images/f01gh15.jpg" width=404 height=234 border=0 ALT="Click to view at full size."></A>

<p>
<!-- caption --><b>Figure 1-15.</b> <i>Output from the 
Echo2 program showing different options.</i><!-- /caption -->

<A NAME="89"><H2>Reading Formatted Data</H2></A>

<p>The standard Java <I>FileInputStream</I> and <I>FileOutStream</I> classes 
we have used up until now are ideal for reading in large blocks of data. 
Containing nothing more than the simple <I>read()</I> and <I>write()</I> methods, these classes are extremely limited 
in their formatting capability. The <I>DataInputStream</I> 
and <I>DataOutputStream</I> classes are provided for the 
purpose of extending formatting options. For example, the following code snippet 
can be used to read a floating point grade, an integer number of class hours, 
and a class name from a file named courses.txt.

<p><pre>
FileInputStream fin = new FileInputStream(&quot;courses.txt&quot;);
DataInputStream din = new DataInputStream(fin);

float  grade = din.readFloat();
int    hours = din.readInt();
String title = din.readUTF();
</pre>

<P></P><DIV CLASS="note"><BLOCKQUOTE>
<B>NOTE</B>
<hr><P>
Since Java assigns 16 bits to each character in a 
    string, Java methods do not normally have to worry about 1-, 2-, and 3-byte 
    Unicode characters. The <I>readUTF()</I> method reads 
    Unicode Text Format-8 (UTF-8) files that might have been written in another 
    language such as C++ and converts the data into a Java string. 
    Unfortunately, <I>readUTF()</I> reads to the end of the 
    file. There is no 
<I>DataInputStream</I> equivalent to 
    the C++ <I>getLine() </I>function, which reads until 
    the end of the line.</P>
</BLOCKQUOTE></DIV>

</BODY>
</HTML>




