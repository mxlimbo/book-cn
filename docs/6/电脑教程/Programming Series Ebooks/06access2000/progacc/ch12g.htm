<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Programmatic Issues</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch12f.htm", "ch13a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="396"><H1>Programmatic Issues</H1></A>

<P>One way to extend the capabilities of your Access Projects is with SQL. This 
is particularly so for views and stored procedures. Several of the preceding 
samples have shown what you can do with SQL. However, you can also put your 
VBA and ADO knowledge to use. The remaining samples in this chapter show 
how to apply your expertise in these areas to working with Access Projects or 
even to working with SQL Server and MSDE databases without the convenient 
user interface of Access Projects.</P>

<A NAME="397"><H2>Working with Forms</H2></A>

<P>While the Access Project user interface delivers extraordinary functionality 
with remote data sources, you can automate and simplify processes by 
developing custom programmatic solutions. We'll look at three areas pertaining 
to Access Projects: opening a form, finding a record, and viewing changes 
made by other users.</P>

<A NAME="398"><H3>Opening a form</H3></A>

<P>When you open a form with the Access Project interface, the form populates a local copy of the remote data in the client workstation. This local copy is a snapshot, at a point in time, of the remote data for the form. When you open the form programmatically, you must create the local copy of the remote data. One advantage to programmatically opening a form is that you can dynamically assign values to the local cache of the remote data. Your application can do 
this because the recordset that you assign to the form with VBA overrides the 
<I>Record Source </I>setting on the form's property sheet.</P>

<P>The procedure below constructs a recordset for a form before opening 
it. It starts by setting a reference to a new recordset instance: It assigns 
<I>adUseClient </I>to the recordset's <I>CursorLocation </I>property to establish the location of the form's data. (Recall that the form gets the data from the local cache on the workstation, not from the remote server.) Next, it opens the recordset with a SQL statement that extracts data from the remote source into the local copy. The sample works with the form from Figure 12-14. A commented line shows a SQL statement that can override the form's default record source. After making the local copy of the remote data, the procedure opens the form and assigns the local copy to the form's <I>Recordset </I>property. This new property possesses the functionality of the <I>RecordsetClone </I>property; in addition, changes to the recordset appear 
on the form automatically-the <I>RecordsetClone </I>property provides a read-only copy of a form's recordset. Like the <I>RecordsetClone </I>property, a form's <I>Recordset </I>property is available only programmatically.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub openForm()
Dim rst1 As ADODB.Recordset

'Establish a local recordset and populate it with values;
'can override property sheet settings.
    Set rst1 = New ADODB.Recordset
    rst1.CursorLocation = adUseClient
    rst1.Open &quot;Select * From employees&quot;, _
        CurrentProject.Connection, adKeySet, _
        adLockPessimistic
'Optionally run with where clause to demo override effect.
'    &quot;Select * From employees where employeeid&gt;3&quot;

'Open the form.
    DoCmd.openForm &quot;frmemployees2&quot;

'Assign recordset to the open form; can override a
'setting on the property sheet.
    Set Forms(&quot;frmemployees2&quot;).Recordset = rst1

End Sub
</PRE>
</TD></TR></TABLE></P>

<P><DIV CLASS="NOTE"><BLOCKQUOTE>
<B>NOTE</B><HR>
The recordset created for a recordset instance is available 
only if the form remains open. Closing and reopening the form manually 
causes the form to revert to the <I>Record Source 
</I>setting on its property sheet.
</BLOCKQUOTE></DIV></P>

<A NAME="399"><H3>Finding a record</H3></A>

<P>One common task when you work with data in a form is finding a specific record. The following two procedures accomplish this task. The 
<I>locateEmployee </I>procedure prompts for an employee ID value and passes that value along to the second procedure, <I>findByID</I>. The second procedure taps the <I>FindRecord </I>method of the <I>DoCmd </I>object to search for and position the form at a new record.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub locateEmployee()

'Ask for employee ID and pass it on to findByID.
    employeeNumber = InputBox(&quot;Type the ID for the employee you want&quot;, _
        &quot;Programming Microsoft Access 2000&quot;)
    findById CLng(employeeNumber)

End Sub


Sub findById(eid As Long)
On Error GoTo findByIdTrap

'Set focus to employee ID field and launch find.
    Forms(&quot;frmemployees2&quot;).EmployeeID.SetFocus
    DoCmd.FindRecord eid

findByIdExit:
'Report mismatch before exiting.
    If Forms(&quot;frmemployees2&quot;).EmployeeID &lt;&gt; eid Then
        MsgBox &quot;No employee with ID &quot; &amp; eid &amp; &quot;.&quot;, _
            vbExclamation, &quot;Programming Microsoft Access 2000&quot;
    End If
    Exit Sub
    
findByIdTrap:
    If Err.Number = 2450 Then
'Open form if it is closed and start find again.
        openForm
        Resume
    Else
        Debug.Print Err.Number, Err.Description
    End If

End Sub
</PRE>
</TD></TR></TABLE></P>

<P>The second procedure detects two potential problems. First, if there is 
no match, the procedure issues a message to that effect. Second, neither 
procedure is an event procedure, so they can be invoked from outside the form. If the form is closed, the procedure detects the problem and opens it so that it can try again to find the target record.</P>

<A NAME="400"><H3>Viewing changes made by other users</H3></A>

<P>Access is inherently a multi-user development environment, and Access 
Projects frequently serve multi-user purposes. Therefore, you need a way to refresh 
the local cache so that you can view updates, additions, and deletions made 
by others. The following procedure does this by repopulating the local 
recordset for the form from the remote data source. Like the preceding samples, this 
one is based on the form in Figure 12-14.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub requeryRemoteRestoreID()
Dim int1 As Integer

'Turn off screen updates and save employee ID.
    DoCmd.Echo False
    int1 = Forms(&quot;frmemployees2&quot;).EmployeeID

'Requery local recordset from the server.
    openForm
    
'Reposition to employee ID before requery and
'restore screen updating.
    Forms(&quot;frmemployees2&quot;).EmployeeID.SetFocus
    DoCmd.FindRecord int1
    DoCmd.Echo True
    
End Sub
</PRE>
</TD></TR></TABLE></P>

<P>The procedure refills the local data cache by invoking the <I>openForm </I>procedure (which was discussed earlier). If the form is already open, the 
call simply repopulates the cache. Since repopulating a form's recordset 
automatically makes the first record current, the procedure saves the current 
record position before repopulating the local cache from the remote data store. 
After repopulating the cache, the procedure searches through the records to find the preceding current record. This restores the old record position if that record is still available (that is, not deleted). If another user has deleted the former current record, the form displays the first record in the local cache.</P>

<A NAME="401"><H2>Working with Standalone Modules</H2></A>

<P>All the emphasis on ADO throughout this book will serve you well when 
you develop custom solutions against MSDE and SQL Server data sources. Chapter 
4 shows some samples for dealing with remote data sources. Here, we'll 
revisit some programmatic issues in the context of Access Projects and MSDE.</P>

<A NAME="402"><H3>Opening a table</H3></A>

<P>The following sample integrates opening a table in a remote data source 
with writing the results to the Immediate window as a telephone directory. It uses ADO <I>Connection </I>and <I>Recordset </I>objects to do this. The procedure starts by creating a new instance of an ADO <I>Connection 
</I>object. Then it defines a connection string and uses that string to open a connection to the NorthwindCS database on the cab2200 server. Next, it opens a forward-only, read-only recordset based on the <I>Employees </I>table in NorthwindCS. This type of recordset is acceptable for a report that makes a single pass through a recordset. The procedure prints the employee directory in the Immediate window with the help of a <I>Do </I>loop for passing through successive records.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub openTableOnRemoteServer()
Dim cnn1 As ADODB.Connection
Dim rst1 As ADODB.Recordset

'Open connection to NorthwindCS database
'on cab2200 server.
    Set cnn1 = New ADODB.Connection
    strCnn = &quot;Provider=sqloledb;&quot; &amp; _
        &quot;Data Source=cab2200;&quot; &amp; _
        &quot;Initial Catalog=NorthwindCS;&quot; &amp; _
        &quot;User Id=sa;Password=;&quot;
    cnn1.Open strCnn
    
'Open employee table with a forward-only,
'read-only recordset; this type is OK for a single
'pass through the data.
    Set rst1 = New ADODB.Recordset
    rst1.CursorType = adOpenForwardOnly
    rst1.LockType = adLockReadOnly
    rst1.Open &quot;employees&quot;, cnn1, , , adCmdTable

'Print an employee telephone directory.
    Do Until rst1.EOF
        Debug.Print rst1.Fields(&quot;FirstName&quot;) &amp; &quot; &quot; &amp; _
            rst1.Fields(&quot;LastName&quot;) &amp; &quot; has extension &quot; &amp; _
            rst1.Fields(&quot;Extension&quot;) &amp; &quot;.&quot;
        rst1.MoveNext
    Loop

'Close the connection and recover the resource.
    cnn1.Close
    Set cnn1 = Nothing

End Sub
</PRE>
</TD></TR></TABLE></P>

<P>The test environment for this chapter has an MSDE server on the local machine named CABXLI in addition to the SQL Server database manager on 
the machine named cab2200. The syntax for referring to local servers is 
slightly different than the syntax for referring to remote ones. Instead of having to designate a specific server by name, you can simply specify 
<I>(local)</I>. Since my local computer also has the NorthwindCS database installed, no other change in the procedure is necessary. The procedure is identical to the preceding one with the exception of the one block that appears below. Notice the new server name. In practice, you might want to have users designate their own login account name or have them use a limited one with fewer privileges than <I>sa</I>.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
'Open connection to NorthwindCS database
'on the local server.
    Set cnn1 = New ADODB.Connection
    strCnn = &quot;Provider=sqloledb;&quot; &amp; _
        &quot;Data Source=(local);&quot; &amp; _
        &quot;Initial Catalog=NorthwindCS;&quot; &amp; _
        &quot;User Id=sa;Password=;&quot;
    cnn1.Open strCnn
</PRE>
</TD></TR></TABLE></P>

<P>You can process views by using the same syntax that you use for tables. Simply enclose the view's name in quotes, just like you do for a table. You must still use the <I>adCmdTable </I>setting for the <I>Option </I>parameter. The companion CD includes a sample named <I>openViewOnRemoteServer </I>that demonstrates this approach.</P>

<A NAME="403"><H3>Opening a stored procedure</H3></A>

<P>Stored procedures can return recordsets. Your applications have more 
flexibility when they provide recordsets using stored procedures instead of tables because you are not restricted to the tables in the current data source or even exact copies of the tables in the current data source. With stored 
procedures, you can filter records, compute new values, and aggregate field values across the records in a table.</P>

<P>The following procedure invokes the stored procedure named <I>Ten Most Expensive Products</I> and prints in the Immediate window the 10 product 
names and prices. Because the procedure name includes spaces, it must be in 
brackets. Notice also that the procedure uses an <I>Options </I>argument of <I>adCmdStoredProc</I>. This tells the ADO processor to expect a procedure name that contains SQL, not an actual SQL statement. Since the procedure always processes 10 records, the procedure for printing out the records uses a 
<I>For </I>loop that goes from 1 through 10. In other respects, the procedure for printing the return set from a stored procedure is identical to the procedure for printing an entire table.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub openProcedureOnRemoteServer()
Dim cnn1 As ADODB.Connection
Dim rst1 As ADODB.Recordset
Dim int1 As Integer

'Open connection to NorthwindCS database
'on cab2200 server.
    Set cnn1 = New ADODB.Connection
    strCnn = &quot;Provider=sqloledb;&quot; &amp; _
        &quot;Data Source=cab2200;&quot; &amp; _
        &quot;Initial Catalog=NorthwindCS;&quot; &amp; _
        &quot;User Id=sa;Password=;&quot;
    cnn1.Open strCnn
    
'Open employee table.
    Set rst1 = New ADODB.Recordset
    rst1.CursorType = adOpenForwardOnly
    rst1.LockType = adLockReadOnly
    rst1.Open &quot;[Ten Most Expensive Products]&quot;, _
        cnn1, , , adCmdStoredProc

'Print prices for 10 products.
    For int1 = 1 To 10
        Debug.Print rst1.Fields(0) &amp; &quot; has a unit price &quot; &amp; _
            &quot;of $&quot; &amp; rst1.Fields(1) &amp; &quot;.&quot;
        rst1.MoveNext
    Next int1

'Close the connection and recover the resource.
    cnn1.Close
    Set cnn1 = Nothing

End Sub
</PRE>
</TD></TR></TABLE></P>

<A NAME="404"><H3>Assigning <I>CursorLocation </I>values</H3></A>
<P><I>CursorLocation </I>settings can profoundly affect performance, especially as table sources grow to even moderate size. The sample below demonstrates this 
with a recordset source of just over 19,000 records. It forms this recordset with a view based on the Cartesian product of the <I>Employees </I>and <I>Order Details </I>tables. The view's name is <I>vwLargeView</I>.</P>

<P>The sample opens its recordset source with either <I>adUseClient </I>or <I>adUseServer </I>as its <I>CursorLocation </I>setting. The <I>adUseServer 
</I>setting causes a procedure to progressively move through the records one at a time on the server. The <I>adUseClient </I>setting transfers the records to the local workstation so that procedures can access the records from a local workstation without returning to the server for each record.</P>

<P>The first procedure in the sample prompts for an instruction about which <I>CursorLocation </I>setting to use. The second procedure prepares a report 
and prints it in the Immediate window. It prints the cursor location and type as well as the start time, end time, and the duration for the task. You can adapt this general model for testing various combinations of database settings with your own data sources.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub openRemoteWithCursorLocation()
Dim cnn1 As ADODB.Connection
Dim rst1 As ADODB.Recordset
Dim start As Date, done As Date

'Open connection to NorthwindCS database
'on cab2200 server.
    strCnn = &quot;Provider=sqloledb;&quot; &amp; _
        &quot;Data Source=cab2200;&quot; &amp; _
        &quot;Initial Catalog=NorthwindCS;&quot; &amp; _
        &quot;User Id=sa;Password=;&quot;
    Set cnn1 = New ADODB.Connection
    If MsgBox(&quot;Use local cursor?&quot;, vbYesNo, _
        &quot;Programming Microsoft Access 2000&quot;) = vbYes Then
        cnn1.CursorLocation = adUseClient
    Else
        cnn1.CursorLocation = adUseServer
    End If
    cnn1.Open strCnn
    
'Open vwLargeView view; create the view in the remote
'database server before running the procedure.
'The sample uses the Cartesian product of the
'Employees and Order Details tables.
'Notice that the connection setting for CursorType silently
'overrides the recordset property setting.
    Set rst1 = New ADODB.Recordset
    rst1.CursorType = adOpenKeyset
    rst1.LockType = adLockOptimistic
    rst1.Open &quot;vwLargeView&quot;, cnn1, , , adCmdTable
    start = Now
    Do Until rst1.EOF
        temp = rst1.Fields(1)
        rst1.MoveNext
    Loop
    done = Now
    reportResults cnn1.CursorLocation, rst1.CursorType, _
        start, done

End Sub


Sub reportResults(cloc As Integer, ctype As Integer, _
    startedAt As Date, endedAt As Date)

    Debug.Print &quot;Results for: &quot;
    Select Case cloc
        Case adUseServer
            Debug.Print &quot;     Cursor Location: adUseServer&quot;
        Case adUseClient
            Debug.Print &quot;     Cursor Location: adUseClient&quot;
        Case Else
            Debug.Print &quot;     Faulty Cursor Location setting&quot;
    End Select
    Select Case ctype
        Case adOpenForwardOnly
            Debug.Print &quot;     Cursor Type: adOpenForwardOnly&quot;
        Case adOpenKeyset
            Debug.Print &quot;     Cursor Type: adOpenKeyset&quot;
        Case adOpenDynamic
            Debug.Print &quot;     Cursor Type: adOpenDynamic&quot;
        Case adOpenStatic
            Debug.Print &quot;     Cursor Type: adStatic&quot;
    End Select
    Debug.Print &quot;Start time to nearest second: &quot; &amp; startedAt
    Debug.Print &quot;End time to nearest second: &quot; &amp; endedAt
    Debug.Print &quot;Difference in seconds: &quot; &amp; DateDiff(&quot;s&quot;, &amp; _
        startedAt, endedAt)

End Sub
</PRE>
</TD></TR></TABLE></P>

<P>Figure 12-18 shows the results of running the procedures using 
an <I>adUseClient </I>setting and then an <I>adUseServer </I>setting. It took just 1 second to loop through the records with a local cursor, but it took 37 seconds to loop through the records with a server-side cursor. Results can vary depending on a wide range of factors, so it's a good idea to test for other settings and your particular databases.</P>

<P><A HREF="javascript:fullSize('F12qh18x.htm')"> <img src="Images/F12qh18.JPG" width=404 height=223 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 12-18.</B> <I>Sample output showing results of processing the same data source with an </I>adUseClient <I>or an </I>adUseServer <I>setting.</I><!-- /CAPTION -->
</P>


<P>This sample is instructive for a few reasons. First, the performance 
outcomes are drastically different. Second, you can see that ADO changes your 
settings if they conflict. For example, the program sets the cursor type to 
<I>adOpenKeyset</I>, but this setting conflicts with <I>adUseClient</I>, so the ADO interpreter silently changes the cursor type setting to <I>adStatic</I>. This happens in other contexts as well. Third, this sample presents a simple model that you can readily adapt for exploring database settings in your own custom applications.</P>

</BODY>
</HTML>




