<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Designing Queries Manually</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04b.htm", "ch04d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="131"><H1>Designing Queries Manually</H1></A>

<p>Custom applications can build queries programmatically or use prebuilt queries as record sources. Just as with tables, it is likely that you will sometimes build queries manually and sometimes construct them programmatically. A good knowledge of manual query design principles serves as a foundation for learning how to design and run queries programmatically.</p>

<p>This section explores building queries with wizards and reviews using the query Design view. While the wizards are easy to use, they substantially constrain your design options relative to manually building queries on the query design grid in Design view. The review of techniques for using the query design grid covers adding tables, selecting rows, and designating criteria. You will also discover how to construct parameter queries, union queries, and subqueries.</p>

<A NAME="132"><H2>Using the Wizards</H2></A>

<p>The Access query wizards provide a fast and easy way to create queries. This section describes each of the four query wizards.</p>

<A NAME="133"><H3>The Simple Query wizard</H3></A>

<p>The redesign of the Database window in Access 2000 makes accessing the Simple Query wizard somewhat unique. Select Queries in the Database window and double-click the Create Query By Using Wizard icon to open the Simple Query wizard. You can also reach the Simple Query wizard via the more traditional route by selecting Queries and clicking the New button on the Database window toolbar.</p>

<p>The Simple Query wizard enables three kinds of query design. All of its features target beginning developers. However, even you, as an experienced developer, will find you can develop queries just as fast as with the query design grid. The major disadvantage of the Simple Query wizard is that it does not permit the full range of query designs that you can achieve via the query design grid or SQL. Developers who are unfamiliar with SQL and joining rules will find its graphical interface attractive.</p>

<p><div class="NOTE"><blockquote>
<b>NOTE</b><hr>
There are no query wizards for the new Microsoft Access Project (this type of project has an .adp file type as opposed to the traditional .mdb database file type). In addition, the query Design view layout is different for .mdb and .adp files. See the last section in this chapter for an initial consideration of query design with Access Projects. See <a href="ch12a.htm">Chapter 12</a> for indepth coverage of working with remote databases and the Microsoft Data Engine.
</blockquote></div></P>


<p>The most basic way to build a query with the Simple Query wizard, shown in Figure 4-1, is to base it on a single table or query. Use the wizard this way to delimit the fields that a query returns. Even this simple application of the wizard adds value since restricting the return set improves query performance.</p>

<P><A HREF="javascript:fullSize('F04QH01x.htm')"> <img src="Images/F04QH01.JPG" width=404 height=299 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-1.</b> <i>The Simple Query wizard on the way to creating a query based on a subset of the fields in the Northwind </i>Categories<i> table.</i><!-- /CAPTION -->
</P>

<p>The real power of the Simple Query wizard comes in its ability to join two or more tables without requiring a query designer to actually create joins between tables. This lets the designer focus on the fields needed in the query and the tables from which they must come without spending any time at all focusing on the proper query design. The wizard is smart enough to generate correct results.</p>

<p>Figure 4-2 shows the Simple Query wizard on the way to developing a query that joins two tables in the Northwind database. All you need to do is select a table and then select fields within the table and move them from the Available Fields list box to the Selected Fields list box. The bottom window shows an excerpt of the result set of joining the <i>CategoryName</i> field from the <i>Categories</i> table and the <i>ProductName</i> field from the <i>Products</i> table.</p>

<p>The query in Figure 4-2 joins the <i>Categories</i> and <i>Products</i> tables on their common <i>CategoryID</i> field. However, at no point do you have to specify this. The Simple Query wizard automatically detects the shared field and joins the two tables on it. The wizard automatically assumes an equi-join that includes only records with matching <i>CategoryID</i> field values in both tables. If a record in one table had a <i>CategoryID</i> value that was not present in a record in the other table, the Simple Query wizard would ignore the record. If your application requires records excluded by an equi-join, then you can edit the query design from the wizard, design the query in Design view, or use SQL statements to construct the query.</p>

<P><A HREF="javascript:fullSize('F04qh02x.htm')"> <img src="Images/F04qh02.JPG" width=404 height=588 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-2.</b> <i>The Simple Query Wizard dialog box and the resulting query's Datasheet view.</i><!-- /CAPTION -->
</P>


<p>The query in Figure 4-2 joins the <i>Categories</i> and <i>Products</i> tables on their common <i>CategoryID</i> field. However, at no point do you have to specify this. The Simple Query wizard automatically detects the shared field and joins the two tables on it. The wizard automatically assumes an equi-join that includes only records with matching <i>CategoryID</i> field values in both tables. If a record in one table had a <i>CategoryID</i> value that was not present in a record in the other table, the Simple Query wizard would ignore the record. If your application requires records excluded by an equi-join, then you can edit the query design from the wizard, design the query in Design view, or use SQL statements to construct the query.</p>

<p>You can also design queries that perform some aggregations with the Simple Query wizard. The wizard automatically detects when an aggregation is possible and does as much as possible to help the query designer. It presents a dialog box like the top one in Figure 4-3 only when numerical aggregations are possible. You can still decline the aggregation route by selecting the Detail option in the second step of the wizard. If you choose the Summary option, then you should also click the Summary Options button to specify which fields to aggregate and which functions to use for the aggregation. The wizard only presents legitimate options. The wizard does occasionally prepare an extra summary field. If this happens, just delete the field in the query design grid.</p>

<P><A HREF="javascript:fullSize('F04qh03x.htm')"> <img src="Images/F04qh03.JPG" width=404 height=413 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-3.</b> <i>The second step in the Simple Query Wizard dialog box allows you to designate the computation of aggregates in a query.</i><!-- /CAPTION -->
</P>

<p>The two bottom windows in Figure 4-3 show the Design and Datasheet views of the query. Notice that the query counts the products in each category. The bottom left window shows the query design grid that computes the result. However, the Simple Query wizard removes the need to know where to place the aggregate function and what selections to make in the Total row. (You need to click the Totals toolbar button to make the Total row appear in the query design grid when designing a query manually.) The wizard relieves you of all this detail.</p>

<A NAME="134"><H3>The Find Duplicates Query wizard</H3></A>

<p>A pair of query wizards helps create queries that perform common tasks. The Find Duplicates Query wizard searches a recordset to determine whether there are two or more records with the same values. It returns the duplicate values for all records with common values for fields specified by the search criteria.</p>

<p>One common reason for wanting to find duplicates is to eliminate the extra copies of records from a record source. However, you cannot convert the resulting query to a delete query since it will remove the original records along with their duplicates. The Access 2000 online help describes a procedure for automatically removing duplicates based on the result from the Find Duplicates Query wizard. To discover the procedure, type &quot;automatically delete duplicates&quot; as the search criterion for the Office Assistant.</p>

<p>Open the specific instructions by choosing the prompt reading &quot;Automatically delete duplicate records from a table.&quot;</p>

<p>Our sample for this wizard uses the <i>FamilyMembers</i> table (see the top window in Figure 4-4). The Find Duplicates Query Wizard dialog box in the middle of Figure 4-4 contains a pair of list boxes for choosing fields on which to search for duplicate values. As with the Simple Query wizard, you move fields from the Available Fields list box into the Duplicate-Value Fields list box. In the sample, I chose the <i>Lname</i> field on which to search for duplicates. As the top window in Figure 4-4 shows, all the records in <i>FamilyMembers</i> are duplicates of one of the two values for this field. Step 3 of the wizard enables you to designate other fields that will show in the return set. The sample chooses all the remaining fields.</p>

<p>The bottom window in Figure 4-4 highlights one of the strengths of Access wizards, which is that they simplify complex tasks. The bottom window also shows the query design grid layout created by the wizard. Notice that it contains a SQL subquery. The subquery statement includes an aggregate function as well as GROUP BY and HAVING clauses. It is this subquery in the criterion row of the design grid that detects duplicate values in the source recordset. You can fine-tune the resulting query design by adding or removing fields, including new or replacement source fields, or even by using additional criteria to eliminate some duplicates.</p>

<P><A HREF="javascript:fullSize('F04qh04x.htm')"> <img src="Images/F04qh04.JPG" width=404 height=509 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-4.</b> <i>The Find Duplicates Query wizard. The top window shows the input record source. The middle dialog box shows the selection of a field on which to search for duplicate values. The bottom window shows the resulting query in Design view.</i><!-- /CAPTION -->
</P>

<A NAME="135"><H3>The Find Unmatched Query wizard</H3></A>

<p>The Find Unmatched Query wizard is another feature that supports a common database management chore. This wizard returns records in one table that do not have a match in a corresponding table. It is particularly convenient for managing tables that do not have referential integrity, but that are in a one-to-many relationship. In this situation, you can inadvertently, or purposefully, remove the one or the many side of a relationship. When either the one or the many side is without a match in its corresponding table, the Find Unmatched Query wizard will discover it. You will typically want to remove these records from a record source. Happily, all you have to do is convert the automatically created query to a delete query.</p>

<p>The query in Figure 4-5 checks the <i>FamilyNames</i> table and the <i>FamilyMembers</i> table for unmatched records. The comparison takes place on the <i>Lname</i> field in both tables. The query joins the two tables by forcing all the records from the <i>FamilyNames</i> table into the query, as shown by the directional arrow from the <i>FamilyNames</i> table to the <i>FamilyMembers</i> table. Then, the query searches for null record values for the <i>Lname</i> field in the <i>FamilyMembers</i> table. If the record value for <i>Lname</i> in the <i>FamilyMembers</i> side of the return set is null, the <i>FamilyNames</i> side of the return set has no match in the <i>FamilyMembers</i> table. The proper design of this query requires an understanding of left joins and null values. Studying the design of queries such as this one and queries that return duplicate values can help to sharpen your query design skills if you do not routinely write queries like these.</p>

<P><img src="Images/F04qh05.GIF" width=346 height=493 border=0>
</P><P><!-- CAPTION --><b>Figure 4-5.</b> <i>The Find Unmatched Query wizard and its resulting query. The second record source is the </i>FamilyMembers <i>table. The match criterion is the </i>Lname <i>field.</i><!-- /CAPTION -->
</P>

<A NAME="136"><H3>The Crosstab Query wizard</H3></A>

<p>Decision support analysts sometimes find that crosstab queries yield insights about objects and processes. Figure 4-6 shows an input table to the Crosstab Query wizard and resulting return set. I refined the return set's display in both its Design and Datasheet views.</p>

<p>The crosstab query in the bottom datasheet counts <i>FamID</i> by <i>Relation</i> and <i>Lname</i> fields from the top datasheet. The tweak I made in Design view adjusts the order for <i>Relation</i> from ascending to descending. In Datasheet view, I dragged the column labeled <i>Total Of FamID</i> from the second column to the last column. Otherwise, the layout was automatic. There was no need to enter field names and keywords in the query design grid. Nor did I have to write SQL code.</p>

<P><img src="Images/F04qh06.GIF" width=360 height=345 border=0>
</P><P><!-- CAPTION --><b>Figure 4-6.</b> <i>A query created by the Access 2000 Crosstab Query wizard. The top datasheet shows the input for the query return set that appears in the bottom datasheet.</i><!-- /CAPTION -->
</P>

<p>Two newer technologies for analysis emerge as challenges to the crosstab queries. First, a pivot table can compute basic crosstab results from a record source, but it can additionally enable the dynamic manipulation of the data after the computation of the crosstab. This permits decision analysts to interact dynamically with their analysis results. Access enables pivot table analysis through its forms and Data Access Pages, but Microsoft Excel is the primary vehicle for performing pivot table analysis within Office. Second, online analytical processing database (OLAP) technology enables dynamic data analysis against potentially very large data sources. This technology requires a remote database server, such as SQL Server 7, and an OLAP consumer for the data. Within the traditional Microsoft Office 2000 components, Excel 2000 is the designated resource for that role.</p>

<A NAME="137"><H2>Using Design View</H2></A>

<p>While wizards enable query design with little or no knowledge of query 
syntax and design issues, they do not offer great variability relative to the total scope of what queries can accomplish. As is frequently the case with wizards, the design of the query wizards is sometimes more complicated than 
absolutely necessary to accomplish some tasks. This can complicate minor changes to a query. If you initially design a query yourself, then you are likely to recall the logic and be able to modify it easily later.</p>

<A NAME="138"><H3>Adding tables and queries</H3></A>

<p>You can create your own custom queries by adding tables or other queries to the query design grid. Taking this route will generally remove the requirement that you write SQL code to create and edit your queries. Open the query design grid by double-clicking the Create Query In Design View option in the Database window's Queries objects group. Next, add one or more tables, queries, or a combination of tables and queries to the top of the design grid. Select a table or query and click Add to move a table or query from the Show Table dialog box to the top of the design grid.</p>

<p>After adding a table to the top of the Design view, you need to select fields that will be part of the query in the bottom grid. There are at least three ways to add fields to the query. First, drag and drop them from the record source's field list box to the Field row in the bottom grid. If you drag and drop a field on the left top edge of an already occupied column, Access automatically moves the remaining columns to the right. Second, you can double-click an entry in the field list. This copies the field to the first vacant column in the grid. Third, you can choose a field from the drop-down box in each column's Field row. If you have more than one record source in the top of the grid, then the Field row's drop-down list enumerates fields grouped by record source.</p>

<p>You can use any of the three techniques with a single table to specify a few columns from a table with many columns. Figure 4-7 shows the Design and Datasheet views of a query based on the sample's <i>Products</i> table. This query specifies three fields from the <i>Products</i> table.</p>

<p>The Sort row in the <i>ProductName</i> column of Figure 4-7 is set to Ascending. This row contains a drop-down list with three options: Ascending, Descending, and (Not Sorted). If you choose the last option, the cell appears blank in the grid and the column's data is not sorted when the query is displayed in Datasheet view. Choosing Ascending for the <i>ProductName</i> column causes the records to appear in alphabetical order based on <i>ProductName</i>. If the Sort row for <i>ProductName</i> is blank, the datasheet in the bottom window of Figure 4-7 would appear sorted on the table's primary key, <i>ProductID</i>.</p>

<P><A HREF="javascript:fullSize('F04qh07x.htm')"> <img src="Images/F04qh07.JPG" width=404 height=607 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-7.</b> <i>The top window shows the query design for a manually created query based on the </i>Products<i> table. The bottom window is the resulting datasheet.</i><!-- /CAPTION -->
</P>


<p>It is easy to add more than one record source to a query's design. You can choose an input record source from tables and other queries. It is highly desirable to join record sources (if Access does not automatically join them based on the relationships denoted in the Relationships window). Failing to join the tables will cause the resulting datasheet to show the Cartesian product of the two tables. This will often be a table with an excessively large number of rows.</p>

<p>Figure 4-8 shows the <i>Products</i> and <i>Order Details</i> tables joined on the <i>ProductID</i> field. You can create a default join like this by dragging a field from one table and dropping it on the matching field in another table. This creates a datasheet with one row for each matching field in both tables. If a record appears in just one table, it does not show in the query's datasheet. There are two other types of joins. One adds all the rows from the <i>Products</i> table on the left. The other adds all the rows from the <i>Order Details</i> table on the right. You can choose either of these join types by right-clicking the join line and then choosing the desired join type.</p>

<P><A HREF="javascript:fullSize('F04qh08x.htm')"> <img src="Images/F04qh08.JPG" width=404 height=395 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-8.</b> <i>The top window shows the query design for a manually created query based on both the </i>Products <i>and </i>Order Details <i>tables. The bottom window displays a Zoom dialog box that shows the formula for the calculated field in the query.</i><!-- /CAPTION -->
</P>

<p>The Table row in Figure 4-8 shows four of the columns belonging to the <i>Order Details</i> table. Another column, <i>ProductName</i>, belongs to the <i>Products</i> table. The query design's last field does not show completely in the top window of the figure.</p>

<A NAME="139"><H3>Referencing subdatasheets</H3></A>

<p>One of the innovations introduced with Access 2000 is the ability to reference hierarchically one table or query from within another query. In a sense, it is as if one parent query has a child table or query.</p>

<p>Figure 4-9 displays a subdatasheet within a query datasheet. The parent query is named <i>qryCategories</i>. Notice the + in the query's first column. Clicking any of these, such as the one for the Meat/Poultry category, opens a child datasheet and transforms the + to a -. This +/- sign acts like a toggle switch for opening and closing the subdatasheet linked to any row in the parent query. The child subdatasheet in the figure displays the product fields for one row in its parent's datasheet. More generally, the child subdatasheet references another query or a table linked to the current row. You can concurrently open multiple child subdatasheets. In fact, a query property lets you leave all the child datasheets open by default.</p>

<P><A HREF="javascript:fullSize('F04qh09x.htm')"> <img src="Images/F04qh09.JPG" width=404 height=220 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-9.</b> <i>A parent query, </i>qryCategories<i>, displays its subdatasheet for the </i>Meat/Poultry <i>category.</i><!-- /CAPTION -->
</P>

<p>Five new query properties control the behavior and appearance of subdatasheets. The <i>Subdatasheet Name</i> property points at a table or query with the child data. To access this and the other four properties, open the Query Properties dialog box in the query's Design view. The five new properties are at the bottom of the dialog box. The <i>Subdatasheet Name</i> property box contains a drop-down box that simplifies selecting another query or table as the record source for the subdatasheet. For the query in Figure 4-9, <i>Subdatasheet Name</i> is the table <i>MyProducts</i>. Enter field names for the <i>Link Child Fields</i> and <i>Link Master Fields</i> properties to synchronize the parent query with its child query or table. As with a main/sub form, the field names do not have to be the same, but they must have the same data type. The <i>Subdatasheet Height</i> property controls the height of the subdatasheet within the parent's Datasheet view. Finally, the <i>Subdatasheet Expanded</i> property takes values of <i>Yes </i>or <i>No</i>. The Query Properties dialog box offers a drop-down list for entering either value.</p>

<p>Access 2000 also supports subdatasheets for parent datasheets based on tables as well as queries. However, slightly different mechanisms support subdatasheets for parent queries vs. parent tables. With a parent table, you can designate the relationship between a parent table and its child table or query in the Relationships window. If you do elect to use the Table Properties dialog box, you must open the table in Design view. Then, you must explicitly open the Table Properties dialog box by right-clicking in the top part of the grid and choosing Properties. This makes the same five properties as for queries available for setting relationships between a parent table and its subdatasheet.</p>

<A NAME="140"><H3>Using calculated fields</H3></A>

<p>You can create a calculated field that derives its value from one or more fields in a query. Use simple arithmetic and string operators, built-in functions, or custom functions to express computed fields.</p>

<p>Calculated fields are not directly updateable. This is because Access stores just the expression in a SQL statement, rather than the result for the calculation. You can revise calculated fields by altering the inputs to the expression for the calculation. Although calculated fields are not updateable, your applications can aggregate them across records.</p>

<p>Specifying fields as expressions in a query has several benefits. First, since an expression can display data without actually storing data, using an expression for a field allows a query to show a result without consuming storage space. Second, expressions recompute automatically. This enables them to reflect the most recent data without any special action on the part of a database administrator. Third, there is a rich diversity of ways to include expressions as fields. Learning these ways will heighten your overall understanding of Access.</p>

<p><b>Arithmetic operators</b>  Figure 4-8 shows a calculated field to compute an extended price. The expression for the extended price relies on simple arithmetic operators, such as multiplication and subtraction, to develop its calculated field. Notice that the Table row for the calculated field in the top window of Figure 4-8 is blank. This signifies that the field does not consume any storage space. The calculated field in Figure 4-8 uses the field label to represent a meaningful label for the field in Datasheet view.</p>

<p><b>Built-in functions</b>  Figure 4-10 shows a calculated field that relies on built-in functions. Since the expression builds a string, it can use the <i>Left$</i> function. This saves memory over the more generic <i>Left</i> function that returns a string in a variant data type.</p>

<p>The expression in Figure 4-10 concatenates three distinct strings. First, it retrieves the first letter of a family member's first name with the <i>Left$</i> function. Second, it appends the string &quot;. &quot; to add a period and a space after the first letter of a person's name. The expression closes by appending the family member's last name. This calculated field still has the default field label, but the query's Datasheet view shows the column with a different header that is more descriptive. The top right dialog box in Figure 4-10 shows that you can achieve this result by assigning a value to the field's caption. Any entry in the caption property box overrides a field expression as the column heading.</p>

<P><A HREF="javascript:fullSize('F04qh10x.htm')"> <img src="Images/F04qh10.JPG" width=404 height=278 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-10.</b> <i>Three windows reveal the syntax and label conventions for adding a string expression to a query to define its sole field. The bottom window displays the return set from the query.</i><!-- /CAPTION -->
</P>


<p>You can ease the process of using built-in functions and referring to table, query, and form values by using the Expression Builder. If you find it necessary to refine the expression after adding it with the Expression Builder or manually, use the Zoom dialog box. You can do this by right-clicking in the Field row and choosing Zoom. This opens the Zoom dialog box with your expression. Edit the expression as necessary before clicking OK to close the Zoom dialog box and enter your edited expression into the query. The bottom window in Figure 4-8 is a Zoom box that displays a calculated field from a query.</p>

<p><b>Custom functions</b>  In addition to using operators and built-in functions, you can develop your own custom functions to return field values. Figure 4-11 shows a query that links to the <i>dbo_titles</i> table in the SQL Server Pubs database.</p>

<p>This query lists the <i>title</i> and <i>pubdate</i> fields for each record. In addition, it includes a calculated field that calls the custom function <i>daysto2K</i>. The expression passes the <i>pubdate</i> field value to the function. The <i>daysto2K</i> function appears below. By comparing the function name below with the query design in Figure 4-11, you can see that function references in a query are case insensitive.</p>

<p>
	<table cellpadding=5 width="95%">
		<tr>
			<td>
<pre>
Public Function DaysTo2K(InDate As Date) As Integer

    DaysTo2K = DateDiff(&quot;d&quot;, InDate, #1/1/2000#)

End Function
</pre></td>
		</tr>
	</table></P>


<P><A HREF="javascript:fullSize('F04qh11x.htm')"> <img src="Images/F04qh11.JPG" width=404 height=244 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-11.</b> <i>This query uses a custom function to compute the difference between a field in the query and January 1, 2000</i><!-- /CAPTION -->
</P>


<p>The function accepts the <i>pubdate</i> field value as an argument and returns an integer data type to the query. This enables automatic right alignment. (Failing to specify an integer return causes the function to return a variant to the query, which results in left alignment.) The custom function has a single line. It applies the built-in <i>DateDiff</i> function to compute the difference in days between the <i>pubdate</i> field value and January 1, 2000.</p>

<p>There is a potential downside to applying custom functions in expressions for query fields&#8212;particularly with large, remote databases. Your application must pause while a potentially large table moves over the wire from the remote server to your local workstation. In addition, you lose the power of computing your query on the remote server computer. In situations where you absolutely require a custom function, construct a query that extracts the fewest number of records from the remote server and performs all other functions on the remote server. Then, apply your custom function to the small return set from the server. These objections to custom functions are not pertinent to the sample in Figure 411 because the <i>dbo_titles </i>table is very small. Custom functions work well with Jet databases of any size.</p>

<p><b>Aggregate SQL functions</b>  You can compute a value without using expressions. One way to accomplish this is by clicking the Totals button&#8212;the button with a sigma (&aring;)&#8212;on the Query Design toolbar. Then, drag one or more fields to the query design grid and choose Group By in the Total row. You must have at least one field with a numeric value whose Total row is not set to Group By. You can designate a calculated field as the numeric field. Choose Expression in the Total row. Insert an aggregate SQL function around your calculated field to report a count, sum, or average of the calculated field for each unique combination of fields whose Total row is set to Group By in the record source.</p>

<p>Figure 4-12 shows a query design that sums the extended price by <i>OrderID</i>. The query computes the extended price for each line item before summing and grouping them by <i>OrderID</i>. The <i>Group By</i> keyword appears in the Total row of the <i>OrderID</i> column. The <i>Sum</i> function around the Extended Price expression indicates that the query will compute the sum of the extended price for each order.</p>

<P><A HREF="javascript:fullSize('F04qh12x.htm')"> <img src="Images/F04qh12.JPG" width=404 height=193 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-12.</b> <i>The expression for the calculated field in this query computes the extended price for each line item in every order. The </i>Group By<i> keyword in the Total row forces the aggregate function in the expression to compute the sum of values across line items for each order.</i><!-- /CAPTION -->
</P>


<p><b>Computing a value from more than one query</b>  Statistical results are most interesting when they compare two or more bits of information. While it is useful to know the amount of each order, you may want to know whether the price of each order is above or below the average and by how much. Access does not permit you to compute this kind of outcome in a single query. My sample for this problem requires three queries, and one of these contains a Cartesian product of the other two queries. The first query is the one shown in Figure 412. The second is a query that computes the average price across all orders. This query involves a simple <i>AVG</i> aggregate function on the extended price for the query in Figure 4-12. The top window of Figure 4-13 illustrates the Cartesian product of the query that sums extended prices by order (<i>qryODetailsSummedPrices</i>) and the query that computes the average extended price across orders (<i>qryODAvgPrices</i>). Recall that the way to compute a Cartesian product is to include both queries in the Design view without joining them. The bottom window of Figure 4-13 shows the percent change between each order's total and the average across all orders. If the sum is greater than the average, the percent is positive&#8212;otherwise, it is negative.</p>

<p>The formula that computes the average percent change does not show in Figure 4-13. The expression is merely the ratio of two numbers. The numerator is the difference between the order's extended price and the average across all orders. The denominator is the average extended price across all orders. This calculated field has its format property set to <i>Percent </i>with 0 places after the decimal.</p>

<p>
	<table cellpadding=5 width="95%">
		<tr>
			<td>
<pre>
% Delta from Avg: ([Extended Price]-[Avg of Extended Price])/
    [Avg of Extended Price]
</pre></td>
		</tr>
	</table></P>


<P><A HREF="javascript:fullSize('F04qh13x.htm')"> <img src="Images/F04qh13.JPG" width=404 height=463 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-13.</b> <i>The top window shows a query that computes a Cartesian product between two queries. The expression in the calculated field computes the percent change between the summed extended price per order and the average extended price across all orders.</i><!-- /CAPTION -->
</P>

<A NAME="141"><H3>Working with criteria</H3></A>

<p>Criteria can have a critical impact on the behavior of queries. By specifying criteria with expressions and constants, you can designate which records a query will return. Criteria cause the inclusion or exclusion of records in a select query's return set. The samples in this section highlight simple queries that have one condition. Once you learn how to create these, you can readily extend the knowledge to create compound condition criteria that combine two or more individual criterion conditions with either And or Or operators.</p>

<p><b>Using a single criterion</b> Figure 4-5 illustrates a simple criterion that uses the key phrase <i>Is Null</i>. Use the <i>Is Null </i>phrase to detect an empty field value in a query. The query's design joins the <i>FamilyNames</i> and <i>FamilyMembers</i> tables on the <i>Lname</i> field. The join type includes all the names from the <i>FamilyNames</i> table whether or not they match a <i>Lname</i> value in the <i>FamilyMembers</i> table. In the <i>FamilyNames</i> table, the <i>Lname</i> field has one of four values. These are Dobson, Hill, Simmons, and Edelstein. The <i>Lname</i> field in the <i>FamilyMembers</i> table has values of Dobson and Hill. Therefore, the query returns both Simmons and Edelstein since these two names are in <i>FamilyNames</i> but not in <i>FamilyMember</i>s. Changing the <i>Is Null </i>phrase to <i>Is Not Null </i>causes the return set to change to Dobson and Hill.</p>

<p>Figure 4-14 illustrates a query design that includes only those records in the <i>FamilyMembers</i> table with <i>Lname</i> field values that contain a lower case <i>s</i> in the fourth position. The <i>InStr</i> function is one of the many powerful built-in operators in Access. It compares one string vs. another in any of several ways. The fourth parameter sets the search type; 0 specifies a binary search. The <i>InStr</i> function returns a number that is the position of the first occurrence of the second string within the first string. For the expression in Figure 4-14, <i>InStr</i> finds the string <i>s</i> at position 4 in the name Dobson. Therefore, setting the criterion to <i>4 </i>selects records whose <i>Lname</i> field contains an <i>s</i> at position 4.</p>

<P><A HREF="javascript:fullSize('F04qh14x.htm')"> <img src="Images/F04qh14.JPG" width=404 height=248 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-14.</b> <i>This query returns the records in the </i>FamilyMembers <i>table whose </i>Lname <i>field contains an </i>s<i> at position 4.</i><!-- /CAPTION -->
</P>


<p>If you add more names to the <i>FamilyMembers</i> table whose <i>Lname</i> field contains an <i>s</i> at position 4, the query will return those records as well. For example, adding a new record with an <i>Lname</i> value of Samson will cause the query to return Samson along with Dobson.</p>

<p>Notice that the result of the expression in Figure 4-14 does not show in the query's return set because its Show box is unchecked.</p>

<p><b>Using multiple criteria</b>  The query in Figure 4-15 creates a series of sentences. The query dynamically constructs the sentences from the values in fields, but it also excludes the record whose <i>Relation</i> value is <i>me</i>. (The sentences in the query's return set describe the relation of each family member to me (the person). Therefore, the record whose <i>Relation</i> value is <i>me </i>should not be in the query.) This query uses two expressions. One specifies a criterion for including records; the other is a string expression that constructs the sentences using selected field values.</p>

<P><A HREF="javascript:fullSize('F04qh15x.htm')"> <img src="Images/F04qh15.JPG" width=404 height=392 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-15.</b> <i>A query that dynamically constructs sentences.</i><!-- /CAPTION -->
</P>

<p><b>Using a compound criterion</b>  After creating and testing individual criteria for specific fields, you may find it necessary to create compound criteria that combine two or more criteria for specific fields. There are two basic strategies to accomplish this. First, you can combine criteria with an And operator. This design technique causes a query to return rows for records that meet all its criteria concurrently. Second, you can combine multiple criteria with an Or operator. With the Or operator, a query returns rows for records that meet any of its criteria.</p>

<p>Happily, the Access query design grid insulates you from the syntax details of constructing SQL statements. When using the And operator, place all your criteria on a single row of the design grid. If you want to see all customers in a particular city that have ordered more than a minimum sales amount, you might start with a query that sums sales by customer from any city. Then, in a second query that references the first, you might use compound And criteria: one criterion to designate the particular city about which you seek information and a second criterion to set a lower limit so that the query only returns customers with more than a minimum sales amount. Since the task calls for an And operator, both criteria will reside on the same row of the query design grid.</p>

<p>After finding all the customers that meet the criteria in a particular city, you might decide to drill down into the buying patterns of your customers within a city. To develop data on this topic, you might start with a query that joins the <i>Orders</i> and <i>Order Details</i> tables. Your query design grid can include separate pairs of criteria on multiple rows. Placing criteria on different rows within the query design grid combines them with Or logic. The criteria on each row will have a city and customer. The city will be the same for all rows, but the customer criterion will be unique for each row. To group sales alphabetically by customer click the Sort row for the <i>Customer</i> field and choose Ascending.</p>

</BODY>
</HTML>




