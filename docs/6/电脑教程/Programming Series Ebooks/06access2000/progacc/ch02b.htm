<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>DAO Overview</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch02a.htm", "ch02c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="38"><H1>DAO Overview</H1></A>

<P>Access 2000 includes the 3.6 version of the DAO library, a maintenance 
upgrade to the 3.5 version that shipped with Access 97. (The basic architecture 
and functionality is very similar between versions.) DAO relies on a workspace 
object model for types of data access. The workspace object can contain session, security, and transaction information. (A workspace object defines how 
your application interacts with data.)</P>

<P>There are two types of workspaces: Microsoft Jet workspaces 
and ODBCDirect workspaces.</P>

<A NAME="39"><H2>Jet Workspaces</H2></A>

<P>Jet workspaces are for Jet, Jet-connected ODBC, and installable ISAM 
data sources. Jet-connected ODBC data sources let you link to remote data 
sources in a familiar DAO environment. Unfortunately, this type of connection 
requires the full DAO model, and it loads Jet even when no data access is 
required. Installable ISAM data sources come in a variety of formats, such as Paradox and Lotus 1-2-3.</P>

<P>Traditional Jet workspaces offer a set of advantages, which include 
the following:</P>

<UL>
<P><LI>
Updating data in recordset objects
</LI></P>

<P><LI>
Joining tables from different data sources into a common recordset
</LI></P>

<P><LI>
Creating tables based on familiar DAO methods instead of SQL 
Data Definition Language (DDL) conventions
</LI></P>

<P><LI>
Binding data to forms and reports
</LI></P>
</UL>

<P>Jet workspaces include <I>Groups </I>and <I>Users </I>collection objects, while ODBCDirect workspaces do not because remote database sources such as Microsoft SQL Server can manage their own security.</P>

<A NAME="40"><H2>ODBCDirect Workspaces</H2></A>

<P>ODBCDirect is a relatively new DAO technology that was introduced 
with Microsoft Office 97 and DAO 3.5. Because the security-related DAO objects 
are not used with remote ODBC data sources, and because other DAO objects 
work best with locally connected data sources, Microsoft created the 
ODBCDirect object model, which is available from a separate type of workspace. 
The ODBCDirect workspace offers fast, direct access to remote ODBC data 
sources (such as SQL Server) and can bypass Jet. You still get the richness of an object model without having to rely exclusively on SQL commands, as with SQL 
pass-through queries.</P>

<P>Some of the chief benefits of ODBCDirect workspaces are as follows:</P>

<UL>
<P><LI>
Use of remote data sources without loading the Jet engine
</LI></P>

<P><LI>
Asynchronous queries
</LI></P>

<P><LI>
Better access to remote database functionality, including cursors 
and stored procedures
</LI></P>

<P><LI>
Batch updating of remote sources from a local cache
</LI></P>

<P><LI>
Returning multiple result sets from a single query
</LI></P>
</UL>

<P>ODBCDirect workspaces have a richer cursor library than Jet 
workspaces, and they support dynamic as well as update batch cursors, which are not available in Jet workspaces. The dynamic cursor lets a session view changes 
made to a database by other users without having to requery the data source. 
The batch update cursor permits asynchronous updates to a remote data source. 
This improves performance by removing the need for holding locks on records.</P>

<P><DIV CLASS="NOTE"><BLOCKQUOTE>
<B>NOTE</B><HR>
Cursors define the type and location of access to a data 
source. Several data source properties can go into defining a cursor. For 
example, cursors can be updatable or not. They can permit forward-only 
movement or bidirectional navigation. Cursors can automatically update to reflect edits and other database modifications or they can require an explicit 
refresh operation to show the most recent version of a database. You can 
designate a cursor that works on a remote database server or on a local 
workstation.
</blockquote></div></p>

<P>You can enjoy the best of both workspaces by having multiple workspaces of both types open at the same time. Using concurrent, multiple workspaces, you can benefit from the simplicity of bound forms with data that originates 
in an ODBCDirect workspace. You simply use the returning records in a Jet workspace.</P>

<A NAME="41"><H2>Objects Common to Jet and ODBCDirect Workspaces</H2></A>

<P>Within both types of workspaces, DAO objects generally follow a 
hierarchical organization. Figure 2-1 shows the hierarchy of DAO collections and objects in Jet workspaces, and Figure 2-2 shows the hierarchy of DAO collections and objects in ODBCDirect workspaces.</P>

<P><A HREF="javascript:fullSize('F02QH01x.htm')"> <img src="Images/F02qh01.JPG" width=404 height=416 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 2-1.</B> <I>DAO collections and objects for Jet workspaces.</I><!-- /CAPTION -->
</P>

<P><A HREF="javascript:fullSize('F02QH02x.htm')"> <img src="Images/F02qh02.JPG" width=404 height=255 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 2-2.</B> <I>DAO collections and objects for ODBCDirect workspaces.</I><!-- /CAPTION -->
</P>


<A NAME="42"><H3>The <I>DBEngine</I> object</H3></A>
<P>The top-level DAO object for both workspaces is <I>DBEngine</I>. You use its <I>CreateWorkspace </I>method to open a session. An optional <I>Type </I>argument for the method lets you designate either a Jet workspace or an ODBCDirect workspace. You can also set the <I>DefaultType </I>property of the <I>DBEngine </I>object so that either type of workspace opens in the absence of a specific <I>CreateWorkspace Type </I>setting. The Jet workspace type is the native default. Any setting for the <I>CreateWorkspace Type </I>argument overrides either a native or an explicitly set <I>DefaultType </I>property.</P>

<P>The <I>DBEngine </I>properties and methods available to both workspace 
types provide a core set of DAO functions. You can use <I>DBEngine </I>to both create and manage databases.</P>

<P>The <I>CreateDatabase </I>method creates new workspaces, and you can 
use arguments for this method to set a database's sort order and encryption 
status. You can also set the version format for a database to programmatically 
create databases compatible with prior versions of Access. The <I>OpenDatabase </I>method opens an existing database in a workspace object. After you create a 
database, you can apply the <I>Compact </I>and <I>Repair </I>methods to manage the database.</P>

<P>DAO enables transaction processing through <I>DBEngine </I>with three methods: <I>BeginTrans</I>, <I>CommitTrans</I>, and <I>Rollback</I>. A transaction is a set of operations that occur in all-or-none fashion. If any link in a chain of database operations fails, you can roll back all the operations. For example, if a bank transfers money from a checking to a savings account, both the debit to checking and the credit to savings must be successful in order for the books to balance. If either part fails, the bank's code should roll back both parts. Transactions can also speed up database processing by batching sets of disk writes. You can nest transactions up to five levels deep.</P>

<P>Some of the properties and methods available depend on the type of workspace used. However, no matter which workspace you use, <I>DBEngine </I>contains the <I>Errors </I>and <I>Workspaces </I>collections.</P>

<A NAME="43"><H3>The <I>Errors</I> collection</H3></A>
<P>You use the <I>Errors </I>collection to process data access errors. The 
<I>Errors </I>collection contains one or more error numbers and descriptions from the last failed statement. Multiple errors from a single failure are common with ODBC data sources because different ODBC layers can each report an error for the same failure, such as a remote database source that is not operational.</P>

<P>The <I>Errors </I>collection, like other DAO collections, is zero-based. Its 
<I>Count </I>property denotes the number of errors in a collection, and the individual errors have item numbers of 0 through <I>Count</I> -1. The last entry in the <I>Errors </I>collection corresponds to the Microsoft Visual Basic for Applications (VBA) <I>Err </I>object. As you debug your applications, you might find it helpful to enumerate the <I>Errors </I>collection to simplify your search for the source of an error or the solution to an error.</P>

<A NAME="44"><H3>The <I>Workspaces</I> collection</H3></A>
<P>You use the properties and methods of the <I>Workspaces 
</I>collection to reference individual workspace sessions. Because the 
<I>Workspaces </I>collection is always available, Access can maintain multiple sessions concurrently and your applications can open and manage any combination of Jet and ODBCDirect workspaces. While these sessions do not persist beyond a logon session, they can exist for a whole session. You can use the <I>CreateWorkspace </I>method's <I>Name </I>argument to uniquely reference individual workspaces within a collection using one of these formats:</P>

<UL>
<P><LI>
DBEngine.Workspaces (0)
</LI></P>

<P><LI>
DBEngine.Workspaces (&quot;Name&quot;)
</LI></P>

<P><LI>
DBEngine.Workspaces! [Name]
</LI></P>
</UL>

<P>All DAO objects have a similar referencing syntax to these examples. 
The first two styles listed above match ADO conventions. You should adopt one 
of these whenever possible to enhance your migration skills when you start 
coding in ADO.</P>

<P><I>Workspace </I>objects share several important methods with the 
<I>DBEngine </I>object, such as <I>CreateDatabase</I>, <I>OpenDatabase</I>, and 
<I>BeginTrans</I>. Other methods, such as <I>CreateUser</I> and <I>CreateGroup</I>, are unique to the <I>Workspace </I>object. These two methods help manage user-level security within a workspace.</P>

<A NAME="45"><H3>The <I>Databases</I> collection</H3></A>
<P>Within any workspace, you can programmatically open multiple databases. Using DAO with VBA offers a distinct advantage over the user interface that enables the opening of a single database at a time. You use variable names 
to reference database objects to speed access. This same approach enhances 
speed for many DAO objects.</P>

<P>The <I>Name </I>property of an individual database in a Jet workspace is the 
path to the database file. You reference the database for the current project in your VBA code with the <I>CurrentDb </I>function. Access also supports the 
alternative syntax of <I>DBEngine (0) (0)</I> to reference the current database. The <I>CurrentDb </I>syntax creates another instance of the current project's database, but the <I>DBEngine </I>syntax refers to the open copy of the current database. You can open database objects on nonJet data sources, such as ISAM databases (for example, dBASE or Microsoft FoxPro). While it is also possible to use an ODBC data source in this way, you generally get better performance by using an ODBCDirect workspace (as explained in the section &quot;<A HREF="ch02b.htm#52">ODBCDirect Workspace Objects</A>&quot;).</P>

<A NAME="46"><H3>The <I>Recordsets</I> collection</H3></A>
<P>A <I>Recordset </I>object represents the records in a table or those resulting from a row-returning query. You create new recordsets using the 
<I>OpenRecordset </I>method. You can invoke this method from several objects, including both databases and <I>TableDef</I> objects, to create a recordset. Other objects that have an <I>OpenRecordset </I>method include <I>QueryDef 
</I>objects and even other recordsets. This method adds a new recordset to the 
<I>Recordsets </I>collection. You can create five types of recordsets, as shown in the following table.</P>

<P><B><I>Recordset </I>Objects</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Type</I></th>    
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top">Table</td>     
<td valign="top">This type refers to a record in a table, such as one you 
create using the <I>CreateTableDef </I>method. It always refers to a single Jet table. You can update the field values as well as add and delete records. There is no corresponding ODBC cursor.</td>
</tr>
<tr>
<td valign="top">Dynaset</td>    
<td valign="top">This type is a dynamic collection of records that can result from one or more tables. Selected fields might be updatable, so you can add, delete, and modify records. You use a field's <I>DataUpdatable </I>property to 
determine whether a field is updatable. In a multi-user database, you can view selected changes made by other users. This recordset type corresponds to the ODBC keyset cursor.</td>
</tr>
<tr>
<td valign="top">Snapshot</td>    
<td valign="top">With this type, you can examine records based on oneor more tables, but you cannot change the underlying records. Once you load a snapshot into memory, it does not reflect any further modifications to the underlying tables. This recordset type corresponds to the ODBC static cursor.</td>
</tr>
<tr>
<td valign="top">Forward-only</td>    
<td valign="top">This type is identical to the snapshot-type recordset, except that you can scroll forward only. This type corresponds to an ODBC forward-only cursor.</td>
</tr>
<tr>
<td valign="top">Dynamic</td>
<td valign="top">This type represents a query result based on one or more underlying tables. Users can update the recordset by adding, deleting, and modifying records. This type also shows changes made by other users in a multi-user environment. It is available only in ODBCDirect workspaces and 
corresponds to the ODBC dynamic cursor.</td>
</tr></table></p>

<P><b>The <I>OpenRecordset</I> method</b> The <I>OpenRecordset </I>method requires a source argument that specifies the source of the resulting recordset. As mentioned, this is typically a table name, a query name, or a SQL statement. You can also specify the recordset type; if you don't, DAO returns a table, dynaset, or forward-only type, depending on the source.</P>

<P>An options argument lets you specify any of several recordset characteristics, such as prohibiting users from reading or writing to the recordset. A final argument lets you set the <I>LockEdits</I> property for a recordset. This property indicates the type of locking that is in effect when an application revises, adds, or deletes records from a recordset. With Jet workspaces, your settings for this final argument are likely to be read-only, pessimistic locks, and optimistic locks. With a read-only setting, no recordset revisions are possible. With pessimistic locks, invoking the <I>Edit </I>method locks the page containing the record. With optimistic locks, other users can revise the record until your application invokes the <I>Update </I>method. This can yield a faster-performing recordset, but it can also lead to conflicting updates.</P>

<P><b><I>Recordset</I> methods</b> You can modify the records in a recordset using 
the <I>Edit</I>, <I>AddNew</I>, <I>Update</I>, and <I>Delete </I>methods. You use the <I>Edit </I>and <I>Update </I>methods together to revise the values in a recordset. The <I>Edit </I>method opens a record for editing, and the 
<I>Update </I>method commits the new values to the recordset's underlying tables. The <I>AddNew </I>and <I>Update </I>methods operate as a team. You signal that your code will be adding a record by invoking the <I>AddNew </I>method. You save the new record with the <I>Update </I>method. The <I>Delete </I>method removes the current record from a recordset. After you delete a record, that record remains current until you navigate to a new record. The <I>Delete </I>method does not require the <I>Update </I>method.</P>

<P>You can use a set of <I>Move </I>methods to navigate a recordset once you 
add it to the <I>Recordsets </I>collection. The <I>MoveNext </I>and <I>MovePrevious </I>methods navigate forward and backward one record. If you are already at the first record and your application invokes the <I>MovePrevious </I>method, DAO returns a BOF marker from the recordset. You can use this marker to flag a movement beyond the first record. Similarly, DAO returns an EOF marker when an application invokes the <I>MoveNext </I>method from the last record. Any attempt to move beyond either the BOF or EOF markers generates a run-time error. The <I>Move </I>method lets you specify a fixed number of rows to move. You can also designate a starting position other than the current record. The <I>MoveFirst </I>and <I>MoveLast </I>methods move directly to the first and last record in a recordset, respectively. With very large recordsets, there might be a significant pause until you reach the last 
record in a recordset.</P>

<P>Another set of methods navigates to a new record that meets specified criteria. These methods are <I>FindFirst</I>, <I>FindLast</I>, <I>FindNext</I>, and <I>FindPrevious</I>. You designate the criteria for a <I>Find </I>method with the same syntax as the WHERE<I> </I>clause in a SQL statement. If no records meet the specified criteria, these methods set the recordset's <I>NoMatch </I>property to True. Otherwise, they simply move to the record that meets the criteria. Both <I>FindNext </I>and <I>FindPrevious </I>move from the current record. <I>FindFirst </I>and <I>FindLast </I>search from the first or last records, respectively. When you work with <I>TableDef </I>objects, the <I>Seek </I>method can yield faster results than the <I>Find </I>methods. In general, you get better search performance using SQL statement searches in <I>OpenRecordset </I>methods. With <I>Find</I>, <I>Move</I>, and <I>Seek </I>methods, it is often desirable to set a recordset's <I>Index </I>property so that you can put the records in the precise order designated by the index fields.</P>

<A NAME="47"><H2>Jet Workspace Objects</H2></A>

<P>Database objects in Jet workspaces hold and can activate selected elements 
of a database schema. For example, you can open recordsets for manipulation 
or you can run action queries that update, append, or delete records. Database methods also let you create and manage replicas. The five hierarchical 
collections for a database are listed below. The <I>Database</I> object has methods for adding new elements to all of these collections.</P>

<UL>
<P><LI>TableDefs</LI></P>
<P><LI>Recordsets</LI></P>
<P><LI>QueryDefs</LI></P>
<P><LI>Relations</LI></P>
<P><LI>Containers</LI></P>
</UL>

<A NAME="48"><H3>The <I>TableDefs</I> collection</H3></A>
<P>The <I>TableDefs </I>collection accesses the individual <I>TableDef</I> objects within a database. <I>TableDef </I>objects contain <I>Fields </I>and <I>Indexes </I>collections, so you can define a table using a <I>TableDef </I>object. You use <I>CreateField </I>and <I>CreateIndex </I>methods to compose the definition of a table. When you use the <I>CreateField </I>method, you first specify your field by designating its name, type, and size. Then you invoke the <I>Append </I>method to add your new field to the <I>Fields </I>collection for a <I>TableDef </I>object. If a collection already contains afield with the name you designate as an argument, your code generates a trappable run-time error. You can use this to manage your <I>TableDef</I> object by, for example, removing the old field with the <I>Delete </I>method.</P>

<P>When you create indexes, you invoke the <I>CreateIndex </I>method and append one or more fields to the index. Then you append the new index to the <I>Indexes </I>collection for the <I>TableDef</I> object. If an index already exists with the name you specify, a run-time error occurs. You can use these errors to manage the process of indexing a <I>TableDef</I> object.</P>

<P>The <I>TableDef </I>object can also manage links to tables in ISAM and 
ODBC data sources. Your code requires the <I>Connect </I>and <I>SourceTableName </I>properties and the <I>CreateTableDef </I>methods for this activity. You invoke the <I>CreateTableDef </I>method to set a reference in a variable to the linked table. Then you set the <I>Connect </I>and <I>SourceTableName </I>properties for the variable. The <I>Connect </I>property specifies the data source type, such as dBase 5.0 or Paradox 5.<I>x</I>, and the path to the specific data source that you want to link. The <I>SourceTableName </I>property is the table name that you link. After setting these properties for the variable referencing the linked table, you complete the process by appending the <I>TableDef </I>object to the <I>TableDefs </I>collection.</P>

<A NAME="49"><H3>The <I>QueryDefs</I> collection</H3></A>
<P>The <I>QueryDefs </I>collection stores the individual <I>QueryDef </I>objects in a database. A <I>QueryDef </I>object is a SQL statement that typically returns a row set or performs an action, such as updating, adding, or deleting records in a recordset. When the SQL statement for a <I>QueryDef </I>object returns rows, it can have a <I>Fields </I>collection of individual fields. If your SQL statement accepts arguments that specify its criteria at run time, a <I>QueryDef </I>object can have a <I>Parameters </I>collection. 
When the <I>QueryDef</I> object runs, you can specify these parameters programmatically or at run time by means of a dialog box.</P>

<P>You can create new <I>QueryDef </I>objects using the <I>CreateQueryDef </I>method for either the <I>Database</I> object in the Jet workspace or the 
<I>Database</I> or <I>Connection</I> object in an ODBCDirect workspace. If you name the <I>QueryDef</I> object a non-zero-length string, DAO automatically enters it in the <I>QueryDefs </I>collection and saves the <I>QueryDef 
</I>object to disk for permanent storage along with the database. Use the <I>Delete </I>method to remove an item from the <I>QueryDefs </I>collection. Any <I>Querydef </I>object created with a <I>Name </I>property equal to a zero-length string is temporary. DAO does not persist these. Temporary 
<I>QueryDef</I> objects are convenient when your applications need to create 
<I>QueryDef </I>objects dynamically.</P>

<P>Two methods allow you to activate a <I>QueryDef</I> object. The <I>OpenRecordset </I>method returns the rows in a <I>QueryDef</I> object with a SELECT<I> </I>statement, while the <I>Execute </I>method runs an action query. The <I>dbFailOnError </I>option can allow your application to determine whether a <I>QueryDef</I> object fails to perform its designated action for all records that meet its criteria. As long as a <I>QueryDef </I>object is syntactically correct, it does not generate an error-even if it fails to perform its action. The <I>dbFailOnError </I>option rolls back any changes if the <I>QueryDef</I> object cannot perform all the changes. This option also generates a run-time error to help you perform any associated processing, such as providing feedback to a user.</P>

<A NAME="50"><H3>The <I>Relations</I> collection</H3></A>
<P>You use the <I>Relations </I>collection and its individual relations to define links between tables programmatically. The <I>CreateRelation </I>method for the <I>Database </I>object can initially specify relations; it lets an application define one-to-one or one-to-many relations between any pair of tables. This method can also designate referential integrity as well as cascading deletes and updates. (See <a href="ch04a.htm">Chapter 4</a> for an in-depth discussion of these terms.) You define relations between tables based on common fields in both tables. The <I>Relation </I>object has a <I>Fields </I>collection to support this function. The <I>Relations </I>collection and individual <I>Relations </I>objects are unique to the Jet workspaces. They are unavailable 
in ODBCDirect workspaces because remote database engines typically maintain their own relations between tables.</P>

<A NAME="51"><H3>The <I>Containers</I> collection</H3></A>
<P>The <I>Containers </I>collection defines a set of container objects for database documents. Some of the container objects follow from the Database window: <I>Forms</I>, <I>Reports</I>, <I>Scripts for Macros</I>, and <I>Modules</I>. These are all Access objects, not Jet database objects. Other container objects are Jet-based, including <I>Databases</I>, <I>Tables</I>, and 
<I>Relationships</I>. The <I>Tables </I>container object includes information about both tables and queries. There is an additional container object for 
saved relationship layout information.</P>

<P>Container objects hold documents, which consist of all saved elements 
of a type, such as forms or relationships. These documents provide 
administrative, not content, information about the objects in a container object. Selected properties for documents include the date created and the date last updated as well as the owner, user, and permissions. Jet uses the information in documents to manage security for Access objects as well as its own native tables and queries.</P>

<P>It is important to understand that the documents in container objects 
are different from the elements in a collection. Documents consist of all 
saved objects-whether or not they are open. Collections are groups of objects that are open. If an object is not open, it is not part of a collection. However, it can belong to a container object. Also, documents hold administrative information about objects, but elements in a collection have information about the content, layout, and subelements of the objects of a collection.</P>

<P>The <I>Users </I>and <I>Groups </I>collections each have their matching objects. These collections and objects complement the container documents to help Jet manage user-level security. Documents have permissions. Users belong to groups. Document permissions describe levels of access by users and groups. 
Chapter 10 includes detailed coverage of user-level security, including users, groups, and permissions.</P>

<A NAME="52"><H2>ODBCDirect Workspace Objects</H2></A>

<P>By comparing Figure 2-2 with Figure 2-1, you can see that 
the ODBCDirect model is much more parsimonious because ODBCDirect workspaces hand over to remote database servers some of the functions that Jet manages. For example, remote database servers manage their own security, so <I>Users</I> and <I>Groups</I> collections aren't needed. There is also no <I>TableDefs</I> collection because remote database servers manage their own tables. The story 
is similar for relations.</P>

<P>The two workspace models are different in other ways. The ODBCDirect model has a new <I>Connections </I>collection with its corresponding objects. 
Also, in the ODBCDirect model the role of the <I>Database </I>object is different, and <I>QueryDef </I>objects do not have a <I>Fields </I>collection. You can derive a <I>Recordset </I>object from a <I>QueryDef </I>object via the 
<I>OpenRecordset </I>method.</P>

<P>Although both workspaces have a <I>Database </I>object, it behaves somewhat differently in the ODBCDirect workspace than it does in the Jet workspace. 
In the ODBCDirect workspace, that object has a <I>Connect </I>property that returns a reference to a <I>Connection</I>. The <I>Connection </I>object has a 
<I>Database </I>property that returns a reference to a <I>Database </I>object. In DAO models, <I>Connection </I>and <I>Database </I>objects are different ways of referencing the same thing. These properties simplify migration from Jet workspace models to ODBCDirect workspaces and back again.</P>

<A NAME="53"><H3>The <I>Connections</I> collection</H3></A>
<P>The <I>Connections </I>collection of a workspace and its objects are critical when you work with remote databases. In ODBCDirect workspaces, you use 
the <I>OpenConnection </I>method to establish a connection to a remote database. You need as many as four arguments, three of which are optional. The one required argument is the name. Naming a connection adds it to the 
<I>Connections </I>collection. The other three arguments define the nature of the connection. Since these are optional arguments, you can designate them when you create the connection or later. However, you must define a connection before you can use it to extract data or otherwise work with the data in a remote data source. One key remaining argument is the <I>Connect </I>argument that sets the <I>Connect </I>property of the <I>Connection </I>object. You use the <I>Connect </I>argument to specify the connection string. It starts with 
<I>ODBC </I>and a semicolon followed by other connection information needed to link to the remote data source. This can include a DSN and a database name and is also likely to include a user ID and corresponding password. You delimit each type of information with a semicolon. Your application can examine and reset the connection string through the <I>Connect </I>property of a <I>Connection </I>object.</P>

<P>A second optional<I> OpenConnection </I>parameter controls two distinct types of behavior: how a connection reacts to incomplete connection string information and how to open a connection asynchronously. In the case of 
incomplete connection string information, you can let the connection fail and 
generate a run-time error or you can trap the error and prompt for 
complete information. You can also use this parameter to designate that a connection is to open asynchronously. The application can open a connection and then go on to other tasks. Your Access application can serve the local user by 
opening forms or even interacting with the user. At the same time, the remote 
database server processes the request for a new connection. With the <I>Connection </I>object's <I>StillExecuting </I>property, your application can poll the connection to determine when it is available for use.</P>

<P>The <I>Connection </I>object has five methods:</P>

<UL>
<P><LI><I>OpenRecordset</I> This method returns a set of rows from a 
remote data source. It has more features in an ODBCDirect workspace 
than in a Jet workspace. Perhaps the most profound difference is 
that, when using this method in an ODBCDirect workspace, you 
can specify more than one SQL statement so that a single <I>OpenRecordset </I>statement can provide multiple recordsets for local use.
</LI></P>

<P><LI><I>Close</I> This method closes an open connection.
</LI></P>

<P><LI><I>CreateQueryDef</I> This method also has additional features in an ODBCDirect workspace. Perhaps the most obvious is that <I>QueryDef </I>objects do not have fields. If you want to view the rows returned by a row-returning <I>QueryDef </I>object, you invoke the <I>OpenRecordset </I>method for the object. All 
<I>QueryDef</I> objects in ODBCDirect workspaces are temporary. In the ODBCDirect object model, you cannot create stored procedures in a remote data source. <I>QueryDef </I>objects can belong only to <I>Connection </I>objects. There is no <I>CreateQueryDef </I>method for <I>Database </I>objects in an ODBCDirect workspace, as there is in a Jet workspace. You can open a <I>Recordset </I>object from a <I>Database </I>object in either kind of workspace.
</LI></P>

<P><LI>
<I>Execute</I> This method runs action, parameter, and select 
queries. You designate the <I>dbRunAsync </I>constant to specify that a 
<I>QueryDef </I>object should run asynchronously. Just as for the 
<I>OpenConnection </I>method, users can perform other tasks simultaneously as 
the <I>QueryDef</I> object runs. The <I>StillExecuting 
</I>property enables an application to check on the completion status of the 
<I>QueryDef</I> object.
</LI></P>

<P><LI>
<I>Cancel</I> This method terminates an asynchronous query. It returns a run-time error if you invoke it without specifying asynchronous operation. You free the resources consumed by a <I>QueryDef </I>object by applying the <I>Close </I>method or by setting the <I>QueryDef</I> object reference to Nothing.
</LI></P>
</UL>

<A NAME="54"><H3>Batch updating</H3></A>

<P>One of the more powerful innovations in ODBCDirect workspaces is batch updating, which enables an application to download a set of records, perform updates locally, and then update the original as a single batch instead of one record at a time. Batch updating has obvious concurrency advantages over single-record locking. Because of the potential for conflicts, it is best used when a database is unlikely to be changed by multiple users. However, some 
features for handling collisions are built into batch processing. For example, 
a <I>BatchCollisions </I>property returns bookmarks that point at collisions in a recordset after you upload the recordset. You can also force a remote database to match your update or accept the value in the remote data source. Three <I>Field </I>properties let you examine the original value before downloading, the updated value in the local recordset version, and the new field value in the remote data source.</P>

<P>There are five steps to implementing batch updating in an ODBCDirect workspace:</P>

<OL>
<P><LI>
Set the <I>DefaultCursorDriver</I> property for the workspace 
to <I>dbUseClientBatchCursor</I>.
</LI></P>

<P><LI>
Create a <I>Connection</I> object or a <I>Database</I> object.
</LI></P>

<P><LI>
Invoke the <I>OpenRecordset</I> method for the object from step 2 with 
a <I>dbOptimisticBatch</I> setting for the <I>LockEdits</I> argument.
</LI></P>

<P><LI>
Edit the fields locally as needed.
</LI></P>

<P><LI>
Invoke the <I>Update</I> method for the recordset from the third step 
with a <I>dbUpdateBatch</I> setting for the type argument. If you have no 
collisions, you are done. If there are collisions, you need additional 
logic to reconcile them.
</LI></P>
</OL>

</BODY>
</HTML>





