<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Creating and Managing Tables Programmatically</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch03d.htm", "ch04a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="98"><H1>Creating and Managing Tables Programmatically</H1></A>

<p>Sometimes&#8212;perhaps even most of the time&#8212;you will create tables manually. However, on occasion you might find it convenient to create a table dynamically, such as when you need to persist intermediate results for reuse in a subsequent operation. Access 2000 lets you do this using ADO techniques as well as the more traditional Data Access Objects (DAO) techniques. This section describes how to create and manage tables using ADO techniques. Once you learn this approach, you'll be able to take advantage of upcoming innovations in Microsoft data access technology.</P>


<p>After creating a table programmatically, you will often want to 
populate it with data. Even if you do not create a table programmatically, populating it with data programmatically has appeal. You can use many different data sources for populating an Access table. This section explores using another Access table, an Excel table (as an example of an ISAM data source), and an ODBC data source. You'll also learn how to populate an Access table using OLE database (OLE DB) providers and the native Access <I>DoCmd</I> object, which makes it easy to link to remote data sources. Unlike using OLE DB, using <I>DoCmd</I> makes the linked data source available from the Database window.</P>


<A NAME="99"><H2>Creating a Table </H2></A>


<p>To add tables dynamically, all you need is ADO&#8212;the ADOX library, to be specific. Just as when you manually create a table in a database, when you create a table dynamically you must name it, add columns to it, and append it to the <I>Tables</I> collection.</P>


<p>The <I>MakeLocalTable</I> procedure below creates a table dynamically. It starts by declaring the <I>Catalog</I> object and the <I>Table</I> object. The <I>Catalog</I> object is a container for the database schema, including the <I>Tables</I> collection. Next, the procedure instantiates the <I>Catalog</I> and <I>Table</I> objects. It names the new 
table <I>FamilyMembers2</I> and assigns four columns to it using four 
<I>Append</I> methods nested inside a <I>With...End</I> statement. Each <I>Append</I> method includes a column name, a constant specifying a data type, and a length argument, if appropriate. The three Text fields (those created by specifying the <I>adVarWChar </I>data type) each have a field size specification. The procedure ends by appending the 
completed table to the catalog's <I>Tables</I> collection and closing the 
<I>Catalog</I> object.</P>


<p><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>Sub MakeLocalTable()
Dim cat1 As ADOX.Catalog
Dim tbl1 As ADOX.Table

'Reference objects for table
    Set cat1 = New Catalog
    cat1.ActiveConnection = CurrentProject.Connection
    Set tbl1 = New Table

'Name table and append columns.
    With tbl1
        .Name = &quot;FamilyMembers2&quot;
        .Columns.Append &quot;FamID&quot;, adInteger
        .Columns.Append &quot;Fname&quot;, adVarWChar, 20
        .Columns.Append &quot;Lname&quot;, adVarWChar, 25
        .Columns.Append &quot;Relation&quot;, adVarWChar, 30
    End With

'Append new table to Tables collection
'and free catalog resource.
    cat1.Tables.Append tbl1
    Set cat1 = Nothing

End Sub
</pre>
</TD></TR></TABLE></P>


<p>The following table lists the data type and subtypes represented by 
the ADOX library's <I>DataTypeEnum </I>class constants.</P>


<p>
<b>Column Type Constants and Their Manual Data Type Equivalents</b></p>

<p><table cellpadding=5 width="95%"><tr>
<th valign="top"><i>Constant</i></th>
<th valign="top"><i>Value</i></th>    
<th valign="top"><i>Manual Data Type</i></th>
</tr>
<tr>
<td valign="top"><i>adBoolean</i></td>
<td valign="top">11</td>
<td valign="top">Yes/No</td>
</tr>
<tr>
<td valign="top"><i>adCurrency</i></td>
<td valign="top">6</td>
<td valign="top">Currency</td>
</tr>
<tr>
<td valign="top"><i>adDate</i></td>
<td valign="top">7</td>
<td valign="top">Date/Time</td>
</tr>
<tr>
<td valign="top"><i>adDecimal</i></td>
<td valign="top">14</td>
<td valign="top">Number&#8212;Decimal</td>
</tr>
<tr>
<td valign="top"><i>adDouble</i></td>
<td valign="top">5</td>
<td valign="top">Number&#8212;Double</td>
</tr>
<tr>
<td valign="top"><i>adGuid</i></td>
<td valign="top">72</td>
<td valign="top">Number&#8212;Replication ID</td>
</tr>
<tr>
<td valign="top"><i>adInteger</i></td>
<td valign="top"> 3</td>
<td valign="top"> AutoNumber</td>
</tr>
<tr>
<td valign="top"><i>adInteger</i></td>
<td valign="top">3 </td>
<td valign="top"> Number&#8212;Long Integer</td>
</tr>
<tr>
<td valign="top"><i>adLongVarBinary</i></td>
<td valign="top">205</td>
<td valign="top">OLE Object</td>
</tr>
<tr>
<td valign="top"><i>adLongVarWChar</i></td>
<td valign="top">203</td>
<td valign="top">Hyperlink</td>
</tr>
<tr>
<td valign="top"><i>adLongVarWChar</i></td>
<td valign="top">203</td>
<td valign="top">Memo</td>
</tr>
<tr>
<td valign="top"><i>adSingle</i></td>
<td valign="top">4</td>
<td valign="top"> Number&#8212;Single</td>
</tr>
<tr>
<td valign="top"><i>adSmallInt</i></td>
<td valign="top">2</td>
<td valign="top"> Number&#8212;Integer</td>
</tr>
<tr>
<td valign="top"><i>adUnSignedTinyInt</i></td>
<td valign="top"> 17  </td>
<td valign="top">Number&#8212;Byte</td>
</tr>
<tr>
<td valign="top"><i>adWChar</i></td>
<td valign="top">130 </td>
<td valign="top">Text</td>
</tr>
</table></P>


<p>The table shows a couple of interesting points. First, the Hyperlink 
data type is equivalent to the Memo data type from a programming 
perspective. Second, there is no distinct data type for AutoNumber fields in the ADOX library. If your code checks the <I>Type</I> property of an AutoNumber field, you get the value <I>adInteger</I>. This value does not reflect the dynamic nature of the AutoNumber data type. Jet 4, however, does have a distinct data type, Identity, that corresponds to the AutoNumber data type. (See <a href="ch02a.htm">Chapter 2</a> for more on using this data type.) Also, the &quot;<A HREF="ch03d.htm#86">Creating Tables Manually</A>&quot; section earlier in this 
chapter mentions more keywords for programmatically managing AutoNumber fields.</P>


<A NAME="100"><H3>Avoiding replacing a table</H3></A>

<p>When you add a table to a database manually, it is easy to check whether a table name already exists. If you inadvertently try to save a table with the name of an existing table in the database, Access warns you and asks if you want to overwrite the existing table. When you create a table programmatically, however, Access VBA halts with a run-time error when a procedure attempts to create a new table that has the name of an existing table. Therefore, you need error trapping to handle this situation. There are at least a couple of approaches to this task. The one that makes the most sense depends on the frequency with which you will be creating new tables.</P>


<p>The <I>MakeLocalTableErrCatcher</I> procedure below uses a classic error 
trapping approach. First, it enables a custom error handling routine so that the program can manage errors. The <I>On Error</I> statement at the beginning of the procedure accomplishes this. Next, it attempts to create and append the same <I>FamilyMembers2</I> table as in the 
<I>MakeLocalTable</I> procedure. If the table already exists in the catalog, the Access VBA generates an error (-2147217857) and transfers control to the <I>TableErrCatcher</I> error handling routine. The error 
trapping logic checks for the &quot;already exists&quot; error. If it detects that error, it deletes the existing table and returns control to the line that caused the error. This allows the program to save the new table and exit the procedure normally. If another error causes a visit to the error handling routine, the routine prints the error's number and description to the Immediate window before gracefully exiting the procedure. The procedure never ends abnormally with a system message.</P>


<p><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>Sub MakeLocalTableErrCatcher()
On Error GoTo TableErrCatcher
Dim cat1 As ADOX.Catalog
Dim tbl1 As ADOX.Table

'Reference objects for table
    Set cat1 = New Catalog
    cat1.ActiveConnection = CurrentProject.Connection
    Set tbl1 = New Table

'Name table and append columns.
    With tbl1
        .Name = &quot;FamilyMembers2&quot;
        .Columns.Append &quot;FamID&quot;, adInteger
        .Columns.Append &quot;Fname&quot;, adVarWChar, 20
        .Columns.Append &quot;Lname&quot;, adVarWChar, 25
        .Columns.Append &quot;Relation&quot;, adVarWChar, 30
    End With

'Append new table to Tables collection
'and free catalog resource.
    cat1.Tables.Append tbl1
    Set cat1 = Nothing
    
'Exit the procedure.
TableErrExit:
    Exit Sub
    
    TableErrCatcher:
'Trap &quot;table already exits&quot; error.
'Delete table and resume.
    If Err.Number = -2147217857 Then
        cat1.Tables.Delete &quot;FamilyMembers2&quot;
        Resume
    End If
'Print details for other errors and exit.
    Debug.Print Err.Number, Err.Description
    Resume TableErrExit

End Sub
</pre>
</TD></TR></TABLE></p>

<A NAME="101"><H3>Replacing a table</H3></A>


<p>If the database application regularly creates the 
<I>FamilyMembers2</I> table, the procedure can generate the &quot;already exists&quot; error nearly every time it runs. 
In this situation, your procedure will run faster if you try to delete the existing 
table before appending the new one. This generally avoids the need to process 
an error. You still need an error handler for when the table does not already 
exist or when another condition generates an error. The following procedure 
writes the error handler when you unconditionally delete a table with the same 
name as the one that you are about to append to the database.</P>


<p><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>Sub MakeLocalTableErrCatcher2()
On Error GoTo TableErrCatcher
Dim cat1 As ADOX.Catalog
Dim tbl1 As ADOX.Table

'Reference objects for table
    Set cat1 = New Catalog
    cat1.ActiveConnection = CurrentProject.Connection
    Set tbl1 = New Table

'Name table and append columns.
    With tbl1
        .Name = &quot;FamilyMembers2&quot;
        .Columns.Append &quot;FamID&quot;, adInteger
        .Columns.Append &quot;Fname&quot;, adVarWChar, 20
        .Columns.Append &quot;Lname&quot;, adVarWChar, 25
        .Columns.Append &quot;Relation&quot;, adVarWChar, 30
    End With
    
'Delete the old table (if it is there).
'Append the new one, and free the resource.
    cat1.Tables.Delete &quot;FamilyMembers2&quot;
    cat1.Tables.Append tbl1
    Set cat1 = Nothing
    
'Exit the procedure.
TableErrExit:
    Exit Sub
    
TableErrCatcher:
'Trap &quot;object not in collection&quot; error.
'Resume at next line.
    If Err.Number = 3265 Then
        Resume Next
    End If
'Print details for other errors and exit.
    Debug.Print Err.Number, Err.Description
    Resume TableErrExit

End Sub
</pre>
</TD></TR></TABLE></P>


<p>The 3265 error mentioned in 
<I>MakeLocalTableErrCatcher2</I>'s error handling routine results when you attempt to delete an object that is not in the 
collection. <I>MakeLocalTableErrCatcher2</I> simply traps the error and resumes after the line that caused it. Any other error causes the program to end gracefully with the only trace being the error number and description in the Immediate window.</P>


<A NAME="102"><H2>Working with Indexes</H2></A>

<p>You can also add primary keys, indexes, and relationships 
programmatically. You can define primary keys and indexes across a single field or multiple fields.</P>


<A NAME="103"><H3>Creating a primary key</H3></A>

<p>Adding a primary key or an index to a table is similar to adding a new table to a catalog. First, you create a context to which to add the index, including a catalog and a table. Second, you define the index properties. These can differ between indexes and primary keys. Third, you append a column to the index and then append the new index to the table. If an error occurs, for example if the index already exists, you must respond appropriately. The <I>AddPK</I> procedure below dynamically creates a primary key.</P>


<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>Sub AddPK()
Dim cat1 As New ADOX.Catalog
Dim tbl1 As New ADOX.Table
Dim pk1 As New ADOX.Index

'Create a context for the new primary key.
    cat1.ActiveConnection = CurrentProject.Connection
    Set tbl1 = cat1.Tables(&quot;FamilyMembers2&quot;)

'Set the primary key properties.
    With pk1
        .Name = &quot;MyPrimaryKey&quot;
        .PrimaryKey = True
        .Unique = True
        .IndexNulls = adIndexNullsDisallow
    End With
    
'Append column to index and index to table.
    pk1.Columns.Append &quot;FamID&quot;
    tbl1.Indexes.Append pk1
    
'Free resources.
    Set cat1 = Nothing

End Sub
</pre>
</TD></TR></TABLE></P>


<p>The procedure begins by declaring and instantiating 
<I>Catalog</I>, <I>Table</I>, and <I>Index</I> objects. (You need all three objects to create a primary key.) Notice that there is no explicit object for a primary key. Next, the procedure sets the context for defining the new primary key. It sets the <I>ActiveConnection</I> property of the 
<I>Catalog</I> object to point the catalog at a specific database. Then it sets the table reference to a table within that database. This reference is the table to which your procedure will add the new primary key.</P>


<p>Next, the procedure sets four index properties. The first is the name 
of the primary key. It appears as an entry in the Index Name column in the 
table's Indexes window. The remaining three properties differentiate the primary key from a simple index. You should always set these properties as they appear in the <I>AddPK</I> procedure when you create a primary key.</P>


<p>
The procedure then invokes two <I>Append</I> methods. The first one 
appends the <I>FamID</I> column from the <I>FamilyMembers2</I> table to the index. The second one appends the index to the table. Finally, the procedure sets the <I>Catalog</I> object to <I>Nothing</I>, thereby freeing the resources used to create the primary key. </P>


<p>
It is often desirable to have an AutoNumber, Long Integer, or Text field as a primary key. These can be faster than a multiple field primary key. 
However, at times a multiple field index makes sense in terms of uniquely 
defining records and in terms of how you will use the data from the table. When a multiple key index is appropriate, you simply append more than one 
column to the index before you append the index to the table.</p>

<p>In the preceding example, you can replace the line</P>


<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>pk1.Columns.Append &quot;FamID&quot;
</pre>
</TD></TR></TABLE></P>


<p>with the lines</P>


<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>pk1.Columns.Append &quot;Lname&quot;
pk1.Columns.Append &quot;Fname&quot;
pk1.Columns.Append &quot;Relation&quot;
</pre>
</TD></TR></TABLE></P>


<p>These lines define a primary key on three fields instead of just one. 
The <I>AddPK</I> procedure generates a primary key based on a single field; the top Indexes window in Figure 3-14 shows the result of calling 
<I>AddPK</I>. The bottom Indexes window shows the result of calling 
<I>AddPK3</I>, which is identical to <I>AddPK</I> except for the code replacement shown above. (Both procedures are in 
the database for <a href="ch03a.htm">Chapter 3</a> on the companion CD.) Because you can have only 
one primary key at a time, you must manually remove the primary key 
between calling the <I>AddPK</I> and <I>AddPK3</I> procedures.</P>


<P><img SRC="Images/F03qh14.GIF" width=401 height=494 border=0>
</P><P><!-- CAPTION --><B>Figure 3-14.</B> <I>The Indexes windows after running the </I>AddPK<I> and </I>AddPK3<I> procedures.</I><!-- /CAPTION -->
</P>


<P>
The <I>AddPK</I> and <I>AddPK3</I> procedures can fail for any of several 
reasons. Two errors that the following <I>AddPKErr</I> procedure traps are an already existing primary key (-2147467259) and the table already being open (-2147217856). (As stated above, you cannot add a new primary key if one already exists; also, you cannot even modify the index structure if the table is open.)</P>


<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>Sub AddPKErr()
On Error GoTo PKErr
Dim cat1 As New ADOX.Catalog
Dim tbl1 As New ADOX.Table
Dim pk1 As New ADOX.Index
Dim iNumber As Integer

'Create a context for the new primary key.
    cat1.ActiveConnection = CurrentProject.Connection
    Set tbl1 = cat1.Tables(&quot;FamilyMembers2&quot;)

'Set the primary key properties.
'The label (SetPKvariable) gives the procedure a
'recovery point from a previously existing primary key.
SetPKvariable:
    With pk1
        .Name = &quot;MyPrimaryKey&quot;
        .PrimaryKey = True
        .Unique = True
        .IndexNulls = adIndexNullsDisallow
    End With

'Append column to index and index to table.
    pk1.Columns.Append &quot;FamID&quot;
    tbl1.Indexes.Append pk1

'Exit procedure.
PKErrExit:
    Set cat1 = Nothing
    Exit Sub

PKErr:
'Checks for table already in use
    If Err.Number = -2147217856 Then
        MsgBox &quot;FamilyMembers2 currently in use.  This&quot; &amp; _
            &quot; operation requires the table to be closed.&quot;
'Checks for primary key already exists
    ElseIf Err.Number = -2147467259 Then
        For Each pk1 In tbl1.Indexes
            If pk1.PrimaryKey = True Then
                tbl1.Indexes.Delete (iNumber)
                Resume SetPKvariable
            End If
            iNumber = iNumber + 1
        Next pk1
'Traps for other errors
    Else
        MsgBox &quot;Open Immediate window for Bug report&quot;
        Debug.Print Err.Number; Err.Description
        Resume PKErrExit
    End If

End Sub
</pre>
</TD></TR></TABLE></P>


<p>With a few exceptions for error trapping, the 
<I>AddPKErr</I> procedure follows the logic of the 
<I>AddPK</I> procedure in its main segment. 
<I>AddPKErr</I> first enables an error handling routine with an 
<I>On Error</I> statement. The declaration area includes a new 
<I>Dim</I> statement for an Integer variable. The error trapping 
logic uses this variable as an index in the loop that iterates through the 
Indexes collection of the table.</P>


<p> 
The error trapping logic in <I>AddPKErr</I> starts at the <I>PKErr</I> label. An <I>If...Then</I> statement initially tests for whether the table is open. If it is, the routine displays a message box that explains the problem and offers a solution before gracefully exiting. The <I>ElseIf</I> clause detects the existence of a primary key. In this 
case, the routine enumerates the indexes in the table until it detects the one with its <I>PrimaryKey</I> attribute set to <I>True</I>. Then it deletes that index and returns control to the initial step for defining a new primary key. This is necessary since the error wipes out the previous settings. If the table is not open and no primary key exists, the routine writes the error number and its description to the Immediate window before exiting the procedure. A message box tells the user to view the Immediate window for the cause of the error.</p>

<A NAME="104"><H3>Creating an index</H3></A>

<p>Adding a simple index to a table is not much different from adding a 
primary key. The major difference is that you do not set the <I>PrimaryKey</I> property to <I>True</I>. (It is <I>False </I>by default.) The <I>AddIdx</I> procedure below has a design similar to that of <I>AddPK</I>. Aside from not setting the primary key property, the major 
difference is that it explicitly assigns a sort order for the index. By instructing the table to sort on the <I>FamID</I> column values in descending order, the procedure makes the table show the most recent records first (assuming that records with a higher <I>FamID</I> value are added after earlier ones). When assigning the sort order, 
you must specify which number column it applies to. The numbering for 
columns is zero-based.</P>

<p><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>Sub AddIdx()
Dim cat1 As New ADOX.Catalog
Dim tbl1 As New ADOX.Table
Dim idx1 As New ADOX.Index

'Create a context for the new index.
    cat1.ActiveConnection = CurrentProject.Connection
    Set tbl1 = cat1.Tables(&quot;FamilyMembers2&quot;)

'Set the index properties.
    With idx1
        .Name = &quot;LastIsFirst&quot;
        .Unique = True
        .IndexNulls = adIndexNullsDisallow
    End With

'Append column to index and set its sort order.
'Append new index to table.
    idx1.Columns.Append &quot;FamID&quot;
    idx1.Columns(0).SortOrder = adSortDescending
    tbl1.Indexes.Append idx1
    
'Free resources.
    Set cat1 = Nothing

End Sub
</pre>
</TD></TR></TABLE></p>

<A NAME="105"><H2>Dynamically Populating a Table</H2></A>

<p>After you design a table and set its indexes, you populate it with values using one of two approaches. When the data for the table resides in another table, you can define recordsets on the data source table and the new table. Then you simply navigate through both recordsets in synchrony as you copy records to the new table using the <I>AddNew</I> method. (This approach loops through a recordset, so it is not appropriate for very large tables.) A second approach is to use SQL to insert values into the new table based on the values of the original table. This approach does not rely on recordsets or the 
<I>AddNew</I> method, but it does need at least one 
<I>Command</I> object.</P>


<A NAME="106"><H3>Using recordsets</H3></A>


<p>The first approach, illustrated in the following procedure, requires a 
<I>Connection</I> object and a <I>Catalog</I> object in addition to a pair of recordsets. The 
<I>Catalog</I> object and the two recordsets share a common 
<I>Connection</I> object. Because so many objects share a common connection, it makes sense to declare a 
<I>Connection</I> object and invoke it for each of the other objects that need it.</P>

<p><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>Sub AddValues()
Dim cnn1 As ADODB.Connection
Dim cat1 As New ADOX.Catalog
Dim rst1 As New ADODB.Recordset
Dim rst2 As New ADODB.Recordset

'Set context for populating new table (FamilyMembers2).
'Empty values from FamilyMembers2 before running.
    Set cnn1 = CurrentProject.Connection
    Set cat1.ActiveConnection = cnn1
    Set rst1.ActiveConnection = cnn1
'    Set rst2.ActiveConnection = cnn1

'Open recordsets based on new and original tables.
    rst1.Open &quot;FamilyMembers2&quot;, , adOpenKeyset, _
        adLockOptimistic, adCmdTable
    rst2.Open &quot;FamilyMembers&quot;, cnn1, adOpenForwardOnly, _
        adLockReadOnly, adCmdTable

'Loop through recordsets to copy from original to new table.
    With rst1
        Do Until rst2.EOF
            .AddNew
                .Fields(0) = rst2.Fields(0)
                .Fields(1) = rst2.Fields(1)
                .Fields(2) = rst2.Fields(2)
                .Fields(3) = rst2.Fields(3)
'            .Update
            .MoveNext
            rst2.MoveNext
        Loop
    End With

End Sub
</pre>
</TD></TR></TABLE></P>


<p>After declaring objects and assigning the connection to the other 
objects that will use it, the procedure opens recordsets on the table with the source records, <I>FamilyMembers</I>, and the new table, 
<I>FamilyMembers2</I>.</P>


<p>
The code above shows two approaches to assigning a connection to 
a recordset. You can assign a connection to a recordset's 
<I>ActiveConnection</I> 
property&#8212;<I>AddValue</I> uses this technique for 
<I>rst1</I>. Or you can reference a 
<I>Connection</I> object in the <I>Open</I> method for a recordset&#8212;the 
<I>Open</I> method for <I>rst2</I> uses this technique. You can use either approach with both recordsets. The 
<I>AddValues</I> procedure comments out a line that reveals how to set 
<I>rst2</I>'s <I>ActiveConnection</I> property with an assignment. If you use that technique for 
<I>rst2</I>, you can remove the reference to 
<I>cnn1</I> in the <I>Open</I> method for 
<I>rst2</I>.</P>


<p>
The <I>Do...Loop</I> statement that iterates through the records in 
<I>rst2</I> occurs inside of a 
<I>With...End</I> statement that references 
<I>rst1</I>. (Because there are so many references to 
<I>rst1</I> in the loop, this statement makes the code faster and 
much easier to read.) Within the loop, an 
<I>AddNew</I> method enables the assignment of the current record in 
<I>rst2</I> to <I>rst1</I>. The use of the 
<I>Update</I> method to complete the operation of the 
<I>AddNew</I> method is optional. (The sample shows it 
commented out of the procedure.) After adding the current record in 
<I>rst2</I> to <I>rst1</I>, the procedure advances one record in 
<I>rst2</I>. There is no need to advance in 
<I>rst1</I> since each iteration of the loop simply adds a new record to the end of 
<I>rst1</I>. The <I>Do</I> loop continues until it encounters an end-of-file (EOF) for 
<I>rst2</I>.
<A NAME="107"><H3>Saving a recordset</H3></A></P>


<p>After populating a recordset and its underlying table with values (and 
maybe even updating them), you can save a copy of the recordset using the 
new recordset <I>Save</I> method and its persistent file type, which uses a compact 
binary format. Access 2000 offers several ways to save and retrieve recordsets with 
this new format and a corresponding provider. The following procedures save 
a recordset, by using a client cursor, and then open it.</P>


<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>Sub SaveRST()
On Error GoTo SaveRSTErr
Dim rst1 As New ADODB.Recordset

'Open client cursor and recordset.
    rst1.CursorLocation = adUseClient
    rst1.Open &quot;FamilyMembers2&quot;, CurrentProject.Connection, _
        adOpenStatic, adLockBatchOptimistic

    rst1.Save &quot;c:\FamilyMembers3.adtg&quot;, adPersistADTG

SaveRSTExit:
    Exit Sub

SaveRSTErr:
'Trap file already exists error
    If Err.Number = -2147286960 Then
        Kill &quot;c:\FamilyMembers3.adtg&quot;
        Resume
    End If
'Exit for other errors.
    MsgBox &quot;View Immediate window for error diagnostics.&quot;, _
        vbCritical, &quot;Programming Microsoft Access 2000&quot;
    Resume SaveRSTExit

End Sub


Sub OpenSavedRST()
Dim rst1 As New ADODB.Recordset

'Open saved recordset file.
    rst1.Open &quot;c:\FamilyMembers3.adtg&quot;, &quot;Provider=MSPersist&quot;

'Print selected info to confirm retrieval.
    Debug.Print rst1.Fields(0).Name &amp; &quot; = &quot; &amp; _
        rst1.Fields(0).Value

End Sub
</pre>
</TD></TR></TABLE></P>


<p>The main part of the <I>SaveRST</I> procedure opens a client cursor and 
then places a recordset in it. Then it invokes the recordset's 
<I>Save</I> method. Persisting a recordset to a file is no more complicated than that. The ADTG 
(Advanced Data TableGram) file is minimal (just 1 KB on my system). This 
represents substantial savings over storing the recordset as a table in a database file.</P>


<p>If you regularly save a recordset after updates, the 
<I>Save</I> method will fail unless you delete the old filename or use a new name. Alternatively, you 
can trap the error, delete the old file version, and then invoke the 
<I>Save</I> method again. The error handling routine in 
<I>SaveRST</I> illustrates this technique.</P>


<p>You can open a saved recordset with just two lines of code, as 
demonstrated by <I>OpenSavedRST</I>. The first line declares and instantiates a 
<I>Recordset</I> object. The second line invokes the 
<I>Open</I> method for the recordset. Its source is the file saved by the 
<I>SaveRST</I> procedure, and its connection argument 
references the persistence provider that ships with Access 2000. A third line 
prints a field from the recordset to confirm that the information in the file is correct.
<A NAME="108"><H3>Using SQL</H3></A></P>


<p>To many developers, looping through a recordset one record at a time 
has the appeal of being concrete. It is easy to envision moving from one 
record to the next in <I>rst2</I> and adding individual records to 
<I>rst1</I>. However, it is more efficient to use SQL code to perform the same task. In addition, the SQL 
approach requires just a single <I>Command</I> object from the ADODB library. 
The looping approach relies on several objects from both the ADODB and 
ADOX libraries. If you are uncomfortable with writing SQL, you can use the 
Access visual query designer to get a first draft of the correct SQL syntax for a task, 
such as inserting records from one table into another. The following 
<I>AddValuesSQL</I> procedure demonstrates how compact the SQL approach can be. (In fact, if 
your application does not need to know how many records it adds, the SQL 
approach can be even shorter.)</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>Sub AddValuesSQL()
Dim cmd1 As ADODB.Command
Dim intRowsAdded As Integer
Dim str1

'Instantiate cmd1.
    Set cmd1 = New ADODB.Command

'Set the connection and text for cmd1
'before executing it.
    With cmd1
        .ActiveConnection = CurrentProject.Connection
        .CommandText = &quot;INSERT INTO FamilyMembers2 &quot; &amp; _
            &quot;SELECT FamilyMembers.* &quot; &amp; _
            &quot;FROM FamilyMembers;&quot;
        .CommandType = adCmdText
        .Execute intRowsAdded
    End With

'Report how many records cmd1 added.
    str1 = intRowsAdded &amp; &quot; rows were added to the table.&quot;
    MsgBox str1, vbInformation, &quot;Programming Microsoft Access 2000&quot;

End Sub
</pre>
</TD></TR></TABLE></P>


<p>The procedure begins by declaring and instantiating a 
<I>Command</I> object. It uses a 
<I>With...End</I> statement to simplify setting the object's properties 
and invoking its methods. The <I>With...End</I> code block begins by setting the 
<I>Command</I> object's <I>ActiveConnection</I> and 
<I>CommandText</I> properties. (The command text is always a SQL statement with this approach.) The block then sets 
the <I>CommandType</I> property to 
<I>adCmdText</I> to optimize performance. (Failing to 
set the <I>CommandType</I> property forces Access to resolve the type of 
<I>Command</I> object before it can process the command.) Finally, the block calls the 
<I>Execute</I> method with an optional argument, 
<I>intRowsAdded</I>. When the call to 
<I>Execute</I> returns, <I>intRowsAdded</I> contains the number of records the SQL statement 
affected. A subsequent message box statement uses 
<I>intRowsAdded</I> to report to the user the number of records that were added to the new table.
<A NAME="109"><H2>Working with Data in Other Formats</H2></A></P>


<p>In Chapter 2, you learned how to use the Jet 4 OLE DB provider to open 
the Northwind database from an application. You can use this technique to 
access the data in one Access database from any other Access database. The 
technique even works for data stored in other formats for which an OLE DB provider exists. Even when an OLE DB provider is not available, you can link to another database via DAO and access its information with all the ease of use and power of any linked data source.</P>


<P>You can use the Jet 4 provider to open an Excel data source. Figure 
3-15 shows a simple worksheet in an Excel workbook, named Customers.xls. 
Sheet1 contains a Customers range (see the Name Box) with information about 
customer ID, company name, contact name, and payment terms. The following procedure opens a range in an Excel 2000 workbook with Access 2000.</P>


<P><A HREF="javascript:fullSize('F03QH15x.htm')"> <img src="images/F03QH15.JPG" width=404 height=390 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 3-15.</B> <I>Access can easily work with the information in this Excel spreadsheet.</I><!-- /CAPTION -->
</P>


<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>Sub OpenPrintXLDataSource()
Dim cnn1 As New ADODB.Connection
Dim rst1 As Recordset

'Open and set recordset.
    cnn1.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Programming Access\Chap03\Customers.xls;&quot; &amp; _
        &quot;Extended Properties=Excel 8.0;&quot;
    Set rst1 = New ADODB.Recordset
    rst1.CursorType = adOpenKeyset
    rst1.LockType = adLockOptimistic
    rst1.Open &quot;customers&quot;, cnn1, , , adCmdTable

'Open recordset and print a test record.
    Do Until rst1.EOF
        Debug.Print rst1.Fields(0).Value, rst1.Fields(1).Value
        rst1.MoveNext
    Loop

End Sub
</pre>
</TD></TR></TABLE></P>


<p><I>OpenPrintXLDataSource</I> uses a 
<I>Connection</I> object to open an Excel workbook. The 
<I>Open</I> method for the <I>cnn1</I> object creates a connection to the 
worksheet file. The provider in this call is the same one used for Jet 4 files, the 
Extended Properties argument specifies a format compatible with Excel 2000 files, and 
the Data Source argument points to an Excel workbook in the My Documents 
folder of the C drive. The next four lines in the procedure create and open a 
reference to a recordset defined on the Customers range in the Customers.xls 
file. The <I>Do</I> loop at the end of the procedure prints the first two fields in the 
recordset to the Immediate window.</P>


<p>
After you open a recordset for an Excel data source, you can do 
anything that Access permits you to do with a record source, such as update field values. The difference is that your application updates values in a range on the Excel worksheet rather than those in an Access table. 
The <I>OpenPrintXLDataSource</I> example clearly demonstrates the power of ADO and OLEDB providers within an Access application.</P>


<A NAME="110"><H3>Using the MSDASQL provider</H3></A>


<p>Access 2000 works with other OLEDB providers, such as MSDASQL, 
which works for all ODBC data sources. Although there is a special provider 
for Microsoft SQL Server, the following procedure uses the general OLEDB 
ODBC provider to illustrate how you can use the provider with any ODBC data 
source. Since this provider always references an ODBC data source, you can use it in coordination with a DSN. The procedure shows the MSDASQL provider 
referencing the SQL Server Pubs database to print the author social security number, first name, and last name.</P>



<p><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>Sub GetODBCThroughOLEDB()
Dim cnn1 As New ADODB.Connection
Dim rst1 As ADODB.Recordset

'Open ODBC sources with msdaSQL provider and DSN reference.
    cnn1.Open &quot;Provider=MSDASQL;DSN=Pubs;&quot;
    Set rst1 = New ADODB.Recordset
    rst1.CursorType = adOpenKeyset
    rst1.LockType = adLockOptimistic
    rst1.Open &quot;authors&quot;, cnn1, , , adCmdTable

'Open recordset and print a test record.
    Do Until rst1.EOF
        Debug.Print rst1.Fields(0).Value, _
            rst1.Fields(2), rst1.Fields(1).Value
        rst1.MoveNext
    Loop
End Sub
</pre>
</TD></TR></TABLE></P>


<p>The <I>GetODBCThroughOLEDB</I> procedure starts by opening a 
connection to the SQL Server Pubs database and invokes the object's 
<I>Open</I> method. The provider argument specifies the MSDASQL provider, and the DSN argument contains the connection information and acts as a Data Source argument for the Jet 4 provider. The <I>Open</I> method can specify the connection string information, which eliminates the need to reference the DSN. The following statement shows how to open the SQL Server Pubs database without denoting a DSN:</P>


<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>cnn1.Open &quot;Provider=MSDASQL;DRIVER=SQL Server;&quot; &amp; _
    &quot;SERVER=CAB2200;DATABASE=Pubs;uid=sa;pwd=;&quot;
</pre>
</TD></TR></TABLE></P>


<p>The SQL Server name is CAB2200. Notice that the connection string 
also contains user ID and password arguments. The connection string is specific 
to the database to which you connect.</P>


<p>The next four lines of the procedure open a recordset on the 
<I>Authors</I> table in the SQL Server Pubs database. The syntax of the 
<I>Open</I> method is identical to the one used to open a range on an Excel worksheet. This symmetry of 
form between two such diverse sources illustrates the power of ADO with OLE 
DB providers. The final <I>Do</I> loop iterates through the records to print the 
social security number, first name, and last name for each author. Since the 
<I>Value</I> property is the default for the 
<I>Recordset</I> object's <I>Fields</I> collection, you don't 
need to specify it. (Notice that the second argument to the 
<I>Debug.Print</I> method does not explicitly reference the 
<I>Value</I> property of the<I> Fields</I> collection.) The 
overall design of the <I>GetODBCThroughOLEDB</I> procedure shows that Access 
2000 can link to a SQL Server database as easily as it can to an Excel workbook.</P>


<p>The <I>TransferDatabase</I> and 
<I>TransferSpreadsheet</I> methods of the 
<I>DoCmd</I> object are an easy and robust way to link to data in another application; 
they do not even depend on a reference to the DAO library. These methods 
expose their sources through the Database window, while the OLE DB provider 
offers an exclusively programmatic interface to its data sources. Whether 
exposure through the Database window is a benefit to you will depend on your 
application and the preferences of its users.
<A NAME="111"><H3>Using the <I>TransferDatabase</I> or <I>TransferSpreadsheet</I> method</H3></A></P>

<p>The <I>TransferDatabase</I> and 
<I>TransferSpreadsheet</I> methods follow from 
macro actions that enable importing, linking, and exporting. The 
<I>TransferSpreadsheet</I> method supports a wide array of Lotus and Excel formats. The 
<I>TransferDatabase</I> method supports ODBC data sources, such as SQL Server and Oracle, as 
well as ISAM data sources, such as Paradox, dBase, Microsoft FoxPro, and 
Jet. <I>TransferSpreadsheet</I> and 
<I>TransferDatabase</I> tap into the ISAM and ODBC 
drivers that ship with Access. Good sources of documentation on these 
methods include the Access online documentation and a Macro window open in 
Design view with drop-down boxes offering options for selected arguments.</P>


<p>The <I>linkXLCustomers </I>procedure below shows the 
syntax for the <I>TransferSpreadsheet</I> method. You can compare this technique with the functionality of an OLE DB provider. This sample links to the Customers range in the Customers.xls workbook. (Customers.xls is included in this book's companion CD.) It specifies an Excel 97 file format, but also supports Excel 5, Excel 4, and Excel 3. <I>TransferSpreadsheet</I> also supports Lotus formats, such as WK1, WK3, and WK4. The <I>DoCmd</I> object creates a linked table named <I>XLCustomers</I> in the Database window. The next-to-last argument to <I>TransferSpreadsheet</I> (-1) indicates that the Excel range has field names in the first row.</P>


<p><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>Sub linkXLCustomers()
Dim cnn1 As New ADODB.Connection
Dim rst1 As ADODB.Recordset

'Use DoCmd to programmatically make the link.
    DoCmd.TransferSpreadsheet acLink, acSpreadsheetTypeExcel97, _
        &quot;XLCustomers&quot;, &quot;C:\Programming Access\Chap03\Customers.xls&quot;, _ 
        -1, &quot;Customers&quot;

'Open and set recordset.
    Set rst1 = New ADODB.Recordset
    rst1.ActiveConnection = CurrentProject.Connection
    rst1.CursorType = adOpenKeyset
    rst1.LockType = adLockOptimistic
    rst1.Open &quot;XLCustomers&quot;, , , , adCmdTable

'Open recordset and print a test record.
    Do Until rst1.EOF
        Debug.Print rst1.Fields(0).Value, rst1.Fields(2)
        rst1.MoveNext
    Loop

End Sub
</pre>
</TD></TR></TABLE></P>


<p>After the <I>TransferSpreadsheet</I> method executes, your application can 
use its return set similarly to one from an OLE DB provider. First, you open a 
recordset on the linked table. Then you programmatically manipulate the recordset to 
serve the requirements of your application. 
(<I>linkXLCustomers</I> merely prints several 
fields for each row.)</P>


<p>The <I>TransferDatabase</I> method offers a wider range of data access 
options than the <I>TransferSpreadsheet</I> command. These include its historical ISAM 
drivers and ODBC drivers. Since most databases support ODBC access, this method 
can interface with nearly any relational database management system (RDBMS) 
data source. Furthermore, the 
<I>TransferDatabase</I> method has a similar syntax to 
the <I>TransferSpreadsheet</I> method, which makes it easy to use.</P>


<p>The following <I>linkODBCAuthors</I> procedure uses the 
<I>TransferSpreadsheet</I> method to link to the 
<I>Authors</I> table in the SQL Server Pubs 
database. <I>linkODBCAuthors</I> forms a link to the 
<I>Authors</I> table under the name 
<I>dboAuthors</I> in the current database. If 
<I>dboAuthors</I> is already in the current database, 
the method silently retains the original copy and makes another copy, naming 
it <I>dboAuthors1</I>.</P>


<p><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>

<pre>Sub linkODBCAuthors()
Dim cnn1 As New ADODB.Connection
Dim rst1 As ADODB.Recordset

'Use DoCmd to programmatically make the link.
    DoCmd.TransferDatabase acLink, &quot;ODBC Database&quot;, _
        &quot;ODBC;DSN=Pubs;UID=sa;PWD=;DATABASE=pubs&quot;, _
        acTable, &quot;Authors&quot;, &quot;dboAuthors&quot;

'Open and set recordset.
    Set rst1 = New ADODB.Recordset
    rst1.ActiveConnection = CurrentProject.Connection
    rst1.CursorType = adOpenKeyset
    rst1.LockType = adLockOptimistic
    rst1.Open &quot;dboAuthors&quot;, , , , adCmdTable

'Open recordset and print a test record.
    Do Until rst1.EOF
        Debug.Print rst1.Fields(0).Value, rst1.Fields(2)
        rst1.MoveNext
    Loop

End Sub
</pre>
</TD></TR></TABLE></P>


<p>The first argument to<I> TransferSpreadsheet</I> specifies the transfer type to the data source; the <I>acLink </I>argument creates a linked table in the Database window. The next two arguments specify the type of database and its name. (<I>linkODBCAuthors</I> specifies an ODBC data source. In fact, this sample uses the popular SQL Server Pubs database.) The final arguments designate the type of database object on which you want to base your source, its name in the remote source (<I>Authors</I>), and its name in your application (<I>dboAuthors</I>). The remainder of 
<I>linkODBCAuthors</I> performs the same actions as the other samples 
in this section.</P>


</BODY>
</HTML>





