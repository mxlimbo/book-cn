<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>ADO Overview</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch02b.htm", "ch03a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="55"><H1>ADO Overview</H1></A>

<P>Access 2000 supports ADO version 2.1, which includes three ADO data 
access models: the ADODB library, the ADOX library, and the JRO library. By 
segmenting data access into three libraries, Access offers a smaller footprint 
for applications that do not require all three. Another major component of 
the Access 2000 data access strategy is reliance on OLE DB providers, which 
work with ADO to offer access to traditional data sources as well as new ones, 
such as e-mail directories. This vastly expands the power of database programming.</P>

<P>The ADODB library is a small, lightweight library that contains core 
objects and offers the basics for making connections, issuing commands, 
and retrieving recordsets, and it also enables recordset navigation. You can use it to perform basic maintenance tasks, such as modifying, adding, and 
deleting records. The nonhierarchical design of this library makes it easy for beginners.</P>

<P>The ADOX library supports data definition language and security issues. It offers objects that put you in touch with a database's overall schema. For example, it lets you create tables and relations. The model includes support 
for referential integrity and cascading updates and deletes, and it offers 
procedures and views as well as <I>Users </I>and <I>Groups </I>collections for user-level database security.</P>

<P>The JRO library enables Jet database replication. Access 2000 supports database replication with both Jet and SQL Server databases. <a href="ch11a.htm">Chapter 11</a> covers database replication in depth.</P>

<P>One major advantage that ADO offers is an event model. ODBCDirect permits asynchronous operations, but ADO provides events. This frees an application from polling an object and checking its <I>StillExecuting </I>property. Instead, you can simply create event handlers to respond to events whenever 
they happen. (Subsequent chapters will explain how to design event handlers.)</P>

<P>OLE DB providers help make ADO powerful. They offer a new way 
to access remote data that embraces and extends ODBC, and they provide 
access to both relational databases and nontraditional data sources with a 
consistent ADO interface. Access 2000 ships with a variety of OLE DB providers, 
including ones for Jet, SQL Server, Oracle, general ODBC data sources, and 
such nontraditional sources as Microsoft Active Directory Service and Microsoft 
Index Server. You can expect more of these providers over time.</P>

<P>Before you can use any of the ADO libraries, you must create a reference to at least one of them. You do this from the Visual Basic Editor (VBE) window using the Tools-References command. Figure 2-3 below shows the References dialog box with all three libraries selected. While it might be more convenient to select all three, you can conserve resources by selecting just the libraries that you need. Experiment with the selections for your applications and the machines that they run on to determine what makes sense for your environment. If you have a production application that runs on many different types of machines, you should conserve resources for other application requirements.</P>

<P><A HREF="javascript:fullSize('F02qh03x.htm')"> <img src="Images/F02qh03.JPG" width=404 height=321 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 2-3.</B> <I>You use the References dialog box to add ADO libraries to an application.</I><!-- /CAPTION -->
</P>


<A NAME="56"><H2>The ADODB Library </H2></A>

<P>The ADODB object library has seven main objects. Four of these objects 
have collections. The <I>Connection </I>object appears at the top of the hierarchy, but you can create connections implicitly using other objects. The 
<I>Connection</I>, <I>Command</I>, <I>Recordset</I>, and <I>Field </I>objects have <I>Properties </I>collections.</P>

<P><A HREF="javascript:fullSize('F02QH04x.htm')"> <img src="Images/F02qh04.JPG" width=404 height=420 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 2-4.</B> <I>The ADODB object library.</I><!-- /CAPTION -->
</P>


<A NAME="57"><H3>The <I>Connection</I> object</H3></A>
<P>The <I>Connection </I>object establishes a link to a database. You always use a <I>Connection </I>object either implicitly or explicitly when you work with a database. When you explicitly create one, you can efficiently manage one or more connections and reassign the roles that they serve in an application. By implicitly creating one you can shorten your code. Each new object that you create with an implicit connection consumes more resources. If your application has only one or two objects that each requires its own connection, implicit 
connections might serve your needs best. ADO lets you choose how to create and 
manage connections as you see fit.</P>

<P>Unlike DAO, ADO is a general data access language, so not all of its 
properties and methods are appropriate for the Jet engine. There is, however, 
a special OLE DB provider for Jet 4, which is the latest version of Jet that 
ships with Access 2000. Since <I>Connection </I>objects depend critically on provider specifications, the ability to set a <I>Connection </I>parameter that references the Jet 4 provider is valuable. This custom provider allows ADO to reflect many of the special strengths that Jet offers. When you refer to a database in another file, you might want to include a <I>Data Source </I>parameter, which points to the physical location of a database when it is not in the current project.</P>

<P>The following simple code sample opens the familiar Northwind database. Notice that a <I>Dim </I>statement declares and creates a reference to 
<I>cnnNorthwind </I>as a <I>Connection </I>object. The use of the <I>Open </I>method on <I>cnnNorthwind </I>makes the database available to the rest ofthe procedure. Notice that the <I>Provider </I>and <I>Data Source </I>parameters appear within a single pair of double quotes. The <I>Provider </I>parameter points to the Jet 4 OLE DB provider and the <I>Data Source </I>parameter points to the physical location of the Northwind database.</P>


<p><table cellpadding=5 width="95%"><tr><td>
<pre>
Sub OpenMyDB()
Dim cnnNorthwind As New Connection
Dim rsCustomers As Recordset

'Create the connection.
    cnnNorthwind.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;

'Create recordset reference and set its properties.
    Set rsCustomers = New ADODB.Recordset
    rsCustomers.CursorType = adOpenKeyset
    rsCustomers.LockType = adLockOptimistic

'Open recordset and print a test record.
    rsCustomers.Open &quot;Customers&quot;, cnnNorthwind, , , adCmdTable
    Debug.Print rsCustomers.Fields(0).Value, rsCustomers.Fields(1).Value
    rsCustomers.Close
    cnnNorthwind.Close

End Sub
</PRE>
</TD></TR></TABLE></P>

<P>After creating a reference to the connection, the code creates a <I>Recordset </I>object. It sets a reference to the object variable denoting the recordset, and then it assigns values to a couple of properties for the recordset. The last block of code opens the recordset and prints a couple of fields from the first record. The <I>Open </I>method for a <I>Recordset </I>object can reference a connection to a database and some source of records in the database. The code above selects all of the records from the <I>Customers</I> table in the Northwind database. The <I>Open </I>method initially makes the first record available to an application.</P>

<P>The final two lines in the last block of code close the recordset and 
then the connection. Closing a connection makes all objects that reference it, 
such as a <I>Recordset </I>object, inoperable. Any attempt to set properties or invoke methods for a recordset that references a closed connection generates a 
run-time error. For this reason, implicitly creating a connection might be a better choice because the object has use of the connection for its lifetime.</P>

<P>The following code also opens a recordset based on the <I>Customers</I> table in the Northwind database and prints the first record. However, it uses 
fewer lines of code and the code is less complicated because it implicitly creates a connection and accepts more default settings.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub OpenFast()
Dim rsCustomers As Recordset
    Set rsCustomers = New ADODB.Recordset

'Less code, but potentially greater resource consumption
    rsCustomers.Open &quot;customers&quot;, &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;
    Debug.Print rsCustomers.Fields(0), rsCustomers.Fields(1)
    rsCustomers.Close

End Sub
</PRE>
</TD></TR></TABLE></P>

<P>Since there is no explicit connection, the <I>OpenFast </I>procedure does not need to declare a connection object (and therefore doesn't have to open one or close one). As you can see, the <I>Open </I>method for a recordset object can include the essential connection information of a provider and a data 
source. The code above has only one other parameter-the source for the 
recordset, which is the <I>Customers</I> table. The <I>Open </I>method relies on the default <I>CursorType </I>and <I>LockType </I>settings, which are, respectively, forward-only and read-only. These settings provide for very fast operations, but they do not offer a lot of functionality. Nevertheless, if they suit your needs and let you divert your attention to other aspects of application development, they might be the best choice.</P>

<P><b>The <I>Mode</I> property</b> By default, the <I>Connection </I>object's <I>Open </I>method creates a database for shared access. However, you can set the 
<I>Connection </I>object's <I>Mode </I>property to any of seven other settings that grant various degrees of restricted access to a database. These mode settings pertain to all the recordsets and commands that assign a connection to their <I>ActiveConnection </I>property. The following code shows the impact of the read-only mode setting on the ability to update a recordset.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub OpenLookOnly()
Dim cnn1 As New Connection
Dim rsCustomers As Recordset
'    cnn1.Mode = adModeRead
    cnn1.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;
    Set rsCustomers = New ADODB.Recordset
    rsCustomers.Open &quot;Customers&quot;, cnn1, adOpenKeyset, _
        adLockPessimistic
'An adModeRead setting for cnn1.Mode causes an error in this procedure.
'Remove the comment from the cnn1.Mode line to see an error here.
    rsCustomers.Fields(&quot;CustomerID&quot;) = &quot;xxxxx&quot;
    rsCustomers.Update
    Debug.Print rsCustomers.Fields(&quot;CustomerID&quot;)
    rsCustomers.Close

End Sub
</PRE>
</TD></TR></TABLE></P>

<P>The <I>OpenLookOnly </I>procedure declares a new <I>Connection </I>object in its first line. The third line, if uncommented, sets the connection's <I>Mode </I>property to <I>adModeRead </I>for read-only access. Two more lines into the procedure, an <I>Open </I>method makes the <I>rsCustomers </I>recordset available. The next pair of lines attempts to update the value of the <I>CustomerID </I>field for the first record. If you remove the comment in the third line these updates will cause an error because you can't update a read-only database.</P>

<P>The following table describes the eight constants that you can use to set a connection's <I>Mode </I>property. You can use these constants to control the 
type of editing that one or more users can do through a connection to a database.</P>

<P><B>Constants Used to Set the<I> Connection </I>Object's <I>Mode</I> Property</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Constant</I></th>      
<th valign="top"><I>Value</I></th>
<th valign="top"><I>Behavior</I></th>
</tr>
<tr>
<td valign="top"><I>adModeUnknown</I></td>     
<td valign="top">0</td>     
<td valign="top">Permissions not set or determined</td>
</tr>
<tr>
<td valign="top"><I>adModeRead</I></td>     
<td valign="top">1</td>     
<td valign="top">Read-only permission</td>
</tr>
<tr>
<td valign="top"><I>adModeWrite</I></td>     
<td valign="top">2</td>     
<td valign="top">Write-only permission</td>
</tr>
<tr>
<td valign="top"><I>adModeReadWrite</I></td>     
<td valign="top">3</td>     
<td valign="top">Read/write permission</td>
</tr>
<tr>
<td valign="top"><I>adModeShareDenyRead</I></td>     
<td valign="top">4</td>     
<td valign="top">Prevents others from opening record source with read permissions</td>
</tr>
<tr>
<td valign="top"><I>adModeShareDenyWrite</I></td>     
<td valign="top">8</td>     
<td valign="top">Prevents others from opening record source with write permissions</td>
</tr>
<tr>
<td valign="top"><I>adModeShareExclusive</I></td>     
<td valign="top">12</td>     
<td valign="top">Prevents others from opening the connection</td>
</tr>
<tr>
<td valign="top"><I>adModeShareDenyNone</I></td>     
<td valign="top">16</td>     
<td valign="top">Shared access (default)</td>
</tr></table></p>

<P><b>The <I>OpenSchema</I> method</b> The <I>Connection </I>object's <I>OpenSchema </I>method lets an application browse the objects in the collections available through a connection without enumerating the elements in a list. The output from the <I>OpenSchema </I>method can contain information about tables, views, 
procedures, indexes, and more. The specific details depend on how a given OLE DB provider implements the general capabilities of the method. The following 
code uses the <I>OpenSchema </I>method with the Jet 4 provider to list the views available through a connection.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Public Sub OpenSchemaX()
Dim cnn1 As New ADODB.Connection
Dim rstSchema As ADODB.Recordset
   
    cnn1.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;
   
    Set rstSchema = cnn1.OpenSchema(adSchemaTables)
  
'Print just views; other selection criteria include
'TABLE, ACCESS TABLE, and SYSTEM TABLE.
    Do Until rstSchema.EOF
        If rstSchema.Fields(&quot;TABLE_TYPE&quot;) = &quot;VIEW&quot; Then
            Debug.Print &quot;View name: &quot; &amp; _
            RstSchema.Fields(&quot;TABLE_NAME&quot;) &amp; vbCr
        End If
        rstSchema.MoveNext
    Loop
    rstSchema.Close
    cnn1.Close

End Sub
</PRE>
</TD></TR></TABLE></P>

<P>The procedure starts by declaring a connection and a recordset. The recordset holds the output from the <I>OpenSchema </I>method. The argument for the <I>OpenSchema </I>method indicates that elements of the Tables domain for the database schema will make entries in the records. However, the 
<I>OpenSchema </I>method tracks several types of tables, including views, normal user tables, special system tables, another table of Access objects, and linked tables. The code above prints the output from the method just for views.</P>

<A NAME="58"><H3>The <I>Recordset </I>object</H3></A>
<P>A recordset is a programmatic construct for working with records. You can 
base your records on a table or a view in the current project or on another file, a SQL statement, or a command that returns rows. What you can do with 
a recordset depends on its OLE DB provider and on native data source attributes.</P>

<P>While you can extract recordsets using other objects, such as connections and commands, the <I>Recordset </I>object's rich mix of properties and methods 
make it a natural choice for doing much of your row-set processing. You can 
use recordsets to perform multiple actions against a set of rows: You can 
navigate between rows; print all or some of their contents; add, revise, and delete records; find records; and filter records to select one or any subset from a full recordset. Recordsets have historically been nonpersistent objects-they normally exist just for the time that they are open in a program. The 2.10 version of ADO that ships with Access 2000 offers persistent recordsets, which you can save to disk and then open again later.</P>

<P><b>The <I>ActiveConnection</I> property</b> A recordset's <I>ActiveConnection </I>property lets your application tap an open connection to support a recordset. You can set this property any time after setting the object for the recordset. Its use simplifies your <I>Open </I>method statement for the recordset by removing the need to include the connection information. When you preset the property, you do not even need to reference an existing connection in the <I>Open </I>method statement.</P>

<P><b>The <I>Open</I> method</b> The recordset's <I>Open </I>method is one common route 
for making a recordset available in a procedure. The source argument is the 
most critical one for this method. It designates the data source on which the 
method patterns the object that it opens. Typical options for the source argument include a table, a SQL statement, a saved recordset file, or a stored 
procedure. You use the <I>Open </I>method's <I>Options </I>argument to designate the source type when you open a recordset.</P>

<P><b>The cursor type</b> The cursor type is among the most basic features of 
a recordset. It determines how you can navigate through the recordset and 
the types of locks that you can impose on it. ADO supports four cursor types:</P>

<UL>
<P><LI>
<I>Dynamic</I> This type of cursor lets users view changes to a 
data source made by other users. It enables recordset 
maintenance functions such as adding, changing, and deleting records, and 
it permits bidirectional navigation around a database without 
relying on bookmarks.
</LI></P>

<P><LI>
<I>Keyset</I> This cursor has most of the properties of a dynamic 
cursor, except you do not have ready access to changes by other users 
of a data source. One way to view changes made by others is to 
invoke a recordset's <I>Requery </I>method.
</LI></P>

<P><LI>
<I>Static</I> This cursor is a snapshot of a recordset at a point in time. 
It allows bidirectional navigation. Changes to the database by 
other users are not visible. Microsoft Internet Explorer 4 and later 
supports this type as its most flexible client-side cursor.
</LI></P>

<P><LI>
<I>Forward-only</I> Sometimes called the fire hydrant cursor, this 
type goes in one direction and can speed up cursor performance. 
This is the default ADO cursor type. If you need another type of 
cursor, you must set the <I>CursorType </I>property before opening the recordset.

<P><DIV CLASS="NOTE"><BLOCKQUOTE>
<B>NOTE</B><HR>
The cursor type setting interacts with lock type settings. If 
you designate a forward-only cursor type with a lock type other than 
read-only (<I>adLockReadOnly</I>), ADO overrides your cursor type setting. For 
example, ADO automatically converts a forward-only cursor type to a keyset 
cursor type if you designate optimistic locking.
</BLOCKQUOTE></DIV></P>

</LI></P>
</UL>

<P><b>The <I>LockType</I> property</b> The <I>LockType </I>property partially interacts with the cursor type because it controls how users can manipulate a recordset. One lock type setting (<I>adLockReadOnly</I>) specifically matches forward-only cursors. This is the default lock type. The following table describes the four possible settings for the <I>LockType </I>property. The <I>adLockBatchOptimistic </I>setting is specifically for remote databases, such as SQL Server or Oracle, as opposed to a local Jet database. This topic will receive more attention in <a href="ch12a.htm">Chapter 12.</a> </P>

<P><B>Constants Used to Set the<I> Connection </I>Object's<I> LockType </I>Property</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Constant</I></th>      
<th valign="top"><I>Value</I></th>
<th valign="top"><I>Behavior</I></th>
</tr>
<tr>
<td valign="top"><I>adLockReadOnly</I></td>     
<td valign="top">1</td>      
<td valign="top">Read-only access (default)</td> 
</tr>
<tr>
<td valign="top"><I>adLockPessimistic</I></td>      
<td valign="top">2</td>      
<td valign="top">Locks a record as soon as a user chooses to start editing it</td> 
</tr>
<tr>
<td valign="top"><I>adLockOptimistic</I></td>      
<td valign="top">3</td>      
<td valign="top">Locks a record only when a user chooses to commit edits back to the database</td> 
</tr>
<tr>
<td valign="top"><I>adLockBatchOptimistic</I></td>      
<td valign="top">4</td>      
<td valign="top">Allows edits to a batch of records before an attempt to update a remote database from the local batch of records</td> 
</tr></table></p>

<P><DIV CLASS="NOTE"><BLOCKQUOTE>
<B>NOTE</B><HR>
You can determine whether the recordset you are using provides a particular type of functionality by using the <I>Supports </I>method. You simply put the constant that represents that functionality in parentheses when you invoke <I>Supports</I>. A return value of <I>True </I>indicates that the recordset provides that functionality. The online <I>Supports </I>documentation describes the names of the constants. Search the Object Browser for <I>CursorOptionEnum</I> to see a list of constants for which <I>Supports </I>returns <I>True</I> or <I>False</I>.
</BLOCKQUOTE></DIV></P>

<P><b>Recordset navigation</b> Four methods enable recordset navigation by 
changing the current record position:</P>

<UL>
<P><LI>
<I>MoveFirst</I> This method changes the current record position to 
the first record in a recordset. The order of records depends on 
the current index, or, if there is no index, on the order of entry. 
This method functions with all cursor types. Its use with 
forward-only cursors can force a reexecution of the command that generated 
the recordset.
</LI></P>

<P><LI>
<I>MoveLast</I> This method establishes the last record in a recordset 
as the current record position. It requires a cursor type that 
supports backward movement or at least movement based on bookmarks. Using the method with a forward-only cursor generates a run-time error.
</LI></P>

<P><LI>
<I>MoveNext</I> This method relocates the current record position 
one record forward (in the direction of the recordset's final record). If 
the current record position is the last record, the recordset's <I>EOF</I> property is set to <I>True</I>. If this method is called when the recordset's 
<I>EOF</I> property is already <I>True</I>, a run-time error results.
</LI></P>

<P><LI>
<I>MovePrevious</I> This method sends the current record position 
one record backward. If the current record position is the first record, 
the recordset's <I>BOF</I> property is set to <I>True</I>. If this method is called when the recordset's <I>BOF</I> property is already <I>True</I>, a run-time error results. This method also generates a run-time error if you use it with a forward-only cursor type.
</LI></P>
</UL>

<P>The <I>Move</I> method works differently than the other four recordset 
navigation methods because it can move the current record position a variable 
number of records in either direction. You use a positive argument to indicate 
moves toward the last record and a negative argument to identify moves toward 
the first record. If a move will extend beyond the first or last record, the 
<I>Move </I>method sets the recordset's <I>BOF</I> or <I>EOF</I> property to <I>True</I>. If that property is already <I>True</I>, the <I>Move </I>method generates a run-time error. Movement is relative to the current record unless you specify a <I>Start </I>parameter that can enable movement from the first or last record.</P>

<P>You can enhance the <I>Move </I>method's performance in a couple of ways 
by using it with a recordset's <I>CacheSize </I>property set to greater than the default value, which is 1. <I>CacheSize </I>settings cause ADO to store a fixed number of records in the local workstation's memory. Since it is much faster to retrieve records from memory than from a provider's data store, you can speed record navigation with <I>Move </I>by using a larger 
<I>CacheSize</I>. With a forward-only cursor and a larger <I>CacheSize</I>, you can actually enable backward as well as forward scrolling. If your cache setting is equal to the number of records in a recordset, you can scroll the full extent of the recordset in both directions. The <I>CacheSize </I>property does not enable backward scrolling with the <I>MovePrevious </I>method. (You can use the <I>Move </I>method with a negative argument.)</P>

<P><b>The <I>Find</I> method</b> The recordset's <I>Find </I>method searches for the first record that matches a specified selection criterion. While this method bears a striking similarity to a collection of <I>Find </I>methods in earlier versions of Access, the Access 2000 version has a different syntax and behavior. Rather than attempt to map the similarities and differences, you should simply learn the syntax and behavior of the new version.</P>

<P>The new <I>Find </I>method takes as many as four arguments. The first 
argument is required and is the criterion for the search. Its syntax follows that of SQL statement WHERE clauses. If you do not specify any other arguments, 
the method searches from the current record through the last record to find a 
record that matches the criterion. Once the method finds a match, you must move 
off that record to find a new match in the recordset. If there is no match, the 
method sets the recordset's <I>EOF</I> property to <I>True</I>. See the online help for a description of the remaining three optional arguments.</P>

<P><b>The <I>Sort</I> property</b> A recordset <I>Sort </I>property can affect the results of both the <I>Find </I>and <I>Move </I>methods. This property designates one or more fields that can determine the order in which rows display. The <I>Sort </I>property setting allows the designation of an ascending or descending order for any field. The default is ascending order. The <I>Sort </I>property settings do not physically rearrange the rows-they merely determine the order in which a recordset makes its 
rows available.</P>

<P><b>The <I>Filtered</I> property</b> The <I>Filtered </I>property for a recordset defines a new recordset that is a filtered version of the original recordset.While this property has specialized applications for database synchronization and batch updating a remote data source, it can also be a simple alternative to defining a new recordset based on a SQL statement. If you already have a recordset and you need only a subset for another purpose, this property can serve admirably.</P>

<P><b>The <I>AddNew</I> method</b> The <I>AddNew </I>method adds new records to a 
recordset. After you invoke the method, you set the values for the fields in a new row that you want to add. Then you either move off the record using a 
<I>Move </I>method or you call the <I>Update </I>method while still on the row. (You can modify the values in a field using a similar pair of techniques. You update fields by assigning them new values, and then you move off the record. Alternatively, you can remain on an edited record as long as you call the 
<I>Update </I>method. You can delete a record by simply navigating to it and then calling the <I>Delete </I>method. The deleted record remains current until you move away from it.)</P>

<P><b>Printing field values</b> The following simple procedure opens a data 
source and then successively prints out the rows of the database. A loop passes 
through all the records and prints the first two fields of each record.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub EasyLoop()
Dim rsCustomers As Recordset

    Set rsCustomers = New ADODB.Recordset
    rsCustomers.Open &quot;customers&quot;, &amp; _
        &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;

'Loop through recordset.
    Do Until rsCustomers.EOF
        Debug.Print rsCustomers.Fields(0), rsCustomers.Fields(1)
        rsCustomers.MoveNext
    Loop
  
    rsCustomers.Close

End Sub
</PRE>
</TD></TR></TABLE></P>

<P>One weakness of the first <I>EasyLoop </I>procedure is that it prints only 
the values of the fields you specifically request. The <I>EasyLoop2 </I>procedure below circumvents this difficulty. No matter how many fields are in the data source for a recordset, the procedure automatically prints all of them.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub EasyLoop2()
Dim rsCustomers As Recordset
Dim fldMyField As Field
Dim strForRow As String

    Set rsCustomers = New ADODB.Recordset

    rsCustomers.Open &quot;customers&quot;, &amp; _
        &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;

'Loop through recordset and fields with rows.
    Do Until rsCustomers.EOF
        strForRow = &quot;&quot;
        For Each fldMyField In rsCustomers.Fields
            strForRow = strForRow &amp; fldMyField &amp; &quot;; &quot;
        Next fldMyField
        Debug.Print strForRow
        rsCustomers.MoveNext
    Loop

    rsCustomers.Close

End Sub
</PRE>
</TD></TR></TABLE></P>

<P>The first several and last several lines in each procedure are identical. 
The <I>EasyLoop2 </I>procedure nests a <I>For </I>loop inside a <I>Do </I>loop. This inner <I>For </I>loop enumerates the fields in a row and builds a string with all the field values on each row. (The string is cleared at the top of the loop to start the process over again for another row.)</P>

<P>Looping is an easy way to perform an operation on the rows and columns within a recordset. However, it is not the most efficient way to retrieve the 
field values of a recordset. The <I>NoEasyLoop </I>procedure below uses the <I>GetString</I> method to retrieve and print all the fields on all rows of a recordset in one step. The <I>GetString </I>method returns a recordset as a string. It can take up to five arguments; the code uses three of those arguments. You designate the <I>adClipString </I>constant as the first argument-this is your only choice. It specifies the format for representing the recordset as a string. The second argument specifies 
the number of recordset rows to return. This code returns five rows. Leaving 
this argument blank enables the method to return all the rows in the recordset. 
The third argument designates a semicolon delimiter for the columns within a 
row. The default column delimiter is a tab. The fourth and fifth arguments, 
neither of which appears below, specify a column delimiter and an expression to 
represent null values. The default values for these arguments are a carriage 
return and a zero-length string.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub NoEasyLoop()
Dim rsCustomers As Recordset

    Set rsCustomers = New ADODB.Recordset

    rsCustomers.Open &quot;customers&quot;, _
        &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;

'Print records without a loop.
    Debug.Print rsCustomers.GetString(adClipString, 5, &quot;; &quot;)

    rsCustomers.Close

End Sub
</PRE>
</TD></TR></TABLE></P>

<P>The <I>GetString </I>method replaces a pair of nested loops. If the defaults 
are acceptable, you can use the method without any arguments. This makes for 
a simple way to extract values from a recordset. Although nested loops are 
the intuitive way to retrieve values from a recordset, the <I>GetString </I>method can achieve a similar result in a single line.</P>

<P><b>Adding a record</b> The following code tackles a new task-adding a 
new record to a data source.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub AddARecord()
Dim rsMyTable As Recordset

'Set your cursor so that it is not read-only to delete.
    Set rsMyTable = New ADODB.Recordset
    rsMyTable.ActiveConnection = CurrentProject.Connection
    rsMyTable.Open &quot;MyTable&quot;, , adOpenKeyset, adLockOptimistic, _
        adCmdTable

'Invoke the AddNew method.
    rsMyTable.AddNew
    rsMyTable.Fields(&quot;Column1&quot;).Value = 16
    rsMyTable.Fields(&quot;Column2&quot;).Value = 17
    rsMyTable.Fields(&quot;Column3&quot;).Value = 18
    rsMyTable.Update

End Sub
</PRE>
</td></tr></table></P>

<P>While <I>EasyLoop</I>, <I>EasyLoop2</I>, and <I>NoEasyLoop</I> all accept the <I>Open</I> method's default cursor type and lock type settings, the 
<I>AddARecord </I>procedure does not. Recall that the defaults are a forward-only cursor and a read-only lock type. These settings are acceptable for merely printing the contents of a recordset. However, you need a cursor and a lock type that permit updates to a recordset when your task requires adding, editing, or deleting records. The <I>adOpenKeyset </I>and <I>adLockOptimistic</I> arguments to <I>Open</I> allow you to add new rows to a recordset. Also, notice that the <I>ActiveConnection </I>setting in the code above does not reference the Northwind sample project. It instead references the connection for the current project. When you need to reference a data source in the current project, use this syntax. The connection statement also explicitly designates a table in the current project as the data source for the recordset. There are several alternative sources, including the text for a SQL statement, a stored procedure, an external file saved in a special format, and more.</P>

<P>To use the <I>AddNew </I>method to add a record, you call the method, 
issue assignment statements to populate the new record with values, and then 
invoke the <I>Update </I>method. The call to <I>Update</I> is not strictly mandatory; you can simply move off the new, current record. For example, you can invoke <I>MoveFirst </I>or another method to navigate to a new record.</P>

<P><b>Editing or deleting a record</b> The following code edits or deletes a 
record. It does not use the <I>Edit </I>and <I>Update </I>methods to save the edited records. Instead, it moves off the record. If it is impractical to move off the record or if your application needs to commit the changes before moving, use the recordset's <I>Update </I>method instead.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub DeleteOrUpdateARecord()
Dim rsMyTable As Recordset
  
'Use a non-read-only lock type to be able to delete records.
    Set rsMyTable = New ADODB.Recordset
    rsMyTable.ActiveConnection = CurrentProject.Connection
    rsMyTable.Open &quot;MyTable&quot;, , adOpenKeyset, adLockOptimistic, _
        adCmdTable

'Loop through recordset.
    Do Until rsMyTable.EOF
        If rsMyTable.Fields(&quot;Column1&quot;) = 16 Then
'            rsMyTable.Fields(&quot;Column1&quot;) = 88
            rsMyTable.Delete
        End If
        rsMyTable.MoveNext
    Loop
  
    rsMyTable.Close

End Sub
</PRE>
</td></tr></table></P>

<P>A loop such as the one in the <I>DeleteOrUpdateARecord </I>procedure can help you select records for deleting or editing. The procedure examines each 
<I>Column1 </I>field value in a recordset, searching for one with a value of 16. When it finds one, it deletes the row. Notice that the loop contains a comment line. To switch from a delete routine to an updating routine, you simply transfer the comment mark from the assignment line to the <I>Delete</I> method line.</P>

<P><b>Finding records</b> Another common use for a recordset is to find one or more records that meet specified criteria. Access 2000 offers several approaches 
to this task. With earlier versions of Access, many developers used one or 
more variations of the <I>Find </I>method. As mentioned earlier, Access 2000 offers a single <I>Find </I>method that works somewhat differently from the earlier <I>Find </I>methods. If you liked the earlier <I>Find </I>methods, you can use the new <I>Find </I>method with its similar functionality.</P>

<P>The following code shows a simple application of the <I>Find </I>method that searches for a record with a customer ID<I> </I>that begins with the letter <I>D.</I> When it finds a record matching its criteria, the method relocates the current record to that location. The code prints the <I>CustomerID 
</I>and <I>ContactName </I>fields to confirm exactly which record matches the criteria.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub FindAMatch()
Dim rsCustomers As Recordset
   
    Set rsCustomers = New ADODB.Recordset
    rsCustomers.ActiveConnection = _
        &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;
    rsCustomers.Open &quot;Customers&quot;, , adOpenKeyset, adLockPessimistic, _
        adCmdTable
    rsCustomers.Find (&quot;CustomerID Like 'D*'&quot;)
    Debug.Print rsCustomers.Fields(&quot;CustomerID&quot;), _
    rsCustomers.Fields(&quot;ContactName&quot;)

End Sub
</PRE>
</td></tr></table></P>

<P>One drawback to this approach is that it searches for a single match 
to the criteria, and then stops immediately after finding it. The code below 
discovers all the records that match the criteria statement. This simple 
application reveals more of the flexibility of the <I>Find </I>method.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub FindAMatch2()
Dim rsCustomers As Recordset
   
    Set rsCustomers = New ADODB.Recordset
    rsCustomers.ActiveConnection = &amp; _
        &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;
    rsCustomers.Open &quot;Customers&quot;, , adOpenKeyset, _adLockPessimistic,
        adCmdTable
    Do
        rsCustomers.Find (&quot;CustomerID Like 'D*'&quot;)
        If rsCustomers.EOF Then
            Exit Sub
        End If
        Debug.Print rsCustomers.Fields(&quot;CustomerID&quot;)
        rsCustomers.MoveNext
    Loop

End Sub
</PRE>
</td></tr></table></P>

<P>The trick to finding all the records that match the search criteria is to 
embed the <I>Find</I> method in a <I>Do </I>loop. When the <I>Find </I>method sets the recordset's <I>EOF</I> property to <I>True</I>, there are no additional matching records. In this case, the code executes an <I>Exit Sub </I>statement to end the subroutine. As long as <I>Find </I>keeps discovering new matches, the procedure prints the customer IDs in the Immediate window. After printing a matching record, the procedure advances the current record by one. Without this, the <I>Find </I>method would repeatedly return the same record.</P>

<P>The <I>Find </I>method goes through a recordset sequentially and discloses matches one at a time. It does not create another version of the recordset 
that contains all the records that match the criteria. When you need a new or 
alternate recordset containing just the matches, your application needs a 
different approach. The recordset <I>Filter </I>property might be the answer. This property lets you designate a simple criterion for a field, and it returns a filtered version of the original recordset with only those records that match the criterion. By setting the <I>Filter </I>property equal to any of a series of constants, you can achieve special effects for database replication or for updating a remote data source. One filter constant, <I>adFilterNone</I>, removes the filter setting from a recordset and restores the original values.</P>

<P><b>Filtering records</b> The two following procedures filter a recordset based 
on the <I>Customers</I> table in the Northwind database. The <I>FilterRecordset </I>procedure manages the overall use of the <I>Filter </I>property, prints the result set, clears the filter, and then prints the result set again. The 
<I>FilterRecordset </I>procedure relies on the <I>FilterLikeField </I>function to manage the setting of the <I>Filter </I>property based on parameters passed to it by the <I>FilterRecordset </I>procedure.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub FilterRecordset()
Dim rsCustomers As Recordset

'Create recordset variable.
    Set rsCustomers = New ADODB.Recordset
    rsCustomers.ActiveConnection = &amp; _
        &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;

'Open recordset.
    rsCustomers.Open &quot;Customers&quot;, , , , adCmdTable

'Filter recordset.
    Set rsCustomers = _
        FilterLikeField(rsCustomers, &quot;CustomerID&quot;, &quot;D*&quot;)
    Debug.Print rsCustomers.GetString

'Restore recordset.
    rsCustomers.Filter = adFilterNone
    Debug.Print rsCustomers.GetString
  
    rsCustomers.Close

End Sub


Function FilterLikeField(rstTemp As ADODB.Recordset, _
    strField As String, strFilter As String) As ADODB.Recordset

'Set a filter on the specified Recordset object and then
'open a new Recordset object.
    rstTemp.Filter = strField &amp; &quot; LIKE '&quot; &amp; strFilter &amp; &quot;'&quot;
    Set FilterLikeField = rstTemp

End Function
</PRE>
</td></tr></table></P>

<P>The <I>FilterRecordset</I> procedure starts by creating and opening 
the <I>rsCustomers </I>recordset. Next, it applies a filter by calling the 
<I>FilterLikeField </I>function, which takes three arguments and returns a filtered recordset based on them. <I>FilterRecordset</I> assigns the filtered return set to <I>rsCustomers</I> and prints it<I> </I>to confirm the result.</P>

<P>The arguments to <I>FilterLikeField </I>include <I>rsCustomers</I>, a field name on which to filter records, and a filter criterion value, which can include any legitimate expression for the Like<I> </I>operator used by 
<I>FilterLikeField</I>. <I>FilterRecordset</I> passes <I>D*</I> to find just the records that have a <I>CustomerID </I>beginning with the letter <I>D</I>. The <I>Filter </I>property does not restrict you to filtering with the 
Like<I> </I>operator. Other acceptable operators include &lt;, &gt;, &lt;=, &gt;=, &lt;&gt;, and =. You can also include And<I> </I>and Or<I> </I>operators in your criteria expressions to combine two or more criteria expressions based on the other legitimate operators.</P>

<P>The <I>Filter </I>property does restrict your criteria expressions to those 
of the form <I>FieldName-Operator-Value</I>. However, some <I>Filter </I>constants enable special uses of the property. The <I>FilterRecordset </I>procedure uses the <I>adFilterNone </I>property to restore a recordset by removing its filters.</P>

<P><b>Using SQL to create a recordset</b> You should know one final thing about recordsets: how to generate recordsets based on SQL statements. SQL 
statements are often nothing more than &quot;SELECT * FROM TABLENAME&quot;, but you can tap the full functionality of SQL to generate recordsets. You can even use complex multitable SELECT<I> </I>statements with computed fields that use either inner or outer joins and that constrain or organize return sets with WHERE, GROUP BY, and ORDER BY<I> </I>clauses. One easy way to create a custom recordset based on SQL statements is by using WHERE<I> </I>clauses. You can selectively extract records from an existing source using expressions that are more complicated than when you use the <I>Filter </I>property.</P>

<P>The following code uses an <I>Open </I>method with a SQL statement. 
When you base a recordset on a SQL statement instead of an existing table, you 
pass your SQL statement and use the optional <I>adCmdTable </I>argument instead of <I>adCmdText</I>. That's all there is to it. You can then use the recordset to construct any simpler recordset based on an individual table. More complicated SQL statements do not alter how you declare or use the recordset with ADO.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub SQLRecordset()
Dim rsCustomers As Recordset
'Create recordset variable.
    Set rsCustomers = New ADODB.Recordset
    rsCustomers.ActiveConnection = &amp; _
        &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;
    
'Open the recordset.
    rsCustomers.Open &quot;SELECT * FROM Customers&quot;, , adOpenForwardOnly, _
        adLockReadOnly, adCmdText
    Debug.Print rsCustomers.GetString
  
    rsCustomers.Close

End Sub
</PRE>
</td></tr></table></P>

<A NAME="59"><H3>The <I>Field </I>object</H3></A>
<P>A field is a column of data containing entries with the same data type. In 
the ADODB library, the <I>Fields </I>collection belongs exclusively to recordsets, and its members are <I>Field</I> objects. <I>Field </I>objects have properties and methods for storing and retrieving data.</P>

<P>Recordsets use a <I>Field</I> object's <I>Value </I>property to display the contents of a column in the current record. When you change the record, this value can change to reflect the contents of the new record. Many of the other 
<I>Field</I> properties contain metadata-data about the data in a record. The <I>Name </I>property is a handle by which your applications can reference a field. The <I>DefinedSize </I>property characterizes the maximum size of a field (in characters for Text fields). The <I>ActualSize </I>property is the actual length (in bytes) of the contents of a <I>Field</I> object's value. The <I>Attributes </I>property contains an array of information features about a field. It can indicate whether a field's value is updatable or whether it can contain Nulls.</P>

<P><DIV CLASS="NOTE"><BLOCKQUOTE>
<B>NOTE</B><HR>
The <I>DefinedSize </I>and <I>ActualSize </I>properties use different 
measurements for Text fields. <I>DefinedSize </I>is the maximum number of 
characters in the field and <I>ActualSize </I>is the number of bytes in the field. Since Text fields with Jet 4 represent characters with 2 bytes each, 
their <I>ActualSize </I>value can be as much as twice the <I>DefinedSize</I> value. For numeric fields, and Text fields in databases that represent characters with 1 byte (for example, a Jet 3.51 database), this difference does not exist.
</BLOCKQUOTE></DIV></P>

<P>The <I>Field</I> methods <I>GetChunk </I>and <I>AppendChunk </I>facilitate processing of large text or binary data fields in smaller chunks that more conveniently fit into memory. You use the <I>GetChunk </I>method to bring into memory a portion of a large field. The <I>Size </I>argument specifies the number of bytes to retrieve in one invocation of the <I>GetChunk </I>method. Each uninterrupted, successive invocation of the method starts reading new data from where the previous one finished. The <I>AppendChunk </I>method lets you construct a large text or binary data field in chunks from memory. Like the <I>GetChunk </I>method, it writes new data into a field from where the previous 
<I>AppendChunk </I>method finished. To use either method correctly, a <I>Field</I> object's <I>adFldLong </I>bit in the <I>Attributes </I>property must be set to <I>True</I>.</P>

<P><b>The <I>Name</I> and <I>Value</I> properties</b> The following procedure shows 
common uses for the <I>Name </I>and <I>Value </I>properties. It lists all the field names with their corresponding values. This procedure creates its single-record recordset based on a SQL statement.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub FieldNameValue()
Dim cnn1 As ADODB.Connection
Dim rsCustomers As ADODB.Recordset
Dim fldLoop As ADODB.Field

'Open connection and recordset.
    strCnn = &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office&quot; &amp; _
        &quot;\Office\Samples\Northwind.mdb;&quot;
    Set cnn1 = New ADODB.Connection
    cnn1.Open strCnn
    Set rsCustomers = New ADODB.Recordset
    rsCustomers.ActiveConnection = cnn1
    rsCustomers.Open &quot;SELECT * FROM Customers &quot; &amp; _
        &quot;WHERE CustomerID='BONAP'&quot;, , , , adCmdText
  
'Report field names and values for record.
    For Each fldLoop In rsCustomers.Fields
        Debug.Print fldLoop.Name, fldLoop.Value
    Next fldLoop

End Sub
</PRE>
</td></tr></table></P>

<P>The procedure begins by opening a connection and then creating a recordset on the connection. The SQL statement extracts the record for the customer with a <I>CustomerID </I>field equal to <I>BONAP</I>. The <I>Do </I>loop that follows the creation of the recordset loops through the recordset's fields. Printing the <I>Name </I>property along with the<I> Value </I>property helps readability.</P>

<P><b>The <I>Type</I> property</b> A <I>Field </I>object's <I>Type </I>property indicates the kind of data it can contain. This property returns one of the data type constants in the <I>DataTypeEnum </I>values range. You can view these options in the Object Browser for the ADODB library. Figure 2-5 shows these constants in the Object Browser screen. By selecting the type for a field, you can determine legitimate values for its <I>Value </I>property.</P>

<P><A HREF="javascript:fullSize('F02qh05x.htm')"> <img src="Images/F02qh05.JPG" width=404 height=446 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 2-5.</B> <I>The Object Browser showing a selection of data type constants.</I><!-- /CAPTION -->
</P>


<P><b>Printing field data types</b> The following two procedures work together 
to process data type constants with ADO. The <I>FieldNameType </I>procedure opens a recordset based on the <I>Orders</I> table in the Northwind database. This table has a reasonable variety of data types, so it makes a nice case study for examining data types. After opening a recordset, the procedure loops through the fields in the recordset and prints each <I>Field</I> object's name and type. The <I>FieldType </I>function translates the numeric constant's value to a string that represents the constant. The <I>adCurrency </I>constant has a value of 6. The <I>FieldType </I>function decodes the value 6 to the string 
&quot;<I>adCurrency&quot;.</I> The <I>FieldNameType </I>procedure then prints each field's name and data type constant name.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub FieldNameType()
Dim cnn1 As ADODB.Connection
Dim rsOrders As ADODB.Recordset
Dim fldLoop As ADODB.Field

'Open connection and recordset.
    strCnn = &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office&quot; &amp; _
        &quot;\Office\Samples\Northwind.mdb;&quot;
    Set cnn1 = New ADODB.Connection
    cnn1.Open strCnn
    Set rsOrders = New ADODB.Recordset
    rsOrders.ActiveConnection = cnn1
    rsOrders.Open &quot;orders&quot;, , , , adCmdTable
  
'Report field names and types for record.
    For Each fldLoop In rsOrders.Fields
        Debug.Print &quot; Name: &quot; &amp; fldLoop.Name &amp; vbCr &amp; _
            &quot; Type: &quot; &amp; FieldType(fldLoop.Type) &amp; vbCr
    Next fldLoop

End Sub


Public Function FieldType(intType As Integer) As String
    Select Case intType
        Case adVarWChar
            FieldType = &quot;adVarWChar&quot;
        Case adCurrency
            FieldType = &quot;adCurrency&quot;
        Case adInteger
            FieldType = &quot;adInteger&quot;
        Case adDate
            FieldType = &quot;adDate&quot;
    End Select

End Function
</PRE>
</td></tr></table></P>

<P>Figure 2-6 shows an excerpt from the output from <I>FieldNameType</I>. This excerpt includes at least one field from each of the data types decoded in 
the <I>FieldType </I>function. You can easily run <I>FieldNameType </I>and <I>FieldType </I>against recordsets based on other data sources than the 
<I>Orders</I> table. You might encounter another data type besides the four in the list. In this case, the <I>Type </I>field in the report will be blank. You can fix this problem by determining the value of the field. You do this by putting a breakpoint on the <I>Debug.Print </I>statement inside the <I>Do </I>loop in the <I>FieldNameType </I>procedure. You examine the value 
of <I>fldloop.Type </I>for a field whose type doesn't display and then match that constant value against the constant names in the Object Browser for 
<I>DataTypeEnum. </I>(See Figure 2-5.) Finally, you amend the 
<I>Select Case </I>statement in the <I>FieldType </I>procedure to decode the new constant.</P>

<P><img src="Images/F02qh06.GIF" width=215 height=417 border="0">
</P><P><!-- CAPTION --><B>Figure 2-6.</B> <I>An excerpt from the output for the </I>FieldNameType <I>procedure.</I><!-- /CAPTION -->
</P>


<P><b>Finding the longest field entry</b> The <I>FieldSizes </I>procedure below applies the <I>ActualSize </I>property to find the longest entry in the <I>CompanyName </I>field of the <I>Shippers</I> table in the Northwind database. The procedure begins by creating a connection to the Northwind database, and then it opens a recordset based on the <I>Shippers</I> table. The second portion of the routine finds the longest shipper's name and displays a message box showing the number of characters in the name and the name itself.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub FieldSizes()
Dim cnn1 As ADODB.Connection
Dim rsShippers As ADODB.Recordset
Dim fldLoop As ADODB.Field
Dim intMaxChars As Integer, strMsg As String
Dim strName As String
'Open connection and recordset.
    strCnn = &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office&quot; &amp; _
        &quot;\Office\Samples\Northwind.mdb;&quot;
    Set cnn1 = New ADODB.Connection
    cnn1.Open strCnn
    Set rsShippers = New ADODB.Recordset
    rsShippers.ActiveConnection = cnn1
    rsShippers.Open &quot;SELECT * FROM Shippers&quot; _
        , , , , adCmdText

'Find longest shipper's name.
    intMaxChars = 0
    Do Until rsShippers.EOF
        If rsShippers!CompanyName.ActualSize / 2 _
            &gt; intMaxChars Then
            intMaxChars _
                = rsShippers!CompanyName.ActualSize / 2
            strName = rsShippers.Fields(&quot;CompanyName&quot;)
        End If
        rsShippers.MoveNext
    Loop
    strMsg = &quot;The longest shipper's name is '&quot; &amp; _
        strName  &amp; &quot;' (&quot; &amp; intMaxChars &amp; &quot; characters).&quot;
    MsgBox strMsg, vbInformation, &quot;Programming Microsoft Access 2000&quot;

    rsShippers.Close

End Sub
</PRE>
</td></tr></table></P>

<P>The <I>intMaxChars </I>variable tracks the longest field length. The 
second portion of <I>FieldSizes </I>initializes the variable to 0 before opening a loop that goes through all of the records in the recordset. It is not strictly necessary to set <I>intMaxChars </I>to 0 because VBA does that automatically. However, doing so helps to make the procedure self-documenting. Any shipper's name containing more characters than the current value of <I>intMaxChars </I>is the longest name up to that point. When the procedure finds such a name, it updates <I>intMaxChars </I>and saves the name. Notice that the procedure uses two different syntax conventions for referencing a field. Several statements use a bang character (!), an older Access notation. In this notation, the bang character separates the recordset name and the name of the field. The newer and more common way is to reference the field using the <I>Fields </I>collection. You can use the numerical index if you know it, or you can include the field name in quotes.</P>

<A NAME="60"><H3><I>Command </I>and <I>Parameter o</I>bjects</H3></A>
<P>Within the ADODB library, <I>Command </I>objects deliver three major benefits:</P>

<UL>
<P><LI>
They can perform a select query to return a set of rows from a 
data source.
</LI></P>

<P><LI>
They execute a parameter query so that you can input 
run-time search criteria.
</LI></P>

<P><LI>
They support action queries against a data source to perform 
such operations as the updating, deleting, and adding of records.
</LI></P>
</UL>

<P>The <I>Command</I> object can serve additional roles with other libraries, 
as discussed in later sections.</P>

<P>You must designate a <I>Connection </I> object on which to run a command. 
You can either implicitly create a <I>Connection</I> object when you specify a 
command or explicitly assign an existing <I>Connection </I>object to a command. These are the same options as for recordsets.</P>

<P>The <I>CommandTimeout </I> property determines how long ADO waits for
the execution of a command to conclude. This property takes a Long<I> </I>value that specifies the maximum wait time in seconds. Its default value is 30. If the timeout interval elapses before the <I>Command </I>object completes execution, ADO cancels the command and returns an error. The <I>Connection </I>object also supports a <I>CommandTimeout </I>property. It has the same name, but it is independent of the <I>Command </I>object's <I>CommandTimeout 
</I>property. The <I>Command </I>object's <I>CommandTimeout </I>property does not inherit the setting of the <I>Connection </I>object's <I>CommandTimeout </I>property.</P>

<P><b>The <I>CommandType</I> property</b> There are actually several different types 
of <I>Command </I>objects. The <I>CommandType </I>property sets the type of 
<I>Command </I>object. You can base your command on a SQL statement, a table, or a stored procedure, as shown in the following table. One main reason for resorting to a <I>CommandType </I>property setting is to enable the creation of a <I>Command </I>object based on a SQL statement. Changing the <I>CommandType </I>constant from its default setting can speed up the operation of a command. Therefore, if you know the source, you should set this constant.</P>

<P><b>The <I>CommandText</I> property</b> To write a SQL statement for the 
command to execute, you use the <I>Command </I>object's <I>CommandText </I>setting. You can also set this property to the name of a stored procedure. When you run a SQL statement, you can use the <I>Prepared </I>property to indicate that the statement is to be compiled and stored on the database server. This slows the first execution of the command but speeds up subsequent executions. You assign <I>True</I> to the <I>Prepared </I>property to invoke compilation of a SQL statement.</P>


<P><B><I>CommandType</I> Constants </B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Constant</I></th>      
<th valign="top"><I>Value</I></th>
<th valign="top"><I>Behavior</I></th>
</tr>
<tr>
<td valign="top"><I>adCmdText</I></td>     
<td valign="top">1</td>     
<td valign="top">Lets you run a command based on a SQL statement, a stored procedure, or even a table. Usually, you reserve this setting for a SQL statement.</td>
</tr>
<tr>
<td valign="top"><I>adCmdTable</I></td>     
<td valign="top">2</td>
<td valign="top">Bases the return set on a previously designed table. Returns all columns from a table based on an internally generated SQL statement.</td>
</tr>
<tr>
<td valign="top"><I>adCmdStoredProc</I></td>     
<td valign="top">4</td>
<td valign="top">Runs a command based on text for a stored procedure.</td>
</tr>
<tr>
<td valign="top"><I>adCmdUnknown</I></td>
<td valign="top">8</td>
<td valign="top">There is no specification of the type 
of command text. This is the default.</td>
</tr>
<tr>
<td valign="top"><I>adCmdFile</I></td>    
<td valign="top">256</td>
<td valign="top">Evaluates a command based on the filename for a persistent recordset.</td>
</tr>
<tr>
<td valign="top"><I>adCmdTableDirect</I></td>     
<td valign="top">512</td>     
<td valign="top">Evaluates a command as a table name. Returns all columns in a table without any intermediate SQL code.</td>
</tr></table></p>

<P><b>The <I>Execute</I> method</b> The <I>Execute </I>method for a <I>Command </I>object invokes the code behind the <I>Command </I>object (a query, a SQL statement, or a stored procedure). You can specify up to three arguments for the <I>Execute </I>method. The first argument allows the <I>Command </I>object to tell the procedure invoking it how many records it has affected. The second argument can be a <I>Variant </I>array with parameters to drive the command. The third argument tells ADO how to evaluate the source. It can be any of the constant names listed in the table above.</P>

<P><b>The <I>CreateParameter</I> method</b> The <I>Command </I>object's <I>CreateParameter </I>method creates a new parameter for a command. After creating the parameter, you can use the <I>Append </I>method to add the parameter to the <I>Parameters </I>collection for a command. Before running a parameter query, you also have to assign a value to the parameter.</P>

<P><b>Creating a recordset with a select query</b> One of the most straightforward tasks you can perform with a <I>Command </I>object is to create a recordset based on a select query. The <I>Command </I>object runs the select query and 
represents its return set. Your code can then open a <I>Recordset </I>object based on the return set from the <I>Command </I>object. The <I>SelectCommand </I>procedure below accomplishes this. It has two parts: One part creates the 
<I>Command </I>object and a connection for it to relate to a database, and the second part processes a recordset based on the return set from the <I>Command 
</I>object.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub SelectCommand()
Dim cmd1 As Command
Dim rs1 As Recordset, str1 As String
Dim fldLoop As ADODB.Field

'Define and execute command.

    Set cmd1 = New ADODB.Command
  
    With cmd1
        .ActiveConnection = CurrentProject.Connection
        .CommandText = &quot;SELECT MyTable.* FROM MyTable&quot;
        .CommandType = adCmdText
        .Execute
    End With
  
'Open and print recordset.
    Set rs1 = New ADODB.Recordset
    rs1.Open cmd1
  
    Do Until rs1.EOF
        str1 = &quot;&quot;
        For Each fldLoop In rs1.Fields
            str1 = str1 &amp; fldLoop.Value &amp; Chr(9)
        Next fldLoop
        Debug.Print str1
        rs1.MoveNext
    Loop

End Sub
</PRE>
</td></tr></table></P>

<P>The first part declares <I>cmd1 </I>as a <I>Command </I>
object and then sets three critical properties of the object. Every command must have an 
<I>ActiveConnection </I>property in order to run against a database. The 
<I>Command </I> object relies on a SQL statement to represent its select query. You can substitute a saved query. An <I>Execute </I>statement runs the select query. After the <I>Execute </I>method runs, <I>cmd1</I> contains a reference to a recordset.</P>

<P>The second part of the procedure opens a <I>Recordset </I> object based on <I>cmd1</I> and prints the return set with tab delimiters (<I>Chr(9)</I>) in the Immediate window. The procedure can handle any number of columns in any number of rows.</P>

<P><b>Creating a recordset with a parameter query</b> The following code is 
an example of a parameter query. This code also has a two-part design. The 
parameter query in the first part has some extra ADO code lines and a 
different SQL statement syntax than that of the previous select query. The second part that prints the return set is the same as the previous select query.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub ParameterQCommand()
Dim cmd1 As Command
Dim rs1 As Recordset, str1 As String
Dim fldLoop As ADODB.Field
Dim prm1 As ADODB.Parameter, int1 As Integer

'Create and define command.
    Set cmd1 = New ADODB.Command
  
    With cmd1
        .ActiveConnection = CurrentProject.Connection
        .CommandText = &quot;Parameters [Lowest] Long;&quot; &amp; _
            &quot;SELECT Column1, Column2, Column3 &quot; &amp; _
            &quot;FROM MyTable &quot; &amp; _
            &quot;WHERE Column1&gt;=[Lowest]&quot;
        .CommandType = adCmdText
    End With

'Create and define parameter.
    Set prm1 = cmd1.CreateParameter(&quot;[Lowest]&quot;, _
        adInteger, adParamInput)
    cmd1.Parameters.Append prm1
    int1 = Trim(InputBox(&quot;Lowest value?&quot;, _
        &quot;Programming Microsoft Access 2000&quot;))
    prm1.Value = int1
  
'Run parameter query.
    cmd1.Execute
  
'Open recordset on cmd1 and print it out.
    Set rs1 = New ADODB.Recordset
    rs1.Open cmd1
  
    Do Until rs1.EOF
        str1 = &quot;&quot;
        For Each fldLoop In rs1.Fields
            str1 = str1 &amp; fldLoop.Value &amp; Chr(9)
        Next fldLoop
        Debug.Print str1
        rs1.MoveNext
    Loop

End Sub
</PRE>
</td></tr></table></P>

<P>The SQL statement syntax uses a new <I>Parameters </I>declaration line that specifies the parameter's name and data type. The WHERE<I> </I>clause should also reference one or more parameters so that the parameters can affect the 
return set. These SQL syntax statement adjustments are not by themselves 
sufficient to make the parameter query work-you must add the parameter and 
append it to the command using ADO code.</P>

<P>You invoke the <I>CreateParameter </I> method to add the parameter. The 
code above uses three arguments with the <I> CreateParameter </I>method. The first one names the parameter, the second designates a data type for the parameter, and the third declares a direction for the parameter. The 
<I>adParamInput </I> constant is actually the default that declares the parameter an input to the query. Other constants let you designate output, input/output, and return value parameters. After creating a parameter, you must append it to the <I>Parameters </I>collection for the command.</P>

<P>After writing the code to add a parameter, you must assign a value to 
the parameter to make the parameter query command function properly: The 
code above uses an <I>InputBox </I> function to gather input from a user. The 
procedure then invokes the <I>Command </I> object's <I>Execute </I>method to generate a return set.</P>

<P><b>Deleting records</b> You can use the <I>Command </I> object to delete, update, 
and add records to a data source. <I>Command </I>objects offer a programmatic 
means of maintaining a data source. The <I>DeleteARecord </I>and <I>DeleteAllRecords </I> procedures below prune records from a data source. You designate the data source and the criteria for selecting records using the SQL 
DELETE<I> </I>statement. The SQL view in the Access query window lets you graphically design a query and then copy the code to the <I>CommandText </I>property of a command. You typically want to edit the SQL code from the Access query designer to remove extra parentheses. If your query operates on a single table, you can remove the table prefix before field names. As you can see, the difference between the two delete queries is simply the syntax of the SQL statement.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub DeleteARecord()
Dim cmd1 As ADODB.Command

    Set cmd1 = New ADODB.Command

    With cmd1
        .ActiveConnection = CurrentProject.Connection
        .CommandText = &quot;DELETE MyTable.Column1 FROM &quot; &amp; _
            &quot;MyTable WHERE (((MyTable.Column1)=13));&quot;
        .CommandType = adCmdText
        .Execute
    End With

End Sub


Sub DeleteAllRecords()
Dim cmd1 As ADODB.Command

    Set cmd1 = New ADODB.Command

    With cmd1
        .ActiveConnection = CurrentProject.Connection
        .CommandText = &quot;DELETE MyTable.* FROM MyTable&quot;
        .CommandType = adCmdText
        .Execute
    End With

End Sub
</PRE>
</td></tr></table></P>

<P><b>Inserting records</b> When you develop an application, you might want 
the ability to delete all the records from a table and then reset its contents. 
The <I>InsertRecords </I>procedure below uses the <I>Command </I>object to stock a table with values. You can use this procedure in conjunction with the 
<I>DeleteAllRecords </I>procedure to refresh a table with a small base set of records.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub InsertRecords()
Dim cmd1 As ADODB.Command

    Set cmd1 = New Command

    With cmd1
        .ActiveConnection = CurrentProject.Connection
        .CommandText = &quot;INSERT INTO MyTable(Column1, &quot; &amp; _
            &quot;Column2, Column3) VALUES (1,2,'3')&quot;
        .CommandType = adCmdText
        .Execute
        .CommandText = &quot;INSERT INTO MyTable(Column1, &quot; &amp; _
            &quot;Column2, Column3) VALUES (4,5,'6')&quot;
        .CommandType = adCmdText
        .Execute
        .CommandText = &quot;INSERT INTO MyTable(Column1, &quot; &amp; _
            &quot;Column2, Column3) VALUES (7,8,'9')&quot;
        .CommandType = adCmdText
        .Execute
        .CommandText = &quot;INSERT INTO MyTable(Column1, &quot; &amp; _
            &quot;Column2, Column3) VALUES (10,11,'12')&quot;
        .CommandType = adCmdText
        .Execute
        .CommandText = &quot;INSERT INTO MyTable(Column1, &quot; &amp; _
            &quot;Column2, Column3) VALUES (13,14,'15')&quot;
        .CommandType = adCmdText
        .Execute
        .CommandText = &quot;INSERT INTO MyTable(Column1, &quot; &amp; _
            &quot;Column2, Column3) VALUES (16,17,'18')&quot;
        .CommandType = adCmdText
        .Execute
    End With

End Sub
</PRE>
</td></tr></table></P>

<P>The <I>InsertRecords </I> procedure has general and specific elements. The 
general elements do not depend on the design of a particular table. In the 
code above, the specific elements tailor the general elements for the <I>MyTable</I> table. Figure 2-7 shows <I>MyTable</I> in Design view. It has three columns, named <I>Column1</I>, <I>Column2</I>, and <I>Column3</I>. The first two columns have Long Integer data types, and the third column has a Text data type. (When you add records to a table, you must consider the field data types.)</P>

<P><A HREF="javascript:fullSize('F02qh07x.htm')"> <img src="Images/F02qh07.JPG" width=404 height=259 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 2-7.</B> <I>The Design view of the table to which the </I>InsertRecords <I>procedure adds records.</I><!-- /CAPTION -->
</P>


<P>The general elements of the <I>InsertRecords </I>procedure are shared with 
other applications of the <I>Command </I>object. You create a reference to the 
<I>Command </I>object and set its connection property. For each row that you need to add to a record, three lines are required: the <I>CommandText 
</I>property setting, which indicates what the command will do; the 
<I>CommandType </I>property setting, which designates the format of the instruction; and the <I>Execute </I>method, which launches the addition of the new record. You can repeat these three lines for each row added to the data source. If you specify an updatable dynaset as the target, these steps can concurrently add records to two or more tables at the same time.</P>

<P>The syntax of the <I>CommandText </I> SQL statement has three features. 
(This syntax is not available from the SQL view of the Access query designer.) 
First, it uses the INSERT INTO keyword, which is followed by the name of the data source to which you want to add records. Second, it takes the optional step of listing the field names for which it submits values. If you do not take this step, your values in the third step will append in sequential order, which can be a problem if the data source design changes over time. Third, the 
VALUES<I> </I>keyword appears before the field values for the new record.</P>

<P><b>Updating record values</b> The <I>OddToEven </I> and <I>EvenToOdd </I> procedures below update data source values of <I>Column1</I> using the <I>Command </I> object. Figure 2-8 shows a fresh view of the table immediately after the 
<I>DeleteAllRecords </I>and <I>InsertRecords </I>procedures run. Notice that in Figure 2-8 the <I>Column1</I> values alternate between odd and even: If the value in <I>Column1</I> is odd, the value in <I>Column2</I> is even. The procedures use this information to manage the contents of the table.</P>

<P><img src="Images/F02QH08.GIF" width=333 height=196 border="0">
</P><P><!-- CAPTION --><B>Figure 2-8.</B> <I>A Datasheet view of the table that the </I>OddToEven<I> and </I>EvenToOdd <I>procedures update.</I><!-- /CAPTION -->
</P>


<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub OddToEven()
Dim cmdO2E As ADODB.Command
Dim intRowsChanged As Integer

    Set cmdO2E = New ADODB.Command

    With cmdO2E
        .ActiveConnection = CurrentProject.Connection
        .CommandText = &quot;UPDATE MyTable SET Column1 = &quot; &amp; _
            &quot;Column1+1 WHERE ((-1*(Column1 Mod 2))=True)&quot;
        .CommandType = adCmdText
        .Execute intRowsChanged
        Debug.Print intRowsChanged &amp; &quot; rows were affected.&quot;
    End With

End Sub


Sub EvenToOdd()
Dim cmdE2O As ADODB.Command

    Set cmdE2O = New ADODB.Command

    With cmdE2O
        .ActiveConnection = CurrentProject.Connection
        .CommandText = &quot;UPDATE MyTable SET Column1 = &quot; &amp; _
            &quot;Column1-1 WHERE ((-1*(Column2 Mod 2))=False)&quot;
        .CommandType = adCmdText
        .Execute
    End With

End Sub
</PRE>
</td></tr></table></P>

<P>The overall design of these procedures should be familiar by now. The most significant difference between these examples and earlier ones is in the syntax of the SQL statement for the <I>CommandText </I> property. In this case, you can easily derive that general syntax from the Access query designer. The WHERE clause in the <I>OddToEven </I> procedure selects records whose Column1 value is odd. The UPDATE<I> </I>part of the syntax adds 1 to the value to convert the value from an odd to an even number. The <I>Execute </I>method uses one of its built-in arguments to return the number of rows that a command changes. A simple <I>Print </I> method sends this value to the Immediate window for viewing.</P>

<P>The <I>EvenToOdd </I>procedure examines the entry in <I>Column2</I> to determine whether it should subtract 1 from the value in <I>Column1</I>. When the entry in <I>Column2 </I> is not odd, the SQL statement operates on the value in <I>Column1</I>. This restores the entries in <I>Column1 </I>to their initial values if <I>EvenToOdd</I> runs immediately after the <I>OddToEven </I>procedure runs.</P>

<A NAME="61"><H3>The <I>Errors </I>collection</H3></A>
<P>The <I>Errors </I>collection lets you trap some, but not all, errors that occur in an ADO application. It also returns errors from an OLE DB provider. A single error condition can return multiple errors, each of which causes a new 
<I>Error</I> object to be placed in the <I>Errors </I>collection. Some errors cause a program termination; others do not. A new failure automatically clears the <I>Errors </I>collection for the entry of errors associated with it. Some ADO errors enter the <I>Err </I>object rather than <I>Errors </I>collection, but you might want to use the latter collection as well. The <I>Errors </I>collection is most appropriate for handling connection-based errors returned from a remote database through its OLE DB provider.</P>

<P>The <I>Error </I>objects in the <I>Errors </I>collection have five properties that help you gather more information so that you can respond to them with program logic. The <I>Number </I>and <I>Description 
</I>properties parallel those for the <I>Err </I>object. These properties complement one another. The <I>Number </I>property returns a unique number that identifies an error, and the <I>Description</I> property returns a brief string that describes the error. The <I>NativeError </I>property offers a provider-specific error code. If you often work with a particular provider, this property might provide useful information about how to resolve an error. The <I>Source </I>property names the object or application that originated the error. The <I>SQLState </I>property can contain SQL statement syntax error messages originating from the database server to which you submit your request.</P>

<P>The <I>OpenLookOnly Errors </I>procedure below is an adaptation of an 
earlier procedure that reveals the impact of the <I>Connection </I>object's <I>Mode </I>property. A read-only setting for this property causes an error to be generated when you attempt to update a database. Interestingly, this error does not become part of the <I>Errors </I>collection. You can trap the error and respond to it using the <I>Err </I>object. The last member of the <I>Errors 
</I>collection also appears in the <I>Err </I>object. The error-trapping logic at the end of the procedure avoids printing two lines with an identical number and description.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub OpenLookOnlyErrors()
Dim cnn1 As New Connection
Dim rsCustomers As Recordset
Dim errLoop As Error, intInErrors As Integer
On Error GoTo LookOnlyTrap

    cnn1.Mode = adModeRead
    cnn1.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;
'Spell Northwind incorrectly to generate trappable error.
'    cnn1.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
    &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
    &quot;Samples\Northwinds.mdb;&quot;
'No Errrors element for faulty provider spelling
'    cnn1.Open &quot;Provider=Microsoft.Jets.OLEDB.4.0;&quot; &amp; _
    &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
    &quot;Samples\Northwind.mdb;&quot;
  
    Set rsCustomers = New ADODB.Recordset
    rsCustomers.ActiveConnection = cnn1
'Spell rsCustomers incorrectly to make a 424 non-tappable error.
'Spell cnn1 as cnn to make 3001 non-trappable error.
'    rsCustomer.ActiveConnection = cnn1
'Spell table name as &quot;Customer&quot; to make -2147217900 trappable error.
    rsCustomers.Open &quot;Customers&quot;
'adModeRead setting for cnn1.Mode causes an error (3251) here.
'Comment out cnn1.Mode line to enable updates.
    rsCustomers.Fields(&quot;CustomerID&quot;) = &quot;xxxxx&quot;
    rsCustomers.Update
    Debug.Print rsCustomers.Fields(&quot;CustomerID&quot;)
    rsCustomers.Close

LookOnlyTrap:
    intInErrors = 0
    For Each errLoop In cnn1.Errors
        Debug.Print errLoop.Number, errLoop.Description
        intInErrors = intInErrors + 1
    Next errLoop
    If intInErrors = 0 Then
        Debug.Print Err.Number, Err.Description
    End If

End Sub
</PRE>
</td></tr></table></P>

<P>The <I>OpenLookOnly Errors </I>procedure creates several different types 
of errors and attempts to write to a read-only connection. Figure 2-9 shows 
the VBE Code and Immediate windows for these errors. The messages with 
large, negative error codes are from the <I>Errors </I>collection. The remaining errors are ADO errors that report through the <I>Err </I>object. Only two of the errors have the large negative numbers characteristic of the 
<I>Errors </I>collection. The remaining errors are ADO errors that are available through the <I>Err </I>object. One error within the connection string (error number 3706) still did not report through the <I>Errors </I>collection. This, plus the fact that the last member of the <I>Errors </I>collection appears in the <I>Err</I> object, points to usefulness of error trapping with the <I>Err </I>object. This same design works for VBA errors.</P>

<P><A HREF="javascript:fullSize('F02qh09x.htm')"> <img src="Images/F02qh09.JPG" width=404 height=302 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 2-9.</B> <I>The VBE Code and Immediate windows showing error codes from typical kinds of errors.</I><!-- /CAPTION -->
</P>


<P><DIV CLASS="NOTE"><BLOCKQUOTE>
<B>NOTE</B><HR>
You can insert an 
<I>Option Explicit </I>statement in the general 
declarations area of a module to eliminate the possibility of certain errors, 
such as references to objects that do not exist.
</BLOCKQUOTE></DIV></P>

<P>The <I>LoopToUsingErrors </I> procedure below offers some alternative 
approaches to error processing with the <I>Err </I>object. The procedure generates one error and includes a comment that details the modifications to the code that are necessary to create another error. It also responds specifically to two errors and includes a general error handling routine for all others:</P>

<UL>
<P><LI>
In the case of a 3251 error, the procedure changes the lock type so that the recordset is updatable. This error occurs because the lock type is wrong. To fix the problem, the error-processing code closes the old recordset, resets the <I>LockType </I>property, and reopens the recordset object.
</LI></P>

<P><LI>
With a 424 error, the procedure does not try to fix the error but 
alerts the user to the potential cause of the problem. This error occurs 
when a method is invoked or a property is set against a variable 
not declared as an object. For example, a typographical error can 
cause this problem.
</LI></P>

<P><LI>
If the error does not have a 3251 or 424 error number, the routine prints out the number and description properties for the <I>Err </I>object.
</LI></P>
</UL>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub LoopToUsingErrors()
On Error GoTo DErrorsTrap
Dim cnn1 As Connection
Dim rsMyTable As Recordset
  
    Set cnn1 = New ADODB.Connection
    cnn1.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;
  
    Set rsMyTable = New ADODB.Recordset

'Open recordset with defaults.
OpenRSMyTable:
    rsMyTable.Open &quot;MyTable&quot;, cnn1

'Loop through recordset.
    Do Until rsMyTable.EOF
'Make 424 error by using next instead of preceding line.
'    Do Until rsMyTables.EOF
    If rsMyTable.Fields(0) = 4 Then
'This line makes 3251 error because recordset is read-only.
        rsMyTable.Fields(0) = 88
    Else
        Debug.Print rsMyTable.Fields(0), rsMyTable.Fields(1)
    End If
    rsMyTable.MoveNext
    Loop
  
    rsMyTable.Close
  
ErrorsExit:
    Exit Sub

DErrorsTrap:
    If Err.Number = 3251 Then
        MsgBox &quot;OLEDB Provider does not support operation. &quot; &amp; _
            &quot;Find another way to get the job done or get a new &quot; &amp; _
            &quot;OLEDB Provider. Error happened in LoopToDeleteErrors.&quot;
        Debug.Print rsMyTable.LockType
        rsMyTable.Close
        rsMyTable.LockType = adLockOptimistic
        Resume OpenRSMyTable
    ElseIf Err.Number = 424 Then
        MsgBox &quot;The code tried to do something requiring an &quot; &amp; _
            &quot;object, such as set a property or invoke a method, &quot; &amp; _
            &quot;but the code did not have an object. Check spelling.&quot;
    Else
        MsgBox &quot;Check Immediate window for error # and desc.&quot;
            Debug.Print Err.Number, Err.Description
    End If
    Resume ErrorsExit

End Sub
</PRE>
</td></tr></table></P>

<A NAME="62"><H2>The ADOX Library </H2></A>

<P>The ADOX library supports schema and security tasks. You use this library 
to manage objects and thereby modify the architecture of your application's 
database design. With the exception of the <I>Catalog </I>object, all objects have matching collections. You use these collections to add and organize new objects in a catalog. Selected objects, such as tables, indexes, keys, and columns, have <I>Properties </I>collections. You use these to manage the behavior of the objects within an application. You manage the <I>Users 
</I>and <I>Groups </I>collections to control permissions for other ADOX objects, such as tables, views, and procedures. Figure 2-10 shows an overview of the ADOX library.</P>

<P><A HREF="javascript:fullSize('F02QH10x.htm')"> <img src="Images/F02qh10.JPG" width=404 height=624 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 2-10.</B> <I>The ADOX object library.</I><!-- /CAPTION -->
</P>


<P>The ADOX library is an extension of the ADODB library. The Jet 
ADO provider fully supports ADOX. Other database providers can selectively 
implement its features, and you can use the two libraries together to build 
applications. For example, you can build <I>Command </I>objects with the ADODB library and then save them as procedures with the ADOX library. Or you can 
search for the availability of a table before basing a recordset on it. If the table does not exist, you can add it and populate it with values. The ability of the ADOX library to define new data structures makes it an alternative to SQL DDL.</P>

<A NAME="63"><H3>The <I>Catalog </I>object</H3></A>
<P>The <I>Catalog </I>object is the highest-level container in the ADOX library. Its members define the schema and security model for a database. Its 
<I>ActiveConnection </I>property defines the connection to which the catalog belongs. The <I>Connection </I>object is the database. The <I>Catalog 
</I>object is the database's container for tables, views, procedures, users, and groups within a connection or database. The <I>Name </I>property for a catalog is read-only. You designate it when you declare the catalog. You use the <I>Catalog </I>object's <I>Create </I>method to assign a connection and source to a catalog so that you can concurrently open a new database and gain access to its catalog.</P>

<P>The following code examples show the <I>Catalog </I>object in three typical contexts. The <I>CatCon </I>procedure opens the Northwind database and gives 
the current application programmatic access to the structure of the database. 
Notice that you need a <I>Connection </I>object for the catalog so that ADO knows which catalog to make available. You assign the <I>Connection </I>object to the catalog using its <I>ActiveConnection </I>property. Once ADO knows which database to reference with a catalog, you have programmatic access to the contents of the catalog. You control access using database and user-level security techniques.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub CatCon()
Dim cnn1 As New Connection
Dim cat1 As New Catalog

'Open the catalog of another database.
    cnn1.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;
    Set cat1.ActiveConnection = cnn1
    Debug.Print cat1.Tables(0).Name

End Sub


Sub CatCon2()
Dim cnn1 As New Connection
Dim cat1 As New Catalog
Dim proc1 As Procedure

'Open the catalog of this database.
'Print a range of selected collection information.
    Set cnn1 = CurrentProject.Connection
    Set cat1.ActiveConnection = cnn1
    Debug.Print cat1.Tables(1).Name
    Debug.Print cat1.Views(0).Name
    Debug.Print cat1.Procedures(0).Name
    Debug.Print cat1.Users(0).Name
    Debug.Print cat1.Groups(0).Name

End Sub


Sub CatCon3()
Dim cat1 As New ADOX.Catalog

'Open the catalog to a new database.
    cat1.Create &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=c:\My Documents\NewDB.mdb&quot;
    Debug.Print cat1.Tables(0).Name

End Sub
</PRE>
</td></tr></table></P>

<P><I>CatCon2 </I>lists a member from each collection within the <I>Catalog </I>object of the current database. While you can reference a table's contents with an ADODB library reference, you must use an ADOX reference to loop through the <I>Columns </I>collection of a table. Only the ADOX library has <I>Tables </I>and <I>Columns </I>collections.</P>

<P><DIV CLASS="NOTE"><BLOCKQUOTE>
<B>NOTE</B><HR>
You must impose a logon requirement before you can list the members of the <I>Users </I>and <I>Groups </I>collections. Any attempt to print them without logging on can generate a run-time error. You can impose a logon requirement by setting a password for the Admin user.
</BLOCKQUOTE></DIV></P>

<P><I>CatCon3 </I>creates a new database and exposes its catalog in one step. 
Notice that you apply the <I>Create </I>method to the <I>Catalog </I>object. The method takes a connection string as an argument. If the file specified in the connection string already exists, <I>CatCon3 </I>generates a run-time error. When the file runs successfully, it prints out one of the system table names because no user files are available just after the creation of a database.</P>

<P> You can use the <I>Catalog </I>object to enumerate the members of any of the collections within it. The following procedure enumerates the members of the <I>Views </I>collection, which corresponds to the set of all row-returning queries that do not rely on parameters that have Jet databases. When you use a SQL Server database, views are explicitly available from the Access 2000 database container.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub ListViews()
Dim cnn1 As New Connection
Dim cat1 As New Catalog
Dim view1 As View

    cnn1.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;
    Set cat1.ActiveConnection = cnn1

    For Each view1 In cat1.Views
        Debug.Print view1.Name
    Next view1

End Sub
</PRE>
</td></tr></table></P>

<P>The <I>Views </I>collection is available from the catalog for a connection. 
To enumerate the views, you must declare one view that your code will use 
to reference each member of the <I>Views </I>collection as it loops through the 
collection. Printing the <I>Name </I>property of each view provides an inventory of the <I>View </I>objects<I> </I>in a catalog.</P>

<A NAME="64"><H3>The <I>Table </I>object</H3></A>
<P>The <I>Table </I>object is a member of the <I>Tables </I>collection, which is a member of the <I>Catalog </I>object. Each <I>Table </I>object has a <I>Name </I>property and a <I>Type</I> property. A <I>Table </I>object can be a standard table within the current database or a linked table based on ODBC and non-ODBC data sources. It can even be a view. The <I>Type </I>property values also include two system table types-Jet system tables and the Access system table.</P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top">Type<I> values for the </I>Table<I> object</I></th> 
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top">ACCESS TABLE</td>     
<td valign="top">An Access system table</td>
</tr>
<tr>
<td valign="top">LINK</td>     
<td valign="top">A linked table from a non-ODBC data source</td>
</tr>
<tr>
<td valign="top">PASS-THROUGH</td>     
<td valign="top">A linked table through an ODBC data source</td>
</tr>
<tr>
<td valign="top">SYSTEM TABLE</td>     
<td valign="top">A Jet system table</td>
</tr>
<tr>
<td valign="top">TABLE</td>     
<td valign="top">A table developed by or for your application</td>
</tr>
<tr>
<td valign="top">VIEW</td>     
<td valign="top">A table from a row-returning, nonparameterized query</td>
</tr></table></p>

<P>A <I>Table </I>object in the ADOX library can contain up to three collections: <I>Columns</I>, <I>Indexes</I>, and <I>Keys</I>.</P>

<A NAME="65"><H3>The <I>Column</I> object</H3></A>
<P>The <I>Columns </I>collection is for tables, keys, and indexes. A <I>Column </I>object is roughly comparable to a <I>Field</I> object in the ADODB library. For a table, a column represents a set of data referring to a specific characteristic of the entity represented by the table. The <I>Column </I>object has several properties:</P>

<UL>
<P><LI>
<I>Name</I> This property is the name of the column.
</LI></P>

<P><LI>
<I>Type</I> This property indicates the data type of a column within 
the table. All the data within a column is of the same type.
</LI></P>

<P><LI>
<I>Attributes</I> The <I>Attributes</I> property describes the characteristics 
of a column. The two column characteristics are whether the 
column can contain nulls and whether it has a fixed length.
</LI></P>

<P><LI>
<I>DefinedSize</I> This property designates the maximum size of an 
entry in the column.
</LI></P>

<P><LI>
<I>Precision </I>and <I>NumericScale</I> These properties are used 
exclusively for numeric fields, such as integers, currency, and floating 
point numbers. <I>Precision </I>represents the maximum total number of 
digits used to convey the value of a column. <I>NumericScale </I>designates how many digits to the right of the decimal point are available to express a value.
</LI></P>
</UL>

<P>When a <I>Column </I>object is an index, other properties, such as 
<I>SortOrder </I>and <I>RelatedColumn</I>, are also available.</P>

<P><DIV CLASS="NOTE"><BLOCKQUOTE>
<B>NOTE</B><HR>
The <I>NumericScale 
</I>property can yield confusing results. For example, <I>Currency </I>values have four places to the right of the decimal point, but their <I>NumericScale </I>property equals 0 because Access stores Currency data types as scaled integers. When you modify the <I>Scale</I> setting of a column that uses a Decimal data type in a table's Design view, the column's <I>NumericScale </I>property adjusts accordingly.
</BLOCKQUOTE></DIV></P>

<A NAME="66"><H3>The <I>Index </I>object</H3></A>
<P>The <I>Index </I>object sets indexes for a table. It has five properties: 
<I>Clustered</I>, <I>IndexNulls</I>, <I>Name</I>, <I>PrimaryKey</I>, and <I>Unique</I>. With the exception of the <I>Name </I>property, all are read-only after you append the index. The <I>Name </I>property is the name of the index. Three other properties are Boolean and indicate, respectively, whether the index is clustered (an index is said to be <I>clustered</I> when the physical order of rows matches the indexed order of rows), unique, or a primary key.</P>

<P>The <I>IndexNulls </I>property can assume any of three different values. 
Setting it to <I>adIndexNullsDisallow </I>causes the <I>Index </I>construction to fail if there is a Null in the index for the column. Assigning the 
<I>adIndexNullsIsIgnore </I>constant to <I>IndexNulls </I>allows the construction of the index if there is a Null in the index, but sets the <I>Ignore Nulls </I>property (on the Indexes window in the user interface) to <I>Yes</I>. Using the <I>adIndexNullsIsIgnoreAny</I> also constructs the index when the index contains a null, but it sets the <I>Ignore Nulls </I>property to <I>No</I>.</P>

<A NAME="67"><H3>The <I>Key</I> object</H3></A>
<P>The <I>Key </I>object embodies the behavior of foreign keys in its properties. Of course, the <I>Name </I>property is the name of the key. The 
<I>RelatedTable </I>property designates the table to which a foreign key points. The <I>DeleteRule </I>and <I>UpdateRule</I> properties determine what happens when a primary key is deleted or updated. The <I>Type </I>property is the type of the key and has three options: <I>adKeyForeign</I> for foreign keys, <I>adKeyUnique</I> for unique keys, and <I>adKeyPrimary</I> for primary keys.</P>

<P><b>Enumerating tables</b> One of the easiest ways to start working with tables is to enumerate them. The <I>ListTables </I>procedure below shows how to list the tables in the Northwind database. The declarations instantiate <I>cat1 </I>as a <I>Catalog </I>object and <I>tbl1 </I>as a <I>Table </I>object. Next, the procedure assigns the Northwind database and the Jet 4 provider to the 
<I>ActiveConnection </I>property for the catalog. The following loop identifies the longest table name in the catalog. The final segment prints the table names to the Immediate window. A string formula appends blanks to table names so they all occupy a fixed number of characters. The code appends the table type.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub ListTables()
Dim cat1 As New ADOX.Catalog
Dim tbl1 As ADOX.Table
Dim intMaxLength As Integer

'Specify active connection for the Catalog object.
    cat1.ActiveConnection = &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;

'Find longest table name.
    intMaxLength = 0
    For Each tbl1 In cat1.Tables
        If Len(tbl1.Name) &gt; intMaxLength Then intMaxLength = _
            Len(tbl1.Name)
    Next tbl1

'Print table names to Immediate window.
    intMaxLength = intMaxLength + 2
    For Each tbl1 In cat1.Tables
        strName = tbl1.Name
        strFiller = String(intMaxLength - Len(tbl1.Name), &quot; &quot;)
        Debug.Print strName &amp; strFiller &amp; tbl1.Type
    Next tbl1

End Sub
</PRE>
</td></tr></table></P>

<P>Figure 2-11 shows output from the <I>ListTables</I> procedure. Notice that it appears as two columns, each showing a table's name. Next to the name is 
the <I>Type </I>property for the table. Recall that the <I>Table </I>object includes six types. Four of these appear in the figure.</P>

<P><A HREF="javascript:fullSize('F02qh11x.htm')"> <img src="Images/F02qh11.JPG" width=404 height=437 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 2-11.</B> <I>The output from the </I>ListTables<I> procedure.</I><!-- /CAPTION -->
</P>


<P><b>Enumerating fields</b> The <I>ListTableTypeColumns </I>and <I>ColumnType </I>procedures below are more elaborate samples that dig into table hierarchy and properties. Once <I>ListTableTypeColumns </I>finds a 
<I>Table </I>object with its <I>Table </I>property set to TABLE, it lists the column names and types of the columns within that table. These appear below the table's name and its column count. Each column name is next to its <I>ColumnType </I>constant. Figure 2-12 shows an excerpt from the listing. The sample is considered rich because it manipulates several types of <I>Table </I>objects and multiple properties, and the objects and properties are at 
different points on the ADOX object model hierarchy.</P>

<P><A HREF="javascript:fullSize('F02qh12x.htm')"> <img src="Images/F02qh12.JPG" width=404 height=396 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 2-12.</B> <I>The output from the </I>ListTableTypeColumns <I>and </I>ColumnType <I>procedures.</I><!-- /CAPTION -->
</P>


<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub ListTableTypeColumns()
Dim cat1 As New ADOX.Catalog
Dim tbl1 As ADOX.Table
Dim col1 As ADOX.Column

    cat1.ActiveConnection = &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\&quot; &amp; _
        &quot;Office\Samples\Northwind.mdb;&quot;

    For Each tbl1 In cat1.Tables
        If tbl1.Type = &quot;TABLE&quot; Then
            strName = tbl1.Name
            strFiller = String(30 - Len(tbl1.Name), &quot; &quot;)
            Debug.Print strName &amp; strFiller &amp; tbl1.Columns.Count
            For Each col1 In tbl1.Columns
                strFiller = String(20 - Len(col1.Name), &quot; &quot;)
                Debug.Print String(5, &quot; &quot;) &amp; col1.Name &amp; _
                strFiller &amp; ColumnType(col1.Type)
            Next col1
        End If
    Next tbl1

End Sub


Public Function ColumnType(intType As Integer) As String

    Select Case intType
        Case adVarWChar
            ColumnType = &quot;adVarWChar&quot;
        Case adCurrency
            ColumnType = &quot;adCurrency&quot;
        Case adInteger
            ColumnType = &quot;adInteger&quot;
        Case adDate
            ColumnType = &quot;adDate&quot;
        Case adWChar
            ColumnType = &quot;adWChar&quot;
        Case adLongVarWChar
            ColumnType = &quot;adLongVarWChar&quot;
        Case adLongVarBinary
            ColumnType = &quot;adLongVarBinary&quot;
        Case adBoolean
            ColumnType = &quot;adBoolean&quot;
        Case adSmallInt
            ColumnType = &quot;adSmallInt&quot;
        Case Else
            ColumnType = CStr(intType)
    End Select

End Function
</PRE>
</td></tr></table></P>

<P>The declarations include a catalog, a table, and a column from the ADOX library. The catalog's declaration instantiates its object, but the other two 
are used as item references in collections. Immediately after the declarations, 
the procedure assigns a connection string to the <I>ActiveConnection </I>property of the <I>Catalog </I>object.</P>

<P>A pair of nested <I>For </I>loops search through the tables and their 
columns. The outer loop seeks tables whose <I>Table </I>property is set to TABLE. When it finds one, it prints the name and column count for that table. The inner <I>For </I>loop enumerates the columns of the table and handles the formatting of the output. The loop calls the <I>ColumnType </I>function, which returns a character string that represents the constant designating the column's <I>Type </I>property. It is a very robust function, so you can adapt it for your own conversion tasks. If it encounters a type that it does not recognize, it converts the type's value to a string. This helps you to go back into the function and add the new decode specification.</P>

<P><b>Creating tables</b> The ADOX library is especially important because you 
can programmatically create tables along with their indexes and keys.</P>

<P>If you are comfortable adding tables in Design view, you only have to learn a little more to do it programmatically. You define the table and then append it to the catalog's <I>Tables </I>collection. Defining a table involves a similar kind of logic. You first declare a table object variable, and then you append columns to the object variable. When you append the columns, your code can assign data types and other column properties. After you finish defining a table, you might want to populate it with data. Earlier in the chapter, you saw two approaches to tackling this issue (using SQL code and the recordset's <I>AddNew </I>method.) We'll examine this topic in greater detail in Chapter 3.</P>

<P><b>Adding an index</b> The <I>AddIndex </I>procedure below demonstrates how to programmatically add an index to a table. As when you create a table, you use the <I>Append </I>method twice. First, you append one or more columns 
of data to your index. These columns define the index. Next, you set the <I>Name </I>property of the <I>Index</I> object. You can also set several other properties. The comment lines in the procedure below give instructions on how to set several optional properties and describe the impact of assigning values to the properties. After completing the specification of your index, you invoke the <I>Append </I>method again. This time, however, you use it to add the new index to the table's <I>Indexes </I>collection. This completes the task-unless there are run-time errors!</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub AddIndex()
Dim cat1 As New ADOX.Catalog
Dim tbl1 As New ADOX.Table
Dim idx1 As New ADOX.Index

    cat1.ActiveConnection = CurrentProject.Connection
    
    Set tbl1 = cat1.Tables(&quot;MyTable&quot;)

    idx1.Name = &quot;MyFirstIndex&quot;
    idx1.Columns.Append (&quot;Column1&quot;)

'Rules and syntax for setting IndexNulls property
'Does not create index if field contains Nulls; yields error.
'    idx1.IndexNulls = adIndexNullsDisallow
'Sets Ignore Nulls index property to Yes -- creates index.
'    idx1.IndexNulls = adIndexNullsIgnore
'Sets Ignore Nulls index property to No -- creates index.
'    idx1.IndexNulls = adIndexNullsIgnoreAny
  
'If you want to set the PrimaryKey property
'    idx1.PrimaryKey = True
'you must also set the Unique property for the
'primaryKey property to take effect and avoid an error.
'    idx1.Unique = True

    tbl1.Indexes.Append idx1

End Sub
</PRE>
</td></tr></table></P>

<P><I>PKErrorCatcher</I>, shown<I> </I>below, performs error trapping when you 
create a new primary key in a table. The same general error trapping approach 
works for other indexes and foreign keys. The error trap explicitly handles two 
types of errors and includes a more general trap for other errors.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub PKErrorCatcher()
On Error GoTo PKErrorCatcherTrap

Dim cat1 As New ADOX.Catalog
Dim tbl1 As New ADOX.Table
Dim idx1 As New ADOX.Index
Dim iNumber As Integer

    cat1.ActiveConnection = CurrentProject.Connection
    
    Set tbl1 = cat1.Tables(&quot;MyTable&quot;)

PKErrorCatcherTry:
    With idx1
        .Name = &quot;MyPrimaryKey&quot;
        .PrimaryKey = True
        .Unique = True
        .IndexNulls = adIndexNullsDisallow
    End With
  
    idx1.Columns.Append &quot;Column2&quot;
    tbl1.Indexes.Append idx1
  
    Set cat1 = Nothing
  
PKErrorCatcherExit:
    Exit Sub
  
PKErrorCatcherTrap:
    If Err.Number = -2147217856 Then
        MsgBox &quot;Table currently in use.&quot;
    ElseIf Err.Number = -2147467259 Then
        For Each idx1 In tbl1.Indexes
            If idx1.PrimaryKey = True Then
                tbl1.Indexes.Delete (iNumber)
                Resume PKErrorCatcherTry
            End If
            iNumber = iNumber + 1
        Next idx1
    Else
        MsgBox &quot;Error #&quot; &amp; Err.Number &amp; &quot;: &quot; &amp; Err.Description
End If
    Resume PKErrorCatcherExit

End Sub
</PRE>
</td></tr></table></P>

<P>The procedure starts by declaring new <I>Catalog</I>, <I>Table</I>, and <I>Index</I> objects. (A primary key is just an index with its <I>Unique </I>and <I>PrimaryKey</I> properties set to <I>True</I>.) The main portion of <I>PKErrorCatcher </I>sets the necessary properties, appends a column to the index, and then appends the index to the table. At least two conditions can cause these simple instructions to fail at run time. First, the table might be open. ADO assigns error number -2147217856 to this condition. When the error trap detects this error number, it displays a message telling the user that the table is currently in use. Second, the attempt to append a new primary key can fail if a primary key is already defined for the table. The procedure deletes the old obsolete primary key and then tries to create the primary key a second time. Since there is no longer a primary key, the routine cannot fail again for that reason.</P>

<P><b>Setting <I>autoincrement</I> field values</b> Access 2000 is the first version 
of Access that lets developers set the start and step value of <I>autoincrement </I>columns. You can programmatically set the start and step value of 
<I>autoincrement </I>columns by creating the table using Jet 4 SQL statements. You use the CREATE TABLE command to create the overall table, and you use the IDENTITY data type in Jet SQL for the <I>autoincrement </I>field. The IDENTITY data type has start and step values that let you specify the initial value for the <I>autoincrement </I>field, as well as how much it increases with each new record. The following <I>SetStartAndStep </I>procedure taps this new technology.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub SetStartAndStep()
Dim cnn1 As Connection
Dim cmd1 As Command
Dim tbl1 As New Table

    Set cnn1 = CurrentProject.Connection
    Set cmd1 = New ADODB.Command
  
    With cmd1
        .ActiveConnection = cnn1
'First create a table with two columns.
'Make one column an Identity column.
'Set its start value first, and its step value second.
        .CommandType = adCmdText
        .CommandText = &quot;CREATE TABLE Contacts (ContactID &quot; &amp; _
            &quot;IDENTITY(2,4),ContactName Char)&quot;
        .Execute
'After creating the table with the autoincrement/identity
'column you should add data.
        .CommandText = &quot;INSERT INTO Contacts(ContactName) &quot; &amp; _
            &quot;Values ('Kevin Mineweaser')&quot;
        .CommandType = adCmdText
        .Execute
        .CommandText = &quot;INSERT INTO Contacts(ContactName) &quot; &amp; _
            &quot;Values ('Mike Gilbert')&quot;
        .CommandType = adCmdText
        .Execute
        .CommandText = &quot;INSERT INTO Contacts(ContactName) &quot; &amp; _
            &quot;Values ('Neil Charney')&quot;
        .CommandType = adCmdText
        .Execute
    End With

End Sub
</PRE>
</td></tr></table></P>

<P>The code begins by creating a table. Although this procedure does not have an error-trapping routine, you should either make sure that such a table does not already exist or include an error trap to delete the table if it does exist. Within the CREATE TABLE statement, you specify the IDENTITY data type. 
You set the <I>autoincrement </I>field's first argument to the initial value and its second argument equal to the step. The code indicates that contacts will start with a value of 2 and increase by 4 for each new entry. Figure 2-13 shows the output from running the <I>SetStartAndStep </I>procedure. Notice that the <I>ContactID </I>field starts at 2 and increments in steps of 4. These are the settings for the IDENTITY data type specified in the procedure.</P>

<P><img src="Images/F02QH13.GIF" width=292 height=151 border="0">
</P><P><!-- CAPTION --><B>Figure 2-13.</B> <I>The output from the </I>SetStartAndStep <I>procedure.</I><!-- /CAPTION -->
</P>


<A NAME="68"><H3>The <I>View </I>object</H3></A>
<P>A <I>View </I>object is a row-returning query without any parameters that your 
application persists. When your application saves the other types of queries, 
it stores them as members of the <I>Procedures </I>collection. You can manipulate the <I>Views </I>collection members using the <I>Command </I>object and the <I>Views </I>and <I>Tables </I>collections. <I>View </I>objects have two critical properties for the purposes of this discussion: the <I>Name </I>property is the name of the view, and the <I>Command </I>property lets you get at the SQL statement underlying the view.</P>

<P>In this section, we'll construct a view using the <I>MakeAView </I>procedure and edit the SQL statement underlying an existing view using the <I>ChangeAView</I>procedure. Both the <I>MakeAView </I>and <I>ChangeAView </I>procedures tap the <I>ViewAView </I>procedure. The code prints three fields from either view to the Immediate window. You'll also learn how to delete a view.</P>

<P><b>Creating a view</b> The <I>MakeAView </I>procedure below adds a new view by creating a <I>Command </I>object that represents the view and appends 
the <I>Command </I>object to the <I>Views </I>collection. <I>MakeAView</I> needs a connection to a database. The <I>cnn1 Connection </I>object opens a link to the Northwind database. Then the application's code sets the <I>ActiveConnection </I>property of the <I>Command </I>object in the sample, 
<I>cmd1</I>, to <I>cnn1</I>. Next, and critically, the code sets the <I>CommandText </I>property of <I>cmd1</I>. The <I>CommandText </I>property holds the SQL statement that sets the view. The SQL statement in <I>MakeAView </I>constructs the view to reveal employee first and last names followed by their phone extensions. The code sets the <I>ActiveConnection </I>property of <I>cat1</I>, a <I>Catalog </I>object, to the Northwind database. An <I>Append </I>command names <I>cmd1 AllEmployees </I>and adds it to the Northwind catalog. Finally, <I>MakeAView</I> calls <I>ViewAView </I>to print the contents of the view<I> </I>to the Immediate window.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub MakeAView()

Dim cnn1 As New ADODB.Connection
Dim cmd1 As New ADODB.Command
Dim cat1 As New ADOX.Catalog


'Open the connection.
    cnn1.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;

'Create the command representing the view.
'Remember to delete it first.
    Set cmd1.ActiveConnection = cnn1
    cmd1.CommandText = &quot;SELECT FirstName, LastName, &quot; &amp; _
        &quot;Extension FROM Employees&quot;

'Open the catalog.
    Set cat1.ActiveConnection = cnn1

'Create the new view.
    cat1.Views.Append &quot;AllEmployees&quot;, cmd1

'Show the view.
    ViewAView

End Sub
</PRE>
</td></tr></table></P>

<P><b>Printing a view</b> The <I>ViewAView </I>procedure below prints the <I>AllEmployees </I>view. <I>ViewAView </I>starts by making a connection to the Northwind database, and then opens the <I>rst1 Recordset </I>object based on the <I>AllEmployees </I>view. Once the recordset is open and pointing to the right data source, the procedure takes a loop through the records to determine the longest name. Since the recordset is relatively small, there is not much of a penalty for making this extra pass. The maximum length for a name is convenient because it suggests a starting point for printing the extension after the name. This step allows the extension numbers to left align irrespective of the length of the names. Before starting the next loop through the names, <I>ViewAView</I> moves back to the recordset. Then, it moves through the names a second time. This time it constructs a string with the help of information gathered in the first loop.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub ViewAView()
Dim cnn1 As New ADODB.Connection
Dim rst1 As New ADODB.Recordset
Dim intMaxLength As Integer, Length As Integer

'Open the connection.
    cnn1.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\&quot; &amp; _
        &quot;Office\Samples\Northwind.mdb;&quot;

'Find the longest name.
    rst1.Open &quot;AllEmployees&quot;, cnn1
    Do Until rst1.EOF
        Length = Len(rst1.Fields(&quot;FirstName&quot;)) + _
        Len(rst1.Fields(&quot;LastName&quot;))
        If Length &gt; intMaxLength Then intMaxLength = _
            Length
        rst1.MoveNext
    Loop

'Print first name, last name, and third field.
    rst1.MoveFirst
    Do Until rst1.EOF
        strFiller = (intMaxLength + 2) - _
            (Len(rst1.Fields(&quot;FirstName&quot;)) + _
            Len(rst1.Fields(&quot;LastName&quot;)))
        Debug.Print rst1.Fields(&quot;FirstName&quot;) &amp; &quot; &quot; &amp; _
        rst1.Fields(&quot;LastName&quot;) &amp; String(strFiller, &quot; &quot;) &amp; _
        rst1.Fields(2)
        rst1.MoveNext
    Loop

End Sub
</PRE>
</td></tr></table></P>

<P><b>Modifying a view</b> The <I>ChangeAView </I>procedure below alters the SQL 
statement behind a view. You can use this simple approach to add new fields, 
replace old ones, or even change the whole design of the view, such as by 
adding sorting and filtering. The procedure modifies the view to show the 
<I>HomePhone </I>field instead of the <I>Extension </I>field.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub ChangeAView()
Dim cnn1 As New ADODB.Connection
Dim cat1 As New ADOX.Catalog
Dim cmd1 As New ADODB.Command

'Open the connection.
    cnn1.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\&quot; &amp; _
        &quot;Office\Samples\Northwind.mdb;&quot;

'Open the catalog.
    Set cat1.ActiveConnection = cnn1

'Update the view.
    cmd1.CommandText = &quot;SELECT FirstName, LastName, &quot; &amp; _
        &quot;HomePhone FROM Employees&quot;
    cat1.Views(&quot;AllEmployees&quot;).Command = cmd1

'Show view.
    ViewAView

End Sub
</PRE>
</td></tr></table></P>

<P>The trick to editing the SQL statement behind a view is to open the 
associated <I>Command </I>object and edit its <I>CommandText </I>property. To do this, you must point the <I>ActiveConnection </I>property of a <I>Catalog </I>object (see <I>cat1 </I>in the code above) to the database containing the view you want to edit-in this case, the Northwind database. Then you assign the SQL statement for the view you want to the <I>CommandText </I>property of a new <I>Command </I>object. Next, you assign that new 
<I>Command </I>object to the view that you want to change. The assignment automatically saves the new SQL statement over the old one.</P>

<P><b>Deleting a view</b> The <I>DeleteAView </I>procedure below deletes one view. It 
is almost too simple to include, but you will be glad to have it if you want to 
run <I>MakeAView </I>more than once because ADO doesn't let you append one view 
over another of the same name. Therefore, you must first delete the last created view in order to rerun <I>MakeAView</I>. To delete a view, you first set the <I>ActiveConnection </I>of a <I>Catalog </I>object to point at the database that has the view you want to delete. Then you invoke the <I>Delete </I>method for the <I>Views </I>collection while you reference the specific member you want expunged from the schema.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub DeleteAView()

Dim cat1 As New ADOX.Catalog

'Open the catalog.
    cat1.ActiveConnection = &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office\Office\&quot; &amp; _
        &quot;Samples\Northwind.mdb;&quot;

'Delete the procedure.
    cat1.Views.Delete (&quot;AllEmployees&quot;)

End Sub
</PRE>
</td></tr></table></P>

<A NAME="69"><H3>The <I>Procedure </I>object</H3></A>
<P>A procedure is a parameterized row-returning query or an action query that adds, deletes, or updates records. We'll discuss parameterized queries in 
this section; see <a href="ch04a.htm">Chapter 4</a> for more complete coverage of queries, including 
procedures that persist action queries.</P>

<P>Procedures and views are similar: Both can persist <I>Command </I>objects. Views represent nonparameterized row-returning queries, and procedures 
represent the remaining query types. If you enumerate the <I>Procedure </I>objects within a catalog, the enumeration will include the set of all views. However, procedures do not appear in an enumeration of <I>View 
</I>objects. The syntax for enumerating either is similar.</P>

<P><I>Procedure </I>objects have two critical properties for this discussion: 
<I>Name </I>and <I>Command</I>. The <I>Name </I>property is the name of the procedure. The <I>Command </I>property makes accessible the properties of the 
<I>Command </I>object behind the procedure. The <I>CommandText </I>property is particularly useful because it sets or returns the SQL statement for the <I>Command </I>object. You can use this property to modify the SQL statement in the command behind a procedure or to view the object's SQL statement. Examining the object's SQL statement can acquaint you with the parameters that you need to set in order to run a procedure.</P>

<P><b>Enumerating views and procedures</b> The <I>ListMyProcs </I>procedure below actually displays both the <I>Views </I>and <I>Procedures </I>collections. The first <I>For </I>loop enumerates only members of the <I>Views </I>collection. The second loop enumerates members of the <I>Procedures </I>collection and lists both procedures and views. The second loop also displays the SQL statement for each query that it enumerates.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub ListMyProcs()
Dim cnn1 As New Connection
Dim cat1 As New Catalog
Dim proc1 As Procedure
Dim view1 As View

'Set database connection for catalog.
    cnn1.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office&quot; &amp; _
        &quot;\Office\Samples\Northwind.mdb;&quot;
    Set cat1.ActiveConnection = cnn1

'Enumerate views -- notice this returns just
'nonparameterized row-returning queries.
    For Each view1 In cat1.Views
        Debug.Print &quot;View name: &quot; &amp; view1.Name
    Next view1

'Enumerate views -- this returns views
'and procedures.
    For Each proc1 In cat1.Procedures
        Debug.Print &quot;Procedure name: &quot; &amp; proc1.Name
        Debug.Print &quot;SQL: &quot; &amp; proc1.Command.CommandText
    Next proc1
End Sub
</PRE>
</td></tr></table></P>

<P>Views and procedures let you persist commands. You simply append the <I>Command </I>object to the appropriate collection. The following code saves 
a parameter query as a stored procedure. This query uses the <I>MyTable </I>table (which appears in several of the preceding procedure examples), and it is available on the companion CD along with the samples to manipulate it. 
Design and Datasheet views of <I>MyTable </I>appear in Figures 2-7 and 2-8.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub SaveParmeterQuery()
On Error GoTo SavePQTrap
Dim cmd1 As Command
Dim cnn1 As New Connection
Dim cat1 As New adox.Catalog

'Create connection.
    Set cnn1 = CurrentProject.Connection

'Create and define command.
    Set cmd1 = New ADODB.Command
    
    With cmd1
        .ActiveConnection = cnn1
        .CommandText = &quot;Parameters [Lowest] Long;&quot; &amp; _
            &quot;SELECT Column1, Column2, Column3 &quot; &amp; _
            &quot;FROM MyTable &quot; &amp; _
            &quot;Where Column1&gt;=[Lowest]&quot;
        .CommandType = adCmdText
    End With

'Open the catalog.
Set cat1.ActiveConnection = cnn1

'Create the new procedure based on parameter query.
cat1.Procedures.Append &quot;spLowestRow&quot;, cmd1

SavePQExit:
    Exit Sub

SavePQTrap:
    If Err.Number = -2147217816 Then
'If err.number = -214... query already exists
        deleteProcedure(&quot;spLowestRow&quot;)
        Resume
    Else
        Debug.Print Err.Number, Err.Description
    End If

End Sub

Sub deleteProcedure(procName as String)
Dim cnn1 As New Connection
Dim cat1 As New adox.Catalog

'Open the catalog.
    Set cnn1 = CurrentProject.Connection
    Set cat1.ActiveConnection = cnn1

'Delete existing procedure.
    cat1.Procedures.Delete (procName)

End Sub
</PRE>
</TD></TR></TABLE></P>

<P>The procedure constructs a parameter query and saves it as a stored  procedure. Its query prompts for the lowest value to appear in the first 
column. Notice that you can set the <I>CommandText </I>and <I>CommandType </I>properties for the query. The SQL statement includes a declaration for the parameter. After creating the <I>Command </I>object for a stored procedure, you use the <I>Append </I>method of the <I>Procedures </I>collection to persist the 
<I>Command </I>object as a stored procedure. If you run <I>SaveParameterQuery</I> more than once, the second attempt to save spLowestRow generates a run-time error. <I>SaveParameterQuery</I> traps for this error and deletes the old copy if it already exists. The procedure that 
deletes the stored procedure accepts an argument for the name of the procedure 
to delete. The <I>ParameterQCommand </I>procedure, shown earlier, performs the 
same task as the stored procedure, <I>spLowestRow</I>. Since ADO runs stored 
procedures as compiled objects, they run faster than when you construct a 
<I>Command </I>object each time you want to execute a SQL statement.</P>

<P><b>Creating and running stored procedures</b> The following pair of procedures prepares and runs a stored procedure. The first procedure creates a stored procedure that looks up the extension number for employees in the Northwind database; the second procedure invokes the stored procedure.</P>

<P><TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<PRE>
Sub procLookupNumber()
Dim cnn1 As New ADODB.Connection
Dim cmd1 As New ADODB.Command
Dim prm1 As ADODB.Parameter
Dim cat1 As New ADOX.Catalog

'Open the connection.
    cnn1.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office&quot; &amp; _
        &quot;\Office\Samples\Northwind.mdb;&quot;

'Create the parameterized command.
    Set cmd1.ActiveConnection = cnn1
    cmd1.CommandText = &quot;SELECT FirstName, LastName, Extension &quot; &amp; _
        &quot;FROM Employees WHERE LastName = [LName]&quot;
    Set prm1 = cmd1.CreateParameter(&quot;[LName]&quot;, adWChar, adParamInput, 20)
    cmd1.Parameters.Append prm1

'Open the catalog.
    Set cat1.ActiveConnection = cnn1

'Create the new procedure based on parameter query.
    cat1.Procedures.Append &quot;spEmployeeExtension&quot;, cmd1

End Sub


Sub RunLookUpProc()
Dim cnn1 As New Connection
Dim cat1 As New Catalog
Dim rst1 As New Recordset
Dim cmd1 As New Command
Dim prm1 As Parameter
Dim typedName As String

'Create and assign a connection for the catalog.
    cnn1.Open &quot;Provider=Microsoft.Jet.OLEDB.4.0;&quot; &amp; _
        &quot;Data Source=C:\Program Files\Microsoft Office&quot; &amp; _
        &quot;\Office\Samples\Northwind.mdb;&quot;
    Set cat1.ActiveConnection = cnn1

'Set the Command and parameter object references.
    Set cmd1 = cat1.Procedures(&quot;spEmployeeExtension&quot;).Command
    Set prm1 = cmd1.CreateParameter(&quot;[LName]&quot;, adWChar, adParamInput, 20)
    cmd1.Parameters.Append prm1

'Gather the parameter value from the user and assign it.
    typedName = InputBox(&quot;Last name for extension?&quot;, _
        &quot;Programming Microsoft Access 2000&quot;)
    prm1.Value = typedName

'Execute the parameter query and show first match.
    cmd1.Execute
    rst1.Open cmd1
    MsgBox &quot;The extension for &quot; &amp; rst1.Fields(0) &amp; _
        &quot; &quot; &amp; rst1(&quot;LastName&quot;) &amp; &quot; is &quot; &amp; rst1.Fields(2), _
        vbInformation, &quot;Programming Microsoft Access 2000&quot;

End Sub
</PRE>
</TD></TR></TABLE></P>

<P>The <I>procLookupNumber </I>procedure creates a persistent parameter query as a stored procedure. This query looks up a telephone number extension for an employee based on the employee's last name. The procedure defines the <I>Command </I>object and its associated parameter, <I>[LName]</I>. The <I>adWChar </I>constant designates the parameter as a fixed-width text string. The <I>adParamInput </I>constant designates this parameter for input only, and the trailing number denotes that the parameter can contain up to 20 characters. After defining both the <I>Command </I>and its associated parameter, the procedure sets the catalog connection to the Northwind database and appends the 
<I>Command </I>object to the <I>Procedures </I>collection with the name 
<I>spEmployeeExtension</I>.</P>

<P>If you run <I>procLookupNumber </I>more than once, it will fail when it tries to write <I>spEmployeeExtension</I> over itself. Add error trapping to detect this situation. Then create a delete routine. You will need to edit the one used in the previous sample since it deletes procedures in the current project, and this sample needs to delete procedures in the Northwind database.</P>

<P>The <I>RunLookUpProc </I>procedure runs the stored procedure created by 
the <I>procLookupNumber </I>procedure. This short procedure does four things:</P>

<UL>
<P><LI>
It creates a connection to the database with the stored procedure.
</LI></P>

<P><LI>
It designates object variables that point at the stored procedure and its parameter. The code uses a <I>Command </I>object to refer to the stored procedure.
</LI></P>

<P><LI>
It displays a dialog box in which the user must indicate the last name of the employee's extension. The code assigns the return value from the dialog box to the command's parameter.
</LI></P>

<P><LI>
It executes the command and opens a recordset based on the command's return set. It displays the first row from the return set in a dialog box. The code uses both naming conventions for selecting one member from the <I>Fields </I>collection in a recordset. You can use either its ordinal position or its <I>Name </I>property.
</LI></P>
</UL>

</BODY>
</HTML>




