<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Working with Outlook from Access</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch09c.htm", "ch09e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="313"><H1>Working with Outlook from Access</H1></A>

<P>Outlook comes with a standard set of folders, including folders for its calendar, contacts, deleted items, drafts, e-mail inbox, journal, notes, e-mail outbox, 
sent e-mail, and tasks. Users can also add custom folders and can nest folders within one another. Users work with items within their folders&#8212;adding, 
deleting, viewing, and performing other functions.</P>


<p>
The initial version of Outlook shipped with programmatic support only through Microsoft VB Script. Outlook 2000 adds programmatic control with VBA. Outlook 2000 supports scripting with either VBA or VB Script. For compatibility with the rest of the book, this section focuses on scripting Outlook from 
Access using VBA. In addition, all the samples use the Contacts folder to provide a familiar context.</P>


<p>
You can establish a reference to an instance of Outlook in Access with the 
<I>CreateObject </I>function. Before you can reference a particular folder, you typically must apply the <I>GetNameSpace </I>method to the 
<I>Application </I>object. The 
<I>NameSpace </I>object is an abstract root object that exists between the 
<I>Application </I>object and individual folders. The method takes a single argument, which must be 
<I>MAPI </I>for the current release. You apply the 
<I>GetDefaultFolder </I>method to the 
<I>NameSpace </I>object to get the default folder of a certain type. You use a constant to designate which default folder your application will manipulate. The Contacts folder constant is 
<I>olFolderContacts</I>.</P>


<A NAME="314"><H2>Enumerating Items in the Contacts Folder</H2></A>

<P>The following procedure manipulates the Contacts folder to enumerate all its items. You can set up a sample Contacts folder with a few entries to evaluate this and subsequent samples. The book's companion CD also includes some sample contact information for populating a Contacts folder.</P>


<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>
Sub listContacts()
Dim myOlApp As Outlook.Application
Dim myNameSpace As NameSpace
Dim myContacts As Items
Dim myItem As ContactItem

'Create an instance of Outlook.
'Reference its MAPI Namespace.
'Reference MAPI's Contact folder.
    
    Set myOlApp = CreateObject(&quot;Outlook.Application&quot;)
    Set myNameSpace = myOlApp.GetNamespace(&quot;MAPI&quot;)
    Set myContacts = _
        myNameSpace.GetDefaultFolder(olFolderContacts).Items

'Enumerate items in Contact folder and
'print selected fields.
    For Each myItem In myContacts
        Debug.Print myItem.FirstName, myItem.LastName, _
            myItem.Email1Address
    Next

End Sub
</pre>
</td>
</tr>
</table></P>


<P>The procedure starts by declaring four variables: one for the Outlook 
application, one for its 
<I>NameSpace </I>object, one for the collection of items in 
the Contacts folder, and one for enumerating those items. It takes three 
<I>Set </I>statements to expose the items in the Contacts folder. The last of these uses the <I>GetDefaultFolder </I>method to return the Contacts folder, and it uses the 
<I>Items </I>property to access the individual items. The enumeration takes place with a 
<I>For...Each </I>loop. The items in the Contact folder have a series of properties 
that identify information about contacts. The sample uses three of these 
properties to print the first name, last name, and first e-mail address for each entry in 
the Contacts folder.</P>


<A NAME="315"><H2>Adding an Item to the Contacts Folder</H2></A>

<P>You can also build Access-based solutions that manipulate the contents of the Contacts folder. The first of the next three procedures, 
<I>addOneContact</I>, inserts a new contact into the folder. It uses string constants to define the first 
name, last name, and e-mail address for a contact, but you can easily modify the procedure to pass these as arguments. The next two procedures, 
<I>removeOneEmail </I>and 
<I>deleteAContact</I>, do just that. The 
<I>removeOneEmail </I>procedure passes an e-mail address to the 
<I>deleteAContact </I>procedure, finds a contact item with 
a matching e-mail address, and then deletes it.</P>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>Sub addOneContact()
Dim myOlApp As Outlook.Application
Dim myItem As ContactItem

'Create an instance of Outlook.
    Set myOlApp = CreateObject(&quot;Outlook.Application&quot;)

'Create an item for the folder.
'Populate the item with values.
'Save the item.
    Set myItem = myOlApp.CreateItem(olContactItem)
    With myItem
        .FirstName = &quot;foo&quot;
        .LastName = &quot;bar&quot;
        .Email1Address = &quot;foobar@yourcompany.com&quot;
        .Save
    End With

End Sub


Sub removeOneEmail()
    deleteAContact (&quot;foobar@yourcompany.com&quot;)

End Sub


Sub deleteAContact(strEmail)
Dim myOlApp As Outlook.Application
Dim myNameSpace As NameSpace
Dim myContacts As Items
Dim myItem As ContactItem

'Create an instance of Outlook.
'Reference its MAPI Namespace.
'Reference MAPI's Contact folder.
    Set myOlApp = CreateObject(&quot;Outlook.Application&quot;)
    Set myNameSpace = myOlApp.GetNamespace(&quot;MAPI&quot;)
    Set myContacts = _
        myNameSpace.GetDefaultFolder(olFolderContacts).Items

'Enumerate to search for item to delete.
    For Each myItem In myContacts
        If myItem.Email1Address = strEmail Then
            myItem.Delete
            Exit Sub
        End If
    Next

'No entry found
    MsgBox &quot;No entry found with email of &quot; &amp; strEmail, vbCritical, _
        &quot;Programming Microsoft Access 2000&quot;

End Sub
</pre>
</td>
</tr>
</table></P>


<P>The procedure requires just two objects&#8212;the Outlook 
<I>Application </I>object and a 
<I>ContactItem </I>object to represent an item in the Contacts folder. The 
procedure creates a reference to the 
<I>Application </I>object with the 
<I>CreateObject </I>function. This reference supports the 
<I>CreateItem </I>method, which creates an empty instance of an item for any specified folder. You designate the type of folder for the item using a constant that you pass to the 
<I>CreateItem </I>method. You can choose from more than 140 properties to specify the characteristics of a contact. The sample assigns string constants for the 
<I>FirstName</I>, 
<I>LastName</I>, and 
<I>Email1Address </I>properties. (Yes, each contact can have more than one e-mail address.) 
Then it invokes the 
<I>Save </I>method to store the new entry in the Contacts folder.</P>


<A NAME="316"><H2>Deleting an Item from the Contacts Folder</H2></A>

<P>The 
<I>deleteAContact </I>procedure accepts a string argument that is the value of the 
<I>Email1Address </I>property of the contact item to delete. The procedure enumerates members of the Contacts folder until it finds one with an 
<I>Email1Address </I>property that matches the passed argument. When it finds a match, it removes the item by invoking the 
<I>Delete </I>method and exits the procedure to eliminate further searching. If the procedure enumerates 
the entire contents of the Contacts folder without discovering a match, control 
passes to a message box statement, which reports that no entries match the 
e-mail address passed to it.</P>


<A NAME="317"><H2>Adding Multiple Items to the Contacts Folder</H2></A>

<P>One common task performed with a database manager such as Access is adding multiple contact items to the Contacts folder. These contacts can come 
from any source, such as the Contacts folder on another computer, addresses 
entered over the Internet, or even an old Access contact file. The 
<I>addContacts </I>procedure below uses one approach to updating an Outlook Contacts folder with 
the contact information in an Access table.</P>


<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>
Sub addContacts()
Dim myOlApp As Outlook.Application
Dim myItem As ContactItem
Dim rst1 As New Recordset

'Open the Contacts folder in Outlook.
    Set myOlApp = CreateObject(&quot;Outlook.Application&quot;)
    
'Open the table with the new contacts.
    With rst1
        .ActiveConnection = CurrentProject.Connection
        .Open &quot;oe4pab&quot;
    End With

'Create a ContactItem for adding contacts and
'loop through the table records to add them to the folder.
    AssistantWorkingOn
    Do Until rst1.EOF
        Set myItem = myOlApp.CreateItem(olContactItem)
        With myItem
            .FirstName = IIf(IsNull(rst1.Fields(0)), _
            &quot;&quot;, rst1.Fields(0))
            .LastName = rst1.Fields(1)
            .Email1Address = rst1.Fields(2)
            .Save
        End With
        rst1.MoveNext
    Loop
    AssistantIdleOn

End Sub
</pre>
</td>
</tr>
</table></P>


<P>The procedure sets a reference to the Outlook application and then opens a recordset based on the <I>oe4pab </I>table. This is the local table in the Access 
Tables folder. The table contains just 34 entries, but the procedure can accommodate a much longer list of addresses. For this reason, the procedure calls 
another procedure that turns on the Assistant with a working animation and leaves it on until Access and Outlook finish updating the Outlook Contacts folder 
with the entries in the 
<I>oe4pab </I>table. (Chapter 8 describes how to design procedures to control Assistant animation. You can find the procedures for Assistant animation in the Chap08 directory on the companion CD.) In between the two calls to turn Assistant animation on and off, a 
<I>Do </I>loop iterates through all the records in the 
<I>oe4pab </I>table. The loop creates a new 
<I>ContactItem </I>object on each pass, and then it assigns the records for that pass to the item and saves the item.</P>


<A NAME="318"><H2>Deleting Multiple Items from the Contacts Folder</H2></A>

<P>The following procedure, 
<I>removeEmails</I>, is an adaptation of the 
<I>deleteAContact </I>procedure shown earlier. It deletes multiple records from a Contacts folder. 
It removes one item at a time by successively calling 
<I>deleteAContact </I>with different e-mail addresses. The sample uses the addresses in the 
<I>oe4pab </I>table as the source for the arguments. This procedure offers two advantages: it is easy to write and it reuses the 
<I>deleteAContact </I>procedure.</P>


<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>
Sub removeEmails()
Dim rst1 As New Recordset

'Open the table with the new contacts.
    With rst1
        .ActiveConnection = CurrentProject.Connection
        .Open &quot;oe4pab&quot;
    End With
    

'Loop through the table records to add them to the folder.
    AssistantWorkingOn
    Do Until rst1.EOF
        deleteAContact (rst1.Fields(2))
        rst1.MoveNext
    Loop
    AssistantIdleOn

End Sub</pre>
</td>
</tr>
</table></P>



<P>While this procedure can get the job done, it has at least two deficiencies. First, it searches through the Contacts folder for each item that it wants to 
remove. This gets increasingly costly as the number of items to delete grows, 
the number of items in the Contacts folder grows, or both. Second, if there is 
no match for an item, it pauses with a message box that requires the user to 
click a button to proceed. If there are numerous entries in the list of items to 
delete that are already missing from the Contacts folder, having to click a 
button for each item not present in the folder can become tedious. One solution to these 
weaknesses is to replace the call to 
<I>deleteAContact </I>with a call to 
<I>deleteAContact2</I>, shown below.</P>


<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>
Sub deleteAContact2(strEmail)
On Error GoTo delete2Trap
Dim myOlApp As Outlook.Application
Dim myNameSpace As NameSpace
Dim myContacts As Items
Dim myItem As ContactItem
Dim strFilter As String

'Create an instance of Outlook.
'Reference its MAPI Namespace.
'Reference MAPI's Contact folder.
    Set myOlApp = CreateObject(&quot;Outlook.Application&quot;)
    Set myNameSpace = myOlApp.GetNamespace(&quot;MAPI&quot;)
    Set myContacts = _
        myNameSpace.GetDefaultFolder(olFolderContacts).Items
    
'Find target item and remove it.
    strFilter = &quot;[Email1Address] = &quot;&quot;&quot; &amp; strEmail &amp; &quot;&quot;&quot;&quot;
    Set myItem = myContacts.Find(strFilter)
    myItem.Delete

delete2Exit:
    Exit Sub
    
delete2Trap:
    If Err.Number = 91 Then
'If item is not there, just keep on going.
        Resume Next
    Else
'Otherwise, pause with a message box.
        MsgBox Err.Number &amp; &quot;: &quot; &amp; vblfcr &amp; _
            Err.Description, vbCritical, _
            &quot;Programming Microsoft Access 2000&quot;
        Resume Next
    End If

End Sub
</pre>
</td>
</tr>
</table></P>


<P>This procedure expedites the search for an item to delete by using the 
<I>Find </I>method. It constructs a criterion for the 
<I>Find </I>method based on the e-mail address passed to it. After finding an item with a matching e-mail address, it applies the 
<I>Delete </I>method to that item. Using 
<I>Find </I>saves a noticeable amount of time even with a short list of items such as those in the 
<I>oe4pab </I>table, but its speed advantage grows with longer lists of e-mail addresses or with 
Contact folders that have many items. The procedure also traps failures of the 
<I>Find </I>method to return an item. This happens when there is no matching item in 
the Contacts folder for an e-mail address. In this situation, 
<I>deleteAContact2 </I>silently returns control to the calling routine so that it can search again for a new 
e-mail address. There is no need for operator intervention.</P>


</BODY>
</HTML>




