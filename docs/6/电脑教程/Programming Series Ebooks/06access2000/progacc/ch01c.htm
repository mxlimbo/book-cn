<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Procedures and Modules</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch01b.htm", "ch01d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="8"><H1>Procedures and Modules</H1></A>

<P>Procedures are containers for VBA code. There are three types of these 
containers: subprocedures, function procedures, and property procedures. 
Although their functions overlap in some areas, each type has a specific and 
unique purpose. Access offers two basic kinds of containers for procedures: 
standard modules and class modules. Class modules can be custom classes for forms 
and reports. You can also use them to define your own classes to simplify reuse 
of code for such routine tasks as adding new employees, making a deposit to 
an account, or withdrawing money from an account.</P>

<A NAME="9"><H2>Sub Procedures</H2></A>

<P>Sub procedures can perform actions, compute values, and update and 
revise built-in property settings. (&quot;Sub procedure&quot; is usually shortened to 
&quot;subprocedure&quot; or simply 
&quot;procedure.&quot;) As you have seen, Access 2000 automatically 
invokes procedures for events, but you can use them more broadly. Procedures 
never return values. They also do not define custom properties for form, report, 
or class modules.</P>

<P>A procedure consists of a series of VBA statements between 
<I>Sub </I>and <I>End Sub </I>statements. The <I>Sub 
</I>statement must declare a name for the procedure. 
While event procedures have very stylized names (such as 
<I>object_event</I>), procedure names generally follow standard variable naming conventions. They must 
begin with a letter, cannot exceed 255 characters, cannot include punctuation 
or spaces, and should not include a VBA keyword, function, or operator 
name. Procedures can take arguments, which you insert after the procedure name. 
If there is more than one argument, you separate them with commas.</P>

<P>One way to gain a basic familiarity with procedures is by using the 
Command Button wizard, which writes VBA code for more than 30 functions. 
All you have to do is make a few selections in dialog boxes. The procedures 
written by the wizard are generally simple, so they make good learning 
models. Even intermediate and advanced developers can benefit from the wizard 
because it generates a good skeleton for adding code with more specifics. 
Beginners can use the wizard to quickly automate record navigation, 
database maintenance, general form and report operations, invoking of other 
applications, and miscellaneous tasks such as running a query or dialing a 
phone number.</P>

<P>You invoke the Command Button wizard from the toolbox in Form 
Design view. Select the Control Wizards button and then drop a button on the 
form. This opens the dialog box shown in Figure 1-3. You can select from about 
a half dozen actions in each category. After completing all the dialog boxes 
for the action you select, you can view the code in Access 2000 VBE. Click the 
Code button on the Form Design toolbar to switch to VBE.</P>


<P><A HREF="javascript:fullSize('F01QH03x.htm')"> <img src="Images/F01QH03.JPG" width=404 height=285 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 1-3.</B> <I>Using the Command Button wizard, you can create a whole event procedure by replying to a few dialog boxes.</I><!-- /CAPTION -->
</P>


<P>Many developers prefer to write their procedures from scratch. You 
can open a code window for an event procedure as described above, or you 
can create an ordinary procedure. There are two ways to start this kind of 
procedure, depending on where you put it. If the procedure is to reside behind a 
form or report, click the Code button on the Design toolbar. If the code is to exist 
in a standard module that is not behind any specific form or report, choose 
Tools-Macro-Visual Basic Editor or press Alt+F11. In either case, you end up in 
VBE. Choose Insert-Procedure, and in the Add Procedure dialog box enter a 
name and confirm the selection of the Sub option button. This creates a shell for 
a procedure with a <I>Sub </I>and an <I>End Sub 
</I>statement. You can then add code to it.</P>
<P>Use your knowledge of the Access object model to code some 
actions. Recall that the <I>DoCmd </I>object has many methods. Type 
<I>DoCmd </I>and then press the period key. This opens a drop-down list box that displays all the 
legitimate entries after <I>DoCmd</I>. As you type an entry, Access converges on the subset 
of responses that match your entry. (See Figure 1-4.) If you are unsure what to 
type, you can scroll through the entries to find a method. This technique works 
for all objects, not just <I>DoCmd</I>. Microsoft calls this feature IntelliSense because 
it intelligently senses the subset of appropriate replies. IntelliSense actually 
does two things: It lists the properties and methods that are legitimate at any 
point in the construction of a VBA statement, and it provides syntax information 
about the content for the fields required for selected VBA statements. This 
dramatically reduces errors and helps you get started quickly.</P>

<P><A HREF="javascript:fullSize('F01QH04x.htm')"> <img src="Images/F01QH04.JPG" width=404 height=224 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 1-4.</B> <I>IntelliSense helps to complete a VBA statement for the </I>DoCmd <I>object. You type the beginning of a statement, and it shows a list of legitimate replies for the balance of that portion of the statement.</I><!-- /CAPTION -->
</P>


<P>The following is a simple procedure consisting of three lines. The first 
line reserves a memory location for a calculated result. The second adds two 
constants. The third prints the result in the Immediate window. This window is 
like a work pad for storing intermediate results as you check your code. You 
can open it from VBE by choosing View-Immediate Window. You can run the 
procedure from VBE by clicking anywhere in the procedure and then clicking 
the Run Sub/UserForm button on the Standard toolbar.</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Sub MyFirstCalculator()
Dim Result
    Result = 1 + 2
    Debug.Print Result
End Sub
</pre>
</TD></TR></TABLE></P>


<P>In a more typical situation, you can call a procedure in either of two 
ways. You can include its name on a line by itself; if the procedure has any 
arguments, you can include them after the name, separated by commas. Alternatively, 
you can precede the procedure name with 
<I>Call</I>. This is a VBA keyword for invoking a procedure. When you use 
<I>Call</I>, enclose arguments in parentheses 
after the procedure name.</P>
<P>The following is a slightly more flexible version of the initial 
calculator function. The calculator consists of a pair of procedures. The one 
named <I>MySecondCalculator </I>adds any two numbers and prints the result to the 
Immediate window. It determines what numbers to add from the two arguments 
that it receives. The other procedure calls the procedure that performs the sum. 
You can vary the numbers the second procedure adds by altering the value of 
the two arguments in the first procedure. In a more sophisticated application, 
you might tie these argument values to variables or form fields.</P>


<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Sub CallSecondCalculator()
    MySecondCalculator 1, 3
End Sub

Sub MySecondCalculator(First, Second)
Dim Result
    Result = First + Second
    Debug.Print Result
End Sub
</pre>
</TD></TR></TABLE></P>


<A NAME="10"><H2>Function Procedures</H2></A>


<P>Function procedures&#8212;usually called &quot;functions&quot;&#8212;differ from procedures in 
a couple of ways. First, they can return a value, so you can use them in 
expressions just as you use variables. Second, they do not serve as event 
procedures. Both procedures and functions can perform tasks. With the exceptions 
noted, functions and procedures are generally interchangeable.</P>
<P>A function is a collection of VBA statements bounded by 
<I>Function </I>and <I>End Function </I>statements. It can accept arguments in the same way that a 
procedure accepts arguments. A function can include one or more expressions. 
At least one of these can set the function's name equal to a value. You can 
terminate a function after setting its value by using an 
<I>Exit Function </I>statement. Any function can contain one or more 
<I>Exit Function</I> statements.</P>

<P>Although a function can return a value, it does not have to. A function 
can be a collection of statements that invoke methods and set properties 
without ever setting the function name equal to a value. This is one way in which 
functions and procedures are similar.</P>

<P>You start a function just like you do a procedure, but you select the 
Function option button instead of the Sub option button in the Add Procedure 
dialog box. You can invoke a function procedure by clicking the Run 
Sub/UserForm button on the Standard toolbar in VBE. You can also invoke a function 
from the Immediate window: Type a question mark followed by the function 
name. If the function has arguments, you place these in parentheses, separated 
by commas. You can run your own custom functions as well as built-in 
Access functions from the Immediate window.</P>

<P>Figure 1-5 shows a view of VBE with a simple function that 
determines whether the date submitted as an argument is in the third millennium. To 
match popular conventions, we'll compute this millennium to start in the year 
2000 rather than 2001. The function <I>Year2KTest 
</I>accepts a date and returns <I>3</I> if the date is in the third millennium, or returns 
<I>0</I> otherwise. The Immediate window below the code window shows the outcome for running the function with 
two different dates. The Immediate window in Figure 1-5 confirms this result 
by returning a <I>3</I> for the first day in 2000 and a 
<I>0</I> for the first day in 1999. Notice that you must enclose a date between pound signs.</P>


<P><A HREF="javascript:fullSize('F01QH05x.htm')"> <img src="Images/F01QH05.JPG" width=404 height=269 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 1-5.</B> <I>A simple function invoked from the Immediate window.</I><!-- /CAPTION -->
</P>


<P>The procedure below is a more sophisticated 
approach to millennium assessment. The function starts by declaring the range of 
dates for which it is accurate. Then it tests its argument against two 
millennium milestones. If the date does not fall within the first or second millennium, 
the function assumes that it belongs in the third millennium. The initial 
message box statement indicates the range of dates for which the function is accurate.</P>


<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>Public Function PopularMillennium(dtmDateIn) As Byte
    MsgBox &quot;This works for dates after 12/31/0099&quot; &amp; _
        &quot; and before 1/1/3000.&quot;, _
        vbInformation, _
        &quot;Programming Microsoft Access 2000&quot;
    If dtmDateIn &lt;= #12/31/999# Then
        PopularMillennium = 1
    ElseIf dtmDateIn &lt;= #12/31/1999# Then
        PopularMillennium = 2
    Else
        PopularMillennium = 3
    End If
End Function
</pre>
</TD></TR></TABLE></P>


<P>Access 2000 dates are valid from 1/1/100 through 12/31/2999. This 
range is sufficient for the vast majority of desktop applications. If you need a 
range beyond these dates, you should consider coding dates independently of 
the Access serial date system.</P>


<P><DIV CLASS="NOTE"><BLOCKQUOTE><B>NOTE</B><HR>
Access 2000 is Year 2000-compliant. Like previous versions, 
it stores dates with the full four digits. Access 2000 also handles leap 
years correctly: Years divisible by 4 are leap years unless they are divisible 
by 100. However, if they are divisible by 400, they are leap years. Since 
2000 is divisible by 400, it is a leap year. This rule is critical for computing 
the difference between two dates. The General Date and Short Date 
formats in Access use the operating system's short date format options to 
determine the correct display. If you set your Regional settings in the 
Control Panel to show dates with four-digit years, all of the General date 
formats will show the full four digits.
</BLOCKQUOTE></DIV></P>


<P>The above rules do not force you to program in such a way that Y2K 
issues cannot emerge. Therefore, any Access application can have a Y2K bug 
even though Access 2000 is Year 2000-compliant. Visit 
www.microsoft.com/technet/topics/year2k/default.htm for Microsoft's overview of the topic along 
with specific product and version Y2K compliance reviews. The FMS 
site (www.fmsinc.com/tpapers/index.html#Year 2000 Papers) has a different 
perspective on some Y2K/Access issues. FMS markets a product called Total 
Access Inspector 2000 that specifically detects Y2K issues in Access applications.</P>

<P>You can often use both procedures and functions to develop a 
solution to a problem. Figure 1-6 shows a form that relies on both kinds of functions 
to develop answers. The form allows a user to type values in the text boxes 
labeled Number 1 and Number 2. Clicking a function button of /, *, 
-, or + computes a corresponding outcome in the Result text box.</P>


<P><A HREF="javascript:fullSize('F01QH06x.htm')"> <img src="Images/F01QH06.JPG" width=404 height=168 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><B>Figure 1-6.</B> <I>This form serves as a simple calculator. VBA functions enable the form's buttons and populate the Result text box based on entries in the other two text boxes.</I><!-- /CAPTION -->
</P>


<P>The VBA code to implement the form in Figure 1-6 uses just four pairs 
of procedures, as shown below. Four procedures act as the event handler for 
a click to the four function keys on the form. These event handlers simply call 
a function that pulls the values from the two text boxes, executes the 
computation indicated by the function button, and returns that value to the event 
procedure. The event procedure, in turn, assigns the return value from the 
function to the third text box on the form. Notice the optional use of the 
<I>Me </I>prefix before the text box names. Since the code is behind the form with the text box, 
specifying the form name is optional. The event procedures use 
<I>Me </I>instead of the form's longer, more formal class name 
(<I>Form_frmCalculator1</I>).</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Option Compare Database
Option Explicit
Dim dblResult As Double

Private Sub cmdAddition_Click()
    Me.txtResult = MyAdder
End Sub

Private Function MyAdder()
    dblResult = CDbl(txtNumber1) + CDbl(txtNumber2)
    MyAdder = dblResult
End Function

Private Sub cmdSubtraction_Click()
    Me.txtResult = MySubtractor
End Sub

Private Function MySubtractor()
    dblResult = CDbl(txtNumber1) - CDbl(txtNumber2)
    MySubtractor = dblResult
End Function

Private Sub cmdMultiplication_Click()
    Me.txtResult = MyMultiplier
End Sub

Private Function MyMultiplier()
    dblResult = CDbl(txtNumber1) * CDbl(txtNumber2)
    MyMultiplier = dblResult
End Function

Private Sub cmdDivision_Click()
    Me.txtResult = MyDivider
End Sub

Private Function MyDivider()
    dblResult = CDbl(txtNumber1) / CDbl(txtNumber2)
    MyDivider = dblResult
End Function
</pre>
</TD></TR></TABLE></P>


<P>The function and the procedures reside in the code module behind 
the form. The <I>Dim </I>statement at the top of the module declares a variable that 
all of the procedures in the module can use. Since users can click only one 
function key at a time, this sharing of <I>dblResult 
</I>works. The <I>Option Explicit </I>statement forces the declaration of variables before their use. This helps to guard 
against typographical errors, which are a common source of errors in programs. 
<I>Option Compare Database </I>is a module-level specification that designates 
string variables sorted in an order determined by the locale ID in the Control Panel.</P>

<P>The following pair of procedures illustrates much of what we 
have covered about procedures, functions, and methods. The form, 
<I>frmCalculator2</I>, has just two controls: a text box named 
<I>txtInput</I> and a command button named 
<I>cmdSquarer</I>. The form computes the square of the entry in the text box 
when the user clicks the button. The procedures display the result in a message box.</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Option Compare Database
Option Explicit
Dim dblResult As Double

Private Sub cmdSquarer_Click()
    MySquarer Form_frmCalculator2.txtInput
End Sub

Public Sub MySquarer(MyOtherNumber As Double)
    dblResult = MyOtherNumber * MyOtherNumber
    MsgBox dblResult, vbInformation, _
        &quot;Programming Microsoft Access 2000&quot;
'Optional statements illustrating the use of methods
'    DoCmd.GoToControl &quot;txtInput&quot;
'    txtInput.SetFocus
'    DoCmd.Close acForm, &quot;frmCalculator2&quot;, acSaveNo
End Sub
</pre>
</TD></TR></TABLE></P>


<P>The <I>cmdSquarer_Click</I> event procedure invokes the 
<I>MySquarer</I> procedure and passes the contents of 
<I>txtInput </I>as an argument. <I>MySquarer </I>computes 
its result and then displays the result in a message box.</P>

<P>Three more comment lines suggest additional actions that you can 
perform. A line calling the <I>GoToControl </I>method shows how to move the focus 
from the button to the text box. The <I>SetFocus 
</I>example on the next line illustrates an alternative way to achieve the same result. The 
<I>Close </I>method shows how to close a form. Notice that this line uses yet another name, 
<I>frmCalculator2</I>, to refer to the form. Using the 
<I>acSaveNo </I>constant is important because it allows the 
form to close without a prompt asking whether to save the form.</P>

<A NAME="11"><H2>Property Procedures</H2></A>

<P>You use property procedures to define custom properties for forms, reports, 
and class modules. We will discuss class modules in the next section, and we 
will look at samples of property procedures in Chapter 7.</P>
<P>There are three types of property statements: <I>Property 
Get</I>, <I>Property Let</I>, and <I>Property 
Set</I>. You can use these statements to add special properties to 
forms. The <I>Property Get </I>statement and its matching 
<I>End Property </I>statement can return a value, just like a function procedure. If you define a property with only 
a <I>Property Get </I>statement, that property is read-only. A read-only property is 
convenient when you have the right to view a quantity but not to alter it&#8212;think 
of your 401K balance or your grades.</P>
<P>With some properties, it is important to be able to change them 
without being able to read them. For example, database security administrators do 
not necessarily need to be able to read the user passwords that they supervise. 
They only need to be able to write over them when users forget their password. 
Use the <I>Property Let </I>statement with its matching 
<I>End Property </I>statement to set a password.</P>

<P>The <I>Property Set</I> statement works similarly to the 
<I>Property Let </I>statement. Both create a setting for a property. The 
<I>Property Let </I>statement sets a property equal to a data type, such as a string or integer. The 
<I>Property Set </I>statement sets a property equal to an object reference. You use the 
<I>Property Set </I>statement with object references, such as references to a form or a report.</P>
<P>Since many properties are both read and write, you will frequently 
use both <I>Property Get </I>and either <I>Property Let 
</I>or <I>Property Set</I>. In this case, the pair of 
<I>Property </I>statements must have the same name so that they refer to the 
same property.</P>

<A NAME="12"><H2>Modules</H2></A>

<P>A module is a container for procedures and declarations such as 
<I>Option Explicit </I>and <I>Dim</I>. There are two basic kinds of modules. First, there are standard 
modules. These are listed under Modules in the Database window. The 
procedures in a standard module are independent of existing objects in an Access 
database file. This means there are no references to 
<I>Me </I>or control names without appropriate prefixes for the controls. However, your applications can reference 
procedures in standard modules readily from any other object.</P>

<P>The second kind of module is a class module. There are three basic 
varieties of these: form class modules, report class modules, and custom 
class modules. The procedures within a module are generally accessible to 
other modules. You can take a procedure out of this general scope by using the 
<I>Private </I>keyword when you initially specify the procedure. (See Figure 1-7 for 
sample syntax.) You can also explicitly declare procedures to have global scope by 
using the <I>Public </I>keyword.</P>
<P>A form module is the module for any form that has at least one 
declaration or procedure. Creating an event procedure for a form or a control on a 
form creates a form class module. Report class modules work about the same as 
form class modules, but the <I>Report </I>events are different from those for forms and 
you are unlikely to have the same mix of controls on a report as a form. You 
can create custom class modules that comprise method functions and 
procedure functions for a concept, such as an employee or an account. You can 
reference the methods and properties for custom class modules much as you do for 
built-in Access classes.</P>

<P>You use custom class modules like cookie cutters to make new 
instances of a class. Access offers two ways to accomplish this. First, you can use a 
single <I>Dim </I>statement to both declare the class and create a new instance of it. 
The syntax for this type of statement is</P>

<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Dim objInstance As New objClass
</pre>
</TD></TR></TABLE></P>


<P>The second approach relies on a pair of statements. The first member 
of the pair declares the object instance. The second member sets a reference 
to the object. The syntax for these statements is</P>


<P>
<TABLE CELLPADDING=5 WIDTH="95%"><TR><TD>
<pre>
Dim objInstance as objClass
Set objInstance = New objClass
</pre>
</TD></TR></TABLE></P>


<P>The <I>objClass </I>name refers to a class module populated with property 
procedures and public<I> </I>method functions. These method functions act as 
methods for the class just as the property procedures serve to define properties. 
Chapter 7 shows how to create and use custom class modules.</P>

</BODY>
</HTML>




