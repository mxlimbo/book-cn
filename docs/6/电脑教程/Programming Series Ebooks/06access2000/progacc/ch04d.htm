<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Special Select Queries</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04c.htm", "ch04e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="142"><H1>Special Select Queries</H1></A>

<p>Much of the query design discussion to this point has focused on the basic elements of design for select queries. This subsection presents three extensions to select queries that significantly enhance the flexibility and adaptability of your applications. First, you will learn about parameter queries. Many developers relish parameter queries because they make applications interactive. Others like them because of their exceptional ease of use. Second, union queries allow you to form data in ways that joining just cannot accomplish. When you need to concatenate two or more recordsets with common fields, union queries may be your most efficient tool. Union queries, unfortunately, require a working knowledge of SQL. The last section in this chapter includes some review of SQL syntax and many samples demonstrating the application of the language. Third, subqueries are the tool of choice when you require intelligent criteria that adapt to the values in your database. This technique for creating dynamic criteria that change along with the entries in your database will often benefit from a medium to advanced knowledge of SQL.</p>

<A NAME="143"><H2>Parameter Queries</H2></A>

<p>Parameter queries get their name because they require the input of a parameter at run time before they can complete. When you create a parameter query in Design View, you can designate the prompt for the input parameter in the Criteria row. Use the prompt in the criterion statement as a variable that the user will set at run time. The user interface also enables you to declare a data type for each input parameter. <a href="ch02a.htm">Chapter 2</a> demonstrates how to code a parameter query in ADO. This section describes how to manage the same task through the user interface.</p>

<p>Figure 4-16 shows a parameter query design along with its built-in prompt dialog box. Notice that the prompt in the criteria statement for the <i>UnitPrice</i> field is enclosed within brackets. The preceding less than (&lt;) symbol is used to set an upper limit for the return set's <i>UnitPrice</i> field values. If the user enters <i>35</i> to the parameter query prompt and clicks OK, the query responds with a list of all the products that have a price less than 35 dollars. The bottom window in Figure 14-6 displays the first several products satisfying the criteria as well as the total number of records meeting the criterion (56).</p>

<P><A HREF="javascript:fullSize('F04qh16x.htm')"> <img src="Images/F04qh16.JPG" width=404 height=587 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-16.</b> <i>A parameter query and its return set.</i><!-- /CAPTION -->
</P>


<p>The users of your applications will not typically run parameter queries from a query's Design view as was done in Figure 4-16. Figure 4-17 shows how the query looks when run from the database container. This particular query returns the customers in the UK, Germany, and France whose orders exceed the value specified by the user. It is this ability for users to control the return set that makes parameter queries highly interactive and dynamic.</p>

<P><A HREF="javascript:fullSize('F04qh17x.htm')"> <img src="Images/F04qh17.JPG" width=404 height=269 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-17.</b> <i>A parameter query run from the database window.</i><!-- /CAPTION -->
</P>


<p>Figure 4-18 shows the previous query in Design view. This query has two criteria. The first uses the <i>In</i> keyword to select customers that have headquarters in the UK, France , or Germany. This eliminates the need to specify three separate rows with a different country name in each row. The prompt in the <i>Extended Price</i> column follows a great than (&gt;) symbol. Therefore, the query returns all records that have an extended price greater than the amount specified by the user.</p>

<P><A HREF="javascript:fullSize('F04qh18x.htm')"> <img src="Images/F04qh18.JPG" width=404 height=172 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-18.</b> <i>The Design view of the query in Figure 4-17.</i><!-- /CAPTION -->
</P>


<p>The query in Figure 4-18 accomplishes other tasks as well. It computes and sums extended price by company and sorts its return set alphabetically by country and in descending extended price order. Its sorting design causes the biggest customers to appear at the top of the customer list for each country.</p>

<A NAME="144"><H2>Union Queries</H2></A>

<p>Union queries are unique from several perspectives. First, they dramatically simplify the task of concatenating two or more recordsets. (Recall that joining two recordsets brings them together in a side-by-side rather than one-after-the-other fashion.) Second, you can only define union queries with SQL. The only two views for union queries are Datasheet and SQL views; they have no Design view at all. Third, you cannot directly update the field values in a union query's Datasheet view. Many select queries, which appear identical to union queries in Datasheet view, are dynasets, which let a user revise the tables behind a recordset. If you must edit the data resulting from a union query, you should use a make-table query to construct a copy that you can edit. This will still not change the original inputs to the union query, but it will at least allow changes to the copy of the resulting data.</p>

<p>Figure 4-19 shows a very simple union query that combines the <i>FamilyMembers</i> and <i>AdditionsToFamilyMembers</i> tables. If you feel uncomfortable about developing with SQL, you can always keep your union queries this simple for the basic design. Make the first statement a simple SELECT statement that lists the field names and the record source for the fields in the FROM clause. Your references to all remaining record sources must start with UNION SELECT, but you still list the field names and the record source. It is possible to do more advanced operations, but that is not essential. You can always combine the record sources just this simply and reserve more sophisticated manipulation of the combined record sources to another select query that relies on the union query output. You can perform these more sophisticated operations in Design view.</p>

<P><A HREF="javascript:fullSize('F04qh19x.htm')"> <img src="Images/F04qh19.JPG" width=404 height=246 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-19.</b> <i>A union query in SQL view.</i><!-- /CAPTION -->
</P>


<p>Notice from the SELECT and UNION SELECT statements that I am concatenating tables with the same field data types. This is a requirement for union queries. The tables, or at least the fields that you combine, need to have the same number, order, and types of columns. While you cannot update the source from the Datasheet view, the query recomputes each time you open it with the most recent data from its inputs. Notice that Access disables the Design view icon for the union query. You cannot examine a union query in Design view. You must design or edit it in SQL view, and you examine the impact of your SQL statements in Datasheet view.</p>

<p>Figure 4-20 reveals the operation of the union query in Figure 4-19. The <i>FamilyMembers</i> and <i>AdditionsToFamilyMembers</i> tables are on the left in Figure 4-20; the output of the union query is the datasheet on the right. As you can see from the sequencing of the <i>FamID</i> field, the query creates a new datasheet that appends the two rows in <i>AdditionsToFamilyMembers</i> table to the <i>FamilyMembers</i> table.</p>

<P><A HREF="javascript:fullSize('F04QH20x.htm')"> <img src="Images/F04QH20.JPG" width=404 height=187 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-20.</b> <i>The two datasheets on the left are the inputs to the union query in Figure 4-19. The datasheet on the right is the output of the union query.</i><!-- /CAPTION -->
</P>


<A NAME="145"><H2>Subqueries</H2></A>

<p>A subquery is a select query inside of another query. The subquery must always be a SELECT statement, but you can use it inside of any other query, such as a select or an action query. There are a few extra keywords that can moderate the behavior of the standard SQL SELECT keyword in a subquery. Because the SELECT statement returns values, the subquery represents an important option for building dynamic criteria in queries that use them.</p>

<p>The embedded SELECT statement on the Criteria row for the <i>Lname</i> column in the bottom window in Figure 4-4 is a subquery.</p>

<p>Figure 4-21 shows a query that returns the nonduplicated <i>Lname</i> values returned by a union query named <i>qunFamilyMembersAdditionsMoreAdditions</i>. The union query concatenates three separate record sources. The lower left window in Figure 4-21 is the return set from the union query. Notice that there is only one nonduplicated <i>Lname</i> value, namely Edelstein. The lower right window is the return set from the select query.</p>

<P><A HREF="javascript:fullSize('F04qh21x.htm')"> <img src="Images/F04qh21.JPG" width=404 height=364 border=0 ALT="Click to view at full size."> </A>
</P><P><!-- CAPTION --><b>Figure 4-21.</b> <i>The top window is a query that finds non-duplicated field values in a record source. The bottom left and right windows are the input and output datasheets from the query.</i><!-- /CAPTION -->
</P>


<p>The top window in Figure 4-21 is the subquery design for finding non-duplicated <i>Lname</i> values. Notice that it is similar to the query in Figure 4-4. Aside from the fact that it searches a different record source, its sole distinction is that the subquery starts with <i>Not In</i> instead of <i>In</i>. The expression containing <i>Not In</i> returns nonduplicated names while the one with <i>In</i> returns duplicated names.</p>

<p><div class="NOTE"><blockquote>
<b>NOTE</b><hr>
While you can combine the return sets from queries like those in Figures 4-4 and 4-21 to return all distinct names, Access offers more direct graphical and expression-based routes to the same result. More consideration of the expression-based approach appears later in this chapter. The graphical approach involves setting the <i>Unique Values</i> property of a query to <i>Yes</i>.
</blockquote></div></P>


</BODY>
</HTML>




