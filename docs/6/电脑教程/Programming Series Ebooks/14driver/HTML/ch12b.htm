<HTML>
<HEAD>
<TITLE>The INF File</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch12a.htm">[Previous]</A> <A HREF="ch12c.htm">[Next]</a>
</p>

<A NAME="402"><H1>The INF File</H1></A>

<p>An INF file contains a collection of <i>sections</i> introduced by a section name in
brackets. Most sections contain a series of directives of the form &quot;keyword = value&quot;.
The INF file begins with a <b>Version</b> section that identifies the type of device described
by entries in the file:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>[Version]
Signature=$CHICAGO$
Class=Sample
ClassGuid={894A7460-A033-11d2-821E-444553540000}</pre>
</td></tr>
</table>
</p>

<p><b>Signature</b> can be one of the three magic values <b>$Chicago$</b>, <b>$Windows NT$</b> 
(with one space), or <b>$Windows 95$</b> (also with one space). <b>Class</b> identifies the
class of device. Table 12-1 lists the predefined classes that Windows 2000 already supports.
<b>ClassGuid</b> uniquely identifies the device class. The DDK header file DEVGUID.H defines
the globally unique identifiers (GUIDs) for standard device classes, and the DDK documentation
entry for the Version section documents them as well.</p>

<p>In a production INF file, you will also need to have <b>DriverVer</b> and <b>CatalogFile</b> 
statements in the <b>Version</b> section. You should also have a comment (that is, any line
that starts with a semicolon) containing the word &quot;copyright&quot; to satisfy the CHKINF
utility I'll describe in the section &quot;<A HREF="ch12b.htm#417">Tools for INF Files</A>&quot; later in this chapter.
The operating systems will accept INF files that lack these details, but Microsoft won't
certify your driver package without them. Refer to the DDK documentation for more details about
the required INF syntax.</p>

<p>I find it useful to think of the bulk of an INF file as the linear description of a tree
structure. Each section is a node in the tree, and each directive is a pointer to another
section. Figure 12-1 illustrates the concept.</p>

<p>
<A HREF="javascript:fullSize('F12wi01x.htm')"> <img src="images/F12wi01.JPG" width=404 height=261 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 12-1.</b> <i>Tree structure of an INF file.</i><!--/caption-->
</p>


<p><b>Table 12-1.</b> <i>Device classes for INF files.</i></p>

<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>INF Class Name</i></th><th><i>Description</i></th>
</tr>
<tr>
<td valign="top">1394</td><td valign="top">IEEE 1394 host bus controllers (but not peripherals)</td>
</tr>
<tr>
<td valign="top">Battery</td><td valign="top">Battery devices</td>
</tr>
<tr>
<td valign="top">CDROM</td><td valign="top">CD-ROM drives, including SCSI and IDE</td>
</tr>
<tr>
<td valign="top">DiskDrive</td><td valign="top">Hard disk drives</td>
</tr>
<tr>
<td valign="top">Display</td><td valign="top">Video adapters</td>
</tr>
<tr>
<td valign="top">FDC</td><td valign="top">Floppy disk controllers</td>
</tr>
<tr>
<td valign="top">FloppyDisk</td><td valign="top">Floppy disk drives</td>
</tr>
<tr>
<td valign="top">HDC</td><td valign="top">Hard disk controllers</td>
</tr>
<tr>
<td valign="top">HIDClass</td><td valign="top">Human input devices</td>
</tr>
<tr>
<td valign="top">Image</td><td valign="top">Still-image capture devices, including cameras and scanners</td>
</tr>
<tr>
<td valign="top">Infrared</td><td valign="top">NDIS miniport drivers for Serial-IR and Fast-IR ports</td>
</tr>
<tr>
<td valign="top">Keyboard</td><td valign="top">Keyboards</td>
</tr>
<tr>
<td valign="top">MediumChanger</td><td valign="top">SCSI media changer devices</td>
</tr>
<tr>
<td valign="top">Media</td><td valign="top">Multimedia devices, including audio, DVD, joysticks, and full-motion video capture devices</td>
</tr>
<tr>
<td valign="top">Modem</td><td valign="top">Modems</td>
</tr>
<tr>
<td valign="top">Monitor</td><td valign="top">Display monitors</td>
</tr>
<tr>
<td valign="top">Mouse</td><td valign="top">Mouse and other pointing devices</td>
</tr>
<tr>
<td valign="top">MTD</td><td valign="top">Memory technology driver for memory devices</td>
</tr>
<tr>
<td valign="top">Multifunction</td><td valign="top">Combination devices</td>
</tr>
<tr>
<td valign="top">MultiportSerial</td><td valign="top">Intelligent multiport serial cards</td>
</tr>
<tr>
<td valign="top">Net</td><td valign="top">Network adapter cards</td>
</tr>
<tr>
<td valign="top">NetClient</td><td valign="top">Network file system and print providers (client side)</td>
</tr>
<tr>
<td valign="top">NetService</td><td valign="top">Server-side support for network file systems</td>
</tr>
<tr>
<td valign="top">NetTrans</td><td valign="top">Network protocol drivers</td>
</tr>
<tr>
<td valign="top">PCMCIA</td><td valign="top">PCMCIA and CardBus host controllers (but not peripherals)</td>
</tr>
<tr>
<td valign="top">Ports</td><td valign="top">Serial and parallel ports</td>
</tr>
<tr>
<td valign="top">Printer</td><td valign="top">Printers</td>
</tr>
<tr>
<td valign="top">SCSIAdapter</td><td valign="top">SCSI and RAID controllers, host bus adapter miniports, and disk array controllers</td>
</tr>
<tr>
<td valign="top">SmartCardReader</td><td valign="top">Smart card readers</td>
</tr>
<tr>
<td valign="top">System</td><td valign="top">System devices</td>
</tr>
<tr>
<td valign="top">TapeDrive</td><td valign="top">Tape drives</td>
</tr>
<tr>
<td valign="top">USB</td><td valign="top">USB host controllers and hubs (but not peripherals)</td>
</tr>
<tr>
<td valign="top">Volume</td><td valign="top">Logical storage volume drivers</td>
</tr>
</table>
</p>



<p>At the apex of the tree is a <b>Manufacturer</b> section that lists all the companies with
hardware described in the file. For example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>[manufacturer]
&quot;Walter Oney Software&quot;=DeviceList
&quot;Finest Organization On Earth Yet&quot;=FOOEY

[DeviceList]
...

[FOOEY]
...</pre>
</td></tr>
</table>
</p>

<p>Each individual manufacturer's <i>model</i> section (DeviceList and FOOEY in the
example) describes one or more devices:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>[DeviceList]
<i>Description</i>=<i>InstallSectionName</i>,<i>DeviceId</i>
...</pre>
</td></tr>
</table>
</p>

<p>where <b>Description</b> is a human-readable description of the device and <b>DeviceId</b> 
identifies a hardware device. The <b>InstallSectionName</b> parameter identifies (or points to,
in my tree metaphor) another section of the INF file that contains instructions for installing
the software for a particular device. An example of an entry for a single type of device might
be this (drawn from the PKTDMA sample in Chapter 7, &quot;<A HREF="ch07a.htm#226">Reading and Writing Data</A>&quot;):</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>[DeviceList]
&quot;AMCC S5933 Development Board (DMA)&quot;=DriverInstall,PCI\VEN_10E8&amp;DEV_4750</pre>
</td></tr>
</table>
</p>

<p>The information in the Manufacturer section and in the model section(s) for individual
manufacturers comes into play when the system needs to install a driver for a piece of
hardware. A Plug and Play (PnP) device announces its presence and identity electronically. A
bus driver detects it automatically and constructs a device identifier using onboard data. The
system then attempts to locate preinstalled INF files that describe that particular device. INF
files reside in the INF subdirectory of the Windows directory. If the system can't find a
suitable INF file, it asks the end user to specify one.</p>

<p>A legacy device can't announce its own presence or identity. The end user therefore
launches the add hardware wizard to install a legacy device and helps the wizard locate the
right INF file. Key steps in this process include specifying the type of device being installed
and the name of the manufacturer. See Figure 12-2.</p>

<p>The hardware wizard constructs dialogs such as Figure 12-2 by enumerating all the INF files
for a particular type of device, all of the statements in their Manufacturer sections, and all
of the model statements for each of the manufacturers. You can guess that the manufacturer
names that appear in the left pane of the dialog come from the left sides of Manufacturer
statements and that the device types that appear in the right pane come from the left sides of
model statements.</p>

<p>
<A HREF="javascript:fullSize('F12wi02x.htm')"> <img src="images/F12wi02.JPG" width=404 height=309 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 12-2.</b> <i>Selecting a device during installation.</i><!--/caption-->
</p>


<p><div class="sidebar"><blockquote>
<b>More About Hardware Wizard Dialogs</b>

<p>Once the wizard is past the stage of looking for PnP devices, it builds a list of device
classes and uses various <b>SetupDi</b> <i>Xxx</i> routines from SETUPAPI.DLL to retrieve icons
and descriptions. The information that SETUPAPI uses to implement these routines ultimately
comes from the registry, where it was placed by entries in <b>ClassInstall32</b> sections. Not
every device class will be represented in the list&#8212;the wizard will suppress information
about classes that have the <b>NoInstallClass</b> attribute.</p>

<p>After the end user selects a device class, the wizard calls SETUPAPI functions to construct
lists of manufacturers and devices as described in the text. Devices mentioned in <b>
ExcludeFromSelect</b> statements will be absent from these lists.</p>
</blockquote></div>
</p>

<A NAME="403"><H2>Install Sections</H2></A>

<p>An <i>install</i> <i>section</i> contains the actual instructions that the installer needs
to install software for a device. We've been considering the PKTDMA sample. For that
device, the DeviceList model section specifies the name DriverInstall. I find it useful to
think of this name as identifying an <i>array</i> of sections, one for each Windows platform.
The &quot;zero&quot; element in this array has the base name of the section (DriverInstall).
You can have platform-specific array elements whose names start with the base name and contain
one of the suffixes listed in Table 12-2. The device installer looks for the install section
having the most specialized suffix. Suppose, for example, that you have install sections with
no suffix, with the <b>.NT</b> suffix, and with the <b>.NTx86</b> suffix. If you're
installing into Windows 2000 on an Intel x86 platform, the installer will use the .NTx86
section. If you're installing into Windows 2000 on a non-Intel platform, it would use the
.NT section. If you're installing into Windows 98, it would use the section without a
suffix.</p>

<p><b>Table 12-2.</b> <i>Install section suffixes for each platform.</i></p>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>Platform</i></th>
<th><i>Install Section Suffix</i></th>
</tr>
<tr>
<td valign="top">Any platform including Windows 98</td>
<td valign="top">[none]</td>
</tr>
<tr>
<td valign="top">Any Windows 2000 platform</td>
<td valign="top">.NT</td>
</tr>
<tr>
<td valign="top">Windows 2000 on Intel x86</td>
<td valign="top">.NTx86</td>
</tr>
</table>
</p>

<p>Because of the search rules I just outlined, all of the INF files for my sample drivers have
the no-suffix and .NT-suffix install sections. That makes the INF files work fine on any Intel
platform. (As you probably know by now, Microsoft and Compaq dropped support for the current
32-bit version of Windows 2000 on the Alpha platform just as this book was going to press. We
therefore made no provision for testing my samples on the Alpha.)</p>

<p>Further along in this chapter, I'll be discussing other INF sections whose names begin
with the name of the install section. If you have multiple install sections in your
&quot;array,&quot; these other sections have to include the platform-dependent suffix in their
names, too. For example, I'll be discussing a Services section that you use to install a
description of the driver into the registry. You would form the name of this section by taking
the base name of the install section (for example, DriverInstall) plus the platform suffix (for
example, NT) and adding the word Services, ending up with [DriverInstall.NT.Services].</p>

<p>A typical Windows 2000 install section would contain a <b>CopyFiles</b> directive and
nothing else:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>[DriverInstall.nt]
CopyFiles=DriverCopyFiles</pre>
</td></tr>
</table>
</p>

<p>This CopyFiles directive indicates that we want the installer to use the information in
another INF section for copying files onto the end user hard disk. For the PKTDMA sample, the
other section is named DriverCopyFiles:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>[DriverCopyFiles]
pktdma.sys,,,2</pre>
</td></tr>
</table>
</p>

<p>This section directs the installer to copy PKTDMA.SYS to the end user's hard disk.</p>

<p>The statements in a CopyFiles section have this general form:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>Destination,Source,Temporary,Flags</pre>
</td></tr>
</table>
</p>

<p><b>Destination</b> is the name (without any directory name) of the file as it will
eventually exist on the end user system. <b>Source</b> is the name of the file as it exists on
the distribution media, if that name is different from the Destination name; otherwise,
it's just blank as in the example. In Windows 98, if you might be installing a file that
will be in use at the time of installation, you specify a temporary name in the <b>
Temporary</b> parameter. Windows 98 will rename the temporary file to the Destination name on
the next reboot. It's not necessary to use this parameter for Windows 2000 installs because
the system automatically generates temporary names.</p>

<p>The <b>Flags</b> parameter contains a bit mask that governs whether the system will
decompress a file and how the system deals with situations in which a file by the same name
already exists. The interpretation of the flags depends in part on whether the INF and driver
are part of a package that Microsoft has digitally signed after certification. Table 12-3 is a list of all these flag bits. The italicized flags in the table are
ignored in a digitally signed package. I used a double line to delimit groups of mutually
exclusive flags. Thus, in an unsigned package, you could specify one or the other of the NOSKIP
or WARN_IF_SKIP flags, but not both.</p>

<p>The file name by itself is not sufficient to tell the installer what it needs to know to
copy a file. It also needs to know which directory you want the file copied to. In addition, if
you have multiple diskettes in the installation set, it needs to know which diskette contains
the source file. These pieces of information come from other sections of the INF file, as
suggested by Figure 12-3. In the PKTDMA example, these sections are as follows:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>[DestinationDirs]
DefaultDestDir=10,System32\Drivers

[SourceDisksFiles]
pktdma.sys=1

[SourceDisksNames]
1=&quot;WDM Book Companion Disc&quot;,disk1</pre>
</td></tr>
</table>
</p>

<p>
<A HREF="javascript:fullSize('F12wi03x.htm')"> <img src="images/F12wi03.JPG" width=404 height=130 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 12-3.</b> <i>Source and destination information for file copies.</i><!--/caption-->
</p>


<p><b>Table 12-3.</b> <i>Flags in a CopyFile section directive.</i></p>

<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>Symbolic Name</i></th>
<th><i>Numeric Value</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">COPYFLG_REPLACEONLY</td>
<td valign="top">0x00000400</td>
<td valign="top">Copy only if destination file already exists</td>
</tr>
<tr>
<td valign="top">COPYFLG_NODECOMP</td>
<td valign="top">0x00000800</td>
<td valign="top">Dont decompress file</td>
</tr>
<tr>
<td valign="top">COPYFLG_FORCE_FILE_IN_USE</td>
<td valign="top">0x00000008</td>
<td valign="top">Always copy under temporary name and rename on next boot</td>
</tr>
<tr>
<td valign="top">COPYFLG_NO_OVERWRITE</td>
<td valign="top">0x00000010</td>
<td valign="top">Dont overwrite an existing file (other flags cant be used with this flag)</td>
</tr>
<tr>
<td valign="top">COPYFLG_REPLACE_BOOT_FILE</td>
<td valign="top">0x00001000</td>
<td valign="top">Replace boot file needed by the loader, which will prompt user to reboot</td>
</tr>
<tr>
<td valign="top">COPYFLG_NOPRUNE</td>
<td valign="top">0x00002000</td>
<td valign="top">Copy this file even if Setup thinks its already present</td>
</tr>
<tr>
<td valign="top"><i>COPYFLG_NOVERSIONCHECK</i></td>
<td valign="top">0x00000004</td>
<td valign="top">Overwrite a file even if its a newer version than the source file</td>
</tr>
<tr>
<td valign="top"><i>COPYFLG_NO_VERSION_DIALOG</i></td>
<td valign="top">0x00000020</td>
<td valign="top">Dont present the dialog that allows the user to decide whether to overwrite a newer file</td>
</tr>
<tr>
<td valign="top"><i>COPYFLG_OVERWRITE_OLDER_ONLY</i></td>
<td valign="top">0x00000040</td>
<td valign="top">Only overwrite an older version of the file</td>
</tr>
<tr>
<td valign="top"><i>COPYFLG_NOSKIP</i></td>
<td valign="top">0x00000002</td>
<td valign="top">Dont allow the user to skip this file</td>
</tr>
<tr>
<td valign="top"><i>COPYFLG_WARN_IF_SKIP</i></td>
<td valign="top">0x00000001</td>
<td valign="top">Allow the user to skip this file and provide a warning</td>
</tr>
</table>
</p>

<p>The <b>SourceDisksFiles</b> section indicates that the installer can find PKTDMA.SYS on disk
number 1 of the set. The <b>SourceDisksNames</b> section indicates that disk number 1 has a
human-readable label of &quot;WDM Book Companion Disc&quot; and contains a file named
&quot;disk1&quot; that the installer can look for to verify that the correct diskette is in the
drive. Note that these section names have an interior &quot;s&quot; that's very easy to
miss.</p>

<p>The <b>DestinationDirs</b> section specifies the target directories for copy operations. <b>
DefaultDestDir</b> is the target directory to use for any file whose target directory isn't
otherwise specified. You use a numeric code to specify the target directory because the end
user might choose to install Windows 2000 to a directory with a nonstandard name. Please refer
to the DDK documentation entry for the DestinationDirs section for a complete list of the
codes&#8212;only a few of them are in common use, as follows:</p>

<ul>
<p><li> Directory 10 is the Windows directory (for example, &quot;\Windows&quot; or
&quot;\Winnt&quot;).</li></p>

<p><li> Directory 11 is the System directory (for example, &quot;\Windows\System&quot; or
&quot;\Winnt\System32&quot;).</li></p>

<p><li> Directory 12 is the Drivers directory on a Windows 2000 system (for example,
&quot;\Winnt\System32\Drivers&quot;). Unfortunately, this number has a different meaning on a
Windows 98 system (for example, &quot;\Windows\System\Iosubsys&quot;).</li></p>
</ul>


<p>WDM drivers reside in the Drivers directory. If your CopyFiles section applies only to a
Windows 2000 installation, you can just specify directory number 12. If you want to share a
CopyFiles section between Windows 98 and Windows 2000 installs, however, I recommend that you
specify &quot;10,System32\Drivers&quot; instead because it identifies the Drivers directory in
both cases.</p>

<A NAME="404"><H3>Defining the Driver Service</H3></A>

<p>The INF syntax I've described so far is sufficient for your driver file(s) to be copied
onto the end user's hard disk. You must also arrange for the PnP Manager to know which
files to load. A <b>.Services</b> section accomplishes that goal, as in this example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>[DriverInstall.NT.Services]
AddService=PKTDMA,2,DriverService

[DriverService]
ServiceType=1
StartType=3
ErrorControl=1
ServiceBinary=%10%\system32\drivers\pktdma.sys</pre>
</td></tr>
</table>
</p>

<p>The 2 in the <b>AddService</b> directive indicates that the PKTDMA service will be the
function driver for the device. You form the name of this section by appending the word
&quot;Services&quot; to the name of the install section to which it applies.</p>

<p>The end result of these directives will be a key in the HKEY_LOCAL_MACHINE\System\CurrentControlSet\Services branch of the registry named PKTDMA (the first
parameter in the AddService directive). It will define the service entry for the driver as a
kernel-mode driver (<b>ServiceType</b> equal to 1) that should be demand-loaded by the PnP
Manager (<b>StartType</b> equal to 3). Errors that occur during loading should be logged but
should not by themselves prevent the system from starting (<b>ErrorControl</b> equal to 1). The
executable image can be found in \Winnt\System32\Drivers\pktdma.sys (the value of <b>ServiceBinary</b>). By the way, when you look in the
registry, you'll see that the name of the executable file is stored under the name <b>
ImagePath</b> rather than ServiceBinary.</p>

<p>It's a good idea to make the name of the service (PKTDMA in this example) the same as the
filename (PKTDMA.SYS in this example) of your driver binary file. Not only does this make it
obvious which service name corresponds to which driver, but it also avoids a problem that can
arise when two different service keys point to the same driver: any device that uses the same
driver as a then-started device but under a different service name can't itself start.</p>

<A NAME="405"><H2>Device Identifiers</H2></A>

<p>For true Plug and Play devices, the device identifier that appears in a manufacturer's
model section of an INF is very important. Plug and Play devices are those that can
electronically announce their presence and identity. A bus enumerator can find these devices
automatically, and it can read some sort of onboard information to find out what kind each
device is. Universal serial bus (USB) devices, for example, include vendor and product
identification codes in their device descriptors, and the configuration space of Peripheral
Component Interconnect (PCI) devices includes vendor and product codes.</p>

<p>  When an enumerator detects a device, it constructs a list of device identification strings. One
entry in the list is a complete identification of the device. This entry will end up naming the
hardware key in the registry. Additional entries in the list are &quot;compatible&quot;
identifiers. The PnP Manager uses all of the identifiers in the list when it tries to match a
device to an INF file. Enumerators place more specific identifiers ahead of less specific
identifiers so that vendors can supply specific drivers that will be found in preference to
more general drivers. The algorithm for constructing the strings depends on the enumerator, as
follows:</p>

<A NAME="406"><H3>PCI Devices</H3></A>

<p>The full device identifier has the form</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>PCI\VEN_<i>vvvv</i>&amp;DEV_<i>dddd</i>&amp;SUBSYS_<i>ssssssss</i>&amp;REV_<i>rr</i></pre>
</td></tr>
</table>
</p>

<p>where <b>vvvv</b> is the vendor identifier that the PCI Special Interest Group assigned to
the manufacturer of the card, <b>dddd</b> is the device identifier that the manufacturer
assigned to the card, <b>ssssssss</b> is the subsystem id (often zero) reported by the card,
and <b>rr</b> is the revision number.</p>

<p>For example, the display adapter on my current laptop computer (based on the Chips and
Technologies 65550 chip) has this identifier:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>PCI\VEN_102C&amp;DEV_00E0&amp;SUBSYS_00000000&amp;REV_04</pre>
</td></tr>
</table>
</p>

<p>A device can also match an INF model with any of these identifiers:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>PCI\VEN_<i>vvvv</i>&amp;DEV_<i>dddd</i>&amp;SUBSYS_<i>ssssssss</i>
PCI\VEN_<i>vvvv</i>&amp;DEV_<i>dddd</i>&amp;REV_<i>rr</i>
PCI\VEN_<i>vvvv</i>&amp;DEV_<i>dddd</i>
PCI\VEN_<i>vvvv</i>&amp;DEV_<i>dddd</i>&amp;REV_<i>rr</i>&amp;CC_<i>ccss</i>
PCI\VEN_<i>vvvv</i>&amp;DEV_<i>dddd</i>&amp;CC_<i>ccsspp</i>
PCI\VEN_<i>vvvv</i>&amp;DEV_<i>dddd</i>&amp;CC_<i>ccss</i>
PCI\VEN_<i>vvvv</i>&amp;CC_<i>ccsspp</i>
PCI\VEN_<i>vvvv</i>&amp;CC_<i>ccss</i>
PCI\VEN_<i>vvvv</i>
PCI\CC_<i>ccsspp</i>
PCI\CC_<i>ccss</i></pre>
</td></tr>
</table>
</p>

<p>in which <b>cc</b> is the base class code from the configuration space, <b>ss</b> is the
subclass code, and <b>pp</b> is the programming interface. For example, the following
additional identifiers for my laptop's display adapter would have matched the information
in an INF file:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>PCI\VEN_102C&amp;DEV_00E0&amp;SUBSYS_00000000
PCI\VEN_102C&amp;DEV_00E0&amp;REV_04
PCI\VEN_102C&amp;DEV_00E0
PCI\VEN_102C&amp;DEV_00E0&amp;REV_04&amp;CC_0300
PCI\VEN_102C&amp;DEV_00E0&amp;CC_030000
PCI\VEN_102C&amp;DEV_00E0&amp;CC_0300
PCI\VEN_102C&amp;CC_030000
PCI\VEN_102C&amp;CC_0300
PCI\VEN_102C
PCI\CC_030000
PCI\CC_0300</pre>
</td></tr>
</table>
</p>

<p>The INF that the system actually used for driver installation was the third one, which
includes just the vendor and device identifiers.</p>

<A NAME="407"><H3>PCMCIA Devices</H3></A>

<p>The device identifier for a simple device has the form</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>PCMCIA\<i>Manufacturer</i>-<i>Product</i>-<i>Crc</i></pre>
</td></tr>
</table>
</p>

<p>For example, the device identifier for the 3Com network card on my current laptop computer
is</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>PCMCIA\MEGAHERTZ-CC10BT/2-BF05</pre>
</td></tr>
</table>
</p>

<p>For an individual function on a multifunction device, the identifier has the form</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>PCMCIA\<i>Manufacturer</i>-<i>Product</i>-DEV<i>dddd</i>-<i>Crc</i></pre>
</td></tr>
</table>
</p>

<p>where <b>Manufacturer</b> is the name of the manufacturer and <b>Product</b> is the name of
the product. The PCMCIA enumerator retrieves these strings directly from tuples on the card.
<b>Crc</b> is the 4-digit hexadecimal CRC checksum for the card. The child function number
(<b>dddd</b> in the template) is a decimal number without leading zeros.</p>

<p>If the card doesn't have a manufacturer name, the identifier will have one of these
three forms:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>PCMCIA\UNKNOWN_MANUFACTURER-<i>Crc</i>
PCMCIA\UNKNOWN_MANUFACTURER-DEV<i>dddd</i>-<i>Crc</i>
PCMCIA\MTD-0002</pre>
</td></tr>
</table>
</p>

<p>(The last of these three alternatives is for a flash memory card with no manufacturer
identifier on the card.)</p>

<p>In addition to the device identifier just described, an INF file's model section can
also contain an identifier composed by replacing the 4-digit hexadecimal CRC with a string
containing the 4-digit hexadecimal manufacturer code, a hyphen, and the 4-digit hexadecimal
manufacturer information code (both from onboard tuples). For example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>PCMCIA\MEGAHERTZ-CC10BT/2-0128-0103</pre>
</td></tr>
</table>
</p>

<A NAME="408"><H3>SCSI Devices</H3></A>

<p>The complete device identifier is</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>SCSI\<i>ttttvvvvvvvvpppppppppppppppprrrr</i></pre>
</td></tr>
</table>
</p>

<p>where <b>tttt</b> is a device type code, <b>vvvvvvvv</b> is an 8-character vendor
identifier, <b>pppppppppppppppp</b> is a 16-character product identifier, and <b>rrrr</b> is a
4-character revision level value. The device type code is the only one of the identifier
components that doesn't have a fixed length. The bus driver determines this portion of the
device identifier by indexing an internal string table with the device type code from the
device's inquiry data, as shown in Table 12-4. The remaining components are just the
strings that appear in the device's inquiry data but with special characters (including
space, comma, and any nonprinting graphic) replaced with an underscore.</p>

<p><b>Table 12-4.</b> <i>Type names for SCSI devices.</i></p>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>SCSI Type Code</i></th>
<th><i>Device Type</i></th>
<th><i>Generic Type</i></th>
</tr>
<tr>
<td valign="top">DIRECT_ACCESS_DEVICE (0)</td>
<td valign="top">Disk</td>
<td valign="top">GenDisk</td>
</tr>
<tr>
<td valign="top">SEQUENTIAL_ACCESS_DEVICE (1)</td>
<td valign="top">Sequential</td>
<td valign="top"></td>
</tr>
<tr>
<td valign="top">PRINTER_DEVICE (2)</td>
<td valign="top">Printer</td>
<td valign="top">GenPrinter</td>
</tr>
<tr>
<td valign="top">PROCESSOR_DEVICE (3)</td>
<td valign="top">Processor</td>
<td valign="top"></td>
</tr>
<tr>
<td valign="top">WRITE_ONCE_READ_MULTIPLE_DEVICE (4)</td>
<td valign="top">Worm</td>
<td valign="top">GenWorm</td>
</tr>
<tr>
<td valign="top">READ_ONLY_DIRECT_ACCESS_DEVICE (5)</td>
<td valign="top">CdRom</td>
<td valign="top">GenCdRom</td>
</tr>
<tr>
<td valign="top">SCANNER_DEVICE (6)</td>
<td valign="top">Scanner</td>
<td valign="top">GenScanner</td>
</tr>
<tr>
<td valign="top">OPTICAL_DEVICE (7)</td>
<td valign="top">Optical</td>
<td valign="top">GenOptical</td>
</tr>
<tr>
<td valign="top">MEDIUM_CHANGER (8)</td>
<td valign="top">Changer</td>
<td valign="top">ScsiChanger</td>
</tr>
<tr>
<td valign="top">COMMUNICATION_DEVICE (9)</td>
<td valign="top">Net</td>
<td valign="top">ScsiNet</td>
</tr>
<tr>
<td valign="top"></td>
<td valign="top">Other</td>
<td valign="top">ScsiOther</td>
</tr>
</table>
</p>

<p>For example, a disk drive on one of my workstations has this identifier:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>SCSI\DiskSEAGATE_ST39102LW_______0004</pre>
</td></tr>
</table>
</p>

<p>The bus driver also creates these additional identifiers:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>SCSI\<i>ttttvvvvvvvvpppppppppppppppp</i>
SCSI\<i>ttttvvvvvvvv</i>
SCSI\<i>vvvvvvvvppppppppppppppppr
vvvvvvvvppppppppppppppppr
gggg</i></pre>
</td></tr>
</table>
</p>

<p>In the third and fourth of these additional identifiers, <b>r</b> represents just the first
character of the revision identifier. In the last identifier, <b>gggg</b> is the generic type
code from Table 12-4.</p>

<p>To carry forward the example of my disk drive, the bus driver generated these additional device
identifiers:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>SCSI\DiskSEAGATE_ST39102LW_______
SCSI\DiskSEAGATE_
SCSI\DiskSEAGATE_ST39102LW_______0
SEAGATE_ST39102LW_______0
GenDisk</pre>
</td></tr>
</table>
</p>

<p>The last of these (<b>GenDisk</b>) is the one that appeared as the device identifier in the
INF file that the PnP Manager actually used to install a driver for this disk. In fact, the
generic identifier is <i>usually</i> the one that's in the INF file because SCSI drivers
tend to be generic.</p>

<A NAME="409"><H3>IDE Devices</H3></A>

<p>IDE devices receive device identifiers that are very similar to SCSI identifiers:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>IDE\<i>ttttvpvprrrrrrrr</i>
IDE\<i>vpvprrrrrrrr</i>
IDE\<i>ttttvpvp
vpvprrrrrrrr
gggg</i></pre>
</td></tr>
</table>
</p>

<p>Here, <b>tttt</b> is a device type name (same as SCSI); <b>vpvp</b> is a string containing
the vendor name, an underscore, the vendor's product name, and enough underscores to bring
the total to 40 characters; <b>rrrrrrrr</b> is an 8-character revision number; and <b>gggg</b> 
is a generic type name (almost the same as SCSI type names in Table 12-4). For IDE changer
devices, the generic type name is <b>GenChanger</b> instead of <b>ScsiChanger</b>; other IDE
generic names are the same as SCSI.</p>

<p>For example, here are the device identifiers generated for an IDE hard drive on one of my
desktop systems:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>IDE\DiskMaxtor_91000D8_____________________SASX1B18
IDE\Maxtor_91000D8___________________________SASX1B18
IDE\DiskMaxtor_91000D8________________________
Maxtor_91000D8__________________________SASX1B18
GenDisk</pre>
</td></tr>
</table>
</p>

<A NAME="410"><H3>ISAPNP Devices</H3></A>

<p>The ISAPNP enumerator constructs two hardware identifiers:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>ISAPNP\<i>id</i>
*<i>altid</i></pre>
</td></tr>
</table>
</p>

<p>where <b>id</b> and <b>altid</b> are EISA-style identifiers for the device&#8212;three
letters to identify the manufacturer and 4 hexadecimal digits to identify the particular
device. If the device in question is one function of a multifunction card, the first identifier
in the list takes this form:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>ISAPNP\<i>id</i>_DEV<i>nnnn</i></pre>
</td></tr>
</table>
</p>

<p>where <b>nnnn</b> is the decimal index (with leading zeros) of the function.</p>

<p>For example, the codec function of the Crystal Semiconductor audio card on one of my desktop
machines has these two hardware identifiers:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>ISAPNP\CSC6835_DEV0000
*CSC0000</pre>
</td></tr>
</table>
</p>

<p>The second of these identifiers is the one that matched the actual INF file.</p>

<A NAME="411"><H3>USB Devices</H3></A>

<p>The complete device identifier is</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>USB\VID_<i>vvvv</i>&amp;PID_<i>dddd</i>&amp;REV_<i>rrrr</i></pre>
</td></tr>
</table>
</p>

<p>where <b>vvvv</b> is the 4-digit hexadecimal vendor code assigned by the USB committee to
the vendor, <b>dddd</b> is the 4-digit hexadecimal product code assigned to the device by the
vendor, and <b>rrrr</b> is the revision code. All three of these values appear in the device
descriptor or interface descriptor for the device.</p>

<p>An INF model section can also specify these alternatives:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>USB\VID_<i>vvvv</i>&amp;PID_<i>dddd</i>
USB\CLASS_<i>cc</i>&amp;SUBCLASS_<i>ss</i>&amp;PROT_<i>pp</i>
USB\CLASS_<i>cc</i>&amp;SUBCLASS_<i>ss</i>
USB\CLASS_<i>cc</i>
USB\COMPOSITE</pre>
</td></tr>
</table>
</p>

<p>where <b>cc</b> is the class code from the device or interface descriptor, <b>ss</b> is the
subclass code, and <b>pp</b> is the protocol code. These values are in 2-digit hexadecimal
format.</p>

<A NAME="412"><H3>1394 Devices</H3></A>

<p>The 1394 bus driver constructs these identifiers for a device:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>1394\<i>VendorName</i>&amp;<i>ModelName</i>
1394\<i>UnitSpecId</i>&amp;<i>UnitSwVersion</i></pre>
</td></tr>
</table>
</p>

<p>where <b>VendorName</b> is the name of the hardware vendor, <b>ModelName</b> identifies the
device, <b>UnitSpecId</b> identifies the software specification authority, and <b>
UnitSwVersion</b> identifies the software specification. The information used to construct
these identifiers comes from the device's configuration ROM.</p>

<p>If a device has vendor and model name strings, the 1394 bus driver uses the first identifier
as the hardware ID and the second identifier as the one and only compatible ID. If a device
lacks a vendor or model name string, the bus driver uses the second identifier as the hardware
ID.</p>

<p>Since I don't have a 1394 bus on any of my computers, I relied on fellow driver writer
Jeff Kellam to provide me with two examples. The first example is for a Sony camera, for which
the device identifier is</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>1394\SONY&amp;CCM-DS250_1.08</pre>
</td></tr>
</table>
</p>

<p>The second example is for the 1394 bus itself operating in diagnostic mode; this device
identifier is</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>1394\031887&amp;040892</pre>
</td></tr>
</table>
</p>

<A NAME="413"><H3>Identifiers for Generic Devices</H3></A>

<p>The PnP Manager also works with device identifiers for generic devices that can appear on
many different buses. These identifiers are of the form</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>*PNP<i>dddd</i></pre>
</td></tr>
</table>
</p>

<p>where <b>dddd</b> is a 4-digit hexadecimal type identifier. At press time, the official list
of these identifiers was at <i><a href="http://www.microsoft.com/hwdev/download/respec/devids.txt" target="_window2">http://www.microsoft.com/hwdev/download/respec/devids.txt</a></i>.</p>

<A NAME="414"><H2>The Hardware Registry Key</H2></A>

<p>The hardware registry key records information about a particular hardware instance your
driver manages. Each enumerator of devices has its own registry key below
HKEY_LOCAL_MACHINE\System\CurrentControlSet\Enum. When the enumerator finds a device with a
particular identifier, it creates a key for the identifier and a subkey for each instance of
the same device. For example, the PKTDMA device has the identifier PCI\VEN_10E8&amp;DEV_4750.
The first instance of this device in your system might have a hardware key named like this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>\Registry\Machine\System\CurrentControlSet\Enum\
  PCI\VEN_10E8&amp;DEV_4750\BUS_00&amp;DEV_04&amp;FUNC_00</pre>
</td></tr>
</table>
</p>

<A NAME="415"><H3>Standard Properties</H3></A>

<p>The PnP Manager stores certain standard information about the device in the hardware key.
You can retrieve this information in a WDM driver by calling <b>IoGetDeviceProperty</b> with
one of the property codes listed in Table 12-5.</p>

<p><b>Table 12-5.</b> <i>Standard device properties in the hardware key.</i></p>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>Property Name</i></th>
<th><i>Value Name</i></th>
<th><i>Source</i></th>
<th><i>Description</i></th>
</tr>
<tr>
<td valign="top">DevicePropertyDeviceDescription</td>
<td valign="top">DeviceDesc</td>
<td valign="top">First parameter in model statement </td>
<td valign="top">Description of device</td>
</tr>
<tr>
<td valign="top">DevicePropertyHardwareId</td>
<td valign="top">HardwareID</td>
<td valign="top">Third parameter in model statement </td>
<td valign="top">Identifies device</td>
</tr>
<tr>
<td valign="top">DevicePropertyCompatibleIDs</td>
<td valign="top">CompatibleIDs</td>
<td valign="top">Created by bus driver during detection </td>
<td valign="top">Device types that can be considered to match </td>
</tr>
<tr>
<td valign="top">DevicePropertyClassName</td>
<td valign="top">Class</td>
<td valign="top">Class parameter in Version section of INF </td>
<td valign="top">Name of device class</td>
</tr>
<tr>
<td valign="top">DevicePropertyClassGuid</td>
<td valign="top">ClassGUID</td>
<td valign="top">ClassGuid parameter in Version section of INF</td>
<td valign="top">Unique identifier of device class</td>
</tr>
<tr>
<td valign="top">DevicePropertyDriverKeyName</td>
<td valign="top">Driver</td>
<td valign="top">Created automatically as part of installation process</td>
<td valign="top">Name of service (software) key that specifies driver	</td>
</tr>
<tr>
<td valign="top">DevicePropertyManufacturer</td>
<td valign="top">Mfg</td>
<td valign="top">Manufacturer in whose model section device was found </td>
<td valign="top">Name of hardware manufacturer</td>
</tr>
<tr>
<td valign="top">DevicePropertyFriendlyName</td>
<td valign="top">FriendlyName</td>
<td valign="top">Explicit AddReg in INF file, or class installer </td>
<td valign="top">Friendly name suitable for presentation to the user</td>
</tr>
</table>
</p>

<p>For example, to retrieve the description of a device, use the following code. (See the <b>
AddDevice</b> function in the DEVPROP sample.)</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>WCHAR name[256];
ULONG junk;
status = IoGetDeviceProperty(pdo, 
  DevicePropertyDeviceDescription, sizeof(name), name, &amp;junk);
KdPrint((DRIVERNAME 
  &quot; - AddDevice has succeeded for '%ws' device\n&quot;, name));</pre>
</td></tr>
</table>
</p>

<p>Notice from Table 12-5 that the PnP Manager and bus driver together manage to create all of
the standard device properties automatically except for the friendly name. You can supply a
friendly name by an explicit statement in your INF file if you want:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>[DriverInstall.NT.hw]
AddReg=DriverHwAddReg

[DriverHwAddReg]
HKR,,FriendlyName,,&quot;Packet DMA Demonstration Device&quot;</pre>
</td></tr>
</table>
</p>

<p>Mind you, <i>every</i> device of this particular type that is installed on a particular
machine will end up with the same friendly name if you adopt this approach. The end user will
obviously be confused if more than one device has the same friendly name. If you anticipate
that there might be duplicate friendly names, you should provide a co-installer DLL to compute
unique names.</p>

<p>User-mode applications can retrieve the standard device properties with <b>
SetupDiGetDeviceRegistryProperty</b>. Use the following method within the context of an
enumeration of registered interfaces using the setup APIs:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>HDEVINFO info = SetupDiGetClassDevs(...);
SP_DEVINFO_DATA did = {sizeof(SP_DEVINFO_DATA)};
SetupDiGetDeviceInterfaceDetail(info, ..., &amp;did);
<b>TCHAR fname[256];
SetupDiGetDeviceRegistryProperty(info, &amp;did,
  SPDRP_FRIENDLYNAME, NULL, (PBYTE) fname, 
  sizeof(fname), NULL);</b> </pre>
</td></tr>
</table>
</p>

<p>Refer to the DDK documentation of SetupDiGetDeviceRegistryProperty for a list of the
SPDRP_<i>XXX</i> values you can specify to retrieve the various properties.</p>

<p>As you can see, you must supply a device information set handle (an HDEVINFO) and an
SP_DEVINFO_DATA structure as arguments to SetupDiGetDeviceRegistryProperty. That's easy to
do if you're in the middle of a loop enumerating instances of a device interface. But
suppose all you have is the symbolic name of the device? You can use the following trick, which
I found to be pretty obscure when one of the Microsoft developers showed it to me, to construct
these two crucial parameters:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>LPCTSTR devname;   // <img src="images/tlarrow.jpg" width=13 height=12 border="0">someone gives you this
HDEVINFO info = SetupDiCreateDeviceInfoList(NULL, NULL);
SP_DEVICE_INTERFACE_DATA ifdata = {sizeof(SP_DEVICE_INTERFACE_DATA)};
SetupDiOpenDeviceInterface(info, devname, 0, &amp;ifdata);
SP_DEVINFO_DATA did = {sizeof(SP_DEVINFO_DATA)};
SetupDiGetDeviceInterfaceDetail(info, &amp;ifdata, NULL, 0, NULL, &amp;did);</pre>
</td></tr>
</table>
</p>

<p>You can go on to call routines such as SetupDiGetDeviceRegistryProperty in the normal way at
this point.</p>

<p>
<div class="note"><blockquote><b>NOTE</b> <hr>
In Windows 98 and Windows NT version 4, application programs used the CFGMGR32
set of APIs to obtain information about devices and to interact with the PnP Manager. These
APIs continue to be supported for purposes of compatibility in Windows 98 and Windows 2000, but
Microsoft discourages their use in new code. For that reason, I'm not even showing you
examples of calling them. You might be tempted&#8212;as I initially was&#8212;to use them because
they seem to be better documented. If you know where to look for the documentation, that is.
Have patience: Microsoft will get around to documenting the SetupDi<i>Xxx</i> functions in
enough detail for us mortals to use them effectively.</blockquote></div>
</p>

<A NAME="416"><H3>Nonstandard Properties</H3></A>

<p>The PnP Manager creates a subkey of the hardware key named <b>Device Parameters</b>. This
subkey contains nonstandard properties of the device. You can initialize nonstandard properties
in a hardware add registry section in your INF:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>[DriverInstall.nt.hw]
AddReg=DriverHwAddReg

[DriverHwAddReg]
HKR,,SampleInfo,,&quot;%wdmbook%\chap7\pktdma\pktdma.htm&quot;</pre>
</td></tr>
</table>
</p>

<p>WDM drivers can easily open a handle to the device parameter key by calling <b>
IoOpenDeviceRegistryKey</b>. Applications can access the key by using <b>
SetupDiOpenDevRegKey</b>.</p>

<A NAME="417"><H2>Tools for INF Files</H2></A>

<p>If you look in the TOOLS subdirectory of the Windows 2000 DDK, you'll find two useful
utilities for working with INF files. GENINF will help you build a new INF file, and CHKINF
will help you validate an INF file. At the time I'm writing this, I'm using the RC1
release of the DDK, in which GENINF is still pretty rudimentary. By the time you read this,
GENINF will either have grown to a robust tool with a completely different user interface than
it now has, or else it will have been dropped from the kit. Either way, I can't give you
any useful information about how to use it.</p>

<p>CHKINF is actually a BAT file that runs a PERL script to examine and validate an INF file.
You'll obviously need a PERL implementation to use this tool. I got a copy from <i>
<a href="http://www.perl.com" target="_window2">http://www.perl.com</a></i>.</p>

<p>You can run CHKINF most easily from a command prompt. For example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>E:\Ntddk\tools\chkinf&gt;chkinf C:\wdmbook\chap12\devprop\sys\device.inf</pre>
</td></tr>
</table>
</p>

<p>CHKINF generates HTML output files in an HTM subdirectory. Figure 12-4 shows the output I
received when checking DEVICE.INF for DEVPROP sample.</p>

<p>
<A HREF="javascript:fullSize('F12wi04x.htm')"> <img src="images/F12wi04.JPG" width=404 height=302 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 12-4.</b> <i>Example of CHKINF output.</i><!--/caption-->
</p>


<p>In Windows 2000, the device installer logs various information about the operations it
performs in a disk file named SETUPAPI.LOG in the Windows NT directory. You can control the
verbosity of the log and the name of the log file by manually changing entries in the registry
key named HKEY_LOCAL_MACHINE\Software\Microsoft\Windows\CurrentVersion\Setup. Please consult the DDK documentation for detailed information
about these settings.</p>

</BODY>
</HTML>





