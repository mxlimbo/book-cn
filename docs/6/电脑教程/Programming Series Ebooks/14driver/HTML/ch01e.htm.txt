<HTML>
<HEAD>
<TITLE>Organization of This Book</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch01d.htm">[Previous]</A> <A HREF="ch01f.htm">[Next]</a>
</p>

<A NAME="21"><H1>Organization of This Book</H1></A>

<p>After teaching driver programming seminars to hundreds of students over the past several
years, I've come to understand that people learn things in fundamentally different ways.
Some people like to learn a great deal of theory about something and then learn how to apply
that theory to practical problems. Other people like to learn practical things first and then
learn the general theory. I'd call the former approach deductive and the latter approach
inductive. I personally prefer an inductive approach, and I've organized this book to suit
that style of learning.</p>

<p>My aim is to explain how to write device drivers. Broadly speaking, I wanted to provide the
minimum background you'll need to write an actual driver and then move on to more
specialized topics. That &quot;minimum background&quot; is pretty extensive, however; it
consumes six chapters. Once past <a href="ch07a.htm">Chapter 7</a>, you'll be reading about topics that are
important but not necessarily on the fall line that leads straight downhill to a working
driver.</p>

<p>Chapter 2, &quot;<a href="ch02a.htm">Basic Structure of a WDM Driver</a>,&quot; explains the basic data structures
that Windows 2000 uses to manage I/O devices and the basic way your driver relates to those
data structures. I'll discuss the driver object and the device object. I'll also
discuss how you write two of the subroutines&#8212;the DriverEntry and AddDevice
routines&#8212;that every WDM driver package contains.</p>

<p>Chapter 3, &quot;<A HREF="ch03a.htm">Basic Programming Techniques</A>,&quot; describes the most important service
functions you can call on to perform mundane programming tasks. In that chapter, I'll
discuss error handling, memory management, and a few other miscellaneous tasks.</p>

<p>Chapter 4, &quot;<A HREF="ch04a.htm">Synchronization</A>,&quot; discusses how your driver can synchronize access to
shared data in the multitasking, multiprocessor world of Windows 2000. You'll learn the
details about IRQL and about various synchronization primitives that the operating system
offers for your use.</p>

<p>Chapter 5, &quot;<A HREF="ch05a.htm">The I/O Request Packet</A>,&quot; introduces the subject of input/output
programming, which of course is the real reason for this book. I'll explain where I/O
request packets come from, and I'll give an overview of what drivers do with them when they
follow what I call the &quot;standard model&quot; for IRP processing. I'll also discuss the
knotty subject of IRP cancellation, wherein accurate reasoning about synchronization problems
becomes crucial.</p>

<p>Chapter 6, &quot;<A HREF="ch06a.htm">Plug and Play</A>,&quot; concerns just one type of I/O request packet, namely
IRP_MJ_PNP. The Plug and Play Manager component of the operating system sends you this IRP to
give you details about your device's configuration and to notify you of important events in
the life of your device. Being a good PnP citizen implies that many drivers can't use the
&quot;standard model&quot; for IRP processing. I'll therefore describe an object I named a
DEVQUEUE that you can use to queue and dequeue IRPs appropriately when PnP events are occurring
all around you.</p>

<p>Chapter 7, &quot;<A HREF="ch07a.htm">Reading and Writing Data</A>,&quot; is where we finally get to write driver
code that performs I/O operations. I'll discuss how you obtain configuration information
from the PnP Manager and how you use that information to prepare your driver for
&quot;substantive&quot; IRPs that read and write data. I'll present two simple driver
sample programs as well: one for dealing with a PIO device and one for dealing with a
bus-mastering DMA device.</p>

<p>Chapter 8, &quot;<A HREF="ch08a.htm">Power Management</A>,&quot; describes how your driver participates in power
management. I think you'll find, as I did, that power management is pretty complicated.
Unfortunately, you have to participate in the system's power management protocols or else
the system as a whole won't work right. Worse yet, the system will sometimes present a
dialog box that identifies <i>you</i> as the culprit if you don't do the right things.
Luckily, the community of driver writers already has a grand tradition of cutting and pasting,
and that will save you.</p>

<p>Chapter 9, &quot;<A HREF="ch09a.htm">Specialized Topics</A>,&quot; contains a discussion of filter drivers, error
logging, I/O control operations, and system threads.</p>

<p>Chapter 10, &quot;<A HREF="ch10a.htm">Windows Management Instrumentation</A>,&quot; concerns a scheme for
enterprisewide computer management in which your driver can and should participate. I'll
explain how you can provide statistical and performance data for use by monitoring
applications, how you can respond to standard WBEM controls, and how you can alert controlling
applications of important events when they occur.</p>

<p>Chapter 11, &quot;<A HREF="ch11a.htm">The Universal Serial Bus</A>,&quot; describes how to write drivers for USB
devices.</p>

<p>Chapter 12, &quot;<A HREF="ch12a.htm">Installing Device Drivers</A>,&quot; tells you how to arrange for your driver
to get installed onto end user systems. You'll learn the basics of writing an INF file to
control installation, and you'll also learn some interesting and useful things to do with
the system registry.</p>

<p>Appendix A, &quot;<a href="chaaa.htm">Coping with Windows 98 Incompatibilities</a>,&quot; explains a VxD-based
scheme that will allow you to deploy the same driver binary on both Windows 2000 and Windows 98
platforms. The basic problem you now have to solve&#8212;and the basic reason a distinction
exists between PnP drivers and WDM drivers&#8212;is that Windows