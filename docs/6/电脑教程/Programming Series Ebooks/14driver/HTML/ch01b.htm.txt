<HTML>
<HEAD>
<TITLE>An Overview of the Operating Systems</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch01a.htm">[Previous]</A> <A HREF="ch01c.htm">[Next]</a>
</p>

<A NAME="4"><H1>An Overview of the Operating Systems</H1></A>

<p>The Windows Driver Model (WDM) provides a framework for device drivers that operate in two
operating systems&#8212;Windows 98 and Windows 2000. Although to the end user these two systems
are very similar, they work very differently on the inside. In this section, I'll present a
brief overview of the two systems.</p>

<A NAME="5"><H2>Windows 2000 Overview</H2></A>

<p>Figure 1-1 is my perspective poster of the Windows 2000 operating system, wherein I
emphasize the features that are important to people who write device drivers. Software executes
either in <i>user mode</i> (untrusted and restricted to authorized activities only) or in <i>
kernel mode</i> (fully trusted and able to do anything). A user-mode program that wants to,
say, read some data from a device would call an application programming interface (API) such as
<b>ReadFile</b>. A subsystem module such as KERNEL32.DLL implements this API by invoking some
sort of platform-dependent system service interface to reach a kernel-mode support routine. In
the case of a call to ReadFile, the mechanism involves making a user-mode call to an entry
point named <b>NtReadFile</b> in a system dynamic-link library (DLL) named&#8212;redundantly,
I've always thought&#8212;NTDLL.DLL. The user-mode NtReadFile function uses the system
service interface to reach a kernel-mode routine that's also named NtReadFile.</p>

<p>
<A HREF="javascript:fullSize('F01wi01x.htm')"> <img src="images/F01wi01.JPG" width=404 height=270 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 1-1.</b> <i>The Windows 2000 architecture.</i><!--/caption-->
</p>


<p>We often say that NtReadFile is part of a system component that we call the I/O Manager. The
term <i>I/O Manager</i> is perhaps a little misleading because there isn't any single
executable module with that name. We need a name to use when discussing the &quot;cloud&quot;
of operating system services that surrounds our own driver, though, and this name is the one we
usually pick.</p>

<p>Many routines serve a purpose similar to NtReadFile. They operate in kernel mode to service
an application's request to interact with a device in some way. They all validate their
parameters, thereby ensuring that they don't inadvertently allow a security breach by
performing an operation or accessing some data that the user-mode program wouldn't have
been able to perform or access by itself. They then create a data structure called an I/O
request packet (IRP) that they pass to an entry point in some device driver. In the case of an
original ReadFile call, NtReadFile would create an IRP with a <i>major function code</i> of
IRP_MJ_READ (a constant in a DDK [Device Driver Kit] header file). Processing details at this
point can differ, but a likely scenario is for a routine like NtReadFile to return to the
user-mode caller with an indication that the operation described by the IRP hasn't finished
yet. The user-mode program might continue about its business and then wait for the operation to
finish, or it might wait immediately. Either way, the device driver proceeds independently of
the application to service the request.</p>

<p>A device driver might eventually need to actually access its hardware to perform an IRP. In
the case of an IRP_MJ_READ to a programmed I/O (PIO) sort of device, the access might take the
form of a read operation directed to an I/O port or a memory register implemented by the
device. Drivers, even though they execute in kernel mode and can therefore talk directly to
their hardware, use facilities provided by the hardware abstraction layer (HAL) to access
hardware. A read operation might involve calling READ_PORT_UCHAR to read a single data byte
from an I/O port. The HAL routine uses a platform-dependent method to actually perform the
operation. On an Intel x86 computer, the HAL would use the IN instruction; on an Alpha, it
would perform a memory fetch.</p>

<p>After a driver has finished with an I/O operation, it <i>completes</i> the IRP by calling a
particular kernel-mode service routine. Completion is the last act in processing an IRP, and it
allows the waiting application to resume execution.</p>

<A NAME="6"><H2>Windows 98 Overview</H2></A>

<p>Figure 1-2 shows one way of thinking about Windows 98. The operating system kernel is called
the Virtual Machine Manager (VMM) because its main job is to create one or more
&quot;virtual&quot; machines that share the hardware of a single physical machine. The original
purpose of a virtual device driver (VxD) in Microsoft Windows 3.0 was to virtualize a specific
device to help the VMM create the fiction that each virtual machine had a full complement of
hardware. The same VMM architecture introduced with Windows 3.0 is in Windows 98 today but with
a bunch of accretions to handle new hardware and 32-bit applications.</p>

<p>
<A HREF="javascript:fullSize('F01wi02x.htm')"> <img src="images/F01wi02.JPG" width=404 height=212 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 1-2.</b> <i>The Windows 98 architecture.</i><!--/caption-->
</p>


<p>Windows 98 doesn't handle I/O operations in quite as orderly a way as Windows 2000.
There are major differences in how Windows 98 handles operations directed to disks, to
communication ports, to keyboards, and so on. Windows 98 also services 32-bit and 16-bit
applications in fundamentally different ways. See Figure