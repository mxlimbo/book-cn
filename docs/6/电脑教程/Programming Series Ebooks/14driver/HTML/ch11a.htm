<html>
<head>
<title>Chapter 11 -- The Universal Serial Bus</title>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch10e.htm">[Previous]</A> <A HREF="ch11b.htm">[Next]</a>
</p>

<p>
<font size="+3">Chapter 11</font>
</p>

<A NAME="359"><H1>The Universal Serial Bus </H1></A>

<p>End user convenience is the keynote of the universal serial bus (USB). The Plug and Play
(PnP) concept has simplified the process of installing certain types of hardware on existing
PCs. However, configuration issues continue to plague end users with respect to legacy devices
such as serial and parallel ports, keyboards, and mice. The USB specification also identifies
port availability as one of the factors limiting proliferation of low-speed to medium-speed
peripherals, including modems, answering machines, scanners, and personal digital assistants.
USB helps solve these problems by providing a uniform method of connecting a potentially large
number of self-identifying low-to-medium-speed devices&#8212;that is, devices that require less
than a 1.5-megabyte-per-second data rate and that can electronically identify themselves to
system software&#8212;through a single PC port.</p>

<p>Although this book concerns software, some of the electrical and mechanical aspects of USB
are important to software developers. From the end user's point of view, USB's main
feature is the use by every device of an identical 4-conductor wire with a standardized plug
that fits into a socket on the back of the PC or on a hub device plugged into the PC.
Furthermore, you can attach or remove USB devices at will without explicitly opening or closing
the applications that use them and without worrying about electrical damage.</p>

<p>This chapter covers two broad topics. In the first part of the chapter, I'll describe
the programming architecture of USB. This architecture encompasses several ideas, including a
hierarchical method for attaching devices to a computer, a generic scheme for power management,
and a standard for self-identification that relies on a hierarchy of descriptors on board the
hardware. The USB architecture also employs a scheme for subdividing fixed-duration <i>
frames</i> into <i>packets</i> that convey data to and from devices. Finally, USB allows for
four different ways of transporting data between the host computer and <i>endpoints</i> on
devices. One method, named <i>isochronous,</i> permits a fixed amount of data to be moved
without error correction every millisecond (ms). The other methods, named <i>control, bulk,</i>
and <i>interrupt,</i> allow relatively small amounts of data (64 bytes or less) to be moved
with error correction.</p>

<p>In the second part of this chapter, I'll describe the additional features of a Windows
Driver Model driver for a USB device over and above the features you already know about. Rather
than communicate directly with hardware by using hardware abstraction layer (HAL) function
calls, a USB driver relies heavily on the bus driver (USBD.SYS). To send a request to its
device, the driver creates a <i>USB request block</i> (URB), which it submits to the bus
driver. Configuring a USB device, for example, requires the driver to submit several URBs for
reading descriptors and sending commands. USBD.SYS in turn schedules requests onto the bus
according to demand and available bandwidth.</p>

<p>The ultimate source for information about USB is the official specification, which was at
revision level 1.1 when this book went to press. The specification and various other documents
produced by the USB committee and its working groups were available on line at <i>
<a href="http://www.usb.org/developers/" target="_window2">http://www.usb.org/developers/</a></i>. Don Anderson's <i>Universal Serial Bus System
Architecture</i> (Addison-Wesley, 1997) recapitulates much of the specification in useful
form.</p>

<p><div class="sidebar"><blockquote>
<b>Note on Sample Programs</b>

<p>Anchor Chips, Incorporated (<i><a href="http://www.anchorchips.com" target="_window2">http://www.anchorchips.com</a></i>), kindly provided me one of
their EZ-USB development kits. The Anchor Chips USB chip set revolves around a modified 8051
microprocessor and additional core logic to perform some of the low-level protocol functions
mandated by the USB specification. The development board also contains additional external
memory, a UART and serial connector, a set of push buttons, and an LED readout to facilitate
development and debugging of 8051 firmware using Anchor Chips' software framework. One of
the key features of the Anchor Chips chip set is that you can download firmware over the USB
connection easily. For a programmer like me with a phobia for hardware in general and EEPROM
programming in particular, that feature is a godsend.</p>
<p>The USB sample drivers on the companion disc illustrate the simplest possible USB
devices and stand alone as examples of how to perform various tasks. If you happen to have an
Anchor Chips development kit, however, you can also try out these samples with real firmware.
Each sample contains a WDM driver in a SYS subdirectory, a Microsoft Win32 test program in a
TEST subdirectory, and a firmware program in an EZUSB directory. You can follow the directions
in the HTM files included with each sample to build these components or to simply install the
prebuilt versions that are on the disc. </p>

<p>A word of caution is in order here. Anchor Chips provides a reduced-function version of 8051
development tools authored by Keil Elektronik GmbH. You'll need an unlimited version of
those tools (which you must license separately from Keil) to develop real firmware and even to
build some of my samples. You might also need some perseverance to get past the rather dated
interface offered by these 16-bit programming tools. But, by the time you read this, Keil will
have introduced new, considerably improved 32-bit tools for the 8051 called uVision2.</p>
</blockquote></div></p>

</BODY>
</HTML>





