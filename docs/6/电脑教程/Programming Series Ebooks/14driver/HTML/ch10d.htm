<HTML>
<HEAD>
<TITLE>User-Mode Applications and WMI</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch10c.htm">[Previous]</A> <A HREF="ch10e.htm">[Next]</a>
</p>

<A NAME="348"><H1>User-Mode Applications and WMI</H1></A>

<p>User-mode support for WMI relies on the facilities of COM. To summarize a very complicated
situation, the Windows Management Service acts as the clearinghouse for information flowing
between consumers and providers by implementing several COM interfaces. Providers register
their existence with Windows Management via certain interfaces. Consumers indirectly
communicate with providers via interfaces. All of these interfaces are documented in the
Platform SDK, so I'm going to illustrate only the important method routines a consumer
uses. I'll start, though, by explaining the basic mechanics of using COM for those readers
who have little or no experience with COM.</p>

<A NAME="349"><H2>Just Enough COM</H2></A>

<p>As I said, this section is for readers who don't know the basics of using COM
interfaces. I spent years deliberately avoiding COM because its unique terminology made me
think it was too intricate to understand. I won't say that COM aficionados want it that
way, but I will say that I was once roundly criticized for presenting the following simplified
overview to a conference audience.</p>

<p>You'll encounter three crucial terms when you hear about COM. In COM, an <i>object</i>
is a software entity that implements the <i>methods</i> belonging to an <i>interface.</i>
(People in my generation will be imagining Bill Cosby saying, &quot;R-i-g-h-t! What's an
interface?&quot; just about now.) The key element you deal with when acting as a COM client is
a pointer to an interface, which you can dereference to invoke the method routines. You get an
interface pointer either because someone gives it to you or because you call an API that
returns it to you. From the perspective of a client program, some mysterious &quot;them&quot;
takes care of creating and destroying objects.</p>

<A NAME="350"><H3>What's an Interface?</H3></A>

<p>Now let's go through these three concepts more slowly, starting with the last one. An
interface is nothing more than a C++ class that has a bunch of virtual member functions but no
data members and no nonvirtual member functions. You can implement or use a COM interface in
many languages, not just C++. But because C++ gives us a common ground for understanding the
concept, I'll forge ahead as if C++ were the only language you'd ever use. Here's
the declaration of a simple interface as it might look before being translated into the
language of COM:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>class IUnknown
{
public:
  virtual long _ _stdcall QueryInterface(const GUID&amp; riid,
    void** ppvObject);
  virtual unsigned long _ _stdcall AddRef();
  virtual unsigned long _ _stdcall Release();
};</pre>
</td></tr>
</table>
</p>

<p>Instances of <b>IUnknown</b> (objects in COM) implement three public, virtual functions
(methods) named <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b>. AddRef and Release
are part of the mechanism by which COM makes sure that objects persist long enough for clients
to make use of them. QueryInterface is how client programs obtain pointers to additional
interfaces that an object supports.</p>

<p>In the Interface Definition Language (IDL) of COM, this interface description would look like
this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>interface IUnknown
{
  HRESULT QueryInterface(REFIID riid, void** ppvObject);
  ULONG AddRef();
  ULONG Release();
};</pre>
</td></tr>
</table>
</p>

<p>Apart from the syntactic differences, I think it's obvious how the IDL description of
this interface relates to a C++ class declaration. An IDL compiler can be used that translates
an interface declaration like this into syntax understandable by C and C++ compilers. Some
programming languages understand the IDL syntax without a translation, even.</p>

<p>Just like C++ classes, interfaces can be derived from other interfaces. In COM, one doesn't
declare interfaces with more than one base class. In addition, every COM interface derives
ultimately from IUnknown&#8212;meaning that every COM object supports the QueryInterface,
AddRef, and Release methods. Here's an example from the WMI world that we'll be using
later on:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>interface IWbemLocator : IUnknown
{
  HRESULT ConnectServer(BSTR strNetworkResource,
    BSTR strUser, BSTR strPassword, BSTR strLocale,
    long lSecurityFlags, BSTR strAuthority,
    IWbemContext* pCtx, IWbemServices** ppNameSpace);
};</pre>
</td></tr>
</table>
</p>

<p>So, an object that implements <b>IWbemLocator</b> has <i>four</i> method routines:
QueryInterface, AddRef, Release, and <b>ConnectServer</b>.</p>

<A NAME="351"><H3>Creating and Destroying Objects</H3></A>

<p>Getting an interface pointer that you can use to talk to an object is possible in many ways. Calling <b>CoCreateInstance</b> is a common way:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>IWbemLocator* locator;
HRESULT hr = CoCreateInstance(CLSID_WbemLocator, NULL,
  CLSCTX_INPROC_SERVER, IID_IWbemLocator, (PVOID*) &amp;locator);</pre>
</td></tr>
</table>
</p>

<p>CoCreateInstance consults the registry to locate a server that can instantiate a <b>
CLSID_WbemLocator</b> class of object. CLSID_WbemLocator is a 128-bit GUID of the same kind I
mentioned in Chapter 2 (&quot;<A HREF="ch02a.htm#30">Basic Structure of a WDM Driver</A>&quot;) in connection with
registered device interfaces. It's called a <i>class identifier</i> because it identifies a
kind, or class, of COM object. The HKEY_CLASSES_ROOT branch of the registry contains a key
named <b>CLSID</b>, the subkeys of which are the ASCII representations of all the class
identifiers that COM knows anything about. In the example we're considering,
CLSID_WbemLocator would be conventionally represented as
{4590f811-1d3a-11d0-891f-00aa004b2e24}, and the CLSID key includes a subkey named exactly that
in the registry. A subkey named <b>InProcServer32</b> designates a DLL (named WBEMPROX.DLL, a
part of the WMI core) as the server that implements this class of object.</p>

<p>Having located the class key in the registry, CoCreateInstance loads the designated server into
your address space and uses magic we don't need to discuss here to instantiate a
WbemLocator object and develop a pointer to the IWbemLocator interface that the object
supports. (<b>IID_IWbemLocator</b> is another GUID declared in WBEMCLI.H, which you'll
#include in your consumer project files.)</p>

<p>Following a successful call to CoCreateInstance, you'll have an interface pointer that
you can use like any pointer to a C++ class to call the method functions associated with the
interface. Somewhere in the world (maybe not even on the same computer) a concrete object
exists that implements those method functions. The object occupies storage and the executable
program whose instructions comprise the implementation also occupies storage. At some point in
time, presumably, you'll be done using your interface pointer and will be prepared to
destroy the object and, maybe, unload the program. The question is, when? That's where
AddRef and Release come in.</p>

<p>Each COM object has a reference count. Whenever someone obtains a pointer to an interface on
the object, the program that implements the object increments the reference count. So,
CoCreateInstance will always return a referenced interface pointer, and you can be sure that
the pointer will remain valid for the time being. You can increase the reference count on an
object explicitly by calling AddRef. When you're done using an interface pointer, you call
the Release method. The implementation of Release decrements the reference count. If the count
drops to 0, the implementation deletes the object. When a server doesn't own any more
objects, it can be unloaded.</p>

<p>Your job as a COM client is simply to release your reference to an interface when you no
longer need the underlying object. The following stylized coding sequence is pretty
typical:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>IWbemLocator* locator;
HRESULT hr = CoCreateInstance(...);
if (SUCCEEDED(hr))
  {
  ...
  locator-&gt;Release();
  }</pre>
</td></tr>
</table>
</p>

<A NAME="352"><H2>Accessing WMI Information</H2></A>

<p>When you want to access WMI facilities in user mode, you need to first establish a
connection to a particular namespace. Within the context of the namespace, you can then find
instances of WMI classes. You can query and set the data blocks associated with class
instances, invoke their method routines, and monitor the events that they generate.</p>

<A NAME="353"><H3>Connecting to a Namespace</H3></A>

<p>When you connect to a WMI namespace, you obtain a pointer to an <b>IWbemServices</b> 
interface that Windows Management implements. The following code&#8212;based on the TEST program
in the WMI42 sample&#8212;shows how to do this:</p>

<table width="95%" cellpadding="5" valign="TOP" border=0>
<tr><td valign=top>
<pre>
1 <img src="images/arorite2.jpg" width=17 height=10 alt="" border="0">


2 <img src="images/arorite2.jpg" width=17 height=10 alt="" border="0">









3 <img src="images/arorite2.jpg" width=17 height=10 alt="" border="0">





4 <img src="images/arorite2.jpg" width=17 height=10 alt="" border="0">




5 <img src="images/arorite2.jpg" width=17 height=10 alt="" border="0">









6 <img src="images/arorite2.jpg" width=17 height=10 alt="" border="0">
</pre>
</td>
<td valign=top>
<pre>
HRESULT hr = CoInitializeEx(NULL, 0);
if (!SUCCEEDED(hr))
  return;
hr = CoInitializeSecurity(NULL, -1, NULL, NULL,
  RPC_C_AUTHN_LEVEL_NONE, RPC_C_IMP_LEVEL_IMPERSONATE,
  NULL, 0, 0);
if (!SUCCEEDED(hr))
  {
  CoUninitialize();
  return;
  }

IWbemLocator* locator;
hr = CoCreateInstance(CLSID_WbemLocator, NULL,
  CLSCTX_INPROC_SERVER, IID_IWbemLocator, (PVOID*) &amp;locator);
if (SUCCEEDED(hr))
  {
  IWbemServices* services;
  BSTR pnamespace = SysAllocString(L&quot;root\\CIMV2&quot;);
  hr = locator-&gt;ConnectServer(pnamespace, NULL, NULL, 0, 0
    &amp;services);
  SysFreeString(pnamespace);
  if (SUCCEEDED(hr))
    {
    IClientSecurity* security;
    hr = services-&gt;QueryInterface(IID_IClientSecurity,
      (PVOID*) &amp;security);
    if (SUCCEEDED(hr))
      {
      security-&gt;SetBlanket(services, RPC_C_AUTHN_WINNT,
        RPC_C_AUTHZ_NONE, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
        RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
      security-&gt;Release();
      }
    // use the services interface
    services-&gt;Release();
    }
  locator-&gt;Release();
  }
CoUninitialize();
</pre></td></tr></table>

<ol>
<p><li> Every program that uses COM calls CoInitialize or <b>CoInitializeEx</b> to
initialize the COM library and calls <b>CoUninitialize</b> to close the COM library.</li></p>

<p><li> Never mind why you need to do this.</li></p>

<p><li> Here's where we instantiate a WbemLocator object and get a pointer to its <b>
IWbemLocator</b> interface. If this call succeeds, we'll eventually release our reference
to the interface.</li></p>

<p><li> We use the <b>IWbemLocator</b> interface to connect to the CIMV2 namespace. (In
beta releases, this should be the WMI namespace.) One of the quirks of using the <b>
ConnectServer</b> method is that you must make a copy of the Unicode name of the namespace by
calling <b>SysAllocString</b>.</li></p>

<p><li> <i>Really</i> never mind! I spent a couple of days figuring out that a call to
<b>IClientSecurity::SetBlanket</b> was needed here, because at the time I was writing this
chapter the SDK documentation hadn't caught up to the implementation. (@#$!)</li></p>

<p><li> This is the point at which you can use the <b>IWbemServices</b> interface pointer
to locate WMI class instances and access other WMI services.</li></p>
</ol>

<A NAME="354"><H3>Enumerating Class Instances</H3></A>

<p>Using an IWbemServices interface, you can enumerate all the instances of a particular WMI
class. WMI42's test program, for example, enumerates all the WMI42 class instances with the
following code:</p>


<table width="95%" cellpadding="5" valign="TOP" border=0>
<tr><td valign=top>
<pre>
1 <img src="images/arorite2.jpg" width=17 height=10 alt="" border="0">










2 <img src="images/arorite2.jpg" width=17 height=10 alt="" border="0">
</pre>
</td>
<td valign=top>
<pre>
IEnumWbemClassObject* enumerator = NULL;
BSTR bs = SysAllocString(L&quot;WMI42&quot;);
HRESULT hr = services-&gt;CreateInstanceEnum(bs,
  WBEM_FLAG_SHALLOW | WBEM_FLAG_RETURN_IMMEDIATELY |
  WBEM_FLAG_FORWARD_ONLY, NULL, &amp;enumerator);
SysFreeString(bs);
if (SUCCEEDED(hr))
  {
  while (TRUE)
    {
    ULONG junk;
    IWbemClassObject* cop = NULL;
    hr = Enumerator-&gt;Next(INFINITE, 1, &amp;cop, &amp;junk);
    if (hr == WBEM_S_FALSE)
      break;
    if (!SUCCEEDED(hr))
      break;
    // Use IWbemClassObject interface
    cop-&gt;Release();
    }
  enumerator-&gt;Release();
  }</pre>
</td></tr>
</table>


<ol>
<p><li> <b>IWbemServices::CreateInstanceEnum</b> will create an enumerator for all
instances of a named WMI class. This interface has two quirks that I discovered the hard way.
First, the class name must be passed in a separately allocated BSTR. Also, you must initialize
the target interface pointer to NULL even though it's supposedly only an output
argument&#8212;a crash ensues if the pointer is invalid to start with.</li></p>

<p><li> The instance enumerator's <b>Next</b> method delivers pointers to successive
instances of the class in the form of an <b>IWbemClassObject</b> interface pointer. The Next
method returns WBEM_S_FALSE when there are no more instances of the class. Initializing the
supposed output argument to NULL is required to avoid a crash with this interface, too.</li></p>
</ol>

<A NAME="355"><H3>Getting and Setting Item Values</H3></A>

<p>The <b>IWbemClassObject</b> interface is the key that unlocks the WMI functionality of your
driver. With a pointer to this interface, you can easily get or set the values of items in a
data block:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>IWbemClassObject* cop;
VARIANT answer;
BSTR propname = SysAllocString(L&quot;TheAnswer&quot;);
cop-&gt;Get(propname, 0, &amp;answer, NULL, NULL);
VariantClear(&amp;answer);

answer.vt = VT_I4;
answer.lVal = 6 * 9; // should be done in base 13!
cop-&gt;Put(propname, 0, &amp;answer, 0);
VariantClear(&amp;answer);

SysFreeString(propname);</pre>
</td></tr>
</table>
</p>

<p>In these fragments, we use a system string to name the property (that is, the item within
our schema) we want to get or put, and we use an OLE VARIANT structure (which can hold any type
of data) as the data value. Calling the <b>Get</b> method on this interface results in our
driver getting a QUERY_ALL_DATA or QUERY_SINGLE_INSTANCE. Calling the <b>Put</b> method results 
in a CHANGE_SINGLE_INSTANCE or CHANGE_SINGLE_ITEM. You can observe for yourself what happens by 
loading the WMI42 sample driver and invoking the test program a time or two. You shouldn't try 
to predict exactly which type of IRP will be used to support a Get or Put call because the WMI 
provider is free to package data requests to drivers in any convenient way.</p>

<A NAME="356"><H3>Receiving Event Notifications</H3></A>

<p>To receive notifications that WMI events have occurred, an application has to register
interest in specific events. To register interest, you must formulate a query in the so-called
WMI Query Language (WQL). WQL is a great deal like the Structured Query Language (SQL) one uses
in the world of relational databases. For example, to sign up to receive WMIEXTRA_EVENT
notifications, you could submit the following query:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>IWbemServices* services;
BSTR query = SysAllocString(L&quot;select * from WMIEXTRA_EVENT&quot;);
BSTR language = SysAllocString(L&quot;WQL&quot;);
IEnumWbemClassObject* enumerator = NULL;
HRESULT hr = services-&gt;ExecNotificationQuery(language, query,
  WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
  NULL, &amp;enumerator);
SysFreeString(language);
SysFreeString(query);
if (SUCCEEDED(hr))
  {
  ...
  enumerator-&gt;Release();
  }</pre>
</td></tr>
</table>
</p>

<p>The flag arguments to <b>ExecNotificationQuery</b> must be specified exactly as shown, by
the way.</p>

<p>Once you have the enumeration interface, you can call its <b>Next</b> method to poll for
events. For example:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>IWbemClassObject* cop = NULL;
DWORD junk;
hr = enumerator-&gt;Next(1000, 1, &amp;cop, &amp;junk);</pre>
</td></tr>
</table>
</p>

<p>In this call, we specify that we will wait up to 1000 milliseconds to obtain one event. If
an event is already pending or fires within this timeout period, Next will return us a
(referenced) IWbemClassObject pointer. Recall from the previous discussion of how a driver
fires an event that the event is represented by an instance of a WMI class. We can therefore
call the object's Get method to interrogate properties of the event.</p>

<p>In a real-world application, you should use <b>ExecNotificationQueryAsync</b> instead of
ExecNotificationQuery. The asynchronous form of the query allows you to provide an <b>
IWbemObjectSink</b> interface that WMI can call when events occur. Please refer to the Platform
SDK for additional information.</p>

<A NAME="357"><H3>Calling Method Routines</H3></A>

<p>Invoking a method routine requires just a few deceptively simple statements, as shown in the
following excerpt from WMIEXTRA's test program:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>IWbemServices* services; // <img src="images/tlarrow.jpg" width=13 height=12 border="0"> developed as shown earlier
IWbemClassObject* result = NULL;
BSTR pmethod = SysAllocString(L&quot;AnswerMethod&quot;);
BSTR objpath;            // <img src="images/aroleft.GIF" width=21 height=17  border="0"> more about this later
IWbemClassObject* inarg; // <img src="images/aroleft.GIF" width=21 height=17  border="0"> ditto

HRESULT hr = services-&gt;ExecMethod(objpath, pmethod, 0, NULL,
  inarg, &amp;result, NULL);
...
result-&gt;Release();
SysFreeString(pmethod);
<i>&lt;more cleanup&gt;</i></pre>
</td></tr>
</table>
</p>

<p>Calling <b>ExecMethod</b> invokes the method routine. You supply values for the input
arguments in the <b>inarg</b> object. The result of the call appears as the <b>result</b> 
object.</p>

<p>Invoking a method in this way would be almost trivial if it weren't for two complicating
factors. First, you have to come up with the full pathname (that is, the <b>objpath</b> 
argument to ExecMethod) to the object you want to address. And you must construct and
initialize a WMI object to contain the input arguments (if any) for the method call. I found
the first of these tasks to be a gigantic pain in the neck, as shown by the following snippet
from WMIEXTRA's test program:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>
IWbemServices* services;  // <img src="images/aroleft.GIF" width=21 height=17  border="0"> someone gives me this
BSTR pclass = SysAllocString(L&quot;wmiextra_method&quot;);
BSTR objpath = NULL;
HRESULT hr;

IEnumWbemClassObject* enumerator = NULL;
hr = services-&gt;CreateInstanceEnum(pclass, <i>&lt;etc.&gt;</i>);
if (SUCCEEDED(hr))
  {
  IWbemClassObject* instance = NULL;
  ULONG junk;
  hr = enumerator-&gt;Next(INFINITE, 1, &amp;instance, &amp;junk);
  if (SUCCEEDED(hr))
    {
    VARIANT instname;
    BSTR propname = SysAllocString(L&quot;InstanceName&quot;);
    hr = instance-&gt;Get(propname, 0, &amp;instname, NULL, NULL);
    SysFreeString(propname);
    if (SUCCEEDED(hr))
      {
      WCHAR fullpath[256];
      WCHAR escapedname[256];
      <i>&lt;code to double backslashes in instname&gt;</i>
      swprintf(fullpath, L&quot;%ws.InstanceName=\&quot;%s\&quot;&quot;,
        pclass, escapedname);
      objpath = SysAllocString(fullpath);
      VariantClear(&amp;instname);
      }
    instance-&gt;Release();
    }
  enumerator-&gt;Release();
  }
</pre></td></tr></table></p>
<p>Ugh. Especially the part (which I omitted here in the text) that goes through the instance
name and changes each backslash to two backslashes. In my opinion, there should be a method on
the IWbemClassObject interface that you can call to get the full pathname of an object. Such a
method would prevent our needing to discover the algorithm that some other system component has
used to construct the instance name. But, as I frequently find to be the case, no one asked me
for my opinion.</p>

<p>The Platform SDK documentation describes how to build the input arguments (that is, the <b>
inarg</b> argument to ExecMethod). Here's how I did it for WMIEXTRA:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>IWbemClassObject* cop = NULL; // <img src="images/tlarrow.jpg" width=13 height=12 border="0"> the class, not an instance
hr = services-&gt;GetObject(pclass, 0, NULL, &amp;cop, NULL);
if (SUCCEEDED(hr))
  {
  IWbemClassObject* iop = NULL; // <img src="images/tlarrow.jpg" width=13 height=12 border="0"> another class
  hr = cop-&gt;GetMethod(pmethod, 0, &amp;iop, NULL);
  if (SUCCEEDED(hr))
    {
    IWbemClassObject* inarg = NULL; // <img src="images/tlarrow.jpg" width=13 height=12 border="0"> an instance of iop
    hr = iop-&gt;SpawnInstance(0, &amp;inarg);
    if (SUCCEEDED(hr))
      {
      BSTR argname = SysAllocString(L&quot;TheAnswer&quot;);
      VARIANT argval;
      argval.vt = VT_I4;
      argval.lVal = 41;
      hr = inarg-&gt;Put(argname, 0, &amp;argval, 0);
      SysFreeString(argname);

      <i>&lt;the actual call to ExecMethod&gt;</i>

      inarg-&gt;Release();
      }
    iop-&gt;Release();
    }
  cop-&gt;Release();
  }</pre>
</td></tr>
</table>
</p>

<p>This code uses the data dictionary to obtain a description of the input argument class (the
<b>iop</b> variable). It then creates and initializes an instance of the input argument class
(the <b>inarg</b> variable) for use as an argument to the method routine.</p>

<p>I didn't check, but I assume that MFC provides a streamlined way to do all of this.</p>

</BODY>
</HTML>





