<HTML>
<HEAD>
<TITLE>Error Handling</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch03b.htm">[Previous]</A> <A HREF="ch03d.htm">[Next]</a>
</p>

<A NAME="69"><H1>Error Handling</H1></A>

<p>To err is human, to recover is part of software engineering. Exceptional conditions are
always arising in programs. Some of them start with program bugs, either in our own code or in
the user-mode applications that invoke our code. Some of them relate to system load or the
instantaneous state of hardware. Whatever the cause, unusual circumstances demand a flexible
response from our code. In this section, I'll describe three aspects of error handling:
status codes, structured exception handling, and bug checks. In general, kernel-mode support
routines report unexpected errors by returning a status code, whereas they report expected
variations in normal flow by returning a Boolean or numeric value other than a formal status
code. Structured exception handling offers a standardized way to clean up after really
unexpected events, such as dividing by zero or dereferencing an invalid pointer, or to avoid
the system crash that normally ensues after such an event. A <i>bug check</i> is the internal
name for a catastrophic failure for which a system shutdown is the only cure.</p>

<A NAME="70"><H2>Status Codes</H2></A>

<p>Kernel-mode support routines (and your code too, for that matter) indicate success or
failure by returning a status code to their caller. An NTSTATUS value is a 32-bit integer
composed of several subfields, as illustrated in Figure 3-2. The high-order two bits denote the
severity of the condition being reported&#8212;success, information, warning, or error. The
customer bit is, I believe, a vestige of the 1960s when IBM reserved customer fields for local
modification of its mainframe operating systems. I can't think of a current use for a
customer field. The facility code indicates which system component originated the message and
basically serves to decouple development groups from each other when it comes to assigning
numbers to codes. The remainder of the status code&#8212;16 bits' worth&#8212;indicates the
exact condition being reported.</p>

<p>
<A HREF="javascript:fullSize('F03wi02x.htm')"> <img src="images/F03wi02.JPG" width=404 height=93 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 3-2.</b> <i>Format of an NTSTATUS code.</i><!--/caption-->
</p>


<p>You should always check the status returns from routines that provide them. I'm going to
break this rule frequently in some of the code fragments I show you because including all the
necessary error handling code often obscures the expository purpose of the fragment. But
don't you emulate this sloppy practice!</p>

<p>If the high-order bit of a status code is zero, any number of the remaining bits could be
set and the code would still indicate success. Consequently, never just compare status codes to
zero to see if you're dealing with success&#8212;instead, use the NT_SUCCESS macro:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
NTSTATUSÁàètatus