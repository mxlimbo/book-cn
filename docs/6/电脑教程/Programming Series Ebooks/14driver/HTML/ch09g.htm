<HTML>
<HEAD>
<TITLE>Watchdog Timers</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch09f.htm">[Previous]</A> <A HREF="ch09h.htm">[Next]</a>
</p>

<A NAME="324"><H1>Watchdog Timers</H1></A>

<p>Some devices won't notify you when something goes wrong&#8212;they simply don't
respond when you talk to them. Each device object has an associated IO_TIMER object that you
can use to avoid indefinitely waiting for an operation to finish. While the timer is running,
the I/O Manager will call a timer callback routine once a second. Within the timer callback
routine, you can take steps to terminate any outstanding operations that should have finished
but didn't.</p>

<p>You initialize the timer object at AddDevice time:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>NTSTATUS AddDevice(...)
  {
  ...
  IoInitializeTimer(fdo, (PIO_TIMER_ROUTINE) OnTimer, pdx);
  ...
  }</pre>
</td></tr>
</table>
</p>

<p>where <b>fdo</b> is the address of your device object, <b>OnTimer</b> is the timer callback
routine, and <b>pdx</b> is a context argument for the I/O Manager's calls to OnTimer.</p>

<p>You start the timer counting by calling <b>IoStartTimer</b>, and you stop it from counting
by calling <b>IoStopTimer</b>. In between, your OnTimer routine is called once a second.</p>

<p>The PIOFAKE sample on the companion disc illustrates one way of using the IO_TIMER as a
watchdog. I put a <b>timer</b> member into the device extension for this fake device:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>typedef struct _DEVICE_EXTENSION {
  ...
  LONG timer;
  ...
  } DEVICE_EXTENSION, *PDEVICE_EXTENSION;</pre>
</td></tr>
</table>
</p>

<p>When I process an IRP_MJ_CREATE after a period with no handles open to the device, I start
the timer counting. When I process the IRP_MJ_CLOSE that closes the last handle, I stop the
timer:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>NTSTATUS DispatchCreate(...)
  {
  ...
  if (InterlockedIncrement(&amp;pdx-&gt;handles == 1)
    {
    pdx-&gt;timer = -1;
    IoStartTimer(fdo);
    }
  ...
  }

NTSTATUS DispatchClose(...)
  {
  ...
  if (InterlockedDecrement(&amp;pdx-&gt;handles) == 0)
    IoStopTimer(fdo);
  ...
  }</pre>
</td></tr>
</table>
</p>

<p>The <b>timer</b> cell begins life with the value -1. I set it to 10 (meaning 10 seconds) in
the StartIo routine and again after each interrupt. Thus, I allow 10 seconds for the device to
digest an output byte and to generate an interrupt that indicates readiness for the next byte.
(See the sidebar &quot;More About PIOFAKE&quot; for an explanation of the way this nonexistent
device works.) The work to be done by the OnTimer routine at each 1-second tick of the timer
needs to be synchronized with the interrupt service routine (ISR). Consequently, I use <b>
KeSynchronizeExecution</b> to call a helper routine (<b>CheckTimer</b>) at device IRQL (DIRQL)
under protection of the interrupt spin lock. The timer-tick routines dovetail with the ISR and
DPC routines as shown in this excerpt:</p>

<p>
<table cellpadding=5 width="95%"><tr>
<td valign=top>
<pre>








1 <img src="images/arorite2.jpg" width=17 height=10 border=0>

2 <img src="images/arorite2.jpg" width=17 height=10 border=0>


3 <img src="images/arorite2.jpg" width=17 height=10 border=0>







4 <img src="images/arorite2.jpg" width=17 height=10 border=0>









5 <img src="images/arorite2.jpg" width=17 height=10 border=0>






6 <img src="images/arorite2.jpg" width=17 height=10 border=0>
</pre>
</td>
<td valign="top">
<pre>VOID OnTimer(PDEVICE_OBJECT fdo, PDEVICE_EXTENSION pdx)
  {
  KeSynchronizeExecution(pdx-&gt;InterruptObject,
    (PKSYNCHRONIZE_ROUTINE) CheckTimer, pdx);
  }

VOID CheckTimer(PDEVICE_EXTENSION pdx)
  {
  if (pdx-&gt;timer &lt;= 0 || --pdx-&gt;timer &gt; 0)
    return;
  PIRP Irp = GetCurrentIrp(&amp;pdx-&gt;dqReadWrite);
  if (!Irp)
    return;
  Irp-&gt;IoStatus.Status = STATUS_IO_TIMEOUT;
  Irp-&gt;IoStatus.Information = 0;
  IoRequestDpc(pdx-&gt;DeviceObject, Irp, NULL);
  }

BOOLEAN OnInterrupt(...)
  {
  ...
  if (pdx-&gt;timer &lt;= 0)
    return TRUE;
  if (!pdx-&gt;nbytes)
    {
    Irp-&gt;IoStatus.Status = STATUS_SUCCESS;
    Irp-&gt;IoStatus.Information = pdx-&gt;numxfer;
    pdx-&gt;timer = -1;
    IoRequestDpc(pdx-&gt;DeviceObject, Irp, NULL);
    }
  ...
  pdx-&gt;timer = 10;
  }

VOID DpcForIsr(...)
  {
  ...
  PIRP Irp = StartNextPacket(&amp;pdx-&gt;dqReadWrite, fdo);
  IoCompleteRequest(Irp, IO_NO_INCREMENT);
  ...
  }</pre>
</td></tr>
</table>
</p>

<ol>
<p><li> A timer value of -1 means that no request is currently pending. A value of 0
means that the current request has timed out. In either case, we don't want or need to do
any more work in this routine. The second part of the <b>if</b> expression decrements the
timer. If it hasn't counted down to 0 yet, we return without doing anything else.</li></p>

<p><li> This driver uses a DEVQUEUE, so we call the DEVQUEUE routine <b>GetCurrentIrp</b> 
to get the address of the request we're currently processing. If this value is NULL, the
device is currently idle.</li></p>

<p><li> At this point, we've decided we want to terminate the current request because
nothing has happened for 10 seconds. We request a DPC after filling in the IRP status fields.
This particular status code (STATUS_IO_TIMEOUT) turns into a Win32 error code (ERROR_SEM_TIMEOUT) for which the standard error
text (&quot;The semaphore timeout period has expired&quot;) doesn't really indicate
what's gone wrong. If the application that has requested this operation is under your
control, you should provide a more meaningful explanation.</li></p>

<p><li> If the timer equals 0, the current request has timed out. The <b>CheckTimer</b> 
routine requested a DPC, so we don't need or want to do any more work in the ISR besides
dismissing the interrupt. By setting <b>timer</b> to -1, we prevent the next invocation of
CheckTimer from requesting another DPC for this same request.</li></p>

<p><li> We allow 10 seconds between interrupts.</li></p>

<p><li> Whatever requested this DPC also filled in the IRP's status fields. We
therefore need to call only <b>IoCompleteRequest</b>.</li></p>
</ol>

<p><div class="sidebar"><blockquote>
<b>More About PIOFAKE</b>
<p>The PIOFAKE sample driver works with a nonexistent device that follows a programmed I/O (PIO)
model. The device has a single output port to which you can write ASCII characters. After it
digests a data byte, it generates an interrupt on its IRQ line.</p>

<p>If you install PIOFAKE in Windows 2000 and run the associated TEST program, nothing will happen
for 10 seconds. Then PIOFAKE will time out because it hasn't seen an interrupt, whereupon
the test application will report a timeout error.</p>

<p>In Windows 98, you can use the DEVTEST device simulator to exercise the PIO part of this sample
driver. Refer to the instructions in PIOFAKE.HTM for additional information.</p>
</blockquote></div>
</p>

</BODY>
</HTML>





