<HTML>
<HEAD>
<TITLE>Ports and Registers</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch07c.htm">[Previous]</A> <A HREF="ch07e.htm">[Next]</a>
</p>

<A NAME="233"><H1>Ports and Registers</H1></A>

<p>Windows 2000 models driver access to many devices, as depicted in Figure 7-4. Generally,
CPUs can have separate memory and I/O address spaces. To access a <i>memory-mapped</i> device,
the CPU employs a memory-type reference such as a load or a store directed to a virtual
address. The CPU translates the virtual address to a physical address by using a set of page
tables. To access an <i>I/O-mapped</i> device, on the other hand, the CPU invokes some special
mechanism such as the x86 IN and OUT instructions.<br>

<p>
<A HREF="javascript:fullSize('F07wi04x.htm')"> <img src="images/F07wi04.JPG" width=404 height=276 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 7-4.</b> <i>Accessing ports and registers.</i><!--/caption-->
</p>


Devices have bus-specific ways of decoding memory and I/O addresses. In the case of the PCI
bus, a host bridge maps CPU physical memory addresses and I/O addresses to a bus address space
that's directly accessible to devices. Flag bits in the device's configuration space
determine whether the bridge maps the device's registers to a memory or an I/O address on
CPUs that have both address spaces.</p>

<p>As I've said, some CPUs have separate memory and I/O address spaces. Intel architecture
CPUs have both, for example. Other CPUs, such as the Alpha, have just a memory address space.
If your device is I/O-mapped, the PnP Manager will give you port resources. If your device is
memory-mapped, it will give you memory resources instead.</p>

<p>Rather than have you place reams of conditionally compiled code into your driver for all
possible platforms, the Windows NT designers invented the hardware abstraction layer (HAL) to
which I've alluded a few times in this book. The HAL provides functions that you use to
access port and memory resources. See Table 7-3. As the table indicates, you can READ/WRITE
either a single UCHAR/USHORT/ULONG or an array of them from or to a PORT/REGISTER. That makes
24 HAL functions in all that are used for device access. Since a WDM driver doesn't
directly rely on the HAL for anything else, you might as well think of these 24 functions as
being the entire public interface to the HAL.</p>

<b>Table 7-3.</b> <i>HAL functions for accessing ports and memory registers.</i>

<table cellpadding="5" width="95%">
<tr><th><i>Access Width</i></th><th><i>Functions for Port Access</i></th><th><i>Functions for Memory Access</i></th></tr>
<tr><td valign="top">8 bits</td><td valign="top">READ_PORT_UCHAR<br>WRITE_PORT_UCHAR</td><td valign="top">READ_REGISTER_UCHAR<br>WRITE_REGISTER_UCHAR</td></tr>
<tr><td valign="top">16 bits</td><td valign="top">READ_PORT_USHORT<br>WRITE_PORT_USHORT</td><td valign="top">READ_REGISTER_USHORT<br>WRITE_REGISTER_USHORT</td></tr>
<tr><td valign="top">32 bits</td><td valign="top">READ_PORT_ULONG<br>WRITE_PORT_ULONG</td><td valign="top">READ_REGISTER_ULONG<br>WRITE_REGISTER_ULONG</td></tr>
<tr><td valign="top">string of 8-bit bytes</td><td valign="top">READ_PORT_BUFFER_UCHAR<br>WRITE_PORT_BUFFER_UCHAR</td><td valign="top">READ_REGISTER_BUFFER_UCHAR<br>WRITE_REGISTER_BUFFER_UCHAR</td></tr>
<tr><td valign="top">string of 16-bit words</td><td valign="top">READ_PORT_BUFFER_USHORT<br>WRITE_PORT_BUFFER_USHORT</td><td valign="top">READ_REGISTER_BUFFER_USHORT<br>WRITE_REGISTER_BUFFER_USHORT</td></tr>
<tr><td valign="top">string of 32-bit double words</td><td valign="top">READ_PORT_BUFFER_ULONG<br>WRITE_PORT_BUFFER_ULONG</td><td valign="top">READ_REGISTER_BUFFER_ULONG<br>WRITE_REGISTER_BUFFER_ULONG</td></tr>
</table>

<p>What goes on inside these access functions is (obviously!) highly dependent on the platform.
The Intel x86 version of READ_PORT_CHAR, for example, performs an IN instruction to read one
byte from the designated I/O port. The Microsoftç‡±indows