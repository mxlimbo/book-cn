<HTML>
<HEAD>
<TITLE>User-Mode Applications and WMI</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch10c.htm">[Previous]</A> <A HREF="ch10e.htm">[Next]</a>
</p>

<A NAME="348"><H1>User-Mode Applications and WMI</H1></A>

<p>User-mode support for WMI relies on the facilities of COM. To summarize a very complicated
situation, the Windows Management Service acts as the clearinghouse for information flowing
between consumers and providers by implementing several COM interfaces. Providers register
their existence with Windows Management via certain interfaces. Consumers indirectly
communicate with providers via interfaces. All of these interfaces are documented in the
Platform SDK, so I'm going to illustrate only the important method routines a consumer
uses. I'll start, though, by explaining the basic mechanics of using COM for those readers
who have little or no experience with COM.</p>

<A NAME="349"><H2>Just Enough COM</H2></A>

<p>As I said, this section is for readers who don't know the basics of using COM
interfaces. I spent years deliberately avoiding COM because its unique terminology made me
think it was too intricate to understand. I won't say that COM aficionados want it that
way, but I will say that I was once roundly criticized for presenting the following simplified
overview to a conference audience.</p>

<p>You'll encounter three crucial terms when you hear about COM. In COM, an <i>object</i>
is a software entity that implements the <i>methods</i> belonging to an <i>interface.</i>
(People in my generation will be imagining Bill Cosby saying, &quot;R-i-g-h-t! What's an
interface?&quot; just about now.) The key element you deal with when acting as a COM client is
a pointer to an interface, which you can dereference to invoke the method routines. You get an
interface pointer either because someone gives it to you or because you call an API that
returns it to you. From the perspective of a client program, some mysterious &quot;them&quot;
takes care of creating and destroying objects.</p>

<A NAME="350"><H3>What's an Interface?</H3></A>

<p>Now let's go through these three concepts more slowly, starting with the last one. An
interface is nothing more than a C++ class that has a bunch of virtual member functions but no
data members and no nonvirtual member functions. You can implement or use a COM interface in
many languages, not just C++. But because C++ gives us a common ground for understanding the
concept, I'll forge ahead as if C++ were the only language you'd ever use. Here's
the declaration of a simple interface as it might look before being translated into the
language of COM:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>class營Unknown
{
public:
牋virtual爈ong燺 _stdcall燪ueryInterface(const燝UID&amp;爎iid,
牋牋void**爌pvObject);
牋virtual爑nsigned爈ong燺 _stdcall燗ddRef();
牋virtual爑nsigned爈ong燺 _stdcall燫elease();
};</pre>
</td></tr>
</table>
</p>

<p>Instances of <b>IUnknown</b> (objects in COM) implement three public, virtual functions
(methods) named <b>QueryInterface</b>, <b>AddRef</b>, and <b>Release</b>. AddRef and Release
are part of the mechanism by which COM makes sure that objects persist long enough for clients
to make use of them. QueryInterface is how client programs obtain pointers to additional
interfaces that an object supports.</p>

<p>In the Interface Definition Language (IDL) of COM, this interface description would look like
this:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>interface營Unknown
{
牋HRESULT燪ueryInterface(REFIID爎iid,爒oid**爌pvObject);
牋ULONG燗ddRef();
牋ULONG燫elease();
};</pre>
</td></tr>
</table>
</p>

<p>Apart from the syntactic differences, I think it's obvious how the IDL description of
this interface relates to a C++ class declaration. An IDL compiler can be used that translates
an interface declaration like this into syntax understandable by C and C++ compilers. Some
programming languages understand the IDL syntax without a translation, even.</p>

<p>Just like C++ classes, interfaces can be derived from other interfaces. In COM, one doesn't
declare interfaces with more than one base class. In addition, every COM interface derives
ultimately from IUnknown&#8212;meaning that every COM object supports the QueryInterface,
AddRef, and Release methods. Here's an example from the WMI world that we'll be using
later on:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>interface營WbemLocator