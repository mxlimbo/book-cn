<HTML>
<HEAD>
<TITLE>String Handling</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch03d.htm">[Previous]</A> <A HREF="ch03f.htm">[Next]</a>
</p>

<A NAME="92"><H1>String Handling</H1></A>

<p>WDM drivers can work with string data in any of four formats:</p>

<ul>
<p><li> A Unicode string, normally described by a UNICODE_STRING structure, contains 16-bit
characters. Unicode has sufficient code points to accommodate the language scripts used on this
planet (and on at least one other&#8212;see <i>
<a href="http://www.indigo.ie/egt/standards/csur/klingon.html" target="_window2">http://www.indigo.ie/egt/standards/csur/klingon.html</a></i> ).</li></p>

<p><li> An ANSI string, normally described by an ANSI_STRING structure, contains 8-bit
characters. A variant is an OEM_STRING, which also describes a string of 8-bit characters. The
difference between the two is that an OEM string has characters whose graphic depends on the
current code page, whereas an ANSI string has characters whose graphic is independent of code
page. WDM drivers would not normally deal with OEM strings because they would have to originate
in user mode, and some other kernel-mode component will have already translated them into
Unicode strings by the time the driver sees them.</li></p>

<p><li> A null-terminated string of characters. You can express constants using normal C syntax,
such as <b>&quot;Hello, world!&quot;</b> Strings employ 8-bit characters of type CHAR, which
are assumed to be from the ANSI character set. The characters in string constants originate in
whatever editor you used to create your source code. If you use an editor that relies on the
then-current code page to display graphics in the editing window, be aware that some characters
might have a different meaning when treated as part of the Windows ANSI character set.</li></p>

<p><li> A null-terminated string of wide characters (type WCHAR). You can express wide string
constants using normal C syntax, such as <b>L&quot;Goodbye, cruel world!&quot;</b> Such strings
look like Unicode constants, but, being ultimately derived from some text editor or another,
actually use only the ASCII and Latin1 code points (0020-007F and 00A0-00FF) that correspond to
the Windows ANSI set.</li></p>
</ul>


<p>The UNICODE_STRING and ANSI_STRING data structures both have the layout depicted in Figure
3-14. The <b>Buffer</b> field of either structure points to a data area elsewhere in memory
that contains the string data. <b>MaximumLength</b> gives the length of the buffer area, and
<b>Length</b> provides the (current) length of the string without regard to any null terminator
that might be present. Both length fields are <i>in bytes,</i> even for the UNICODE_STRING
structure.</p>

<p>
<img src="images/F03wi14.JPG" width=403 height=234 border="0">
</p><p>
<!--caption--><b>Figure 3-14.</b> <i>The UNICODE_STRING and ANSI_STRING structures.</i><!--/caption-->
</p>


<p>Table 3-7 lists the service functions that you can use for working with Unicode and ANSI
strings. I've listed them side by side because there's a fair amount of duplication.
I've also listed some functions from the standard C run-time library that are available in
kernel mode for manipulating regular C-style strings. The standard DDK headers include
declarations of these functions, and the libraries with which you link drivers contain them, so
there's no particular reason not to use them even though they've never been documented
in the DDK as being available.</p>

<p><b>Table 3-7.</b> <i>Functions for string manipulation.</i></p>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>Operation</i></th>
<th><i>ANSI String Function</i></th>
<th><i>Unicode String Function</i></th>
</tr>
<tr>
<td valign="top">Length</td>
<td valign="top">strlen</td>
<td valign="top">wcslen</td>
</tr>
<tr>
<td valign="top">Concatenate</td>
<td valign="top">strcat, strncat</td>
<td valign="top">wcscat, wcsncat, 
RtlAppendUnicodeStringToString, 
RtlAppendUnicodeToString</td>
</tr>
<tr>
<td valign="top">Copy</td>
<td valign="top">strcpy, strncpy, 
RtlCopyString</td>
<td valign="top">wcscpy, wcsncpy, 
RtlCopyUnicodeString</td>
</tr>
<tr>
<td valign="top">Reverse</td>
<td valign="top">_strrev</td>
<td valign="top">_wcsrev</td>
</tr>
<tr>
<td valign="top">Compare</td>
<td valign="top">strcmp, strncmp, 
_stricmp, _strnicmp, 
RtlCompareString, 
RtlEqualString</td>
<td valign="top">wcscmp, wcsncmp, _wcsicmp, 
_wcsnicmp, 
RtlCompareUnicodeString, 
RtlEqualUnicodeString, 
RtlPrefixUnicodeString</td>
</tr>
<tr>
<td valign="top">Initialize</td>
<td valign="top">_strset, _strnset, 
RtlInitAnsiString, 
RtlInitString</td>
<td valign="top">_wcsnset, 
RtlInitUnicodeString</td>
</tr>
<tr>
<td valign="top">Search</td>
<td valign="top">strchr, strrchr, 
strspn, strstr</td>
<td valign="top">wcschr, wcsrchr, wcsspn, wcsstr</td>
</tr>
<tr>
<td valign="top">Upper/lowercase</td>
<td valign="top">_strlwr, _strupr, 
RtlUpperString</td>
<td valign="top">_wcslwr, _wcsupr, 
RtlUpcaseUnicodeString</td>
</tr>
<tr>
<td valign="top">Character</td>
<td valign="top">isdigit, islower, isprint, 
isspace, isupper, 
isxdigit, tolower, 
toupper, 
RtlUpperChar</td>
<td valign="top">towlower, towupper, 
RtlUpcaseUnicodeChar</td>
</tr>
<tr>
<td valign="top">Format</td>
<td valign="top">sprintf, vsprintf, 
 _snprintf, _vsnprintf</td>
<td valign="top">swprintf, _snwprintf</td>
</tr>
<tr>
<td valign="top">String conversion</td>
<td valign="top">atoi, atol, _itoa</td>
<td valign="top">_itow, 
RtlIntegerToUnicodeString, 
RtlUnicodeStringToInteger</td>
</tr>
<tr>
<td valign="top">Type conversion</td>
<td valign="top">RtlAnsiStringToUnicodeSize, 
RtlAnsiStringToUnicodeString</td>
<td valign="top">RtlUnicodeStringToAnsiString</td>
</tr>
<tr>
<td valign="top">Memory release</td>
<td valign="top">RtlFreeAnsiString</td>
<td valign="top">RtlFreeUnicodeString</td>
</tr>
</table>
</p>


<p>Many more <b>Rtl</b><i>Xxx</i> functions are exported by the system DLLs, but I've listed
the ones for which the DDK header files (and the SDK headers they include) define prototypes.
These are the only ones we should use in drivers.</p>

<A NAME="93"><H3>Allocating and Releasing String Buffers</H3></A>

<p>I'm not going to describe the string manipulation functions in detail because the DDK
documentation does this perfectly well and you already know, based on your general programming
experience, how to put functions like this together to get your work done. But I do want to
discuss a problem that can rear up and bite you if you don't look out for it.</p>

<p>You often define UNICODE_STRING (or ANSI_STRING) structures as automatic variables or as parts
of your own device extension. The string buffers to which these structures point usually occupy
dynamically allocated memory, but you'll sometimes want to work with string constants, too.
Keeping track of who owns the memory to which a particular UNICODE_STRING or ANSI_STRING
structure points can be a bit of a problem. Consider the following fragment of a function:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>
UNICODE_STRINGÁàÅoo;
if