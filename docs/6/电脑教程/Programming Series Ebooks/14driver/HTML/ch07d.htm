<HTML>
<HEAD>
<TITLE>Ports and Registers</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch07c.htm">[Previous]</A> <A HREF="ch07e.htm">[Next]</a>
</p>

<A NAME="233"><H1>Ports and Registers</H1></A>

<p>Windows 2000 models driver access to many devices, as depicted in Figure 7-4. Generally,
CPUs can have separate memory and I/O address spaces. To access a <i>memory-mapped</i> device,
the CPU employs a memory-type reference such as a load or a store directed to a virtual
address. The CPU translates the virtual address to a physical address by using a set of page
tables. To access an <i>I/O-mapped</i> device, on the other hand, the CPU invokes some special
mechanism such as the x86 IN and OUT instructions.<br>

<p>
<A HREF="javascript:fullSize('F07wi04x.htm')"> <img src="images/F07wi04.JPG" width=404 height=276 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!--caption--><b>Figure 7-4.</b> <i>Accessing ports and registers.</i><!--/caption-->
</p>


Devices have bus-specific ways of decoding memory and I/O addresses. In the case of the PCI
bus, a host bridge maps CPU physical memory addresses and I/O addresses to a bus address space
that's directly accessible to devices. Flag bits in the device's configuration space
determine whether the bridge maps the device's registers to a memory or an I/O address on
CPUs that have both address spaces.</p>

<p>As I've said, some CPUs have separate memory and I/O address spaces. Intel architecture
CPUs have both, for example. Other CPUs, such as the Alpha, have just a memory address space.
If your device is I/O-mapped, the PnP Manager will give you port resources. If your device is
memory-mapped, it will give you memory resources instead.</p>

<p>Rather than have you place reams of conditionally compiled code into your driver for all
possible platforms, the Windows NT designers invented the hardware abstraction layer (HAL) to
which I've alluded a few times in this book. The HAL provides functions that you use to
access port and memory resources. See Table 7-3. As the table indicates, you can READ/WRITE
either a single UCHAR/USHORT/ULONG or an array of them from or to a PORT/REGISTER. That makes
24 HAL functions in all that are used for device access. Since a WDM driver doesn't
directly rely on the HAL for anything else, you might as well think of these 24 functions as
being the entire public interface to the HAL.</p>

<b>Table 7-3.</b> <i>HAL functions for accessing ports and memory registers.</i>

<table cellpadding="5" width="95%">
<tr><th><i>Access Width</i></th><th><i>Functions for Port Access</i></th><th><i>Functions for Memory Access</i></th></tr>
<tr><td valign="top">8 bits</td><td valign="top">READ_PORT_UCHAR<br>WRITE_PORT_UCHAR</td><td valign="top">READ_REGISTER_UCHAR<br>WRITE_REGISTER_UCHAR</td></tr>
<tr><td valign="top">16 bits</td><td valign="top">READ_PORT_USHORT<br>WRITE_PORT_USHORT</td><td valign="top">READ_REGISTER_USHORT<br>WRITE_REGISTER_USHORT</td></tr>
<tr><td valign="top">32 bits</td><td valign="top">READ_PORT_ULONG<br>WRITE_PORT_ULONG</td><td valign="top">READ_REGISTER_ULONG<br>WRITE_REGISTER_ULONG</td></tr>
<tr><td valign="top">string of 8-bit bytes</td><td valign="top">READ_PORT_BUFFER_UCHAR<br>WRITE_PORT_BUFFER_UCHAR</td><td valign="top">READ_REGISTER_BUFFER_UCHAR<br>WRITE_REGISTER_BUFFER_UCHAR</td></tr>
<tr><td valign="top">string of 16-bit words</td><td valign="top">READ_PORT_BUFFER_USHORT<br>WRITE_PORT_BUFFER_USHORT</td><td valign="top">READ_REGISTER_BUFFER_USHORT<br>WRITE_REGISTER_BUFFER_USHORT</td></tr>
<tr><td valign="top">string of 32-bit double words</td><td valign="top">READ_PORT_BUFFER_ULONG<br>WRITE_PORT_BUFFER_ULONG</td><td valign="top">READ_REGISTER_BUFFER_ULONG<br>WRITE_REGISTER_BUFFER_ULONG</td></tr>
</table>

<p>What goes on inside these access functions is (obviously!) highly dependent on the platform.
The Intel x86 version of READ_PORT_CHAR, for example, performs an IN instruction to read one
byte from the designated I/O port. The Microsoft Windows 98 implementation goes so far as to
overstore the driver's call instruction with an actual IN instruction in some situations.
The Alpha version of this routine performs a memory fetch. The Intel x86 version of
READ_REGISTER_UCHAR performs a memory fetch also; this function is macro'ed as a direct
memory reference on the Alpha. The buffered version of this function
(READ_REGISTER_BUFFER_UCHAR), on the other hand, does some extra work in the Intel x86
environment to be sure that all CPU caches get properly flushed when the operation
finishes.</p>

<p>The whole point of having the HAL in the first place is so that you don't have to worry
about platform differences or about the sometimes arcane requirements for accessing devices in
the multitasking, multiprocessor environment of Windows 2000. Your job is quite simple: use a
PORT call to access what you think is a port resource, and use a REGISTER call to access what
you think is a memory resource.</p>

<A NAME="234"><H2>Port Resources</H2></A>

<p>I/O-mapped devices expose hardware registers that, on some CPU architectures (including
Intel x86), are addressed by software using a special I/O address space. On other CPU
architectures, no separate I/O address space exists and these registers are addressed using
regular memory references. Luckily, you don't need to understand these addressing
complexities. If your device requests a port resource, one iteration of your loop over the
translated resource descriptors will find a CmResourceTypePort descriptor and you'll save
three pieces of information.</p>

<p>
<table cellpadding=5 width="95%">
<tr><td valign=top>
<pre>














1 <img src="images/arorite2.jpg" width=17 height=10 border=0>

2 <img src="images/arorite2.jpg" width=17 height=10 border=0>






3 <img src="images/arorite2.jpg" width=17 height=10 border=0>




4 <img src="images/arorite2.jpg" width=17 height=10 border=0>
</pre>
</td>
<td valign=top>
<pre>
typedef struct _DEVICE_EXTENSION {
  ...
  PUCHAR portbase;
  ULONG nports;
  BOOLEAN mappedport;
  ...} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

PHYSICAL_ADDRESS portbase;    // base address of range
...
for (ULONG i = 0; i &lt; nres; ++i, ++resource)
  {
  switch (resource-&gt;Type)
    {
  case CmResourceTypePort:
    portbase = resource-&gt;u.Port.Start;
    pdx-&gt;nports = resource-&gt;u.Port.Length;
    pdx-&gt;mappedport = (resource-&gt;Flags &amp; CM_RESOURCE_PORT_IO) == 0;
    break;
  ...
    }
...
if (mappedport)
  {
  pdx-&gt;portbase = (PUCHAR) MmMapIoSpace(portbase, nports, MmNonCached);
  if (!pdx-&gt;portbase)
    return STATUS_NO_MEMORY;
  }
else
  pdx-&gt;portbase = (PUCHAR) portbase.QuadPart;</pre>
</td></tr>
</table>
</p>

<ol>
<p><li> The resource descriptor contains a union named <b>u</b> that has substructures
for each of the standard resource types. <b>u.Port</b> has information about a port resource.
<b>u.Port.Start</b> is the beginning address of a contiguous range of I/O ports, and <b>
u.Port.Length</b> is the number of ports in the range. The start address is a 64-bit
PHYSICAL_ADDRESS value.</li></p>

<p><li> The <b>Flags</b> member of the resource descriptor for a port resource has the
CM_RESOURCE_PORT_IO flag set if the CPU architecture has a separate I/O address space to which
the given port address belongs.</li></p>

<p><li> If the CM_RESOURCE_PORT_IO flag was clear, as it will be on an Alpha and perhaps
other RISC platforms, you must call <b>MmMapIoSpace</b> to obtain a kernel-mode virtual address
by which the port can be accessed. The access will really employ a memory reference, but
you'll still call the PORT flavor of HAL routines (READ_PORT_UCHAR and so on) from your
driver.</li></p>

<p><li> If the CM_RESOURCE_PORT_IO flag was set, as it will be on an x86 platform, you do
not need to map the port address. You'll call the PORT flavor of HAL routines from your
driver when you want to access one of your ports. The HAL routines demand a PUCHAR port address
argument, which is why we cast the base address to that type. The <b>QuadPart</b> reference, by
the way, results in your getting a 32-bit or 64-bit pointer, as appropriate to the platform for
which you're compiling.</li></p>
</ol>

<p>Whether or not the port address needs to be mapped via MmMapIoSpace, you'll always call
the HAL routines that deal with I/O port resources: READ_PORT_UCHAR, WRITE_PORT_UCHAR, and so
on. On a CPU that requires you to map a port address, the HAL will be making memory references.
On a CPU that doesn't require the mapping, the HAL will be making I/O references; on an
x86, this means using one of the IN and OUT instruction family.</p>

<p>Your <b>StopDevice</b> helper routine has a small cleanup task to perform if you happen to have
mapped your port resource:</p>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>VOID StopDevice(...)
  {
  ...
  if (pdx-&gt;portbase &amp;&amp; pdx-&gt;mappedport)
    MmUnmapIoSpace(pdx-&gt;portbase, pdx-&gt;nports);
  pdx-&gt;portbase = NULL;
  ...
  }</pre>
</td></tr>
</table>
</p>

<A NAME="235"><H2>Memory Resources</H2></A>

<p>Memory-mapped devices expose registers that software accesses using load and store
instructions. The translated resource value you get from the PnP Manager is a physical address,
and you need to reserve virtual addresses to cover the physical memory. Later on, you'll be
calling HAL routines that deal with memory registers, such as READ_REGISTER_UCHAR,
WRITE_REGISTER_UCHAR, and so on. Your extraction and configuration code would look like this
fragment:</p>

<p>
<table cellpadding=5 width="95%">
<tr><td valign=top>
<pre>













1 <img src="images/arorite2.jpg" width=17 height=10 border=0>





2 <img src="images/arorite2.jpg" width=17 height=10 border=0>
</pre>
</td>
<td valign=top>
<pre>
typedef struct _DEVICE_EXTENSION {
  ...
  PUCHAR membase;
  ULONG nbytes;
  ...} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

PHYSICAL_ADDRESS membase;     // base address of range
...
for (ULONG i = 0; i &lt; nres; ++i, ++resource)
  {
  switch (resource-&gt;Type)
    {
  case CmResourceTypeMemory:
  membase = resource-&gt;u.Memory.Start;
    pdx-&gt;nbytes = resource-&gt;u.Memory.Length;
    break;
  ...
    }
...
pdx-&gt;membase = (PUCHAR) MmMapIoSpace(membase, pdx-&gt;nbytes,
  MmNonCached);
if (!pdx-&gt;membase)
  return STATUS_NO_MEMORY;</pre>
</td></tr>
</table>
</p>

<ol>
<p><li> Within the resource descriptor, <b>u.Memory</b> has information about a memory
resource. <b>u.Memory.Start</b> is the beginning address of a contiguous range of memory
locations, and <b>u.Memory.Length</b> is the number of bytes in the range. The start address is
a 64-bit PHYSICAL_ADDRESS value. It's not an accident that the <b>u.Port</b> and <b>
u.Memory</b> substructures are identical&#8212;it's on purpose, and you can rely on it being
true if you want to.</li></p>

<p><li> You must call <b>MmMapIoSpace</b> to obtain a kernel-mode virtual address by
which the memory range can be accessed.</li></p>
</ol>
<p>Your <b>StopDevice</b> function unconditionally unmaps your memory resources:</p>


<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>VOID StopDevice(...)
  {
  ...
  if (pdx-&gt;membase)
    MmUnmapIoSpace(pdx-&gt;membase, pdx-&gt;nbytes);
  pdx-&gt;membase = NULL;
  ...
  }</pre>
</td></tr>
</table>
</p>

</BODY>
</HTML>





