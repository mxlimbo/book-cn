<HTML>
<HEAD>
<TITLE>System Threads</TITLE>
<link rel="STYLESHEET" type="text/css" href="waltoney.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</head>
<BODY bgcolor="#ffffff" text="#000000">
<p>
<A HREF="ch09d.htm">[Previous]</A> <A HREF="ch09f.htm">[Next]</a>
</p>

<A NAME="319"><H1>System Threads</H1></A>

<p>In all the device drivers considered so far in the book, we haven't been overly
concerned about the thread context in which our driver subroutines have executed. Much of the
time, our subroutines run in an arbitrary thread context, which means we can't block and
can't directly access user-mode virtual memory. Some devices are very difficult to program
when faced with the first of these constraints.</p>

<p>Some devices are best handled by <i>polling</i>. A device that can't asynchronously
interrupt the CPU, for example, needs to be interrogated from time to time to check its state.
In other cases, the natural way to program the device might be to perform an operation in steps
with waits in between. A floppy disk driver, for example, goes through a series of steps to
perform an operation. In general, the driver has to command the drive to spin up to speed, wait
for the spin-up to occur, commence the transfer, wait a short while, and then spin the drive
back down. You could design a driver that operates as a finite state machine to allow a
callback function to properly sequence operations. It would be much easier, though, if you
could just insert event and timer waits at the appropriate spots of a straight-line
program.</p>

<p>Dealing with situations that require you to periodically interrogate a device is easy with the
help of a <i>system thread</i> belonging to the driver. A system thread is a thread that
operates within the overall umbrella of a process belonging to the operating system as a whole.
I'll be talking exclusively about system threads that execute solely in kernel mode. In the
next section, I'll describe the mechanism by which you create and destroy your own system
threads. Then I'll give an example of how to use a system thread to manage a polled input
device.</p>

<A NAME="320"><H2>Creating and Terminating System Threads</H2></A>

<p>To launch a system thread, you call <b>PsCreateSystemThread</b>. One of the arguments to
this service function is the address of a <i>thread procedure</i> that acts as the main program
for the new thread. When the thread procedure is going to terminate the thread, it calls <b>
PsTerminateSystemThread</b>, which does not return. Generally speaking, you need to provide a
way for a PnP event to tell the thread to terminate and to wait for the termination to occur.
Combining all these factors, you'll end up with code that performs the functions of these
three subroutines:</p>

<p>
<table cellpadding=5 width="95%"><tr>
<td valign=top>
<pre>










1 <img src="images/arorite2.jpg" width=17 height=10 border=0>
2 <img src="images/arorite2.jpg" width=17 height=10 border=0>



3 <img src="images/arorite2.jpg" width=17 height=10 border=0>

4 <img src="images/arorite2.jpg" width=17 height=10 border=0>





5 <img src="images/arorite2.jpg" width=17 height=10 border=0>
6 <img src="images/arorite2.jpg" width=17 height=10 border=0>
7 <img src="images/arorite2.jpg" width=17 height=10 border=0>





8 <img src="images/arorite2.jpg" width=17 height=10 border=0>

9 <img src="images/arorite2.jpg" width=17 height=10 border=0>
</pre>
</td>

<td valign="top">
<pre>typedef爏truct燺DEVICE_EXTENSION爗
牋...
牋KEVENT爀vKill;
牋PKTHREAD爐hread;
牋};

NTSTATUS燬tartThread(PDEVICE_EXTENSION爌dx)
牋{
牋NTSTATUS爏tatus;
牋HANDLE爃thread;
牋KeInitializeEvent(&amp;pdx-&gt;evKill,燦otificationEvent,燜ALSE);
牋status