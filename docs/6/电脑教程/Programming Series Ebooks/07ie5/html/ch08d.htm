<HTML>
<head>
<link rel="STYLESHEET" type="text/css" href="Progie5.css">
<TITLE>Accessing the DHTML Object Model from Visual C++</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch08c.htm">[Previous]</A> <A HREF="ch08e.htm">[Next]</A><P>

<A NAME="208"><H1>Accessing the DHTML Object Model from Visual C++</H1></A>

<P>As with the Visual Basic example you created earlier, you must perform a few 
preliminary steps before you can access the object model from within Visual C++. It 
doesn't matter whether you are hosting the WebBrowser control or automating 
Internet Explorer in an MFC, an ATL, or a C++ application&#8212;you will access the DHTML Object 
Model the same way&#8212;through the 
<I>document</I> object.</P>

<P>In this section, we'll create an MFC dialog-based application that hosts 
the WebBrowser control. We'll use the MFC wrapper classes for hosting the 
WebBrowser control, so the method call that retrieves the initial 
<I>document</I> object pointer will be slightly different from the way this pointer is retrieved using other development 
libraries.</P>

<P>Go ahead and start Visual C++, create a new MFC AppWizard (exe) 
application, and name it MfcObjMdl. In the Step 1 dialog box, choose Dialog Based. 
Accept the remainder of the project defaults by clicking the 
Finish  button and then clicking the OK<I> 
</I>button in the New  Project Information dialog box. Visual C++ will 
automatically display your project's dialog in design mode so that you can add controls to it.</P>

<P>Next add the WebBrowser control to your project by selecting it from the 
Components And Controls  dialog, which you can access via the Project/Add To 
Project menu. (If you forget how to do this, refer to the section in Chapter 6, &quot;<A HREF="ch06d.htm#165">Using Visual C++</A>&quot;) Add the WebBrowser control to the dialog along with the other controls 
that you will use for navigation, just as you did for the Visual Basic example. The 
dialog should look similar to the one shown in Figure 8-8.</P>

<P>
<A HREF="javascript:fullSize('F08ii08x.htm')"> <img src="images/F08ii08.JPG" width=404 height=279 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 8-8. </B> <I>MfcObjMdl dialog with WebBrowser control and navigation controls. </I><!-- /caption -->
</P>

<P>So that the dialog won't close if the user presses the Enter key, change the 
ID of the Go  button to <I>IDOK</I>. (The default MFC handler function for a button with 
the ID <I>IDOK</I> automatically closes the dialog. We will add code later to override 
this message handler and prevent the dialog from closing when the Enter key is 
pressed.) Use ClassWizard  to associate variables with the WebBrowser control and the edit 
box in the dialog. Name the WebBrowser variable 
<I>m_webBrowser</I> and the edit box variable 
<I>m_strAddress</I>.</P>

<P>Now add the code below to the 
<I>OnInitDialog</I> method for the dialog class to navigate to the user's home page when the application is started.</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>BOOL CMfcObjMdlDlg::OnInitDialog()
{
   <img src="images/grayvellip.JPG" width=3 height=13 border="0">

   m_webBrowser.GoHome();

   <img src="images/grayvellip.JPG" width=3 height=13 border="0">
}
</PRE>
</td></tr></table></p>

<P>Implement the Go  button to navigate to the URL that was entered in the 
edit box. Because the Go button has an ID of 
<I>IDOK</I>, you must name the method 
<I>OnOK</I> so that it will be called when the user presses the 
Enter  key as well as when the user clicks the 
Go  button. Don't call the base class version of this function; if you do, 
the dialog will be closed when the user presses the 
Enter  key.</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>void CMfcObjMdlDlg::OnOK() 
{
   UpdateData();

   if (!m_strAddress.IsEmpty())
   {
      COleVariant vtEmpty;
      m_webBrowser.Navigate(m_strAddress, &amp;vtEmpty, &amp;vtEmpty,
                            &amp;vtEmpty, &amp;vtEmpty);
   }
}
</PRE>
</td></tr></table></p>

<P>Now compile and test the application to make sure it works correctly. 
When you enter a URL and click the Go button, the application will navigate to the 
URL you specified.</P>

<P>Before you can start accessing the DHTML Object Model from this 
application, you must get a pointer to the 
<I>document</I> object. By using the 
<I>document</I> object, you can access the entire contents of the Web page that is loaded into the 
WebBrowser. Create a data member of the dialog class named 
<I>m_pHTMLDocument2</I> of type 
<I>IHTMLDocument2</I>. This interface is the type that represents the document 
being displayed in the WebBrowser. Here's how this declaration should appear in 
the <I>CMfcObjMdlDlg</I> class:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>protected:
   IHTMLDocument2* m_pHTMLDocument2;
</PRE>
</td></tr></table></p>

<P>Initialize this pointer to <I>NULL</I> in the constructor for the 
<I>CMfcObjMdlDlg </I>class. Also, in MfcObjMdlDlg.h, include the mshtml.h file, which contains the definition 
of the <I>IHTMLDocument2</I> interface.</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>#include &lt;mshtml.h&gt;
</PRE>
</td></tr></table></p>


<P><div class="sidebar"><blockquote><B>Using the Latest Technology</B>
<P>Remember to download the latest Internet Explorer 5 headers and libraries 
from the MSDN Online Web Workshop. Download and install the headers and 
libraries for Windows 2000 even if you aren't developing for this platform. Some 
of the headers and libraries that you'll need have been updated and reside in 
the Windows NT 5 directories that are created when you install them from the 
MSDN Online Web Workshop. You must place the headers and libraries in the 
correct order as specified in <A HREF="ch06a.htm">Chapter 6</A>.</P>

<P>Also note that Internet Explorer 5 has a new interface 
named <I>IHTMLDocument3</I>, which provides some functionality that the 
<I>IHTMLDocument2 </I>interface doesn't provide. Unfortunately, 
<I>IHTMLDocument3 </I>doesn't inherit from the <I>IHTMLDocument2 
</I>interface, so you must use two separate pointers to 
access the methods of both interfaces.</P></blockquote></div>
</P>

<P>Just as you did when you accessed the DHTML Object Model from within 
Visual Basic, you must wait until the WebBrowser's 
<I>DocumentComplete</I> event has fired before you access the 
<I>document</I> object. Implementing events when hosting 
the WebBrowser control in an MFC dialog_based application is easy. To implement 
the <I>DocumentComplete </I>event, open ClassWizard, and select the ID of the 
WebBrowser control from the Object IDs  list box on the Message 
Maps  tab, shown in Figure 8-9. If you haven't changed the default ID of the WebBrowser control, the ID will 
be <I>IDC_EXPLORER1</I>.</P>

<P>
<A HREF="javascript:fullSize('F08ii09x.htm')"> <img src="images/F08ii09.JPG" width=404 height=290 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 8-9. </B> <I>MFC ClassWizard displaying the Message Maps tab with the ID of the WebBrowser control and the </I>DocumentComplete<I> event selected. </I><!-- /caption -->
</P>

<P>Next select DocumentComplete from the Messages list box, which is on the 
right side of the dialog box. Click the Add 
Function  button to create the event handler. 
The default name that ClassWizard specifies is 
<I>OnDocumentCompleteExplorer1</I>, but I think that name is rather long. I usually change it to 
<I>OnDocumentComplete</I>. You can change it if you like, or leave it as is. After you specify a name for this event handler, 
click the OK  button. Click the Edit Code button to begin editing the code for this 
handler method.</p>

<P>In the <I>DocumentComplete</I> event's handler method, you're going to retrieve 
and store the pointer to the document. As in the Visual Basic example you created, 
you use the <I>Document</I> property to obtain this pointer. The MFC class that was created 
to wrap the WebBrowser control provides a method named 
<I>GetDocument</I> that makes retrieving the 
<I>Document</I> property easy. But unlike what you can do in Visual 
Basic, you can't call methods of the 
<I>document</I> object directly by using this returned 
pointer. The pointer that is returned from the 
<I>Document</I> property  in Visual C++ 
applications is actually the pointer to the 
<I>IDispatch</I> interface of the document. You must 
query for the document interface, 
<I>IHTMLDocument2</I>, before you can directly access 
the methods and properties of the <I>document</I> object. The code that follows shows 
how the code for the <I>OnDocumentComplete</I> method should look.</p>



<p>
<div class="note"><blockquote><b>NOTE</b><hr>
If you are hosting the WebBrowser control by using ATL or 
standard C++, or if you are automating Internet Explorer, you can obtain a pointer to 
the <I>IDispatch </I>of the document by calling 
<I>IWebBrowser2</I>'s <I>get_Document </I>method.
</blockquote></div>
</p>

<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>void CMfcObjMdlDlg::OnDocumentComplete(LPDISPATCH pDisp, VARIANT FAR* URL) 
{
   LPDISPATCH lpDispatch;
   lpDispatch = m_webBrowser.GetDocument();

   if (lpDispatch)
   {
      HRESULT hr = lpDispatch-&gt;QueryInterface(IID_IHTMLDocument2,
                                              (LPVOID*)&amp;m_pHTMLDocument2);
      lpDispatch-&gt;Release();
      ASSERT(SUCCEEDED(hr));
   }
}
</PRE>
</td></tr></table></p>

<P>Each time you navigate to a new Web page, you should release the 
document pointer and set it to <I>NULL</I>. That way, you can check 
<I>m_pHTMLDocument2</I> to see whether the document has finished loading before you try to use the 
document pointer. If this pointer is <I>NULL</I>, the document hasn't finished loading. If this 
pointer isn't <I>NULL</I>, you should release the pointer and set it to 
<I>NULL</I> in an event handler for the WebBrowser's 
<I>BeforeNavigate2 </I>event. Use ClassWizard like you did before 
to create this event handler. Name this handler method 
<I>OnBeforeNavigate2. </I>Then in this method, release the interface pointer and set it to 
<I>NULL</I>:</P>

<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>void CMfcObjMdlDlg::OnBeforeNavigate2(LPDISPATCH pDisp, 
                                      VARIANT FAR* URL,
                                      VARIANT FAR* Flags,
                                      VARIANT FAR* TargetFrameName,
                                      VARIANT FAR* PostData,
                                      VARIANT FAR* Headers,
                                      BOOL FAR* Cancel) 
{
   if (m_pHTMLDocument2)   
   {
      m_pHTMLDocument2-&gt;Release();
      m_pHTMLDocument2 = NULL;
   }
}
</PRE>
</td></tr></table></p>

<P>You should also release this pointer when your application is closed. The 
best place to do this is in the destructor for the 
<I>CMfcObjMdlDlg</I> class. Create the destructor, and release the interface pointer if it isn't 
<I>NULL</I>:</P>

<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>CMfcObjMdlDlg::~CMfcObjMdlDlg()
{
   if (m_pHTMLDocument2)
      m_pHTMLDocument2-&gt;Release();
}
</PRE>
</td></tr></table></p>

<P>Now that you have a pointer to the 
<I>document</I> object, you're ready to access the data contained in the document and then change it.</P>

<A NAME="209"><H2>Obtaining Data from a Web Page</H2></A>

<P>To see how to retrieve data from the document, let's add the same functionality 
to MfcObjMdl that we added to the VbObjMdl example. First add a button that will 
be used to retrieve the inner HTML of the body of the document. Give this button 
an ID of <I>IDC_GET_BODY</I>, and change the caption of the button to 
<I>Get Body</I>. (You might have to resize the WebBrowser control to make room for this and other controls 
that you're going to add to the dialog.)</P>

<P>Implement a <I>BN_CLICKED</I> message handler for the Get Body button in the 
same way you would for any other button in MFC&#8212;by using ClassWizard. Accept the 
default name of <I>OnGetBody </I>for this handler method. In the 
<I>OnGetBody </I>method, you must first obtain a pointer to the 
<I>body</I> object and then retrieve its 
<I>innerHTML</I> property, which returns the inner HTML of the body. Then you can display the inner HTML 
in a message box. The code to implement the message handler is below.</P>

<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>void CMfcObjMdlDlg::OnGetBody() 
{
   if (!m_pHTMLDocument2)
      return;

   // Get the body element.
   //
   IHTMLElement* pBody;
   HRESULT hr = m_pHTMLDocument2-&gt;get_body(&amp;pBody);

   ASSERT(SUCCEEDED(hr));

   // Get the inner HTML.
   //
   BSTR bstrHTML;
   pBody-&gt;get_innerHTML(&amp;bstrHTML);
   pBody-&gt;Release();

   USES_CONVERSION;
   MessageBox(OLE2T(bstrHTML), _T(&quot;MfcObjMdl&quot;));   

   SysFreeString(bstrHTML);
}
</PRE>
</td></tr></table></p>

<P>In this code, we first retrieve a pointer to the body by using the 
<I>get_body</I> method of <I>IHTMLDocument2</I>. When 
<I>get_body</I> is called, the address of an 
<I>IHTMLElement </I>pointer is passed to the <I>get_body 
</I>method. You're probably wondering why the 
address of an <I>IHTMLBodyElement </I>pointer isn't passed to the 
<I>get_body </I>method. Although the 
<I>IHTMLBodyElement</I> interface does represent the body of the document, it 
doesn't inherit from <I>IHTMLElement</I>.  The 
<I>get_body</I> method returns a pointer to the 
<I>IHTMLElement </I>interface, so an 
<I>IHTMLBodyElement</I> pointer can't be passed. It just 
won't compile. If you need to use functionality that is specific to the body, you can 
query the interface returned from <I>get_body</I> for the 
<I>IHTMLElement</I> pointer like so:</P>

<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>IHTMLBodyElement* pBodyElem;
HRESULT hr = pBody-&gt;QueryInterface(IID_IHTMLBodyElement, 
                                   (LPVOID*)&amp;pBodyElem);
</PRE>
</td></tr></table></p>

<P>After obtaining a pointer to the body of the document, we call the 
<I>get_
innerHTML</I> method to retrieve the inner HTML of the body of the 
document. The <I>get_innerHTML</I> method returns a 
<I>BSTR</I> that contains the inner HTML. Next we use the 
<I>MessageBox </I>function to display the inner HTML. You can use the 
OLE2T macro to convert the <I>BSTR</I> to an 
<I>ANSI</I> character string. To use the OLE2T 
macro, you must include the afxconv.h file in the 
MfcObjMdlDlg.cpp  file and include the 
USES_CONVERSION  macro in the 
<I>OnGetBody</I> method. Finally, we release the 
<I>BSTR </I>by calling the <I>SysFreeString </I>Win32 API function.</P>

<P>That wasn't too hard, was it? Now you can implement the Get All HTML 
button that displays all the HTML for the document. Add this button to the dialog, and 
give it an ID of <I>IDC_GET_ALL_HTML</I>. Use 
ClassWizard  to create a <I>BN_CLICKED</I> 
message handler named <I>OnGetAllHTML</I>. Add code to this message handler method to 
obtain a pointer to the document element. You can then retrieve and display the entire 
HTML for the document by using the 
<I>outerHTML</I> property. Here's the code to 
implement the <I>OnGetAllHTML</I> message handler method:</P>

<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>void CMfcObjMdlDlg::OnGetAllHtml() 
{
   if (!m_pHTMLDocument2)
      return;
    
   IHTMLDocument3* pHTMLDoc3;
   HRESULT hr = m_pHTMLDocument2-&gt;QueryInterface(IID_IHTMLDocument3,
                                                 (LPVOID*)&amp;pHTMLDoc3);
   ASSERT(SUCCEEDED(hr));
   
   // Get the document element.
   //
   IHTMLElement* pDocElem;

   hr = pHTMLDoc3-&gt;get_documentElement(&amp;pDocElem);
   pHTMLDoc3-&gt;Release();

   ASSERT(SUCCEEDED(hr));

   // Get the outer HTML.
   //
   BSTR bstrHTML;

   pDocElem-&gt;get_outerHTML(&amp;bstrHTML);
   pDocElem-&gt;Release();

   USES_CONVERSION;
   MessageBox(OLE2T(bstrHTML), _T(&quot;MfcObjMdl&quot;));   
 
   SysFreeString(bstrHTML);
}
</PRE>
</td></tr></table></p>

<P>As in the Visual Basic sample, you use the 
<I>documentElement</I> property to retrieve a pointer to the document element. Because this property is a member of the 
new Internet Explorer 5 <I>IHTMLDocument3 </I>interface, you must query the document 
for this interface before you can obtain a pointer to the document element. In the 
preceding code, we call the 
<I>get_documentElement</I> method to obtain a pointer to the 
document element. The <I>get_documentElement</I> method returns a pointer to 
an <I>IHTMLElement</I> in the same way that the 
<I>get_body</I> method did. You can use the pointer you have 
just retrieved to call <I>get_outerHTML</I> to retrieve the HTML for the entire page. Then 
you can display the entire HTML by using the <I>MessageBox 
</I>function.</P>
<P>Now it's time to compile and test your application. Navigate to a Web page, 
and click the Get All HTML button. A message box will be displayed that contains 
the entire HTML for the page.</P>

<p>Now that you know how to retrieve the HTML of the page in a Visual 
C++ application, go ahead and add the functionality to retrieve form data from 
your application. Before adding new controls to the dialog, copy the 
MfcObjMdl.htm  file from the companion CD in the folder \Samples\Chap08\MfcObjMdl and place it 
in your application directory. Then change the initial navigation in the 
<I>OnInitDialog </I>method to navigate to this page instead of to the user's home page.</P>

<P>Here's the code to navigate to the 
MfcObjMdl.htm  file in the current 
directory. This code obtains the name of the current directory by using the 
<I>GetCurrentDirectory</I> Win32 API function.</P>

<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>BOOL CMfcObjMdlDlg::OnInitDialog()
{
   <img src="images/grayvellip.JPG" width=3 height=13 border="0">
   <img src="images/grayvellip.JPG" width=3 height=13 border="0">
   // Get the length of the buffer for the current directory.
   //
   DWORD dwLen;
   dwLen = ::GetCurrentDirectory(0, NULL);

   // Create a new string, and get the current directory.
   //
   char* pszCurDir;
   pszCurDir = new char[dwLen + 1];
   ::GetCurrentDirectory(dwLen, szCurDir);

   // Format the string to add the HTML file to the end.
   //
   CString strURL;
   strURL.Format(&quot;%s\\MfcObjMdl.htm\n&quot;, pszCurDir);
   delete pszCurDir;

   // Navigate to MfcObjMdl.htm.
   //
   COleVariant vtEmpty;
   m_webBrowser.Navigate(strURL, &amp;vtEmpty, &amp;vtEmpty, &amp;vtEmpty, &amp;vtEmpty);

   return TRUE;  // Return TRUE unless you set the focus to a     
                 // control.
}
</PRE>
</td></tr></table></p>

<P>Now add a list box and button to the dialog. Use ClassWizard to create a 
data member for the list box control named 
<I>m_lstFormData</I> of type <I>CListBox</I>. Also, on 
the  Styles tab in the Properties dialog for the control, uncheck the Sort Property 
check box. Name the button 
<I>IDC_GET_FORM_DATA</I>, and change its caption to 
<I>Get Form Data</I>.</P>

<p>Compile your application again, and run it to make sure that it loads the 
MfcObjMdl.htm file. At this point, it should look similar to the application in Figure 8-10.</P>

<P>
<A HREF="javascript:fullSize('F08ii10x.htm')"> <img src="images/F08ii10.JPG" width=404 height=293 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 8-10.</B> <I>MfcObjMdl dialog after adding list box and Get Form Data button.</I><!-- /caption -->
</p>

<P>Next use ClassWizard to create a <I>BN_CLICKED 
</I>message handler for the Get Form Data button. Accept the default name of 
<I>OnGetFormData</I> for this message handler. In this message handler, use the 
<I>all </I>collection of the form to retrieve the data the 
user entered into the form (just as you did in the Visual Basic example). The 
following code implements this functionality. The 
<I>OnGetFormData</I> method shown in the code is quite long, so I broke it into steps. Each step is indicated by a comment in the 
code, and I'll explain each of these in turn. You can find the code on the companion 
CD in the folder \Samples\Chap08\MfcObjMdl.</P>

<p>
<table cellpadding=5 width="95%"><tr><td>
<pre>void CMfcObjMdlDlg::OnGetFormData() 
{
   // 1) Get a pointer to the forms collection.
   //
   IHTMLElementCollection* pElemColl;
   HRESULT hr = m_pHTMLDocument2-&gt;get_forms(&amp;pElemColl);
    
   if (FAILED(hr))
      return;

   // 2) Get the first form in the collection.
   //
   LPDISPATCH lpDispatch = NULL;
   COleVariant vtEmpty;
   COleVariant vtIdx(0L, VT_I4);

   hr = pElemColl-&gt;item(vtIdx, vtEmpty, &amp;lpDispatch);
   pElemColl-&gt;Release();

   if (FAILED(hr) || !lpDispatch)
         return;

   // 3) Get a pointer to the form itself _ IHTMLFormElement.
   // This pointer is actually a collection of all the 
   // input elements in the form.
   //
   IHTMLFormElement* pFormElem;

   hr = lpDispatch-&gt;QueryInterface(IID_IHTMLFormElement,
                                   (LPVOID*)&amp;pFormElem);
   lpDispatch-&gt;Release();

   if (FAILED(hr))
      return;

   // 4) Get and store the number of elements
   // in the form.
   //
   long lLen = 0;
   pFormElem-&gt;get_length(&amp;lLen);

   // 5) Loop through all the elements in the collection
   // and retrieve the data entered by the user.
   //
   IHTMLElement* pElem;
   IHTMLInputElement* pInpElem;
   BSTR bstrData;
   CString strFormData;

   USES_CONVERSION;

   m_lstFormData.ResetContent();

   for (long i = 0; i &lt; lLen; i++)
   {
      // 6) Retrieve an item from the collection.
      //
      vtIdx = i;
      lpDispatch = NULL;
      hr = pFormElem-&gt;item(vtIdx, vtEmpty, &amp;lpDispatch);

      if (FAILED(hr) || !lpDispatch)
         break;

      // 7) Query for IHTMLElement.
      //
      hr = lpDispatch&gt;QueryInterface(IID_IHTMLElement,
                                     (LPVOID*)&amp;pElem);
      lpDispatch-&gt;Release();

      if (FAILED(hr))
         break;

      // 8) Get the ID of the element.
      //
      pElem-&gt;get_id(&amp;bstrData);

      strFormData = CString(&quot;ID: &quot;) + CString(bstrData) + CString(&quot;, &quot;);
      SysFreeString(bstrData);

      // 9) Query for IHTMLInputElement.
      //
      hr = pElem-&gt;QueryInterface(IID_IHTMLInputElement,
                                 (LPVOID*)&amp;pInpElem);
      pElem-&gt;Release();

      if (SUCCEEDED(hr))
      {
         // 10) Get the type of the input element.
         //
         pInpElem-&gt;get_type(&amp;bstrData);

         // If the type of the input element is checkbox
         // or radio button, retrieve the value of the 
         // checked property. Otherwise, retrieve the
         // value of the input element.
         //
         if ( !_stricmp(OLE2T(bstrData), _T(&quot;checkbox&quot;)) 
           || !_stricmp(OLE2T(bstrData), _T(&quot;radio&quot;)))
         {
            // 11) Determine whether the checkbox or radio
            // button is checked.
            //
            VARIANT_BOOL vboolChecked;
            pInpElem-&gt;get_checked(&amp;vboolChecked);

            if (vboolChecked == VARIANT_TRUE)
               strFormData += &quot;Checked: True&quot;;
            else
               strFormData += &quot;Checked: False&quot;;
         }
         else
         {
            // 12) Get the value and add it to the string.
            //
            SysFreeString(bstrData);

            pInpElem-&gt;get_value(&amp;bstrData);
            strFormData += CString(&quot;Value: &quot;) + bstrData;
         }

         SysFreeString(bstrData);
         pInpElem-&gt;Release();
      }

      m_lstFormData.AddString(strFormData);
   }

   pFormElem-&gt;Release();

   UpdateData(FALSE);
}
</pre>
</td></tr>
</table>
</p>

<P>Here's how to work your way through the code. The following numbers 
correspond to the numbers in the code comments:</P>

<OL>

<P><LI>Get a pointer to the 
<I>forms</I> collection by calling the 
<I>get_forms</I> method of the <I>document</I> object.</LI></P>

<P><LI>Because at most one form exists on this Web page, the first form in 
the collection will be the form we need. If no forms exist on the page, the 
<I>item</I> method will return <I>S_OK</I>, but the pointer returned from the 
<I>lpDispatch</I> parameter will be <I>NULL</I>. That's why this 
<I>OnGetFormData</I> method checks 
<I>lpDispatch</I> and returns  if 
<I>lpDispatch</I> is <I>NULL</I>.</LI></P>

<P><LI>Get a pointer to the form as represented by the 
<I>IHTMLFormElement </I>interface. To obtain this interface pointer, simply query 
<I>lpDispatch</I>. The returned interface pointer is actually a pointer to a collection of all the 
input elements on the page.</LI></P>

<P><LI>Get the number of elements in the collection by calling the 
<I>get_length </I>method.</LI></P>

<P><LI>Loop through all the elements in the collection, and retrieve the 
data entered by the user. In this loop, the ID of the element is retrieved. Also, 
if the type of the element is <I>checkbox </I>or 
<I>radio</I>, the state of the checkbox or radio button is retrieved. If the input element is something other than 
a checkbox or radio button, the value of the input element is retrieved.</LI></P>

<P><LI>Retrieve an item from the collection of input elements by using the 
<I>form</I> object's <I>item </I>method.</LI></P>

<P><LI>To retrieve the ID of the element, you must first have a pointer to 
an <I>IHTMLElement</I> because the <I>get_id</I> method that returns the ID of the 
element is a member of this interface. Therefore, query 
<I>lpDispatch </I>for this interface. Store the returned pointer in a local variable named 
<I>pElem</I>.</LI></P>

<P><LI>Call <I>get_id</I> to get the ID of the element. Add this ID to 
<I>strFormData</I>,  which is  the string that will be added to the list box.</LI></P>

<P><LI>Query <I>pElem </I>for 
<I>IHTMLInputElement,</I> because the 
<I>get_type</I>, <I>get_checked</I>, and <I>get_value 
</I>methods are members of the 
<I>IHTMLInputElement</I> interface that will be called in the remainder of this code.</LI></P>

<P><LI>Get the type of the input element by calling 
<I>get_type</I>. This type will be used to determine which text to add to 
<I>strFormData</I>. If the type of the input element is 
<I>checkbox </I>or <I>radio</I>, a string is added to 
<I>strFormData</I>, indicating whether the checkbox or radio button is checked. If the type of 
the input element isn't <I>checkbox </I>or 
<I>radio</I>, the value of the input element is added to 
<I>strFormData</I>.</LI></P>

<P><LI>If the type of the input element is 
<I>checkbox</I> or <I>radio</I>, use the <I>get_checked</I> method to determine the state of the checkbox or radio 
button. This method returns <I>VARIANT_TRUE</I> if either of these are checked 
or <I>VARIANT_FALSE</I> otherwise. If the checkbox or radio button is 
checked, add<I> &quot;Checked: True&quot;</I> to 
<I>strFormData</I> and <I>&quot;Checked: False&quot;</I> otherwise.</LI></P>

<P><LI>If the type of input element is something other than 
<I>checkbox</I> or <I>radio</I>, get the value of the input element by calling 
<I>get_value</I> and add this value to 
<I>strFormData</I>.</LI></P>

</OL>

<A NAME="210"><H2>Dynamically Inserting Data into a Web Page Using VC++</H2></A>

<P>Now that you've worked so hard to implement the 
<I>OnGetFormData</I> method, dynamically changing the data on a Web page will be easy. Following our 
original Visual Basic example, add a button that will allow you to enter HTML text to 
be appended to the Web page. Name this button 
<I>IDC_ADD_HTML</I>,  and change its caption to 
<I>Add HTML</I>. When the user clicks the Add HTML button, a dialog for 
entering HTML or text will be displayed. When the user clicks the OK button in this 
dialog, the HTML or text that was entered will be added to the Web page.</p>
<p>Before you implement the <I>BN_CLICKED </I>message handler for the Add 
HTML button, you must create the dialog that will allow users to enter HTML or text. 
Create a new dialog resource in Visual C++ that contains a multiline edit box and an 
OK button. Then set the Want Return  style in the Properties dialog for the edit box 
so that when the user presses the Enter key while typing text into the edit box, a 
carriage return will be inserted. And change the title of the dialog to 
<I>Add HTML</I>. The new dialog should look similar to the one shown in Figure 8-11.</p>

<P>
<A HREF="javascript:fullSize('F08ii11x.htm')"> <img src="images/F08ii11.JPG" width=404 height=279 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 8-11.</B> <I>Add HTML dialog.</I><!-- /caption -->
</P>

<P>Now use ClassWizard  to create a new dialog class for this dialog, and name 
this class <I>CHtmlDlg</I>. Also use ClassWizard to associate a 
<I>CString</I> variable with the edit box. Name this variable 
<I>m_strHTML</I>.</P>

<P>Now go back to the MfcObjMdl dialog, and use ClassWizard to implement 
a message handler for the <I>BN_CLICKED </I>message of the Add HTML button. Name 
this method <I>OnAddHtml</I>. In this method, create a new instance of the Add HTML 
dialog class, and then call its <I>DoModal</I> method to display it as a modal dialog. 
(Remember to include the header file for this dialog.) When the 
<I>DoModal</I> method returns, if the user entered HTML into the edit box and clicked the OK button, add the HTML 
to the end of the Web page by using the 
<I>insertAdjacentHTML</I> method. Here's the code to implement the 
<I>OnAddHtml</I> method:</p>

<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>void CMfcObjMdlDlg::OnAddHtml() 
{
   CHtmlDlg dlgHTML;
   
   if (dlgHTML.DoModal() == IDOK)
   {
      if (!dlgHTML.m_strHTML.IsEmpty())
      {
         // Get the body element from the document.
         //
         IHTMLElement* pBody;
         HRESULT hr = m_pHTMLDocument2-&gt;get_body(&amp;pBody);

         if (FAILED(hr))
            return;

         // Insert the HTML entered at the end of
         // the Web page.
         //
         pBody-&gt;insertAdjacentHTML(L&quot;BeforeEnd&quot;,
                                   dlgHTML.m_strHTML.AllocSysString());
         pBody-&gt;Release();
      }
   }
}
</PRE>
</td></tr></table></p>

<P>This code should look familiar to you because you have seen most of it in 
the section on obtaining data from a Web page. After the user clicks the OK button, 
if HTML or text was entered we retrieve the body element from the 
<I>document </I>object using the <I>get_body</I> method. Then we call the 
<I>insertAdjacentHTML</I> method to insert the HTML right before the end of the body of the document.</p>

<P>Now compile and test your application. Invoke the Add HTML dialog, and 
enter some HTML or text. When you click the OK button, the HTML or text you 
entered will be added to the end of the Web page.</p>

<P>Hang in there, we're almost finished! To completely implement this 
example, you just need to add the controls and code so that you can change the contents 
of the textbox element on the MfcObjMdl.htm<I> 
</I>Web page. Add a new edit box and button to the dialog. The dialog should look similar to the one shown in Figure 8-12. 
Use ClassWizard to associate a <I>CString </I>variable with the edit box, and name this 
variable <I>m_strNewText. </I>Also give the button an ID of 
<I>IDC_CHANGE_TEXT1</I>, and change its caption to 
<I>Change Text1</I>.</p>

<P>
<A HREF="javascript:fullSize('F08ii12x.htm')"> <img src="images/F08ii12.JPG" width=404 height=279 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 8-12.</B> <I>MfcObjMdl dialog after adding the edit box and Change Text1 button.</I><!-- /caption -->
</P>

<P>Next use ClassWizard to create a <I>BN_CLICKED 
</I>message handler for the Change Text1 button. Name this handler method 
<I>OnChangeText1</I>. In this method, you will simply change the value of the Web page textbox that has the ID 
<I>Text1. </I>Here's the code to implement the <I>OnChangeText1 
</I>method. The code can also be found on the companion CD in the folder \Samples\Chap08\MfcObjMdl.</p>

<P><table cellpadding=5 WIDTH="95%"><TR><TD>
<PRE>void CMfcObjMdlDlg::OnChangeText1() 
{
   UpdateData();

   if (m_strNewText.IsEmpty())
      return;

   // 1) Get a pointer to the forms collection.
   //
   IHTMLElementCollection* pElemColl;
   HRESULT hr = m_pHTMLDocument2-&gt;get_forms(&amp;pElemColl);
    
   if (FAILED(hr))
      return;

   // 2) Get the first form in the collection.
   //
   LPDISPATCH lpDispatch = NULL;
   COleVariant vtEmpty;
   COleVariant vtIdx(0L, VT_I4);

   hr = pElemColl-&gt;item(vtIdx, vtEmpty, &amp;lpDispatch);
   pElemColl-&gt;Release();

   if (FAILED(hr) || !lpDispatch)
      return;

   // 3) Get a pointer to the form&#8212;IHTMLFormElement.
   // This pointer is actually a pointer to a collection of all the 
   // input elements on the form.
   //
   IHTMLFormElement* pFormElem;

   hr = lpDispatch-&gt;QueryInterface(IID_IHTMLFormElement,
                                   (LPVOID*)&amp;pFormElem);
   lpDispatch-&gt;Release();

   if (FAILED(hr))
      return;

   // 4) Retrieve an item from the collection.
   //
   COleVariant vtName(_T(&quot;Text1&quot;));

   lpDispatch = NULL;

   hr = pFormElem-&gt;item(vtName, vtEmpty, &amp;lpDispatch);
   pFormElem-&gt;Release();

   if (FAILED(hr) || !lpDispatch)
      return;

   // 5) Query for the IHTMLInputElement so that
   // its value can be changed.
   //
   IHTMLInputElement* pInpElem;

   hr = lpDispatch-&gt;QueryInterface(IID_IHTMLInputElement,
                                   (LPVOID*)&amp;pInpElem);
   lpDispatch-&gt;Release();


   if (FAILED(hr))
      return;

   // 6) Set the value of the textbox
   // to the text entered into the edit box.
   //
   pInpElem-&gt;put_value(m_strNewText.AllocSysString());
   pInpElem-&gt;Release();
}
</PRE>
</td></tr></table></p>

<P>You've already seen most of this code, so I'll explain only the step that is 
different&#8212;step 6. In this step, we call the 
<I>put_value</I> method of the input element 
object to change the contents of the textbox on the Web page to what was entered into 
the edit box on the MfcObjMdl dialog.</p>

<P>Now compile and test your application. Change the text in the text box on 
the Web page to make sure that it works. That wasn't too painful, was it? By now, 
you can see the power of the DHTML Object Model. But wait, there's more! In 
<A HREF="ch07a.htm">Chapter 7</A>, you learned how to sink events when you are hosting the WebBrowser control 
or automating Internet Explorer. The objects in the DHTML Object Model also fire 
events, and you can write event handlers for them in your applications. That's the topic 
of the next section.</p>

</BODY>
</HTML>






