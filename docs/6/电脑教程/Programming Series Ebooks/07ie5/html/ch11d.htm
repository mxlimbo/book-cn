<HTML>
<head>
<link rel="STYLESHEET" type="text/css" href="Progie5.css">
<TITLE>Using Binary DHTML Behaviors</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch11c.htm">[Previous]</A> <A HREF="ch11e.htm">[Next]</A><P>

<A NAME="269"><H1>Using Binary DHTML Behaviors</H1></A>

<P>
As you'll see in this section, Binary DHTML Behaviors don't suffer from the 
restrictions that HTCs do. Binary DHTML Behaviors are just normal COM objects that 
you can create based on C++ libraries such as ATL or MFC. (You can also create 
Binary DHTML Behaviors using standard C++.) Using Binary DHTML Behaviors is just as 
easy as using Behaviors implemented as HTCs, except that one extra step is 
required. Because a Binary DHTML Behavior is a binary component, you must insert it into 
a Web page by using the &lt;OBJECT&gt; tag, as shown in the following code. (This 
code comes from a Binary Behavior example named AtlBehave that we'll discuss in 
more detail later in this section.)
</P>

<P>
<table cellpadding=5 width="95%"><TR><TD>
<PRE>
&lt;OBJECT
   ID=behave1
   CLASSID=&quot;clsid:140D550D-2290-11D2-AF61-00A0C9C9E6C5&quot;
   CODEBASE=&quot;atlbehave.cab&quot;&gt;
&lt;/OBJECT&gt;
</PRE>
</td></tr></table></p>

<P>The format of the &lt;OBJECT&gt; tag for inserting a Binary DHTML 
Behavior is exactly the same as its format for inserting an ActiveX control and other 
COM objects. And because you are required to use the &lt;OBJECT&gt; tag to insert 
Binary DHTML Behaviors into a Web page, the security mechanism that Internet 
Explorer applies to the Binary DHTML Behavior is the same as the mechanism that it 
applies to ActiveX controls and other COM objects. If the Binary DHTML Behavior isn't 
safe for scripting, initialization, or both, Internet Explorer will display the same 
security dialog box you've seen in <a href="ch05a.htm">Chapters 5</a> and <a href="ch06a.htm">6</a>.
</P>

<P>
As you know, when inserting an ActiveX control or COM object into a Web 
page by using the &lt;OBJECT&gt; tag, you can use the ID attribute to specify an 
identification marker for that object. When specifying the name of the Behavior for the CSS 
behavior attribute of the STYLE attribute, instead of specifying the filename for the 
Behavior, you use the ID that you specified for the &lt;OBJECT&gt; tag, as shown here:
</P>

<P>
<table cellpadding=5 width="95%"><TR><TD>
<PRE>
&lt;SPAN ID=target STYLE=&quot;behavior:url(#behave1); font-size:xx-large&quot;&gt;
   This text has an attached Behavior. 
   Move the cursor here to see the effect.
&lt;/SPAN&gt;
</PRE>
</td></tr></table></p>

<P>Notice that besides specifying the ID of the Binary Behavior, you must 
also specify the pound sign (#). The pound sign tells Internet Explorer that the ID is 
for the Binary Behavior on the current page and is not the name of a file that 
contains the implementation of an HTC Behavior. (Note that you shouldn't give your 
Binary DHTML Behavior an ID of <I>default</I>. If you do, the ID will conflict with the ID of the default DHTML Behaviors.)
</P>

<P>
To demonstrate how to implement Binary DHTML Behaviors and how to 
sink events for HTML elements from a Binary DHTML Behavior, let's look at 
AtlBehave, a  Binary Behavior example created using ATL. The 
AtlBehave<I> </I>example, which is shown in Figure 11-4, can be found on the companion CD in the folder \Samples\Chap11\AtlBehave.</p>

<p>
<A HREF="javascript:fullSize('F11ii04x.htm')"> <img src="images/F11ii04.JPG" width=404 height=303 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><B>Figure 11-4.</B> <i>AtlBehave.</i><!-- /caption -->
</p>

<p>Before compiling the AtlBehave example, you must install headers and 
libraries for Internet Explorer 5 and place the headers and libraries in the correct order 
as specified in <A HREF="ch06a.htm">Chapter 6</A>.</p>

<A NAME="270"><H2>Implementing Binary DHTML Behaviors in C++</H2></A>

<P>As with any other COM object, you must implement some interfaces for Binary 
Behaviors, and the container must implement some other interfaces. The required 
and optional interfaces implemented by a Binary DHTML Behavior and those that 
are implemented by the container are listed in Table 11-5.
</P>

<P><b>Table 11-5.</b> <i>Interfaces Implemented by the Binary 
DHTML Behavior and the Container</i></p>

<table cellpadding=5 width="95%">
<tr><th valign="top"><i>Interface</i></th>     
<th valign="top"><i>Description</i></th>     
<th valign="top"><i>Where Implemented</i></th></tr>
     

<tr><td valign="top"><I>IElementBehavior</I></td>     
<td valign="top">Receives notifications from the container (MSHTML) concerning the activities of DHTML Behaviors. This interface is an event sink, and it's required.</td>      <td valign="top">Behavior</td></tr>      

<tr><td valign="top"><I>IElementBehaviorCategory</I></td>     
<td valign="top">Provides Behaviors with a way to identify their categories. Using categories, you can locate all related Behaviors. This interface is optional.</td>     <td valign="top">Behavior</td></tr>
 
<tr><td valign="top"><I>IElementBehaviorFactory</I></td>     
<td valign="top">Provides the container (MSHTML) with implementations of Behaviors. This interface is the class factory for a Behavior, and it's required.</td>
<td valign="top">Behavior</td></tr>
   
<tr><td valign="top"><I>IElementBehaviorSite</I></td>     
<td valign="top">Provides a means of communication between a Behavior and the container (MSHTML). This is the site interface for the Behavior. This interface is required.</td>   
<td valign="top">Container</td></tr>
  
<tr><td valign="top"><I>IElementBehaviorSiteCategory</I></td>     
<td valign="top">Provides Behaviors a means of finding related Behaviors. This interface is optional.</td><td valign="top">Container</td></tr>

<tr><td valign="top"><I>IElementBehaviorSiteOM</I></td>     
<td valign="top">Provides event services to Behaviors. These event services allow Behaviors 
to create events, fire events, and so on. This interface is required if the container wants to provide event services.</td>
<td valign="top">Container</td></tr>
</table>
     
<p>Although all the interfaces listed in Table 11-5 are important, we'll look at 
only those interfaces that you'll normally use when creating Binary Behaviors. We'll 
discuss <I>IElementBehaviorFactory</I> and 
<I>IElementBehavior</I> first. <I>IElementBehaviorSite 
</I>and<I> IElementBehaviorSiteOM</I> will be covered when we talk about 
<I>IElementBehavior</I>'s<I> Init </I>method.</p>

<A NAME="271"><H3><I>IElementBehaviorFactory</I></H3></A>
<P>Probably the most important Behavior interface is 
<I>IElementBehaviorFactory</I>. Through this interface, the container (MSHTML, in the case of Internet 
Explorer) creates an instance of a Behavior. Then the container obtains a pointer to 
the Behavior's <I>IElementBehavior</I> interface with which the container will 
communicate. The <I>IElementBehaviorFactory</I> interface has one method that is used for creating 
the Binary DHTML Behavior and obtaining a pointer to the Behavior's 
<I>IElementBehavior</I> interface: 
<I>FindBehavior</I>. The following code from the AtlBehave example shows 
an implementation of the <I>FindBehavior</I> method. Table 11-6 shows 
the four parameters of the <I>FindBehavior </I>method.
</P>

<P>
<table cellpadding=5 width="95%"><TR><TD>
<PRE>
STDMETHODIMP
CFactory::FindBehavior(BSTR pchNameSpace, 
                       BSTR pchTagName,
                       IElementBehaviorSite* pUnkArg,
                       IElementBehavior** ppBehavior)
{
   HRESULT hr;
   CComObject&lt;CBehavior&gt;* pBehavior;

   // Create a Behavior object.
   hr = CComObject&lt;CBehavior&gt;::CreateInstance( &amp;pBehavior );

   if (SUCCEEDED(hr))
   {
      hr = pBehavior-&gt;QueryInterface(__uuidof(IElementBehavior),
                                     (void**)ppBehavior );
   }

   return hr;
}
</PRE>
</td></tr></table></p>


<P>The implementation of the <I>FindBehavior</I> method as shown in the preceding code is typical of any class factory creation technique. First an instance of the <I>CBehavior </I>class is created by using the <I>CreateInstance</I> method. In this example, <I>CBehavior</I> is the class that implements the <I>IElementBehavior </I>interface. Then <I>QueryInterface</I> is called to obtain a pointer to the <I>IElementBehavior</I> interface that is implemented in the <I>CBehavior</I> class. This pointer is returned to the container via the <I>ppBehavior</I> method parameter.</p>

<p><b>Table 11-6.</b> <i>Parameters of the</i> FindBehavior <i>Method</i></p>

<table cellpadding=5 width="95%">
<tr><th valign="top"><i>Parameter</i></th><th valign="top"><i>Description</i></th></tr>

<tr><td valign="top"><I>bstrBehavior</I></td>     
<td valign="top">String that contains the name of the Behavior for which the container is searching.</td></tr>

<tr><td valign="top"><I>bstrBehaviorURL </I></td>     
<td valign="top">String that contains the URL of the Behavior for which the container is searching.</td></tr>

<tr><td valign="top"><I>pSite </I></td>     
<td valign="top">Pointer to the container's implementation of the <I>IElementBehaviorSite</I> interface.</td></tr>

<tr><td valign="top"><I>ppBehavior</I></td>     
<td valign="top">Pointer to the <I>IElementBehavior</I> interface that is implemented by the Binary DHTML Behavior. After creating an instance of the Behavior, the <I>FindBehavior</I> method should query for the <I>IElementBehavior</I> interface and return the pointer to the container through this interface.</td></tr>
</table>

<A NAME="272"><H3><I>IElementBehavior</I></H3></A>
<P>Another important interface that the Binary DHTML Behavior must implement is <I>IElementBehavior</I>. This<I> </I>interface is an event sink that receivesnotifications from the container (MSHTML) concerning the activities of Behaviors on a Web page. The <I>IElementBehavior </I>interface contains three methods, shown in Table 11-7 in vtable order.</p>

<p><b>Table 11-7.</b> <i>Methods of the</I> IElementBehavior <I>Interface</i></p>

<table cellpadding=5 width="95%">
<tr><th valign="top"><i>Method</i></th><th valign="top"><i>Description</i></th></tr>

<tr><td valign="top"><I>Init</I></td>     
<td valign="top">Called immediately after the container obtains the <I>IElementBehavior </I>interface by calling the <I>IElementBehaviorFactory::FindBehavior</I> method. A pointer to the <I>IElementBehaviorSite </I>interface of the container is passed to the implementation of the <I>Init</I> method.</td></tr>

<tr><td valign="top"><I>Notify</I></td>     
<td valign="top">Called with information about the parsing of the document 
and the Behavior component. The <I>Notify </I>method is the actual 
event sink for the Behavior. It is passed one of the values contained 
in the BEHAVIOR_EVENT enumeration defined in the 
mshtml.h header file. Just as when implementing the 
<I>IDispatch::Invoke</I> method for other event sinks, the 
<I>Notify </I>method typically contains a 
<I>switch</I> statement to handle the Behavior events 
of interest.</td></tr>

<tr><td valign="top"><I>Detach</I></td><td valign="top">Called before the document is unloaded.</td></tr>
</table>

<P>The following code implements the <I>Init </I>method in the AtlBehave example:
</P>

<P>
<table cellpadding=5 width="95%"><TR><TD>
<PRE>
STDMETHODIMP
CBehavior::Init(IElementBehaviorSite* pBehaviorSite)
{
   // Cache the IElementBehaviorSite interface pointer.
   m_spSite = pBehaviorSite;

   // Cache the IElementBehaviorSiteOM interface pointer.
   HRESULT hr = m_spSite-&gt;QueryInterface(__uuidof(IElementBehaviorSiteOM),
                                         (void**)&amp;m_spOMSite);

   ATLASSERT(SUCCEEDED(hr));

   if (SUCCEEDED(hr))
      m_spOMSite-&gt;RegisterEvent(L&quot;ondocumentready&quot;, 0, NULL);

   return S_OK;
}
</PRE>
</td></tr></table></p>


<P>This implementation is quite simple. The <I>Init 
</I>method receives a pointer to the <I>IElementBehaviorSite 
</I>interface that is implemented in the container. This site 
pointer is saved in the <I>m_spSite</I> data member that will be used in this and other methods 
in the Behavior.
</P>

<P>
Next the <I>IElementBehaviorSite</I> interface pointer is queried for a pointer to 
the <I>IElementBehaviorSiteOM </I>interface, which is saved in the 
<I>m_spOMSite</I> data member. This data member will be used to register and fire an event.
</P>

<P>
Registration of the event occurs in the next step of the 
<I>Init</I> method when the code calls the <I>RegisterEvent 
</I>method of the <I>IElementBehaviorSiteOM </I>interface. 
All events must be registered before they can be fired. Also, registration of events 
must occur in the <I>Init </I>method. If you try to register an event elsewhere, you'll receive an error.</p>

<p>The <I>RegisterEvent </I>method takes three arguments. The first is the name of 
the event that you want to fire. The second argument is reserved, so you should 
specify <I>0</I> for this parameter. The third argument is a pointer to a 
<I>long</I> value that receives a cookie that can be used in later event calls. In the call to <I>RegisterEvent </I>in the previous code, only the name of the event is specified.</p>

<A NAME="273"><H3><I>IElementBehaviorSite</I></H3></A>
<P>As you saw, the <I>IElementBehaviorSite </I>interface that is implemented by the container is sent to the Behavior's <I>Init </I>method. The <I>IElementBehaviorSite </I>interface is the means by which the Binary DHTML Behavior communicates with the document. This interface contains one method, <I>GetElement</I>, which returns a pointer to the <I>IHTMLElement </I>interface that is implemented by the element to which a Binary DHTML Behavior is attached.</p>

<p>Calling the <I>GetElement</I> method is analogous to using the <I>element </I>object in an HTC. Through the <I>IHTMLElement </I>interface that is returned from <I>GetElement</I>, you can access methods, properties, and events of the element to which a Behavior is attached. Therefore, you can also access methods, properties, and events of any other object in the DHTML Object Model for the Web page.</p>

<A NAME="274"><H3><I>IElementBehaviorSiteOM</I></H3></A>
<P>By using the pointer to the <I>IElementBehaviorSite </I>interface received in the <I>Init </I>method, you can query for the <I>IElementBehaviorSiteOM</I> interface, as shown in the implementation of <I>Init </I>in the previous code. <I>IElementBehaviorSiteOM </I>provides event services to the Behavior, and through it, you can perform tasks such as creating event objects and firing events, just as you can with HTCs. The methods of the <I>IElementBehaviorSiteOM</I> are listed in Table 11-8.</p>


<b>Table 11-8.</b> <i>Methods of the</I> IElementBehaviorSiteOM <I>Interface</i>

<table cellpadding=5 width="95%">
<tr><th valign="top"><i>Method</i></th>     <th valign="top"><i>Description</i></th></tr>

<tr><td valign="top"><I>CreateEventObject</I></td>     
<td valign="top">Creates a new <I>event 
</I>object that can be used when calling the <I>FireEvent 
</I>method to pass event information to event handlers.</td></tr>

<tr><td valign="top"><I>FireEvent</I></td><td valign="top">Fires an event.</td></tr>

<tr><td valign="top"><I>GetEventCookie</I></td>     
<td valign="top">Returns the ID that identifies the Behavior event to 
the container (MSHTML).</td></tr>

<tr><td valign="top"><I>RegisterEvent</I></td>     
<td valign="top">Registers a Behavior event with the container 
(MSHTML). This method must be called before MSHTML will 
recognize events fired by a Binary DHTML Behavior. 
When using the <I>IElementBehaviorSiteOM </I>interface to 
code event handlers for events fired by Binary DHTML 
Behaviors, use inline event handlers or the &lt;SCRIPT 
FOR=&quot;&#133;&quot; EVENT=&quot;&#133;&quot;&gt; syntax.</td></tr>

<tr><td valign="top"><I>RegisterName</I></td>     
<td valign="top">Registers a Behavior name with the 
container (MSHTML).</td></tr>

<tr><td valign="top"><I>RegisterUrn</I></td>     
<td valign="top">Registers a Uniform Resource Name (URN) with the container (MSHTML).</td></tr>
</table>

<p>The next method of the <I>IElementBehavior </I>interface that is implemented by 
the <I>CBehavior </I>class is <I>Notify</I>. This method is the event sink for the Behavior, and it has the following two input parameters:</p>

<UL>
<P><LI><I>lEvent</I>. Identifies the event being sent to the Behavior from the 
container&#8212;MSHTML. The value of this input parameter can be any of the 
constants defined in the BEHAVIOR_EVENT enumeration declared in the 
mshtml.h header file.</li></p>
<P><LI><I>pVar</I>. Reserved.</LI></P>
</UL>

<P>
Here's the implementation of the <I>Notify </I>method as included in the 
AtlBehave example:
</P>

<P>
<table cellpadding=5 width="95%"><TR><TD>
<PRE>
STDMETHODIMP
CBehavior::Notify(LONG lEvent, VARIANT* pVar)
{
   HRESULT hr = S_OK;
   CComPtr&lt;IHTMLElement&gt; spElem;

   switch (lEvent)
   {
   // End tag of element has been parsed (We can get at attributes.)
   case BEHAVIOREVENT_CONTENTREADY:
      break;

   // HTML document has been parsed
   // (We can get at the document object model.)
   //
   case BEHAVIOREVENT_DOCUMENTREADY:
      if (m_spSite)
      {
         hr = m_spSite-&gt;GetElement(&amp;m_spElem);
         if (SUCCEEDED(hr))
         {
            // Create and connect the event sink.
            hr = CComObject&lt;CEventSink&gt;::CreateInstance(&amp;m_pEventSink);
            if (SUCCEEDED(hr))
            {
               CComPtr&lt;IHTMLStyle&gt; spStyle;
               HRESULT hr;

               hr = m_spElem-&gt;get_style(&amp;spStyle);
               if (SUCCEEDED(hr))
               {
                  spStyle-&gt;get_color(&amp;m_varColor);
                  spStyle-&gt;get_backgroundColor(&amp;m_varBackColor);
               }

               m_pEventSink-&gt;m_pBehavior = this;

               hr = AtlAdvise(m_spElem, m_pEventSink,
                              DIID_HTMLElementEvents,
                              &amp;m_dwCookie);
            }
         }
      }

      // Fire the ondocumentready event.
      //
      ATLASSERT(m_spOMSite);
      if (m_spOMSite)
      {
         LONG lCookie;

         hr = m_spOMSite-&gt;GetEventCookie(L&quot;ondocumentready&quot;, &amp;lCookie);
         ATLASSERT(SUCCEEDED(hr));

         if (SUCCEEDED(hr))
         {
            IHTMLEventObj* pEvtObj;

            hr = m_spOMSite-&gt;CreateEventObject(&amp;pEvtObj);
            ATLASSERT(SUCCEEDED(hr));

            if (SUCCEEDED(hr))
            {
               hr = m_spOMSite-&gt;FireEvent(lCookie, pEvtObj);
               ATLASSERT(SUCCEEDED(hr));

               pEvtObj-&gt;Release();
            }
         }
      }

      break;

   case BEHAVIOREVENT_APPLYSTYLE:
      break;

   case BEHAVIOREVENT_DOCUMENTCONTEXTCHANGE:
      break;

   default:
      break;
   }

   return S_OK;
}
</PRE>
</td></tr></table></p>


<P>The only event that is handled is <I>BEHAVIOREVENT_DOCUMENTREADY</I>, which indicates that the document is finished loading. In this event handler, the <I>style </I>object is retrieved from the element to which the Behavior is attached. Then the text and background color are retrieved. Next an event sink is connected to the element to handle the element's events. Finally the <I>ondocumentready</I> event is fired to the containing document.</P>

<p>This code is a little overkill, but it does demonstrate how to fire an event from a Binary DHTML Behavior. Before firing the event, the <I>GetEventCookie</I> method must be called to retrieve the event ID. (The event ID that is returned as the third parameter of the <I>RegisterEvent </I>method could have been stored as a data member, but I wanted to show you how to use as many of the methods in <I>IElementBehaviorSiteOM</I> as possible.) Next <I>CreateEventObject</I> is called to create an event object. Finally <I>FireEvent</I> is called to fire the event by using the cookie and the <I>event</I> object obtained earlier.</p>

<p>The final method of the <I>IElementBehavior</I> interface that is implemented by the <I>CBehavior </I>class is <I>Detach</I>. The <I>Detach</I> method is called when the document is being unloaded. The implementation of <I>Detach </I>is simple&#8212;typically, you just perform cleanup by releasing any interface pointers and freeing any memory that was dynamically allocated. The following code implements the AtlBehave example's <I>Detach</I> method:</p>


<P>
<table cellpadding=5 width="95%"><TR><TD>
<PRE>
STDMETHODIMP
CBehavior::Detach(void)
{
   // Release cached interface pointers.
   ATLASSERT(m_pEventSink);
   m_pEventSink-&gt;Release();

   ATLASSERT(m_spElem);
   m_spElem.Release();

   ATLASSERT(m_spOMSite);
   m_spOMSite.Release();

   return S_OK;
}
</PRE>
</td></tr></table></p>


<P>Now that you know how to implement Binary DHTML Behaviors, let's take 
a look at some other Behavior examples to round out our discussion.</p>

</BODY>
</HTML>





