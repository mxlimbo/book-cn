<HTML>
<head>
<link rel="STYLESHEET" type="text/css" href="Progie5.css">
<TITLE>Creating ATL ActiveX Controls </TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch05c.htm">[Previous]</A> <A HREF="ch06a.htm">[Next]</A><P>

<A NAME="143"><H1>Creating ATL ActiveX Controls </H1></A>

<P>Creating ActiveX controls by using C++ and ATL isn't as easy as creating them 
using Visual Basic, but ATL provides a lot of wizards that simplify the job. If you're a 
C++ programmer and are familiar with templates, you'll find ATL easy to use and 
understand. ATL takes a lot of the hassle out of creating ActiveX controls and 
other COM objects using C++. By providing default 
implementations for many COM interfaces such as 
<I>IUnknown</I> and <I>IDispatch, </I>ATL takes care of much of the 
boilerplate COM code that you probably copied from one project to the next in the past. Also, 
ATL provides several wizards that generate most of the code for ActiveX controls. 
So you can create the controls a lot faster than if you had to enter all the code 
manually.</P>

<P>Because most of the C++ type code I'll use in the rest of this book is based 
on ATL, this section provides a short introduction to creating ActiveX controls using 
ATL. Like the introduction to creating ActiveX controls using Visual Basic earlier in 
this chapter, this discussion isn't meant to be an all-inclusive reference to the Active 
Template Library. It's merely intended to get you started creating ActiveX controls by 
using ATL and to help you understand much of the code in later chapters. Also, just as 
the previous discussion about creating ActiveX controls by using Visual Basic 
didn't require you to have a good understanding of COM, you don't necessarily have 
to know COM to follow this section. But you will deal more directly with COM in 
this section than in the Visual Basic section, so understanding the basics of COM 
before you continue reading would certainly help.</P>

<P>To create ATL ActiveX controls, you first need to understand the internals of 
an ActiveX control from a COM standpoint: what's required by the COM 
specification for a COM object to be considered an ActiveX control. According to the 
OC96 (OLE Controls) standard, to be considered an ActiveX control, a COM object 
must be able to implement <I>IUnknown</I> and support self-registration. Self-registration 
means that the ActiveX control knows how to register itself. In other words, the DLL 
that contains the ActiveX control exports the 
<I>DllRegisterServer</I> function, which can be called to force the ActiveX control to register itself in the Registry. The control 
isn't required to be self-unregistering; however, a control is often considered rude if 
it is not!</P>

<P>The requirements are lax so that an ActiveX control can be as small as 
possible. You're not required to implement a large number of interfaces that you'll never 
need. You can implement only the smallest bit of required functionality needed by 
an ActiveX control. Although an ActiveX control is required to implement only 
<I>IUnknown</I> and self-registration, if that's all it did, the control wouldn't be especially useful. 
In fact, it would be downright boring. So you do need to implement enough 
interfaces to make the ActiveX control useful. These interfaces, listed in order of 
importance, are described in Table 5-1. If you're going to use the control on 
a Web page, you should implement at least the first four interfaces to ensure the 
control will work correctly in Internet Explorer.</P>

<P><B>Table 5-1.</B> <I>ActiveX Control-Related Interfaces</I></P>
<P>
<table cellpadding=5 width="95%">
<tr>  
<th><I>Interface</I>  </th>
<th><I>Description</I>  </th></tr>
<tr>
<td valign="top"><I>IUnknown</I>  </td>
<td valign="top">Manages object lifetime (<I>AddRef</I> and <I>Release</I>) and object recognition (<I>QueryInterface</I>). Base interface for all other interfaces.  </td></tr>
<tr>
<td valign="top"><I>IClassFactory</I>  </td>
<td valign="top">Contains two methods (<I>CreateInstance</I> and <I>LockServer</I>) to deal with the creation of objects.  </td></tr>
<tr>
<td valign="top"><I>IOleObject</I>  </td>
<td valign="top">Provides the basic means for a control to communicate with its container.   </td></tr>
<tr>
<td valign="top"><I>IDispatch</I>  </td>
<td valign="top">Supports automation of COM objects.  </td></tr>    
<tr>
<td valign="top"><I>IOleControl</I>  </td>
<td valign="top">Provides container support for ambient properties, keyboard mnemonics, and events.  </td></tr>
<tr>
<td valign="top"><I>IOleInPlaceActiveObject</I>  </td>
<td valign="top">Provides a direct channel between an in-place object and the container's outermost frame window and document window.  </td></tr>     
<tr>
<td valign="top"><I>IViewObject</I>  </td>
<td valign="top">Enables an object to display itself directly without having to pass a data object to the caller.  </td></tr>
<tr>
<td valign="top"><I>IOleInPlaceObjectWindowless</I>  </td>
<td valign="top">Enables a windowless control to process Windows messages.  </td></tr> 
<tr>
<td valign="top"><I>IPersistStreamInit</I>  </td>
<td valign="top">Supports persistence via a stream.  </td></tr>    
</table></p>

<P>Some of the interfaces in Table 5-1 are more important than others. In 
particular, the first four are extremely important&#8212;an ActiveX control 
might not work on a Web page at all without them. In addition to implementing these interfaces, 
you'll probably want the control to have some kind of user interface or other form 
of visual representation. Next we'll discuss how to use ATL to create an ActiveX 
control that can be seen on a Web page, exposes methods and properties, and fires events.</P>

<P>To create an ATL ActiveX control, first start Visual C++ 6. After you get 
past that difficult step, choose New from the File menu, which displays the dialog 
box in Figure 5-24. Make sure that the ATL COM AppWizard is selected. Then enter a 
name in the Project Name text box on the upper right-hand side of the dialog box. For 
this example, name the project AtlControl. You might want to change the default 
location for your project to a different directory.</P>

<P>When you click OK, the dialog box in Figure 5-25 is displayed. Notice that 
the title bar states that you're performing step 1 of 1. See how easy this is going to be?!</P>

<P>You're creating an ActiveX control, so leave the default 
selection of Dynamic Link Library (DLL) alone, and click the Finish button. Click OK in the 
confirmation dialog box that appears. Now Visual C++ 
will create a number of files for you that contain the 
boilerplate code necessary for Internet Explorer to interact with 
the DLL of your ActiveX control. For example, if you look in the file AtlControl.cpp, 
you'll see several exported DLL functions that containers can use to communicate with 
the ActiveX control.</P>

<P>
<A HREF="javascript:fullSize('F05ii24x.htm')"> <img src="images/F05ii24.JPG" width=404 height=288 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 5-24. </B> <I>New dialog box. </I><!-- /caption -->
</P>

<P>
<A HREF="javascript:fullSize('F05ii25x.htm')"> <img src="images/F05ii25.JPG" width=404 height=325 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 5-25. </B> <I>Step 1 of the ATL COM AppWizard. </I><!-- /caption -->
</P>

<P>Before this DLL can do anything exciting, you must add an ActiveX 
control. Right-click AtlControl Classes<B> 
</B>in the ClassView pane of Visual C++, which will 
bring up the context menu displayed in Figure 5-26.</P>

<P>
<A HREF="javascript:fullSize('F05ii26x.htm')"> <img src="images/F05ii26.JPG" width=404 height=303 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 5-26. </B> <I>ATL context menu. </I><!-- /caption -->
</P>

<P>From this context menu, choose New ATL Object. The ATL Object
Wizard dialog box shown in Figure 5-27 is displayed. It allows you to choose the type of 
ATL object that you want. Four categories of objects are listed on the left-hand side of 
the dialog box. Because you're creating an ActiveX control, select the Controls 
category. You can choose from seven types of controls. They are listed in Table 5-2.</P>

<P>
<A HREF="javascript:fullSize('F05ii27x.htm')"> <img src="images/F05ii27.JPG" width=404 height=251 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 5-27. </B> <I>ATL Object Wizard. </I><!-- /caption -->
</P>

<P><B>Table 5-2.</B> <I>Control Types Available in the ATL Object Wizard Dialog Box</I></P>

<P>
<table cellpadding=5 width="95%">
<tr>  
<th><I>ATL Control Type</I>  </th>
<th><I>Description</I>  </th></tr>
<tr>
<td valign="top">Full Control  </td>
<td valign="top">Supports all the interfaces for an ActiveX control.  </td></tr>
<tr>
<td valign="top">Lite Control  </td>
<td valign="top">Meant to be used in Internet Explorer. Has a smaller number of interface implementations than the Full Control.  </td></tr>
<tr>
<td valign="top">Composite Control  </td>
<td valign="top">Can contain other controls.  </td></tr>
<tr>
<td valign="top">HTML Control  </td>
<td valign="top">Can display HTML Web pages.  </td></tr>
<tr>
<td valign="top">Property Page  </td>
<td valign="top">Used to create property pages.  </td></tr>
<tr>
<td valign="top">Lite Composite Control  </td>
<td valign="top">Same as the Composite Control but with fewer interface implementations.  </td></tr>
<tr>
<td valign="top">Lite HTML Control  </td>
<td valign="top">Same as the HTML Control but with fewer interface implementations.  </td></tr>   
</table></p>

<P>Because you're creating an ActiveX control for use in Internet Explorer, 
choose the Lite Control, and then click the 
Next button. The ATL Object Wizard 
Properties dialog box, shown in Figure 5-28, is displayed. Using this dialog box, specify the 
name of the ActiveX control. Enter the name 
<I>AtlCtrl</I> in the Short Name field. You'll 
notice that the other fields are filled in automatically.</P>

<P>
<A HREF="javascript:fullSize('F05ii28x.htm')"> <img src="images/F05ii28.JPG" width=404 height=268 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 5-28.</B> <I>ATL Object Wizard Properties dialog box. </I><!-- /caption -->
</P>

<P>Click the Attributes tab to display the dialog box shown in Figure 5-29. Using this tab, you can set certain attributes such as the 
control's threading model. Notice that Apartment threading is the 
default. You can leave this setting alone because the 
control will be used on a Web page inside Internet 
Explorer. Remember, ActiveX controls must be Apartment-threaded to work correctly 
in Internet Explorer.</P>

<P>
<A HREF="javascript:fullSize('F05ii29x.htm')"> <img src="images/F05ii29.JPG" width=404 height=268 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 5-29. </B> <I>Attributes tab. </I><!-- /caption -->
</P>

<P>One other item on the Attributes tab is of great importance for this 
example&#8212;the Support Connection Points check box. Check this box, because events will be 
fired from your ActiveX control. (More discussion on connection points is in Chapter 
7.) The other two tabs aren't important to this example, so you do not need to look 
at them. Click the OK button.</P>

<P>Notice that Visual C++ created a new class named 
<I>CAtlCtrl</I>. The <I>CAtlCtrl</I> class is the C++ implementation of the control. Before you add any methods, 
properties, or events, build the ActiveX control by pressing F7 or by choosing 
Build AtlControl.dll from the Build menu. Because you're building a control that will be 
downloaded across the Internet, you should set the active configuration to Win32 
Release MinDependency. This setting will ensure that the control has the minimal amount 
of dependencies possible so that you won't have to include any other files 
besides AtlControl.dll in the CAB file. This is one advantage that ATL has over MFC. If 
you build ActiveX controls using MFC, the C run-time and MFC library files have to 
be downloaded to the client machine in addition to the control DLL.</P>

<P><div class="note"><blockquote><B>NOTE</B><HR>Setting the active configuration to Win32 Release MinDependency 
statically links the DLL with the run-time code needed for the control to operate 
correctly. If you'll be debugging the control using the Visual C++ debugger, set 
the configuration to Win32 Debug. If you receive a compile error indicating that 
the <I>_main</I> function is missing, remove the _ATL_MIN_CRT definition from the 
Preprocessor Definitions box on the C/C++ tab of the Project settings dialog box.</blockquote></div>
</P>

<P>After building the control, test it using the sample HTML file that Visual 
C++ created in the Project directory when you created the control using the 
ATL Object Wizard. This HTML file contains &lt;OBJECT&gt; tags and the necessary CLASSID 
attribute to display the control on the Web page. If you load this Web page into 
Internet Explorer, you'll see the page shown in Figure 5-30.</P>

<P>
<A HREF="javascript:fullSize('F05ii30x.htm')"> <img src="images/F05ii30.JPG" width=404 height=274 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 5-30. </B> <I>ATL Control test page. </I><!-- /caption -->
</P>

<P>Notice that ATL creates some default drawing code that displays on the 
Web page. At this point, close Internet Explorer and go back to your project. In the 
ClassView pane, expand the <I>CAtlCtrl</I> class, and then double-click the 
<I>OnDraw</I> method. This method is called by the 
ATL framework in response to the container calling 
the control's <I>IViewObject::Draw</I> method. (This shows the reason why 
the <I>IViewObject</I> interface is required if you want to provide any useful user interface for the 
control.) As Figure 5-30 shows, by default, ATL just prints a message that includes the 
version number of ATL. The default code that the ATL Object Wizard generated follows:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>HRESULT OnDraw(ATL_DRAWINFO&amp; di)
{
      RECT&amp; rc = *(RECT*)di.prcBounds;
      Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

      SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
      LPCTSTR pszText = _T(&quot;ATL 3.0 : AtlCtrl&quot;);
      TextOut(di.hdcDraw, 
            (rc.left + rc.right) / 2, 
            (rc.top + rc.bottom) / 2, 
            pszText, 
            lstrlen(pszText));

      return S_OK;
}
</PRE>
</td></tr></table></p>

<P>In the next few sections of this chapter, I'll show you how to add methods 
and properties to change the default message.</P>

<A NAME="144"><H2>Adding Methods </H2></A>

<P>Adding methods to the ATL control is fairly easy. For this example, let's add a 
method named <I>ChangeMessage</I> that will change the message displayed by the control. To 
add a method, right-click the <I>IAtlCtrl</I> interface in the ClassView pane of your project. 
The context menu shown in Figure 5-31 is displayed.</P>

<P>
<A HREF="javascript:fullSize('F05ii31x.htm')"> <img src="images/F05ii31.JPG" width=404 height=303 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 5-31. </B> IAtlCtrl <I>interface context menu. </I><!-- /caption -->
</P>

<P>From the context menu, choose the Add Method menu item. The 
Add Method To Interface dialog box, as shown in Figure 5-32, is then displayed. In this dialog 
box, enter the name of the method and any parameters it will accept. Enter the 
name <I>ChangeMessage</I> in the Method Name text box. Then add one parameter named 
<I>bstrMsg</I> to the Parameters text box. The string you enter to specify the input parameter 
should look like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>[in] BSTR bstrMsg
</PRE>
</td></tr></table></p>

<P>The [in] specifier indicates that the <I>bstrMsg 
</I>parameter is an input parameter. The 
<I>bstrMsg</I> parameter has a type of <I>BSTR</I>. On a 32-bit Windows platform, a 
<I>BSTR </I>is a COM-compatible, wide-character string that has four bytes for the size of the 
string followed by the string itself. (For more detailed information about 
<I>BSTRs</I>, consult MSDN or one of the many COM books offered by Microsoft Press.) After entering 
the parameter string, click OK to complete the creation of the 
<I>ChangeMessage</I> method. Now add some code to this method so that it actually changes the message 
displayed on the Web page.</P>

<P>
<img src="images/F05ii32.GIF" width=366 height=257 border="0">
</P><P>
<!-- caption --><B>Figure 5-32. </B> <I>Add Method To Interface dialog box. </I><!-- /caption -->
</P>

<P>Open the AtlCtrl.h header file that contains the class definition for the 
<I>CAtlCtrl</I> class. Add a protected data member of type 
<I>CComBSTR</I> named <I>m_bstrMessage</I> to 
the end of the <I>CAtlCtrl</I> class definition. (A 
<I>CComBSTR</I> is an ATL utility class that encapsulates 
<I>BSTR </I>strings and provides functions that make these strings easier to use.) 
Add the following code to the <I>CAtlCtrl</I> class:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>protected:
   CComBSTR m_bstrMessage;
</PRE>
</td></tr></table></p>

<P>Initialize the data member to a message that will be printed the first time 
the control is displayed. You can change the constructor to initialize 
<I>m_bstrMessage</I>, like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>CAtlCtrl() : m_bstrMessage(bstrDefaultMsg)
{
}
</PRE>
</td></tr></table></p>

<P>The <I>m_bstrMessage</I> data member is set to 
<I>bstrDefaultMsg</I>. The <I>bstrDefaultMsg </I>variable is a global constant that stores the default message. The 
<I>bstrDefaultMsg </I>variable is defined at the top of the AtlCtrl.h header file, like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>const CComBSTR bstrDefaultMsg = _T(&quot;Hello, Internet Explorer!&quot;);
</PRE>
</td></tr></table></p>

<P>Locate the <I>OnDraw</I> method, the last method in the AtlCtrl.h header file. A 
local variable exists in this method named 
<I>pszText</I> that is displayed on the Web page. 
Set this variable equal to the 
<I>m_bstrMessage</I> data member. You'll first have to convert 
this data member from a <I>BSTR</I> type to a 
<I>LPCTSTR</I> type, because <I>pszText</I> is a 
<I>LPCTSTR</I> variable, and <I>m_bstrMessage</I> is a 
<I>BSTR </I>type variable. To perform this conversion, 
use the OLE2T macro provided by ATL in conjunction with the USES_CONVERSION 
macro. Change the line containing the 
<I>pszText</I> variable to these two lines of code:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>USES_CONVERSION;
LPCTSTR pszText = OLE2T(m_bstrMessage);
</PRE>
</td></tr></table></p>

<P>Open the AtlCtrl.cpp file. This file should contain only skeleton code for 
the <I>ChangeMessage</I> method. Change the code in this method so that it sets 
the <I>m_bstrMessage</I> data member equal to the 
<I>bstrMsg</I> parameter that was sent to this method. You 
also need to alert Internet Explorer that the ActiveX control's view has changed by 
calling the <I>FireViewChange</I> method, which is a member of 
<I>CComControl</I> class. The code for the 
<I>ChangeMessage</I> method should look like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHODIMP CAtlCtrl::ChangeMessage(BSTR bstrMsg)
{
   m_bstrMessage = bstrMsg;
   FireViewChange();

   return S_OK;
}   
</PRE>
</td></tr></table></p>

<P>The entire code for this example can be found on the companion CD in 
the folder \Samples\Chap05\AtlControl.</P>

<A NAME="145"><H2>Adding Properties</H2></A>

<P>Now you'll add a property to the ActiveX control that allows you to retrieve the 
current value of the message that's displayed on the Web page. Adding a property is as 
simple as adding a method. Start by right-clicking 
<I>IAtlCtrl</I> in the ClassView pane, like you did when creating the 
<I>ChangeMessage</I> method. But this time, choose 
Add Property from the context menu. The 
Add Property To Interface<B> 
</B>dialog box is displayed, as shown in Figure 5-33.</P>

<P>
<img src="images/F05ii33.GIF" width=366 height=405 border="0">
</P><P>
<!-- caption --><B>Figure 5-33. </B> <I>Add Property To Interface dialog box. </I><!-- /caption -->
</P>

<P>The Property Type drop-down list box allows you to choose the type of 
property that you want to create. Choose BSTR. 
Type <I>Message</I> into the Property Name text 
box. Although properties can accept parameters, because 
you'll be accessing this property using script, you won't want to specify any parameters.</P>

<P>The next section of the dialog box specifies the function type for the 
property. You'll see two types listed: Get Function and Put Function. Internet Explorer 
uses the Get Function type when you're retrieving the value of a property using 
script, and it uses the Put Function type when you're setting the value of a property 
using script. For this example, you want to allow only script code to retrieve the value 
of the property. The <I>ChangeMessage</I> method will be used to set the value of the 
message that's displayed. Therefore uncheck the Put Function check box. Then click 
OK to allow Visual C++ to create the property.</P>

<P>Take a look at the AtlCtrl.cpp file again. Notice that one method has been 
added to this file: <I>get_Message</I>. This method is the implementation of the Get Function 
type for the property of your ActiveX control. If you had chosen to include the Put 
Function type in the Add Property To Interface dialog box, Visual C++ would have 
created a <I>put_Message</I> method for you.</P>

<P>Change the <I>get_Message</I> method so that it sets the 
<I>pVal</I> parameter to the 
<I>m_bstrMessage</I> data member. That's how you'll return the current message 
being displayed on the Web page to script code. Now the 
<I>get_Message</I> method should 
look like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHODIMP CAtlCtrl::get_Message(BSTR *pVal)
{
   *pVal = m_bstrMessage;
   return S_OK;
}
</PRE>
</td></tr></table></p>

<A NAME="146"><H2>Firing Events</H2></A>

<P>Firing events from an ATL control is about as easy as adding methods and 
properties. As you've probably guessed, Visual C++ provides wizards that enable you to 
fire events from the control. You can add an event to the ATL control that will fire 
when the message in the display window changes.</P>

<P>Earlier, when you created the Lite Control and checked the 
Support Connection Points check box, Visual C++ created the 
<I>_IAtlCtrlEvents</I> interface. This 
interface is referred to as a source interface because it will be used as the source of 
events. Whereas methods and properties are called by clients, events are functions that 
are implemented in the clients and called by the controls. This topic is explained in 
greater detail in <A HREF="ch07a.htm">Chapter 7</A>.</P>

<P>To add an event that will be fired by the control, right-click the 
<I>_IAtlCtrlEvents</I> interface in the ClassView pane of Visual C++. The same context menu is shown 
that was displayed when you created the method and property for the control. From 
the context menu, choose Add Method. The 
Add Method To Interface dialog box that was shown in Figure 5-32 is displayed. Select a return type of 
<I>void</I> from the Return Type drop-down list. Enter 
<I>OnMessageChanged</I> for the name of the 
event. You don't need to enter any parameters, as they aren't required for this event. 
When you're finished, click the OK button. Visual C++ adds the 
<I>OnMessageChanged</I> method to the .idl file for the control.</P>

<P>Next you must compile the .idl file to create a type library. Right-click 
AtlControl.idl in the FileView pane of the Visual C++ IDE, and choose Compile AtlControl.idl. 
If everything goes well, Visual C++ will create a type library file (.tlb) for the control.</P>

<P>Now you must implement a connection point for the control. Right-click 
<I>CAtlCtrl</I> in the ClassView pane, and choose 
Implement Connection Point from the 
context menu. The dialog box shown in Figure 5-34 will be displayed. Select 
<I>_IAtlCtrlEvents</I> from the list of interfaces, and then click OK. Visual C++ will then create an 
ATL-based proxy class that will be used for firing the 
<I>OnMessageChanged</I> event. This class is named 
<I>CProxy_IAtlCtrlEvents</I>. In addition to creating this class, Visual C++ adds 
the class to the inheritance list for 
<I>CAtlCtrl</I>. Adding the class is necessary so that the 
event <I>OnMessageChanged</I> can be fired by using the 
<I>Fire_OnMessageChanged</I> function 
of the <I>CProxy_IAtlCtrlEvents</I> class.</P>

<P>
<A HREF="javascript:fullSize('F05ii34x.htm')"> <img src="images/F05ii34.JPG" width=404 height=320 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 5-34. </B> <I>Implement Connection Point dialog box. </I><!-- /caption -->
</P>

<P>Internet Explorer has a requirement that is usually overlooked when 
trying to fire events from an ActiveX control: a control must implement the 
interface <I>IProvideClassInfo2</I>. Using 
<I>IProvideClassInfo2</I>, Internet Explorer retrieves the 
interface ID of the control's event 
source&#8212;<I>DIID__IAtlCtrlEvents</I>. If you don't 
implement <I>IProvideClassInfo2</I>, the event handlers you create in script will never be 
called. Fortunately, ATL provides a default implementation of 
<I>IProvideClassInfo2 </I>named 
<I>IProvideClassInfo2Impl</I>.</P>

<P>There are two steps to implementing the 
<I>IProvideClassInfo2</I> interface in ATL. First, place 
<I>IProvideClassInfo2Impl </I>in the inheritance list for the implementation 
class, <I>CAtlCtrl</I>. The code should look like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>class ATL_NO_VTABLE CAtlCtrl :
   
   
   public IProvideClassInfo2Impl&lt;&amp;CLSID_AtlCtrl,
                                 &amp;DIID__IAtlCtrlEvents,
                                 &amp;LIBID_ATLCONTROLLib&gt;
{
   
   
};
</PRE>
</td></tr></table></p>

<P>Because <I>IProvideClassInfo2Impl</I> is a template class, you must specify a 
number of parameters. The required parameters are the CLSID of the ActiveX 
control (<I>CLSID_AtlCtrl</I>), the interface ID of the event source interface 
(<I>DIID__IAtlCtrlEvents</I>), and the GUID for the type library 
(<I>LIBID_ATLCONTROLLib</I>).</p>

<P>The second step is to add the 
<I>IProvideClassInfo</I> and 
<I>IProvideClassInfo2</I> interfaces to the COM map for the 
<I>CAtlCtrl</I> class. You must add both of these 
interfaces because <I>IProvideClassInfo2</I> is derived from 
<I>IProvideClassInfo</I>. Now your code should look like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>BEGIN_COM_MAP(CAtlCtrl)
   
   
   COM_INTERFACE_ENTRY(IProvideClassInfo)
   COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()
</PRE>
</td></tr></table></p>

<P>You must perform one last task before the 
<I>OnMessageChanged</I> event can be fired&#8212;correct the name of the interface that will be referenced by the proxy 
class. Recall that when you were creating the control and chose to support 
connection points, the wizard created not only the 
<I>_IAtlCtrlEvents</I> interface but also a CLSID 
for it named <I>DIID__IAtlCtrlEvents</I>. However, the wizard that created the proxy class 
that you will use to fire events references this 
<I>_IAtlCtrlEvents </I>interface using the 
incorrect name 
<I>IID__IAtlCtrlEvents</I>. To correct this error, open the AtlCtrl.h file, and 
locate the connection point map for the control. The connection point map should 
look like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>BEGIN_CONNECTION_POINT_MAP(CAtlCtrl)
CONNECTION_POINT_ENTRY(IID__IAtlCtrlEvents)
END_CONNECTION_POINT_MAP()
</PRE>
</td></tr></table></p>

<P>Change the interface ID for 
<I>_IAtlCtrlEvents</I> to 
<I>DIID__IAtlCtrlEvents</I>. The new code should look like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>BEGIN_CONNECTION_POINT_MAP(CAtlCtrl)
CONNECTION_POINT_ENTRY(DIID__IAtlCtrlEvents)
END_CONNECTION_POINT_MAP()
</PRE>
</td></tr></table></p>

<P>Now all you have to do is call the 
<I>Fire_OnMessageChanged</I> function 
whenever you want to fire the event. You should call 
<I>Fire_OnMessageChanged</I> whenever the 
<I>Message</I> property has been changed. For this example, you need to call it only 
from within the <I>ChangeMessage</I> method. Here's the updated code for 
<I>ChangeMessage</I> to fire the 
<I>OnMessageChanged</I> event:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHODIMP CAtlCtrl::ChangeMessage(BSTR bstrMsg)
{
   m_bstrMessage = bstrMsg;
   FireViewChange();

   Fire_OnMessageChanged();

   return S_OK;
}
</PRE>
</td></tr></table></p>

<A NAME="147"><H2>Marking ATL Controls as Safe </H2></A>

<P>Earlier you marked Visual Basic ActiveX controls as safe for scripting and 
initialization by using the Package And Deployment Wizard. Unfortunately, no such ATL 
tool exists that creates packages like PDW does for Visual Basic. Consequently, 
besides having to create your own CAB and INF files, you'll also have to manually mark 
the control as safe for scripting and initialization. If you don't, the users will either 
receive a warning dialog box from Internet Explorer (as shown in Figure 5-35), or, if 
their security levels are set high enough, the control won't be able to be scripted or 
initialized at all!</P>

<P>
<img src="images/F05ii35.GIF" width=345 height=136 border="0">
</P><P>
<!-- caption --><B>Figure 5-35. </B> <I>Warning dialog box. </I><!-- /caption -->
</P>

<P>For this reason, the <I>IObjectSafety</I> interface exists. An ATL ActiveX control 
can implement <I>IObjectSafety</I> to tell Internet Explorer that the control is safe. When 
loading the control, Internet Explorer queries the ActiveX control for 
<I>IObjectSafety</I>. If this interface is returned, Internet Explorer calls 
the <I>GetInterfaceSafetyOptions</I> method of 
<I>IObjectSafety</I> to see whether the control is safe for scripting, safe for 
initialization, or both.</P>

<P>Implementing <I>IObjectSafety</I> is the preferred technique for telling 
Internet Explorer that your control is safe, and doing so in ATL is straightforward. The procedure 
is similar to the steps you follow to implement 
<I>IProvideClassInfo2</I>: add ATL's implementation class for the interface to the inheritance list, and then add the interface 
to the COM map. Regarding the first step of the process, in the same way that ATL 
provides the <I>IProvideClassInfo2Impl</I> class to implement 
<I>IProvideClassInfo2</I>, ATL also provides the 
<I>IObjectSafetyImpl</I> class to implement 
<I>IObjectSafety</I>. After adding 
<I>IObjectSafetyImpl</I> to the inheritance 
list, the code for the <I>CAtlCtrl</I> class 
declaration should look like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>class ATL_NO_VTABLE CAtlCtrl :
   
   
   public IObjectSafetyImpl&lt;CAtlCtrl, 
                            INTERFACESAFE_FOR_UNTRUSTED_CALLER 
                          | INTERFACESAFE_FOR_UNTRUSTED_DATA&gt;
{
   
   
};
</PRE>
</td></tr></table></p>

<P>Like any other template class, you must specify certain parameters when 
inheriting from <I>IObjectSafetyImpl</I>. The first parameter is the name of the 
class&#8212;<I>CAtlCtrl</I>. The second parameter specifies the supported safety options for the control. 
Two options are currently available: 
<I>INTERFACESAFE_FOR_UNTRUSTED_CALLER</I> and 
<I>INTERFACESAFE_FOR_UNTRUSTED_DATA</I>. The first of the two indicates that 
the control is safe for scripting. The second indicates that the control is safe for 
initialization. You can specify one of the two, or specify them both by OR'ing them together.</P>

<P>The second step to completing the implementation of 
<I>IObjectSafety</I> is to add the 
<I>IObjectSafety</I> interface to the COM map. After adding this interface, the COM 
map should look like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>BEGIN_COM_MAP(CAtlCtrl)
   
   
   COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()
</PRE>
</td></tr></table></p>

<A NAME="148"><H2>Initializing from HTML</H2></A>

<P>In the same way that you can initialize a Visual Basic ActiveX control, you can 
initialize an ATL control using the &lt;PARAM&gt; tags. When you include the &lt;PARAM&gt; 
tags as children of the &lt;OBJECT&gt; tags, Internet Explorer sends the data that you 
specify to the control when the control is first instantiated. For example, to specify an 
initial value for the <I>Message</I> property, you can insert a &lt;PARAM&gt; tag between the 
opening and closing object tags for the control. This HTML code looks like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>&lt;OBJECT ID=&quot;AtlCtrl&quot;
        CLASSID=&quot;CLSID:638B718E-AEF1-11D2-A9BA-444553540001&quot;&gt;
        &lt;PARAM NAME=&quot;Message&quot; VALUE=&quot;Hello, There!&quot;&gt;
&lt;/OBJECT&gt;
</PRE>
</td></tr></table></p>

<P>This data is stored in a property bag object maintained by Internet 
Explorer. Internet Explorer will query the control for the 
<I>IPersistPropertyBag</I> interface. If the control returns a pointer to this interface, Internet Explorer calls the 
<I>Load</I> method of 
<I>IPersistPropertyBag</I> to instruct the control to load initialization data. When calling 
the <I>Load</I> method, Internet Explorer passes a pointer to 
<I>IPropertyBag</I> interface of its property bag object. The control then calls the 
<I>Read</I> method of the passed in 
<I>IPropertyBag</I> interface to retrieve the initialization data.</P>

<P>To make this work correctly in the AtlCtrl control, you need to follow a 
few steps. As usual, ATL provides a default implementation of 
<I>IPersistPropertyBag</I> named 
<I>IPersistPropertyBagImpl</I>. Add this template class to the end of the inheritance list. 
After adding the template class, the declaration of 
<I>CAtlCtrl</I> should look like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>class ATL_NO_VTABLE CAtlCtrl : 
   
   
   public IPersistPropertyBagImpl&lt;CAtlCtrl&gt;
{
   
   
};
</PRE>
</td></tr></table></p>

<P>Add the <I>IPersistPropertyBag</I> interface to the COM map. After adding this 
interface, the COM map should look like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>BEGIN_COM_MAP(CAtlCtrl)
   
   
   COM_INTERFACE_ENTRY(IPersistPropertyBag)
END_COM_MAP()
</PRE>
</td></tr></table></p>

<P>Implement the <I>Load</I> method, as shown in the next code fragment. You can 
add this method to the bottom of the class declaration. With 
<I>Load</I>, you can retrieve the initialization data that you specified on the Web page by using &lt;PARAM&gt; tags.</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog)
{
   CComVariant vtVal;

   HRESULT hr = pPropBag-&gt;Read(L&quot;Message&quot;, &amp;vtVal, pErrorLog);

   if (SUCCEEDED(hr) &amp;&amp; VT_BSTR == vtVal.vt)
   {
      m_bstrMessage = vtVal.bstrVal;
      m_fDirty = TRUE;
   }

   return hr;
}
</PRE>
</td></tr></table></p>

<P>In the <I>Load</I> method, we first have to declare a variable of 
<I>CComVariant</I>. The <I>CComVariant </I>variable is similar to 
<I>CComBSTR </I>in that it's a wrapper class that 
provides greater functionality than the data type it contains. In this case, a 
<I>CComVariant </I>wraps a <I>VARIANT</I> type. This variable is needed to retrieve the values of the 
parameters specified using &lt;PARAM&gt; tags. (If you need more information about 
<I>CComVariant</I>, refer to MSDN.)</P>

<P>Next we call the <I>Read</I> method of the 
<I>IPropertyBag</I> interface that was passed into the 
<I>Load</I> method. The first parameter specifies the name of the property that we 
want to retrieve. This parameter tacks on the 'L' specifier that converts the ANSI string 
to an OLE string. Here we're reading the 
<I>Message</I> property from the property bag. The second parameter is a 
<I>VARIANT</I> that will contain the value of the 
<I>Message</I> property when this method returns. The third parameter is a pointer to 
<I>IErrorLog</I> interface that the <I>Read</I> method uses to report errors. This parameter can be 
<I>NULL</I> if we're not interested in error information. In this case, we simply pass the pointer to 
<I>IErrorLog</I> interface that we received from the argument of the 
<I>Load</I> method.</P>

<P>Then we check the return value of the 
<I>Read</I> method. If the call to 
<I>Read</I> succeeded and the type of the 
<I>VARIANT</I> that was returned is a <I>BSTR</I> (as indicated by 
<I>vtVal.vt</I> being equal to <I>VT_BSTR</I>), we set the 
<I>m_bstrMessage</I> data member to the 
<I>BSTR</I> value that is contained in the 
<I>vtVal</I> variable. Now, when the 
<I>OnDraw</I> method is initially called, the value that we specified for the 
<I>Message</I> property will be displayed on the Web page. In addition to setting the 
<I>m_bstrMessage</I> data member, we also set the 
<I>m_fDirty</I> data member to <I>TRUE</I>. The 
<I>m_fDirty </I>data member indicates that the 
property has been changed. Here's how <I>m_fDirty 
</I>is defined in the <I>CAtlCtrl</I> class:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>BOOL m_fDirty;
</PRE>
</td></tr></table></p>

<P>We should also initialize <I>m_fDirty </I>in the 
<I>CAtlCtrl</I> constructor. The constructor will look like this:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>CAtlCtrl() : m_bstrMessage(bstrDefaultMsg),
             m_fDirty(FALSE)
{
}
</PRE>
</td></tr></table></p>

<A NAME="149"><H2>Printing </H2></A>

<P>Earlier in the discussion about creating Visual Basic ActiveX controls, you learned 
that Internet Explorer creates a hidden Web page used for background printing. Also, 
you have to handle the <I>WriteProperties</I> event and call the 
<I>WriteProperty </I>method of the property bag object so that the control will be printed in its current state.</p>

<P><div class="note"><blockquote><B>NOTE</B><HR>ActiveX controls built using Visual C++ can use 
<I>IPersistStreamInit</I> instead of 
<I>IPersistPropertyBag</I> for printing. Internet Explorer will query the 
control first for <I>IPersistPropertyBag</I>. If 
<I>IPersistPropertyBag</I> isn't found, Internet Explorer will query for 
<I>IPersistStreamInit</I> and, if it's found, use that interface 
for printing.</blockquote></div>
</P>

<P>Ensuring that the ATL control prints in its current state is similar to the 
process of ensuring proper printing of Visual Basic ActiveX controls. However, you don't 
have an event to handle. In an ATL control, you simply have to implement the 
<I>Save</I> method of <I>IPersistPropertyBag</I>. The 
<I>Save</I> method takes three input parameters:</P>

<UL>
<P><LI><I>     pPropBag</I>. A property bag object as represented by 
<I>IPropertyBag</I>.</LI></P>

<P><LI><I>     fClearDirty</I>. A Boolean value that indicates whether you should clear 
the dirty flag. The <I>m_fDirty </I> data member is the dirty flag for the 
<I>CAtlCtrl </I> class. A value of <I>TRUE</I> indicates that the dirty flag should be cleared. A 
value of <I>FALSE</I> indicates that it should not.</LI></P>


<P><LI><I>     fSaveAllProperties</I>. A Boolean value that indicates whether you 
should save all the properties to the property bag object 
(<I>TRUE</I>) or only those that have changed since the control was last saved or initialized 
(<I>FALSE</I>).</LI></P>
</UL>

<P>Implementing the code for the <I>Save </I>method in the 
<I>CAtlCtrl</I> class is straightforward, as shown here:</P>

<P><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHOD(Save)(IPropertyBag* pPropBag, BOOL fClearDirty,
                BOOL fSaveAllProperties)
{
   HRESULT hr = E_FAIL;
      
   if (fSaveAllProperties)
   {
      // Save all properties whether they have changed or not.
      //
      hr = pPropBag-&gt;Write(L&quot;Message&quot;, &amp;CComVariant(m_bstrMessage));
      }
      else if (m_fDirty)
      {
      // Save only the properties that have changed. This
      // control has only one property, so check its current
      // value against its default value. If the value has changed,
      // save it.
      //
      if (wcscmp(m_bstrMessage, bstrDefaultMsg))
         hr = pPropBag-&gt;Write(L&quot;Message&quot;, &amp;CComVariant(m_bstrMessage));
   }

   if (SUCCEEDED(hr) &amp;&amp; fClearDirty)
      m_fDirty = FALSE;

   return hr;
}
</PRE>
</td></tr></table></p>

<P>In this code, we first define an <I>HRESULT</I> variable, 
<I>hr</I>, and initialize it to <I>E_FAIL.</I> <I>E_FAIL 
</I>is the value that will be returned from the 
<I>Save</I> method as the result of an error. Next, we check the 
<I>fSaveAllProperties</I> flag to see whether Internet 
Explorer wants us to save all the properties. If so, we save all the properties to the 
property bag by calling the <I>Write</I> method of the 
<I>IPropertyBag</I> interface. The <I>Write</I> method 
takes two input parameters&#8212;the name of the property, which is an OLE string, and the 
value of the property.</P>

<P>In this code, we have only one property to 
save&#8212;<I>Message</I>. So we pass the string 
&quot;<I>Message</I>&quot; for the first parameter, tacking on the 'L' specifier that converts the 
ANSI string to an OLE string. For the second parameter, we pass the value stored 
in <I>m_bstrMessage</I>. However, the <I>Write</I> method takes the address of a 
<I>VARIANT</I>, so we convert <I>m_bstrMessage</I> to a 
<I>VARIANT</I> using the <I>CComVariant</I> utility class and 
pass in a pointer to the object that's created.</P>

<P>If the <I>fSaveAllProperties</I> input parameter is 
<I>FALSE</I>, Internet Explorer is telling us that we don't need to save all the properties&#8212;just the ones that have changed. 
If this parameter is <I>TRUE</I>, we're going to save all the properties, no matter whether 
they have changed or not. So we check the value of the 
<I>m_fDirty</I> flag that indicates whether any of the properties have changed. If the value of 
<I>m_fDirty </I>is <I>TRUE</I>, we save only those properties that have changed. Because we have only one property, 
potentially we have only one property to save.</P>

<P>We then determine whether the property has changed by using the 
<I>wcscmp</I> API function, which compares the values of two wide-character strings and returns 
<I>0 </I>if they're the same or nonzero if they're different. We determine whether 
<I>m_bstrMessage </I>has changed by comparing it to the default message stored in 
<I>bstrDefaultMsg</I>. If <I>m_bstrMessage </I>has changed, we call the 
<I>Write </I>method of <I>IPropertyBag.</I></P>

<P>Finally, before returning from this method, we check the 
<I>fClearDirty</I> input parameter and check whether one of the previous calls to the 
<I>Write </I>method has succeeded. If <I>fClearDirty 
</I>is <I>TRUE</I> and one of the calls to the 
<I>Write</I> method has succeeded, we clear the dirty flag by setting 
<I>m_fDirty </I>to <I>FALSE</I>. Then we return from this 
method and pass the value of the <I>hr</I> local variable back to Internet Explorer.</P>

<A NAME="150"><H2>Writing Script for Your ATL Control</H2></A>

<P>Now it's time for the fun part&#8212;compiling and testing the ATL control. If you 
haven't already, go ahead and compile the control and fix any errors that might occur 
due to typos or whatnot.</P>

<P>To test the control, use the sample HTML page that Visual C++ created for 
you when you first created the control. Add some script to the page to call the 
<I>ChangeMessage</I> method, access the 
<I>Message</I> property, and handle events. The finished HTML 
page should look similar to the page shown in Figure 5-36. Also try changing the 
control and then printing it to ensure that the code you implemented to save the 
properties is functioning correctly.</P>

<P>
<A HREF="javascript:fullSize('F05ii36x.htm')"> <img src="images/F05ii36.JPG" width=404 height=343 border=0 ALT = "Click to view at full size."> </A>
</P><P>
<!-- caption --><B>Figure 5-36. </B> <I>Final ATL test page. </I><!-- /caption -->
</P>

<P>The HTML code for this page is shown in Listing 5-4. You can find the 
code listing on the companion CD in the folder \Samples\Chap05\AtlControl.</P>

<P><B>Listing 5-4.</B></P>

<P><table cellpadding=5 width="95%"><TR><TD>
<A NAME="151"><H3> AtlCtrl.htm</H3></A>
<PRE>&lt;HTML&gt;
&lt;HEAD&gt;
   &lt;TITLE&gt;ATL 3.0 test page for object AtlCtrl&lt;/TITLE&gt;

   &lt;SCRIPT LANGUAGE=&quot;VBScript&quot;&gt;
   Sub btnChange_onclick
      AtlCtrl.ChangeMessage Text1.Value
   End Sub
   Sub AtlCtrl_OnMessageChanged
      MsgBox &quot;Message Changed&quot;
   End Sub
   &lt;/SCRIPT&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
   &lt;OBJECT ID=&quot;AtlCtrl&quot; 
         CLASSID=&quot;CLSID:638B718E-AEF1-11D2-A9BA-444553540001&quot;&gt;
      &lt;PARAM NAME=&quot;Message&quot; VALUE=&quot;Hello, There!!&quot;&gt;
   &lt;/OBJECT&gt;

   &lt;P&gt;
   &lt;BR&gt;&lt;BR&gt;

   &lt;INPUT TYPE=TEXT ID=&quot;Text1&quot;&gt;
   &lt;BUTTON ID=&quot;btnChange&quot;&gt;Change Message&lt;/BUTTON&gt;
   &lt;P&gt;
   &lt;BUTTON onclick=&quot;alert(AtlCtrl.Message)&quot;&gt;Get Message&lt;/BUTTON&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</td></tr></table></p>


<P>
<div class="sidebar"><blockquote><p><B>What's Next?</B></p>
Now that you know how to create Visual Basic ActiveX controls and 
ATL ActiveX controls, we can move on to one of the greatest controls of all 
time: WebBrowser. This control and its interfaces allow you to access Internet 
Explorer and the DHTML Object Model from ActiveX controls on a Web page. So 
you can read or change the data from the Web page on which the control is 
residing. Also, the WebBrowser control allows you to add Web browsing to the 
Windows applications that you create in Visual Basic, Visual C++, or any 
COM-aware development tool. You can add rich content to the user interface or to the 
help system. You can even create your own Web browser application. In the 
<a href="ch06a.htm">next chapter</a>, we'll talk about how to do this and much more by using the 
WebBrowser control and Internet Explorer automation.</blockquote></div>
</P>


</BODY>
</HTML>





