<HTML>
<HEAD>
<link rel="STYLESHEET" type="text/css" href="Progie5.css">
<TITLE>The WebBrowser Control and Internet Explorer</TITLE>
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="ch06b.htm">[Previous]</A> <A HREF="ch06d.htm">[Next]</A><P>

<A NAME="157"><H1>The WebBrowser Control and Internet Explorer</H1></A>

<P>The WebBrowser control and Internet Explorer have a lot in common. You access the functionality of both by using the same COM interfaces. The objects that you use to host the control or automate the browser, however, are different. For example, when hosting the control, you'll work with the <I>WebBrowser</I> object. In Visual Basic, this object is simply named <I>WebBrowser</I>. In Visual C++ applications, you'll access the WebBrowser control by using the class ID <I>CLSID_WebBrowser</I>. Of course, if you're hosting the WebBrowser control in Visual Basic or in Visual C++ using the Microsoft Foundation Classes (MFC), you won't have to create the <I>WebBrowser </I>object manually. I'll show you how to host the WebBrowser control in Visual Basic and Visual C++ later in this chapter in the section &quot;<A HREF="ch06d.htm#162">Hosting the WebBrowser Control</A>.&quot;
</P>

<P>When automating Internet Explorer, you'll have to manually create the <I>InternetExplorer </I>object. In Visual Basic, this object is named <I>InternetExplorer</I>. In Visual C++, whether you're using MFC, ATL, or plain vanilla C++, you'll access the <I>InternetExplorer </I>object by using the class ID <I>CLSID_InternetExplorer</I>.</P>

<p><div class="note"><blockquote><b>NOTE</b><HR>
The class IDs <I>CLSID_WebBrowser </I>and <I>CLSID_InternetExplorer</I> are installed on your machine when you install Internet Explorer, but you can't use these names to reference the class IDs from a Visual C++ application unless you install the Internet Explorer headers and libraries from the MSDN Online Web Workshop. I'll show you how to use these headers and libraries later in this chapter in the section &quot;<A HREF="ch06d.htm#165">Using Visual C++</A>.&quot;</blockquote></div></p>


<P>Before I demonstrate how to host the WebBrowser control and automate 
Internet Explorer in both Visual Basic and MFC, I'll explain the different interfaces 
included with the WebBrowser control and Internet Explorer, and I'll cover the methods 
and properties that belong to each. Because most of their functionality is shared in a 
single interface&#8212;<I>IWebBrowser2</I>&#8212;I'll refer to the WebBrowser control and Internet Explorer simply as the WebBrowser.
</P>

<p><div class="sidebar"><blockquote><b>Compatibility with Earlier Versions</b>
<P>The Internet Explorer 5 version of the WebBrowser control is 100 percent 
compatible with earlier versions. So if you develop an application by using an 
earlier version of the WebBrowser control, the application will work correctly 
in Internet Explorer 5. But if you develop an application by using Internet 
Explorer 5, the application might not work in earlier versions. The 
application should work OK in Internet Explorer 4, but it probably won't work well 
in versions 3 and earlier.</P>

<P>For compatibility with the Internet Explorer version 3 of the WebBrowser control, an object named <I>WebBrowser_V1</I> is included with the WebBrowser control. (For C++ developers, this object is instantiated with <I>CLSID_WebBrowser_V1</I>.)<I> </I>Using the <I>WebBrowser_V1 </I>object is complicated. If you need to support version 3 of Internet Explorer, develop for the lowest common denominator; in other words, develop your application on a machine with Internet Explorer 3.<I>x </I>installed. This is the best way to ensure that your application is compatible with the version you need to support.</p>
</blockquote></div></p>


<A NAME="158"><H2>Interfaces</H2></A>

<P>The WebBrowser consists of four interfaces, three of which provide all its functionality. (The fourth interface, <I>DWebBrowserEvents2</I>, exists for events. I'll cover this interface in <a href="ch07a.htm">Chapter 7</a>.) Prior to Internet Explorer 4, only two interfaces existed&#8212;one for the WebBrowser control (<I>IWebBrowser</I>) and the other for the Internet Explorer object (<I>IWebBrowserApp</I>). <I>IWebBrowser</I> and <I>IWebBrowserApp</I> share a lot of the same functionality, so when expanding the functionality of the WebBrowser for Internet Explorer 4, the developers decided to create a third interface&#8212;<I>IWebBrowser2</I>&#8212;that derives from the other two. Combining the functionality of the <I>IWebBrowser</I> and <I>IWebBrowserApp</I> interfaces into a new interface with more functionality just made perfect sense. (The name of the resulting interface is different because COM specification requires you to create a new interface name and GUID if functionality is added or removed.) The hierarchy in Figure 6-2 illustrates the relationship among three of the four interfaces.</P>

<P>
<A HREF="javascript:fullSize('F06ii02x.htm')"> <img src="images/F06ii02.JPG" width=404 height=235 border="0" ALT = "Click to view at full size."> </A>
</P><P>
<B>Figure 6-2.</B> <I>Hierarchy of WebBrowser interfaces.</I> IWebBrowser<I> supplies the minimum functionality. A fourth interface, </I>DWebBrowserEvents2<I>, is not shown.</I>
</P>

<P>The following sections explain each interface in detail, including their 
methods and properties. I'll also discuss some differences between the WebBrowser 
control and Internet Explorer that commonly cause confusion among developers who 
reuse the control or automate the browser.</P>

<A NAME="159"><H3><I>IWebBrowser</I></H3></A>
<P><I>IWebBrowser </I>is the interface that originally represented only the WebBrowser 
control. This interface provides basic browsing functionality such as navigating to a 
Web page or moving backward and forward in the navigation history. As you can see 
from Figure 6-2, <I>IWebBrowser</I> is the base interface from which all the other 
WebBrowser interfaces are derived. <I>IWebBrowser </I>is implemented by the WebBrowser control, so all you have to do to add Web browsing to an application is use 
<I>IWebBrowser</I>'s<I> </I>methods and properties. It has eight methods and thirteen properties.</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>
In COM, the interface doesn't actually provide the implementation 
of the methods, properties, and so forth. An interface just defines the binary 
representation of an object. The interface must be implemented by an object 
such as the <I>WebBrowser</I> object or <I>InternetExplorer 
</I>object. For more details, refer to MSDN or any of the Microsoft Press COM books such as 
<I>Inside COM</I> by Dale Rogerson and <I>Inside 
OLE2</I> by Kraig Brockschmidt.</blockquote></div></p>


<P><b>Methods</b> Table 6-1 describes the eight <I>IWebBrowser </I>interface methods, which are listed in the order in which they are defined in the vtable of <I>IWebBrowser</I>. All eight methods are related to browsing the Web. Using these methods in your applications is easy, as I'll show you later in this section. For now, I'll discuss only those methods that you'll use most often or that require explanation.
</P>

<p><div class="sidebar"><blockquote><b>What Is vtable Order?</b>
<P>In COM, the order in which methods appear in an interface definition is 
referred to as vtable order. A vtable is a virtual function table that stores pointers to 
the actual implementations of the methods and properties defined by an interface.</P>
<P>Methods and properties of base class interfaces appear before the 
derived class interface's methods and properties in a vtable.</P>
</blockquote></div></p>

<P><b>Table 6-1.</b> IWebBrowser <I>Methods in Vtable Order</I></p>
<p><table cellpadding=5 width="95%">

<tr><th><i>Method</i></th><th><i>Description</i></th></tr>

<tr><td valign="top"><i>GoBack</i></td><td valign="top">Navigates to the previous item in the history list.</td></tr>

<tr><td valign="top"><i>GoForward</i></td>    
<td valign="top">Navigates to the next item in the history list.</td></tr>

<tr><td valign="top"><i>GoHome</i></td>     
<td valign="top">Navigates to the user's default home page. This home page is a URL that is set by the user in the Internet Explorer Options dialog box and is stored in the Registry.</td></tr>

<tr><td valign="top"><i>GoSearch</i></td>    
<td valign="top">Navigates to the user's default search page.</td></tr>

<tr><td valign="top"><i>Navigate</i></td>    
<td valign="top">Navigates to a URL or to a file.</td></tr>

<tr><td valign="top"><i>Refresh</i></td>  
<td valign="top">Refreshes the current Web page.</td></tr>

<tr><td valign="top"><i>Refresh2</i></td>   
<td valign="top">Works the same way as the Refresh method but allows you to choose the refresh level. The value of the refresh level that you specify comes from the <I>RefreshConstants</I> enumeration, which is defined in the ExDisp.h header file. (This header file is part of the Internet Explorer 5 header files that are available for download from the MSDN Online Web Workshop.) The different values you can specify are as follows:</td></tr>

<tr><td valign="top"></td><td valign="top"><i><b>REFRESH_NORMAL</b></i> Performs a lightweight refresh that doesn't send the HTTP <I>pragma:nocache</I> header to the server.</td></tr>

<tr><td valign="top"></td><td valign="top"><b><i>REFRESH_IFEXPIRED</i></b> Performs a lightweight refresh only if the page has expired.</td></tr>

<tr><td valign="top"></td><td valign="top"><b><i>REFRESH_CONTINUE</i></b> For internal use only. Don't use this value.</td></tr>

<tr><td valign="top"></td><td valign="top"><i><b>REFRESH_COMPLETELY</b></i> Performs a full refresh that includes sending the HTTP <I>pragma:nocache</I> header to the server for HTTP protocol URLs.</td></tr>

<tr><td valign="top"><i>Stop</i></td><td valign="top">Stops the current navigation.</td></tr>
</table></p>

<P>Whenever a user employs Internet Explorer or the WebBrowser control to 
navigate to Web pages, the WebBrowser keeps track of where that user has been 
so that the user can easily return to previously viewed pages. The <I>GoBack </I>and <I>GoForward </I>methods allow you to navigate backward and forward, respectively, in this 
navigation history. The <I>GoBack </I>and <I>GoForward </I>methods won't work in the following situations, however:</p>

<UL>
<P><LI>If you've loaded only one Web page into the WebBrowser control 
or Internet Explorer, the <I>GoBack</I> and <I>GoForward</I> methods have no effect because the history list doesn't currently contain any items before or after the current URL.</LI></P>

<P><LI>If you've navigated to multiple pages but have never gone back to 
them, the <I>GoBack </I>method will work but the <I>GoForward</I> method will have no effect because you are at the end of the history list.
</LI></P>

<P><LI>If you've navigated to multiple pages and then gone back to where 
you started, the <I>GoForward </I>method will work but the <I>GoBack </I>method will have no effect because you are currently at the beginning of the history list.
</LI></P>
</UL>

<P>Although the WebBrowser control provides the methods you need to 
navigate backward and forward in the history list, it doesn't give you direct access to URLs in the history list that are before or after the current item. Consequently, you can't find out where the user has been without actually navigating backward or forward in the history list using <I>GoBack </I>or <I>GoForward</I>. Once you've navigated backward or forward to the page in question, you can easily retrieve the URL of the current page by using a property that I'll discuss shortly&#8212;<I>LocationURL</I>.</P>

<P>Calling the <I>GoBack </I>and <I>GoForward </I>methods in Visual Basic or Visual C++ is easy. You use either the object that represents the WebBrowser control or Internet Explorer. For example, in Visual Basic you can call the methods like this:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
WebBrowser1.GoBack           ' Hosting WebBrowser control
InternetExplorer1.GoForward  ' Automating Internet Explorer object
</PRE>
</td></tr></table></p>

<P>Calling the same methods in Visual C++ is similar:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
m_webBrowser.GoBack();            // Hosting WebBrowser control
m_pInternetExplorer-&gt;GoForward(); // Automating Internet Explorer object
</PRE>
</td></tr></table></p>

<P>Although the <I>GoBack </I>and <I>GoForward </I>methods are quite important, <I>Navigate</I> is the most important method you'll ever use when hosting the WebBrowser control or automating Internet Explorer. <I>Navigate </I>allows you to navigate precisely to the Web page or file that you want. <I>Navigate</I> takes five parameters, or arguments, that allow you to specify the URL to navigate to and other information that defines how the navigation will occur. I'll explain these parameters in the order in which they appear in the parameter list.</P>

<P>The first parameter is the URL, which identifies the location and name of a Web page or file that you want to load. (The type of this parameter is <I>BSTR</I>.) The URL can be one of the standard URL protocol types you're used to, such as HTTP and FILE, or it can be the full path and name of a file on your system, such as C:\MyFile.htm.</P>

<p><div class="note"><blockquote><b>NOTE</b><HR>
If you specify the full path and name of a file on your system, 
the WebBrowser will convert this path to a standard URL by prepending the 
string that you specify like this: <I>file:///</I>. Notice the three forward slashes (///). 
Although only two forward slashes are used when specifying a URL, the WebBrowser 
will prepend the file protocol specifier and add three forward slashes to the file 
path that you specify. Knowing that the WebBrowser uses three forward slashes 
is important if you need to parse the URL string of the current Web page.</blockquote></div></p>


<P>By using the second parameter, <I>Flags</I>, you can dictate how or even where to load the specified URL. (The type of this parameter is a pointer to <I>VARIANT</I>.) The values for <I>Flags</I> come from an enumeration named <I>BrowserNavConstants</I>, which is defined in the ExDisp.h header file and contains six values, described in the following list. You can specify one or more of these values for the <I>Flags</I> parameter (some of which aren't currently implemented, mind you).</p>

<UL>
<P><LI><I>navOpenInNewWindow</I>. Causes a new window to open to display 
the URL. By default, this value will cause a new Internet Explorer browser 
window to open even if you are hosting the WebBrowser control in your 
application. I'll show you how to change this behavior in <a href="ch07a.htm">Chapter 7</a>.
</LI></P>
<P><LI><I>navNoHistory</I>. Specifies that the URL parameter shouldn't be added to 
the history list.
</LI></P>
<P><LI><I>navNoReadFromCache</I>. Not currently implemented.
</LI></P>
<P><LI><I>navNoWriteToCache</I>. Not currently implemented.
</LI></P>
<P><LI><I>navAllowAutoSearch</I>. If the URL you specify cannot be found, 
the AutoSearch facility of the WebBrowser will attempt to find the correct 
URL by navigating to common domains such as .com, .edu, and .org. If 
the AutoSearch fails, the URL will be passed to a search engine.
</LI></P>
<P><LI><I>navBrowserBar</I>. Loads the URL into the Explorer Bar, if possible. 
(You'll learn more about Explorer bars in <a href="ch10a.htm">Chapter 10</a>.)</LI></P>
</UL>


<P>The third parameter is <I>TargetFrameName</I>. It allows you to specify in which frame of the Web page the navigation should occur. (This parameter type is a pointer to a <I>VARIANT</I>.) This string can be a name that exists on the current Web page or a special value such as <I>_top</I> or <I>_search</I>. The <I>_top</I> value specifies that the URL should be loaded over the top of the current Web page and not in one of the frames that might exist on the current Web page. The <I>_search</I> value specifies that the Search band should be opened. (This value has effect only if you're automating Internet Explorer.) If the frame name you specify doesn't exist, a new Internet Explorer window will be opened.
</P>

<P>You can use the <I>PostData </I>parameter (the fourth parameter) to specify data 
to send to the server with an HTTP Post transaction. (The type of this parameter is 
a pointer to <I>VARIANT</I>.) The Post transaction is used to send data that has been 
gathered by an HTML form. If you don't specify any data for this parameter, the 
<I>Navigate </I>method will use the HTTP Get transaction. Also, if you don't specify an 
HTTP protocol URL (in other words, if you specify a FILE protocol URL), the 
<I>PostData </I>parameter will be ignored.</P>

<P>You can use the fifth parameter, <I>Headers</I>, to send HTTP header information to the server. (The type of this parameter is a pointer to <I>VARIANT</I>.) These headers are added to those that the WebBrowser control will normally send. As with the 
<I>PostData </I>parameter, if you don't specify an HTTP protocol URL for the first parameter, <I>Headers </I>will be ignored.</P>

<P>Calling the <I>Navigate </I>method is a little more difficult than calling 
<I>GoBack</I> or <I>GoForward</I>, but if you're navigating only to a URL and not passing any of the additional parameters, it's easy. For example, to navigate to Microsoft's home page by using Visual Basic, you can call <I>Navigate </I>like this:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
WebBrowser1.Navigate &quot;http://www.microsoft.com&quot;
</PRE>
</td></tr></table></p>

<P>The Visual Basic code to call <I>Navigate </I>is so easy because all parameters 
except the first one are optional. In contrast, in Visual C++ you can't exclude any of 
the parameters. If you want to navigate to Microsoft's home page by using Visual 
C++ without specifying values for one or more of the parameters other than the first 
one, you must pass in empty <I>VARIANT </I>structures. In an MFC application, you would 
call <I>Navigate</I> like this:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
COleVariant vtEmpty;
m_webBrowser.Navigate(_T(&quot;http://www.microsoft.com&quot;), &amp;vtEmpty, &amp;vtEmpty,
                 &amp;vtEmpty, &amp;vtEmpty);
</PRE>
</td></tr></table></p>

<P>This example demonstrates how to call <I>Navigate</I> when hosting the WebBrowser control in an MFC application. I passed the first parameter as a normal string instead of a <I>BSTR </I>because MFC provides a wrapper class for the WebBrowser control, and the first parameter for the <I>Navigate</I> method of this wrapper class is a <I>LPCTSTR</I>, which is a normal string. The other parameters of <I>Navigate</I> take pointers to <I>VARIANT </I>structures. If you don't want to specify any values for these parameters, don't just pass <I>NULL</I> to them&#8212;if you do, your application could crash. You must pass the address of an empty <I>VARIANT </I>structure. The preceding code used the <I>COleVariant </I>class, which is similar to the <I>CComVariant </I>class that you encountered in <a href="ch05a.htm">Chapter 5</a>. <I>COleVariant</I> simply wraps a <I>VARIANT </I>to make the <I>VARIANT </I>structure easier to use.</P>

<P><b>Properties</b> Now that you've seen all the methods of <I>IWebBrowser</I>, you probably want to see the properties. (Demanding, aren't we?) The <I>IWebBrowser</I> interface has thirteen properties, described in Table 6-2. I've listed these properties in the order in which they appear in the vtable of <I>IWebBrowser. </I>The properties in Table 6-2 appear in the vtable after all the methods of <I>IWebBrowser</I>,<I> </I>so if you want to know the entire vtable layout for the <I>IWebBrowser</I> interface, just combine Tables 6-1 and 6-2, adding the properties after the methods. (Of course, <I>IWebBrowser</I> inherits from <I>IDispatch </I>and <I>IUnknown</I>,<I> </I>and their methods appear first in the vtable.)</P>

<P><b>Table 6-2.</b> IWebBrowser <I>Properties in vtable Order</I></P>

<p><table cellpadding=5 width="95%">
<tr><th><i>Property</i></th><th><i>Description</i></th></tr>

<tr><td valign="top"><I>Application</I></td>     
<td valign="top">Returns the automation object (<I>IDispatch</I>) implemented in the application that is hosting the WebBrowser control, if the object is available. If an automation object isn't available in the host application, this property returns the automation object of the WebBrowser control.</td></tr>

<tr><td valign="top"><I>Parent</I></td><td valign="top">Returns the automation object 
(<I>IDispatch</I>) of the parent of the WebBrowser control, which is usually 
the container&#8212;for example, your host or the Internet 
Explorer window.</td></tr>

<tr><td valign="top"><I>Container</I></td>     
<td valign="top">Returns the automation object (<I>IDispatch</I>) of the container of the WebBrowser control. Usually, this value is the same one that is returned by the <I>Parent</I> property.</td></tr>

<tr><td valign="top"><I>Document</I></td>     
<td valign="top">Returns the automation object (<I>IDispatch</I>) for the active document. If HTML is currently being displayed in the WebBrowser, the <I>Document</I> property gives you access to the DHTML Object Model.</td></tr>

<tr><td valign="top"><I>TopLevelContainer</I></td>     
<td valign="top">Returns a Boolean value that indicates whether Internet Explorer is the top-level container of the WebBrowser control. In other words, returns <I>true 
</I>if Internet Explorer is the host application.</td></tr>

<tr><td valign="top"><I>Type</I></td>     
<td valign="top">Returns the type of the object that has been loaded by the WebBrowser control. For example, if the document loaded is an HTML document, <I>Type </I>returns <I>Microsoft HTML Document 5.0</I>. If the document is a Word document, <I>Type </I>returns <I>Microsoft Word Document</I>.</td></tr>

<tr><td valign="top"><I>Left</I></td>     
<td valign="top">Returns or sets the distance between the internal left edge of the WebBrowser control's window and the left edge of its container's window.</td></tr>

<tr><td valign="top"><I>Top</I></td>     
<td valign="top">Returns or sets the distance between the internal top edge of the WebBrowser control's window and the top edge of its container's window.</td></tr>

<tr><td valign="top"><I>Width</I></td>     
<td valign="top">Returns or sets the width (horizontal dimension), in pixels, of the WebBrowser's window.</td></tr>

<tr><td valign="top"><I>Height</I></td>     
<td valign="top">Returns or sets the height (vertical dimension), in pixels, of the WebBrowser's window.</td></tr>

<tr><td valign="top"><I>LocationName</I></td>     
<td valign="top">Returns a string that contains the name of the resource (in other words, the HTML page, the Word document, the folder, and so on) that the WebBrowser is currently displaying. If the resource is an HTML page, this string is the title of the page. If the resource is a file or folder, this string is the name of that file or a folder&#8212;for example, foo.doc for a Word document or Temp for the temp directory.</td></tr>

<tr><td valign="top"><I>LocationURL</I></td>     
<td valign="top">Returns the URL of the resource that the WebBrowser is currently displaying.</td></tr>

<tr><td valign="top"><I>Busy</I></td>     
<td valign="top">Returns a Boolean value that indicates whether the WebBrowser is currently loading a URL. If this property returns <I>true</I>,<I> </I>you can use the <I>Stop</I> method to cancel the navigation that is occurring.</td></tr>
</table>

<P>After reviewing Table 6-2, it should be pretty clear to you when to use the properties. A few of them, however, warrant more explanation. One property of <I>IWebBrowser</I> that you'll probably use quite a bit is <I>LocationURL</I>, which gives you the URL of the document that is currently loaded into the WebBrowser window. Obtaining the value of <I>LocationURL</I> from Visual Basic is easy:

</P><P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
Dim strLocation
strLocation = WebBrowser1.LocationURL
</PRE>
</td></tr></table></p>

<P>When you're hosting the WebBrowser control in Visual C++ with MFC, the MFC wrapper class makes accessing <I>LocationURL</I> just as easy. You simply call the <I>GetLocationURL</I> method, which returns a <I>CString</I> object. If you want to access <I>LocationURL</I> when automating Internet Explorer or when hosting the WebBrowser control in a C++ application that's not built by using MFC, you must call a method that represents <I>LocationURL</I> and pass to this method a pointer to a <I>BSTR</I>. The <I>BSTR</I> that you pass will contain the value of the property upon returning from this method. Here's how to access the <I>LocationURL</I> property in C++:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
BSTR bstrURL;
m_pInternetExplorer-&gt;get_LocationURL(&amp;bstrURL);
</PRE>
</td></tr></table></p>

<p><div class="note"><blockquote><b>NOTE</b><HR>
When accessing the <I>LocationURL</I> property from C++ (other than by using the MFC wrapper class), you call a method named <I>get_LocationURL</I>. In COM, properties are typically accessed via functions that prepend either <I>put_</I> or <I>get_ </I>to their names, depending on whether you're setting or retrieving the property. When setting a property, you call the <I>put_</I> method. When reading a property, you call the <I>get_</I> method.</blockquote></div></p>


<P>The most important property of <I>IWebBrowser </I>is the <I>Document </I>property, which lets you access the document that is being displayed in the WebBrowser window. If the document is an HTML document, once you get access to the document using the <I>Document</I> property, you can retrieve or change the document's contents by using the DHTML Object Model.</P>

<p><div class="note"><blockquote><b>NOTE</b><HR>
The <I>Document</I> property returns an automation object (<I>IDispatch)</I> that represents the document being displayed. If the document being displayed is an HTML document, you can query the automation object for an interface of the <I>HTMLDocument</I> object and use it to access the DHTML Object Model. I'll show you how this is done in Visual Basic and Visual C++ in <a href="ch08a.htm">Chapter 8</a>.</blockquote></div></p>

<P>Accessing the <I>Document</I> property in Visual Basic is quite easy. After declaring a variable (for example, <I>HtmlDoc</I>), just set the variable to the value returned by the <I>Document</I> property:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
Set HtmlDoc = WebBrowser1.Document
</PRE>
</td></tr></table></p>

</P><P>Accessing the <I>Document</I> property in an MFC application hosting the WebBrowser control is just as easy. Call the <I>GetDocument</I> method of the MFC wrapper class:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
IDispatch* pDisp;
pDisp = m_webBrowser.GetDocument();
</PRE>
</td></tr></table></p>

<P><I>GetDocument </I>returns a pointer to the 
<I>IDispatch</I> interface that represents the document. If 
<I>GetDocument </I>fails, the object returned will be equal to 
<I>NULL</I>.</P>

<P>In a non-MFC C++ application that is hosting the WebBrowser control or in any C++ application that is automating Internet Explorer, you access the <I>Document</I> property just like any other COM method&#8212;by prepending the name of the property with <I>get_</I>. (Note that this property is read-only, so there is no <I>put_ </I>method for it.) When calling the <I>get_</I> method for the <I>Document </I>property, you pass in the address of a pointer to an <I>IDispatch</I> interface that will be set to the <I>IDispatch</I> interface of the document. Here's how you would obtain this property from a non-MFC application:

</P><P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
IDispatch* pDisp;
HRESULT hr = m_pInternetExplorer-&gt;get_Document(&amp;pDisp);
</PRE>
</td></tr></table></p>

<P>When using this code, you can use the SUCCEEDED macro, which is part of the Win32 API, to determine whether the call to <I>get_Document</I> succeeded. You must ensure that <I>get_Document</I> succeeded before trying to access the <I>IDispatch</I> interface of the document.</P>

<p><div class="note"><blockquote><b>NOTE</b><HR>
You must wait for the <I>DocumentComplete</I> event to fire before you can safely access the document. If you access the <I>Document</I> property before this event has fired, you might experience undesirable results. I'll discuss the <I>DocumentComplete</I> event further in <a href="ch07a.htm">Chapter 7</a>.
</blockquote></div></p>

<A NAME="160"><H3><I>IWebBrowserApp</I></H3></A>
<P>The <I>IWebBrowserApp</I> interface originally represented only Internet Explorer. 
Typically, you would create an instance of Internet Explorer using the 
<I>InternetExplorer</I> object. Then you controlled this instance by using the 
<I>IWebBrowserApp</I> interface. (You can still control this instance by using 
<I>IWebBrowserApp </I>today, but you will 
typically use <I>IWebBrowser2</I> instead, as I'll explain shortly.) The 
<I>IWebBrowserApp</I> interface inherits from 
<I>IWebBrowser</I>, so<I> </I>it provides all the functionality of the 
<I>IWebBrowser </I>interface along with its own.
</P>

<P>Because <I>IWebBrowserApp </I>represents an instance of the Internet Explorer 
window, its methods and properties typically allow you to control the user 
interface aspects of the browser window. These methods and properties aren't included in 
the <I>IWebBrowser </I>interface that represents the WebBrowser control: the application 
that is hosting the control is responsible for providing user interface aspects such as 
status bars, toolbars, and menu bars. The WebBrowser control is used only to load 
and display Web pages and other types of files.
</P>

<P><I>IWebBrowserApp</I> has four methods and 10 properties. As with the 
<I>IWebBrowser</I> interface, in the vtable the methods are listed first, followed by the properties.
</P>

<P><b>Methods</b> The methods of the <I>IWebBrowserApp </I>interface are pretty straightforward, as you can see in Table 6-3, but two warrant further discussion: <I>GetProperty</I> and <I>PutProperty</I>. These methods allow you to store a property in the Internet Explorer property bag so that you can retrieve it later. You'll typically want to do this to store some state information or data from one Web page to the next. (In fact, you can even use these methods when hosting the WebBrowser control by using the <I>IWebBrowser2</I> interface.)</P>

<P><b>Table 6-3.</b> IWebBrowserApp <I>Methods in vtable Order</I></p>

<p><table cellpadding=5 width="95%">

<tr><th><i>Method</i></th><th><i>Description</i></th></tr>

<tr><td valign="top"><I>Quit</I></td><td valign="top">Forces the Internet Explorer window to close. In other words, it shuts down the instance of Internet Explorer that you are automating.</td></tr>

<tr><td valign="top"><I>ClientToWindow</I></td><td valign="top">Converts the client coordinates of a point to window coordinates. Client coordinates are relative to the upper left corner of the client area, whereas window coordinates are relative to the upper left corner of the window.</td></tr>

<tr><td valign="top"><I>PutProperty</I></td><td valign="top">Stores a property in the Internet Explorer property bag, which can be retrieved at a later time by using <I>GetProperty</I>.</td></tr>

<tr><td valign="top"><I>GetProperty</I></td>     
<td valign="top">Retrieves a property that was previously stored in the Internet Explorer property bag by using <I>PutProperty</I>.</td></tr>
</table></p>

<P>If you read <a href="ch05a.htm">Chapter 5</a>, you're already familiar with the Internet Explorer property bag. Storing a property in the property bag is as easy as calling the <I>PutProperty</I> method and passing it the property's name and value. Retrieving the property is as easy as calling the <I>GetProperty</I> method and passing it the name of the property you want to retrieve. The value of that property will be returned if it exists in the property bag.
</P>

<P>Calling the methods in Table 6-3 in Visual Basic is pretty simple. The following Visual Basic code saves the <I>CurrentPicture</I> property and then retrieves it. (In this next bit of code, <I>InternetExplorer1</I> is an <I>InternetExplorer</I> object that you declare somewhere in your code.)
</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
InternetExplorer1.PutProperty &quot;CurrentPicture&quot;, 10
InternetExplorer1.GetProperty(&quot;CurrentPicture&quot;)
</PRE>
</td></tr></table></p>

<P>Calling the <I>PutProperty</I> and <I>GetProperty</I> methods in Visual C++ is just as easy, but calling the <I>PutProperty</I> method returns an <I>HRESULT </I>instead of the value of the property. As with most COM methods, when a value is returned from a method, that value is placed in a variable that is passed to the method. Here's a Visual C++ code example that shows how to use the <I>PutProperty</I> and <I>GetProperty</I> methods:

</P><P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
CSomeClass::PutGetProperty(VARIANT vtCurrentValue, VARIANT* vtNewValue)
{
   HRESULT hr;
   hr = m_pInternetExplorer-&gt;PutProperty(L&quot;CurrentPicture&quot;,
                               vtCurrentValue);

   if (SUCCEEDED(hr))
   {
     // Notice that vtNewValue is already a pointer, so you
     // don't have to pass the address to GetProperty.
     //
     hr = m_pInternetExplorer-&gt;GetProperty(L&quot;CurrentPicture&quot;, 
                                 vtNewValue);
   }

   return hr;
}
</PRE>
</td></tr></table></p>

<P>The <I>PutGetProperty</I> method takes a 
<I>VARIANT</I> that is the current value of the property and a pointer to a 
<I>VARIANT</I> that will receive the value of the property 
retrieved from the property bag. Then the 
<I>PutProperty</I> method is called to store the 
<I>CurrentPicture</I> property in Internet Explorer's property bag. If that call succeeds, 
the <I>GetProperty</I> method retrieves the value that was just stored. Finally, the 
<I>HRESULT</I> that was returned from calls to the 
<I>PutProperty </I>and <I>GetProperty</I> methods is returned. 
The <I>PutGetProperty</I> method isn't extremely useful, but it does demonstrate how to 
use the <I>PutProperty </I>and <I>GetProperty</I> methods.</p>


<p><b>Properties</b> The <I>IWebBrowserApp </I>interface has 10 properties. Short descriptions of these properties are listed in vtable order in Table 6-4. To determine the entire vtable order for <I>IWebBrowserApp</I>,<I> </I>append the properties to the methods. (<I>IWebBrowserApp</I>'s vtable also includes <I>IWebBrowser</I>'s vtable, because <I>IWebBrowserApp </I>inherits from <I>IWebBrowser</I>. <I>IWebBrowser</I>'s methods and properties appear before <I>IWebBrowserApp</I>'s methods and properties in the vtable.)</p>

<P><b>Table 6-4.</b> IWebBrowserApp <i>Properties in vtable Order</i></P>
<p><table cellpadding=5 width="95%">

<tr><th><i>Property</i></th><th><i>Description</i></th></tr>

<tr><td valign="top"><I>Name</I></td>     
<td valign="top">Returns the name of the object. (For example, when 
automating Internet Explorer, the <I>Name</I> property returns 
<I>Microsoft Internet Explorer</I>.)</td></tr>

<tr><td valign="top"><I>HWND</I></td><td valign="top">Returns the handle of the Internet Explorer main window.</td></tr>

<tr><td valign="top"><I>FullName</I></td>     
<td valign="top">Returns the full path of the Internet Explorer executable file (iexplore.exe).</td></tr>

<tr><td valign="top"><I>Path</I></td>     
<td valign="top">Returns the full path of the Internet Explorer application.</td></tr>

<tr><td valign="top"><I>Visible</I></td>     
<td valign="top">Retrieves or sets the visibility of the Internet Explorer window. (In other words, you can use this property to determine or control whether Internet Explorer is visible or hidden.)</td></tr>

<tr><td valign="top"><I>StatusBar</I></td>     
<td valign="top">Shows or hides the Internet Explorer status bar. This 
property can also be used to determine the current state of the 
status bar&#8212;visible or hidden.</td></tr>

<tr><td valign="top"><I>StatusText</I></td>     
<td valign="top">Sets or retrieves the text that is shown in the Internet Explorer status bar.</td></tr>

<tr><td valign="top"><I>ToolBar</I></td>     
<td valign="top">Shows or hides the Internet Explorer toolbar. This property 
can also be used to determine the current state of the 
toolbar&#8212;visible or hidden.</td></tr>

<tr><td valign="top"><I>MenuBar</I></td>     
<td valign="top">Shows or hides the Internet Explorer menu bar. This property can also be used to determine the current state of the menu bar&#8212;visible or hidden.</td></tr>

<tr><td valign="top"><I>FullScreen</I></td>     
<td valign="top">Sets or retrieves a value that indicates whether Internet Explorer is currently being displayed in FullScreen mode. In FullScreen mode, Internet Explorer takes up the entire screen.</td></tr>
</table></p>

<P>The properties listed in Table 6-4 are straightforward and easy to use. For 
example, if you wanted to retrieve the text that is stored in the Internet Explorer 
status bar from your Visual Basic application, you would use this code:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
Dim strStatusText
strStatusText = InternetExplorer1.StatusText
</PRE>
</td></tr></table></p>

<P>You retrieve the status text in a Visual C++ application in a similar 
manner, especially if you are hosting the WebBrowser control using the MFC wrapper 
class. The following C++ code retrieves the status text for an application that is 
automating Internet Explorer:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
BSTR bstrStatusText;
HRESULT hr = m_pInternetExplorer-&gt;get_StatusText(&amp;bstrStatusText);
</PRE>
</td></tr></table></p>

<A NAME="161"><H3><I>IWebBrowser2</I></H3></A>
<P>Because of the COM rule that all interfaces are immutable (they can never 
change), to add new functionality to a COM interface, you must create a new interface. 
This new interface can inherit from other interfaces to extend their functionality. 
For example, when the need arose to add functionality to the WebBrowser and 
Internet Explorer interfaces, the developers were required to create a new 
interface: <I>IWebBrowser2</I>.</P>

<P>As mentioned earlier, <I>IWebBrowser2 </I>inherits from both <I>IWebBrowser </I>and <I>IWebBrowserApp</I>,<I> </I>plus it provides functionality that isn't included in either.<I> </I>So you should use the <I>IWebBrowser2</I> interface for all interaction with either the WebBrowser control or Internet Explorer.</P>

<P>The <I>IWebBrowser2 </I>interface has four methods and eight properties. As with 
the <I>IWebBrowser</I> and <I>IWebBrowserApp</I> interfaces, the properties follow the methods in <I>IWebBrowser2</I>'s vtable.</P>

<p><div class="note"><blockquote><b>NOTE</b><HR>
<I>IWebBrowser2</I>'s vtable contains all <I>IWebBrowser2's </I>methods and properties, which include the methods and properties of <I>IWebBrowserApp</I>, <I>IWebBrowser</I>, and any interfaces from which they derive.
</blockquote></div></p>

<P><b>Methods</b> The four methods of the <I>IWebBrowser2</I> interface are briefly 
described, in vtable order, in Table 6-5.</P>

<P>Probably one of the most widely used <I>IWebBrowser2 </I>interface methods is <I>ExecWB</I>. It provides a wrapper around the <I>Exec </I>method of the <I>IOleCommandTarget</I> interface that is implemented by the WebBrowser. Before the <I>ExecWB </I>method was created, you couldn't directly call <I>IOleCommandTarget::Exec </I>from Visual Basic, because Visual Basic cannot access the <I>IOleCommandTarget</I> interface and accordingly cannot use the method of this interface directly. The <I>IOleCommandTarget::Exec </I>method was used a lot in the past, so the WebBrowser developers decided to create <I>ExecWB</I> to make things easier.</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>In object-oriented programming languages, an expression such as <I>IOleCommandTarget::Exec </I>indicates that the <I>Exec</I> method is a member of the <I>IOleCommandTarget </I>interface. Any method or property of a class or interface can be represented in this way.
</blockquote></div></p>

<P><b>Table 6-5.</b> IWebBrowser2 <I>Methods in Vtable Order</I></p>

<p><table cellpadding=5 width="95%">

<tr><th><i>Method</i></th><th><i>Description</i></th></tr>

<tr><td valign="top"><I>Navigate2</I></td><td valign="top">Functions basically the same as the <I>Navigate</I> method of <I>IWebBrowser </I>except that <I>Navigate2</I> allows you to navigate to a location that might not be expressed as a URL, such as a Windows shell folder. (A Windows shell folder is represented by a pointer to an item identifier list, 
or PIDL, in the Windows shell namespace.)</td></tr>

<tr><td valign="top"><I>QueryStatusWB</I></td>     
<td valign="top">Works as a wrapper function for the <I>QueryStatus</I> method of the <I>IOleCommandTarget </I>interface implemented in the WebBrowser.</td></tr>

<tr><td valign="top"><I>ExecWB</I></td>     
<td valign="top">Works as a wrapper function for the <I>Exec </I>method of the <I>IOleCommandTarget </I>interface implemented in the WebBrowser.</td></tr>

<tr><td valign="top"><I>ShowBrowserBar</I></td>     
<td valign="top">Shows or hides a specific browser bar. (I'll discuss browser bars further in <a href="ch10a.htm">Chapter 10</a>.) This method applies only to the <I>InternetExplorer</I> object.</td></tr>
</table></p>

<P>Why on earth would you want to call the <I>ExecWB</I> method, anyway? Because it allows you to access functionality (via <I>IOleCommandTarget::Exec</I>) that isn't exposed by the WebBrowser interfaces. You're probably wondering why the developers didn't just implement methods and properties for this extra functionality. Remember that COM interfaces are immutable. Once the vtable of an interface is published, the interface can't be changed. So you can't add functionality without creating a new interface.</P>

<P>The <I>ExecWB</I> method allows WebBrowser developers to add functionality 
without creating new interfaces. Plus, that which is exposed by the WebBrowser 
via <I>ExecWB</I> typically consists of functionality that isn't used often, such as invoking the Save As dialog box for the Web page or zooming the content on the page. The 
way <I>ExecWB</I> works is that you pass it a command ID and any parameters that are 
necessary for the command you want to invoke. Far too many command IDs exist to 
list them all here. However, they're included in the <I>OLECMDID</I> enumeration in the DocObj.h header file.</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>Make sure you're using the latest DocObj.h header file for Internet Explorer 5. All the headers and libraries can be downloaded from the &quot;Downloads/Samples&quot; section of the MSDN Online Web Workshop:<a href="http://msdn.microsoft.com/workshop" target="_window2"> <I>http://msdn.microsoft.com/workshop</I></a>. Incidentally, you need to download and install these headers and libraries if you intend to compile the Visual C++ examples in this and later chapters.</blockquote></div></p>

<P>As an example, suppose you want to zoom the contents of a Web page. 
Internet Explorer enables you to change the size of the text on a Web page from 
smallest<I> </I>to largest by using the View menu's Text Size submenu. The 
<I>ExecWB</I> method exposes functionality that allows you to change the size of the text displayed in the 
browser. For the Zoom command, you can specify the values 
<I>0</I>, <I>1</I>, <I>2</I>, <I>3</I>, or 
<I>4</I>, where <I>0 </I>is the smallest and <I>4 
</I>is the largest. For example, the following code changes the zoom 
size to the largest (<I>4</I>) for a Visual Basic application hosting the WebBrowser control:

</P><P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
WebBrowser1.ExecWB OLECMDID_ZOOM, OLECMDEXECOPT_DONTPROMPTUSER, _
                   CLng(4), Null
</PRE>
</td></tr></table></p>

<P>In this code, I call the <I>ExecWB</I> method, passing it 
<I>OLECMDID_ZOOM</I> constant for the first parameter. This constant specifies that the zoom operation should be executed. The second parameter that is passed in is a constant that tells <I>ExecWB</I> not to prompt the user. Alternatively, you could prompt the user by specifying <I>OLECMDEXECOPT_PROMPTUSER</I>. (These constants&#8212;along with a few more&#8212;are included in the <I>OLECMDEXECOPT</I> enumeration in DocObj.h.)</p>
<p>The third parameter is an input parameter that specifies the size of the text you want to set. I want to make the text as large as possible, so I specify <I>4</I>. Note that I wrap the value in a call to the Visual Basic <I>CLng </I>function, which converts the value that I specify to a variant&#8212;the required type of this input value. The final parameter is an output parameter that contains any return values. Because return values aren't required in this case, I pass a value of <I>Null</I>.</p>

<p><div class="note"><blockquote><b>NOTE</b><HR>
The <I>OLECMDID </I>and <I>OLECMDEXECOPT </I>enumerations are included in the type library for the WebBrowser control. Therefore, you won't need to define constants for their values in your Visual Basic project. The companion CD includes a sample Visual Basic application named VBZoom that demonstrates the use of <I>ExecWB</I> with <I>OLECMDID_ZOOM, </I>which you can find in the folder \Samples\Chap06\VBZoom.
</blockquote></div></p>

<p><div class="sidebar"><blockquote><b>Retrieving the Current Zoom Value</b>
<P>If you want to retrieve the current zoom value, you can call <I>ExecWB</I> with the <I>OLECMDID_ZOOM </I>command ID, passing <I>Null </I>for the third parameter and a variant variable for the fourth. Upon returningfrom <I>ExecWB</I>,<I> </I>the variable will contain the current zoom value. Here's the VisualBasic code to retrieve the current zoom value:</P>

<P><table cellpadding=5>
<TR><TD>
<PRE>
Dim range as Variant
WebBrowser1.ExecWB OLECMDID_ZOOM, OLECMDEXECOPT_DONTPROMPTUSER, _
                   Null, range
</PRE>
</td></tr></table></p>
</blockquote></div></p>

<P><b>Properties</b> The <I>IWebBrowser2 </I>interface has eight properties. (Table 6-6 describes them in vtable order.) These properties are pretty straightforward, so I'll explain only one of them&#8212;<I>AddressBar</I>.</p>

<p><b>Table 6-6.</b> IWebBrowser2 <I>Properties in Vtable Order</I></p>

<p><table cellpadding=5 width="95%">

<tr><th><i>Property</i></th><th><i>Description</i></th></tr>

<tr><td valign="top"><I>ReadyState</I></td>     
<td valign="top">Returns the ready state of the WebBrowser (in other words, it indicates whether the document is finished loading). Although you can use the <I>ReadyState</I> property, using the <I>DocumentComplete</I> event to determine whether the document is completely finished loading (that is, all components and the HTML are loaded) is better. (You'll learn how to use <I>DocumentComplete </I>in <a href="ch07a.htm">Chapter 7</a>.)</td></tr>

<tr><td valign="top"><I>Offline</I></td>     
<td valign="top">Returns or sets the value that indicates whether the WebBrowser is operating in offline mode.</td></tr>

<tr><td valign="top"><I>Silent</I></td>     
<td valign="top">Returns or sets the value that indicates whether the WebBrowser is operating in silent mode. If it is, no dialog boxes will be displayed.</td></tr>

<tr><td valign="top"><I>RegisterAsBrowser</I></td><td valign="top">Retrieves or sets the value that indicates whether the WebBrowser is registered as the top-level browser.</td></tr>

<tr><td valign="top"><I>RegisterAsDropTarget</I></td>     
<td valign="top">Retrieves or sets the value that indicates whether 
the WebBrowser is registered as a drop target for 
navigation. If the WebBrowser is registered as a 
drop target, users will be able to drag and drop links 
into the WebBrowser control that you're hosting or 
into the Internet Explorer window.</td></tr>

<tr><td valign="top"><I>TheaterMode</I></td>     
<td valign="top">Retrieves or sets the value that indicates whether Internet Explorer is in theater or normal window mode. In theater mode, Internet Explorer takes up the entire screen like in FullScreen mode, but it also has a minimal set of buttons and other user interface elements. (This property applies only to the <I>InternetExplorer</I> object.)</td></tr>

<tr><td valign="top"><I>AddressBar</I></td>     
<td valign="top">Shows or hides the Internet Explorer address bar. (This property applies only to the 
<I>InternetExplorer</I> object.)</td></tr>

<tr><td valign="top"><I>Resizable</I></td>     
<td valign="top">Returns or sets the value that indicates whether Internet Explorer can be resized. Using this property, you can prevent the user from changing the size of the Internet Explorer window. (This property applies only to the <I>InternetExplorer</I> object.)</td></tr>
</table></p>

<p><div class="sidebar"><blockquote>
<b>WebBrowser Control and Internet Explorer Differences</b>

<P>As you've seen, whether you're hosting the WebBrowser control or automating Internet Explorer, you use one interface&#8212;<I>IWebBrowser2</I>&#8212;which includes all the methods of <I>IWebBrowser</I> and <I>IWebBrowserApp</I> and a lot more. Some methods and properties of <I>IWebBrowser2</I>, however, don't work unless you're automating Internet Explorer.</P>

<P>For example, if you're hosting the WebBrowser control, user interface features such as the address bar, menu bar, status bar, and toolbar are implemented by your application and not by the WebBrowser control. So properties of <I>IWebBrowser2 </I>such as <I>AddressBar</I>,<I> MenuBar</I>,<I> StatusBar</I>,<I> </I>and <I>ToolBar</I> aren't functional when hosting the WebBrowser control. Because you've created the container application yourself, you should be able to control the user interface features without having to rely on these properties. The properties exist to help you easily communicate with a running instance of Internet Explorer. Some methods and properties apply only to Internet Explorer: these methods include <I>ShowBrowserBar</I> and <I>ClientToWindow</I>, and these properties include <I>FullScreen</I>, <I>MenuBar</I>, <I>Resizable</I>, <I>AddressBar</I>, <I>StatusBar</I>, <I>StatusText</I>, <I>TheaterMode</I>, and <I>ToolBar</I>.</P>
</blockquote></div></p>


<P>The <I>AddressBar</I> property allows you to show or hide the Internet 
Explorer address bar: the toolbar that contains a text box in which you can enter a URL 
that you want to navigate to in the browser. Being able to show or hide the address 
bar enables you to completely control your user's navigation experience&#8212;you 
already have properties that allow you to show or hide the other user interface features.</P>

<P>Controlling the user's navigation experience is often helpful if you want 
to provide Internet browsing for your corporate intranet or for an elementary 
school, for example. In these environments, you would want to control the user's 
navigation so that certain inappropriate Web sites weren't available. You could create 
your own browser by using the WebBrowser control, which I'll show you how to do 
later. But if you don't have the time or resources to do so, you could automate 
Internet Explorer instead. Automating Internet Explorer allows you to turn off all user 
interface features that enable a user to navigate to a Web page, such as the menu 
bar, toolbar, and address bar. Then you can create a number of Web pages that 
provide links to which the user can navigate.</P>

<P>Turning off the user interface features is easy. To hide the menu bar, use the <I>MenuBar</I> property. To hide the toolbar, use the <I>ToolBar</I> property. To hide the address bar, use the <I>AddressBar </I>property. To hide each of these user interface features, simply set their associated properties to <I>False</I>. For example, here's how you would turn off the menu bar, toolbar, and address bar in a Visual Basic application that is automating Internet Explorer:</P>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
InternetExplorer1.AddressBar = False
InternetExplorer1.ToolBar = False
InternetExplorer1.MenuBar = False
</PRE>
</td></tr></table></p>

</BODY>
</HTML>


