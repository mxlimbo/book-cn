<HTML>
<head>
<link rel="STYLESHEET" type="text/css" href="Progie5.css">
<TITLE>Creating Explorer Bars and Desk Bands Using C++ and COM</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch10c.htm">[Previous]</A> <A HREF="ch10e.htm">[Next]</A><P>

<A NAME="232"><H1>Creating Explorer Bars and Desk Bands Using C++ and COM</H1></A>

<P>Creating Explorer Bars and Desk bands by using C++ and COM is a bit more 
involved than creating them by using DHTML and script, as you might imagine. However, 
C++ and COM give you a lot more power and flexibility. For example, you might 
want to know when users are navigating in the main Internet Explorer window. To 
achieve this, you would have to sink events for the WebBrowser of the main Internet 
Explorer window, which is possible only when using C++.</P>

<P>When you use C++ and COM to create an Explorer band, Comm band, or 
Desk band, the process is almost the same for each type of band object: you create a 
DLL that implements a few required interfaces and possibly other optional interfaces. 
The main difference is the way you register the band object. As in the previous 
section, when you create keys in the Registry to build Explorer Bars, the value of the 
CATID that you specify beneath the <I>Implemented 
Categories</I> key determines the type of band object.</P>

<P><DIV CLASS="NOTE"><BLOCKQUOTE><B>NOTE</B><HR>
Remember that the term band object encompasses both Explorer 
Bars and Desk bands.
</BLOCKQUOTE></DIV></P>

<P>When registering your band object, you can choose from the three CATIDs 
listed in the following table to specify which type of band object you want to create. 
The values in the table can be used when registering your band object. (These 
constants are defined in the Internet Explorer 5 
shlguid.h header file, which you can download from the MSDN Online Web Workshop.)</P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR>
<TH><i>CATID Constant</i></TH>
<TH><i>Value</i></TH>
<TH><i>Description</i></TH>
</TR><TR>
<TD VALIGN="TOP">CATID_InfoBand</TD>
<TD VALIGN="TOP">{00021493-0000-0000-C000-000000000046}</TD>
<TD VALIGN="TOP">Explorer band</TD>
</TR><TR>
<TD VALIGN="TOP">CATID_CommBand</TD>
<TD VALIGN="TOP">{00021494-0000-0000-C000-000000000046}</TD>
<TD VALIGN="TOP">Comm band</TD>
</TR><TR>
<TD VALIGN="TOP">CATID_DeskBand</TD>
<TD VALIGN="TOP">{00021492-0000-0000-C000-000000000046}</TD>
<TD VALIGN="TOP">Desk band</TD>
</TR></TABLE></P>

<A NAME="233"><H2>Implementing the Required DLL Functions </H2></A>

<P>Because a band object is a DLL, you must implement a few DLL functions: 
<I>DllMain</I>,<I> DllGetClassObject</I>,<I> 
DllCanUnloadNow</I>, and <I>DllRegisterServer</I>. To allow your users 
to easily unregister your band object by using Regsvr32.exe, you should also 
implement <I>DllUnregisterServer</I>. You implement 
<I>DllMain</I>,<I> DllGetClassObject</I>, and<I> 
DllCanUnloadNow</I> in the same way you would implement them with any COM DLL, so we'll look at 
only the two that are important for band objects: 
<I>DllRegisterServer</I> and 
<I>DllUnregisterServer</I>.</P>


<P>Because you already know which Registry keys need to be created for 
your band object, you should easily be able to understand the code that I will show 
you. When implementing 
<I>DllRegisterServer</I>, you must call the necessary Registry 
functions to create the keys discussed earlier in the section &quot;<A HREF="ch10c.htm#231">Creating Explorer Bars Using DHTML and Script</A>&quot; including registering the CLSID for your band object and 
the component category.</P>
<P>The following code is taken from the WebBand example and shows how 
you might want to implement 
<I>DllRegisterServer</I>:</P>
<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>STDAPI DllRegisterServer(void)
{
   // Register the Explorer Bar object.
   if (!RegisterServer(CLSID_WBExplorerBar, TEXT(&quot;&amp;WebBand Search&quot;)))
      return SELFREG_E_CLASS;

   // Register the Component Categories for the Explorer Bar object.
   if (!RegisterComCat(CLSID_WBExplorerBar, CATID_InfoBand))
      return SELFREG_E_CLASS;

   return S_OK;
}
</PRE>
</TD></TR></TABLE></P>

<P><DIV CLASS="SIDEBAR"><BLOCKQUOTE>
<P><B>WebBand Example </B></P>

<P>Throughout the rest of this chapter, we'll examine the code from the 
WebBand application included on the companion CD in the folder 
\Samples\Chap10\ WebBand. WebBand, shown in Figure 10-11, is an example of 
a vertical Explorer band that hosts the WebBrowser control. Although 
WebBand demonstrates how to create an Explorer band, the concepts apply to Comm 
and Desk bands as well. (WebBand is similar to the Internet Explorer 5 Search band.)</P>
<P>To use WebBand, copy the WebBand.htm and Results.htm files from 
the companion CD to the root directory for your Internet server (for 
example, C:\InetPub\wwwroot). If you want to place these files in a different 
directory, you must change the definition of 
<I>STARTUP_URL</I> in the WBExplorerBar.cpp file to point to the new location.</P>
<P>After compiling and registering WebBand.dll, start Internet Explorer 5, 
and choose WebBand Search from the View/Explorer Bar menu. WebBand will 
load WebBand.htm, which contains a form with an edit box, Submit button, and 
a couple of links to other Web pages.</P>
<P>When you type some text in the edit box and click the Submit button, 
the Results.htm file will be loaded into the current window. If you click one of 
the links on the WebBand.htm Web page, the URL will be loaded into the 
main Internet Explorer window.</P>
</BLOCKQUOTE></DIV></P>

<P>This code consolidates the Registry function calls into two private 
functions: <I>RegisterServer </I>and 
<I>RegisterComCat</I>. These functions take care of registering the 
CLSID and component categories for the WebBand Explorer Bar. Here's the 
implementation of these two functions:</P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>typedef struct
{
   HKEY   hRootKey;
   LPTSTR szSubKey;  // TCHAR szSubKey[MAX_PATH];
   LPTSTR lpszValueName;
   LPTSTR szData;    // TCHAR szData[MAX_PATH];

} DOREGSTRUCT, *LPDOREGSTRUCT;

BOOL RegisterServer(CLSID clsid, LPTSTR lpszTitle)
{
   int     i;
   HKEY    hKey;
   LRESULT lResult;
   DWORD   dwDisp;
   TCHAR   szSubKey[MAX_PATH];
   TCHAR   szCLSID[MAX_PATH];
   TCHAR   szModule[MAX_PATH];
   LPWSTR  pwsz;

   // Get the CLSID in string form.
   StringFromIID(clsid, &amp;pwsz);

   if (pwsz)
   {
#ifdef UNICODE
      lstrcpy(szCLSID, pwsz);
#else
      WideCharToMultiByte(CP_ACP, 0, pwsz, -1, szCLSID,
                       ARRAYSIZE(szCLSID), NULL, NULL);
#endif

      // Free the string.
      LPMALLOC pMalloc;

      CoGetMalloc(1, &amp;pMalloc);
      pMalloc-&gt;Free(pwsz);

      pMalloc-&gt;Release();
   }

   // Get this application's path and filename.
   GetModuleFileName(g_hInst, szModule, ARRAYSIZE(szModule));

   DOREGSTRUCT ClsidEntries[] =
   {
      HKEY_CLASSES_ROOT, TEXT(&quot;CLSID\\%s&quot;),
         NULL, lpszTitle,
      HKEY_CLASSES_ROOT, TEXT(&quot;CLSID\\%s\\InprocServer32&quot;),
         NULL, szModule,
      HKEY_CLASSES_ROOT, TEXT(&quot;CLSID\\%s\\InprocServer32&quot;)
         TEXT(&quot;ThreadingModel&quot;), TEXT(&quot;Apartment&quot;)
      NULL, NULL, NULL, NULL
   };

   // Register the CLSID entries.
   for (i = 0; ClsidEntries[i].hRootKey; i++)
   {
      // Create the subkey string. For this case, insert
      // the file extension.
      //
      wsprintf(szSubKey, ClsidEntries[i].szSubKey, szCLSID);

      lResult = RegCreateKeyEx(ClsidEntries[i].hRootKey, szSubKey,
                               0, NULL, REG_OPTION_NON_VOLATILE,
                               KEY_WRITE, NULL, &amp;hKey, &amp;dwDisp);
   
      if (ERROR_SUCCESS == lResult)
      {
         TCHAR szData[MAX_PATH];

         // If necessary, create the value string.
         wsprintf(szData, ClsidEntries[i].szData, szModule);

         lResult = RegSetValueEx(hKey, ClsidEntries[i].lpszValueName,
                                 0, REG_SZ, (LPBYTE)szData,
                                 lstrlen(szData) + 1);
         RegCloseKey(hKey);

         if (ERROR_SUCCESS != lResult)
            return FALSE;
      }
      else
      {
         return FALSE;
      }
   }

   return TRUE;
}

BOOL RegisterComCat(CLSID clsid, CATID CatID)
{
   ICatRegister* pcr;
   HRESULT hr = S_OK ;
    
   CoInitialize(NULL);

   hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                         NULL,
                         CLSCTX_INPROC_SERVER,
                         IID_ICatRegister,
                         (LPVOID*)&amp;pcr);

   if (SUCCEEDED(hr))
   {
      hr = pcr-&gt;RegisterClassImplCategories(clsid, 1, &amp;CatID);
      pcr-&gt;Release();
   }
        
   CoUninitialize();

   return SUCCEEDED(hr);
}
</PRE>
</TD></TR></TABLE></P>


<P>In this code, the <I>RegisterServer</I> function is pretty straightforward. It uses an 
array of <I>DOREGSTRUCT</I> structures that contain the necessary information to be 
entered into the Registry. The <I>DOREGSTRUCT</I> structure is defined at the 
beginning of this code. After initializing the array of 
<I>DOREGSTRUCT</I> structures, the code loops through 
the array and calls <I>RegCreateKeyEx </I>to create the Registry keys and 
<I>RegSetValueEx </I>to set Registry values. (These functions are both Win32 API functions.) When initializing 
the array of <I>DOREGSTRUCT</I> structures, make sure that the Registry information is 
listed in top-down order. In other words, the 
<I>CLSID</I> key must be created before any of its subkeys.</P>
<P>The <I>RegisterComCat</I> function is a little more interesting. Instead of calling 
the Win32 Registry functions to register the component category information, the 
code uses the Component Categories Manager. This COM object takes care of 
registering the component categories for you. After initializing COM, the code creates an 
instance of the Component Categories Manager by calling 
<I>CoCreateInstance </I>and passing 
<I>CLSID_StdComponentCategoriesMgr</I>.</P>
<P>When calling <I>CoCreateInstance</I>, the code also passes the interface 
ID <I>IID_ICatRegister</I> as the fourth parameter to request a pointer to the 
<I>ICatRegister</I> interface. Then the code calls the 
<I>RegisterClassImplCategories</I> method of 
<I>ICatRegister</I>, passing the CLSID of the WebBand Explorer Bar and the CATID of the type of 
band that you want to create. The 
<I>RegisterClassImplCategories</I> method registers the 
component category for your band object.</P>
<P>So that your users can unregister your band object, you should also 
implement the <I>DllUnregisterServer </I>function. This implementation isn't required, but it 
enables your users to use Rregsvr32.exe to unregister your band object, which will keep 
them happy. Imagine having to manually unregister all ActiveX controls or COM 
objects on your system. I know that wouldn't make me happy!</P>
<P>Implementing the <I>DllUnregisterServer</I> function is pretty easy, as the 
following WebBand code demonstrates:</P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>STDAPI DllUnregisterServer(void)
{
   // Register the Component Categories for the Explorer Bar object.
   if (!UnRegisterComCat(CLSID_WBExplorerBar, CATID_InfoBand))
      return SELFREG_E_CLASS;

   // Register the Explorer Bar object.
   if (!UnRegisterServer(CLSID_WBExplorerBar))
      return SELFREG_E_CLASS;

   return S_OK;
}
</PRE>
</TD></TR></TABLE></P>

<P>Notice that this code unregisters the component categories first, before 
it unregisters the CLSID for your band object, because the component category 
information is stored as the <I>Implemented 
Categories</I> subkey of your CLSID. You can't 
delete a key from the Registry by using the Win32 API functions if that key has subkeys.</P>
<P>The <I>UnRegisterComCat </I>function is similar to the 
<I>RegisterComCat </I>function. It uses the Component Categories Manager to unregister the component categories:</P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>BOOL UnRegisterComCat(CLSID clsid, CATID CatID)
{
   ICatRegister* pcr;
   HRESULT hr = S_OK ;
    
   CoInitialize(NULL);

   hr = CoCreateInstance(CLSID_StdComponentCategoriesMgr,
                         NULL,
                         CLSCTX_INPROC_SERVER, 
                         IID_ICatRegister,
                         (LPVOID*)&amp;pcr);

   if (SUCCEEDED(hr))
   {
      hr = pcr-&gt;UnRegisterClassImplCategories(clsid, 1, &amp;CatID);
      pcr-&gt;Release();
   }
        
   CoUninitialize();

   return SUCCEEDED(hr);
}
</PRE>
</TD></TR></TABLE></P>

<P>As you can see, the only difference between this code and the code for 
the <I>RegisterComCat </I>function is that <I>UnRegisterComCat 
</I>calls <I>ICatRegister::UnRegisterClassImplCategories 
</I>to unregister the component categories.</P>
<P>The implementation of the function 
<I>UnRegisterServer</I> is similar to the function 
<I>RegisterServer</I>:</P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>BOOL UnRegisterServer(CLSID clsid)
{
   TCHAR   szSubKey[MAX_PATH];
   TCHAR   szCLSID[MAX_PATH];
   LPWSTR  pwsz;

   // Get the CLSID in string form.
   StringFromIID(clsid, &amp;pwsz);

   if (pwsz)
   {
#ifdef UNICODE
      lstrcpy(szCLSID, pwsz);
#else
      WideCharToMultiByte(CP_ACP, 0, pwsz, -1, szCLSID,
                          ARRAYSIZE(szCLSID), NULL, NULL);
#endif

      // Free the string.
      LPMALLOC pMalloc;

      CoGetMalloc(1, &amp;pMalloc);

      pMalloc-&gt;Free(pwsz);
      pMalloc-&gt;Release();
   }

   DOREGSTRUCT ClsidEntries[] =
   {
      HKEY_CLASSES_ROOT, TEXT(&quot;CLSID\\%s\\InprocServer32&quot;),
         NULL, NULL,
      //
      // Remove the Implemented Categories key, just in case 
      // UnRegisterClassImplCategories doesn't remove it.
      // 
      HKEY_CLASSES_ROOT, TEXT(&quot;CLSID\\%s\\Implemented Categories&quot;),
         NULL, NULL,
      HKEY_CLASSES_ROOT, TEXT(&quot;CLSID\\%s&quot;), NULL, NULL,
         NULL, NULL, NULL, NULL
   };

   // Delete the CLSID entries.
   for (int i = 0; ClsidEntries[i].hRootKey; i++)
   {
      wsprintf(szSubKey, ClsidEntries[i].szSubKey, szCLSID);
      RegDeleteKey(ClsidEntries[i].hRootKey, szSubKey);
   }

   return TRUE;
}
</PRE>
</TD></TR></TABLE></P>

<P>This code uses the <I>RegDeleteKey</I> Win32 API function to delete the 
<I>CLSID</I> key and its subkeys. Notice that the 
<I>DOREGSTRUCT</I> array is set up to delete all 
subkeys before their parent keys. This is required.</P>

<A NAME="234"><H2>Implementing Required Interfaces</H2></A>

<P>Besides implementing the required DLL functions (and of course 
<I>IUnknown</I>), you must implement a few interfaces: 
<I>IDeskBand</I>,<I> IDockingWindow, IOleWindow, 
IObjectWithSite</I>, and <I>IPersistStream</I>.</P>

<A NAME="235"><H3><I>IDeskBand</I></H3></A>
<P>The <I>IDeskBand </I>interface is specific to band objects. You implement it just as 
you would any other interface. The WebBand example is written by using standard 
C++, so a class named <I>CWBExplorerBar </I>implements 
<I>IDeskBand </I>by inheriting from it and implementing its one method, 
<I>GetBandInfo</I>. Internet Explorer uses 
<I>GetBandInfo</I> to specify the identifier and viewing mode of your band object as well as to 
obtain information about your band object. The 
<I>GetBandInfo</I> method is defined in the 
shlobj.h header file as follows:</P>
<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>HRESULT GetBandInfo(DWORD dwBandID, DWORD dwViewMode, DESKBANDINFO* pdbi);</PRE>
</TD></TR></TABLE></P>

<P>The first parameter of this method is the identifier of the band as assigned 
by the container&#8212;Internet Explorer, in most cases. The second parameter is the 
view mode, which can have one of the values shown in Table 10-1. You should save 
the values stored in the first and second parameters in data members of the class 
that implement <I>IDeskBand</I>.</P>


<P><B>Table 10-1.</B> DWViewMode <I>Constants</I></P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR>
<TH><i>Value</i></TH>
<TH><i>Description</i></TH>
</TR><TR>
<TD VALIGN="TOP"><I>DBIF_VIEWMODE_NORMAL</I></TD>
<TD VALIGN="TOP">Your band object is being 
displayed in a horizontal band.</TD>
</TR><TR>
<TD VALIGN="TOP"><I>DBIF_VIEWMODE_VERTICAL</I></TD>
<TD VALIGN="TOP">Your band object is being 
displayed in a vertical band.</TD>
</TR><TR>
<TD VALIGN="TOP"><I>DBIF_VIEWMODE_FLOATING</I></TD>
<TD VALIGN="TOP">Your band object is being 
displayed in a floating band.</TD>
</TR><TR>
<TD VALIGN="TOP"><I>DBIF_VIEWMODE_TRANSPARENT</I></TD>
<TD VALIGN="TOP">Your band object is being 
displayed in a transparent band.</TD>
</TR></TABLE></P>


<P>Internet Explorer will request information from your band object by using the third parameter of this method&#8212;<I>pdbi</I>. This parameter is a pointer to a <I>DESKBANDINFO</I> structure, which is defined as follows:</P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>typedef struct {
   DWORD       dwMask;
   POINTL      ptMinSize;
   POINTL      ptMaxSize;    
   POINTL      ptIntegral;
   POINTL      ptActual
   WCHAR       wszTitl[256];
   DWORD       dwModeFlags;
   COLORREF    crBkgnd;
} DESKBANDINFO;
</PRE>
</TD></TR></TABLE></P>

<P>Internet Explorer uses the <I>dwMask </I>member of this structure to specify 
what information it is requesting. This data member can contain one or more of the 
flags listed in Table 10-2.</P>

<P><B>Table 10-2.</B> DWMask <I>Values</I></P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR>
<TH><i>Value</i></TH>
<TH><i>Description</i></TH>
</TR><TR>
<TD VALIGN="TOP"><I>DBIM_ACTUAL</I></TD>
<TD VALIGN="TOP"><I>ptActual</I> is being requested. This data 
member receives the ideal size you would like your band 
object to be. It is not guaranteed to be this size.</TD>
</TR><TR>
<TD VALIGN="TOP"><I>DBIM_BKCOLOR</I></TD>
<TD VALIGN="TOP"><I>crBkgnd</I> is being requested. This data 
member receives the background color of your band 
object. <I>DBIM_BKCOLOR</I> is ignored if the 
<I>dwModeFlags</I> data member doesn't contain the 
<I>DBIMF_BKCOLOR</I> flag.</TD>
</TR><TR>
<TD VALIGN="TOP"><I>DBIM_INTEGRAL</I></TD>
<TD VALIGN="TOP"><I>ptIntegral</I> is being requested. This data 
member receives the sizing step value of the band object, 
which specifies in which increments the band will 
be resized. This data member is ignored if 
<I>dwModeFlags</I> doesn't contain 
<I>DBIMF_VARIABLEHEIGHT</I>.</TD>
</TR><TR>
<TD VALIGN="TOP"><I>DBIM_MAXSIZE</I></TD>
<TD VALIGN="TOP"><I>ptMaxSize</I> is being requested. This data 
member receives the maximum size of your band object.</TD>
</TR><TR>
<TD VALIGN="TOP"><I>DBIM_MINSIZE</I></TD>
<TD VALIGN="TOP"><I>ptMinSize</I> is being requested. This data 
member receives the minimum size of your band object.</TD>
</TR><TR>
<TD VALIGN="TOP"><I>DBIM_MODEFLAGS</I></TD>
<TD VALIGN="TOP"><I>dwModeFlags</I> is being requested. This data 
member receives one or more flags, logically OR'ed 
together, that define the mode of operation for your 
band object. The following are the possible values 
for this data member:
<P><B><I>DBIMF_BKCOLOR</I></B> Your band object will 
have the background color defined by the 
<I>crBkgnd</I> data member.</P>
<P><B><I>DBIMF_DEBOSSED</I></B> Your band object will 
appear sunken when displayed.</P>
<P><B><I>DBIMF_NORMAL</I></B> Your band is in normal 
mode of operation.</P>
<P><B><I>DBIMF_VARIABLEHEIGHT</I></B> The height of 
the band object can be changed. The <I>ptIntegral 
</I>data member defines the step value for resizing 
your band object.</P></TD>
</TR><TR>
<TD VALIGN="TOP"><I>DBIM_TITLE</I></TD>
<TD VALIGN="TOP"><I>wszTitle</I> is being requested. This data 
member receives the title of your band object.</TD>
</TR></TABLE></P>


<P>This next code listing shows how the WebBand example implements 
the <I>GetBandInfo</I> method:</P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>#define MIN_SIZE_X   10
#define MIN_SIZE_Y   10

STDMETHODIMP CWBExplorerBar::GetBandInfo(DWORD dwBandID,
                                         DWORD dwViewMode,
                                         DESKBANDINFO* pdbi)
{
   if (pdbi)
   {
      _dwBandID = dwBandID;
      _dwViewMode = dwViewMode;

      if (pdbi-&gt;dwMask &amp; DBIM_MINSIZE)
      {
         pdbi-&gt;ptMinSize.x = MIN_SIZE_X;
         pdbi-&gt;ptMinSize.y = MIN_SIZE_Y;
      }

      if (pdbi-&gt;dwMask &amp; DBIM_MAXSIZE)
      {
         pdbi-&gt;ptMaxSize.x = -1;
         pdbi-&gt;ptMaxSize.y = -1;
      }

      if (pdbi-&gt;dwMask &amp; DBIM_INTEGRAL)
      {
         pdbi-&gt;ptIntegral.x = 1;
         pdbi-&gt;ptIntegral.y = 1;
      }

      if (pdbi-&gt;dwMask &amp; DBIM_ACTUAL)
      {
         pdbi-&gt;ptActual.x = 0;
         pdbi-&gt;ptActual.y = 0;
      }

      if (pdbi-&gt;dwMask &amp; DBIM_TITLE)
      { 
         lstrcpyW(pdbi-&gt;wszTitle, L&quot;WebBand Search&quot;);
      }

      if (pdbi-&gt;dwMask &amp; DBIM_MODEFLAGS)
         pdbi-&gt;dwModeFlags = DBIMF_VARIABLEHEIGHT;
   
      if (pdbi-&gt;dwMask &amp; DBIM_BKCOLOR)
      {
         // Use the default background color by removing this flag.
         pdbi-&gt;dwMask &amp;= ~DBIM_BKCOLOR;
      }

      return S_OK;
   }

   return E_INVALIDARG;
}
</PRE>
</TD></TR></TABLE></P>


<P>In addition to implementing the <I>IDeskBand 
</I>interface, because <I>IDeskBand </I>inherits from the 
<I>IDockingWindow</I> interface and <I>IDockingWindow 
</I>inherits from the <I>IOleWindow</I> interface, you must implement these interfaces as well. 
Implementing the <I>IOleWindow </I>interface's methods is pretty standard, so I won't show you here. 
(If you're interested, take a look at the WebBand example.)</P>
<P>Implementing most of the <I>IDockingWindow</I> interface's methods is pretty 
standard as well, but its <I>ShowDW</I> method warrants some attention. 
<I>ShowDW </I>is called when the Explorer band's window is being shown or hidden. The 
<I>ShowDW</I> method takes one parameter, 
<I>fShow</I>, which is a Boolean value that indicates whether the 
band object's window is being shown (TRUE) or hidden (FALSE). Here is WebBand's 
implementation of the <I>ShowDW</I> method:</P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>STDMETHODIMP CWBExplorerBar::ShowDW(BOOL fShow)
{
   if (_hWnd)
   {
      //
      // Hide or show the window depending on
      // the value of the fShow parameter.
      //
      if (fShow)
         ShowWindow(_hWnd, SW_SHOW);
      else
         ShowWindow(_hWnd, SW_HIDE);
   }

   return S_OK;
}
</PRE>
</TD></TR></TABLE></P>

<A NAME="236"><H3><I>IObjectWithSite</I></H3></A>
<P>Internet Explorer uses the 
<I>IObjectWithSite</I> interface's <I>SetSite</I> method to pass a 
pointer to the <I>IUnknown </I>interface of the band object's site. One way you can use this 
pointer is to query for various interfaces implemented in the container such as 
<I>IWebBrowser2</I>,<I> IInputObjectSite</I>,<I> 
</I>and <I>IOleInPlaceObject</I>. You can then use these interfaces to 
perform different actions in your band object and to control the container&#8212;Internet Explorer.</P>

<P>The following code shows the 
<I>IObjectWithSite</I> interface's <I>SetSite</I> method 
as implemented by the <I>CWBExplorerBar </I>class of the WebBand example:</P>
<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>STDMETHODIMP CWBExplorerBar::SetSite(IUnknown* pUnkSite)
{
   // If pUnkSite is not NULL, a new site is being set.
   if (pUnkSite)
   {
      //
      // If a pointer to the IInputObjectSite interface is being held,  
      // release it.
      //
      if (_pSite)
      {
         _pSite-&gt;Release();
         _pSite = NULL;
      }

      // Get the parent window.
      IOleWindow* pOleWindow;
   
      if (SUCCEEDED(pUnkSite-&gt;QueryInterface(IID_IOleWindow,
                    (LPVOID*)&amp;pOleWindow)))
      {
         pOleWindow-&gt;GetWindow(&amp;_hwndParent);
         pOleWindow-&gt;Release();
      }

      _ASSERT(_hwndParent);
      if (!_hwndParent)
         return E_FAIL;

      if (!RegisterAndCreateWindow())
         return E_FAIL;

      // Get and keep the IInputObjectSite pointer.
      HRESULT hr = pUnkSite-&gt;QueryInterface(IID_IInputObjectSite, 
                                            (LPVOID*)&amp;_pSite);
      _ASSERT(SUCCEEDED(hr));

      //
      // Get the IWebBrowser2 interface of Internet Explorer
      // so that you can perform such tasks as 
      // navigating in the main window and writing to the status bar.
      //
      IOleCommandTarget* pCmdTarget;
      hr = pUnkSite-&gt;QueryInterface(IID_IOleCommandTarget, 
                                    (LPVOID*)&amp;pCmdTarget);
      if (SUCCEEDED(hr))
      {
         IServiceProvider* pSP;
         hr = pCmdTarget-&gt;QueryInterface(IID_IServiceProvider, 
                                         (LPVOID*)&amp;pSP);

         pCmdTarget-&gt;Release();

         if (SUCCEEDED(hr))
         {
            if (_pFrameWB)
            {
               _pFrameWB-&gt;Release();
               _pFrameWB = NULL;
            }

            hr = pSP-&gt;QueryService(SID_SWebBrowserApp,
                                   IID_IWebBrowser2,
                                   (LPVOID*)&amp;_pFrameWB);
            _ASSERT(_pFrameWB);

            pSP-&gt;Release();
         }
      }
   <img src="images/grayvellip.JPG" width=3 height=13 border="0">

   }

   return S_OK;
}
</PRE>
</TD></TR></TABLE></P>

<P>Much of the code in the <I>SetSite</I> method pertains to hosting the 
WebBrowser control in the band object, which we'll look at later in this chapter. But you'll 
need to include quite a bit of code in this method whether or not you are hosting 
the WebBrowser control.</P>
<P>The first action that this code performs is to get the 
<I>HWND</I> of the parent window. The code will use it later to perform tasks such as activating the window 
and determining the window size. To obtain this 
<I>HWND</I>, the code simply queries the <I>IUnknown 
</I>of the site for <I>IOleWindow </I>and then calls 
<I>IOleWindow</I>'s <I>GetWindow</I> method.</P>
<P>Next a private member function named <I>RegisterAndCreateWindow 
</I>is called to register and create the window for the band object&#8212;hence, the name. The 
implementation of this function is what you would expect when registering a window 
class and creating a window of that class, as shown below.</P>
<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>BOOL CWBExplorerBar::RegisterAndCreateWindow(void)
{
   // If the window doesn't exist yet, create it now.
   if (!_hWnd)
   {
      // Can't create a child window without a parent.
      if (!_hwndParent)
         return FALSE;

      // If the window class hasn't been registered, then do so.
      WNDCLASS wc;
      if (!GetClassInfo(g_hInst, EB_CLASS_NAME, &amp;wc))
      {
         ZeroMemory(&amp;wc, sizeof(wc));
         wc.style          = CS_HREDRAW | CS_VREDRAW | CS_GLOBALCLASS;
         wc.lpfnWndProc    = (WNDPROC)MainWndProc;
         wc.cbClsExtra     = 0;
         wc.cbWndExtra     = 0;
         wc.hInstance      = g_hInst;
         wc.hIcon          = NULL;
         wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
         wc.hbrBackground  = NULL;
         wc.lpszMenuName   = NULL;
         wc.lpszClassName  = EB_CLASS_NAME;
      
         if (!RegisterClass(&amp;wc))
         {
            // If RegisterClass fails, CreateWindowEx will fail.
         }
      }

      RECT rc;
      GetClientRect(_hWnd, &amp;rc);

      // Create the window. The WndProc will set _hWnd.
      CreateWindowEx(0,
                     EB_CLASS_NAME,
                     NULL,
                     WS_CHILD | WS_CLIPSIBLINGS | WS_BORDER,
                     rc.left,
                     rc.top,
                     rc.right - rc.left,
                     rc.bottom - rc.top,
                     _hwndParent,
                     NULL,
                     g_hInst,
                     (LPVOID)this);
   }

   return (NULL != _hWnd);
}
</PRE>
</TD></TR></TABLE></P>

<P>The next action that is performed in the <I>SetSite 
</I>method is querying the site's <I>IUnknown </I>interface for a pointer to the site's implementation of 
<I>IInputObjectSite</I>. This pointer is stored in a data member of the class that will later be used to alert 
the container when the focus has changed to the band object.</P>
<P>The remainder of the <I>SetSite </I>method's code gets a pointer to the 
<I>IWebBrowser2 </I>interface of the container (Internet Explorer) and creates and sites an instance of 
the WebBrowser control that will be hosted in the WebBand Explorer Bar. I'll talk 
more about this later in this chapter in the section on hosting the WebBrowser control 
in a band object.</P>

<A NAME="237"><H3><I>IPersistStream</I></H3></A>
<P>Internet Explorer calls the methods of your 
band object's implementation of 
<I>IPersistStream</I> to allow your band object to load or save persistent data. If you 
don't have any data to load or save, your code must still return 
<I>S_OK</I> from the <I>Load </I>and <I>Save </I>methods, and it can return 
<I>S_FALSE</I> from the <I>IsDirty </I>method.</P>

<A NAME="238"><H2>Implementing Optional Interfaces</H2></A>

<P>You can implement a number of optional interfaces in any ActiveX control or 
COM object, and a band object is no exception. The interfaces discussed in the 
following sections are of particular importance for 
band objects.</P>

<A NAME="239"><H3><I>IInputObject</I></H3></A>
<P>The <I>IInputObject </I>interface must be implemented by your band object if your 
band object is going to receive user input. This implementation is necessary, for 
instance, if your band is hosting the WebBrowser control and you want to allow users to 
type information into form controls and use accelerator keys such as Backspace and 
Delete. The WebBand example hosts the WebBrowser control, so the 
<I>IInputObject</I> interface is of particular importance. Internet Explorer implements the 
<I>IInputObjectSite </I>interface and uses the <I>IInputObject 
</I>interface to manage user input focus.</P>

<P>If you implement the <I>IInputObject</I> interface in your band object, you 
must implement its three methods: 
<I>UIActivateIO</I>,<I> HasFocusIO</I>, and 
<I>TranslateAcceleratorIO</I>. If you aren't hosting the WebBrowser control, the code for these methods is 
pretty straightforward, as shown next. But if you are hosting the WebBrowser control, 
these methods become a little more complex. (See the Appendix for details about 
the changes to these methods.)</P>
<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>STDMETHODIMP CExplorerBar::UIActivateIO(BOOL fActivate, LPMSG pMsg)
{
   if (fActivate)
      SetFocus(m_hWnd);

   return S_OK;
}

STDMETHODIMP CExplorerBar::HasFocusIO(void)
{
   if (m_fFocus)
      return S_OK;

   return S_FALSE;
}

STDMETHODIMP CExplorerBar::TranslateAcceleratorIO(LPMSG pMsg)
{
   return S_FALSE;
}
</PRE>
</TD></TR></TABLE></P>

<A NAME="240"><H3><I>IContextMenu</I></H3></A>
<P>Implement the <I>IContextMenu</I> interface if you want to add items to the context 
menu that is displayed when you right-click your band object. (If you are hosting 
the WebBrowser control, the context menu is displayed when you click your band 
object's title bar.)</P>

<P><I>IContextMenu</I> has three methods: 
<I>QueryContextMenu</I>, <I>InvokeCommand</I>, and 
<I>GetCommandString</I>. The 
<I>QueryContextMenu</I> method is called when the 
context menu is about to be displayed. In the implementation of 
<I>QueryContextMenu</I>, you can add your context menu items. For example, the WebBand example adds the 
Refresh menu item and the Open In New Window menu item. WebBand implements 
the <I>QueryContextMenu</I> method like this:</P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>STDMETHODIMP CWBExplorerBar::QueryContextMenu(HMENU hmenu,
                                              UINT indexMenu, 
                                              UINT idCmdFirst,
                                              UINT idCmdLast, 
                                              UINT uFlags)
{
   if (!(CMF_DEFAULTONLY &amp; uFlags))
   {
      InsertMenu(hmenu, indexMenu, MF_STRING | MF_BYPOSITION,
                 idCmdFirst + IDM_REFRESH, &quot;&amp;Refresh&quot;);

      InsertMenu(hmenu, indexMenu + 1, MF_STRING | MF_BYPOSITION, 
                 idCmdFirst + IDM_OPENINWINDOW, &quot;&amp;Open in Window&quot;);

      return MAKE_HRESULT(SEVERITY_SUCCESS, 0,
                          USHORT(IDM_OPENINWINDOW + 1));
   }

   return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(0));
}
</PRE>
</TD></TR></TABLE></P>

<P>The <I>InvokeCommand</I> method is called when the user selects one of your 
context menu items. This method is passed a pointer to a structure that contains 
information about which menu item was selected, including the ID of the menu item. 
In this method, you can execute whatever code corresponds to the selected menu item.</P>
<P>Here is WebBand's implementation of the 
<I>InvokeCommand</I> method. Notice that the menu items pertain to the WebBrowser's Refresh operation and Open In 
New Window operation:</P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>STDMETHODIMP CWBExplorerBar::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
   switch (LOWORD(lpici-&gt;lpVerb))
   {
      case IDM_REFRESH:
         _pWebBrowserOC-&gt;Refresh();
         break;

      case IDM_OPENINWINDOW:
         {
            BSTR bstrURL;

            HRESULT hr = _pWebBrowserOC-&gt;get_LocationURL(&amp;bstrURL);
            if (SUCCEEDED(hr))
            {
               _variant_t vtEmpty;
               _variant_t vtFlags((long)
                                  (navOpenInNewWindow|navNoHistory));

               hr = _pWebBrowserOC-&gt;Navigate(bstrURL, &amp;vtFlags, 
                                             &amp;vtEmpty, &amp;vtEmpty, 
                                             &amp;vtEmpty);
            }

            break;
         }

      default:
         return E_INVALIDARG;
   }

   return NOERROR;
}
</PRE>
</TD></TR></TABLE></P>

<P>The <I>IContextMenu</I> interface's last method is 
<I>GetCommandString</I>. It is called when Internet Explorer needs help text or a language-independent command 
name. The help text is typically displayed in Internet Explorer's status bar. (For more 
information about the <I>GetCommandString </I>method, refer to the MSDN documentation 
or <I>GetCommandString</I>'s implementation in the WebBand example.)</P>

<A NAME="241"><H2>Sending Commands to the Container</H2></A>

<P>A band object can send commands to its container to tell the container that the 
band object's information has changed or to tell the container to maximize the band 
object. To send commands to the container, query the container for its 
implementation of the <I>IOleCommandTarget</I> interface. You can use the pointer to the 
<I>IUnknown </I>interface that was received in the 
<I>SetSite </I>method or any interface pointer obtained 
from this <I>IUnknown </I>pointer. Then the code should call the 
<I>IOleCommandTarget</I> interface's <I>Exec</I> method to send a command to the container.</P>

<P>When calling the <I>Exec</I> method, specify 
<I>CGID_DeskBand </I>for the command group and the ID of your 
band object that you received in the <I>GetBandInfo 
</I>method for the <I>pvaIn </I>parameter of 
<I>Exec</I>. Currently, four commands exist that you can send to 
your container. (These commands are defined in the 
shlobj.h header file.)</P>

<UL>
<P><LI><I>DBID_BANDINFOCHANGED</I>. This command tells the container that 
the band object's information has changed and that the container should 
call the band object's <I>GetBandInfo</I> method to obtain the updated information.</LI></P>
<P><LI><I>DBID_SHOWONLY</I>. This command turns other bands on or off. The 
<I>vt </I>member of <I>pvaIn </I>should be set to 
<I>VT_UNKNOWN</I>, and the <I>punkVal</I> member should be set to one of the following values:</LI></P>
<UL>
<P><LI><I>Pointer to </I>IUnknown <I>of the current 
band</I>. All bands should be hidden except for this band.</LI></P>
<P><LI><I>0</I>. Hide every band.</LI></P>
<P><LI><I>1</I>. Show every band.</LI></P>
</UL>

<P><LI><I>DBID_MAXIMIZEBAND</I>. This command tells the container to 
maximize your band object.</LI></P>

<P><LI><I>DBID_PUSHCHEVRON</I>. This command can be used to 
programmatically display a chevron menu, the type of menu button that contains 
chevron characters (&gt;&gt;). This menu button is typically displayed on a toolbar 
when not enough room exists to display all the items on the toolbar. For 
this command ID, the <I>nCmdExecOpt </I>parameter should be set to the ID of 
the band. The <I>vt </I>member of <I>pvaIn </I>should be set 
to<I> VT_I4</I>. The <I>lVal</I> member of 
<I>pvaIn</I> gets handed back to the band as an 
<I>lParam</I>, which contains the menu notification 
(<I>RBN_CHEVRONPUSHED</I>) to display the chevron 
drop-down menu.</LI></P>
</UL>

<A NAME="242"><H2>Implementing the Windows Procedure for the Band Object</H2></A>

<P>You probably wouldn't expect to have to implement a Windows procedure for a 
band object because it exists in a DLL. But because 
band objects use child windows for their display, a Windows procedure is required to handle Windows messages. 
The WebBand example handles a normal set of Windows messages, as shown here:</P>
<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>LRESULT CALLBACK MainWndProc(HWND hWnd, UINT uMessage, 
                             WPARAM wParam, LPARAM lParam)
{
   if (uMessage == WM_NCCREATE)
   {
      LPCREATESTRUCT lpcs = (LPCREATESTRUCT)lParam;
      SetWindowLong(hWnd, GWL_USERDATA, (LONG)lpcs-&gt;lpCreateParams);
   }

   CWBExplorerBar* pThis = reinterpret_cast&lt;CWBExplorerBar*&gt;
                                 (GetWindowLong(hWnd, GWL_USERDATA));
   if (pThis)
      return pThis-&gt;WndProc(hWnd, uMessage, wParam, lParam);
   else
      return DefWindowProc(hWnd, uMessage, wParam, lParam);
}

LRESULT CWBExplorerBar::WndProc(HWND hWnd, UINT uMessage, 
                                WPARAM wParam, LPARAM lParam)
{
   switch (uMessage)
   {
      case WM_NCCREATE:
      {
         // Set the window handle.
         _hWnd = hWnd;
      }
      break;
   
      case WM_PAINT:
         return OnPaint();
   
      case WM_COMMAND:
         return OnCommand(wParam, lParam);
   
      case WM_SETFOCUS:
         return OnSetFocus();

      case WM_KILLFOCUS:
         return OnKillFocus();

      case WM_SIZE:
         return OnSize();

      case WM_DESTROY:
         Cleanup();
         return 0;
   }
   return DefWindowProc(hWnd, uMessage, wParam, lParam);
}
</PRE>
</TD></TR></TABLE></P>

<P>Notice that WebBand uses two functions to handle Windows messages: 
they keep the code clean and minimize the number of static data members and 
static member functions. Using this technique, only one global function and no static 
variables are needed. If the main Windows procedure, 
<I>MainWndProc</I>, were a member of the <I>CWBExplorerBar 
</I>class, it would have to be static. Therefore, any data 
members accessed in the <I>MainWndProc</I> method would have to be static or 
accessed through the <I>pThis</I> local variable.</P>
<P>Two messages in the Windows procedure that are of particular interest 
are <I>WM_SETFOCUS</I> and <I>WM_KILLFOCUS</I>. The handlers for these messages inform the 
site that the focus has changed. This is when the pointer to the 
<I>IInputObjectSite </I>interface that you saved in the 
<I>SetSite</I> method comes into play. In the handlers for these 
messages, you call 
<I>IInputObjectSite::OnFocusChangeIS</I> to inform the site that the 
focus has changed.</P>
<P>The following code shows the implementation for these message handlers:</P>
<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>LRESULT CWBExplorerBar::OnSetFocus(void)
{
   FocusChange(TRUE);
   return 0;
}

LRESULT CWBExplorerBar::OnKillFocus(void)
{
   FocusChange(FALSE);
   return 0;
}

void CWBExplorerBar::FocusChange(BOOL fFocus)
{
   // Inform the input object site that the focus has changed.
   //
   if (_pSite)
      _pSite-&gt;OnFocusChangeIS(static_cast&lt;IDockingWindow*&gt;(this), fFocus);
}
</PRE>
</TD></TR></TABLE></P>

<A NAME="243"><H2>Hosting the WebBrowser Control in a Band Object </H2></A>

<P>Because a band object is just a COM object, it can contain ActiveX controls like 
any other COM object. If you want to host the WebBrowser control in your 
band object, all you have to do is implement the correct interfaces and call the right methods 
to create and site the WebBrowser control.</P>

<P>At a minimum, to contain ActiveX controls, your 
band object should implement the following interfaces: 
<I>IOleClientSite</I>,<I> IOleInPlaceSite</I>,<I> 
</I>and <I>IOleControlSite</I>. Most of the methods of these interfaces are implemented by using boilerplate code, so 
we won't look at them here. In fact, most of them can return only 
<I>E_NOTIMPL</I> or <I>S_OK</I>. (Take a look at the WebBand example if you're interested in implementing 
these methods.)</P>
<P>However, one method deserves more attention: 
<I>IOleControlSite::OnFocus</I>. This method is called when the control being hosted by your 
band object receives or loses the focus. Just as in the message handler for 
<I>WM_SETFOCUS</I>, when <I>IOleControlSite::
OnFocus</I> is called you must inform the site that the focus has changed by 
calling <I>IInputObjectSite::OnFocusChangeIS</I>. If you don't inform the site that focus has 
changed, you'll experience problems with accelerator keys on Web pages that contain text 
boxes and text areas. (The Appendix discusses problems with 
band object accelerator keys in more detail.) Here's the implementation code for the 
<I>OnFocus</I> method:</P>
<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>STDMETHODIMP CWBExplorerBar::OnFocus(BOOL fGotFocus)
{
   if (_pSite)
      _pSite-&gt;OnFocusChangeIS(static_cast&lt;IInputObject*&gt;(this), 
                              fGotFocus);

   return S_OK;
}
</PRE>
</TD></TR></TABLE></P>

<P>After implementing the interfaces that your 
band object requires so that it can be an ActiveX control host, you must call the methods to create and site the 
control. These actions usually occur in the <I>SetSite 
</I>method, so let's take another look at that method now. This time, the code shows how to create and site the 
WebBrowser control:</P>

<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>STDMETHODIMP CWBExplorerBar::SetSite(IUnknown* pUnkSite)
{
   // If pUnkSite is not NULL, a new site is being set.
   if (pUnkSite)
   {

      <img src="images/grayvellip.JPG" width=3 height=13 border="0">
      // Create and initialize the WebBrowser control that we are hosting.
      hr = CoCreateInstance(CLSID_WebBrowser, NULL, CLSCTX_INPROC,
                            IID_IOleObject, (LPVOID*)&amp;_pIOleObject);
      if (hr != S_OK) 
         return E_FAIL;

      if (_pIOleObject-&gt;SetClientSite(this) != S_OK)
         return E_FAIL;

      // Get the rectangle of the client area.
      RECT rcClient = { CW_USEDEFAULT, 0, 0, 0 };
      GetClientRect(_hWnd, &amp;rcClient);

      MSG msg;

      // In-place activate the WebBrowser control.
      hr = _pIOleObject-&gt;DoVerb(OLEIVERB_INPLACEACTIVATE, &amp;msg,
                                this, 0, _hWnd, &amp;rcClient);
      _ASSERT(SUCCEEDED(hr));

      if (FAILED(hr))
         return E_FAIL;

      //
      // Get the pointer to the WebBrowser control. 
      //
      hr = _pIOleObject-&gt;QueryInterface(IID_IWebBrowser2, 
                                        (LPVOID*)&amp;_pWebBrowserOC);
      _ASSERT(_pWebBrowserOC);

      if (FAILED(hr))
         return E_FAIL;
      else
      {
         // Set up an event sink for the WebBrowser events.
         if (_pWebBrowserOC)
            AdviseWBEventSink();

         //
         // QI for the in-place object to set the size.
         //
         if (_pIOleIPObject)
         {
            _pIOleIPObject-&gt;Release();
            _pIOleIPObject = NULL;
         }

         hr = _pWebBrowserOC-&gt;QueryInterface(IID_IOleInPlaceObject, 
                                             (LPVOID*)&amp;_pIOleIPObject);
         _ASSERT(_pIOleIPObject);

         if (FAILED(hr))
            return E_FAIL;

         hr = _pIOleIPObject-&gt;SetObjectRects(&amp;rcClient, &amp;rcClient);
         _ASSERT(SUCCEEDED(hr));

         // Navigate to the sample search page.
         _variant_t vtEmpty;
         _bstr_t bstrURL(STARTUP_URL);

         _pWebBrowserOC-&gt;Navigate(bstrURL, &amp;vtEmpty, &amp;vtEmpty,
                                  &amp;vtEmpty, &amp;vtEmpty);

         // Get the HWND of the WebBrowser control.
         //
         IOleWindow* pWnd;

         if (SUCCEEDED(_pWebBrowserOC-&gt;QueryInterface(IID_IOleWindow,
                                                      (LPVOID*)&amp;pWnd)))
         {
            pWnd-&gt;GetWindow(&amp;_hwndWB);
            pWnd-&gt;Release();
         }
      }
  }

   return S_OK;
}</PRE>
</TD></TR></TABLE></P>

<P>First this code creates an instance of the WebBrowser control&#8212;nothing new 
to you by now. When calling 
<I>CoCreateInstance</I> to create the control, a pointer to 
the <I>IOleObject </I>interface of the host is obtained so that the 
<I>IOleObject</I> interface's <I>SetClientSite 
</I>method can then be called to set the client site for the control. Then 
the <I>IOleObject::DoVerb </I>method is called to in-place activate the WebBrowser control.</P>
<P>Next the pointer to the <I>IOleObject</I> 
interface is queried for a pointer to 
<I>IWebBrowser2</I>. This pointer will be used later to navigate within the 
band object and perform any other task that you would normally expect of this type of pointer, 
such as setting up an event sink (which is done next in the 
<I>SetSite</I> method).</P>
<P>Next the pointer to the <I>IWebBrowser2 </I>interface is queried for 
<I>IOleInPlaceObject</I>, which sets the size of the WebBrowser control by calling the 
<I>SetObjectRects</I> method of 
<I>IOleInPlaceObject</I>.</P>
<P>The <I>IWebBrowser2::Navigate</I> method is then called to navigate to a Web 
page. Finally the pointer to <I>IWebBrowser2</I> is queried for 
<I>IOleWindow</I> so that the <I>GetWindow</I> method can be called to get the 
<I>HWND</I> of the WebBrowser control. This 
<I>HWND</I> will be used in the <I>IInputObject::HasFocusIO 
</I>method to determine whether the WebBrowser control or any of its child windows has the focus. (This is discussed 
in more detail in the Appendix.)</P>
<P>You must perform one last task to make this all work. In the handler for 
the <I>WM_SIZE</I> message, the code must call <I>IOleInPlaceObject::SetObjectRects 
</I>to resize the WebBrowser control window when your band object's window is resized. If the 
code doesn't call this method, the WebBrowser control will always be the same size. 
The following code shows WebBand's implementation of the message handler for 
<I>WM_SIZE</I>:</P>
<P><TABLE CELLPADDING="5" WIDTH="95%"><TR><TD>
<PRE>LRESULT CWBExplorerBar::OnSize(void)
{
   HRESULT hr = E_FAIL;

   if (_pIOleIPObject)
   {
      RECT rcClient;
      GetClientRect(_hWnd, &amp;rcClient);

      hr = _pIOleIPObject-&gt;SetObjectRects(&amp;rcClient, &amp;rcClient);
      _ASSERT(SUCCEEDED(hr));
   }

   return hr;
}
</PRE>
</TD></TR></TABLE></P>

</BODY>
</HTML>






