<HTML>
<head>
<link rel="STYLESHEET" type="text/css" href="Progie5.css">
<TITLE>Handling Internet Explorer Events from ActiveX Controls</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch07f.htm">[Previous]</A> <A HREF="ch08a.htm">[Next]</A><P>

<A NAME="202"><H1>Handling Internet Explorer Events from ActiveX Controls</H1></A>

<p>In the <a href="ch06a.htm">previous chapter</a>, you learned how to create code in your C++ ActiveX 
controls to access the methods and properties of the 
<I>IWebBrowser2</I> interface implemented by Internet Explorer. As you might have guessed, because you can access the 
methods and properties of Internet Explorer's 
<I>IWebBrowser2</I> interface, you can also sink 
events for Internet Explorer's 
<I>DWebBrowserEvents2</I> interface from ActiveX controls. As 
with accessing the methods and properties, you can sink events in ActiveX controls 
written only in Visual C++ because you have to access the container object in the same 
way you accessed it in <A HREF="ch06a.htm">Chapter 6</A>.</p>

<p>You're probably wondering why you would want to sink Internet 
Explorer events from an ActiveX control. Well, you might have to if the ActiveX control 
accesses and changes elements in your document, for instance. (As you'll see in <A HREF="ch08a.htm">Chapter 
8</a>, you will have to make sure that the document can be safely accessed.) Earlier in 
this chapter in the section titled 
&quot;<I>DocumentComplete</I>,&quot; I mentioned that you can't 
access a document safely until the 
<I>DocumentComplete</I> event has fired. The only way to 
know that the <I>DocumentComplete</I> event has fired from the ActiveX control is to sink 
events for Internet Explorer and handle the 
<I>DocumentComplete</I> event.</p>

<p>Besides sinking Internet Explorer events because you 
<I>have</I> to, you might also <I>choose </I>to. For example, you might want to control the user's navigation 
experience if you are building an ActiveX control for your corporate intranet or perhaps an 
elementary school, as I've mentioned in earlier chapters. Any tasks that you can 
perform when handling events while automating Internet Explorer, you can perform from 
an ActiveX control.</p>

<p>To illustrate, let's revisit the AtlPrint example from <A HREF="ch06a.htm">Chapter 6</A>. It allows you 
to print the document in which AtlPrint's control, PrintCtl, is contained. You 
probably won't want to print the contents of the document before the document is 
completely finished loading and, normally, you would want to handle the 
<I>DocumentComplete</I> event to determine when the document is completely finished loading and when 
it's ready to be used.</p>

<p>When you refresh a page, however, the <I>DocumentComplete 
</I>event is not fired. Because of this and because I want to show you how to use other 
WebBrowser events, the AtlPrint<I> </I>example handles the 
<I>ProgressChange</I> event to determine whether the 
page can be printed.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
When the <I>DocumentComplete 
</I>event is not being fired, the <I>ProgressChange 
</I>event is handled to determine whether a page is finished 
loading. Using <I>ProgressChange </I>will work correctly only on a page without frames 
and probably only on a very simple Web page. The AtlPrint example is here mainly 
for demonstration purposes. The best way to determine whether the page is 
finished loading is by handling the 
<I>DocumentComplete</I> event, as I explained earlier. 
To handle the refresh situation, just look for <I>DownloadBegin 
</I>and <I>DownloadComplete </I>events being fired without being wrapped by the 
<I>BeforeNavigate2 </I>and <I>DocumentComplete 
</I>events<I>. </I>I will leave this as an exercise for you so that 
you can learn how to handle the WebBrowser events.
</blockquote></div>
</p>

<p>Remember that the <I>ProgressChange </I>event has two parameters that tell you 
the progress of the download operation. The first parameter (the only one we'll 
discuss) is set to <I>-1</I> when the progress is complete, which helps you determine whether 
it's OK to print. (In the <a href="ch08a.htm">next chapter</a>, you'll learn how to use the 
<I>DocumentComplete</I> event in cooperation with the 
<I>Document </I>property to access and change the document.)</p>

<p>To sink Internet Explorer events from the PrintCtl control, you must make 
a number of changes to AtlPrint. When Internet Explorer loads AtlPrint, you have 
to set up the event sink, which means you must obtain the 
<I>IWebBrowser2 </I>interface implemented by Internet Explorer. (Obtaining the interface is already done in the 
<I>Print </I>method of the <I>CPrintCtl </I>class.)</p>

<p>You should move the code that connects to the container and the code 
that obtains a pointer to its <I>IWebBrowser2 </I>interface out of the 
<I>Print</I> method. First move the declaration of the 
<I>IWebBrowser2 </I>smart pointer from the <I>Print 
</I>method to the class declaration of the <I>CPrintCtl 
</I>class. You'll also have to move the compiler directive 
that includes the ExDisp.h header file to the PrintCtl.h header file. The declaration of 
the <I>IWebBrowser2 </I>smart pointer should look like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>protected:
   CComPtr&lt;IWebBrowser2&gt; m_spWebBrowser;
</PRE>
</td></tr></table></p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Obviously, obtaining the 
<I>IWebBrowser2</I> interface should be done only once, when the control is first loaded. Obtaining a pointer to 
<I>IWebBrowser2</I> every time the <I>Print </I>method is called is inefficient. To set up the event sink, you 
have to obtain a pointer to the <I>IWebBrowser2 
</I>interface anyway, so why not just obtain and save this pointer in a data member so that you can use it in the 
<I>Print </I>method as well? This strategy will save you the expense of obtaining this pointer 
every time the <I>Print</I> method is called.
</blockquote></div>
</p>

<p>Next override the <I>SetClientSite </I>method of 
<I>IOleObjectImpl</I>.<I> </I>The <I>SetClientSite 
</I>method is called when Internet Explorer is notifying the control of its client site. 
You use this client site (<I>m_spClientSite</I>) to access the container and obtain 
the <I>IWebBrowser2 </I>interface pointer. In the implementation of 
<I>SetClientSite</I>, you must first call its base class version, like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>IOleObjectImpl&lt;CPrintCtl&gt;::SetClientSite(pClientSite);
</PRE>
</td></tr></table></p>

<p>This code might look a little strange, but remember that 
<I>IOleObjectImpl </I>is a template class. To call its methods, you must specify the required template 
parameters to indicate to the compiler which instance of the class to use when calling 
the <I>SetClientSite </I>method.
Now move the remaining code that accesses the container and 
the <I>IWebBrowser2 </I>interface pointer from the 
<I>Print </I>method to the <I>SetClientSite</I> method. The 
<I>Print</I> method should now be pretty empty:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHODIMP CPrintCtl::Print()
{
   ATLASSERT(m_spWebBrowser);

   HRESULT hr = E_FAIL;

   if (m_spWebBrowser)
   {
      hr = m_spWebBrowser-&gt;ExecWB(OLECMDID_PRINT, 
                                  OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
   }

   return hr;
}
</PRE>
</td></tr></table></p>

<p>Add the code to the <I>SetClientSite </I>method that sets up the event sink for 
Internet Explorer events. The implementation of 
<I>SetClientSite</I> should look like this:</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
You can't implement the code to set up the event sink in the 
<I>FinalConstruct </I>method because the client site hasn't been set yet.
</blockquote></div>
</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHODIMP CPrintCtl::SetClientSite(IOleClientSite* pClientSite)
{
   HRESULT hr = IOleObjectImpl&lt;CPrintCtl&gt;::SetClientSite(pClientSite);

   if (!pClientSite)
   {
      return hr;
   }

   CComPtr&lt;IOleContainer&gt; spContainer;
   m_spClientSite-&gt;GetContainer(&amp;spContainer);

   ATLASSERT(spContainer);

   if (SUCCEEDED(hr))
   {
      // Set up the event sink.
      //
      CComQIPtr&lt;IServiceProvider, &amp;IID_IServiceProvider&gt;
         spServiceProvider(spContainer);

      ATLASSERT(spServiceProvider);

      if (spServiceProvider)
      {
         spServiceProvider-&gt;QueryService(SID_SInternetExplorer,
                                         IID_IWebBrowser2,
                                         (void**)&amp;m_spWebBrowser);
         ATLASSERT(m_spWebBrowser);

         if (m_spWebBrowser)
         {
            AtlAdvise(m_spWebBrowser, GetUnknown(),
                      DIID_DWebBrowserEvents2, &amp;m_dwCookie);
         }
      }
   }

   return hr;
}
</PRE>
</td></tr></table></p>

<p>Notice in the call to <I>AtlAdvise </I>that you'll have to create either a protected or 
a private data member of type <I>DWORD</I> to hold the cookie that is returned from 
the <I>AtlAdvise</I> method. Initialize this data member to 
<I>0</I> in the constructor for the <I>CPrintCtl 
</I>class.<I> </I>Also notice that we hold on to the return value from 
<I>IOleObjectImpl::SetClientSite</I> and use the value as the return value of the 
<I>CPrintCtl::SetClientSite</I> method. This method doesn't check the return values of any of the other methods that are 
being called because the return value of 
<I>CPrintCtl::SetClientSite</I> should reflect the status 
of setting the client site.</p>

<p>Finally, we check to see whether the 
<I>pClientSite</I> input parameter is <I>NULL</I>. If 
so, we return from this function because when Internet Explorer unloads the control, 
it calls <I>SetClientSite</I> with 
<I>pClientSite</I> set to <I>NULL</I>. This tells you that you are being 
disconnected from the client site, so the code that obtains a pointer to the 
<I>IWebBrowser2</I> interface of the container doesn't need to be executed.</p>

<p>Because you advised the container that you want to sink events for it, you 
should be polite and disconnect the sink when you're done, including when the control 
is being unloaded. To do this, place a call to the 
<I>AtlUnadvise </I>method in the section of code that checks to see whether 
<I>pClientSite </I>is <I>NULL</I> in the <I>SetClientSite 
</I>method. Remember that <I>pClientSite</I> will be 
<I>NULL</I> when the control is being unloaded. The 
new section of code should look like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>if (!pClientSite)
{
   ATLASSERT(m_spWebBrowser);

   if (m_spWebBrowser)
      AtlUnadvise(m_spWebBrowser, DIID_DWebBrowserEvents2, m_dwCookie);

   return hr;
}
</PRE>
</td></tr></table></p>

<p>Now that you've established the event sink by using 
<I>AtlAdvise</I>, let's handle some events. To handle events, you must override the 
<I>Invoke </I>method of <I>IDispatchImpl</I>. Typically, you would want to create a separate class for your event sink 
because the DISPIDs of Internet Explorer events could conflict with the DISPIDs of 
your control. But for this example, you can simply implement the event handlers 
inside of the <I>CPrintCtl </I>class. Implement 
<I>Invoke </I>(as in the code below) to 
handle the <I>ProgressChange</I> event. In the event handler, if the amount of progress is 
<I>-1</I>, set a data member that indicates that the page is ready to be printed.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Remember that the parameters for methods, properties, and 
events are sent to <I>Invoke</I> in reverse order. Therefore, the 
<I>Progress</I> parameter of the 
<I>ProgressChange</I> event is actually the second parameter in the array of 
arguments sent to <I>Invoke</I>.
</blockquote></div>
</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHODIMP CPrintCtl::Invoke(DISPID dispidMember, 
                               REFIID riid, 
                               LCID lcid,
                               WORD wFlags, 
                               DISPPARAMS* pDispParams, 
                               VARIANT* pvarResult, 
                               EXCEPINFO* pExcepInfo,
                               UINT* puArgErr)
{
   if (riid != IID_NULL)
      return DISP_E_UNKNOWNINTERFACE;

   if (!pDispParams)
      return DISP_E_PARAMNOTOPTIONAL;

   switch (dispidMember)
   {
      //
      // The parameters for this DISPID:
      // [0]: Maximum progress - VT_I4
      // [1]: Amount of total progress - VT_I4
      //
      case DISPID_PROGRESSCHANGE:
         if (pDispParams-&gt;cArgs != 0)
         {
            // Make sure that you access the
            // correct data member of the rgvarg array.
            // To do this, check the type of data to
            // make sure it is correct.
            //
            if (pDispParams-&gt;cArgs &gt; 1
               &amp;&amp; pDispParams-&gt;rgvarg[1].vt == VT_I4
               &amp;&amp; pDispParams-&gt;rgvarg[0].vt == VT_I4)
            {
               if (-1 == pDispParams-&gt;rgvarg[1].lVal)
                  m_fCanBePrinted = TRUE;
            }
         }

         break;

      default:
         // Call the base class implementation of Invoke
         // so that IPrintCtl methods and properties will
         // work correctly.
         //
         IDispatchImpl&lt;IPrintCtl, &amp;IID_IPrintCtl, 
            &amp;LIBID_ATLPRINTLib&gt;::Invoke(dispidMember, riid, lcid,
                                        wFlags, pDispParams,
                                        pvarResult, pExcepInfo, puArgErr);

         break;
   }

   return S_OK;
}
</PRE>
</td></tr></table></p>

<p>In the handler for the <I>ProgressChange </I>event, when the 
<I>Progress </I>parameter 
(<I>pDispParams-&gt;rgvarg[1].lVal</I>) is 
<I>-1</I>, we set a data member that tells the control 
that the document is completely finished loading and that the user can print. Declare 
this data member as a protected or private member of type 
<I>BOOL</I> belonging to the <I>CPrintCtl</I> class. Initialize the data member to 
<I>FALSE</I> in the constructor for the 
<I>CPrintCtl </I>class.</p>

<p>Now when the user tries to print the document by calling the 
<I>Print </I>method, you can check the data member to see whether the document is ready to be printed. 
Here's the updated code for the <I>Print </I>method:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHODIMP CPrintCtl::Print()
{
   if (!m_fCanBePrinted)
   {
      ::MessageBox(NULL, _T(&quot;The page is not ready to be printed.&quot;),
                   _T(&quot;PrintCtl&quot;), MB_OK);
      return E_FAIL;
   }

   ATLASSERT(m_spWebBrowser);

   HRESULT hr = E_FAIL;

   if (m_spWebBrowser)
   {
      hr = m_spWebBrowser-&gt;ExecWB(OLECMDID_PRINT, 
                                  OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
   }

   return hr;
}
</PRE>
</td></tr></table></p>

<p>If the <I>m_fCanBePrinted </I>data member is 
<I>FALSE</I>, the code displays a message box that tells the user that the document isn't ready to be printed. If this data 
member is <I>TRUE</I>, the code goes ahead and prints the document. You can find the 
entire code for the updated AtlPrint example on the companion CD in the folder \Samples
\Chap07\AtlPrintEvt.</p>


<p>
<div class="sidebar"><blockquote><p><b>What's Next?</b></p>
Now you're an expert at hosting the WebBrowser control and 
automating Internet Explorer! And you can perform both of these tasks in Visual Basic 
and Visual C++ applications. Plus, you know how to use the WebBrowser's 
methods, properties, and events. In the <a href="ch08a.htm">next chapter</a>, you'll build on this experience 
by using the DHTML Object Model to access and change the contents of Web 
pages. (I discussed how to do this from scripting in <A HREF="ch03a.htm">Chapter 3</A>.) In <A HREF="ch08a.htm">Chapter 8</A>, we'll 
revisit the DHTML Object Model and see how to access and change the contents 
of documents from Visual Basic and Visual C++ applications.
</blockquote></div>
</p>

</BODY>
</HTML>





