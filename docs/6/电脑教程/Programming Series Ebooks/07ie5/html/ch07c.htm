<HTML>
<head>
<link rel="STYLESHEET" type="text/css" href="Progie5.css">
<TITLE>Ways to Sink Events</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch07b.htm">[Previous]</A> <A HREF="ch07d.htm">[Next]</A><P>

<A NAME="184"><H1>Ways to Sink Events</H1></A>

<p>Depending on which development tool you use to create the client application, 
you can sink events in different ways. Obviously, sinking events in a Visual Basic 
application is much different from and easier than sinking events in a C++ application. 
In C++ applications, you can use different techniques to sink events according to 
whether you're using ATL, MFC, or standard C++.</p>

<A NAME="185"><H2>Sinking Events in Visual Basic</H2></A>

<p>Visual Basic is the easiest development tool to use when creating most types 
of applications, so you shouldn't be surprised when I tell you that Visual Basic is 
the easiest tool to use when sinking events. The ATL and Visual Basic examples that 
we're about to examine look and act the same, but the ATL example took me about 
four hours to complete, whereas the Visual Basic example took about 20 minutes. 
Don't get me wrong&#8212;I'm a strong advocate of C++, ATL, and MFC, especially when 
you're creating your own interfaces. But Visual Basic is a great development tool to use 
when creating client applications that sink events from servers such as Internet Explorer.</p>

<p>OK, so how do you sink events in a Visual Basic application? When hosting 
the WebBrowser control, you don't have to do anything special. Visual Basic sets up 
the event sink for the WebBrowser control on the form. All you have to do is create 
event handlers for any events that you're interested in.</p>

<p>You create these event handlers just like you create event handlers for any 
other event (such as the <I>Form_Load</I> event). Choose the event you want to handle from 
the Procedure<I> </I>drop-down list box in the upper right-hand corner of the Visual 
Basic Integrated Development Environment (IDE) after choosing the object from the 
Object drop-down list in the upper left-hand corner of the IDE. Then, in the event 
handler, just add whatever code you want to execute when the event is fired.</p>

<p>To sink events when automating a server, such as Internet Explorer from 
a Visual Basic application, the procedure is just as straightforward. First set a 
reference to the type library of the server in the References dialog box, which you can 
access from the Project/References menu. To set a reference to the type library 
for Internet Explorer, check the Microsoft Internet Controls option in the 
References dialog box. If you don't select this type library, Visual Basic won't be able to 
resolve the reference to the 
<I>InternetExplorer</I> object in your code. Then declare a variable 
of the type of server you are automating. When you declare this variable, specify 
the <I>WithEvents</I> keyword to tell Visual Basic that you want to receive events from 
the server. For example, if you were automating Internet Explorer, you would 
declare a variable like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>Dim WithEvents InternetExplorer1 As InternetExplorer
</PRE>
</td></tr></table></p>

<p>Next create an instance of the server by using 
the<I> CreateObject</I> method or the <I>New</I> keyword. Here is an example of using 
the<I> CreateObject</I> method:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>Set InternetExplorer1 = CreateObject(&quot;InternetExplorer.Application.1&quot;)
</PRE>
</td></tr></table></p>

<p>Here is an example of using the <I>New </I>keyword:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>Set InternetExplorer1 = New InternetExplorer
</PRE>
</td></tr></table></p>

<p>When you create an instance of the server by using either of these 
approaches, Visual Basic automatically initializes and manages the event sink for you. It's as 
simple as that. You don't have to worry about getting a pointer to the connection point 
container and then finding the connection point that you want. Visual Basic 
handles it.</p>

<p>After you enter the code to create the server, you insert method calls that 
correspond to the events that the server is firing. (As mentioned earlier, you can 
choose these events from the Procedure<I> </I>drop-down list in the Visual Basic IDE after 
choosing the name of your Internet Explorer 
object&#8212;<I>InternetExplore1</I>&#8212;from the 
Object<I> </I>drop-down list.) For example, if you wanted to handle the 
<I>DownloadBegin</I> event that is fired by Internet Explorer, you would declare a method like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>Private Sub InternetExplorer1_DownloadBegin()
   ' Insert your best Visual Basic code here.
End Sub
</PRE>
</td></tr></table></p>

<p>When you no longer want to receive events from the server, just set 
the Internet Explorer variable to 
<I>Nothing</I>:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>Set InternetExplorer1 = Nothing
</PRE>
</td></tr></table></p>

<p>Now you're ready to look at the first example of Internet Explorer event 
sinking, VBIEEvtSpy, which is shown in Figure 7-2. This example has one form that 
contains a multiline text box and two buttons. One of the buttons starts an instance of 
Internet Explorer. The other exits from the program and shuts down the running instance 
of Internet Explorer, if one exists. Each time Internet Explorer fires an event, a 
description of it is placed in the text box.</p>


<p>
<A HREF="javascript:fullSize('F07ii02x.htm')"> <img src="images/F07ii02.JPG" width=404 height=338 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 7-2.</b> <i>VBIEEvtSpy.</i><!-- /caption -->
</p>


<p>Writing the code for VBIEEvtSpy is straightforward. First a variable is 
declared to represent an instance of Internet Explorer. The 
<I>WithEvents</I> keyword is specified when declaring this variable so that the client can receive events from Internet 
Explorer. When the user clicks the Start IE5 button, the 
<I>New</I> keyword is used to create a new instance of Internet Explorer. Then we make this instance visible and navigate to 
the user's home page. (This is exactly how we automated Internet Explorer in the 
last chapter.) Here's the code for the 
<I>Click</I> event handler for the Start IE5 button:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>Private Sub btnStartIE_Click()
   ' Start a new instance of InternetExplorer
   ' only if one was not previously started.
   '
   If InternetExplorer1 Is Nothing Then
      Set InternetExplorer1 = New InternetExplorer
      InternetExplorer1.Visible = True
      InternetExplorer1.GoHome
      
      btnStartIE.Enabled = False
   End If
End Sub
</PRE>
</td></tr></table></p>

<p>In this code, just as in the VBAutoIE example in <A HREF="ch06a.htm">Chapter 6</A>, a new instance 
of Internet Explorer is started only if one hasn't already been started. But 
VBIEEvtSpy<I> </I>isn't limited to running only one instance of Internet Explorer each time VBIEEvtSpy 
is run. In this example, we can detect when the user closes the browser by 
handling Internet Explorer's <I>OnQuit</I> event. When Internet Explorer fires the 
<I>OnQuit</I> event, we set the 
<I>InternetExplorer1</I> object to <I>Nothing</I> so that we know it's ready to create 
another instance of Internet Explorer.</p>

<p>VBIEEvtSpy<I> </I>displays messages in a text box each time the Internet 
Explorer object fires an event of interest. In the handler functions for the events, a message 
is printed to the text box to alert the user that an event has been fired. In this 
example, only a subset of events is handled. You can add event handler functions for 
any other events that you want to handle. All event handlers perform basically the 
same task. I'll explain the Internet Explorer events (that is, the WebBrowser control 
events) later in this chapter. You can find this sample on the companion CD in the 
folder \Samples\Chap07\VBIEEvtSpy. For now, here's one of the event handlers in 
this application:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>Private Sub InternetExplorer1_DownloadComplete()
   strEvents = strEvents + &quot;DownloadComplete&quot; + vbNewLine
   txtEvents.Text = strEvents
End Sub
</PRE>
</td></tr></table></p>

<A NAME="186"><H2>Sinking Events in C++</H2></A>

<p>Sinking events in a C++ application involves a little more work than in a Visual 
Basic application. But if you're hosting the WebBrowser control in an MFC 
dialog-based application, you can just choose the events you want to handle by using 
ClassWizard. Hosting the WebBrowser control in another type of application or automating 
Internet Explorer in any C++ application is a bit more difficult but still doesn't require 
much work. To sink events in a C++ client application, just follow these five steps:</p>

<OL>
<p><li> Get a pointer to the connection point container 
(<I>IConnectionPointContainer</I>).</li></p>
<p><li> Call the 
<I>FindConnectionPoint</I> method of <I>IConnectionPointContainer 
</I>to find the connection point for which you want to sink events. For 
Internet Explorer, you'll be sinking events for the 
<I>DWebBrowserEvents2 </I>connection point interface. (Optionally, you can call 
<I>EnumConnectionPoints</I> to enumerate through all the connection points that a server supports.)</li></p>
<p><li> Advise the connection point that you want to receive events. When 
advising, pass a pointer to the <I>IUnknown</I> interface of the event sink. 
Remember that the event sink must implement the 
<I>IDispatch</I> interface to receive events from the WebBrowser. The 
<I>Advise</I> method will return a cookie that you must use when you call the 
<I>Unadvise </I>method.</li></p>
<p><li> Implement 
<I>IDispatch::Invoke</I> to handle any events that are fired. 
(Development tools such as MFC and ATL can make this easy for you to do.)</li></p>
<p><li> When you no longer want to receive events, call 
<I>Unadvise</I>,<I> </I>and pass it the cookie that you received from the call to 
<I>Advise</I>.</li></p>
</ol>

<p>These steps might not be obvious if you're developing in Visual Basic or 
using MFC or ATL, but they are important when creating client applications in standard C++.</p>

<p>The following C++ code allows you to sink events when 
automating Internet Explorer. Look for the comments that describe which step is being 
implemented. Assume that the <I>ConnectEvents</I> method is called when you want to 
establish the event sink and that the <I>Exit</I> method is called when the program is exited. 
Also, the class <I>CSomeClass</I> inherits from 
<I>IDispatch</I>,<I> </I>and the<I> m_pIE</I> data member 
represents an instance of Internet Explorer that was created through a call to 
<I>CoCreateInstance</I>,<I> </I>as you saw in <A HREF="ch06a.htm">Chapter 6</A>. (Note that 
<I>CSomeClass </I>is just some arbitrary name of 
your choosing.)</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>void CSomeClass::ConnectEvents()
{
   IConnectionPointContainer* pCPContainer;

   // Step 1: Get a pointer to the connection point container.
   //
   HRESULT hr = m_pIE-&gt;QueryInterface(IID_IConnectionPointContainer, 
                                      (void**)&amp;pCPContainer);
   if (SUCCEEDED(hr))
   {
      // m_pConnectionPoint is defined like this:
      // IConnectionPoint* m_pConnectionPoint;

      // Step 2: Find the connection point.
      //
      hr = pCPContainer-&gt;FindConnectionPoint(DIID_DWebBrowserEvents2, 
                                             &amp;m_pConnectionPoint);

      if (SUCCEEDED(hr))
      {
         // Step 3: Advise the connection point that you 
         // want to sink its events.
         //
         hr = m_pConnectionPoint-&gt;Advise(this, &amp;m_dwCookie);
         if (FAILED(hr))
         {
            ::MessageBox(NULL, &quot;Failed to Advise&quot;,
                         &quot;C++ Event Sink&quot;, MB_OK);
         }
      }

      pCPContainer-&gt;Release();
   }
}

void CSomeClass::Exit()
{
   // Step 5: Unadvise. Note that m_pConnectionPoint should
   // be released in the destructor for CSomeClass.
   //
   if (m_pConnectionPoint)
   {
      HRESULT hr = m_pConnectionPoint-&gt;Unadvise(m_dwCookie);
      if (FAILED(hr))
      {
         ::MessageBox(NULL, &quot;Failed to Unadvise&quot;,
                      &quot;C++ Event Sink&quot;, MB_OK);
      }
   }
}
</PRE>
</td></tr></table></p>

<p>Notice that I left out step 4: the implementation of the client's 
<I>IDispatch::Invoke</I> method. I will be talking about this method shortly. The server calls it each 
time the server fires an event. The server passes to 
<I>Invoke</I> the dispatch ID (DISPID) of the event that it is firing. For Internet Explorer 5, the following DISPIDs are 
defined in the ExDispID.h header file. (DISPIDs that pertain to Internet Explorer 
3.<I>x </I>still exist in ExDispID.h for backward compatibility.)</p>

<UL>
<p><li> DISPID_BEFORENAVIGATE2</li></p>
<p><li> DISPID_COMMANDSTATECHANGE</li></p>
<p><li> DISPID_DOCUMENTCOMPLETE</li></p>
<p><li> DISPID_DOWNLOADBEGIN</li></p>
<p><li> DISPID_DOWNLOADCOMPLETE</li></p>
<p><li> DISPID_NAVIGATECOMPLETE2</li></p>
<p><li> DISPID_NEWWINDOW2</li></p>
<p><li> DISPID_ONFULLSCREEN</li></p>
<p><li> DISPID_ONMENUBAR</li></p>
<p><li> DISPID_ONQUIT</li></p>
<p><li> DISPID_ONSTATUSBAR</li></p>
<p><li> DISPID_ONTHEATERMODE</li></p>
<p><li> DISPID_ONTOOLBAR</li></p>
<p><li> DISPID_ONVISIBLE</li></p>
<p><li> DISPID_PROGRESSCHANGE</li></p>
<p><li> DISPID_PROPERTYCHANGE</li></p>
<p><li> DISPID_STATUSTEXTCHANGE</li></p>
<p><li> DISPID_TITLECHANGE</li></p>
</UL>
 
<p>Now we can turn our attention to the mother of all automation 
methods&#8212;<I>Invoke</I>. This method takes eight parameters, but we'll discuss only two of them: 
<I>dispidMember</I> and <I>pDispParams</I>. (For information about the other six parameters, see the 
documentation for <I>IDispatch::Invoke</I> in MSDN.)</p>

<p>The <I>dispidMember</I> parameter tells you which event has been fired. If the 
client application is sinking events from Internet Explorer, the value of the 
<I>dispidMember</I> parameter corresponds to one of the DISPIDs listed earlier.</p>

<p>The <I>pDispParams</I> input parameter is a pointer to a structure that contains, 
among other items, a count of the number of parameters for the event that is being fired 
and the actual parameters themselves. Parameters passed to the event handler are 
stored in <I>pDispParams</I>-&gt;<I>rgvarg</I> in reverse order as they appear in the parameter list for 
the event. For example, Internet Explorer fires the 
<I>NavigateComplete2</I> event like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>NavigateComplete2(pDisp, URL)
</PRE>
</td></tr></table></p>

<p>When <I>Invoke</I> is called, 
<I>pDispParams-&gt;cArgs</I> will contain a value of 
<I>2</I>, with the <I>URL </I>parameter in 
<I>pDispParams-&gt;rgvarg[0]</I> and the <I>pDisp 
</I>parameter in <I>pDispParams-&gt;rgvarg[1]</I>. The parameters for the <I>NavigateComplete2 
</I>event are sent in reverse order as they appear in the method signature for 
<I>NavigateComplete2 </I>in the preceding line of code. (The term &quot;method signature&quot; is the object-oriented terminology for 
what you would call a <I>function prototype</I> in C.) This is just the way that COM orders 
input parameters when sending them to the <I>Invoke 
</I>method.</p>

<p>The following code shows a sample implementation of 
<I>Invoke</I> that handles the 
<I>NavigateComplete2</I> event. Notice that this code uses the ATL class 
<I>CComVariant</I> to perform conversion from 
<I>VARIANT</I> to <I>BSTR</I>. (The ATL code in the next section 
demonstrates even more events.)</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>#include &lt;strstrea.h&gt;
STDMETHODIMP CSomeClass::Invoke(DISPID dispidMember,
                                REFIID riid,
                                LCID lcid, 
                                WORD wFlags,
                                DISPPARAMS* pDispParams,
                                VARIANT* pvarResult,
                                EXCEPINFO*  pExcepInfo,
                                UINT* puArgErr)
{
   USES_CONVERSION;
   strstream strEventInfo;

   if (!pDispParams)
      return E_INVALIDARG;

   switch (dispidMember)
   {
      // The parameters for this DISPID:
      // [0]: URL navigated to - VT_BYREF|VT_VARIANT
      // [1]: An object that evaluates to the top-level or frame
      //      WebBrowser object corresponding to the event. 
      //
      case DISPID_NAVIGATECOMPLETE2:
         // Check the argument's type.
         if (pDispParams-&gt;rgvarg[0].vt == (VT_BYREF|VT_VARIANT))
         {
            CComVariant varURL(*pDispParams-&gt;rgvarg[0].pvarVal);
            varURL.ChangeType(VT_BSTR);

            // strEventInfo is an object of type strstream.
            //
            strEventInfo &lt;&lt; &quot;NavigateComplete2: &quot;
                         &lt;&lt; OLE2T(vtURL.bstrVal)
                         &lt;&lt; ends;

            ::MessageBox(NULL, strEventInfo.str(), &quot;Invoke&quot;, MB_OK);
         }
         break;    

      default:
         break;
   }

   return S_OK;
}
</PRE>
</td></tr></table></p>

<A NAME="187"><H2>Sinking Events in ATL</H2></A>

<p>Along with providing default implementations of certain COM interfaces, ATL 
provides two functions&#8212;<I>AtlAdvise</I> and 
<I>AtlUnadvise</I>&#8212;that simplify the job of sinking 
events for any connectable object.</p>

<p>The <I>AtlAdvise</I> function tells a connectable object that the client wants to 
receive events from it. This function accomplishes steps 1 through 3 of the event sinking 
steps (described in the &quot;<A HREF="ch07c.htm#186">Sinking Events in C++</A>&quot; section). 
<I>AtlAdvise</I> certainly saves you a lot of time and effort. Just like the 
<I>IConnectionPoint::Advise</I> method, <I>AtlAdvise 
</I>returns a cookie that you later use in the call to 
<I>AtlUnadvise</I>. <I>AtlUnadvise</I> tells the 
connectable object that the client no longer wants to receive events.</p>

<p>Let's say, for example, that an ATL application is automating Internet 
Explorer, so you want to know about any events that are fired by Internet Explorer. To 
tell Internet Explorer that the client wants to receive events, make the following call 
to <I>AtlAdvise</I>:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>HRESULT hr = AtlAdvise(m_spInetExplorer, GetUnknown(),
                       DIID_DWebBrowserEvents2, &amp;m_dwCookie);
</PRE>
</td></tr></table></p>

<p>Four parameters are passed to <I>AtlAdvise</I>. The first parameter is a pointer to 
the connectable object's <I>IUnknown</I> interface. The 
<I>m_spInetExplorer</I> data member is a smart pointer that represents the running instance of Internet Explorer that 
we're automating. Because the pointer held in 
<I>m_spInetExplorer</I> points to an object that inherits directly or indirectly from 
<I>IUnknown</I>, the compiler automatically 
converts <I>m_spInetExplorer</I> to a pointer to 
<I>IUnknown</I> of the running instance of Internet 
Explorer.</p>

<p>The second parameter in the call to 
<I>AtlAdvise</I> must be a pointer to the 
<I>IUnknown </I>interface of the object that represents the event sink. The 
<I>GetUnknown</I> method returns this pointer. Remember that the class that represents the event sink must 
implement <I>IDispatch</I> in some way. In this case, the class is inheriting from 
<I>IDispatch</I>.</p>

<p>The third parameter in the call to <I>AtlAdvise 
</I>is the IID of the connection point for which you want to sink events. The IID of the connection point 
for Internet Explorer events is 
<I>DIID_DWebBrowserEvents2</I>.</p>

<p>The last parameter is a pointer to a DWORD that stores a cookie when 
the function returns. This cookie will be used in a call to 
<I>AtlUnadvise</I>.</p>

<p>The rest of the code is the same as if this example were a normal C++ 
application. The client must implement 
<I>IDispatch::Invoke</I> to handle the events that Internet Explorer fires. When your application is finished receiving events 
from Internet Explorer, just call 
<I>AtlUnadvise</I>, like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>HRESULT hr = AtlUnadvise(m_spInetExplorer,
                         DIID_DWebBrowserEvents2, 
                         m_dwCookie);
</PRE>
</td></tr></table></p>

<p>Now let's look at the second example, ATLIEEvtSpy, which you can find on 
the companion CD in the folder \Samples\Chap07\ATLIEEvtSpy. The ATLIEEvtSpy 
example behaves almost exactly the same as VBIEEvtSpy, the Visual Basic example we 
looked at earlier in this chapter. Like VBIEEvtSpy, 
ATLIEEvtSpy<I> </I>is a dialog-based application that has a list box and two buttons. (See Figure 7-3.)</p>


<p>
<A HREF="javascript:fullSize('F07ii03x.htm')"> <img src="images/F07ii03.JPG" width=404 height=303 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 7-3.</b> <i>ATLIEEvtSpy.</i><!-- /caption -->
</p>


<p>When the user clicks the Start IE5 button, the call to the 
<I>CoCreateInstance</I> method creates an instance of Internet Explorer in the message handler for this 
button. That instance of Internet Explorer is made visible, and the user's home page 
is loaded into the browser. Here's the code that performs these actions:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>hr = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER, 
                      IID_IWebBrowser2, (void**)&amp;m_spInetExplorer);
if (SUCCEEDED(hr))
{
   m_spInetExplorer-&gt;put_Visible(TRUE);
   m_spInetExplorer-&gt;GoHome();        

<img src="images/grayvellip.JPG" width=3 height=13 border="0">
</PRE>
</td></tr></table></p>

<p>Next, <I>AtlAdvise </I>is called to establish the 
<I>CIEEvtObj</I> class as the event sink, like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>hr = AtlAdvise(m_spInetExplorer, GetUnknown(),
               DIID_DWebBrowserEvents2, &amp;m_dwCookie);
</PRE>
</td></tr></table></p>

<p>The <I>CIEEvtObj</I> class inherits from 
<I>IDispatch</I>,<I> </I>so the <I>CIEEvtObj</I> class can be 
used as the event sink. The <I>Invoke </I>method is implemented in 
<I>CIEEvtObj</I> to handle events. Each time Internet Explorer fires an event, the client displays a message in the 
list box for events. The following code shows the implementation of 
<I>Invoke </I>for this class:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHODIMP CIEEvtObj::Invoke(DISPID dispidMember, 
                               REFIID riid, 
                               LCID lcid, 
                               WORD wFlags, 
                               DISPPARAMS* pDispParams, 
                               VARIANT* pvarResult,
                               EXCEPINFO* pExcepInfo,  
                               UINT* puArgErr)
{
   _ASSERT(m_spInetExplorer);

   USES_CONVERSION;
   strstream strEventInfo;

   if (!pDispParams)
      return E_INVALIDARG;

   switch (dispidMember)
   {
      //
      // The parameters for this DISPID are as follows:
      // [0]: Cancel flag  - VT_BYREF|VT_BOOL
      // [1]: HTTP headers - VT_BYREF|VT_VARIANT
      // [2]: Address of HTTP POST data  - VT_BYREF|VT_VARIANT 
      // [3]: Target frame name - VT_BYREF|VT_VARIANT 
      // [4]: Option flags - VT_BYREF|VT_VARIANT
      // [5]: URL to navigate to - VT_BYREF|VT_VARIANT
      // [6]: An object that evaluates to the top-level or frame
      //      WebBrowser object corresponding to the event 
      //
      case DISPID_BEFORENAVIGATE2:
         strEventInfo &lt;&lt; &quot;BeforeNavigate2: &quot;;

         if (pDispParams-&gt;cArgs &gt;= 5
            &amp;&amp; pDispParams-&gt;rgvarg[5].vt == (VT_BYREF|VT_VARIANT))
         {
            CComVariant vtURL(*pDispParams-&gt;rgvarg[5].pvarVal);
            vtURL.ChangeType(VT_BSTR);

            strEventInfo &lt;&lt; OLE2T(vtURL.bstrVal);
         }
         else
            strEventInfo &lt;&lt; &quot;NULL&quot;;

         strEventInfo &lt;&lt; ends;
         break;

      //
      // The parameters for this DISPID:
      // [0]: Enabled state - VT_BOOL
      // [1]: Command identifier - VT_I4
      //
      case DISPID_COMMANDSTATECHANGE:
         strEventInfo &lt;&lt; &quot;CommandStateChange: &quot;;

         if (pDispParams-&gt;cArgs == 0)
            strEventInfo &lt;&lt; &quot;NULL&quot;;
         else
         {
            if (pDispParams-&gt;cArgs &gt; 1 
               &amp;&amp; pDispParams-&gt;rgvarg[1].vt == VT_I4)
            {
               strEventInfo &lt;&lt; &quot;Command = &quot; 
                            &lt;&lt; pDispParams-&gt;rgvarg[1].lVal;
            }

            if (pDispParams-&gt;rgvarg[0].vt == VT_BOOL)
            {
               strEventInfo &lt;&lt; &quot;, Enabled = &quot;
                      &lt;&lt; ((pDispParams-&gt;rgvarg[0].boolVal == VARIANT_TRUE) 
                           ? &quot;True&quot; : &quot;False&quot;);
            }
         }

         strEventInfo &lt;&lt; ends;
         break;

      case DISPID_DOCUMENTCOMPLETE:
         strEventInfo &lt;&lt; &quot;DocumentComplete&quot; &lt;&lt; ends;
         break;

      case DISPID_DOWNLOADBEGIN:
         strEventInfo &lt;&lt; &quot;DownloadBegin&quot; &lt;&lt; ends;
         break;

      case DISPID_DOWNLOADCOMPLETE:
         strEventInfo &lt;&lt; &quot;DownloadComplete&quot; &lt;&lt; ends;
         break;

      //
      // The parameters for this DISPID:
      // [0]: URL navigated to - VT_BYREF|VT_VARIANT
      // [1]: An object that evaluates to the top-level or frame
      //      WebBrowser object corresponding to the event 
      //
      case DISPID_NAVIGATECOMPLETE2:
         if (pDispParams-&gt;rgvarg[0].vt == (VT_BYREF|VT_VARIANT))
         {
            CComVariant vtURL(*pDispParams-&gt;rgvarg[0].pvarVal);
            vtURL.ChangeType(VT_BSTR);
  
            strEventInfo &lt;&lt; &quot;NavigateComplete2: &quot;
                         &lt;&lt; OLE2T(vtURL.bstrVal)
                         &lt;&lt; ends;
         }
         break;

      //
      // The parameters for this DISPID:
      // [0]: Maximum progress - VT_I4
      // [1]: Amount of total progress - VT_I4
      //
      case DISPID_PROGRESSCHANGE:
         strEventInfo &lt;&lt; &quot;ProgressChange: &quot;;

         if (pDispParams-&gt;cArgs == 0)
            strEventInfo &lt;&lt; &quot;NULL&quot;;
         else
         {
            if (pDispParams-&gt;cArgs &gt; 1 
               &amp;&amp; pDispParams-&gt;rgvarg[1].vt == VT_I4)
            {
               strEventInfo &lt;&lt; &quot;Progress = &quot; 
                            &lt;&lt; pDispParams-&gt;rgvarg[1].lVal;
            }

            if (pDispParams-&gt;rgvarg[0].vt == VT_I4)
               strEventInfo &lt;&lt; &quot;, ProgressMax = &quot; 
                            &lt;&lt; pDispParams-&gt;rgvarg[0].lVal;
         }

         strEventInfo &lt;&lt; ends;
         break;

      //
      // The parameter for this DISPID:
      // [0]: Name of property that changed - VT_BSTR
      //
      case DISPID_PROPERTYCHANGE:
         strEventInfo &lt;&lt; &quot;PropertyChange: &quot;;

         if (pDispParams-&gt;cArgs &gt; 0 
            &amp;&amp; pDispParams-&gt;rgvarg[0].vt == VT_BSTR)
         {
            strEventInfo &lt;&lt; OLE2T(pDispParams-&gt;rgvarg[0].bstrVal);
         }
         else
         {
            strEventInfo &lt;&lt; &quot;NULL&quot;;
         }

         strEventInfo &lt;&lt; ends;
         break;

      //
      // The parameters for this DISPID:
      // [0]: New status bar text - VT_BSTR
      //
      case DISPID_STATUSTEXTCHANGE:
         LPOLESTR lpStatusText;

         m_spInetExplorer-&gt;get_StatusText(&amp;lpStatusText);
         strEventInfo &lt;&lt; &quot;StatusTextChange: &quot;;

         if (!strcmp(OLE2T(lpStatusText), &quot;&quot;))
            strEventInfo &lt;&lt; &quot;NULL&quot;;
         else
            strEventInfo &lt;&lt; OLE2T(lpStatusText);

         strEventInfo &lt;&lt; ends;
         break;

      case DISPID_NEWWINDOW2:
         strEventInfo &lt;&lt; &quot;NewWindow2&quot; &lt;&lt; ends;
         break;

      //
      // The parameter for this DISPID:
      // [0]: Document title - VT_BSTR
      //
      case DISPID_TITLECHANGE:
         strEventInfo &lt;&lt; &quot;TitleChange: &quot;;

         if (pDispParams-&gt;cArgs &gt; 0 
            &amp;&amp; pDispParams-&gt;rgvarg[0].vt == VT_BSTR)
         {
            strEventInfo &lt;&lt; OLE2T(pDispParams-&gt;rgvarg[0].bstrVal);
         }
         else
         {
            strEventInfo &lt;&lt; &quot;NULL&quot;;
         }

         strEventInfo &lt;&lt; ends;
         break;

      // The user has told Internet Explorer to close.
      //
      case DISPID_ONQUIT:
         return Stop();

      default:
         // Note: This class acts only as an event sink, so
         // there's no reason to call the base class version of Invoke.

         strEventInfo &lt;&lt; &quot;Unknown Event&quot; &lt;&lt; dispidMember &lt;&lt; ends;
         break;
   }

   AddEventToList(strEventInfo.str());

   return S_OK;
}
</PRE>
</td></tr></table></p>

<p>Notice that I used the standard C++ library's 
<I>strstream</I> class to build the string to display in the list box. I did this because ATL doesn't provide a string class 
like the <I>CString </I>class that MFC provides. Each time an event is received 
from Internet Explorer, a string is created that contains the name of the event and 
any important parameters. Then a helper method of the 
<I>CIEEvtObj</I> class is called to write the string to the list box in the dialog box.</p>

<p>When the user clicks the Exit button or the Close button in the upper 
right-hand corner of the dialog box, the 
<I>AtlUnadvise</I> function is called to tell Internet 
Explorer that the client no longer wants to receive events. The following code calls 
<I>AtlUnadvise</I>:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>STDMETHODIMP CIEEvtObj::Stop()
{
   if (m_spInetExplorer)
   {
      HRESULT hr = AtlUnadvise(m_spInetExplorer, 
                               DIID_DWebBrowserEvents2, 
                               m_dwCookie);

      if (FAILED(hr))
         ATLTRACE(&quot;Failed to Unadvise\n&quot;);
   }

   PostQuitMessage(0);
   return S_OK;
}
</PRE>
</td></tr></table></p>

<A NAME="188"><H2>Sinking Events in MFC</H2></A>

<p>MFC provides several handy macros that you can use to sink events when 
automating a server or hosting a control. In both cases, the class that you use for the event 
sink must inherit either directly or indirectly from 
<I>CCmdTarget</I>. <I>CCmdTarget </I>implements the 
<I>IDispatch </I>interface that is used for sinking events. In addition, you must call 
the <I>EnableAutomation</I> function in your application to initialize the 
<I>IDispatch </I>interface that is contained within 
<I>CCmdTarget</I>.</p>

<A NAME="189"><H3>Sinking events in MFC when automating a COM object</H3></A>

<p>Sinking events in MFC when automating a COM object is relatively easy. All you 
have to do is write code to call the <I>AfxConnectionAdvise 
</I>helper function to advise the connection point that the client needs to receive events. When the client does 
not want to receive events, it calls 
<I>AfxConnectionUnadvise</I>. The <I>AfxConnectionAdvise 
</I>and <I>AfxConnectionUnadvise</I> functions are defined in the afxctl.h header file.</p>

<p>The <I>AfxConnectionAdvise</I> function takes care of querying for the 
connection point container, finding the connection point, and advising the connection point. 
This function takes the five parameters listed in Table 7-3.</p>

<p><b>Table 7-3</b> <i>Parameters of the </I>AfxConnectionAdvise <I>Function</i></p>
<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>Parameter</i></th>
<th><i>Description</i></th>
</tr>

<tr>
<td valign="top"><I>pUnkSrc</I></td>
<td valign="top">A pointer to the 
<I>IUnknown</I> interface of the COM object that fires 
the events. For example, if you're automating a COM object, 
<I>pUnkSrc</I> is a pointer to the object that is created by a call to 
<I>CoCreateInstance</I>.</td>
</tr>

<tr>
<td valign="top"><I>pUnkSink</I></td>
<td valign="top">A pointer to the 
<I>IUnknown</I> interface of the event sink.</td>
</tr>

<tr>
<td valign="top"><I>iid</I></td>
<td valign="top">The IID of the connection point. For Internet Explorer, this is 
<I>DIID_DWebBrowserEvents2</I>.</td>
</tr>

<tr>
<td valign="top"><I>bRefCount</I></td>
<td valign="top">Passing <I>TRUE</I> indicates that creating the connection should 
cause the reference count of <I>pUnkSink</I> to be incremented. Passing 
<I>FALSE</I> indicates that the reference count shouldn't be incremented.</td>
</tr>

<tr>
<td valign="top"><I>pdwCookie</I></td>
<td valign="top">The identifier of the connection. This identifier is returned 
by <I>AfxConnectionAdvise</I> and should be passed as the 
<I>dwCookie</I> parameter to 
<I>AfxConnectionUnadvise</I> when disconnecting the connection.</td>
</tr>
</table>
</p>

<p>The input parameters for 
<I>AfxConnectionUnadvise</I> are the same except 
that <I>bRefCount</I> indicates whether the reference count of 
<I>pUnkSink</I> should be decremented. Also, the final parameter, 
<I>pdwCookie</I>, is changed to <I>dwCookie</I>, which contains 
the value of the cookie.</p>

<p>Handling events is just as easy as setting up the connection. Remember that 
for an MFC event sink class to be able to receive events, it must inherit in some way 
from <I>CCmdTarget</I>. <I>CCmdTarget</I> uses a dispatch map to determine which event 
handler function to call when it receives an event. You must first declare this dispatch 
map in the header file and then initialize it in the implementation (.cpp) file. 
Fortunately, MFC provides a set of macros to help you define and initialize the dispatch map.</p>

<p>To define this dispatch map, simply specify the 
DECLARE_DISPATCH_MAP macro in the header file for the event sink class. This macro declares the 
dispatch map and a few functions that <I>CCmdTarget 
</I>uses to access the map. Once you've defined the dispatch map, you'll place a few macros in the implementation file 
for the dispatch map. The first macro you'll place is the BEGIN_DISPATCH_MAP 
macro. It takes the name of the event sink class and the name of the base class for the 
event sink class. For example, if the name of the event sink class is 
<I>CEventSink</I> and it inherits from 
<I>CCmdTarget</I>, the BEGIN_DISPATCH_MAP macro will look like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>BEGIN_DISPATCH_MAP(CEventSink, CCmdTarget)
</PRE>
</td></tr></table></p>

<p>Next you must specify the events that you want to handle and the names of 
the functions that will handle them. A number of macros are available that you can 
use to specify the events that you want to handle. To specify these events by their 
DISPID, use the DISP_FUNCTION_ID macro. This macro takes the six parameters listed 
in Table 7-4.</p>

<p><b>Table 7-4</b> <i>Parameters of the DISP_FUNCTION_ID Macro</i></p>

<p>
<table valign="top" cellpadding="5" width="95%">

<tr>
<th><i>Parameter</i></th>
<th><i>Description</i></th>
</tr>

<tr>
<td valign="top"><I>theClass </I></td>
<td valign="top">The name of the event sink class.</td>
</tr>

<tr>
<td valign="top"><I>szExternalName </I></td>
<td valign="top">The external name of the function.</td>
</tr>

<tr>
<td valign="top"><I>dispid</I></td>
<td valign="top">The DISPID of the event.</td>
</tr>

<tr>
<td valign="top"><I>pfnMember </I></td>
<td valign="top">The pointer to a member function that handles the event.</td>
</tr>

<tr>
<td valign="top"><I>vtRetval </I></td>
<td valign="top">The return value of the member function. This parameter 
is one of the VARENUM enumerated types defined in the 
wtypes.h header file.</td>
</tr>

<tr>
<td valign="top"><I>vtsParams </I></td>
<td valign="top">A space-separated list of one or more 
<I>VTS_</I> constants specifying the function's parameter list. 
<I>VTS</I>_ constants are defined in the afxdisp.h header file.</td>
</tr>
</table>
</p>

<p>Let's say you want to handle the 
<I>DownloadComplete</I> event fired by Internet Explorer. To tell 
<I>CCmdTarget</I> that you want to handle 
<I>DownloadComplete</I>, use the DISP_FUNCTION_ID macro like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>DISP_FUNCTION_ID(CIE5Events, &quot;DownloadComplete&quot;,
                 DISPID_DOWNLOADCOMPLETE, OnDownloadComplete,
                 VT_EMPTY, VTS_NONE)
</PRE>
</td></tr></table></p>

<p>Finally, you must close the dispatch map by using the 
END_DISPATCH_MAP<I> </I>macro. The completed dispatch map should look like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>BEGIN_DISPATCH_MAP(CEventSink, CCmdTarget)
   DISP_FUNCTION_ID(CIE5Events, &quot;DownloadComplete&quot;,
                    DISPID_DOWNLOADCOMPLETE, OnDownloadComplete,
                    VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()
</PRE>
</td></tr></table></p>

<A NAME="190"><H3>Sinking events in MFC when hosting an ActiveX control</H3></A>

<p>Sinking events when hosting a control is similar to sinking them when automating 
a COM object. The main difference is that you don't have to advise or unadvise 
the connection point. <I>CCmdTarget</I> handles this for you.</p>

<p>In the case of hosting a control, 
<I>CCmdTarget</I> uses an event sink map instead of a dispatch map. As you might have guessed, MFC provides the macros to 
define and initialize this event sink map. Declaring the event sink map is just like 
declaring the dispatch map&#8212;specify the DECLARE_EVENTSINK_MAP macro in the header 
file. In addition to declaring the map, the DECLARE_EVENTSINK_MAP macro 
declares functions that <I>CCmdTarget</I> will use to access the map.</p>

<p>Next you must initialize the event sink in the implementation file. Begin the 
event sink map with the BEGIN_EVENTSINK_MAP macro. Specify the name of the event 
sink class and its base class when using this macro. For example, here's how to begin 
the event sink map for a dialog-based class:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>BEGIN_EVENTSINK_MAP(CMyDlg, CDialog)
</PRE>
</td></tr></table></p>

<p>Now specify all the events you want to handle and their event handlers by 
using one of the ON_EVENT* macros. In most cases, you'll simply use ON_EVENT, 
which takes five parameters, as listed in Table 7-5. For example, if you want to 
handle WebBrowser control's 
<I>DownloadComplete</I> event, you would specify the following 
for the ON_EVENT macro:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>ON_EVENT(CMyDlg, IDC_WEBBROWSER, DISPID_DOWNLOADCOMPLETE, 
         OnDownloadComplete, VTS_NONE)
</PRE>
</td></tr></table></p>

<p>If you want one member function to handle a range of events, use the ON
_EVENT_RANGE macro.</p>

<p><b>Table 7-5</b> <i>Parameters of the ON_EVENT Macro</i></p>

<p>
<table valign="top" cellpadding="5" width="95%">
<tr>
<th><i>Parameter</i></th>
<th><i>Description</i></th>
</tr>

<tr>
<td valign="top"><I>theClass </I></td>
<td valign="top">The class to which this event sink map belongs.</td>
</tr>

<tr>
<td valign="top"><I>id</I></td>
<td valign="top">The resource identifier of the control.</td>
</tr>

<tr>
<td valign="top"><I>dispid </I></td>
<td valign="top">The dispatch ID of the event fired by the control.</td>
</tr>

<tr>
<td valign="top"><I>pfnHandler </I></td>
<td valign="top">The pointer to a member function that handles the event. 
This function should have a <I>BOOL</I> return type and parameter 
types that match the event's parameters. (See the last parameter in 
this table, <I>vtsParams</I>.) The function should return 
<I>TRUE</I> to indicate that the event was handled; otherwise, the function should 
return <I>FALSE</I>.</td>
</tr>

<tr>
<td valign="top"><I>vtsParams </I></td>
<td valign="top">A sequence of <I>VTS</I>_ constants that specifies the types of the 
parameters for the event. These constants are the same ones 
that are used in dispatch map entries such as 
<I>DISP_FUNCTION</I> and <I>DISP_FUNCTION_ID</I>.</td>
</tr>
</table>
</p>

<p>You must close the event sink map by using the END_EVENTSINK_MAP 
macro. The complete definition of the event sink map looks like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>BEGIN_EVENTSINK_MAP(CMyDlg, CDialog)
   ON_EVENT(CMyDlg, IDC_WEBBROWSER, DISPID_DOWNLOADCOMPLETE, 
            OnDownloadComplete, VTS_NONE)
END_EVENTSINK_MAP()
</PRE>
</td></tr></table></p>

<p>Now let's examine the final event sink example, MFCIEEvtSpy, which is 
shown in Figure 7-4. This dialog-based application hosts the WebBrowser control and 
automates Internet Explorer 5 as well. The example contains two list boxes. The left 
list box displays events for an instance of Internet Explorer that is being automated, 
and the right list box displays events for the WebBrowser control that is being hosted 
in the dialog.</p>

<p>To handle events for the WebBrowser control that is being hosted in the 
dialog, you use an event sink map. When initializing the event sink map, make an entry 
for each event that you want to handle. In each entry, specify the method that 
should be called when the event is fired as well as the list of parameter types that will 
be passed in to the event handler. For example, to handle the 
<I>DocumentComplete </I>event, you would declare and initialize an event sink map that looked like this:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>// Declare the event sink map.  This declaration goes
// in the class declaration of CMFCIEEvtSpyDlg in the 
// MFCIEEvtSpyDlg.h header file.
//
DECLARE_EVENTSINK_MAP()

// Initialize the event sink map.  These macros
// go in the implementation file _ MFCIEEvtSpyDlg.cpp.
//
BEGIN_EVENTSINK_MAP(CMFCIEEvtSpyDlg, CDialog)
   ON_EVENT(CMFCIEEvtSpyDlg, IDC_WEBBROWSER, DISPID_DOCUMENTCOMPLETE,
            OnDocumentComplete, VTS_DISPATCH VTS_PVARIANT)
END_EVENTSINK_MAP()
</PRE>
</td></tr></table></p>


<p>
<A HREF="javascript:fullSize('F07ii04x.htm')"> <img src="images/F07ii04.JPG" width=404 height=303 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 7-4.</b> <i>MFCIEEvtSpy.</i><!-- /caption -->
</p>


<p>When hosting the WebBrowser control in a dialog-based application, you 
don't usually need to insert the macros manually, because the ClassWizard can do it 
for you. In a single document interface (SDI) or multiple document interface 
(MDI) application, however, you'll have to add the macros yourself.</p>

<p>Now that the event sink map is declared, each time the WebBrowser 
control fires the <I>DocumentComplete </I>event, the 
<I>OnDocumentComplete</I> method will be called. In the 
<I>OnDocumentComplete</I> method for the <I>CMFCIEEvtSpyDlg 
</I>class, a string is created that contains the name of the event and the URL to which the user 
navigated. Then this string is added to the list box that contains the WebBrowser control 
events. The same actions are performed for many other WebBrowser control events, as 
you'll see when you look at the MFCIEEvtSpy<I> 
</I>example on the companion CD. You can find it in the folder \Samples\Chap07\MFCIEEvtSpy.</p>

<p>The following code handles the 
<I>DocumentComplete</I> event. 
<I>AddEventToList</I> is a helper function that merely adds the given string to the specified list box:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>void CMFCIEEvtSpyDlg::OnDocumentComplete(LPDISPATCH pDisp, VARIANT* URL)
{
   USES_CONVERSION;

   CString strEvt(&quot;DocumentComplete: &quot;);
   strEvt += OLE2T(URL-&gt;bstrVal);

   AddEventToList(WBListBox, strEvt);
}
</PRE>
</td></tr></table></p>

<p>When the user clicks the Start IE5 button, a new instance of Internet Explorer 
is created as the result of calling 
<I>CoCreateInstance</I> and passing 
<I>CLSID_InternetExplorer</I>. In addition, 
<I>AfxConnectionAdvise</I> is called to advise the 
<I>DWebBrowserEvents2</I> connection point that it should use the 
<I>CIE5Events</I> class as the event sink for the 
instance of Internet Explorer that we are automating.</p>

<p>The <I>CIE5Events</I> class inherits from <I>CCmdTarget 
</I>and contains the event handlers for events that are fired from the running instance of Internet Explorer. 
The <I>CMFCIEEvtSpyDlg</I> class handles the events that are fired from the WebBrowser 
control that is being hosted in the dialog.</p>

<p>Here's the code for the Start IE5 button's message handler:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>void CMFCIEEvtSpyDlg::OnStartIE() 
{
   if (m_pInetExplorer == NULL)  // Can start only one instance
   {
      // Create an instance of Internet Explorer. 
      //
      HRESULT hr = CoCreateInstance(CLSID_InternetExplorer,
                                    NULL,
                                    CLSCTX_LOCAL_SERVER, 
                                    IID_IWebBrowser2, 
                                    (void**)&amp;m_pInetExplorer);
      if (SUCCEEDED(hr))
      {
         // Set up the event sink.
         //
         BOOL bAdvised = AfxConnectionAdvise(m_pInetExplorer, 
                                DIID_DWebBrowserEvents2,
                                m_pIE5Events-&gt;GetInterface(&amp;IID_IUnknown),
                                TRUE, &amp;m_dwCookie);

         // Disable the Start IE5 button so that the 
         // user knows that only one instance of 
         // Internet Explorer can be started at a time.
         //
         m_btnStartIE.EnableWindow(FALSE);

         // Make Internet Explorer visible and go home.
         //
         m_pInetExplorer-&gt;put_Visible(VARIANT_TRUE);
         m_pInetExplorer-&gt;GoHome();
      }
   }
}
</PRE>
</td></tr></table></p>

<p>To handle events for the automated instance of Internet Explorer in the 
<I>CIE5Events </I>class, you must declare a dispatch map in the class declaration for 
<I>CIE5Events </I>and initialize the map in the implementation file. For example, to declare and 
initialize the dispatch map to handle the <I>DocumentComplete 
</I>event, insert the necessary macros into the header and implementation files for 
<I>CIE5Events</I>:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>// Declare the dispatch map. This
// declaration is placed in the class declaration
// for the CIE5Events class, which is in the
// CIE5Events.h header file.
//
DECLARE_DISPATCH_MAP()

// Initialize the dispatch map in the
// implementation file for CIE5Events _ CIE5Events.cpp.
//
BEGIN_DISPATCH_MAP(CIE5Events, CCmdTarget)
   DISP_FUNCTION_ID(CIE5Events, &quot;DocumentComplete&quot;, 
                    DISPID_DOCUMENTCOMPLETE, OnDocumentComplete, 
                    VT_EMPTY, VTS_DISPATCH VTS_PVARIANT)
END_DISPATCH_MAP()
</PRE>
</td></tr></table></p>

<p>Now whenever the automated instance of Internet Explorer fires the 
event <I>DocumentComplete</I>, the 
<I>OnDocumentComplete</I> method of the 
<I>CIE5Events</I> class will be called. Just like the 
<I>OnDocumentComplete</I> method for 
<I>CMFCIEEvtSpy</I>, the <I>OnDocumentComplete</I> method creates a string that contains the name of the 
event and the URL. This string is added to the list box that contains the events for 
the automated instance of Internet Explorer. The same action is performed for many of 
the other events that Internet Explorer fires. Here's the code for 
the <I>OnDocumentComplete </I>method of 
<I>CIE5Events</I>:</p>

<p><table cellpadding=5 width="95%"><TR><TD>
<PRE>void CIE5Events::OnDocumentComplete(LPDISPATCH pDisp, VARIANT* URL)
{
   USES_CONVERSION;

   CString strEvt(&quot;DocumentComplete: &quot;);
   strEvt += OLE2T(URL-&gt;bstrVal);

   m_pParent-&gt;AddEventToList(CMFCIEEvtSpyDlg::IE5ListBox, strEvt);
}
</PRE>
</td></tr></table></p>

</BODY>
</HTML>






