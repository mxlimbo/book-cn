<HTML>
<head>
<link rel="STYLESHEET" type="text/css" href="Progie5.css">
<TITLE>Adding Advanced Functionality</TITLE>

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR="#ffffff" TEXT="#000000">
<A HREF="ch06e.htm">[Previous]</A> <A HREF="ch06g.htm">[Next]</A><P>

<A NAME="173"><H1>Adding Advanced Functionality</H1></A>

<P>Now that we've covered the basics of hosting the WebBrowser control and 
automating Internet Explorer, let's get down to the nitty gritty. In this section, I'll show you 
how to add some advanced functionality to your applications and ActiveX controls. 
I'll demonstrate how to access the 
<I>IWebBrowser2</I> interface of Internet Explorer from 
an ActiveX control and even how to get the 
<I>WebBrowser</I> object of a frame on a Web page. Then I'll explain how to implement some functionality in your application 
that isn't quite as straightforward as you might think. This section is intense. All the 
code was written by using C++ and COM, and you must have a solid understanding of 
both to completely understand the topics covered in this section.</p>

<A NAME="174"><H2>Accessing the <I>IWebBrowser2</I> Interface of Internet Explorer from an ActiveX Control</H2></A>
<P>The ability to access the <I>IWebBrowser2 </I>interface of Internet Explorer from an 
ActiveX control provides you with ultimate control over the browser and your user's 
browsing experience. This means that you can, for example, invoke the functionality of 
Internet Explorer from a Web page that you couldn't otherwise access using script. 
You might want to print or refresh the page or control where your users are 
navigating. (Knowing when and where your users are navigating requires the use of events, 
which I will discuss in the <a href="ch07a.htm">next chapter</a>.) The possibilities are endless.</P>

<p>Accessing the <I>IWebBrowser2</I> interface of Internet Explorer from an ActiveX control is not straightforward, and you can do it only from within an ActiveX control created with Visual C++. Although you can access the <I>document</I> and <I>window</I> objects of Internet Explorer from a Visual Basic ActiveX control, as I will show you in <A HREF="ch08a.htm">Chapter 8</A>, you cannot directly access the <I>WebBrowser</I> object itself.</p>

<p>Accessing the <I>IWebBrowser2 </I>interface of Internet Explorer involves four steps:</p>

<OL>
<P><LI>Include ExDisp.h and shlguid.h in the header file (.h) or 
implementation file (.cpp) for the class.</li></p>
<P><LI>Call the <I>IOleClientSite::GetContainer</I> method of the client site for the 
control. This method returns a pointer to the <I>IOleContainer </I>interface implemented by Internet Explorer.</li></p>

<P><LI>If step 2 succeeds, query the <I>IOleContainer</I> pointer for the <I>IServiceProvider</I> interface.</li></p>

<P><LI>If step 3 succeeds, call the <I>QueryService</I> method of <I>IServiceProvider </I>to obtain a pointer to the <I>IWebBrowser2</I> interface of Internet Explorer.</li></p>


<P>The <I>QueryService</I> method takes three parameters. The first 
parameter specifies the service you want to access. When obtaining a 
pointer to <I>IWebBrowser2 </I>in this manner, specify either 
<I>SID_SInternetExplorer</I> or <I>SID_SWebBrowserApp 
</I>for the service. (In actuality, these are both 
defined to be <I>IID_IWebBrowserApp.</I>) The second parameter is the interface ID 
for the interface pointer you want to receive. For this parameter you 
should specify <I>IID_IWebBrowser2</I>. Finally, for the third parameter you specify 
the variable in which the returned interface pointer should be stored.</p>
</OL>
<p>Call any method or property of <I>IWebBrowser2. 
</I>When you're finished, make sure you release any interface pointers you have acquired. Following is sample code 
that puts these steps to work. I will show you an actual working sample when I talk 
about printing a Web page from an ActiveX control.</p>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
////////////////////////////////////////////////////////
// Begin Step 1

#include &lt;ExDisp.h&gt;
#include &lt;shlguid.h&gt;

// End Step 1
////////////////////////////////////////////////////////

CSomeClass::SomeMethod(){

////////////////////////////////////////////////////////
// Begin Step 2

IOleContainer* pContainer;

// m_pClientSite is a pointer to IOleClientSite.
// This is the client site for your control.
//
HRESULT hr = m_pClientSite-&gt;GetContainer(&amp;pContainer);
if (FAILED(hr))
   return hr;

// End Step 2
////////////////////////////////////////////////////////

////////////////////////////////////////////////////////
// Begin Step 3

IServiceProvider* pServiceProvider;

hr = pContainer-&gt;QueryInterface(IID_IServiceProvider,
                                (void**)&amp;pServiceProvider);
pContainer-&gt;Release();

if (FAILED(hr))
   return hr;

// End Step 3
////////////////////////////////////////////////////////


////////////////////////////////////////////////////////
// Begin Step 4

IWebBrowser2* pWebBrowser;

hr = pServiceProvider-&gt;QueryService(SID_SWebBrowserApp,
                           IID_IWebBrowser2,
                           (void**)&amp;pWebBrowser);
pServiceProvider-&gt;Release();

if (FAILED(hr))
   return hr;

// End Step 4
////////////////////////////////////////////////////////


////////////////////////////////////////////////////////
// Begin Step 5

// Call some IWebBrowser2 methods and/or properties.

// End Step 5
////////////////////////////////////////////////////////
}
</PRE>
</td></tr></table></p>

<A NAME="175"><H3>Printing a Web page by using an ActiveX control</H3></A>

<P>In versions of Internet Explorer earlier than version 5, one of the most common uses for ActiveX controls that access the <I>IWebBrowser2 </I>interface of Internet Explorer was to print the contents of a Web page. Although Internet Explorer 5 enables you to print a Web page in script using <I>window.print</I>, demonstrating how to create an ActiveX control that prints a Web page is a good way to teach you how to access the <I>IWebBrowser2 </I>interface of Internet Explorer. Therefore, I will show you how to create an ActiveX control with ATL to perform the printing task. At this point, I'm going to assume that you already know how to create a control with ATL.</p>

<p>Go ahead and start Visual C++, and create a new ATL DLL. You can name your project <I>AtlPrint</I> if you want. Next, add a Lite Control to your project using the New ATL Object wizard. You might want to name this control <I>PrintCtl</I>. Add a method named <I>Print</I> to the <I>IPrintCtl </I>interface. Later you will call this method from within script to print the contents of the current Web page.</p>

<p>Before implementing your <I>Print</I> method, first include the ExDisp.h and shlguid.h header files in your PrintCtl.cpp implementation file.</p>

<p>Next use the information I just gave you about accessing the <I>IWebBrowser2</I> interface of Internet Explorer to get a pointer to the <I>IWebBrowser2 </I>interface and call <I>ExecWB</I> to print the current Web page. You might want to use the ATL smart pointer classes&#8212;<I>CComPtr </I>and <I>CComQIPtr&#8212;</I>to take some of the hard work out of querying for interfaces and maintaining their reference counts. Here is the code for implementing your <I>Print</I> method using these smart pointers:</p>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
STDMETHODIMP CPrintCtl::Print()
{
   HRESULT hr = E_FAIL;

   if (m_spClientSite)
   {
      CComPtr&lt;IOleContainer&gt; spContainer;
   
      hr = m_spClientSite-&gt;GetContainer(&amp;spContainer);
      ATLASSERT(SUCCEEDED(hr));

      if (SUCCEEDED(hr))
      {
         CComQIPtr&lt;IServiceProvider, &amp;IID_IServiceProvider&gt;
            spServiceProvider(spContainer);

         ATLASSERT(spServiceProvider);

         if (!spServiceProvider)
            hr = E_FAIL;
         else
         {
            CComPtr&lt;IWebBrowser2&gt; spWebBrowser;

            hr = spServiceProvider-&gt;QueryService(SID_SInternetExplorer,
                                                 IID_IWebBrowser2,
                                                 (void**)&amp;spWebBrowser);
            ATLASSERT(SUCCEEDED(hr));

            if (SUCCEEDED(hr))
            {         
               spWebBrowser-&gt;ExecWB(OLECMDID_PRINT, 
                                 OLECMDEXECOPT_PROMPTUSER,
                                 NULL, NULL);
            }
         }
      }
   }

   return hr;
}
</PRE>
</td></tr></table></p>

<P>Now compile your ATL ActiveX control. To test the print function, you must 
add some script to the sample Web page created for you by the New ATL 
Objectwizard. Listing 6-2 shows the modified HTML code for the sample page that includes 
script to call the <I>Print</I> method. This sample can be found on the companion CD in the 
folder \Samples\Chap06\AtlPrint.</P>

<p><B>Listing 6-2.</B></p> 
<P><table cellpadding=5 width="95%">
<TR><TD>
<A NAME="176"><H3>PrintCtl.htm</H3></A>
<PRE>
&lt;HTML&gt;
&lt;HEAD&gt;
   &lt;TITLE&gt;ATL 3.0 test page for object PrintCtl&lt;/TITLE&gt;

   &lt;SCRIPT LANGUAGE=&quot;VBS&quot;&gt;
      Sub btnPrint_onclick
         PrintCtl.Print
      End Sub
   &lt;/SCRIPT&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
   &lt;OBJECT ID=&quot;PrintCtl&quot;
      CLASSID=&quot;CLSID:320B04E4-B55B-11D2-A9BA-444553540001&quot;&gt;
   &lt;/OBJECT&gt;
   &lt;P&gt;
   &lt;BUTTON ID=&quot;btnPrint&quot;&gt;Print Page&lt;/BUTTON&gt;
&lt;/BODY&gt;
&lt;/HTML&gt;
</PRE>
</td></tr></table></p>

<A NAME="177"><H2>Accessing the <I>IWebBrowser2</I> Interface of Frames When Hosting the WebBrowser Control</H2></A>
<P>A Web page that contains frames contains one 
<I>WebBrowser </I>object per frame. When hosting the WebBrowser control, you'll want to be able to access the 
<I>WebBrowser </I>object from your application so that you can control the frame. This access 
enables you to control navigation in the frame, refresh the frame, and so on. Once you 
have a pointer to the <I>IWebrowser2 </I>interface of the 
<I>WebBrowser </I>object in a frame, you can call any of the 
<I>IWebrowser2 </I>interface's methods and properties. (You can also 
sink events. I will tell you more about sinking events in the <a href="ch07a.htm">next chapter</a>.)</P>

<p>You are able to access the <I>WebBrowser </I>object of a frame only from within 
a Visual C++ application. In Visual Basic, you can access the 
<I>document </I>object of a frame (as I will show you in <A HREF="ch08a.htm">Chapter 8</A>), but you cannot access the 
<I>WebBrowser </I>object because you cannot access the 
<I>IOleContainer </I>interface of the HTML document 
that is loaded in the WebBrowser window. Accessing 
<I>IOleContainer </I>is required to access the <I>WebBrowser 
</I>object of the frame. This section details the standard technique 
that Visual C++ WebBrowser control hosts can use to access the WebBrowser Object 
Model of frame windows on a Web page that is loaded inside the WebBrowser control.</p>

<p>The following code demonstrates how to access the <I>WebBrowser </I>object of each frame on a Web page to refresh the contents of each frame.The most important piece of the code uses the <I>IOleContainer::EnumObjects</I> method of the HTML <I>document </I>object to enumerate embeddings on the page. Each of these embeddings represents a control on the page. By querying each control object for the <I>IWebBrowser2</I> interface, the code can determine whether the control is a subframe. If a call to <I>QueryInterface</I> succeeds for <I>IWebBrowser2</I>, the result is a reference to the <I>WebBrowser </I>object in the frame. (The data member <I>m_webBrowser</I> is of type <I>CWebBrowser2</I>&#8212;the MFC wrapper class for the WebBrowser control that I showed you earlier.)</p>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
// Get the IDispatch of the document.
//
LPDISPATCH lpDisp = NULL;
lpDisp = m_webBrowser.GetDocument();

if (lpDisp)
{
   IOleContainer* pContainer;

   // Get the container.
   //
   HRESULT hr = lpDisp-&gt;QueryInterface(IID_IOleContainer,
                                       (void**)&amp;pContainer);
   lpDisp-&gt;Release();

   if (FAILED(hr))
      return hr;

   // Get an enumerator for the frames.
   //
   IEnumUnknown* pEnumerator;

   hr = pContainer-&gt;EnumObjects(OLECONTF_EMBEDDINGS, &amp;pEnumerator);
   pContainer-&gt;Release();

   if (FAILED(hr))
      return hr;

   IUnknown* pUnk;
   ULONG uFetched;

   // Enumerate and refresh all the frames.
   //
   for (UINT i = 0; S_OK == pEnumerator-&gt;Next(1, &amp;pUnk, &amp;uFetched); i++)
   {
      // QI for IWebBrowser here to see whether we have 
      // an embedded browser.
      IWebBrowser2* pWebBrowser;

      hr = pUnk-&gt;QueryInterface(IID_IWebBrowser2, (void**)&amp;pWebBrowser);
      pUnk-&gt;Release();

      if (SUCCEEDED(hr))
      {
         // Refresh the frame.
         pWebBrowser-&gt;Refresh();
         pWebBrowser-&gt;Release();
      }
   }

   pEnumerator-&gt;Release();
}
</PRE>
</td></tr></table></p>

<P>Notice in this code that we first get a pointer to the <I>IDispatch </I>object of the document by using the <I>GetDocument</I> method, which is a member of the <I>WebBrowser </I>wrapper class. Then we access the <I>IOleContainer</I> interface of the document. The <I>IOleContainer</I> interface provides you with the ability to get an enumerator object to enumerate all the embeddings on the page. Then we obtain the enumerator by calling the <I>EnumObjects</I> method of <I>IOleContainer.</I> <I>EnumObjects </I>returns a pointer to an <I>IEnumUnknown</I> interface that can be used to enumerate all the embeddings. Next in the code, we loop through all of the embeddings, querying each for the <I>IWebBrowser2</I> interface. If the query succeeds, we now have a pointer to the <I>IWebBrowser2 </I>interface of the frame. We can then call any of its methods or properties. In this case, we call <I>Refresh</I> for each frame.</p>
 
<p><div class="warning"><blockquote><b>WARNING</b><HR>
ActiveX controls hosted on an HTML page can use this technique in a similar manner. However, if you create an ActiveX control to access the WebBrowser control of Internet Explorer or the WebBrowser control of frames on a page, do not mark your control as safe for scripting and initialization.</blockquote></div></p>
 
<A NAME="178"><H2>Invoking the Find, View Source, and Internet Options</H2></A>

<P>By looking at the methods and properties of the WebBrowser control, you can easily see the functionality the control provides. Or can you? Three programmable items provided by the WebBrowser control aren't easily discovered: the Find dialog box, the View Source menu item, and the Internet Options dialog box. If you have used Internet Explorer in the past, you are undoubtedly familiar with these items. The Find dialog box, which enables you to search for text on a Web page, is invoked by pressing Ctrl-F or by choosing Find from the Edit menu.</P>

<p>The View Source menu item, which allows you to view the HTML source code for a Web page, can be invoked by choosing Source from the View menu or by right-clicking on a Web page and choosing View Source. The Internet Options dialog box, shown in Figure 6-23, can be invoked by choosing Internet Options from the Tools menu.</p>

<p>
<A HREF="javascript:fullSize('F06ii23x.htm')"> <img src="images/F06ii23.JPG" width=404 height=450 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><B>Figure 6-23.</B> <I>Internet Options dialog box.</I><!-- /caption -->
</p>

<P>It certainly would be nice to be able to provide your users with these 
options in your own browser application, but the way you invoke them isn't obvious just 
by inspecting the methods and properties of the WebBrowser control. You actually 
invoke these methods by calling the <I>Exec </I>method of the 
<I>IOleCommandTarget</I> interface, which is implemented by the WebBrowser. When calling 
<I>Exec</I>, you pass it a special command group GUID named 
<I>CGID_IWebBrowser</I> along with the ID of the command you want to invoke. I mentioned earlier that the 
<I>ExecWB </I>method is a wrapper for the 
<I>IOleCommandTarget::Exec</I> method, but you cannot use 
<I>ExecWB</I> to invoke Find, View Source, or Internet Options because 
<I>ExecWB</I> does not allow you to specify a command group GUID. That means that this technique can be used 
only in Visual C++ applications&#8212;you cannot invoke the commands directly from a 
Visual Basic application.</P>


<p><div class="warning"><blockquote><b>WARNING</b><HR>
The sample I'm about to show you uses an undocumented command group GUID that is subject to change in the future. Although this sample has been tested to work correctly with Internet Explorer 3.<I>x</I>, 4.<I>x</I>, and 5, there is no guarantee that these techniques will continue to work successfully in future versions. Please use caution when adding this code to an application.
</blockquote></div></p>

<P>Follow these steps to implement the Find, View Source, and Internet 
Options commands:</p>

<OL>
<P><LI>Define the command group GUID for the WebBrowser control:</li></p>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
DEFINE_GUID(CGID_IWebBrowser,0xED016940L,0xBD5B,0x11cf,0xBA,
         0x4E,0x00,0xC0,0x4F,0xD7,0x08,0x16);
</PRE>
</td></tr></table></p>

<P><LI>Define the command IDs for Find, View Source, and Internet Options:</li></p>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>     
     #define HTMLID_FIND 1
     #define HTMLID_VIEWSOURCE 2
     #define HTMLID_OPTIONS 3
</PRE>
</td></tr></table></p>

<P><LI>Execute the Find, View Source, and Internet Options commands as 
needed. For example, you could create a utility method that accepts a 
command ID and calls 
<I>IOleCommandTarget::Exec</I>, as shown in the following 
code snippet. (Note that in this MFC code, 
<I>m_webBrowser</I> is an instance of the WebBrowser control. Also, 
<I>nCmdID</I> is one of the IDs defined in step 2.)</li></p>

<P><table cellpadding=5 width="95%">
<TR><TD>
<PRE>
HRESULT CYourView::ExecCmdTarget(DWORD nCmdID)
{
   LPDISPATCH lpDispatch = NULL;
   LPOLECOMMANDTARGET lpOleCommandTarget = NULL;
   HRESULT hr = E_FAIL;

   // Get the IDispatch of the document.
   //
   lpDispatch = m_webBrowser.GetDocument();
   ASSERT(lpDispatch);

   if (lpDispatch)
   {
      // Get a pointer for the IOleCommandTarget interface.
      //
      hr = lpDispatch-&gt;QueryInterface(IID_IOleCommandTarget,
                                      (void**)&amp;lpOleCommandTarget);
      lpDispatch-&gt;Release();

      ASSERT(lpOleCommandTarget);

      if (SUCCEEDED(hr))
      {
         // Invoke the given command id 
         // for the WebBrowser control.
         hr = lpOleCommandTarget-&gt;Exec
              (pguidCmdGroup, nCmdID, 0, NULL, NULL);
         lpOleCommandTarget-&gt;Release();
      }
   }

   return hr;
}
</PRE>
</td></tr></table></p>
</OL>
<P>To see this code in action, take a look at the MfcWebHost application we 
worked on earlier. I updated it with the preceding code to enable users to invoke the 
Find, View Source, and Internet Options commands. The menu items for these 
commands exist on the Edit, View, and Tools menus, respectively, as they do in Internet Explorer.</P>

</BODY>
</HTML>





