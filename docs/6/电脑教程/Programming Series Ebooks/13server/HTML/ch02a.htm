<HTML>
<HEAD>
<TITLE>Chapter 2 -- Device I/O and Interthread Communication</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">

<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
<A HREF="ch01g.htm">[Previous]</A> <A HREF="ch02b.htm">[Next]</A><P>


<font size="+3">Chapter 2</font>

<A NAME="10"><H1>Device I/O and Interthread Communication</H1></A>

<p>I can't stress enough the importance of this chapter, which covers two 
topics that are essential when implementing high-performance, scalable 
applications: device I/O and interthread communication. A scalable application handles 
a large number of concurrent operations as efficiently as it handles a small 
number of concurrent operations. For a service application, typically these 
operations are processing client requests that arrive at unpredictable times and 
require an unpredictable amount of processing power. These requests usually arrive 
from I/O devices such as network adapters; processing the requests frequently 
requires additional I/O devices such as disk files.</p>


<p>In Microsoft Windows applications, threads are the best facility 
available to help you partition work. Each thread is assigned to a processor, which 
allows a multiprocessor machine to execute multiple operations simultaneously, 
increasing throughput. When a thread issues a device I/O request, the thread is 
temporarily suspended until the device completes the I/O request. This 
suspension hurts performance because the thread is unable to do useful work such as 
initiate another client's request for processing. So, in short, you want to keep 
your threads doing useful work all the time.</p>


<p>To help keep threads busy, you will need to make your threads 
communicate with one another about the operations they will perform. Microsoft 
has spent years researching and testing in this area and has developed a finely 
tuned mechanism to create this communication. This mechanism, called the 
<I>I/O completion port, </I>can help you create high-performance, scalable applications. 
By using the I/O completion port, you can make your application's threads 
achieve phenomenal throughput by reading and writing to devices without waiting 
for the devices to respond.</p>


<p>The I/O completion port was originally designed to handle device 
I/O, but over the years, Microsoft has architected more and more operating 
system facilities that fit seamlessly into the I/O completion port model. One 
example is the new job kernel object introduced in Microsoft Windows 2000: as a 
job object monitors its processes, it sends event notifications to an I/O 
completion port. The JobLab sample application, which can be found in 
<I>Programming Applications for Microsoft Windows, Fourth Edition </I>
(Jeffrey Richter, Microsoft Press, 1999), demonstrates how I/O completion 
ports and job objects work together.</p>


<p>Throughout my many years as a Windows developer, I have found 
more and more uses for the I/O completion port, and I feel that every 
Windows developer must fully understand how the I/O completion port works. 
Many of the sample applications in this book use the I/O completion port. 
Even though I present the I/O completion port in this chapter about device 
I/O, be aware that the I/O completion port doesn't have to be used with device 
I/O at all&#8212;simply put, it is an awesome interthread communication mechanism 
with an infinite number of uses.</p>


<p>From this fanfare, you can probably tell that I'm a huge fan of the 
I/O completion port. My hope is that by the end of this chapter, you will be 
too. But instead of jumping right into the details of the I/O completion port, 
I'm going to explain what Windows originally offered developers for 
interthread communication and device I/O. This will give you a much greater 
appreciation for the I/O completion port. Toward the end of the chapter, in the section 
&quot;<A HREF="ch02f.htm#32">I/O Completion Ports</A>,&quot; I'll discuss the I/O completion port.</p>

</BODY>
</HTML>




