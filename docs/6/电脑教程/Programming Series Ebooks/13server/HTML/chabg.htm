<HTML>
<HEAD>
<TITLE>The Security Information C++ Class (SecInfo.h)</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="chabf.htm">[Previous]</A> <A HREF="bioa.htm">[Next]</A><P>

<A NAME="321"><h1>The Security Information C++ Class (SecInfo.h)</h1></A>
<p>The CSecInfo class, shown in Listing B-6, is a very thin wrapper around the <i>ISecurityInformation</i> COM interface, which is used in calls to <i>EditSecurity</i> to produce the common dialog for editing the security for an object. The CSecInfo class simply implements the required members of the <i>IUnknown</i> interface so your code does not have to worry about the COM-related aspects of working with <i>EditSecurity</i>.</p>

<p>If you choose to use the CSecInfo class, you should derive your own class from it and implement the pure virtual functions of the base class. </p>

<p><b>Listing B-6.</b> <i>The SecInfo.h header file</i></p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
<p><b>SecInfo.h</b></p>
/******************************************************************************
Module:  SecInfo.h
Notices: Copyright (c) 2000 Jeffrey Richter
Purpose: This class wraps the ISecurityInformation interface, which is used 
         in calls to the EditSecurity function.
         See Appendix B.
******************************************************************************/


#pragma once   // Include this header file once per compilation unit


///////////////////////////////////////////////////////////////////////////////


#include &quot;..\CmnHdr.h&quot;              // See Appendix A.
#include &lt;aclapi.h&gt;
#include &lt;aclui.h&gt;


///////////////////////////////////////////////////////////////////////////////


class CSecInfo: public ISecurityInformation {
public:
   CSecInfo() { m_nRef = 1; m_fMod = FALSE; }
   BOOL IsModified() { return(m_fMod); }

protected:
   virtual ~CSecInfo() {}

protected:
   void Modified() { m_fMod = TRUE; }
   static GUID m_guidNULL;
   static SI_ACCESS m_siAccessAllRights[];

private:
   ULONG m_nRef; 
   BOOL  m_fMod;    

public:
   HRESULT WINAPI QueryInterface(REFIID riid, PVOID* ppvObj);
   ULONG WINAPI AddRef();
   ULONG WINAPI Release();
   HRESULT UseStandardAccessRights(const GUID* pguidObjectType, DWORD dwFlags,
      PSI_ACCESS* ppAccess, ULONG* pcAccesses, ULONG* piDefaultAccess);

protected:
   HRESULT WINAPI GetObjectInformation(PSI_OBJECT_INFO pObjectInfo) = 0;
   HRESULT WINAPI GetSecurity(SECURITY_INFORMATION RequestedInformation,
      PSECURITY_DESCRIPTOR* ppSecurityDescriptor, BOOL fDefault) = 0;
   HRESULT WINAPI SetSecurity(SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor) = 0;
   HRESULT WINAPI GetAccessRights(const GUID* pguidObjectType,
      DWORD dwFlags, // SI_EDIT_AUDITS, SI_EDIT_PROPERTIES
      PSI_ACCESS *ppAccess, ULONG *pcAccesses, ULONG *piDefaultAccess) = 0;
   HRESULT WINAPI MapGeneric(const GUID *pguidObjectType,
      UCHAR *pAceFlags, ACCESS_MASK *pMask) = 0;
   HRESULT WINAPI GetInheritTypes(PSI_INHERIT_TYPE* ppInheritTypes, 
      ULONG *pcInheritTypes);
   HRESULT WINAPI PropertySheetPageCallback(HWND hwnd, UINT uMsg, 
      SI_PAGE_TYPE uPage);

   PSECURITY_DESCRIPTOR LocalAllocSDCopy(PSECURITY_DESCRIPTOR psd);
};


///////////////////////////////////////////////////////////////////////////////


#ifdef SECINFO_IMPL


///////////////////////////////////////////////////////////////////////////////


GUID CSecInfo::m_guidNULL = GUID_NULL;

#define RIGHT(code, text, fGeneral, fSpecific)     \
   { &amp;m_guidNULL, code, L ## text,                 \
      (0 | (fGeneral ? SI_ACCESS_GENERAL : 0) |    \
           (fSpecific ? SI_ACCESS_SPECIFIC : 0)) }

static SI_ACCESS CSecInfo::m_siAccessAllRights[] = {
   RIGHT(DELETE,                   &quot;DELETE&quot;,                   TRUE,  FALSE),
   RIGHT(READ_CONTROL,             &quot;READ_CONTROL&quot;,             TRUE,  FALSE),
   RIGHT(WRITE_DAC,                &quot;WRITE_DAC&quot;,                TRUE,  FALSE),
   RIGHT(WRITE_OWNER,              &quot;WRITE_OWNER&quot;,              TRUE,  FALSE),
   RIGHT(SYNCHRONIZE,              &quot;SYNCHRONIZE&quot;,              TRUE,  FALSE),

   RIGHT(STANDARD_RIGHTS_REQUIRED, &quot;STANDARD_RIGHTS_REQUIRED&quot;, TRUE,  FALSE),
   RIGHT(STANDARD_RIGHTS_READ,     &quot;STANDARD_RIGHTS_READ&quot;,     TRUE,  FALSE),
   RIGHT(STANDARD_RIGHTS_WRITE,    &quot;STANDARD_RIGHTS_WRITE&quot;,    TRUE,  FALSE),
   RIGHT(STANDARD_RIGHTS_EXECUTE,  &quot;STANDARD_RIGHTS_EXECUTE&quot;,  TRUE,  FALSE),
   RIGHT(STANDARD_RIGHTS_ALL,      &quot;STANDARD_RIGHTS_ALL&quot;,      TRUE,  FALSE),
   RIGHT(SPECIFIC_RIGHTS_ALL,      &quot;SPECIFIC_RIGHTS_ALL&quot;,      TRUE,  FALSE),

   RIGHT(ACCESS_SYSTEM_SECURITY,  &quot;ACCESS_SYSTEM_SECURITY&quot;,    TRUE,  FALSE),
   RIGHT(MAXIMUM_ALLOWED,         &quot;MAXIMUM_ALLOWED&quot;,           TRUE,  FALSE),
};


///////////////////////////////////////////////////////////////////////////////


PSECURITY_DESCRIPTOR CSecInfo::LocalAllocSDCopy(PSECURITY_DESCRIPTOR pSD) {
   DWORD dwSize = 0;
   SECURITY_DESCRIPTOR_CONTROL sdc;
   PSECURITY_DESCRIPTOR pSDNew = NULL;
   DWORD     dwVersion;
    
   __try {
      if (pSD == NULL) __leave; 
      
      if (!GetSecurityDescriptorControl(pSD, &amp;sdc, &amp;dwVersion)) __leave;
      if ((sdc &amp; SE_SELF_RELATIVE) != 0) {
         dwSize = GetSecurityDescriptorLength(pSD);
         if (dwSize == 0) __leave;

         pSDNew = LocalAlloc(LPTR, dwSize);
         if (pSDNew == NULL) __leave; 
         CopyMemory(pSDNew, pSD, dwSize);
      } else {
         if (MakeSelfRelativeSD(pSD, NULL, &amp;dwSize)) __leave;
         else if (GetLastError() != ERROR_INSUFFICIENT_BUFFER) __leave;
         pSDNew = LocalAlloc(LPTR, dwSize);
         if (pSDNew == NULL) __leave;
         if (!MakeSelfRelativeSD(pSD, pSDNew, &amp;dwSize)) {
            LocalFree(pSDNew);
            pSDNew = NULL;
         }          
      }
   }
   __finally {
   } 
   return(pSDNew);
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CSecInfo::QueryInterface(REFIID riid, PVOID* ppvObj) {
   HRESULT hr = E_NOINTERFACE;
   if ((riid == IID_ISecurityInformation) || (riid == IID_IUnknown)) {
      *ppvObj = this;
      AddRef();
      hr = S_OK; 
   }
   return(hr); 
}


///////////////////////////////////////////////////////////////////////////////


ULONG CSecInfo::AddRef() {
   m_nRef++;
   return(m_nRef); 
}


///////////////////////////////////////////////////////////////////////////////


ULONG CSecInfo::Release() {
   ULONG nRef = --m_nRef;
   if (m_nRef == 0) 
      delete this;
   return(nRef);
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CSecInfo::UseStandardAccessRights(const GUID* pguidObjectType,
   DWORD dwFlags, PSI_ACCESS* ppAccess, ULONG* pcAccesses, 
   ULONG* piDefaultAccess) {

   *ppAccess = m_siAccessAllRights;
   *pcAccesses = chDIMOF(m_siAccessAllRights);
   *piDefaultAccess = 0;
   return(S_OK); 
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CSecInfo::GetInheritTypes(PSI_INHERIT_TYPE* ppInheritTypes, 
   ULONG* pcInheritTypes) {

   *ppInheritTypes = NULL; 
   *pcInheritTypes = 0;
   return(S_OK);
}


///////////////////////////////////////////////////////////////////////////////


HRESULT CSecInfo::PropertySheetPageCallback(HWND hwnd, UINT uMsg, 
   SI_PAGE_TYPE uPage) {
   
   return(S_OK);
}


///////////////////////////////////////////////////////////////////////////////


#pragma comment(lib, &quot;ACLUI.lib&quot;)   // Force linking against this library


///////////////////////////////////////////////////////////////////////////////


#endif   // SECINFO_IMPL


///////////////////////////////// End of File /////////////////////////////////
</pre></td></tr></table>
</p>
</body>
</html>





