<HTML>
<HEAD>
<TITLE>Basics of Asynchronous Device I/O</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="ch02d.htm">[Previous]</A> <A HREF="ch02f.htm">[Next]</A><P>

<A NAME="22"><H1>Basics of Asynchronous Device I/O</H1></A>

<p>Compared to most other operations carried out by a computer, device I/O 
is one of the slowest and most unpredictable. The CPU performs 
arithmetic operations and even paints the screen much faster than it reads data from 
or writes data to a file or across a network. However, using asynchronous device 
I/O enables you to better utilize resources and thus create more efficient applications.</p>

<p>Consider a thread that issues an asynchronous I/O request to a device. 
This I/O request is passed to a device driver, which assumes the responsibility 
of actually performing the I/O. While the device driver waits for the device 
to respond, the application's thread is not suspended as it waits for the I/O 
request to complete. Instead, this thread continues executing and performs 
other useful tasks.</p>

<p>At some point, the device driver finishes processing the queued I/O 
request and must notify the application that data has been sent, data has 
been received, or an error has occurred. You'll learn how the device driver 
notifies you of I/O completions in the next section, &quot;<A HREF="ch02f.htm#26">Receiving Completed I/O Request Notifications</A>.&quot; For now, let's concentrate on how to queue 
asynchronous I/O requests. Queuing asynchronous I/O requests is the essence of 
designing a high-performance, scalable application, and it is what the remainder of 
this chapter is all about.</p>

<p>To access a device asynchronously, you must first open the device 
by calling <I>CreateFile</I>, specifying the FILE_FLAG_OVERLAPPED flag in 
the <I>dwFlagsAndAttrs</I> parameter. This flag notifies the system that you intend 
to access the device asynchronously.</p>

<p>To queue an I/O request for a device driver, you use the 
<I>ReadFile</I> and <I>WriteFile</I> functions that you already learned about in the section 
&quot;<A HREF="ch02d.htm#20">Performing Synchronous Device I/O</A>.&quot; For convenience, I'll list the function 
prototypes again:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>BOOL ReadFile(
   HANDLE      hfile, 
   PVOID       pvBuffer,
   DWORD       nNumBytesToRead, 
   PDWORD      pdwNumBytes,
   OVERLAPPED* pOverlapped);

BOOL WriteFile(
   HANDLE      hfile, 
   CONST VOID  *pvBuffer,
   DWORD       nNumBytesToWrite, 
   PDWORD      pdwNumBytes,
   OVERLAPPED* pOverlapped);
</pre></td></tr></table>
</p>

<p>When either of these functions is called, the function checks to see if 
the device, identified by the <I>hfile </I>parameter, was opened with the FILE_
FLAG_OVERLAPPED flag. If this flag is specified, the function 
performs asynchronous device I/O. By the way, when calling either function for 
asynchronous I/O, you can (and usually do) pass NULL for the 
<I>pdwNumBytes </I>parameter. After all, you expect these functions to return before the I/O request has 
completed, so examining the number of bytes transferred is meaningless at this time.</p>

<A NAME="23"><H2>The OVERLAPPED Structure</H2></A>

<p>When performing asynchronous device I/O, you must pass the address to 
an initialized OVERLAPPED structure via the 
<I>pOverlapped</I> parameter. The word &quot;overlapped&quot; in this context means that the time spent performing the 
I/O request overlaps the time your thread spends performing other tasks. Here's 
what an OVERLAPPED structure looks like:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>typedef struct _OVERLAPPED {
   DWORD  Internal;     // [out] Error code
   DWORD  InternalHigh; // [out] Number of bytes transferred
   DWORD  Offset;       // [in]  Low  32-bit file offset
   DWORD  OffsetHigh;   // [in]  High 32-bit file offset
   HANDLE hEvent;       // [in]  Event handle or data
} OVERLAPPED, *LPOVERLAPPED;
</pre></td></tr></table>
</p>

<p>This structure contains five members. Three of these members, 
<I>Offset</I>, <I>OffsetHigh</I>, and 
<I>hEvent</I>, must be initialized prior to calling 
<I>ReadFile</I> or <I>WriteFile</I>. The other two members, 
<I>Internal </I>and <I>InternalHigh</I>, are set by the device 
driver and can be examined when the I/O operation completes. Here is a more 
detailed explanation of these member variables:</p>
<UL>

<p><li><I>     <B>Offset</B> </I> <B>and <I>OffsetHigh</I></B> When a file is being accessed, these 
members indicate the 64-bit offset in the file where you want the 
I/O operation to begin. Recall that each file kernel object has a 
file pointer associated with it. When issuing a synchronous I/O 
request, the system knows to start accessing the file at the location 
identified by the file pointer. After the operation is complete, the system 
updates the file pointer automatically so that the next operation 
can pick up where the last operation left off.</li></p>

<p>When performing asynchronous I/O, this file pointer is 
ignored by the system. Imagine what would happen if your code placed 
two asynchronous calls to <I>ReadFile</I> (for the same file kernel object). 
In this scenario, the system wouldn't know where to start reading 
for the second call to <I>ReadFile</I>. You probably wouldn't want to 
start reading the file at the same location used by the first call to 
<I>ReadFile</I>. You might want to start the second read at the byte in the 
file that followed the last byte that was read by the first call to 
<I>ReadFile</I>. To avoid the confusion of multiple asynchronous calls to the same 
object, all asynchronous I/O requests must specify the 
starting file offset in the OVERLAPPED structure.</p>

<p>Note that the <I>Offset</I> and 
<I>OffsetHigh</I> members are <I>not </I>ignored 
for nonfile devices&#8212;you must initialize both members to 0 or the 
I/O request will fail and <I>GetLastError</I> will return ERROR_INVALID_PARAMETER.</p>

<p><li><I><B>hEvent</B> </I> This member is used by one of the four methods 
available for receiving I/O completion notifications. When using the 
alertable I/O notification method, this member can be used for your 
own purposes. I know many developers who store the address of a 
C++ object in <I>hEvent</I>. (This member will be discussed more in the 
section &quot;<A HREF="ch02f.htm#28">Signaling an Event Kernel Object</A>.&quot;)</li></p>

<p><li><I><B>Internal</B> </I> This member holds the processed I/O's error code. 
As soon as you issue an asynchronous I/O request, the device 
driver sets <I>Internal</I> to STATUS_PENDING, indicating that no error 
has occurred because the operation has not started. In fact, the 
macro <I>HasOverlappedIoCompleted</I>, which is<I> 
</I>defined in WinBase.h, allows you to check whether an asynchronous I/O operation has 
completed. If the request is still pending, FALSE is returned; if the I/O request 
is completed, TRUE is returned. Here is the macro's definition:</li></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>#define HasOverlappedIoCompleted(pOverlapped) \
   ((pOverlapped)-&gt;Internal != STATUS_PENDING)</pre>
</td></tr></table>
</p>

<p><li><I><B>InternalHigh</B> </I>  When an asynchronous I/O request completes, 
this member holds the number of bytes transferred.</li></p>
</UL>
 
<p>When first designing the OVERLAPPED structure, Microsoft decided 
not to document the <I>Internal </I>and <I>InternalHigh 
</I>members (which explains their names). As time went on, Microsoft realized that the information contained 
in these members would be useful to developers and so documented them. 
However, Microsoft didn't change the names of the members because the 
operating system source code referenced them frequently, and Microsoft didn't 
want to modify the code.</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> When an asynchronous I/O request completes, you will receive 
the address of the OVERLAPPED structure that was used when the 
request was initiated. Having more contextual information passed around 
with an OVERLAPPED structure is frequently useful&#8212;for example, if 
you wanted to store the handle of the device used to initiate the I/O 
request inside the OVERLAPPED structure. The OVERLAPPED 
structure doesn't offer a device handle member or other potentially useful 
members for storing context, but you can solve this problem quite easily.

<p>I frequently create a C++ class that is derived from an 
OVERLAPPED structure. This C++ class can have any additional 
information in it that I want. When my application receives the address of an 
OVERLAPPED structure, I simply cast the address to a pointer of my 
C++ class. Now I have access to the OVERLAPPED members and any 
additional context information my application needs. The FileCopy 
sample application at the end of this chapter demonstrates this technique. 
See my CIOReq C++ class in the FileCopy sample application for the details.</p>
</blockquote></div>
</p>

<A NAME="24"><H2>Asynchronous Device I/O Caveats</H2></A>

<p>You should be aware of a couple of issues when performing asynchronous 
I/O. First, the device driver doesn't have to process queued I/O requests in a 
first-in first-out (FIFO) fashion. For example, if a thread executes the following 
code, the device driver will quite possibly write to the file and then read from the file:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>OVERLAPPED o1 = { 0 };
OVERLAPPED o2 = { 0 };
BYTE bBuffer[100];
ReadFile (hfile, bBuffer, 100, NULL, &amp;o1);
WriteFile(hfile, bBuffer, 100, NULL, &amp;o2);
</pre></td></tr></table>
</p>

<p>A device driver typically executes I/O requests out of order if doing 
so helps performance. For example, to reduce head movement and seek times, 
a file system driver might scan the queued I/O request list looking for 
requests that are near the same physical location on the hard drive.</p>

<p>The second issue you should be aware of is the proper way to 
perform error checking. Most Windows functions return FALSE to indicate failure 
or nonzero to indicate success. However, the <I>ReadFile 
</I>and <I>WriteFile </I>functions behave a little differently. An example might help to explain.</p>

<p>When attempting to queue an asynchronous I/O request, the device 
driver might choose to process the request synchronously. This can occur if 
you're reading from a file and the system checks whether the data you want is 
already in the system's cache. If the data is available, your I/O request is not 
queued to the device driver; instead, the system copies the data from the cache to 
your buffer, and the I/O operation is complete.</p>

<p><I>ReadFile </I>and <I>WriteFile </I>return a nonzero value if the requested I/O 
was performed synchronously. If the requested I/O is executing asynchronously, 
or if an error occurred while calling 
<I>ReadFile</I> or <I>WriteFile</I>, FALSE is 
returned. When FALSE is returned, you must call 
<I>GetLastError </I>to determine specifically what happened. If 
<I>GetLastError </I>returns ERROR_IO_PENDING, the 
I/O request was successfully queued and will complete later.</p>

<p>If <I>GetLastError </I>returns a value other than ERROR_IO_PENDING, 
the I/O request could not be queued to the device driver. Here are the most 
common error codes returned from <I>GetLastError 
</I>when an I/O request can't be queued to the device driver:</p>
<UL>

<p><li><B>ERROR_INVALID_USER_BUFFER or ERROR_NOT_ENOUGH_MEMORY</B> Each device driver 
maintains a fixed-size list (in a nonpaged pool) of outstanding 
I/O requests. If this list is full, the system can't queue your 
request, <I>ReadFile</I> and <I>WriteFile </I>return FALSE, and 
<I>GetLastError </I>reports one of these two error codes (depending on the driver).</li></p>

<p><li>
<B>ERROR_NOT_ENOUGH_QUOTA</B> Certain devices 
require that your data buffer's storage be page locked so that the data 
cannot be swapped out of RAM while the I/O is pending. This 
page-locked storage requirement is certainly true of file I/O when 
using the FILE_FLAG_NO_BUFFERING flag. However, the system 
restricts the amount of storage that a single process can page lock. 
If <I>ReadFile</I> and <I>WriteFile </I>cannot page lock your buffer's storage, 
the functions return FALSE, and <I>GetLastError 
</I>reports ERROR_NOT_ENOUGH_QUOTA. You can increase a process's quota by 
calling <I>SetProcessWorkingSetSize</I>.</li></p>
</UL>
 
<p>How should you handle these errors? Basically, these errors occur 
because a number of outstanding I/O requests have not yet completed, so you need 
to allow some pending I/O requests to complete and then reissue the calls 
to <I>ReadFile </I>and <I>WriteFile</I>.</p>

<p>The third issue you should be aware of is that the data buffer and 
OVERLAPPED structure used to issue the asynchronous I/O request must not 
be moved or destroyed until the I/O request has completed. When queuing an 
I/O request to a device driver, the driver is passed the 
<I>address </I>of the data buffer and the <I>address 
</I>of the OVERLAPPED structure. Notice that just the address 
is passed, not the actual block. The reason for this should be quite 
obvious: memory copies are very expensive and waste a lot of CPU time.</p>

<p>When the device driver is ready to process your queued request, it 
transfers the data referenced by the <I>pvBuffer 
</I>address, and it accesses the file's offset member and other members contained within the OVERLAPPED 
structure pointed to by the <I>pOverlapped </I>parameter. Specifically, the device driver 
updates the <I>Internal </I>member with the I/O's error code and the 
<I>InternalHigh </I>member with the number of bytes transferred.</p>


<p><div class="note"><blockquote><b>NOTE</b><hr> It is absolutely essential that these buffers not be moved or 
destroyed until the I/O request has completed, or memory will be corrupted. 
Also, you must allocate and initialize a unique OVERLAPPED structure 
for each I/O request.
</blockquote></div>
</p>

<p>The preceding note is very important and is one of the most common 
bugs developers introduce when implementing an asynchronous device I/O 
architecture. Here's an example of what <I>not 
</I>to do:</p>

<p>
<table cellpadding=5 width="95%"><tr><td><pre>VOID ReadData(HANDLE hfile) {
   OVERLAPPED o = { 0 };
   BYTE b[100];
   ReadFile(hfile, b, 100, NULL, &amp;o);
}
</pre></td></tr></table>
</p>

<p>This code looks fairly harmless, and the call to 
<I>ReadFile </I>is perfect. The only problem is that the function returns after queuing the asynchronous I/O 
request. Returning from the function essentially frees the buffer and the 
OVERLAPPED structure from the thread's stack, but the device driver is not 
aware that <I>ReadData </I>returned. The device driver still has two memory addresses 
that point to the thread's stack. When the I/O completes, the device driver is 
going to modify memory on the thread's stack, corrupting whatever happens 
to be occupying that spot in memory at the time. This bug is particularly 
difficult to find because the memory modification occurs asynchronously. Sometimes 
the device driver might perform I/O synchronously, in which case you won't 
see the bug. Sometimes the I/O might complete right after the function 
returns, or it might complete over an hour later, and who knows what the stack is 
being used for then?</p>

<A NAME="25"><H2>Canceling Queued Device I/O Requests</H2></A>

<p>Sometimes you might want to cancel a queued device I/O request before 
the device driver has processed it. Windows offers a few ways to do this:</p>
<UL>

<p><li>You can call 
<I>CancelIo </I>to cancel all I/O requests queued by the 
calling thread for the specified handle:</li></p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>BOOL CancelIo(HANDLE hfile);</pre>
</td></tr></table>
</p>

<p><li>You can cancel all queued I/O requests, regardless of which 
thread queued the request, by closing the handle to a device itself.</li></p>

<p><li>When a thread dies, the system automatically cancels all I/O 
requests issued by the thread.</li></p>
</UL>
 
<p>As you can see, there is no way to cancel a single, specific I/O request.</p>


<p><div class="note"><blockquote><b>NOTE</b><hr>Canceled I/O requests complete with an error code of ERROR_OPERATION_ABORTED.
</blockquote></div>
</p>

</BODY>
</HTML>




