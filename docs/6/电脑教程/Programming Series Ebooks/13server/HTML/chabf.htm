<HTML>
<HEAD>
<TITLE>The I/O Completion Port C++ Class (IOCP.h)</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="chabe.htm">[Previous]</A> <A HREF="chabg.htm">[Next]</A><P>

<A NAME="320"><h1>The I/O Completion Port C++ Class (IOCP.h)</h1></A>
<p>The simple CIOCP C++ class, shown in Listing B-5, just wraps the Windows I/O completion port kernel object functions. All the methods are inline, so there is no performance penalty when you use the class. Wrapping the functions allows you to manipulate an I/O completion port object with a more logical interface. </p>

<p><b>Listing B-5.</b> <i>The IOCP.h header file</i></p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
<p><b>IOCP.h</b></p>
/******************************************************************************
Module:  IOCP.h
Notices: Copyright (c) 2000 Jeffrey Richter
Purpose: This class wraps an I/O Completion Port.
         See Appendix B.
******************************************************************************/


#pragma once   // Include this header file once per compilation unit


///////////////////////////////////////////////////////////////////////////////


#include &quot;..\CmnHdr.h&quot;              // See Appendix A.


///////////////////////////////////////////////////////////////////////////////


class CIOCP {
public:
   CIOCP(int nMaxConcurrency = -1) { 
      m_hIOCP = NULL; 
      if (nMaxConcurrency != -1)
         (void) Create(nMaxConcurrency);
   }

   ~CIOCP() { 
      if (m_hIOCP != NULL) 
         chVERIFY(CloseHandle(m_hIOCP)); 
   }

   BOOL Create(int nMaxConcurrency = 0) {
      m_hIOCP = CreateIoCompletionPort(
         INVALID_HANDLE_VALUE, NULL, 0, nMaxConcurrency);
      chASSERT(m_hIOCP != NULL);
      return(m_hIOCP != NULL);
   }

   BOOL AssociateDevice(HANDLE hDevice, ULONG_PTR CompKey) {
      BOOL fOk = (CreateIoCompletionPort(hDevice, m_hIOCP, CompKey, 0) 
         == m_hIOCP);
      chASSERT(fOk);
      return(fOk);
   }

   BOOL AssociateSocket(SOCKET hSocket, ULONG_PTR CompKey) {
      return(AssociateDevice((HANDLE) hSocket, CompKey));
   }
   
BOOL PostStatus(ULONG_PTR CompKey, DWORD dwNumBytes = 0, 
      OVERLAPPED* po = NULL) {

      BOOL fOk = PostQueuedCompletionStatus(m_hIOCP, dwNumBytes, CompKey, po);
      chASSERT(fOk);
      return(fOk);
   }

   BOOL GetStatus(ULONG_PTR* pCompKey, PDWORD pdwNumBytes,
      OVERLAPPED** ppo, DWORD dwMilliseconds = INFINITE) {

      return(GetQueuedCompletionStatus(m_hIOCP, pdwNumBytes, 
         pCompKey, ppo, dwMilliseconds));
   }

private:
   HANDLE m_hIOCP;
};


///////////////////////////////// End of File /////////////////////////////////
</pre></td></tr></table>
</p>

</BODY>
</HTML>




