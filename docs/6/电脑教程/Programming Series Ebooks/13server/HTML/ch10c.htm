<HTML>
<HEAD>
<TITLE>Programming for Access Control</TITLE>
<link rel="STYLESHEET" type="text/css" href="prosrvwin.css">
<SCRIPT LANGUAGE="JavaScript"><!-- 
function fullSize(sURL){window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}
--></SCRIPT>
</HEAD>
<BODY BGCOLOR = "#ffffff">
<A HREF="ch10b.htm">[Previous]</A> <A HREF="ch11a.htm">[Next]</A><P>

<A NAME="211"><h1>Programming for Access Control</h1></A>
<p>In this section, we will discuss how to programmatically manipulate security in Windows. We'll begin with an overview of the steps involved.</p>

<A NAME="212"><h2>Basic Steps for Security Tasks</h2></A>
<p>Modifying the security of a securable object is largely the same no matter what type of object you are dealing with. You usually perform one of two tasks: create a new object with security, or change the security of an existing object.</p>

<p>Here are the basic steps that you will take to create an object with security:</p>

<ol>
<p><li>Compile a list of SIDs for which you will be creating denied and allowed ACEs.</li></p>

<p><li>Create and initialize a security descriptor.</li></p>

<p><li>Create and initialize a DACL large enough to hold the required ACEs.</li></p>

<p><li>Add ACEs to the DACL.</li></p>

<p><li>Add the DACL to the security descriptor.</li></p>

<p><li>Create the object using the new security descriptor.</li></p>

<p><li>Clean up after yourself.</li></p>
</ol>

<p>Only step 6 is different from one securable object type to the next.</p>

<p>To modify the security of an existing object, follow these steps:</p>

<ol>
<p><li>Compile a list of SIDs for which you will be adding denied and allowed ACEs to the object's DACL.</li></p>

<p><li>Retrieve the DACL of the object.</li></p>

<p><li>Check the existing DACL for ACEs that you wish to remove, and remove them.</li></p>

<p><li>Check the existing DACL for ACEs that you are adding so that you can avoid adding them again and creating unnecessary bulk.</li></p>

<p><li>Create a new DACL large enough to accommodate the modified &quot;old&quot; DACL in addition to the new ACEs.</li></p>

<p><li>Copy the old ACEs and add new ACEs to the &quot;new&quot; DACL.</li></p>

<p><li>Set the DACL to the object.</li></p>

<p><li>Clean up after yourself.</li></p>
</ol>

<p>In this process, only step 2 (in which you retrieve a DACL) and step 7 (in which you apply the DACL) differ from one securable object type to the next.</p>

<p>Don't let yourself be overwhelmed by this process. I will discuss each step in detail and describe alternatives for a few of these steps. The purpose of mentioning the process here is to show the commonality of approach for <i>any</i> securable object in Windows.</p>

<p>As you can see, once you are comfortable modifying the security of one object, you have the skills (and perhaps even the code) that you need to modify the security of any object. The differences in your approach to modification are mainly in the getting and the setting of security. If you know which function to use for the type of object you are concerned with, you are all set. Take a look at Table 10-7.</p>

<p><b>Table 10-7.</b> <i>Specific security functions for securable objects</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Securable Object  </th>
<th>Creation Function  </th>
<th>Getting and Setting <br>  Security Descriptor  </th></tr>
<tr>
<td valign="top">Access tokens <p>Desktops</p> </td>
<td valign="top"><i>DuplicateTokenEx</i> <p><i>CreateDesktop</i></p> </td>
<td valign="top"><i>GetSecurityInfo</i>, <i>SetSecurityInfo</i>  </td></tr>
<tr>
<td valign="top">Directories<br> (on an NTFS file system) <p>Event objects</p> <p> Files (on an NTFS file system)</p> <p>File-mapping objects</p> <p>Job objects</p> <p>Mutex objects</p> <p>Network share objects</p></td>
<td valign="top"><i>CreateDirectory<br>CreateDirectoryEx</i> <p><i>CreateEvent</i></p> <p><i>CreateFile </i></p> <p><i>CreateFileMapping</i></p> <p><i>CreateJobObject</i></p> <p><i>CreateMutex</i></p> <p><i>NetShareAdd</i></p></td>
<td valign="top"><i>GetNamedSecurityInfo</i>,<br>  <i> GetSecurityInfo</i>,<br><i>SetNamedSecurityInfo</i>, <br> <i>SetSecurityInfo</i></td></tr>
<tr>
<td valign="top">Pipes, anonymous <p>Pipes, named</p> </td>
<td valign="top"><i>CreatePipe</i> <p><i>CreateNamedPipe</i></p> </td>
<td valign="top"><i>GetSecurityInfo, SetSecurityInfo</i>  </td></tr>
<tr>
<td valign="top">Printers  </td>
<td valign="top"><i>AddPrinter</i>  </td>
<td valign="top"><i>GetNamedSecurityInfo</i>,<br> <i>GetSecurityInfo</i>,<br> <i>SetNamedSecurityInfo</i>,<br> <i>SetSecurityInfo</i>  </td></tr>
<tr>
<td valign="top">Process objects  </td>
<td valign="top"><i>CreateProcess</i>,<br> <i>CreateProcessAsUser</i> </td>
<td valign="top"><i>GetSecurityInfo</i>, <i>SetSecurityInfo</i>  </td></tr>
<tr>
<td valign="top">Registry keys <p>Semaphore objects </p> </td>
<td valign="top"><i>RegCreateKeyEx</i> <p><i>CreateSemaphore</i></p> </td>
<td valign="top"><i>GetNamedSecurityInfo</i>,<br>  <i>GetSecurityInfo</i>,<br> <i>SetNamedSecurityInfo</i>,<br> <i>SetSecurityInfo</i>  </td></tr>
<tr>
<td valign="top">Service Control Manager  </td>
<td valign="top">[cannot create the Service Control Manager] </td>
<td valign="top"><i>QueryServiceObjectSecurity</i>, <br>  <i>SetServiceObjectSecurity</i>  </td></tr>
<tr>
<td valign="top">Services  </td>
<td valign="top">[cannot specify security when creating services] </td>
<td valign="top"><i>GetNamedSecurityInfo</i>,<br>  <i>GetSecurityInfo</i>,<br> <i>SetNamedSecurityInfo</i>,<br> <i>SetSecurityInfo</i>  </td></tr>
<tr>
<td valign="top">Thread objects  </td>
<td valign="top"><i>CreateThread</i>, <br><i>CreateRemoteThread</i>  </td>
<td valign="top"><i>GetSecurityInfo</i>,<br> <i>SetSecurityInfo</i>  </td></tr>
<tr>
<td valign="top">Waitable timer objects  </td>
<td valign="top"><i>CreateWaitableTimer</i>  </td>
<td valign="top"><i>GetNamedSecurityInfo</i>,<br> <i>GetSecurityInfo</i>,<br> <i>SetNamedSecurityInfo</i>,<br> <i>SetSecurityInfo</i>  </td></tr>
<tr>
<td valign="top">Window stations  </td>
<td valign="top"><i>CreateWindowStation</i>  </td>
<td valign="top"><i>GetSecurityInfo</i>,<br> <i>SetSecurityInfo</i>  </td></tr>
<tr>
<td valign="top">Private objects  </td>
<td valign="top">  </td>
<td valign="top"><i>GetPrivateObjectSecurity</i>,<br> <i>SetPrivateObjectSecurity</i>,<br> <i>SetPrivateObjectSecurityEx</i>  </td></tr>
</table></p>


<p>Notice in Table 10-7 that although the functions for creating an object differ for each object, only a handful of functions are required for setting and retrieving security information for all securable object types in the system.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
There are other functions for getting and setting security for specific object types, such as <i>GetFileSecurity</i> and <i>SetKernelObjectSecurity</i>. However, object-specific functions are no longer the preferred method for retrieving and setting security for objects, because functions such as <i>GetSecurityInfo</i> and <i>SetNamedSecurityInfo</i> are easier to use and offer a more complete implementation of the inheritance model in Windows 2000. You should always use these functions when possible.</blockquote>
</div>
</p>

<A NAME="213"><h2>Reading Security Information for an Object</h2></A>
<p>Only <i>reading</i> an object's security information is not a common task, and typically you do it so you can modify the security in some way. Understanding how to read an object's security, however, will greatly simplify the more common task of modifying object security, and so I'll cover the topic here.</p>

<p>As you might imagine, not everyone can read the security of an object. Like any other task performed on a securable object, the ability to read the security information itself is securable. To read the security information, one or both of the following conditions must be true:</p>

<ol>
<p><li>You are the owner of the object.</li></p>

<p><li>An ACE in the object's DACL grants you, or a group to which you are a member, the standard right READ_CONTROL. (See Table 10-13.)</li></p>
</ol>

<p>If neither of these conditions is true, you do not have the right to read an object's security. If either is true, when you obtain a handle to the object, you can ask for READ_CONTROL access in the access required parameter of the function used to acquire a handle, and the system will give you a handle. The following code fragment shows an example of obtaining a handle for reading the security information of a file:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
HANDLE hFile = CreateFile(TEXT(&quot;C:\\Test\\Test.txt&quot;), READ_CONTROL, 0, 
   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

if ((hFile == INVALID_HANDLE_VALUE) &amp;&amp;
   GetLastError() == ERROR_ACCESS_DENIED){
   // You do not have READ_CONTROL access to the file
}
</pre></td></tr></table>
</p>

<p>If the file C:\Test\Test.txt exists and resides on an NTFS drive, this code fragment will work. If you meet one of the two conditions, this code will give you a valid file handle that you can use to read the security of your object.</p>

<p>Now that you have a handle to a securable object such as a file, let's use that handle to retrieve security information about the object by making a call to the <i>GetSecurityInfo</i> function:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
DWORD GetSecurityInfo(
   HANDLE               hHandle,
   SE_OBJECT_TYPE       objType,
   SECURITY_INFORMATION secInfo,
   PSID                 *ppsidOwner,
   PSID                 *ppsidGroup,
   PACL                 *ppDACL,
   PACL                 *ppSACL,
   PSECURITY_DESCRIPTOR *ppSecurityDescriptor);
</pre></td></tr></table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
As you might recall from Table 10-7, the <i>GetSecurityInfo</i> function is used to retrieve security information for the majority of securable objects in Windows. It is a very flexible and useful function indeed.</blockquote>
</div>
</p>

<p>When using <i>GetSecurityInfo</i>, you pass a handle to an object, which you have opened with READ_CONTROL access as the <i>hHandle</i> parameter. The <i>objType</i> parameter is an enumerated type that indicates the type of securable object that the handle represents. Table 10-1 shows different enumerated values that can be used with this function. For example, if you passed the handle of a file as the <i>hHandle</i> parameter of <i>GetSecurityInfo</i>, you would have to pass the enumerated value SE_FILE_OBJECT as the <i>objType</i> parameter.</p>

<p>The <i>secInfo</i> parameter indicates what information in the object's security descriptor you would like the system to return. Remember that an object's security descriptor maintains an owner, a group, a DACL, and a SACL, and you can use <i>GetSecurityInfo</i> to retrieve any or all of these by passing any combination of the values in Table 10-8.</p>

<p><b>Table 10-8.</b> <i>SECURITY_INFORMATION values that can be passed for</i> GetSecurityInfo'<i>s</i> secInfo <i>parameter</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Value  </th>
<th>Description  </th></tr>
<tr>
<td valign="top">DACL_SECURITY_INFORMATION  </td>
<td valign="top">Indicates that you wish to retrieve DACL information for a securable object  </td></tr>
<tr>
<td valign="top">SACL_SECURITY_INFORMATION  </td>
<td valign="top">Indicates that you wish to retrieve SACL information for a securable object  </td></tr>
<tr>
<td valign="top">OWNER_SECURITY_INFORMATION  </td>
<td valign="top">Indicates that you wish to retrieve owner information for a securable object  </td></tr>
<tr>
<td valign="top">GROUP_SECURITY_INFORMATION  </td>
<td valign="top">Indicates that you wish to retrieve group information for a securable object  </td></tr>
</table></p>
 

<p>The <i>ppsidOwner</i>, <i>ppsidGroup</i>, <i>ppDACL</i>, and <i>ppSACL</i> parameters are optional. If you want the system to return a pointer to the owner's SID, group SID, DACL, or SACL of the object, you can pass the address of a PSID or PACL variable for any or all of these parameters. However, you must pass NULL for any information that you do not request by passing the proper flag as the <i>secInfo</i> parameter. Regardless, you can always pass NULL for any or all of these parameters.</p>

<p>The final parameter is the address of a pointer to a SECURITY_DESCRIPTOR structure and is mandatory. The system allocates a buffer large enough to hold the requested security information for the object using <i>LocalAlloc</i> and places a pointer to the security descriptor in the variable whose address you supply in <i>ppSecurityDescriptor</i>. (It is necessary to pass the value returned in the <i>ppSecurityDescriptor</i> parameter to <i>LocalFree</i> when you are finished with the security descriptor for the object.)</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
If you should pass the address of a PSID or PACL variable as the <i>ppsidOwner</i>, <i>ppsidGroup</i>, <i>ppDACL</i>, or <i>ppSACL</i> parameter, the system will return an address that points to a portion of the security descriptor returned in <i>ppSecurityDescriptor</i>. This is why these parameters are optional.</blockquote>
</div>
</p>

<p>You don't have to call <i>GetLastError</i> after calling <i>GetSecurityInfo</i>, because <i>GetSecurityInfo</i> returns an error code directly. If <i>GetSecurityInfo</i> succeeds, it returns ERROR_SUCCESS. Common error values are ERROR_ ACCESS_DENIED, which indicates that your handle was not opened with READ_CONTROL access, and ERROR_INVALID_HANDLE, which usually indicates that you passed mismatched handle and object type values for the <i>hHandle</i> and <i>objType</i> parameters.</p>

<p> The following code could be used with the preceding code fragment (in the beginning of &quot;<A HREF="ch10c.htm#213">Reading Security Information for an Object</A>&quot;), which opens a handle to a file using <i>CreateFile</i>, to retrieve DACL and object owner information for the file at C:\Test\Test.txt:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
PSECURITY_DESCRIPTOR pSD;
PSID  pSID;
PACL  pDACL; 
ULONG lErr = GetSecurityInfo(hFile, SE_FILE_OBJECT, 
   DACL_SECURITY_INFORMATION, &amp;pSID, NULL, &amp;pDACL, NULL, &amp;pSD);
if (lErr != ERROR_SUCCESS){
   // Error case
}

// Perform work here

// Clean up
LocalFree(pSD);
CloseHandle(hFile);
</pre></td></tr></table>
</p>

<p>In this example, after successfully calling <i>GetSecurityInfo</i>, the <i>pSID</i> and <i>pDACL</i> variables point to a SID structure and a DACL structure contained in the buffer returned in the <i>pSD</i> variable. It is neither necessary nor correct to pass the pointers returned in <i>pSD</i> or <i>pDACL</i> to <i>LocalFree</i>, because the entire security descriptor is freed when the pointer returned in the <i>pSD</i> variable is passed to <i>LocalFree</i>. </p>

<p>You are familiar with SIDs and pointers to SIDs from <A HREF="ch09a.htm">Chapter 9</A>, and you can use the owner SID returned from <i>GetSecurityInfo</i> with functions such as <i>LookupAccountSid</i> and <i>CopySid</i>, which are discussed in that chapter.</p>

<p> Before dissecting the DACL of a secured object, I would like to introduce <i>GetSecurityInfo</i>'s sister function, <i>GetNamedSecurityInfo</i>. Whereas <i>GetSecurityInfo</i> requires a handle to a securable object, <i>GetNamedSecurityInfo</i> requires the textual name of a secure object in the system, and is
defined as follows:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
DWORD GetNamedSecurityInfo(
   LPTSTR               pObjectName,
   SE_OBJECT_TYPE       objType,
   SECURITY_INFORMATION secInfo,
   PSID                 *ppsidOwner,
   PSID                 *ppsidGroup,
   PACL                 *ppDACL,
   PACL                 *ppSACL,
   PSECURITY_DESCRIPTOR *ppSecurityDescriptor);
</pre></td></tr></table>
</p>

<p>Notice that this function differs from <i>GetSecurityInfo</i> only in the first parameter, which takes a pointer to a string containing the name of an object in the system. Fewer secured objects in the system are named. However, for those that are, this function can sometimes be more convenient than <i>GetSecurityInfo</i>, because it does not require you to first obtain a handle to an object. For a list of the objects whose security can be retrieved using <i>GetNamedSecurityInfo</i>, see Table 10-7.</p>

<p>Our previous two code fragments could be consolidated to create this smaller code fragment by using <i>GetNamedSecurityInfo</i>:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
PSECURITY_DESCRIPTOR pSD;
PSID pSID;
PACL pDACL; 
ULONG lErr = GetNamedSecurityInfo(TEXT(&quot;C:\\Test\\Test.txt&quot;), 
   SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, &amp;pSID, NULL, 
   &amp;pDACL, NULL, &amp;pSD);
if (lErr != ERROR_SUCCESS){
   // Error case
}

// Clean up
LocalFree(pSD);
</pre></td></tr></table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
In the examples I have shown so far, I have used the file at C:\Test\Test.txt to demonstrate how to retrieve an object's security information. However, both <i>GetNamedSecurityInfo</i> and <i>GetSecurityInfo</i> can be used to retrieve security for other securable objects including registry keys, kernel objects, and user objects. See Table 10-7 for specific security functions for securable objects.</blockquote>
</div>
</p>

<p><i>GetSecurityInfo</i> and <i>GetNamedSecurityInfo</i> allow you to pass the address of pointer variables to retrieve the address of the owner SID, group SID, DACL, or SACL in the returned security descriptor. However, you might be wondering how you would retrieve this information if you had only retrieved the security descriptor of an object. You can use the <i>GetSecurityDescriptorOwner</i>, <i>GetSecurityDescriptorGroup</i>, <i>GetSecurityDescriptorDacl</i>, and <i>GetSecurityDescriptorSacl</i> functions to retrieve pointers to these data structures within a security descriptor. I will discuss these functions further in the section titled &quot;<A HREF="ch10c.htm#223">Securing Private Objects</A>&quot; later in this chapter.</p>

<A NAME="214"><h3>Dissecting the DACL</h3></A>
<p>Now that we have discussed how to retrieve a pointer to the DACL of a secured object, it is time to begin uncovering how the DACL is read. Remember that the DACL is an access control list (ACL), and an ACL is little more than a list of access control entries (ACEs) that indicate access that is denied or allowed to a trustee.</p>

<p>The DACL for a security descriptor can be set to NULL. This indicates that no DACL is present for a particular object, and is referred to as a &quot;null DACL.&quot; If an object has a null DACL, all access is implicitly granted to all trustees of the system.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
When a DACL <i>is</i> present for an object, all access to the object is implicitly denied unless explicitly allowed. Sometimes an object will have an empty DACL, which should not be confused with a null DACL. An empty DACL signifies no access for anyone (but the owner) for an object. A null DACL, on the other hand, grants all access to all trustees.</blockquote>
</div>
</p>

<p>If a DACL is present, retrieving information about the ACEs in the DACL might be necessary. First you must find out how many ACEs the DACL contains by calling <i>GetAclInformation</i>:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL GetAclInformation(
   PACL                  pACL,
   PVOID                 pACLInformation,
   DWORD                 dwACLInformationLength,
   ACL_INFORMATION_CLASS aclInformationClass); 
</pre></td></tr></table>
</p>

<p>This function allows you to retrieve information about a DACL (or a SACL), which you pass to the function via the <i>pACL</i> parameter. You should pass the address of a structure to retrieve ACL information as the <i>pACLInformation</i> parameter, and the length of the structure as the <i>dwACLInformationLength</i> parameter. The <i>aclInformationClass</i> parameter is an enumerated type that indicates what type of information is being returned and also defines which type of structure you should pass as the <i>pACLInformation</i> parameter. Possible values for the <i>aclInformationClass</i> parameter are listed in Table 10-9.</p>

<p><b>Table 10-9.</b> <i>The ACL_INFORMATION_CLASS enumeration</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Enumerated Value  </th>
<th>Structure  </th>
<th>Definition  </th></tr>
<tr>
<td valign="top">AclRevisionInformation  </td>
<td valign="top">ACL_REVISION_INFORMATION  </td>
<td valign="top">Returns ACL revision information  </td></tr>
<tr>
<td valign="top">AclSizeInformation   </td>
<td valign="top">ACL_SIZE_INFORMATION   </td>
<td valign="top">Returns ACL size information including ACE count  </td></tr>
</table></p>

<p>The ACL_SIZE_INFORMATION structure is most commonly used with <i>GetAclInformation</i> and is defined as follows:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
typedef struct _ACL_SIZE_INFORMATION { 
   DWORD AceCount; 
   DWORD AclBytesInUse; 
   DWORD AclBytesFree; 
} ACL_SIZE_INFORMATION;
</pre></td></tr></table>
</p>

<p>The following code fragment builds on the last fragment to retrieve the number of ACEs in the DACL for the file at C:\Test\Text.txt:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
PSECURITY_DESCRIPTOR pSD;
PACL pDACL; 
ULONG lErr = GetNamedSecurityInfo(TEXT(&quot;C:\\Test\\Test.txt&quot;), 
   SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, 
   &amp;pDACL, NULL, &amp;pSD);
if (lErr != ERROR_SUCCESS){
   // Error case
}

ACL_SIZE_INFORMATION aclSize = {0};
if(pDACL != NULL){   
   if(!GetAclInformation(pDACL, &amp;aclSize, sizeof(aclSize),
      AclSizeInformation)){
      // Error case
   }
}

ULONG nAceCount = aclSize.AceCount;
</pre></td></tr></table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
If the file at C:\Test\Test.txt is on a FAT drive, or if it does not have a DACL, the system returns NULL in the <i>pDACL</i> variable. This is why it is important to test for NULL before calling <i>GetAclInformation</i>. Passing a NULL pointer value to <i>GetAclInformation</i> causes an access violation.</blockquote>
</div>
</p>

<p>After you have the number of ACEs in a DACL, you can use this information to retrieve individual ACEs. Calling <i>GetAce</i> does this.</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL GetAce(
   PACL  pACL,
   DWORD dwACEIndex,
   PVOID *pACE);
</pre></td></tr></table>
</p>

<p>This function simply takes the pointer to an ACL, the zero-based index of the ACE you want to retrieve, and the address of a pointer variable in which to store the pointer to the ACE in the DACL.</p>

<p>Notice that the <i>pACE</i> parameter is of type PVOID. This is because a number of different ACE types can reside in a DACL, and each of these types is represented by a different structure. <i>GetAce</i> is used to retrieve each type. However, ACLs can contain any number of ACEs and any combination of ACE types, so there is no way to know which ACEs will be of which type until after you have retrieved the ACE with <i>GetAce</i>.</p>

<p>Although retrieving the ACE count and the ACE itself is simple, the real work in reading a DACL comes in understanding the different types of ACEs.</p>

<A NAME="215"><h3>Understanding ACEs</h3></A>
<p>There are a number of different ACE types, which can be divided into two broad types: standard ACEs and object ACEs. In each group you will find ACE types for allowing and denying access, as well as for auditing access. Each ACE type is guaranteed to share one attribute in common&#8212;the first member of its structure will be of type ACE_HEADER, defined as follows:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
typedef struct _ACE_HEADER { 
   BYTE   AceType; 
   BYTE   AceFlags; 
   USHORT AceSize; 
} ACE_HEADER;
</pre></td></tr></table>
</p>

<p>The ACE header is key to reading the DACL, because when you retrieve a pointer to an ACE from <i>GetAce</i>, you do not know what type of ACE it is or what type of structure makes up the ACE until you have read the ACE's header.</p>

<p>As you might have guessed, the <i>AceType</i> member of the ACE header indicates what type of ACE the header represents. The possible values for <i>AceType</i> are listed in Table 10-10. These six ACE types are currently available in Windows 2000.</p>

<p><b>Table 10-10.</b> <i>ACE types</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>ACE Type  </th>
<th>Description  </th></tr>
<tr>
<td valign="top">ACCESS_ALLOWED_ACE_TYPE  </td>
<td valign="top">Used in a DACL. Indicates a set of access rights that are explicitly granted to a trustee. Uses the ACCESS_ ALLOWED_ACE structure.  </td></tr>
<tr>
<td valign="top">ACCESS_DENIED_ACE_TYPE  </td>
<td valign="top">Used in a DACL. Indicates a set of access rights that are explicitly denied to a trustee. Uses the ACCESS_DENIED_ACE structure.  </td></tr>
<tr>
<td valign="top">SYSTEM_AUDIT_ACE_TYPE  </td>
<td valign="top">Used in a SACL (see &quot;<A HREF="ch10c.htm#225">Auditing and the SACL</A>&quot;). Indicates a set of access rights that should cause an audit event when requested by a trustee. Uses the SYSTEM_AUDIT_ACE structure.  </td></tr>
<tr>
<td valign="top">ACCESS_ALLOWED_OBJECT_ACE_TYPE  </td>
<td valign="top">Used in a DACL of a directory services object. Indicates a set of access rights that are explicitly granted to a trustee for an object in Active Directory. Uses the ACCESS_ALLOWED_OBJECT_ACE structure.  </td></tr>
<tr>
<td valign="top"> ACCESS_DENIED_OBJECT_ACE_TYPE  </td>
<td valign="top">Used in a DACL of a directory services object. Indicates a set of access rights that are explicitly denied to a trustee for an object in Active Directory. Uses the ACCESS_DENIED_OBJECT_ACE structure.  </td></tr>
<tr>
<td valign="top">SYSTEM_AUDIT_OBJECT_ACE_TYPE   </td>
<td valign="top">Used in a SACL (see &quot;<A HREF="ch10c.htm#225">Auditing and the SACL</A>&quot;) of a directory services object. Indicates a set of access rights that should cause an audit event when requested by a trustee. Uses the SYSTEM_AUDIT_OBJECT_ACE structure.  </td></tr>
</table></p>

<p>The <i>AceFlags</i> member of the ACE_HEADER structure contains inheritance information about the ACE, as well as auditing information. The <i>AceFlags</i> member will be some combination of the values in Table 10-11.</p>

<p><b>Table 10-11.</b> <i>Values for the</i> AceFlags <i>member of the ACE_HEADER structure</i></p>


<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Value  </th>
<th> Description </th></tr>
<tr>
<td valign="top" colspan="2" align="left"> <i>Inheritance Flags</i> </td></tr>
<tr>
<td valign="top">INHERITED_ACE  </td>
<td valign="top">This flag is set in the ACE if the flag was inherited from a parent object. This allows the system to distinguish between ACEs that were directly applied and ACEs that were automatically applied due to inheritance.  </td></tr>
<tr>
<td valign="top">CONTAINER_INHERIT_ACE  </td>
<td valign="top">Container objects that are children of the object owning this ACE will inherit this ACE as an effective ACE.  <p>This inheritance continues indefinitely by default; however, inheritance can be configured to stop with direct children if the NO_PROPAGATE_INHERIT_ACE flag is also set. If this bit is not set, but the OBJECT_INHERIT_ACE bit is set, the ACE will inherit to container objects, but the INHERIT_ONLY_ACE flag will be set for the container's ACE.</p></td></tr>
<tr>
<td valign="top">OBJECT_INHERIT_ACE   </td>
<td valign="top">This ACE is inherited to and effective on non-container and child objects of the owning object. For child objects that are containers, the ACE is inherited as an inherit-only ACE unless the CONTAINER_INHERIT_ACE flag is also set. <p>If the NO_PROPAGATE_INHERIT_ACE flag is set, and the CONTAINER_INHERIT_ACE flag is not set, an ACE with the OBJECT_INHERIT_ACE bit set will not inherit to container objects.</p> </td></tr>
<tr>
<td valign="top">INHERIT_ONLY_ACE   </td>
<td valign="top">This ACE is not effective on the object owning the ACE. However, it might be effective on child container or child non-container objects. It is invalid for an ACE to have the INHERIT_ONLY_ACE flag set unless one or both of the CONTAINER_INHERIT_ACE and OBJECT_INHERIT_ACE flags are set.  </td></tr>
<tr>
<td valign="top">NO_PROPAGATE_INHERIT_ACE  </td>
<td valign="top">Setting this flag in an ACE causes it to be inherited only once. The inherited ACEs will have their OBJECT_INHERIT_ACE and CONTAINER_INHERIT_ACE flags cleared so that the new ACEs will not also be inherited.  </td></tr>
<tr>
<td valign="top" colspan="2" align="left"> <i>Auditing Flags</i> </td></tr>
<tr>
<td valign="top">FAILED_ACCESS_ACE_FLAG  </td>
<td valign="top">In a SACL, an ACE with this bit set will cause an audit event if access is requested and the result is ACCESS_DENIED.  </td></tr>
<tr>
<td valign="top">SUCCESSFUL_ACCESS_ACE_FLAG  </td>
<td valign="top">Used with system-audit ACEs in a SACL to generate audit messages for successful access attempts.  </td></tr>
</table></p>


<p>In addition to the ACE type and flags, the <i>AceSize</i> member of the ACE_HEADER structure indicates the size of the ACE in question. As you can see, the ACE_HEADER contains a fair amount of information about the ACE. In fact, if you wanted to retrieve only inheritance and type information about an ACE, when calling <i>GetAce</i>, you could look no farther than the ACE_HEADER structure. The following code fragment shows how to call <i>GetAce</i> to retrieve the ACE's type:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
ACE_HEADER* pACEHeader ;
GetAce(pDACL, 0, (PVOID*)&amp;pACEHeader);

switch( pACEHeader-&gt;AceType ){
   // Do work depending on the ACE's type
}
</pre></td></tr></table>
</p>

<p>Since you will typically require more information from an ACE than just its type and inheritance style, you will have to go beyond the ACE_HEADER. There are two main types of ACEs, standard and object. Standard ACEs are ACEs that are not object ACEs. Object ACEs are used only with Active Directory. They are known as object ACEs because they contain GUIDs that make it possible for them to work with the many types of objects available with directory services. Because standard ACEs are far and away the most common, we will cover them first.</p>

<p><b>Standard ACEs</b> Most securable objects in the system deal exclusively with standard ACEs. The exceptions are objects that exist in Active Directory, which are referred to as <i>directory services objects</i>.</p>

<p>Like all ACEs, the standard ACEs are represented by three structures, one each for allowing access, denying access, and auditing. Here is the definition of each of these structures:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
typedef struct _ACCESS_DENIED_ACE { 
   ACE_HEADER  Header; 
   ACCESS_MASK Mask; 
   DWORD       SidStart; 
} ACCESS_DENIED_ACE;

typedef struct _ACCESS_ALLOWED_ACE {
   ACE_HEADER  Header; 
   ACCESS_MASK Mask; 
   DWORD       SidStart; 
} ACCESS_ALLOWED_ACE;

typedef struct _SYSTEM_AUDIT_ACE {
   ACE_HEADER  Header; 
   ACCESS_MASK Mask; 
   DWORD       SidStart; 
} SYSTEM_AUDIT_ACE;
</pre></td></tr></table>
</p>

<p>The definition of each of these structures is identical, and each includes the promised <i>Header</i> member, which is the now-familiar type ACE_HEADER.</p>

<p> The remaining two members are relatively easy to understand. The first is <i>Mask</i>, which is a 32-bit mask indicating the access rights that are being denied, allowed, or set for auditing.</p>

<p> I will discuss access rights in great detail shortly, but for now remember that the access rights are broken up into generic, standard, and specific rights for a given object type, and are combined to form a single 32-bit value. This 32-bit value is the <i>Mask</i> member of an ACE. See Figure 10-2 for the access mask format.</p>

<p> The last member of the ACE structure is <i>SidStart</i>, which indicates the beginning of the SID of the trustee account for which the ACE is denying, allowing, or auditing access for the object. This member requires some discussion.</p>

<p> Remember that a SID (discussed in <A HREF="ch09a.htm">Chapter 9</A>) is a variable-length binary structure indicating a trustee account
of the system. Because each ACE contains a SID, the ACE structure is also a variable-length structure. The <i>SidStart</i> member is a placeholder for the beginning of the SID contained within the ACE. The value (and the type) of <i>SidStart</i> is irrelevant and should never be accessed, because it is actually the first couple of bytes of a SID structure.</p>

<p> You might find that a macro such as the following is useful in extracting a SID from an ACE structure:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
#define PSIDFromPACE(pACE) ((PSID)(&amp;((pACE)-&gt;SidStart)))
</pre></td></tr></table>
</p>

<p>This particular macro takes a pointer to any ACE structure&#8212;object or standard&#8212;and returns a pointer to the SID structure for the ACE.</p>

<p> The standard ACE type is broken into three separate structures, which are used primarily as logical placeholders for you when you create ACEs for an ACL. However, because the structure of each ACE is identical, when reading ACEs from a DACL, it is very common to write code that uses only one of the ACE types but uses the <i>AceType</i> member of the ACE_HEADER structure to maintain a type for the ACE. The following function uses this technique and prints information about each ACE in a DACL:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
void DumpACL( PACL pACL ){
   __try{
      if (pACL == NULL){
         _tprintf(TEXT(&quot;NULL DACL\n&quot;));
         __leave;
      }

      ACL_SIZE_INFORMATION aclSize = {0};
      if (!GetAclInformation(pACL, &amp;aclSize, sizeof(aclSize),
         AclSizeInformation))
         __leave;
      _tprintf(TEXT(&quot;ACL ACE count: %d\n&quot;), aclSize.AceCount);
      
      struct{
         BYTE  lACEType;
         PTSTR pszTypeName;
      }aceTypes[6] = {
         {ACCESS_ALLOWED_ACE_TYPE, TEXT(&quot;ACCESS_ALLOWED_ACE_TYPE&quot;)},
         {ACCESS_DENIED_ACE_TYPE, TEXT(&quot;ACCESS_DENIED_ACE_TYPE&quot;)},
         {SYSTEM_AUDIT_ACE_TYPE, TEXT(&quot;SYSTEM_AUDIT_ACE_TYPE&quot;)},
         {ACCESS_ALLOWED_OBJECT_ACE_TYPE,
            TEXT(&quot;ACCESS_ALLOWED_OBJECT_ACE_TYPE&quot;)},
         {ACCESS_DENIED_OBJECT_ACE_TYPE,
            TEXT(&quot;ACCESS_DENIED_OBJECT_ACE_TYPE&quot;)},
         {SYSTEM_AUDIT_OBJECT_ACE_TYPE,
            TEXT(&quot;SYSTEM_AUDIT_OBJECT_ACE_TYPE&quot;)}};

      struct{
         ULONG lACEFlag;
         PTSTR pszFlagName;
      }aceFlags[7] = {
         {INHERITED_ACE, TEXT(&quot;INHERITED_ACE&quot;)},
         {CONTAINER_INHERIT_ACE, TEXT(&quot;CONTAINER_INHERIT_ACE&quot;)},
         {OBJECT_INHERIT_ACE, TEXT(&quot;OBJECT_INHERIT_ACE&quot;)},
         {INHERIT_ONLY_ACE, TEXT(&quot;INHERIT_ONLY_ACE&quot;)},
         {NO_PROPAGATE_INHERIT_ACE, TEXT(&quot;NO_PROPAGATE_INHERIT_ACE&quot;)},
         {FAILED_ACCESS_ACE_FLAG, TEXT(&quot;FAILED_ACCESS_ACE_FLAG&quot;)},
         {SUCCESSFUL_ACCESS_ACE_FLAG, 
            TEXT(&quot;SUCCESSFUL_ACCESS_ACE_FLAG&quot;)}};

      for (ULONG lIndex = 0;lIndex &lt; aclSize.AceCount;lIndex++){
         ACCESS_ALLOWED_ACE* pACE;
         if (!GetAce(pACL, lIndex, (PVOID*)&amp;pACE))
            __leave;

         _tprintf(TEXT(&quot;\nACE #%d\n&quot;), lIndex);
         
         ULONG lIndex2 = 6;
         PTSTR pszString = TEXT(&quot;Unknown ACE Type&quot;);
         while (lIndex2--){
            if(pACE-&gt;Header.AceType == aceTypes[lIndex2].lACEType){
               pszString = aceTypes[lIndex2].pszTypeName;
            }
         }
         _tprintf(TEXT(&quot;  ACE Type =\n  \t%s\n&quot;), pszString);

         _tprintf(TEXT(&quot;  ACE Flags = \n&quot;));
         lIndex2 = 7;
         while (lIndex2--){
            if ((pACE-&gt;Header.AceFlags &amp; aceFlags[lIndex2].lACEFlag) 
               != 0)
               _tprintf(TEXT(&quot;  \t%s\n&quot;), 
                  aceFlags[lIndex2].pszFlagName);
         }

         _tprintf(TEXT(&quot;  ACE Mask (32-&gt;0) =\n  \t&quot;));
         lIndex2 = (ULONG)1&lt;&lt;31;
         while (lIndex2){
            _tprintf(((pACE-&gt;Mask &amp; lIndex2) != 0)?TEXT(&quot;1&quot;):TEXT(&quot;0&quot;));
            lIndex2&gt;&gt;=1;
         }

         TCHAR szName[1024];
         TCHAR szDom[1024];
         PSID pSID = PSIDFromPACE(pACE);
         SID_NAME_USE sidUse;         
         ULONG lLen1 = 1024, lLen2 = 1024;
         if (!LookupAccountSid(NULL, pSID, 
            szName, &amp;lLen1, szDom, &amp;lLen2, &amp;sidUse))
            lstrcpy(szName, TEXT(&quot;Unknown&quot;));
         PTSTR pszSID;
         if (!ConvertSidToStringSid(pSID, &amp;pszSID))
            __leave;
         _tprintf(TEXT(&quot;\n  ACE SID =\n  \t%s (%s)\n&quot;), pszSID, szName);
         LocalFree(pszSID);
      }
   }__finally{}
}
</pre></td></tr></table>
</p>

<p>Notice for all ACE types of the ACEs that are dumped the use of the ACCESS_ALLOWED_ACE structure. This structure will work for any standard ACE type (although this function will fail for object ACEs) because all standard ACE structures are the same.</p>

<p> The following code fragment could be used with the <i>DumpACL</i> function to show the ACEs in a directory on an NTFS share:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
PSECURITY_DESCRIPTOR pSD;
PACL pDACL; 
ULONG lErr = GetNamedSecurityInfo(TEXT(&quot;C:\\Test\\Test&quot;), 
   SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL, NULL, 
   &amp;pDACL, NULL, &amp;pSD);
if (lErr == ERROR_SUCCESS){
   DumpACL(pDACL);
}
</pre></td></tr></table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
The <i>DumpACL</i> sample function demonstrates how to read ACE information in a DACL. You might find code like this useful in your own production code. You might also find the <i>DumpACL</i> function useful as a debugging tool, particularly when you are beginning to write code that modifies the DACL of securable objects. Use it to dump out the DACL of the object before and after you make your modifications to see whether your code is producing the desired results. 

<p>Techniques such as this one have advantages over viewing security by using the Security Properties page in Explorer, because the system's user interface does not display the ACE information of an object verbatim. In fact, the user interface will not display a DACL that is not properly ordered without first ordering the ACEs in the DACL.</p>
</blockquote>
</div>
</p>

<p>Because of the nature of the ACE structures, you might find it helpful to define a union that represents each ACE type. Then you can deal with ACEs returned from <i>GetAce</i> in terms of a pointer to the union type. The following code shows an example of such a technique:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
typedef union _ACE_UNION{
   ACE_HEADER         aceHeader;
   ACCESS_ALLOWED_ACE aceAllowed;
   ACCESS_DENIED_ACE  aceDenied;
   SYSTEM_AUDIT_ACE   aceAudit;
}*PACE_UNION;

PACE_UNION pACE ;
GetAce(pDACL, 0, (PVOID*)&amp;pACE);

switch (pACE-&gt;aceHeader.AceType){
<img src="images/grayvellip.JPG" width=3 height=13 border="0">
</pre></td></tr></table>
</p>


<p><a name="215A"><b>Object ACEs</b></a> Unless you are writing code to secure and modify the security of objects in Active Directory, you are not likely to use object ACEs in your own applications. However, Active Directory is an important component of Windows 2000, and there is no harm in understanding how it secures objects. We won't spend much time on the topic, though, to avoid clouding your understanding of standard ACEs.</p>

<p>Like standard ACEs, object ACEs come in three flavors: one to deny, one to allow, and one to audit access rights for a trustee. Here are the structures for the object ACEs:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
typedef struct _ACCESS_ALLOWED_OBJECT_ACE {
   ACE_HEADER  Header;
   ACCESS_MASK Mask;
   DWORD       Flags;
   GUID        ObjectType;
   GUID        InheritedObjectType;
   DWORD       SidStart;
} ACCESS_ALLOWED_OBJECT_ACE, *PACCESS_ALLOWED_OBJECT_ACE;

typedef struct _ACCESS_DENIED_OBJECT_ACE {
   ACE_HEADER  Header;
   ACCESS_MASK Mask;
   DWORD       Flags;
   GUID        ObjectType;
   GUID        InheritedObjectType;
   DWORD       SidStart;
} ACCESS_DENIED_OBJECT_ACE, *PACCESS_DENIED_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_OBJECT_ACE {
   ACE_HEADER  Header;
   ACCESS_MASK Mask;
   DWORD       Flags;
   GUID        ObjectType;
   GUID        InheritedObjectType;
   DWORD       SidStart;
} SYSTEM_AUDIT_OBJECT_ACE, *PSYSTEM_AUDIT_OBJECT_ACE;
</pre></td></tr></table>
</p>

<p>Notice that like standard ACEs, each structure type is the same and the members of each structure are the same except for the addition of the <i>Flags</i>, <i>ObjectType</i>, and <i>InheritedObjectType</i> members.</p>

<p> Take care not to confuse the <i>Flags</i> member of the object ACE structures with the <i>AceFlags</i> member of the ACE_HEADER structure. The <i>Flags</i> member can be 0 or any combination of the values in Table 10-12.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Unlike similar structures in the Win32 SDK, the flags in Table 10-12 do not indicate whether the <i>ObjectType</i> and <i>InheritedObjectType</i> members are <i>used</i> in the structure, but rather whether these members exist in the structure at all! 

<p>Structures that do not have a fixed member list are referred to as <i>amorphous</i>. Each of the object ACE structures is amorphous, which is very uncommon for a structure in the Win32 SDK. This is by far the most difficult aspect of dealing with object ACEs.</p>
</blockquote>
</div>
</p>

<p><b>Table 10-12.</b> <i>Object ACE</i> Flags <i>member values</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Value  </th>
<th>Description  </th></tr>
<tr>
<td valign="top">ACE_OBJECT_TYPE_PRESENT  </td>
<td valign="top">Indicates that the <i>ObjectType</i> member is present in the object ACE structure  </td></tr>
<tr>
<td valign="top">ACE_INHERITED_OBJECT_TYPE_PRESENT   </td>
<td valign="top">Indicates that the <i>InheritedObjectType</i> member is present in the object ACE structure   </td></tr>
</table></p>

<p>Both <i>ObjectType</i> and <i>InheritedObjectType</i> are GUIDs. If you are unfamiliar with GUIDs, you can find a complete discussion of the topic in the Platform SDK documentation or <i>Inside COM</i> (Dale Rogerson, Microsoft Press, 1997). For our purposes, you need to understand only that a GUID is a 128-bit value that can be used to uniquely identify just about anything.</p>

<p> Fortunately, the Active Directory Service Interfaces (ADSI) provide interfaces for manipulating security on Active Directory objects that remove from your code the responsibility of dealing with object ACEs. For this reason, it is highly unlikely that you will have to write code that directly manipulates object ACEs in a DACL. For more
information on this topic, see the Platform SDK discussion on the <i>IADsSecurityDescriptor</i>, <i>IADsAccessControlList</i>, and <i>IADsAccessControlEntry</i> interfaces.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Object ACEs are never found in the ACLs of securable objects outside of Active Directory, and they significantly complicate ACL manipulation code. For this reason the remainder of this chapter (and all the code in this chapter) assumes ACLs do not contain object ACEs. ACLs without object ACEs ease my job as a writer and simplify your job of understanding a complicated topic.</blockquote>
</div>
</p>

<A NAME="216"><h3>Access Rights</h3></A>
<p>Access rights might at first seem like a simple concept to grasp, but some key points might not be obvious. The best way to understand the nuances of access rights is to discuss where they are used and to examine each group. First let's review what we already know:</p>


<ul>
<p><li>A trustee must hold a combination of access rights before the system will perform any securable task on a securable object on behalf of that trustee.</li></p>

<p><li>All access rights are packed into a 32-bit access mask. (See Figure 10-2.)</li></p>

<p><li>Access rights are divided into three groups: generic rights (bits 31-28), standard rights (bits 22-16), and specific rights (bits 15-0).</li></p>

<p><li>Two &quot;odd&quot; bits in an access mask do not fit into an access right group: the auditing bit and the maximum allowed bit.</li></p>
</ul>

 

<p>Up to this point, I have discussed access rights in terms of the access mask stored in an ACE, which is only one side of the transaction. I said that rights are necessary to perform tasks, but I have not specifically stated how you <i>ask</i> the system for a right. Asking for a right is the other side of the transaction.</p>

<p>You typically ask for a right when you ask the system for a handle to an object. Most functions that return handles to securable objects have a required access parameter to which you pass a value indicating how you intend to use the handle. Look at the following example:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, TEXT(&quot;MyEvent&quot;));
</pre></td></tr></table>
</p>

<p>You are probably so familiar with code like this that it never occurred to you that you were asking the system for a specific access right to the event object, but you are. The flag bits that you pass in the desired access parameter of <i>OpenEvent</i> (and other similar functions) are the same bits that are stored in the ACEs that secure the object. In fact, the system performs an access check before returning the handle to the event.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Many secured objects in Windows are accessed through handles. With these objects, security is checked when the handle is requested, and your rights are stored with the handle. This means that once you have received a handle to an object, the access rights on the object itself might change, but the access provided to you by your handle remains the same until the handle is closed.</blockquote>
</div>
</p>

<p>Some secure actions are performed on objects for which you never see a handle. A perfect example of this is every call to <i>GetNamedSecurityInfo</i>. The convenience of this function is that you do not have to first retrieve a handle to an object. In this case, the system internally performs an access check before performing any securable activity.</p>

<p>Now that you are familiar with both the ACE side and the access request side of access rights, let's discuss the types of access rights in more detail. First, we need to get the &quot;odd&quot; bits in the access mask out of the way.</p>

<p>The auditing bit represents the access right ACCESS_SYSTEM_SECURITY, which must be held by a trustee before that user can modify the SACL on an object. (I will discuss auditing in more detail later in this chapter.)</p>

<p>The maximum allowed bit represents the &quot;non-access right&quot; MAXIMUM_ALLOWED. I call it a non-access right because it will never be found in an ACE stored in a DACL. It is used only in calls to functions requesting access. For example, the following code fragment uses the MAXIMUM_ALLOWED flag in retrieving a handle to a named event object:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
HANDLE hEvent = OpenEvent(MAXIMUM_ALLOWED, FALSE, TEXT(&quot;MyEvent&quot;));
</pre></td></tr></table>
</p>

<p>In this case, the system performs an access check on the object, and rather than allowing or denying the access check, it returns an access mask that is the maximum rights awarded to you for the object. This might seem like a very convenient feature (and in certain situations it can be), as it allows you to always pass MAXIMUM_ALLOWED when requesting a handle rather than forcing you to figure out exactly which rights you need for an object. However, there is a very good reason not to do this.</p>

<p>When you obtain a handle to an object, typically you are being told by the system that you are allowed to use the object in a certain way. If you are denied a request for a handle, this typically means that you are not allowed to do whatever you have requested, and your software can take the appropriate measures.</p>

<p>If you pass MAXIMUM_ALLOWED each time you need access to an object, your code might work well for a long time. But the first time your code encounters an object for which you are not awarded sufficient access, your software might not catch the error until long after it has retrieved a handle to the object. The failing function might not even return ERROR_ACCESS_DENIED. It is entirely possible that a function will return another error such as ERROR_INVALID_PARAMETER, because you passed a handle to it with insufficient access to an object. Code with this type of problem can be drastically harder to debug.</p>

<p><b>Standard access rights</b> Five standard rights are defined by the system. In addition to these, another five &quot;composite&quot; access rights are defined by the system that map to some combination of the five standard rights.</p>

<p>Not all standard rights are relevant for all securable objects in the system, but each standard right is special in that its meaning does not change from object to object. For example, not all objects can be deleted, so the standard right DELETE has no meaning for certain objects. However, for objects that can be deleted, the standard right DELETE carries the same meaning from one object type to the next: the holder of this right can delete the object. Table 10-13 lists all the standard and composite rights.</p>

<p><b>Table 10-13.</b> <i>Standard and composite rights</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Right  </th>
<th>Description  </th></tr>
<tr>
<td valign="top" colspan="2" align="left"><i>Standard Rights</i>  </td></tr>
<tr>
<td valign="top">DELETE <br>(bit 16) </td>
<td valign="top">Delete access.  </td></tr>
<tr>
<td valign="top">READ_CONTROL <br>(bit 17) </td>
<td valign="top">Read access to the security information of a securable object, including the owner SID, the group SID, the DACL, and the security descriptor revision and control. It does not include the access required to read the SACL of a secured object.  </td></tr>
<tr>
<td valign="top">WRITE_DAC <br>(bit 18) </td>
<td valign="top">Write access to the DACL and group SID of a secured object. WRITE_DAC access is implicitly granted to the owner of an object.  </td></tr>
<tr>
<td valign="top">WRITE_OWNER <br>(bit 19) </td>
<td valign="top">Write access to the owner SID of a secured object. Unless you also hold the SE_BACKUP_NAME privilege, you can write a SID that only denotes your user SID or one of your group SIDs to the owner SID of an object.  </td></tr>
<tr>
<td valign="top">SYNCHRONIZE <br>(bit 20) </td>
<td valign="top">Synchronize access can be thought of as the right to wait on an object. Such an object can be a synchronization object (for example, an event or mutex), or it can be one of the other waitable kernel objects (for example, a file or a process handle).  </td></tr>
<tr>
<td valign="top" colspan="2" align="left"><i>Standard Right Composites</i>  </td></tr>
<tr>
<td valign="top">STANDARD_RIGHTS_READ <br>STANDARD_RIGHTS_WRITE<br> STANDARD_RIGHTS_EXECUTE</td>
<td valign="top"> Maps to READ_CONTROL access. </td></tr>
<tr>
<td valign="top">STANDARD_RIGHTS_REQUIRED  </td>
<td valign="top">Maps to bits 16-19; or to DELETE, READ_ CONTROL, WRITE_DAC, and WRITE_OWNER. This access right is typically included with the &quot;all access&quot; defines for specific objects such as EVENT_ALL_ACCESS or FILE_ALL_ACCESS.  </td></tr>
<tr>
<td valign="top">STANDARD_RIGHTS_ALL  </td>
<td valign="top">Defined as 0x001F0000, this access right includes all the standard rights.  </td></tr>
</table></p>


As Table 10-13 shows, the standard rights include some powerful rights. For example, if you hold WRITE_OWNER access to an object, but are denied all other access, you might not be able to do much, as is. But if you choose to use this access to set the owner SID of the object to your SID, you have implicit WRITE_DAC access. You can then use this access to modify the DACL of the object, allowing yourself all the access you want to this object. 

<p><b>Specific rights</b> Specific rights inhabit bits 15-0 of the access mask, and therefore each securable object in the system can have 16 different access rights defined for it.</p>

<p>Because the specific rights differ from object to object, the greatest challenge in working with specific rights is finding a comprehensive list of all specific rights available for a given object. You should look for specific rights in two places: the Platform SDK documentation and the Platform SDK header files. You should check the function that gives you a handle to an existing object of the type you are interested in. For example, if you were interested in finding the specific rights available for a registry key, you might check the Platform SDK documentation for the <i>RegOpenKeyEx</i> function, where you would find a description of rights such as KEY_READ, KEY_SET_VALUE, and KEY_ALL_ACCESS. After you have the names of a couple of access rights for an object, you can search the Platform SDK's include directory for a header file that defines one or more of the specific rights that you know, and you will find the remaining access rights for that object.</p>

<p> Table 10-14 lists the specific rights, as of
this writing, for the most common securable objects in Windows.</p>

<p>SPECIFIC_RIGHTS_ALL is defined as 0x0000FFFF, which includes all 16 of the bits, reserved for specific rights in an access mask. Object Type Specific Right</p>

<p><b>Table 10-14.</b> <i>Specific rights for common securable objects</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Object Type  </th>
<th>Specific Right  </th></tr>
<tr>
<td valign="top" colspan="2">File<br> (WinNT.h)  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">FILE_ALL_ACCESS<br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED |<br>&nbsp;&nbsp;&nbsp;&nbsp;SYNCHRONIZE | <br>&nbsp;&nbsp;&nbsp;&nbsp;0x1FF)<br> &nbsp;&nbsp;&nbsp;&nbsp;(0x1FF includes all currently defined standard rights for files.)<br>FILE_READ_DATA<br>FILE_WRITE_DATA<br>FILE_APPEND_DATA<br>FILE_READ_EA<br>FILE_WRITE_EA<br>FILE_EXECUTE<br>FILE_READ_ATTRIBUTES<br>FILE_WRITE_ATTRIBUTES</td></tr>
<tr>
<td valign="top" colspan="2">Directory<br> (WinNT.h) </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">FILE_ALL_ACCESS<br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED |<br>&nbsp;&nbsp;&nbsp;&nbsp;SYNCHRONIZE | <br>&nbsp;&nbsp;&nbsp;&nbsp;0x1FF)<br>&nbsp;&nbsp;&nbsp;&nbsp;(0x1FF includes all currently defined standard rights for files.)<br>FILE_LIST_DIRECTORY<br>FILE_ADD_FILE<br>FILE_ADD_SUBDIRECTORY<br>FILE_READ_EA<br>FILE_WRITE_EA<br>FILE_TRAVERSE<br>FILE_DELETE_CHILD<br>FILE_READ_ATTRIBUTES<br>FILE_WRITE_ATTRIBUTES</td></tr>
<tr>
<td valign="top" colspan="2">Service <br>(WinSvc.h) </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">SERVICE_ALL_ACCESS<br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED |<br>&nbsp;&nbsp;&nbsp;&nbsp;SERVICE_QUERY_CONFIG |<br>&nbsp;&nbsp;&nbsp;&nbsp;SERVICE_CHANGE_CONFIG |<br>&nbsp;&nbsp;&nbsp;&nbsp;SERVICE_QUERY_STATUS |<br>&nbsp;&nbsp;&nbsp;&nbsp;SERVICE_ENUMERATE_DEPENDENTS | <br>&nbsp;&nbsp;&nbsp;&nbsp;SERVICE_START |<br>&nbsp;&nbsp;&nbsp;&nbsp;SERVICE_STOP |<br>&nbsp;&nbsp;&nbsp;&nbsp;SERVICE_PAUSE_CONTINUE |<br>&nbsp;&nbsp;&nbsp;&nbsp;SERVICE_INTERROGATE |<br>&nbsp;&nbsp;&nbsp;&nbsp;SERVICE_USER_DEFINED_CONTROL)<br>SERVICE_CHANGE_CONFIG<br>SERVICE_ENUMERATE_DEPENDENTS<br>SERVICE_INTERROGATE<br>SERVICE_PAUSE_CONTINUE<br>SERVICE_QUERY_CONFIG<br>SERVICE_QUERY_STATUS<br>SERVICE_START<br>SERVICE_STOP<br>SERVICE_USER_DEFINED_CONTROL</td></tr>
<tr>
<td valign="top" colspan="2">Printer<br>(WinSpool.h)  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">SERVER_ALL_ACCESS <br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED |<br>&nbsp;&nbsp;&nbsp;&nbsp;SERVER_ACCESS_ADMINISTER |<br>&nbsp;&nbsp;&nbsp;&nbsp;SERVER_ACCESS_ENUMERATE)<br>PRINTER_ALL_ACCESS<br>&nbsp;&nbsp;&nbsp;&nbsp; (STANDARD_RIGHTS_REQUIRED |<br>&nbsp;&nbsp;&nbsp;&nbsp;PRINTER_ACCESS_ADMINISTER |<br>&nbsp;&nbsp;&nbsp;&nbsp;PRINTER_ACCESS_USE)<br>JOB_ALL_ACCESS<br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED |<br>&nbsp;&nbsp;&nbsp;&nbsp;JOB_ACCESS_ADMINISTER)<br>SERVER_ACCESS_ADMINISTER<br>SERVER_ACCESS_ENUMERATE<br>PRINTER_ACCESS_ADMINISTER<br>PRINTER_ACCESS_USE<br>JOB_ACCESS_ADMINISTER</td></tr>
<tr>
<td valign="top" colspan="2">Registry key <br>(WinNT.h) </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">KEY_ALL_ACCESS<br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_ALL | <br>&nbsp;&nbsp;&nbsp;&nbsp;KEY_QUERY_VALUE |<br>&nbsp;&nbsp;&nbsp;&nbsp;KEY_SET_VALUE |<br>&nbsp;&nbsp;&nbsp;&nbsp;KEY_CREATE_SUB_KEY | <br>&nbsp;&nbsp;&nbsp;&nbsp;KEY_ENUMERATE_SUB_KEYS |<br>&nbsp;&nbsp;&nbsp;&nbsp;KEY_NOTIFY |<br>&nbsp;&nbsp;&nbsp;&nbsp;KEY_CREATE_LINK)<br>KEY_QUERY_VALUE<br>KEY_SET_VALUE<br>KEY_CREATE_SUB_KEY<br>KEY_ENUMERATE_SUB_KEYS<br>KEY_NOTIFY<br>KEY_CREATE_LINK</td></tr>
<tr>
<td valign="top" colspan="2">Share object <br>(LMShare.h) </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">PERM_FILE_READ <br>PERM_FILE_WRITE <br>PERM_FILE_CREATE</td></tr>
<tr>
<td valign="top" colspan="2">Process <br>(WinNT.h) </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">PROCESS_ALL_ACCESS <br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED | <br>&nbsp;&nbsp;&nbsp;&nbsp;SYNCHRONIZE |<br>&nbsp;&nbsp;&nbsp;&nbsp;0xFFF)<br>&nbsp;&nbsp;&nbsp;&nbsp;(0xFFF includes all currently defined standard rights for processes.)<br>PROCESS_TERMINATE<br>PROCESS_CREATE_THREAD<br>PROCESS_SET_SESSIONID<br>PROCESS_VM_OPERATION<br>PROCESS_VM_READ<br>PROCESS_VM_WRITE<br>PROCESS_DUP_HANDLE<br>PROCESS_CREATE_PROCESS<br>PROCESS_SET_QUOTA<br>PROCESS_SET_INFORMATION<br>PROCESS_QUERY_INFORMATION</td></tr>
<tr>
<td valign="top" colspan="2">Thread <br>(WinNT.h) </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">THREAD_ALL_ACCESS<br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED |<br> &nbsp;&nbsp;&nbsp;&nbsp;SYNCHRONIZE |<br>&nbsp;&nbsp;&nbsp;&nbsp;0x3FF)<br>&nbsp;&nbsp;&nbsp;&nbsp;(0x3FF includes all currently defined standard rights for threads.) <br>THREAD_TERMINATE<br>THREAD_SUSPEND_RESUME<br>THREAD_GET_CONTEXT<br>THREAD_SET_CONTEXT<br>THREAD_SET_INFORMATION<br>THREAD_QUERY_INFORMATION<br>THREAD_SET_THREAD_TOKEN<br>THREAD_IMPERSONATE<br>THREAD_DIRECT_IMPERSONATION</td></tr>
<tr>
<td valign="top" colspan="2">Job <br>(WinNT.h) </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">JOB_OBJECT_ALL_ACCESS <br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED | <br>&nbsp;&nbsp;&nbsp;&nbsp;SYNCHRONIZE |<br>&nbsp;&nbsp;&nbsp;&nbsp;0x1F)<br>&nbsp;&nbsp;&nbsp;&nbsp;(0x1F includes all currently defined standard rights for job objects.)<br>JOB_OBJECT_ASSIGN_PROCESS<br>JOB_OBJECT_SET_ATTRIBUTES<br>JOB_OBJECT_QUERY<br>JOB_OBJECT_TERMINATE<br>JOB_OBJECT_SET_SECURITY_ATTRIBUTES</td></tr>
<tr>
<td valign="top" colspan="2">Semaphore <br>(WinNT.h) </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">SEMAPHORE_ALL_ACCESS <br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED | <br>&nbsp;&nbsp;&nbsp;&nbsp;SYNCHRONIZE |<br>&nbsp;&nbsp;&nbsp;&nbsp;0x3)<br>&nbsp;&nbsp;&nbsp;&nbsp;(0x3 includes all currently defined standard rights for semaphores.)<br>SEMAPHORE_MODIFY_STATE<br>MUTANT_QUERY_STATE</td></tr>
<tr>
<td valign="top" colspan="2">Event <br>(WinNT.h) </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">EVENT_ALL_ACCESS <br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED | <br>&nbsp;&nbsp;&nbsp;&nbsp;SYNCHRONIZE |<br>&nbsp;&nbsp;&nbsp;&nbsp;0x3)<br>&nbsp;&nbsp;&nbsp;&nbsp;(0x3 includes all currently defined standard rights for events.)<br>EVENT_MODIFY_STATE<br>MUTANT_QUERY_STATE</td></tr>
<tr>
<td valign="top" colspan="2">Mutex<br>(WinBase.h)  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">MUTEX_ALL_ACCESS <br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED |<br>&nbsp;&nbsp;&nbsp;&nbsp;SYNCHRONIZE |<br>&nbsp;&nbsp;&nbsp;&nbsp;0x3)<br>&nbsp;&nbsp;&nbsp;&nbsp;(0x3 includes all currently defined standard rights for mutexes.)<br>MUTEX_MODIFY_STATE<br>MUTANT_QUERY_STATE </td></tr>
<tr>
<td valign="top" colspan="2">File map object <br>(WinBase.h) </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">FILE_MAP_ALL_ACCESS<br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED |<br>&nbsp;&nbsp;&nbsp;&nbsp;FILE_MAP_COPY | <br>&nbsp;&nbsp;&nbsp;&nbsp;FILE_MAP_WRITE |<br>&nbsp;&nbsp;&nbsp;&nbsp; FILE_MAP_READ |<br>&nbsp;&nbsp;&nbsp;&nbsp;SECTION_MAP_EXECUTE<br>&nbsp;&nbsp;&nbsp;&nbsp;SECTION_EXTEND_SIZE)<br>FILE_MAP_WRITE<br>FILE_MAP_READ<br>FILE_MAP_COPY<br>SECTION_EXTEND_SIZE</td></tr>
<tr>
<td valign="top" colspan="2">Waitable timer <br>(WinNT.h) </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top"> TIMER_ALL_ACCESS <br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED |<br>&nbsp;&nbsp;&nbsp;&nbsp;SYNCHRONIZE |<br>&nbsp;&nbsp;&nbsp;&nbsp;TIMER_QUERY_STATE |<br>&nbsp;&nbsp;&nbsp;&nbsp;TIMER_MODIFY_STATE)<br>TIMER_QUERY_STATE<br>TIMER_MODIFY_STATE</td></tr>
<tr>
<td valign="top" colspan="2">Token <br>(WinNT.h) </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">TOKEN_ALL_ACCESS <br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED | <br>&nbsp;&nbsp;&nbsp;&nbsp;TOKEN_ASSIGN_PRIMARY |<br>&nbsp;&nbsp;&nbsp;&nbsp;TOKEN_DUPLICATE |<br>&nbsp;&nbsp;&nbsp;&nbsp;TOKEN_IMPERSONATE |<br>&nbsp;&nbsp;&nbsp;&nbsp;TOKEN_QUERY |<br>&nbsp;&nbsp;&nbsp;&nbsp;TOKEN_QUERY_SOURCE |<br>&nbsp;&nbsp;&nbsp;&nbsp;TOKEN_ADJUST_PRIVILEGES |<br>&nbsp;&nbsp;&nbsp;&nbsp;TOKEN_ADJUST_GROUPS |<br>&nbsp;&nbsp;&nbsp;&nbsp;TOKEN_ADJUST_SESSIONID |<br>&nbsp;&nbsp;&nbsp;&nbsp;TOKEN_ADJUST_DEFAULT)<br>TOKEN_ASSIGN_PRIMARY<br>TOKEN_DUPLICATE<br>TOKEN_IMPERSONATE<br>TOKEN_QUERY<br>TOKEN_QUERY_SOURCE<br>TOKEN_ADJUST_PRIVILEGES<br>TOKEN_ADJUST_GROUPS<br>TOKEN_ADJUST_DEFAULT<br>TOKEN_ADJUST_SESSIONID</td></tr>
<tr>
<td valign="top" colspan="2">Pipe <br>(WinNT.h) </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">FILE_ALL_ACCESS<br>&nbsp;&nbsp;&nbsp;&nbsp;(STANDARD_RIGHTS_REQUIRED |<br>&nbsp;&nbsp;&nbsp;&nbsp;SYNCHRONIZE |<br>&nbsp;&nbsp;&nbsp;&nbsp; 0x1FF)<br>&nbsp;&nbsp;&nbsp;&nbsp;(0x1FF includes all currently defined standard rights for files.)<br>FILE_READ_DATA <br>FILE_WRITE_DATA<br>FILE_CREATE_PIPE_INSTANCE<br>FILE_READ_ATTRIBUTES<br>FILE_WRITE_ATTRIBUTES</td></tr>
<tr>
<td valign="top" colspan="2">Window station <br>(WinUser.h) </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">WINSTA_ACCESSCLIPBOARD<br> WINSTA_ACCESSGLOBALATOMS<br>WINSTA_CREATEDESKTOP<br>WINSTA_ENUMDESKTOPS <br>WINSTA_ENUMERATE<br>WINSTA_EXITWINDOWS<br>WINSTA_READATTRIBUTES<br>WINSTA_READSCREEN<br>WINSTA_WRITEATTRIBUTES</td></tr>
<tr>
<td valign="top" colspan="2">Desktop<br>(WinUser.h)  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top"> DESKTOP_CREATEMENU <br>DESKTOP_CREATEWINDOW<br>DESKTOP_ENUMERATE<br>DESKTOP_HOOKCONTROL<br>DESKTOP_JOURNALPLAYBACK<br>DESKTOP_JOURNALRECORD<br>DESKTOP_READOBJECTS<br>DESKTOP_SWITCHDESKTOP<br>DESKTOP_WRITEOBJECTS</td></tr>
</table></p>


<p>With these specific rights and the standard rights discussed earlier, you have all the rights required to secure an object. However, there is still the issue of generic rights.</p>

<p><b>Generic rights and default security</b> Previously in this chapter I mentioned that default security is assigned to securable objects when the software creating the object does not explicitly set the security for the object. This assignment is typically characterized by passing NULL for the security attributes parameter of a function that creates a securable object such as a file or an event. Before we can discuss generic rights, you must understand how default security is implemented.</p>

<p>Remember that your executing code is associated with an internal structure known as a token. Up to this point, I have said that the token contains your identifying SID and group SIDs, as well as a list of privileges assigned to you. In addition to this information, every token also stores a DACL that is used for creating objects with default security, known as the <i>default DACL</i>, and can be set by your code. (This and many other topics regarding tokens are covered in detail in the <a href="ch11a.htm">next chapter</a>.)</p>

<p>For the moment, you need to be aware that a DACL exists (which you can modify and set) and that it can be applied to objects created with default security. The important issue to note is that the DACL can be applied to any type of object. So you can see that this creates a problem for the system.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Neither the DACL nor the standard ACE structures maintain information about the object type that they are protecting. This complicates the creation of ACEs for a default DACL, since specific rights for one type of object might not be appropriate if applied to another type of object. The creators of Windows solved this problem by creating generic rights.</blockquote>
</div>
</p>

<p>Generic rights are intended for use in the default DACL for a token. The system defines the generic rights GENERIC_READ, GENERIC_WRITE, GENERIC_EXECUTE, and GENERIC_ALL. When a default DACL is applied to an object, the system maps any generic rights found in the DACL's ACEs to a combination of standard and specific rights appropriate for that object. In this way, an ACE that will appropriately affect the security on any object that uses that ACE can be added to the default DACL.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
You cannot directly assign a DACL to an object that contains ACEs whose access masks include generic rights. The system automatically clears these rights from the ACE before setting the security on the object. </blockquote></div>
</p>

<p><div class="note"><blockquote><b>NOTE</b><hr> You can specify generic rights when requesting access to an object, but you should never do this. It is more appropriate to request the standard and specific rights that will meet the needs of your code.</blockquote>
</div>
</p>

<p>Knowing what you know about generic rights, you might be wondering how you can find out what generic rights map to for a specific object in the system. This is a good question, and the only good answer is to create a default DACL with an ACE that includes a single generic right (such as GENERIC_READ), and then create an object and inspect the resulting ACE. (See <A HREF="ch11a.htm">Chapter 11</A>.) I did this to produce Table 10-15.</p>

<p><b>Table 10-15.</b> <i>Generic mappings for common securable objects</i></p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Object Type  </th>
<th>Generic Right   </th>
<th>Standard and Specific Mapped Rights  </th></tr>
<tr>
<td valign="top" colspan="3">File  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ<br>GENERIC_WRITE<br>GENERIC_EXECUTE<br>GENERIC_ALL  </td>
<td valign="top">FILE_GENERIC_READ <br>FILE_GENERIC_WRITE<br>FILE_GENERIC_EXECUTE<br>FILE_ALL_ACCESS </td></tr>
<tr>
<td valign="top" colspan="3">Directory  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ  </td>
<td valign="top">STANDARD_RIGHTS_READ |<br> FILE_LIST_DIRECTORY |<br>FILE_ADD_FILE </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_WRITE   </td>
<td valign="top">STANDARD_RIGHTS_WRITE |<br>FILE_ADD_SUBDIRECTORY |<br>FILE_READ_EA   </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_EXECUTE  </td>
<td valign="top">STANDARD_RIGHTS_EXECUTE |<br>FILE_LIST_DIRECTORY |<br>FILE_ADD_FILE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_ALL  </td>
<td valign="top">STANDARD_RIGHTS_REQUIRED | <br>FILE_LIST_DIRECTORY |<br>FILE_ADD_FILE | <br>FILE_ADD_SUBDIRECTORY |<br>FILE_READ_EA </td></tr>
<tr>
<td valign="top" colspan="3">Service  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ  </td>
<td valign="top">STANDARD_RIGHTS_READ |<br>SERVICE_QUERY_CONFIG |<br>SERVICE_QUERY_STATUS |<br> SERVICE_ENUMERATE_DEPENDENTS |<br> SERVICE_INTERROGATE |<br> SERVICE_USER_DEFINED_CONTROL   </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_WRITE  </td>
<td valign="top">STANDARD_RIGHTS_WRITE |<br> SERVICE_CHANGE_CONFIG  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_EXECUTE   </td>
<td valign="top">STANDARD_RIGHTS_EXECUTE |<br> SERVICE_START |<br> SERVICE_STOP |<br> SERVICE_PAUSE_CONTINUE |<br> SERVICE_INTERROGATE |<br> SERVICE_USER_DEFINED_CONTROL  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_ALL  </td>
<td valign="top">SERVICE_ALL_ACCESS  </td></tr>
<tr>
<td valign="top" colspan="3">Printer  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ<br>GENERIC_WRITE<br>GENERIC_EXECUTE<br>GENERIC_ALL   </td>
<td valign="top">PRINTER_READ<br>PRINTER_WRITE<br>PRINTER_EXECUTE<br> PRINTER_ALL_ACCESS  </td></tr>
<tr>
<td valign="top" colspan="3">Registry key  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ<br> GENERIC_WRITE<br>GENERIC_EXECUTE<br>GENERIC_ALL </td>
<td valign="top">KEY_READ<br>KEY_WRITE<br>KEY_EXECUTE<br>KEY_ALL_ACCESS   </td></tr>
<tr>
<td valign="top" colspan="3">Process  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ  </td>
<td valign="top">STANDARD_RIGHTS_READ |<br> PROCESS_VM_READ |<br> PROCESS_QUERY_INFORMATION  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_WRITE  </td>
<td valign="top">  STANDARD_RIGHTS_WRITE |<br> PROCESS_CREATE_PROCESS |<br> PROCESS_CREATE_THREAD |<br> PROCESS_VM_OPERATION |<br> PROCESS_VM_WRITE |<br> PROCESS_DUP_HANDLE |<br> PROCESS_TERMINATE |<br> PROCESS_SET_QUOTA |<br> PROCESS_SET_INFORMATION </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_EXECUTE  </td>
<td valign="top">STANDARD_RIGHTS_EXECUTE |<br> SYNCHRONIZE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_ALL  </td>
<td valign="top">PROCESS_ALL_ACCESS  </td></tr>
<tr>
<td valign="top" colspan="3">Thread  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ  </td>
<td valign="top">STANDARD_RIGHTS_READ |<br> THREAD_GET_CONTEXT |<br> THREAD_QUERY_INFORMATION  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_WRITE  </td>
<td valign="top">STANDARD_RIGHTS_WRITE |<br> THREAD_TERMINATE |<br> THREAD_SUSPEND_RESUME |<br> THREAD_SET_INFORMATION |<br> THREAD_SET_CONTEXT  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_EXECUTE  </td>
<td valign="top">STANDARD_RIGHTS_EXECUTE |<br> SYNCHRONIZE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_ALL  </td>
<td valign="top">THREAD_ALL_ACCESS  </td></tr>
<tr>
<td valign="top" colspan="3">Job  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ  </td>
<td valign="top">STANDARD_RIGHTS_READ |<br> JOB_OBJECT_QUERY  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_WRITE  </td>
<td valign="top">STANDARD_RIGHTS_WRITE |<br> JOB_OBJECT_ASSIGN_PROCESS |<br> JOB_OBJECT_SET_ATTRIBUTES |<br> JOB_OBJECT_TERMINATE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_EXECUTE  </td>
<td valign="top">STANDARD_RIGHTS_EXECUTE |<br> SYNCHRONIZE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_ALL  </td>
<td valign="top">JOB_OBJECT_ALL_ACCESS </td></tr>
<tr>
<td valign="top" colspan="3">Semaphore  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ  </td>
<td valign="top">STANDARD_RIGHTS_READ |<br> MUTANT_QUERY_STATE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_WRITE  </td>
<td valign="top">STANDARD_RIGHTS_WRITE |<br> SEMAPHORE_MODIFY_STATE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_EXECUTE  </td>
<td valign="top">STANDARD_RIGHTS_EXECUTE |<br> SYNCHRONIZE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_ALL  </td>
<td valign="top">SEMAPHORE_ALL_ACCESS  </td></tr>
<tr>
<td valign="top" colspan="3">Event  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ  </td>
<td valign="top">STANDARD_RIGHTS_READ |<br> MUTANT_QUERY_STATE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_WRITE   </td>
<td valign="top">STANDARD_RIGHTS_WRITE |<br> EVENT_MODIFY_STATE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_EXECUTE  </td>
<td valign="top">STANDARD_RIGHTS_EXECUTE |<br> SYNCHRONIZE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_ALL  </td>
<td valign="top">EVENT_ALL_ACCESS  </td></tr>
<tr>
<td valign="top" colspan="3">Mutex  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ  </td>
<td valign="top">STANDARD_RIGHTS_READ |<br> MUTANT_QUERY_STATE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_WRITE </td>
<td valign="top">STANDARD_RIGHTS_WRITE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_EXECUTE  </td>
<td valign="top">STANDARD_RIGHTS_EXECUTE |<br> SYNCHRONIZE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_ALL  </td>
<td valign="top">MUTEX_ALL_ACCESS  </td></tr>
<tr>
<td valign="top" colspan="3">File map object  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ  </td>
<td valign="top">STANDARD_RIGHTS_READ |<br> FILE_MAP_COPY |<br> FILE_MAP_READ  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_WRITE  </td>
<td valign="top">STANDARD_RIGHTS_WRITE | <br>FILE_MAP_WRITE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_EXECUTE  </td>
<td valign="top">STANDARD_RIGHTS_EXECUTE | <br>FILE_MAP_EXECUTE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_ALL   </td>
<td valign="top">FILE_MAP_ALL_ACCESS  </td></tr>
<tr>
<td valign="top" colspan="3">Waitable timer  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ  </td>
<td valign="top">STANDARD_RIGHTS_READ |<br> TIMER_QUERY_STATE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_WRITE  </td>
<td valign="top">STANDARD_RIGHTS_WRITE |<br> TIMER_MODIFY_STATE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_EXECUTE  </td>
<td valign="top">STANDARD_RIGHTS_EXECUTE |<br> SYNCHRONIZE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_ALL  </td>
<td valign="top">TIMER_ALL_ACCESS  </td></tr>
<tr>
<td valign="top" colspan="3">Token  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ  </td>
<td valign="top">TOKEN_READ  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_WRITE  </td>
<td valign="top">TOKEN_WRITE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_EXECUTE  </td>
<td valign="top">TOKEN_EXECUTE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_ALL  </td>
<td valign="top">TOKEN_ALL_ACCESS  </td></tr>
<tr>
<td valign="top" colspan="3">Window station  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ  </td>
<td valign="top">WINSTA_ENUMDESKTOPS |<br> WINSTA_READATTRIBUTES |<br> WINSTA_ENUMERATE |<br> WNSTA_READSCREEN |<br> STANDARD_RIGHTS_READ  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_WRITE  </td>
<td valign="top">WINSTA_ACCESSCLIPBOARD |<br> WINSTA_CREATEDESKTOP |<br> WINSTA_WRITEATTRIBUTES |<br> STANDARD_RIGHTS_WRITE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_EXECUTE  </td>
<td valign="top">WINSTA_ACCESSGLOBALATOMS |<br> WINSTA_EXITWINDOWS |<br> STANDARD_RIGHTS_EXECUTE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_ALL   </td>
<td valign="top">WINSTA_ENUMDESKTOPS |<br> WINSTA_READATTRIBUTES |<br> WINSTA_ENUMERATE |<br> WINSTA_READSCREEN |<br> WINSTA_ACCESSCLIPBOARD |<br> WINSTA_CREATEDESKTOP |<br> WINSTA_WRITEATTRIBUTES |<br> WINSTA_ACCESSGLOBALATOMS |<br> WINSTA_EXITWINDOWS |<br> STANDARD_RIGHTS_REQUIRED  </td></tr>
<tr>
<td valign="top" colspan="3">Desktop  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_READ  </td>
<td valign="top">DESKTOP_READOBJECTS |<br> DESKTOP_ENUMERATE |<br> STANDARD_RIGHTS_READ  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_WRITE  </td>
<td valign="top">DESKTOP_WRITEOBJECTS |<br> DESKTOP_CREATEWINDOW |<br> DESKTOP_CREATEMENU |<br> DESKTOP_HOOKCONTROL | <br>DESKTOP_JOURNALRECORD |<br> DESKTOP_JOURNALPLAYBACK |<br> STANDARD_RIGHTS_WRITE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_EXECUTE  </td>
<td valign="top">DESKTOP_SWITCHDESKTOP |<br> STANDARD_RIGHTS_EXECUTE  </td></tr>
<tr>
<td valign="top">  </td>
<td valign="top">GENERIC_ALL  </td>
<td valign="top">DESKTOP_READOBJECTS |<br> DESKTOP_WRITEOBJECTS |<br> DESKTOP_ENUMERATE |<br> DESKTOP_CREATEWINDOW |<br> DESKTOP_CREATEMENU |<br> DESKTOP_HOOKCONTROL |<br> DESKTOP_JOURNALRECORD |<br> DESKTOP_JOURNALPLAYBACK |<br> DESKTOP_SWITCHDESKTOP |<br> STANDARD_RIGHTS_REQUIRED  </td></tr>
</table></p>


<p>Before we proceed, I must make one more point about default security. If you are dealing with objects for which security is inheritable (such as registry keys or files), the default security is applied only to objects for which no ACEs are inherited from parent objects. In both registry and file system hierarchies, ACEs are inherited by default, so <i>default security</i> is not applied in the common case.</p>

<p>Now that you are familiar with all types of access rights, as well as the ACE and ACL types that contain these rights, you have all the tools necessary to read and interpret the security of any object in the system.</p>

<A NAME="217"><h2>The AccessMaster Sample Application</h2></A>
<p>The AccessMaster sample application (&quot;10 AccessMaster.exe&quot;) demonstrates the usage of the <i>GetNamedSecurityInfo</i>, <i>SetNamedSecurityInfo</i>, <i>GetSecurityInfo</i>, and <i>SetSecurityInfo</i> functions as well as the <i>ISecurityInformation</i> interface for the <i>EditSecurity</i> common dialog. The source code and resource files for the application are in the AccessMaster directory on the companion CD. Figure 10-7 shows AccessMaster being used to set the security for a file.</p>

<p>
<A HREF="javascript:fullSize('F10FJ07x.htm')"> <img src="images/F10FJ07.JPG" width=404 height=263 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 10-7.</b> <i>AccessMaster being used to set the security for a file</i><!-- /caption -->
</p>

<p>In addition to showing how to programmatically get and set the security for common objects in the system, the AccessMaster sample application can be a very useful tool for understanding access control for securable objects. You can access objects by name or by process ID and numeric handle value (use decimal values). You can also view ACEs with raw binary access masks rather than map them to standard and specific rights for the objects.</p>

<p>The AccessMaster tool also lets you set the security on securable objects in the system. Remember that because you might not have rights to all objects in the system, you have to take ownership of an object before you can read or write its other security information. To accomplish this, you can use the TrusteeMan sample application from <A HREF="ch09a.htm">Chapter 9</A> to assign the SE_TAKE_ OWNERSHIP_NAME privilege to your user account.</p>

<p>If you are unfamiliar with the ramifications of access control on objects in the system, including objects created by your software, you can use the AccessMaster tool to view and modify the access rights assigned to these objects.</p>

<A NAME="218"><h2>Setting Security Information for an Object</h2></A>
<p>The next step in programming for access control is setting the security of a securable object. For most securable objects in the system, you do this by calling <i>SetSecurityInfo</i> or <i>SetNamedSecurityInfo</i>. (For a list of securable objects and the functions used to get and set their security, see Table 10-7.)</p>

<p>Here is the definition of the <i>SetSecurityInfo</i> function:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
DWORD SetSecurityInfo(
   HANDLE               handle,
   SE_OBJECT_TYPE       objType,
   SECURITY_INFORMATION secInfo,
   PSID                 psidOwner,
   PSID                 psidGroup,
   PACL                 pDACL,
   PACL                 pSACLl);
</pre></td></tr></table>
</p>

<p>And here is the definition of the <i>SetNamedSecurityInfo</i> function:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
DWORD SetNamedSecurityInfo(
   LPTSTR               pObjectName,
   SE_OBJECT_TYPE       objType,
   SECURITY_INFORMATION secInfo,
   PSID                 psidOwner,
   PSID                 psidGroup,
   PACL                 pDACL,
   PACL                 pSACL);
</pre></td></tr></table>
</p>

<p>As you can see, these functions are very similar, except that <i>SetSecurityInfo</i> sets the security of an object for which you have a handle, and <i>SetNamedSecurityInfo</i> sets the security of a named object in the system and does not require a handle.</p>

<p>These functions also have a strong resemblance to their cousins, <i>GetSecurityInfo</i> and <i>GetNamedSecurityInfo</i>. Notice that the <i>objType</i> parameter of the &quot;SetSecurity&quot; functions defines the type of object for which you are setting security information, and uses the same object types as the &quot;GetSecurity&quot; functions. (See Table 10-7.)</p>

<p>The <i>secInfo</i> parameter indicates which components of the object's security descriptor you wish to set. These components can be any combination of the object's owner SID, group SID, DACL, and SACL. Additionally, this parameter is used to set a security descriptor as protected from inherited ACEs in parent DACLs and SACLs. Table 10-16 shows all values that can be passed as the <i>secInfo</i> parameter to <i>SetNamedSecurityInfo</i> and <i>SetNamedSecurity.</i> You can combine any of these values to indicate exactly what and how to apply the security to your object.</p>

<p><b>Table 10-16.</b> <i>Values that can be passed as the</i> secInfo <i>parameter to</i> SetNamedSecurityInfo <i>and</i> SetNamedSecurity</p>

<p>
<table cellpadding=5 width="95%">
<tr> 
<th>Value  </th>
<th>Description  </th></tr>
<tr>
<td valign="top">DACL_SECURITY_INFORMATION  </td>
<td valign="top">Indicates that you wish to set DACL information for a securable object.  </td></tr>
<tr>
<td valign="top">SACL_SECURITY_INFORMATION  </td>
<td valign="top">Indicates that you wish to set SACL information for a securable object.  </td></tr>
<tr>
<td valign="top">OWNER_SECURITY_INFORMATION  </td>
<td valign="top">Indicates that you wish to set the owner SID for a securable object.  </td></tr>
<tr>
<td valign="top">GROUP_SECURITY_INFORMATION  </td>
<td valign="top">Indicates that you wish to set the group SID for a securable object.  </td></tr>
<tr>
<td valign="top">UNPROTECTED_DACL_SECURITY_INFORMATION  </td>
<td valign="top">Indicates that you want inherited ACEs in  parent objects to propagate to this object's DACL. This flag must be used with DACL_SECURITY_INFORMATION and cannot be used with PROTECTED_DACL_ SECURITY_INFORMATION.  </td></tr>
<tr>
<td valign="top">PROTECTED_DACL_SECURITY_INFORMATION   </td>
<td valign="top">Indicates that you do not want inherited ACEs in parent objects to propagate to this object's DACL. This flag must be used with DACL_SECURITY_INFORMATION and cannot be used with UNPROTECTED_DACL_ SECURITY_INFORMATION.  </td></tr>
<tr>
<td valign="top">UNPROTECTED_SACL_SECURITY_INFORMATION    </td>
<td valign="top">Indicates that you want inherited ACEs in parent objects to propagate to this object's SACL. This flag must be used with SACL_SECURITY_INFORMATION and cannot be used with PROTECTED_SACL_SECURITY_INFORMATION.  </td></tr>
<tr>
<td valign="top">PROTECTED_SACL_SECURITY_INFORMATION  </td>
<td valign="top">Indicates that you do not want inherited ACEs  in parent objects to propagate to this object's SACL. This flag must be used with SACL_SECURITY_INFORMATION and cannot be used with UNPROTECTED_SACL_SECURITY_INFORMATION.  </td></tr>
</table></p>


<p>Depending on which flags you pass as the <i>secInfo</i> parameter when calling <i>SetSecurityInfo</i> or <i>SetNamedSecurityInfo</i>, the values you pass for the <i>psidOwner</i>, <i>psidGroup</i>, <i>pDACL</i>, and <i>pSACL</i> parameters are ignored or indicate the object's new owner SID, group SID, DACL, and SACL, respectively.</p>

<p>You should pass NULL for any parameters to indicate portions of the security descriptor for which you are not setting information.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
It can be appropriate to indicate DACL_SECURITY_INFORMATION or SACL_SECURITY_INFORMATION in the <i>secInfo</i> parameter and still pass NULL for the <i>pDACL</i> or <i>pSACL</i> parameter. This indicates a NULL DACL or a NULL SACL.</blockquote>
</div>
</p>

<p>The following code fragment shows the use of <i>SetNamedSecurityInfo</i> to assign a NULL DACL to a registry key and protect its DACL from inherited ACEs found in parent keys' DACLs.</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
ULONG lErr = SetNamedSecurityInfo(
   TEXT(&quot;Machine\\Software\\Jason'sKey&quot;), SE_REGISTRY_KEY, 
   DACL_SECURITY_INFORMATION|PROTECTED_DACL_SECURITY_INFORMATION, 
   NULL, NULL, NULL, NULL);
   if (lErr != ERROR_SUCCESS){
      // Error case
   }
</pre></td></tr></table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Remember that a NULL DACL indicates that everyone has all access to the object (even the ability to write the security of the object). In the rare cases where it is appropriate to set NULL security to an object, you must protect the object's DACL (or lack of DACL) from inherited ACEs. Otherwise, the system is forced to create a DACL that will include the ACEs inherited from parent objects, which immediately undermines your goal of NULL security for the object. On the other hand, this side effect of inherited security can be a convenient way to set an object's DACL to include no ACEs except those inherited from parent objects.</blockquote>
</div>
</p>

<p>As you can see, setting an object's security can be simple. However, it can become significantly more difficult when including a DACL with meaningful ACEs. Whether you are setting the security of a new object (one you create) or an object that already exists, you can take two basic approaches to create the DACL for the object: create a new DACL for the object, or modify an existing DACL.</p>

<p>You will typically create a DACL for new objects, but not always. You can also use an existing DACL from an object and make modifications to it, and then use the modified DACL to create a new object of the same type as the original securable object.</p>

<p>Similarly for existing objects, it is very common to make modifications to the existing DACL and far less common to completely overwrite the security. However, this does not mean that you cannot completely replace the DACL of an existing object.</p>

<p>Because you can be flexible about the approaches depending on your needs, I will cover both, starting with the simpler task of creating a brand new DACL.</p>

<A NAME="219"><h3>Creating a DACL</h3></A>
<p>You will typically follow these steps when creating a DACL:</p>

<ol>
<p><li>Gather the SIDs for the trustees for which you will be creating ACEs for the DACL.</li></p>

<p><li>Calculate the size of the new DACL by using the size of the SIDs and the size of the ACE structure that you are using.</li></p>

<p><li>Allocate memory for the DACL.</li></p>

<p><li>Initialize the DACL.</li></p>

<p><li>Use the SIDs to add ACEs to the DACL, taking care to add your access-denied ACEs before adding your access-allowed ACEs.</li></p>
</ol>

<p>For existing objects, you will use one of the &quot;SetSecurity&quot; functions to apply the new DACL to the objects. For most new objects, you are required to also create and initialize a security descriptor and a security attributes structure to pass when calling a create function such as <i>CreateEvent</i> or <i>CreateFile</i>. I will show you how to do this in a moment.</p>

<p>The most complicated part of creating a DACL is calculating its size. The <i>CalculateACLSize</i> sample function shows how to do this. To use this function, you pass an array of pointers to SIDs, which are used to calculate the necessary size of the new DACL. I also included an optional pointer to an existing DACL, which, if NULL, is ignored, and if not NULL, adds the size of the ACEs in the existing DACL and gives you the size of a new DACL created from an existing DACL. More on this in a moment, but for now, see the <i>CalculateACLSize</i> function here.</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
ULONG CalculateACLSize( PACL pACLOld, PSID* ppSidArray, int nNumSids, 
   PACE_UNION* ppACEs, int nNumACEs ){
   ULONG lACLSize = 0;
   
   try{
      // If we are including an existing ACL, then find its size
      if (pACLOld != NULL){
         ACL_SIZE_INFORMATION aclSize;
         if(!GetAclInformation(pACLOld, &amp;aclSize, sizeof(aclSize), 
            AclSizeInformation)){            
            goto leave;
         }
         lACLSize = aclSize.AclBytesInUse;
      }

      if (ppSidArray != NULL){
         // Step through each SID
         while (nNumSids--){
            // If a SID isn't valid, then we bail
            if (!IsValidSid(ppSidArray[nNumSids])){
               lACLSize = 0;
               goto leave;
            }
            // Get the SID's length
            lACLSize += GetLengthSid(ppSidArray[nNumSids]);
            // Add the ACE structure size, minus the 
            // size of the SidStart member
            lACLSize += sizeof(ACCESS_ALLOWED_ACE) - 
               sizeof(((ACCESS_ALLOWED_ACE*)0)-&gt;SidStart);         
         }      
      }

      if (ppACEs != NULL){
         // Step through each ACE
         while (nNumACEs--){            
            // Get the SIDs length
            lACLSize += ppACEs[nNumACEs]-&gt;aceHeader.AceSize;
         }      
      }         
      // Add in the ACL structure itself
      lACLSize += sizeof(ACL);

   leave:;
   }catch(...){
      // An exception means we fail the function
      lACLSize = 0;      
   }
   return (lACLSize);
}
</pre></td></tr></table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
The <i>CalculateACLSize</i> function uses the size of the ACCESS_ ALLOWED_ACE structure, which will work for all standard ACE types. This function will not calculate an ACL size properly if it includes object ACE types. To properly calculate the size, replace the reference to ACCESS_ALLOWED_ACE in this function with an object ACE structure such as ACCESS_ALLOWED_OBJECT_ACE. For a discussion on object ACEs, see the section earlier in this chapter titled &quot;<a href="ch10c.htm#215A">Object ACEs.</a>&quot;</blockquote>
</div>
</p>

<p>When you use a function such as <i>CalculateACLSize</i>, finding the amount of memory necessary to create a new ACL is a simple task. You should use the value returned from the function to allocate memory using an allocator such as <i>new</i>, <i>HeapAlloc</i>, or <i>malloc</i>.</p>

<p>After you have memory for your new ACL, you should initialize the ACL using <i>InitializeAcl</i>:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL InitializeAcl(
   PACL  pACL,
   DWORD dwAclLength,
   DWORD dwAclRevision);
</pre></td></tr></table>
</p>

<p><i>InitializeAcl</i> is a very simple function that sets the length of the buffer in the structure of the ACL and the ACL's revision. You should pass ACL_REVISION for the <i>dwAclRevision</i> parameter. An ACL can also have the revision of ACL_REVISION_DS, which indicates that the ACL contains object ACEs. However, you do not need to explicitly set this revision, because when you add object ACEs to an ACL, the system updates the revision of the ACL.</p> 

<p>After calling <i>InitializeAcl</i>, your memory buffer contains an empty ACL containing no ACEs. If you wish to remove all ACEs from an existing ACL, you can also use <i>InitializeAcl</i> to do this.</p>

<p> Now you are ready to begin adding ACEs to your empty ACL. Assuming you have properly calculated the size of your finished ACL, adding ACEs should be as simple as making repeated calls to <i>AddAccessDeniedAceEx</i> for all your access-denied ACEs, followed by calls to <i>AddAccessAllowedAceEx</i> for all of your access-allowed ACEs.</p>

<p><i>AddAccessDeniedAceEx</i> and <i>AddAccessAllowedAceEx</i> build ACEs of the appropriate type and add them to the end of a DACL (assuming that there is room in the DACL to accompany the ACE). <i>AddAccessDeniedAceEx</i> is defined as follows:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL AddAccessDeniedAceEx(
   PACL  pDACL,
   DWORD dwACERevision,
   DWORD dwACEFlags,
   DWORD dwAccessMask,
   PSID  psidTrustee);
</pre></td></tr></table>
</p>

<p>Here is <i>AddAccessAllowedAceEx</i>:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL AddAccessAllowedAceEx(
   PACL  pDACL,
   DWORD dwACERevision,
   DWORD dwACEFlags,
   DWORD dwAccessMask,
   PSID  psidTrustee);
</pre></td></tr></table>
</p>

<p>The declarations for these functions are identical, which is nice. The <i>pDACL</i> parameter indicates the DACL to which you are adding an ACE. The <i>dwACERevision</i> parameter should be set to ACL_REVISION. The <i>dwACEFlags</i> parameter indicates the value that will be set in the <i>AceFlags</i> member of the new ACE's ACE_HEADER. This is used to indicate the ACE's inheritance properties. See Table 10-11 for an explanation of the different ACE flags. You should not pass the flags indicating audit type for the <i>dwACEFlags</i> parameter.</p>

<p> The <i>dwAccessMask</i> parameter indicates the access mask of the new ACE, which describes which rights you are denying or allowing to the trustee. And finally, you should pass a pointer to a SID structure for the <i>psidTrustee</i> parameter to indicate the trustee for which access is being denied or allowed.</p>

<p> If there is insufficient room in the DACL, the <i>AddAccessDeniedAceEx</i> and <i>AddAccessAllowedAceEx</i> functions return FALSE, and <i>
GetLastError</i> returns ERROR_ALLOTTED_SPACE_EXCEEDED.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
For objects that do not support inheritance, you can use the simpler non-&quot;Ex&quot; versions of <i>AddAccessDeniedAce</i> and <i>AddAccessAllowedAce</i>. The only difference with the non-&quot;Ex&quot; functions is that they do not allow you to set the flags for the new ACE.</blockquote>
</div>
</p>

<p>When you understand <i>AddAccessDeniedAceEx</i> and <i>AddAccessAllowedAceEx</i>, you can see that calling them repeatedly to create a new DACL is no big deal. After you create the new DACL, you can pass it to <i>SetSecurityInfo</i> or <i>SetNamedSecurityInfo</i> to apply it to an existing object. (Don't forget to free the memory for your new DACL after you have called one of these functions.)</p>

<p>You usually create a new DACL for an object that you are about to create. Creating an object typically requires you to assign the new DACL to a security descriptor, and then assign the security descriptor to a security attributes structure before calling the &quot;create&quot; function. The following code shows how to create a new DACL for a new event object. The code creates and initializes a security descriptor with a DACL, and then uses it to create a named event. (Note that this code uses the previous <i>CalculateACLSize</i> function to calculate the size of the new DACL.) The two challenges in this process are calculating the DACL's size and adding your ACEs in the proper order.</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
PSID psidEveryone ;

// Create a SID for the built-in &quot;Everyone&quot; group
SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_WORLD_SID_AUTHORITY;
if (!AllocateAndInitializeSid( &amp;sidAuth, 1, SECURITY_WORLD_RID, 
   0, 0, 0, 0, 0, 0, 0, &amp;psidEveryone )){
   // Error
}

// We are creating two ACEs, both using the &quot;Everyone&quot; group
PSID psidArray[2];
psidArray[0] = psidEveryone;
psidArray[1] = psidEveryone;

// Get the size of the new ACL
ULONG lACLSize = CalculateACLSize( NULL, psidArray, 2, NULL, 0);
if (lACLSize == 0){
   // Error
}

// Allocate memory for the ACL
PACL pDACL = (PACL)HeapAlloc(GetProcessHeap(), 0, lACLSize);
if (pDACL == NULL){
   // Error
}

// Initialize the ACL
if (!InitializeAcl(pDACL, lACLSize, ACL_REVISION)){
   // Error
}

// Make sure to add our denied ACE first
if (!AddAccessDeniedAce(pDACL, ACL_REVISION, 
   WRITE_OWNER|WRITE_DAC, psidArray[0])){
   // Error
}

// Then add our allowed ACE
if (!AddAccessAllowedAce(pDACL, ACL_REVISION, 
   STANDARD_RIGHTS_ALL|SPECIFIC_RIGHTS_ALL, psidArray[1])){
   GetLastError();//Error &quot;winerror.h&quot;
}

// Allocate space for a security descriptor
PSECURITY_DESCRIPTOR pSD = HeapAlloc(GetProcessHeap(), 0, 
   SECURITY_DESCRIPTOR_MIN_LENGTH);
if (pSD == NULL){
   // Error
}
// We now have an empty security descriptor
if (!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION)){
   // Error
}
// To which we assign our DACL
if (!SetSecurityDescriptorDacl(pSD, TRUE, pDACL, FALSE)){
   // Error
}

// Then we point to our SD from a SECURITY_ATTRIBUTES structure
SECURITY_ATTRIBUTES sa = {0};
sa.nLength = sizeof(sa);
sa.lpSecurityDescriptor = pSD;

// Which we pass to CreateEvent
HANDLE hEvent = CreateEvent(&amp;sa, TRUE, FALSE, TEXT(&quot;SecureEvent&quot;));

// Clean up 
HeapFree(GetProcessHeap(), 0, pSD);
HeapFree(GetProcessHeap(), 0, pDACL);
FreeSid(psidEveryone);
</pre></td></tr></table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
An alternative to adding the ACEs in the proper order would be to write a function to order the ACL for you so that you could add ACEs without concern for order. You would then order the entire ACL before applying the ACL to an object. I implement such a function later in this chapter.</blockquote>
</div>
</p>

<p>This sample not only shows how to build a DACL and security descriptor for use in object creation, but it also illustrates an important technique for sharing objects with services.</p>

<p> The default security for a service in the LocalSystem user context will cause objects such as named events and named pipes to be secured against use by processes running in the security context of a logged-on user. But sometimes this is not the desired behavior. At times you might be tempted to create an object with a NULL DACL, which allows everyone all access to the object, but doing so creates a security hole. All access includes the ability to adjust the object's security, and would allow anyone to change the security of the object. Having the security changed would almost definitely cause the object to stop working as expected.</p>

<p> A better solution to controlling access is to deny everyone access to the security of the object (which allows only the owner of the object to modify the object's security). After adding the
denied ACE, you can comfortably allow any trustees access to the object, knowing that the deny ACE will take precedence. In this case, I allow everyone all access.</p>

<A NAME="220"><h3>Modifying a DACL</h3></A>
<p>Creating secure objects involves as much access control as many services ever need to implement. It is surprising how many services you can implement without ever having to modify the security of an existing object. Of course, some programs have to deal with existing objects that already have security applied to them. In such a case, your software must be able to read and modify a DACL for an object. Here are the steps you might take to do this:</p>

<ol>
<p><li>Retrieve the DACL of the object that you wish to modify.</li></p>

<p><li>If you are removing ACEs, search the DACL for these ACEs and delete them.</li></p>

<p><li>Gather the SIDs of the trustees for which you will be adding ACEs.</li></p>

<p><li>Create the ACEs that you will be adding.</li></p>

<p><li>Search the DACL for ACEs that are the same as ACEs you will be adding. If any exist, remove them from the group of ACEs you will be adding.</li></p>

<p><li>Calculate the new DACL size.</li></p>

<p><li>Allocate memory for and initialize the new DACL.</li></p>

<p><li>Copy the old DACL to the new DACL.</li></p>

<p><li>Insert new ACEs in the proper position in the new DACL.</li></p>

<p><li>Assign the DACL back to the object.</li></p>
</ol>

<p>As you can see, the process for reading and modifying an object's DACL is not so simple, but I should tell you that I've offered the worst-case scenario. Often you are not removing ACEs at all, so step 2 can be ignored. And commonly you add only a single ACE; if that ACE is already in the DACL, you can abort the whole procedure, simplifying step 5.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
It is important to search ACLs for ACEs that already exist, even though duplicate ACEs do not affect the <i>security</i> of an object. The reason is that ACEs take memory in the system, and some system objects (such as a window station) can hold surprisingly few ACEs. Any software that adds an ACE every time it is run, without checking the necessity of the task, will eventually exhaust system resources.</blockquote>
</div>
</p>

<p>Now I will tell you about the tools required to tackle the task of reading and modifying a DACL. Let's start with a simple function. (You already know how to read information in a DACL, and those skills will come into play here.)</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL DeleteAce(
   PACL  pACL,
   DWORD dwACEIndex);
</pre></td></tr></table>
</p>

<p>The <i>DeleteAce</i> function removes an ACE from a DACL. You must pass it the ACL and the index of the ACE that you wish to remove.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
If the only modification that you are making to an object is to remove ACEs, you do not have to allocate memory for a new DACL. You can simply remove the ACEs in the DACL returned by <i>GetSecurityInfo</i>, and then set the modified DACL back to the object.</blockquote>
</div>
</p>

<p>The next steps in the process require that you have an ACE handy because you will use the <i>AddAce</i> function (discussed shortly), which requires an ACE that is already built. Also, because you might search the ACL for the existence of the ACE, it is convenient to have an ACE structure with which to compare ACEs in the DACL.</p>

<p>Unfortunately the system does not provide a function that helps you build ACEs in a simple manner. The task of building ACEs is complicated because each ACE includes a SID structure, and SID structures are variable in length. It is best to use your SID's length and the length of the ACE structure to allocate a buffer for the ACE, copy the SID into the ACE, and then set the ACE fields. The following function shows how to do this:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
PACE_UNION AllocateACE( ULONG bACEType, ULONG bACEFlags, 
   ULONG lAccessMask, PSID pSID ){
   PACE_UNION pReturnACE = NULL;
   PBYTE pbBuffer = NULL;
   try{
      // Get the offset of the SID in the ACE
      ULONG lSIDOffset = (ULONG)(&amp;((ACCESS_ALLOWED_ACE*)0)-&gt;SidStart);
      // Get the size of the ACE without the SID
      ULONG lACEStructSize = sizeof(ACCESS_ALLOWED_ACE) - 
         sizeof(((ACCESS_ALLOWED_ACE*)0)-&gt;SidStart);
      // Get the length of the SID
      ULONG lSIDSize = GetLengthSid(pSID);      

      // Allocate a buffer for the ACE
      pbBuffer = (PBYTE)LocalAlloc(LPTR, lACEStructSize + lSIDSize);
      if (pbBuffer == NULL)
         goto leave;

      // Copy the SID into the ACE
      if(!CopySid(lSIDSize, (PSID)(pbBuffer+lSIDOffset), pSID)){
         goto leave;
      }      
      pReturnACE = (PACE_UNION) pbBuffer;
      pReturnACE-&gt;aceHeader.AceSize = (USHORT)(lACEStructSize + lSIDSize);
      pReturnACE-&gt;aceHeader.AceType = (BYTE)bACEType;
      pReturnACE-&gt;aceHeader.AceFlags = (BYTE)bACEFlags;
      pReturnACE-&gt;aceAllowed.Mask = lAccessMask;
   leave:;
   }catch(...){}
   // Free the buffer in an error case
   if (pbBuffer != (PBYTE)pReturnACE){
      LocalFree(pbBuffer);
   }
   return (pReturnACE);    
}
</pre></td></tr></table>
</p>

<p>When using <i>AllocateAce</i>, you simply pass the returned ACE to <i>LocalFree</i> when finished with it.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
 <i>AllocateAce</i> returns a PACE_UNION pointer, which is a type I defined earlier in this chapter. I chose to use this technique to represent ACEs in a generic way. It is also very common to simply choose one of the specific ACE types, such as ACCESS_ALLOWED_ACE, to use generically for your ACE manipulation. Either approach works; however, for a number of the sample functions in this chapter, I use the PACE_UNION.</blockquote>
</div>
</p>

<p>Now that you have an ACE built, you must search your object's existing DACL for ACEs that match. You can do this by using the ACL reading techniques discussed earlier in this chapter. I wrote code to perform this task using two functions: one to compare ACEs and one to search an ACL for a matching ACE.</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL IsEqualACE( PACE_UNION pACE1, PACE_UNION pACE2 ){
   BOOL fReturn = FALSE;
   
   try{{
      if(pACE1-&gt;aceHeader.AceType != pACE2-&gt;aceHeader.AceType)
         goto leave;

      // Get the offset of the SID in the ACE
      ULONG lSIDOffset = (ULONG)(&amp;((ACCESS_ALLOWED_ACE*)0)-&gt;SidStart);
      // Get the size of the ACE without the SID
      ULONG lACEStructSize = sizeof(ACCESS_ALLOWED_ACE) - 
         sizeof(((ACCESS_ALLOWED_ACE*)0)-&gt;SidStart);

      PBYTE pbACE1 = (PBYTE)pACE1;
      PBYTE pbACE2 = (PBYTE)pACE2;
      fReturn = TRUE;
      while(lACEStructSize--)
         fReturn = (fReturn &amp;&amp; ((pbACE1[lACEStructSize] ==
            pbACE2[lACEStructSize])));
      // Check SIDs
      fReturn = fReturn &amp;&amp; EqualSid((PSID)(pbACE1+lSIDOffset),
         (PSID)(pbACE2+lSIDOffset));      
   }leave:;
   }catch(...){
   }

   return (fReturn);
}
</pre></td></tr></table>
</p>

<p>Here is the second function:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
int FindACEInACL( PACL pACL, PACE_UNION pACE ){
   int nACEIndex = -1;

   try{{
      ACL_SIZE_INFORMATION aclSize;
      if (!GetAclInformation(pACL, &amp;aclSize, sizeof(aclSize), 
         AclSizeInformation)){
         goto leave;
      }

      while (aclSize.AceCount--){
         PACE_UNION pACETemp;
         if(!GetAce(pACL, aclSize.AceCount, (PVOID *)&amp;pACETemp))
            goto leave;

         if(IsEqualACE(pACETemp, pACE)){
            nACEIndex = (int)aclSize.AceCount;
            break;
         }
      }
   }leave:;
   }catch(...){
   }
   return (nACEIndex);
}
</pre></td></tr></table>
</p>

<p>The <i>FindAceInACL</i> function returns the index of a matching ACE in the DACL, or -1 if no match is found. You should use this function or one like it to find out whether the ACEs you intend to add to your object's DACL already exist in the DACL. (The <i>FindACEInACL</i> function can also be useful for finding ACEs that you wish to delete using <i>DeleteAce</i>).</p>

<p> Now that you know which ACEs you must add your DACL and you have built the ACEs, it is time to calculate the size of your new DACL. You can use the <i>CalculateACLSize</i> function, shown earlier in this chapter. It allows you to calculate an ACL size using an existing ACL, an array of SIDs, and an array of ACEs. You can pass NULL for any of these parameters. In our example, you are likely to pass an existing ACL and an array of ACEs to calculate the new size of the ACL after your ACEs have been added.</p>

<p> After you allocate memory for your new ACL, you initialize the new ACL using <i>InitializeAcl</i> (discussed earlier in this chapter). You
have to copy the ACEs from your old ACL to your new ACL. The following function shows how to do this:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL CopyACL( PACL pACLDestination, PACL pACLSource ){
   BOOL fReturn = FALSE;
   try{{
      // Get the number of ACEs in the source ACL
      ACL_SIZE_INFORMATION aclSize;
      if (!GetAclInformation(pACLSource, &amp;aclSize, 
         sizeof(aclSize), AclSizeInformation)){
         goto leave;
      }

      // Use GetAce and AddAce to copy the ACEs
      for(ULONG lIndex=0;lIndex &lt; aclSize.AceCount;lIndex++){
         ACE_HEADER* pACE;
         if(!GetAce(pACLSource, lIndex, (PVOID*)&amp;pACE))
            goto leave;
         if(!AddAce(pACLDestination, ACL_REVISION, MAXDWORD, 
            (PVOID*)pACE, pACE-&gt;AceSize))
            goto leave;
      }      
      fReturn = TRUE;
   }leave:;
   }catch(...){
   }
   return (fReturn);
}
</pre></td></tr></table>
</p>

<p>This <i>CopyACL</i> function is fairly simple. It simply iterates through the ACEs in the existing DACL and copies each one to the new DACL. C<i>opyACL</i> uses the <i>AddAce</i> system function, which is defined as follows:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL AddAce(
   PACL  pACL,
   DWORD dwACERevision,
   DWORD dwStartingACEIndex,
   PVOID pACEList, 
   DWORD dwACEListLength);
</pre></td></tr></table>
</p>

<p>Notice that <i>AddAce</i> is different from <i>AddAccessAllowedAce</i> and <i>AddAccessDeniedAce</i>. First you have to supply the ACE; the system does not compile the ACE into the DACL for you. This means that you define the type of ACE as well, so <i>AddAce</i> can add any type of ACE to the DACL. Second, <i>AddAce</i> allows you to decide where in the DACL you wish to insert the new ACE by using an index starting with zero. Third, <i>AddAce</i> allows you to add more than one ACE by passing a sequential list of ACEs as the <i>pACEList</i> parameter and the size of the list as the <i>dwACEListLength</i> parameter (not to be confused with the number of ACEs in the list).</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
The <i>CopyACL</i> sample function could have been implemented more efficiently by allowing <i>AddAce</i> to copy all of the source ACEs over in a single function call. However, doing this assumes information about the ACL structure, which you should treat as opaque.</blockquote>
</div>
</p>

<p>After you copy your old DACL into your new, more spacious DACL, you can begin adding ACEs to it using <i>AddAce</i>. Take care to insert your ACEs in the proper index for your new DACL so that proper ACE ordering is preserved. (See Table 10-6 regarding ACE order.) You can use the following function to determine the appropriate index for a new ACE in an ACL:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
ULONG GetACEInsertionIndex( PACL pDACL, PACE_UNION pACENew){
   ULONG lIndex = (ULONG) -1;

   try{{
      // ACE types by ACL order
      ULONG lFilterType[] = { ACCESS_DENIED_ACE_TYPE, 
                              ACCESS_DENIED_OBJECT_ACE_TYPE, 
                              ACCESS_ALLOWED_ACE_TYPE, 
                              ACCESS_ALLOWED_OBJECT_ACE_TYPE};

      // Determine which group the new ACE should belong to
      ULONG lNewAceGroup;
      for(lNewAceGroup = 0; lNewAceGroup&lt;4 ; lNewAceGroup++){
         if(pACENew-&gt;aceHeader.AceType == lFilterType[lNewAceGroup])
            break;
      }
      // If group == 4, the ACE type is no good
      if(lNewAceGroup==4)
         goto leave;
      // If new ACE is an inherited ACE, then it goes after other ACEs
      if((pACENew-&gt;aceHeader.AceFlags &amp; INHERITED_ACE) != 0)
         lNewAceGroup+=4;

      // Get ACE count
      ACL_SIZE_INFORMATION aclSize;
      if (!GetAclInformation(pDACL, &amp;aclSize, 
         sizeof(aclSize), AclSizeInformation)){
         goto leave;
      }      

      // Iterate through ACEs
      lIndex = 0;
      for(lIndex = 0;lIndex &lt; aclSize.AceCount;lIndex++){
         ACE_HEADER* pACE;
         if(!GetAce(pDACL, lIndex, (PVOID*)&amp;pACE))
            goto leave;

         // Get the group of the ACL ACE
         ULONG lAceGroup;
         for(lAceGroup = 0; lAceGroup&lt;4 ; lAceGroup++){
            if(pACE-&gt;AceType == lFilterType[lAceGroup])
               break;
         }
         // Test for bad ACE
         if(lAceGroup==4){
            lIndex = (ULONG) -1;
            goto leave;
         }
         // Inherited adjustment
         if((pACE-&gt;AceFlags &amp; INHERITED_ACE) != 0)
            lAceGroup+=4;

         // If this is the same group, then insertion point found
         if(lAceGroup&gt;=lNewAceGroup)
            break;
      }       

   }leave:;
   }catch(...){
   }   
   return (lIndex);
}
</pre></td></tr></table>
</p>

<p>The <i>GetACEInsertionIndex</i> function finds the index in which to insert your new ACE, and in the process considers object ACEs and ACE inheritance. After you know the proper index, you can call <i>AddAce</i> to add the new ACE into the ACL.</p>

<p> Do this for each new ACE, and then use the appropriate function to set the new DACL to the securable object. Don't forget to clean up after yourself and free any memory that you have allocated.</p>

<p> Earlier in this chapter, I promised to include a sample function that orders the ACEs in a DACL. This function might be useful if you don't want to concern yourself with ACE ordering at all until after you completely finish adding ACEs to your DACL. The following <i>OrderDACL</i> function is fairly simple, and it builds on the <i>GetACEInsertionIndex</i> sample function:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL OrderDACL( PACL pDACL ){
   BOOL fReturn = FALSE;

   try{{
      // Get ACL size and ACE count
      ACL_SIZE_INFORMATION aclSize;
      if (!GetAclInformation(pDACL, &amp;aclSize, 
         sizeof(aclSize), AclSizeInformation)){
         goto leave;
      }
      // Get memory for temporary ACL
      PACL pTempDACL = (PACL) _alloca(aclSize.AclBytesInUse);
      if (pTempDACL==NULL)
         goto leave;
      // Initialize temporary ACL
      if (!InitializeAcl(pTempDACL, aclSize.AclBytesInUse, 
         ACL_REVISION))
         goto leave;
      
      // Iterate through ACEs
      for (ULONG lAceIndex = 0; 
         lAceIndex &lt; aclSize.AceCount ; lAceIndex++){
         // Get ACE
         PACE_UNION pACE;
         if (!GetAce(pDACL, lAceIndex, (PVOID*)&amp;pACE))
            goto leave;
         // Find location, and add ACE to temp DACL
         ULONG lWhere = GetACEInsertionIndex(pTempDACL, pACE);
         if (!AddAce(pTempDACL, ACL_REVISION, 
            lWhere, pACE, pACE-&gt;AceSize))
            goto leave;
      }
      // Copy temp DACL to original
      CopyMemory(pDACL, pTempDACL, aclSize.AclBytesInUse);
      fReturn = TRUE;
   }
   leave:;
   }catch(...){
   }
   return (fReturn);
}
</pre></td></tr></table>
</p>

<p>Let's take a look at a real-world example that implements the techniques we have been discussing.</p>

<A NAME="221"><h3>Modifying a DACL Example</h3></A>
<p>Our example shows how to modify an existing DACL while providing a useful set of functions for the service developer. I used the window station and the desktop-securable objects in Windows.</p>

<p> A <i>window station</i> is a secure object in Windows that contains a clipboard, a set of global atoms, and a collection of desktop objects. A window station can be interactive, meaning its &quot;desktops&quot; can be seen by a user. An interactive window station also maintains keyboard and mouse information. A process can have a single window station associated with it.</p>

<p> A <i>desktop</i> is a secure object contained within a window station. A desktop maintains a logical display surface and contains menus, windows, and other objects visible on screen.</p>

<p> Services that do not interact with the user are not associated with the interactive desktop. When a user logs on to a system, the DACL for the interactive window station (named WinSta0) and its default desktop (named Default) are reset, and the user is given access to the
objects. Ultimately, only the logged-on user and the system are granted access to the objects.</p>

<p><b>Problem description</b> Sometimes a service has to create another process under an arbitrary trustee account (using <i>CreateProcessAsUser</i> discussed in the <a href="ch11a.htm">next chapter</a>) to create a process under a user context that is not currently interacting with the system. If this process needs to interact with a user, and the user account does not have access to the interactive window station and its default desktop, the system fails the call to <i>CreateProcessAsUser</i>.</p>

<p>Herein lies the problem. Before creating the process, you have to check the DACLs of these objects for sufficient access rights for the user. If these rights aren't found, they must be added. It is important to check for the rights first, because adding an ACE blindly to the user objects can eventually exhaust resources in the system. (Typically you can add only about 80 ACEs to a window station.)</p>

<p><b>Solution</b> Now let's tackle the solution. I used the tools and concepts (and some of the sample functions) discussed throughout this section to implement two functions: one that allows a trustee access to a window station and one that allows a trustee access to a desktop. These functions are pretty straightforward. Although the process of modifying an object's DACL can seem somewhat daunting, in the real world the process tends to be less complex than we imagine. The following code allows a trustee access to a window station:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL AllowAccessToWinSta( PSID psidTrustee, HWINSTA hWinSta ){
   BOOL fReturn = FALSE;     
   PSECURITY_DESCRIPTOR psdWinSta = NULL;
   PACE_UNION pACENew = NULL;

   try{{    
      // Get the DACL for the window station
      PACL pDACLWinSta;
      if(GetSecurityInfo(hWinSta, SE_WINDOW_OBJECT, 
         DACL_SECURITY_INFORMATION, NULL, NULL, &amp;pDACLWinSta, 
         NULL, &amp;psdWinSta) != ERROR_SUCCESS)
         goto leave;
      
      // Allocate our new ACE
      // This is the access awarded to a user who logged on interactively
      PACE_UNION pACENew = AllocateACE(ACCESS_ALLOWED_ACE_TYPE, 0, 
         DELETE|WRITE_OWNER|WRITE_DAC|READ_CONTROL|
         WINSTA_ENUMDESKTOPS|WINSTA_READATTRIBUTES|
         WINSTA_ACCESSCLIPBOARD|WINSTA_CREATEDESKTOP|
         WINSTA_WRITEATTRIBUTES|WINSTA_ACCESSGLOBALATOMS|
         WINSTA_EXITWINDOWS|WINSTA_ENUMERATE|WINSTA_READSCREEN, 
         psidTrustee);      
      
      // Is the ACE already in the DACL?
      if (FindACEInACL(pDACLWinSta, pACENew) == -1){
         // If not, calculate new DACL size
         ULONG lNewACL = CalculateACLSize( pDACLWinSta, NULL, 0, 
            &amp;pACENew, 1 );

         // Allocate memory for the new DACL
         PACL pNewDACL = (PACL)_alloca(lNewACL);
         if (pNewDACL == NULL)
            goto leave;

         // Initialize the ACL
         if (!InitializeAcl(pNewDACL, lNewACL, ACL_REVISION))
            goto leave;

         // Copy the ACL
         if (!CopyACL(pNewDACL, pDACLWinSta))
            goto leave;

         // Get location for new ACE
         ULONG lIndex = GetACEInsertionIndex(pNewDACL, pACENew);

         // Add the new ACE
         if (!AddAce(pNewDACL, ACL_REVISION, lIndex, 
            pACENew, pACENew-&gt;aceHeader.AceSize))
            goto leave;

         // Set the DACL back to the window station
         if (SetSecurityInfo(hWinSta, SE_WINDOW_OBJECT, 
            DACL_SECURITY_INFORMATION, NULL, NULL, 
            pNewDACL, NULL)!=ERROR_SUCCESS)
            goto leave;
      }
      fReturn = TRUE;        
   }leave:;
   }catch(...){
   }
   // Clean up
   if(pACENew != NULL)
      LocalFree(pACENew);
   if(psdWinSta != NULL)
      LocalFree(psdWinSta);   
   return (fReturn);   
}
</pre></td></tr></table>
</p>

<p>The next sample function allows a trustee access to a desktop:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL AllowAccessToDesktop( PSID psidTrustee, HDESK hDesk ){
   BOOL fReturn = FALSE;     
   PSECURITY_DESCRIPTOR psdDesk = NULL;
   PACE_UNION pACENew = NULL;

   try{{    
      // Get the DACL for the desktop
      PACL pDACLDesk;
      if(GetSecurityInfo(hDesk, SE_WINDOW_OBJECT, 
         DACL_SECURITY_INFORMATION, NULL, NULL, &amp;pDACLDesk, 
         NULL, &amp;psdDesk) != ERROR_SUCCESS)
         goto leave;
      
      // Allocate our new ACE
      // This is the access awarded to a user who logged on interactively
      PACE_UNION pACENew = AllocateACE(ACCESS_ALLOWED_ACE_TYPE, 0, 
         DELETE|WRITE_OWNER|WRITE_DAC|READ_CONTROL|
         DESKTOP_READOBJECTS|DESKTOP_CREATEWINDOW|
         DESKTOP_CREATEMENU|DESKTOP_HOOKCONTROL|
         DESKTOP_JOURNALRECORD|DESKTOP_JOURNALPLAYBACK|
         DESKTOP_ENUMERATE|DESKTOP_WRITEOBJECTS|DESKTOP_SWITCHDESKTOP,
         psidTrustee);      
      
      // Is the ACE already in the DACL?
      if (FindACEInACL(pDACLDesk, pACENew) == -1){
         // If not, calculate new DACL size
         ULONG lNewACL = CalculateACLSize( pDACLDesk, NULL, 0, 
            &amp;pACENew, 1 );

         // Allocate memory for the new DACL
         PACL pNewDACL = (PACL)_alloca(lNewACL);
         if (pNewDACL == NULL)
            goto leave;

         // Initialize the ACL
         if (!InitializeAcl(pNewDACL, lNewACL, ACL_REVISION))
            goto leave;

         // Copy the ACL
         if (!CopyACL(pNewDACL, pDACLDesk))
            goto leave;

         // Get location for new ACE
         ULONG lIndex = GetACEInsertionIndex(pNewDACL, pACENew);

         // Add the new ACE
         if (!AddAce(pNewDACL, ACL_REVISION, lIndex, 
            pACENew, pACENew-&gt;aceHeader.AceSize))
            goto leave;

         // Set the DACL back to the window station
         if (SetSecurityInfo(hDesk, SE_WINDOW_OBJECT, 
            DACL_SECURITY_INFORMATION, NULL, NULL, 
            pNewDACL, NULL)!=ERROR_SUCCESS)
            goto leave;
      }
      fReturn = TRUE;        
   }leave:;
   }catch(...){
   }
   // Clean up
   if(pACENew != NULL)
      LocalFree(pACENew);
   if(psdDesk != NULL)
      LocalFree(psdDesk);   
   return (fReturn);   
}
</pre></td></tr></table>
</p>

<p>The following code fragment shows an example of how these functions are used. The code creates a SID for the built-in Everyone group and passes it to the <i>AllowAccessToWinSta</i> and <i>AllowAccessToDesktop</i> functions:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
PSID psidEveryone; 

// Create a SID for the built-in &quot;Everyone&quot; group
SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_WORLD_SID_AUTHORITY;
if (!AllocateAndInitializeSid( &amp;sidAuth, 1, SECURITY_WORLD_RID, 
   0, 0, 0, 0, 0, 0, 0, &amp;psidEveryone )){
   // Error
}

HWINSTA hWinSta = GetProcessWindowStation();
if (hWinSta == NULL){
   // Error
}
AllowAccessToWinSta(psidEveryone, hWinSta);

HDESK hDesk = GetThreadDesktop(GetCurrentThreadId());
if (hDesk == NULL){
   // Error
}
AllowAccessToDesktop(psidEveryone, hDesk);
</pre></td></tr></table>
</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Here's a tip. The <i>AllowAccessToWinSta</i> and <i>AllowAccessToDesktop</i> functions use a function called <i>_alloca</i> defined by the C run-time library in the header file Malloc.h. The <i>_alloca</i> function allocates a block of memory on the thread's stack. The beauty of this function is that it is very fast, requires no internal thread synchronization, and returns memory that does not need to be freed by your application. The system frees the memory when you exit the function in which it was called. 

<p>For a security programmer who must make repeated small allocations, a function like this one can be a lifesaver. It will speed up your code and help you avoid memory leaks.</p>
</blockquote>
</div>
</p>

<p>I strongly suggest that you take the time to walk through the <i>AllowAccessToWinSta</i> and <i>AllowAccessToDesktop</i> functions until you understand how they work and feel confident using the techniques that they use. These sample functions perform tasks that are about as complex as you will see in access control programming, and if you are comfortable with them, you probably won't have trouble implementing access control that meets your needs.</p>

<A NAME="222"><h2>Options for Implementing Access Control</h2></A>
<p>Microsoft and other parties have attempted to ease the burden on the access control programmer by creating higher-level functions that wrap the low-level functions we have been covering. Third-party vendors have also created solutions to ease this task of access control. Awareness of the low-level functionality of access control in Windows, as well as of some of the pitfalls of these higher-level functions, should enable you to make decisions that will address the needs of your code.</p>

<p> The implementers of the higher-level packages have been faced with these challenges:</p>


<ul>
<p><li>Simplifying the extremely flexible access control system, without restricting flexibility or the features you are likely to need in your project</li></p>

<p><li>Creating robust and usable code</li></p>
</ul>

 

<p>The first challenge&#8212;maintaining flexibility&#8212;is the most difficult to overcome. It is safe to say that the great majority of your access control needs can be implemented directly using Windows access control. However, with this flexibility comes complexity, and the moment you remove the complexity, you remove features that some other developer is undoubtedly expecting.</p>

<p> The second challenge might appear to be more achievable, but this has not proven to be the case. Microsoft has implemented a set of &quot;high-level&quot; security functions that have been added to the Win32 API. These functions drastically simplify certain aspects of security programming, but some have a history of bugs, and some have intrinsic flaws. Here is an example:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
DWORD GetEffectiveRightsFromAcl(
   PACL         pACL,
   PTRUSTEE     pTrustee,
   PACCESS_MASK pAccessRights);
</pre></td></tr></table>
</p>

<p>The <i>GetEffectiveRightsFromAcl</i> function is intended to search an ACL and return an access mask that indicates access allowed to a trustee by a DACL. Sounds very convenient! Such a function could potentially remove our need to search a DACL for ACEs before adding our own ACEs. <i>GetEffectiveRightsFromAcl</i>, however, attempts to do too much, and thus ends up doing almost nothing of use.</p>

<p> <i>GetEffectiveRightsFromAcl</i> figures out the access allowed based on a composite of the matching access-allowed ACEs, and then subtracts a composite of the matching access-denied ACEs. What this means is that <i>GetEffectiveRightsFromAcl</i> can return a set of access rights indicating that the ACL does not award the access I want for my trustee, and I'm left still not knowing how to fix the problem. Is the access not granted because of the absence of access-allowed ACEs, or is it not granted because of the presence of access-denied ACEs? I would hate to add an access-allowed ACE, just to find out that I
still don't have access because of an overriding access-denied ACE.</p>

<p> <i>GetEffectiveRightsFromAcl</i> not only searches for ACEs that match the trustee you supply, but also searches for any ACEs for group accounts of which your trustee is a member. But the function excludes built-in groups such as Everyone and Authenticated Users. And it fails if it finds ACEs for groups whose member trustees your code does not have rights to enumerate. Finally, there is no way to limit the search to finding only the access explicitly assigned to your trustee.</p>

<p> <i>GetEffectiveRightsFromAcl</i> was intended to enable your code to find out whether an access check on an object would succeed or fail for a trustee. However, access checks require a token, not a trustee SID. Tokens contain privileges; tokens can also be adjusted or restricted. (See <A HREF="ch11a.htm">Chapter 11</A>.) <i>GetEffectiveRightsFromAcl</i> does not take privileges into account when checking access. Access checks can succeed based on object ownership, but <i>
GetEffectiveRightsFromAcl</i> has no knowledge of object ownership. In these ways, <i>GetEffectiveRightsFromAcl</i> has limited use.</p>

<p> The more useful functions <i>SetEntriesInAcl</i> and <i>GetExplicitEntriesFromAcl</i> are intended to relieve you of the responsibility of allocating memory for ACEs and ACLs while still allowing you to deal with the ACL directly. The goal of these functions is great, but the functions have a sordid history of bugs and performance issues. Some of these problems have been cleared up, but if you choose to use these functions in your projects, it is important that you thoroughly test the code that uses them.</p>

<p> The <i>BuildExplicitAccessWithName</i> function, which should be used with <i>SetEntriesInAcl</i>, does not return a value. Instead it potentially defers an error scenario (that you would have caught when using low-level functions to call <i>LookupAccountName</i>) to the <i>SetEntriesInAcl</i> function. Because <i>SetEntriesInAcl</i> has no way of reporting back which entry
failed, you are left with a failure case from which it is difficult to recover.</p>

<p> You also have other options. The developers of the Active Template Library designed a C++ class called <i>CSecurityDescriptor</i> defined in the header file AtlCom.h. The bonus of <i>CSecurityDescriptor</i> is that the entire source code for the class is provided. Although this class provides a wealth of functionality, it comes with its own pitfalls. For example, the functions used to add ACEs do not follow the ACE ordering guidelines set forth for Windows 2000, although they do follow the guidelines for Windows NT 4.0. Additionally, the <i>AttachObject</i> function for retrieving the security from a kernel object uses <i>GetKernelObjectSecurity</i> instead of <i>GetSecurityInfo</i>, which is the suggested function for use with Windows 2000. (The class also suffers from an unlikely but potential race condition.)</p>

<p> As I mentioned, the great thing about the <i>CSecurityDescriptor</i> class is that you have the source code. If it
works for your needs, great! If it doesn't, you have the option of modifying the class. And if you find any bugs, you have the option of fixing them yourself using the knowledge you now have about low-level access control in Windows.</p>

<A NAME="223"><h2>Securing Private Objects</h2></A>
<p>I have mentioned several times that you can secure private objects created by your software by using Windows access control. This feature is a powerful one indeed, and it is particularly likely to be of use to service developers. The DACL building techniques you have learned so far apply to securing private objects as well as securing system objects, so there is little to learn about implementing access control on your own objects.</p>

<p> The tasks involved in securing your objects are shared between your software and the system. Your software must perform the following tasks to implement private security for objects:</p>


<ul>
<p><li>Your software must define specific rights for your objects (using the low 16 bits of the access mask).</li></p>

<p><li>Your software must decide which of the standard rights are relevant for your objects.</li></p>

<p><li>Your software must decide to which standard and specific rights the generic rights map.</li></p>

<p><li>Your software must associate security descriptors (created by the system) with objects.</li></p>

<p><li>Your software must store security descriptors with objects in persistent storage if appropriate for your objects.</li></p>

<p><li>Your software must perform access checks before performing securable actions on secured objects.</li></p>
</ul>

 

<p>The system provides the following features:</p>


<ul>
<p><li>Functions that create and destroy security descriptors for your objects</li></p>

<p><li>Functions that get and set specific parts of these security descriptors</li></p>

<p><li>A function that performs an access check in a manner consistent with other secured objects in Windows</li></p>
</ul>

 

<p>Before beginning our discussion of specific functions, I need to clarify two points:</p>


<ul>
<p><li>Private object security should be used for service software that is serving client software running in a different security context.</li></p>

<p><li>Private object security requires your software to use tokens to indicate client security context. Remember that tokens contain a trustee's SID as well as its group SIDs, privileges, and default DACL. (I will discuss the token in greater detail in <A HREF="ch11a.htm">Chapter 11</A>. You might find it helpful to refer to that chapter while continuing your reading in this chapter.)</li></p>
</ul>

 

<p>When creating an object that is to be secured privately, you should create the object's security descriptor. Call <i>CreatePrivateObjectSecurity</i> to do this:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL CreatePrivateObjectSecurity(
   PSECURITY_DESCRIPTOR psdParentDescriptor,
   PSECURITY_DESCRIPTOR psdCreatorDescriptor,
   PSECURITY_DESCRIPTOR *ppsdNewDescriptor,
   BOOL                 fIsDirectoryObject,
   HANDLE               hToken,
   PGENERIC_MAPPING     gmGenericMapping);
</pre></td></tr></table>
</p>

<p>The <i>CreatePrivateObjectSecurity</i> function takes an optional parent security descriptor, as well as an optional creator descriptor. Both parameters can be NULL. If neither are provided, <i>CreatePrivateObjectSecurity</i> creates a security descriptor by using the default DACL found in the provided token. The generic rights found in the default DACL are mapped to the object's specific and standard rights using the information found in the passed GENERIC_MAPPING structure. The <i>CreatePrivateObjectSecurity</i> function returns the new security descriptor by assigning its address to the PSECURITY_DESCRIPTOR variable, whose address you passed as the <i>ppsdNewDescriptor</i> parameter. This is a new security descriptor that you should now associate with your privately secured object. When you need to free the memory allocated by this function, you should pass the address of a variable that points to the security descriptor you want to free to <i>DestroyPrivateObjectSecurity</i>.</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL DestroyPrivateObjectSecurity(
   PSECURITY_DESCRIPTOR *ppsd<i>ObjectDescriptor</i>);
</pre></td></tr></table>
</p>

<p>The GENERIC_MAPPING structure that you initialize and pass to <i>CreatePrivateObjectSecurity</i> is defined as follows:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
typedef struct _GENERIC_MAPPING { 
   ACCESS_MASK GenericRead; 
   ACCESS_MASK GenericWrite; 
   ACCESS_MASK GenericExecute; 
   ACCESS_MASK GenericAll; 
} GENERIC_MAPPING;
</pre></td></tr></table>
</p>

<p>You can fill in this simple structure by setting each member to the appropriate combination of standard and specific rights for each generic right. The system uses this information when building the DACL from the token's default DACL.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
You should never directly modify the security descriptor returned from <i>CreatePrivateObjectSecurity</i>. Although the system provides functions for you to request specific security information from this descriptor, your software should treat the returned pointer as a black box, as if the security descriptor were stored in system memory.</blockquote>
</div>
</p>

<p>When the client attempts to act on a secure object in your software, you must first subject the client to an access check. To do this, you pass the rights required to perform the securable task, as well as the security descriptor and the client's token, to the <i>AccessCheck</i> function.</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL AccessCheck(
   PSECURITY_DESCRIPTOR pSecurityDescriptor, 
   HANDLE               hClientToken,
   DWORD                dwDesiredAccess,
   PGENERIC_MAPPING     gmGenericMapping,
   PPRIVILEGE_SET       pPrivilegeSet,
   PDWORD               pdwPrivilegeSetLength,
   PDWORD               pdwGrantedAccess,
   PBOOL                pfAccessStatus);
</pre></td></tr></table>
</p>

<p>You must also include an address of a GENERIC_MAPPING structure for the object, as well as the address of an array of PRIVILEGE_SET structures. The system uses the PRIVILEGE_SET structure to report the privileges that were used to grant the access. The system uses privileges to grant access in several cases, and you should provide a sufficiently large buffer to receive several returned privileges. The PRIVILEGE_SET structure is defined as follows:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
typedef struct _PRIVILEGE_SET { 
   DWORD               PrivilegeCount; 
   DWORD               Control; 
   LUID_AND_ATTRIBUTES Privilege[ANYSIZE_ARRAY]; 
} PRIVILEGE_SET;
</pre></td></tr></table>
</p>

<p>The ANYSIZE_ARRAY value is defined as 1, and you should create a buffer large enough to receive the relevant privileges. You can also call <i>AccessCheck</i> once to receive the required size of the privilege buffer, and then allocate a buffer of sufficient length.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Privileges can be used to grant access when your client requests WRITE_OWNER, READ_CONTROL, WRITE_DAC, or ACCESS_SYSTEM_SECURITY access for an object. If these access rights are not explicitly assigned to your client's trustee accounts, the system checks the client's token for privileges that override the security of the object. An example of such a privilege is SE_TAKE_OWNERSHIP_NAME, which allows the client to set the ownership of any object in the system.</blockquote>
</div>
</p>

<p>The access mask that your client was granted is returned via the <i>pdwGrantedAccess</i> parameter, and a Boolean value is returned via the <i>pfAccessStatus</i> parameter indicating whether the <i>AccessCheck</i> function succeeded.</p>

<p>The <i>AccessCheck</i> function is the centerpiece when implementing private object security. If your software is secure, and it religiously calls <i>AccessCheck</i> before performing a secure task on an object, Windows takes care of remaining details of deciding when your software's clients are allowed access.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
You can also create audit events with private security objects by using the <i>AccessCheckAndAuditAlarm</i> function. Auditing will be covered later in this chapter.</blockquote>
</div>
</p>

<p>At this point, you know how to create and destroy private security, and you also know how and when to call <i>AccessCheck</i>. The only remaining piece of the private object puzzle is how to modify the components of a security descriptor.</p>

<p>To modify the security of a private object, you should first get the component of the security descriptor that you wish to adjust. Typically this is the DACL, but it could be the object's owner or SACL. Use <i>GetPrivateObjectSecurity</i> to do this.</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL GetPrivateObjectSecurity(
   PSECURITY_DESCRIPTOR psdObjectDescriptor,
   SECURITY_INFORMATION secInfo,
   PSECURITY_DESCRIPTOR psdResultantDescriptor,
   DWORD                dwDescriptorLength,
   PDWORD               pdwReturnLength);
</pre></td></tr></table>
</p>

<p>The <i>GetPrivateObjectSecurity</i> function takes a pointer to the private security object's security descriptor, and returns the requested security descriptor. You use the familiar <i>secInfo</i> parameter to indicate which portions of the object's security descriptor you want to retrieve. You must supply a buffer large enough to contain a security descriptor that will hold the requested information. You can call <i>GetPrivateObjectSecurity</i> once to find the size of the required buffer, and again to retrieve the information.</p>

<p> After you have the security descriptor for the object, you must modify it, and then reset the modified security descriptor to the private object using <i>SetPrivateObjectSecurity</i>.</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL SetPrivateObjectSecurity(
   SECURITY_INFORMATION secInfo,
   PSECURITY_DESCRIPTOR psdModificationDescriptor,
   PSECURITY_DESCRIPTOR *ppsdObjectsSecurityDescriptor,
   PGENERIC_MAPPING     gmGenericMapping, 
   HANDLE               hClientToken);
</pre></td></tr></table>
</p>

<p>The <i>secInfo</i> parameter indicates which information in the &quot;modification security descriptor&quot; is to be set in the object's private security descriptor. You pass the address of a PSECURITY_DESCRIPTOR variable, which contains a pointer to the object's private security descriptor. <i>SetPrivateObjectSecurity</i> frees the security descriptor and replaces it with the new security descriptor, whose address is returned in the provided pointer variable. You must also pass <i>hClientToken</i> so that the system can confirm object owner settings, as well as the generic mapping structure.</p>

<p> The modification of a security descriptor is typically performed using these steps:</p>

<ol>
<p><li>Retrieve the object's security descriptor.</li></p>

<p><li>Create and initialize a new security descriptor (shown earlier in this chapter).</li></p>

<p><li>Copy security information from the original security descriptor to the new security descriptor.</li></p>

<p><li>Modify the new security descriptor (using techniques described throughout this chapter).</li></p>

<p><li>Set the new security descriptor back to the private object.</li></p>
</ol>

<p>To get the individual components of a security descriptor, you should use the following functions: <i>GetSecurityDescriptorOwner</i>, <i>GetSecurityDescriptorDacl</i>, <i>GetSecurityDescriptorSacl</i>, and <i>GetSecurityDescriptorGroup</i>. To set the components in a new security descriptor, you can use <i>SetSecurityDescriptorOwner</i>, <i>SetSecurityDescriptorDacl</i>, <i>SetSecurityDescriptorSacl</i>, and <i>SetSecurityDescriptorGroup</i>. These functions are similar, so I will show and discuss the most common and complex two, <i>GetSecurityDescriptorDacl</i> and <i>SetSecurityDescriptorDacl</i>. Here is <i>GetSecurityDescriptorDacl</i>:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL GetSecurityDescriptorDacl(
   PSECURITY_DESCRIPTOR pSecurityDescriptor, 
   PBOOL                pfDACLPresent,
   PACL                 *pDACL,
   PBOOL                pfDACLDefaulted);
</pre></td></tr></table>
</p>

<p>This function retrieves a pointer to the DACL in a security descriptor. It also indicates whether a DACL is present, and whether it was originally created via default security. You supply the security descriptor as well as the address of a Boolean value indicating whether a DACL is present, the address of a PACL variable to retrieve the DACL, and the address of another Boolean value, which the system uses to indicate whether the DACL was defaulted.</p>

<p> To set the DACL back to a security descriptor, you can use <i>SetSecurityDescriptorDacl</i>:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
BOOL SetSecurityDescriptorDacl(
   PSECURITY_DESCRIPTOR pSecurityDescriptor, 
   BOOL                 bDaclPresent,
   PACL                 pDacl,
   BOOL                 bDaclDefaulted);
</pre></td></tr></table>
</p>

<p>This function simply takes the pointer to a security descriptor object that you wish to modify, and Boolean values indicating whether the DACL is present and whether it is the result of default security (for which you will typically pass FALSE). The <i>SetSecurityDescriptorDacl</i> function requires a pointer to a DACL that becomes the new DACL for the security descriptor.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
You should never attempt to set the DACL or any other component of a security descriptor that is returned for any object in the system. You should always create a new security descriptor, to which you can set components such as the DACL and SACL. The reason for this is security descriptors returned from the system are packaged in <i>self-relative</i> format. This means that the data comes in a single contiguous block of memory, which leaves no room for modification.</blockquote>
</div>
</p>

<p>When you allocate memory and initialize a new security descriptor by using the <i>InitializeSecurityDescriptor</i> function, the system initializes a security descriptor that is in <i>absolute</i> format. A security descriptor in absolute format uses pointers to reference its components, allowing the components to be set and reset.</p>

<A NAME="224"><h2>The RoboService Sample Service</h2></A>
<p>The RoboService sample service (&quot;10 RoboService.exe&quot;) demonstrates how private security objects and client/server access control are employed using named pipes. The source code and resource files for the application are in the 10-RoboService directory on the companion CD.</p>

<p>When you launch RoboService with the &quot;/install&quot; switch, the application installs itself as a service on the system. (See Figure 10-8.) You can then use any service control program to start and stop the service. Also, if you are executing the service from a debugger, you can pass the &quot;/debug&quot; switch, which causes the service to execute in debug mode, bypassing service functionality.</p>

<p>
<A HREF="javascript:fullSize('F10FJ08x.htm')"> <img src="images/F10FJ08.JPG" width=404 height=138 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 10-8.</b> <i>The command-line options for RoboService</i><!-- /caption -->
</p>

<p>After the service is running, you can run the RoboClient sample application, shown in Figure 10-9, and enter the computer name of the system running the service. If you don't enter a computer name, the client attempts to connect to the service on the local machine.</p>

<p>Once connected, you will see a list of &quot;virtual robots&quot; created by the service. These robots are secured using private security functionality on the service side. You may add and remove robots. You can perform several defined actions with the robots, including editing robot security.</p>

<p>
<A HREF="javascript:fullSize('F10FJ09x.htm')"> <img src="images/F10FJ09.JPG" width=404 height=316 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 10-9.</b> <i>User interface for the RoboClient sample application</i><!-- /caption -->
</p>

<p>I suggest you run the service and then launch the client from multiple user contexts, perhaps by using the RunAs.exe utility packaged with Windows. This will allow you to experiment with object ownership and access control.</p>

<p> The client is very thin, and defers nearly all functionality to the service. All security code (except for ACL editing) is implemented on the service side.</p>

<p> The service uses <i>impersonation</i> to obtain a token for each connecting client. (Impersonation is discussed in detail in <A HREF="ch11a.htm">Chapter 11</A>.) The service then stores the token for use in future securable requests from the client and in robot creation. The service uses <i>CreatePrivateObjectSecurity</i>, <i>DestroyPrivateObjectSecurity</i>, and <i>AccessCheck</i>, as well as many other security-related functions, to implement the service.</p>

<p> In addition to security functionality, the service uses I/O completion ports, discussed in <A HREF="ch02a.htm">Chapter 2</A>, to communicate efficiently with the client, implementing a model for scalable communication.</p>

<A NAME="225"><h2>Auditing and the SACL</h2></A>
<p>Finally, we're ready to discuss auditing and the SACL. Unlike the DACL, the SACL of an object has no effect on who can access an object. However, when access is requested of an object, the SACL can cause an event to be added to the event log. Specifically, you can add ACEs to an object's SACL, which adds events to the event log under two conditions:</p>


<ul>
<p><li>When an access check succeeds for any of a set of access rights</li></p>

<p><li>When an access check fails for any of a set of access rights</li></p>
</ul>

 

<p>For example, you could create a SACL for a file on an NTFS partition that contains a single SYSTEM_AUDIT_ACE. This would indicate that each time a certain trustee failed to write to the file because of denied access, an event should be added to the event log by the system.</p>

<p> Auditing is disabled by default in Windows 2000, so you should enable auditing if you wish to begin writing software that audits. Follow these steps to enable auditing for your system:</p>

<ol>
<p><li>Run the Microsoft Management Console (MMC) with the /a switch, <i>mmc /a</i>.</li></p>

<p><li>On the Console menu, select Add/Remove Snap-in, and then click the Add button.</li></p>

<p><li>In the Add Standalone Snap-in dialog box, select Group Policy, and then click Add.</li></p>

<p><li>In the Select Group Policy Object dialog box, the Local Computer object should be selected, so click Finish.</li></p>

<p><li>Click the Close button, and then click OK. The Local Computer Policy object should be displayed in the MMC.</li></p>

<p><li>Expand the Local Computer Policy object as follows: Local Computer Policy\Computer Configuration\Windows Settings\Security Settings\Local Policies\Audit Policy.</li></p>

<p><li>In the right pane, right-click Audit Object Access, and then select Security.</li></p>

<p><li>In the Local Security Policy Setting dialog box, check the Success and Failure check boxes as shown in Figure 10-10 and click OK.</li></p>

<p>
<A HREF="javascript:fullSize('F10FJ10x.htm')"> <img src="images/F10FJ10.JPG" width=404 height=330 border=0 ALT = "Click to view at full size."> </A>
</p><p>
<!-- caption --><b>Figure 10-10. </b> <i>Enabling success and failure auditing for object access </i><!-- /caption -->
</p>

</ol>


<p>After you have followed these steps, the system begins adding audit events to the event log under the Security log.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
A domain policy can override your local policy, preventing auditing from being set. You must have domain administrative rights to adjust domain policy.</blockquote>
</div>
</p>

<p>Believe it or not, you've already finished the hard work for implementing auditing. You know how to create ACEs and modify ACLs from the work we did with DACLs. Just about everything you have learned so far applies to creating ACEs and SACLs.</p>

<p>Here is the ACE structure used for the SACL:</p>

<p>
<table cellpadding="5" width="95%"><tr><td><pre>
typedef struct _SYSTEM_AUDIT_ACE {
   ACE_HEADER  Header; 
   ACCESS_MASK Mask; 
   DWORD       SidStart; 
} SYSTEM_AUDIT_ACE;
</pre></td></tr></table>
</p>

<p>This structure should look familiar, because it is exactly the same as the ACCESS_ALLOWED_ACE and ACCESS_DENIED_ACE structures that we have been discussing. The <i>AceFlags</i> member of the ACE_HEADER structure typically contains inheritance information, which is also true for audit ACEs. But you should also include one or both of the SUCCESSFUL_ACCESS_ACE_FLAG and FAILED_ACCESS_ACE_FLAG audit flags to indicate auditing for successful and failed access, respectively.</p>

<p>To modify SACLs for objects, use the functions that you are already familiar with, such as <i>InitializeAcl</i> and <i>AddAce</i>. Getting and setting the SACL for a system object is still handled using <i>GetSecurityInfo</i> and <i>SetSecurityInfo</i>, in much the same manner you would use them for the DACL. Creating a SACL is somewhat simpler than creating a DACL, because the order of ACEs in a SACL has no effect on the object. You can add ACEs in any order that is convenient for your software.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
One difference you'll notice in dealing with DACLs is that a trustee cannot set the SACL of an object unless it has the SE_AUDIT_NAME privilege.</blockquote>
</div>
</p>

<A NAME="226"><h2>Access Control Programming Considerations</h2></A>
<p>You now understand what is possible with access control and how to implement access control in your own software, but you've still got more to learn to become a successful security programmer&#8212;it has been argued that the flexibility of Windows access control gives the security developer more than enough rope to hang himself. In this section, I discuss some issues you should consider in your security development. My overall advice to you is to plan the access control of your service. With a little forward planning, you will save yourself a great deal of headache.</p>

<A NAME="227"><h3>Memory Management</h3></A>
<p>Unlike 90 percent of the programming you do at the application level, security programming requires a fair amount of buffer management, including the allocating and moving of structures within memory. Although this is what many developers focused on in school, it is not a terribly common task in Windows development. When dealing with security, you should come up with ways to simplify your memory management because so many functions require the allocation and reallocation of temporary buffers. Here are some tips:</p>


<ul>
<p><li>Consider using functions such as <i>_alloca</i> that do not require memory to be freed.</li></p>

<p><li>Consider writing a class such as the CAutoBuf class, which is discussed in <a href="chaba.htm">Appendix B</a>. (You will also find the sample applications in <a href="chaba.htm">Appendix B</a>.) This class automatically adjusts its buffer and frees itself when it goes out of scope.</li></p>

<p><li>Avoid static buffers; they are a lazy programmer's technique and will eventually break your application.</li></p>

<p><li>Think about the task at hand, and design an approach that requires as few buffer allocations as possible. Place as much of the buffer allocation at the beginning of the algorithm as possible.</li></p>

<p><li>Use structured exception handling to clean up after yourself.</li></p>
</ul>

 

<A NAME="228"><h3>Code Reuse</h3></A>
<p>The more code you write, the more bugs you write. With access control programming, this is doubly true. Plan ahead and write code that can be used generally throughout your service. Try to design the security of different aspects of your service to be consistent with one another so that you can depend on certain patterns and reuse functions as much as possible. This reuse will greatly ease the task of debugging your security code.</p>

<p>Finally, I can't express enough how advantageous it is to implement your security code in a set of thin C++ classes. Doing so buys you code reuse and encapsulation that can greatly simplify a task such as access control.</p>

<A NAME="229"><h3>Keep It Simple</h3></A>
<p>Simple security is often the best security. If an object has dozens of ACEs, your software and users are probably going to have trouble keeping tabs on who really has access to the object. If an object has only a few simple ACEs, both the software and the users will be clear about who has access. An object that is owned by the system and has only an empty DACL (not a NULL DACL) is as simple and secure as an object gets in Windows. Add a single ACE to allow one trustee access and the object is still secure, and it is clear who has access to the object.</p>

<p>Try to implement as much of your access control as possible using only access-allowed ACEs. Remember that access is denied implicitly unless it is explicitly allowed. If you must use both access-allowed ACEs and access-denied ACEs, allow access to groups and individuals, and deny access to individuals and smaller groups. This way you won't find yourself needing to override a group access-denied ACE for a single user in the group.</p>

<p>Keep it simple to avoid holes in your access control.</p>

<A NAME="230"><h3>Use Default Security and Inherited Security</h3></A>
<p>If at all possible, use default security and inherited security. If your service can avoid manipulating ACLs on individual objects, great! Many services can get by with creating only a single DACL and setting it as the default DACL for the service (discussed in more detail in <A HREF="ch12a.htm">Chapter 12</A>). An object created by the service can use the default security, avoiding the need to create a DACL for each object created. This approach can greatly simplify a service that must create many secure objects.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Remember that an object that inherits security will not use ACEs from the default DACL. You might find that you'll need to protect a parent directory or registry key's security descriptor if you want to use default security on child objects.</blockquote>
</div>
</p>

<p>Inherited security is another way to get a DACL for free. You can set the DACL on a single parent object in a file structure (or registry tree), and each object you create under that node can inherit a whole DACL's worth of ACEs. This is a very powerful technique, and it can free your code from creating dozens of individual DACLs.</p>

<p>
<div class="note"><blockquote><b>NOTE</b><hr>
Remember that an object that is protected from inheritable ACEs can itself have inheritable ACEs. So you can create a root directory or registry key that is protected from inherited ACEs, and the object's ACEs can define the inherited security for every object below it. This is a common and powerful tactic for implementing inherited security on files and registry keys.</blockquote>
</div>
</p>

</body>
</html>





