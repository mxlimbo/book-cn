<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Building ActiveX Controls</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch21b.htm", "ch21d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="669"><H1>Building ActiveX Controls</H1></A>

<P>Armed with this knowledge of the ActiveX control architecture and the manner 
in which MFC encapsulates it, you're almost ready to build your first control. But 
first, you need to know more about the 
<I>process</I> of writing ActiveX controls with Visual 
C++ and MFC. The following sections provide additional information about the nature 
of ActiveX controls from an MFC control writer's perspective and describe some of 
the basic skills required to write a control&#8212;for example, how to add methods, 
properties, and events, and what impact these actions have on the underlying source code.
</P>


<A NAME="670"><H2>Running ControlWizard</H2></A>

<P>The first step in writing an MFC ActiveX control is to create a new project and 
select MFC ActiveX ControlWizard as the project type. This runs ControlWizard, which 
asks a series of questions before generating the project's source code files.
</P>

<P>The first series of questions is posed in ControlWizard's Step 1 dialog box, 
shown in Figure 21-4. By default, the OCX generated when this project is built will 
contain just one control. If you'd rather it implement more, enter a number in the How 
Many Controls Would You Like Your Project To Have box. ControlWizard will respond 
by including multiple control classes in the project. Another option is Would You 
Like The Controls In This Project To Have A Runtime License? If you answer 
yes, ControlWizard builds in code that prevents the control from being instantiated in the 
absence of a valid run-time license. Implemented properly, this can be an effective means 
of preventing just anyone from using your control. But because ControlWizard's 
license-checking scheme is easily circumvented, enforcing run-time licensing requires 
extra effort on the part of the control's implementor. For details, see the section 
&quot;<A HREF="ch21e.htm#695">Control Licensing</A>&quot; at the close of this chapter.
</P>

<P>
<A HREF="javascript:fullSize('F21mg04x.htm')"> <img src="images/F21mg04.JPG" width=404 height=325 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 21-4.</B> <I>ControlWizard's Step 1 dialog box.</I><!-- /CAPTION -->
</p>

<P>ControlWizard's Step 2 dialog box is shown in Figure 21-5. Clicking the 
Edit Names button displays a dialog box in which you can enter names for the 
classes ControlWizard will generate, the names of those classes' source code files, and 
ProgIDs for the control and its property page. If you'd like the control to wrap a built-in 
control type such as a slider control or a tree view control, choose a WNDCLASS 
name from the list attached to the Which Window Class, If Any, Should This Control 
Subclass box. The &quot;<A HREF="ch21e.htm#694">Control Subclassing</A>&quot; section later in this chapter explains what 
this does to your source code and what implications it has for the code you write.
</P>

<P>
<A HREF="javascript:fullSize('F21mg05x.htm')"> <img src="images/F21mg05.JPG" width=404 height=325 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 21-5.</B> <I>ControlWizard's Step 2 dialog box.</I><!-- /CAPTION -->
</p>

<P>The options under Which Features Would You Like This Control To Have? 
can have profound effects on a control's appearance and behavior. The defaults are 
normally just fine, but it's hard to understand what these options really mean from 
the scant descriptions provided in the online help. Therefore, here's a brief synopsis 
of each one. The term 
<I>miscellaneous status bits</I> refers to a set of bit flags that communicate certain characteristics of the control to the control container. A container can acquire a control's miscellaneous status bits from the control itself or, if the control isn't running, from the registry.
</P>

<UL>
<P><LI>
<B>Activates When Visible</B>&#8212;Sets a flag in the control's miscellaneous status bits informing the container that the control wants to be active whenever it's visible. Disabling this option gives the container the option of disabling the control, which it might do to conserve resources or speed start-up time. If you uncheck this box, you should check the Mouse Pointer Notifications When Inactive box described below if your control processes WM_MOUSEMOVE or WM_SETCURSOR messages.
</LI></P>

<P><LI>
<B>Invisible At Runtime</B>&#8212;Sets a flag in the control's miscellaneous status bits indicating that the control wants to be visible in design mode but invisible in user mode. In other words, the control should be visible in a design-time environment such as the Visual C++ dialog editor, but invisible when the application that uses the control is running. One example of a control that might choose to exercise this option is a timer control that fires events at specified intervals. The control doesn't need to be seen at run time, but it should be visible at design time so that the user can display its property sheet.</LI></P>

<P><LI>
<B>Available In &quot;Insert Object&quot; Dialog</B>&#8212;Because most ActiveX controls implement a functional superset of the interfaces required to act as object linking and embedding servers, most of them can, if asked, masquerade as object linking and embedding servers. When this option is selected, the control gets registered not only as an ActiveX control but also as an OLE server, which causes it to appear in the Insert Object dialog box found in Microsoft Word, Microsoft Excel, and other OLE containers. Checking this box is generally a bad idea because most OLE containers don't know how to interact with ActiveX controls. Except in isolated cases, the best strategy is to forget that this option even exists.
</LI></P>

<P><LI>
<B>Has An &quot;About&quot; Box</B>&#8212;If checked, adds a method named 
<I>AboutBox</I> to the control that displays an About dialog box. Select this option if you'd like developers using your control to be able to learn more about it and its creator from an About box. ControlWizard creates a simple dialog resource for you; it's up to you to add a professional touch.
</LI></P>

<P><LI>
<B>Acts As A Simple Frame Control</B>&#8212;Tells ControlWizard to add an 
<I>ISimpleFrameSite</I> interface to the control, and sets a flag in the miscellaneous status bits identifying this as a &quot;simple frame&quot; control. A simple frame control is one that hosts other controls but delegates much of the work to its own control container. Use this option for controls, such as group box controls, whose primary purpose is to provide a site for (and visual grouping 
of) other controls.
</LI></P>
</UL>

<P>You can access still more options by clicking the Advanced button in the 
Step 2 dialog box, which displays the window shown in Figure 21-6. All are relatively 
recent additions to the ActiveX control specification (most come directly from OCX 
96), and none are universally supported by control containers. Nevertheless, they're 
worth knowing about, if for no other reason than the fact that ControlWizard exposes 
them to you. 

<P>
<IMG SRC="images/F21mg06.GIF" width=362 height=204 BORDER=0>
</p><p>
<!-- CAPTION --><B>Figure 21-6.</B> <I>ControlWizard's Advanced ActiveX Features dialog box.</I><!-- /CAPTION -->
</p>

Here's a brief summary of the options found in the Advanced ActiveX 
Features dialog box:
</P>

<UL>
<P><LI><B>Windowless Activation</B>&#8212;Makes the control a windowless control. If the container doesn't support windowless activation, the control will be instantiated in a window as if it were a regular windowed control. Windowless controls are discussed at length later in this chapter.
</LI></P>

<P><LI>
<B>Unclipped Device Context</B>&#8212;According to the documentation, this option, if selected, speeds redraws ever so slightly by preventing 
<I>COleControl::OnPaint</I> from calling 
<I>CDC::IntersectClipRect</I> on the device context passed to the control to prevent the control from inadvertently painting outside its own window. Despite what the documentation says, this option has no effect whatsoever on the control's behavior in MFC 6.0.
</LI></P>

<P><LI>
<B>Flicker-Free Activation</B>&#8212;Most ActiveX controls are activated 
when they're created and remain active indefinitely. If a container 
deactivates an active control, however, the container repaints the control. And if 
an inactive control becomes active, the control repaints itself. For controls 
that look the same whether active or inactive, this repainting is 
unnecessary and can cause unsightly flicker. The flicker-free activation option 
eliminates redrawing induced by state transitions in containers that support it.
</LI></P>

<P><LI>
<B>Mouse Pointer Notifications When Inactive</B>&#8212;Allows containers to forward WM_SETCURSOR and WM_MOUSEMOVE messages to inactive controls via an MFC-provided implementation of 
<I>IPointerInactive</I>. This option is typically used with controls that don't use the Activates When Visible option but want to alter the appearance of the mouse cursor or respond to mouse movements even while inactive.
</LI></P>

<P><LI>
<B>Optimized Drawing Code</B>&#8212;When 
<I>IViewObjectEx::Draw</I> is called to draw a windowless control, the control is responsible for leaving the device context in the same state in which it found it. Some containers free the control from this obligation, in which case the control can speed repainting by reducing the number of GDI calls. To take advantage of this feature in supportive containers, select this option and call 
<I>COleControl::IsOptimizedDraw</I> each time 
<I>OnDraw</I> is called. If 
<I>IsOptimizedDraw</I> returns nonzero, 
there's no need to clean up the device context.
</LI></P>

<P><LI>
<B>Loads Properties Asynchronously</B>&#8212;Indicates that this control 
supports datapath properties. Unlike standard control properties, datapath 
properties are downloaded asynchronously, typically from a URL. For 
controls designed to sit in Web pages, implementing properties that 
encapsulate large volumes of data as datapath properties can improve 
performance dramatically. MFC makes implementing datapath properties relatively 
easy, but (in my opinion, anyway) controls designed for the Internet should 
be written with the Active Template Library, not with MFC. 
For more information about implementing datapath properties in MFC, see the 
article &quot;Internet First Steps: ActiveX Controls&quot; in the online documentation.
</LI></P>
</UL>

<P>When you select any of the advanced options&#8212;with the exception of 
Loads Properties Asynchronously&#8212;ControlWizard overrides a 
<I>COleControl</I> function named 
<I>GetControlFlags</I> in the derived control class and selectively sets or clears bit flags 
in the control flags that the function returns. For example, selecting Flicker-Free Activation ORs a 
<I>noFlickerActivate</I> flag into the return value. Some options prompt 
ControlWizard to make more extensive modifications to the source code. For 
example, selecting Optimized Drawing Code adds 
<I>canOptimizeDraw</I> to the control flags and inserts a call to 
<I>IsOptimizedDraw</I> into 
<I>OnDraw</I>. MFC calls 
<I>GetControlFlags</I> at various times to find out about relevant characteristics of the control.
</P>

<P>When ControlWizard is done, you're left with an ActiveX control project 
that will actually compile into a do-nothing ActiveX control&#8212;one that has no 
methods, properties, or events, and does no drawing other than erase its background and 
draw a simple ellipse, but one that satisfies all the criteria for an ActiveX control. That 
project includes these key elements:
</P>

<UL>
<P><LI>A 
<I>COleControlModule</I>-derived class representing the control's OCX.
</LI></P>

<P><LI>A 
<I>COleControl</I>-derived class representing the control. ControlWizard overrides 
<I>OnDraw</I>, 
<I>DoPropExchange</I>, and other virtual functions in the 
derived class, so you don't have to. The control class also includes essential 
infrastructure such as a COM class factory and dispinterfaces for methods, 
properties, and events.
</LI></P>

<P><LI>A 
<I>COlePropertyPage</I>-derived class and a dialog resource representing the control's property page.
</LI></P>

<P><LI>An ODL file that ClassWizard will later modify as methods, properties, 
and events are added and from which the control's type library will be 
generated.
</LI></P>

<P><LI>A toolbar button bitmap that will represent the control on toolbars in design-time environments such as Visual Basic.
</LI></P>
</UL>

<P>ControlWizard does nothing that you couldn't do by hand, but it provides a 
welcome jump start on writing an ActiveX control. I'm not a big fan of 
code-generating wizards, and there's much more I wish ControlWizard would do, but all things 
considered, it's a tool that would be hard to live without.
</P>


<A NAME="671"><H2>Implementing <I>OnDraw</I></H2></A>
<P>When a control needs repainting, MFC calls its 
<I>OnDraw</I> function. 
<I>OnDraw</I> is a virtual function inherited from 
<I>COleControl</I>. It's prototyped like this:</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
virtual void OnDraw (CDC* pDC, const CRect&amp; rcBounds, 
    const CRect&amp; rcInvalid)
</PRE></TD></TR></TABLE>
</P>

<P><I>pDC</I> points to the device context in which the control should paint itself. 
<I>rcBounds</I> describes the rectangle in which painting should be performed. 
<I>rcInvalid</I> describes the portion of the control rectangle (
<I>rcBounds</I>) that is invalid; it could be identical to 
<I>rcBounds</I>, or it could be smaller. Use it to optimize drawing performance the 
same way you'd use 
<I>GetClipBox</I> in a conventional MFC application.
</P>

<P>
<I>OnDraw</I> can be called for three reasons:
</P>

<UL>
<P><LI>A windowed control receives a WM_PAINT message.</LI>
</P>

<P><LI>
<I>IViewObjectEx::Draw</I> is called on an inactive control (or one that's about to become inactive) to retrieve a metafile for the control container. If you'd like to draw the control differently when it's inactive, override 
<I>COleControl::OnDrawMetafile</I>. The default implementation calls 
<I>OnDraw</I>.</LI>
</P>

<P><LI>
<I>IViewObjectEx::Draw</I> is called on a windowless control to ask it to paint itself into the container's window.
</LI></P>
</UL>

<P>Regardless of why it's called, 
<I>OnDraw</I>'s job is to draw the control. The device context is provided for you in the parameter list, and you can use 
<I>CDC</I> output functions to do the drawing. Just be careful to abide by the following rules:
</P>

<UL>
<P><LI>Assume nothing about the state of the device context passed in 
<I>OnDraw</I>'s parameter list. You shouldn't assume, for example, that a black pen or 
a white brush is selected in. Prepare the device context as if its initial 
attributes were all wrong.
</LI></P>


<P><LI>
Leave the device context in the same state you found it in, which 
means not only selecting out the GDI objects you selected in, but also 
preserving the drawing mode, text color, and other attributes of the device context. As an alternative, you can check the Optimized Drawing Code box in ControlWizard to advertise the control's intent 
<I>not</I> to preserve the state of the device context. But because many containers don't support this option, you must call 
<I>COleControl::IsOptimizedDraw</I> inside 
<I>OnDraw</I> to find out whether it's OK.
</LI></P>

<P><LI>
Limit your drawing to the rectangular area described by the 
<I>rcBounds</I> parameter included in 
<I>OnDraw</I>'s parameter list. For a windowed control, 
<I>rcBounds</I>' upper left corner will be (0,0). For a windowless control, these coordinates can be nonzero because they describe an area inside the container's window.
</LI></P>

<P><LI>
Begin 
<I>OnDraw</I> by erasing the control's background&#8212;the rectangle described by 
<I>rcBounds</I>. This is typically accomplished by creating a brush of the desired color and calling 
<I>CDC::FillRect</I>. If the control is windowless, you can effect a transparent background by skipping this step.
</LI></P>
</UL>

<P>These rules exist primarily for the benefit of windowless controls, but it's important to heed them when writing controls that are designed to work equally well whether they're windowed or windowless. To determine at run time whether a control is windowed or windowless, check the control's 
<I>m_bInPlaceSiteWndless</I> data member. A nonzero value means the control is windowless.
</P>


<A NAME="672"><H2>Using Ambient Properties</H2></A>

<P>Ambient properties allow a control to query its container for pertinent characteristics of the environment in which the control is running. Because ambient properties are Automation properties implemented by the container, they are read by calling 
<I>IDispatch::Invoke</I> on the container. 
<I>COleControl</I> simplifies the retrieval of ambient property values by supplying wrapper functions that call 
<I>IDispatch::Invoke</I> for you. 
<I>COleControl::AmbientBackColor</I>, for example, returns the ambient background color. The following table lists several of the ambient properties that are available, their dispatch IDs, and the corresponding <I>COleControl</I> member functions. To read ambient properties for which property-specific retrieval functions don't exist, you can call 
<I>GetAmbientProperty</I> and pass in the property's dispatch ID.
</P>

<P><B>Ambient Properties</B></P>

<P>
<TABLE cellpadding=5 width="95%">
<TR>
<TH VALIGN="TOP"><I>Property Name </I></TH>
<TH VALIGN="TOP"><I>Dispatch ID</I></TH>
<TH VALIGN="TOP">COleControl <I>Retrieval Function</I></TH>
</TR>

<TR>
<TD VALIGN="TOP"><I>BackColor</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_BACKCOLOR</TD>
<TD VALIGN="TOP"><I>AmbientBackColor</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DisplayName</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_ DISPLAYNAME</TD>
<TD VALIGN="TOP"><I>AmbientDisplayName</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>Font</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_ FONT</TD>
<TD VALIGN="TOP"><I>AmbientFont</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>ForeColor</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_ FORECOLOR</TD>
<TD VALIGN="TOP"><I>AmbientForeColor</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>LocaleID</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_ LOCALEID</TD>
<TD VALIGN="TOP"><I>AmbientLocaleID</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>MessageReflect</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_MESSAGEREFLECT</TD>
<TD VALIGN="TOP"><I>GetAmbientProperty</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>ScaleUnits</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_SCALEUNITS</TD>
<TD VALIGN="TOP"><I>AmbientScaleUnits</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>TextAlign</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_TEXTALIGN</TD>
<TD VALIGN="TOP"><I>AmbientTextAlign</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>UserMode</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_USERMODE</TD>
<TD VALIGN="TOP"><I>AmbientUserMode</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>UIDead</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_UIDEAD</TD>
<TD VALIGN="TOP"><I>AmbientUIDead</I></TD>
</TR>

<TR>
<TD ROWSPAN="2"><I>ShowGrabHandles</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT-</TD>
<TD VALIGN="TOP"><I>AmbientShow-</I></TD>
</TR>

<TR>
<TD VALIGN="TOP">_SHOWGRABHANDLES</TD> 
<TD VALIGN="TOP"><I>GrabHandles</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>ShowHatching</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_SHOWHATCHING</TD>
<TD VALIGN="TOP"><I>AmbientShowHatching</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DisplayAsDefaultButton</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_DISPLAYASDEFAULT</TD>
<TD VALIGN="TOP"><I>GetAmbientProperty</I></TD>
</TR>

<TR>
<TD ROWSPAN="2"><I>SupportsMnemonics</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT-</TD>
<TD ROWSPAN="2" VALIGN="TOP"><I>GetAmbientProperty</I></TD>
</TR>

<TR>
<TD VALIGN="TOP">_SUPPORTSMNEMONICS</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>AutoClip</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_AUTOCLIP</TD>
<TD VALIGN="TOP"><I>GetAmbientProperty</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>Appearance</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_APPEARANCE</TD>
<TD VALIGN="TOP"><I>GetAmbientProperty</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>Palette</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_PALETTE</TD>
<TD VALIGN="TOP"><I>GetAmbientProperty</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>TransferPriority</I></TD>
<TD VALIGN="TOP">DISPID_AMBIENT_TRANSFERPRIORITY</TD>
<TD VALIGN="TOP"><I>GetAmbientProperty</I></TD>
</TR>
</TABLE>
</P>

<P>The following code, which would probably be found in a control's 
<I>OnDraw</I> function, queries the container for the ambient background color and paints the control background the same color:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CBrush brush (TranslateColor (AmbientBackColor ()));
pdc-&gt;FillRect (rcBounds, &amp;brush);
</PRE></TD></TR></TABLE>
</P>

<P>Notice the use of 
<I>COleControl::TranslateColor</I> to convert the OLE_COLOR color value returned by 
<I>AmbientBackColor</I> into a Windows COLORREF value. OLE_COLOR is ActiveX's native color data type.
</P>

<P>If your 
<I>OnDraw</I> implementation relies on one or more ambient properties, you should override <I>COleControl::OnAmbientPropertyChange</I> in the derived control class. This function is called when the container notifies the control that one or more ambient properties have changed. Overriding it allows the control to respond immediately to changes in the environment surrounding it. A typical response is to repaint the control by calling 
<I>InvalidateControl</I>:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
void CMyControl::OnAmbientPropertyChange (DISPID dispid)
{
    InvalidateControl (); // Repaint.
}
</PRE></TD></TR></TABLE>
</P>


<P>The 
<I>dispid</I> parameter holds the dispatch ID of the ambient property that changed, or DISPID_UNKNOWN if two or more properties have changed. A smart control could check this parameter and refrain from calling <I>InvalidateControl</I> unnecessarily.
</P>


<A NAME="673"><H2>Adding Methods</H2></A>

<P>Adding a custom method to an ActiveX control is just like adding a method to an Automation server. The procedure, which was described in <a href="ch20a.htm">Chapter 20</a>, involves going to ClassWizard's Automation page, selecting the control class in the Class Name box, clicking Add Method, filling in the Add Method dialog box, and then filling in the empty function body created by ClassWizard.
</P>

<P>Adding a stock method is even easier. You once again click the Add Method button, but rather than enter a method name, you choose one from the drop-down list attached to the External Name box. 
<I>COleControl</I> provides the method implementation, so there's literally nothing more to do. You can call a stock method on your own control by calling the corresponding 
<I>COleControl</I> member function. The stock methods supported by 
<I>COleControl</I> and the member functions used to call them are listed in the following table.
</P>

<P><B>Stock Methods Implemented by <I>COleControl</I></B></P>

<P>
<TABLE cellpadding=5 width="95%">
<TR>
<TH VALIGN="TOP"><I>Method Name</I></TH>
<TH VALIGN="TOP"><I>Dispatch ID</I></TH>
<TH VALIGN="TOP"><I>Call with</I></TH>
</TR>

<TR>
<TD VALIGN="TOP"><I>DoClick</I></TD>
<TD VALIGN="TOP">DISPID_DOCLICK</TD>
<TD VALIGN="TOP"><I>DoClick</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>Refresh</I></TD>
<TD VALIGN="TOP">DISPID_REFRESH</TD>
<TD VALIGN="TOP"><I>Refresh</I></TD>
</TR>
</TABLE>
</P>

<P>When you add a custom method to a control, ClassWizard does the same thing it does when you add a method to an Automation server: it adds the method and its dispatch ID to the project's ODL file, adds a function declaration and body to the control class's H and CPP files, and adds a DISP_FUNCTION statement to the dispatch map.
</P>

<P>Stock methods are treated in a slightly different way. ClassWizard still updates the ODL file, but because the function implementation is provided by 
<I>COleControl</I>, no function is added to your source code. Furthermore, rather than add a DISP_FUNCTION statement to the dispatch map, ClassWizard adds a DISP_STOCKFUNC statement. The following dispatch map declares two methods&#8212;a custom method named 
<I>Foo</I> and the stock method 
<I>Refresh</I>:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
BEGIN_DISPATCH_MAP (CMyControl, COleControl)
    DISP_FUNCTION (CMyControl, &quot;Foo&quot;, Foo, VT_EMPTY, VTS_NONE)
    DISP_STOCKFUNC_REFRESH ()
END_DISPATCH_MAP ()
</PRE></TD></TR></TABLE>
</P>

<P>DISP_STOCKFUNC_REFRESH is defined in Afxctl.h. It maps the Automation method named 
<I>Refresh</I> to 
<I>COleControl::Refresh</I>. A related macro named DISP_STOCKFUNC_DOCLICK adds the stock method 
<I>DoClick</I> to an ActiveX control.
</P>


<A NAME="674"><H2>Adding Properties</H2></A>

<P>Adding a custom property to an ActiveX control is just like adding a property to 
an MFC Automation server. ActiveX controls support member variable properties 
and get/set properties just like Automation servers do, so you can add either type.
</P>

<P>You add a stock property by choosing the property name from the list that drops down from the Add Property dialog box's External Name box. 
<I>COleControl</I> supports most, but not all, of the stock properties defined in the ActiveX control 
specification. The following table lists the ones that it supports.
</P>

<P>
<B>Stock Properties Implemented by 
<I>COleControl</I></B></P>

<P>
<TABLE cellpadding=5 width="95%">
<TR>
<TH VALIGN="TOP"><I>Property Name</I></TH>
<TH VALIGN="TOP"><I>Dispatch ID</I></TH>
<TH VALIGN="TOP"><I>Retrieve with</I></TH>
<TH VALIGN="TOP"><I>Notification Function</I></TH>
</TR>

<TR>
<TD VALIGN="TOP"><I>Appearance</I></TD>    
<TD VALIGN="TOP">DISPID_APPEARANCE</TD>   
<TD VALIGN="TOP"><I>GetAppearance</I></TD>   
<TD VALIGN="TOP"><I>OnAppearanceChanged</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>BackColor</I></TD>
<TD VALIGN="TOP">DISPID_BACKCOLOR</TD>
<TD VALIGN="TOP"><I>GetBackColor</I></TD>
<TD VALIGN="TOP"><I>OnBackColorChanged</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>BorderStyle</I></TD>
<TD VALIGN="TOP">DISPID_BORDERSTYLE</TD>
<TD VALIGN="TOP"><I>GetBorderStyle</I></TD>
<TD VALIGN="TOP"><I>OnBorderStyleChanged</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>Caption</I></TD>
<TD VALIGN="TOP">DISPID_CAPTION</TD>    
<TD VALIGN="TOP"><I>GetText</I> or <I>InternalGetText</I></TD>   
<TD VALIGN="TOP"><I>OnTextChanged</I></TD>
</TR>  

<TR>
<TD VALIGN="TOP"><I>Enabled</I></TD>
<TD VALIGN="TOP">DISPID_ENABLED</TD>
<TD VALIGN="TOP"><I>GetEnabled</I></TD>
<TD VALIGN="TOP"><I>OnEnabledChanged</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>Font</I></TD>
<TD VALIGN="TOP">DISPID_FONT</TD>
<TD VALIGN="TOP"><I>GetFont</I> or <I>InternalGetFont</I></TD>   
<TD VALIGN="TOP"><I>OnFontChanged</I></TD>
</TR>   

<TR>
<TD VALIGN="TOP"><I>ForeColor</I></TD>
<TD VALIGN="TOP">DISPID_FORECOLOR</TD>
<TD VALIGN="TOP"><I>GetForeColor</I></TD>
<TD VALIGN="TOP"><I>OnForeColorChanged</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>hWnd</I></TD>
<TD VALIGN="TOP">DISPID_HWND</TD>
<TD VALIGN="TOP"><I>GetHwnd</I></TD>
<TD VALIGN="TOP">N/A</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>ReadyState</I></TD>
<TD VALIGN="TOP">DISPID_READYSTATE</TD>
<TD VALIGN="TOP"><I>GetReadyState</I></TD>
<TD VALIGN="TOP">N/A</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>Text</I></TD>
<TD VALIGN="TOP">DISPID_TEXT</TD>
<TD VALIGN="TOP"><I>GetText or InternalGetText</I></TD>
<TD VALIGN="TOP"><I>OnTextChanged</I></TD>
</TR>    
</TABLE></P>

<P>To retrieve the value of a stock property that your control implements, call the corresponding <I>COleControl</I> get function. (
<I>COleControl</I> also provides functions for setting stock property values, but they're rarely used.) To find out when the value of a stock property changes, override the corresponding notification function in 
your derived class. Generally, it's a good idea to repaint the control any time a stock property changes if the control indeed uses stock properties. 
<I>COleControl</I> provides default notification functions that repaint the control by calling 
<I>InvalidateControl</I>, so unless you want to do more than simply repaint the control when a stock 
property value changes, there's no need to write a custom notification function.
</P>

<P>Under the hood, adding a custom property to a control modifies the 
control's source code files as if a property had been added to an Automation server. 
Stock properties are handled differently. In addition to declaring the property in the 
ODL file, ClassWizard adds a DISP_STOCKPROP statement to the control's dispatch 
map. The following dispatch map declares a custom member variable property named 
<I>SoundAlarm</I> and the stock property 
<I>BackColor</I>:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
BEGIN_DISPATCH_MAP (CMyControl, COleControl)
    DISP_PROPERTY_EX (CMyControl, &quot;SoundAlarm&quot;, m_bSoundAlarm, VT_BOOL)
    DISP_STOCKPROP_BACKCOLOR ()
END_DISPATCH_MAP ()
</PRE></TD></TR></TABLE>
</P>

<P>DISP_STOCKPROP_BACKCOLOR is one of several stock property macros defined in Afxctl.h. It associates the property with a pair of 
<I>COleControl</I> functions named 
<I>GetBackColor</I> and 
<I>SetBackColor</I>. Similar macros are defined for the other stock properties that 
<I>COleControl</I> supports.
</P>


<A NAME="675"><H2>Making Properties Persistent</H2></A>

<P>After adding a custom property to a control, the very next thing you should do is add a statement to the control's 
<I>DoPropExchange</I> function making that property persistent. A persistent property is one whose value is saved to some storage medium (usually a disk file) and later read back. When a Visual C++ programmer drops an ActiveX control into a dialog and modifies the control's properties, the control is eventually asked to serialize its property values. The dialog editor saves those values in the project's RC file so that they will &quot;stick.&quot; The saved values are reapplied when the control is re-created. Controls implement persistence interfaces such as 
<I>IPersistPropertyBag</I> for this reason.
</P>

<P>To make an MFC control's properties persistent, you don't have to fuss with low-level COM interfaces. Instead, you override the 
<I>DoPropExchange</I> function that a control inherits from 
<I>COleControl</I> and add statements to it&#8212;one per property. The 
statements are actually calls to PX functions. MFC provides one PX function for each 
possible property type, as listed in the following table.
</P>

<P><B>PX Functions for Serializing Control Properties</B></P>

<P>
<TABLE cellpadding=5 width="95%">
<TR>
<TH VALIGN="TOP"><I>Function</I></TH>   
<TH VALIGN="TOP"><I>Description</I></TH>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_Blob</I></TD>
<TD VALIGN="TOP">Serializes a block of binary data</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_Bool</I></TD>
<TD VALIGN="TOP">Serializes a BOOL property</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_Color</I></TD>
<TD VALIGN="TOP">Serializes an OLE_COLOR property</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_Currency</I></TD>
<TD VALIGN="TOP">Serializes a CURRENCY property</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_DataPath</I></TD>
<TD VALIGN="TOP">Serializes a <I>CDataPathProperty</I> property</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_Double</I></TD>
<TD VALIGN="TOP">Serializes a double-precision floating point property</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_Float</I></TD>
<TD VALIGN="TOP">Serializes a single-precision floating point property</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_Font</I></TD>
<TD VALIGN="TOP">Serializes a <I>CFontHolder</I> property</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_IUnknown</I></TD>
<TD VALIGN="TOP">Serializes properties held by another object</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_Long</I></TD>
<TD VALIGN="TOP">Serializes a signed 32-bit integer property</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_Picture</I></TD>
<TD VALIGN="TOP">Serializes a <I>CPictureHolder</I> property</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_Short</I></TD>
<TD VALIGN="TOP">Serializes a signed 16-bit integer property</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_String</I></TD>
<TD VALIGN="TOP">Serializes a <I>CString</I> property</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_ULong</I></TD>
<TD VALIGN="TOP">Serializes an unsigned 32-bit integer property</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>PX_UShort</I></TD>
<TD VALIGN="TOP">Serializes an unsigned 16-bit integer property</TD>
</TR>
</TABLE>
</P>

<P>If your control implements a custom member variable property of type BOOL named 
<I>SoundAlarm</I>, the following statement in the control's 
<I>DoPropExchange</I> function makes the property persistable:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
PX_Bool (pPX, _T (&quot;SoundAlarm&quot;), m_bSoundAlarm, TRUE);
</PRE></TD></TR></TABLE>
</P>

<P>
<I>pPX</I> is a pointer to a 
<I>CPropExchange</I> object; it's provided to you in 
<I>DoPropExchange</I>'s parameter list. 
<I>SoundAlarm</I> is the property name, and 
<I>m_bSoundAlarm</I> is the variable that stores the property's value. The fourth parameter specifies the 
property's default value. It is automatically assigned to 
<I>m_bSoundAlarm</I> when the control is created.
</P>

<P>If 
<I>SoundAlarm</I> were a get/set property instead of a member variable 
property, you'd need to retrieve the property value yourself before calling 
<I>PX_Bool</I>:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
BOOL bSoundAlarm = GetSoundAlarm ();
PX_Bool (pPX, _T (&quot;SoundAlarm&quot;), bSoundAlarm);
</PRE></TD></TR></TABLE>
</P>

<P>In this case, you would use the form of 
<I>PX_Bool</I> that doesn't accept a fourth parameter. Custom get/set properties don't require explicit initialization because they 
are initialized implicitly by their get functions.
</P>

<P>Which brings up a question. Given that custom properties are initialized either inside <I>DoPropExchange</I> or by their get functions, how (and when) do stock properties get initialized? It turns out that MFC initializes them for you using commonsense values. A control's default 
<I>BackColor</I> property, for example, is set equal to the container's ambient 
<I>BackColor</I> property when the control is created. The actual initialization is performed by 
<I>COleControl::ResetStockProps</I>, so if you want to initialize stock 
properties yourself, you can override this function and initialize the property values 
manually after calling the base class implementation of 
<I>ResetStockProps</I>.
</P>

<P>When you create a control project with ControlWizard, 
<I>DoPropExchange</I> is overridden in the derived control class automatically. Your job is to add one 
statement to it for each custom property that you add to the control. There's no 
wizard that does this for you, so you must do it by hand. Also, you don't need to modify <I>DoPropExchange</I> when you add stock properties because MFC serializes stock 
properties for you. This serialization is performed by the 
<I>COleControl::DoPropExchange</I> function. That's why ControlWizard inserts a call to the base class when it overrides 
<I>DoPropExchange</I> in a derived control class.
</P>


<A NAME="676"><H2>Customizing a Control's Property Sheet</H2></A>

<P>One other detail you must attend to when adding properties to an ActiveX control 
is to make sure that all those properties, whether stock or custom, are accessible 
through the control's property sheet. The property sheet is displayed by the container, 
usually at the request of a user. For example, when a Visual C++ programmer drops 
an ActiveX control into a dialog, right-clicks the control, and selects Properties from 
the context menu, the dialog editor displays the control's property sheet.
</P>

<P>To make its properties accessible through a property sheet, a control implements one or more property pages and makes them available through its 
<I>ISpecifyPropertyPages</I> interface. To display the control's property sheet, the container asks the control for a list of CLSIDs by calling its 
<I>ISpecifyPropertyPages::GetPages</I> method. Each 
CLSID corresponds to one property page. The container passes the CLSIDs to 
<I>::OleCreatePropertyFrame</I> or 
<I>::OleCreatePropertyFrameIndirect</I>, which instantiates the 
property page objects and inserts them into an empty property sheet. Sometimes the 
container will insert property pages of its own. That's why a control's property sheet will 
have extra pages in some containers but not in others.
</P>

<P>MFC simplifies matters by implementing 
<I>ISpecifyPropertyPages</I> for you. It even gives you a free implementation of property page objects in the form of 
<I>COlePropertyPage</I>. ControlWizard adds an empty dialog resource representing a 
property page to the project for you; your job is to add controls to that page and link 
those controls to properties of the ActiveX control. You accomplish the first task with 
the dialog editor. You connect a control on the page to an ActiveX control property 
by using ClassWizard's Add Variable button to add a member variable to the 
property page class and specifying the Automation name of the ActiveX control property 
in the Add Member Variable dialog box's Optional Property Name field. (You'll see 
what I mean when you build a control later in this chapter.)
</P>

<P>Under the hood, ClassWizard links a dialog control to an ActiveX control property by modifying the derived 
<I>COlePropertyPage</I> class's 
<I>DoDataExchange</I> function. The 
<I>DDP_Check</I> and 
<I>DDX_Check</I> statements in the following 
<I>DoDataExchange</I> function link the check box whose ID is IDC_CHECKBOX to an ActiveX control property named 
<I>SoundAlarm</I>:
</P>

<P><TABLE cellpadding=5 width="95%"><TR><TD><PRE>
void CMyOlePropertyPage::DoDataExchange(CDataExchange* pDX)
{
    DDP_Check (pDX, IDC_CHECKBOX, m_bSoundAlarm, _T (&quot;SoundAlarm&quot;));
    DDX_Check (pDX, IDC_CHECKBOX, m_bSoundAlarm);
    DDP_PostProcessing (pDX);
}
</PRE></TD></TR></TABLE>
</P>

<P>DDP functions work hand in hand with their DDX counterparts to transfer data between property page controls and ActiveX control properties.
</P>


<A NAME="677"><H2>Adding Pages to a Control's Property Sheet</H2></A>

<P>When ControlWizard creates an ActiveX control project, it includes just one 
property page. You can add extra pages by modifying the control's property page map, 
which is found in the derived control class's CPP file. Here's what a typical property 
page map looks like:
</P>

<P><TABLE cellpadding=5 width="95%"><TR><TD><PRE>
BEGIN_PROPPAGEIDS (CMyControl, 1)
    PROPPAGEID (CMyControlPropPage::guid)
END_PROPPAGEIDS (CMyControl)
</PRE></TD></TR></TABLE>
</P>

<P>The 1 in BEGIN_PROPPAGEIDS' second parameter tells MFC's implementation of 
<I>ISpecifyPropertyPages</I> that this control has just one property page; the 
PROPPAGEID statement specifies that page's CLSID. (
<I>CMyControlPropPage::guid</I> is a static 
variable declared by the IMPLEMENT_OLECREATE_EX macro that ControlWizard includes 
in the property page class's CPP file.)
</P>

<P>Adding a property page is as simple as incrementing the BEGIN_PROPPAGEIDS count from 1 to 2 and adding a PROPPAGEID statement specifying the page's CLSID. The big question is, Where does that property page (and its CLSID) come from?
</P>

<P>There are two possible answers. The first is a stock property page. The 
system provides three stock property pages that ActiveX controls can use as they see fit: 
a color page for color properties, a picture page for picture properties, and a font 
page for font properties. Their CLSIDs are CLSID_CColorPropPage, 
CLSID_CPicturePropPage, and CLSID_CFontPropPage, respectively. The most useful of these is 
the stock color page (shown in Figure 21-7), which provides a standard user 
interface for editing any color properties implemented by your control. The following property page map includes a color page as well as the default property page:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
BEGIN_PROPPAGEIDS (CMyControl, 2)
    PROPPAGEID (CMyOlePropertyPage::guid)
    PROPPAGEID (CLSID_CColorPropPage)
END_PROPPAGEIDS (CMyControl)
</PRE></TD></TR></TABLE>
</P>

<P>
<A HREF="javascript:fullSize('F21mg07x.htm')"> <img src="images/F21mg07.JPG" width=404 height=260 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 21-7.</B> <I>The stock color property page.</I><!-- /CAPTION -->
</p>

<P>The second possibility is that the PROPPAGEID statement you add to the 
property page map identifies a custom property page that you created yourself. 
Although the process for creating a custom property page and wiring it into the control 
isn't difficult, it isn't automatic either. The basic procedure is to add a new dialog 
resource to the project, derive a class from 
<I>COlePropertyPage</I> and associate it with the 
dialog resource, add the page to the property page map, edit the control's string table 
resource, and make a couple of manual changes to the derived property page class. 
I won't provide a blow-by-blow here because the Visual C++ documentation 
already includes one. See &quot;ActiveX controls, adding property pages&quot; in the online help for details.
</P>


<A NAME="678"><H2>Adding Events</H2></A>

<P>Thanks to ClassWizard, adding a custom event to an ActiveX control built with 
MFC is no more difficult than adding a method or a property. Here's how you add a 
custom event:
</P>

<OL>
<P><LI>Invoke ClassWizard, and go to the ActiveX Events page. (See Figure 21-8.)
</LI></P>

<P>
<A HREF="javascript:fullSize('F21mg08x.htm')"> <img src="images/F21mg08.JPG" width=404 height=290 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 21-8.</B> <I>ClassWizard's ActiveX Events page.</I><!-- /CAPTION -->
</p>

<P><LI>Click the Add Event button.
</LI></P>

<P><LI>In the Add Event dialog box (shown in Figure 21-9), enter the event's name (External Name), the name of the member function that you'd like to call to fire the event (Internal Name), and, optionally, the arguments that accompany the event. Because an event is an Automation method implemented by a container, events can have parameter lists.
</LI></P>

<P>
<IMG SRC="images/F21mg09.GIF" width=347 height=301 BORDER=0>
</p><p>
<!-- CAPTION --><B>Figure 21-9.</B> <I>The Add Event dialog box.</I><!-- /CAPTION -->
</p>
</OL>

<P>For each custom event that you add to a control, ClassWizard adds a 
member function to the control class that you can use to fire events of that type. By 
default, the function name is 
<I>Fire</I> followed by the event name, but you can enter any name you like in the Add Event dialog box. These custom event-firing functions do little more than call 
<I>COleControl::FireEvent</I>, which uses a form of 
<I>COleDispatchDriver::InvokeHelper</I> to call Automation methods on the container's 
<I>IDispatch</I> pointer.
</P>

<P>Adding a stock event is as simple as selecting an event name from the list 
attached to the Add Event dialog box's External Name box. The following table 
lists the stock events you can choose from, their dispatch IDs, and the 
<I>COleControl</I> member functions used to fire them.
</P>

<p><b>Stock Events Implemented by <I>COleControl</I></b></p>

<P>
<TABLE cellpadding=5 width="95%">
<TR>
<TH VALIGN="TOP"><I>Event Name</I></TH>   
<TH VALIGN="TOP"><I>Dispatch ID</I></TH>    
<TH VALIGN="TOP"><I>Fire with</I></TH>
</TR>

<TR>
<TD VALIGN="TOP"><I>Click</I></TD>
<TD VALIGN="TOP">DISPID_CLICK</TD>
<TD VALIGN="TOP"><I>FireClick</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DblClick</I></TD>
<TD VALIGN="TOP">DISPID_DBLCLICK</TD>
<TD VALIGN="TOP"><I>FireDblClick</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>Error</I></TD>
<TD VALIGN="TOP">DISPID_ERROREVENT</TD>  
<TD VALIGN="TOP"><I>FireError</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>KeyDown</I></TD>    
<TD VALIGN="TOP">DISPID_KEYDOWN</TD>
<TD VALIGN="TOP"><I>FireKeyDown</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>KeyPress</I></TD>
<TD VALIGN="TOP">DISPID_KEYPRESS</TD>
<TD VALIGN="TOP"><I>FireKeyPress</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>KeyUp</I></TD>
<TD VALIGN="TOP">DISPID_KEYUP</TD>
<TD VALIGN="TOP"><I>FireKeyUp</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>MouseDown</I></TD>
<TD VALIGN="TOP">DISPID_MOUSEDOWN</TD>
<TD VALIGN="TOP"><I>FireMouseDown</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>MouseMove</I></TD>
<TD VALIGN="TOP">DISPID_MOUSEMOVE</TD>
<TD VALIGN="TOP"><I>FireMouseMove</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>MouseUp</I></TD>
<TD VALIGN="TOP">DISPID_MOUSEUP</TD>
<TD VALIGN="TOP"><I>FireMouseUp</I></TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>ReadyStateChange</I></TD> 
<TD VALIGN="TOP">DISPID_READYSTATECHANGE </TD>    
<TD VALIGN="TOP"><I>FireReadyStateChange</I></TD>
</TR>
</TABLE></P>

<P>The 
<I>Fire</I> functions in this table are inline functions that call 
<I>FireEvent</I> with the corresponding event's dispatch ID. With the exception of 
<I>FireReadyStateChange</I> and 
<I>FireError</I>, these functions are rarely used directly because when you add a 
<I>Click</I>, 
<I>DblClick</I>, 
<I>KeyDown</I>, 
<I>KeyUp</I>, 
<I>KeyPress</I>, 
<I>MouseDown</I>, 
<I>MouseUp</I>, or 
<I>MouseMove</I> event to a control, MFC automatically fires the corresponding event for you when a 
keyboard or mouse event occurs.
</P>

<P>Technically speaking, a COM interface that's implemented by a control 
container to allow a control to fire events is known as an 
<I>event interface</I>. Event interfaces are defined just like regular interfaces in both the Interface Definition Language (IDL) and the Object Description Language (ODL), but they're marked with the special 
<I>source</I> attribute. In addition to adding 
<I>Fire</I> functions for the custom events that you add to 
a control, ClassWizard also declares events in the project's ODL file. In ODL, an 
event is simply a method that belongs to an event interface. Here's how the event 
interface is defined in the ODL file for a control named MyControl that fires 
<I>PriceChanged</I> events:
</P>

<P><TABLE cellpadding=5 width="95%"><TR><TD><PRE>
[ uuid(D0C70155-41AA-11D2-AC8B-006008A8274D),
  helpstring(&quot;Event interface for MyControl Control&quot;) ]
dispinterface _DMyControlEvents
{
    properties:
        //  Event interface has no properties
    methods:
        [id(1)] void PriceChanged(CURRENCY price);
};

//  Class information for CMyControl

[ uuid(D0C70156-41AA-11D2-AC8B-006008A8274D),
  helpstring(&quot;MyControl Control&quot;), control ]
coclass MyControl
{
    [default] dispinterface _DMyControl;
    [default, source] dispinterface _DMyControlEvents;
};
</PRE></TD></TR></TABLE>
</P>

<P>The 
<I>dispinterface</I> block defines the interface itself; 
<I>coclass</I> identifies the interfaces that the control supports. In this example, 
<I>_DMyControl</I> is the 
<I>IDispatch</I> interface through which the control's methods and properties are accessed, and 
<I>_DMyControlEvents</I> is the 
<I>IDispatch</I> interface for events. The leading underscore in the 
interface names is a convention COM programmers often use to denote internal interfaces. 
The capital D following the underscore indicates that these are dispinterfaces rather 
than conventional COM interfaces.
</P>


<A NAME="679"><H2>Event Maps</H2></A>

<P>Besides adding 
<I>Fire</I> functions and modifying the control's ODL file when events are added, ClassWizard also adds one entry per event (stock or custom) to the control's event map. An 
<I>event map</I> is a table that begins with BEGIN_EVENT_MAP and ends with END_EVENT_MAP. Statements in between describe to MFC what events the control is capable of firing and what functions are called to fire them. An EVENT_CUSTOM macro declares a custom event, and EVENT_STOCK macros declare stock events. The following event map declares a custom event named 
<I>PriceChanged</I> and the stock event 
<I>Click</I>:
</P>

<P><TABLE cellpadding=5 width="95%"><TR><TD><PRE>
BEGIN_EVENT_MAP(CMyControlCtrl, COleControl)
    EVENT_CUSTOM(&quot;PriceChanged&quot;, FirePriceChanged, VTS_CY)
    EVENT_STOCK_CLICK()
END_EVENT_MAP()
</PRE></TD></TR></TABLE>
</P>

<P>MFC uses event maps to determine whether to fire stock events at certain junctures in a control's lifetime. For example, 
<I>COleControl</I>'s WM_LBUTTONUP handler fires a 
<I>Click</I> event if the event map contains an EVENT_STOCK_CLICK entry. MFC 
currently doesn't use the EVENT_CUSTOM entries found in a control's event map.
</P>


<A NAME="680"><H2>Building an ActiveX Control</H2></A>

<P>Now that you understand the basics of the ActiveX control architecture and 
MFC's support for the same, it's time to write an ActiveX control. The control that you'll 
build is the calendar control featured in Figure 21-1. It supports the following 
methods, properties, and events:
</P>

<P>
<TABLE cellpadding=5 width="100%">
<TR>
<TH VALIGN="TOP"><I>Name</I></TH>    
<TH VALIGN="TOP"><I>Description</I></TH>
</TR>
<TR><TD COLSPAN="2"><B>Methods</B></TD></TR>

<TR>
<TD VALIGN="TOP"><I>GetDate</I></TD>    
<TD VALIGN="TOP">Returns the calendar's current date</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>SetDate</I></TD>
<TD VALIGN="TOP">Sets the calendar's current date<BR>
</TD>
</TR>
</TABLE>
<HR>
<TABLE cellpadding=5 width="100%">

<TR><TD COLSPAN="2"><B>Properties</B></TD></TR>
<TR>
<TD VALIGN="TOP"><I>BackColor</I> </TD>    
<TD VALIGN="TOP">Controls the calendar's background color</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>RedSundays</I></TD>  
<TD VALIGN="TOP">Determines whether Sundays are highlighted in red</TD>
</TR>
</TABLE>
<HR>
<TABLE cellpadding=5 width="100%">
<TR><TD COLSPAN="2"><B>Events</B></TD></TR>

<TR>
<TD VALIGN="TOP"><I>NewDay</I></TD>    
<TD VALIGN="TOP">Fired when a new date is selected</TD>
</TR>

</TABLE>
</P>

<P>Because Calendar is a full-blown ActiveX control, it can be used in Web pages and in applications written in ActiveX-aware languages such as Visual Basic and Visual C++. Following is a step-by-step account of how to build it.
</P>

<OL>
<P><LI>Create a new MFC ActiveX ControlWizard project named Calendar. 
Accept the default options in ControlWizard's Step 1 and Step 2 dialog boxes.</LI></P>

<P><LI>Add three int member variables named 
<I>m_nYear</I>, 
<I>m_nMonth</I>, and 
<I>m_nDay</I> to 
<I>CCalendarCtrl</I>. 
<I>CCalendarCtrl</I> is the class that represents the control. The member variables that you added will store the control's current date.</LI></P>

<P><LI>Add the following code to 
<I>CCalendarCtrl</I>'s constructor to initialize the member variables:</LI></P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CTime time = CTime::GetCurrentTime ();
m_nYear = time.GetYear ();
m_nMonth = time.GetMonth ();
m_nDay = time.GetDay ();
</PRE></TD></TR></TABLE>
</P>


<P><LI>Add the following variable declaration to the 
<I>CCalendarCtrl</I> in CalendarCtrl.h:
</LI></P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
static const int m_nDaysPerMonth[];
</PRE></TD></TR></TABLE>
</P>

<P>Then add these lines to CalendarCtrl.cpp to initialize the 
<I>m_nDaysPerMonth</I> array with the number of days in each month:
</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
const int CCalendarCtrl::m_nDaysPerMonth[] = {
    31,        // January
    28,        // February
    31,        // March
    30,        // April
    31,        // May
    30,        // June
    31,        // July
    31,        // August
    30,        // September
    31,        // October
    30,        // November
    31,        // December
};
</PRE></TD></TR></TABLE>
</P>

<P><LI>Add the following protected member function to 
<I>CCalendarCtrl</I>:
</LI></P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
BOOL CCalendarCtrl::LeapYear(int nYear)
{
    return (nYear % 4 == 0) ^ (nYear % 400 == 0) ^ 
        (nYear % 100 == 0);
}
</PRE></TD></TR></TABLE>
</P>
</OL>
<P>This function returns a nonzero value if 
<I>nYear</I> is a leap year, or 0 if it isn't. The rule is that 
<I>nYear</I> is a leap year if it's evenly divisible by 4, 
<I>unless</I> it's divisible by 100 but not by 400.
</P>
<OL START="6">
<P><LI>Add a 
<I>BackColor</I> property to the control by clicking the Add Property button on ClassWizard's Automation page and selecting 
<I>BackColor</I> from the External Name list in the Add Property dialog box. (See Figure 21-10.)
</LI></P>

<P>
<A HREF="javascript:fullSize('F21mg10x.htm')"> <img src="images/F21mg10.JPG" width=404 height=320 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 21-10.</B> <I>Adding the BackColor property.</I><!-- /CAPTION -->
</p>

<P><LI>Modify the property page map in CalendarCtrl.cpp as shown below to add a stock color page to the control's property sheet. Users will use this property page to customize the control's background color:
</LI></P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
BEGIN_PROPPAGEIDS (CCalendarCtrl, 2)
    PROPPAGEID (CCalendarCtrl::guid)
    PROPPAGEID (CLSID_CColorPropPage)
END_PROPPAGEIDS (CCalendarCtrl)
</PRE></TD></TR></TABLE>
</P>


<P><LI>Fill in the Add Property dialog box as shown in Figure 21-11 to add a custom member variable property named 
<I>RedSundays</I>. In response, ClassWizard will add a member variable named 
<I>m_redSundays</I> (which you can then change to 
<I>m_bRedSundays</I>) and a notification function named 
<I>OnRedSundaysChanged</I> to the control class. Follow up by adding the following statement to the notification function so that the control will automatically repaint when the property value changes:
</LI></P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
InvalidateControl ();
</PRE></TD></TR></TABLE>
</P>

<P>
<A HREF="javascript:fullSize('F21mg11x.htm')"> <img src="images/F21mg11.JPG" width=404 height=320 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 21-11.</B> <I>Adding the RedSundays property.</I><!-- /CAPTION -->
</p>

<P><LI>Add the following statement to 
<I>CCalendarCtrl::DoPropExchange</I> to make 
<I>RedSundays</I> persistent and to assign it a default value equal to TRUE:
</LI></P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
PX_Bool (pPX, _T (&quot;RedSundays&quot;), m_bRedSundays, TRUE);
</PRE></TD></TR></TABLE>
</P>

<P><LI>Switch to ResourceView, and add a checkbox control to the dialog resource whose ID is IDD_PROPPAGE_CALENDAR. (See Figure 21-12.) This is the resource that represents the control's property page. Assign the check box the ID IDC_REDSUNDAYS and the text &quot;Show Sundays in &amp;red.&quot;
</LI></P>

<P>
<IMG SRC="images/F21mg12.GIF" width=374 height=101 BORDER=0>
</p><p>
<!-- CAPTION --><B>Figure 21-12.</B> <I>The modified property page.</I><!-- /CAPTION -->
</p>

<P><LI>On ClassWizard's Member Variables page, select the property page's class name (
<I>CCalendarPropPage</I>) in the Class Name box, click the Add Variable button, and fill in the Add Member Variable dialog box as shown in Figure 21-13. This will connect the check box control to the property named <I>RedSundays</I>.
</LI></P>

<P>
<IMG SRC="images/F21mg13.GIF" width=320 height=288 BORDER=0>
</p><p>
<!-- CAPTION --><B>Figure 21-13.</B> <I>Associating the check box with RedSundays.</I><!-- /CAPTION -->
</p>

<P><LI>Implement the control's 
<I>OnDraw</I> function. See the CalendarCtrl.cpp listing in Figure 21-18 for the finished code. Notice that 
<I>OnDraw</I> uses 
<I>GetBackColor</I> to retrieve the value of the 
<I>BackColor</I> property and then uses that value to paint the control's background. Also notice that it checks the value of 
<I>m_bRedSundays</I> and sets the text color to red before drawing a date corresponding to a Sunday if 
<I>m_bRedSundays</I> is nonzero. This explains how the two properties that you added 
affect the control's appearance.
</LI></P>


<P><LI>Add methods named 
<I>GetDate</I> and 
<I>SetDate</I>. To add a method, click the Add Method button on ClassWizard's Automation page. Pick DATE as <I>GetDate</I>'s return type (as in Figure 21-14) and BOOL as 
<I>SetDate</I>'s return type. Include three parameters in 
<I>SetDate</I>'s parameter list: a short named 
<I>nYear</I>, a short named 
<I>nMonth</I>, and a short named 
<I>nDay</I> (as in Figure 21-15). See Figure 21-18 for the method implementations.
</LI></P>

<P>
<IMG SRC="images/F21mg14.GIF" width=357 height=344 BORDER=0>
</p><p>
<!-- CAPTION --><B>Figure 21-14.</B> <I>Adding the GetDate method.</I><!-- /CAPTION -->
</p>

<P>
<IMG SRC="images/F21mg15.GIF" width=357 height=344 BORDER=0>
</p><p>
<!-- CAPTION --><B>Figure 21-15.</B> <I>Adding the SetDate method.</I><!-- /CAPTION -->
</p>

<P><LI>Add a 
<I>NewDay</I> event to the control by clicking the Add Event button on ClassWizard's ActiveX Events page and filling in the Add Event dialog box as shown in Figure 21-16.
</LI></P>

<P>
<IMG SRC="images/F21mg16.GIF" width=347 height=301 BORDER=0>
</p><p>
<!-- CAPTION --><B>Figure 21-16.</B> <I> Adding the NewDay event.</I><!-- /CAPTION -->
</p>

<P><LI>Add a WM_LBUTTONDOWN handler to the control class that sets 
the current date to the date that was clicked on the calendar. You add a message handler to a control the same way you add a message handler to a conventional MFC application. Refer to Figure 21-18 for the 
implementation of 
<I>OnLButtonDown</I>. Notice the call to 
<I>FireNewDay</I> near the end of the function.
</LI></P>

<P><LI>In ResourceView, customize the control's toolbar button bitmap to look like the one shown in Figure 21-17. You'll find the button bitmap under the project's list of bitmap resources. The bitmap's resource ID is IDB_CALENDAR.
</LI></P>

<P>
<IMG SRC="images/F21mg17.GIF" width=97 height=91 BORDER=0>
</p><p>
<!-- CAPTION --><B>Figure 21-17.</B> <I>The calendar control's toolbar button bitmap.</I><!-- /CAPTION -->
</p>

<P><LI>Build the control.
</LI></P>
</OL>

<P>With that, you've just built your first ActiveX control. It probably didn't 
seem very complicated, but rest assured that's only because of the thousands of lines 
of code MFC supplied to implement all those COM interfaces. Selected portions of 
the finished source code appear in Figure 21-18.
</P>

<P><B>Figure 21-18.</B> <I>The calendar control's source code.</I></P>

<P><TABLE cellpadding=5 width="95%"><TR><TD VALIGN="TOP">

<A NAME="681"><H3>CalendarCtl.h</H3></A>

<PRE>
#if !defined(
    AFX_CALENDARCTL_H__68932D29_CFE2_11D2_9282_00C04F8ECF0C__INCLUDED_)
#define AFX_CALENDARCTL_H__68932D29_CFE2_11D2_9282_00C04F8ECF0C__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

// CalendarCtl.h : Declaration of the CCalendarCtrl ActiveX Control class.
///////////////////////////////////////////////////////////////////////////
// CCalendarCtrl : See CalendarCtl.cpp for implementation.

class CCalendarCtrl : public COleControl
{
    DECLARE_DYNCREATE(CCalendarCtrl)

// Constructor
public:
    CCalendarCtrl();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CCalendarCtrl)
    public:
    virtual void OnDraw(CDC* pdc, const CRect&amp; rcBounds, 
        const CRect&amp; rcInvalid);
    virtual void DoPropExchange(CPropExchange* pPX);
    virtual void OnResetState();
    //}}AFX_VIRTUAL

// Implementation
protected:
    BOOL LeapYear(int nYear);
    static const int m_nDaysPerMonth[];
    int m_nDay;
    int m_nMonth;
    int m_nYear;
    ~CCalendarCtrl();

    DECLARE_OLECREATE_EX(CCalendarCtrl)    // Class factory and guid
    DECLARE_OLETYPELIB(CCalendarCtrl)      // GetTypeInfo
    DECLARE_PROPPAGEIDS(CCalendarCtrl)     // Property page IDs
    DECLARE_OLECTLTYPE(CCalendarCtrl)      // Type name and misc status

// Message maps
    //{{AFX_MSG(CCalendarCtrl)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

// Dispatch maps
    //{{AFX_DISPATCH(CCalendarCtrl)
    BOOL m_bRedSundays;
    afx_msg void OnRedSundaysChanged();
    afx_msg DATE GetDate();
    afx_msg BOOL SetDate(short nYear, short nMonth, short nDay);
    //}}AFX_DISPATCH
    DECLARE_DISPATCH_MAP()

    afx_msg void AboutBox();

// Event maps
    //{{AFX_EVENT(CCalendarCtrl)
    void FireNewDay(short nDay)
        {FireEvent(eventidNewDay,EVENT_PARAM(VTS_I2), nDay);}
    //}}AFX_EVENT
    DECLARE_EVENT_MAP()

// Dispatch and event IDs
public:
    enum {
    //{{AFX_DISP_ID(CCalendarCtrl)
    dispidRedSundays = 1L,
    dispidGetDate = 2L,
    dispidSetDate = 3L,
    eventidNewDay = 1L,
    //}}AFX_DISP_ID
    };
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//     AFX_CALENDARCTL_H__68932D29_CFE2_11D2_9282_00C04F8ECF0C__INCLUDED)
</PRE>
</TD>
</TR>
</TABLE>

<P><TABLE cellpadding=5 width="95%"><TR><TD VALIGN="TOP">

<H3>CalendarCtl.cpp</H3>
<PRE>
// CalendarCtl.cpp : Implementation of the 
// CCalendarCtrl ActiveX Control class.

#include &quot;stdafx.h&quot;
#include &quot;Calendar.h&quot;
#include &quot;CalendarCtl.h&quot;
#include &quot;CalendarPpg.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CCalendarCtrl, COleControl)

const int CCalendarCtrl::m_nDaysPerMonth[] = {
    31,        // January
    28,        // February
    31,        // March
    30,        // April
    31,        // May
    30,        // June
    31,        // July
    31,        // August
    30,        // September
    31,        // October
    30,        // November
    31,        // December
};

///////////////////////////////////////////////////////////////////////////
// Message map

BEGIN_MESSAGE_MAP(CCalendarCtrl, COleControl)
    //{{AFX_MSG_MAP(CCalendarCtrl)
    ON_WM_LBUTTONDOWN()
    //}}AFX_MSG_MAP
    ON_OLEVERB(AFX_IDS_VERB_PROPERTIES, OnProperties)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// Dispatch map

BEGIN_DISPATCH_MAP(CCalendarCtrl, COleControl)
    //{{AFX_DISPATCH_MAP(CCalendarCtrl)
    DISP_PROPERTY_NOTIFY(CCalendarCtrl, &quot;RedSundays&quot;, m_bRedSundays, 
        OnRedSundaysChanged, VT_BOOL)
    DISP_FUNCTION(CCalendarCtrl, &quot;GetDate&quot;, GetDate, VT_DATE, VTS_NONE)
    DISP_FUNCTION(CCalendarCtrl, &quot;SetDate&quot;, SetDate, VT_BOOL, 
        VTS_I2 VTS_I2 VTS_I2)
    DISP_STOCKPROP_BACKCOLOR()
    //}}AFX_DISPATCH_MAP
    DISP_FUNCTION_ID(CCalendarCtrl, &quot;AboutBox&quot;, DISPID_ABOUTBOX, 
        AboutBox, VT_EMPTY, VTS_NONE)
END_DISPATCH_MAP()

///////////////////////////////////////////////////////////////////////////
// Event map

BEGIN_EVENT_MAP(CCalendarCtrl, COleControl)
    //{{AFX_EVENT_MAP(CCalendarCtrl)
    EVENT_CUSTOM(&quot;NewDay&quot;, FireNewDay, VTS_I2)
    //}}AFX_EVENT_MAP
END_EVENT_MAP()

///////////////////////////////////////////////////////////////////////////
// Property pages

// TODO: Add more property pages as needed.  
// Remember to increase the count!
BEGIN_PROPPAGEIDS(CCalendarCtrl, 2)
    PROPPAGEID(CCalendarPropPage::guid)
    PROPPAGEID (CLSID_CColorPropPage)
END_PROPPAGEIDS(CCalendarCtrl)

///////////////////////////////////////////////////////////////////////////
// Initialize class factory and guid

IMPLEMENT_OLECREATE_EX(CCalendarCtrl, &quot;CALENDAR.CalendarCtrl.1&quot;,
    0xed780d6b, 0xcc9f, 0x11d2, 0x92, 0x82, 0, 0xc0, 0x4f, 0x8e, 0xcf, 0xc)

///////////////////////////////////////////////////////////////////////////
// Type library ID and version

IMPLEMENT_OLETYPELIB(CCalendarCtrl, _tlid, _wVerMajor, _wVerMinor)

///////////////////////////////////////////////////////////////////////////
// Interface IDs

const IID BASED_CODE IID_DCalendar =
        { 0x68932d1a, 0xcfe2, 0x11d2, 
            { 0x92, 0x82, 0, 0xc0, 0x4f, 0x8e, 0xcf, 0xc } };
const IID BASED_CODE IID_DCalendarEvents =
        { 0x68932d1b, 0xcfe2, 0x11d2, 
            { 0x92, 0x82, 0, 0xc0, 0x4f, 0x8e, 0xcf, 0xc } };

///////////////////////////////////////////////////////////////////////////
// Control type information

static const DWORD BASED_CODE _dwCalendarOleMisc =
    OLEMISC_ACTIVATEWHENVISIBLE &#339;
    OLEMISC_SETCLIENTSITEFIRST &#339;
    OLEMISC_INSIDEOUT &#339;
    OLEMISC_CANTLINKINSIDE &#339;
    OLEMISC_RECOMPOSEONRESIZE;

IMPLEMENT_OLECTLTYPE(CCalendarCtrl, IDS_CALENDAR, _dwCalendarOleMisc)

///////////////////////////////////////////////////////////////////////////
// CCalendarCtrl::CCalendarCtrlFactory::UpdateRegistry -
// Adds or removes system registry entries for CCalendarCtrl

BOOL CCalendarCtrl::CCalendarCtrlFactory::UpdateRegistry(BOOL bRegister)
{
    // TODO: Verify that your control follows apartment-model 
    // threading rules. Refer to MFC TechNote 64 for more information.
    // If your control does not conform to the apartment-model rules, then
    // you must modify the code below, changing the 6th parameter from
    // afxRegApartmentThreading to 0.

    if (bRegister)
        return AfxOleRegisterControlClass(
            AfxGetInstanceHandle(),
            m_clsid,
            m_lpszProgID,
            IDS_CALENDAR,
            IDB_CALENDAR,
            afxRegApartmentThreading,
            _dwCalendarOleMisc,
            _tlid,
            _wVerMajor,
            _wVerMinor);
    else
        return AfxOleUnregisterClass(m_clsid, m_lpszProgID);
}

///////////////////////////////////////////////////////////////////////////
// CCalendarCtrl::CCalendarCtrl - Constructor

CCalendarCtrl::CCalendarCtrl()
{
    InitializeIIDs(&amp;IID_DCalendar, &amp;IID_DCalendarEvents);

    CTime time = CTime::GetCurrentTime ();
    m_nYear = time.GetYear ();
    m_nMonth = time.GetMonth ();
    m_nDay = time.GetDay ();
}

///////////////////////////////////////////////////////////////////////////
// CCalendarCtrl::~CCalendarCtrl - Destructor

CCalendarCtrl::~CCalendarCtrl()
{
    // TODO: Cleanup your control's instance data here.
}

///////////////////////////////////////////////////////////////////////////
// CCalendarCtrl::OnDraw - Drawing function

void CCalendarCtrl::OnDraw(
            CDC* pdc, const CRect&amp; rcBounds, const CRect&amp; rcInvalid)
{
    //
    // Paint the control's background.
    //
    CBrush brush (TranslateColor (GetBackColor ()));
    pdc-&gt;FillRect (rcBounds, &amp;brush);

    //
    // Compute the number of days in the month, which day of the week
    // the first of the month falls on, and other information needed to
    // draw the calendar.
    //
    int nNumberOfDays = m_nDaysPerMonth[m_nMonth - 1];
    if (m_nMonth == 2 &amp;&amp; LeapYear (m_nYear))
        nNumberOfDays++;

    CTime time (m_nYear, m_nMonth, 1, 12, 0, 0);
    int nFirstDayOfMonth = time.GetDayOfWeek ();
    int nNumberOfRows = (nNumberOfDays + nFirstDayOfMonth + 5) / 7;

    int nCellWidth = rcBounds.Width () / 7;
    int nCellHeight = rcBounds.Height () / nNumberOfRows;

    int cx = rcBounds.left;
    int cy = rcBounds.top;

    //
    // Draw the calendar rectangle.
    //
    CPen* pOldPen = (CPen*) pdc-&gt;SelectStockObject (BLACK_PEN);
    CBrush* pOldBrush = (CBrush*) pdc-&gt;SelectStockObject (NULL_BRUSH);

    pdc-&gt;Rectangle (rcBounds.left, rcBounds.top,
        rcBounds.left + (7 * nCellWidth),
        rcBounds.top + (nNumberOfRows * nCellHeight));
    //
    // Draw rectangles representing the days of the month.
    //
    CFont font;
    font.CreatePointFont (80, _T (&quot;MS Sans Serif&quot;));
    CFont* pOldFont = pdc-&gt;SelectObject (&amp;font);

    COLORREF clrOldTextColor = pdc-&gt;SetTextColor (RGB (0, 0, 0));
    int nOldBkMode = pdc-&gt;SetBkMode (TRANSPARENT);

    for (int i=0; i&lt;nNumberOfDays; i++) {
        int nGridIndex = i + nFirstDayOfMonth - 1;
        int x = ((nGridIndex % 7) * nCellWidth) + cx;
        int y = ((nGridIndex / 7) * nCellHeight) + cy;
        CRect rect (x, y, x + nCellWidth, y + nCellHeight);

        if (i != m_nDay - 1) {
            pdc-&gt;Draw3dRect (rect, RGB (255, 255, 255), 
                RGB (128, 128, 128));
            pdc-&gt;SetTextColor (RGB (0, 0, 0));
        }
        else {
            pdc-&gt;SelectStockObject (NULL_PEN);
            pdc-&gt;SelectStockObject (GRAY_BRUSH);
            pdc-&gt;Rectangle (rect);
            pdc-&gt;Draw3dRect (rect, RGB (128, 128, 128), 
                RGB (255, 255, 255));
            pdc-&gt;SetTextColor (RGB (255, 255, 255));
        }

        CString string;
        string.Format (_T (&quot;%d&quot;), i + 1);
        rect.DeflateRect (nCellWidth / 8, nCellHeight / 8);

        if (m_bRedSundays &amp;&amp; nGridIndex % 7 == 0)
            pdc-&gt;SetTextColor (RGB (255, 0, 0));

        pdc-&gt;DrawText (string, rect, DT_SINGLELINE &#339; DT_LEFT &#339; DT_TOP);
    }

    //
    // Clean up and exit.
    //
    pdc-&gt;SetBkMode (nOldBkMode);
    pdc-&gt;SetTextColor (clrOldTextColor);
    pdc-&gt;SelectObject (pOldFont);
    pdc-&gt;SelectObject (pOldBrush);
    pdc-&gt;SelectObject (pOldPen);
}

///////////////////////////////////////////////////////////////////////////
// CCalendarCtrl::DoPropExchange - Persistence support

void CCalendarCtrl::DoPropExchange(CPropExchange* pPX)
{
    ExchangeVersion(pPX, MAKELONG(_wVerMinor, _wVerMajor));
    COleControl::DoPropExchange(pPX);
    PX_Bool (pPX, _T (&quot;RedSundays&quot;), m_bRedSundays, TRUE);
}

///////////////////////////////////////////////////////////////////////////
// CCalendarCtrl::OnResetState - Reset control to default state

void CCalendarCtrl::OnResetState()
{
    COleControl::OnResetState(); // Resets defaults found in DoPropExchange

    // TODO: Reset any other control state here.
}

///////////////////////////////////////////////////////////////////////////
// CCalendarCtrl::AboutBox - Display an &quot;About&quot; box to the user

void CCalendarCtrl::AboutBox()
{
    CDialog dlgAbout(IDD_ABOUTBOX_CALENDAR);
    dlgAbout.DoModal();
}

///////////////////////////////////////////////////////////////////////////
// CCalendarCtrl message handlers

BOOL CCalendarCtrl::LeapYear(int nYear)
{
    return (nYear % 4 == 0) ^ (nYear % 400 == 0) ^ (nYear % 100 == 0);
}

void CCalendarCtrl::OnRedSundaysChanged() 
{
    InvalidateControl ();
    SetModifiedFlag();
}

DATE CCalendarCtrl::GetDate() 
{
    COleDateTime date (m_nYear, m_nMonth, m_nDay, 12, 0, 0);
    return (DATE) date;
}

BOOL CCalendarCtrl::SetDate(short nYear, short nMonth, short nDay) 
{
    //
    // Make sure the input date is valid.
    //
    if (nYear &lt; 1970 &#339;&#339; nYear &gt; 2037)
        return FALSE;

    if (nMonth &lt; 1 &#339;&#339; nMonth &gt; 12)
        return FALSE;

    int nNumberOfDays = m_nDaysPerMonth[m_nMonth - 1];
    if (nMonth == 2 &amp;&amp; LeapYear (nYear))
        nNumberOfDays++;

    if (nDay &lt; 1 &#339;&#339; nDay &gt; nNumberOfDays)
        return FALSE;

    //
    // Update the date, repaint the control, and fire a NewDay event.
    //
    m_nYear = nYear;
    m_nMonth = nMonth;
    m_nDay = nDay;
    InvalidateControl ();
    return TRUE;
}

void CCalendarCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
{
    int nNumberOfDays = m_nDaysPerMonth[m_nMonth - 1];
    if (m_nMonth == 2 &amp;&amp; LeapYear (m_nYear))
        nNumberOfDays++;

    CTime time (m_nYear, m_nMonth, 1, 12, 0, 0);
    int nFirstDayOfMonth = time.GetDayOfWeek ();
    int nNumberOfRows = (nNumberOfDays + nFirstDayOfMonth + 5) / 7;

    CRect rcClient;
    GetClientRect (&amp;rcClient);
    int nCellWidth = rcClient.Width () / 7;
    int nCellHeight = rcClient.Height () / nNumberOfRows;

    for (int i=0; i&lt;nNumberOfDays; i++) {
        int nGridIndex = i + nFirstDayOfMonth - 1;
        int x = rcClient.left + (nGridIndex % 7) * nCellWidth;
        int y = rcClient.top + (nGridIndex / 7) * nCellHeight;
        CRect rect (x, y, x + nCellWidth, y + nCellHeight);

        if (rect.PtInRect (point)) {
            m_nDay = i + 1;
            FireNewDay (m_nDay);
            InvalidateControl ();
        }
    }    
    COleControl::OnLButtonDown(nFlags, point);
}
</PRE></TD></TR></TABLE>
</P>


<A NAME="682"><H2>Testing and Debugging an ActiveX Control</H2></A>

<P>Now that you've built the control, you'll want to test it, too. Visual C++ comes 
with the perfect tool for testing ActiveX controls: the ActiveX Control Test Container. 
You can start it from Visual C++'s Tools menu or by launching Tstcon32.exe. Once 
the ActiveX Control Test Container is running, go to its Edit menu, select the Insert 
New Control command, and select Calendar Control from the Insert Control dialog box 
to insert your control into the test container, as shown in Figure 21-19.
</P>

<P>
<A HREF="javascript:fullSize('F21mg19x.htm')"> <img src="images/F21mg19.JPG" width=404 height=331 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 21-19.</B> <I>The ActiveX Control Test Container.</I><!-- /CAPTION -->
</p>

<P>Initially, the control's background will probably be white because MFC's implementation of the stock property
<I>BackColor</I> defaults to the container's ambient background color. This presents a wonderful opportunity to test the 
<I>BackColor</I> property you added to the control. With the control selected in the test container window, select Properties from the Edit menu. The control's property sheet will be displayed. (See Figure 21-20.) 
Go to the Colors page, and select light gray as the background color. Then click 
Apply. The control should turn light gray. Go back to the property sheet's General page 
and toggle Show Sundays In Red on and off a time or two. The control should 
repaint itself each time you click the Apply button. Remember the 
<I>OnRedSundaysChanged</I> notification function in which you inserted a call to 
<I>InvalidateControl</I>? It's that call that causes the control to update when the property value changes.</P>

<P>
<A HREF="javascript:fullSize('F21mg20x.htm')"> <img src="images/F21mg20.JPG" width=404 height=260 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 21-20.</B> <I>The calendar control's property sheet.</I><!-- /CAPTION -->
</p>

<P>You can test a control's methods in the ActiveX Control Test Container, too. 
To try it, select the Invoke Methods command from the Control menu. The Invoke 
Methods dialog box, which is pictured in Figure 21-21, knows which methods the 
control implements because it read the control's type information. (That type information 
was generated from the control's ODL file and linked into the control's OCX as a 
binary resource.) To call a method, select the method by name in the Method Name 
box, enter parameter values (if applicable) in the Parameters box, and click the 
Invoke button. The method's return value will appear in the Return Value box. 
Incidentally, properties show up in the Invoke Methods dialog box with PropGet and PropPut 
labels attached to them. A PropGet method reads a property value, and a PropPut 
method writes it.</P>

<P>
<IMG SRC="images/F21mg21.GIF" width=401 height=392 BORDER=0>
</p><p>
<!-- CAPTION --><B>Figure 21-21.</B> <I>The ActiveX Control Test Container's Invoke Methods dialog box.</I><!-- /CAPTION -->
</p>

<P>The ActiveX Control Test Container also lets you test a control's events. To 
demonstrate, choose the Logging command from the Options menu and make sure 
Log To Output Window is selected. Then click a few dates in the calendar. A 
<I>NewDay</I> event should appear in the output window with each click, as in Figure 21-22. 
The event is fired because you included a call to 
<I>FireNewDay</I> in the control's 
<I>OnLButtonDown</I> function.</P>


<P>
<A HREF="javascript:fullSize('F21mg22x.htm')"> <img src="images/F21mg22.JPG" width=404 height=331 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 21-22.</B> <I>Events are reported in the ActiveX Control Test Container's output window.</I><!-- /CAPTION -->
</p>

<P>If your control uses any of the container's ambient properties, you can customize those properties to see how the control reacts. To change an ambient property, use the Ambient Properties command in the Container menu.
</P>

<P>
What happens if your control doesn't behave as expected and you need to debug it? Fortunately, you can do that, too. Suppose you want to set a breakpoint in your code, see it hit, and single-step through the code. It's easy. Just open the control project in Visual C++ and set the breakpoint. Then go to the Build menu and select Start Debug-Go. When Visual C++ asks you for an executable file name, click the arrow next to the edit control and select ActiveX Control Test Container. Insert the control into the container and do something to cause the breakpoint to be hit. That should pop you into the Visual C++ debugger with the arrow on the instruction at the breakpoint. The same debugging facilities that Visual C++ places at your disposal for 
debugging regular MFC applications are available for debugging controls, too.</P>


<A NAME="683"><H2>Registering an ActiveX Control</H2></A>

<P>Like any COM object, an ActiveX control can't be used unless it is registered on the host system. Registering an ActiveX control means adding entries to the registry identifying the control's CLSID, the DLL that houses the control, and other information. When you build an ActiveX control with Visual C++, the control is automatically registered as part of the build process. If you give the control to another user, that user will need to register it on his or her system before it can be used. Here are two ways to register a control on another system.
</P>

<P>The first way is to provide a setup program that registers the control 
programmatically. Because an OCX is a self-registering in-proc COM server, the setup 
program can load the OCX as if it were an ordinary DLL, find the address of its 
<I>DllRegisterServer</I> function, and call the function. 
<I>DllRegisterServer</I>, in turn, will register any 
and all of the controls in the OCX. The following code demonstrates how this is done 
if the OCX is named Calendar.ocx:</P>


<P><TABLE cellpadding=5 width="95%"><TR><TD><PRE>
HINSTANCE hOcx = ::LoadLibrary (_T (&quot;Calendar.ocx&quot;));
if (hOcx != NULL) {
    FARPROC lpfn = ::GetProcAddress (hOcx, _T (&quot;DllRegisterServer&quot;));
    if (lpfn != NULL)
        (*lpfn) ();    // Register the control(s).
    ::FreeLibrary (hOcx);
}
</PRE></TD></TR></TABLE>
</P>

<P>To implement an uninstall feature, use the same code but change the second parameter passed to 
<I>::GetProcAddress</I> from &quot;DllRegisterServer&quot; to &quot;DllUnregisterServer.&quot;
</P>

<P>To register an ActiveX control on someone else's system without writing a 
setup program, use the Regsvr32 utility that comes with Visual C++. If Calendar.ocx is 
in the current directory, typing the following command into a command prompt 
window will register the OCX's controls:</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
Regsvr32 Calendar.ocx
</PRE></TD></TR></TABLE>
</P>

<P>By the same token, passing a /U switch to Regsvr32 unregisters the controls in 
an OCX:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
Regsvr32 /U Calendar.ocx
</PRE></TD></TR></TABLE>
</P>

<P>Regsvr32 isn't a tool you should foist on end users, but it's a handy utility to have when testing and debugging a control prior to deployment.
</P>


</BODY>
</HTML>





