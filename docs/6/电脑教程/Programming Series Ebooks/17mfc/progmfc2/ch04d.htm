<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Menu Magic</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04c.htm", "ch04e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="128"><H1>Menu Magic</H1></A>

<P>The first half of this chapter covered probably 80 percent of everything you'll 
ever need to know about menus. Occasionally, however, you'll need to go beyond 
the basics and do something extra. The following &quot;something extras&quot; are discussed 
in the second half of the chapter:
</p>

<UL>
<P>
<LI>Techniques for creating and modifying menus on the fly
</li>
</p>

<P>
<LI>The system menu and methods for customizing it
</li>
</P>

<P><LI>Menus that display graphics instead of text (owner-draw menus)
</li>
</P>

<P><LI>Cascading menus
</li>
</P>

<P><LI>Context menus
</li>
</P>
</ul>

<P>We'll close out this chapter by revising the Shapes application to include both an 
owner-draw Color menu and a right-click context menu.

</P>


<A NAME="129"><H2>Creating Menus Programmatically</H2></A>

<P>Loading a menu resource from your application's EXE file isn't the only way to 
create a menu. You can also do it programmatically using MFC's 
<I>  CMenu</I> class and its member functions. We've yet to explore 
<I>  CMenu</I> in any depth because basic menu support doesn't require a 
<I>  CMenu</I>. <I>  CMenu</I> comes in handy when you want to create 
a menu on the fly, perhaps from information that isn't available until run time, or 
when you want to modify an existing menu (a subject we'll cover in the next section). 
In situations such as these, <I>  CMenu</I> will be your best friend.
</p>


You create menus programmatically using a combination of 
<I>  CMenu::CreateMenu</I>, <I>  CMenu::CreatePopupMenu</I>, and 
<I>  CMenu::AppendMenu</I>. You build a top-level 
menu and its submenus by creating a menu with 
<I>  CreateMenu</I>, creating the submenus with 
<I>  CreatePopupMenu</I>, and attaching the submenus to the top-level menu with <I>  AppendMenu</I>. The following program listing creates a menu identical to the one featured 
in the Shapes application and attaches it to the frame window. The only difference 
is that the application, not the resource editor, creates this menu:

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMenu menuMain;
menuMain.CreateMenu ();

CMenu menuPopup;
menuPopup.CreatePopupMenu ();
menuPopup.AppendMenu (MF_STRING, ID_FILE_EXIT, &quot;E&amp;xit&quot;);
menuMain.AppendMenu (MF_POPUP, (UINT) menuPopup.Detach (), &quot;&amp;File&quot;);

menuPopup.CreatePopupMenu ();
menuPopup.AppendMenu (MF_STRING, ID_SHAPE_CIRCLE, &quot;&amp;Circle\tF7&quot;);
menuPopup.AppendMenu (MF_STRING, ID_SHAPE_TRIANGLE, &quot;&amp;Triangle\tF8&quot;);
menuPopup.AppendMenu (MF_STRING, ID_SHAPE_SQUARE, &quot;&amp;Square\tF9&quot;);
menuMain.AppendMenu (MF_POPUP, (UINT) menuPopup.Detach (), &quot;&amp;Shape&quot;);

SetMenu (&amp;menuMain);
menuMain.Detach ();
</PRE></TD></TR></TABLE></P>


<P>The first two statements create a <I>  CMenu</I> object named 
<I>  menuMain</I> that represents an empty top-level menu. The next block of statements creates the File menu and 
attaches it to the top-level menu. The MF_POPUP parameter passed to 
<I>  AppendMenu</I> tells Windows that the second parameter is a menu handle, not a menu item ID, 
and <I>  Detach</I> both detaches the menu from the 
<I>  menuPopup</I> object and retrieves the menu handle. The third statement block creates the Shape menu and attaches it to the 
top-level menu. Finally, the call to 
<I>  SetMenu</I> attaches the newly formed menu to the 
frame window, and <I>  Detach</I> disassociates the top-level menu and 
<I>  menuMain</I> so the top-level menu won't be destroyed as soon as the function ends. If the window is visible 
when <I>  SetMenu</I> is called, <I>  DrawMenuBar</I> should also be called to paint the menu on the screen.

</P>


<A NAME="130"><H2>Modifying Menus Programmatically</H2></A>

<P>In addition to creating menus dynamically, you can modify existing menus. The 
following table lists the <I>  CMenu</I> member functions used to add, modify, and delete menu items.
</P>

<p>
<p><table cellpadding="5" width="95%">
<TR><TH valign="top"><I>  Function</i></TH>   <TH valign="top"><i> Description</I></TH></TR>


<TR><TD valign="top"><I>  AppendMenu</I></TD>     <TD valign="top">Adds an item to the end of a menu</TD></TR>

<TR><TD valign="top"><I>  InsertMenu</I></TD>     <TD valign="top">Inserts an item into a menu at a specified location</TD></TR>

<TR><TD valign="top"><I>  ModifyMenu</I></TD>     <TD valign="top">Changes the command ID, text, or other characteristics of 
a menu item</TD></TR>

<TR><TD valign="top"><I>  DeleteMenu</I></TD>     <TD valign="top">Deletes a menu item and the submenu associated with 
it, if any</TD></TR>

<TR><TD valign="top"><I>  RemoveMenu</I></TD>     <TD valign="top">Deletes a menu item</TD>
</TR>
</table>
</P>

<P>The difference between <I>  RemoveMenu</I> and 
<I>  DeleteMenu</I> is that if the item being removed has a submenu, 
<I>  DeleteMenu</I> removes the item and destroys the 
submenu, too. <I>  RemoveMenu</I> removes the item but leaves the submenu extant in 
memory. <I>  DeleteMenu</I> is the one you'll usually want to use, but 
<I>  RemoveMenu</I> is useful if you want to preserve the submenu for later use.
</P>

<P>Before you can modify a menu by adding, changing, or deleting menu 
items, you need a <I>  CMenu</I> pointer referencing the menu. MFC's 
<I>  CWnd::GetMenu</I> function returns a 
<I>  CMenu</I> pointer for a window's top-level menu or NULL if the window 
doesn't have a top-level menu. Let's say you want to delete the Shapes application's 
Shape menu at run time. Here's the code to do it:

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMenu* pMenu = GetMenu ();
pMenu-&gt;DeleteMenu (1, MF_BYPOSITION);
</PRE></TD></TR></TABLE></P>
</P>

<P>The 1 passed to <I>  DeleteMenu</I> is the Shape menu's 0-based index. The File menu 
occupies position 0, the Shape menu position 1. MF_BYPOSITION tells 
<I>  DeleteMenu</I> that the first parameter is a positional index and not a menu item ID. In this case, 
your only choice is to identify the menu item by position because Shape is a submenu 
that has no menu item ID.
</P>

<P>To apply <I>  DeleteMenu</I> and other 
<I>  CMenu</I> functions to items in a submenu, you need a pointer either to the main menu or to the submenu. 
<I>  CMenu::GetSubMenu</I> returns a pointer to a submenu. The following code fragment uses 
<I>  GetMenu</I> to get a pointer to the main menu and 
<I>  GetSubMenu</I> to get a pointer to the Shape menu. 
It then deletes the Square and Circle commands.

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMenu* pMenu = GetMenu ()-&gt;GetSubMenu (1);
pMenu-&gt;DeleteMenu (2, MF_BYPOSITION);              // Delete Square
pMenu-&gt;DeleteMenu (ID_SHAPE_CIRCLE, MF_BYCOMMAND); // Delete Circle
</PRE></TD></TR></TABLE></P>
</P>

<P>The first call to <I>  DeleteMenu</I> identifies the menu item by its position in the 
menu; the second identifies it by its command ID. The MF_BYPOSITION and 
MF_BYCOMMAND flags tell Windows which means of identification you're using. If you specify 
neither, the default is MF_BYCOMMAND. The lone parameter passed to 
<I>  GetSubMenu</I> is the 0-based index of the submenu. Because you identified Circle by ID and not by 
position, you could also delete it by calling 
<I>  DeleteMenu</I> through the pointer to the main menu, like this:

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMenu* pMenu = GetMenu ();
pMenu-&gt;DeleteMenu (ID_SHAPE_CIRCLE, MF_BYCOMMAND);
</PRE></TD></TR></TABLE></P>
</P>

<P>As long as a menu item is identified by ID, you can access it through a pointer 
to the menu in which it appears or a pointer to any higher-level menu. Don't try 
to use MF_BYPOSITION to delete an item in a submenu with the pointer returned 
by <I>  GetMenu</I>&#8212;you might delete a submenu by mistake.
</P>

<P>To change the characteristics of an existing menu item, use 
<I>  CMenu::ModifyMenu</I>. If <I>  pMenu</I> refers to the Shape menu, the statements

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
pMenu-&gt;ModifyMenu (ID_SHAPE_TRIANGLE, MF_STRING &#166; MF_BYCOMMAND,
    ID_SHAPE_TRIANGLE, &quot;&amp;Three-Sided Polygon&quot;);
pMenu-&gt;ModifyMenu (2, MF_STRING &#166; MF_BYPOSITION,
    ID_SHAPE_SQUARE, &quot;&amp;Four-Sided Polygon&quot;);
</PRE></TD></TR></TABLE></P>
</P>

<P>modify the Triangle and Square commands to read &quot;Three-Sided Polygon&quot; and 
&quot;Four-Sided Polygon,&quot; respectively. The third parameter passed to the 
<I>  ModifyMenu</I> function is the menu item's new command ID, which should be the same as the 
original if you don't want to change it. If the item you're changing represents a submenu 
rather than an ordinary menu item, the third parameter holds the menu handle instead of 
a menu item ID. Given a <I>  CMenu</I> pointer to a submenu, you can always get the 
menu handle from the object's <I>  m_hMenu</I> data member.

</P>


<A NAME="131"><H2>The System Menu</H2></A>

<P>Just as a window can call <I>  CWnd::GetMenu</I> to obtain a 
<I>  CMenu</I> pointer to its top-level menu, it can call 
<I>  CWnd::GetSystemMenu</I> to obtain a pointer to its system menu. 
Most applications are content to let Windows manage the system menu, but every 
now and then the need to do something special arises, such as adding an item of 
your own to the system menu or changing the behavior of an existing item.
</p>

<p>
Suppose you want to add an About MyApp menu item to your 
application's system menu. About commands are normally placed in the Help menu, but 
maybe your application doesn't have a Help menu. Or maybe your application is a 
small utility program that doesn't have any menus at all, in which case adding About 
MyApp to the system menu is more efficient than loading an entire menu for the benefit 
of just one command.</p>

<p>The first step is to get a pointer to the system menu, like this:</p>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMenu* pSystemMenu = GetSystemMenu (FALSE);
</PRE></TD></TR></TABLE></P>
</P>

<P>The FALSE parameter tells <I>  GetSystemMenu</I> that you want a pointer to a copy of 
the system menu that you can modify. (TRUE resets the system menu to its default state.) </p>
<p>The second step is to add &quot;About MyApp&quot; to the system menu:</p>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
pSystemMenu-&gt;AppendMenu (MF_SEPARATOR);
pSystemMenu-&gt;AppendMenu (MF_STRING, ID_SYSMENU_ABOUT, 
    _T (&quot;&amp;About MyApp&quot;));
</PRE></TD></TR></TABLE></P>

<P>The first call to <I>  AppendMenu</I> adds a menu item separator to set your menu item 
apart from other items in the system menu; the second adds &quot;About MyApp,&quot; whose ID 
is ID_SYSMENU_ABOUT. A good place to put this code is in the main 
window's <I>  OnCreate </I>handler. Be aware that items added to the system menu should be 
assigned IDs that are multiples of 16 (16, 32, 48, and so on). Windows uses the lower four 
bits of the system menu's command IDs for its own purposes, so if you use any of 
those bits, you could receive some unexpected results.
</P>

<P>As it stands now, the new item will show up in the system menu but it won't 
do anything. When the user picks an item from the system menu, the window receives 
a WM_SYSCOMMAND message with <I>  wParam</I> equal to the menu item ID. The 
following <I>  OnSysCommand </I>handler inspects the menu item ID and displays an About box if 
the ID equals ID_SYSMENU_ABOUT:
</p>

<P>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>// In CMainWindow's message map
ON_WM_SYSCOMMAND ()

  <img src="images/grayvellip.JPG" width=3 height=13 border="0">
void CMainWindow::OnSysCommand (UINT nID, LPARAM lParam)
{
    if ((nID &amp; 0xFFF0) == ID_SYSMENU_ABOUT) {
        // Display the About box.
        return;
    }
    CFrameWnd::OnSysCommand (nID, lParam);
}
</pre>
</td>
</tr>
</table>
</p>

<P>An <I>  nID</I> value equal to ID_SYSMENU_ABOUT means that &quot;About MyApp&quot; was 
selected. If <I>  nID</I> equals anything else, you must call the base class's 
<I>  OnSysCommand</I> handler or else the system menu (and other parts of the program, too) will cease to 
function. Before you test the <I>  nID</I> value passed to 
<I>  OnSysCommand</I>, be sure to AND it with 0xFFF0 to strip any bits added by Windows.
</P>

<P>You can also use <I>  OnSysCommand</I> to modify the behavior of items 
Windows places in the system menu. The following message handler disables the system 
menu's Close command in a frame window:
</p>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
void CMainWindow::OnSysCommand (UINT nID, LPARAM lParam)
{
    if ((nID &amp; 0xFFF0) != SC_CLOSE)
        CFrameWnd::OnSysCommand (nID, lParam);
}
</PRE></TD></TR></TABLE></P>
</P>

<P>This version of <I>  OnSysCommand</I> tests 
<I>  nID</I> and passes the message to <I>  CFrameWnd 
</I>only if <I>  nID</I> represents an item other than Close. Alternatives to disabling Close with 
an <I>  OnSysCommand</I> handler include disabling the menu item with 
<I>  CMenu::EnableMenuItem</I> or deleting it altogether with 
<I>  CMenu::DeleteMenu</I>, as shown here:

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMenu* pSystemMenu = GetSystemMenu (FALSE);
pSystemMenu-&gt;EnableMenuItem (SC_CLOSE,              // Disable it.
    MF_BYCOMMAND &#166; MF_DISABLED);
pSystemMenu-&gt;DeleteMenu (SC_CLOSE, MF_BYCOMMAND);   // Delete it.
</PRE></TD></TR></TABLE></P>
</P>

<P>The command IDs for Close and other system menu items are listed in the 
documentation for <I>  OnSysCommand</I>.

</P>


<A NAME="132"><H2>Owner-Draw Menus</H2></A>

<P>Menus that display strings of text are fine for most applications, but some menus 
cry out for pictures instead of text. One example is a Color menu containing Cyan 
and Magenta commands. Many users won't know that cyan is a 50-50 mix of blue 
and green, or that magenta is a mix of equal parts red and blue. But if the menu 
contained color swatches instead of text, the meanings of the menu items would be 
crystal clear. Graphical menus are a little more work to put together than text menus, 
but the reward can be well worth the effort.
</P>

<P>The easiest way to do graphical menus is to create bitmaps depicting the 
menu items and use them in calls to 
<I>  CMenu::AppendMenu</I>. MFC represents bitmapped images with the class 
<I>  CBitmap</I>, and one form of <I>  AppendMenu</I> accepts a pointer to 
a <I>  CBitmap</I> object whose image then becomes the menu item. Once a 
<I>  CBitmap</I> object is appended to the menu, Windows displays the bitmap when the menu is 
displayed. The drawback to using bitmaps is that they're fixed in size and not easily adapted 
to changes in screen metrics.
</P>

<P>A more flexible way to replace text with graphics in a menu is to use 
<I>  owner-draw</I> menu items. When a menu containing an owner-draw item is displayed, 
Windows sends the menu's owner (the window to which the menu is attached) 
a WM_DRAWITEM message saying, &quot;It's time to draw the menu item, and here's 
where I want you to draw it.&quot; Windows even supplies a device context in which to do 
the drawing. The WM_DRAWITEM handler might display a bitmap, or it could use 
GDI functions to draw the menu item at the specified location. Before a menu 
containing an owner-draw menu item is displayed for the first time, Windows sends the 
menu's owner a WM_MEASUREITEM message to inquire about the menu item's 
dimensions. If a submenu contains, say, five owner-draw menu items, the window that the 
menu is attached to will receive five WM_MEASUREITEM messages and five 
WM_DRAWITEM messages the first time the submenu is displayed. Each time the submenu is 
displayed thereafter, the window will receive five WM_DRAWITEM messages but no 
further WM_MEASUREITEM messages.
</P>

<P>The first step in implementing an owner-draw menu is to stamp all the 
owner-draw items with the label MF_OWNERDRAW. Unfortunately, MF_OWNERDRAW 
can't be specified in a MENU template unless the template is manually changed to a 
MENUEX resource, and the Visual C++ resource editor doesn't support the owner-draw 
style, anyway. Therefore, the best way to create MF_OWNERDRAW items in an MFC 
application is to convert conventional items into owner-draw items programmatically 
using <I>  CMenu::ModifyMenu</I>.
</P>

<P>The second step is adding an 
<I>  OnMeasureItem</I> handler and associated 
message-map entry to respond to WM_MEASUREITEM messages. 
<I>  OnMeasureItem</I> is prototyped as follows:

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
afx_msg void OnMeasureItem (int nIDCtl, LPMEASUREITEMSTRUCT lpmis)
</PRE></TD></TR></TABLE></P>
</P>

<P><I>  nIDCtl</I> contains a control ID identifying the control to which the message 
pertains and is meaningless for owner-draw menus. (WM_MEASUREITEM messages are 
used for owner-draw controls as well as owner-draw menus. When 
<I>  OnMeasureItem</I> is called for a control, 
<I>  nIDCtl</I> identifies the control.) 
<I>  lpmis</I> points to a structure of type MEASUREITEMSTRUCT, which has the following form:

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
typedef struct tagMEASUREITEMSTRUCT {
    UINT   CtlType;
    UINT   CtlID;
    UINT   itemID;
    UINT   itemWidth;
    UINT   itemHeight;
    DWORD  itemData;
} MEASUREITEMSTRUCT;
</PRE></TD></TR></TABLE></P>
</P>

<P><I>  OnMeasureItem</I>'s job is to fill in the 
<I>  itemWidth</I> and <I>  itemHeight</I> fields, 
informing Windows of the menu item's horizontal and vertical dimensions, in pixels. 
An <I>  OnMeasureItem</I> handler can be as simple as this:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
lpmis-&gt;itemWidth = 64;
lpmis-&gt;itemHeight = 16;
</PRE></TD></TR></TABLE></P>

<P>To compensate for differing video resolutions, a better approach is to base the 
width and height of items in an owner-draw menu on some standard such as the 
SM_CYMENU value returned by 
<I>  ::GetSystemMetrics</I>:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
lpmis-&gt;itemWidth = ::GetSystemMetrics (SM_CYMENU) * 4;
lpmis-&gt;itemHeight = ::GetSystemMetrics (SM_CYMENU);
</PRE></TD></TR></TABLE></P>


<P>SM_CYMENU is the height of the menu bars the system draws for top-level 
menus. By basing the height of owner-draw menu items on this value and scaling the 
width accordingly, you can ensure that owner-draw items have roughly the same 
proportions as menu items drawn by Windows.
</P>

<P>
The <I>  CtlType</I> field of the MEASUREITEMSTRUCT structure is set to 
ODT_MENU if the message pertains to an owner-draw menu and is used to differentiate 
between owner-draw UI elements if a window contains owner-draw controls as well as 
owner-draw menu items. <I>  CtlID</I> and 
<I>  itemData</I> are not used for menus, but 
<I>  itemID</I> contains the menu item ID. If the owner-draw menu items your application creates are of 
different heights and widths, you can use this field to determine which menu 
item <I>  OnMeasureItem</I> was called for.
</p>

<p>
The third and final step in implementing owner-draw menu items is to 
provide an <I>  OnDrawItem</I> handler for WM_DRAWITEM messages. The actual drawing is 
done inside <I>  OnDrawItem</I>. The function is prototyped as follows:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
afx_msg void OnDrawItem (int nIDCtl, LPDRAWITEMSTRUCT lpdis)
</PRE></TD></TR></TABLE></P>

<P>Once again, <I>  nIDCtl</I> is undefined for owner-draw menu items. 
<I>  lpdis</I> points to a DRAWITEMSTRUCT structure, which contains the following members:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
typedef struct tagDRAWITEMSTRUCT {
    UINT   CtlType;
    UINT   CtlID;
    UINT   itemID;
    UINT   itemAction;
    UINT   itemState;
    HWND   hwndItem;
    HDC    hDC;
    RECT   rcItem;
    DWORD  itemData;
} DRAWITEMSTRUCT;
</PRE></TD></TR></TABLE></P>


<P>As in MEASUREITEMSTRUCT, <I>  CtlType</I> is set to ODT_MENU if the message 
pertains to an owner-draw menu item, <I>  itemID</I> holds the menu item ID, and 
<I>  CtlID</I> and <I>  itemData</I> are unused. 
<I>  hDC</I> holds the handle of the device context in which the menu item 
is drawn, and <I>  rcItem</I> is a RECT structure containing the coordinates of the rectangle 
in which the item appears. The size of the rectangle described by 
<I>  rcItem</I> is based on the dimensions you provided to Windows in response to the 
WM_MEASUREITEM message for this particular menu item. Windows doesn't clip what you draw to 
the rectangle but instead relies on your code to be &quot;well-behaved&quot; and stay within 
the bounds described by <I>  rcItem</I>. 
<I>  hwndItem</I> holds the handle of the menu to which 
the menu item belongs. This value isn't often used because the other fields provide 
most or all of the information that's needed.
</p>

<p>
DRAWITEMSTRUCT's <I>  itemAction</I> and 
<I>  itemState</I> fields describe the drawing action required and the current state of the menu item&#8212;checked or 
unchecked, enabled or disabled, and so on. For an owner-draw item, 
<I>  itemAction</I> contains one of two values: ODA_DRAWENTIRE means that you should draw the entire item, 
and ODA_SELECT means that you can optionally redraw just the part of the item 
that changes when the item is highlighted or unhighlighted. When the highlight bar 
is moved from one owner-draw menu item to another, the menu's owner receives 
a WM_DRAWITEM message without the ODA_SELECT flag for the item that's losing 
the highlight and another WM_DRAWITEM message with an ODA_SELECT flag for 
the item that's becoming highlighted. Programs that use owner-draw menus often 
ignore the value in <I>  itemAction</I> and redraw the menu item in its entirety no matter what 
the value of <I>  itemAction</I>, using 
<I>  itemState</I> to decide whether the item should be drawn 
with or without highlighting.
</p>

<p>
<I>  itemState</I> contains zero or more of the bit flags shown in the following 
table specifying the menu item's current state.
</P>

<p><table cellpadding="5" width="95%">
<TR><TH valign="top"><I>Value</I></TH>     <TH valign="top"><I>Meaning</I></TH></TR>
<TR><TD valign="top">ODS_CHECKED</TD>     <TD valign="top">The menu item is currently checked.</TD></TR>
<TR><TD valign="top">ODS_DISABLED</TD>    <TD valign="top"> The menu item is currently disabled.</TD></TR>
<TR><TD valign="top">ODS_GRAYED</TD>     <TD valign="top">The menu item is currently grayed out.</TD></TR>
<TR><TD valign="top">ODS_SELECTED</TD>    <TD valign="top"> The menu item is currently selected.</TD></TR>
</table>
</p>
<p>
This state information is important because it tells you how you should 
draw the menu item. Which of the bit flags you examine depends on which states you 
allow the menu item to assume. You should always check the ODS_SELECTED flag 
and highlight the menu item if the flag is set. If your application includes code to 
check and uncheck owner-draw menu items, you should look for ODS_CHECKED and 
draw a check mark next to the menu item if the flag is set. Similarly, if you allow the 
item to be enabled and disabled, look for an ODS_DISABLED flag and draw 
accordingly. By default, MFC disables a menu item if you provide neither an 
ON_COMMAND handler nor an ON_UPDATE_COMMAND_UI handler for it, so it's possible 
for menu items to become disabled even though your application didn't 
explicitly disable them. You can disable this feature of MFC for frame windows by 
setting <I>  CFrameWnd::m_bAutoMenuEnable</I> to FALSE.
</p>

<p>
An alternative method for implementing owner-draw menus is to attach the 
menu to a <I>  CMenu</I> object and override 
<I>  CMenu</I>'s virtual <I>  MeasureItem</I> and 
<I>  DrawItem</I> functions to do the drawing. This technique is useful for creating self-contained 
menu objects that do their own drawing rather than rely on their owners to do it for 
them. For cases in which a menu is loaded from a resource and attached to a window 
without using a <I>  CMenu</I> object as an intermediary, however, it's just as easy to let the 
window that owns the menu draw the menu items as well. That's the approach we'll 
use when we modify Shapes to include an owner-draw Color menu.
</p>

<A NAME="133"><H3><I>  OnMenuChar</I> Processing</H3></A>
<P>One drawback to using owner-draw menus is that Windows doesn't provide 
keyboard shortcuts such as Alt-C-R for Color-Red. Even if you define the menu item text as 
&quot;&amp;Red&quot; before using <I>  ModifyMenu 
</I>to change the menu item to MF_OWNERDRAW, Alt-C-R 
will no longer work. Alt-C will still pull down the Color menu, but the R key will 
do nothing.
</p>

<p>
Windows provides a solution to this problem in the form of 
WM_MENUCHAR messages. A window receives a WM_MENUCHAR message when a menu is 
displayed and a key that doesn't correspond to a menu item is pressed. By processing 
WM_MENUCHAR messages, you can add keyboard shortcuts to owner-draw menu items. 
MFC's <I>  CWnd::OnMenuChar</I> function is prototyped as follows:
</p>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
afx_msg LRESULT OnMenuChar (UINT nChar, UINT nFlags, CMenu* pMenu)
</PRE></TD></TR></TABLE></P>

<P>When <I>  OnMenuChar</I> is called, <I>  nChar</I> contains the ANSI or Unicode character 
code of the key that was pressed, <I>  nFlags</I> contains an MF_POPUP flag if the menu to which the message pertains is a submenu, and <I>  pMenu</I> identifies the menu itself. The 
pointer stored in <I>  pMenu</I> might be a temporary one created by the framework and shouldn't be saved for later use.
</p>

<p>
The value returned by <I>  OnMenuChar</I> tells Windows how to respond to the keystroke. The high word of the return value should be set to one of the following values:
</p>

<UL>
<P>
<LI>0 if Windows should ignore the keystroke
</li>
</p>

<P>
<LI>1 if Windows should close the menu
</li>
</p>

<p>
<li>
2 if Windows should select one of the items displayed in the menu
</li>
</p>
</ul>

<p>
If the high word of the return value is 2, the low word should hold the ID of 
the corresponding menu item. Windows provides a MAKELRESULT macro for setting 
the high and low words of an LRESULT value. The following statement sets the high 
word of an LRESULT value to 2 and the low word to ID_COLOR_RED:
</p>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
LRESULT lResult = MAKELRESULT (ID_COLOR_RED, 2);
</PRE></TD></TR></TABLE></P>

<P>Of course, you can always rely on keyboard accelerators instead of 
keyboard shortcuts. They work just fine with owner-draw menu items. But thanks to 
WM_MENUCHAR messages, you have the option of providing conventional keyboard 
shortcuts as well.
</p>

<A NAME="134"><H2>Cascading Menus</H2></A>

<P>When you click the Start button in the taskbar, a popup menu appears listing the 
various options for starting applications, opening documents, changing system settings, 
and so on. Some of the menu items have arrows next to them indicating that 
clicking invokes another menu. And in some cases, these menus are nested several levels 
deep. Click Start-Programs-Accessories-Games, for example, and the Games menu is 
the fourth in a series of menus cascaded across the screen. This multitiered menu 
structure permits items in the Start menu to be organized hierarchically and prevents 
individual menus from being so cluttered that they become practically useless.
</P>

<P>Cascading menus aren't the sole property of the operating system; 
application programs can use them, too. Creating a cascading menu is as simple as inserting 
one menu into another as if it were a menu item. Windows sweats the details, 
which include drawing the arrow next to the item name and displaying the cascaded 
menu without a button click if the cursor pauses over the item. Here's how Shapes' 
top-level menu would be defined if the Shape menu was nested inside an Options menu.
</p>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
IDR_MAINFRAME MENU PRELOAD DISCARDABLE 
BEGIN
    POPUP &quot;&amp;File&quot;
    BEGIN
        MENUITEM &quot;E&amp;xit&quot;,                       ID_APP_EXIT
    END
    POPUP &quot;&amp;Options&quot;
    BEGIN
        POPUP &quot;&amp;Shape&quot;
        BEGIN
            MENUITEM &quot;&amp;Circle\tF7&quot;,             ID_SHAPE_CIRCLE
            MENUITEM &quot;&amp;Triangle\tF8&quot;,           ID_SHAPE_TRIANGLE
            MENUITEM &quot;&amp;Square\tF9&quot;,             ID_SHAPE_SQUARE
        END
        MENUITEM &quot;&amp;Color&#8230;&quot;,                     ID_OPTIONS_COLOR
        MENUITEM &quot;Si&amp;ze&#8230;&quot;,                      ID_OPTIONS_SIZE
    END
END
</PRE></TD></TR></TABLE></P>

<P>Figure 4-12 shows how the resulting menu would look. Selecting Shape 
from the Options menu displays a cascading menu. Moreover, the remainder of the 
program works as it did before, so the command and update handlers associated 
with the items in the Shape menu needn't change.
</P>

<P>
<A HREF="javascript:fullSize('F04mg12x.htm')"> <img src="images/F04mg12.JPG" width=404 height=303 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 4-12.</B> <I>Cascading menus.</I><!-- /CAPTION -->
</p>

<P>You don't have to edit menu resources by hand to create cascading 
menus. Instead, you can create a nested menu in Visual C++'s menu editor by checking 
the Pop-up check box in the Menu Item Properties dialog box, as shown in Figure 4-13.
</P>

<P>
<IMG SRC="images/F04mg13.GIF" width=403 height=162 BORDER="0">
</p><p>
<!-- CAPTION --><B>Figure 4-13.</B> <I>Creating a nested menu.</I><!-- /CAPTION -->
</p>


<A NAME="135"><H2>Context Menus</H2></A>

<P>Windows uses right-click context menus extensively to make objects displayed 
by the shell easier to manipulate. Right-clicking the My Computer icon on the 
desktop, for example, displays a context menu containing a concise list of actions that can 
be performed on My Computer: Explore, Rename, Map Network Drive, and so on. 
Right-clicking the desktop produces an entirely different context menu. Developers 
are encouraged to build context menus into their applications to be consistent with 
the shell and to reinforce the object-oriented UI paradigm. Windows makes it easy 
by sending your application a WM_CONTEXTMENU message when the right 
mouse button is clicked in a window and the resulting right-button message isn't processed.
</p>

<p>
A context menu is nothing more than a submenu that isn't attached to a 
top-level menu. MFC's <I>  CMenu::TrackPopupMenu</I> function displays such a menu. 
Here's the function prototype:
</p>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
BOOL TrackPopupMenu (UINT nFlags, int <I>  x</I>, int <I>  y</I>, CWnd* pWnd,
    LPCRECT lpRect = NULL)
</PRE></TD></TR></TABLE></P>

<P><I>  x</I> and <I>  y</I> identify the location on the screen (in screen coordinates) at which the 
menu will appear. <I>  nFlags</I> contains bit flags specifying the menu's horizontal alignment 
relative to <I>  x</I> and which mouse button (or buttons) can be used to select items from the 
menu. The alignment flags TPM_LEFTALIGN, TPM_CENTERALIGN, 
and TPM_RIGHTALIGN tell Windows that <I>  x</I> specifies the location of the menu's left 
edge, center, and right edge, respectively, and the TPM_LEFTBUTTON and 
TPM_RIGHTBUTTON flags specify whether menu selections will be made with the left or the right mouse button. 
Only one of the alignment flags can be specified, but either or both of the button flags 
can be used. <I>  pWnd</I> identifies the window that will receive messages emanating 
from actions in the menu, and <I>  lpRect</I> points to a 
<I>  CRect</I> object or RECT structure containing the screen coordinates of the rectangle within which the user can click 
without dismissing the menu. If <I>  lpRect</I> is NULL, clicking outside the menu dismisses it. 
Assuming <I>  pMenu</I> is a <I>  CMenu</I> pointer that references a submenu, the statement
</p>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
pMenu-&gt;TrackPopupMenu (TPM_LEFTALIGN &#166; TPM_LEFTBUTTON &#166;
    TPM_RIGHTBUTTON, 32, 64, AfxGetMainWnd ());
</PRE></TD></TR></TABLE></P>


<P>displays the menu whose upper left corner is positioned 32 pixels right and 64 
pixels down from the upper left corner of the screen. The user can make selections 
from the menu with either the left or the right mouse button. While the menu is 
displayed, the application's main window receives messages just as if the menu were part of 
a top-level menu. Once the menu is dismissed, the messages will cease until the 
menu is displayed again.</p>

<p><I>  TrackPopupMenu</I> is typically called in response to 
WM_CONTEXTMENU messages. MFC's ON_WM_CONTEXTMENU macro maps WM_CONTEXTMENU 
messages to the message handler 
<I>  OnContextMenu</I>. <I>  OnContextMenu</I> receives two 
parameters: a <I>  CWnd</I> pointer identifying the window in which the click occurred and a 
<I>  CPoint</I> containing the cursor's screen coordinates:
</p>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
afx_msg void OnContextMenu (CWnd* pWnd, CPoint point)
</PRE></TD></TR></TABLE></P>


<P>If necessary, you can translate the screen coordinates passed in 
<I>  point</I> into client coordinates with 
<I>  CWnd::ScreenToClient</I>. It might seem curious that 
<I>  OnContextMenu</I> receives a pointer identifying a window since mouse messages go to the window 
under the cursor. However, there's a reason. Unlike other messages, 
WM_CONTEXTMENU messages percolate upward through the window hierarchy if a right-click occurs in 
a child window (for example, a push button control) and the child window 
doesn't process the message. Therefore, if a window contains child windows, it could 
receive WM_CONTEXTMENU messages with <I>  pWnd</I> containing a pointer to one of 
its children.
</p>

<p>
It's important for an <I>  OnContextMenu</I> handler to call the base class's 
<I>  OnContextMenu</I> handler if it examines 
<I>  pWnd</I> or <I>  point</I> and decides not to process the 
message. Otherwise, WM_CONTEXTMENU messages won't percolate upward. Worse, 
right-clicking the window's title bar will no longer display the system menu. The 
following <I>  OnContextMenu</I> handler displays the context menu referenced by 
<I>  pContextMenu</I> if the button click occurs in the upper half of the window and passes it to the 
base class if the click occurs elsewhere:

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
void CChildView::OnContextMenu (CWnd* <I>  pWnd</I>, CPoint <I>  point</I>)
{
    CPoint pos = point;
    ScreenToClient (&amp;pos);

    CRect rect;
    GetClientRect (&amp;rect);
    rect.bottom /= 2; // Divide the height by 2.

    if (rect.PtInRect (pos)) {
        pContextMenu-&gt;TrackPopupMenu (TPM_LEFTALIGN &#166;
            TPM_LEFTBUTTON &#166; TPM_RIGHTBUTTON, point.x, point.y,
            AfxGetMainWnd ());
        return;
    }
    CWnd::OnContextMenu (pWnd, point);
}
</PRE></TD></TR></TABLE></P>
</P>

<P>In a view-based application like Shapes, the WM_CONTEXTMENU handler is 
typically placed in the view class because that's where the objects that are subject to 
right clicks are displayed.
</P>

<P>How do you get a pointer to a context menu in order to display it? One 
method is to construct a <I>  CMenu</I> object and build the menu with 
<I>  CMenu</I> member functions. Another is to load the menu from a resource in the same way that a top-level 
menu is loaded. The following menu template defines a menu that contains one submenu:
</p>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
IDR_CONTEXTMENU MENU 
BEGIN
    POPUP &quot;&quot; 
    BEGIN
        MENUITEM &quot;&amp;Copy&quot;,       ID_CONTEXT_COPY
        MENUITEM &quot;&amp;Rename&quot;,     ID_CONTEXT_RENAME
        MENUITEM &quot;&amp;Delete&quot;,     ID_CONTEXT_DELETE
    END
END
</PRE></TD></TR></TABLE></P>

<P>The following statements load the menu into a 
<I>  CMenu</I> object and display it as a context menu:

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMenu menu;
menu.LoadMenu (IDR_CONTEXTMENU);
CMenu* pContextMenu = menu.GetSubMenu (0);
pContextMenu-&gt;TrackPopupMenu (TPM_LEFTALIGN &#166;
    TPM_LEFTBUTTON &#166; TPM_RIGHTBUTTON, point.x, point.y,
    AfxGetMainWnd ());
</PRE></TD></TR></TABLE></P>
</P>

<P>If your application uses several context menus, you can define each context 
menu as a separate submenu of IDR_CONTEXTMENU and retrieve 
<I>  CMenu</I> pointers by varying the index passed to 
<I>  GetSubMenu</I>. Or you can define each one as a separate 
menu resource. In any event, attaching the context menu to a 
<I>  CMenu</I> object that resides on the stack ensures that the menu will be destroyed when the object goes out of 
scope. The menu is no longer needed after 
<I>  TrackPopupMenu</I> returns, so deleting it frees 
up memory that can be put to other uses.
</p>

<A NAME="136"><H3>The TPM_RETURNCMD Flag</H3></A>

<P>How do you process context menu commands? The same way you process 
commands from conventional menus: by writing command handlers. You can 
write update handlers for commands in a context menu, too. In fact, it's perfectly 
legal to assign a command in a conventional menu and a command in a context menu 
the same command ID and let one command handler (and, if you'd like, one 
update handler) service both of them.
</P>

<P>Occasionally, you'll want to get a return value from 
<I>  TrackPopupMenu</I> indicating which, if any, menu item was selected and to process the command on the 
spot rather than delegate to a command handler. That's why TPM_RETURNCMD 
exists. Passed a TPM_RETURNCMD flag in its first parameter, 
<I>  TrackPopupMenu</I> returns the command ID of the item selected from the menu. A 0 return means that the 
menu was dismissed with no selection. Assuming 
<I>  pContextMenu</I> references the context menu 
used in the example in the previous section, the following statements 
demonstrate how to display the menu and act immediately on the user's selection:

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
int nCmd = (int) pContextMenu-&gt;TrackPopupMenu (TPM_LEFTALIGN &#166;
    TPM_LEFTBUTTON &#166; TPM_RIGHTBUTTON &#166; TPM_RETURNCMD,
    point.x, point.y, AfxGetMainWnd ());

switch (nCmd) {
case ID_CONTEXT_COPY:
    // Copy the object.
    break;
case ID_CONTEXT_RENAME:
    // Rename the object.
    break;
case ID_CONTEXT_DELETE:
    // Delete the object.
    break;
}
</PRE></TD></TR></TABLE></P>
</P>

<P>A menu displayed this way still generates a WM_COMMAND message when an 
item is selected. That's normally not a problem, because if you don't provide a 
command handler for the item, the message is passed harmlessly on to Windows. But 
suppose you'd like to suppress such messages, perhaps because you've used the same ID 
for an item in a conventional menu and an item in a context menu and you want 
the item in the context menu to behave differently than the one in the conventional 
menu. To do it, simply include a TPM_NONOTIFY flag in the call to 
<I>  TrackPopupMenu</I>.
</p>

<p>
Don't forget that by default, MFC disables menu items for which no command and update handlers are provided. Therefore, if you use the TPM_RETURNCMD flag, you'll probably find it necessary to set <I>  m_bAutoMenuEnable</I> to FALSE in your frame window.
</P>

</BODY>
</HTML>




