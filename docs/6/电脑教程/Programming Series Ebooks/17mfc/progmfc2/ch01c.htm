<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Introducing MFC</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch01b.htm", "ch01d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="7"><H1>Introducing MFC</H1></A>

<P>MFC is the C++ class library Microsoft provides to place an object-oriented 
wrapper around the Windows API. Version 6 contains about 200 classes, some of which 
you'll use directly and others of which will serve primarily as base classes for classes of 
your own. Some MFC classes are exceedingly simple, such as the 
<I>CPoint</I> class that represents a point (a location defined by 
<I>x</I> and <I>y</I> coordinates). Others are more 
complex, such as the <I>CWnd</I> class that encapsulates the functionality of a window. In an 
MFC program, you don't often call the Windows API directly. Instead, you create 
objects from MFC classes and call member functions belonging to those objects. Many of 
the hundreds of member functions defined in the class library are thin wrappers 
around the Windows API and even have the same names as the corresponding API 
functions. An obvious benefit of this naming convention is that it speeds the transition for 
C programmers making the move to MFC. Want to move a window? A C 
programmer would probably call the 
<I>SetWindowPos</I> API function. Look up 
<I>SetWindowPos</I> in an MFC reference, and you'll find that MFC supports 
<I>SetWindowPos</I>, too. It's a member of the 
<I>CWnd</I> class, which makes sense when you think of a window as an object 
and <I>SetWindowPos</I> as an operation you might want to perform on that object.
</p>

<P>
MFC is also an <I>application framework</I>. More than merely a collection of 
classes, MFC helps define the structure of an application and handles many routine 
chores on the application's behalf. Starting with 
<I>CWinApp</I>, the class that represents the 
application itself, MFC encapsulates virtually every aspect of a program's operation. 
The framework supplies the <I>WinMain</I> function, and 
<I>WinMain</I> in turn calls the application object's member functions to make the program go. One of the 
<I>CWinApp</I> member functions called by 
<I>WinMain</I>&#8212;<I>Run</I>&#8212;provides the message loop that pumps 
messages to the application's window. The framework also provides abstractions that go 
above and beyond what the Windows API has to offer. For example, MFC's 
document/view architecture builds a powerful infrastructure on top of the API that separates a 
program's data from graphical representations, or views, of that data. Such 
abstractions are totally foreign to the API and don't exist outside the framework of MFC or a 
similar class library.
</p>

<A NAME="8"><H2>The Benefits of Using C++ and MFC</H2></A>

<P>The fact that you're reading this book means you've probably already heard the 
traditional arguments in favor of using an object-oriented design methodology: reusability, 
tighter binding of code and data, and so on. And you should already be familiar with 
common object-oriented programming (OOP) terms such as 
<I>object, inheritance,</I> and 
<I>encapsulation,</I> particularly as they pertain to the C++ language. But without a good 
class library to serve as a starting point, OOP does little to reduce the amount of code 
you write.
</p>

<P>That's where MFC comes in. Want to add a toolbar to your 
application&#8212;one that can be docked to different sides of a window or floated in a window of its 
own? No problem: MFC provides a <I>CToolBar</I> class that does the bulk of the work for 
you. Need a linked list or a resizeable array? That's easy, too: 
<I>CList</I>, <I>CArray</I>, and other MFC collection classes provide canned containers for your data. And don't forget 
about COM, OLE, and ActiveX. Few among us have the desire or the know-how to 
write an ActiveX control from scratch. MFC simplifies the development of ActiveX 
controls by providing the bulk of the code you need in classes such as 
<I>COleControl</I> and <I>COlePropertyPage</I>.
</p>

<P>Another advantage to using MFC is that the framework uses a lot of tricks 
to make Windows objects such as windows, dialog boxes, and controls behave like 
C++ objects. Suppose you want to write a reusable list box class that displays a 
navigable list of drives and directories on the host PC. Unless you create a custom control to 
do the job, you can't implement such a list box in C because clicking an item in the 
list box sends a notification to the list box's parent (the window or the dialog box in 
which the list box appears), and it's up to the parent to process that notification. In 
other words, the list box control doesn't control its own destiny; it's the parent's job to 
update the list box's contents when a drive or a directory is changed.
</p>

<P>Not so with MFC. In an MFC application, windows and dialog boxes 
reflect unprocessed notifications back to the controls that sent them. You can create a 
self-contained and highly reusable list box class that responds to its own click 
notifications by deriving your own list box class from 
<I>CListBox</I>. The resulting list box implements its own behavior and can be ported to another application with little more than 
a #include statement in a source code file. That's what reusability is all about.
</p>

<A NAME="9"><H2>The MFC Design Philosophy</H2></A>

<P>When the programmers at Microsoft set out to create MFC, they had a vision of the future that included a pair of key design goals:</p>

<UL>
<p>
<LI> MFC should provide an object-oriented interface to the Windows 
operating system that supports reusability, self-containment, and other tenets of OOP.
</li>
</p>

<p>
<li>It should do so without imposing undue overhead on the system or 
unnecessarily adding to an application's memory requirements.
</li>
</p>
</ul>

<P>The first goal was accomplished by writing classes to encapsulate 
windows, dialog boxes, and other objects and by including key virtual functions that can 
be overridden to alter the behavior of derived classes. The second goal required 
the architects of MFC to make some choices early on about how windows, menus, 
and other objects would be wrapped by MFC classes such as 
<I>CWnd</I> and <I>CMenu</I>. Efficient use of memory was important then and it's important today, because nobody likes 
a class library that produces bloated code.
</p>

<P>One of the ways in which the designers of MFC minimized the overhead 
added by the class library is manifested in the relationship between MFC objects and 
Windows objects. In Windows, information about the characteristics and current state of a 
window is stored in memory owned by the operating system. This information is 
hidden from applications, which deal exclusively with window handles, or HWNDs. 
Rather than duplicate all the information associated with an HWND in the data members 
of the <I>CWnd</I> class, MFC wraps a window in a 
<I>CWnd</I> by storing the HWND in a public 
<I>CWnd</I> data member named <I>m_hWnd</I>. As a rule, if Windows exposes an object 
through a handle of some type, the corresponding MFC class will contain a data member 
for that handle. This knowledge can be useful if you want to call an API function 
that requires a handle but you have, say, a 
<I>CWnd</I> or <I>CWnd</I> pointer instead of an HWND.
</p>

<A NAME="10"><H2>The Document/View Architecture</H2></A>

<P>The cornerstone of MFC's application framework is the document/view 
architecture, which defines a program structure that relies on document objects to hold an 
application's data and on view objects to render views of that data. MFC provides the 
infrastructure for documents and views in the classes 
<I>CDocument</I> and <I>CView</I>. <I>CWinApp</I>
, <I>CFrameWnd</I>, and other classes work in conjunction with 
<I>CDocument</I> and <I>CView</I> to bind all the pieces together. It's a little early to discuss the details of the 
document/view architecture, but you should at least be familiar with the term 
<I>document/view</I> because it inevitably comes up in any discussion of MFC.
</p>

<P>The reason documents and views are so important is that document/view 
applications derive the greatest benefit from the application framework. You can 
write MFC programs that don't use documents and views (and we'll do a lot of that in 
this book, especially in Chapters 1 through 8), but to get the most out of the 
framework and take advantage of some of MFC's most advanced features, you must use 
the document/view architecture. That's not as restricting as it sounds, because almost 
any program that relies on documents of some type can be cast in the 
document/view mold. Don't let the term 
<I>document</I> mislead you into thinking that the 
document/view architecture is useful only for writing word processors and spreadsheet 
programs. A document is simply an abstract representation of a program's data. A 
document could just as easily be a byte array that stores board positions in a 
computerized game of chess as it could be a spreadsheet.
</p>

<P>What kinds of support does MFC provide to document/view 
applications? Among other things, the document/view architecture vastly simplifies printing 
and print previewing, the mechanics of saving documents to disk and reading them 
back again, and converting applications into Active document servers whose 
documents can be opened in Microsoft Internet Explorer. You'll learn all about the 
document/view architecture in Part II of this book, but only after you've done some 
programming without documents and views so that you can get to know MFC without 
having too much heaped on your plate at once.
</p>

<A NAME="11"><H2>The MFC Class Hierarchy</H2></A>

<P>MFC provides a variety of classes designed to serve a wide range of needs. 
You'll find a handy diagram of the MFC 6.0 class hierarchy inside the front cover of this book.
</p>

<P>The majority of MFC classes are derived, either directly or indirectly, 
from <I>CObject</I>. <I>CObject</I> provides three important features to classes that inherit from it:
</p>

<UL>
<p>
<LI>Serialization support
</li>
</p>

<p>
<li>Run-time class information support
</li>
</p>

<P>
<li>Diagnostic and debugging support
</li>
</p>
</ul>

<P>
Serialization is the process of streaming an object's persistent data to or from 
a storage medium such as a disk file. By using 
<I>CObject</I> as a base class, you can write serializable classes whose instances are easily saved and re-created. Run-time 
class information (RTCI) lets you retrieve an object's class name and other information 
about the object at run time. RTCI is implemented apart from the run-time type 
information (RTTI) mechanism in C++ because it predated RTTI by a number of years. 
Diagnostic and debugging support built into 
<I>CObject</I> let you perform validity checks on 
instances of <I>CObject</I>-derived classes and dump state information to a debugging window.
</p>

<P><I>CObject</I> provides other benefits to its derived classes as well. For example, 
it overloads the <I>new</I> and <I>delete</I> operators to provide protection against memory 
leaks. If you create an object from a 
<I>CObject</I>-derived class and fail to delete it before 
the application terminates, MFC will warn you by writing a message to the debug 
output window. The overarching importance of this most basic of MFC classes will 
become increasingly clear as you grow more familiar with MFC.
</p>

<A NAME="12"><H2>AFX Functions</H2></A>

<P>Not all of the functions that MFC offers are members of classes. MFC provides an 
API of sorts all its own in the form of global functions whose names begin with 
<I>Afx</I>. Class member functions can be called only in the context of the objects to which they 
belong, but AFX functions are available anytime and anywhere.
</p>

<P>The following table lists some of the more commonly used AFX functions. <I>AfxBeginThread</I> simplifies the process of creating threads of execution. <I>AfxMessageBox</I> is the global equivalent of the Windows <I>MessageBox</I> function and, unlike <I>CWnd::MessageBox</I>, can be called just as easily from a document class as from a window class. <I>AfxGetApp</I> and <I>AfxGetMainWnd</I> return pointers to the application object and the application's main window and are useful when you want to access a function or data member of those objects but don't have a pointer readily available. <I>AfxGetInstanceHandle</I> is handy when you need an instance handle to pass to a Windows API function. (Even MFC programs call API functions every now and then!)</p>

<p><B>Commonly Used AFX Functions</B></p>

<p><table cellpadding="5" width="95%">
<TR><TH valign="top"><I>Function Name </I></TH>
<TH valign="top"><I>Description</I></TH></TR>

<TR><TD valign="top"><I>AfxAbort</I></TD>
<TD valign="top">Unconditionally terminates an application; 
usually called when an unrecoverable error occurs</TD></TR>

<TR><TD valign="top"><I>AfxBeginThread</I></TD>
<TD valign="top">Creates a new thread and begins executing it</TD></TR>

<TR><TD valign="top"><I>AfxEndThread</I></TD>
<TD valign="top">Terminates the thread that is currently executing</TD></TR>

<TR><TD valign="top"><I>AfxMessageBox</I> </TD>
<TD valign="top">Displays a Windows message box</TD></TR>

<TR><TD valign="top"><I>AfxGetApp</I></TD>
<TD valign="top">Returns a pointer to the application object</TD></TR>

<TR><TD valign="top"><I>AfxGetAppName</I></TD>
<TD valign="top">Returns the name of the application</TD></TR>

<TR><TD valign="top"><I>AfxGetMainWnd</I></TD>
<TD valign="top">Returns a pointer to the application's main window</TD></TR>

<TR><TD valign="top"><I>AfxGetInstanceHandle</I></TD>
<TD valign="top">Returns a handle identifying the current 
application instance</TD></TR>

<TR><TD valign="top"><I>AfxRegisterWndClass</I></TD>
<TD valign="top">Registers a custom WNDCLASS for an MFC application</TD></TR>
</table></p>

</BODY>
</HTML>




