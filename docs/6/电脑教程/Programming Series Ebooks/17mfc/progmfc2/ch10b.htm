<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Scroll Views</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch10a.htm", "ch10c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="295"><H1>Scroll Views</H1></A>

<p><I>CScrollView</I> adds basic scrolling capabilities to 
<I>CView</I>. It includes handlers for WM_VSCROLL and WM_HSCROLL messages that allow MFC to do the bulk of the 
work involved in scrolling a window in response to scroll bar messages. It also 
includes member functions that you can call to perform fundamental tasks such as scrolling 
to a specified position and retrieving the current scroll position. Because 
<I>CScrollView</I> handles scrolling entirely on its own, you have to do very little to make it 
work other than implement <I>OnDraw</I>. You can usually implement 
<I>OnDraw</I> in a <I>CScrollView</I> exactly as you do in a 
<I>CView</I>. Unless you want to tweak it to optimize 
scrolling performance, <I>OnDraw</I> requires little or no special logic to support scrolling.
</p>

<A NAME="296"><H2><I>CScrollView</I> Basics</H2></A>
<p>Using <I>CScrollView</I> to create a scrolling view is simplicity itself. Here are the three 
basic steps. The term <I>physical view</I> refers to the view window and the space that it 
occupies on the screen, and <I>logical view</I> describes the virtual workspace that can be 
viewed by using the scroll bars:
</p>

<ol>
<p>
<li>
Derive your application's view class from 
<I>CScrollView</I>. If you use AppWizard to create the project, you can select 
<I>CScrollView</I> from the list of base classes presented in AppWizard's Step 6 dialog box, as shown 
in Figure 10-1.
</li>
</p>

<p>
<A HREF="javascript:fullSize('F10mg01x.htm')"> <img src="images/F10mg01.JPG" width=404 height=360 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 10-1.</B> <I>Using AppWizard to create a CScrollView-based application.</I><!-- /CAPTION -->
</p>

<p>
<li>
Override <I>OnInitialUpdate</I> in the view class, and call 
<I>SetScrollSizes</I> to specify the view's logical dimensions. This is your means of telling MFC how 
large an area the scrollable view should cover. If you use AppWizard to create the project and choose <I>CScrollView</I> in the Step 6 dialog box, AppWizard overrides <I>OnInitialUpdate</I> for you and inserts a call to <I>SetScrollSizes</I> that sets the view's logical width and height to 100 pixels.
</li>
</p>

<p>
<li>
Implement <I>OnDraw</I> as if the view were a conventional 
<I>CView</I>.
</li>
</p>
</ol>

<p>A scroll view created in this manner automatically scrolls in response to scroll bar events. It automatically factors the scroll position into the output from <I>OnDraw</I>. It also hides its scroll bars if the physical view size exceeds the logical view size and sizes the scroll bar thumbs to reflect the relative proportions of the physical and 
logical views when the scroll bars are visible.
</p>

<p><I>CScrollView::SetScrollSizes</I> accepts four parameters, two of which are optional. In order, here are those parameters:
</p>

<UL>
<p>
<LI>An integer specifying the mapping mode (required)
</li>
</p>
 
<p>
<li>
A SIZE structure or <I>CSize</I> object specifying the view's logical 
dimensions (required)
</li>
</p>

<p>
<li>A SIZE structure or <I>CSize</I> object specifying the 
<I>page size</I>&#8212;the amount by which MFC scrolls the view when the scroll bar shaft is clicked (optional)
</li>
</p>

<p>
<li>A SIZE structure or <I>CSize</I> object specifying the line size&#8212;the amount 
by which MFC scrolls the view when the scroll bar arrows are 
clicked (optional)
</li>
</p>
</ul>

<p>
If you omit either or both of the final two parameters, MFC uses sensible defaults 
for the page size and the line size. Here's an 
<I>OnInitialUpdate</I> function that sets the 
logical view size to 1,280 pixels wide and 1,024 pixels high:
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>void CMyView::OnInitialUpdate ()
{
    CScrollView::OnInitialUpdate ();
    SetScrollSizes (MM_TEXT, CSize (1280, 1024));
}
</pre>
</td>
</tr>
</table>
</p>

<p>And here's one that sets the view's dimensions to those of an 8&#189;-by-11-inch page:</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>void CMyView::OnInitialUpdate ()
{
    CScrollView::OnInitialUpdate ();
    SetScrollSizes (MM_LOENGLISH, CSize (850, 1100));
}</pre>
</td>
</tr>
</table>
</p>

<p>The next one does the same as the last one, but it also programs the view to scroll 2 inches in response to SB_PAGEUP/DOWN/LEFT/RIGHT events and 
&#188; inch in response to SB_LINEUP/DOWN/LEFT/RIGHT events:</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>void CMyView::OnInitialUpdate ()
{
    CScrollView::OnInitialUpdate ();
    SetScrollSizes (MM_LOENGLISH, CSize (850, 1100),
        CSize (200, 200), CSize (25, 25));
}
</pre>
</td>
</tr>
</table>
</p>

<p>The mapping mode specified in <I>SetScrollSizes</I>' first parameter determines the units of measurement for the second, third, and fourth parameters. You can specify any mapping mode except MM_ISOTROPIC and MM_ANISOTROPIC. When <I>OnDraw</I> is called, the mapping mode has already been set to the one specified in the call to <I>SetScrollSizes</I>. Therefore, you needn't call <I>SetMapMode</I> yourself when you implement 
<I>OnDraw</I>.
</p>

<p>Is that all there is to creating a scrolling view? Almost. You should 
remember two basic principles when using a 
<I>CScrollView</I>:
</p>

<UL>
<p>
<LI>If you draw in the view outside of 
<I>OnDraw</I>, call <I>CScrollView::OnPrepareDC</I> to allow MFC to factor the mapping mode and scroll position into 
the output.
</li>
</p>

<p>
<li>If you do any hit-testing in response to mouse messages, use <I>CDC-::DPtoLP</I> to convert the click coordinates from device coordinates 
to logical coordinates to factor the mapping mode and scroll position 
into the hit-test.
</li>
</p>
</ul>

<p>A bit of background on how a <I>CScrollView</I> works will clarify why these 
principles are important&#8212;and why an ordinary 
<I>OnDraw</I> function that knows nothing about scrolling magically adjusts its output to match the current scroll position when 
it's part of a <I>CScrollView</I>.
</p>

<p>When a scroll event occurs, <I>CScrollView</I> captures the ensuing message with its <I>OnVScroll</I> or <I>OnHScroll</I> message handler and calls <I>::ScrollWindow</I> to scroll the view horizontally or vertically. Soon after, the view's 
<I>OnPaint</I> function is called to paint the portion of the window that was invalidated by <I>::ScrollWindow</I>. Here's the <I>OnPaint</I> handler that <I>CScrollView</I> inherits from <I>CView</I>:
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>CPaintDC dc(this);
OnPrepareDC(&amp;dc);
OnDraw(&amp;dc);</pre>
</td>
</tr>
</table>
</p>

<p>
Before it calls <I>OnDraw</I>, 
<I>CView::OnPaint</I> calls the virtual 
<I>OnPrepareDC</I> function. <I>CScrollView</I> overrides 
<I>OnPrepareDC</I> and in it calls 
<I>CDC::SetMapMode</I> to set the mapping mode and 
<I>CDC::SetViewportOrg</I> to translate the viewport origin an amount 
that equals the horizontal and vertical scroll positions. Consequently, the scroll 
positions are automatically factored in when 
<I>OnDraw</I> repaints the view. Thanks to 
<I>CScrollView::OnPrepareDC</I>, a generic 
<I>OnDraw</I> function ported from a <I>CView</I> to a 
<I>CScrollView</I> automatically adapts to changes in the scroll position.
</p>

<p>Now think about what happens if you instantiate a device context class on 
your own, outside the view's <I>OnDraw</I> function, and draw something in a 
<I>CScrollView</I>. Unless you first call 
<I>OnPrepareDC</I> to prepare the device context as 
<I>OnPaint</I> does, <I>SetViewportOrg</I> won't get called and drawing will be performed relative to the 
upper left corner of the physical view rather than to the upper left corner of the 
logical view. Views of a document get out of kilter pretty quickly if they're drawn using 
two different coordinate systems. Therefore, when you draw in a 
<I>CScrollView</I> window outside of <I>OnDraw</I> like this:</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>CClientDC dc (this);
// Draw something with dc.</pre>
</td>
</tr>
</table>
</p>

<p>Make it a habit to pass the device context to 
<I>OnPrepareDC</I> first, like this:
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>CClientDC dc (this);
OnPrepareDC (&amp;dc);
// Draw something with dc.</pre>
</td>
</tr>
</table>
</p>

<p>By the same token, if you have the coordinates of a point in a <I>CScrollView</I> in device coordinates and want to find the corresponding position in the logical view, use <I>CDC::DPtoLP</I> to convert the device coordinates to logical coordinates. Call <I>OnPrepareDC</I> first to set the mapping mode and factor in the scroll position. Here's a WM_LBUTTONDOWN handler that performs a simple hit-test to determine whether the click point lies in the upper or lower half of the logical view:
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>void CMyView::OnLButtonDown (UINT nFlags, CPoint point)
{
    CPoint pos = point;
    CClientDC dc (this);
    OnPrepareDC (&amp;dc);
    dc.DPtoLP (&amp;pos);

    CSize size = GetTotalSize ();
    if (::abs (pos.y) &lt; (size.cy / 2)) {
        // Upper half was clicked.
    }
    else {
        // Lower half was clicked.
    }
}
</pre>
</td>
</tr>
</table>
</p>

<p><I>CPoint</I> objects passed to 
<I>OnLButtonDown</I> and other mouse message handlers 
always contain device coordinates, so conversion is essential if you want to know 
the coordinates of the corresponding point in logical view space.
</p>

<A NAME="297"><H2><I>CScrollView</I> Operations</H2></A>
<p><I>CScrollView</I> includes a handful of member functions that you can use to operate 
on a scroll view programmatically. For example, you can retrieve the current 
horizontal or vertical scroll position from a 
<I>CScrollView</I> by calling 
<I>GetScrollPosition</I>:
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>CPoint pos = GetScrollPosition ();
</pre>
</td>
</tr>
</table> 
</p>

<p>You can scroll to a given position programmatically with 
<I>ScrollToPosition</I>:</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>ScrollToPosition (CPoint (100, 100));</pre>
</td>
</tr>
</table>
</p>

<p>And you can measure the view's logical width and height with 
<I>GetTotalSize</I>:
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>CSize size = GetTotalSize ();
int nWidth = size.cx;
int nHeight = size.cy;</pre>
</td>
</tr>
</table>
</p>

<p>One of <I>CScrollView</I>'s more interesting member functions is 
<I>SetScaleToFit-Size</I>. Suppose you'd like to implement a Zoom To Fit command in your 
application that scales the entire logical view to fit the physical view. It's easy with 
<I>SetScaleToFitSize</I>:</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>SetScaleToFitSize (GetTotalSize ());</pre>
</td>
</tr>
</table>
</p>

<p>To restore the view to its default scrollable form, simply call <I>SetScrollSizes</I> again. Incidentally, you can call 
<I>SetScrollSizes</I> multiple times throughout the life of 
an application to adjust scrolling parameters on the fly. For example, if the size of the logical view grows as data is added to the document, it's perfectly legal to use 
<I>SetScrollSizes</I> to increase the view's logical dimensions each time the document grows.
</p>

<A NAME="298"><H2>Optimizing Scrolling Performance</H2></A>

<p><I>CScrollView</I> is architected in such a way that the 
<I>OnDraw</I> code you write doesn't have to explicitly factor in the scroll position. Consequently, an 
<I>OnDraw</I> function borrowed from a 
<I>CView</I> generally works without modification in a 
<I>CScrollView</I>. But &quot;works&quot; and &quot;performs acceptably&quot; are two different things.
</p>

<p><I>CScrollView</I> stresses a view's 
<I>OnDraw</I> function far more than a 
<I>CView</I> does because scrolling precipitates more calls to 
<I>OnDraw</I>. Very often, a call to <I>OnDraw</I> induced by a scroll bar event requires only a few rows of pixels to be painted. 
If <I>OnDraw</I> attempts to paint the entire view, the GDI eliminates unnecessary 
output by clipping pixels outside the invalid rectangle. But clipping takes time, with the 
result that scrolling performance can range from fine to abysmal depending on how 
many CPU cycles <I>OnDraw</I> wastes trying to paint outside the invalid rectangle.
</p>

<p>After you get a scroll view working, you should test its performance by 
dragging the scroll bar thumb. If the window scrolls acceptably, you're done. But if it 
doesn't (and in practice, it probably won't more often than it will), you should modify 
the view's <I>OnDraw</I> function so that it identifies the invalid rectangle and, to the 
extent possible, limits its painting to those pixels that fall inside the rectangle.
</p>

<p>The key to optimizing <I>OnDraw</I> is a 
<I>CDC</I> function named <I>GetClipBox</I>. 
Called on the device context object passed to 
<I>OnDraw</I>, <I>GetClipBox</I> initializes a 
RECT structure or <I>CRect</I> object with the size and location, in logical coordinates, of 
the invalid rectangle, as shown here:
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>CRect rect;
pDC-&gt;GetClipBox (&amp;rect);</pre>
</td>
</tr>
</table>
</p>

<p>A <I>CRect</I> initialized in this manner tells you what part of the view needs 
redrawing. How you use this information is highly application-specific. The sample program 
in the next section, which displays a spreadsheet in a scrollable view, translates 
the coordinates returned by <I>GetClipBox</I> into row and column numbers and uses the 
results to paint only those cells that fall within (either in whole or in part) the invalid 
rectangle. This is just one example of how 
<I>GetClipBox</I> can be used to optimize painting by eliminating unnecessary output. You'll see additional examples in 
subsequent chapters.
</p>

<A NAME="299"><H2>The ScrollDemo Application</H2></A>

<p>The ScrollDemo application shown in Figure 10-2 demonstrates many of 
the principles discussed in the preceding sections. ScrollDemo displays a 
spreadsheet that measures 26 columns wide and 99 rows high. One cell in the 
spreadsheet&#8212;the &quot;current cell&quot;&#8212;is highlighted in light blue. Clicking a cell with the left 
mouse button makes that cell the current cell and moves the highlight. The spreadsheet 
is displayed in a scrollable view defined by the 
<I>CScrollView</I>-derived class named 
<I>CScrollDemoView</I>. <I>CScrollDemoView</I>'s source code appears in Figure 10-3.
</p>

<p>
<A HREF="javascript:fullSize('F10mg02x.htm')"> <img src="images/F10mg02.JPG" width=404 height=302 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 10-2.</B> <I> The ScrollDemo window.</I><!-- /CAPTION -->
</p>


<p><b>Figure 10-3.</b> <i>The ScrollDemo application</i></p>


<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<A NAME="300"><H3>ScrollDemoView.h</H3></A>
<pre>
// ScrollDemoView.h : interface of the CScrollDemoView class
//
//////////////////////////////////////////////////////////////////////////

#if !defined(AFX_SCROLLDEMOVIEW_H__DCCF4E0D_9735_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_SCROLLDEMOVIEW_H__DCCF4E0D_9735_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000


class CScrollDemoView : public CScrollView
{
protected: // create from serialization only
    CScrollDemoView();
    DECLARE_DYNCREATE(CScrollDemoView)

// Attributes
public:
    CScrollDemoDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CScrollDemoView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    protected:
    virtual void OnInitialUpdate(); // called first time after construct
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CScrollDemoView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:

// Generated message map functions
protected:
    BOOL m_bSmooth;
    void GetCellRect (int row, int col, LPRECT pRect);
    void DrawAddress (CDC* pDC, int row, int col);
    void DrawPointer (CDC* pDC, int row, int col, BOOL bHighlight);
    CFont m_font;
    int m_nCurrentCol;
    int m_nCurrentRow;
    int m_nRibbonWidth;
    int m_nCellHeight;
    int m_nCellWidth;
    //{{AFX_MSG(CScrollDemoView)
    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in ScrollDemoView.cpp
inline CScrollDemoDoc* CScrollDemoView::GetDocument()
   { return (CScrollDemoDoc*)m_pDocument; }
#endif

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(
//     AFX_SCROLLDEMOVIEW_H__DCCF4E0D_9735_11D2_8E53_006008A82731__INCLUDED_)
</pre>
</td>
</tr>
</table>
</p>



<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<A NAME="301"><H3>ScrollDemoView.cpp</H3></A>
<pre>
// ScrollDemoView.cpp : implementation of the CScrollDemoView class
//

#include &quot;stdafx.h&quot;
#include &quot;ScrollDemo.h&quot;
#include &quot;ScrollDemoDoc.h&quot;

#include &quot;ScrollDemoView.h&quot;
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CScrollDemoView

IMPLEMENT_DYNCREATE(CScrollDemoView, CScrollView)

BEGIN_MESSAGE_MAP(CScrollDemoView, CScrollView)
    //{{AFX_MSG_MAP(CScrollDemoView)
    ON_WM_LBUTTONDOWN()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CScrollDemoView construction/destruction

CScrollDemoView::CScrollDemoView()
{
    m_font.CreatePointFont (80, _T (&quot;MS Sans Serif&quot;));
}

CScrollDemoView::~CScrollDemoView()
{
}

BOOL CScrollDemoView::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    return CScrollView::PreCreateWindow(cs);
}

///////////////////////////////////////////////////////////////////////////
// CScrollDemoView drawing

void CScrollDemoView::OnDraw(CDC* pDC)
{
    CScrollDemoDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    //
    // Draw the grid lines.

//
    CSize size = GetTotalSize ();

    CPen pen (PS_SOLID, 0, RGB (192, 192, 192));
    CPen* pOldPen = pDC-&gt;SelectObject (&amp;pen);
    for (int i=0; i&lt;99; i++) {
        int y = (i * m_nCellHeight) + m_nCellHeight;
        pDC-&gt;MoveTo (0, y);
        pDC-&gt;LineTo (size.cx, y);
    }

    for (int j=0; j&lt;26; j++) {
        int x = (j * m_nCellWidth) + m_nRibbonWidth;
        pDC-&gt;MoveTo (x, 0);
        pDC-&gt;LineTo (x, size.cy);
    }

    pDC-&gt;SelectObject (pOldPen);
    
    //
    // Draw the bodies of the rows and column headers.
    //
    CBrush brush;
    brush.CreateStockObject (LTGRAY_BRUSH);

    CRect rcTop (0, 0, size.cx, m_nCellHeight);
    pDC-&gt;FillRect (rcTop, &amp;brush);
    CRect rcLeft (0, 0, m_nRibbonWidth, size.cy);
    pDC-&gt;FillRect (rcLeft, &amp;brush);

    pDC-&gt;MoveTo (0, m_nCellHeight);
    pDC-&gt;LineTo (size.cx, m_nCellHeight);
    pDC-&gt;MoveTo (m_nRibbonWidth, 0);
    pDC-&gt;LineTo (m_nRibbonWidth, size.cy);

    pDC-&gt;SetBkMode (TRANSPARENT);

    //
    // Add numbers and button outlines to the row headers.
    //
    for (i=0; i&lt;99; i++) {
        int y = (i * m_nCellHeight) + m_nCellHeight;
        pDC-&gt;MoveTo (0, y);
        pDC-&gt;LineTo (m_nRibbonWidth, y);

        CString string;
        string.Format (_T (&quot;%d&quot;), i + 1);

        CRect rect (0, y, m_nRibbonWidth, y + m_nCellHeight);
        pDC-&gt;DrawText (string, &amp;rect, DT_SINGLELINE &#166;
            DT_CENTER &#166; DT_VCENTER);

        rect.top++;
        pDC-&gt;Draw3dRect (rect, RGB (255, 255, 255),
            RGB (128, 128, 128));
    }

    //
    // Add letters and button outlines to the column headers.
    //
    for (j=0; j&lt;26; j++) {
        int x = (j * m_nCellWidth) + m_nRibbonWidth;
        pDC-&gt;MoveTo (x, 0);
        pDC-&gt;LineTo (x, m_nCellHeight);

        CString string;
        string.Format (_T (&quot;%c&quot;), j + `A');

        CRect rect (x, 0, x + m_nCellWidth, m_nCellHeight);
        pDC-&gt;DrawText (string, &amp;rect, DT_SINGLELINE &#166;
            DT_CENTER &#166; DT_VCENTER);

        rect.left++;
        pDC-&gt;Draw3dRect (rect, RGB (255, 255, 255),
            RGB (128, 128, 128));
    }

    //
    // Draw address labels into the individual cells.
    //
    CRect rect;
    pDC-&gt;GetClipBox (&amp;rect);
    int nStartRow = max (0, (rect.top - m_nCellHeight) / m_nCellHeight);
    int nEndRow = min (98, (rect.bottom - 1) / m_nCellHeight);
    int nStartCol = max (0, (rect.left - m_nRibbonWidth) / m_nCellWidth);
    int nEndCol = min (25, ((rect.right + m_nCellWidth - 1) -
        m_nRibbonWidth) / m_nCellWidth);

    for (i=nStartRow; i&lt;=nEndRow; i++)
        for (j=nStartCol; j&lt;=nEndCol; j++)
            DrawAddress (pDC, i, j);

    //
    // Draw the cell pointer.
    //
    DrawPointer (pDC, m_nCurrentRow, m_nCurrentCol, TRUE);
}
void CScrollDemoView::OnInitialUpdate()
{
    CScrollView::OnInitialUpdate();

    m_nCurrentRow = 0;
    m_nCurrentCol = 0;
    m_bSmooth = FALSE;

    CClientDC dc (this);
    m_nCellWidth = dc.GetDeviceCaps (LOGPIXELSX);
    m_nCellHeight = dc.GetDeviceCaps (LOGPIXELSY) / 4;
    m_nRibbonWidth = m_nCellWidth / 2;

    int nWidth = (26 * m_nCellWidth) + m_nRibbonWidth;
    int nHeight = m_nCellHeight * 100;
    SetScrollSizes (MM_TEXT, CSize (nWidth, nHeight));
}

///////////////////////////////////////////////////////////////////////////
// CScrollDemoView diagnostics

#ifdef _DEBUG
void CScrollDemoView::AssertValid() const
{
    CScrollView::AssertValid();
}

void CScrollDemoView::Dump(CDumpContext&amp; dc) const
{
    CScrollView::Dump(dc);
}

CScrollDemoDoc* CScrollDemoView::GetDocument() // non-debug version is
                                               inline
{
    ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CScrollDemoDoc)));
    return (CScrollDemoDoc*)m_pDocument;
}
#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CScrollDemoView message handlers

void CScrollDemoView::OnLButtonDown(UINT nFlags, CPoint point) 
{
    CScrollView::OnLButtonDown(nFlags, point);

    //
    // Convert the click point to logical coordinates.
    //
    CPoint pos = point;
    CClientDC dc (this);
    OnPrepareDC (&amp;dc);
    dc.DPtoLP (&amp;pos);

    //
    // If a cell was clicked, move the cell pointer.
    //
    CSize size = GetTotalSize ();
    if (pos.x &gt; m_nRibbonWidth &amp;&amp; pos.x &lt; size.cx &amp;&amp;
        pos.y &gt; m_nCellHeight &amp;&amp; pos.y &lt; size.cy) {

        int row = (pos.y - m_nCellHeight) / m_nCellHeight;
        int col = (pos.x - m_nRibbonWidth) / m_nCellWidth;
        ASSERT (row &gt;= 0 &amp;&amp; row &lt;= 98 &amp;&amp; col &gt;= 0 &amp;&amp; col &lt;= 25);

        DrawPointer (&amp;dc, m_nCurrentRow, m_nCurrentCol, FALSE);
        m_nCurrentRow = row;
        m_nCurrentCol = col;
        DrawPointer (&amp;dc, m_nCurrentRow, m_nCurrentCol, TRUE);
    }
}

void CScrollDemoView::DrawPointer(CDC *pDC, int row, int col, 
    BOOL bHighlight)
{
    CRect rect;
    GetCellRect (row, col, &amp;rect);
    CBrush brush (bHighlight ? RGB (0, 255, 255) :
        ::GetSysColor (COLOR_WINDOW));
    pDC-&gt;FillRect (rect, &amp;brush);
    DrawAddress (pDC, row, col);
}

void CScrollDemoView::DrawAddress(CDC *pDC, int row, int col)
{
    CRect rect;
    GetCellRect (row, col, &amp;rect);

    CString string;
    string.Format (_T (&quot;%c%d&quot;), col + _T (`A'), row + 1);

    pDC-&gt;SetBkMode (TRANSPARENT);
    CFont* pOldFont = pDC-&gt;SelectObject (&amp;m_font);
    pDC-&gt;DrawText (string, rect, DT_SINGLELINE &#166; DT_CENTER &#166; DT_VCENTER);
    pDC-&gt;SelectObject (pOldFont);
}

void CScrollDemoView::GetCellRect(int row, int col, LPRECT pRect)
{
    pRect-&gt;left = m_nRibbonWidth + (col * m_nCellWidth) + 1;
    pRect-&gt;top = m_nCellHeight + (row * m_nCellHeight) + 1;
    pRect-&gt;right = pRect-&gt;left + m_nCellWidth - 1;
    pRect-&gt;bottom = pRect-&gt;top + m_nCellHeight - 1;
}
</pre>
</td>
</tr>
</table>
</p>

   <p>Because <I>CScrollView</I> manages most aspects of scrolling, ScrollDemo 
includes remarkably little code to explicitly support scrolling operations. It does, however, 
use <I>GetClipBox</I> to optimize <I>OnDraw</I>'s performance. Rather than attempt to paint all 
2,574 spreadsheet cells every time it's called, 
<I>OnDraw</I> translates the clip box into 
starting and ending row and column numbers and paints only those cells that fall within 
these ranges. The pertinent code is near the end of 
<I>OnDraw</I>:</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>CRect rect;
pDC-&gt;GetClipBox (&amp;rect);
int nStartRow = max (0, (rect.top - m_nCellHeight) / m_nCellHeight);
int nEndRow = min (98, (rect.bottom - 1) / m_nCellHeight);
int nStartCol = max (0, (rect.left - m_nRibbonWidth) / m_nCellWidth);
int nEndCol = min (25, ((rect.right + m_nCellWidth - 1) -
    m_nRibbonWidth) / m_nCellWidth);

for (i=nStartRow; i&lt;=nEndRow; i++)
    for (j=nStartCol; j&lt;=nEndCol; j++)
        DrawAddress (pDC, i, j);
</pre>
</td>
</tr>
</table>
</p>

<p>As an experiment, try modifying the <I>for</I> loop to paint every cell:
</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>for (i=0; i&lt;99; i++)
    for (j=0; j&lt;26; j++)
        DrawAddress (pDC, i, j);</pre>
</td>
</tr>
</table>
</p>

<p>Then try scrolling the spreadsheet. You'll quickly see why optimizing 
<I>OnDraw</I> is a necessity rather than an option in many scroll views.</p>

<p>Another interesting experiment involves the view's 
<I>OnLButtonDown</I> function, which moves the cell highlight in response to mouse clicks. Before using the 
<I>CPoint</I> object passed to it to determine the row and column number in which the 
click occurred, <I>OnLButtonDown</I> converts the 
<I>CPoint</I>'s device coordinates to logical coordinates with the following statements:</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>CPoint pos = point;
CClientDC dc (this);
OnPrepareDC (&amp;dc);
dc.DPtoLP (&amp;pos);</pre>
</td>
</tr>
</table>
</p>

<p>To see what happens if <I>OnLButtonDown</I> fails to take the scroll position into 
account in a <I>CScrollView</I>, delete the call to 
<I>DPtoLP</I> and try clicking around in the 
spreadsheet after scrolling it a short distance horizontally or vertically.
</p>

<A NAME="302"><H2>Converting an Ordinary View into a Scroll View</H2></A>

<p>What happens if you use AppWizard to generate a 
<I>CView</I>-based application and later decide you want a 
<I>CScrollView</I>? You can't use the MFC wizards to convert 
a <I>CView</I> into a <I>CScrollView</I> after the fact, but you 
<I>can</I> perform the conversion by hand. Here's how:
</p>

<ol>
<p>
<li>
Search the view's header file and CPP file and change all occurrences 
of <I>CView</I> to <I>CScrollView</I>, except where 
<I>CView*</I> occurs in a function's parameter list.
</li>
</p>

<p>
<li>
Override <I>OnInitialUpdate</I> if it isn't overridden already, and insert a call 
to <I>SetScrollSizes</I>.
</li>
</p>
</ol>

<p>
If you perform step 1 but forget step 2, you'll know it as soon as you run the 
application because MFC will assert on you. MFC can't manage a scroll view if it doesn't 
know the view's logical dimensions.
</p>

</BODY>
</HTML>




