<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>The Clock Application</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch14b.htm", "ch14d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="430"><H1>The Clock Application</H1></A>

<P>The Clock application shown in Figure 14-1 uses a timer set to fire at 1-second 
intervals to periodically redraw a set of clock hands simulating an analog clock. 
Clock isn't a document/view application; it uses the MFC 1.0_style application 
architecture described in the first few chapters of this book. All of its source code, including 
the RC file, was generated by hand. (See Figure 14-2.) Besides demonstrating how to 
use a timer in a Windows application, Clock introduces a new MFC class named 
<I>CTime</I> and a new message, WM_MINMAXINFO. It also has several other 
interesting features that have nothing to do with timers, including these:</p>

<UL>
<P><LI>A command in the system menu for removing the window's title bar</li></p>
<P><LI>A command in the system menu for making Clock's window a topmost window&#8212;one that's drawn on top of other windows even when it's running in the background</li></p>
<P><LI>A persistent frame window that remembers its size and position</li></p>
<P><LI>A frame window that can be dragged by its client area</li></p>
</UL>

<P>We'll go over these and other unique aspects of the application in the sections that follow.</p>

<P>
<img src="images/F14MG01x.GIF" width=415 height=377 border=0>
</p><p>
<!-- CAPTION --><B>Figure 14-1.</B> <I>The Clock window.</I><!-- /CAPTION -->
</p>

<P><B>Figure 14-2.</B> <I>The Clock application.</I></p>

<p><table cellpadding="5" width="95%">
<tr><td>
<A NAME="431"><H3>Resource.h</H3></A>
<PRE>#define IDM_SYSMENU_FULL_WINDOW      16
#define IDM_SYSMENU_STAY_ON_TOP      32
#define IDI_APPICON                 100
</pre>
</td></tr></table></p>

<p><table cellpadding="5" width="95%">
<tr><td>
<A NAME="432"><H3>Clock.rc</H3></A>
<PRE>#include &lt;afxres.h&gt;
#include &quot;Resource.h&quot;

IDI_APPICON ICON Clock.ico
</pre>
</td></tr></table></p>

<p><table cellpadding="5" width="95%">
<tr><td>
<A NAME="433"><H3>Clock.h</H3></A>
<PRE>class CMyApp : public CWinApp
{
public:
    virtual BOOL InitInstance ();
};

class CMainWindow : public CFrameWnd
{

protected:
    BOOL m_bFullWindow;
    BOOL m_bStayOnTop;

    int m_nPrevSecond;        
    int m_nPrevMinute;
    int m_nPrevHour;

    void DrawClockFace (CDC* pDC);
    void DrawSecondHand (CDC* pDC, int nLength, int nScale, int nDegrees,
        COLORREF clrColor);
    void DrawHand (CDC* pDC, int nLength, int nScale, int nDegrees,
        COLORREF clrColor);

    void SetTitleBarState ();
    void SetTopMostState ();
    void SaveWindowState ();
    void UpdateSystemMenu (CMenu* pMenu);

public:
    CMainWindow ();
    virtual BOOL PreCreateWindow (CREATESTRUCT&amp; cs);
    BOOL RestoreWindowState ();

protected:
    afx_msg int OnCreate (LPCREATESTRUCT lpcs);
    afx_msg void OnGetMinMaxInfo (MINMAXINFO* pMMI);
    afx_msg void OnTimer (UINT nTimerID);
    afx_msg void OnPaint ();
    afx_msg UINT OnNcHitTest (CPoint point);
    afx_msg void OnSysCommand (UINT nID, LPARAM lParam);
    afx_msg void OnContextMenu (CWnd* pWnd, CPoint point);
    afx_msg void OnEndSession (BOOL bEnding);
    afx_msg void OnClose ();

    DECLARE_MESSAGE_MAP ()
};
</pre>
</td></tr></table></p>

<p><table cellpadding="5" width="95%">
<tr><td>
<A NAME="434"><H3>Clock.cpp</H3></A>
<PRE>
#include &lt;afxwin.h&gt;
#include &lt;math.h&gt;
#include &quot;Clock.h&quot;
#include &quot;Resource.h&quot;
#define SQUARESIZE 20
#define ID_TIMER_CLOCK 1

CMyApp myApp;

/////////////////////////////////////////////////////////////////////////
// CMyApp member functions

BOOL CMyApp::InitInstance ()
{
    SetRegistryKey (_T (&quot;Programming Windows with MFC&quot;));
    m_pMainWnd = new CMainWindow;
    if (!((CMainWindow*) m_pMainWnd)-&gt;RestoreWindowState ())
        m_pMainWnd-&gt;ShowWindow (m_nCmdShow);
    m_pMainWnd-&gt;UpdateWindow ();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////
// CMainWindow message map and member functions

BEGIN_MESSAGE_MAP (CMainWindow, CFrameWnd)
    ON_WM_CREATE ()
    ON_WM_PAINT ()
    ON_WM_TIMER ()
    ON_WM_GETMINMAXINFO ()
    ON_WM_NCHITTEST ()
    ON_WM_SYSCOMMAND ()
    ON_WM_CONTEXTMENU ()
    ON_WM_ENDSESSION ()
    ON_WM_CLOSE ()
END_MESSAGE_MAP ()

CMainWindow::CMainWindow ()
{
    m_bAutoMenuEnable = FALSE;

    CTime time = CTime::GetCurrentTime ();
    m_nPrevSecond = time.GetSecond ();
    m_nPrevMinute = time.GetMinute ();
    m_nPrevHour = time.GetHour () % 12;

    CString strWndClass = AfxRegisterWndClass (
        CS_HREDRAW &#339; CS_VREDRAW,
        myApp.LoadStandardCursor (IDC_ARROW),

        (HBRUSH) (COLOR_3DFACE + 1),
        myApp.LoadIcon (IDI_APPICON)    );

    Create (strWndClass, _T (&quot;Clock&quot;));
}

BOOL CMainWindow::PreCreateWindow (CREATESTRUCT&amp; cs)
{
    if (!CFrameWnd::PreCreateWindow (cs))
        return FALSE;

    cs.dwExStyle &amp;= ~WS_EX_CLIENTEDGE;
    return TRUE;
}

int CMainWindow::OnCreate (LPCREATESTRUCT lpcs)
{
    if (CFrameWnd::OnCreate (lpcs) == -1)
        return -1;

    //
    // Set a timer to fire at 1-second intervals.
    //
    if (!SetTimer (ID_TIMER_CLOCK, 1000, NULL)) {
        MessageBox (_T (&quot;SetTimer failed&quot;), _T (&quot;Error&quot;),
            MB_ICONSTOP &#339; MB_OK);
        return -1;
    }

    //
    // Customize the system menu.
    //
    CMenu* pMenu = GetSystemMenu (FALSE);
    pMenu-&gt;AppendMenu (MF_SEPARATOR);
    pMenu-&gt;AppendMenu (MF_STRING, IDM_SYSMENU_FULL_WINDOW,
        _T (&quot;Remove &amp;Title&quot;));
    pMenu-&gt;AppendMenu (MF_STRING, IDM_SYSMENU_STAY_ON_TOP,
        _T (&quot;Stay on To&amp;p&quot;));
    return 0;
}

void CMainWindow::OnClose ()
{
    SaveWindowState ();
    KillTimer (ID_TIMER_CLOCK);
    CFrameWnd::OnClose ();
}


void CMainWindow::OnEndSession (BOOL bEnding)
{
    if (bEnding)
        SaveWindowState ();
    CFrameWnd::OnEndSession (bEnding);
}

void CMainWindow::OnGetMinMaxInfo (MINMAXINFO* pMMI)
{
    pMMI-&gt;ptMinTrackSize.x = 120;
    pMMI-&gt;ptMinTrackSize.y = 120;
}

UINT CMainWindow::OnNcHitTest (CPoint point)
{
    UINT nHitTest = CFrameWnd::OnNcHitTest (point);
    if ((nHitTest == HTCLIENT) &amp;&amp; (::GetAsyncKeyState (MK_LBUTTON) &lt; 0))
        nHitTest = HTCAPTION;
    return nHitTest;
}

void CMainWindow::OnSysCommand (UINT nID, LPARAM lParam)
{
    UINT nMaskedID = nID &amp; 0xFFF0;

    if (nMaskedID == IDM_SYSMENU_FULL_WINDOW) {
        m_bFullWindow = m_bFullWindow ? 0 : 1;
        SetTitleBarState ();
        return;
    }
    else if (nMaskedID == IDM_SYSMENU_STAY_ON_TOP) {
        m_bStayOnTop = m_bStayOnTop ? 0 : 1;
        SetTopMostState ();
        return;
    }
    CFrameWnd::OnSysCommand (nID, lParam);
}

void CMainWindow::OnContextMenu (CWnd* pWnd, CPoint point)
{
    CRect rect;
    GetClientRect (&amp;rect);
    ClientToScreen (&amp;rect);

    if (rect.PtInRect (point)) {
        CMenu* pMenu = GetSystemMenu (FALSE);
        UpdateSystemMenu (pMenu);

        int nID = (int) pMenu-&gt;TrackPopupMenu (TPM_LEFTALIGN &#339;
            TPM_LEFTBUTTON &#339; TPM_RIGHTBUTTON &#339; TPM_RETURNCMD, point.x,
            point.y, this);

        if (nID &gt; 0)
            SendMessage (WM_SYSCOMMAND, nID, 0);

        return;
    }
    CFrameWnd::OnContextMenu (pWnd, point);
}

void CMainWindow::OnTimer (UINT nTimerID)
{
    //
    // Do nothing if the window is minimized.
    //
    if (IsIconic ())
        return;

    //
    // Get the current time and do nothing if it hasn't changed.
    //
    CTime time = CTime::GetCurrentTime ();
    int nSecond = time.GetSecond ();
    int nMinute = time.GetMinute ();
    int nHour = time.GetHour () % 12;

    if ((nSecond == m_nPrevSecond) &amp;&amp;
        (nMinute == m_nPrevMinute) &amp;&amp;
        (nHour == m_nPrevHour))
        return;

    //
    // Center the origin and switch to the MM_ISOTROPIC mapping mode.
    //
    CRect rect;
    GetClientRect (&amp;rect);

    CClientDC dc (this);
    dc.SetMapMode (MM_ISOTROPIC);
    dc.SetWindowExt (1000, 1000);
    dc.SetViewportExt (rect.Width (), -rect.Height ());
    dc.SetViewportOrg (rect.Width () / 2, rect.Height () / 2);

    //
    // If minutes have changed, erase the hour and minute hands.
    //
    COLORREF clrColor = ::GetSysColor (COLOR_3DFACE);

    if (nMinute != m_nPrevMinute) {
        DrawHand (&amp;dc, 200, 4, (m_nPrevHour * 30) + (m_nPrevMinute / 2),
            clrColor);
        DrawHand (&amp;dc, 400, 8, m_nPrevMinute * 6, clrColor);
        m_nPrevMinute = nMinute;
        m_nPrevHour = nHour;
    }

    //
    // If seconds have changed, erase the second hand and redraw all hands.
    //
    if (nSecond != m_nPrevSecond) {
        DrawSecondHand (&amp;dc, 400, 8, m_nPrevSecond * 6, clrColor);
        DrawSecondHand (&amp;dc, 400, 8, nSecond * 6, RGB (0, 0, 0));
        DrawHand (&amp;dc, 200, 4, (nHour * 30) + (nMinute / 2),
            RGB (0, 0, 0));
        DrawHand (&amp;dc, 400, 8, nMinute * 6, RGB (0, 0, 0));
        m_nPrevSecond = nSecond;
    }
}

void CMainWindow::OnPaint ()
{
    CRect rect;
    GetClientRect (&amp;rect);

    CPaintDC dc (this);
    dc.SetMapMode (MM_ISOTROPIC);
    dc.SetWindowExt (1000, 1000);
    dc.SetViewportExt (rect.Width (), -rect.Height ());
    dc.SetViewportOrg (rect.Width () / 2, rect.Height () / 2);

    DrawClockFace (&amp;dc);
    DrawHand (&amp;dc, 200, 4, (m_nPrevHour * 30) +
        (m_nPrevMinute / 2), RGB (0, 0, 0));
    DrawHand (&amp;dc, 400, 8, m_nPrevMinute * 6, RGB (0, 0, 0));
    DrawSecondHand (&amp;dc, 400, 8, m_nPrevSecond * 6, RGB (0, 0, 0));
}

void CMainWindow::DrawClockFace (CDC* pDC)
{
    static CPoint point[12] = {
        CPoint (   0,  450),    // 12 o'clock
        CPoint ( 225,  390),    //  1 o'clock
        CPoint ( 390,  225),    //  2 o'clock
        CPoint ( 450,    0),    //  3 o'clock
        CPoint ( 390, -225),    //  4 o'clock
        CPoint ( 225, -390),    //  5 o'clock
        CPoint (   0, -450),    //  6 o'clock
        CPoint (-225, -390),    //  7 o'clock
        CPoint (-390, -225),    //  8 o'clock
        CPoint (-450,    0),    //  9 o'clock
        CPoint (-390,  225),    // 10 o'clock
        CPoint (-225,  390),    // 11 o'clock
    };

    pDC-&gt;SelectStockObject (NULL_BRUSH);

    for (int i=0; i&lt;12; i++)
        pDC-&gt;Rectangle (point[i].x - SQUARESIZE,
            point[i].y + SQUARESIZE, point[i].x + SQUARESIZE,
            point[i].y - SQUARESIZE);
}

void CMainWindow::DrawHand (CDC* pDC, int nLength, int nScale,
    int nDegrees, COLORREF clrColor)
{
    CPoint point[4];
    double nRadians = (double) nDegrees * 0.017453292;

    point[0].x = (int) (nLength * sin (nRadians));
    point[0].y = (int) (nLength * cos (nRadians));

    point[2].x = -point[0].x / nScale;
    point[2].y = -point[0].y / nScale;

    point[1].x = -point[2].y;
    point[1].y = point[2].x;

    point[3].x = -point[1].x;
    point[3].y = -point[1].y;

    CPen pen (PS_SOLID, 0, clrColor);
    CPen* pOldPen = pDC-&gt;SelectObject (&amp;pen);

    pDC-&gt;MoveTo (point[0]);
    pDC-&gt;LineTo (point[1]);
    pDC-&gt;LineTo (point[2]);
    pDC-&gt;LineTo (point[3]);
    pDC-&gt;LineTo (point[0]);

    pDC-&gt;SelectObject (pOldPen);
}

void CMainWindow::DrawSecondHand (CDC* pDC, int nLength, int nScale,
    int nDegrees, COLORREF clrColor)
{
    CPoint point[2];
    double nRadians = (double) nDegrees * 0.017453292;

    point[0].x = (int) (nLength * sin (nRadians));
    point[0].y = (int) (nLength * cos (nRadians));

    point[1].x = -point[0].x / nScale;
    point[1].y = -point[0].y / nScale;

    CPen pen (PS_SOLID, 0, clrColor);
    CPen* pOldPen = pDC-&gt;SelectObject (&amp;pen);

    pDC-&gt;MoveTo (point[0]);
    pDC-&gt;LineTo (point[1]);

    pDC-&gt;SelectObject (pOldPen);
}

void CMainWindow::SetTitleBarState ()
{
    CMenu* pMenu = GetSystemMenu (FALSE);

    if (m_bFullWindow ) {
        ModifyStyle (WS_CAPTION, 0);
        pMenu-&gt;ModifyMenu (IDM_SYSMENU_FULL_WINDOW, MF_STRING,
            IDM_SYSMENU_FULL_WINDOW, _T (&quot;Restore &amp;Title&quot;));
    }
    else {
        ModifyStyle (0, WS_CAPTION);
        pMenu-&gt;ModifyMenu (IDM_SYSMENU_FULL_WINDOW, MF_STRING,
            IDM_SYSMENU_FULL_WINDOW, _T (&quot;Remove &amp;Title&quot;));
    }
    SetWindowPos (NULL, 0, 0, 0, 0, SWP_NOMOVE &#339; SWP_NOSIZE &#339;
        SWP_NOZORDER &#339; SWP_DRAWFRAME);
}

void CMainWindow::SetTopMostState ()
{
    CMenu* pMenu = GetSystemMenu (FALSE);

    if (m_bStayOnTop) {
        SetWindowPos (&amp;wndTopMost, 0, 0, 0, 0, SWP_NOMOVE &#339; SWP_NOSIZE);
        pMenu-&gt;CheckMenuItem (IDM_SYSMENU_STAY_ON_TOP, MF_CHECKED);
    }       
    else {
        SetWindowPos (&amp;wndNoTopMost, 0, 0, 0, 0, SWP_NOMOVE &#339; SWP_NOSIZE);
        pMenu-&gt;CheckMenuItem (IDM_SYSMENU_STAY_ON_TOP, MF_UNCHECKED);
    }
}

BOOL CMainWindow::RestoreWindowState ()
{
    CString version = _T (&quot;Version 1.0&quot;);
    m_bFullWindow = myApp.GetProfileInt (version, _T (&quot;FullWindow&quot;), 0);
    SetTitleBarState ();
    m_bStayOnTop = myApp.GetProfileInt (version, _T (&quot;StayOnTop&quot;), 0);
    SetTopMostState ();

    WINDOWPLACEMENT wp;
    wp.length = sizeof (WINDOWPLACEMENT);
    GetWindowPlacement (&amp;wp);

    if (((wp.flags =
            myApp.GetProfileInt (version, _T (&quot;flags&quot;), -1)) != -1) &amp;&amp;
        ((wp.showCmd =
            myApp.GetProfileInt (version, _T (&quot;showCmd&quot;), -1)) != -1) &amp;&amp;
        ((wp.rcNormalPosition.left =
            myApp.GetProfileInt (version, _T (&quot;x1&quot;), -1)) != -1) &amp;&amp;
        ((wp.rcNormalPosition.top =
            myApp.GetProfileInt (version, _T (&quot;y1&quot;), -1)) != -1) &amp;&amp;
        ((wp.rcNormalPosition.right =
            myApp.GetProfileInt (version, _T (&quot;x2&quot;), -1)) != -1) &amp;&amp;
        ((wp.rcNormalPosition.bottom =
            myApp.GetProfileInt (version, _T (&quot;y2&quot;), -1)) != -1)) {

        wp.rcNormalPosition.left = min (wp.rcNormalPosition.left,
            ::GetSystemMetrics (SM_CXSCREEN) -
            ::GetSystemMetrics (SM_CXICON));
        wp.rcNormalPosition.top = min (wp.rcNormalPosition.top,
            ::GetSystemMetrics (SM_CYSCREEN) -
            ::GetSystemMetrics (SM_CYICON));
        SetWindowPlacement (&amp;wp);
        return TRUE;
    }
    return FALSE;
}

void CMainWindow::SaveWindowState ()
{
    CString version = _T (&quot;Version 1.0&quot;);
    myApp.WriteProfileInt (version, _T (&quot;FullWindow&quot;), m_bFullWindow);
    myApp.WriteProfileInt (version, _T (&quot;StayOnTop&quot;), m_bStayOnTop);

    WINDOWPLACEMENT wp;
    wp.length = sizeof (WINDOWPLACEMENT);
    GetWindowPlacement (&amp;wp);

    myApp.WriteProfileInt (version, _T (&quot;flags&quot;), wp.flags);
    myApp.WriteProfileInt (version, _T (&quot;showCmd&quot;), wp.showCmd);
    myApp.WriteProfileInt (version, _T (&quot;x1&quot;), wp.rcNormalPosition.left);
    myApp.WriteProfileInt (version, _T (&quot;y1&quot;), wp.rcNormalPosition.top);
    myApp.WriteProfileInt (version, _T (&quot;x2&quot;), wp.rcNormalPosition.right);
    myApp.WriteProfileInt (version, _T (&quot;y2&quot;), wp.rcNormalPosition.bottom);
}

void CMainWindow::UpdateSystemMenu (CMenu* pMenu)
{
    static UINT nState[2][5] = {
        { MFS_GRAYED,  MFS_ENABLED, MFS_ENABLED,
          MFS_ENABLED, MFS_DEFAULT },
        { MFS_DEFAULT, MFS_GRAYED,  MFS_GRAYED,
          MFS_ENABLED, MFS_GRAYED  }
    };

    if (IsIconic ()) // Shouldn't happen, but let's be safe
        return;

    int i = 0;
    if (IsZoomed ())
        i = 1;

    CString strMenuText;
    pMenu-&gt;GetMenuString (SC_RESTORE, strMenuText, MF_BYCOMMAND);
    pMenu-&gt;ModifyMenu (SC_RESTORE, MF_STRING &#339; nState[i][0], SC_RESTORE,
        strMenuText);

    pMenu-&gt;GetMenuString (SC_MOVE, strMenuText, MF_BYCOMMAND);
    pMenu-&gt;ModifyMenu (SC_MOVE, MF_STRING &#339; nState[i][1], SC_MOVE,
        strMenuText);

    pMenu-&gt;GetMenuString (SC_SIZE, strMenuText, MF_BYCOMMAND);
    pMenu-&gt;ModifyMenu (SC_SIZE, MF_STRING &#339; nState[i][2], SC_SIZE,
        strMenuText);

    pMenu-&gt;GetMenuString (SC_MINIMIZE, strMenuText, MF_BYCOMMAND);
    pMenu-&gt;ModifyMenu (SC_MINIMIZE, MF_STRING &#339; nState[i][3], SC_MINIMIZE,
        strMenuText);

    pMenu-&gt;GetMenuString (SC_MAXIMIZE, strMenuText, MF_BYCOMMAND);
    pMenu-&gt;ModifyMenu (SC_MAXIMIZE, MF_STRING &#339; nState[i][4], SC_MAXIMIZE,
        strMenuText);

    SetMenuDefaultItem (pMenu-&gt;m_hMenu, i ? SC_RESTORE :
        SC_MAXIMIZE, FALSE);
}
</pre>
</td></tr></table></p>

<A NAME="435"><H2>Processing Timer Messages</H2></A>

<P>Clock uses <I>SetTimer</I> to program a timer in <I>OnCreate</I>. The timer is destroyed in 
<I>OnClose</I> with <I>KillTimer</I>. When a WM_TIMER message arrives, 
<I>CMainWindow::OnTimer</I> gets the current time and compares the hour, minute, and second to the hour, minute, 
and second previously recorded in the member variables 
<I>m_nPrevHour</I>, <I>m_nPrevMinute</I>, and <I>m_nPrevSecond</I>. If the current hour, minute, and second equal the hour, 
minute, and second recorded earlier, <I>OnTimer</I> does nothing. Otherwise, it records the 
new time and moves the clock hands. <I>CMainWindow::DrawHand</I> draws the hour and minute hands, and 
<I>CMainWindow::DrawSecondHand</I> draws the second hand. A hand is moved by calling the corresponding drawing function twice: once to erase the 
hand by drawing over it with the window background color (COLOR_3DFACE) and 
once to draw the hand&#8212;in black&#8212;in its new position.</p>

<p>With this <I>OnTimer</I> mechanism in place, the clock's second hand is 
moved roughly once per second and the hour and minute hands are moved whenever 
the current number of minutes past the hour no longer equals the previously 
recorded minutes-past-the-hour. Because the hands are drawn to reflect the current time 
and not some assumed time based on the number of WM_TIMER messages received, 
it doesn't matter if WM_TIMER messages are skipped as the window is dragged 
or resized. If you watch closely, you'll see that the second hand occasionally 
advances by two seconds rather than one. That's because every now and then a 
WM_TIMER message arrives just before a new second ticks off and the next WM_TIMER 
message arrives a split second after the next new second. You could prevent this from 
happening by lowering the timer interval to, say, 0.5 second. The cost would be 
more overhead to the system, but the added overhead would be minimal because 
<I>OnTimer</I> is structured so that it redraws the clock hands (by far the most labor-intensive 
part of the process) only if the time has changed since the last timer message.</p>

<p>Before doing anything else, <I>OnTimer</I> calls the main window's 
<I>IsIconic</I> function to determine whether the window is currently minimized. 
<I>IsIconic</I> returns nonzero for a minimized window and 0 for an unminimized window. (A complementary 
function, <I>CWnd::IsZoomed</I>, returns a nonzero value if a window is maximized and 0 if 
it isn't.) If <I>IsIconic</I> returns nonzero, <I>OnTimer</I> exits immediately to prevent the 
clock display from being updated when the window isn't displayed. When a 
minimized window calls <I>GetClientRect</I> in Windows 95 or higher or Windows NT 4.0 or 
higher, the returned rectangle is a NULL rectangle&#8212;one whose coordinates equal 0. 
The application can try to paint in this rectangle, but the GDI will clip the output. 
Checking for a minimized window upon each timer tick reduces the load on the CPU 
by eliminating unnecessary drawing.</p>

<p>If you'd rather that Clock not sit idle while its window is minimized, try 
rewriting the beginning of the <I>OnTimer</I> function so that it looks like this:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
CTime time = CTime::GetCurrentTime ();
int nSecond = time.GetSecond ();
int nMinute = time.GetMinute ();
int nHour = time.GetHour () % 12;

if (IsIconic ()) {
    CString time;
    time.Format (_T (&quot;%0.2d:%0.2d:%0.2d&quot;), nHour, nMinute, nSecond);
    SetWindowText (time);
    return;
}

else {
    SetWindowText (_T (&quot;Clock&quot;));
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
}
</PRE>
</td></tr></table></p>

<P>An application can change the text displayed next to its icon in the taskbar by 
changing the window title with <I>CWnd::SetWindowText</I>. If modified as shown above, 
Clock will tick off the seconds in the taskbar while it is minimized.</p>

<A NAME="436"><H2>Getting the Current Time:The <I>CTime</I> Class</H2></A>
<P>To query the system for the current time, Clock uses a <I>CTime</I> object. <I>CTime</I> is an MFC class that represents times and dates. It includes convenient member functions 
for getting the date, time, day of the week (Sunday, Monday, Tuesday, and so on), 
and other information. Overloaded operators such as +, 
-, and &gt; allow you to manipulate times and dates with the ease of simple integers.</p>

<p>The <I>CTime</I> member functions that interest us are <I>GetCurrentTime</I>, which is a static function that returns a 
<I>CTime</I> object initialized to the current date and time; <I>GetHour</I>, which returns the hour (0 through 23); 
<I>GetMinute</I>, which returns the number of minutes past the hour (0 through 59); and 
<I>GetSecond</I>, which returns the number of seconds (0 through 59). 
<I>OnTimer</I> uses the following statements to retrieve 
the current hour, minute, and second so that it can determine whether the clock 
display needs to be updated:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
CTime time = CTime::GetCurrentTime ();
int nSecond = time.GetSecond ();
int nMinute = time.GetMinute ();
int nHour = time.GetHour () % 12;
</PRE>
</td></tr></table></p>

<P>The modulo-12 operation applied to <I>GetHour</I>'s return value converts the hour to 
an integer from 0 through 11. <I>CMainWindow</I>'s constructor uses similar code to 
initialize <I>m_nPrevHour</I>, <I>m_nPrevMinute</I>, and <I>m_nPrevSecond</I>.</p>

<A NAME="437"><H2>Using the MM_ISOTROPIC Mapping Mode</H2></A>

<P>Up to now, most of the applications that we've developed have used the 
default MM_TEXT mapping mode. The mapping mode governs how Windows converts 
the logical units passed to <I>CDC</I> drawing functions into device units (pixels) on the 
display. In the MM_TEXT mapping mode, logical units and device units are one and 
the same, so if an application draws a line from (0,0) to (50,100), the line extends 
from the pixel in the upper left corner of the display surface to the pixel that lies 50 
pixels to the right of and 100 pixels below the upper left corner. This assumes, of 
course, that the drawing origin hasn't been moved from its default location in the upper 
left corner of the display surface.</p>

<p>MM_TEXT is fine for most applications, but you can use other GDI 
mapping modes to lessen an application's dependency on the physical characteristics of 
the display. (For a review of GDI mapping modes, refer to Chapter 2.) In the 
MM_LOENGLISH mapping mode, for example, one logical unit is equal to 1/100 of an 
inch, so if you want to draw a line exactly 1 inch long, you can use a length of 100 
units and Windows will factor in the number of pixels per inch when it scan-converts 
the line into pixels. The conversion might not be perfect for screen DCs because 
Windows uses assumed pixel-per-inch values for screens that aren't based on the 
physical screen size. Windows can obtain precise pixel-per-inch values for printers 
and other hardcopy devices, however, so by using MM_LOENGLISH for printer 
output, you really can draw a line 1 inch long.</p>

<p>Clock uses the MM_ISOTROPIC mapping mode, in which logical units 
measured along the <I>x</I> axis have the same physical dimensions as logical units measured 
along the <I>y</I> axis. Before drawing the clock's face and hands in response to a WM_TIMER 
or WM_PAINT message, Clock measures the window's client area with 
<I>GetClientRect</I> and creates a device context. Then it sets the mapping mode to MM_ISOTROPIC, 
moves the origin of the coordinate system so that the logical point (0,0) lies at the center 
of the window's client area, and sets the window extents so that the window's 
client area measures 1,000 logical units in each direction. Here's how it looks in code:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
CRect rect;
GetClientRect (&amp;rect);

CClientDC dc (this); // In OnPaint, use CPaintDC instead.
dc.SetMapMode (MM_ISOTROPIC);
dc.SetWindowExt (1000, 1000);
dc.SetViewportExt (rect.Width (), -rect.Height ());
dc.SetViewportOrg (rect.Width () / 2, rect.Height () / 2);
</PRE>
</td></tr></table></p>

<P>The negative value passed to <I>SetViewportExt</I> specifying the viewport's physical 
height orients the coordinate system such that values of 
<I>y</I> increase in the upward direction. If the negative sign were omitted, increasing values of 
<I>y</I> would move down the screen rather than up because Windows numbers pixels at the bottom of the screen 
higher than it does pixels at the top. Figure 14-3 shows what the coordinate system 
looks like after it is transformed. The coordinate system is centered in the window's 
client area, and values of <I>x</I> and <I>y</I> increase as you move to the right and up. The result is 
a four-quadrant Cartesian coordinate system that happens to be a very convenient 
model for drawing an analog clock face.</p>

<p>
<img src="images/F14mg03.JPG" width=364 height=412 border="0">
</p><p>
<!-- CAPTION --><B>Figure 14-3.</B> <I>Clock's coordinate system for screen output.</I><!-- /CAPTION -->
</p>

<p>Once you've configured the coordinate system this way, you can write the 
routines that draw the clock's face and hands without regard for the physical 
dimensions of the window. When <I>DrawHand</I> is called to draw a clock hand, the length 
value passed in the second parameter is either 200 for an hour hand or 400 for a 
minute hand. <I>DrawSecondHand</I>, too, is passed a length of 400. Because the distance 
from the origin of the coordinate system to any edge of the window is 500 logical 
units, the minute and second hands extend outward 80 percent of the distance to the 
nearest window edge and the hour hand spans 40 percent of the distance. If you used 
the MM_TEXT mapping mode instead, you'd have to scale every coordinate and 
every distance manually before passing it to the GDI.</p>

<A NAME="438"><H2>Hiding and Displaying the Title Bar</H2></A>

<P>Clock's system menu contains two extra commands: Remove Title and Stay On 
Top. Remove Title removes the window's title bar so that the clock face fills the 
entire window. You can restore the title bar by displaying the system menu again and 
selecting Restore Title, which appears where Remove Title used to be. The magic 
underlying this transformation is simple, yet adding or removing a title bar on the fly 
is enough to make even seasoned Windows programmers scratch their heads in 
bewilderment the first time they try it.</p>

<p>The secret lies in <I>CMainWindow::SetTitleBarState</I>. The attribute that 
determines whether a window has a title bar is the WS_CAPTION style bit, which is included 
in the WS_OVERLAPPEDWINDOW style used by most frame windows. Creating a 
window without a title bar is as simple as omitting WS_CAPTION from the window 
style. It follows that you can remove a title bar from a window that already exists by 
stripping the WS_CAPTION bit. MFC's <I>CWnd::ModifyStyle</I> function changes a 
window's style with one simple function call. When Remove/Restore Title is selected from 
Clock's system menu, <I>CMainWindow::OnSysCommand</I> toggles the value stored in 
<I>CMainWindow::m_bFullWindow</I> from 0 to 1 or 1 to 0 and then calls 
<I>CMainWindow::SetTitleBarState</I>, which adds or removes the WS_CAPTION style based on the 
current value of <I>m_bFullWindow</I>:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
if (m_bFullWindow ) {
    ModifyStyle (WS_CAPTION, 0);
    pMenu-&gt;ModifyMenu (IDM_SYSMENU_FULL_WINDOW, MF_STRING,
        IDM_SYSMENU_FULL_WINDOW, _T (&quot;Restore &amp;Title&quot;));
}
else {
    ModifyStyle (0, WS_CAPTION);
    pMenu-&gt;ModifyMenu (IDM_SYSMENU_FULL_WINDOW, MF_STRING,
        IDM_SYSMENU_FULL_WINDOW, _T (&quot;Remove &amp;Title&quot;));
}
</PRE>
</td></tr></table></p>

<P>The first parameter passed to <I>ModifyStyle</I> specifies the style or styles to remove, 
and the second parameter specifies the style or styles to 
add.<I> SetTitleBarState</I> also sets the menu item text to match the state of the style bit: &quot;Remove Title&quot; if the title bar 
is displayed and &quot;Restore Title&quot; if it isn't.</p>

<p>Toggling WS_CAPTION on and off is only half the battle, however. The trick 
is getting the window's nonclient area to repaint once the window style is 
changed. Calling <I>CWnd::Invalidate</I> won't do it, but calling 
<I>SetWindowPos</I> with a SWP_DRAWFRAME parameter will:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
SetWindowPos (NULL, 0, 0, 0, 0, SWP_NOMOVE &#166; SWP_NOSIZE &#166;  
    SWP_NOZORDER &#166; SWP_DRAWFRAME);
</PRE>
</td></tr></table></p>

<P>The combination of <I>SetWindowPos</I> and SWP_DRAWFRAME causes the entire 
window, including the title bar, to redraw. The other SWP flags passed to 
<I>SetWindowPos</I> preserve the window's position, size, and position in the 
<I>z</I>-order&#8212;the front-to-back ordering of windows that determines which windows are painted on top of others.</p>

<A NAME="439"><H2>Implementing Client-Area Drag</H2></A>

<P>One problem with a window without a title bar is that it can't be repositioned 
with the mouse. Windows are dragged by their title bars, and when there's no title 
bar, the user has nothing to grab onto. Clock solves this little dilemma by playing a 
trick with the window's WM_NCHITTEST handler so that the window can be dragged 
by its client area, a feature Windows programmers call <I>client-area drag.</I></p>

<p>In Windows, every mouse message is preceded by a WM_NCHITTEST 
message containing screen coordinates identifying the cursor location. The message is 
normally handled by <I>::DefWindowProc</I>, which returns a code that tells Windows 
what part of the window the cursor is over. Windows uses the return value to decide 
what type of mouse message to send. For example, if the left mouse button is clicked 
over the window's title bar, <I>::DefWindowProc</I>'s WM_NCHITTEST handler returns 
HTCAPTION and Windows sends the window a WM_NCLBUTTONDOWN message. If 
<I>::DefWindowProc</I> returns HTCLIENT instead, Windows converts the cursor 
coordinates from screen coordinates to client coordinates and passes them to the window in 
a WM_LBUTTONDOWN message.</p>

<p>The fact that an application sees mouse messages in raw form makes for 
some interesting possibilities. The following 
<I>OnNcHitTest</I> handler implements client-area drag by fooling Windows into thinking that the mouse is over the title bar when 
in fact it's over the window's client area:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
UINT CMainWindow::OnNcHitTest (CPoint point)
{
    UINT nHitTest = CFrameWnd::OnNcHitTest (point);
    if (nHitTest == HTCLIENT)
        nHitTest = HTCAPTION;
    return nHitTest;
}
</PRE>
</td></tr></table></p>

<P>With this <I>OnNcHitTest</I> handler in place, a window is as easily dragged by its 
client area as by its title bar. And it works even if the window doesn't 
<I>have</I> a title bar. Try it: click the left mouse button in Clock's client area, and move the mouse with the 
button held down. The window should go wherever the mouse goes.</p>

<p>Clock uses an <I>OnNcHitTest</I> handler similar to the one shown above. The 
only difference is that Clock verifies that the left mouse button is down before 
replacing an HTCLIENT return code with HTCAPTION so that other mouse 
messages&#8212;particularly right-button mouse messages that precede WM_CONTEXTMENU 
messages&#8212;will get through unscathed:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
UINT CMainWindow::OnNcHitTest (CPoint point)
{
    UINT nHitTest = CFrameWnd::OnNcHitTest (point);
    if ((nHitTest == HTCLIENT) &amp;&amp;
        (::GetAsyncKeyState (MK_LBUTTON) &lt; 0))
        nHitTest = HTCAPTION;
    return nHitTest;
}
</PRE>
</td></tr></table></p>

<P>The call to <I>::GetAsyncKeyState</I> checks the left mouse button and returns a 
negative value if the button is currently down.</p>

<A NAME="440"><H2>Using the System Menu as a Context Menu</H2></A>

<P>Removing a window's title bar has other implications, too. Without a title bar, the 
user has nothing to click on to display the system menu so that the title bar can be 
restored. Clock's solution is an <I>OnContextMenu</I> handler that displays the system 
menu as a context menu when the right mouse button is clicked in the window's client 
area. Popping up a system menu at an arbitrary location is easier said than done 
because there's no convenient API function for displaying a system menu 
programmatically. Clock demonstrates one technique that you can use to do it yourself.</p>

<p>When Clock's client area is clicked with the right mouse button, <I>CMainWindow</I>'s 
<I>OnContextMenu</I> handler retrieves a <I>CMenu</I> pointer to the system menu with 
<I>GetSystemMenu</I> and displays the menu with <I>CMenu::TrackPopupMenu</I>:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
CMenu* pMenu = GetSystemMenu (FALSE);
    <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
int nID = (int) pMenu-&gt;TrackPopupMenu (TPM_LEFTALIGN &#166;
    TPM_LEFTBUTTON &#166; TPM_RIGHTBUTTON &#166; TPM_RETURNCMD, point.x,
    point.y, this);
</PRE>
</td></tr></table></p>

<P>One problem with this solution is that commands selected from the menu 
produce WM_COMMAND messages instead of WM_SYSCOMMAND messages. To 
compensate, Clock passes <I>TrackPopupMenu</I> a TPM_RETURNCMD flag instructing it to 
return the ID of the selected menu item. If <I>TrackPopupMenu</I> returns a positive, nonzero value, indicating that an item was selected, Clock sends itself a 
WM_SYSCOMMAND message with <I>wParam</I> equal to the menu item ID as shown below.</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
if (nID &gt; 0)
    SendMessage (WM_SYSCOMMAND, nID, 0);
</PRE>
</td></tr></table></p>

<P>Consequently, <I>OnSysCommand</I> gets called to process selections from the 
pseudo_system menu just as it does for selections from the real system menu. To prevent 
the framework from disabling the items added to the system menu because of the 
lack of ON_COMMAND handlers, <I>CMainWindow</I>'s constructor sets <I>m_bAutoMenuEnable</I> 
to FALSE. Normally, the framework's automatic enabling and disabling of menu 
items doesn't affect items added to the system menu, but Clock's system menu is an 
exception because it's treated as a conventional menu when it's displayed with 
<I>TrackPopupMenu</I>.</p>

<P>So far, so good. There's just one problem remaining. Windows 
interactively enables and disables certain commands in the system menu so that the selection 
of commands available is consistent with the window state. For example, the Move, 
Size, and Maximize commands are grayed in a maximized window's system menu but 
the Restore and Minimize commands are not. If the same window is restored to 
its unmaximized size, Restore is grayed out but all other commands are enabled. 
Unfortunately, when you get a menu pointer with 
<I>GetSystemMenu</I>, the menu items haven't been updated yet. Therefore, 
<I>OnContextMenu</I> calls a <I>CMainWindow</I> function 
named <I>UpdateSystemMenu</I> to manually update the menu item states based on the 
current state of the window. After <I>UpdateSystemMenu</I> updates the system menu by placing 
a series of calls to <I>CMenu::GetMenuString</I> and <I>CMenu::ModifyMenu</I>, it uses the 
<I>::SetMenuDefaultItem</I> API function to set the default menu item (the one displayed 
in boldface type) to either Restore or Maximize, depending on the window state. 
<I>UpdateSystemMenu</I> is hardly an ideal solution, but it works, and to date I haven't found 
a better way to keep the items in a programmatically displayed system menu in 
sync with the window the menu belongs to.</p>

<A NAME="441"><H2>Topmost Windows</H2></A>

<P>One of the innovations Windows 3.1 introduced was the notion of a 
<I>topmost window</I>&#8212;a window whose position in the 
<I>z</I>-order is implicitly higher than those of 
conventional, or nontopmost, windows. Normally, the window at the top of the 
<I>z</I>-order is painted on top of other windows, the window that's second in the 
<I>z</I>-order is painted on top of windows other than the first, and so on. A topmost window, however, 
receives priority over other windows so that it's not obscured even if it's at the 
bottom of the <I>z</I>-order. It's always visible, even while it's running in the background.</p>

<p>The Windows taskbar is the perfect example of a topmost window. By 
default, the taskbar is designated a topmost window so that it will be drawn on top of 
other windows. If two (or more) topmost windows are displayed at the same time, the 
normal rules of <I>z</I>-ordering determine the visibility of each one relative to the other. You 
should use topmost windows sparingly because if all windows were topmost windows, 
a topmost window would no longer be accorded priority over other windows.</p>

<p>The difference between a topmost window and a nontopmost window is 
an extended window style bit. WS_EX_TOPMOST makes a window a topmost 
window. You can create a topmost frame window by including a WS_EX_TOPMOST flag 
in the call to <I>Create</I>, like this:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
Create (NULL, _T (&quot;MyWindow&quot;), WS_OVERLAPPEDWINDOW, rectDefault,
    NULL, NULL, WS_EX_TOPMOST);
</PRE>
</td></tr></table></p>

<P>The alternative is to add the style bit after the window is created by calling 
<I>SetWindowPos</I> with a <I>&amp;wndTopMost</I> parameter, as shown here:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
SetWindowPos (&amp;wndTopMost, 0, 0, 0, 0, SWP_NOMOVE &#166; SWP_NOSIZE);
</PRE>
</td></tr></table></p>

<P>You can convert a topmost window into a nontopmost window by calling 
<I>SetWindowPos</I> with the first parameter equal to 
<I>&amp;wndNoTopMost</I> rather than <I>&amp;wndTopMost</I>.</p>

<p>Clock uses <I>SetWindowPos</I> to make its window a topmost window when 
Stay On Top is checked in the system menu and a nontopmost window when Stay 
On Top is unchecked. The work is done by <I>CMainWindow::SetTopMostState</I>, which is called by 
<I>OnSysCommand</I>. When Stay On Top is checked, Clock is visible on 
the screen at all times, even if it's running in the background and it overlaps the 
application running in the foreground.</p>

<A NAME="442"><H2>Making Configuration Settings Persistent</H2></A>

<P>Clock is the first program presented thus far that makes program settings 
persistent by recording them on disk. The word <I>persistent</I> comes up a lot in discussions of Windows programming. Saying that a piece of information is persistent means 
that it's preserved across sessions. If you want Clock to run in a tiny window in the 
lower right corner of your screen, you can size it and position it once and it will 
automatically come back up in the same size and position the next time it's started. For 
users who like to arrange their desktops a certain way, little touches like this one make 
the difference between a good application and a great one. Other Clock 
configuration settings are preserved, too, including the title bar and stay-on-top states.</p>

<p>The key to preserving configuration information across sessions is to store it 
on the hard disk so that it can be read back again the next time the application is 
started. In 16-bit Windows, applications commonly use <I>::WriteProfileString</I>, 
<I>::GetProfileString</I>, and other API functions to store configuration settings in Win.ini or private INI 
files. In 32-bit Windows, INI files are still supported for backward compatibility, but 
programmers are discouraged from using them. 32-bit applications should store 
configuration settings in the registry instead.</p>

<p>The registry is a binary database that serves as a central data repository for 
the operating system and the applications it hosts. Information stored in the registry 
is organized hierarchically using a system of keys and subkeys, which are analogous 
to directories and subdirectories on a hard disk. Keys can contain data entries just 
as directories can contain files. Data entries have names and can be assigned text or 
binary values. The uppermost level in the registry's hierarchy is a set of six root keys 
named HKEY_CLASSES_ROOT, HKEY_USERS, HKEY_CURRENT_USER, 
HKEY_LOCAL_MACHINE, HKEY_CURRENT_CONFIG, and HKEY_DYN_DATA. Per 
Microsoft's recommendations, Windows applications should store private configuration 
settings under the key</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
HKEY_CURRENT_USER\Software\<I>CompanyName</I>\<I>ProductName</I>\<I>Version</I>
</PRE>
</td></tr></table></p>

<P>where <I>CompanyName</I> is the company name, 
<I>ProductName</I> is the product name, and 
<I>Version</I> is the product's version number. A registry entry that records the 
user-selectable window background color for version 2.0 of a product named 
WidgetMaster from WinWidgets, Inc., might look like this:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
HKEY_CURRENT_USER\Software\WinWidgets, Inc.\WidgetMaster\Version 2.0\BkgndColor=4
</PRE>
</td></tr></table></p>

<P>Because the information is stored under HKEY_CURRENT_USER, it is maintained 
on a per-user basis. That is, if another user logs in and runs the same application 
but selects a different background color, a separate <I>BkgndColor</I> value will be recorded for that user.</p>

<P>The Win32 API includes an assortment of functions for reading and writing 
to the registry, but MFC provides a layer on top of the API that makes reading and 
writing application-specific registry values no different from using ordinary INI files. 
A call to <I>CWinApp::SetRegistryKey</I> with the name of a registry key directs the 
framework to use the registry instead of an INI file. The key name passed to 
<I>SetRegistryKey</I> corresponds to the company name&#8212;for example, &quot;WinWidgets, Inc.&quot; in the 
example above. String and numeric values are written to the registry with 
<I>CWinApp</I>'s<I> WriteProfileString</I> and <I>WriteProfileInt</I> functions and read back with 
<I>GetProfileString</I> and <I>GetProfileInt</I>. In an application named MyWord.exe, the statements</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
SetRegistryKey (_T (&quot;WordSmith&quot;));
WriteProfileInt (_T (&quot;Version 1.0&quot;), _T (&quot;MRULength&quot;), 8);
</PRE>
</td></tr></table></p>

<P>create the following numeric registry entry:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
HKEY_CURRENT_USER\Software\WordSmith\MYWORD\Version 1.0\MRULength=8
</PRE>
</td></tr></table></p>

<P>The statement</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
m_nMRULength = GetProfileInt (_T (&quot;Version 1.0&quot;), _T (&quot;MRULength&quot;), 4);
</PRE>
</td></tr></table></p>

<P>reads it back and returns 4 if the entry doesn't exist. Note that MFC generates 
the product name for you by stripping the .exe extension from the executable file name.</p>

<P>Before it terminates, Clock records the following configuration settings in 
the registry:</p>

<UL>
<P><LI>The value of <I>CMainWindow::m_bFullWindow</I>, which indicates whether the title bar is displayed</li></p>
<P><LI>The value of <I>CMainWindow::m_bStayOnTop</I>, which indicates whether Stay On Top is selected</li></p>
<P><LI>The size and position of the frame window</li></p>
</ul>

<P>The next time it starts up, Clock reads the settings back. The full complement of 
entries that Clock stores in the registry is shown in Figure 14-4. The 
<I>CMainWindow</I> functions <I>SaveWindowState</I> and <I>RestoreWindowState</I> do the reading and 
writing. <I>SaveWindowState</I> is called from the window's <I>OnClose</I> and <I>OnEndSession</I> handlers, which are called just before the application closes and just before Windows 
shuts down, respectively. If Windows is shut down, a running application doesn't 
receive a WM_CLOSE message, but it does receive a WM_ENDSESSION message. If you 
want to know whether Windows is preparing to shut down, simply add an 
ON_WM_ENDSESSION entry to the main window's message map and write an 
<I>OnEndSession</I> handler to go with it. The <I>bEnding</I> parameter passed to 
<I>OnEndSession</I> indicates whether Windows is in fact shutting down. A nonzero value means it is; 0 
means Windows was about to shut down but another application vetoed the operation. 
A WM_ENDSESSION message is preceded by a WM_QUERYENDSESSION message, 
in which each application is given a chance to say yes or no to an impending shutdown.</p>

<P>
<A HREF="javascript:fullSize('F14mg04x.htm')"> <img src="images/F14mg04.JPG" width=404 height=263 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 14-4.</B> <I>Clock's registry entries as seen in Registry Editor (RegEdit.exe).</I><!-- /CAPTION -->
</p>

<p>Clock's title bar and stay-on-top settings are saved to the 
HKEY_CURRENT_USER\Software\Programming Windows with MFC\CLOCK\Version 1.0 branch 
of the registry with the following statements in <I>SaveWindowState</I>.</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
CString version = _T (&quot;Version 1.0&quot;);
myApp.WriteProfileInt (version, _T (&quot;FullWindow&quot;), m_bFullWindow);
myApp.WriteProfileInt (version, _T (&quot;StayOnTop&quot;), m_bStayOnTop);
</PRE>
</td></tr></table></p>

<P>The settings are read back and applied to the window in 
<I>RestoreWindowState</I>:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
CString version = _T (&quot;Version 1.0&quot;);
m_bFullWindow = myApp.GetProfileInt (version, _T (&quot;FullWindow&quot;), 0);
SetTitleBarState ();
m_bStayOnTop = myApp.GetProfileInt (version, _T (&quot;StayOnTop&quot;), 0);
SetTopMostState ();
</PRE>
</td></tr></table></p>

<P><I>RestoreWindowState</I> is called by <I>CMyApp::InitInstance</I> right after the window is 
created but before it's displayed on the screen.</p>

<P>Saving and restoring the window's size and position is a little trickier. If 
you've never written an application with a window that remembers its size and position, 
you might think it would be a simple matter of saving the coordinates returned by 
<I>CWnd::GetWindowRect</I> so that they can be passed to 
<I>Create</I> or <I>CreateEx</I>. But there's more to it than that. If you fail to take into account the window's current state 
(minimized, maximized, or neither minimized nor maximized), all kinds of bad things can 
happen. For example, if you pass the coordinates of a maximized window to 
<I>Create</I> or <I>CreateEx</I>, the resultant window will occupy the full extent of the screen but its 
title bar will have a maximize box instead of a restore box. A persistent window 
that's closed while it's minimized or maximized should come back up in the minimized 
or maximized state, and it should also remember its normal size so that restoring it 
will restore its former size.</p>

<P>The key to preserving a window's size and position and taking relevant 
state information into account lies in a pair of <I>CWnd</I> functions named 
<I>GetWindowPlacement</I> and <I>SetWindowPlacement</I>. Each accepts the address of a WINDOWPLACEMENT 
structure, which is defined as follows:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
typedef struct tagWINDOWPLACEMENT {
      UINT  length;
      UINT  flags;
      UINT  showCmd;
      POINT ptMinPosition;
      POINT ptMaxPosition;
      RECT  rcNormalPosition;
  } WINDOWPLACEMENT;
</PRE>
</td></tr></table></p>

<P>WINDOWPLACEMENT brings together in one place everything Windows needs 
to know to characterize a window's screen state. <I>length</I> specifies the size of the WINDOWPLACEMENT structure. Both 
<I>CWnd::GetWindowPlacement</I> and <I>CWnd::SetWindowPlacement</I> fill in this field for you. 
<I>flags</I> contains zero or more bit flags specifying information about minimized windows. The WPF_RESTORETOMAXIMIZED flag, 
if present, indicates that a minimized window will be maximized when it is 
restored. <I>showCmd</I> specifies the window's current display state. It is set to 
SW_SHOWMINIMIZED if the window is minimized, SW_SHOWMAXIMIZED if the window 
is maximized, or SW_SHOWNORMAL if the window is neither minimized nor 
maximized. <I>ptMinPosition</I> and <I>ptMaxPosition</I> hold the screen coordinates of the window's 
upper left corner when it is minimized and maximized, respectively. (Don't rely 
on <I>ptMinPosition</I> to tell you anything; in current versions of Windows, 
<I>ptMinPosition</I> is set to (3000,3000) when a window is minimized.) 
<I>rcNormalPosition</I> contains the screen coordinates of the window's &quot;normal,&quot; or unminimized and unmaximized, 
screen position. When a window is minimized or maximized, 
<I>rcNormalPosition</I> specifies the position and size the window will be restored to&#8212;provided, of course, that 
the WPF_RESTORETOMAXIMIZED flag isn't set to force a restored window to full screen.</p>

<p>You can preserve a window's screen state across sessions by saving the 
<I>flags</I>, <I>showCmd</I>, and <I>rcNormalPosition</I> values in the window's WINDOWPLACEMENT 
structure and restoring these values when the window is re-created. You don't need 
to save <I>ptMinPosition</I> and <I>ptMaxPosition</I> because Windows fills in their values 
when the window is minimized or maximized. Clock's 
<I>SaveWindowState</I> function uses <I>GetWindowPlacement</I> to initialize a WINDOWPLACEMENT structure and then 
writes the pertinent members of that structure to the registry. The window state is 
restored when <I>CMyApp::InitInstance</I> calls <I>CMainWindow::RestoreWindowState</I>, which in 
turn calls <I>GetWindowPlacement</I> to fill in a WINDOWPLACEMENT structure; reads the 
<I>flags</I>, <I>showCmd</I>, and <I>rcNormalPosition</I> values from the registry; copies them to the 
structure; and calls <I>SetWindowPlacement</I>. The SW_SHOWMINIMIZED, 
SW_SHOWMAXIMIZED, or SW_SHOWNORMAL parameter passed to 
<I>SetWindowPlacement</I> in <I>showCmd</I> makes the window visible, so there's no need to call 
<I>ShowWindow</I> if <I>RestoreWindowState</I> returns TRUE, indicating that the window state was successfully restored. In fact, 
you should skip the usual call placed to <I>ShowWindow</I> from <I>InitInstance</I> if 
<I>RestoreWindowState</I> returns TRUE because the application object's 
<I>m_nCmdShow</I> parameter might alter the window's state. Clock's 
<I>InitInstance</I> function looks like this:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
BOOL CMyApp::InitInstance ()
{
    SetRegistryKey (_T (&quot;Programming Windows with MFC&quot;));
    m_pMainWnd = new CMainWindow;
    if (!((CMainWindow*) m_pMainWnd)-&gt;RestoreWindowState ())
        m_pMainWnd-&gt;ShowWindow (m_nCmdShow);
    m_pMainWnd-&gt;UpdateWindow ();
    return TRUE;
}
</PRE>
</td></tr></table></p>

<P>The first time Clock is executed, <I>ShowWindow</I> is called in the normal way 
because <I>RestoreWindowState</I> returns FALSE. In subsequent invocations, the window's 
size, position, and visibility state are set by <I>RestoreWindowState,</I> and <I>ShowWindow</I> 
is skipped.</p>

<p>Before calling <I>SetWindowPlacement</I> to apply the state values retrieved from 
the registry, <I>RestoreWindowState</I> ensures that a window positioned near the edge of 
a 1,024-by-768 screen won't disappear if Windows is restarted in 640-by-480 or 
800-by-600 mode by comparing the window's normal position with the screen extents:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
wp.rcNormalPosition.left = min (wp.rcNormalPosition.left,
    ::GetSystemMetrics (SM_CXSCREEN) -
    ::GetSystemMetrics (SM_CXICON));
wp.rcNormalPosition.top = min (wp.rcNormalPosition.top,
    ::GetSystemMetrics (SM_CYSCREEN) -
    ::GetSystemMetrics (SM_CYICON));
</PRE>
</td></tr></table></p>

<P>Called with SM_CXSCREEN and SM_CYSCREEN parameters, 
<I>::GetSystemMetrics</I> returns the screen's width and height, respectively, in pixels. If the window 
coordinates retrieved from the registry are 700 and 600 and Windows is running at a resolution 
of 640 by 480, this simple procedure transforms the 700 and 600 into 640 and 480 
minus the width and height of an icon. Rather than appear out of sight off the 
screen and probably leave the user wondering why the application didn't start, the 
window will appear just inside the lower right corner of the screen.</p>

<P>A good way to test a program that preserves a window's position and size is 
to resize the window to some arbitrary size, maximize it, minimize it, and then 
close the application with the window minimized. When the program is restarted, the 
window should come up minimized, and clicking the minimized window's icon in 
the taskbar should remaximize it. Clicking the restore button should restore the 
window's original size and position. Try this procedure with Clock, and you should find that 
it passes the test with flying colors.</p>

<A NAME="443"><H2>Controlling the Window Size: The WM_GETMINMAXINFO Message</H2></A>

<P>A final aspect of Clock that deserves scrutiny is its 
<I>OnGetMinMaxInfo</I> handler. As a window is being resized, it receives a series of WM_GETMINMAXINFO messages 
with <I>lParam</I> pointing to a MINMAXINFO structure containing information about 
the window's minimum and maximum &quot;tracking&quot; sizes. You can limit a window's 
minimum and maximum sizes programmatically by processing WM_GETMINMAXINFO messages and copying the minimum width and height to the 
<I>x</I> and <I>y</I> members of the structure's <I>ptMinTrackSize</I> field and the maximum width and height to the 
<I>x</I> and <I>y</I> members of the <I>ptMaxTrackSize</I> field. Clock prevents its window from being 
reduced to less than 120 pixels horizontally and vertically with the following 
<I>OnGetMinMaxInfo</I> handler:</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
void CMainWindow::OnGetMinMaxInfo (MINMAXINFO* pMMI)
{
    pMMI-&gt;ptMinTrackSize.x = 120;
    pMMI-&gt;ptMinTrackSize.y = 120;
}
</PRE>
</td></tr></table></p>

<P>The tracking dimensions copied to MINMAXINFO are measured in device units, 
or pixels. In this example, the window's maximum size is unconstrained because 
<I>pMMI-&gt;ptMaxTrackSize</I> is left unchanged. You could limit the maximum window size 
to one-half the screen size by adding the statements</p>

<p><table cellpadding="5" width="95%">
<tr><td>
<PRE>
pMMI-&gt;ptMaxTrackSize.x = ::GetSystemMetrics (SM_CXSCREEN) / 2;
pMMI-&gt;ptMaxTrackSize.y = ::GetSystemMetrics (SM_CYSCREEN) / 2;
</PRE>
</td></tr></table></p>

<P>to the message handler.</p>

</BODY>
</HTML>




