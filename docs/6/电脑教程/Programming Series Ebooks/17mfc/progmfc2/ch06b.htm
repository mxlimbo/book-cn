<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>The CFile Class</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch06a.htm", "ch06c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="163"><H1>The <I>CFile</I> Class</H1></A>
<P><I>CFile</I> is a relatively simple class that encapsulates the portion of the Win32 API 
that deals with file I/O. Among its 25-plus member functions are functions for 
opening and closing files, reading and writing file data, deleting and renaming files, 
and retrieving file information. Its one public data member, 
<I>m_hFile</I>, holds the handle of the file associated with a 
<I>CFile</I> object. A protected <I>CString</I> data member 
named <I>m_strFileName</I> holds the file name. The member functions 
<I>GetFilePath</I>, <I>GetFileName</I>, and 
<I>GetFileTitle</I> can be used to extract the file name, in whole or in part. For 
example, if the full file name, path name included, is C:\Personal\File.txt, 
<I>GetFilePath</I> returns the entire string, 
<I>GetFileName</I> returns &quot;File.txt,&quot; and 
<I>GetFileTitle</I> returns &quot;File.&quot;</P>

<P>But to dwell on these functions is to disregard 
the features of <I>CFile</I> that are the most important to programmers&#8212;that is, the functions used to write data to 
disk and read it back. The next several sections offer a brief tutorial in the use of 
<I>CFile</I> and its rather peculiar way of letting you know when an error occurs. 
(<I>Hint</I>: If you've never used C++ exception handling, now is a good time to dust off the manual 
and brush up on it.)</P>

<A NAME="164"><H2>Opening, Closing, and Creating Files</H2></A>

<P>Files can be opened with <I>CFile</I> in either of two ways. The first option is to 
construct an uninitialized <I>CFile</I> object and call 
<I>CFile::Open</I>. The following code fragment 
uses this technique to open a file named File.txt with read/write access. Because no 
path name is provided in the function's first parameter, 
<I>Open</I> will fail unless the file is located in the current directory:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CFile file;
file.Open (_T (&quot;File.txt&quot;), CFile::modeReadWrite);
</pre>
</TD></TR></TABLE>
</P>

<P><I>CFile::Open</I> returns a BOOL indicating whether the operation was successful. 
The following example uses that return value to verify that the file was successfully opened:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CFile file;
if (file.Open (_T (&quot;File.txt&quot;), CFile::modeReadWrite)) {
    // It worked!
      <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
}
</pre>
</TD></TR></TABLE>
</P>

<P>A nonzero return value means the file was opened; 0 means it wasn't. If 
<I>CFile::Open</I> returns 0 and you want to know 
<I>why</I> the call failed, create a 
<I>CFileException</I> object and pass its address to 
<I>Open</I> in the third parameter:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CFile file;
CFileException e;
if (file.Open (_T (&quot;File.txt&quot;), CFile::modeReadWrite, &amp;e)) {
    // It worked!
      <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
}
else {
    // Open failed. Tell the user why.
    e.ReportError ();
}
</pre>
</TD></TR></TABLE>
</P>

<P>If <I>Open</I> fails, it initializes the 
<I>CFileException</I> object with information describing 
the nature of the failure. <I>ReportError </I>displays an error message based on that 
information. You can find out what caused the failure by examining the 
<I>CFileException</I>'s public <I>m_cause </I>data member. The documentation for 
<I>CFileException </I>contains a complete list of error codes.</P>

<P>The second option is to open the file using 
<I>CFile</I>'s constructor. Rather than construct an empty 
<I>CFile</I> object and call <I>Open</I>, you can create a 
<I>CFile</I> object and open a file in one step like this:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CFile file (_T (&quot;File.txt&quot;), CFile::modeReadWrite);
</pre>
</TD></TR></TABLE>
</P>

<P>If the file can't be opened, <I>CFile</I>'s constructor throws a 
<I>CFileException</I>. Therefore, code that opens files using 
<I>CFile::CFile</I> normally uses <I>try</I> and 
<I>catch</I> blocks to trap errors:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
try {
    CFile file (_T (&quot;File.txt&quot;), CFile::modeReadWrite);
      <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
}
catch (CFileException* e) {
    // Something went wrong.
    e-&gt;ReportError ();
    e-&gt;Delete ();
}
</pre>
</TD></TR></TABLE>
</P>

<P>It's up to you to delete the 
<I>CFileException</I> objects MFC throws to you. That's 
why this example calls <I>Delete</I> on the exception object after processing the exception. 
The only time you don't want to call <I>Delete</I> is the rare occasion when you use 
<I>throw</I> to rethrow the exception.</P>

<P>To create a new file rather than open an existing one, include a 
<I>CFile::modeCreate</I> flag in the second parameter to 
<I>CFile::Open</I> or the <I>CFile</I> constructor:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CFile file (_T (&quot;File.txt&quot;), CFile::modeReadWrite &#166; CFile::modeCreate);
</pre>
</TD></TR></TABLE>
</P>

<P>If a file created this way already exists, its length is truncated to 0. To create the 
file if it doesn't exist or to open it without truncating it if it does exist, include a 
<I>CFile::modeNoTruncate</I> flag as well:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CFile file (_T (&quot;File.txt&quot;), CFile::modeReadWrite &#166; CFile::modeCreate &#166;
    CFile::modeNoTruncate);
</pre>
</TD></TR></TABLE>
</P>

<P>An open performed this way almost always succeeds because the file is 
automatically created for you if it doesn't already exist.</P>

<P>By default, a file opened with 
<I>CFile::Open</I> or <I>CFile::CFile</I> is opened 
for exclusive access, which means that no one else can open the file. If desired, you can 
specify a sharing mode when opening the file to explicitly grant others permission to 
access the file, too. Here are the four sharing modes that you can choose from:</P>

<P>
<table valign="top" cellpadding=5 width="95%">
<tr><th valign="top"><I>Sharing Mode</I></th>
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top"><I>CFile::shareDenyNone</I></td>
<td valign="top">Opens the file nonexclusively</td>
</tr>
<tr>
<td valign="top"><I>CFile::shareDenyRead</I></td>
<td valign="top">Denies read access to other parties</td>
</tr>
<tr>
<td valign="top"><I>CFile::shareDenyWrite</I></td>
<td valign="top">Denies write access to other parties</td>
</tr>
<tr>
<td valign="top"><I>CFile::shareExclusive</I></td>
<td valign="top">Denies both read and write access to other 
parties (default)</td>
</tr>
</table>
</P>
       
<P>In addition, you can specify any one of the following three types of 
read/write access:</P>


<P>
<table valign="top" cellpadding=5 width="95%">
<tr><th valign="top"><I>Access Mode</I></th>
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top"><I>CFile::modeReadWrite</I></td>
<td valign="top"> Requests read and write access</td>
</tr>
<tr>
<td valign="top"><I>CFile::modeRead</I></td>
<td valign="top">Requests read access only</td>
</tr>
<tr>
<td valign="top"><I>CFile::modeWrite</I></td>
<td valign="top">Requests write access only</td>
</tr>
</table>
</P>
   
<P>A common use for these options is to allow any number of clients to open a file 
for reading but to deny any client the ability to write to it:</P>


<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CFile file (_T (&quot;File.txt&quot;), CFile::modeRead &#166; CFile::shareDenyWrite);
</pre>
</TD></TR></TABLE>
</P>


<P>If the file is already open for writing when this statement is executed, the call will 
fail and <I>CFile</I> will throw a 
<I>CFileException</I> with <I>m_cause</I> equal to 
<I>CFileException::sharingViolation</I>.</P>
<P>An open file can be closed in two ways. To close a file explicitly, call 
<I>CFile::Close</I> on the corresponding 
<I>CFile</I> object:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
file.Close ();
</pre>
</TD></TR></TABLE>
</P>


<P>If you'd prefer, you can let <I>CFile</I>'s destructor close the file for you. The class 
destructor calls <I>Close</I> if the file hasn't been closed already. This means that a 
<I>CFile</I> object created on the stack will be closed automatically when it goes out of scope. 
In the following example, the file is closed the moment the brace marking the end 
of the <I>try</I> block is reached:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
try {
    CFile file (_T (&quot;File.txt&quot;), CFile::modeReadWrite);
<img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    // CFile::~CFile closes the file.
}
</pre>
</TD></TR></TABLE>
</P>

<P>One reason programmers sometimes call 
<I>Close</I> explicitly is to close the file that 
is currently open so that they can open another file using the same 
<I>CFile</I> object.</P>

<A NAME="165"><H2>Reading and Writing</H2></A>

<P>A file opened with read access can be read using 
<I>CFile::Read</I>. A file opened with write access can be written with 
<I>CFile::Write</I>. The following example allocates a 4-KB 
file I/O buffer and reads the file 4 KB at a time. Error checking is omitted for clarity.</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
BYTE buffer[0x1000];
CFile file (_T (&quot;File.txt&quot;), CFile::modeRead);
DWORD dwBytesRemaining = file.GetLength ();

while (dwBytesRemaining) {
    UINT nBytesRead = file.Read (buffer, sizeof (buffer));
    dwBytesRemaining -= nBytesRead;
}
</pre>
</TD></TR></TABLE>
</P>

<P>A count of bytes remaining to be read is maintained in 
<I>dwBytesRemaining</I>, which is initialized with the file size returned by 
<I>CFile::GetLength</I>. After each call to 
<I>Read</I>, the number of bytes read from the file 
(<I>nBytesRead</I>) is subtracted from 
<I>dwBytesRemaining</I>. The <I>while</I> loop executes until 
<I>dwBytesRemaining</I> reaches 0.</P>

<P>The following example builds on the code in the previous paragraph by 
using <I>::CharLowerBuff</I> to convert all the uppercase characters read from the file to 
lowercase and using <I>CFile::Write</I> to write the converted text back to the file. Once 
again, error checking is omitted for clarity.</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
BYTE buffer[0x1000];
CFile file (_T (&quot;File.txt&quot;), CFile::modeReadWrite);
DWORD dwBytesRemaining = file.GetLength ();

while (dwBytesRemaining) {
    DWORD dwPosition = file.GetPosition ();
    UINT nBytesRead = file.Read (buffer, sizeof (buffer));
    ::CharLowerBuff ((LPTSTR)buffer, nBytesRead);
    file.Seek (dwPosition, CFile::begin);
    file.Write (buffer, nBytesRead);
    dwBytesRemaining -= nBytesRead;
}
</pre>
</TD></TR></TABLE>
</P>

<P>This example uses the <I>CFile</I> functions 
<I>GetPosition</I> and <I>Seek</I> to manipulate the 
file pointer&#8212;the offset into the file at which the next read or write is performed&#8212;so 
that the modified data is written over the top of the original. 
<I>Seek</I>'s second parameter specifies whether the byte offset passed in the first parameter is relative to 
the beginning of the file (<I>CFile::begin</I>), the end of the file 
(<I>CFile::end</I>), or the current position 
(<I>CFile::current</I>). To quickly seek to the beginning or end of a file, 
use <I>CFile::SeekToBegin</I> or 
<I>CFile::SeekToEnd</I>.</P>

<P><I>Read</I>, <I>Write</I>, and other <I>CFile</I> functions throw a 
<I>CFileException</I> if an error occurs during a file I/O operation. 
<I>CFileException::m_cause</I> tells you why the error 
occurred. For example, attempting to write to a disk that is full throws a 
<I>CFileException</I> with <I>m_cause</I> equal to 
<I>CFileException::diskFull</I>. Attempting to read beyond the end of 
a file throws a <I>CFileException</I> with 
<I>m_cause</I> equal to 
<I>CFileException::endOfFile</I>. Here's how the routine that converts all the lowercase text in a file to uppercase might 
look with error checking code included:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
BYTE buffer[0x1000];
try {
    CFile file (_T (&quot;File.txt&quot;), CFile::modeReadWrite);
    DWORD dwBytesRemaining = file.GetLength ();
    while (dwBytesRemaining) {
        DWORD dwPosition = file.GetPosition ();
        UINT nBytesRead = file.Read (buffer, sizeof (buffer));
        ::CharLowerBuff ((LPTSTR)buffer, nBytesRead);
        file.Seek (dwPosition, CFile::begin);
        file.Write (buffer, nBytesRead);
        dwBytesRemaining -= nBytesRead;
    }
}
catch (CFileException* e) {
    e-&gt;ReportError ();
    e-&gt;Delete ();
}
</pre>
</TD></TR></TABLE>
</P>


<P>If you don't catch exceptions thrown by 
<I>CFile</I> member functions, MFC will catch them for you. MFC's default handler for unprocessed exceptions uses 
<I>ReportError</I> to display a descriptive error message. Normally, however, it's in your best interest 
to catch file I/O exceptions to prevent critical sections of code from being skipped.</P>

<A NAME="166"><H2><I>CFile</I> Derivatives</H2></A>
<P><I>CFile</I> is the root class for an entire family of MFC classes. The members of this 
family and the relationships that they share with one another are shown in Figure 6-1.</P>

<P>
<img src="images/F06mg01.JPG" width=362 height=461 border=0>
</p><p>
<!-- CAPTION --><B>Figure 6-1.</B> <I>The </I>CFile<I> family.</I><!-- /CAPTION -->
</p>
 
<P>Some members of the <I>CFile</I> family exist solely to provide filelike interfaces 
to nonfile media. For example, <I>CMemFile</I> and 
<I>CSharedFile</I> let blocks of memory be read and written as if they were files. MFC's 
<I>COleDataObject::GetFileData</I> function, which is discussed in <a href="ch19a.htm">Chapter 19</a>, uses this handy abstraction to allow OLE drop targets 
and users of the OLE clipboard to retrieve data from memory with 
<I>CFile</I>::<I>Read</I>. <I>CSocketFile</I> provides a similar abstraction for TCP/IP sockets. MFC programmers sometimes 
place a <I>CSocketFile</I> object between a 
<I>CSocket</I> object and a <I>CArchive</I> object so that 
C++'s insertion and extraction operators can be used to write to and read from an 
open socket. <I>COleStreamFile</I> makes a stream object&#8212;a COM object that represents a 
byte stream&#8212;look like an ordinary file. It plays an important role in MFC applications 
that support object linking and embedding (OLE).</P>

<P><I>CStdioFile</I> simplifies the programmatic interface to text files. It adds just 
two member functions to those it inherits from 
<I>CFile</I>: a <I>ReadString</I> function for 
reading lines of text and a <I>WriteString</I> function for outputting lines of text. In 
<I>CStdioFile</I>-speak, a line of text is a string of characters delimited by a carriage return and line feed 
pair (0x0D and 0x0A). <I>ReadString</I> reads everything from the current file position up 
to, and optionally including, the next carriage return. 
<I>WriteString</I> outputs a text string and writes a carriage return and line feed to the file, too. The following code 
fragment opens a text file named File.txt and dumps its contents to the debug 
output window:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
try {
    CString string;
    CStdioFile file (_T (&quot;File.txt&quot;), CFile::modeRead);
    while (file.ReadString (string))
        TRACE (_T (&quot;%s\n&quot;), string);
}
catch (CFileException* e) {
    e-&gt;ReportError ();
    e-&gt;Delete ();
}
</pre>
</TD></TR></TABLE>
</P>

<P>Like <I>Read</I> and <I>Write</I>, 
<I>ReadString</I> and <I>WriteString</I> throw exceptions if an error 
prevents them from carrying out their missions.</P>

<A NAME="167"><H2>Enumerating Files and Folders</H2></A>

<P><I>CFile</I> includes a pair of static member functions named 
<I>Rename</I> and <I>Remove</I> that can be used to rename and delete files. It doesn't, however, include functions for 
enumerating files and folders. For that, you must resort to the Windows API.</P>

<P>The key to enumerating files and folders is a pair of API functions 
named <I>::FindFirstFile</I> and 
<I>::FindNextFile</I>. Given an absolute or relative file name 
specification (for example, &quot;C:\\*.*&quot; or 
&quot;*.*&quot;), <I>::FindFirstFile</I> opens a 
<I>find handle</I> and returns it to the caller. 
<I>::FindNextFile</I> uses that handle to enumerate file system objects. 
The general strategy is to call 
<I>::FindFirstFile</I> once to begin an enumeration and then 
to call <I>::FindNextFile</I> repeatedly until the enumeration is exhausted. Each successful 
call to <I>::FindFirstFile</I> or 
<I>::FindNextFile</I>&#8212;that is, a call to 
<I>::FindFirstFile</I> that returns any value other than INVALID_HANDLE_VALUE or a call to 
<I>::FindNextFile</I> that returns a non-NULL value&#8212;fills a WIN32_FIND_DATA structure with information about 
one file or directory. WIN32_FIND_DATA is defined this way in ANSI code builds:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
    CHAR   cFileName[ MAX_PATH ];
    CHAR   cAlternateFileName[ 14 ];
} WIN32_FIND_DATAA;

typedef WIN32_FIND_DATAA WIN32_FIND_DATA;
</pre>
</TD></TR></TABLE>
</P>

<P>To determine whether the item represented by the WIN32_FIND_DATA structure is 
a file or a directory, test the 
<I>dwFileAttributes</I> field for a 
FILE_ATTRIBUTE_DIRECTORY flag:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
if (fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {
    // It's a directory.
}
else {
    // It's a file.
}
</pre>
</TD></TR></TABLE>
</P>

<P>The <I>cFileName</I> and 
<I>cAlternateFileName</I> fields hold the file or directory name. 
<I>cFileName</I> contains the long name; 
<I>cAlternateFileName</I> contains the short (8.3 
format) name. When the enumeration is complete, you should close any handles 
returned by <I>::FindFirstFile</I> with 
<I>::FindClose</I>.</P>

<P>To demonstrate, the following routine enumerates all the files in the 
current directory and writes their names to the debug output window:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
WIN32_FIND_DATA fd;
HANDLE hFind = ::FindFirstFile (_T (&quot;*.*&quot;), &amp;fd);

if (hFind != INVALID_HANDLE_VALUE) {
    do {
        if (!(fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY))
            TRACE (_T (&quot;%s\n&quot;), fd.cFileName);
    } while (::FindNextFile (hFind, &amp;fd));
    ::FindClose (hFind);
}
</pre>
</TD></TR></TABLE>
</P>

<P>Enumerating all the subdirectories in the current directory requires just one 
simple change:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
WIN32_FIND_DATA fd;
HANDLE hFind = ::FindFirstFile (_T (&quot;*.*&quot;), &amp;fd);

if (hFind != INVALID_HANDLE_VALUE) {
    do {
        if (fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY)
            TRACE (_T (&quot;%s\n&quot;), fd.cFileName);
    } while (::FindNextFile (hFind, &amp;fd));
    ::FindClose (hFind);
}
</pre>
</TD></TR></TABLE>
</P>

<P>The more interesting case is how you can enumerate all the directories in 
a given directory <I>and its subdirectories</I>. The following function enumerates all 
the directories in the current directory and its descendants, writing the name of 
each directory to the debug output window. The secret? Whenever it encounters a 
directory, <I>EnumerateFolders</I> descends into that directory and calls itself recursively.</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
void EnumerateFolders ()
{
    WIN32_FIND_DATA fd;
    HANDLE hFind = ::FindFirstFile (_T (&quot;*.*&quot;), &amp;fd);

    if (hFind != INVALID_HANDLE_VALUE) {
        do {
            if (fd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {
                CString name = fd.cFileName;
                if (name != _T (&quot;.&quot;) &amp;&amp; name != _T (&quot;..&quot;)) {
                    TRACE (_T (&quot;%s\n&quot;), fd.cFileName);
                    ::SetCurrentDirectory (fd.cFileName);
                    EnumerateFolders ();
                    ::SetCurrentDirectory (_T (&quot;..&quot;));
                }
            }
        } while (::FindNextFile (hFind, &amp;fd));
        ::FindClose (hFind);
    }
}
</pre>
</TD></TR></TABLE>
</P>

<P>To use this function, navigate to the directory in which you want the enumeration 
to begin and call <I>EnumerateFolders</I>. The following statements enumerate all the 
directories on drive C:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
::SetCurrentDirectory (_T (&quot;C:\\&quot;));
EnumerateFolders ();
</pre>
</TD></TR></TABLE>
</P>

<P>We'll use a similar technique in <a href="ch10a.htm">Chapter 10</a> to populate a tree view with items 
representing all the folders on a drive.</P>

</BODY>
</HTML>




