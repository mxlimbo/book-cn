<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>IP Address Controls and Other Data-Entry Controls</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch16e.htm", "ch17a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="519"><H1>IP Address Controls and Other Data-Entry Controls</H1></A>

<P>IP address controls, hotkey controls, month calendar controls, and date-time 
picker controls all have one characteristic in common: they exist to make it easy to 
solicit specially formatted input from the user. Some of them, such as the IP address 
control, are exceedingly simple; others, such as the date-time picker control, offer 
an intimidating array of options. All are relatively easy to program, however, 
especially when you use the wrapper classes provided by MFC. The sections that follow 
provide an overview of all four control types and present code samples demonstrating their use.</p>

<A NAME="520"><H2>IP Address Controls</H2></A>

<P>IP address controls facilitate the effortless entry of 32-bit IP addresses consisting 
of four 8-bit integer values separated by periods, as in 10.255.10.1. The control 
accepts numeric input only and is divided into four 3-digit fields, as shown in Figure 
16-12. When the user types three digits into a field, the input focus automatically moves 
to the next field. IP address controls exist only on systems that have Internet 
Explorer 4.0 or later installed.</p>

<p>
<img src="images/F16mg12.GIF" width=150 height=51 border=0>
</p><p>
<!-- CAPTION --><B>Figure 16-12.</B> <I>The IP address control.</I><!-- /CAPTION -->
</p>

<p>MFC codifies the interface to IP address controls with 
<I>CIPAddressCtrl</I>. <I>CIPAddressCtrl</I> functions named 
<I>SetAddress</I> and <I>GetAddress</I> get IP addresses in and 
out. If <I>m_wndIPAddress</I> is a 
<I>CIPAddressCtrl</I> data member in a dialog class, the 
following <I>OnInitDialog</I> and <I>OnOK</I> functions initialize the control with the IP address stored 
in <I>m_nField1</I> through <I>m_nField4</I> when the dialog box is created and retrieve the 
IP address from the control when the dialog box is dismissed:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
// In CMyDialog's class declaration
BYTE m_nField1, m_nField2, m_nField3, m_nField4;
    <img src="images/grayvellip.JPG" width=3 height=13 border="0">
BOOL CMyDialog::OnInitDialog ()
{
    CDialog::OnInitDialog ();
    m_wndIPAddress.SetAddress (m_nField1, m_nField2,
        m_nField3, m_nField4);
    return TRUE;
}

void CMyDialog::OnOK ()
{
    m_wndIPAddress.GetAddress (m_nField1, m_nField2,
        m_nField3, m_nField4);
    CDialog::OnOK ();
}
</pre></td></tr></table></p>

<P>You can also empty an IP address control with 
<I>CIPAddressCtrl::ClearAddress</I> or find out whether it is currently empty with 
<I>CIPAddressCtrl::IsBlank</I>. Another 
<I>CIPAddressCtrl</I> member function, 
<I>SetFieldFocus</I>, programmatically moves the input focus to 
a specified field.</p>

<p>By default, each field in an IP address control accepts a value from 0 to 
255. You can change the range of values that a given field will accept with 
<I>CIPAddressCtrl::SetFieldRange</I>. The following statement configures the control to restrict 
values entered into the control's first field to 10 through 100 and values entered in the 
final field to 100 through 155, inclusive:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndIPAddress.SetFieldRange (0,  10, 100); // Field 1
m_wndIPAddress.SetFieldRange (3, 100, 155); // Field 4
</pre></td></tr></table></p>

<P>The control prevents invalid values from being entered into a field by 
automatically converting values that fall outside the allowable range to the upper or lower limit 
of that range, whichever is appropriate.</p>

<p>IP address controls send four types of notifications to their owners. 
EN_SETFOCUS and EN_KILLFOCUS notifications signify that the control gained or lost 
the input focus. EN_CHANGE notifications indicate that the data in the control 
has changed. All three notifications are encapsulated in WM_COMMAND messages. 
IP address controls also send IPN_FIELDCHANGED notifications when a field's 
value changes or the input focus moves from one field to another. 
IPN_FIELDCHANGED is unique among IP address control notifications in that it is transmitted in 
WM_NOTIFY messages.</p>

<A NAME="521"><H2>Hotkey Controls</H2></A>

<P>Hotkey controls are similar in concept to IP address controls. The chief difference 
is that hotkey controls accept key combinations instead of IP addresses. A hotkey 
control is essentially a glorified edit control that automatically converts key 
combinations such as Ctrl-Alt-P into text strings suitable for displaying on the screen. Hotkey 
controls are so-called because the key combinations entered in them are sometimes 
converted into hotkeys with WM_SETHOTKEY messages. Data entered into a 
hotkey control doesn't have to be used for hotkeys, however; it can be used any way 
that you, the developer, see fit.</p>

<p>MFC represents hotkey controls with instances of 
<I>CHotKeyCtrl</I>. Member functions named 
<I>SetHotKey</I> and <I>GetHotKey</I> convert key combinations into text 
strings displayed by the control, and vice versa. The following statement initializes a 
hotkey control represented by the 
<I>CHotKeyCtrl</I> object <I>m_wndHotkey</I> with the key 
combination Ctrl-Alt-P. The control responds by displaying the text string &quot;Ctrl + Alt + P&quot;:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndHotkey.SetHotKey (_T (`P'), HOTKEYF_CONTROL &#166; HOTKEYF_ALT);
</pre></td></tr></table></p>

<P>The next two statements read data from the hotkey control into variables 
named <I>wKeyCode</I>, which holds a virtual key code, and 
<I>wModifiers</I>, which holds bit flags specifying which, if any, modifier keys&#8212;Ctrl, Alt, and Shift&#8212;are included in the 
key combination:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
WORD wKeyCode, wModifiers;
m_wndHotkey.GetHotKey (wKeyCode, wModifiers);
</pre></td></tr></table></p>

<P>You can include similar calls to 
<I>SetHotKey</I> and <I>GetHotKey</I> in a dialog class's 
<I>OnInitDialog</I> and <I>OnOK</I> functions to transfer data between a hotkey control and data 
members of the dialog class.</p>

<p>By default, a hotkey control accepts key combinations that include any 
combination of the Ctrl, Shift, and Alt keys. You can restrict the combinations that the 
control will accept by calling 
<I>CHotKeyCtrl::SetRules</I>. <I>SetRules</I> accepts two parameters: 
an array of bit flags identifying invalid combinations of Ctrl, Shift, and Alt, and an 
array of bit flags specifying the combination of Ctrl, Shift, and Alt that should replace 
an invalid combination of modifier keys. For example, the statement</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndHotkey.SetRules (HKCOMB_A &#166; HKCOMB_CA &#166; HKCOMB_SA &#166; HKCOMB_SCA, 0);
</pre></td></tr></table></p>

<P>disallows any key combination that includes the Alt key, and the statement</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndHotkey.SetRules (HKCOMB_A &#166; HKCOMB_CA &#166; HKCOMB_SA &#166; HKCOMB_SCA,
    HOTKEYF_CONTROL);
</pre></td></tr></table></p>

<P>does the same but also directs the control to replace the modifiers in any key 
combination that includes the Alt key with the Ctrl key. See the 
<I>SetRules</I> documentation for a list of other supported HKCOMB flags.</p>

<A NAME="522"><H2>Month Calendar Controls</H2></A>

<P>The month calendar control, which I'll refer to simply as the 
<I>calendar control</I>, lets users input dates by picking them from a calendar rather than typing them into 
an edit control. (See Figure 16-13.) A calendar control can support single selections 
or multiple selections. Clicking a date in a single-selection calendar control makes 
that date the &quot;current date.&quot; In a multiple-selection calendar control, the user can select 
a single date or a contiguous range of dates. You can set and retrieve the current 
selection, be it a single date or a range of dates, programmatically by sending messages 
to the control. MFC wraps these and other calendar control messages in member 
functions belonging to the <I>CMonthCalCtrl</I> class.</p>

<p>
<img src="images/F16mg13.GIF" width=224 height=191 border=0>
</p><p>
<!-- CAPTION --><B>Figure 16-13.</B> <I>The month calendar control.</I><!-- /CAPTION -->
</p>

<p>In a single-selection calendar control, 
<I>CMonthCalCtrl::SetCurSel</I> sets the current date and 
<I>CMonthCalCtrl::GetCurSel</I> retrieves it. The statement</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndCal.SetCurSel (CTime (1999, 9, 30, 0, 0, 0));
</pre></td></tr></table></p>

<P>sets the current date to September 30, 1999, in the calendar control represented 
by <I>m_wndCal</I>. Ostensibly, the statements</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
CTime date;
m_wndCal.GetCurSel (date);
</pre></td></tr></table></p>

<P>retrieve the date from the control by initializing 
<I>date</I> with the currently selected date. But watch out. Contrary to what the documentation says, a calendar control 
sometimes returns random data in the hours, minutes, seconds, and milliseconds fields 
of the SYSTEMTIME structure it uses to divulge dates in response to 
MCM_GETCURSEL messages. Because <I>CTime</I> factors the time into the dates it obtains from 
SYSTEMTIME structures, incrementing the day by 1, for example, if hours equals 25, 
<I>CTime</I> objects initialized by 
<I>CMonthCalCtrl::GetCurSel</I> can't be trusted. The solution is to 
retrieve the current date by sending the control an MCM_GETCURSEL message and 
zeroing the time fields of the SYSTEMTIME structure before converting it into a 
<I>CTime</I>, as demonstrated here:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
SYSTEMTIME st;
m_wndCal.SendMessage (MCM_GETCURSEL, 0, (LPARAM) &amp;st);
st.wHour = st.wMinute = st.wSecond = st.wMilliseconds = 0;
CTime date (st);
</pre></td></tr></table></p>

<P>If you prefer, you can also use 
<I>CMonthCalCtrl</I>'s <I>SetRange</I> function to place upper 
and lower bounds on the dates that the control will allow the user to select.</p>

<p>The alternative to <I>SetCurSel</I> and 
<I>GetCurSel</I> is to use DDX to get dates in and out of a calendar control. MFC includes a DDX function named 
<I>DDX_MonthCalCtrl</I> that you can put in a dialog's 
<I>DoDataExchange</I> function to automatically transfer 
data between a calendar control and a 
<I>CTime</I> or <I>COleDateTime</I> data member. It even 
includes DDV functions for date validation. But guess what? 
<I>DDX_MonthCalCtrl</I> doesn't work because it uses 
<I>GetCurSel</I> to read the current date. Until this bug is fixed, 
your best recourse is to forego DDX and use the techniques described above to get 
and set the current date.</p>

<p>You can create a calendar control that allows the user to select a range of 
contiguous dates by including an MCS_MULTISELECT bit in the control's style. By 
default, a selection can't span more than 7 days. You can change that with 
<I>CMonthCalCtrl::SetMaxSelCount</I>. The statement</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndCal.SetMaxSelCount (14);
</pre></td></tr></table></p>

<P>sets the upper limit on selection ranges to 14 days. The complementary 
<I>GetMaxSelCount</I> function returns the current maximum selection count.</p>

<p>To programmatically select a date or a range of dates in a 
multiple-selection calendar control, you must use 
<I>CMonthCalCtrl::SetSelRange</I> instead of 
<I>CMonthCalCtrl::SetCurSel</I>. (The latter fails if it's called on a multiple-selection calendar control.) 
The statements</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndCal.SetSelRange (CTime (1999, 9, 30, 0, 0, 0),
    CTime (1999, 9, 30, 0, 0, 0));
</pre></td></tr></table></p>

<P>select September 30, 1999, in an MCS_MULTISELECT-style calendar control, and 
the statements</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndCal.SetSelRange (CTime (1999, 9, 16, 0, 0, 0),
    CTime (1999, 9, 30, 0, 0, 0));
</pre></td></tr></table></p>

<P>select September 16 through September 30. This call will fail unless you first 
call <I>SetMaxSelCount</I> to set the maximum selection range size to 15 days or higher. To 
read the current selection, use 
<I>CMonthCalCtrl::GetSelRange</I> as demonstrated here:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
CTime dateStart, dateEnd;
m_wndCal.GetSelRange (dateStart, dateEnd);
</pre></td></tr></table></p>

<P>This example sets <I>dateStart</I> equal to the selection's start date and 
<I>dateEnd</I> to the end date. If just one day is selected, 
<I>dateStart</I> will equal <I>dateEnd</I>. Fortunately, 
<I>GetSelRange</I> doesn't suffer from the randomness problems that 
<I>GetCurSel</I> does.</p>

<p>Three calendar control styles allow you to alter a calendar control's 
appearance. MCS_NOTODAY removes the line that displays today's date at the bottom of the 
calendar; MCS_NOTODAYCIRCLE removes the circle that appears around today's 
date in the body of the calendar; and MCS_WEEKNUMBERS displays week numbers 
(1 through 52). You can further modify a calendar's appearance with 
<I>CMonthCalCtrl</I> functions. For example, you can change today's date (as displayed by the 
control) with <I>SetToday</I>, the day of the week that appears in the calendar's leftmost 
column with <I>SetFirstDayOfWeek</I>, and the control's colors with 
<I>SetColor</I>. You can even command the control to display certain dates in boldface type by calling its 
<I>SetDayState</I> function or processing MCN_GETDAYSTATE notifications. Be aware that 
<I>SetDayState</I> works (and MCN_GETDAYSTATE notifications are sent) only if MCS_DAYSTATE 
is included in the control style.</p>

<p>If you'd like to know when the current date (or date range) changes in a 
calendar control, you can process either of two notifications. MCN_SELECT 
notifications are sent when the user selects a new date or range of dates. MCN_SELCHANGE 
notifications are sent when the user explicitly makes a selection 
<I>and</I> when the selection changes because the user scrolled the calendar backward or forward a 
month. In an MFC application, you can map these notifications to member functions in 
the parent window class with ON_NOTIFY or reflect them to functions in a derived 
control class with ON_NOTIFY_REFLECT.</p>

<A NAME="523"><H2>Date-Time Picker Controls</H2></A>

<P>Date-time picker controls, or <I>DTP 
controls</I>, provide developers with a simple, 
convenient, and easy-to-use means for soliciting dates and times from a user. A DTP 
control resembles an edit control, but rather than display ordinary text strings, it displays 
dates and times. Dates can be displayed in short format, as in 9/30/99, or long format, as 
in Thursday, September 30, 1999. Times are displayed in standard HH:MM:SS 
format followed by AM or PM. Custom date and time formats are also supported. Times 
and dates can be edited visually&#8212;for example, by clicking the control's up and 
down arrows or picking from a drop-down calendar control&#8212;or manually. MFC 
simplifies the interface to DTP controls with the wrapper class named 
<I>CDateTimeCtrl</I>.</p>

<p>Using a DTP control to solicit a time requires just one or two lines of code. 
First you assign the control the style DTS_TIMEFORMAT to configure it to display 
times rather than dates. Then you call 
<I>CDateTimeCtrl::SetTime</I> to set the time displayed 
in the control and <I>CDateTimeCtrl::GetTime</I> when you're ready to retrieve it. 
Assuming <I>m_wndDTP</I> is a <I>CDateTimeCtrl</I> data member in a dialog class and that 
<I>m_wndDTP</I> is mapped to a DTP control in the dialog, the following 
<I>OnInitDialog</I> and <I>OnOK</I> functions transfer data between the control and a 
<I>CTime</I> member variable in the dialog class:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
// In CMyDialog's class declaration
CTime m_time;
    <img src="images/grayvellip.JPG" width=3 height=13 border="0">
BOOL CMyDialog::OnInitDialog ()
{
    CDialog::OnInitDialog ();
    m_wndDTP.SetTime (&amp;m_time);
    return TRUE;
}

void CMyDialog::OnOK ()
{
    m_wndDTP.GetTime (m_time);
    CDialog::OnOK ();
}
</pre></td></tr></table></p>

<P>Rather than call <I>SetTime</I> and 
<I>GetTime</I> explicitly, you can use a 
<I>DDX_DateTimeCtrl</I> statement in the dialog's 
<I>DoDataExchange</I> function instead:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
DDX_DateTimeCtrl (pDX, IDC_DTP, m_time);
</pre></td></tr></table></p>

<P>If you use <I>DDX_DateTimeCtrl</I> to connect a DTP control to a dialog data 
member, you might also want to use MFC's 
<I>DDV_MinMaxDateTime</I> function to validate 
times retrieved from the control.</p>

<P>To display dates rather than times in a DTP control, replace 
DTS_TIMEFORMAT with either DTS_SHORTDATEFORMAT for short dates or 
DTS_LONGDATEFORMAT for long dates. You set and retrieve dates the same way you do times: with 
<I>SetTime</I> and <I>GetTime</I> or 
<I>DDX_DateTimeCtrl</I>. You can use 
<I>CDateTimeCtrl::SetRange</I> to limit the dates and times that a DTP control will accept.</p>

<P>A DTP control whose style includes DTS_UPDOWN has up and down 
arrows that the user can use to edit times and dates. If DTS_UPDOWN is omitted from 
the control style, a downward-pointing arrow similar to the arrow in a combo box 
replaces the up and down arrows. Clicking the downward-pointing arrow displays 
a drop-down calendar control, as illustrated in Figure 16-14. Thus, combining either 
of the date styles (DTS_SHORTDATEFORMAT or DTS_LONGDATEFORMAT) with 
DTS_UPDOWN produces a DTP control in which dates are entered using up and 
down arrows; using either of the date styles without DTS_UPDOWN creates a control 
in which dates are picked from a calendar. By default, a calendar dropped down 
from a DTP control is left-aligned with the control. You can alter the alignment by 
including DTS_RIGHTALIGN in the control style. You can also use the 
DTS_APPCANPARSE style to allow the user to manually edit the text displayed in a DTP control. Even 
without this style, the keyboard's arrow keys can be used to edit time and date entries.</p>

<p>
<A HREF="javascript:fullSize('F16mg14x.htm')"> <img src="images/F16mg14.JPG" width=404 height=205 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 16-14.</B> <I>Date-time picker controls with and without the style DTS_UPDOWN.</I><!-- /CAPTION -->
</p>

<P><I>CDateTimeCtrl</I>'s <I>SetFormat</I> function assigns custom formatting strings to a 
DTP control. For example, a formatting string of the form &quot;H': `mm': `ss&quot; programs a 
DTP control to display the time in 24-hour military format. Here's how 
<I>SetFormat</I> would be used to apply this formatting string:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndDTP.SetFormat (_T (&quot;H\':\'mm\':\'ss&quot;));
</pre></td></tr></table></p>

<P>In a formatting string, <I>H</I> represents a one-digit or two-digit hour in 24-hour 
format, <I>mm</I> represents a two-digit minute, and 
<I>ss</I> represents a two-digit second. The 
following table shows all the special characters that you can use in formatting strings. 
You can include literals, such as the colons in the example above, by enclosing them 
in single quotation marks. If you really want to get fancy, you can use Xs to define 
<I>callback fields</I>. A DTP control uses DTN_FORMAT and DTN_FORMATQUERY 
notifications to determine what to display in a callback field, enabling an application 
that processes these notifications to provide text to a DTP control at run time.</p>

<p><b>DTP Formatting Characters</b></p>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top">Character(s)</th>
<th valign="top">Description</th>
</tr><tr>
<td valign="top"><I>d</I></td>
<td valign="top">One-digit or two-digit day</td>
</tr><tr>
<td valign="top"><I>dd</I></td>
<td valign="top">Two-digit day</td>
</tr><tr>
<td valign="top"><I>ddd</I></td>
<td valign="top">Three-character day of the week abbreviation (for example, Mon or Tue)</td>
</tr><tr>
<td valign="top"><I>dddd</I></td>
<td valign="top">Full day of the week name (for example, Monday or Tuesday)</td>
</tr><tr>
<td valign="top"><I>h</I></td>
<td valign="top">One-digit or two-digit hour in 12-hour format</td>
</tr><tr>
<td valign="top"><I>hh</I></td>
<td valign="top">Two-digit hour in 12-hour format</td>
</tr><tr>
<td valign="top"><I>H</I></td>
<td valign="top">One-digit or two-digit hour in 24-hour format</td>
</tr><tr>
<td valign="top"><I>HH</I></td>
<td valign="top">Two-digit hour in 24-hour format</td>
</tr><tr>
<td valign="top"><I>m</I></td>
<td valign="top">One-digit or two-digit minute</td>
</tr><tr>
<td valign="top"><I>mm</I></td>
<td valign="top">Two-digit minute</td>
</tr><tr>
<td valign="top"><I>M</I></td>
<td valign="top">One-digit or two-digit month</td>
</tr><tr>
<td valign="top"><I>MM</I></td>
<td valign="top">Two-digit month</td>
</tr><tr>
<td valign="top"><I>MMM</I></td>
<td valign="top">Three-character month abbreviation (for example, Jan or Feb)</td>
</tr><tr>
<td valign="top"><I>MMMM</I></td>
<td valign="top">Full month name (for example, January or February)</td>
</tr><tr>
<td valign="top"><I>s</I></td>
<td valign="top">One-digit or two-digit second</td>
</tr><tr>
<td valign="top"><I>ss</I></td>
<td valign="top">Two-digit second</td>
</tr><tr>
<td valign="top"><I>t</I></td>
<td valign="top">Displays A for a.m. or P for p.m.</td>
</tr><tr>
<td valign="top"><I>tt</I></td>
<td valign="top">Displays AM for a.m. or PM for p.m.</td>
</tr><tr>
<td valign="top"><I>X</I></td>
<td valign="top">Callback field</td>
</tr><tr>
<td valign="top"><I>y</I></td>
<td valign="top">One-digit year</td>
</tr><tr>
<td valign="top"><I>yy</I></td>
<td valign="top">Two-digit year</td>
</tr><tr>
<td valign="top"><I>yyyy</I></td>
<td valign="top">Four-digit year</td>
</tr></table></p>

<P>DTP controls send a variety of other notifications to their parents. If you 
want to know when a drop-down calendar control is displayed, listen for 
DTN_DROPDOWN notifications. When a DTN_DROPDOWN notification arrives, you can call 
<I>CDateTimeCtrl::GetMonthCalCtrl</I> to acquire a 
<I>CMonthCalCtrl</I> pointer that you can use to modify the calendar control. If you simply want to know when the time or the 
date in a DTP control changes, process DTN_DATETIMECHANGE notifications. 
Consult the Platform SDK documentation on DTP controls for details concerning these 
and other DTP control notifications.</p>
</BODY>
</HTML>




