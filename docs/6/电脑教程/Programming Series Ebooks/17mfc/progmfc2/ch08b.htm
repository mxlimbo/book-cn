<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Modal Dialog Boxes and the CDialog Class</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch08a.htm", "ch08c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="210"><H1>Modal Dialog Boxes and the <I>CDialog</I> Class</H1></A>

<P>Creating a modal dialog box is a three-step process:
</P>

<OL>
<P><LI>Create a dialog box template describing the dialog and the controls that 
it contains.</LI></P>

<P><LI>Construct a <I>CDialog</I> object that encapsulates the dialog template.</LI></P>

<P><LI>Call <I>CDialog::DoModal</I> to display the dialog box.</LI></P>
</OL>


<P>For very simple dialogs, you can sometimes instantiate 
<I>CDialog</I> directly. More often, however, you'll need to derive a dialog class of your own so that you can 
customize its behavior. Let's begin by examining the ingredients that go into a modal dialog 
box. After that, we'll apply what we've learned to modeless dialogs and property sheets.
</P>

<A NAME="211"><H2>The Dialog Box Template</H2></A>

<P>The first step in creating a dialog box is to create a dialog box template. A 
template defines the fundamental properties of a dialog box, from the controls it contains 
to its width and height. Although it's possible to create dialog box templates 
programmatically by assembling DLGTEMPLATE and DLGITEMTEMPLATE structures in 
memory, most dialog box templates are resources compiled from statements in an 
application's RC file. These statements can be hand-coded, but more often they are written to the 
RC file by a resource editor that supports the visual editing of dialog box templates.
</P>

<P>The following RC statements define a dialog box template whose resource ID is IDD_MYDIALOG. The dialog box described by this template contains four controls: a single-line edit control for entering text, a static text control that serves as a label for the edit control, an OK button, and a Cancel button:
</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
IDD_MYDIALOG DIALOG 0, 0, 160, 68
STYLE DS_MODALFRAME &#166; WS_POPUP &#166; WS_VISIBLE &#166; WS_CAPTION &#166; WS_SYSMENU
CAPTION &quot;Enter Your Name&quot;
FONT 8, &quot;MS Sans Serif&quot;
BEGIN
    LTEXT           &quot;&amp;Name&quot;, -1, 8, 14, 24, 8
    EDITTEXT        IDC_NAME, 34, 12, 118, 12, ES_AUTOHSCROLL
    DEFPUSHBUTTON   &quot;OK&quot;, IDOK, 60, 34, 40, 14, WS_GROUP
    PUSHBUTTON      &quot;Cancel&quot;, IDCANCEL, 112, 34, 40, 14, WS_GROUP
END
</PRE></TD></TR></TABLE>
</P>

<P>The numbers on the first line specify the template's resource ID 
(IDD_MYDIALOG), the dialog box's default position (0,0, which would place the dialog in the upper 
left corner of its owner's client area save for the fact that MFC automatically centers 
a modal dialog box whose position is 0,0), and the dialog box's dimensions 
(160,68). All measurements are expressed in dialog box units. Horizontally, one dialog box 
unit is equal to one-fourth the average width of a character in the dialog box font. 
Vertically, one dialog box unit equals one-eighth the character height. Because 
characters are generally about twice as tall as they are wide, the distance represented by 
one horizontal dialog box unit is roughly equal to that of one vertical dialog box 
unit. Measuring distances in dialog box units rather than pixels allows you to define a 
dialog box's relative proportions independent of the screen resolution.
</P>

<P>The STYLE statement in the dialog box template specifies the dialog box's 
window style. You should always include WS_POPUP in a dialog box's window style. 
You should typically include WS_VISIBLE, too, so that you don't have to call 
<I>ShowWindow</I> to make the dialog box visible on the screen. WS_CAPTION gives the dialog box 
a title bar, and WS_SYSMENU adds a close button to the title bar. Styles prefixed 
with DS_ are specific to dialog boxes. By convention, modal dialog boxes are 
assigned the style DS_MODALFRAME. In early versions of Windows, this style placed a 
thick border around the dialog box. Today, DS_MODALFRAME has subtle effects on a 
dialog box's behavior but does nothing to its appearance. Other interesting dialog 
styles include DS_CENTER, which centers a dialog box on the screen, DS_ABSALIGN, 
which positions a dialog relative to the upper left corner of the screen instead of the 
upper left corner of its owner, and DS_CONTEXTHELP, which adds a question mark 
button to the dialog box's title bar so that the user can get context-sensitive help 
regarding the dialog box's controls.
</P>

<P>You can create a <I>system-modal</I> dialog box by including DS_SYSMODAL in 
the STYLE statement. In 16-bit Windows, a system-modal dialog box disables all 
other windows in the system until it is dismissed and is typically used to report critical 
errors that must be attended to before further processing is performed. In 32-bit 
Windows, where processes are physically isolated from one another by the operating 
system, DS_SYSMODAL simply makes the dialog box a topmost window&#8212;that is, one that 
is always displayed on top of other windows. The dialog box overlays all other 
windows, but the user is free to switch to other applications while the dialog box is displayed.
</P>

<P>The CAPTION statement specifies the text that appears in the dialog box's 
title bar. You can also set the title programmatically with the 
<I>SetWindowText</I> function a <I>CDialog</I> object inherits from 
<I>CWnd</I>.
</P>

<P>FONT specifies the dialog box font, which is automatically assigned to all 
the controls in the dialog. The statement
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
FONT 8, &quot;MS Sans Serif&quot;
</PRE></TD></TR></TABLE>
</P>

<P>is somewhat redundant because 8-point MS Sans Serif is the default font in 
current versions of Windows. If your dialogs will be used in older (pre-Windows 95) 
versions of Windows, this statement ensures that the dialog will use 8-point MS Sans 
Serif. You can use <I>CWnd::SetFont</I> to change the fonts assigned to individual controls in 
a dialog box.
</P>

<P>The statements between BEGIN and END define the dialog box's controls. 
Each statement defines one control, specifying its type (push button, check box, list 
box, and so on), its control ID, its position, its width and height, and its style. For 
static and button controls, you can specify the control text, too. In the example above, the LTEXT statement creates a static text control whose ID is 
-1, whose text is left-aligned in the control rectangle, whose upper left corner lies 8 
horizontal dialog box units to the right of and 14 vertical dialog box units below the dialog 
box's upper left corner, and whose width and height are 24 horizontal dialog box 
units and 8 vertical dialog box units, respectively. The ampersand in the control text 
makes Alt-N a shortcut for the edit control created on the following line.
</P>

<P>LTEXT is one of several resource statements used to define controls in 
dialog box templates; a complete list appears in the table below. In essence, 
these statements are shorthand ways of creating the same kinds of controls we created 
in <a href="ch07a.htm">Chapter 7</a> by instantiating a control class and calling the resulting object's 
<I>Create </I>or <I>CreateEx</I> function. Each keyword has certain default styles associated with it, and 
all build in the styles WS_CHILD and WS_VISIBLE. Buttons and edit controls also 
include the style WS_TABSTOP so that they can be tabbed to with the Tab key. If 
desired, you can remove an implicit style with the NOT operator. For example, the 
following resource statement creates an edit control minus the default WS_TABSTOP style:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
EDITTEXT IDC_EDIT, 32, 16, 96, 12, NOT WS_TABSTOP
</PRE></TD></TR></TABLE>
</P>


<P>You can also define dialog box controls with the more generic CONTROL 
keyword. Sometimes you'll see a dialog box template defined this way:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
IDD_MYDIALOG DIALOG 0, 0, 160, 68
STYLE DS_MODALFRAME &#166; WS_POPUP &#166; WS_VISIBLE &#166; WS_CAPTION &#166; WS_SYSMENU
CAPTION &quot;Enter Your Name&quot;
BEGIN
    CONTROL    &quot;&amp;Name&quot;, -1, &quot;STATIC&quot;, SS_LEFT, 8, 14, 24, 8
    CONTROL    &quot;&quot;, IDC_NAME, &quot;EDIT&quot;, WS_BORDER &#166; ES_AUTOHSCROLL &#166;
               ES_LEFT &#166; WS_TABSTOP, 34, 12, 118, 12
</PRE></TD></TR></TABLE>
</P>

<P>
<B>Resource Statements for Creating Dialog Box Controls</B>
</P>

<P>
<TABLE cellpadding=5 width="95%">
<TR>
<TH valign="top"><i>Keyword</i></TH>
<TH valign="top"><i>Control Type</i></TH>
<TH valign="top"><i>Default Styles</i></TH>
</TR>


<TR>
<TD VALIGN="TOP">LTEXT     </TD>
<TD VALIGN="TOP">Static control with left-aligned text      </TD>
<TD VALIGN="TOP">SS_LEFT &#166; WS_GROUP</TD>
</TR>

<TR>
<TD VALIGN="TOP">CTEXT     </TD>
<TD VALIGN="TOP">Static control with centered text      </TD>
<TD VALIGN="TOP">SS_CENTER &#166; WS_GROUP     </TD>
</TR>

<TR>
<TD VALIGN="TOP">RTEXT     </TD>
<TD VALIGN="TOP">Static control with right-aligned text      </TD>
<TD VALIGN="TOP">SS_RIGHT &#166; WS_GROUP</TD>
</TR>


<TR>
<TD VALIGN="TOP">PUSHBUTTON     </TD>
<TD VALIGN="TOP">Push button     </TD>
<TD VALIGN="TOP">BS_PUSHBUTTON &#166; WS_TABSTOP</TD>
</TR>


<TR>
<TD VALIGN="TOP">DEFPUSHBUTTON     </TD>
<TD VALIGN="TOP">Default push button     </TD>
<TD VALIGN="TOP">BS_DEFPUSHBUTTON &#166; WS_TABSTOP</TD>
</TR>


<TR>
<TD VALIGN="TOP">EDITTEXT     </TD>
<TD VALIGN="TOP">Edit control     </TD>
<TD VALIGN="TOP">ES_LEFT &#166; WS_BORDER &#166; WS_TABSTOP</TD>
</TR>


<TR>
<TD VALIGN="TOP">CHECKBOX     </TD>
<TD VALIGN="TOP">Check box     </TD>
<TD VALIGN="TOP">BS_CHECKBOX &#166; WS_TABSTOP</TD>
</TR>

<TR>
<TD VALIGN="TOP">AUTOCHECKBOX     </TD>
<TD VALIGN="TOP">Automatic check box      </TD>
<TD VALIGN="TOP">BS_AUTOCHECKBOX &#166; WS_TABSTOP</TD>
</TR>

<TR>
<TD VALIGN="TOP">STATE3     </TD>
<TD VALIGN="TOP">Three-state check box     </TD>
<TD VALIGN="TOP">BS_3STATE &#166; WS_TABSTOP</TD>
</TR>

<TR>
<TD VALIGN="TOP">AUTO3STATE     </TD>
<TD VALIGN="TOP">Automatic three-state check box      </TD>
<TD VALIGN="TOP">BS_AUTO3STATE &#166; WS_TABSTOP         </TD>
</TR>

<TR>
<TD VALIGN="TOP">RADIOBUTTON     </TD>
<TD VALIGN="TOP">Radio button     </TD>
<TD VALIGN="TOP">BS_RADIOBUTTON &#166; WS_TABSTOP</TD>
</TR>

<TR>
<TD VALIGN="TOP">AUTORADIOBUTTON     </TD>
<TD VALIGN="TOP">Automatic radio button     </TD>
<TD VALIGN="TOP">BS_AUTORADIOBUTTON &#166; WS_TABSTOP      </TD>
</TR>

<TR>
<TD VALIGN="TOP">GROUPBOX     </TD>
<TD VALIGN="TOP">Group box     </TD>
<TD VALIGN="TOP">BS_GROUPBOX</TD>
</TR>

<TR>
<TD VALIGN="TOP">LISTBOX     </TD>
<TD VALIGN="TOP">List box     </TD>
<TD VALIGN="TOP">LBS_NOTIFY &#166; WS_BORDER</TD>
</TR>

<TR>
<TD VALIGN="TOP">COMBOBOX     </TD>
<TD VALIGN="TOP">Combo box     </TD>
<TD VALIGN="TOP">CBS_SIMPLE</TD>
</TR>

<TR>
<TD VALIGN="TOP">SCROLLBAR     </TD>
<TD VALIGN="TOP">Scroll bar     </TD>
<TD VALIGN="TOP">SBS_HORZ</TD>
</TR>

<TR>
<TD VALIGN="TOP">ICON     </TD>
<TD VALIGN="TOP">Static icon control     </TD>
<TD VALIGN="TOP">SS_ICON</TD>
</TR>
</TABLE></P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
    CONTROL    &quot;OK&quot;, IDOK, &quot;BUTTON&quot;, BS_DEFPUSHBUTTON &#166;
               WS_TABSTOP &#166; WS_GROUP, 60, 34, 40, 14
    CONTROL    &quot;Cancel&quot;, IDCANCEL, &quot;BUTTON&quot;, BS_PUSHBUTTON &#166;
               WS_TABSTOP &#166; WS_GROUP, 112, 34, 40, 14
END
</PRE></TD></TR></TABLE>
</P>


<P>This dialog template is equivalent to the one at the beginning of this section. The styles WS_CHILD and WS_VISIBLE are implicit in a CONTROL statement, but all other styles must 
be specified explicitly. The third parameter in a CONTROL statement specifies the 
WNDCLASS the control is based on&#8212;&quot;BUTTON&quot; for push buttons, radio buttons, 
check boxes, and group boxes; &quot;EDIT&quot; for edit controls; and so on. Because the 
WNDCLASS is specified explicitly, you can use CONTROL to create custom controls 
whose WNDCLASSes are registered with 
<I>::RegisterClass</I>. It's with CONTROL statements, 
in fact, that you add progress bars, spin buttons, and other common controls to a 
dialog box. You'll learn more about the common controls in <a href="ch16a.htm">Chapter 16</a>.
</P>

<P>Today it's rare for programmers to create dialog box templates by hand. 
Using Visual C++'s Insert/Resource command, you can insert a dialog box resource into 
a project and edit it visually. Figure 8-1 shows the Visual C++ dialog editor at 
work. You add controls to a dialog box by picking them from the Controls toolbar 
and literally drawing them into the dialog window. (If the Controls toolbar isn't 
visible, you can make it visible by selecting Customize from the Tools menu, clicking 
the Toolbars tab, and placing a check mark next to Controls.) You modify a dialog 
box's properties&#8212;its STYLE, CAPTION, FONT, and so on&#8212;by making selections in the 
dialog box's property sheet, which you display by right-clicking the dialog box and 
selecting Properties from the context menu.
</P>

<P>
<A HREF="javascript:fullSize('F08mg01x.htm')"> <img src="images/F08mg01.JPG" width=404 height=309 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 8-1.</B> <I>The Visual C++ dialog editor.</I><!-- /CAPTION -->
</p>

<A NAME="212"><H3>The Dialog Box Keyboard Interface</H3></A>

<P>Windows supplies every dialog box with a keyboard interface that lets the user 
move the input focus among controls with the Tab key, cycle among the controls within 
a group using the arrow keys, and more. When you define a dialog box template in 
an RC file, you implicitly define the dialog box's keyboard interface, too. Here are 
the elements of the dialog box template that affect the keyboard interface:
</P>

<UL> 
<P><LI>The order in which the controls are defined
</LI> </P>

<P><LI>The use of ampersands in control text to designate shortcut keys
</LI></P>

<P><LI>The use of the WS_GROUP style to group controls
</LI></P>

<P><LI>The use of DEFPUSHBUTTON to designate the default push button
</LI></P>
</UL>

<P>The order of the control-creation statements in the dialog template 
determines the <I>tab order</I>&#8212;the order in which the input focus is passed around when the user 
presses Tab or Shift-Tab. Most dialog editors, including the one that's built into Visual 
C++, let you specify the tab order visually. Under the hood, they simply reorder the 
resource statements to match the tab order. A control can't be tabbed to unless it includes 
the style WS_TABSTOP. That's why many of the resource statements discussed in 
the previous section include WS_TABSTOP by default.
</P>

<P>Dialog boxes support shortcut keys for those users who prefer the 
keyboard over the mouse. You can create a shortcut key for a push button, a radio button, or 
a check box control by preceding the shortcut character in the control text with 
an ampersand, as in
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
PUSHBUTTON &quot;&amp;Reset&quot;, IDC_RESET, 112, 34, 40, 24, WS_GROUP
</PRE></TD></TR></TABLE>
</P>

<P>Now presses of Alt-R (or simply R if the input focus rests on another button 
control) will click the Reset button unless another control has been assigned the same 
mnemonic, in which case repeated presses of the shortcut key will cycle the input 
focus between the two controls. For list boxes, edit controls, and other controls that 
have no control text per se, you define a shortcut key by preceding the statement that 
creates the control with a statement that creates a static control and including an 
ampersand in the static control's text. For example, the statements
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
LTEXT       &quot;&amp;Name&quot;, -1, 8, 14, 24, 8
EDITTEXT    IDC_NAME, 34, 12, 118, 12, ES_AUTOHSCROLL
</PRE></TD></TR></TABLE>
</P>

<P>create a static control labeled &quot;<U>N</U>ame&quot; and a single-line edit control to the right of 
it. Pressing Alt-N moves the input focus to the edit control.
</P>

<P>Another element of the keyboard interface to consider when creating a 
dialog box template, especially if the dialog box includes radio buttons, is the grouping 
of the controls. Recall from <a href="ch07a.htm">Chapter 7</a> that BS_AUTORADIOBUTTON-style radio 
buttons must be grouped if Windows is to uncheck all the other buttons in the 
group when one of the buttons is clicked. Windows also uses radio button groupings 
to determine how to cycle the input focus among radio buttons when the arrow 
keys are pressed. To define a group of radio buttons, first make sure that the 
buttons occupy consecutive positions in the tab order&#8212;that is, if the first button in the 
group is control number 5 in the tab order, that the second button is number 6, that the 
third button is number 7, and so on. Then assign the style WS_GROUP to the first 
radio button in the group and to the first control that comes after the group in the 
tab order. Windows programmers often assign WS_GROUP to push buttons and 
check boxes, too, so that the arrow keys won't move the input focus when the input 
focus rests on a push button or a check box.
</P>

<P>A final point to consider as you design a dialog box's keyboard interface is 
which push button should serve as the default. In most dialog boxes, you designate 
one push button (typically the OK button) as the default push button by creating it 
with a DEFPUSHBUTTON statement or assigning it the BS_DEFPUSHBUTTON style. 
When the Enter key is pressed, Windows simulates a click of the default push button in 
the dialog box. If the input focus is on a non-push-button control, the default push 
button is the one designated as the default in the dialog box template. As the input focus 
is cycled among push buttons, however, the &quot;defaultness&quot; moves with it. You can 
always tell which push button is the default by the thick border Windows draws around it.
</P>

<P>All elements of a dialog box's keyboard interface can be specified visually 
in the Visual C++ dialog editor. You specify the tab order by selecting Tab Order 
from the Layout menu and clicking the controls in order. The dialog editor uses 
numbered boxes to show the tab order, as you can see in Figure 8-2. To apply the 
WS_GROUP style to a control, check the Group box in the control's property sheet. The 
property sheet is displayed by clicking the control with the right mouse button and 
selecting Properties. To make a push button the default push button, check the Default 
Button box in the button's property sheet.
</P>

<P>
<A HREF="javascript:fullSize('F08mg02x.htm')"> <img src="images/F08mg02.JPG" width=404 height=309 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 8-2.</B> <I>A dialog box's tab order as seen in the Visual C++ dialog editor.</I><!-- /CAPTION -->
</p>

<A NAME="213"><H2>The <I>CDialog</I> Class</H2></A>
<P>For all but the most trivial dialog boxes, the next step in creating a modal dialog is 
to derive a class from <I>CDialog</I> and use it to define the dialog box's behavior. 
<I>CDialog</I> includes three key functions that you can override to initialize the dialog box 
and respond to clicks of the OK and Cancel buttons: 
<I>OnInitDialog</I>, <I>OnOK</I>, and 
<I>OnCancel</I>. Although each of these functions corresponds to a dialog box message, you 
don't need a message map to process them because 
<I>CDialog</I> does the message mapping for you and exposes the corresponding functions as ordinary virtual functions. 
<I>CDialog</I> also provides default implementations of all three, so you can frequently get 
away without overriding any of them if you take advantage of MFC's Dialog Data 
Exchange and Dialog Data Validation mechanisms, which we'll cover later in this chapter.
</P>

<P>When a dialog box is created, it receives a WM_CREATE message just as 
any other window does. But when the WM_CREATE message arrives, the controls 
specified in the dialog box template have yet to be created and therefore can't be 
initialized. The dialog box is, in effect, empty. The internal window procedure that 
Windows uses to process dialog box messages responds to WM_CREATE messages by 
creating the dialog box's controls. After its controls are created, the dialog box receives 
a WM_INITDIALOG message affording it the opportunity to perform any 
necessary initializations, including those involving the controls. In a 
<I>CDialog</I>-derived class, the WM_INITDIALOG message activates the dialog box's 
<I>OnInitDialog</I> function, which is prototyped as follows:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
virtual BOOL OnInitDialog ()
</PRE></TD></TR></TABLE>
</P>

<P><I>OnInitDialog</I> is where you do anything you need to do to get the dialog box 
ready for action&#8212;for example, check a radio button or insert text into an edit control. 
At the moment <I>OnInitDialog</I> is called, the dialog box is extant in memory but not 
yet visible on the screen. The user won't see what you do in 
<I>OnInitDialog</I>, but he or she <I>will</I> see the results.
</P>

<P>The value returned from <I>OnInitDialog</I> tells Windows what to do with the 
input focus. If <I>OnInitDialog</I> returns TRUE, Windows assigns the input focus to the first 
control in the tab order. To assign the input focus to a control other than the first one, 
call that control's <I>SetFocus</I> function in 
<I>OnInitDialog</I> and return FALSE from 
<I>OnInitDialog</I> to prevent Windows from setting the input focus itself. You can get a 
<I>CWnd</I> pointer through which to call 
<I>SetFocus</I> by passing the control ID to 
<I>GetDlgItem</I>, as demonstrated here:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
GetDlgItem (IDC_EDIT)-&gt;SetFocus ();
</PRE></TD></TR></TABLE>
</P>

<P>If you override <I>OnInitDialog</I>, you should call the base class's 
<I>OnInitDialog</I> handler for reasons that we'll get into shortly.
</P>

<P>When the user clicks the dialog box's OK button, the dialog box receives 
a WM_COMMAND message reporting the button click, and MFC in turn calls the 
dialog's virtual <I>OnOK</I> function. For this mechanism to work properly, you must assign 
the OK button the special ID value IDOK, as shown in the following resource statement:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
DEFPUSHBUTTON &quot;OK&quot;, IDOK, 60, 34, 40, 24, WS_GROUP
</PRE></TD></TR></TABLE>
</P>

<P>You can override <I>OnOK</I> to perform specialized processing before the dialog box 
is dismissed, which might include extracting data from the controls in the dialog box 
and possibly validating the data (for example, making sure that a numeric value 
retrieved from an edit control falls within an allowable range). If you do provide your 
own implementation of <I>OnOK</I>, be sure to close it out by calling 
<I>EndDialog</I> to dismiss the dialog box or by calling the base class's 
<I>OnOK</I> handler to dismiss it for you. Otherwise, the dialog box won't disappear when OK is clicked.
</P>

<P>You must assign a Cancel button the predefined ID IDCANCEL for 
<I>OnCancel</I> to be called when the button is clicked. Be aware that even if your dialog box 
doesn't include a Cancel button, <I>OnCancel</I> will still be called if the Esc key is pressed or 
the close button in the dialog box's title bar is clicked. 
<I>OnCancel</I> isn't usually overridden because data typically doesn't need to be read from the dialog's controls if 
changes are canceled. <I>CDialog::OnCancel</I> calls 
<I>EndDialog</I> with an IDCANCEL parameter to dismiss the dialog box and inform the caller that changes in the dialog box 
controls should be ignored.
</P>

<P>With the exception of the WM_INITDIALOG message, which is unique to 
dialog boxes, dialog boxes receive the same messages that conventional windows do. 
You can map any of these messages to the dialog class's member functions using a 
message map. For example, if your dialog box includes a Reset button whose ID 
is IDC_RESET and you want <I>OnReset</I> to be called when the button is clicked, you 
can use the following message-map entry to connect the two:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
ON_BN_CLICKED (IDC_RESET, OnReset)
</PRE></TD></TR></TABLE>
</P>

<P>Dialog boxes can even handle WM_PAINT messages&#8212;somewhat unusual but 
doable nonetheless. Most dialog boxes don't need 
<I>OnPaint</I> handlers because controls repaint themselves when the area of the dialog box that they occupy is invalidated.
</P>

<A NAME="214"><H3>Getting Help from ClassWizard</H3></A>


<P>Although deriving dialog classes from 
<I>CDialog</I> by hand is perfectly acceptable, 
most MFC programmers today prefer to let ClassWizard do it for them. It's easy: 
invoke ClassWizard, click its Add Class button, select New from the menu that appears 
under the button, and fill in a class name, base class name 
(<I>CDialog</I>), and resource ID, as shown in Figure 8-3. The resource ID that you specify must be that of a dialog 
resource. If you want to override 
<I>OnInitDialog</I>, <I>OnOK</I>, or 
<I>OnCancel</I> in the derived class, you can do so after ClassWizard has performed the derivation.
</P>

<P>That's one way to get to ClassWizard's New Class dialog box, but it's not 
the only way. In the dialog editor, double-click the body of the dialog box. Visual 
C++ will prompt you with a message asking if you want to create a new class. If you 
answer OK, ClassWizard will pop up and the New Class dialog box will appear with the 
name of the base class and the resource ID already filled in.
</P>

<P>
<IMG SRC="images/F08mg03.GIF" width=404 height=366 BORDER=0>
</p><p>
<!-- CAPTION --><B>Figure 8-3.</B> <I>Using ClassWizard to derive from CDialog.</I><!-- /CAPTION -->
</p>

<P>You can also use ClassWizard to write message handlers for a dialog's 
controls. Suppose you want to write a BN_CLICKED handler for a push button, and the 
push button's control ID is IDC_RESET. Here's how to go about it:
</P>
<OL>
<P><LI>Right-click the dialog class in the ClassView window.</LI>
</P>

<P><LI>Select Add Windows Message Handler from the context menu.</LI>
</P>

<P><LI>Select the button ID (IDC_RESET) in the Class Or Object To Handle box.</LI>
</P>

<P><LI>Click BN_CLICKED in the New Windows Messages/Events box.</LI></P>

<P><LI>Click the Add Handler button, and enter a function name.</LI></P>
</OL>


<P>When you're done, the function whose name you entered will be present in the 
dialog class and will be wired to the push button via an ON_BN_CLICKED entry in 
the dialog's message map.
</P>

<A NAME="215"><H2>Creating a Modal Dialog Box</H2></A>

<P>Once you've defined the dialog box template and declared the dialog class, 
creating a modal dialog box is a simple matter of constructing an object from your 
<I>CDialog</I>-derived class and calling that object's 
<I>DoModal</I> function. <I>DoModal</I> doesn't return 
until after the dialog box is dismissed. When 
<I>DoModal</I> does return, its return value is 
the value that was passed to <I>EndDialog</I>. Applications typically test the 
<I>DoModal </I>return value and take action only if the return value is IDOK, indicating that the dialog 
box was dismissed with the OK button. If the return value is anything else (most 
likely IDCANCEL), the information entered into the dialog box is ignored.
</P>

<P><I>CDialog</I> defines two constructors: one that accepts a string dialog 
template resource ID and a <I>CWnd</I> pointer identifying the dialog box's owner, and another 
that accepts an integer dialog template resource ID and a 
<I>CWnd</I> pointer identifying the dialog box's owner. The 
<I>CWnd</I> pointer can be omitted, in which case the 
application's main window becomes the dialog's owner. To make derived dialog classes 
more objectlike and more self-contained, MFC programmers often provide their own 
constructors that build in references to the dialog templates. You could write a 
simple inline constructor for <I>CMyDialog</I> like this:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMyDialog::CMyDialog (CWnd* pParentWnd = NULL) :
    CDialog (IDD_MYDIALOG, pParentWnd) {}
</PRE></TD></TR></TABLE>
</P>

<P>This constructor simplifies the code that creates the dialog box and eliminates the possibility of inadvertently passing the constructor the wrong resource identifier:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMyDialog dlg;
dlg.DoModal ();
</PRE></TD></TR></TABLE>
</P>

<P>When the user dismisses the dialog box by clicking OK or Cancel, 
<I>DoModal</I> returns and the function that called 
<I>DoModal</I> continues. If the action taken following the 
call to <I>DoModal</I> depends on whether the data entered in the dialog box was okayed 
or canceled (and it almost inevitably will), you can test the return value, like this:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMyDialog dlg;
if (dlg.DoModal () == IDOK) {
    // The user clicked OK; do something!
}

</PRE></TD></TR></TABLE>
</P>

<P>By default, the only values <I>DoModal</I> will return are IDOK and IDCANCEL. 
However, you can write your dialog class to return other values by calling 
<I>EndDialog</I> with a value other than IDOK or IDCANCEL. You could, for example, include an End 
This Application button in a dialog box and wire it into the program as follows:
</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
// In the dialog class
BEGIN_MESSAGE_MAP (CMyDialog, CDialog)
    ON_BN_CLICKED (IDC_ENDAPP, OnEndThisApplication)
END_MESSAGE_MAP ()
  
  <img src="images/grayvellip.JPG" width=3 height=13 border="0">
void CMyDialog::OnEndThisApplication ()
{
    EndDialog (IDC_ENDAPP);
}

// Elsewhere in the application
CMyDialog dlg;
int nReturn = dlg.DoModal ();
if (nReturn == IDOK) {
    // The user clicked OK; do something!
}
else if (nReturn == IDC_ENDAPP)
    PostMessage (WM_CLOSE, 0, 0);
</PRE></TD></TR></TABLE>
</P>


<P>When the user clicks End This Application in the dialog box, the return 
value IDC_ENDAPP alerts the caller that the user wants to terminate the application. 
Consequently, a WM_CLOSE message is posted to the message queue to initiate a 
shutdown. IDC_ENDAPP and other user-defined values passed to 
<I>EndDialog</I> should be assigned ID values equal to 3 or higher to avoid conflicting with the predefined 
IDOK and IDCANCEL button IDs.
</P>

<A NAME="216"><H2>Dialog Data Exchange and Dialog Data Validation</H2></A>

<P>A typical dialog box presents a list of options to the user, gathers input regarding 
those options, and makes that input available to the application that created the dialog 
box. A convenient way to expose the input is to map it to public member variables in 
the dialog class. The application that uses the dialog box can then access the data 
by reading or writing the dialog object's member variables.
</P>

<P>Suppose your dialog box contains two single-line edit controls in which the 
user enters a name and a phone number. To expose the name and number input by 
the user to the application that creates the dialog, declare two 
<I>CString</I> member variables in your dialog class:
</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
class CMyDialog : public CDialog
{
public:
    CMyDialog::CMyDialog (CWnd* pParentWnd = NULL) :
        CDialog (IDD_MYDIALOG, pParentWnd) {}
    CString m_strName;
    CString m_strPhone;
<img src="images/grayvellip.JPG" width=3 height=13 border="0">
};
</PRE></TD></TR></TABLE>
</P>


<P>To solicit a name and phone number from the user, display the dialog and 
retrieve the values of <I>m_strName</I> and 
<I>m_strPhone</I> after the dialog is dismissed:
</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMyDialog dlg;
if (dlg.DoModal () == IDOK) {
    CString strName = dlg.m_strName;
    CString strPhone = dlg.m_strPhone;
    TRACE (_T (&quot;Name=%s, Phone=%s&quot;), strName, strPhone);
}
</PRE></TD></TR></TABLE>
</P>


<P>You could modify the code slightly to initialize the edit controls with a default 
name and phone number:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMyDialog dlg;
dlg.m_strName = _T (&quot;Jeff&quot;);
dlg.m_strPhone = _T (&quot;555-1212&quot;);
if (dlg.DoModal () == IDOK) {
    CString strName = dlg.m_strName;
    CString strPhone = dlg.m_strPhone;
    TRACE (_T (&quot;Name=%s, Phone=%s&quot;), strName, strPhone);
}
</PRE></TD></TR></TABLE>
</P>

<P>These examples assume that <I>m_strName</I> and 
<I>m_strPhone</I> are intrinsically linked to the dialog's edit controls&#8212;that is, that the strings assigned to these variables are 
magically inserted into the edit controls and that strings read from these variables are 
the strings the user entered into the edit controls.
</P>

<P>The coupling of a dialog's controls and data members doesn't happen by 
itself; you have to make it happen. One way to perform the coupling is to 
override <I>OnInitDialog</I> and <I>OnOK</I> in the derived dialog class and include code that 
transfers data between the controls and the data members. Assuming the edit controls' IDs 
are IDC_NAME and IDC_PHONE, here's a revised version of 
<I>CMyDialog</I> that demonstrates this technique:
</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
class CMyDialog : public CDialog
{
public:
    CMyDialog::CMyDialog (CWnd* pParentWnd = NULL) :
        CDialog (IDD_MYDIALOG, pParentWnd) {}
    CString m_strName;
    CString m_strPhone;
protected:
    virtual BOOL OnInitDialog ();
    virtual void OnOK ();
};

BOOL CMyDialog::OnInitDialog ()
{
    CDialog::OnInitDialog ();
    SetDlgItemText (IDC_NAME, m_strName);
    SetDlgItemText (IDC_PHONE, m_strPhone);
    return TRUE;
}

void CMyDialog::OnOK ()
{
    GetDlgItemText (IDC_NAME, m_strName);
    GetDlgItemText (IDC_PHONE, m_strPhone);
    CDialog::OnOK ();
}
</PRE></TD></TR></TABLE>
</P>


<P>Structuring <I>CMyDialog</I> this way ensures that strings written to 
<I>m_strName</I> and <I>m_strPhone</I> before the dialog is created will appear in the edit controls and that 
strings entered in those edit controls will be copied to 
<I>m_strName</I> and <I>m_strPhone</I> when the dialog is dismissed with the OK button.
</P>

<P>Imagine how trivial the implementation of 
<I>CMyDialog</I> would be if you didn't have to initialize the controls in 
<I>OnInitDialog</I> and read them back in 
<I>OnOK</I>&#8212;that is, if you could provide a &quot;data map&quot; of sorts correlating controls to member 
variables. Sound farfetched? It's not. In fact, that's exactly what MFC's Dialog Data 
Exchange (DDX) mechanism is for. It's simple to use, and in many cases, it completely 
obviates the need to supply custom 
<I>OnInitDialog</I> and <I>OnOK</I> functions, even if your 
dialog box contains dozens of controls.
</P>

<P>You enact DDX by overriding a virtual function named 
<I>DoDataExchange</I> in each class you derive from 
<I>CDialog</I>. In the override, you use DDX functions provided 
by MFC to transfer data between the dialog's controls and data members. Here's 
a <I>DoDataExchange</I> implementation that links two 
<I>CString</I> data members (<I>m_strName</I> and 
<I>m_strPhone</I>) to a pair of edit controls (IDC_NAME and IDC_PHONE):
</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
void CMyDialog::DoDataExchange (CDataExchange* pDX)
{
    DDX_Text (pDX, IDC_NAME, m_strName);
    DDX_Text (pDX, IDC_PHONE, m_strPhone);
}
</PRE></TD></TR></TABLE>
</P>


<P>MFC calls <I>DoDataExchange</I> once when the dialog is created (when the dialog 
box receives a WM_INITDIALOG message) and again when the OK button is clicked. 
The <I>pDX</I> parameter is a pointer to a 
<I>CDataExchange</I> object supplied by MFC. Among 
other things, the <I>CDataExchange</I> object tells 
<I>DDX_Text</I> in which direction the information 
is flowing&#8212;that is, whether data is being transferred from the data members to the 
controls or from the controls to the data members. Once it has determined the direction 
of data flow, <I>DDX_Text</I> performs the actual data transfer. Thus, one 
<I>DoDataExchange</I> function is sufficient to copy data from data members to controls when the dialog 
is created and from the controls to the data members when the dialog is dismissed.
</P>

<P><I>DDX_Text</I> is one of several DDX functions that MFC provides; a partial list 
is shown in the table below. The relationship between a control and a 
data member depends on the DDX function connecting the two. For example, an 
int variable linked to a group of radio buttons with 
<I>DDX_Radio</I> holds a 0-based index identifying one member of the group. 
If the int's value is 2 when the dialog is created, 
<I>DDX_Radio</I> checks the third button in the group. When the OK button 
is clicked, <I>DDX_Radio</I> copies the index of the currently selected button to the 
member variable. An int connected to a scroll bar with 
<I>DDX_Scroll</I> specifies the position of the scroll bar thumb, and an int associated with a check box with 
<I>DDX_Check</I> specifies the check box's state&#8212;BST_CHECKED, BST_UNCHECKED, or, for 
three-state check boxes, BST_INDETERMINATE. If an int is linked to an edit control 
with <I>DDX_Text</I>, MFC automatically converts the integer into a text string when 
transferring the value to the edit control and the string to an integer when transferring 
data from the edit control.
</P>


<P><B>Dialog Data Exchange (DDX) Functions</B>
</P>

<P>
<TABLE cellpadding=5 width="95%">
<TR>
<TH><I>DDX Function</I> </TH>    
<TH><I>Description</I></TH>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDX_Text</I> </TD>    
<TD VALIGN="TOP">Associates a BYTE, an int, a short, a UINT, a long, 
a DWORD, a <I>CString</I>, a string, a float, a double, 
a <I>COleDateTime</I>, or a <I>COleCurrency</I> variable with an 
edit control</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDX_Check</I>  </TD>   
<TD VALIGN="TOP">Associates an int variable with a check box control</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDX_Radio</I>     </TD>
<TD VALIGN="TOP">Associates an int variable with a group of radio buttons</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDX_LBIndex</I>     </TD>
<TD VALIGN="TOP">Associates an int variable with a list box</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDX_LBString</I>     </TD>
<TD VALIGN="TOP">Associates a <I>CString</I> variable with a list box</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDX_LBStringExact</I>     </TD>
<TD VALIGN="TOP">Associates a <I>CString</I> variable with a list box</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDX_CBIndex</I>     </TD>
<TD VALIGN="TOP">Associates an int variable with a combo box</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDX_CBString</I>     </TD>
<TD VALIGN="TOP">Associates a <I>CString</I> variable with a combo box</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDX_CBStringExact</I>     </TD>
<TD VALIGN="TOP">Associates a <I>CString</I> variable with a combo box</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDX_Scroll</I>     </TD>
<TD VALIGN="TOP">Associates an int variable with a scroll bar</TD>
</TR>
</TABLE>
</P>



<P>A related mechanism called Dialog Data Validation (DDV) allows MFC to 
validate the values entered into a dialog's controls before the dialog is dismissed. 
DDV functions fall into two categories: those that validate numeric variables to ensure 
that they fall within specified limits and one that validates a 
<I>CString</I> variable to verify that its length doesn't exceed a certain value. Here's a 
<I>DoDataExchange</I> function that uses 
<I>DDX_Text</I> to connect an int member variable to an edit control and 
<I>DDV_MinMaxInt</I> to perform a range check on the value when the dialog's OK button is clicked:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
void CMyDialog::DoDataExchange (CDataExchange* pDX)
{
    DDX_Text (pDX, IDC_COUNT, m_nCount);
    DDV_MinMaxInt (pDX, m_nCount, 0, 100);
}
</PRE></TD></TR></TABLE>
</P>

<P>If the value displayed in the edit control is less than 0 or greater than 100 when 
OK is clicked, <I>DDV_MinMaxInt</I> transfers the input focus to the control and displays 
an error message. For a given data member, the DDV function call should 
immediately follow the DDX function call to enable MFC to set the input focus to the proper 
control if the validation proves negative.
</P>

<P><I>DDV_MinMaxInt</I> is one of several DDV functions that MFC provides. The 
following table lists the DDV functions that pertain to the classic controls. The DDV 
range-validation routines are not overloaded to accept multiple data types, so if you 
write a <I>DoDataExchange</I> function by hand, you must be careful to match the function 
to the data type.
</P>

<P><B>Dialog Data Validation (DDV) Functions</B>
</P>
<P>
<TABLE cellpadding=5 width="95%">
<TR>
<TH><I>Function</I></TH>     
<TH><I>Description</I></TH>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDV_MinMaxByte</I>     </TD>
<TD VALIGN="TOP">Verifies that a BYTE value falls within specified limits</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDV_MinMaxInt</I>     </TD>
<TD VALIGN="TOP">Verifies that an int value falls within specified limits</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDV_MinMaxLong</I>     </TD>
<TD VALIGN="TOP">Verifies that a long value falls within specified limits</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDV_MinMaxUInt</I>     </TD>
<TD VALIGN="TOP">Verifies that a UINT value falls within specified limits</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDV_MinMaxDWord</I>     </TD>
<TD VALIGN="TOP">Verifies that a DWORD value falls within 
specified limits</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDV_MinMaxFloat</I>     </TD>
<TD VALIGN="TOP">Verifies that a float value falls within specified limits</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDV_MinMaxDouble</I>     </TD>
<TD VALIGN="TOP">Verifies that a double value falls within specified limits</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>DDV_MaxChars</I> </TD>    
<TD VALIGN="TOP">On entry, uses an EM_LIMITTEXT message to 
limit the number of characters that can be entered into 
an edit control; on exit, verifies that the control 
contains no more than the specified number of characters</TD>
</TR>
</TABLE></P>

<P>The code that drives DDX and DDV is found in 
<I>CDialog</I>. When the dialog box is created, 
<I>CDialog::OnInitDialog</I> calls the 
<I>UpdateData</I> function a dialog object 
inherits from <I>CWnd</I> with a FALSE parameter. 
<I>UpdateData</I>, in turn, creates a 
<I>CDataExchange</I> object and calls the dialog's 
<I>DoDataExchange</I> function, passing it a pointer to 
the <I>CDataExchange</I> object. Each DDX function called by 
<I>DoDataExchange</I> initializes a control using the value of a member variable. Later, when the user clicks 
OK, <I>CDialog::OnOK</I> calls <I>UpdateData</I> with a TRUE parameter, causing the DDX 
functions to do just the opposite of what they did earlier. Any DDV functions present 
in <I>DoDataExchange</I> take this opportunity to validate the user's input. Earlier I 
mentioned the importance of calling the base class's 
<I>OnOK</I> and <I>OnInitDialog</I> functions if 
you override them in a derived class. Now you know why. If you fail to call the base 
class implementations of these functions, the framework won't get the opportunity to 
call <I>UpdateData</I> and DDX and DDV won't work.
</P>

<P>What DDX and DDV amount to is a painless way to get data in and out of 
dialog box controls and perform simple validation procedures on the data. In 
practice, DDX and DDV prevent you from having to override 
<I>OnInitDialog</I> and <I>OnOK</I> simply to transfer data between a dialog's controls and data members.
</P>

<A NAME="217"><H3>More Help from ClassWizard</H3></A>


<P>In an application crafted with the MFC wizards, you can add DDX and DDV 
functions to <I>DoDataExchange</I> by hand, or you can let ClassWizard add them for 
you. ClassWizard will even add member variables to a dialog class for you. Here's 
the procedure for adding a data member to a dialog class 
<I>and</I> associating it with a control via DDX or DDV:
</P>

<OL>
<P><LI>Invoke ClassWizard, and go to the Member Variables page. (See 
Figure 8-4.)
</LI></P>

<P>
<A HREF="javascript:fullSize('F08mg04x.htm')"> <img src="images/F08mg04.JPG" width=404 height=290 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 8-4.</B> <I>ClassWizard's Member Variables page.</I><!-- /CAPTION -->
</p>

<P><LI>Select the dialog class's name in the Class Name box.
</LI></P>

<P><LI>Highlight the ID of the control that you want to associate with a 
member variable in the Control IDs box, and click the Add Variable button.</LI></P>

<P><LI>Type the member variable name into the Add Member Variable dialog 
box shown in Figure 8-5, and select the variable type from the Variable Type box. Then click OK.</LI></P>
</OL>

<P>If you examine the dialog class's source code after dismissing ClassWizard, 
you'll find that ClassWizard has added the member variable to the class declaration and 
also added a DDX statement to 
<I>DoDataExchange</I> connecting the member variable to 
a control. If the variable type is numeric, you can enter minimum and maximum 
values into the edit controls at the bottom of the Member Variables page and 
ClassWizard will add a <I>DDV_MinMax</I> statement, too. For string variables, you can enter a 
maximum character count and ClassWizard will add a 
<I>DDV_MaxChars</I> statement.
</P>

<P>
<IMG SRC="images/F08mg05.GIF" width=320 height=288 BORDER=0>
</P><P>
<B>Figure 8-5.</B> <I>ClassWizard's Add Member Variable dialog box.</I>
</P>

<A NAME="218"><H2>Interacting with the Controls in a Dialog</H2></A>

<P>Does the presence of DDX and DDV mean that you'll never again have to 
write code to interact with the controls in a dialog box? Hardly. You might, for 
example, need to call <I>CListBox</I> functions on a list box control to add strings to the list box 
in <I>OnInitDialog</I>. To do that, you'll need a 
<I>CListBox</I> pointer to the list box. The 
question is, How do you get that pointer?
</P>

<P>You can get a <I>CWnd</I> pointer to any control in a dialog with 
<I>CWnd::GetDlgItem</I>. The following code sample uses 
<I>GetDlgItem</I> and <I>CWnd::EnableWindow</I> to 
interactively enable the control whose ID is IDC_CHECK:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CWnd* pWnd = GetDlgItem (IDC_CHECK);
pWnd-&gt;EnableWindow (TRUE);
</PRE></TD></TR></TABLE>
</P>


<P>This code works fine because <I>GetDlgItem</I> returns a generic 
<I>CWnd</I> pointer and <I>EnableWindow</I> is a 
<I>CWnd</I> function. But consider the following code sample:
</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CListBox* pListBox = (CListBox*) GetDlgItem (IDC_LIST);
pListBox-&gt;AddString (_T (&quot;One&quot;));
pListBox-&gt;AddString (_T (&quot;Two&quot;));
pListBox-&gt;AddString (_T (&quot;Three&quot;));
</PRE></TD></TR></TABLE>
</P>

<P>This code works, but only because MFC is specifically architected to make it 
work. Because <I>GetDlgItem</I> returns a 
<I>CWnd</I> pointer, casting it to a 
<I>CListBox</I> pointer and calling a 
<I>CListBox</I> function through it is poor programming practice at best and 
dangerous at worst. In fact, in some situations, this technique simply won't work.
</P>

<P>A better solution for calling non-<I>CWnd</I> functions on a control in a dialog box 
is MFC's <I>CWnd::Attach</I> function. With 
<I>Attach</I>, you can declare an instance of a 
control class (for example, <I>CListBox</I>) and dynamically attach it to a dialog box control. 
Here's how you'd use <I>Attach</I> to add strings to a list box.
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CListBox wndListBox;
wndListBox.Attach (GetDlgItem (IDC_LIST)-&gt;m_hWnd);
wndListBox.AddString (_T (&quot;One&quot;));
wndListBox.AddString (_T (&quot;Two&quot;));
wndListBox.AddString (_T (&quot;Three&quot;));
wndListBox.Detach ();
</PRE></TD></TR></TABLE>
</P>

<P>When a <I>CListBox</I> object is declared on the stack as shown in this example, it's 
important to call <I>Detach</I> before the 
<I>CListBox</I> object goes out of scope. Otherwise, 
<I>CListBox</I>'s destructor will destroy the list box and the list box will suddenly disappear from 
the dialog box.
</P>

<P>MFC's <I>DDX_Control</I> function offers a seamless mechanism for attaching an 
instance of an MFC control class to a control in a dialog box. Placing the following 
statement in a derived dialog class's 
<I>DoDataExchange</I> function transparently connects 
a <I>CListBox</I> data member named 
<I>m_wndListBox</I> to a list box control whose ID 
is IDC_LIST:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
DDX_Control (pDX, IDC_LIST, m_wndListBox);
</PRE></TD></TR></TABLE>
</P>

<P>Now adding strings to the list box is a simple matter of calling 
<I>AddString</I> on <I>m_wndListBox</I>:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
m_wndListBox.AddString (_T (&quot;One&quot;));
m_wndListBox.AddString (_T (&quot;Two&quot;));
m_wndListBox.AddString (_T (&quot;Three&quot;));
</PRE></TD></TR></TABLE>
</P>

<P><I>DDX_Control</I> offers added value because rather than simply encapsulate a 
control's window handle as <I>Attach</I> does, 
<I>DDX_Control</I> dynamically subclasses the control 
so that messages sent to the control first pass through the object specified in 
<I>DDX_Control</I>'s third parameter. This is the easiest and most effective way to make a control in a 
dialog box behave like an object of a derived control class&#8212;for example, to make 
an edit control behave like a <I>CNumEdit</I> instead of an ordinary 
<I>CEdit</I>. You'll see an example demonstrating how to use a derived control class in a dialog box in the 
Phones application at the end of this chapter.
</P>

<P>You can use ClassWizard to add 
<I>DDX_Control</I> statements to 
<I>DoDataExchange</I>. To do it, go to the Member Variables page and use the Add Variable button to add 
a member variable to the dialog class. But this time, select Control rather than Value 
in the Add Member Variable dialog box's Category box. Then pick a control class in 
the Variable Type box and click OK until you exit ClassWizard. Now, if you check 
the dialog class, you'll find that ClassWizard has added both the member variable and 
a <I>DDX_Control</I> statement connecting the variable to the control.
</P>

<A NAME="219"><H2>The DlgDemo1 Application</H2></A>

<P>The DlgDemo1 application pictured in Figure 8-6 is a simple view-based 
program that draws a colored rectangle in the upper left corner of the view. The File 
menu features an Options command that displays a dialog box through which you can 
alter the rectangle's width, height, and units of measurement.
</P>

<P>
<A HREF="javascript:fullSize('F08mg06x.htm')"> <img src="images/F08mg06.JPG" width=404 height=305 border=0 ALT="Click to view at full size."> </A>
</P><P>
<!-- CAPTION --><B>Figure 8-6.</B> <I>The DlgDemo1 window and dialog box.</I><!-- /CAPTION -->
</P>

<P>I created DlgDemo1 with AppWizard and used ClassWizard to derive the 
dialog class, write message handlers, and so on. Portions of the source code are 
reproduced in Figure 8-7. The dialog box is an instance of 
<I>COptionsDialog</I>, which encapsulates the dialog resource IDD_OPTIONS. 
<I>COptionsDialog</I> has three public data 
members&#8212;<I>m_nWidth</I>, <I>m_nHeight</I>, and 
<I>m_nUnits</I>&#8212;which represent the rectangle's width, 
height, and units of measurement, respectively. Each data member is bound to a 
control (or group of controls) in the dialog box via DDX. 
An <I>m_nUnits</I> value equal to 0 represents inches, while 1 represents centimeters and 2 represents pixels. The view 
class <I>CChildView</I> contains identically named member variables that 
<I>CChildView::OnPaint</I> uses to paint the rectangle.
</P>

<P>When the Options command is selected from the File menu, the 
command handler <I>CChildView::OnFileOptions</I> instantiates 
<I>COptionsDialog</I>; copies the current width, height, and units values to the dialog object's member variables; and 
displays the dialog with <I>DoModal</I>. If 
<I>DoModal</I> returns IDOK, <I>OnFileOptions</I> reads 
the width, height, and units values from the dialog's data members and copies them 
to the view's data members. Then it calls 
<I>Invalidate</I> to repaint the view, which 
refreshes the rectangle to conform to the new parameters.
</P>

<P>
<B>Figure 8-7.</B> <I>The DlgDemo1 application.</I>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="220"><H3>MainFrm.h</H3></A>
<PRE>
// MainFrm.h : interface of the CMainFrame class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__AC8095E8_902A_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_MAINFRM_H__AC8095E8_902A_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#include &quot;ChildView.h&quot;

class CMainFrame : public CFrameWnd
{
    
public:
    CMainFrame();
protected: 
    DECLARE_DYNAMIC(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
        AFX_CMDHANDLERINFO* pHandlerInfo);
    //}}AFX_VIRTUAL
// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif
    CChildView    m_wndView;

// Generated message map functions
protected:



//{{AFX_MSG(CMainFrame)
    afx_msg void OnSetFocus(CWnd *pOldWnd);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(AFX_MAINFRM_H__AC8095E8_902A_11D2_8E53_006008A82731__INCLUDED_)
</PRE></TD></TR></TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="221"><H3>MainFrm.cpp</H3></A>
<PRE>
// MainFrm.cpp : implementation of the CMainFrame class
//

#include &quot;stdafx.h&quot;
#include &quot;DlgDemo1.h&quot;

#include &quot;MainFrm.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)

    ON_WM_SETFOCUS()
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction


CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    cs.dwExStyle &amp;= ~WS_EX_CLIENTEDGE;
    cs.lpszClass = AfxRegisterWndClass(0);
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext&amp; dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
void CMainFrame::OnSetFocus(CWnd* pOldWnd)
{
    // forward focus to the view window
    m_wndView.SetFocus();
}

BOOL CMainFrame::OnCmdMsg(UINT nID, int nCode, void* pExtra,
    AFX_CMDHANDLERINFO* pHandlerInfo)
{
    // let the view have first crack at the command
    if (m_wndView.OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // otherwise, do default handling
    return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    if (!m_wndView.Create(NULL, NULL, AFX_WS_DEFAULT_VIEW,
        CRect(0, 0, 0, 0), this, AFX_IDW_PANE_FIRST, NULL))
        return -1;

    return 0;
}
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="222"><H3>ChildView.h</H3></A>
<PRE>
// ChildView.h : interface of the CChildView class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDVIEW_H__AC8095EA_902A_11D2_8E53_006008A82731__INCLUDED_)

#define AFX_CHILDVIEW_H__AC8095EA_902A_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

///////////////////////////////////////////////////////////////////////////
// CChildView window

class CChildView : public CWnd
{
// Construction
public:
    CChildView();

// Attributes
public:

// Operations
public:
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChildView)
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CChildView();

    // Generated message map functions
protected:
    int m_nUnits;
    int m_nHeight;
    int m_nWidth;
    //{{AFX_MSG(CChildView)
    afx_msg void OnPaint();
    afx_msg void OnFileOptions();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately 
// before the previous line.

#endif 
//defined(AFX_CHILDVIEW_H__AC8095EA_902A_11D2_8E53_006008A82731__INCLUDED_)
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="223"><H3>ChildView.cpp</H3></A>
<PRE>
// ChildView.cpp : implementation of the CChildView class
//

#include &quot;stdafx.h&quot;
#include &quot;DlgDemo1.h&quot;
#include &quot;OptionsDialog.h&quot;
#include &quot;ChildView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CChildView

CChildView::CChildView()
{
    m_nWidth = 4;
    m_nHeight = 2;
    m_nUnits = 0;
}

CChildView::~CChildView()
{
}

BEGIN_MESSAGE_MAP(CChildView,CWnd )
    //{{AFX_MSG_MAP(CChildView)
    ON_WM_PAINT()
    ON_COMMAND(ID_FILE_OPTIONS, OnFileOptions)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CChildView message handlers

BOOL CChildView::PreCreateWindow(CREATESTRUCT&amp; cs) 
{
    if (!CWnd::PreCreateWindow(cs))
        return FALSE;

    cs.dwExStyle &#166;= WS_EX_CLIENTEDGE;
    cs.style &amp;= ~WS_BORDER;
    cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW&#166;CS_VREDRAW&#166;CS_DBLCLKS, 
        ::LoadCursor(NULL, IDC_ARROW), HBRUSH(COLOR_WINDOW+1), NULL);

    return TRUE;
}

void CChildView::OnPaint() 
{
    CPaintDC dc(this); // Device context for painting.
    
    CBrush brush (RGB (255, 0, 255));
    CBrush* pOldBrush = dc.SelectObject (&amp;brush);
    switch (m_nUnits) {

    case 0: // Inches.
        dc.SetMapMode (MM_LOENGLISH);
        dc.Rectangle (0, 0, m_nWidth * 100, -m_nHeight * 100);
        break;

    case 1: // Centimeters.
        dc.SetMapMode (MM_LOMETRIC);
        dc.Rectangle (0, 0, m_nWidth * 100, -m_nHeight * 100);
        break;

    case 2: // Pixels.
        dc.SetMapMode (MM_TEXT);
        dc.Rectangle (0, 0, m_nWidth, m_nHeight);
        break;
    }
    dc.SelectObject (pOldBrush);
}

void CChildView::OnFileOptions() 
{
    COptionsDialog dlg;

    dlg.m_nWidth = m_nWidth;
    dlg.m_nHeight = m_nHeight;
    dlg.m_nUnits = m_nUnits;

    if (dlg.DoModal () == IDOK) {
        m_nWidth = dlg.m_nWidth;
        m_nHeight = dlg.m_nHeight;
        m_nUnits = dlg.m_nUnits;
        Invalidate ();
    }    
}
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="224"><H3>OptionsDialog.h</H3></A>
<PRE>#if !defined(AFX_OPTIONSDIALOG_H__AC8095F0_902A_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_OPTIONSDIALOG_H__AC8095F0_902A_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// OptionsDialog.h : header file
//

///////////////////////////////////////////////////////////////////////////
// COptionsDialog dialog

class COptionsDialog : public CDialog
{
// Construction
public:
    COptionsDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(COptionsDialog)
    enum { IDD = IDD_OPTIONS };
    int        m_nWidth;
    int        m_nHeight;
    int        m_nUnits;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(COptionsDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(COptionsDialog)
    afx_msg void OnReset();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
//!defined(
//    AFX_OPTIONSDIALOG_H__AC8095F0_902A_11D2_8E53_006008A82731__INCLUDED_)
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>

<A NAME="225"><H3>OptionsDialog.cpp</H3></A>
<PRE>// OptionsDialog.cpp : implementation file
//

#include &quot;stdafx.h&quot;
#include &quot;DlgDemo1.h&quot;
#include &quot;OptionsDialog.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// COptionsDialog dialog

COptionsDialog::COptionsDialog(CWnd* pParent /*=NULL*/)
    : CDialog(COptionsDialog::IDD, pParent)
{
    //{{AFX_DATA_INIT(COptionsDialog)
    m_nWidth = 0;
    m_nHeight = 0;
    m_nUnits = -1;
    //}}AFX_DATA_INIT
}

void COptionsDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(COptionsDialog)
    DDX_Text(pDX, IDC_WIDTH, m_nWidth);
    DDV_MinMaxInt(pDX, m_nWidth, 1, 128);
    DDX_Text(pDX, IDC_HEIGHT, m_nHeight);
    DDX_Radio(pDX, IDC_INCHES, m_nUnits);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(COptionsDialog, CDialog)
    //{{AFX_MSG_MAP(COptionsDialog)
    ON_BN_CLICKED(IDC_RESET, OnReset)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// COptionsDialog message handlers

void COptionsDialog::OnReset() 
{
    m_nWidth = 4;
    m_nHeight = 2;


    m_nUnits = 0;
    UpdateData (FALSE);    
}
</PRE></TD></TR></TABLE>
</P>




<P>Here's a synopsis of the procedure I used to write DlgDemo1. You can 
create the application, too, by following these steps:</P>

<OL>
<P><LI>Use AppWizard to create a project named DlgDemo1. In AppWizard's Step 1 dialog box, choose Single Document as the application type and uncheck the Document/View Architecture Support box. Uncheck the following boxes in the Step 3 and Step 4 dialog boxes:</LI></P>

<UL>
<P><LI>ActiveX Controls</LI></P>
<P><LI>3D Controls</LI></P>
<P><LI>Docking Toolbar</LI></P>
<P><LI>Initial Status Bar</LI></P>
</UL>

<P>Accept the AppWizard defaults everywhere else.</P>

<P><LI>Add the following member variables to 
<I>CChildView</I>. Make the member variables protected, and initialize them in the view's constructor.</LI></P>
<P>
<TABLE cellpadding=5 width="95%">
<TR>
<TH><I>Variable Name</I></TH>     
<TH><I>Type</I> </TH>    
<TH><I>Initial Value</I></TH>
</TR>

<TR>
<TD VALIGN="TOP"><I>m_nWidth</I></TD>     
<TD VALIGN="TOP">int</TD>     
<TD VALIGN="TOP">4</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>m_nHeight</I></TD>     
<TD VALIGN="TOP">int </TD>    
<TD VALIGN="TOP">2</TD>
</TR>

<TR>
<TD VALIGN="TOP"><I>m_nUnits</I></TD>     
<TD VALIGN="TOP">int </TD>    
<TD VALIGN="TOP">0</TD>
</TR>
</TABLE></P>
<P><LI>Implement the view's <I>OnPaint</I> function.</LI></P>

<P><LI>To compensate for a bug in Visual C++ 6.0, add a WM_CREATE 
message handler to the frame window class 
<I>CMainFrame</I> and add code to create the view.
</LI></P>

<P><LI>Use the Insert-Resource command to add a new dialog resource to 
the project. Change the dialog's resource ID to IDD_OPTIONS by 
right-clicking IDD_DIALOG1 in ResourceView, selecting Properties from the 
context menu, and entering the new ID. While you're at it, change the 
dialog's caption to &quot;Options.&quot;
</LI></P>

<P><LI>Edit the dialog box so that it resembles the one in Figure 8-6. The table below lists the controls in the dialog box and their IDs. Be sure to create the radio buttons one after another so that they will be assigned consecutive control IDs. The OK and Cancel buttons are provided for you, so you don't need to add them separately.
</LI></P>
<P>
<TABLE cellpadding=5 width="95%">
<TR>
<TH><I>Control Type   </I>  </TH>
<TH><I>Control Text </I>    </TH>
<TH><I>Control ID</I></TH>
</TR>

<TR>
<TD VALIGN="TOP">Static     </TD>
<TD VALIGN="TOP">&quot;&amp;Width&quot;     </TD>
<TD VALIGN="TOP">IDC_STATIC</TD>
</TR>

<TR>
<TD VALIGN="TOP">Static    </TD> 
<TD VALIGN="TOP">&quot;&amp;Height&quot;  </TD>   
<TD VALIGN="TOP">IDC_STATIC</TD>
</TR>

<TR>
<TD VALIGN="TOP">Edit</TD>     
<TD VALIGN="TOP">None </TD>    
<TD VALIGN="TOP">IDC_WIDTH</TD>
</TR>

<TR>
<TD VALIGN="TOP">Edit</TD>     
<TD VALIGN="TOP">None</TD>     
<TD VALIGN="TOP">IDC_HEIGHT</TD>
</TR>

<TR>
<TD VALIGN="TOP">Group box     </TD>
<TD VALIGN="TOP">&quot;Units&quot;     </TD>
<TD VALIGN="TOP">IDC_STATIC</TD>
</TR>

<TR>
<TD VALIGN="TOP">Radio button     </TD>
<TD VALIGN="TOP">&quot;&amp;Inches&quot;     </TD>
<TD VALIGN="TOP">IDC_INCHES</TD>
</TR>

<TR>
<TD VALIGN="TOP">Radio button     </TD>
<TD VALIGN="TOP">&quot;&amp;Centimeters&quot;     </TD>
<TD VALIGN="TOP">IDC_CENTIMETERS</TD>
</TR>

<TR>
<TD VALIGN="TOP">Radio button     </TD>
<TD VALIGN="TOP">&quot;&amp;Pixels&quot;     </TD>
<TD VALIGN="TOP">IDC_PIXELS</TD>
</TR>

<TR>
<TD VALIGN="TOP">Push button     </TD>
<TD VALIGN="TOP">&quot;&amp;Reset&quot;     </TD>
<TD VALIGN="TOP">IDC_RESET<BR></TD>
</TR>

<TR>
<TD VALIGN="TOP">Push button     </TD>
<TD VALIGN="TOP">&quot;OK&quot;     </TD>
<TD VALIGN="TOP">IDOK</TD>
</TR>

<TR>
<TD VALIGN="TOP">Push button     </TD>
<TD VALIGN="TOP">&quot;Cancel&quot;     </TD>
<TD VALIGN="TOP">IDCANCEL</TD>
</TR>
</TABLE>
</P>

<P><LI>Select Tab Order from the Layout menu, and set the tab order shown in Figure 8-2. You can test the tab order by selecting Tab Order again to exit tab order mode, selecting Test from the Layout menu and using the Tab key to tab among the dialog box's controls. Note that you must manually select one of the radio buttons before the Tab key will move the input focus to a radio button.</LI></P>

<P><LI>Let Windows know that the three radio buttons are a group by marking the first control in the group (the Inches radio button) and the first control in the tab order following the final control in the group (the OK button) with the style WS_GROUP. You can test the grouping by choosing Test from the Layout menu, clicking one of the radio buttons, and pressing the up or down arrow key a few times. If the radio buttons are properly grouped, the input focus will cycle among the radio buttons.
</LI></P>

<P><LI>Double-click the dialog box in the dialog editor, and use ClassWizard to derive a dialog class named 
<I>COptionsDialog</I>. After you dismiss ClassWizard, <I>COptionsDialog</I> should appear in the ClassView window.</LI></P>

<P><LI>Use ClassWizard to add three int member variables to the dialog 
class: one (<I>m_nUnits</I>) that's linked to the radio button IDC_INCHES, another (<I>m_nWidth</I>) that's linked to the IDC_WIDTH edit control, and a third (<I>m_nHeight</I>) that's linked to the IDC_HEIGHT edit control. Set the minimum and maximum values for <I>m_nWidth</I> and <I>m_nHeight</I> to 1 and 128, respectively.</LI></P>

<p>
<div class="note"><blockquote>
<b>NOTE</b><hr>Be sure that you create int member variables for the 
edit controls, not <I>CString</I> member variables, by selecting int in the 
Add Member Variable dialog box's Variable Type field. 
<I>CString</I> is the default. If you make a mistake, use the Delete Variable button 
to delete the member variable and try again.
</blockquote></div></p>

<P><LI>Open the menu resource IDR_MAINFRAME, and add an Options 
command to the File menu. Enter &quot;&amp;Options...&quot; for the text of the menu item 
and ID_FILE_OPTIONS for the command ID.</LI></P>

<P><LI>Add the following #include to the view's CPP file:</LI></P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
#include &quot;OptionsDialog.h&quot;
</PRE></TD></TR></TABLE>
</P>

<P>Then add a command handler named 
<I>OnFileOptions</I> to the view class that's called when the Options command is selected. Implement the 
function as shown in Figure 8-7.</P>

<P><LI>Add a BN_CLICKED handler named 
<I>OnReset</I> to the dialog class that sets 
<I>m_nWidth</I> to 4, <I>m_nHeight</I> to 2, and 
<I>m_nUnits</I> to 0 when the Reset button is clicked. Implement the handler as shown in Figure 8-7.</LI></P>

<P><LI>Run the application, and use the File/Options command to display the Options dialog box. Test your handiwork by entering various widths and heights and selecting different units of measurement.</LI></P>
</OL>

<P>Notice how <I>COptionsDialog::OnReset</I> is implemented. It's perfectly legal to 
call <I>UpdateData</I> yourself to transfer data between a dialog's controls and data 
members. In this case, <I>UpdateData</I> is called with a FALSE parameter to transfer data from 
the member variables to the controls. To read data out of the controls and into the 
member variables, pass <I>UpdateData</I> a TRUE parameter.
</P>

</BODY>
</HTML>




