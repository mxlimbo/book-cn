<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Progress Controls and Animation Controls</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch16d.htm", "ch16f.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="516"><H1>Progress Controls and Animation Controls</H1></A>

<P>Comctl32.dll includes two convenient tools for providing visual feedback to 
users concerning the status of ongoing operations. The first is the progress control. A 
<I>progress control</I> is a vertical or horizontal rectangle containing a colored bar that grows as 
an operation approaches completion. The second is the 
<I>animation control</I>, which reduces the complex task of playing an AVI file to two simple function calls. 
Although animation controls enjoy a variety of uses, very often they are used simply to let 
the user know that a lengthy operation is underway.</p>

<A NAME="517"><H2>Progress Controls</H2></A>

<P>MFC represents progress controls with instances of the class 
<I>CProgressCtrl</I>. By default, a progress control is oriented horizontally and its bar is drawn as a series 
of line segments. You can orient a progress control vertically by assigning it the 
style PBS_VERTICAL, and you can change the bar from broken to solid with 
PBS_SMOOTH. (See Figure 16-11.) Unfortunately, neither style is supported in the absence of 
Internet Explorer 3.0 or later.</p>

<p>
<img src="images/F16mg11.GIF" width=366 height=157 border=0>
</p><p>
<!-- CAPTION --><B>Figure 16-11.</B> <I>Progress controls with and without the style PBS_SMOOTH.</I><!-- /CAPTION -->
</p>

<p>Like slider controls, progress controls have ranges and positions. If a 
progress control's range is 0 to 100 and its position is 20, the bar fills 20 percent of the 
control. If the range is 100 to 400 and the position is 300, the bar extends two-thirds of 
the control's length. The default range is 0 to 100, but you can change it to anything 
you like with <I>CProgressCtrl::SetRange</I>. If 
<I>m_wndProgress</I> is a <I>CProgressCtrl</I> object, 
the statement</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndProgress.SetRange (100, 400);
</pre></td></tr></table></p>

<P>sets the control's range to 100 to 400. 
<I>SetRange</I> limits its minimums and maximums to 16-bit values, but if Internet Explorer 3.0 or later is installed, you can specify 
32-bit ranges using the newer 
<I>CProgressCtrl::SetRange32</I> function. To retrieve the 
current range, use <I>GetRange</I>. 
<I>GetRange</I> handles both 16-bit and 32-bit ranges.</p>

<p>Once you've created a progress control and set its range, you can set its 
position with <I>CProgressCtrl::SetPos</I>. The following example steps a progress control 
from 0 to 100 in about 2&#189; seconds by calling 
<I>SetPos</I> repeatedly from a loop that uses the 
<I>::Sleep</I> API function to ensure that each iteration requires at least 25 milliseconds:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndProgress.SetRange (0, 100);
m_wndProgress.SetPos (0);
for (int i=0; i&lt;100; i++) {
    m_wndProgress.SetPos (i);
    ::Sleep (25);
}
m_wndProgress.SetPos (0);
</pre></td></tr></table></p>

<P>That's one way to step a progress control. You can also use the 
<I>OffsetPos</I> function to specify a new position that's relative to the current one. Here's the previous 
code sample rewritten to use <I>OffsetPos</I>:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndProgress.SetRange (0, 100);
m_wndProgress.SetPos (0);
for (int i=0; i&lt;100; i++) {
    m_wndProgress.OffsetPos (1);
    ::Sleep (25);
}
m_wndProgress.SetPos (0);
</pre></td></tr></table></p>

<P>A third way to step a progress control is to assign the control a step size with 
<I>SetStep</I> and then to increment the position by the current step size with 
<I>StepIt</I>:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndProgress.SetRange (0, 100);
m_wndProgress.SetPos (0);
m_wndProgress.SetStep (1);
for (int i=0; i&lt;100; i++) {
    m_wndProgress.StepIt ();
    ::Sleep (25);
}
m_wndProgress.SetPos (0);
</pre></td></tr></table></p>

<P>You can call the complementary 
<I>CProgressCtrl::GetPos</I> function at any time to 
retrieve the control's current position.</p>

<p>By default, the color of the bar in a progress control is the system color 
COLOR_HIGHLIGHT, and the control's background color is COLOR_3DFACE. On 
systems equipped with Internet Explorer 4.0 or higher, you can change the bar color with 
a PBM_SETBARCOLOR message, and you can change the control's background 
color with a PBM_SETBKCOLOR message. Because 
<I>CProgressCtrl</I> lacks wrapper functions for these messages, you must send the messages yourself. For example, the statement</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndProgress.SendMessage (PBM_SETBARCOLOR, 0, (LPARAM) RGB (255, 0, 0));
</pre></td></tr></table></p>

<P>changes <I>m_wndProgress</I>'s bar color to red.</p>

<p>One of the sample programs in the next chapter&#8212;ImageEdit&#8212;uses a 
progress control to provide visual feedback regarding an image processing operation. 
The progress control is attached to a status bar and in fact appears to be an ordinary 
status bar pane until the operation begins and the bar begins stepping across the face 
of the control. If you'd like to see a progress control in action, feel free to skip 
ahead and take a look at ImageEdit.</p>

<A NAME="518"><H2>Animation Controls</H2></A>

<P>Animation controls simplify the task of playing video clips in a dialog box or a 
window. The video clips must be in Windows AVI format, and they can have at most 
two streams inside them. If one of the streams is an audio stream, it is ignored. 
Visual Studio comes with a number of sample AVI files that work well in animation 
controls. One of those sample files, Findfile.avi, contains the circling magnifying 
glass featured in the system's Find utility. Another, Filecopy.avi, contains the &quot;flying 
paper&quot; clip you see when you drag-copy a large file or group of files from one folder to 
another.</p>

<p><I>CAnimateCtrl</I> wraps the functionality of animation controls in an 
easy-to-use C++ class. Using <I>CAnimateCtrl</I> is simplicity itself. 
<I>CAnimateCtrl::Open</I> loads an AVI clip from a resource or an external file. 
<I>CAnimateCtrl::Play</I> begins playing the clip, 
<I>CAnimateCtrl::Stop</I> stops it, and 
<I>CAnimateCtrl::Close</I> unloads the clip. Assuming 
that <I>m_wndAnimate</I> is an instance of 
<I>CAnimateCtrl</I> and that it is associated with an 
animation control, the following code sample loads an AVI file named Findfile.avi 
and begins playing it:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndAnimate.Open (_T (&quot;Findfile.avi&quot;));
m_wndAnimate.Play (0, -1, -1);
</pre></td></tr></table></p>

<P><I>Open</I> will accept a resource ID in lieu of a file name, enabling you to embed 
AVI clips as resources in EXE files:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
// In the RC file
IDR_FINDFILE AVI &quot;Findfile.avi&quot;
    <img src="images/grayvellip.JPG" width=3 height=13 border="0">
// In the CPP file
m_wndAnimate.Open (IDR_FINDFILE);
m_wndAnimate.Play (0, -1, -1);
</pre></td></tr></table></p>

<P><I>Play</I> starts the animation and returns immediately; it doesn't wait around for the 
animation to stop. That's good, because it means the thread that called 
<I>Play</I> can continue working while the animation plays in the background.</p>

<p><I>Play</I> accepts three parameters: the starting and ending frame numbers and 
the number of times the animation should be played. Specifying 0, 
-1, and -1 for these parameters tells the control to play all the frames and to repeat them indefinitely 
until <I>Stop</I> is called, like this:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndAnimate.Stop ();
</pre></td></tr></table></p>

<P>After you call <I>Stop</I>, you should call 
<I>Close</I> to remove the clip from memory if you 
don't intend to play it anymore:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
m_wndAnimate.Close ();
</pre></td></tr></table></p>

<P>Every call to <I>Open</I> should be accompanied by a call to 
<I>Close</I> to prevent resource leaks.</p>

<p>Animation controls support four styles that affect their appearance and 
operation. ACS_AUTOPLAY configures the control to begin playing an animation as 
soon as it is opened rather than waiting for 
<I>Play</I> to be called. ACS_CENTER centers the output in the control rectangle. Without this style, the clip plays in the upper left 
corner of the control rectangle and the control is resized to fit the frames contained in 
the animation. ACS_TRANSPARENT plays the animation using a transparent 
background instead of the background color designated inside the AVI file. Finally, 
ACS_TIMER prevents the control from launching a background thread to do its drawing. 
Rather than start another thread (threads consume resources, and too many threads can 
bog down the system), an ACS_TIMER-style animation control sets a timer in the 
caller's thread and uses timer callbacks to draw successive frames. ACS_TIMER is 
supported only on systems equipped with Internet Explorer 3.0 or later.</p>

</BODY>
</HTML>




