<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Common Control Fundamentals</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch16a.htm", "ch16c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="493"><H1>Common Control Fundamentals</H1></A>

<P>MFC provides classes to wrap the common controls just as it provides classes to wrap the core control types implemented in User.exe. The following table shows the 20 types of common controls, the WNDCLASSes on which they're based, and the corresponding MFC classes. It also shows aliases for those WNDCLASSes defined in the header file Commctrl.h. Image lists and property sheets don't have WNDCLASSes because they're not controls in the strict sense of the word, but they're nearly always counted among the common controls because their code resides in Comctl32.dll. You'll sometimes see drag list boxes shown with the common controls. I didn't include them here because drag list boxes aren't stand-alone controls; they're conventional list boxes that are converted into &quot;drag&quot; list boxes by a function in Comctl32.dll. MFC provides a convenient implementation of drag list boxes in <I>CDragListBox</I>, so for more information, see the documentation for <I>CDragListBox</I>.</p>


<P><b>The Common Controls</b></p>
<p>
<table width="95%" cellpadding="5">
<tr><th valign="top"><i>Control Type</i></th>
<th valign="top"><i>WNDCLASS</i></th>
<th valign="top"><i>WNDCLASS Alias</i></th>
<th valign="top"><i>MFC Class</i></th></tr>
<tr><td valign="top">Animation</td>
<td valign="top">&quot;SysAnimate32&quot;</td>
<td valign="top">ANIMATE_CLASS</td>
<td valign="top"><I>CAnimateCtrl</I></td></tr>
<tr><td valign="top">ComboBoxEx*</td>
<td valign="top">&quot;ComboBoxEx32&quot;</td>
<td valign="top">WC_COMBOBOXEX</td>
<td valign="top"><I>CComboBoxEx</I></td></tr>
<tr><td valign="top">Date-Time*</td>
<td valign="top">&quot;SysDateTimePick32&quot;</td>
<td valign="top">DATETIMEPICK_CLASS</td>
<td valign="top"><I>CDateTimeCtrl</I></td></tr>
<tr><td valign="top">Header</td>
<td valign="top">&quot;SysHeader32&quot;</td>
<td valign="top">WC_HEADER</td>
<td valign="top"><I>CHeaderCtrl</I></td></tr>
<tr><td valign="top">Hotkey</td>
<td valign="top">&quot;msctls_hotkey32&quot;</td>
<td valign="top">HOTKEY_CLASS</td>
<td valign="top"><I>CHotKeyCtrl</I></td></tr>
<tr><td valign="top">Image list</td>
<td valign="top">N/A</td>
<td valign="top">N/A</td>
<td valign="top"><I>CImageList</I></td></tr>
<tr><td valign="top">IP address**</td>
<td valign="top">&quot;SysIPAddress32&quot;</td>
<td valign="top">WC_IPADDRESS</td>
<td valign="top"><I>CIPAddressCtrl</I></td></tr>
<tr><td valign="top">List view</td>
<td valign="top">&quot;SysListView32&quot;</td>
<td valign="top">WC_LISTVIEW</td>
<td valign="top"><I>CListCtrl</I></td></tr>
<tr><td valign="top">Month calendar*</td>
<td valign="top">&quot;SysMonthCal32&quot;</td>
<td valign="top">MONTHCAL_CLASS</td>
<td valign="top"><I>CMonthCalCtrl</I></td></tr>
<tr><td valign="top">Progress</td>
<td valign="top">&quot;msctls_progress32&quot;</td>
<td valign="top">PROGRESS_CLASS</td>
<td valign="top"><I>CProgressCtrl</I></td></tr>
<tr><td valign="top">Property sheet</td>
<td valign="top">N/A</td>
<td valign="top">N/A</td>
<td valign="top"><I>CPropertySheet</I></td></tr>
<tr><td valign="top">Rebar*</td>
<td valign="top">&quot;ReBarWindow32&quot;</td>
<td valign="top">REBARCLASSNAME</td>
<td valign="top"><I>CReBarCtrl</I></td></tr>
<tr><td valign="top">Rich edit</td>
<td valign="top">&quot;RichEdit20A&quot; (ANSI) or &quot;RichEdit20W&quot; (Unicode) </td>
<td valign="top">RICHEDIT_CLASS</td>
<td valign="top"><I>CRichEditCtrl</I></td></tr>
<tr><td valign="top">Slider</td>
<td valign="top">&quot;msctls_trackbar32&quot;</td>
<td valign="top">TRACKBAR_CLASS</td>
<td valign="top"><I>CSliderCtrl</I></td></tr>
<tr><td valign="top">Spin button</td>
<td valign="top">&quot;msctls_updown32&quot;</td>
<td valign="top">UPDOWN_CLASS</td>
<td valign="top"><I>CSpinButtonCtrl</I></td></tr>
<tr><td valign="top">Status bar</td>
<td valign="top">&quot;msctls_statusbar32&quot;</td>
<td valign="top">STATUSCLASSNAME</td>
<td valign="top"><I>CStatusBarCtrl</I></td></tr>
<tr><td valign="top">Tab</td>
<td valign="top">&quot;SysTabControl32&quot;</td>
<td valign="top">WC_TABCONTROL</td>
<td valign="top"><I>CTabCtrl</I></td></tr>
<tr><td valign="top">Toolbar</td>
<td valign="top">&quot;ToolbarWindow32&quot;</td>
<td valign="top">TOOLBARCLASSNAME</td>
<td valign="top"><I>CToolBarCtrl</I></td></tr>
<tr><td valign="top">ToolTip</td>
<td valign="top">&quot;tooltips_class32&quot;</td>
<td valign="top">TOOLTIPS_CLASS</td>
<td valign="top"><I>CToolTipCtrl</I></td></tr>
<tr><td valign="top">Tree view</td>
<td valign="top">&quot;SysTreeView32&quot;</td>
<td valign="top">WC_TREEVIEW</td>
<td valign="top"><I>CTreeCtrl</I></td></tr>
</table></p>
<P>*  Requires Internet Explorer 3.0 or later.</p>
<P>** Requires Internet Explorer 4.0 or later.</p>

<P>As you can see from the table, some of the common controls are only supported on systems that have a particular version of Internet Explorer installed. That's because when you install Internet Explorer, the setup program silently upgrades Comctl32.dll, too. Many times in this chapter I'll say something like &quot;This style is only supported on systems equipped with Internet Explorer 3.0 or later&quot; or &quot;This feature requires Internet Explorer 4.0.&quot; In truth, it's not Internet Explorer that's required but the version of Comctl32.dll that comes with that version of Internet Explorer. Because installing a more recent version of Internet Explorer is presently the only legal way to get the latest version of Comctl32.dll, Internet Explorer is a reasonable basis for documenting version dependencies.</p>

<P>Given the common controls' myriad dependencies on the version of Comctl32.dll that's installed and the fact that some systems don't have Internet Explorer installed at all, you might wonder how to determine at run time whether a given feature is supported provided that you know what version of Comctl32.dll it requires. Here's a simple routine that returns Comctl32.dll's major and minor version numbers. It returns 4.0 if the Comctl32.dll installed on the host system is one that predates Internet Explorer 3.0, and 0.0 if Comctl32.dll isn't installed at all:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
void GetComctlVersion(DWORD &amp;dwMajor, DWORD &amp;dwMinor)
{
    dwMajor = dwMinor = 0;
    HINSTANCE hLib = ::LoadLibrary (_T (&quot;Comctl32.dll&quot;));
    if (hLib != NULL) {
        DLLGETVERSIONPROC pDllGetVersion =
            (DLLGETVERSIONPROC) ::GetProcAddress (hLib, _T (&quot;DllGetVersion&quot;));
        if (pDllGetVersion) { // IE 3.0 or higher
            DLLVERSIONINFO dvi;
            ::ZeroMemory (&amp;dvi, sizeof (dvi));
            dvi.cbSize = sizeof (dvi);
            HRESULT hr = (*pDllGetVersion) (&amp;dvi);
            if (SUCCEEDED (hr)) {
                dwMajor = dvi.dwMajorVersion;
                dwMinor = dvi.dwMinorVersion;
            }
        }
        else { // Pre-IE 3.0
            dwMajor = 4;
            dwMinor = 0;
        }
        ::FreeLibrary (hLib);
    }
}
</pre></td></tr></table></p>

<P>You also need a way to translate Internet Explorer version numbers into Comctl32.dll version numbers. Here's a table that will help:</p>

<p>
<table cellpadding=5 width="95%">
<tr>
<th valign="top">Internet Explorer Version</th>
<th valign="top">Comctl32.dll Version</th>
</tr><tr>
<td valign="top">3.0</td>
<td valign="top">4.70</td>
</tr><tr>
<td valign="top">4.0</td>
<td valign="top">4.71</td>
</tr><tr>
<td valign="top">4.01</td>
<td valign="top">4.72</td>
</tr>
</table>
</p>

<P>Now if I say that a certain feature requires Internet Explorer 3.0 or later and you want to determine at run time whether that feature is supported, you can do this:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
DWORD dwMajor, dwMinor;
GetComctlVersion (dwMajor, dwMinor);
if ((dwMajor == 4 &amp;&amp; dwMinor &gt;= 70) &#166;&#166; dwMajor &gt; 4) {
    // The feature is supported.
}
else {
    // The feature is not supported.
}
</pre></td></tr></table></p>

<P>Yes, it's ugly. But it's the only option currently available.</p>

<A NAME="494"><H2>Creating a Common Control</H2></A>

<P>There are two ways to create a common control without resorting to API functions. The first method is to instantiate the corresponding MFC control class and call the resulting object's <I>Create</I> function, as demonstrated here:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
#include &lt;afxcmn.h&gt;
    <img src="images/grayvellip.JPG" width=3 height=13 border="0">
CProgressCtrl wndProgress;
wndProgress.Create (WS_CHILD &#166; WS_VISIBLE &#166; WS_BORDER,
    CRect (x1, y1, x2, y2), this, IDC_PROGRESS);
</pre></td></tr></table></p>

<P>The header file Afxcmn.h contains the declarations for <I>CProgressCtrl</I> and other common control classes. The second method is to add a CONTROL statement to a dialog template. When the dialog box is created, the control is created, too. The following CONTROL statement creates a progress control in a dialog box:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
CONTROL &quot;&quot;, IDC_PROGRESS, PROGRESS_CLASS, WS_BORDER, 32, 32, 80, 16
</pre></td></tr></table></p>

<P>When you create a common control this way, you can specify either the literal WNDCLASS name or its alias, whichever you prefer. The Visual C++ dialog editor writes CONTROL statements for you when you use it to add common controls to a dialog box.</p>

<P>Most of the common controls support their own window styles, which you can combine with WS_CHILD, WS_VISIBLE, and other standard window styles. The table below shows the &quot;generic&quot; common control styles that, at least in theory, aren't specific to any particular control type. As an MFC programmer, you'll rarely have occasion to manipulate these styles directly because many of them apply only to toolbars and status bars, and if you use <I>CToolBar</I> and <I>CStatusBar</I> instead of the more primitive <I>CToolBarCtrl</I> and <I>CStatusBarCtrl</I> classes to implement toolbars and status bars, the appropriate CCS styles are built in. These are by no means all the styles you can use with common controls. I'll point out control-specific styles when we examine individual control types.</p>

<p><b>Common Control Styles</b></p>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><i>Style</i></th>
<th valign="top"><i>Description</i></th>
</tr><tr>
<td valign="top">CCS_TOP</td>
<td valign="top">Positions the control at the top of its parent's client area and matches the control's width to the width of its parent. Toolbars have this style by default.</td>
</tr><tr>
<td valign="top">CCS_BOTTOM</td>
<td valign="top">Positions the control at the bottom of its parent's client area and matches the control's width to the width of its parent. Status bars have this style by default.</td>
</tr><tr>
<td valign="top">CCS_LEFT*</td>
<td valign="top">Positions the control at the left end of its parent's client area.</td>
</tr><tr>
<td valign="top">CCS_RIGHT*</td>
<td valign="top">Positions the control at the right end of its parent's client area.</td>
</tr><tr>
<td valign="top">CCS_VERT*</td>
<td valign="top">Orients the control vertically rather than horizontally.</td>
</tr><tr>
<td valign="top">CCS_NOMOVEX*</td>
<td valign="top">Causes the control to resize and move itself vertically but not horizontally when its parent is resized.</td>
</tr><tr>
<td valign="top">CCS_NOMOVEY</td>
<td valign="top">Causes the control to resize and move itself horizontally but not vertically when its parent is resized. 
Header controls have this style by default.</td>
</tr><tr>
<td valign="top">CCS_NORESIZE</td>
<td valign="top">Prevents the control from resizing itself when the size of its parent changes. If this style is specified, the control assumes the width and height specified in the control rectangle.</td>
</tr><tr>
<td valign="top">CCS_NOPARENTALIGN</td>
<td valign="top">Prevents the control from sticking to the top or bottom of its parent's client area. A control with this style retains its position relative to the upper left corner of its parent's client area. If this style is combined with CCS_TOP or CCS_BOTTOM, the control assumes a default height but its width and position don't change when its parent is resized.</td>
</tr><tr>
<td valign="top">CCS_NODIVIDER</td>
<td valign="top">Eliminates the divider drawn at the top of a toolbar control.</td>
</tr><tr>
<td valign="top">CCS_ADJUSTABLE</td>
<td valign="top">Enables a toolbar control's built-in customization features. Double-clicking a toolbar of this type displays a Customize Toolbar dialog box.</td>
</tr>
</table></p>

<P>* Requires Internet Explorer 3.0 or later</p>

<P>Once you've created a common control, you manipulate it using member functions of the corresponding control class. For controls created from dialog templates, you can use any of the techniques described in <a href="ch08a.htm">Chapter 8</a> to manufacture type-specific references for accessing a control's function and data members. For example, the following statement links a <I>CProgressCtrl</I> member variable named <I>m_wndProgress</I> to the progress control whose ID is IDC_PROGRESS:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
DDX_Control (pDX, IDC_PROGRESS, m_wndProgress);
</pre></td></tr></table></p>

<P>This statement must appear in a dialog class's <I>DoDataExchange</I> function. Rather than add the statement manually, you can use ClassWizard if you'd like. See <a href="ch08a.htm">Chapter 8</a> for a description of how to use ClassWizard to bind a member variable in a dialog class to a control in the dialog box.</p>

<P>When you use the common controls in an SDK-style application, you must call either <I>::InitCommonControls</I> or the newer <I>::InitCommonControlsEx</I> to load Comctl32.dll and register the controls' WNDCLASSes before creating the first control. In an MFC application, MFC calls these functions for you. It first tries to call <I>::InitCommonControlsEx</I>. If the attempt fails because Internet Explorer 3.0 or later isn't installed (Internet Explorer adds <I>::InitCommonControlsEx</I> to the Win32 API), MFC falls back and calls <I>::InitCommonControls</I>, which is supported on any system running Windows 95 or higher or Windows NT 3.51 or higher.</p>

<P>MFC calls <I>::InitCommonControls(Ex)</I> whenever a dialog box is created or a common control class's <I>Create</I> function is called. If for some reason you decide to create a common control or a dialog box that contains a common control using the Windows API instead of MFC, or if you create a common control with <I>CreateEx</I> instead of <I>Create</I>, you should call <I>::InitCommonControls</I> or <I>::InitCommonControlsEx</I> yourself. A good place to do that is in the main window's <I>OnCreate</I> handler or <I>InitInstance</I>, although you can defer the call until just before the control or dialog box is created if you'd prefer. It's not harmful to call <I>::InitCommonControls(Ex)</I> multiple times during an application's lifetime.</p>

<A NAME="495"><H2>Processing Notifications: The WM_NOTIFY Message</H2></A>

<P>Unlike the classic controls, which send notifications to their parents using WM_COMMAND messages, most common controls package their notifications in WM_NOTIFY messages. A WM_NOTIFY message's <I>wParam</I> holds the child window ID of the control that sent the message, and <I>lParam</I> holds a pointer to either an NMHDR structure or a structure that's a superset of NMHDR. NMHDR is defined as follows:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
typedef struct tagNMHDR {
    HWND hwndFrom;
    UINT idFrom;
    UINT code;
} NMHDR;
</pre></td></tr></table></p>

<P><I>hwndFrom</I> holds the control's window handle, <I>idFrom</I> holds the control ID (the same value that's passed in <I>wParam</I>), and <I>code</I> specifies the notification code. The following notifications are transmitted by virtually all of the common controls.</p>

<P><table cellpadding=5 width="95%">
<tr>
<th valign="top">Notification</th>
<th valign="top">Sent When</th>
</tr><tr>
<td valign="top">NM_CLICK</td>
<td valign="top">The control is clicked with the left mouse button.</td>
</tr><tr>
<td valign="top">NM_DBLCLK</td>
<td valign="top">The control is double-clicked with the left mouse button.</td>
</tr><tr>
<td valign="top">NM_RCLICK</td>
<td valign="top">The control is clicked with the right mouse button.</td>
</tr><tr>
<td valign="top">NM_RDBLCLK</td>
<td valign="top">The control is double-clicked with the right 
mouse button.</td>
</tr><tr>
<td valign="top">NM_RETURN</td>
<td valign="top">The Enter key is pressed while the control has the input focus.</td>
</tr><tr>
<td valign="top">NM_KILLFOCUS</td>
<td valign="top">The control loses the input focus.</td>
</tr><tr>
<td valign="top">NM_SETFOCUS</td>
<td valign="top">The control gains the input focus.</td>
</tr><tr>
<td valign="top">NM_OUTOFMEMORY</td>
<td valign="top">An operation on the control has failed because of insufficient memory.</td>
</tr>
</table></p>

<P>Systems on which Internet Explorer 3.0 or later is installed support a richer assortment of NM notifications. For example, certain control types, including some of the original common controls that aren't unique to Internet Explorer but that are enhanced when Internet Explorer is installed, send NM_CUSTOMDRAW notifications so that their owners can customize their appearance. Others send NM_SETCURSOR notifications that their owners can use to apply custom cursors. The documentation for individual controls notes the &quot;special&quot; NM notifications, if any, that the controls send.</p>

<P>Most common controls define additional notification codes to signify control-specific events. For example, a tree view control notifies its parent when a subtree is expanded by sending it a WM_NOTIFY message with <I>code</I> equal to TVN_ITEMEXPANDED. <I>lParam</I> points to an NM_TREEVIEW structure, which contains the following data members:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
typedef struct _NM_TREEVIEW {
    NMHDR    hdr;
    UINT     action;
    TV_ITEM  itemOld;
    TV_ITEM  itemNew;
    POINT    ptDrag;
} NM_TREEVIEW;
</pre></td></tr></table></p>

<P>Notice that the structure's first member is an NMHDR structure, making NM_TREEVIEW a functional superset of NMHDR. The type of structure <I>lParam</I> points to depends on the type of control the notification came from. It sometimes even depends on the notification code. For instance, the <I>lParam</I> accompanying a TVN_GETDISPINFO notification from a tree view control points to a TV_DISPINFO structure, which 
is defined differently than NM_TREEVIEW is:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
typedef struct _TV_DISPINFO {
    NMHDR   hdr;
    TV_ITEM item;
} TV_DISPINFO;
</pre></td></tr></table></p>

<P>How do you know what kind of pointer to cast <I>lParam</I> to? You start by casting to an NMHDR pointer and examining the notification code. Then, if necessary, you can recast to a more specific pointer type, as demonstrated here:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
NMHDR* pnmh = (NMHDR*) lParam;
switch (pnmh-&gt;code) {

case TVN_ITEMEXPANDED:
    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*) pnmh;
    // Process the notification.
    break;

case TVN_GETDISPINFO:
    NM_DISPINFO* pnmdi = (NM_DISPINFO*) pnmh;
    // Process the notification.
    break;
}
</pre></td></tr></table></p>

<P>If the window that processes these notifications contains two or more tree view controls, it can examine the <I>hwndFrom</I> or <I>idFrom</I> field of the NMHDR structure to determine which control sent the notification.</p>

<p><I>switch</I> statements like the one above are usually unnecessary in MFC applications, because notifications encapsulated in WM_NOTIFY messages are mapped to class member functions with ON_NOTIFY and ON_NOTIFY_RANGE macros. In addition, WM_NOTIFY notifications can be reflected to derived control classes using ON_NOTIFY_REFLECT. (MFC also supports extended forms of these macros named ON_NOTIFY_EX, ON_NOTIFY_EX_RANGE, and ON_NOTIFY_REFLECT_EX.) The following message-map entries map TVN_ITEMEXPANDED and TVN_GETDISPINFO notifications from a tree view control whose ID is IDC_TREEVIEW to handling functions named <I>OnItemExpanded</I> and <I>OnGetDispInfo</I>:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
ON_NOTIFY (TVN_ITEMEXPANDED, IDC_TREEVIEW, OnItemExpanded)
ON_NOTIFY (TVN_GETDISPINFO, IDC_TREEVIEW, OnGetDispInfo)
</pre></td></tr></table></p>

<P>Casting to specific pointer types is performed inside the notification handlers:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
void CMyWindow::OnItemExpanded (NMHDR* pnmh, LRESULT* pResult)
{
    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*) pnmh;
    // Process the notification.
}

void CMyWindow::OnGetDispInfo (NMHDR* pnmh, LRESULT* pResult)
{
    NM_DISPINFO* pnmdi = (NM_DISPINFO*) pnmh;
    // Process the notification.
}
</pre></td></tr></table></p>

<P>The <I>pnmh</I> parameter passed to an ON_NOTIFY handler is identical to the WM_NOTIFY message's <I>lParam</I>. The <I>pResult</I> parameter points to a 32-bit LRESULT variable that receives the handler's return value. Many notifications attach no meaning to the return value, in which case the handler can safely ignore <I>pResult</I>. But sometimes what happens after the handler returns depends on the value of *<I>pResult</I>. For example, you can prevent branches of a tree view control from being expanded by processing TVN_ITEMEXPANDING notifications and setting *<I>pResult</I> to a nonzero value. A 0 return value, on the other hand, allows the expansion to occur:</p>

<P><table cellpadding=5 width="95%"><tr><td><pre>
// In the message map
ON_NOTIFY (TVN_ITEMEXPANDING, IDC_TREEVIEW, OnItemExpanding)
    <img src="images/grayvellip.JPG" width=3 height=13 border="0">
void OnItemExpanding (NMHDR* pnmh, LRESULT* pResult)
{
    NM_TREEVIEW* pnmtv = (NM_TREEVIEW*) pnmh;
    if (...) {
        *pResult = TRUE; // Under certain conditions, prevent
        return;          // the expansion from taking place.
    }
    *pResult = 0;        // Allow the expansion to proceed.
}
</pre></td></tr></table></p>

<P>A TVN_ITEMEXPANDING notification differs from a TVN_ITEMEXPANDED notification in that it is sent <I>before</I> an item in a tree view control is expanded, not after. As with the standard control types, you can ignore notifications you're not interested in and process only those that are meaningful to your application. Windows provides appropriate default responses for unhandled notifications.</p>

</BODY>
</HTML>




