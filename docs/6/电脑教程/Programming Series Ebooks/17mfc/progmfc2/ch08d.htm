<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Using a Dialog Box as a Main Window</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch08c.htm", "ch08e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="235"><H1>Using a Dialog Box as a Main Window</H1></A>

<P>If you write an application whose primary user interface 
is a dialog-like collection of controls, you should consider using a dialog box 
as a main window. Charles Petzold immortalizes this technique with the HEXCALC 
program featured in his book <I>Programming Windows</I>. 
Scores of developers have used similar techniques for creating small, 
utility-type application programs whose main windows are more easily defined in 
dialog templates than within the programmatic confines of 
<I>OnCreate</I> handlers.</P>

<P>Writing a dialog-based application is a snap thanks to 
AppWizard. One of the options in AppWizard's Step 1 dialog box is a radio button 
labeled Dialog Based. Checking this button prompts AppWizard to generate an 
application whose main window is a dialog box. AppWizard creates the dialog 
resource for you and derives a dialog class from <I>CDialog</I>. It also emits a special version of 
<I>InitInstance</I> that instantiates the dialog class and calls its 
<I>DoModal</I> function to display the dialog box on the 
screen when the application is started. All you have to do is add controls to 
the dialog in the resource editor and write message handlers to respond to 
control events. The AppWizard-generated code handles everything else.</P>

<P>The DlgCalc application shown in Figure 8-9 is an 
example of a dialog-based MFC application. DlgCalc is a calculator applet. It 
differs from the calculator applet supplied with Windows in one important 
respect: it uses postfix notation, which is also known as <I>reverse Polish notation</I>, or RPN. Postfix notation is the form of data 
entry used by Hewlett-Packard calculators. Once you've grown accustomed to 
postfix notation, you'll never want to use a conventional calculator again.</P>

<P>
<IMG SRC="images/F08mg09.GIF" width=168 height=241 BORDER=0> 
</P><P>
<B>Figure 8-9.</B> <I>The DlgCalc window.</I> 
</P>

<P>DlgCalc's source code appears in Figure 8-10. The main 
window is created in <I>CDlgCalcApp::InitInstance</I>, 
which constructs a 
<I>CDlgCalcDlg</I> object, copies the 
object's address to the application object's 
<I>m_pMainWnd</I> data member, and calls 
<I>DoModal</I> 
to display the window:</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CDlgCalcDlg dlg;
m_pMainWnd = &amp;dlg;
dlg.DoModal ();
</PRE></TD></TR>
</TABLE>
</P>


<P><I>CDlgCalcDlg</I> is the dialog 
class that AppWizard derived from 
<I>CDialog</I>. The 
window created from it is a dialog box in every sense of the term, but it 
doubles as a main window since it has no parent and its address is tucked away 
in 
<I>m_pMainWnd</I>. I deleted some of the code that 
AppWizard placed in 
<I>InitInstance</I>&mdash;notably, the 
code that tests <I>DoModal</I>'s return value&mdash;because 
it served no purpose in this application. I also deleted the WM_QUERYDRAGICON 
handler that AppWizard included in the dialog class and the AppWizard-generated 
<I>OnPaint</I> code that paints the application icon when 
the window is minimized because neither is needed unless your application will 
be run on old versions of Windows&mdash;specifically, versions that use the 
Windows 3.<I>x</I>_style shell. 
</P>

<P>
<B>Figure 8-10.</B> <I>The DlgCalc application.</I> 
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="236"><H3>DlgCalc.h</H3></A>
<PRE>
// DlgCalc.h : main header file for the DLGCALC application
//

#if !defined(AFX_DLGCALC_H__F42970C4_9047_11D2_8E53_006008A82731__INCLUDED_)
#define 
AFX_DLGCALC_H__F42970C4_9047_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
#ifndef __AFXWIN_H__
    #error include `stdafx.h' before including this file for PCH
#endif

#include &quot;resource.h&quot;        // main symbols

///////////////////////////////////////////////////////////////////////////
// CDlgCalcApp:
// See DlgCalc.cpp for the implementation of this class
//

class CDlgCalcApp : public CWinApp
{
public:
    CDlgCalcApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDlgCalcApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation

    //{{AFX_MSG(CDlgCalcApp)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(AFX_DLGCALC_H__F42970C4_9047_11D2_8E53_006008A82731__INCLUDED_)
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="237"><H3>DlgCalc.cpp</H3></A>
<PRE>
// DlgCalc.cpp : Defines the class behaviors for the application.
//

#include &quot;stdafx.h&quot;
#include &quot;DlgCalc.h&quot;
#include &quot;DlgCalcDlg.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CDlgCalcApp

BEGIN_MESSAGE_MAP(CDlgCalcApp, CWinApp)
    //{{AFX_MSG_MAP(CDlgCalcApp)
    //}}AFX_MSG
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CDlgCalcApp construction

CDlgCalcApp::CDlgCalcApp()
{
}

///////////////////////////////////////////////////////////////////////////
// The one and only CDlgCalcApp object

CDlgCalcApp theApp;

///////////////////////////////////////////////////////////////////////////
// CDlgCalcApp initialization

BOOL CDlgCalcApp::InitInstance()
{
    CDlgCalcDlg dlg;
    m_pMainWnd = &amp;dlg;
    dlg.DoModal ();
    return FALSE;
}
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="238"><H3>DlgCalcDlg.h</H3></A>

<PRE>
// DlgCalcDlg.h : header file
//

#if !defined(AFX_DLGCALCDLG_H__F42970C6_9047_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_DLGCALCDLG_H__F42970C6_9047_11D2_8E53_006008A82731__INCLUDED_
#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

///////////////////////////////////////////////////////////////////////////
// CDlgCalcDlg dialog

class CDlgCalcDlg : public CDialog
{
// Construction
public:
    void UpdateDisplay (LPCTSTR pszDisplay);
    CDlgCalcDlg(CWnd* pParent = NULL);    // standard constructor

// Dialog Data
    //{{AFX_DATA(CDlgCalcDlg)
    enum { IDD = IDD_DLGCALC_DIALOG };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CDlgCalcDlg)
    public:
    virtual BOOL PreTranslateMessage(MSG* pMsg);
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

// Implementation
protected:
    void DropStack();
    void LiftStack();
    void DisplayXRegister();

    double m_dblStack[4];
    double m_dblMemory;
    CString m_strDisplay;
    CString m_strFormat;
    CRect m_rect;
    int m_cxChar;
    int m_cyChar;

    BOOL m_bFixPending;
    BOOL m_bErrorFlag;
    BOOL m_bDecimalInString;
    BOOL m_bStackLiftEnabled;
    BOOL m_bNewX;

    HICON m_hIcon;
    HACCEL m_hAccel;

    // Generated message map functions
    //{{AFX_MSG(CDlgCalcDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnPaint();
    afx_msg void OnAdd();
    afx_msg void OnSubtract();
    afx_msg void OnMultiply();
    afx_msg void OnDivide();
    afx_msg void OnEnter();
    afx_msg void OnChangeSign();
    afx_msg void OnExponent();
    afx_msg void OnStore();
    afx_msg void OnRecall();
    afx_msg void OnFix();
    afx_msg void OnClear();
    afx_msg void OnDecimal();
    afx_msg void OnDelete();
    //}}AFX_MSG
    afx_msg void OnDigit(UINT nID);
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(
//    AFX_DLGCALCDLG_H__F42970C6_9047_11D2_8E53_006008A82731__INCLUDED_)
</PRE></TD></TR>
</TABLE>
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="239"><H3>DlgCalcDlg.cpp</H3></A>

<PRE>
// DlgCalcDlg.cpp : implementation file
//

#include &quot;stdafx.h&quot;
#include &quot;DlgCalc.h&quot;
#include &quot;DlgCalcDlg.h&quot;
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CDlgCalcDlg dialog

CDlgCalcDlg::CDlgCalcDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CDlgCalcDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CDlgCalcDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
    m_hIcon = AfxGetApp()-&gt;LoadIcon(IDR_MAINFRAME);
    m_hAccel = ::LoadAccelerators (AfxGetInstanceHandle (),
        MAKEINTRESOURCE (IDR_ACCEL));

    m_bFixPending = FALSE;
    m_bErrorFlag = FALSE;
    m_bDecimalInString = FALSE;
    m_bStackLiftEnabled = FALSE;
    m_bNewX = TRUE;

    for (int i=0; i&lt;4; i++)
        m_dblStack[i] = 0.0;
    m_dblMemory = 0.0;
    m_strFormat = _T (&quot;%0.2f&quot;);
}

void CDlgCalcDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDlgCalcDlg)
        // NOTE: the ClassWizard will add DDX and DDV calls here
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CDlgCalcDlg, CDialog)
    //{{AFX_MSG_MAP(CDlgCalcDlg)
    ON_WM_PAINT()
    ON_BN_CLICKED(IDC_ADD, OnAdd)
    ON_BN_CLICKED(IDC_SUBTRACT, OnSubtract)
    ON_BN_CLICKED(IDC_MULTIPLY, OnMultiply)
    ON_BN_CLICKED(IDC_DIVIDE, OnDivide)
    ON_BN_CLICKED(IDC_ENTER, OnEnter)
    ON_BN_CLICKED(IDC_CHGSIGN, OnChangeSign)
    ON_BN_CLICKED(IDC_EXP, OnExponent)
    ON_BN_CLICKED(IDC_STO, OnStore)
    ON_BN_CLICKED(IDC_RCL, OnRecall)
    ON_BN_CLICKED(IDC_FIX, OnFix)
    ON_BN_CLICKED(IDC_CLX, OnClear)
    ON_BN_CLICKED(IDC_DECIMAL, OnDecimal)
    ON_BN_CLICKED(IDC_DEL, OnDelete)
    //}}AFX_MSG_MAP
    ON_CONTROL_RANGE (BN_CLICKED, IDC_0, IDC_9, OnDigit)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CDlgCalcDlg message handlers

BOOL CDlgCalcDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    //
    // Set the application's icon.
    //
    SetIcon(m_hIcon, TRUE);
    SetIcon(m_hIcon, FALSE);
    
    //
    // Remove the Size and Maximize commands from the system menu.
    //
    CMenu* pMenu = GetSystemMenu (FALSE);
    pMenu-&gt;DeleteMenu (SC_SIZE, MF_BYCOMMAND);
    pMenu-&gt;DeleteMenu (SC_MAXIMIZE, MF_BYCOMMAND);

    //
    // Initialize m_rect with the coordinates of the control representing
    // the calculator's output window. Then destroy the control.
    //
    CWnd* pWnd = GetDlgItem (IDC_DISPLAYRECT);
    pWnd-&gt;GetWindowRect (&amp;m_rect);
    pWnd-&gt;DestroyWindow ();
    ScreenToClient (&amp;m_rect);

    //
    // Initialize m_cxChar and m_cyChar with the average character width
    // and height.
    //
    TEXTMETRIC tm;
    CClientDC dc (this);
    dc.GetTextMetrics (&amp;tm);
    m_cxChar = tm.tmAveCharWidth;
    m_cyChar = tm.tmHeight - tm.tmDescent;

    //
    // Initialize the calculator's output window and return.
    //
    DisplayXRegister ();
    return TRUE;
}

void CDlgCalcDlg::OnPaint() 
{
    CPaintDC dc (this);
    dc.DrawEdge (m_rect, EDGE_SUNKEN, BF_RECT);
    UpdateDisplay (m_strDisplay);
}

BOOL CDlgCalcDlg::PreTranslateMessage(MSG* pMsg) 
{
    if (m_hAccel != NULL)
        if (::TranslateAccelerator (m_hWnd, m_hAccel, pMsg))
            return TRUE;
    
    return CDialog::PreTranslateMessage (pMsg);
}

BOOL CDlgCalcDlg::OnCommand(WPARAM wParam, LPARAM lParam) 
{
    int nID = (int) LOWORD (wParam);

    if (m_bErrorFlag &amp;&amp; (nID != IDC_CLX)) {
        ::MessageBeep (MB_ICONASTERISK);
        return TRUE;
    }

    if (m_bFixPending &amp;&amp;
        ((nID &lt; IDC_0) &brvbar;&brvbar; (nID &gt; IDC_9)) &amp;&amp;
        (nID != IDC_CLX)) {
        ::MessageBeep (MB_ICONASTERISK);
        return TRUE;
    }
    return CDialog::OnCommand (wParam, lParam);
}

void CDlgCalcDlg::OnDigit(UINT nID) 
{
    TCHAR cDigit = (char) nID;

    if (m_bFixPending) {
        m_strFormat.SetAt (3, cDigit - IDC_0 + 0x30);
        DisplayXRegister ();
        m_bFixPending = FALSE;
        m_bStackLiftEnabled = TRUE;
        m_bNewX = TRUE;
        return;
    }

    if (m_bNewX) {
        m_bNewX = FALSE;
        if (m_bStackLiftEnabled) {
            m_bStackLiftEnabled = FALSE;
            LiftStack ();
        }
        m_bDecimalInString = FALSE;
        m_strDisplay.Empty ();
    }

    int nLength = m_strDisplay.GetLength ();
    if ((nLength == MAXCHARS) &brvbar;&brvbar;
        ((nLength == (MAXCHARS - 10)) &amp;&amp; !m_bDecimalInString))
        ::MessageBeep (MB_ICONASTERISK);
    else {
        m_strDisplay += (cDigit - IDC_0 + 0x30);
        UpdateDisplay (m_strDisplay);
        m_dblStack[0] = _tcstod (m_strDisplay.GetBuffer (0), NULL);
    }
}

void CDlgCalcDlg::OnAdd() 
{
    m_dblStack[0] += m_dblStack[1];
    DisplayXRegister ();
    DropStack ();
    m_bStackLiftEnabled = TRUE;
    m_bNewX = TRUE;
}

void CDlgCalcDlg::OnSubtract() 
{
    m_dblStack[0] = m_dblStack[1] - m_dblStack[0];
    DisplayXRegister ();
    DropStack ();
    m_bStackLiftEnabled = TRUE;
    m_bNewX = TRUE;
}

void CDlgCalcDlg::OnMultiply() 
{
    m_dblStack[0] *= m_dblStack[1];
    DisplayXRegister ();
    DropStack ();
    m_bStackLiftEnabled = TRUE;
    m_bNewX = TRUE;
}

void CDlgCalcDlg::OnDivide() 
{
    if (m_dblStack[0] == 0.0) {
        m_bErrorFlag = TRUE;
        ::MessageBeep (MB_ICONASTERISK);
        UpdateDisplay (CString (_T (&quot;Divide by zero&quot;)));
    }
    else {
        m_dblStack[0] = m_dblStack[1] / m_dblStack[0];
        DisplayXRegister ();
        DropStack ();
        m_bStackLiftEnabled = TRUE;
        m_bNewX = TRUE;
    }
}

void CDlgCalcDlg::OnEnter() 
{
    LiftStack ();
    DisplayXRegister ();
    m_bStackLiftEnabled = FALSE;
    m_bNewX = TRUE;
}

void CDlgCalcDlg::OnChangeSign() 
{
    if (m_dblStack[0] != 0.0) {
        m_dblStack[0] = -m_dblStack[0];
        if (m_strDisplay[0] == _T (`-')) {
            int nLength = m_strDisplay.GetLength ();
            m_strDisplay = m_strDisplay.Right (nLength - 1);
        }
        else
            m_strDisplay = _T (&quot;-&quot;) + m_strDisplay;
        UpdateDisplay (m_strDisplay);
    }
}

void CDlgCalcDlg::OnExponent() 
{
    if (((m_dblStack[1] == 0.0) &amp;&amp; (m_dblStack[0] &lt; 0.0)) &brvbar;&brvbar;
        ((m_dblStack[1] == 0.0) &amp;&amp; (m_dblStack[0] == 0.0)) &brvbar;&brvbar;
        ((m_dblStack[1] &lt; 0.0) &amp;&amp;
        (floor (m_dblStack[0]) != m_dblStack[0]))) {
        m_bErrorFlag = TRUE;
        ::MessageBeep (MB_ICONASTERISK);
        UpdateDisplay (CString (_T (&quot;Invalid operation&quot;)));
    }
    else {
        m_dblStack[0] = pow (m_dblStack[1], m_dblStack[0]);
        DisplayXRegister ();
        DropStack ();
        m_bStackLiftEnabled = TRUE;
        m_bNewX = TRUE;
    }
}

void CDlgCalcDlg::OnStore() 
{
    DisplayXRegister ();
    m_dblMemory = m_dblStack[0];
    m_bStackLiftEnabled = TRUE;
    m_bNewX = TRUE;
}

void CDlgCalcDlg::OnRecall() 
{
    LiftStack ();
    m_dblStack[0] = m_dblMemory;
    DisplayXRegister ();
    m_bStackLiftEnabled = TRUE;
    m_bNewX = TRUE;
}

void CDlgCalcDlg::OnFix() 
{
    m_bFixPending = TRUE;
}

void CDlgCalcDlg::OnClear() 
{
    if (m_bFixPending) {
        m_bFixPending = FALSE;
        return;
    }

    m_bErrorFlag = FALSE;
    m_dblStack[0] = 0.0;
    DisplayXRegister ();
    m_bStackLiftEnabled = FALSE;
    m_bNewX = TRUE;
}

void CDlgCalcDlg::OnDecimal() 
{
    if (m_bNewX) {
        m_bNewX = FALSE;
        if (m_bStackLiftEnabled) {
            m_bStackLiftEnabled = FALSE;
            LiftStack ();
        }
        m_bDecimalInString = FALSE;
        m_strDisplay.Empty ();
    }

    int nLength = m_strDisplay.GetLength ();
    if ((nLength == MAXCHARS) &brvbar;&brvbar; (m_bDecimalInString))
        ::MessageBeep (MB_ICONASTERISK);
    else {
        m_bDecimalInString = TRUE;
        m_strDisplay += (char) 0x2E;
        UpdateDisplay (m_strDisplay);
        m_dblStack[0] = strtod (m_strDisplay.GetBuffer (0), NULL);
    }
}

void CDlgCalcDlg::OnDelete() 
{
    int nLength = m_strDisplay.GetLength ();

    if (!m_bNewX &amp;&amp; (nLength != 0)) {
        if (m_strDisplay[nLength - 1] == _T (`.'))
            m_bDecimalInString = FALSE;
        m_strDisplay = m_strDisplay.Left (nLength - 1);
        UpdateDisplay (m_strDisplay);
        m_dblStack[0] = strtod (m_strDisplay.GetBuffer (0), NULL);
    }
}

void CDlgCalcDlg::LiftStack()
{
    for (int i=3; i&gt;0; i--)
        m_dblStack[i] = m_dblStack[i-1];
}

void CDlgCalcDlg::DropStack()
{
    for (int i=1; i&lt;3; i++)
        m_dblStack[i] = m_dblStack[i+1];
}

void CDlgCalcDlg::DisplayXRegister()
{
    double dblVal = m_dblStack[0];

    if ((dblVal &gt;= 1000000000000.0) &brvbar;&brvbar; (dblVal &lt;= -1000000000000.0)) {
        UpdateDisplay (CString (_T (&quot;Overflow error&quot;)));
        m_bErrorFlag = TRUE;
        MessageBeep (MB_ICONASTERISK);
    }
    else {
        m_strDisplay.Format (m_strFormat, dblVal);
        UpdateDisplay (m_strDisplay);
    }
}

void CDlgCalcDlg::UpdateDisplay(LPCTSTR pszDisplay)
{
    CClientDC dc (this);
    CFont* pOldFont = dc.SelectObject (GetFont ());
    CSize size = dc.GetTextExtent (pszDisplay);

    CRect rect = m_rect;
    rect.InflateRect (-2, -2);
    int x = rect.right - size.cx - m_cxChar;
    int y = rect.top + ((rect.Height () - m_cyChar) / 2);

    dc.ExtTextOut (x, y, ETO_OPAQUE, rect, pszDisplay, NULL);
    dc.SelectObject (pOldFont);
}
</PRE></TD></TR>
</TABLE>
</P>

<P>By default, the main window in a dialog-based 
application created by AppWizard doesn't have a minimize button. I added one to 
the title bar by opening the dialog box in the dialog editor and checking 
Minimize Button in the dialog's property sheet.</P>

<P>The bulk of the code in DlgCalcDlg.cpp is there to 
process clicks of the calculator buttons. Thanks to this code, DlgCalc works 
very much like a genuine RPN calculator. To add 2 and 2, for example, you would 
type</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
2 &lt;Enter&gt; 2 +
</PRE></TD></TR></TABLE>
</P>

<P>To multiply 3.46 by 9, add 13, divide by 10, and raise 
the result to a power of 2.5, you would type 
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
3.46 &lt;Enter&gt; 9 * 13 + 10 / 2.5 &lt;Exp&gt;
</PRE></TD></TR></TABLE>
</P>

<P>The Sto key copies the number in the calculator display 
to memory (stores it), and Rcl recalls it. Clx clears the calculator display 
(the &quot;x&quot; in &quot;Clx&quot; is a reference to the calculator's X 
register, whose contents are always shown in the calculator display), and the 
&plusmn; button changes the sign of the number that's currently displayed. Fix 
sets the number of digits displayed to the right of the decimal point. To change 
from two decimal places to four, click Fix and then the 4 button. The Del button 
deletes the rightmost character in the numeric display. For each button on the 
face of the calculator, there is an equivalent key on the keyboard, as shown in 
the following table. The P key assigned to the &plusmn; button is a crude 
mnemonic for &quot;plus or minus.&quot; Most users find it slow going to click 
calculator buttons with the mouse, so the keyboard shortcuts are an important 
part of this application's user interface.</P>

<P><B>Keyboard Equivalents for 
DlgCalc's Calculator Buttons</B></P>

<P>
<TABLE cellpadding=5 width="95%">
<TR>
<TH><I>Button(s)</I>    </TH>
<TH><I> Key(s)</I>     </TH>
</TR>

<TR>
<TD VALIGN="top">&plusmn;</TD>
<TD VALIGN="top">P</TD>
</TR>

<TR>
<TD VALIGN="top">Exp</TD>
<TD VALIGN="top">E</TD>
</TR>

<TR>
<TD VALIGN="top">Sto</TD>
<TD VALIGN="top">S</TD>
</TR>

<TR>
<TD VALIGN="top">Rcl</TD>
<TD VALIGN="top">R</TD>
</TR>

<TR>
<TD VALIGN="top">Enter</TD>
<TD VALIGN="top">Enter</TD>
</TR>

<TR>
<TD VALIGN="top">Fix     </TD>
<TD VALIGN="top">F     </TD>
</TR>

<TR>
<TD VALIGN="top">Clx</TD>     
<TD VALIGN="top">C </TD>    
</TR>

<TR>
<TD VALIGN="top">0-9</TD>
<TD VALIGN="top">0-9</TD>
</TR>

<TR>
<TD VALIGN="top">-</TD>
<TD VALIGN="top">-</TD>
</TR>

<TR>
<TD VALIGN="top">+</TD>
<TD VALIGN="top">+</TD>
</TR>

<TR>
<TD VALIGN="top">x     </TD>
<TD VALIGN="top">*</TD>
</TR>

<TR>
<TD VALIGN="top">&divide;</TD>
<TD VALIGN="top">/</TD>
</TR>

<TR>
<TD VALIGN="top">.     </TD>
<TD VALIGN="top">.</TD>
</TR>

<TR>
<TD VALIGN="top">Del</TD>   
<TD VALIGN="top">Del, 
Backspace</TD>
</TR>
</TABLE>
</P>

<A NAME="240"><H3>Processing Keyboard Messages</H3></A>

<P>Because it's unusual for a dialog box to implement its 
own keyboard interface on top of the one that Windows provides, DlgCalc's 
keyboard processing logic deserves a closer look.</P>

<P>A fundamental problem with processing keystrokes in a 
dialog box is that WM_CHAR messages are processed by 
<I>::IsDialogMessage</I>, which is called from every MFC dialog's message 
loop. You can add an 
<I>OnChar</I> handler to a dialog 
class, but it will never get called if 
<I>::IsDialogMessage</I> sees keyboard messages before 
<I>::TranslateMessage</I> does. Another problem is that once a control gets 
the input focus, subsequent keyboard messages go to the control instead of to 
the dialog window.</P>

<P>To circumvent these problems, I decided to use 
accelerators to process keyboard input. I first created an accelerator resource 
by selecting the Resource command from Visual C++'s Insert menu and 
double-clicking &quot;Accelerator.&quot; Then I added accelerators for all the 
keys on the face of the calculator&mdash;&quot;1&quot; for the IDC_1 button, 
&quot;2&quot; for the IDC_2 button, and so on. Next I added an HACCEL member 
variable to <I>CDlgCalcDlg</I> and inserted the following 
statement into 
<I>CDlgCalcDlg</I>'s constructor to load the 
accelerators: 
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
m_hAccel = ::LoadAccelerators (AfxGetInstanceHandle (),
    MAKEINTRESOURCE (IDR_ACCELL));
</PRE></TD></TR>
</TABLE>
</P>


<P>Finally, I overrode <I>PreTranslateMessage</I> and replaced it with a version that calls <I>::TranslateAccelerator</I> on each message that the dialog 
receives:</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
BOOL CCalcDialog::PreTranslateMessage (MSG* pMsg)
{
    if (m_hAccel != NULL)
        if (::TranslateAccelerator (m_hWnd, m_hAccel, pMsg))
            return TRUE;
    
    return CDialog::PreTranslateMessage (pMsg);
}
</PRE></TD></TR>
</TABLE>
</P>


<P>This way, <I>::TranslateAccelerator</I> sees keyboard messages even before 
<I>::IsDialogMessage</I> does, and messages corresponding to 
accelerator keys are magically transformed into WM_COMMAND messages. Because the 
accelerator keys are assigned the same command IDs as the calculator's push 
buttons, the same ON_BN_CLICKED handlers process button clicks 
<I>and</I> keypresses. 
</P>

<A NAME="241"><H3>Preprocessing WM_COMMAND Messages</H3></A>

<P>Before a WM_COMMAND message emanating from a control is 
routed through a class's message map, MFC calls the class's virtual 
<I>OnCommand</I> function. The default implementation of 
<I>OnCommand</I> is the starting point for a command routing 
system put in place to ensure that all relevant objects associated with a 
running application program, including the document, view, and application 
objects used in document/view applications, see the message and get a crack at 
processing it. If desired, an application can preprocess WM_COMMAND messages by 
overriding 
<I>OnCommand</I>. When preprocessing is 
complete, the application can call the base class's 
<I>OnCommand</I> function to pass the message on for normal processing, or it 
can &quot;eat&quot; the message by returning without calling the base class. An 
<I>OnCommand</I> handler that doesn't call the base class 
should return TRUE to inform Windows that message processing is complete.</P>

<P>DlgCalc does something else unusual for an MFC 
application: it overrides 
<I>OnCommand</I> and filters out 
selected WM_COMMAND messages if either one of a pair of <I>CDlgCalcDlg</I> member variables&mdash;<I>m_bErrorFlag</I> or 
<I>m_bFixPending</I>&mdash;is 
nonzero. 
<I>CDlgCalcDialog::OnCommand</I> begins by 
obtaining the ID of the control that generated the message from the low word of 
the 
<I>wParam</I> value passed to it by MFC:</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
int nID = (int) LOWORD (wParam);
</PRE></TD></TR>
</TABLE>
</P>


<P>It then examines <I>m_bErrorFlag</I>, which, if nonzero, indicates that a divide-by-zero or 
other error has occurred. The user must click Clx to clear the display after an 
error occurs, so <I>OnCommand</I> rejects all buttons but 
Clx if 
<I>m_bErrorFlag</I> is nonzero:</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
if (m_bErrorFlag &amp;&amp; (nID != IDC_CLX)) {
    ::MessageBeep (MB_ICONASTERISK);
    return TRUE;
}
</PRE></TD></TR>
</TABLE>
</P>


<P>Similarly, if the <I>m_bFixPending</I> flag is set, indicating that the calculator is awaiting 
a press of a numeric key following a press of the Fix key, all buttons other 
than 0 through 9 and the Clx key, which cancels a pending fix operation, are 
rejected:</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
if (m_bFixPending &amp;&amp;
    ((nID &lt; IDC_0) &brvbar;&brvbar; (nID &gt; IDC_9)) &amp;&amp;
    (nID != IDC_CLX)) {
    ::MessageBeep (MB_ICONASTERISK);
    return TRUE;
}
</PRE></TD></TR>
</TABLE>
</P>


<P>In both cases, the <I>::MessageBeep</I> API function is called to produce an audible tone 
signifying an invalid button press. The base class's 
<I>OnCommand</I> handler is called only if 
<I>m_bErrorFlag</I> and <I>m_bFixPending</I> are both 0. 
Putting the code that tests these flags in the <I>OnCommand</I> handler prevents the code from having to be duplicated in 
every ON_BN_CLICKED handler.</P>

<P>Another item of interest related to WM_COMMAND messages 
is the fact that DlgCalc processes clicks of the 0 through 9 buttons with a 
common handler. An ON_CONTROL_RANGE statement hand-coded into the message map 
directs BN_CLICKED notifications from each of the 10 buttons to 
<I>CDlgCalcDlg::OnDigit</I>:</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
ON_CONTROL_RANGE (BN_CLICKED, IDC_0, IDC_9, OnDigit)
</PRE></TD></TR>
</TABLE>
</P>


<P>An ON_CONTROL_RANGE handler receives a UINT parameter 
identifying the control that sent the notification, and it returns void. In 
DlgCalc's case, the alternative to ON_CONTROL_RANGE would have been 10 separate 
ON_BN_CLICKED macros and a handler that called 
<I>CWnd::GetCurrentMessage</I> to retrieve the control ID from the message's <I>wParam</I>. One message-map entry is obviously more 
memory-efficient than ten, and the job of extracting control IDs from message 
parameters is best left to MFC when possible to ensure compatibility with future 
versions of Windows. 
</P>

</BODY>
</HTML>




