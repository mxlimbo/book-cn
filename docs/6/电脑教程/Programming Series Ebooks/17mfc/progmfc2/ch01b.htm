<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>The Windows Programming Model</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch01a.htm", "ch01c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="2"><H1>The Windows Programming Model</H1></A>


<P>Programs written for traditional operating environments use a procedural 
programming model in which programs execute from top to bottom in an orderly 
fashion. The path taken from start to finish may vary with each invocation of the 
program depending on the input it receives or the conditions under which it is run, but 
the path remains fairly predictable. In a C program, execution begins with the first 
line in the function named <I>main</I> and ends when 
<I>main</I> returns. In between, <I>main</I> might call other functions and these functions might call even more functions, but 
ultimately it is the program&#8212;not the operating system&#8212;that determines what gets called and when.
</p>

<P>Windows programs operate differently. They use the event-driven 
programming model illustrated in Figure 1-1, in which applications respond to 
<I>events</I> by processing messages sent by the operating system. An event could be a keystroke, a 
mouse click, or a command for a window to repaint itself, among other things. The 
entry point for a Windows program is a function named 
<I>WinMain</I>, but most of the action takes place in a function known as the 
<I>window procedure</I>. The window procedure processes messages sent to the window. 
<I>WinMain</I> creates that window and then enters a 
<I>message loop,</I> alternately retrieving messages and dispatching them to the 
window procedure. Messages wait in a message queue until they are retrieved. A 
typical Windows application performs the bulk of its processing in response to the 
messages it receives, and in between messages, it does little except wait for the next 
message to arrive.
</p>

<P>The message loop ends when a WM_QUIT message is retrieved from the 
message queue, signaling that it's time for the application to end. This message usually 
appears because the user selected Exit from the File menu, clicked the close button (the 
small button with an X in the window's upper right corner), or selected Close from 
the window's system menu. When the message loop ends, 
<I>WinMain</I> returns and the application terminates.
</p>

<P>
<A HREF="javascript:fullSize('F01mg01x.htm')"> <img src="images/F01mg01.JPG" width=404 height=622 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 1-1.</B> <I>The Windows programming model.</I><!-- /CAPTION -->
</p>

<P>The window procedure typically calls other functions to help process the 
messages it receives. It can call functions local to the application, or it can call API 
functions provided by Windows. API functions are contained in special modules 
known as <I>dynamic-link libraries,</I> or DLLs. The Win32 API includes hundreds of 
functions that an application can call to perform various tasks such as creating a 
window, drawing a line, and performing file input and output. In C, the window procedure 
is typically implemented as a monolithic function containing a large 
<I>switch</I> statement with cases for individual messages. The code provided to process a particular 
message is known as a <I>message handler</I>. Messages that an application doesn't 
process are passed on to an API function named 
<I>DefWindowProc</I>, which provides default responses to unprocessed messages.
</p>

<A NAME="3"><H2>Messages, Messages, and More Messages</H2></A>

<P>Where do messages come from, and what kinds of information do they 
convey? Windows defines hundreds of different message types. 
Most messages have names that begin with the letters &quot;WM&quot; and an underscore, as in WM_CREATE and 
WM_PAINT. These messages can be classified in various ways, but for the moment 
classification is not nearly as important as realizing the critical role messages play in the 
operation of an application. The following table shows 10 of the most common 
messages. A window receives a WM_PAINT message, for example, when its interior 
needs repainting. One way to characterize a Windows program is to think of it as a 
collection of message handlers. To a large extent, it is a program's unique way of 
responding to messages that gives it its personality. 
</p>


<p><B>Common Windows Messages</B></p>
<p><table cellpadding="5" width="95%">

<TR><TH valign="top"><I>Message</i></TH>
<TH valign="top"><i>Sent When</I></TH></TR>

<TR><TD valign="top">WM_CHAR</TD>
<TD valign="top">A character is input from the keyboard.</TD></TR>

<TR><TD valign="top">WM_COMMAND</TD>
<TD valign="top">The user selects an item from a menu, or a control sends a notification to its parent.</TD></TR>

<TR><TD valign="top">WM_CREATE</TD>
<TD valign="top">A window is created.</TD></TR>

<TR><TD valign="top">WM_DESTROY</TD>
<TD valign="top">A window is destroyed.</TD></TR>

<TR><TD valign="top">WM_LBUTTONDOWN</TD>
<TD valign="top">The left mouse button is pressed.</TD></TR>

<TR><TD valign="top">WM_LBUTTONUP</TD>
<TD valign="top">The left mouse button is released.</TD></TR>

<TR><TD valign="top">WM_MOUSEMOVE </TD>
<TD valign="top">The mouse pointer is moved.</TD></TR>

<TR><TD valign="top">WM_PAINT</TD>
<TD valign="top">A window needs repainting.</TD></TR>

<TR><TD valign="top">WM_QUIT</TD>
<TD valign="top">The application is about to terminate.</TD></TR>

<TR><TD valign="top">WM_SIZE</TD>
<TD valign="top">A window is resized.</TD></TR>

</table></p>

<P>A message manifests itself in the form of a call to a window's window 
procedure. Bundled with the call are four input parameters: the handle of the window to 
which the message is directed, a message ID, and two 32-bit parameters known as 
<I>wParam</I> and <I>lParam</I>. The window handle is a 32-bit value that uniquely identifies a 
window. Internally, the value references a data structure in which Windows stores 
relevant information about the window such as its size, style, and location on the 
screen. The message ID is a numeric value that identifies the message type: 
WM_CREATE, WM_PAINT, and so on. <I>wParam</I> and 
<I>lParam</I> contain information specific to the message type. When a WM_LBUTTONDOWN message arrives, for example, 
<I>wParam </I>holds a series of bit flags identifying the state of the Ctrl and Shift keys and of 
the mouse buttons. <I>lParam</I> holds two 16-bit values identifying the location of the 
mouse pointer when the click occurred. Together, these parameters provide the 
window procedure with all the information it needs to process the 
WM_LBUTTONDOWN message.
</p>

<A NAME="4"><H2>Windows Programming, SDK-Style</H2></A>

<P>If you haven't programmed Windows in C before, it's instructive to see what the 
source code for a simple program looks like. The program listed in Figure 1-2 creates a 
window and responds to WM_PAINT messages by drawing an ellipse in the 
window's upper left corner. This code is similar to the source code you'll find in books such 
as Charles Petzold's <I>Programming Windows</I> (1998, Microsoft Press) and other books 
that teach Windows programming in C.
</p>

<p><B>Figure 1-2.</B> <I>C source code for a simple Windows program.</I></p>

<p>
<table cellpadding=5 width="95%">
<tr>
<td>
<pre>
#include &lt;windows.h&gt;

LONG WINAPI WndProc (HWND, UINT, WPARAM, LPARAM);

int WINAPI WinMain (HINSTANCE hInstance, HINSTANCE hPrevInstance,
    LPSTR lpszCmdLine, int nCmdShow)
{
    WNDCLASS wc;
    HWND hwnd;
    MSG msg;

    wc.style = 0;                                   // Class style
    wc.lpfnWndProc = (WNDPROC) WndProc;             // Window procedure address
    wc.cbClsExtra = 0;                              // Class extra bytes
    wc.cbWndExtra = 0;                              // Window extra bytes
    wc.hInstance = hInstance;                       // Instance handle
    wc.hIcon = LoadIcon (NULL, IDI_WINLOGO);        // Icon handle
    wc.hCursor = LoadCursor (NULL, IDC_ARROW);      // Cursor handle
    wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1); // Background color
    wc.lpszMenuName = NULL;                         // Menu name
    wc.lpszClassName = &quot;MyWndClass&quot;;                // WNDCLASS name

    RegisterClass (&amp;wc);
	

    hwnd = CreateWindow (
        &quot;MyWndClass&quot;,               // WNDCLASS name
        &quot;SDK Application&quot;,          // Window title
        WS_OVERLAPPEDWINDOW,        // Window style
        CW_USEDEFAULT,              // Horizontal position
        CW_USEDEFAULT,              // Vertical position        
        CW_USEDEFAULT,              // Initial width
        CW_USEDEFAULT,              // Initial height
        HWND_DESKTOP,               // Handle of parent window
        NULL,                       // Menu handle
        hInstance,                  // Application's instance handle
        NULL                        // Window-creation data
    );

    ShowWindow (hwnd, nCmdShow);
    UpdateWindow (hwnd);

    while (GetMessage (&amp;msg, NULL, 0, 0)) {
        TranslateMessage (&amp;msg);
        DispatchMessage (&amp;msg);
    }
    return msg.wParam;
}

LRESULT CALLBACK WndProc (HWND hwnd, UINT message, WPARAM wParam,
    LPARAM lParam)
{
    PAINTSTRUCT ps;
    HDC hdc;

    switch (message) {
    
    case WM_PAINT:
        hdc = BeginPaint (hwnd, &amp;ps);
        Ellipse (hdc, 0, 0, 200, 100);
        EndPaint (hwnd, &amp;ps);
        return 0;

    case WM_DESTROY:
        PostQuitMessage (0);
        return 0;
    }
    return DefWindowProc (hwnd, message, wParam, lParam);
}
</pre>
</td>
</tr>
</table>
</p>

<P>
<I>WinMain</I> begins by calling the API function 
<I>RegisterClass</I> to register a window class. The window class defines important characteristics of a window such as 
its window procedure address, its default background color, and its icon. These and 
other properties are defined by filling in the fields of a WNDCLASS structure, which is 
subsequently passed to <I>RegisterClass</I>. An application must specify a window class 
when it creates a window, and a class must be registered before it can be used. That's 
why <I>RegisterClass</I> is called at the outset of the program. Keep in mind that a 
WNDCLASS-type window class is not the same as a C++ window class. To avoid confusion, 
I'll use the term <I>WNDCLASS</I> throughout this book to refer to classes registered 
with <I>RegisterClass</I>. The term <I>window 
class</I> will refer to C++ classes derived from 
MFC's <I>CWnd</I> class.
</p>

<p>
Once the WNDCLASS is registered, <I>WinMain</I> calls the all-important 
<I>CreateWindow</I> function to create the application's window. The first parameter to 
<I>CreateWindow</I> is the name of the WNDCLASS from which the window will be created. The 
second parameter is the text that will appear in the window's title bar. The third specifies 
the window style. WS_OVERLAPPEDWINDOW is a commonly used style that creates 
a top-level window with a resizing border, a title bar, a system menu, and buttons 
for minimizing, maximizing, and closing the window.
</p>

<p>
The next four parameters specify the window's initial position and 
size. CW_USEDEFAULT tells Windows to use default values for both. The final four 
parameters specify, in order, the handle of the window's parent window 
(HWND_DESKTOP for an application's main window); the handle of the menu 
associated with the window, if any; the application's instance handle (a value that lets 
the programmer differentiate between the program itself and the modules&#8212;that is, 
DLLs&#8212;that it loads); and a pointer to application-specific window-creation data. I could 
easily devote a section of this book to 
<I>CreateWindow</I> and its parameters, but as you'll 
see later, MFC hides much of this detail inside the class library. A typical MFC 
application doesn't have a <I>WinMain</I> function (at least not one you can see), and it doesn't 
call <I>RegisterClass</I> or <I>CreateWindow</I>.
</p>

<p>
The window that <I>CreateWindow</I> creates is not initially visible on the 
screen because it was not created with the WS_VISIBLE style. (Had it been used, 
WS_VISIBLE would have been combined with WS_OVERLAPPEDWINDOW in the call to 
<I>CreateWindow</I>.) Therefore, <I>WinMain</I> follows 
<I>CreateWindow</I> with calls to 
<I>ShowWindow</I> and <I>UpdateWindow</I>, which make the window visible and ensure that its WM_PAINT 
handler is called immediately.
</p>

<p>
Next comes the message loop. In order to retrieve and dispatch 
messages, <I>WinMain</I> executes a simple 
<I>while</I> loop that calls the 
<I>GetMessage</I>,<I> TranslateMessage</I>, and 
<I>DispatchMessage</I> API functions repeatedly. 
<I>GetMessage</I> checks the message queue. If a message is available, it is removed from the queue and copied to 
<I>msg</I>; otherwise, <I>GetMessage</I> blocks on the empty message queue until a message is available. 
<I>msg</I> is an instance of the structure MSG, whose fields contain pertinent message 
parameters such as the message ID and the time at which the message was placed in the 
queue. <I>TranslateMessage</I> converts a keyboard message denoting a character key to an 
easier-to-use WM_CHAR message, and 
<I>DispatchMessage</I> dispatches the message to the 
window procedure. The message loop executes until 
<I>GetMessage</I> returns 0, which happens only when a WM_QUIT message is retrieved from the message queue. When 
this occurs, <I>WinMain</I> ends and the program terminates.
</p>

<P>
Messages dispatched with <I>DispatchMessage</I> generate calls to the window 
procedure <I>WndProc</I>. The sample program in Figure 1-2 processes just two message 
types, WM_PAINT and WM_DESTROY; all other messages are passed to 
<I>DefWindowProc</I> for default processing. A 
<I>switch-case</I> block inspects the message ID passed in 
the<I> message</I> parameter and executes the appropriate message handler. The 
WM_PAINT handler calls the <I>BeginPaint</I> API function to obtain a device context handle 
before painting begins and the <I>EndPaint</I> API function to release the handle when 
painting is finished. In between, the 
<I>Ellipse</I> API function draws an ellipse that is 200 
pixels wide and 100 pixels high. A device context handle is the &quot;magic cookie&quot; that 
permits a Windows application to draw on the screen. Without it, functions such as 
<I>Ellipse</I> won't work.
</p>

<P>
The WM_DESTROY handler calls the 
<I>PostQuitMessage</I> API function to post a WM_QUIT message to the message queue and ultimately cause the program 
to terminate. The WM_DESTROY message is sent to a window just before it is 
destroyed. A top-level window must call <I>PostQuitMessage 
</I>when it receives a WM_DESTROY message, or else the message loop will not fall through and the program will never end.
</p>

<A NAME="5"><H2>Hungarian Notation and Windows Data Types</H2></A>

<P>
Another aspect of Figure 1-2 that deserves mentioning is the variable naming 
convention that it uses. Veteran Windows programmers know it as 
<I>Hungarian notation,</I> in which each variable name begins with one or more lowercase characters 
identifying the variable's type: <I>h</I> for handle, 
<I>n</I> for integer, and so on. The table below lists some of the commonly used Hungarian prefixes. Prefixes are often 
combined to form other prefixes, as when <I>p</I> and 
<I>sz</I> are joined to form <I>psz</I>, which 
stands for &quot;pointer to zero-terminated string.&quot;
</p>

<P>
Many of the data types shown in this table aren't standard C/C++ data types 
but rather are &quot;special&quot; data types defined in the Windows header files. COLORREF, 
for example, is the Windows data type for 24-bit RGB color values. A BOOL is a 
Boolean data type that stores TRUE/FALSE values, while a DWORD is a 32-bit 
unsigned integer. Over time, you'll come to know these data types as well as you know 
your compiler's native data types.
</p>

<p><b>Common Hungarian Notation Prefixes</b></p>

<p><table cellpadding="5" width="95%">
<TR><TH valign="top">Prefix</TH>
<TH valign="top">Data Type</TH></TR>

<TR><TD valign="top"><I>b</I></TD>
<TD valign="top">BOOL</TD></TR>

<TR><TD valign="top"><I>c</I> or <I>ch</I> </TD>
<TD valign="top">char</TD></TR>

<TR><TD valign="top"><I>clr</I></TD>
<TD valign="top">COLORREF</TD></TR>

<TR><TD valign="top"><I>cx, cy</I></TD>
<TD valign="top">Horizontal or vertical distance</TD></TR>

<TR><TD valign="top"><I>dw</I></TD>
<TD valign="top">DWORD</TD></TR>

<TR><TD valign="top"><I>h</I></TD>
<TD valign="top">Handle</TD></TR>

<TR><TD valign="top"><I>l</I></TD>
<TD valign="top">LONG</TD></TR>

<TR><TD valign="top"><I>n</I></TD>
<TD valign="top">int</TD></TR>

<TR><TD valign="top"><I>p</I></TD>
<TD valign="top">Pointer</TD></TR>

<TR><TD valign="top"><I>sz</I></TD>
<TD valign="top">Zero-terminated string</TD></TR>

<TR><TD valign="top"><I>w</I></TD>
<TD valign="top">WORD</TD></TR>
</table></p>

<P>Most MFC programmers use Hungarian notation, too. Glance through the 
source code for a typical MFC program and you'll see hundreds of 
<I>h</I>s and <I>lp</I>s and other familiar prefixes as well as prefixes representing MFC's own data types (for example, 
<I>wnd</I> for <I>CWnd</I> variables). It's also common to prefix member variables with 
<I>m_</I> so that it's obvious whether a variable is a member of a class. A temporary 
<I>CString</I> variable created on the stack might have the name 
<I>strWndClass</I>, but if it's a member variable it will probably be called 
<I>m_strWndClass</I>. You don't have to abide by these 
rules yourself, of course, but observing established naming conventions will make 
your code more readable to other programmers who do.
</p>

<A NAME="6"><H2>SDK Programming in Perspective</H2></A>

<P>All this is a lot to digest if you've never programmed Windows before, but it brings 
to light a few very important concepts. First, Windows is an event-driven, 
message-based operating system. Messages are the key to everything that goes on in the 
system, and for an application, very few things happen that aren't the direct result of 
receiving a message. Second, there are many different API functions and many 
different message types, which complicates application development and makes it hard 
to predict all of the scenarios an application might encounter. Third, seeing how 
Windows programming is done the hard way provides a baseline for evaluating MFC and 
other class libraries. MFC is not the panacea some of its proponents would have you 
believe, but it undeniably makes certain aspects of Windows programming easier. And 
the higher order it lends to Windows programs frees programmers to spend more 
time developing the structural components of a program and less time worrying about 
the style bits passed to <I>CreateWindow</I> and other nuances of the API. If you haven't 
given MFC a look, now is the time to consider it. Windows programming isn't getting 
any easier, and MFC lets you benefit from tens of thousands of lines of code already 
written and tested by Microsoft.
</p>

</BODY>
</HTML>




