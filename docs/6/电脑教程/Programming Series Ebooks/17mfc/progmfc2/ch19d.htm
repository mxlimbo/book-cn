<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>OLE Drag-and-Drop</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch19c.htm", "ch19e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="601"><H1>OLE Drag-and-Drop</H1></A>

<P>If you've never seen OLE drag-and-drop in action, you can perform a simple demonstration using the source code editor in Visual C++. Begin by opening a source code file and highlighting a line of text. Grab the highlighted text with the left mouse button, and with the button held down, drag it down a few lines. Then release the mouse button. The text will disappear from its original location and appear where you dropped it, just as if you had performed a cut-and-paste operation. Repeat the operation with the Ctrl key held down, and the text will be copied rather than moved. That's OLE drag-and-drop. You used it to transfer text from one part of a document to another, but it works just as well if the destination is a different document or even a different application. And just as with the OLE clipboard, you can use OLE drag-and-drop to transfer any kind of data&#8212;not just text.</P>

<P>Programmatically, OLE drag-and-drop is very similar to the OLE clipboard. The data provider, or <I>drop source,</I> creates a data object that encapsulates the data and makes an <I>IDataObject</I> pointer available. The data consumer, or <I>drop target,</I> retrieves the <I>IDataObject</I> pointer and uses it to extract data from the data object.</P>

<P>One difference between OLE drag-and-drop and the OLE clipboard is how the <I>IDataObject</I> pointer changes hands. The OLE clipboard uses <I>::OleSetClipboard</I> and <I>::OleGetClipboard</I> to transfer the pointer from sender to receiver. In OLE drag-and-drop, the drop source initiates a drag-and-drop operation by passing an <I>IDataObject</I> pointer to <I>::DoDragDrop</I>. On the other end, any window interested in being a drop target registers itself with the system by calling the API function <I>::RegisterDragDrop</I>. If a drop occurs over a window that's registered in this way, the drop target is handed the <I>IDataObject</I> pointer passed to <I>::DoDragDrop</I>.</P>

<P>If that's all there was to it, OLE drag-and-drop wouldn't be difficult at all. What complicates matters is that OLE drag-and-drop requires three COM objects instead of just one:</P>

<UL>
<P><LI>A data object that implements <I>IDataObject</I></LI></P>
<P><LI>A drop source object that implements <I>IDropSource</I></LI></P>
<P><LI>A drop target object that implements <I>IDropTarget</I></LI></P>
</UL>

<P>The data object is identical to the one used for OLE clipboard transfers. The drop source and drop target objects are new. Figure 19-2 shows a schematic representation of the participants in a drag-and-drop data transfer. On the sending end of the transaction is an application that implements two COM objects: a data object and a drop source object. (There's nothing to prevent one object from supporting both interfaces, but in practice, the objects are usually implemented separately.) On the receiving end is an application that implements a drop target object. Neither the drop source nor the drop target receives an <I>IDropSource</I> or <I>IDropTarget</I> pointer that references the other. Instead, the system acts as an intermediary and calls methods on both interfaces at the appropriate times.</P>

<P>
<A HREF="javascript:fullSize('F19mg02x.htm')"> <img src="images/F19mg02.JPG" width=404 height=352 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 19-2.</B> <I>Participants in an OLE drag-and-drop operation.</I><!-- /CAPTION -->
</p>

<A NAME="602"><H2>Anatomy of a Drop Source</H2></A>

<P>An OLE drag-and-drop operation begins when an application calls <I>::DoDragDrop</I> and passes in four key pieces of information:</P>

<UL>
<P><LI>An <I>IDataObject</I> pointer</LI></P>

<P><LI>An <I>IDropSource</I> pointer</LI></P>
<P><LI>An input value containing one or more DROPEFFECT codes 
specifying what types of operations are allowed on the data (for example, move, copy, or both move and copy)</LI></P>

<P><LI>A pointer to a DWORD that receives a DROPEFFECT code specifying what happened on the other end (for example, did a drop occur, and if it did, was the data moved or copied?)</LI></P>
</UL>

<P><I>::DoDragDrop</I> returns when either of two conditions is met:</P>

<UL>
<P><LI>A drop occurs.</LI></P>
<P><LI>The operation is canceled.</LI></P>
</UL>

<P>The action that cancels a drag-and-drop operation varies from application to application and is ultimately determined by the drop source. In most cases, the stimulus is a press of the Esc key. If the operation is canceled or the drop target rejects the drop, <I>::DoDragDrop</I> copies the value DROPEFFECT_NONE to the address in the fourth parameter. If the drop is successful, <I>::DoDragDrop</I> copies one of the DROPEFFECT codes passed in the third parameter to the address in the fourth parameter so that the drop source will know precisely what occurred.</P>

<P>Assume that <I>pdo</I> and <I>pds</I> hold <I>IDataObject</I> and <I>IDropSource</I> pointers, respectively. The following statements initiate a drag-and-drop operation in which the data encapsulated in the data object can be either moved or copied:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
DWORD dwEffect;
HRESULT hr = ::DoDragDrop (pdo, pds,
    DROPEFFECT_MOVE | DROPEFFECT_COPY, &amp;dwEffect);
</pre>
</td></tr></table></p>

<P>When <I>::DoDragDrop</I> returns, <I>dwEffect</I> tells the drop source what transpired on the other end. If <I>dwEffect</I> equals DROPEFFECT_NONE or DROPEFFECT_COPY, the drop source doesn't need to do anything more. If <I>dwEffect</I> equals DROPEFFECT_MOVE, however, the drop source must delete the data from the source document:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
if (SUCCEEDED (hr) &amp;&amp; dwEffect == DROPEFFECT_MOVE) {
    // Delete the original data from the document.
}
</pre>
</td></tr></table></p>

<P>The code that deletes the data isn't shown because, obviously, it's application-specific.</P>

<P>Calls to <I>::DoDragDrop</I> are synchronous; that is, <I>::DoDragDrop</I> doesn't return until the operation has been completed or canceled. However, as a drag-and-drop operation is being performed, the system communicates with the drop source through the <I>IDropSource</I> pointer provided to <I>::DoDragDrop</I>. <I>IDropSource</I> is a simple interface that contains just two methods besides the <I>IUnknown</I> methods common to all COM interfaces:</P>

<P><B><I>IDropSource</I> Methods</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Method</I></th>     
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top"><I>GiveFeedback</I></td>   
<td valign="top">Called each time the cursor moves or a key state changes to allow the drop source to update the cursor</td>  
</tr>
<tr>
<td valign="top"><I>QueryContinueDrag</I></td>  
<td valign="top">Called when a key state or mouse button state changes to allow the drop source to specify whether to continue the operation, cancel it, or execute a drop</td>  
</tr></table></p>

<P>Whenever a change occurs in the state of a key or mouse button that might be of interest to the drop source, the drop source object's <I>QueryContinueDrag</I> method is called. <I>QueryContinueDrag</I> receives two parameters: a BOOL indicating whether the Esc key has been pressed and a DWORD containing flags that reflect the current state of the mouse buttons as well as the Ctrl, Alt, and Shift keys. Using this information, <I>QueryContinueDrag</I> must return one of three values telling the system what to do next:</P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Return Value</I></th>     
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top">S_OK</td>     
<td valign="top">Continue the drag-and-drop operation</td>
</tr>
<tr>
<td valign="top">DRAGDROP_S_DROP</td>     
<td valign="top">End the operation by executing a drop</td>
</tr>
<tr>
<td valign="top">DRAGDROP_S_CANCEL</td>     
<td valign="top">Cancel the drag-and-drop operation</td>
</tr></table></p>

<P>Typical responses are to cancel the operation if the Esc key has been pressed, to execute a drop if the left mouse button has been released, or to allow the operation to continue if neither of the first two conditions is true. The following <I>QueryContinueDrag</I> implementation embodies this logic:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
HRESULT __stdcall CDropSource::QueryContinueDrag (BOOL fEscape,
    DWORD grfKeyState)
{
    if (fEscape)
        return DRAGDROP_S_CANCEL;     // Esc key was pressed.
    if (!(grfKeyState &amp; MK_LBUTTON))
        return DRAGDROP_S_DROP;          // Left mouse button was released.
    return S_OK;                    // Let the operation continue.
}
</pre>
</td></tr></table></p>

<P>This code assumes that the drag-and-drop operation began when the left mouse button was depressed. If you're implementing right-button drag instead, check the right mouse button (MK_RBUTTON) to determine whether to execute the drop. If you prefer to use a key other than Esc to cancel the operation, you can call <I>::GetAsyncKeyState</I> to read the key's state and use that value rather than <I>fEscape</I> to decide whether to return DRAGDROP_S_CANCEL.</P>

<P>As a drag-and-drop operation unfolds, the drop source receives a flurry of calls to its <I>IDropSource::GiveFeedback</I> method. <I>GiveFeedback</I> receives one function parameter: a DROPEFFECT code that tells the drop source what would happen if a drop were to occur right now. (As you'll see in the next section, this information comes from the drop target because ultimately it's the drop target that controls what happens on the other end.) <I>GiveFeedback</I>'s job is to inspect this parameter and update the cursor to provide visual feedback to the user. When you see the cursor change shape as it moves from window to window during a drag-and-drop data transfer or when you see a little plus sign appear next to the cursor when the Ctrl key is pressed, what you're actually seeing is the drop source's response to <I>IDropSource::GiveFeedback</I>.</P>

<P>If you want to, you can create your own cursors and display them each time <I>GiveFeedback</I> is called; however, the system provides several predefined cursors for just this purpose. To use them, simply return DRAGDROP_S_USEDEFAULTCURSORS from your <I>GiveFeedback</I> implementation. Rather than do this:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
HRESULT __stdcall CDropSource::GiveFeedback (DWORD dwEffect)
{
    HCURSOR hCursor;
    switch (dwEffect) {
        // Inspect dwEffect, and load a cursor handle in hCursor.
    }
    ::SetCursor (hCursor);
    return S_OK;
}
</pre>
</td></tr></table></p>

<P>you can do this:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
HRESULT __stdcall CDropSource::GiveFeedback (DWORD dwEffect)
{
    return DRAGDROP_S_USEDEFAULTCURSORS;
}
</pre>
</td></tr></table></p>

<P>That's all there is to most implementations of <I>IDropSource::GiveFeedback</I>. You can do more if you'd like, but you might as well use the default cursors unless you have compelling reasons to do otherwise.</P>

<A NAME="603"><H2>Anatomy of a Drop Target</H2></A>

<P>A window becomes an OLE drop target when an application calls <I>::RegisterDragDrop</I> and passes in the window's handle and a pointer to an <I>IDropTarget</I> interface:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
::RegisterDragDrop (hWnd, pdt);
</pre>
</td></tr></table></p>

<P>You unregister a drop target by calling <I>::RevokeDragDrop</I>. Although the system will clean up after you if you fail to call this function before a drop target window is destroyed, calling it yourself is good form.</P>

<P>When the cursor enters, leaves, or moves over a drop target window during a drag-and-drop operation, the system apprises the drop target of that fact by calling <I>IDropTarget</I> methods through the <I>IDropTarget</I> pointer provided to <I>::RegisterDragDrop</I>. <I>IDropTarget</I> has just the four methods listed in the following table.</P>

<P><B><I>IDropTarget</I> Methods</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Method</I></th>     
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top"><I>DragEnter</I></td>     
<td valign="top">Called when the cursor enters the drop target window</td> 
</tr>
<tr>
<td valign="top"><I>DragOver</I></td> 
<td valign="top">Called as the cursor moves over the drop target window</td> 
</tr>
<tr>
<td valign="top"><I>DragLeave</I></td> 
<td valign="top">Called when the cursor leaves the drop target window or if the 
operation is canceled while the cursor is over the window</td> 
</tr>
<tr>
<td valign="top"><I>Drop</I></td> 
<td valign="top">Called when a drop occurs</td> 
</tr></table></p>

<P>Both <I>DragEnter</I> and <I>DragOver</I> receive a pointer to a DWORD (among other things) in their parameter lists. When either of these methods is called, the drop target must let the drop source know what would happen if a drop were to occur by copying a DROPEFFECT value to the DWORD. The value copied to the DWORD is the value passed to the drop source's <I>GiveFeedback</I> method. <I>DragEnter</I> and <I>DragOver</I> also receive a set of cursor coordinates (in case the outcome of a drop depends on the current cursor position) and flags that specify the status of the Ctrl, Alt, and Shift keys and each of the mouse buttons. In addition, <I>DragEnter</I> receives an <I>IDataObject</I> pointer that it can use to query the data object. The following implementations of <I>DragEnter</I> and <I>DragOver</I> return DROPEFFECT_NONE, DROPEFFECT_MOVE, or DROPEFFECT_COPY to the data source depending on whether text is available from the data object and whether the Ctrl key is up (move) or down (copy):</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
HRESULT __stdcall CDropTarget::DragEnter (IDataObject* pDataObject,
    DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    FORMATETC fe = {
        CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL
    };

    if (pDataObject-&gt;QueryGetData (&amp;fe) == S_OK) {
        m_bCanAcceptData = TRUE;
        *pdwEffect = (grfKeyState &amp; MK_CONTROL) ?
            DROPEFFECT_COPY : DROPEFFECT_MOVE;
    }
    else {
        m_bCanAcceptData = FALSE;
        *pdwEffect = DROPEFFECT_NONE;
    }
    return S_OK;
}

HRESULT __stdcall CDropTarget::DragOver (DWORD grfKeyState,
    POINTL pt, DWORD* pdwEffect)
{
    if (m_bCanAcceptData)
        *pdwEffect = (grfKeyState &amp; MK_CONTROL) ?
            DROPEFFECT_COPY : DROPEFFECT_MOVE;
    else
        *pdwEffect = DROPEFFECT_NONE;
    return S_OK;
}
</pre>
</td></tr></table></p>

<P><I>m_bCanAcceptData</I> is a BOOL member variable that keeps a record of whether the data offered by the drop source is in a format that the drop target will accept. When <I>DragOver</I> is called, the drop target uses this value to determine whether to indicate that it's willing to accept a drop.</P>

<P>The drop target's <I>DragLeave</I> method is called if the cursor leaves the drop target window without executing a drop or if the drag-and-drop operation is canceled while the cursor is over the drop target window. The call to <I>DragLeave</I> gives the drop target the opportunity to clean up after itself by freeing any resources allocated in <I>DragEnter</I> or <I>DragOver</I> if the anticipated drop doesn't occur.</P>

<P>The final <I>IDropTarget</I> method, <I>Drop</I>, is called if (and only if) a drop occurs. Through its parameter list, <I>Drop</I> receives all the information it needs to process the drop, including an <I>IDataObject</I> pointer; a DWORD that specifies the state of the Ctrl, Alt, and Shift keys and the mouse buttons; and cursor coordinates. It also receives a DWORD pointer to which it must copy a DROPEFFECT value that informs the data source what happened as a result of the drop. The following <I>Drop</I> implementation retrieves a text string from the data object, provided that a text string is available:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
HRESULT __stdcall CDropTarget::Drop (IDataObject* pDataObject,
    DWORD grfKeyState, POINTL pt, DWORD* pdwEffect)
{
    if (m_bCanAcceptData) {
        FORMATETC fe = {
            CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL
        };

        STGMEDIUM stgm;

        if (SUCCEEDED (pDataObject-&gt;GetData (&amp;fe, &amp;stgm)) &amp;&amp;
            stgm.hGlobal != NULL) {
            // Copy the string from the global memory block.
                .
                .
                .
           ::ReleaseStgMedium (&amp;stgm);
            *pdwEffect = (grfKeyState &amp; MK_CONTROL) ?
                DROPEFFECT_COPY : DROPEFFECT_MOVE;
            return S_OK;
        }
    }
    // If we make it to here, the drop did not succeed.
   *pdwEffect = DROPEFFECT_NONE;
    return S_OK;
}
</pre>
</td></tr></table></p>

<P>A call to <I>Drop</I> isn't followed by a call to <I>DragLeave</I>, so if there's any cleaning up to do after the drop is completed, the <I>Drop</I> method should do it.</P>

<A NAME="604"><H2>MFC Support for OLE Drag-and-Drop</H2></A>

<P>Most of the work in writing OLE drag-and-drop code lies in implementing the COM objects. Fortunately, MFC will implement them for you. The same <I>COleDataSource</I> class that provides data objects for OLE clipboard operations works with OLE drag-and-drop, too. <I>COleDropSource</I> provides a handy implementation of the drop source object, and <I>COleDropTarget</I> provides the drop target object. Very often, you don't even have to instantiate <I>COleDropSource</I> yourself because <I>COleDataSource</I> does it for you. You will have to instantiate <I>COleDropTarget</I>, but you usually do that simply by adding a <I>COleDropTarget</I> member variable to the application's view class.</P>

<P>Suppose you'd like to transfer a text string using OLE drag-and-drop in an MFC application. Here's how to do it using a global memory block as the storage medium:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
char szText[] = &quot;Hello, world&quot;;
HANDLE hData = ::GlobalAlloc (GMEM_MOVEABLE, ::lstrlen (szText) + 1)
LPSTR pData = (LPSTR) ::GlobalLock (hData);
::lstrcpy (pData, szText);
::GlobalUnlock (hData);

COleDataSource ods;
ods.CacheGlobalData (CF_TEXT, hData);

DROPEFFECT de =
    ods.DoDragDrop (DROPEFFECT_MOVE | DROPEFFECT_COPY)

if (de == DROPEFFECT_MOVE) {
    // Delete the string from the document.
}
</pre>
</td></tr></table></p>

<P>This code is strikingly similar to the code presented earlier in this chapter that used <I>COleDataSource</I> to place a text string on the OLE clipboard. Other than the fact that the <I>COleDataSource</I> object is created on the stack rather than on the heap (which is correct because, in this case, the object doesn't need to outlive the function that created it), the only real difference is that <I>COleDataSource::DoDragDrop</I> is called instead of <I>COleDataSource::SetClipboard</I>. <I>COleDataSource::DoDragDrop</I> is a wrapper around the API function of the same name. In addition to calling <I>::DoDragDrop</I> for you, it also creates the <I>COleDropSource</I> object whose <I>IDropSource</I> interface pointer is passed to <I>::DoDragDrop</I>.</P>

<P>If you'd rather create your own <I>COleDropSource</I> object, you can do so and pass it by address to <I>COleDataSource::DoDragDrop</I> in that function's optional third parameter. The only reason to create this object yourself is if you want to derive a class from <I>COleDropSource</I> and use it instead of <I>COleDropSource</I>. Programmers occasionally derive from <I>COleDropSource</I> and override its <I>GiveFeedback</I> and <I>QueryContinueDrag</I> member functions to provide custom responses to the <I>IDropSource</I> methods of the same names.</P>

<P>MFC makes acting as a target for OLE drag-and-drop data transfers relatively easy, too. The first thing you do is add a <I>COleDropTarget</I> data member to the application's view class:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
// In CMyView's class declaration
COleDropTarget m_oleDropTarget;
</pre>
</td></tr></table></p>

<P>Then, in the view's <I>OnCreate</I> function, you call <I>COleDropTarget::Register</I> and pass in a pointer to the view object:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
m_oleDropTarget.Register (this);
</pre>
</td></tr></table></p>

<P>Finally, you override the view's <I>OnDragEnter</I>, <I>OnDragOver</I>, <I>OnDragLeave</I>, and <I>OnDrop</I> functions or some combination of them. These <I>CView</I> functions are coupled to the similarly named <I>IDropTarget</I> methods. For example, when the drop target object's <I>IDropTarget::Drop</I> method is called, <I>COleDropTarget::OnDrop</I> calls your view's <I>OnDrop</I> function. To respond to calls to <I>IDropTarget::Drop</I>, you simply override <I>CView::OnDrop</I>.</P>

<P>Here's an example that demonstrates how to override <I>OnDragEnter</I>, <I>OnDragOver</I>, and <I>OnDrop</I> in a <I>CScrollView</I>-derived class to make the view a drop target for text. <I>OnDragLeave</I> isn't overridden in this example because nothing special needs to be done when it's called. Notice that a preallocated <I>COleDataObject</I> is provided in each function's parameter list. This <I>COleDataObject</I> wraps the <I>IDataObject</I> pointer passed to the drop target's <I>IDropTarget</I> methods:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
DROPEFFECT CMyView::OnDragEnter (COleDataObject* pDataObject,
    DWORD dwKeyState, CPoint point)
{
    CScrollView::OnDragEnter (pDataObject, dwKeyState, point);
    if (!pDataObject-&gt;IsDataAvailable (CF_TEXT))
        return DROPEFFECT_NONE;
    return (dwKeyState &amp; MK_CONTROL) ?
        DROPEFFECT_COPY : DROPEFFECT_MOVE;
}

DROPEFFECT CMyView::OnDragOver (COleDataObject* pDataObject,
    DWORD dwKeyState, CPoint point) 
{
    CScrollView::OnDragOver (pDataObject, dwKeyState, point);
    if (!pDataObject-&gt;IsDataAvailable (CF_TEXT))
        return DROPEFFECT_NONE;
    return (dwKeyState &amp; MK_CONTROL) ?
        DROPEFFECT_COPY : DROPEFFECT_MOVE;
}

BOOL CMyView::OnDrop (COleDataObject* pDataObject, DROPEFFECT dropEffect,
    CPoint point) 
{
    CScrollView::OnDrop (pDataObject, dropEffect, point);
    HANDLE hData = pDataObject-&gt;GetGlobalData (CF_TEXT);
    if (hData != NULL) {
        // Copy the string from the global memory block.

           .
           .
           .
        ::GlobalFree (hData);
        return TRUE;     // Drop succeeded.
    }
    return FALSE;          // Drop failed.
}
</pre>
</td></tr></table></p>

<P>This code looks a lot like the non-MFC version presented in the previous section. <I>OnDragEnter</I> and <I>OnDragOver</I> call <I>COleDataObject::IsDataAvailable</I> through the pointer provided in their parameter lists to determine whether text is available. If the answer is no, both functions return DROPEFFECT_NONE to indicate that they won't accept the drop. The drop source, in turn, will probably display a &quot;no-drop&quot; cursor. If text is available, <I>OnDragEnter</I> and <I>OnDragOver</I> return either DROPEFFECT_MOVE or DROPEFFECT_COPY, depending on whether the Ctrl key is down. <I>OnDrop</I> uses <I>COleDataObject::GetGlobalData</I> to retrieve the data when a drop occurs.</P>

<A NAME="605"><H2>Drop Target Scrolling</H2></A>

<P>The examples in the previous section assume that the drop target is a view-based application. You can use <I>COleDropTarget</I> to implement drop targeting in applications that don't have views by deriving your own class from <I>COleDropTarget</I> and overriding <I>OnDragEnter</I>, <I>OnDragOver</I>, <I>OnDragLeave</I>, and <I>OnDrop</I>. However, using a view as a drop target offers one very attractive benefit if the drop target has scroll bars: you get drop target scrolling for free, courtesy of MFC.</P>

<P>What is drop target scrolling? Suppose a drag-and-drop operation has begun and the user wants to drop the data at a location in a <I>CScrollView</I> that is currently scrolled out of sight. If the cursor pauses within a few pixels of the view's border, a <I>CScrollView</I> will automatically scroll itself for as long as the cursor remains in that vicinity. Thus, the user can move the cursor to the edge of the window and wait until the drop point scrolls into view. This is just one more detail you'd have to handle yourself if MFC didn't do if for you.</P>

</BODY>
</HTML>




