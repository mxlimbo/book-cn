<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Automation Basics</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch20a.htm", "ch20c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="617"><H1>Automation Basics</H1></A>


<p>Unlike a typical COM object, which exposes interfaces and methods, an Automation object exposes methods and properties. A <I>method</I> is a function that can be called by the object's clients. A <I>property</I> is an attribute of the object, such as a color or a file name.</P>

<p>Automation-aware languages such as Visual Basic shield the programmer from reference counting, interface pointers, and other idioms of COM. They also permit you to access Automation methods and properties as easily as you access local subroutines and variables. The following Visual Basic statements instantiate an Automation object and invoke a method named <I>Add</I> to add 2 and 2:</P>

<P>
<table cellpadding=5 width="95%"><tr><td>

<PRE>Dim Math as Object
Set Math = CreateObject (&quot;Math.Object&quot;)
Sum = Math.Add (2, 2)
Set Math = Nothing
</PRE>
</td></tr></table>
</P>

<p>In this example, <I>Math</I> is a variable of type <I>Object</I>. &quot;Math.Object&quot; is the Automation object's ProgID. (Recall from <a href="ch18a.htm">Chapter 18</a> that a ProgID is the string analogue of a COM CLSID.) The final statement frees the object by performing the Visual Basic equivalent of calling <I>Release</I> through an interface pointer.</P>

<p>In Visual Basic, accessing an Automation property is syntactically similar to calling an Automation method. The next example creates a bank account object and sets the balance in the account by assigning a value to a property named <I>Balance</I>:</P>

<p>
<table cellpadding=5 width="95%"><tr><td>

<PRE>
Dim Account as Object
Set Account = CreateObject (&quot;BankAccount.Object&quot;)
Account.Balance = 100
</PRE>
</td></tr></table>
</P>

<p>Checking the balance in the account is as simple as reading the property value:</P>

<P>
<table cellpadding=5 width="95%"><tr><td>

<PRE>
Amount = Account.Balance
</PRE>
</td></tr></table>
</P>

<p>Reading or writing an Automation property is analogous to accessing a public member variable in a C++ class. In truth, COM objects can't expose member variables any more than C++ objects can expose private data members. The illusion that an Automation object can expose values as well as methods is part of the magic of Automation.</P>

<p>Automation clients written in VBScript look very much like Automation clients written in Visual Basic. The following script uses VBScript's built-in <I>FileSystemObject</I> object, which is in reality an Automation object, to create a text file containing the string &quot;Hello, world&quot;:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>

<PRE>
Set fso = CreateObject (&quot;Scripting.FileSystemObject&quot;)
Set TextFile = fso.CreateTextFile (&quot;C:\Hello.txt&quot;, True)
TextFile.WriteLine (&quot;Hello, world&quot;)
TextFile.Close
</PRE>
</td></tr></table>
</P>

<p>To try this script for yourself, use Notepad or a program editor to enter these statements in a text file and save the file with the extension .vbs. Then double-click the file in the operating system shell or type START <I>filename</I>.vbs in a command prompt window. On Windows 98 and Windows 2000 systems, this will invoke the built-in Windows Scripting Host, which will open the file and execute the statements found inside it.</P>

<p>You can also write Automation clients in C++. The next section shows you 
how, but be warned that it isn't pretty because a C++ client doesn't have the Visual Basic run-time or a scripting engine to serve as a mediator between it and the Automation server. The good news is that Visual C++ aids in the creation of Automation clients by generating easy-to-use wrapper classes based on MFC's <I>COleDispatchDriver</I> class. You'll see what I mean later in this chapter.
</P>


<A NAME="618"><H2><I>IDispatch</I>: The Root of All Automation</H2></A>

<p>Automation looks fairly simple from the outside, and for a Visual Basic 
programmer, Automation <I>is</I> simple. But the fact that COM is involved should be a clue that what goes on under the hood is a far different story.
</P>

<p>The key to understanding how Automation works lies in understanding the 
COM interface known as <I>IDispatch</I>. An Automation object is a COM object that implements <I>IDispatch</I>. <I>IDispatch</I> contains four methods (which are listed in the table below), not counting the three <I>IUnknown</I> methods common to all COM interfaces. Of the four, <I>Invoke</I> and <I>GetIDsOfNames</I> are the most important. A client calls <I>Invoke</I> to call an Automation method or to read or write an Automation property. <I>Invoke</I> doesn't accept a method or a property name such as &quot;Add&quot; or   &quot;Balance.&quot; Instead, it accepts an integer <I>dispatch ID</I>, or <I>dispid</I>, that identifies the property or method. <I>GetIDsOfNames</I> converts a property name or a method name into a dispatch ID that can be passed to <I>Invoke</I>. Collectively, the methods and properties exposed through an <I>IDispatch</I> interface form a <I>dispinterface</I>.
</P>

<p><B>The <I>IDispatch</I> Interface</B> 
<p><table cellpadding=5 width="95%">
<tr><th valign="top"><I>Method</I></th>
<th valign="top"><I>Description</I></th></tr>
<tr><td valign="top"><I>Invoke</I></td> 
<td valign="top">Calls an Automation method or accesses an Automation property</td></tr>
<tr><td valign="top"><I>GetIDsOfNames</I></td> 
<td valign="top">Returns the dispatch ID of a property or a method</td></tr>
<tr><td valign="top"><I>GetTypeInfo</I></td> 
<td valign="top">Retrieves an <I>ITypeInfo</I> pointer (if available) for accessing 
the Automation object's type information</td></tr>
<tr><td valign="top"><I>GetTypeInfoCount</I></td>
<td valign="top">Returns 0 if the Automation object doesn't offer type information; returns 1 if it does</td></tr></table></P>


<p>When Visual Basic encounters a statement like</P>

<table cellpadding=5 width="95%"><tr><td>

<PRE>
Sum = Math.Add (2, 2)
</PRE>
</td></tr></table>

<p>it calls <I>GetIDsOfNames</I> to convert &quot;Add&quot; into a dispatch ID. It then calls 
<I>Invoke</I>, passing in the dispatch ID retrieved from <I>GetIDsOfNames</I>. Before calling <I>Invoke</I>, Visual Basic initializes an array of structures with the values of the method 
parameters&#8212;in this case, 2 and 2. It passes the array's address to <I>Invoke</I> along with the address of an empty structure that receives the method's return value (the sum of the two input parameters). The Automation object examines the dispatch ID, sees that it corresponds to the <I>Add</I> method, unpacks the input values, adds them together, and copies the sum to the structure provided by the caller.</P>

<p>A good way to picture this process is to see how a C++ programmer would 
call an Automation method. The following code is the C++ equivalent of the first example in the previous section:</P>

<P>
<table cellpadding=5 width="95%"><tr><td>

<PRE>
// Convert the ProgID into a CLSID.
CLSID clsid;
::CLSIDFromProgID (OLESTR (&quot;Math.Object&quot;), &amp;clsid);

// Create the object, and get a pointer to its IDispatch interface.
IDispatch* pDispatch;
::CoCreateInstance (clsid, NULL, CLSCTX_SERVER, IID_IDispatch,
    (void**) &amp;pDispatch);

// Get the Add method's dispatch ID.
DISPID dispid;
OLECHAR* szName = OLESTR (&quot;Add&quot;);
pDispatch-&gt;GetIDsOfNames (IID_NULL, &amp;szName, 1,
    ::GetUserDefaultLCID (), &amp;dispid);

// Prepare an argument list for the Add method.
VARIANTARG args[2];
DISPPARAMS params = { args, NULL, 2, 0 };
for (int i=0; i&lt;2; i++) {
    ::VariantInit (&amp;args[i]);    // Initialize the VARIANT.
    args[i].vt = VT_I4;          // Data type = 32-bit long
    V_I4 (&amp;args[i]) = 2;         // Value = 2
}

// Call Add to add 2 and 2.
VARIANT result;
::VariantInit (&amp;result);
pDispatch-&gt;Invoke (dispid, IID_NULL, ::GetUserDefaultLCID (),
    DISPATCH_METHOD, &amp;params, &amp;result, NULL, NULL);

// Extract the result.
long lResult = V_I4 (&amp;result);

// Clear the VARIANTs.
::VariantClear (&amp;args[0]);
::VariantClear (&amp;args[1]);
::VariantClear (&amp;result);

// Release the Automation object.
pDispatch-&gt;Release ();
</PRE>
</td></tr></table></P>

<p>You can plainly see the calls to <I>IDispatch::GetIDsOfNames</I> and <I>IDispatch::Invoke</I>, as well as the <I>::CoCreateInstance</I> statement that creates the Automation object. You can also see that input and output parameters are packaged in structures called VARIANTARGs, a subject that's covered in the next section.</P>

<p> You also use <I>IDispatch::Invoke</I> to access Automation properties. You can set the fourth parameter, which was equal to DISPATCH_METHOD in the preceding example, to DISPATCH_PROPERTYPUT or DISPATCH_PROPERTYGET to indicate that the value of the property named by the dispatch ID in parameter 1 is being set or retrieved. In addition, <I>IDispatch::Invoke</I> can return error information in an EXCEPINFO structure provided by the caller. The structure's address is passed in <I>Invoke</I>'s seventh parameter; a NULL pointer means the caller isn't interested in such information. <I>Invoke</I> also supports Automation methods and properties with optional and named arguments, which matters little to C++ clients but can simplify client code written in Visual Basic.</P>

<p> It should be evident from these examples that Automation leaves something to be desired for C++ programmers. It's faster and more efficient for C++ clients to call conventional COM methods than it is for them to call Automation methods. Automation looks easy in Visual Basic for the simple reason that Visual Basic goes to great lengths to <I>make</I> it look easy. Peel away the fa&ccedil;ade, however, and Automation looks very different indeed.
</P>

<A NAME="619"><H2>Automation Data Types</H2></A>

<p>One of the more interesting aspects of <I>IDispatch::Invoke</I> is how it handles input and output parameters. In Automation, all parameters are passed in data structures called VARIANTs. (Technically, input parameters are passed in VARIANTARGs and output parameters in VARIANTs, but because these structures are identical, developers often use the term VARIANT to describe both.) A VARIANT is, in essence, a self-describing data type. Inside a VARIANT is a union of data types for holding the VARIANT's data and a separate field for defining the data type. Here's how the structure is defined in Oaidl.idl:
</P>

<P>
<table cellpadding=5 width="95%"><tr><td>

<PRE>
struct tagVARIANT {
    union {
        struct __tagVARIANT {
            VARTYPE vt;
            WORD    wReserved1;
            WORD    wReserved2;
            WORD    wReserved3;
            union {
                LONG          lVal;         /* VT_I4                */
                BYTE          bVal;         /* VT_UI1               */
                SHORT         iVal;         /* VT_I2                */
                FLOAT         fltVal;       /* VT_R4                */
                DOUBLE        dblVal;       /* VT_R8                */
                VARIANT_BOOL  boolVal;      /* VT_BOOL              */
                _VARIANT_BOOL bool;         /* (obsolete)           */
                SCODE         scode;        /* VT_ERROR             */
                CY            cyVal;        /* VT_CY                */
                DATE          date;         /* VT_DATE              */
                BSTR          bstrVal;      /* VT_BSTR              */
                IUnknown *    punkVal;      /* VT_UNKNOWN           */
                IDispatch *   pdispVal;     /* VT_DISPATCH          */
                SAFEARRAY *   parray;       /* VT_ARRAY             */
                BYTE *        pbVal;        /* VT_BYREFVT_UI1       */
                SHORT *       piVal;        /* VT_BYREFVT_I2        */
                LONG *        plVal;        /* VT_BYREFVT_I4        */
                FLOAT *       pfltVal;      /* VT_BYREFVT_R4        */
                DOUBLE *      pdblVal;      /* VT_BYREFVT_R8        */
                VARIANT_BOOL *pboolVal;     /* VT_BYREFVT_BOOL      */
                _VARIANT_BOOL *pbool;       /* (obsolete)           */
                SCODE *       pscode;       /* VT_BYREFVT_ERROR     */
                CY *          pcyVal;       /* VT_BYREFVT_CY        */
                DATE *        pdate;        /* VT_BYREFVT_DATE      */
                BSTR *        pbstrVal;     /* VT_BYREFVT_BSTR      */
                IUnknown **   ppunkVal;     /* VT_BYREFVT_UNKNOWN   */
                IDispatch **  ppdispVal;    /* VT_BYREFVT_DISPATCH  */
                SAFEARRAY **  pparray;      /* VT_BYREFVT_ARRAY     */
                VARIANT *     pvarVal;      /* VT_BYREFVT_VARIANT   */
                PVOID         byref;        /* Generic ByRef        */
                CHAR          cVal;         /* VT_I1                */
                USHORT        uiVal;        /* VT_UI2               */
                ULONG         ulVal;        /* VT_UI4               */
                INT           intVal;       /* VT_INT               */
                UINT          uintVal;      /* VT_UINT              */
                DECIMAL *     pdecVal;      /* VT_BYREFVT_DECIMAL   */
                CHAR *        pcVal;        /* VT_BYREFVT_I1        */
                USHORT *      puiVal;       /* VT_BYREFVT_UI2       */
                ULONG *       pulVal;       /* VT_BYREFVT_UI4       */
                INT *         pintVal;      /* VT_BYREFVT_INT       */
                UINT *        puintVal;     /* VT_BYREFVT_UINT      */
                struct __tagBRECORD {
                    PVOID         pvRecord;
                    IRecordInfo * pRecInfo;
                } __VARIANT_NAME_4;         /* VT_RECORD            */
            } __VARIANT_NAME_3;
        } __VARIANT_NAME_2;

        DECIMAL decVal;
    } __VARIANT_NAME_1;
};
</PRE>
</TD></TR></TABLE>
</P>

<p>The <I>vt</I> field holds one or more VT_ flags identifying the data type. Another field 
holds the actual value. For example, a VARIANT that represents a 32-bit long equal to 
128 has a <I>vt</I> equal to VT_I4 and an <I>lVal</I> equal to 128. The header file Oleauto.h 
defines macros for reading and writing data encapsulated in VARIANTs. In addition, the 
system file Oleaut32.dll includes API functions, such as <I>::VariantInit</I> and <I>::VariantClear,</I> for managing and manipulating VARIANTs, and MFC's <I>COleVariant</I> class places a friendly wrapper around VARIANT data structures and the operations that can 
be performed on them.
</P>

<p>When you write Automation objects, you must use Automation-compatible data types&#8212;that is, data types that can be represented with VARIANTs&#8212;for all the objects' properties and methods. The table on the below summarizes the available data types.
</P>

<p><B>VARIANT-Compatible Data Types</B></P>

<p><table cellpadding=5 width="95%">
<tr><th valign="top"><i>Data Type</i></th>
<th valign="top"><I>Description</I></th></tr>
<tr><td valign="top">BSTR</td> 
<td valign="top">Automation string</td></tr>
<tr><td valign="top">BSTR*</td>
<td valign="top">Pointer to Automation string</td></tr>
<tr><td valign="top">BYTE</td>
<td valign="top">8-bit byte</td></tr>
<tr><td valign="top">BYTE*</td> 
<td valign="top">Pointer to 8-bit byte</td></tr>
<tr><td valign="top">BYTE</td>
<td valign="top">8-bit byte</td></tr>
<tr><td valign="top">CHAR</td> 
<td valign="top">8-bit character</td></tr>
<tr><td valign="top">CHAR*</td> 
<td valign="top">Pointer to 8-bit character</td></tr>
<tr><td valign="top">CY*</td> 
<td valign="top">64-bit currency value</td></tr>           
<tr><td valign="top">DATE</td> 
<td valign="top">64-bit date and time value</td></tr>           
<tr><td valign="top">DATE*</td> 
<td valign="top">Pointer to 64-bit date and time value</td></tr>           
<tr><td valign="top">DECIMAL*</td> 
<td valign="top">Pointer to DECIMAL data structure</td></tr>           
<tr><td valign="top">DOUBLE</td> 
<td valign="top">Double-precision floating point value</td></tr>           
<tr><td valign="top">DOUBLE*</td> 
<td valign="top">Pointer to double-precision floating point value</td></tr>           
<tr><td valign="top">FLOAT</td> 
<td valign="top">Single-precision floating point value</td></tr>           
<tr><td valign="top">FLOAT*</td> 
<td valign="top">Pointer to single-precision floating point value</td></tr>             
<tr><td valign="top"><I>IDispatch</I>*</td> 
<td valign="top"><I>IDispatch</I> interface pointer</td></tr>             
<tr><td valign="top"><I>IDispatch</I>**</td> 
<td valign="top">Pointer to<I> IDispatch</I> interface pointer</td></tr>	  	  
<tr><td valign="top">INT</td> 
<td valign="top">Signed integer (32 bits on Win32 platforms)</td></tr>	  	  
<tr><td valign="top">INT*</td> 
<td valign="top">Pointer to signed integer</td></tr>	  	  
<tr><td valign="top"><I>IUnknown</I>*</td> 
<td valign="top">COM interface pointer*</td></tr>	  	  
<tr><td valign="top"><I>IUnknown</I>**</td> 
<td valign="top">Pointer to COM interface pointer</td></tr>
<tr><td valign="top">LONG</td> 
<td valign="top">32-bit signed integer</td></tr>
<tr><td valign="top">LONG*</td> 
<td valign="top">Pointer to 32-bit signed integer</td></tr>
<tr><td valign="top">PVOID</td> 
<td valign="top">Untyped pointer</td></tr> 
<tr><td valign="top">SAFEARRAY*</td> 
<td valign="top">SAFEARRAY pointer</td></tr> 
<tr><td valign="top">SAFEARRAY**</td> 
<td valign="top">Pointer to SAFEARRAY pointer</td></tr> 
<tr><td valign="top">SCODE</td> 
<td valign="top">COM HRESULT</td></tr>
<tr><td valign="top">SCODE*</td> 
<td valign="top">Pointer to COM HRESULT</td></tr>
<tr><td valign="top">SHORT</td> 
<td valign="top">16-bit signed integer</td></tr>
<tr><td valign="top">SHORT*</td> 
<td valign="top">Pointer to 16-bit signed integer</td></tr>
<tr><td valign="top">UINT</td> 
<td valign="top">Pointer unsigned integer</td></tr>
<tr><td valign="top">UINT*</td> 
<td valign="top">Pointer unsigned integer</td></tr>
<tr><td valign="top">ULONG</td> 
<td valign="top">32-bit unsigned integer</td></tr>
<tr><td valign="top">ULONG*</td> 
<td valign="top">Pointer to 32-bit unsigned integer</td></tr>
<tr><td valign="top">USHORT</td> 
<td valign="top">16-bit unsigned integer</td></tr>
<tr><td valign="top">USHORT*</td> 
<td valign="top">Pointer to 16-bit unsigned integer</td></tr>
<tr><td valign="top">VARIANT*</td> 
<td valign="top">Pointer to VARIANT data structure</td></tr>	
<tr><td valign="top">VARIANT_BOOL</td> 
<td valign="top">Automation Boolean</td></tr>		
<tr><td valign="top">VARIANT_BOOL*</td> 
<td valign="top">Pointer to Automation Boolean</td></tr>			  	                   
</table>   
</p>

<p>Generally speaking, Automation's dependence on VARIANT-compatible 
data types is a limitation that can frustrate developers who are accustomed to building &quot;pure&quot; COM objects&#8212;objects that use conventional COM interfaces rather than dispinterfaces and are therefore less restricted in the types of data that they can use. However, using only Automation-compatible data types offers one advantage: COM knows 
how to marshal VARIANTs, so Automation objects don't require custom proxy/stub DLLs. The trade-off is that you can't use structures (or pointers to structures) in methods' parameter lists, and arrays require special handling because they must be encapsulated in structures called SAFEARRAYs.</P>

<A NAME="620"><H3>The BSTR Data Type</H3></A>

<p>Most of the data types presented in the preceding section are self-explanatory. Two, however, merit further explanation. BSTR (pronounced &quot;Bee'-ster&quot;) is Automation's string data type. Unlike a C++ string, which is an array of characters followed by a zero delimiter, a BSTR is a counted string. The first four bytes hold the number of bytes (not characters) in the string; subsequent bytes hold the characters 
themselves. All characters in a BSTR are 16-bit Unicode characters. A BSTR value is actually a pointer to the first character in the string. (See Figure 20-1.) The string is, in fact, zero-delimited, which means that you can convert a BSTR into a C++ string pointer by casting 
it to an LPCWSTR.
</P>

<p>
<img src="images/F20mg01.JPG" width=333 height=170  border=0>
</p><p>
<!-- CAPTION --><B>Figure 20-1.</B> <I>The BSTR data type.</I><!-- /CAPTION -->
</p>

<p>In MFC, dealing with BSTRs frequently means converting 
<I>CString</I>s to BSTRs and BSTRs to 
<I>CString</I>s. <I>CString::AllocSysString</I> creates a BSTR from a 
<I>CString</I>:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>	

<PRE>CString string = _T (&quot;Hello, world&quot;);
BSTR bstr = string.AllocSysString ();
</PRE>
</td></tr></table>
</p>

<p><I>AllocSysString</I> will automatically convert ANSI characters to Unicode characters if 
the preprocessor symbol _UNICODE is not defined, indicating that this is an ANSI 
program build. <I>CString</I> also includes a member function named 
<I>SetSysString</I> that can be used to modify an existing BSTR.
</p>

<p>Converting a BSTR into a <I>CString</I> is equally easy. 
<I>CString</I>'s LPCWSTR operator initializes a 
<I>CString</I> from a BSTR and conveniently converts the characters to 
8-bit ANSI characters if the <I>CString</I> is of the ANSI variety:
</p>

<p>
<table cellpadding=5 width="95%"><tr><td>	
<PRE>CString string = (LPCWSTR) bstr;
</PRE>
</td></tr></table>
</p>

<p>Be aware that if a BSTR contains embedded zeros (a very real possibility since BSTRs are counted strings), turning it into a 
<I>CString</I> in this way will effectively 
truncate the string.
</p>

<A NAME="621"><H3>The SAFEARRAY Data Type</H3></A>

<p>SAFEARRAY is Automation's array data type. It's called a &quot;safe&quot; array because in 
addition to holding the data comprising the array elements, it houses information 
regarding the number of dimensions in the array, the bounds of each dimension, 
and more.
</p>

<p>A SAFEARRAY is actually a structure. It is defined this way in Oaidl.h:
</P>

<P>
<table cellpadding=5 width="95%"><tr><td>	
<PRE>typedef struct  tagSAFEARRAY
    {
    USHORT cDims;
    USHORT fFeatures;
    ULONG cbElements;
    ULONG cLocks;
    PVOID pvData;
    SAFEARRAYBOUND rgsabound[ 1 ];
    } SAFEARRAY;
</PRE>
</td></tr></table>
</P>

<p>SAFEARRAYBOUND is also a structure. It is defined like this:
</P>

<P>
<table cellpadding=5 width="95%"><tr><td>	
<PRE>typedef struct  tagSAFEARRAYBOUND
    {
    ULONG cElements;
    LONG lLbound;
    } SAFEARRAYBOUND; 
</PRE>
</td></tr></table>
</P>

<p>The <I>cDims</I> field holds the number of dimensions in the SAFEARRAY. 
<I>rgsabound</I> is an embedded array that contains one element for each dimension. Each element defines the bounds (number of storage elements) of one dimension as well as the index of that dimension's lower bound. Unlike C++ arrays, which number their elements from 0 to <I>n</I>, a SAFEARRAY's elements can be numbered using any contiguous range of integers&#8212;for example, -5 to <I>n</I>-5. <I>fFeatures</I> holds flags specifying what 
kind of data the SAFEARRAY stores and how the SAFEARRAY is allocated. 
<I>cbElements</I> holds the size, in bytes, of each element. Finally, 
<I>pvData</I> points to the elements themselves.
</p>

<p>
The Windows API includes numerous functions for creating and using 
SAFEARRAYs; all begin with the name 
<I>SafeArray</I>. MFC has its own way of dealing 
with SAFEARRAYs in the form of a class named 
<I>COleSafeArray</I>. The following code creates a 
<I>COleSafeArray</I> object that represents a one-dimensional SAFEARRAY 
containing the integers 1 through 10:
</p>

<P>
<table cellpadding=5 width="95%"><tr><td>	

<PRE>COleSafeArray sa;
LONG lValues[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
sa.CreateOneDim (VT_I4, 10, lValues);
</PRE>
</td></tr></table>
</p>

<p>The address of the VARIANT data structure in which the SAFEARRAY is stored can be retrieved with <I>COleSafeArray</I>'s LPVARIANT or LPCVARIANT operator:
</p>

<P>
<table cellpadding=5 width="95%"><tr><td>	
<PRE>VARIANT* pVariant = (LPVARIANT) sa;
</PRE>
</td></tr></table>
</P>

<p>One-dimensional arrays are relatively easy to create with 
<I>COleSafeArray</I>, but multidimensional arrays require more effort. Suffice it to say that even <I>COleSafeArray</I> can't make SAFEARRAYs as palatable to C++ programmers as ordinary arrays.
</P>

<A NAME="622"><H2>Late Binding vs. Early Binding</H2></A>

<p>A C++ programmer seeing Automation for the first time might wonder 
why dispinterfaces should even exist: the reason for them is far from obvious. Given that Automation objects are inherently more complex and less efficient than their conventional COM counterparts, why not use custom COM interfaces instead of <I>IDispatch</I> interfaces and save developers a lot of time and trouble?
</P>

<p>Dispinterfaces were created to allow Visual Basic programmers to use 
COM objects at a time when Visual Basic flatly didn't support conventional COM 
interfaces. In its early incarnations, Visual Basic couldn't call COM methods through 
ordinary interface pointers. Current versions of Visual Basic have partially eliminated this 
limitation, but to this day, many scripting languages, including VBScript, can talk to 
COM objects only through <I>IDispatch</I> interfaces.
</p>

<P>
What's so special about <I>IDispatch</I>? In a nutshell, it prevents a compiler (or an interpreter, as the case may be) from having to understand vtables. A COM interface pointer is really a pointer to a location inside the object that holds the address of a table of function pointers&#8212;in C++ parlance, a virtual function table, or vtable. If <I>pMath</I> holds an <I>IMath</I> interface pointer, when a C++ compiler encounters a statement like
</p>

<table cellpadding=5 width="95%"><tr><td>
<PRE>pMath-&gt;Add (2, 2, &amp;sum);
</PRE>
</td></tr></table>

<p>it resolves the call by emitting code that extracts the address of the 
<I>Add</I> method from the interface's vtable. It knows the vtable's layout because the interface definition 
was #included in a header file. And therein lies the problem. Scripting languages 
don't understand C++ interface definitions. These languages can't resolve a statement 
like the following one unless they can somehow pass the method name to the object 
and ask the object itself to resolve the call:
</p>

<P>
<table cellpadding=5 width="95%"><tr><td>	
<PRE>Sum = Math.Add (2, 2)
</PRE>
</td></tr></table>
</P>

<p>Scripting languages may not understand vtables, but they know 
<I>IDispatch</I> very well. Given a pointer to an 
<I>IDispatch</I> interface, they know where they can go in the 
vtable to find the addresses of 
<I>GetIDsOfNames</I> and <I>Invoke</I>. It's therefore a simple matter 
for them to call <I>IDispatch::Invoke</I> and &quot;bind&quot; to a method at run time.
</p>

<p>That's the crux of <I>IDispatch</I>: shifting the responsibility for resolving method 
calls from the client to the object. Programmers call this 
<I>late binding</I> because the actual binding is done at run time. By contrast, we say that C++ clients use 
<I>early binding</I> because the bulk of the work required to resolve a method call is performed at compile 
time.
</p>

<A NAME="623"><H2>Dual Interfaces</H2></A>

<p>The drawback to late binding is that it requires a run-time lookup that's not 
necessary in early binding. That impacts performance. And because of 
<I>IDispatch</I>'s reliance on dispatch IDs, each property or method access nominally requires two 
round-trips to the server: a call to 
<I>GetIDsOfNames</I> followed by a call to 
<I>Invoke</I>. A smart Automation client can minimize round-trips by caching dispatch IDs, but the fact 
remains that late binding is inherently less efficient than early binding.
</p>

<p>The choice between an <I>IDispatch</I> interface and a conventional COM 
interface is a choice between flexibility and speed. An object that exposes its features 
through an <I>IDispatch</I> interface serves a wider variety of clients, but an object that uses 
ordinary COM interfaces serves late binding clients (particularly C++ clients) more efficiently.
</p>

<p>Dual interfaces are the COM equivalent of having your cake and eating it, too. A dual interface is an interface that derives from <I>IDispatch</I>. Its vtable includes entries for <I>IDispatch</I> methods (<I>GetIDsOfNames</I>, <I>Invoke</I>, and so on) as well as custom methods. Figure 20-2 shows the layout of the vtable for a dual interface that permits methods named <I>Add</I> and <I>Subtract</I> to be accessed indirectly through <I>IDispatch::Invoke</I> or directly through the vtable. Clients that rely exclusively on <I>IDispatch</I> can call <I>Add</I> and 
<I>Subtract</I> through <I>IDispatch::Invoke</I>; they won't even realize that the custom portion of the vtable exists. C++ clients, on the other hand, will effectively ignore the <I>IDispatch</I> section of the vtable and use early binding to call <I>Add</I> and <I>Subtract</I>. Thus, the same object can support early and late binding. Notice that methods defined in the custom half of the vtable must use Automation-compatible data types, just as methods 
exposed through <I>IDispatch::Invoke </I>must.
</p>

<p>
<IMG SRC="IMAGES/F20mg02.JPG" width=216 height=242 border=0>
</p><p>
<!-- CAPTION --><B>Figure 20-2.</B> <I>Virtual function table for a dual interface.</I><!-- /CAPTION -->
</p>

<p>For MFC programmers, the greatest impediment to dual interfaces is the 
amount of effort required to implement them. MFC Technical Note 65 describes how to 
add dual interfaces to an MFC Automation server, but the procedure isn't for the faint 
of heart. The best way to do dual interfaces today is to forego MFC and instead use 
the Active Template Library (ATL), which makes creating dual interfaces truly effortless.
</p>

<A NAME="624"><H2>Type Libraries</H2></A>

<p>Most Automation servers are accompanied by type libraries. In his book 
<I>Inside COM</I> (1997, Microsoft Press), Dale Rogerson describes a type library as &quot;a bag of 
information about interfaces and components.&quot; Given a type library, a client can find out 
all sorts of interesting things about a COM object, including which interfaces it 
implements, what methods are present in those interfaces, and what each method's 
parameter list looks like. A type library can be provided in a separate file (usually 
with the extension .tlb, although .olb is sometimes used instead) or as a resource 
embedded in the object's executable file. Regardless of how they're packaged, type 
libraries are registered in the registry so that clients can easily locate them.
</p>

<p>Type libraries can be used in a variety of ways. ActiveX controls, for 
example, use type information (the kind of data found in type libraries) to tell control 
containers what kinds of events they're capable of firing. Type libraries can also be used 
to implement <I>IDispatch</I> interfaces and to provide information to object browsers. 
But the big reason type libraries are important to Automation programmers is that 
they permit Visual Basic clients to access a server's Automation methods and 
properties using the custom portion of a dual interface. Given type information, today's 
Visual Basic programs can even use conventional COM objects&#8212;ones that expose their 
functionality through custom COM interfaces instead of 
<I>IDispatch</I> interfaces. Type libraries aren't only for Visual Basic users, however; C++ programmers can use them, 
too. Shortly, you'll see how you can use ClassWizard to generate wrapper classes 
that simplify the writing of MFC Automation clients. Significantly, ClassWizard can 
work its magic only if a type library is available.
</p>

<p>How do type libraries get created? You can create them programmatically 
using COM API functions and methods, but most are created from IDL files. MIDL 
will read an IDL file and produce a type library from the statements inside it. You 
can also create type libraries by defining objects and their interfaces in ODL files 
and compiling them with a special tool called MkTypeLib. IDL files are the 
preferred method, but Visual C++ still uses ODL files for MFC Automation servers. The 
following ODL statements define a type library that contains descriptions of an 
Automation component named Math and a dispinterface named 
<I>IAutoMath</I>:
</p>

<P>
<table cellpadding=5 width="95%"><tr><td>	
<PRE>[uuid (B617CC83-3C57-11D2-8E53-006008A82731), version (1.0)]
library AutoMath
{
    importlib (&quot;stdole32.tlb&quot;);

    [uuid (B617CC84-3C57-11D2-8E53-006008A82731)]
    dispinterface IAutoMath
    {
        properties:
            [id(1)] double Pi;
        methods:
            [id(2)] long Add (long a, long b);
            [id(3)] long Subtract (long a, long b);
    };

    [uuid (B617CC82-3C57-11D2-8E53-006008A82731)]
    coclass Math
    {
        [default] dispinterface IAutoMath;
    };
};
</PRE>
</td></tr></table>
</P>

<p>The <I>importlib</I> statement in ODL is analogous to 
#<I>include</I> in C++. <I>uuid</I> assigns a GUID to an object or interface, and 
<I>dispinterface</I> defines a dispinterface. Statements 
inside a <I>dispinterface</I> block declare Automation methods and properties as well as 
their dispatch IDs. The object in this example features a property named 
<I>Pi</I> and methods named <I>Add</I> and 
<I>Subtract</I>. Their dispatch IDs are 1, 2, and 3, respectively.
</p>

<p>
When you write an MFC Automation server, AppWizard creates an ODL file 
and adds it to the project. Each time a method or property is added, ClassWizard 
modifies the ODL file so that the next build will produce an up-to-date type library. 
As long as you use the MFC wizards to craft MFC Automation servers, type libraries 
are a natural consequence of the build process and require no extra effort to generate.
</p>

</BODY>
</HTML>




