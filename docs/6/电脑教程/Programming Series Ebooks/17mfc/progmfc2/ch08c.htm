<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Modeless Dialog Boxes</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch08b.htm", "ch08d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="226"><H1>Modeless Dialog Boxes</H1></A>


<P>Once you've mastered modal dialog boxes, you'll discover that modeless dialog 
boxes are just a variation on what you've already learned. Modal and modeless dialog 
boxes are more alike than they are different. The key differences between them include 
the following:
</P>

<UL> 
<P><LI>Whereas a modal dialog box is displayed by calling 
<I>CDialog::DoModal</I>, modeless dialog boxes are displayed with 
<I>CDialog::Create</I>. Unlike <I>DoModal</I>, which doesn't return until the dialog box is dismissed, 
<I>Create</I> returns as soon as the dialog box is created. Therefore, the dialog box 
is still displayed when <I>Create</I> returns.
</LI></P>


<P><LI>Modeless dialog boxes are dismissed by calling 
<I>DestroyWindow</I>, not <I>End-Dialog</I>. You mustn't 
allow <I>CDialog::OnOK</I> or 
<I>CDialog::OnCancel</I> to be called on a modeless dialog box, because both call 
<I>EndDialog</I>.
</LI></P>

<P><LI>Modal dialog classes are usually 
instantiated on the stack so that de-struction is automatic. Modeless dialog classes are instantiated with <I>new</I> so that the dialog object won't be destroyed prematurely. One way 
to ensure that the modeless dialog object is deleted when the dialog box is destroyed is to override 
<I>CDialog::PostNcDestroy</I> in the derived dialog 
class and execute a <I>delete this</I> statement.
</LI></P>
</UL>

<P>There are other differences between modal and modeless dialog boxes that 
MFC handles for you. For example, the message loop of an SDK application that uses 
a modeless dialog box must be modified to call 
<I>::IsDialogMessage</I> to forward messages to the 
dialog box. An MFC application requires no such modification 
because <I>::IsDialogMessage</I> is called automatically.
</P>

<P>In general, MFC makes dialog handling generic so that using modeless 
dialog boxes is little different than using modal dialog boxes. Let's prove it by 
converting DlgDemo1's dialog box into a modeless dialog box.
</P>

<A NAME="227"><H2>The DlgDemo2 Application</H2></A>

<P>Figure 8-8's DlgDemo2 application is functionally identical to DlgDemo1 in all 
respects but one: the Options dialog box is modeless rather than modal. Following 
convention, the OK and Cancel buttons are now labeled Apply and Close. The Apply 
button applies the settings entered in the dialog box to the rectangle but doesn't dismiss 
the dialog box. The Close button removes the dialog box from the screen and 
discards any changes, just like the Cancel button in DlgDemo1. Despite the name 
changes, the button IDs are still IDOK and IDCANCEL. This means that we can still use 
<I>OnOK</I> and <I>OnCancel</I> to process button clicks and that Enter and Esc still serve as the 
buttons' keyboard equivalents.
</P>

<P><B>Figure 8-8.</B> <I>The DlgDemo2 application.</I></P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="228"><H3>MainFrm.h</H3></A>
<PRE>// MainFrm.h : interface of the CMainFrame class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__7040DB88_9039_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_MAINFRM_H__7040DB88_9039_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#include &quot;ChildView.h&quot;

class CMainFrame : public CFrameWnd
{
    
public:
    CMainFrame();
protected: 
    DECLARE_DYNAMIC(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
        AFX_CMDHANDLERINFO* pHandlerInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif
    CChildView    m_wndView;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg void OnSetFocus(CWnd *pOldWnd);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    afx_msg LRESULT OnApply (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnDialogDestroyed (WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
};
///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(AFX_MAINFRM_H__7040DB88_9039_11D2_8E53_006008A82731__INCLUDED_)
</PRE></TD></TR>
</TABLE>
</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="229"><H3>MainFrm.cpp</H3></A>
<PRE>// MainFrm.cpp : implementation of the CMainFrame class
//

#include &quot;stdafx.h&quot;
#include &quot;DlgDemo2.h&quot;
#include &quot;OptionsDialog.h&quot;
#include &quot;MainFrm.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_SETFOCUS()
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
    ON_MESSAGE (WM_USER_APPLY, OnApply)
    ON_MESSAGE (WM_USER_DIALOG_DESTROYED, OnDialogDestroyed)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    cs.dwExStyle &amp;= ~WS_EX_CLIENTEDGE;
    cs.lpszClass = AfxRegisterWndClass(0);
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext&amp; dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
void CMainFrame::OnSetFocus(CWnd* pOldWnd)
{
    // forward focus to the view window
    m_wndView.SetFocus();
}

BOOL CMainFrame::OnCmdMsg(UINT nID, int nCode, void* pExtra,
    AFX_CMDHANDLERINFO* pHandlerInfo)
{
    // let the view have first crack at the command
    if (m_wndView.OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // otherwise, do default handling
    return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    if (!m_wndView.Create(NULL, NULL, AFX_WS_DEFAULT_VIEW,
        CRect(0, 0, 0, 0), this, AFX_IDW_PANE_FIRST, NULL))
        return -1;

    return 0;
}

LRESULT CMainFrame::OnApply (WPARAM wParam, LPARAM lParam)
{
    m_wndView.SendMessage (WM_USER_APPLY, wParam, lParam);
    return 0;
}

LRESULT CMainFrame::OnDialogDestroyed (WPARAM wParam, LPARAM lParam)
{
    m_wndView.SendMessage (WM_USER_DIALOG_DESTROYED, wParam, lParam);
    return 0;
}
</PRE></TD></TR>
</TABLE>
</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="230"><H3>ChildView.h</H3></A>
<PRE>// ChildView.h : interface of the CChildView class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDVIEW_H__7040DB8A_9039_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_CHILDVIEW_H__7040DB8A_9039_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

///////////////////////////////////////////////////////////////////////////
// CChildView window

class CChildView : public CWnd
{
// Construction
public:
    CChildView();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChildView)
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CChildView();

    // Generated message map functions
protected:
    COptionsDialog* m_pDlg;
    int m_nUnits;
    int m_nHeight;
    int m_nWidth;
    //{{AFX_MSG(CChildView)
    afx_msg void OnPaint();
    afx_msg void OnFileOptions();
    //}}AFX_MSG
    afx_msg LRESULT OnApply (WPARAM wParam, LPARAM lParam);
    afx_msg LRESULT OnDialogDestroyed (WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately
// before the previous line.

#endif 
// !defined(
//    AFX_CHILDVIEW_H__7040DB8A_9039_11D2_8E53_006008A82731__INCLUDED_)
</PRE></TD></TR>
</TABLE>
</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="231"><H3>ChildView.cpp</H3></A>
<PRE>// ChildView.cpp : implementation of the CChildView class
//

#include &quot;stdafx.h&quot;
#include &quot;DlgDemo2.h&quot;
#include &quot;OptionsDialog.h&quot;
#include &quot;ChildView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CChildView

CChildView::CChildView()
{
    m_nWidth = 4;
    m_nHeight = 2;
    m_nUnits = 0;
    m_pDlg = NULL;
}

CChildView::~CChildView()
{
}

BEGIN_MESSAGE_MAP(CChildView,CWnd )
    //{{AFX_MSG_MAP(CChildView)
    ON_WM_PAINT()
    ON_COMMAND(ID_FILE_OPTIONS, OnFileOptions)
    //}}AFX_MSG_MAP
    ON_MESSAGE (WM_USER_APPLY, OnApply)
    ON_MESSAGE (WM_USER_DIALOG_DESTROYED, OnDialogDestroyed)
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CChildView message handlers

BOOL CChildView::PreCreateWindow(CREATESTRUCT&amp; cs) 
{
    if (!CWnd::PreCreateWindow(cs))
        return FALSE;

    cs.dwExStyle &#166;= WS_EX_CLIENTEDGE;
    cs.style &amp;= ~WS_BORDER;
    cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW&#166;CS_VREDRAW&#166;CS_DBLCLKS, 
        ::LoadCursor(NULL, IDC_ARROW), HBRUSH(COLOR_WINDOW+1), NULL);

    return TRUE;
}

void CChildView::OnPaint() 
{
    CPaintDC dc(this); // Device context for painting.
    
    CBrush brush (RGB (255, 0, 255));
    CBrush* pOldBrush = dc.SelectObject (&amp;brush);

    switch (m_nUnits) {

    case 0: // Inches.
        dc.SetMapMode (MM_LOENGLISH);
        dc.Rectangle (0, 0, m_nWidth * 100, -m_nHeight * 100);
        break;

    case 1: // Centimeters.
        dc.SetMapMode (MM_LOMETRIC);
        dc.Rectangle (0, 0, m_nWidth * 100, -m_nHeight * 100);
        break;

    case 2: // Pixels.
        dc.SetMapMode (MM_TEXT);
        dc.Rectangle (0, 0, m_nWidth, m_nHeight);
        break;
    }
    dc.SelectObject (pOldBrush);
}

void CChildView::OnFileOptions() 
{
    //
    // If the dialog box already exists, display it.
    //
    if (m_pDlg != NULL)
        m_pDlg-&gt;SetFocus ();

    //
    // If the dialog box doesn't already exist, create it.
    //
    else {
        m_pDlg = new COptionsDialog;
        m_pDlg-&gt;m_nWidth = m_nWidth;
        m_pDlg-&gt;m_nHeight = m_nHeight;
        m_pDlg-&gt;m_nUnits = m_nUnits;
        m_pDlg-&gt;Create (IDD_OPTIONS);
        m_pDlg-&gt;ShowWindow (SW_SHOW);
    }
}

LRESULT CChildView::OnApply (WPARAM wParam, LPARAM lParam)
{
    RECTPROP* prp = (RECTPROP*) lParam;
    m_nWidth = prp-&gt;nWidth;
    m_nHeight = prp-&gt;nHeight;
    m_nUnits = prp-&gt;nUnits;
    Invalidate ();
    return 0;
}

LRESULT CChildView::OnDialogDestroyed (WPARAM wParam, LPARAM lParam)
{
    m_pDlg = NULL;
    return 0;
}
</PRE></TD></TR>
</TABLE>
</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="232"><H3>OptionsDialog.h</H3></A>
<PRE>#if !defined(AFX_OPTIONSDIALOG_H__7040DB90_9039_11D2_8E53_006008A82731__INCLUDED_)
#define 
AFX_OPTIONSDIALOG_H__7040DB90_9039_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000
// OptionsDialog.h : header file
//

///////////////////////////////////////////////////////////////////////////
// COptionsDialog dialog

class COptionsDialog : public CDialog
{
// Construction
public:
    COptionsDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
    //{{AFX_DATA(COptionsDialog)
    enum { IDD = IDD_OPTIONS };
    int        m_nWidth;
    int        m_nHeight;
    int        m_nUnits;
    //}}AFX_DATA

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(COptionsDialog)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    virtual void PostNcDestroy();
    //}}AFX_VIRTUAL
    virtual void OnOK ();
    virtual void OnCancel ();

// Implementation
protected:

    // Generated message map functions
    //{{AFX_MSG(COptionsDialog)
    afx_msg void OnReset();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately 
// before the previous line.

#endif 
// !defined(
//    AFX_OPTIONSDIALOG_H__7040DB90_9039_11D2_8E53_006008A82731__INCLUDED_)
</PRE></TD></TR>
</TABLE>
</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="233"><H3>OptionsDialog.cpp</H3></A>
<PRE>// OptionsDialog.cpp : implementation file
//

#include &quot;stdafx.h&quot;
#include &quot;DlgDemo2.h&quot;
#include &quot;OptionsDialog.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// COptionsDialog dialog

COptionsDialog::COptionsDialog(CWnd* pParent /*=NULL*/)
    : CDialog(COptionsDialog::IDD, pParent)
{
    //{{AFX_DATA_INIT(COptionsDialog)
    m_nWidth = 0;
    m_nHeight = 0;
    m_nUnits = -1;
    //}}AFX_DATA_INIT
}

void COptionsDialog::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(COptionsDialog)
    DDX_Text(pDX, IDC_WIDTH, m_nWidth);
    DDX_Text(pDX, IDC_HEIGHT, m_nHeight);
    DDX_Radio(pDX, IDC_INCHES, m_nUnits);
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(COptionsDialog, CDialog)
    //{{AFX_MSG_MAP(COptionsDialog)
    ON_BN_CLICKED(IDC_RESET, OnReset)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// COptionsDialog message handlers

void COptionsDialog::OnReset() 
{
    m_nWidth = 4;
    m_nHeight = 2;
    m_nUnits = 0;
    UpdateData (FALSE);    
}

void COptionsDialog::OnOK ()
{
    UpdateData (TRUE);

    RECTPROP rp;
    rp.nWidth = m_nWidth;
    rp.nHeight = m_nHeight;
    rp.nUnits = m_nUnits;
 
    AfxGetMainWnd ()-&gt;SendMessage (WM_USER_APPLY, 0, (LPARAM) &amp;rp);
}

void COptionsDialog::OnCancel ()
{
    DestroyWindow ();
}

void COptionsDialog::PostNcDestroy () 
{
    CDialog::PostNcDestroy ();
    AfxGetMainWnd ()-&gt;SendMessage (WM_USER_DIALOG_DESTROYED, 0, 0);
    delete this;
}
</PRE></TD></TR>
</TABLE>
</P>




<P>As before, the Options dialog box is invoked by selecting Options from the 
File menu. Here's the code in <I>OnFileOptions</I> that constructs the dialog object, 
initializes the dialog's data members, and creates the dialog box:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
m_pDlg = new COptionsDialog;
m_pDlg-&gt;m_nWidth = m_nWidth;
m_pDlg-&gt;m_nHeight = m_nHeight;
m_pDlg-&gt;m_nUnits = m_nUnits;
m_pDlg-&gt;Create (IDD_OPTIONS);
m_pDlg-&gt;ShowWindow (SW_SHOW);
</PRE></TD></TR></TABLE>
</P>



<P>To avoid automatic destruction, the dialog object is created on the heap rather 
than on the stack. The dialog pointer is saved in 
<I>CChildView::m_pDlg</I>, which is initialized to NULL by 
<I>CChildView</I>'s constructor and reset to NULL when the dialog box 
is destroyed. Any member function of 
<I>CChildView</I> can determine whether the dialog box is currently displayed by checking 
<I>m_pDlg</I> for a non-NULL value. This turns out to be quite useful because before creating the Options dialog box, 
<I>OnFileOptions</I> checks <I>m_pDlg</I> to see whether the dialog box is already displayed. If the answer 
is yes, <I>OnFileOptions</I> uses the 
<I>m_pDlg</I> pointer to set the focus to the existing 
dialog box rather than create a new one:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
if (m_pDlg != NULL)
    m_pDlg-&gt;SetFocus ();
</PRE></TD></TR></TABLE>
</P>


<P>Without this precaution, every invocation of File-Options would create a new 
instance of the dialog, even if other instances already existed. There's normally no reason 
to have two or more copies of the same dialog box on the screen at the same time, 
so you shouldn't allow the user to open multiple instances of a modeless dialog 
box unless circumstances warrant it.
</P>

<A NAME="234"><H3>Processing the Apply and Close Buttons</H3></A>

<P>One of the fundamental differences in implementing modal and modeless 
dialog boxes with MFC is how the dialog classes handle 
<I>OnOK</I> and <I>OnCancel</I>. A modal dialog class 
rarely overrides <I>OnCancel</I> because the default implementation in 
<I>CDialog</I> calls <I>EndDialog</I> to close the dialog box and return IDCANCEL. 
<I>OnOK</I> rarely needs to be overridden because the 
<I>CDialog</I> implementation of <I>OnOK</I> calls 
<I>UpdateData</I> to update the dialog's data members before dismissing the dialog box. If the dialog 
box's controls and data members are linked via DDX or DDV, the default action 
provided by <I>CDialog::OnOK</I> is usually sufficient.
</P>

<P>A modeless dialog box, by contrast, almost always overrides 
<I>OnOK</I> and <I>OnCancel</I>. As mentioned earlier, it's important to prevent 
<I>CDialog::OnOK</I> and <I>CDialog::OnCancel</I> from being called in a modeless dialog box because modeless dialog 
boxes are dismissed with <I>DestroyWindow</I>, not 
<I>EndDialog</I>. You should override <I>OnOK</I> if 
any button in the dialog box has the ID IDOK. You should always override 
<I>OnCancel</I> because an IDCANCEL notification is sent when the user presses the Esc key or 
clicks the dialog box's close button, regardless of whether the dialog box contains a 
Cancel button.
</P>

<P>Because clicking DlgDemo2's Apply and Close buttons generates calls to 
<I>On-OK</I> and <I>OnCancel</I>, both functions are overridden in 
<I>COptionsDialog</I>. <I>COptionsDialog::OnOK</I> contains the following statements:</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
UpdateData (TRUE);

RECTPROP rp;
rp.nWidth = m_nWidth;
rp.nHeight = m_nHeight;
rp.nUnits = m_nUnits;
 
AfxGetMainWnd ()-&gt;SendMessage (WM_USER_APPLY, 0, (LPARAM) &amp;rp);
</PRE></TD></TR></TABLE>
</P>

<P>The first statement updates the dialog's member variables to match the current 
state of the controls. A modeless dialog box that uses DDX or DDV must call 
<I>UpdateData</I> itself because calling 
<I>CDialog::OnOK</I> and letting it call 
<I>UpdateData</I> is out of the question. The next block of statements instantiates the RECTPROP structure 
declared in Stdafx.h and copies the new settings from the dialog's data members to the 
data structure. The final statement sends a message to the application's main window 
telling it to apply the settings contained in the RECTPROP structure to the dialog 
box<I>. </I>WM_USER_APPLY is a user-defined message that's defined this way in Stdafx.h:</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
#define WM_USER_APPLY WM_USER+0x100
</PRE></TD></TR></TABLE>
</P>


<P>WM_USER, which is defined as 0x400 in the header file Winuser.h, specifies the 
low end of a range of message IDs an application can use without conflicting with 
the message IDs of standard Windows messages such as WM_CREATE and 
WM_PAINT. An application is free to use message IDs from WM_USER's 0x400 through 
0x7FFF for its own purposes. Messages in this range are referred to as 
<I>user-defined messages.</I> Because dialog boxes use some message IDs in this range themselves, DlgDemo2 arbitrarily adds 0x100 to WM_USER to avoid conflicts.</P>

<P>A message transmitted with <I>SendMessage</I> includes two parameters the sender can use to pass data to the receiver: a 32-bit value of type WPARAM and another 32-bit value whose type is LPARAM. When <I>COptionsDialog::OnOK</I> sends a message to the main window, it sends along a pointer to a RECTPROP structure containing the settings retrieved from the dialog box. The main window processes the message with <I>CMainFrame::OnApply</I>, which is referenced in the message map with the following statement:</P>


<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
ON_MESSAGE (WM_USER_APPLY, OnApply);
</PRE></TD></TR></TABLE>
</P>

<P>When activated, <I>OnApply</I> forwards the message to the view:</P>



<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
LRESULT CMainFrame::OnApply (WPARAM wParam, LPARAM lParam)
{
    m_wndView.SendMessage (WM_USER_APPLY, wParam, lParam);
    return 0;
}
</PRE></TD></TR></TABLE>
</P>

<P><I>CChildView::OnApply</I>, in turn, copies the values out of the data structure and into 
its own data members. It then invalidates the view to force a repaint incorporating 
the new settings:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
LRESULT CChildView::OnApply (WPARAM wParam, LPARAM lParam)
{
    RECTPROP* prp = (RECTPROP*) lParam;
    m_nWidth = prp-&gt;nWidth;
    m_nHeight = prp-&gt;nHeight;
    m_nUnits = prp-&gt;nUnits;
    Invalidate ();
    return 0;
}
</PRE></TD></TR>
</TABLE>
</P>

<P>The value returned by a handler for a user-defined message is returned to the 
caller through <I>SendMessage</I>. DlgDemo2 attaches no meaning to the return value, so 
both <I>CMainFrame::OnApply</I> and 
<I>CChildView::OnApply</I> return 0.</P>

<P><I>COptionsDialog::OnCancel</I> contains just one statement: a call to 
<I>DestroyWindow</I> to destroy the dialog box. Ultimately, this action activates 
<I>COptionsDialog::PostNcDestroy</I>, which is implemented as follows:
</P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
void COptionsDialog::PostNcDestroy ()
{
    CDialog::PostNcDestroy ();
    AfxGetMainWnd ()-&gt;SendMessage (WM_USER_DIALOG_DESTROYED, 0, 0);
    delete this;
}
</PRE></TD></TR>
</TABLE>
</P>

<P>This <I>SendMessage</I> sends a different user-defined message to the main window. 
The main window's WM_USER_DIALOG_DESTROYED handler, 
<I>CMainFrame::OnDialogDestroyed</I>, forwards the message to the view, whose 
WM_USER_DIALOG_DESTROYED handler responds by setting 
<I>m_pDlg</I> to NULL. Its work almost done, 
<I>PostNcDestroy</I> finishes up by executing a 
<I>delete this</I> statement to delete the dialog object created by 
<I>CChildView::OnFileOptions</I>.
</P>

</BODY>
</HTML>




