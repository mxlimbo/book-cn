<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>The Colors Application</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch04d.htm", "ch05a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="137"><H1>The Colors Application</H1></A>

<P>Let's close out this chapter by writing an application that uses owner-draw 
menus and context menus. Colors is a souped-up version of Shapes that features an 
owner-draw Color menu and a context menu from which the user can select both 
shapes and colors. The items in the context menu are functional duplicates of the items 
in the Shape and Color menus and even share command and update handlers. 
The context menu appears when the user clicks the shape in the middle of the 
window with the right mouse button, as seen in Figure 4-14.
</P>

<P>
<A HREF="javascript:fullSize('F04mg14x.htm')"> <img src="images/F04mg14.JPG" width=404 height=303 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 4-14.</B> <I>The Colors window.</I><!-- /CAPTION -->
</p>

<p>
Colors' source code appears in Figure 4-15. To generate the source code, I 
used AppWizard to create a new project named Colors and then proceeded as if I 
were writing Shapes all over again by implementing 
<I>  OnPaint</I>, adding the Shape menu, writing command and update handlers, and so on. I then added the Color menu. 
Even though the menu items are assigned text strings such as &quot;&amp;Red&quot; and &quot;&amp;Blue,&quot; 
those strings are never seen because the menu is owner-draw. The code that converts 
the items in the menu into owner-draw items is found in 
<I>  InitInstance</I>:
</p>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CMenu* pMenu = pFrame-&gt;GetMenu ();
ASSERT (pMenu != NULL);

for (int i=0; i&lt;5; i++)
    pMenu-&gt;ModifyMenu (ID_COLOR_RED + i, MF_OWNERDRAW, 
        ID_COLOR_RED + i);
</PRE></TD></TR></TABLE></P>

<P>The first statement initializes <I>  pMenu</I> with a pointer to a 
<I>  CMenu</I> object representing the main menu. 
<I>  ModifyMenu</I> is then called five times in succession to tag the 
items in the Color menu with the flag MF_OWNERDRAW.

</p>

<p><B>Figure 4-15.</B> <I>The Colors program.</I></p>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="138"><H3>Colors.h</H3></A>
<PRE>// Colors.h : main header file for the COLORS application
//

#if !defined(AFX_COLORS_H__1B036BE8_5C6F_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_COLORS_H__1B036BE8_5C6F_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#ifndef __AFXWIN_H__
    #error include `stdafx.h' before including this file for PCH
#endif

#include &quot;resource.h&quot;       // main symbols

///////////////////////////////////////////////////////////////////////////
// CColorsApp:
// See Colors.cpp for the implementation of this class
//

class CColorsApp : public CWinApp
{
public:
    CColorsApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CColorsApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation

public:
    //{{AFX_MSG(CColorsApp)
    afx_msg void OnAppAbout();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
</pre></TD></TR></TABLE></P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately 
// before the previous line.

#endif 
// !defined(AFX_COLORS_H__1B036BE8_5C6F_11D2_8E53_006008A82731__INCLUDED_)
</PRE></TD></TR></TABLE></P>




<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="139"><H3>Colors.cpp</H3></A>
<PRE>// Colors.cpp : Defines the class behaviors for the application.
//

#include &quot;stdafx.h&quot;
#include &quot;Colors.h&quot;

#include &quot;MainFrm.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CColorsApp

BEGIN_MESSAGE_MAP(CColorsApp, CWinApp)
    //{{AFX_MSG_MAP(CColorsApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CColorsApp construction

CColorsApp::CColorsApp()
{
}

///////////////////////////////////////////////////////////////////////////
// The one and only CColorsApp object

CColorsApp theApp;

///////////////////////////////////////////////////////////////////////////
// CColorsApp initialization

BOOL CColorsApp::InitInstance()
{
    // Standard initialization

    // Change the registry key under which our settings are stored.
    SetRegistryKey(_T(&quot;Local AppWizard-Generated Applications&quot;));

    CMainFrame* pFrame = new CMainFrame;
    m_pMainWnd = pFrame;

    // create and load the frame with its resources

    pFrame-&gt;LoadFrame(IDR_MAINFRAME,
        WS_OVERLAPPEDWINDOW &#166; FWS_ADDTOTITLE, NULL,
        NULL);

    pFrame-&gt;ShowWindow(SW_SHOW);
    pFrame-&gt;UpdateWindow();

    //
    // Convert the items in the Color menu to owner-draw.
    //
    CMenu* pMenu = pFrame-&gt;GetMenu ();
    ASSERT (pMenu != NULL);

    for (int i=0; i&lt;5; i++)
        pMenu-&gt;ModifyMenu (ID_COLOR_RED + i, MF_OWNERDRAW, 
            ID_COLOR_RED + i);

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CColorsApp message handlers





///////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CColorsApp::OnAppAbout()
{
    CAboutDlg aboutDlg;
    aboutDlg.DoModal();
}

///////////////////////////////////////////////////////////////////////////
// CColorsApp message handlers
</pre></TD></TR></TABLE>
</P>



<p>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="140"><H3>MainFrm.h</H3></A>
<PRE>
// MainFrm.h : interface of the CMainFrame class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__1B036BEC_5C6F_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_MAINFRM_H__1B036BEC_5C6F_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#include &quot;ChildView.h&quot;

class CMainFrame : public CFrameWnd
{
    
public:
    CMainFrame();
protected: 
    DECLARE_DYNAMIC(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, 
        AFX_CMDHANDLERINFO* pHandlerInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif
    CChildView    m_wndView;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg void OnSetFocus(CWnd *pOldWnd);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    afx_msg void OnMeasureItem (int nIDCtl, LPMEASUREITEMSTRUCT lpmis);
    afx_msg void OnDrawItem (int nIDCtl, LPDRAWITEMSTRUCT lpdis);
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately 
// before the previous line.

#endif 
// !defined(AFX_MAINFRM_H__1B036BEC_5C6F_11D2_8E53_006008A82731__INCLUDED_)
</pre></TD></TR></TABLE>
</P>

<p>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="141"><H3>MainFrm.cpp</H3></A>
<PRE>// MainFrm.cpp : implementation of the CMainFrame class
//

#include &quot;stdafx.h&quot;
#include &quot;Colors.h&quot;

#include &quot;MainFrm.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE

static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_SETFOCUS()
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
    ON_WM_MEASUREITEM ()
    ON_WM_DRAWITEM ()
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    cs.dwExStyle &amp;= ~WS_EX_CLIENTEDGE;
    cs.lpszClass = AfxRegisterWndClass(0);
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext&amp; dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
void CMainFrame::OnSetFocus(CWnd* pOldWnd)
{
    // forward focus to the view window
    m_wndView.SetFocus();
}

BOOL CMainFrame::OnCmdMsg(UINT nID, int nCode, void* pExtra, 
    AFX_CMDHANDLERINFO* pHandlerInfo)
{
    // let the view have first crack at the command
    if (m_wndView.OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // otherwise, do default handling
    return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}


int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    if (!m_wndView.Create(NULL, NULL, AFX_WS_DEFAULT_VIEW,
        CRect(0, 0, 0, 0), this, AFX_IDW_PANE_FIRST, NULL))
    {
        TRACE0(&quot;Failed to create view window\n&quot;);
        return -1;
    }
    return 0;
}

void CMainFrame::OnMeasureItem (int nIDCtl, LPMEASUREITEMSTRUCT lpmis)
{
    lpmis-&gt;itemWidth = ::GetSystemMetrics (SM_CYMENU) * 4;
    lpmis-&gt;itemHeight = ::GetSystemMetrics (SM_CYMENU);
}

void CMainFrame::OnDrawItem (int nIDCtl, LPDRAWITEMSTRUCT lpdis)
{
    BITMAP bm;
    CBitmap bitmap;
    bitmap.LoadOEMBitmap (OBM_CHECK);
    bitmap.GetObject (sizeof (bm), &amp;bm);

    CDC dc;
    dc.Attach (lpdis-&gt;hDC);

    CBrush* pBrush = new CBrush (::GetSysColor ((lpdis-&gt;itemState &amp;
        ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_MENU));
    dc.FrameRect (&amp;(lpdis-&gt;rcItem), pBrush);
    delete pBrush;

    if (lpdis-&gt;itemState &amp; ODS_CHECKED) {
        CDC dcMem;
        dcMem.CreateCompatibleDC (&amp;dc);
        CBitmap* pOldBitmap = dcMem.SelectObject (&amp;bitmap);

        dc.BitBlt (lpdis-&gt;rcItem.left + 4, lpdis-&gt;rcItem.top +
            (((lpdis-&gt;rcItem.bottom - lpdis-&gt;rcItem.top) -
            bm.bmHeight) / 2), bm.bmWidth, bm.bmHeight, &amp;dcMem,
            0, 0, SRCCOPY);

        dcMem.SelectObject (pOldBitmap);
    }

    UINT itemID = lpdis-&gt;itemID &amp; 0xFFFF; // Fix for Win95 bug.
    pBrush = new CBrush (m_wndView.m_clrColors[itemID - ID_COLOR_RED]);
    CRect rect = lpdis-&gt;rcItem;
    rect.DeflateRect (6, 4);
    rect.left += bm.bmWidth;
    dc.FillRect (rect, pBrush);
    delete pBrush;

    dc.Detach ();
}
</pre></TD></TR></TABLE></P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="142"><H3>ChildView.h</H3></A>
<PRE>// ChildView.h : interface of the CChildView class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDVIEW_H__1B036BEE_5C6F_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_CHILDVIEW_H__1B036BEE_5C6F_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

///////////////////////////////////////////////////////////////////////////
// CChildView window

class CChildView : public CWnd
{
// Construction
public:
    CChildView();

// Attributes
public:
    static const COLORREF m_clrColors[5];

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChildView)
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CChildView();

    // Generated message map functions
protected:
    int m_nColor;
    int m_nShape;
    //{{AFX_MSG(CChildView)
    afx_msg void OnPaint();
    afx_msg void OnShapeCircle();
    afx_msg void OnShapeTriangle();
    afx_msg void OnShapeSquare();
    afx_msg void OnUpdateShapeCircle(CCmdUI* pCmdUI);
    afx_msg void OnUpdateShapeTriangle(CCmdUI* pCmdUI);
    afx_msg void OnUpdateShapeSquare(CCmdUI* pCmdUI);
    afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
    //}}AFX_MSG
    afx_msg void OnColor (UINT nID);
    afx_msg void OnUpdateColor (CCmdUI* pCmdUI);
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately 
// before the previous line.

#endif 
//!defined(AFX_CHILDVIEW_H__1B036BEE_5C6F_11D2_8E53_006008A82731__INCLUDED_)
</pre></TD></TR></TABLE></P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="143"><H3>ChildView.cpp</H3></A>
<PRE>// ChildView.cpp : implementation of the CChildView class
//

#include &quot;stdafx.h&quot;
#include &quot;Colors.h&quot;
#include &quot;ChildView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CChildView

CChildView::CChildView()
{
    m_nShape = 1; // Triangle
    m_nColor = 0; // Red
}

CChildView::~CChildView()
{
}

BEGIN_MESSAGE_MAP(CChildView,CWnd )
    //{{AFX_MSG_MAP(CChildView)
    ON_WM_PAINT()
    ON_COMMAND(ID_SHAPE_CIRCLE, OnShapeCircle)
    ON_COMMAND(ID_SHAPE_TRIANGLE, OnShapeTriangle)
    ON_COMMAND(ID_SHAPE_SQUARE, OnShapeSquare)
    ON_UPDATE_COMMAND_UI(ID_SHAPE_CIRCLE, OnUpdateShapeCircle)
    ON_UPDATE_COMMAND_UI(ID_SHAPE_TRIANGLE, OnUpdateShapeTriangle)
    ON_UPDATE_COMMAND_UI(ID_SHAPE_SQUARE, OnUpdateShapeSquare)
    ON_WM_CONTEXTMENU()
    //}}AFX_MSG_MAP
    ON_COMMAND_RANGE (ID_COLOR_RED, ID_COLOR_BLUE, OnColor)
    ON_UPDATE_COMMAND_UI_RANGE (ID_COLOR_RED, ID_COLOR_BLUE, OnUpdateColor)
END_MESSAGE_MAP()

const COLORREF CChildView::m_clrColors[5] = {
    RGB ( 255,   0,   0), // Red
    RGB ( 255, 255,   0), // Yellow
    RGB (   0, 255,   0), // Green
    RGB (   0, 255, 255), // Cyan
    RGB (   0,   0, 255)  // Blue
};

///////////////////////////////////////////////////////////////////////////
// CChildView message handlers

BOOL CChildView::PreCreateWindow(CREATESTRUCT&amp; cs) 
{
    if (!CWnd::PreCreateWindow(cs))
        return FALSE;

    cs.dwExStyle &#166;= WS_EX_CLIENTEDGE;
    cs.style &amp;= ~WS_BORDER;
    cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW&#166;CS_VREDRAW&#166;CS_DBLCLKS, 
        ::LoadCursor(NULL, IDC_ARROW), HBRUSH(COLOR_WINDOW+1), NULL);

    return TRUE;
}

void CChildView::OnPaint() 
{
    CPoint points[3];
    CPaintDC dc(this);
    
    CRect rcClient;
    GetClientRect (&amp;rcClient);
    int cx = rcClient.Width () / 2;
    int cy = rcClient.Height () / 2;
    CRect rcShape (cx - 45, cy - 45, cx + 45, cy + 45);

    CBrush brush (m_clrColors[m_nColor]);
    CBrush* pOldBrush = dc.SelectObject (&amp;brush);

    switch (m_nShape) {    

    case 0: // Circle
        dc.Ellipse (rcShape);
        break;

    case 1: // Triangle
        points[0].x = cx - 45;
        points[0].y = cy + 45;
        points[1].x = cx;
        points[1].y = cy - 45;
        points[2].x = cx + 45;
        points[2].y = cy + 45;
        dc.Polygon (points, 3);
        break;

    case 2: // Square
        dc.Rectangle (rcShape);
        break;
    }
    dc.SelectObject (pOldBrush);
}

void CChildView::OnShapeCircle() 
{
    m_nShape = 0;
    Invalidate ();    
}

void CChildView::OnShapeTriangle() 
{
    m_nShape = 1;
    Invalidate ();    
}

void CChildView::OnShapeSquare() 
{
    m_nShape = 2;
    Invalidate ();    
}

void CChildView::OnUpdateShapeCircle(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;SetCheck (m_nShape == 0);    
}

void CChildView::OnUpdateShapeTriangle(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;SetCheck (m_nShape == 1);    
}

void CChildView::OnUpdateShapeSquare(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;SetCheck (m_nShape == 2);    
}

void CChildView::OnColor (UINT nID)
{
    m_nColor = nID - ID_COLOR_RED;
    Invalidate ();
}

void CChildView::OnUpdateColor (CCmdUI* pCmdUI)
{
    pCmdUI-&gt;SetCheck ((int) pCmdUI-&gt;m_nID - ID_COLOR_RED == m_nColor);
}

void CChildView::OnContextMenu(CWnd* pWnd, CPoint point) 
{
    CRect rcClient;
    GetClientRect (&amp;rcClient);

    int cx = rcClient.Width () / 2;
    int cy = rcClient.Height () / 2;
    CRect rcShape (cx - 45, cy - 45, cx + 45, cy + 45);
    
    CPoint pos = point;
    ScreenToClient (&amp;pos);

    CPoint points[3];
    BOOL bShapeClicked = FALSE;
    int dx, dy;

    //
    // Hit test the shape.
    //
    switch (m_nShape) {
    case 0: // Circle
        dx = pos.x - cx;
        dy = pos.y - cy;
        if ((dx * dx) + (dy * dy) &lt;= (45 * 45))
            bShapeClicked = TRUE;
        break;

    case 1: // Triangle
        if (rcShape.PtInRect (pos)) {
            dx = min (pos.x - rcShape.left, rcShape.right - pos.x);
            if ((rcShape.bottom - pos.y) &lt; (2 * dx))
                bShapeClicked = TRUE;
        }
        break;

    case 2: // Square
        if (rcShape.PtInRect (pos))
            bShapeClicked = TRUE;
        break;
    }

    //
    // Display a context menu if the shape was clicked.
    //
    if (bShapeClicked) {
        CMenu menu;
        menu.LoadMenu (IDR_CONTEXTMENU);
        CMenu* pContextMenu = menu.GetSubMenu (0);

        for (int i=0; i&lt;5; i++)
            pContextMenu-&gt;ModifyMenu (ID_COLOR_RED + i,
                MF_BYCOMMAND &#166; MF_OWNERDRAW, ID_COLOR_RED + i);

        pContextMenu-&gt;TrackPopupMenu (TPM_LEFTALIGN &#166; TPM_LEFTBUTTON &#166;
            TPM_RIGHTBUTTON, point.x, point.y, AfxGetMainWnd ());
        return;
    }

    //
    // Call the base class if the shape was not clicked.
    //
    CWnd::OnContextMenu (pWnd, point);
}
</pre></TD></TR></TABLE></P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="144"><H3>Resource.h</H3></A>
<PRE>
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Colors.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_COLORSTYPE                  129
#define IDR_CONTEXTMENU                 130
#define ID_SHAPE_CIRCLE                 32771
#define ID_SHAPE_TRIANGLE               32772
#define ID_SHAPE_SQUARE                 32773
#define ID_COLOR_RED                    32774
#define ID_COLOR_YELLOW                 32775
#define ID_COLOR_GREEN                  32776
#define ID_COLOR_CYAN                   32777
#define ID_COLOR_BLUE                   32778

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        131
#define _APS_NEXT_COMMAND_VALUE         32779
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
</pre></TD></TR></TABLE></P>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD>
<A NAME="145"><H3>Colors.rc</H3></A>
<PRE>//Microsoft Developer Studio generated resource script.

//
#include &quot;resource.h&quot;

#define APSTUDIO_READONLY_SYMBOLS
///////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 2 resource.
//
#include &quot;afxres.h&quot;

///////////////////////////////////////////////////////////////////////////
#undef APSTUDIO_READONLY_SYMBOLS

///////////////////////////////////////////////////////////////////////////
// English (U.S.) resources

#if !defined(AFX_RESOURCE_DLL) &#166;&#166; defined(AFX_TARG_ENU)
#ifdef _WIN32
LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
#pragma code_page(1252)
#endif //_WIN32

#ifdef APSTUDIO_INVOKED
///////////////////////////////////////////////////////////////////////////
//
// TEXTINCLUDE
//

1 TEXTINCLUDE DISCARDABLE 
BEGIN
    &quot;resource.h\0&quot;
END

2 TEXTINCLUDE DISCARDABLE 
BEGIN
    &quot;#include &quot;&quot;afxres.h&quot;&quot;\r\n&quot;
    &quot;\0&quot;
END

3 TEXTINCLUDE DISCARDABLE 
BEGIN
    &quot;#define _AFX_NO_SPLITTER_RESOURCES\r\n&quot;
    &quot;#define _AFX_NO_OLE_RESOURCES\r\n&quot;
    &quot;#define _AFX_NO_TRACKER_RESOURCES\r\n&quot;
    &quot;#define _AFX_NO_PROPERTY_RESOURCES\r\n&quot;
    &quot;\r\n&quot;
    &quot;#if !defined(AFX_RESOURCE_DLL) &#166;&#166; defined(AFX_TARG_ENU)\r\n&quot;
    &quot;#ifdef _WIN32\r\n&quot;
    &quot;LANGUAGE 9, 1\r\n&quot;
    &quot;#pragma code_page(1252)\r\n&quot;
    &quot;#endif //_WIN32\r\n&quot;
    &quot;#include &quot;&quot;res\\Colors.rc2&quot;
        &quot;  // non-Microsoft Visual C++ edited resources\r\n&quot;
    &quot;#include &quot;&quot;afxres.rc&quot;&quot;         // Standard components\r\n&quot;
    &quot;#endif\r\n&quot;
    &quot;\0&quot;
END

#endif    // APSTUDIO_INVOKED


///////////////////////////////////////////////////////////////////////////
//
// Icon
//

// Icon with lowest ID value placed first to ensure application icon
// remains consistent on all systems.
IDR_MAINFRAME           ICON    DISCARDABLE     &quot;res\\Colors.ico&quot;

///////////////////////////////////////////////////////////////////////////
//
// Menu
//

IDR_MAINFRAME MENU PRELOAD DISCARDABLE 
BEGIN
    POPUP &quot;&amp;File&quot;
    BEGIN
        MENUITEM &quot;E&amp;xit&quot;,                       ID_APP_EXIT
    END
    POPUP &quot;&amp;Shape&quot;
    BEGIN
        MENUITEM &quot;&amp;Circle\tF7&quot;,                 ID_SHAPE_CIRCLE
        MENUITEM &quot;&amp;Triangle\tF8&quot;,               ID_SHAPE_TRIANGLE
        MENUITEM &quot;&amp;Square\tF9&quot;,                 ID_SHAPE_SQUARE
    END
    POPUP &quot;&amp;Color&quot;
    BEGIN
        MENUITEM &quot;&amp;Red&quot;,                        ID_COLOR_RED
        MENUITEM &quot;&amp;Yellow&quot;,                     ID_COLOR_YELLOW
        MENUITEM &quot;&amp;Green&quot;,                      ID_COLOR_GREEN
        MENUITEM &quot;&amp;Cyan&quot;,                       ID_COLOR_CYAN
        MENUITEM &quot;&amp;Blue&quot;,                       ID_COLOR_BLUE
    END
END

IDR_CONTEXTMENU MENU DISCARDABLE 
BEGIN
    POPUP &quot;Top&quot;
    BEGIN
        MENUITEM &quot;&amp;Circle\tF7&quot;,                 ID_SHAPE_CIRCLE
        MENUITEM &quot;&amp;Triangle\tF8&quot;,               ID_SHAPE_TRIANGLE
        MENUITEM &quot;&amp;Square\tF9&quot;,                 ID_SHAPE_SQUARE
        MENUITEM SEPARATOR
        MENUITEM &quot;&amp;Red&quot;,                        ID_COLOR_RED
        MENUITEM &quot;&amp;Yellow&quot;,                     ID_COLOR_YELLOW
        MENUITEM &quot;&amp;Green&quot;,                      ID_COLOR_GREEN
        MENUITEM &quot;&amp;Cyan&quot;,                       ID_COLOR_CYAN
        MENUITEM &quot;&amp;Blue&quot;,                       ID_COLOR_BLUE
    END
END


///////////////////////////////////////////////////////////////////////////
//
// Accelerator
//

IDR_MAINFRAME ACCELERATORS PRELOAD MOVEABLE PURE 
BEGIN
    &quot;B&quot;,            ID_COLOR_BLUE,          VIRTKEY, CONTROL, NOINVERT
    &quot;C&quot;,            ID_COLOR_CYAN,          VIRTKEY, CONTROL, NOINVERT
    &quot;G&quot;,            ID_COLOR_GREEN,         VIRTKEY, CONTROL, NOINVERT
    &quot;R&quot;,            ID_COLOR_RED,           VIRTKEY, CONTROL, NOINVERT
    VK_F7,          ID_SHAPE_CIRCLE,        VIRTKEY, NOINVERT
    VK_F8,          ID_SHAPE_TRIANGLE,      VIRTKEY, NOINVERT
    VK_F9,          ID_SHAPE_SQUARE,        VIRTKEY, NOINVERT
    &quot;Y&quot;,            ID_COLOR_YELLOW,        VIRTKEY, CONTROL, NOINVERT
END


///////////////////////////////////////////////////////////////////////////
//
// Dialog
//

IDD_ABOUTBOX DIALOG DISCARDABLE  0, 0, 235, 55
STYLE DS_MODALFRAME &#166; WS_POPUP &#166; WS_CAPTION &#166; WS_SYSMENU
CAPTION &quot;About Colors&quot;
FONT 8, &quot;MS Sans Serif&quot;
BEGIN
    ICON            IDR_MAINFRAME,IDC_STATIC,11,17,20,20
    LTEXT           &quot;Colors Version 1.0&quot;,IDC_STATIC,40,10,119,8,SS_NOPREFIX
    LTEXT           &quot;Copyright (C) 1998&quot;,IDC_STATIC,40,25,119,8
    DEFPUSHBUTTON   &quot;OK&quot;,IDOK,178,7,50,14,WS_GROUP
END


#ifndef _MAC
///////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION 1,0,0,1
 PRODUCTVERSION 1,0,0,1
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS 0x1L
#else
 FILEFLAGS 0x0L
#endif
 FILEOS 0x4L
 FILETYPE 0x1L
 FILESUBTYPE 0x0L
BEGIN
    BLOCK &quot;StringFileInfo&quot;
    BEGIN
        BLOCK &quot;040904B0&quot;
        BEGIN
            VALUE &quot;CompanyName&quot;, &quot;\0&quot;
            VALUE &quot;FileDescription&quot;, &quot;Colors MFC Application\0&quot;
            VALUE &quot;FileVersion&quot;, &quot;1, 0, 0, 1\0&quot;
            VALUE &quot;InternalName&quot;, &quot;Colors\0&quot;
            VALUE &quot;LegalCopyright&quot;, &quot;Copyright (C) 1998\0&quot;
            VALUE &quot;LegalTrademarks&quot;, &quot;\0&quot;
            VALUE &quot;OriginalFilename&quot;, &quot;Colors.EXE\0&quot;
            VALUE &quot;ProductName&quot;, &quot;Colors Application\0&quot;
            VALUE &quot;ProductVersion&quot;, &quot;1, 0, 0, 1\0&quot;
        END
    END
    BLOCK &quot;VarFileInfo&quot;
    BEGIN
        VALUE &quot;Translation&quot;, 0x409, 1200
    END
END

#endif    // !_MAC

///////////////////////////////////////////////////////////////////////////
//
// DESIGNINFO
//

#ifdef APSTUDIO_INVOKED
GUIDELINES DESIGNINFO DISCARDABLE 
BEGIN
    IDD_ABOUTBOX, DIALOG
    BEGIN
        LEFTMARGIN, 7
        RIGHTMARGIN, 228
        TOPMARGIN, 7
        BOTTOMMARGIN, 48
    END
END
#endif    // APSTUDIO_INVOKED


///////////////////////////////////////////////////////////////////////////
//
// String Table
//

STRINGTABLE PRELOAD DISCARDABLE 
BEGIN
    IDR_MAINFRAME           &quot;Colors&quot;
END

STRINGTABLE PRELOAD DISCARDABLE 
BEGIN
    AFX_IDS_APP_TITLE       &quot;Colors&quot;
    AFX_IDS_IDLEMESSAGE     &quot;Ready&quot;
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_INDICATOR_EXT        &quot;EXT&quot;
    ID_INDICATOR_CAPS       &quot;CAP&quot;
    ID_INDICATOR_NUM        &quot;NUM&quot;
    ID_INDICATOR_SCRL       &quot;SCRL&quot;
    ID_INDICATOR_OVR        &quot;OVR&quot;
    ID_INDICATOR_REC        &quot;REC&quot;
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_APP_ABOUT            &quot;Display program information, version number and copyright\nAbout&quot;
    ID_APP_EXIT             &quot;Quit the application; prompts to save documents\nExit&quot;
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_NEXT_PANE            &quot;Switch to the next window pane\nNext Pane&quot;
    ID_PREV_PANE            &quot;Switch back to the previous window pane\nPrevious Pane&quot;
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_WINDOW_SPLIT         &quot;Split the active window into panes\nSplit&quot;
END

STRINGTABLE DISCARDABLE 
BEGIN
    ID_EDIT_CLEAR           &quot;Erase the selection\nErase&quot;
    ID_EDIT_CLEAR_ALL       &quot;Erase everything\nErase All&quot;
    ID_EDIT_COPY            &quot;Copy the selection and put it on the Clipboard\nCopy&quot;
    ID_EDIT_CUT             &quot;Cut the selection and put it on the Clipboard\nCut&quot;
    ID_EDIT_FIND            &quot;Find the specified text\nFind&quot;
    ID_EDIT_PASTE           &quot;Insert Clipboard contents\nPaste&quot;
    ID_EDIT_REPEAT          &quot;Repeat the last action\nRepeat&quot;
    ID_EDIT_REPLACE         &quot;Replace specific text with different text\nReplace&quot;
    ID_EDIT_SELECT_ALL      &quot;Select the entire document\nSelect All&quot;
    ID_EDIT_UNDO            &quot;Undo the last action\nUndo&quot;
    ID_EDIT_REDO            &quot;Redo the previously undone action\nRedo&quot;
END

STRINGTABLE DISCARDABLE 
BEGIN
    AFX_IDS_SCSIZE          &quot;Change the window size&quot;
    AFX_IDS_SCMOVE          &quot;Change the window position&quot;
    AFX_IDS_SCMINIMIZE      &quot;Reduce the window to an icon&quot;
    AFX_IDS_SCMAXIMIZE      &quot;Enlarge the window to full size&quot;
    AFX_IDS_SCNEXTWINDOW    &quot;Switch to the next document window&quot;
    AFX_IDS_SCPREVWINDOW    &quot;Switch to the previous document window&quot;
    AFX_IDS_SCCLOSE         &quot;Close the active window and prompts to save the documents&quot;
END

STRINGTABLE DISCARDABLE 
BEGIN
    AFX_IDS_SCRESTORE       &quot;Restore the window to normal size&quot;
    AFX_IDS_SCTASKLIST      &quot;Activate Task List&quot;
END

#endif    // English (U.S.) resources
///////////////////////////////////////////////////////////////////////////



#ifndef APSTUDIO_INVOKED
///////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define _AFX_NO_SPLITTER_RESOURCES
#define _AFX_NO_OLE_RESOURCES
#define _AFX_NO_TRACKER_RESOURCES
#define _AFX_NO_PROPERTY_RESOURCES

#if !defined(AFX_RESOURCE_DLL) &#166;&#166; defined(AFX_TARG_ENU)
#ifdef _WIN32
LANGUAGE 9, 1
#pragma code_page(1252)
#endif //_WIN32
#include &quot;res\Colors.rc2&quot;  // non-Microsoft Visual C++ edited resources
#include &quot;afxres.rc&quot;         // Standard components
#endif

///////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
</pre></TD></TR></TABLE></P>

<P>Because the frame window is the menu's owner, the frame window 
receives the WM_MEASUREITEM and WM_DRAWITEM messages that the owner-draw 
items generate. Therefore, the message handlers appear in the frame window 
class. <I>  CMainFrame::OnMeasureItem</I> contains just two statements: one specifying the 
height of each menu item (the SM_CYMENU value returned by 
<I>  ::GetSystemMetrics</I>), the other specifying the width (SM_CYMENU*4). 
<I>  CMainFrame::OnDrawItem</I> is a bit more complicated because it's responsible for doing the actual drawing. After doing some 
preliminary work involving a <I>  CBitmap</I> object that we'll discuss in a moment, 
<I>  OnDrawItem</I> constructs an empty <I>  CDC</I> object and attaches to it the device context handle 
provided in the DRAWITEMSTRUCT structure using 
<I>  CDC::Attach</I>:

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CDC dc;
dc.Attach (lpdis-&gt;hDC);
</PRE></TD></TR></TABLE></P>


<P>This converts <I>  dc</I> into a valid device context object that wraps the 
Windows-provided device context. That device context should be returned to Windows in the same 
state in which it was received. Objects selected into the device context should be 
selected back out, and any changes made to the state of the device context (for example, 
to the background mode or the text color) should be undone before 
<I>  OnDrawItem</I> ends.
</p>

<p>
Next, <I>  OnDrawItem</I> creates a brush whose color is either COLOR_MENU 
or COLOR_HIGHLIGHT, depending on whether the ODS_SELECTED bit in the 
<I>  itemState</I> field is set. Then it outlines the menu item with a rectangle by calling 
<I>  CDC::FrameRect</I> with a pointer to the brush:

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CBrush* pBrush = new CBrush (::GetSysColor ((lpdis-&gt;itemState &amp;
    ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_MENU));
dc.FrameRect (&amp;(lpdis-&gt;rcItem), pBrush);
delete pBrush;
</PRE></TD></TR></TABLE></P>
</P>

<P>COLOR_MENU is the default menu background color; COLOR_HIGHLIGHT is 
the color of a menu's highlight bar. 
<I>  CDC::FrameRect</I> uses the specified brush to draw 
a rectangle with lines 1 pixel wide. The code above draws a rectangle around the 
menu item in the background color if the item isn't selected or in the highlight color if it 
is. This is the rectangle you see when you pull down the Color menu and move the 
mouse up and down. Drawing the rectangle in the background color if the 
ODS_SELECTED bit is clear erases the selection rectangle when the highlight passes from one item 
to another.
</p>

<p>
<I>  OnDrawItem</I>'s next task is to draw a check mark next to the menu item if 
the ODS_CHECKED bit is set. Unfortunately, drawing check marks is a detail you 
have to take care of yourself when you use owner-draw menus. More unfortunate 
still, neither MFC nor the Windows API has a 
<I>  DrawCheckMark</I> function that would make drawing a check mark easy. The alternative is to create a bitmap depicting the 
check mark and use <I>  CDC::BitBlt</I> to &quot;blit&quot; the check mark to the screen. Blitting is 
discussed in detail in <a href="ch15a.htm">Chapter 15</a>, but even without that background preparation, the 
<I>  OnDrawItem</I> code that draws a check mark if ODS_CHECKED is set is relatively easy to understand:

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
CDC dcMem;
dcMem.CreateCompatibleDC (&amp;dc);
CBitmap* pOldBitmap = dcMem.SelectObject (&amp;bitmap);

dc.BitBlt (lpdis-&gt;rcItem.left + 4, lpdis-&gt;rcItem.top +
    (((lpdis-&gt;rcItem.bottom - lpdis-&gt;rcItem.top) - 
    bm.bmHeight) / 2), bm.bmWidth, bm.bmHeight, &amp;dcMem, 
    0, 0, SRCCOPY);

dcMem.SelectObject (pOldBitmap);
</PRE></TD></TR></TABLE></P>
</P>

<P><I>  dcMem</I> represents a memory device context (DC)&#8212;a virtual display surface in 
memory that can be drawn to as if it were a screen or other output device. 
<I>  CreateCompatibleDC</I> creates a memory DC. Windows doesn't let you blit bitmaps directly to a 
display surface, so instead you must select the bitmap into a memory DC and copy it to 
the screen DC. In this example, <I>  BitBlt</I> copies the bitmap from the memory DC to a 
location near the left end of the rectangle described by 
<I>  lpdis-&gt;rcItem</I> in the screen DC. When 
<I>  BitBlt</I> returns, the bitmap is selected out of the memory DC in preparation for 
the memory DC to be destroyed when <I>  dcMem</I> goes out of scope.
</p>

<p>Where does the bitmap come from? The first four statements in 
<I>  OnDrawItem</I> create an empty <I>  CBitmap</I> object, initialize it with the bitmap that Windows uses 
to draw menu check marks, and copy information about the bitmap (including its 
width and height) to a BITMAP structure:
</p>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
BITMAP bm;
CBitmap bitmap;
bitmap.LoadOEMBitmap (OBM_CHECK);
bitmap.GetObject (sizeof (bm), &amp;bm);
</PRE></TD></TR></TABLE></P>
</P>

<P>OBM_CHECK is the bitmap ID; 
<I>  CBitmap::LoadOEMBitmap</I> copies the bitmap to 
a <I>  CBitmap</I> object. <I>  CBitmap::GetObject</I> copies information about the bitmap to a 
BITMAP structure, and the width and height values stored in the structure's 
<I>  bmWidth</I> and <I>  bmHeight</I> fields are used in the call to 
<I>  BitBlt</I>. <I>  bmWidth</I> is used again toward the 
end of <I>  OnDrawItem</I> to indent the left end of each color swatch by an amount that 
equals the width of the check mark. For OBM_CHECK to be recognized, the statement

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
#define OEMRESOURCE
</PRE></TD></TR></TABLE></P>

<P>must appear before the statement that includes Afxwin.h. In Colors, you'll find 
the #define in StdAfx.h.</p>

<p>
After the selection rectangle is drawn or erased and the check mark is drawn 
if the ODS_CHECKED bit is set, <I>  OnDrawItem</I> draws the colored rectangle 
representing the menu item itself. To do so, it creates a solid brush, creates a 
<I>  CRect</I> object from the <I>  rcItem</I> structure passed in DRAWITEMSTRUCT, shrinks the rectangle a few 
pixels, and paints the rectangle using 
<I>  CDC::FillRect</I>:

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
UINT itemID = lpdis-&gt;itemID &amp; 0xFFFF; // Fix for Win95 bug.
pBrush = new CBrush (m_wndView.m_clrColors[itemID - ID_COLOR_RED]);
CRect rect = lpdis-&gt;rcItem;
rect.DeflateRect (6, 4);
rect.left += bm.bmWidth;
dc.FillRect (rect, pBrush);
delete pBrush;
</PRE></TD></TR></TABLE></P>
</P>

<P><I>  CDC::FillRect</I> is yet another <I>  CDC</I> rectangle function. It fills the interior of the 
rectangle with a specified brush rather than with the brush selected into the device 
context, and it doesn't outline the rectangle with the current pen. Using 
<I>  FillRect</I> rather than <I>  Rectangle</I> prevents us from having to select a pen and a brush into the device 
context and select them back out again when we're done. The color of the brush passed 
to <I>  FillRect</I> is determined by subtracting ID_COLOR_RED from the menu item ID 
supplied in <I>  lpdis-&gt;itemID</I> and using the result as an index into the view object's 
<I>  m_clrColors</I> array.
</P>

<P>Speaking of <I>  lpdis-&gt;itemID</I>: Observe that the code fragment in the 
previous paragraph ANDs the item ID with 0xFFFF. This is done to work around a bug 
in Windows 95. If you assign an owner-draw menu item an ID equal to 0x8000 
or higher, Windows 95 unwittingly sign-extends the value when passing it between 
the 16-bit and 32-bit halves of USER. The result? The command ID 0x8000 
becomes 0xFFFF8000, 0x8001 becomes 0xFFFF8001, and so on, and 
<I>  OnDrawItem</I> won't recognize its own command IDs unless it masks off the upper 16 bits. Using ID 
values lower than 0x8000 fixes this problem by eliminating the 1 in the upper bit, but it 
just so happens that when you allow Visual C++ to pick your command IDs, it uses 
values greater than 0x8000. Rather than manually change the IDs, I chose to strip 
the bits instead. This problem doesn't exist in Windows NT and is fixed in Windows 98.
</p>

<p>
<I>  OnDrawItem</I>'s final act is to detach 
<I>  dc</I> from the device context handle obtained from DRAWITEMSTRUCT. This final step is important because it prevents 
<I>  dc</I>'s destructor from deleting the device context when 
<I>  OnDrawItem</I> ends. Normally you <I>  want</I> a 
device context to be deleted when a message handler returns, but because this device 
context was borrowed from Windows, only Windows should delete it. 
<I>  CDC::Detach</I> disassociates a <I>  CDC</I> object and its device context so that the object can safely go out of scope.
</P>


<A NAME="146"><H2>The Context Menu</H2></A>

<P>Colors' context menu comes from the menu resource IDR_CONTEXTMENU. The 
menu resource is defined as follows in Colors.rc:
</p>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
IDR_CONTEXTMENU MENU DISCARDABLE 
BEGIN
    POPUP &quot;Top&quot;
    BEGIN
        MENUITEM &quot;&amp;Circle\tF7&quot;,                 ID_SHAPE_CIRCLE
        MENUITEM &quot;&amp;Triangle\tF8&quot;,               ID_SHAPE_TRIANGLE
        MENUITEM &quot;&amp;Square\tF9&quot;,                 ID_SHAPE_SQUARE
        MENUITEM SEPARATOR
        MENUITEM &quot;&amp;Red&quot;,                        ID_COLOR_RED
        MENUITEM &quot;&amp;Yellow&quot;,                     ID_COLOR_YELLOW
        MENUITEM &quot;&amp;Green&quot;,                      ID_COLOR_GREEN
        MENUITEM &quot;&amp;Cyan&quot;,                       ID_COLOR_CYAN
        MENUITEM &quot;&amp;Blue&quot;,                       ID_COLOR_BLUE
    END
END
</PRE></TD></TR></TABLE></P>
</P>

<P>I created it by inserting a new menu resource into the application with Visual 
C++'s Insert-Resource command. I added items using the menu editor.
</p>

<p>
When the right mouse button is clicked in the view, the context menu is 
loaded and displayed by 
<I>  CChildView::OnContextMenu</I>. Before loading the menu, 
<I>  OnContextMenu</I> hit-tests the shape in the window and passes the WM_CONTEXTMENU 
message to the base class if the click occurred outside the shape. If it determines that the 
click occurred over the circle, the triangle, or the square, 
<I>  OnContextMenu</I> loads the menu and converts the items in it to owner-draw items before calling 
<I>  TrackPopupMenu</I>:
</p>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
if (bShapeClicked) {
    CMenu menu;
    menu.LoadMenu (IDR_CONTEXTMENU);
    CMenu* pContextMenu = menu.GetSubMenu (0);

    for (int i=0; i&lt;5; i++)
        pContextMenu-&gt;ModifyMenu (ID_COLOR_RED + i,
            MF_BYCOMMAND &#166; MF_OWNERDRAW, ID_COLOR_RED + i);

    pContextMenu-&gt;TrackPopupMenu (TPM_LEFTALIGN &#166; TPM_LEFTBUTTON &#166;
        TPM_RIGHTBUTTON, point.x, point.y, AfxGetMainWnd ());
    return;
}
</PRE></TD></TR></TABLE></P>


<P>The owner-draw conversion must be performed each time the menu is loaded 
because when <I>  menu</I> goes out of scope, the menu is destroyed and the modifications made 
to it are lost.
</p>

<p>
The colors in the Color menu and the context menu are linked to the 
command handler <I>  OnColor</I> and the update handler 
<I>  OnUpdateColor</I> by the following entries in 
<I>  CChildView</I>'s message map:
</p>

<P>
<TABLE cellpadding=5 width="95%"><TR><TD><PRE>
ON_COMMAND_RANGE (ID_COLOR_RED, ID_COLOR_BLUE, OnColor)
ON_UPDATE_COMMAND_UI_RANGE (ID_COLOR_RED, ID_COLOR_BLUE, OnUpdateColor)
</PRE></TD></TR></TABLE></P>

<P>I added these entries to the source code manually because ClassWizard doesn't 
support either ON_COMMAND_RANGE or ON_UPDATE_COMMAND_UI_RANGE. 
ClassWizard's lack of support for these macros is one very important reason why 
MFC programmers shouldn't become too reliant on code-generating wizards. The 
wizards are useful, but they support only a subset of MFC's functionality. I could have 
used ClassWizard to write separate command and update handlers for every 
command, but hand-coding RANGE macros into the message map is more efficient because 
it reduces what would have been 10 separate command and update handlers to just 
2. Note that entries added to a message map manually should be added 
<I>  outside</I> the AFX_MSG_MAP comments generated by AppWizard. The portion of the message 
map that lies between these comments belongs to ClassWizard.
</p>

<p>
For these RANGE macros to work, the items in the Color menu must be 
assigned contiguous command IDs, with ID_COLOR_RED and ID_COLOR_BLUE bracketing 
the low and high ends of the range, respectively. To ensure that these conditions are 
met, you should either specify the command IDs explicitly when creating the menu 
items in the menu editor or edit them after the fact. You can specify a numeric 
command ID when creating or editing a menu item by appending 
&quot;=<I>  value</I>&quot; to the command ID typed into the Menu Item Properties dialog box's ID combo box, as shown 
in Figure 4-16. Or you can edit Resource.h instead. I used the values 32774 
through 32778 for ID_COLOR_RED through ID_COLOR_BLUE.
</p>

<p>
<IMG SRC="images/F04MG16.GIF" width=403 height=162 BORDER="0">
</p><p>
<!-- CAPTION --><B>Figure 4-16.</B> <I>Assigning a numeric value to a menu item ID.</I><!-- /CAPTION -->
</p>


<A NAME="147"><H2>On Your Own</H2></A>

<P>Here's an exercise you can try on your own. Go to ResourceView and edit the 
icon resource IDR_MAINFRAME. This resource, which was created by AppWizard, 
defines the application icon. The icon contains two images: a large (32 by 32) image and 
a small (16 by 16) image. You should edit both of them before you ship an 
application so that your application will have a unique icon. You can pick the one you want 
to edit by selecting Standard or Small from the icon editor's Device drop-down list. 
You can see the large icon in the operating system shell if you navigate to the folder 
containing Colors.exe and select Large Icons as the view type. If you have Small 
Icons, List, or Details selected instead, you'll see the small icon. The small icon also 
appears in the frame window's title bar, thanks to some code in 
<I>  CFrameWnd::LoadFrame</I> that loads the icon resource and associates it with the window.
</p>


</BODY>
</HTML>




