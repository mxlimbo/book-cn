<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Regions</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch15c.htm", "ch16a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="485"><H1>Regions</H1></A>

<P>MFC's <I>CRect</I> class represents rectangles&#8212;simple regions of space enclosed by 
four boundaries aligned at right angles. More complex regions of space can be 
represented with the <I>CRgn</I> class, which encapsulates GDI objects called, appropriately 
enough, <I>regions</I>. The most common use for regions is to create complex patterns that 
serve as clipping boundaries for GDI drawing functions. But you can use 
<I>CRgn</I> in other ways, too. Here's a brief look at regions and some of the interesting things that 
you can do with them.</P>

<A NAME="486"><H2>Regions and the <I>CRgn</I> Class</H2></A>
<P><I>CRgn</I> provides functions for creating geometrically shaped regions, combining 
existing regions to create more complex regions, and performing certain operations 
such as hit-testing a region or retrieving a region's bounding rectangle. The 
<I>CDC</I> class provides tools for drawing with a region once it's created&#8212;for example, filling a 
region with a brush color or using it to clip other drawing operations. Let's see 
first how regions are created. Then we'll look at the 
<I>CDC</I> functions that act on regions and finish up by building a sample program that uses regions to generate some 
rather unusual output.</P>

<A NAME="487"><H3>Creating Regions</H3></A>

<P>After a <I>CRgn</I> object is constructed, a region is created and attached to it by 
calling one of several member functions the 
<I>CRgn</I> class provides for region creation. 
The pertinent <I>CRgn</I> functions are summarized in the following table.</P>

<p><b><I>CRgn</I> Region-Creation Functions</b></P>

<P>
<table width="95%" cellpadding="5">
<tr><th valign="top"><B><I>Function</I></B></th>
<th valign="top"><b><i>Description</i></b></th></tr>
<tr><td valign="top"><I>CreateRectRgn</I></td>
<td valign="top">Creates a rectangular region from a set of coordinates</td></tr>
<tr><td valign="top"><I>CreateRectRgnIndirect</I></td>
<td valign="top">Creates a rectangular region from a RECT structure or a <I>CRect</I> object</td></tr>
<tr><td valign="top"><I>CreateEllipticRgn</I></td>
<td valign="top">Creates an elliptical region from a set of coordinates</td></tr>
<tr><td valign="top"><I>CreateEllipticRgnIndirect</I></td>
<td valign="top">Creates an elliptical region from a RECT structure or a <I>CRect</I> object</td></tr>
<tr><td valign="top"><I>CreateRoundRectRgn</I></td>
<td valign="top">Creates a rectangular region with rounded corners</td></tr>
<tr><td valign="top"><I>CreatePolygonRgn</I></td>
<td valign="top">Creates a polygonal region from a set of points</td></tr>
<tr><td valign="top"><I>CreatePolyPolygonRgn</I></td>
<td valign="top">Creates a region composed of multiple polygons from a set of points</td></tr>
<tr><td valign="top"><I>CreateFromPath</I></td>
<td valign="top">Creates a region from a path</td></tr>
<tr><td valign="top"><I>CreateFromData</I></td>
<td valign="top">Creates a region by applying two-dimensional coordinate transformations to an existing region</td></tr>
<tr><td valign="top"><I>CopyRgn</I></td>
<td valign="top">Creates a region that is a copy of an existing region</td></tr>
</table></P>

<P>The use of most of these functions is straightforward. For example, to create 
an elliptical region from a <I>CRect</I> object named 
<I>rect</I> that defines a bounding box, you can write</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
CRgn rgn;
rgn.CreateEllipticRgnIndirect(&amp;rect);
</PRE>
</td></tr></table></P>

<P>To create a rectangular region with rounded corners, you'd do it this way instead:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
CRgn rgn;
rgn.CreateRoundRectRgn (rect.left, rect.top, rect.right,
    rect.bottom, nCornerWidth, nCornerHeight);
</PRE>
</td></tr></table></P>

<P><I>nCornerWidth</I> and <I>nCornerHeight </I>represent the horizontal and vertical 
dimensions, respectively, of the ellipses used to round the corners. All coordinates passed to 
functions that create regions are logical coordinates. Like other GDI objects, a region 
must be deleted when it's no longer needed. Creating a 
<I>CRgn</I> on the stack makes destruction automatic because when a 
<I>CRgn</I> goes out of scope it destroys the GDI 
region it's attached to.</P>

<p>One of the most powerful region-creation functions is 
<I>CRgn::CreateFromPath</I>, which converts the device context's current path into a region. A 
<I>path</I> is an outline generated by bracketing calls to other GDI drawing functions between calls to 
<I>CDC::BeginPath</I> and <I>CDC::EndPath</I>. The following statements generate a simple 
elliptical path and convert it into a region:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
dc.BeginPath ();                // Define a path
dc.Ellipse (0, 0, 400, 200);
dc.EndPath ();
 
CRgn rgn;                       // Convert the path into a region.
rgn.CreateFromPath (&amp;dc);
</PRE>
</td></tr></table></P>

<P>There's nothing remarkable about this code because you could do the same thing 
by simply calling <I>CRgn::CreateEllipticRgn</I>. But what's cool about 
<I>CreateFromPath</I> is that you can create paths from more complex objects such as B&eacute;zier curves and text 
outlines. The following statements create a region from the characters in the text 
string &quot;Hello, MFC&quot;:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
dc.BeginPath ();
dc.TextOut (0, 0, CString (_T (&quot;Hello, MFC&quot;)));
dc.EndPath ();
</PRE>
</td></tr></table></P>

<p>Once created, the path can be converted into a region with 
<I>CRgn::CreateFromPath</I>. <I>Ellipse</I> and 
<I>TextOut</I> are but two of several <I>CDC</I> drawing functions that work 
with <I>BeginPath</I> and <I>EndPath</I>; for a complete list, refer to the MFC documentation for 
the API function <I>::BeginPath</I>. (The subset of GDI drawing functions that can be used 
to generate paths varies slightly between Windows 95 and Windows 98 and 
Windows NT and Windows 2000, so watch out.) You can also use paths in ways unrelated 
to regions. To learn about the drawing operations you can perform with paths, see 
the MFC documentation for the <I>CDC</I> functions 
<I>FillPath</I>, <I>StrokePath</I>, 
<I>StrokeAndFillPath</I>, and <I>WidenPath</I>.</P>

<p>Another way to create complex regions is to combine existing regions 
with <I>CRgn::CombineRgn</I>. <I>CombineRgn</I> accepts three parameters: 
<I>CRgn</I> pointers to the two regions to be combined (region 1 and region 2) and an integer value specifying 
the combine mode. The combine mode can be any one of the five values listed here:</P>

<p>
<table width="95%" cellpadding="5">
<tr><th valign="top"><B><I>Mode</I></B></th>
<th valign="top"><b><i>Description</i></b></th></tr>
<tr><td valign="top">RGN_COPY</td>
<td valign="top">Sets the region equal to region 1</td></tr>
<tr><td valign="top">RGN_AND</td>
<td valign="top">Sets the region equal to the intersection of regions 1 and 2</td></tr>
<tr><td valign="top">RGN_OR</td>
<td valign="top">Sets the region equal to the union of regions 1 and 2</td></tr>
<tr><td valign="top">RGN_DIFF</td>
<td valign="top">Sets the region equal to the area bounded by region 1 minus the area bounded by region 2</td></tr>
<tr><td valign="top">RGN_XOR</td>
<td valign="top">Sets the region equal to the nonoverlapping areas of regions 1 and 2</td></tr>
</table></P>

<p>The combine mode tells the GDI what Boolean operations to use to 
combine the regions. The statements</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
CRgn rgn1, rgn2, rgn3;
rgn1.CreateEllipticRgn (0, 0, 100, 100);
rgn2.CreateEllipticRgn (40, 40, 60, 60);
rgn3.CreateRectRgn (0, 0, 1, 1);
rgn3.CombineRgn (&amp;rgn1, &amp;rgn2, RGN_DIFF);
</PRE>
</td></tr></table></P>

<P>create a donut-shaped region consisting of a circle with a hole in the middle. 
Note that <I>CombineRgn</I> can't be called until the region it's called for is created by 
some other means (that is, until there's an HRGN to go with the 
<I>CRgn</I>). That's why this example calls 
<I>CreateRectRgn</I> to create a trivial rectangular region for 
<I>rgn3</I> before calling <I>CombineRgn</I>.</P>

<A NAME="488"><H3>Using Regions</H3></A>

<P>Just what can you do with a region after it's created? To start with, the following 
<I>CDC</I> drawing functions use regions:</P>

<UL>
<P><LI><I>CDC::FillRgn</I> fills a region using a specified brush.</LI></P>
<P><LI><I>CDC::PaintRgn</I> fills a region using the current brush.</LI></P>
<P><LI><I>CDC::InvertRgn</I> inverts the colors in a region.</LI></P>
<P><LI><I>CDC::FrameRgn</I> borders a region with a specified brush.</LI></P>
</UL>

<p>You can also invalidate a region with 
<I>CWnd::InvalidateRgn</I>. Internally, Windows 
uses regions rather than rectangles to track the invalid areas of a window. When you 
call <I>CDC::GetClipBox</I>, what you get back is a rectangle that bounds the window's 
invalid region. That region could be a simple rectangle, or it could be something much 
more complex.</P>

<p>You can perform hit-testing in regions with 
<I>CRgn::PtInRegion</I>. Let's say you create an elliptical region that's centered in a window's client area. You used 
<I>PaintRgn</I> or <I>FillRgn</I> to paint the region a different color from the window background color, 
and now you want to know when the user clicks the left mouse button inside the 
ellipse. If <I>m_rgn</I> is the <I>CRgn</I> object, here's what the 
<I>OnLButtonDown</I> handler might look like:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
void CMyWindow::OnLButtonDown (UINT nFlags, CPoint point)
{
    CClientDC dc (this);
    dc.DPtoLP (&amp;point); // Convert to logical coordinates.
    if (m_rgn.PtInRegion (point)) {
        // The point falls within the region.
    }
}
</PRE>
</td></tr></table></P>

<P>MFC's <I>CRect</I> class provides an analogous function for rectangles: 
<I>PtInRect</I>. In fact, there are many parallels in the API (and in MFC member functions) between 
regions and rectangles: <I>InvalidateRect</I> and 
<I>InvalidateRgn</I>, <I>FillRect</I> and 
<I>FillRgn</I>, and so on. Rectangle functions are faster, so when possible you should avoid using 
region functions to operate on simple rectangles and use the equivalent rectangle 
functions instead.</P>

<p>Regions really pay off when you use them as clipping boundaries for 
complex graphic images. A region can be selected into a device context with 
<I>CDC::SelectObject</I> or 
<I>CDC::SelectClipRgn</I>. Once selected, the region serves as a clipping boundary 
for all subsequent output to the device context. The RegionDemo application in the 
next section uses a clipping region to create an image that would be murderously 
difficult to draw by other means. But with a region acting as a virtual stencil for graphics 
output, the image is relatively easy to render. The drawback to complex clipping regions 
is that they're slow. But sometimes using a clipping region is the only practical way 
to get the output you're looking for. If you want to use a path as a clipping region, 
you don't have to convert it into a region and then select it into a device context. You 
can select the path directly into the device context with 
<I>CDC::SelectClipPath</I>.</P>

<p>One of the more imaginative uses for a region is to pass it to the 
<I>CWnd::SetWindowRgn</I> function so that it becomes a window region. A 
<I>window region</I> is a clipping region for an entire window. Windows doesn't allow anything outside the 
window region to be painted, including title bars and other nonclient-area window 
elements. Create an elliptical region and pass its handle to 
<I>SetWindowRgn</I>, and you'll get an elliptical window. If the window is a top-level window and its title bar is 
hidden from view, use an <I>OnNcHitTest</I> handler to convert HTCLIENT hit-test codes 
into HTCAPTION codes so that the window can be dragged by its client area. A 
more practical use for nonrectangular window regions is to create stylized text bubbles 
that are actually windows and that receive messages just as other windows do. 
With <I>SetWindowRgn</I> to assist you, it's not terribly difficult to create a popup window 
class that displays help text in a window shaped like a thought balloon and that 
automatically destroys itself when it's clicked.</P>

<A NAME="489"><H2>The RegionDemo Application</H2></A>

<P>Figure 15-10 shows the output from an application named RegionDemo, which 
uses a clipping region to draw a radial array of lines forming the words &quot;Hello, MFC.&quot; 
The clipping region is generated from a path, and the path, in turn, is generated by 
calling <I>CDC::TextOut</I> between calls to 
<I>CDC::BeginPath</I> and <I>CDC::EndPath</I>. All the 
work is done in <I>OnPaint</I>. Look over the source code in Figure 15-11; it should be 
pretty apparent what's going on in each phase of the output, with the possible exception 
of the code that uses two different <I>CRgn</I> objects and various calls to 
<I>CRgn</I> member functions to generate the final clipping region 
(<I>rgn1</I>) that is selected into the device context with 
<I>CDC::SelectClipRgn</I>.</P>

<P>
<A HREF="javascript:fullSize('F15mg10x.htm')"> <img src="images/F15mg10.JPG" width=404 height=303 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 15-10.</B> <I>The RegionDemo window.</I><!-- /CAPTION -->
</p>

<P><B>Figure 15-11.</B> <I>The RegionDemo application.</I></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="490"><H3>RegionDemo.h</H3></A>
<PRE>
class CMyApp : public CWinApp
{
public:
    virtual BOOL InitInstance ();
};

class CMainWindow : public CFrameWnd
{
public:
    CMainWindow ();

protected:
    afx_msg void OnPaint ();
    DECLARE_MESSAGE_MAP ()
};
</PRE>
</td></tr></table></P>

<P>
<table cellpadding=5 width="95%"><tr><td>
<A NAME="491"><H3>RegionDemo.cpp</H3></A>
<PRE>
#include &lt;afxwin.h&gt;
#include &lt;math.h&gt;
#include &quot;RegionDemo.h&quot;

CMyApp myApp;

/////////////////////////////////////////////////////////////////////////
// CMyApp member functions

BOOL CMyApp::InitInstance ()
{
    m_pMainWnd = new CMainWindow;
    m_pMainWnd-&gt;ShowWindow (m_nCmdShow);
    m_pMainWnd-&gt;UpdateWindow ();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////
// CMainWindow message map and member functions

BEGIN_MESSAGE_MAP (CMainWindow, CFrameWnd)
    ON_WM_PAINT ()
END_MESSAGE_MAP ()

CMainWindow::CMainWindow ()
{
    Create (NULL, _T (&quot;Region Demo&quot;));
}

void CMainWindow::OnPaint ()
{
    CPaintDC dc (this);

    //
    // Create a 72-point Times New Roman font.
    //
    CFont font;
    font.CreatePointFont (720, _T (&quot;Times New Roman&quot;));

    //
    // Create a clipping region from the text string &quot;Hello, MFC.&quot;
    //
    CRect rect;
    GetClientRect (&amp;rect);
    CString string (&quot;Hello, MFC&quot;);

    CFont* pOldFont = dc.SelectObject (&amp;font);
    CSize size = dc.GetTextExtent (string);
    int x = (rect.Width () - size.cx) / 2;

    TEXTMETRIC tm;
    dc.GetTextMetrics (&amp;tm);
    int y = (rect.Height () - tm.tmHeight) / 2;

    dc.BeginPath ();
    dc.TextOut (x, y, string);
    dc.EndPath ();
    dc.SelectObject (pOldFont);

    CRect rcText;
    CRgn rgn1, rgn2;
    rgn1.CreateFromPath (&amp;dc);
    rgn1.GetRgnBox (&amp;rcText);
    rgn2.CreateRectRgnIndirect (&amp;rcText);
    rgn1.CombineRgn (&amp;rgn2, &amp;rgn1, RGN_DIFF);

    dc.SelectClipRgn (&amp;rgn1);

    //
    // Draw a radial array of lines.
    //
    dc.SetViewportOrg (rect.Width () / 2, rect.Height () / 2);
    double fRadius = hypot (rect.Width () / 2, rect.Height () / 2);

    for (double fAngle = 0.0; fAngle &lt; 6.283; fAngle += 0.01745) {
        dc.MoveTo (0, 0);
        dc.LineTo ((int) ((fRadius * cos (fAngle)) + 0.5),
            (int) ((fRadius * sin (fAngle)) + 0.5));
    }
}
</PRE>
</td></tr></table></P>

<P>Here's a blow-by-blow analysis of the code that creates the clipping region 
after the path outlining the characters in the text string is created. The statement</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
rgn1.CreateFromPath (&amp;dc);
</PRE>
</td></tr></table></P>

<P>initializes <I>rgn1</I> with a region that matches the path. Figure 15-12 shows what this 
first region looks like. The interior of the region is a rectangle with the outline of the 
letters &quot;Hello, MFC&quot; stamped out in the middle. (Some graphics 
systems&#8212;notably PostScript&#8212;handle paths generated from character outlines differently by making 
the interiors of the regions the interiors of the characters themselves. The GDI does 
essentially the opposite, creating a region from the characters' bounding box and 
then subtracting the areas enclosed by the character outlines.) Next, the statements</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
rgn1.GetRgnBox (&amp;rcText);
rgn2.CreateRectRgnIndirect (&amp;rcText);
</PRE>
</td></tr></table></P>

<P>copy <I>rgn1</I>'s bounding box to a 
<I>CRect</I> object named <I>rcText</I> and create a region 
(<I>rgn2</I>) from it. The final statement effectively inverts 
<I>rgn1</I> by subtracting <I>rgn1</I> from 
<I>rgn2</I>:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
rgn1.CombineRgn (&amp;rgn2, &amp;rgn1, RGN_DIFF);
</PRE>
</td></tr></table></P>

<P>
<A HREF="javascript:fullSize('F15mg12x.htm')"> <img src="images/F15mg12.JPG" width=404 height=72 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 15-12.</B> <I>The path generated from the text string &quot;Hello, MFC.&quot;</I><!-- /CAPTION -->
</p>

<P>The resulting region is one whose interior exactly matches the insides of the 
characters drawn by <I>TextOut</I>. After the region is selected into the device context, a 
radial array of lines is drawn outward at 1-degree increments from the center of the 
window's client area. Because the lines are clipped to the boundaries of the region, nothing 
is drawn outside the character outlines.</P>

<p>You could make RegionDemo slightly more efficient by moving the code 
that generates the region out of <I>OnPaint</I> and into 
<I>OnCreate</I>. The region would no longer have to be generated anew each time the window is repainted, but it would need 
to be repositioned with <I>CRgn::OffsetRgn</I> to keep it centered. Eliminating redundant 
calls to <I>CRgn</I> functions improves the speed of the output somewhat, but the biggest 
performance hit still comes when the lines drawn on the screen are clipped to the 
region's boundaries. That complex clipping regions exact a price in performance is a fact 
of life in computer graphics, so it's wise to avoid using nonrectangular clipping 
regions except in cases in which there's no reasonable alternative.</P>



</BODY>
</HTML>




