<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Bitmaps</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch15b.htm", "ch15d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="464"><H1>Bitmaps</H1></A>

<P>The bitmapped image, or simply <I>bitmap,</I> is a staple of modern computer 
graphics because it allows computers to store complex images in the form of 1s and 0s. 
In Windows, bitmaps are GDI objects that are handled at a fairly high level just like 
fonts, brushes, pens, and other GDI objects. You can create bitmaps with a paint 
program, embed them as resources in an application's EXE file, and load them with a 
simple function call; or you can create bitmaps on the fly by using GDI functions to draw 
to virtual display surfaces in memory. Once created, a bitmap can be displayed on 
the screen or reproduced on the printer with a few simple function calls.</P>

<p>Two types of bitmaps are supported in 32-bit Windows: 
<I>device-dependent bitmaps</I> (DDBs) and <I>device-independent 
bitmaps</I> (DIBs). Also supported in 32-bit Windows is a variation on the device-independent bitmap that was first 
introduced in Windows NT&#8212;something programmers refer to as a 
<I>DIB section</I>. DDBs are the simplest of the lot as well as the most limiting. They also happen to be the only 
type of bitmap that MFC thoroughly encapsulates. We'll get the fundamentals out of 
the way first by covering <I>CBitmap</I>s and DDBs, and later we'll move on to the more 
powerful DIBs and DIB sections. As you read, be aware that I'll often use the term 
<I>bitmap</I> interchangeably with the more specific terms 
<I>DDB, DIB,</I> and <I>DIB section</I>. Which 
type of bitmap I'm referring to (or whether I'm using the term generically) should be 
clear from the context of the discussion.</P>

<A NAME="465"><H2>DDBs and the <I>CBitmap</I> Class</H2></A>
<P>It goes without saying that before you can do anything with a bitmap, you must 
first create it. One way to create a bitmap is to construct a 
<I>CBitmap</I> object and call 
<I>CBitmap::CreateCompatibleBitmap</I>:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
CBitmap bitmap;
bitmap.CreateCompatibleBitmap (&amp;dc, nWidth, nHeight);
</PRE>
</td></tr></table></P>

<P>In this example, <I>dc</I> represents a screen device context and 
<I>nWidth</I> and <I>nHeight</I> are the bitmap's dimensions in pixels. The reason 
<I>CreateCompatibleBitmap</I> requires a device context pointer is that the format of the resulting DDB is closely tied to 
the architecture of the output device. Providing a pointer to a device context 
enables Windows to structure the DDB so that it's compatible with the device on which 
you intend to display it. The alternative is to call 
<I>CBitmap::CreateBitmap</I> or 
<I>CBitmap::CreateBitmapIndirect</I> and specify the number of color planes and number of 
bits per pixel per color plane, both of which are device-dependent values. These 
days, about the only practical use for 
<I>CreateBitmap</I> and 
<I>CreateBitmapIndirect</I> is for creating monochrome bitmaps. Monochrome bitmaps are sometimes useful even in 
color environments, as one of this chapter's sample programs will demonstrate.</P>

<p>A DDB created with <I>CreateCompatibleBitmap</I> initially contains random data. 
If you want to do something with the DDB&#8212;say, display it in a window&#8212;you'll 
probably want to draw something into the bitmap first. You can use GDI functions to 
draw into a bitmap by first creating a special type of device context known as a 
<I>memory device context</I> (DC) and then selecting the bitmap into the memory DC. In 
essence, a bitmap selected into a memory DC becomes the device context's display 
surface, just as the display surface that corresponds to a screen DC is the screen itself. 
The following code creates an uninitialized DDB that measures 100 pixels square. It 
then creates a memory DC, selects the bitmap into it, and initializes all the pixels in 
the bitmap to blue:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
CClientDC dcScreen (this);
CBitmap bitmap;
bitmap.CreateCompatibleBitmap (&amp;dcScreen, 100, 100);

CDC dcMem;
dcMem.CreateCompatibleDC (&amp;dcScreen);

CBrush brush (RGB (0, 0, 255));
CBitmap* pOldBitmap = dcMem.SelectObject (&amp;bitmap);
dcMem.FillRect (CRect (0, 0, 100, 100), &amp;brush);
dcMem.SelectObject (pOldBitmap);
</PRE>
</td></tr></table></P>

<P><I>CDC::CreateCompatibleDC</I> creates a memory DC that's compatible with the 
specified device context. The device context whose address you pass in is usually a 
screen DC, but it could just as easily be a printer DC if the image you're preparing is 
destined for a printer rather than the screen. Once a bitmap is selected into a 
memory DC, you can draw to the memory DC (and hence into the bitmap) using the 
same <I>CDC</I> member functions you use to draw to a screen or printer DC.</P>

<p>The big difference between drawing to a memory DC and drawing to a 
screen DC is that pixels drawn to a memory DC aren't displayed. To display them, you 
have to copy them from the memory DC to a screen DC. Drawing to a memory DC 
first and then transferring pixels to a screen DC can be useful for replicating the 
same image on the screen several times. Rather than draw the image anew each time, 
you can draw it once in a memory DC and then transfer the image to a screen DC as 
many times as you want. (Be aware, however, that many display adapters will perform better if you copy the image 
from the memory DC to the screen DC one time and then replicate the image already
present in the screen DC as needed.) Bitmaps play an important role in the process because when a memory DC is 
first created it contains just one pixel you can draw to, and that pixel is a 
monochrome pixel. Selecting a bitmap into a memory DC gives you a larger display surface to 
draw on and also more colors to work with as long as the bitmap isn't monochrome.</P>

<A NAME="466"><H2>Blitting Bitmaps to Screens and Other Devices</H2></A>

<P>How do you draw a bitmap on the screen? Bitmaps can't be selected into 
nonmemory DCs; if you try, <I>SelectObject</I> will return NULL. But you can use 
<I>CDC::BitBlt</I> or <I>CDC::StretchBlt</I> to &quot;blit&quot; pixels from a memory DC to a screen DC. 
<I>BitBlt</I> transfers a block of pixels from one DC to another and preserves the block's dimensions; 
<I>StretchBlt</I> transfers a block of pixels between DCs and scales the block to the dimensions 
you specify. If <I>dcMem</I> is a memory DC that contains a 100-pixel by 100-pixel bitmap 
image and <I>dcScreen</I> is a screen DC, the statement</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
dcScreen.BitBlt (0, 0, 100, 100, &amp;dcMem, 0, 0, SRCCOPY);
</PRE>
</td></tr></table></P>

<P>copies the image to the screen DC and consequently displays it on the screen. 
The first two parameters passed to <I>BitBlt</I> specify the coordinates of the image's upper 
left corner in the destination (screen) DC, the next two specify the width and height 
of the block to be transferred, the fifth is a pointer to the source (memory) DC, the 
sixth and seventh specify the coordinates of the upper left corner of the block of pixels 
in the source DC, and the eighth and final parameter specifies the type of raster 
operation to be used in the transfer. SRCCOPY copies the pixels unchanged from the 
memory DC to the screen DC.</P>

<p>You can shrink or expand a bitmap as it's blitted by using 
<I>StretchBlt</I> instead of <I>BitBlt</I>. 
<I>StretchBlt</I>'s argument list looks a lot like 
<I>BitBlt</I>'s, but it includes an additional pair of parameters specifying the width and height of the resized image. The following statement blits a 100-by-100 image from a memory DC to a screen 
DC and stretches the image to fit a 50-by-200 rectangle:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
dcScreen.StretchBlt (0, 0, 50, 200, &amp;dcMem, 0, 0, 100, 100, SRCCOPY);
</PRE>
</td></tr></table></P>

<P>By default, rows and columns of pixels are simply removed from the resultant 
image when the width or height in the destination DC is less than the width or height in 
the source DC. You can call 
<I>CDC::SetStretchBltMode</I> before calling 
<I>StretchBlt</I> to specify other stretching modes that use various methods to preserve discarded color 
information. Refer to the documentation on 
<I>SetStretchBltMode</I> for further details, but 
be advised that the most potentially useful alternative stretching 
mode&#8212;HALFTONE, which uses dithering to simulate colors that can't be displayed directly&#8212;works 
in Windows NT and Windows 2000 but not in Windows 95 and Windows 98.</P>

<p>You can get information about a bitmap by passing a pointer to a BITMAP 
structure to <I>CBitmap::GetBitmap</I>. BITMAP is defined as follows:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
typedef struct tagBITMAP {
    LONG    bmType;
    LONG    bmWidth;
    LONG    bmHeight;
    LONG    bmWidthBytes;
    WORD    bmPlanes;
    WORD    bmBitsPixel;
    LPVOID  bmBits;
} BITMAP;
</PRE>
</td></tr></table></P>

<P>The <I>bmType</I> field always contains 0. 
<I>bmWidth</I> and <I>bmHeight</I> specify the 
bitmap's dimensions in pixels. <I>bmWidthBytes</I> specifies the length (in bytes) of each line in 
the bitmap and is always a multiple of 2 because rows of bits are padded to 16-bit 
boundaries. <I>bmPlanes</I> and <I>bmBitsPixel</I> specify the number of color planes and the 
number of pixels per bit in each color plane. If 
<I>bm</I> is an initialized BITMAP, you can determine the maximum number of colors the bitmap can contain by using the 
following statement:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
int nColors = 1 &lt;&lt; (bm.bmPlanes * bm.bmBitsPixel);
</PRE>
</td></tr></table></P>

<P>Finally, <I>bmBits</I> contains a NULL pointer following a call to 
<I>GetBitmap </I>if the bitmap is a DDB. If 
<I>bitmap</I> represents a <I>CBitmap</I> object, the statements</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
BITMAP bm;
bitmap.GetBitmap (&amp;bm);
</PRE>
</td></tr></table></P>

<p>initialize <I>bm</I> with information about the bitmap.</P>

<p>The bitmap dimensions returned by <I>GetBitmap</I> are expressed in device 
units (pixels), but both <I>BitBlt</I> and 
<I>StretchBlt</I> use logical units. If you want to write a 
generic <I>DrawBitmap</I> function that blits a bitmap to a DC, you must anticipate the 
possibility that the DC might be set to a mapping mode other than MM_TEXT. 
The following <I>DrawBitmap</I> function, which is designed to be a member function of a 
class derived from <I>CBitmap</I>, works in all mapping modes. 
<I>pDC</I> points to the device context the bitmap is being blitted to; 
<I>x</I> and <I>y</I> specify the location of the image's 
upper left corner at the destination:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
void CMyBitmap::DrawBitmap (CDC* pDC, int x, int y)
{
    BITMAP bm;
    GetBitmap (&amp;bm);
    CPoint size (bm.bmWidth, bm.bmHeight);
    pDC-&gt;DPtoLP (&amp;size);

    CPoint org (0, 0);
    pDC-&gt;DPtoLP (&amp;org);

    CDC dcMem;
    dcMem.CreateCompatibleDC (pDC);
    CBitmap* pOldBitmap = dcMem.SelectObject (this);
    dcMem.SetMapMode (pDC-&gt;GetMapMode ());
    pDC-&gt;BitBlt (x, y, size.x, size.y, &amp;dcMem, org.x, org.y, SRCCOPY);
    dcMem.SelectObject (pOldBitmap);
}
</PRE>
</td></tr></table></P>

<P>Because of some inadvertent skullduggery that MFC's 
<I>CDC::DPtoLP</I> function performs on 
<I>CSize</I> objects, the <I>size</I> variable that holds the bitmap's dimensions is a 
<I>CPoint</I> object, not a <I>CSize</I> object. When you pass 
<I>CDC::DPtoLP</I> the address of a <I>CPoint</I> object, 
the call goes straight through to the 
<I>::DPtoLP</I> API function and the conversion is 
performed properly, even if one or more of the coordinates comes back negative. But when 
you pass <I>CDC::DPtoLP</I> the address of a 
<I>CSize</I> object, MFC performs the conversion 
itself and converts any negatives to positives. It might make intuitive sense that 
sizes shouldn't be negative, but that's exactly what 
<I>BitBlt</I> expects in mapping modes in which the 
<I>y</I> axis points upward.</P>

<A NAME="467"><H2>Bitmap Resources</H2></A>

<P>If all you want to do is display a predefined bitmap image&#8212;one created with the 
Visual C++ resource editor or any paint program or image editor that generates BMP 
files&#8212;you can add a bitmap resource to your application's RC file like this:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
IDB_MYLOGO BITMAP Logo.bmp
</PRE>
</td></tr></table></P>

<P>Then you can load it like this:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
CBitmap bitmap;
bitmap.LoadBitmap (IDB_MYLOGO);
</PRE>
</td></tr></table></P>

<P>In this example, IDB_MYLOGO is the bitmap's integer resource ID and Logo.bmp 
is the name of the file that contains the bitmap image. You can also assign a 
bitmap resource a string ID and load it this way:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
bitmap.LoadBitmap (_T (&quot;MyLogo&quot;));
</PRE>
</td></tr></table></P>

<P><I>LoadBitmap</I> accepts resource IDs of either type. After loading a bitmap resource, 
you display it the way you display any other bitmap&#8212;by selecting it into a memory 
DC and blitting it to a screen DC. Splash screens like the one you see when Visual 
C++ starts up are typically stored as bitmap resources and loaded with 
<I>LoadBitmap</I> (or its API equivalent, 
<I>::LoadBitmap</I>) just before they're displayed.</P>

<P><I>CBitmap</I> includes a related member function named 
<I>LoadMappedBitmap</I> that loads a bitmap resource and transforms one or more colors in the bitmap to the 
colors you specify. <I>LoadMappedBitmap</I> is a wrapper around 
<I>::CreateMappedBitmap</I>, which was added to the API so that colors in bitmaps used to paint owner-draw 
buttons, toolbar buttons, and other controls could be transformed into system colors 
upon loading. The statement</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
bitmap.LoadMappedBitmap (IDB_BITMAP);
</PRE>
</td></tr></table></P>

<P>loads a bitmap resource and automatically transforms black pixels to the system 
color COLOR_BTNTEXT, dark gray (R=128, G=128, B=128) pixels to 
COLOR_BTNSHADOW, light gray (R=192, G=192, B=192) pixels to COLOR _BTNFACE, white pixels to 
COLOR_BTNHIGHLIGHT, dark blue (R=0, G=0, B=128) pixels to 
COLOR_HIGHLIGHT, and magenta (R=255, G=0, B=255) pixels to COLOR_WINDOW. The idea behind 
mapping magenta to COLOR_WINDOW is that you can add &quot;transparent&quot; pixels to a 
bitmap by coloring them magenta. If 
<I>LoadMappedBitmap</I> transforms magenta pixels 
into COLOR_WINDOW pixels and the bitmap is displayed against a 
COLOR_WINDOW background, the remapped pixels will be invisible against the window background.</P>

<p>You can perform custom color conversions by passing 
<I>LoadMappedBitmap</I> a pointer to an array of COLORMAP structures specifying the colors you want 
changed and the colors you want to change them to. One use for custom color mapping is 
for simulating transparent pixels by transforming an arbitrary background color to 
the background color of your choice. Later in this chapter, we'll examine a technique 
for drawing bitmaps with transparent pixels that works with any kind of background 
(even those that aren't solid) and requires no color mapping.</P>

<A NAME="468"><H2>DIBs and DIB Sections</H2></A>

<P>The problem with device-dependent bitmaps is&#8212;well, that they're 
device-dependent. You can manipulate the bits in a DDB directly using 
<I>CBitmap::GetBitmapBits</I> and 
<I>CBitmap::SetBitmapBits</I>, but because pixel color data is stored in a 
device-dependent format, it's difficult to know what to do with the data returned by 
<I>GetBitmapBits</I> (or what to pass to 
<I>SetBitmapBits</I>) unless the bitmap is monochrome. Worse, the 
color information encoded in a DDB is meaningful only to the device driver that 
displays it. If you write a DDB to disk on one PC and read it back on another, there's a 
very good chance that the colors won't come out the same. DDBs are fine for loading 
and displaying bitmap resources (although you'll get poor results if a bitmap 
resource contains more colors than your hardware is capable of displaying) and for 
drawing images in memory DCs before rendering them on an output device. But their lack 
of portability makes them unsuitable for just about anything else.</P>

<p>That's why Windows 3.0 introduced the device-independent bitmap, or 
DIB. The term <I>DIB</I> describes a device-independent format for storing bitmap data, a 
format that's meaningful outside the context of a display driver and even outside 
the framework of Windows itself. When you call 
<I>::CreateBitmap</I> (the API equivalent of 
<I>CBitmap::CreateBitmap</I>) to create a bitmap, you get back an HBITMAP handle. 
When you call <I>::CreateDIBitmap</I> to create a bitmap, you also get back an HBITMAP. 
The difference is what's inside. Pixel data passed to 
<I>::CreateBitmap</I> is stored in device driver format, but pixel data passed to 
<I>::CreateDIBitmap</I> is stored in DIB format. Moreover, the DIB format includes color information that enables different 
device drivers to interpret colors consistently. The API includes a pair of functions 
named <I>::GetDIBits</I> and <I>::SetDIBits</I> for reading and writing DIB-formatted bits. It also 
includes functions for rendering raw DIB data stored in a buffer owned by the application 
to an output device. Windows BMP files store bitmaps in DIB format, so it's 
relatively easy to write a function that uses 
<I>::CreateDIBitmap</I> to convert the contents of a 
BMP file into a GDI bitmap object.</P>

<p>DIB sections are similar to DIBs and were created to solve a performance 
problem involving the <I>::StretchDIBits</I> function in Windows NT. Some graphics 
programs allocate a buffer to hold DIB bits and then render those bits directly to the 
screen with <I>::StretchDIBits</I>. By not passing the bits to 
<I>::CreateDIBitmap</I> and creating an HBITMAP, the programs enjoy direct access to the bitmap data but can still 
display the bitmap on the screen. Unfortunately, the client/server architecture of 
Windows NT and Windows 2000 dictates that bits blitted from a buffer on the client side 
be copied to a buffer on the server side before they're transferred to the frame 
buffer, and the extra overhead causes 
<I>::StretchDIBits</I> to perform sluggishly.</P>

<p>Rather than compromise the system architecture, the Windows NT team 
came up with DIB sections. A DIB section is the Windows NT and Windows 2000 
equivalent of having your cake and eating it, too: you can select a DIB section into a 
DC and blit it to the screen (thus avoiding the undesirable memory-to-memory 
moves), but you can also access the bitmap bits directly. Speed isn't as much of an issue 
with the <I>::StretchDIBits</I> function in Windows 95 and Windows 98 because these 
operating systems are architected differently than Windows NT and Windows 2000, but 
Windows 95 and Windows 98 support DIB sections just as Windows NT and 
Windows 2000 do and also offer some handy API functions for dealing with them. Win32 
programmers are encouraged to use DIB sections in lieu of ordinary DIBs and 
DDBs whenever possible to give the operating system the greatest amount of flexibility 
in handling bitmap data.</P>

<p>The bad news about DIBs and DIB sections is that current versions of MFC 
don't encapsulate them. To use DIBs and DIB sections in your MFC applications, you 
have to either resort to the API or write your own classes to encapsulate the relevant 
API functions. Writing a basic <I>CDib</I> class or extending 
<I>CBitmap</I> to include functions for DIBs and DIB sections isn't difficult, but I'm not going to do either here because 
it's very likely that some future version of MFC will include a comprehensive set of 
classes representing DIBs and DIB sections. What I'll do instead is show you how to get 
the most out of MFC's <I>CBitmap</I> class and how to combine 
<I>CBitmap</I> with API functions to get some very DIB-like behavior out of ordinary 
<I>CBitmap</I>s.</P>

<A NAME="469"><H2>Blits, Raster Operations, and Color Mapping</H2></A>

<P>The most common use for <I>CDC::BitBlt</I> is to blit bitmap images to the screen. 
But <I>BitBlt</I> does more than just transfer raw bits. In reality, it's a complex function 
that computes the color of each pixel it outputs by using Boolean operations to 
combine pixels from the source DC, the destination DC, and the brush currently 
selected in the destination DC. The SRCCOPY raster-op code is simple; it merely copies 
pixels from the source to the destination. Other raster-op codes aren't so 
simple. MERGEPAINT, for example, inverts the colors of the source pixels with a 
Boolean NOT operation and ORs the result with the pixel colors at the destination. 
<I>BitBlt</I> supports 256 raster-op codes in all. The 15 shown in the following table are 
given names with <I>#define</I> statements in Wingdi.h.</P>

<P><b><I>BitBlt</I> Raster-Op Codes</b></P>

<p><table width="95%" cellpadding="5">
<tr><th valign="top"><B><I>Name</I></B></th>
<th valign="top"><b><i>Binary Equivalent</i></b></th>
<th valign="top"><b><i>Operation(s) Performed</i></b></th></tr>
<tr><td valign="top">SRCCOPY</td>
<td valign="top">0xCC0020</td>
<td valign="top">dest = source</td></tr>
<tr><td valign="top">SRCPAINT</td>
<td valign="top">0xEE0086</td>
<td valign="top">dest = source OR dest</td></tr>
<tr><td valign="top">SRCAND</td>
<td valign="top">0x8800C6</td>
<td valign="top">dest = source AND dest</td></tr>
<tr><td valign="top">SRCINVERT</td>
<td valign="top">0x660046</td>
<td valign="top">dest = source XOR dest</td></tr>
<tr><td valign="top">SRCERASE</td>
<td valign="top">0x440328</td>
<td valign="top">dest = source AND (NOT dest )</td></tr>
<tr><td valign="top">NOTSRCCOPY</td>
<td valign="top">0x330008</td>
<td valign="top">dest = (NOT source)</td></tr>
<tr><td valign="top">NOTSRCERASE</td>
<td valign="top">0x1100A6</td>
<td valign="top">dest = (NOT src) AND (NOT dest)</td></tr>
<tr><td valign="top">MERGECOPY</td>
<td valign="top">0xC000CA</td>
<td valign="top">dest = (source AND pattern)</td></tr>
<tr><td valign="top">MERGEPAINT</td>
<td valign="top">0xBB0226</td>
<td valign="top">dest = (NOT source) OR dest</td></tr>
<tr><td valign="top">PATCOPY</td>
<td valign="top">0xF00021</td>
<td valign="top">dest = pattern</td></tr>
<tr><td valign="top">PATPAINT</td>
<td valign="top">0xFB0A09</td>
<td valign="top">dest = pattern OR (NOT src) OR dest</td></tr>
<tr><td valign="top">PATINVERT</td>
<td valign="top">0x5A0049</td>
<td valign="top">dest = pattern XOR dest</td></tr>
<tr><td valign="top">DSTINVERT</td>
<td valign="top">0x550009</td>
<td valign="top">dest = (NOT dest)</td></tr>
<tr><td valign="top">BLACKNESS</td>
<td valign="top">0x000042</td>
<td valign="top">dest = BLACK</td></tr>
<tr><td valign="top">WHITENESS</td>
<td valign="top">0xFF0062</td>
<td valign="top">dest = WHITE</td></tr>
</table></P>

<p>You can derive custom raster-op codes by applying the logical operations 
you want to the bit values in the following list and using the result to look up a 
DWORD-sized raster-op code in the &quot;Ternary Raster Operations&quot; section of Microsoft's 
Platform SDK.</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
<B>Pat</B>      1     1     1     1     0     0     0     0
<B>Src</B>      1     1     0     0     1     1     0     0
<B>Dest</B>     1     0     1     0     1     0     1     0
</PRE>
</td></tr></table></P>

<P><I>Pat</I> (for &quot;pattern&quot;) represents the color of the brush selected into the destination 
DC; <I>Src</I> represents the pixel color in the source DC; and 
<I>Dest</I> represents the pixel color in the destination DC. Let's say you want to find a raster-op code that inverts a 
source bitmap, ANDs it with the pixels at the destination, and ORs the result with the 
brush color. First apply these same operations to each column of bits in the list. The 
result is shown here:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
<B>Pat</B>      1     1     1     1     0     0     0     0     
<B>Src</B>      1     1     0     0     1     1     0     0
<B>Dest</B>     1     0     1     0     1     0     1     0
        ---------------------------------------------
         1     1     1     1     0     0     1     0     =      0xF2
</PRE>
</td></tr></table></P>

<P>Look up 0xF2 in the ternary raster operations table, and you'll find that the 
full raster-op code is 0xF20B05. Consequently, you can pass 
<I>BitBlt</I> the hex value 0xF20B05 instead of SRCCOPY or some other raster-op code and it will perform the raster 
operation described above.</P>

<p>So what can you <I>do</I> with all those raster-op codes? The truth is that in 
color environments you probably won't use many of them. After SRCCOPY, the next 
most useful raster operations are SRCAND, SRCINVERT, and SRCPAINT. But as the 
sample program in the next section demonstrates, using an unnamed raster-op code 
can sometimes reduce the number of steps required to achieve a desired result.</P>

<p><I>BitBlt</I> is part of a larger family of 
<I>CDC</I> blitting functions that includes 
<I>StretchBlt</I> (which we've already discussed), 
<I>PatBlt</I>, <I>MaskBlt</I>, and <I>PlgBlt</I>. 
<I>PatBlt</I> combines pixels in a rectangle in the destination DC with the brush selected into the device 
context, basically duplicating the subset of 
<I>BitBlt</I> raster operations that don't use a 
source DC. <I>MaskBlt</I> combines pixels in source and destination DCs and uses a 
monochrome bitmap as a mask. One raster operation (the &quot;foreground&quot; raster operation) is 
performed on pixels that correspond to 1s in the mask, and another raster operation 
(the &quot;background&quot; raster operation) is performed on pixels that correspond to 0s in 
the mask. <I>PlgBlt</I> blits a rectangular block of pixels in a source DC to a parallelogram 
in the destination DC and optionally uses a monochrome bitmap as a mask during 
the transfer. Pixels that correspond to 1s in the mask are blitted to the parallelogram; 
pixels that correspond to 0s in the mask are not. Unfortunately, 
<I>MaskBlt</I> and <I>PlgBlt</I> are supported in Windows NT 3.1 and higher and in Windows 2000 but not in Windows 
95 and Windows 98. If you call either of them in Windows 95 or Windows 98, you'll 
get a 0 return, indicating that the function failed.</P>

<p>Some output devices (notably plotters) don't support 
<I>BitBlt</I> and other blitting functions. To determine whether 
<I>BitBlt</I>s are supported on a given device, get a 
device context and call <I>GetDeviceCaps</I> with a RASTERCAPS parameter. If the 
RC_BITBLT bit is set in the return value, the device supports 
<I>BitBlt</I>s; if the RC_STRETCHBLT bit is set, the device also supports 
<I>StretchBlt</I>s. There are no specific RASTERCAPS 
bits for other blit functions, but if you're writing for Windows NT and 
<I>BitBlt</I> isn't supported, you should assume that 
<I>PatBlt</I>, <I>MaskBlt</I>, and <I>PlgBlt</I> aren't supported, 
either. Generally, plotters and other vector-type devices that don't support blits will set 
the RC_NONE bit in the value returned by 
<I>GetDeviceCaps</I> to indicate that they don't 
support raster operations of any type.</P>

<p><I>BitBlt</I> and other blitting functions produce the best results (and also 
perform the best) when the color characteristics of the source and destination DCs match. 
If you blit a 256-color bitmap to a 16-color destination DC, Windows must map the 
colors in the source DC to the colors in the destination DC. On some occasions, 
however, you can use color mapping to your advantage. When 
<I>BitBlt</I> blits a monochrome bitmap to a color DC, it converts 0 bits to the destination DC's current foreground 
color (<I>CDC::SetTextColor</I>) and 1 bits to the destination DC's current background 
color (<I>CDC::SetBkColor</I>). Conversely, when it blits a color bitmap to a monochrome 
DC, <I>BitBlt</I> converts pixels that match the destination DC's background color to 1 and 
all other pixels to 0. You can use the latter form of color mapping to create a 
monochrome mask from a color bitmap and use that mask in a routine that blits all 
pixels except those of a certain color from a bitmap to a screen DC, in effect creating 
transparent pixels in the bitmap.</P>

<p>Sound interesting? Icons implement transparent pixels by storing two 
bitmaps for every icon image: a monochrome AND mask and a color XOR mask. You can 
draw bitmaps with transparent pixels by writing an output routine that uses 
<I>BitBlt</I>s and raster operations to build the AND and XOR masks on the fly. The BitmapDemo 
sample program in the next section shows how.</P>

<A NAME="470"><H2>The BitmapDemo Application</H2></A>

<P>BitmapDemo is a non-document/view application created with AppWizard that 
demonstrates how to load a bitmap resource and 
<I>BitBlt</I> it to the screen. It also shows how to make clever use of 
<I>BitBlt</I>s and raster-op codes to blit irregularly shaped images 
by designating one color in the bitmap as the transparency color. The program's 
output consists of a rectangular array of bitmap images drawn against a background that 
fades from blue to black. When Draw Opaque is checked in the Options menu, 
bitmaps are blitted to the screen unchanged, producing the result shown in Figure 15-5. 
If Draw Transparent is checked instead, red pixels are removed from the bitmaps 
when they're blitted to the screen. The result is pictured in Figure 15-6.</P>

<p>
<A HREF="javascript:fullSize('F15mg05x.htm')"> <img src="images/F15mg05.JPG" width=404 height=302 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 15-5.</B> <I>The BitmapDemo window with transparency disabled.</I><!-- /CAPTION -->
</p>
<p>
<A HREF="javascript:fullSize('F15mg06x.htm')"> <img src="images/F15mg06.JPG" width=404 height=302 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 15-6.</B> <I>The BitmapDemo window with transparency enabled.</I><!-- /CAPTION -->
</p>

<p>BitmapDemo uses a <I>CBitmap</I>-derived class named 
<I>CMaskedBitmap</I> to represent bitmaps. 
<I>CMaskedBitmap</I> contains two member functions that 
<I>CBitmap</I> doesn't: a <I>Draw</I> function for blitting a bitmap to a DC and a 
<I>DrawTransparent</I> function for blitting a bitmap to a DC and simultaneously filtering out all pixels of a specified 
color. With <I>CMaskedBitmap</I> to lend a hand, the statements</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
CMaskedBitmap bitmap;
bitmap.LoadBitmap (IDB_BITMAP);
bitmap.Draw (pDC, x, y);
</PRE>
</td></tr></table></P>

<P>are all you need to create a bitmap object, load a bitmap resource into it, and 
draw that bitmap on the device represented by 
<I>pDC</I>. The <I>x</I> and <I>y</I> parameters specify 
the placement of the bitmap's upper left corner. The statements</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
CMaskedBitmap bitmap;
bitmap.LoadBitmap (IDB_BITMAP);
bitmap.DrawTransparent (pDC, x, y, RGB (255, 0, 255));
</PRE>
</td></tr></table></P>

<P>do the same but don't blit any pixels in the bitmap whose color is bright 
magenta&#8212;RGB (255, 0, 255). With 
<I>CMaskedBitmap</I> to help out, drawing bitmaps with 
&quot;holes&quot; or nonrectangular profiles is easy: just assign all the transparent pixels in the 
bitmap a common color and pass that color to 
<I>DrawTransparent</I>. <I>DrawTransparent</I> will 
see to it that the transparent pixels don't get blitted along with the others.</P>

<P>The source code for <I>CMaskedBitmap::Draw</I> should look familiar to you: 
it's identical to the <I>DrawBitmap</I> function discussed earlier. 
<I>CMaskedBitmap::DrawTransparent</I> is a little more complicated. The comments in the source code 
should help you understand what's going on. If the comments don't make things clear 
enough, here's a summary of the steps involved in blitting a bitmap to the screen but 
omitting pixels of a certain color:</P>

<OL>
<P><LI>Create a memory DC, and select the bitmap into it.</LI></P>
<P><LI>Create a second memory DC, and select in a monochrome bitmap 
whose size is identical to that of the original bitmap. Create an AND mask by 
setting the background color of the memory DC created in step 1 to the 
transparency color and blitting the bitmap to the DC. The resultant AND mask 
has 1s everywhere the original bitmap has pixels whose color equals the 
transparency color and 0s everywhere else.</LI></P>
<P><LI>Create a third memory DC, and select in a bitmap whose size and 
color characteristics match those of the original bitmap. Create an XOR mask 
in this DC by first blitting the image from the memory DC created in step 
1 to this DC with a SRCCOPY raster-op code and then blitting the AND 
mask to this DC with the raster-op code 0x220326.</LI></P>
<P><LI>Create a fourth memory DC, and select in a bitmap whose size and 
color characteristics match those of the original bitmap. Blit the pixels from 
the rectangle in which the bitmap will go in the output DC to the newly 
created memory DC.</LI></P>
<P><LI>Create the final image in the memory DC created in step 4 by first 
blitting in the AND mask with a SRCAND raster-op code and then blitting in 
the XOR mask with a SRCINVERT raster-op code.</LI></P>
<P><LI>Copy the image from the memory DC to the output DC.</LI></P>
</OL>

<P>Notice how <I>BitBlt</I> is used to generate the AND mask in step 2. Because the 
destination DC is monochrome, the GDI translates pixels whose color equals the 
background color to 1s and all other pixels to 0s at the destination. It's important to set the 
source DC's background color equal to the bitmap's transparency color first so that the 
transformation will be performed properly. If you look at the code in 
<I>CMaskedBitmap::DrawTransparent</I> that corresponds to step 2, you'll see that the destination 
DC's size and color characteristics are set by using 
<I>CBitmap::CreateBitmap</I> to create a monochrome bitmap whose dimensions equal the dimensions of the original 
bitmap and then selecting the monochrome bitmap into the DC. You control the size of 
a memory DC's display surface and the number of colors that it supports by 
selecting a bitmap into it. That's why you see so many calls to 
<I>CreateBitmap</I> and 
<I>CreateCompatibleBitmap</I> in 
<I>DrawTransparent</I>.</P>

<P>One other point of interest in 
<I>DrawTransparent</I> is the raster-op code 
0x220326 used in step 3, which performs the following raster operation involving pixels at 
the source and destination.</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
dest = (NOT src) AND dest
</PRE>
</td></tr></table></P>

<P>You can accomplish the same thing using &quot;standard&quot; raster-op codes by calling 
<I>BitBlt</I> twice: once with the raster-op code NOTSRCCOPY to invert the image in the 
source DC and again with SRCAND to AND the inverted image with the pixels in the 
destination DC. One <I>BitBlt</I> is obviously more efficient than two, but don't be surprised 
if the 0x220326 code doesn't perform any faster than the NOTSRCCOPY/SRCAND 
combination on some PCs. Most display drivers are optimized to perform certain 
raster operations faster than others, and it's always possible that a NOTSRCCOPY or 
a SRCAND will execute very quickly but a 0x220326 won't.</P>

<P>As you experiment with BitmapDemo (whose source code appears 
in Figure 15-7), notice that the window takes longer to repaint when BitmapDemo 
draws transparent pixels. That's because 
<I>DrawTransparent</I> has to do a lot more work 
than <I>Draw</I> to get a single image to the screen. The worst performance hit occurs 
when <I>DrawTransparent</I> generates the same AND and XOR masks over and over again. 
If you want the functionality of 
<I>DrawTransparent</I> in an application in which 
output performance is critical (for example, if you use transparent bitmaps to create 
spritelike objects that move about the screen), you should modify the 
<I>CMaskedBitmap</I> class so that the masks are generated just once and then reused as needed. Performance 
can also be improved by applying the AND and XOR masks directly to the 
destination DC rather than to a memory DC containing a copy of the pixels at the 
destination, but the small amount of flickering produced by the short delay between the 
application of the masks might be too much if you're using the bitmap for animation.</P>

<P><B>Figure 15-7.</B> <I>The BitmapDemo application.</I></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="471"><H3>MainFrm.h</H3></A>
<PRE>
// MainFrm.h : interface of the CMainFrame class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(
    AFX_MAINFRM_H__D71EF549_A6FE_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_MAINFRM_H__D71EF549_A6FE_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#include &quot;ChildView.h&quot;

class CMainFrame : public CFrameWnd
{
public:
    CMainFrame();
protected: 
    DECLARE_DYNAMIC(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, 
        AFX_CMDHANDLERINFO* pHandlerInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:  // control bar embedded members
    CStatusBar  m_wndStatusBar;
    CChildView    m_wndView;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSetFocus(CWnd *pOldWnd);
    afx_msg BOOL OnQueryNewPalette();
    afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//     AFX_MAINFRM_H__D71EF549_A6FE_11D2_8E53_006008A82731__INCLUDED_)
</PRE>
</td></tr></table></P>



<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="472"><H3>MainFrm.cpp</H3></A>
<PRE>
// MainFrm.cpp : implementation of the CMainFrame class
//

#include &quot;stdafx.h&quot;
#include &quot;BitmapDemo.h&quot;
#include &quot;MaskedBitmap.h&quot;
#include &quot;MainFrm.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_WM_SETFOCUS()
    ON_WM_QUERYNEWPALETTE()
    ON_WM_PALETTECHANGED()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR
};

///////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction
CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    // create a view to occupy the client area of the frame
    if (!m_wndView.Create(NULL, NULL, AFX_WS_DEFAULT_VIEW,
        CRect(0, 0, 0, 0), this, AFX_IDW_PANE_FIRST, NULL))
    {
        TRACE0(&quot;Failed to create view window\n&quot;);
        return -1;
    }

    if (!m_wndStatusBar.Create(this) &#166;&#166;
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0(&quot;Failed to create status bar\n&quot;);
        return -1;      // fail to create
    }

    return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    cs.dwExStyle &amp;= ~WS_EX_CLIENTEDGE;
    cs.lpszClass = AfxRegisterWndClass(0);
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext&amp; dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
void CMainFrame::OnSetFocus(CWnd* pOldWnd)
{
    // forward focus to the view window
    m_wndView.SetFocus();
}

BOOL CMainFrame::OnCmdMsg(UINT nID, int nCode, void* pExtra, 
    AFX_CMDHANDLERINFO* pHandlerInfo)
{
    // let the view have first crack at the command
    if (m_wndView.OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // otherwise, do default handling
    return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}

BOOL CMainFrame::OnQueryNewPalette() 
{
    m_wndView.Invalidate ();
    return TRUE;
}

void CMainFrame::OnPaletteChanged(CWnd* pFocusWnd) 
{
    m_wndView.Invalidate ();
}
</PRE>
</td></tr></table></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="473"><H3>ChildView.h</H3></A>
<PRE>
// ChildView.h : interface of the CChildView class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(
    AFX_CHILDVIEW_H__D71EF54B_A6FE_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_CHILDVIEW_H__D71EF54B_A6FE_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

///////////////////////////////////////////////////////////////////////////
// CChildView window

class CChildView : public CWnd
{
// Construction
public:
    CChildView();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChildView)
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CChildView();

    // Generated message map functions
protected:
    void DoGradientFill (CDC* pDC, LPRECT pRect);
    CPalette m_palette;
    CMaskedBitmap m_bitmap;
    BOOL m_bDrawOpaque;
    //{{AFX_MSG(CChildView)
    afx_msg void OnPaint();
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg BOOL OnEraseBkgnd(CDC* pDC);
    afx_msg void OnOptionsDrawOpaque();
    afx_msg void OnOptionsDrawTransparent();
    afx_msg void OnUpdateOptionsDrawOpaque(CCmdUI* pCmdUI);
    afx_msg void OnUpdateOptionsDrawTransparent(CCmdUI* pCmdUI);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//     AFX_CHILDVIEW_H__D71EF54B_A6FE_11D2_8E53_006008A82731__INCLUDED_)
</PRE>
</td></tr></table></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="474"><H3>ChildView.cpp</H3></A>
<PRE>
// ChildView.cpp : implementation of the CChildView class
//

#include &quot;stdafx.h&quot;
#include &quot;BitmapDemo.h&quot;
#include &quot;MaskedBitmap.h&quot;
#include &quot;ChildView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CChildView

CChildView::CChildView()
{
    m_bDrawOpaque = TRUE;
}

CChildView::~CChildView()
{
}

BEGIN_MESSAGE_MAP(CChildView,CWnd )
    //{{AFX_MSG_MAP(CChildView)
    ON_WM_PAINT()
    ON_WM_CREATE()
    ON_WM_ERASEBKGND()
    ON_COMMAND(ID_OPTIONS_DRAW_OPAQUE, OnOptionsDrawOpaque)
    ON_COMMAND(ID_OPTIONS_DRAW_TRANSPARENT, OnOptionsDrawTransparent)
    ON_UPDATE_COMMAND_UI(ID_OPTIONS_DRAW_OPAQUE, OnUpdateOptionsDrawOpaque)
    ON_UPDATE_COMMAND_UI(ID_OPTIONS_DRAW_TRANSPARENT, 
        OnUpdateOptionsDrawTransparent)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CChildView message handlers

BOOL CChildView::PreCreateWindow(CREATESTRUCT&amp; cs) 
{
    if (!CWnd::PreCreateWindow(cs))
        return FALSE;

    cs.dwExStyle &#166;= WS_EX_CLIENTEDGE;
    cs.style &amp;= ~WS_BORDER;
    cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW&#166;CS_VREDRAW&#166;CS_DBLCLKS, 
        ::LoadCursor(NULL, IDC_ARROW), HBRUSH(COLOR_WINDOW+1), NULL);

    return TRUE;
}

void CChildView::OnPaint() 
{
    CRect rect;
    GetClientRect (&amp;rect);
    CPaintDC dc (this);

    BITMAP bm;
    m_bitmap.GetBitmap (&amp;bm);
    int cx = (rect.Width () / (bm.bmWidth + 8)) + 1;
    int cy = (rect.Height () / (bm.bmHeight + 8)) + 1;

    int i, j, x, y;
    for (i=0; i&lt;cx; i++) {
        for (j=0; j&lt;cy; j++) {
            x = 8 + (i * (bm.bmWidth + 8));
            y = 8 + (j * (bm.bmHeight + 8));
            if (m_bDrawOpaque)
                m_bitmap.Draw (&amp;dc, x, y);
            else
                m_bitmap.DrawTransparent (&amp;dc, x, y, RGB (255, 0, 0));
        }
    }
}

int CChildView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CWnd ::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    //
    // Load the bitmap.
    //
    m_bitmap.LoadBitmap (IDB_BITMAP);

    //
    // Create a palette for a gradient fill if this is a palettized device.
    //
    CClientDC dc (this);
    if (dc.GetDeviceCaps (RASTERCAPS) &amp; RC_PALETTE) {
        struct {
            LOGPALETTE lp;
            PALETTEENTRY ape[63];
        } pal;

        LOGPALETTE* pLP = (LOGPALETTE*) &amp;pal;
        pLP-&gt;palVersion = 0x300;
        pLP-&gt;palNumEntries = 64;

        for (int i=0; i&lt;64; i++) {
            pLP-&gt;palPalEntry[i].peRed = 0;
            pLP-&gt;palPalEntry[i].peGreen = 0;
            pLP-&gt;palPalEntry[i].peBlue = 255 - (i * 4);
            pLP-&gt;palPalEntry[i].peFlags = 0;
        }
        m_palette.CreatePalette (pLP);
    }
    return 0;
}
BOOL CChildView::OnEraseBkgnd(CDC* pDC) 
{
    CRect rect;
    GetClientRect (&amp;rect);

    CPalette* pOldPalette;
    if ((HPALETTE) m_palette != NULL) {
        pOldPalette = pDC-&gt;SelectPalette (&amp;m_palette, FALSE);
        pDC-&gt;RealizePalette ();
    }

    DoGradientFill (pDC, &amp;rect);

    if ((HPALETTE) m_palette != NULL)
        pDC-&gt;SelectPalette (pOldPalette, FALSE);
    return TRUE;
}

void CChildView::DoGradientFill(CDC *pDC, LPRECT pRect)
{
    CBrush* pBrush[64];
    for (int i=0; i&lt;64; i++)
        pBrush[i] = new CBrush (PALETTERGB (0, 0, 255 - (i * 4)));

    int nWidth = pRect-&gt;right - pRect-&gt;left;
    int nHeight = pRect-&gt;bottom - pRect-&gt;top;
    CRect rect;

    for (i=0; i&lt;nHeight; i++) {
        rect.SetRect (0, i, nWidth, i + 1);
        pDC-&gt;FillRect (&amp;rect, pBrush[(i * 63) / nHeight]);
    }

    for (i=0; i&lt;64; i++)
        delete pBrush[i];
}

void CChildView::OnOptionsDrawOpaque() 
{
    m_bDrawOpaque = TRUE;
    Invalidate ();
}

void CChildView::OnOptionsDrawTransparent() 
{
    m_bDrawOpaque = FALSE;
    Invalidate ();
}

void CChildView::OnUpdateOptionsDrawOpaque(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;SetCheck (m_bDrawOpaque ? 1 : 0);
}

void CChildView::OnUpdateOptionsDrawTransparent(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;SetCheck (m_bDrawOpaque ? 0 : 1);
}
</PRE>
</td></tr></table></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="475"><H3>MaskedBitmap.h</H3></A>
<PRE>
// MaskedBitmap.h: interface for the CMaskedBitmap class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(
    AFX_MASKEDBITMAP_H__D71EF554_A6FE_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_MASKEDBITMAP_H__D71EF554_A6FE_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

class CMaskedBitmap : public CBitmap  
{
public:
    void DrawTransparent (CDC* pDC, int x, int y, 
        COLORREF clrTransparency);
    void Draw (CDC* pDC, int x, int y);
};

#endif 
// !defined(
//     AFX_MASKEDBITMAP_H__D71EF554_A6FE_11D2_8E53_006008A82731__INCLUDED_)
</PRE>
</td></tr></table></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="476"><H3>MaskedBitmap.cpp</H3></A>
<PRE>
// MaskedBitmap.cpp: implementation of the CMaskedBitmap class.
//
//////////////////////////////////////////////////////////////////////

#include &quot;stdafx.h&quot;
#include &quot;BitmapDemo.h&quot;
#include &quot;MaskedBitmap.h&quot;

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

void CMaskedBitmap::Draw(CDC *pDC, int x, int y)
{
    BITMAP bm;
    GetBitmap (&amp;bm);
    CPoint size (bm.bmWidth, bm.bmHeight);
    pDC-&gt;DPtoLP (&amp;size);

    CPoint org (0, 0);
    pDC-&gt;DPtoLP (&amp;org);

    CDC dcMem;
    dcMem.CreateCompatibleDC (pDC);
    CBitmap* pOldBitmap = dcMem.SelectObject (this);
    dcMem.SetMapMode (pDC-&gt;GetMapMode ());

    pDC-&gt;BitBlt (x, y, size.x, size.y, &amp;dcMem, org.x, org.y, SRCCOPY);

    dcMem.SelectObject (pOldBitmap);
}

void CMaskedBitmap::DrawTransparent(CDC *pDC, int x, int y,
    COLORREF clrTransparency)
{
    BITMAP bm;
    GetBitmap (&amp;bm);
    CPoint size (bm.bmWidth, bm.bmHeight);
    pDC-&gt;DPtoLP (&amp;size);

    CPoint org (0, 0);
    pDC-&gt;DPtoLP (&amp;org);

    //
    // Create a memory DC (dcImage) and select the bitmap into it.
    //
    CDC dcImage;
    dcImage.CreateCompatibleDC (pDC);
    CBitmap* pOldBitmapImage = dcImage.SelectObject (this);
    dcImage.SetMapMode (pDC-&gt;GetMapMode ());

    //
    // Create a second memory DC (dcAnd) and in it create an AND mask.
    //
    CDC dcAnd;
    dcAnd.CreateCompatibleDC (pDC);
    dcAnd.SetMapMode (pDC-&gt;GetMapMode ());

    CBitmap bitmapAnd;
    bitmapAnd.CreateBitmap (bm.bmWidth, bm.bmHeight, 1, 1, NULL);
    CBitmap* pOldBitmapAnd = dcAnd.SelectObject (&amp;bitmapAnd);

    dcImage.SetBkColor (clrTransparency);
    dcAnd.BitBlt (org.x, org.y, size.x, size.y, &amp;dcImage, org.x, org.y,
        SRCCOPY);

    //
    // Create a third memory DC (dcXor) and in it create an XOR mask.
    //
    CDC dcXor;
    dcXor.CreateCompatibleDC (pDC);
    dcXor.SetMapMode (pDC-&gt;GetMapMode ());

    CBitmap bitmapXor;
    bitmapXor.CreateCompatibleBitmap (&amp;dcImage, bm.bmWidth, bm.bmHeight);
    CBitmap* pOldBitmapXor = dcXor.SelectObject (&amp;bitmapXor);

    dcXor.BitBlt (org.x, org.y, size.x, size.y, &amp;dcImage, org.x, org.y,
        SRCCOPY);

    dcXor.BitBlt (org.x, org.y, size.x, size.y, &amp;dcAnd, org.x, org.y,
        0x220326);

    //
    // Copy the pixels in the destination rectangle to a temporary
    // memory DC (dcTemp).
    //
    CDC dcTemp;
    dcTemp.CreateCompatibleDC (pDC);
    dcTemp.SetMapMode (pDC-&gt;GetMapMode ());

    CBitmap bitmapTemp;
    bitmapTemp.CreateCompatibleBitmap (&amp;dcImage, bm.bmWidth, bm.bmHeight);
    CBitmap* pOldBitmapTemp = dcTemp.SelectObject (&amp;bitmapTemp);

    dcTemp.BitBlt (org.x, org.y, size.x, size.y, pDC, x, y, SRCCOPY);

    //
    // Generate the final image by applying the AND and XOR masks to
    // the image in the temporary memory DC.
    //
    dcTemp.BitBlt (org.x, org.y, size.x, size.y, &amp;dcAnd, org.x, org.y,
        SRCAND);

    dcTemp.BitBlt (org.x, org.y, size.x, size.y, &amp;dcXor, org.x, org.y,
        SRCINVERT);

    //
    // Blit the resulting image to the screen.
    //
    pDC-&gt;BitBlt (x, y, size.x, size.y, &amp;dcTemp, org.x, org.y, SRCCOPY);

    //
    // Restore the default bitmaps.
    //
    dcTemp.SelectObject (pOldBitmapTemp);
    dcXor.SelectObject (pOldBitmapXor);
    dcAnd.SelectObject (pOldBitmapAnd);
    dcImage.SelectObject (pOldBitmapImage);
}
</PRE>
</td></tr></table></P>

<P>Both Windows 98 and Windows 2000 support a new API function named 
<I>::TransparentBlt</I> that performs the equivalent of a 
<I>StretchBlt</I> and also accepts a transparency color. Like BitmapDemo's 
<I>DrawTransparent</I> function, 
<I>::TransparentBlt</I> skips pixels whose color equals the transparency color. I didn't use 
<I>::TransparentBlt</I> because I wanted BitmapDemo to work as well on down-level systems as it works on Windows 98 
and Windows 2000 systems. Which of these transparency functions you should use 
depends on the platforms you're targeting.</P>

<A NAME="477"><H2>Writing a BMP File Viewer</H2></A>

<P>The disk-and-drive image drawn by BitmapDemo looks pretty good because it's 
a simple 16-color bitmap whose colors match the static colors in the system palette. 
As long as you draw the bitmaps yourself and stick to the colors in the default 
palette, bitmaps will display just fine without custom 
<I>CPalette</I>s. But if you write an application that reads arbitrary BMP files created by other programs and you rely on the 
default palette for color mapping, bitmaps containing 256 or more colors will be 
posterized&#8212;some rather severely. You can dramatically improve the quality of the output 
by creating a <I>CPalette</I> whose colors match the colors in the bitmap. The sample 
program in this section demonstrates how. It also shows one way that MFC 
programmers can combine <I>CBitmap</I>s with DIB sections to create more functional bitmaps.</P>

<p>The sample program, which I'll call Vista, is shown in Figure 15-8. Vista is 
a document/view BMP file viewer that will read virtually any BMP file containing 
any number of colors and draw a reasonable representation of it on a screen that's 
capable of displaying 256 or more colors. (Vista works with 16-color screens, too, 
but don't expect a lot from the output if the bitmap contains more than 16 colors.) 
The source code, selected portions of which appear in Figure 15-9, is surprisingly simple. Other than the code that creates a logical palette after 
a BMP file is read from disk, the application includes very little other than the 
standard stuff that forms the core of every document/view application.</P>

<P>
<A HREF="javascript:fullSize('F15mg08x.htm')"> <img src="images/F15mg08.JPG" width=404 height=336 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 15-8.</B> <I>The Vista window with a bitmap displayed.</I><!-- /CAPTION -->
</p>

<P>The view's <I>OnDraw</I> function displays bitmaps on the screen by selecting 
the logical palette associated with the bitmap into the device context (provided such 
a palette exists) and <I>BitBlt</I>ing the bitmap to a 
<I>CScrollView</I>. <I>OnDraw</I> retrieves the 
logical palette by calling the document's 
<I>GetPalette</I> function, and it retrieves the 
bitmap by calling the document's <I>GetBitmap</I> function. 
<I>GetPalette</I> returns a <I>CPalette</I> 
pointer to the palette that the document object creates when the bitmap is loaded. A 
NULL return means that no palette is associated with the bitmap, which in turn means 
that Vista is running on a nonpalettized video adapter. 
<I>GetBitmap</I> returns a pointer to the bitmap that constitutes the document itself. Vista's document class 
<I>CVistaDoc </I>stores the bitmap in a 
<I>CBitmap</I> data member named <I>m_bitmap</I> and the palette (if any) 
that goes with the bitmap in a <I>CPalette</I> member named 
<I>m_palette</I>. The bitmap and palette objects are initialized when the document's 
<I>OnOpenDocument</I> function is called (when the user selects Open from the File menu) and destroyed when the 
document's <I>DeleteContents</I> function is called.</P>

<P>One simple statement in <I>OnOpenDocument</I> reads the BMP file named in 
the function's parameter list:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
HBITMAP hBitmap = (HBITMAP) ::LoadImage (NULL, lpszPathName,
    IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE &#166; LR_CREATEDIBSECTION);
</PRE>
</td></tr></table></P>

<P>The value returned by <I>::LoadImage</I> is a valid HBITMAP if the DIB section was 
successfully created and NULL if it wasn't. If 
<I>::LoadImage</I> fails, it's highly likely that 
the file doesn't contain a DIB. 
<I>OnOpenDocument</I> indicates as much in the error 
message it displays when <I>::LoadImage</I> returns NULL. If the HBITMAP isn't NULL, 
<I>OnOpenDocument</I> attaches it to 
<I>m_bitmap</I>. The document (bitmap) is now loaded and 
ready to be displayed&#8212;almost.</P>

<p>If Vista is running on a palettized display device, the bitmap probably 
won't look very good unless there's a logical palette to go with it. After 
<I>::LoadImage</I> returns, <I>OnOpenDocument</I> grabs a device context and calls 
<I>GetDeviceCaps</I> to determine whether palettes are supported. If the return value doesn't contain an 
RC_PALETTE flag, <I>OnOpenDocument</I> returns immediately and leaves 
<I>m_palette</I> uninitialized. Otherwise, 
<I>OnOpenDocument</I> initializes <I>m_palette</I> with a logical palette.</P>

<p>To determine how best to create the palette, 
<I>OnOpenDocument</I> first finds out how many colors the bitmap contains by calling 
<I>GetObject</I> with a pointer to a DIBSECTION structure. One of the members of a DIBSECTION structure is a 
BITMAPINFOHEADER structure, and the BITMAPINFOHEADER structure's 
<I>biClrUsed</I> and <I>biBitCount</I> fields reveal the number of colors in the bitmap. If 
<I>biClrUsed</I> is nonzero, it specifies the color count. If 
<I>biClrUsed</I> is 0, the number of colors equals</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
1 &lt;&lt; biBitCount
</PRE>
</td></tr></table></P>

<P>The following code in <I>OnOpenDocument</I> sets 
<I>nColors</I> equal to the number of colors in the bitmap:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
DIBSECTION ds;
m_bitmap.GetObject (sizeof (DIBSECTION), &amp;ds);

int nColors;
if (ds.dsBmih.biClrUsed != 0)
    nColors = ds.dsBmih.biClrUsed;
else
    nColors = 1 &lt;&lt; ds.dsBmih.biBitCount;
</PRE>
</td></tr></table></P>

<P>What <I>OnOpenDocument</I> does next depends on the value of 
<I>nColors</I>. If <I>nColors</I> is greater than 256, indicating that the bitmap has a color depth of 16, 24, or 32 
bits (images stored in BMP files always use 1-bit, 4-bit, 8-bit, 16-bit, 24-bit, or 32-bit 
color), <I>OnOpenDocument</I> creates a halftone palette by calling 
<I>CPalette::CreateHalftonePalette</I> with a pointer to the screen DC it obtained earlier:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
if (nColors &gt; 256)
    m_palette.CreateHalftonePalette (&amp;dc);
</PRE>
</td></tr></table></P>

<P>In return, the system creates a generic palette with a rainbow of colors that's 
suited to the device context. In most cases, a logical palette created by 
<I>CreateHalftonePalette</I> will contain 256 colors. That's not enough to allow a bitmap containing thousands 
or perhaps millions of colors to be displayed with 100 percent accuracy, but it will 
produce much better results than you'd get if you used the device context's default palette.</P>

<p>If <I>nColors</I> is less than or equal to 256, 
<I>OnOpenDocument</I> initializes <I>m_palette</I> with a logical palette whose colors match the colors in the bitmap. The key to 
matching the bitmap's colors is the API function 
<I>::GetDIBColorTable</I>, which copies the color table associated with a 1-bit, 4-bit, or 8-bit DIB section to an array of RGBQUAD 
structures. That array, in turn, is used to initialize an array of PALETTEENTRY 
structures and create a logical palette:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
RGBQUAD* pRGB = new RGBQUAD[nColors];

CDC memDC;
memDC.CreateCompatibleDC (&amp;dc);
CBitmap* pOldBitmap = memDC.SelectObject (&amp;m_bitmap);
::GetDIBColorTable ((HDC) memDC, 0, nColors, pRGB);
memDC.SelectObject (pOldBitmap);

UINT nSize = sizeof (LOGPALETTE) +
    (sizeof (PALETTEENTRY) * (nColors - 1));
LOGPALETTE* pLP = (LOGPALETTE*) new BYTE[nSize];

pLP-&gt;palVersion = 0x300;
pLP-&gt;palNumEntries = nColors;

for (int i=0; i&lt;nColors; i++) {
    pLP-&gt;palPalEntry[i].peRed = pRGB[i].rgbRed;
    pLP-&gt;palPalEntry[i].peGreen = pRGB[i].rgbGreen;
    pLP-&gt;palPalEntry[i].peBlue = pRGB[i].rgbBlue;
    pLP-&gt;palPalEntry[i].peFlags = 0;
}

m_palette.CreatePalette (pLP);
</PRE>
</td></tr></table></P>

<P><I>::GetDIBColorTable</I> works only if the DIB section is selected into a device 
context, so <I>OnOpenDocument</I> creates a memory DC and selects 
<I>m_bitmap</I> into it before making the call. The rest is just detail: allocating memory for a LOGPALETTE 
structure, transferring the RGBQUAD values from the color table to the corresponding 
PALETTEENTRY entries, and calling 
<I>CreatePalette</I>. Once it has a palette to work with, 
Vista will display most 256-color bitmaps with stunning accuracy on 256-color screens.</P>

<p>For a nice touch, Vista includes a readout in its status bar that identifies 
the bitmap's dimensions and color depth (bits per pixel). The status bar is updated 
when <I>OnOpenDocument</I> sends Vista's main window a WM_USER_UPDATE_STATS 
message containing a pointer to the string that it wants to appear in the status bar pane. 
A message handler in the frame window class fields the message and updates the 
status bar accordingly.</P>

<P><B>Figure 15-9.</B> <I>The Vista application.</I></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="478"><H3>MainFrm.h</H3></A>
<PRE>
// MainFrm.h : interface of the CMainFrame class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(
    AFX_MAINFRM_H__3597FEA9_A70E_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_MAINFRM_H__3597FEA9_A70E_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

class CMainFrame : public CFrameWnd
{
    
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:  // control bar embedded members
    CStatusBar  m_wndStatusBar;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg BOOL OnQueryNewPalette();
    afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
    //}}AFX_MSG
    afx_msg LRESULT OnUpdateImageStats (WPARAM wParam, LPARAM lParam);
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(AFX_MAINFRM_H__3597FEA9_A70E_11D2_8E53_006008A82731__INCLUDED_)
</PRE>
</td></tr></table></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="479"><H3>MainFrm.cpp</H3></A>
<PRE>
// MainFrm.cpp : implementation of the CMainFrame class
//

#include &quot;stdafx.h&quot;
#include &quot;Vista.h&quot;

#include &quot;MainFrm.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_WM_QUERYNEWPALETTE()
    ON_WM_PALETTECHANGED()
    //}}AFX_MSG_MAP
    ON_MESSAGE (WM_USER_UPDATE_STATS, OnUpdateImageStats)
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,
    ID_SEPARATOR
};

///////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    //
    // Create the status bar.
    //
    if (!m_wndStatusBar.Create(this) &#166;&#166;
        !m_wndStatusBar.SetIndicators(indicators,
            sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0(&quot;Failed to create status bar\n&quot;);
        return -1;      // fail to create
    }

    //
    // Size the status bar's rightmost pane to hold a text string.
    //
    TEXTMETRIC tm;
    CClientDC dc (this);
    CFont* pFont = m_wndStatusBar.GetFont ();
    CFont* pOldFont = dc.SelectObject (pFont);
    dc.GetTextMetrics (&amp;tm);
    dc.SelectObject (pOldFont);

    int cxWidth;
    UINT nID, nStyle;
    m_wndStatusBar.GetPaneInfo (1, nID, nStyle, cxWidth);
    cxWidth = tm.tmAveCharWidth * 24;
    m_wndStatusBar.SetPaneInfo (1, nID, nStyle, cxWidth);
    return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext&amp; dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

BOOL CMainFrame::OnQueryNewPalette() 
{
    CDocument* pDoc = GetActiveDocument ();
    if (pDoc != NULL)
        GetActiveDocument ()-&gt;UpdateAllViews (NULL);
    return TRUE;
}

void CMainFrame::OnPaletteChanged(CWnd* pFocusWnd) 
{
    if (pFocusWnd != this) {
        CDocument* pDoc = GetActiveDocument ();
        if (pDoc != NULL)
            GetActiveDocument ()-&gt;UpdateAllViews (NULL);
    }
}

LRESULT CMainFrame::OnUpdateImageStats (WPARAM wParam, LPARAM lParam)
{
    m_wndStatusBar.SetPaneText (1, (LPCTSTR) lParam, TRUE);
    return 0;
}
</PRE>
</td></tr></table></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="480"><H3>VistaDoc.h</H3></A>
<PRE>
// VistaDoc.h : interface of the CVistaDoc class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(
    AFX_VISTADOC_H__3597FEAB_A70E_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_VISTADOC_H__3597FEAB_A70E_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000


class CVistaDoc : public CDocument
{
protected: // create from serialization only
    CVistaDoc();
    DECLARE_DYNCREATE(CVistaDoc)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CVistaDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive&amp; ar);
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    virtual void DeleteContents();
    //}}AFX_VIRTUAL

// Implementation
public:
    CPalette* GetPalette();
    CBitmap* GetBitmap();
    virtual ~CVistaDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:

// Generated message map functions
protected:
    CPalette m_palette;
    CBitmap m_bitmap;
    //{{AFX_MSG(CVistaDoc)
       // NOTE - the ClassWizard will add and remove member functions here.
       //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//     AFX_VISTADOC_H__3597FEAB_A70E_11D2_8E53_006008A82731__INCLUDED_)
</PRE>
</td></tr></table></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="481"><H3>VistaDoc.cpp</H3></A>
<PRE>
// VistaDoc.cpp : implementation of the CVistaDoc class
//

#include &quot;stdafx.h&quot;
#include &quot;Vista.h&quot;

#include &quot;VistaDoc.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CVistaDoc

IMPLEMENT_DYNCREATE(CVistaDoc, CDocument)

BEGIN_MESSAGE_MAP(CVistaDoc, CDocument)
    //{{AFX_MSG_MAP(CVistaDoc)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CVistaDoc construction/destruction

CVistaDoc::CVistaDoc()
{
}

CVistaDoc::~CVistaDoc()
{
}

BOOL CVistaDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CVistaDoc serialization

void CVistaDoc::Serialize(CArchive&amp; ar)
{
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
}

///////////////////////////////////////////////////////////////////////////
// CVistaDoc diagnostics

#ifdef _DEBUG
void CVistaDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CVistaDoc::Dump(CDumpContext&amp; dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CVistaDoc commands

BOOL CVistaDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
    if (!CDocument::OnOpenDocument (lpszPathName))
        return FALSE;

    //
    // Open the file and create a DIB section from its contents.
    //
    HBITMAP hBitmap = (HBITMAP) ::LoadImage (NULL, lpszPathName,
        IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE &#166; LR_CREATEDIBSECTION);

    if (hBitmap == NULL) {
        CString string;
        string.Format (_T (&quot;%s does not contain a DIB&quot;), lpszPathName);
        AfxMessageBox (string);
        return FALSE;
    }

    m_bitmap.Attach (hBitmap);

    //
    // Return now if this device doesn't support palettes.
    //
    CClientDC dc (NULL);
    if ((dc.GetDeviceCaps (RASTERCAPS) &amp; RC_PALETTE) == 0)
        return TRUE;

    //
    // Create a palette to go with the DIB section.
    //
    if ((HBITMAP) m_bitmap != NULL) {
        DIBSECTION ds;
        m_bitmap.GetObject (sizeof (DIBSECTION), &amp;ds);

        int nColors;
        if (ds.dsBmih.biClrUsed != 0)
            nColors = ds.dsBmih.biClrUsed;
        else
            nColors = 1 &lt;&lt; ds.dsBmih.biBitCount;

        //
        // Create a halftone palette if the DIB section contains more
        // than 256 colors.
        //
        if (nColors &gt; 256)
            m_palette.CreateHalftonePalette (&amp;dc);

        //
        // Create a custom palette from the DIB section's color table
        // if the number of colors is 256 or less.
        //
        else {
            RGBQUAD* pRGB = new RGBQUAD[nColors];

            CDC memDC;
            memDC.CreateCompatibleDC (&amp;dc);
            CBitmap* pOldBitmap = memDC.SelectObject (&amp;m_bitmap);
            ::GetDIBColorTable ((HDC) memDC, 0, nColors, pRGB);
            memDC.SelectObject (pOldBitmap);
            UINT nSize = sizeof (LOGPALETTE) +
                (sizeof (PALETTEENTRY) * (nColors - 1));
            LOGPALETTE* pLP = (LOGPALETTE*) new BYTE[nSize];

            pLP-&gt;palVersion = 0x300;
            pLP-&gt;palNumEntries = nColors;

            for (int i=0; i&lt;nColors; i++) {
                pLP-&gt;palPalEntry[i].peRed = pRGB[i].rgbRed;
                pLP-&gt;palPalEntry[i].peGreen = pRGB[i].rgbGreen;
                pLP-&gt;palPalEntry[i].peBlue = pRGB[i].rgbBlue;
                pLP-&gt;palPalEntry[i].peFlags = 0;
            }

            m_palette.CreatePalette (pLP);
            delete[] pLP;
            delete[] pRGB;
        }
    }
    return TRUE;
}

void CVistaDoc::DeleteContents() 
{
    if ((HBITMAP) m_bitmap != NULL)
        m_bitmap.DeleteObject ();

    if ((HPALETTE) m_palette != NULL)
        m_palette.DeleteObject ();
    
    CDocument::DeleteContents();
}

CBitmap* CVistaDoc::GetBitmap()
{
    return ((HBITMAP) m_bitmap == NULL) ? NULL : &amp;m_bitmap;
}

CPalette* CVistaDoc::GetPalette()
{
    return ((HPALETTE) m_palette == NULL) ? NULL : &amp;m_palette;
}
</PRE>
</td></tr></table></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="482"><H3>VistaView.h</H3></A>
<PRE>
// VistaView.h : interface of the CVistaView class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(
    AFX_VISTAVIEW_H__3597FEAD_A70E_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_VISTAVIEW_H__3597FEAD_A70E_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000


class CVistaView : public CScrollView
{
protected: // create from serialization only
    CVistaView();
    DECLARE_DYNCREATE(CVistaView)

// Attributes
public:
    CVistaDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CVistaView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    protected:
    virtual void OnInitialUpdate(); // called first time after construct
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CVistaView();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CVistaView)
       // NOTE - the ClassWizard will add and remove member functions here.
       //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in VistaView.cpp
inline CVistaDoc* CVistaView::GetDocument()
   { return (CVistaDoc*)m_pDocument; }
#endif

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(
//     AFX_VISTAVIEW_H__3597FEAD_A70E_11D2_8E53_006008A82731__INCLUDED_)
</PRE>
</td></tr></table></P>

<P><table cellpadding=5 width="95%"><tr><td>
<A NAME="483"><H3>VistaView.cpp</H3></A>
<PRE>
// VistaView.cpp : implementation of the CVistaView class
//

#include &quot;stdafx.h&quot;
#include &quot;Vista.h&quot;

#include &quot;VistaDoc.h&quot;
#include &quot;VistaView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CVistaView

IMPLEMENT_DYNCREATE(CVistaView, CScrollView)

BEGIN_MESSAGE_MAP(CVistaView, CScrollView)
    //{{AFX_MSG_MAP(CVistaView)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CVistaView construction/destruction

CVistaView::CVistaView()
{
}

CVistaView::~CVistaView()
{
}

BOOL CVistaView::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    return CScrollView::PreCreateWindow(cs);
}

///////////////////////////////////////////////////////////////////////////
// CVistaView drawing

void CVistaView::OnDraw(CDC* pDC)
{
    CVistaDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);

    CBitmap* pBitmap = pDoc-&gt;GetBitmap ();

    if (pBitmap != NULL) {
        CPalette* pOldPalette;
        CPalette* pPalette = pDoc-&gt;GetPalette ();

        if (pPalette != NULL) {
            pOldPalette = pDC-&gt;SelectPalette (pPalette, FALSE);
            pDC-&gt;RealizePalette ();
        }
        DIBSECTION ds;
        pBitmap-&gt;GetObject (sizeof (DIBSECTION), &amp;ds);

        CDC memDC;
        memDC.CreateCompatibleDC (pDC);
        CBitmap* pOldBitmap = memDC.SelectObject (pBitmap);

        pDC-&gt;BitBlt (0, 0, ds.dsBm.bmWidth, ds.dsBm.bmHeight, &amp;memDC,
            0, 0, SRCCOPY);

        memDC.SelectObject (pOldBitmap);

        if (pPalette != NULL)
            pDC-&gt;SelectPalette (pOldPalette, FALSE);
    }
}

void CVistaView::OnInitialUpdate()
{
    CScrollView::OnInitialUpdate ();

    CString string;
    CSize sizeTotal;
    CBitmap* pBitmap = GetDocument ()-&gt;GetBitmap ();

    //
    // If a bitmap is loaded, set the view size equal to the bitmap size.
    // Otherwise, set the view's width and height to 0.
    //
    if (pBitmap != NULL) {
        DIBSECTION ds;
        pBitmap-&gt;GetObject (sizeof (DIBSECTION), &amp;ds);
        sizeTotal.cx = ds.dsBm.bmWidth;
        sizeTotal.cy = ds.dsBm.bmHeight;
        string.Format (_T (&quot;\t%d x %d, %d bpp&quot;), ds.dsBm.bmWidth,
            ds.dsBm.bmHeight, ds.dsBmih.biBitCount);
    }
    else {
        sizeTotal.cx = sizeTotal.cy = 0;
        string.Empty ();
    }

    AfxGetMainWnd ()-&gt;SendMessage (WM_USER_UPDATE_STATS, 0,
        (LPARAM) (LPCTSTR) string);
    SetScrollSizes (MM_TEXT, sizeTotal);
}

///////////////////////////////////////////////////////////////////////////
// CVistaView diagnostics

#ifdef _DEBUG
void CVistaView::AssertValid() const
{
    CScrollView::AssertValid();
}

void CVistaView::Dump(CDumpContext&amp; dc) const
{
    CScrollView::Dump(dc);
}

CVistaDoc* CVistaView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument-&gt;IsKindOf(RUNTIME_CLASS(CVistaDoc)));
    return (CVistaDoc*)m_pDocument;
}
#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CVistaView message handlers
</PRE>
</td></tr></table></P>

<A NAME="484"><H2>More on the <I>::LoadImage</I> Function</H2></A>
<P>One reason Vista can do so much with so little code is that the 
<I>::LoadImage</I> function allows a DIB section to be built from a BMP file with just one statement. Here's 
that statement again:</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
HBITMAP hBitmap = (HBITMAP) ::LoadImage (NULL, lpszPathName,
    IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE &#166; LR_CREATEDIBSECTION);
</PRE>
</td></tr></table></P>

<P><I>::LoadImage</I> is to DIB sections what 
<I>::LoadBitmap</I> and <I>CDC::LoadBitmap</I> are to 
DDBs. But it's also much more. I won't rehash all the input values it accepts because 
you can get that from the documentation, but here's a short summary of some of the 
things you can do with <I>::LoadImage</I>:</P>

<UL>
<P><LI>Load bitmap resources, and create DDBs and DIB sections from them.</LI></P>
<P><LI>Load bitmaps stored in BMP files, and create DDBs and DIB sections from them.</LI></P>
<P><LI>Automatically convert three shades of gray (RGB (128, 128, 128), RGB (192, 192, 192), and RGB (223, 223, 223)) to the system colors COLOR_3DSHADOW, COLOR_3DFACE, and COLOR_3DLIGHT as an image is loaded.</LI></P>
<P><LI>Automatically convert the color of the pixel in the upper left corner of the bitmap to the system color COLOR_WINDOW or COLOR_3DFACE so that the pixel and others like it will be invisible against a COLOR_WINDOW or COLOR_3DFACE background.</LI></P>
<P><LI>Convert a color image to monochrome.</LI></P>
</UL>

<P>Keep in mind that <I>::LoadImage</I>'s color-mapping capabilities work only with 
images that contain 256 or fewer colors. DIBs with 256 or fewer colors contain built-in 
color tables that make color mapping fast and efficient. Rather than examine every pixel 
in the image to perform a color conversion, 
<I>::LoadImage</I> simply modifies the color table.</P>

<p>Vista demonstrates how <I>::LoadImage</I> can be used to create a DIB section 
from a BMP file and attach it to a <I>CBitmap</I> object. One advantage of loading a bitmap as 
a DIB section instead of as an ordinary DDB is that you can call functions such 
as <I>::GetDIBColorTable</I> on it. Had the LR_CREATEDIBSECTION flag been omitted 
from the call to <I>::LoadImage</I>, we would have been unable to access the bitmap's color 
table and create a logical palette from it. In general, your applications will port more 
easily to future versions of Windows (and probably perform better, too) if you now 
start using DIB sections instead of DDBs whenever possible.</P>

</BODY>
</HTML>




