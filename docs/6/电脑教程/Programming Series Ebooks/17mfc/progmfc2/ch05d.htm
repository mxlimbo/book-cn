<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Maps</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch05c.htm", "ch05e.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="156"><H1>Maps</H1></A>

<P>Of all the MFC collection types, maps might be the most interesting. A 
<I>map</I>, also known as a <I>dictionary</I>, is a table of items keyed by other items. A simple example of a 
map is a list of the 50 states keyed by each state's two-letter abbreviation. Given a 
key such as CA, the corresponding state name (California) can be retrieved with a 
simple function call. Maps are designed so that given a key, the corresponding item can 
be found in the table very quickly&#8212;often with just one lookup. Maps are ideal 
containers for large amounts of data when lookup performance is of paramount importance. 
MFC uses maps to implement handle maps (tables that correlate HWNDs to 
<I>CWnd</I>s, HPENs to <I>CPen</I>s, and so on) and other internal data structures. It also makes its map 
classes public, so you can use them to create maps of your own.</P>

<A NAME="157"><H2>The MFC Map Classes</H2></A>

<P>In addition to the template-based map class 
<I>CMap</I>, which can be specialized to handle specific data types, MFC provides the following type-specific (and 
non-template-based) map classes. Each class includes member functions for adding and removing 
items, retrieving items by key, and enumerating all the items in the map.</P>

<P><b>Type-Specific MFC Map Classes</b></P>

<P>
<table valign="top" cellpadding=5 width="95%">
<tr><th valign="top"><I>Class Name</I></th>
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top"><I>CMapWordToPtr</I></td>
<td valign="top">Stores void pointers keyed by WORDs</td>
</tr>
<tr>
<td valign="top"><I>CMapPtrToWord</I></td>
<td valign="top">Stores WORDs keyed by void pointers</td>
</tr>
<tr>
<td valign="top"><I>CMapPtrToPtr</I></td>
<td valign="top">Stores void pointers keyed by other void pointers</td>
</tr>
<tr>
<td valign="top"><I>CMapWordToOb</I></td>
<td valign="top">Stores <I>CObject</I> pointers keyed by WORDs</td>
</tr>
<tr>
<td valign="top"><I>CMapStringToOb</I> </td>
<td valign="top">Stores <I>CObject</I> pointers keyed by strings</td>
</tr>
<tr>
<td valign="top"><I>CMapStringToPtr</I></td>
<td valign="top">Stores void pointers keyed by strings</td>
</tr>
<tr>
<td valign="top"><I>CMapStringToString</I> </td>
<td valign="top">Stores strings keyed by other strings</td>
</tr>
</table>
</P>
   
<P>To demonstrate the semantics of map usage, let's use 
<I>CMapStringToString</I> to build a simple English-French dictionary containing the names of the days in the 
week. The following statements build the map.</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CMapStringToString map;
map[_T (&quot;Sunday&quot;)]    = _T (&quot;Dimanche&quot;);
map[_T (&quot;Monday&quot;)]    = _T (&quot;Lundi&quot;);
map[_T (&quot;Tuesday&quot;)]   = _T (&quot;Mardi&quot;);
map[_T (&quot;Wednesday&quot;)] = _T (&quot;Mercredi&quot;);
map[_T (&quot;Thursday&quot;)]  = _T (&quot;Jeudi&quot;);
map[_T (&quot;Friday&quot;)]    = _T (&quot;Vendredi&quot;);
map[_T (&quot;Saturday&quot;)]  = _T (&quot;Samedi&quot;);
</pre>
</TD></TR></TABLE>
</P>

<P>In this example, the items stored in the map are the French names for the days of 
the week. Each item is keyed by a string specifying its English-language equivalent. 
The [] operator inserts an item and its key into the map. Because 
<I>CMapStringToString</I> stores keys and items in 
<I>CString</I> objects, inserting an item copies both its text and the 
key text to <I>CString</I>s.</P>

<P>With the map initialized like this, a simple lookup retrieves the French 
word for Thursday. You perform lookups by calling the map's 
<I>Lookup</I> function and specifying the key:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CString string;
if (map.Lookup (_T (&quot;Thursday&quot;), string))
    TRACE (_T (&quot;Thursday in English = %s in French\n&quot;), string);
</pre>
</TD></TR></TABLE>
</P>

<P>A nonzero return from <I>Lookup</I> indicates that the item was successfully retrieved. A 
0 return means that no such item exists&#8212;that is, that no item is keyed by the key 
specified in <I>Lookup</I>'s first parameter.</P>

<P>You can remove items from a map with 
<I>RemoveKey</I> and <I>RemoveAll</I>. 
<I>GetCount</I> returns the number of items in the map, and 
<I>IsEmpty</I> indicates whether the map contains any items at all. 
<I>GetStartPosition</I> and <I>GetNextAssoc</I> permit you to 
enumerate the map's contents item by item:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
POSITION pos = map.GetStartPosition ();
while (pos != NULL) {
    CString strKey, strItem;
    map.GetNextAssoc (pos, strKey, strItem);
    TRACE (_T (&quot;Key=%s, Item=%s\n&quot;), strKey, strItem);
}
</pre>
</TD></TR></TABLE>
</P>

<P>Run on the <I>CMapStringToString</I> object shown above, this code produces the 
following output:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
Key=Tuesday, Item=Mardi
Key=Saturday, Item=Samedi
Key=Wednesday, Item=Mercredi
Key=Thursday, Item=Jeudi
Key=Friday, Item=Vendredi
Key=Monday, Item=Lundi
Key=Sunday, Item=Dimanche
</pre>
</TD></TR></TABLE>
</P>

<P>As this listing shows, items aren't necessarily stored in the order in which they 
are added. This is a natural consequence of the fact that maps are not designed to 
preserve order, but to enable items to be retrieved as quickly as possible. Map architecture 
is described in the next section.</P>

<P>Incidentally, if you insert an item into a map and that item has the same key 
as an item that was previously inserted, the new item will replace the old one. It's 
not possible for an MFC map to contain two or more items identified by the same key.</P>

<A NAME="158"><H2>How Maps Work</H2></A>

<P>Maps wouldn't be very remarkable if it weren't for the fact that lookups are so 
fast. The key to maximizing performance is minimizing the number of items 
examined during the search. Sequential searches are the worst, because if the map contains 
<I>n</I> items, up to <I>n</I> individual lookups could be required. Binary searches are better 
but require ordered items. The best algorithm is one that can go directly to the 
requested item without having to do any searching, regardless of the number of items 
present. Sounds impossible? It's not. If a map is set up properly, MFC's 
<I>Lookup</I> function can normally find any item with a single lookup. Rarely, in fact, are more than two 
or three lookups required. Here's why.</P>


<P>Soon after a map is created (usually at the moment the first item is added, 
but occasionally before), it allocates memory for a hash table, which is actually an 
array of pointers to <I>CAssoc</I> structures. MFC uses 
<I>CAssoc</I> structures to represent the items (and keys) that you add to a map. 
<I>CAssoc</I> is defined this way for 
<I>CMapStringToString</I>:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
struct CAssoc
{
    CAssoc* pNext;
    UINT nHashValue;
    CString key;
    CString value;
};
</pre>
</TD></TR></TABLE>
</P>

<P>Whenever an item is added to the map, a new 
<I>CAssoc</I> structure is created, a hash value is computed from the item's key, and a pointer to the 
<I>CAssoc</I> structure is copied to the hash table at index 
<I>i</I>, where <I>i</I> is computed using the following formula:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
i = nHashValue % nHashTableSize
</pre>
</TD></TR></TABLE>
</P>

<P><I>nHashValue</I> is the hash value computed from the key; 
<I>nHashTableSize</I> is the number of elements in the hash table. The default hash table size is 17 entries; I'll discuss 
how (and why) you change the size in just a moment. If perchance the element at 
index <I>i</I> already holds a <I>CAssoc</I> pointer, MFC builds a singly linked list of 
<I>CAssoc</I> structures. The address of the first 
<I>CAssoc</I> structure in the list is stored in the hash table. 
The address of the second <I>CAssoc</I> structure is stored in the first 
<I>CAssoc</I> structure's <I>pNext</I> field, and so on. Figure 5-1 illustrates how the hash table might look after 10 
items are added. In this example, five of the items' addresses are stored at unique 
locations in the hash table, and five others are split between two linked lists whose lengths 
are 2 and 3, respectively.</P>

<p>
<A HREF="javascript:fullSize('F05mg01x.htm')"> <img src="images/F05mg01.JPG" width=404 height=335 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 5-1.</B> <I>A hash table containing a combination of unique items and linked lists.</I><!-- /CAPTION -->
</p>
 
<P>When a map's <I>Lookup</I> function is called, MFC computes a hash value from 
the input key, converts the hash into an index into the hash table using the 
formula described in the previous paragraph, and retrieves the 
<I>CAssoc</I> pointer from the corresponding location in the hash table. Under ideal conditions, there is just 
one <I>CAssoc</I> pointer at that location, and not a linked list of 
<I>CAssoc</I> pointers. If that's the case, the item has been found with just one lookup in the map, and its value is 
retrieved from the <I>CAssoc</I> object. If the 
<I>CAssoc</I> pointer retrieved from the hash table 
is the head of a linked list, MFC walks the list until it finds the key it's looking for. 
A properly built map will never have more than two or three items in a list of 
<I>CAssoc</I> structures, which means a lookup should never require more than two or three 
items to be examined.</P>


<A NAME="159"><H2>Optimizing Lookup Efficiency</H2></A>

<P>The efficiency with which lookups are performed depends on two factors:</P>

<UL>
<P><LI>The size of the hash table</LI></P>

<P><LI>The hashing algorithm's ability to generate unique hash values from arbitrary (and possibly similar) input keys</LI></P>
</UL>

<P>The hash table size is important. If a map contains 1,000 items but the hash table has room for only 17 <I>CAssoc</I> pointers, the best case is that each entry in the hash table stores the address of the first <I>CAssoc</I> structure in a linked list of 58 or 59 <I>CAssoc</I> structures. This arrangement greatly impedes lookup performance. The hashing algorithm is important too, because no matter how many <I>CAssoc</I> pointers the hash table can hold, if the hashing algorithm generates only a handful of different hash values 
(and therefore a handful of different hash table indexes), lookup performance is similarly diminished.</P>
<P>The best way to optimize lookup efficiency is to make the hash table as 
large as possible to minimize the number of collisions. A collision occurs when 
dissimilar input keys yield the same hash table index. Microsoft recommends setting the 
hash table size to a value 10 to 20 percent larger than the number of items in the map 
to strike a reasonable balance between memory consumption and lookup 
efficiency. To specify the hash table size, call the map's 
<I>InitHashTable</I> function:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
// Assume the map will hold about 1,000 items.
map.InitHashTable (1200); // 1200 = 1000 + 20 percent
</pre>
</TD></TR></TABLE>
</P>

<P>For statistical reasons, using a prime number for the hash table size also helps 
to minimize collisions. Therefore, an even better way to initialize a hash table for 
1,000 items is to call <I>InitHashTable</I> this way:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
map.InitHashTable (1201);
</pre>
</TD></TR></TABLE>
</P>

<P>You should call<I> InitHashTable</I> before adding any items to the map. Attempting to 
resize the hash table when the map contains one or more items causes an assertion error.</P>

<P>Although the algorithms that MFC uses to generate hash values are 
adequate for most purposes, you can replace them with your own if you want to. To hash 
an input key, MFC calls a global template function named 
<I>HashKey</I>. For most data types, 
<I>HashKey</I> is implemented this way:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
AFX_INLINE UINT AFXAPI HashKey(ARG_KEY key)
{
    // default identity hash - works for most primitive values
    return ((UINT)(void*)(DWORD)key) &gt;&gt; 4;
}
For strings, however, it's implemented this way:
UINT AFXAPI HashKey(LPCWSTR key) // Unicode strings
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash&lt;&lt;5) + nHash + *key++;
    return nHash;
}

UINT AFXAPI HashKey(LPCSTR key) // ANSI strings
{
    UINT nHash = 0;
    while (*key)
        nHash = (nHash&lt;&lt;5) + nHash + *key++;
    return nHash;
}
</pre>
</TD></TR></TABLE>
</P>

<P>To implement your own algorithm for a particular data type, simply write a 
type-specific <I>HashKey</I> function. You can use the string versions of 
<I>HashKey</I> shown above as a model.</P>

<A NAME="160"><H2>Creating Type-Safe Map Classes with <I>CMap</I></H2></A>
<P>As you probably suspected, you can use MFC's 
<I>CMap</I> template class to create maps for data types that aren't supported by the type-specific map classes. The 
following example creates a collection of 
<I>CPoint</I> objects keyed by <I>CString</I>s and then 
performs a lookup:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CMap&lt;CString, CString&amp;, CPoint, CPoint&amp;&gt; map;
map[CString (_T (&quot;Vertex1&quot;))] = CPoint (  0,   0);
map[CString (_T (&quot;Vertex2&quot;))] = CPoint (100,   0);
map[CString (_T (&quot;Vertex3&quot;))] = CPoint (100, 100);
map[CString (_T (&quot;Vertex4&quot;))] = CPoint (  0, 100);

CPoint point;
if (map.Lookup (CString (_T (&quot;Vertex3&quot;)), point))
    TRACE (_T (&quot;Vertex 3 = (%d,%d)\n&quot;), point.x, point.y);
</pre>
</TD></TR></TABLE>
</P>

<P>Because <I>CString</I> is used as a key, this code won't compile unless you override 
<I>HashKey</I> with a version that is specifically designed to hash 
<I>CString</I>s. Here's one possibility:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
UINT AFXAPI HashKey(CString&amp; string)
{
    LPCTSTR key = (LPCTSTR) string;
    UINT nHash = 0;
    while (*key)
        nHash = (nHash&lt;&lt;5) + nHash + *key++;
    return nHash;
}
</pre>
</TD></TR></TABLE>
</P>

<P>After converting the <I>CString</I> reference into a conventional string pointer, this 
code hashes the string the same way MFC's LPCSTR/LPCWSTR 
<I>HashKey</I> functions hash a string.</P>


<P>Like the <I>CList</I> class's <I>Find</I> function, 
<I>CMap::Lookup</I> uses the 
<I>CompareElements</I> template function to compare elements. Because 
<I>CompareElements</I> uses the == operator to perform comparisons, the default implementation is fine for primitive 
data types and classes that overload the == operator. If you use classes of your own 
devising as keys in a map, however, you must either overload the 
== operator in those classes or override 
<I>CompareElements</I> for individual data types. Refer to the 
section &quot;<A HREF="ch05c.htm#155">Creating Type-Safe List Classes with <I>CList</I></A>&quot; earlier in this chapter for examples of 
how to do both.</P>


</BODY>
</HTML>





