<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>MFC and COM</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch18b.htm", "ch19a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="574"><H1>MFC and COM</H1></A>

<P>The primary reason why MFC makes COM, OLE, and ActiveX programming simpler is that it provides canned implementations of common COM interfaces in classes such as 
<I>COleControl</I> and 
<I>COleControlSite</I>. COM has been described as an &quot;empty API,&quot; which means that Microsoft defines the interfaces and the methods and tells you what the methods are supposed to do but leaves it up to <I>you</I>, the object implementor, to write the code. The good news is that as long as you're writingActiveX controls, Automation servers, or other types of components that MFC explicitly supports, MFC implements the necessary COM interfaces for you.
</P>

<P>In the next three chapters, you'll get acquainted with many of the MFC 
classes that implement COM interfaces. Right now, I want you to understand 
<I>how</I> MFC classes implement COM interfaces. To do that, you must understand the two techniques 
that COM programmers use to write C++ classes representing COM objects. The first is 
<I>multiple inheritance</I>. The second is 
<I>nested classes</I>. MFC uses only nested classes, but let's look at both techniques so that we can compare the relative merits of each.
</P>


<A NAME="575"><H2>Multiple Inheritance</H2></A>

<P>C++ programmers define COM interfaces using the following syntax:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
interface IUnknown
{
    virtual HRESULT __stdcall QueryInterface (REFIID riid, void** ppv) = 0;
    virtual ULONG __stdcall AddRef () = 0;
    virtual ULONG __stdcall Release () = 0;
};
</PRE>
</TD></TR></TABLE>
</P>

<P>The keyword 
<I>interface</I> is an alias for 
<I>struct</I>. Therefore, to the C++ programmer, 
an interface definition is a set of pure virtual functions logically bound together as 
members of a common structure. And because structures and classes are treated 
almost identically in C++, it's perfectly legal to derive one interface from another, like this.
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
interface IMath : public IUnknown
{
    virtual HRESULT __stdcall Add (int a, int b, int* pResult) = 0;
    virtual HRESULT __stdcall Subtract (int a, int b, int* pResult) = 0;
};
</PRE>
</TD></TR></TABLE>
</P>

<P>You can take advantage of the fact that interface definitions are merely sets of 
pure virtual functions when you develop C++ classes that represent COM objects. 
For example, you can declare a class that implements 
<I>IMath</I> like this:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
class CComClass : public IMath
{
protected:
    long m_lRef;    // Reference count
public:
    CComClass ();
    virtual ~CComClass ();
    // IUnknown methods
    virtual HRESULT __stdcall QueryInterface (REFIID riid, void** ppv);
    virtual ULONG __stdcall AddRef ();
    virtual ULONG __stdcall Release ();
    // IMath methods
    virtual HRESULT __stdcall Add (int a, int b, int* pResult);
    virtual HRESULT __stdcall Subtract (int a, int b, int* pResult);
};
</PRE>
</TD></TR></TABLE>
</P>

<P>With this setup, you can implement 
<I>QueryInterface</I>, 
<I>AddRef</I>, 
<I>Release</I>, 
<I>Add</I>, and 
<I>Subtract</I> as member functions of class 
<I>CComClass</I>.
</P>

<P>Now, suppose you want 
<I>CComClass</I> to implement not just one COM 
interface, but two. How do you do it? One approach is to derive 
<I>CComClass</I> from both 
<I>IMath</I> and another interface by using multiple inheritance, like so:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
class CComClass : public IMath, public ISpelling
{
protected:
    long m_lRef;    // Reference count
public:
    CComClass ();
    virtual ~CComClass ();
    // IUnknown methods
    virtual HRESULT __stdcall QueryInterface (REFIID riid, void** ppv);
    virtual ULONG __stdcall AddRef ();
    virtual ULONG __stdcall Release ();
    // IMath methods
    virtual HRESULT __stdcall Add (int a, int b, int* pResult);
    virtual HRESULT __stdcall Subtract (int a, int b, int* pResult);
    // ISpelling methods
    virtual HRESULT __stdcall CheckSpelling (wchar_t* pString);
};
</PRE>
</TD></TR></TABLE>
</P>

<P>This approach has a couple of advantages. First, it's simple. To declare a class that implements 
<I>n</I> interfaces, you simply include all 
<I>n</I> interfaces in the class's list of base classes. Second, you have to implement 
<I>IUnknown</I> only once. If each interface were truly implemented separately, you'd have to implement 
<I>QueryInterface</I>, 
<I>AddRef</I>, and 
<I>Release</I> for each one. But with multiple inheritance, all methods supported by all interfaces are essentially merged into one implementation. 
</P>

<P>One of the more interesting aspects of using multiple inheritance to write COM classes is what happens when a client calls 
<I>QueryInterface</I> asking for an interface pointer. Let's say that the client asks for an 
<I>IMath</I> pointer. The proper way to return the interface pointer is to cast the 
<I>this</I> pointer to an 
<I>IMath*</I>:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
*ppv = (IMath*) this;
</PRE>
</TD></TR></TABLE>
</P>

<P>If the client asks for an 
<I>ISpelling</I> pointer instead, you cast to 
<I>ISpelling</I>*:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
*ppv = (ISpelling*) this;
</PRE>
</TD></TR></TABLE>
</P>

<P>If you omit the casts, the code will compile just fine but will probably blow up 
when one of the two interfaces is used. Why? Because a class formed with multiple 
inheritance contains multiple vtables and multiple vtable pointers, and without the 
cast, you don't know which vtable the 
<I>this</I> pointer references. In other words, the two 
casts shown here return different numeric values, even though 
<I>this</I> never varies. If a client asks for an 
<I>ISpelling</I> pointer and you return a plain (uncasted) 
<I>this</I> pointer, and if 
<I>this</I> happens to reference 
<I>IMath</I>'s vtable, the client calls 
<I>ISpelling</I> methods through an 
<I>IMath</I> vtable. That's a formula for disaster and is why COM classes that use multiple inheritance 
<I>always</I> cast to retrieve the proper vtable pointer.
</P>


<A NAME="576"><H2>Nested Classes</H2></A>

<P>What's wrong with using multiple inheritance to implement COM classes? 
Nothing&#8212;provided that no two interfaces have methods with the same names and 
signatures. If 
<I>IMath</I> and 
<I>ISpelling</I> both contained methods named 
<I>Init</I> that had identical parameter lists but required separate implementations, you wouldn't be able to use multiple inheritance to define a class that implements both of them. Why? Because with 
multiple inheritance, the class would have just one member function named 
<I>Init</I>. It would therefore be impossible to implement 
<I>Init</I> separately for 
<I>IMath</I> and 
<I>ISpelling</I>.
</P>

<P>This limitation is the reason MFC uses the nested class approach to 
implementing COM interfaces. Nested classes are a little more work and slightly less 
intuitive than multiple inheritance, but they're also suitably generic. You can use the 
nested class approach to implement 
<I>any</I> combination of COM interfaces in a single C++ class, regardless of the interfaces' characteristics. Here's how it works.
</P>

<P>Suppose that 
<I>CComClass</I> implements 
<I>IMath</I> and 
<I>ISpelling</I> and that both interfaces have a method named 
<I>Init</I> that accepts no parameters.
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
virtual HRESULT __stdcall Init () = 0;
</PRE>
</TD></TR></TABLE>
</P>

<P>You can't use multiple inheritance in this case because of C++'s inability to 
support two semantically identical functions in one class. So instead, you define two 
subclasses, each of which implements one interface:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
class CMath : public IMath
{
protected:
    CComClass* m_pParent;    // Back pointer to parent
public:
    CMath ();
    virtual ~CMath ();
    // IUnknown methods
    virtual HRESULT __stdcall QueryInterface (REFIID riid, void** ppv);
    virtual ULONG __stdcall AddRef ();
    virtual ULONG __stdcall Release ();
    // IMath methods
    virtual HRESULT __stdcall Add (int a, int b, int* pResult);
    virtual HRESULT __stdcall Subtract (int a, int b, int* pResult);
    virtual HRESULT __stdcall Init () = 0;
};

class CSpelling : public ISpelling
{
protected:
    CComClass* m_pParent;    // Back pointer to parent
public:
    CSpelling ();
    virtual ~CSpelling ();
    // IUnknown methods
    virtual HRESULT __stdcall QueryInterface (REFIID riid, void** ppv);
    virtual ULONG __stdcall AddRef ();
    virtual ULONG __stdcall Release ();
    // ISpelling methods
    virtual HRESULT __stdcall CheckSpelling (wchar_t* pString);
    virtual HRESULT __stdcall Init () = 0;
};
</PRE>
</TD></TR></TABLE>
</P>


<P>To make 
<I>CMath</I> and 
<I>CSpelling</I> nested classes, you declare them inside 
<I>CComClass</I>. Then you include in 
<I>CComClass</I> a pair of data members that are instances of 
<I>CMath</I> and 
<I>CSpelling</I>:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
class CComClass : public IUnknown
{
protected:
    long m_lRef;        // Reference count
    class CMath : public IMath
    {
        [...]
    };
    CMath m_objMath;        // CMath object
    class CSpelling : public ISpelling
    {
        [...]
    };
    CSpelling m_objSpell;    // CSpelling object
public:
    CComClass ();
    virtual ~CComClass ();
    // IUnknown methods
    virtual HRESULT __stdcall QueryInterface (REFIID riid, void** ppv);
    virtual ULONG __stdcall AddRef ();
    virtual ULONG __stdcall Release ();
};
</PRE>
</TD></TR></TABLE>
</P>

<P>Notice that 
<I>CComClass</I> now derives only from 
<I>IUnknown</I>. It doesn't derive from 
<I>IMath</I> or 
<I>ISpelling</I> because the nested classes provide implementations of both 
interfaces. If a client calls 
<I>QueryInterface</I> asking for an <I>IMath</I> pointer, 
<I>CComClass</I> simply passes out a pointer to the 
<I>CMath</I> object:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
*ppv = (IMath*) &amp;m_objMath;
</PRE>
</TD></TR></TABLE>
</P>

<P>Similarly, if asked for an 
<I>ISpelling</I> pointer, 
<I>CComClass</I> returns a pointer to 
<I>m_objSpell</I>:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
*ppv = (ISpelling*) &amp;m_objSpell;
</PRE>
</TD></TR></TABLE>
</P>

<P>A key point to understand about the nested class approach is that the subobjects must delegate all calls to their 
<I>IUnknown</I> methods to the equivalent methods in 
the parent class. Notice that in place of a member variable that stores a reference count, each nested class stores a 
<I>CComClass</I> pointer. That pointer is a &quot;back pointer&quot; to the subobject's parent. Delegation is performed by calling 
<I>CComClass</I>'s 
<I>IUnknown</I> methods through the back pointer. Typically, the parent's constructor initializes the 
back pointers:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
CComClass::CComClass ()
{
    [...]        // Normal initialization stuff goes here.
    m_objMath.m_pParent = this;
    m_objSpell.m_pParent = this;
}
</PRE>
</TD></TR></TABLE>
</P>

<P>The nested classes' implementations of 
<I>IUnknown</I> look like this:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
HRESULT __stdcall CComClass::CMath::QueryInterface (REFIID riid, void** ppv)
{
    return m_pParent-&gt;QueryInterface (riid, ppv);
}

ULONG __stdcall CComClass::CMath::AddRef ()
{
    return m_pParent-&gt;AddRef ();
}

ULONG __stdcall CComClass::CMath::Release ()
{
    return m_pParent-&gt;Release ();
}
</PRE>
</TD></TR></TABLE>
</P>

<P>Delegation of this sort is necessary for two reasons. First, if a client calls 
<I>AddRef</I> or 
<I>Release</I> on an interface implemented by a subobject, the parent's reference 
count should be adjusted, not the subobject's. Second, if a client calls 
<I>QueryInterface</I> on one of the subobjects, the parent must field the call because only the parent 
knows which nested classes are present and therefore which interfaces it implements.
</P>


<A NAME="577"><H2>MFC and Nested Classes</H2></A>

<P>If you browse through the source code for MFC classes such as 
<I>COleControl</I>, you won't see anything that resembles the code in the previous section. That's because 
MFC hides its nested classes behind macros.
</P>

<P>MFC's 
<I>COleDropTarget</I> class is a case in point. It's one of the simpler MFC 
COM classes, and it implements just one COM interface&#8212;a standard interface named 
<I>IDropTarget</I>. If you look inside Afxole.h, you'll see these statements near the end of <I>COleDropTarget</I>'s class declaration:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
BEGIN_INTERFACE_PART(DropTarget, IDropTarget)
    [...]
    STDMETHOD(DragEnter)(LPDATAOBJECT, DWORD, POINTL, LPDWORD);
    STDMETHOD(DragOver)(DWORD, POINTL, LPDWORD);
    STDMETHOD(DragLeave)();
    STDMETHOD(Drop)(LPDATAOBJECT, DWORD, POINTL pt, LPDWORD);
END_INTERFACE_PART(DropTarget)
</PRE>
</TD></TR></TABLE>
</P>

<P>MFC's BEGIN_INTERFACE_PART macro defines a nested class that implements 
one COM interface. The class is named by prepending a capital 
<I>X</I> to the first parameter in the macro's parameter list. In this example, the nested class's name is 
<I>XDropTarget</I>. The END_INTERFACE_PART macro declares a member variable that's an instance 
of the nested class. Here's the code generated by the preprocessor:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
class XDropTarget : public IDropTarget
{
public:
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
    STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj);
    STDMETHOD(DragEnter)(LPDATAOBJECT, DWORD, POINTL, LPDWORD);
    STDMETHOD(DragOver)(DWORD, POINTL, LPDWORD);
    STDMETHOD(DragLeave)();
    STDMETHOD(Drop)(LPDATAOBJECT, DWORD, POINTL pt, LPDWORD);
} m_xDropTarget;
friend class XDropTarget;
</PRE>
</TD></TR></TABLE>
</P>

<P>Do you see the resemblance between the preprocessor output and the nested 
class example we looked at earlier? Notice that the name of the nested class instance is 
<I>m_x</I> plus the first parameter in the macro's parameter list&#8212;in this case, 
<I>m_xDropTarget</I>.
</P>

<P>The nested class implements the three 
<I>IUnknown</I> methods plus the methods listed between BEGIN_INTERFACE_PART and END_INTERFACE_PART. 
<I>IDropTarget</I> has four 
methods&#8212;
<I>DragEnter</I>, 
<I>DragOver</I>, 
<I>DragLeave</I>, and 
<I>Drop</I>&#8212;hence the methods named in the preceding code listing. Here's an excerpt from the MFC source code file Oledrop2.cpp showing how 
<I>IDropTarget</I>'s methods are implemented in the nested 
<I>XDropTarget</I> class:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
STDMETHODIMP_(ULONG) COleDropTarget::XDropTarget::AddRef()
{
    [...]
}

STDMETHODIMP_(ULONG) COleDropTarget::XDropTarget::Release()
{
    [...]
}

STDMETHODIMP COleDropTarget::XDropTarget::QueryInterface(...)
{
    [...]
}

STDMETHODIMP COleDropTarget::XDropTarget::DragEnter(...)
{
    [...]
}

STDMETHODIMP COleDropTarget::XDropTarget::DragOver(...)
{
    [...]
}

STDMETHODIMP COleDropTarget::XDropTarget::DragLeave(...)
{
    [...]
}

STDMETHODIMP COleDropTarget::XDropTarget::Drop(...)
{
    [...]
}
</PRE>
</TD></TR></TABLE>
</P>

<P>The code inside the method implementations is unimportant for now. The key 
here is that a few innocent-looking macros in an MFC source code listing turn into a 
nested class that implements a full-blown COM interface. You can create a class that 
implements several COM interfaces by including one 
BEGIN_INTERFACE_PART/END_INTERFACE_PART block for each interface. Moreover, you needn't worry 
about conflicts if two or more interfaces contain identical methods because the nested 
class technique permits each interface (and its methods) to be implemented independently.
</P>


<A NAME="578"><H2>How MFC Implements <I>IUnknown</I></H2></A>
<P>Let's go back and look more closely at 
<I>COleDropTarget</I>'s implementation of 
<I>QueryInterface</I>, <I>AddRef</I>, and 
<I>Release</I>. Here's the complete, unabridged version:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
STDMETHODIMP_(ULONG) COleDropTarget::XDropTarget::AddRef()
{
    METHOD_PROLOGUE_EX_(COleDropTarget, DropTarget)
    return pThis-&gt;ExternalAddRef();
}

STDMETHODIMP_(ULONG) COleDropTarget::XDropTarget::Release()
{
    METHOD_PROLOGUE_EX_(COleDropTarget, DropTarget)
    return pThis-&gt;ExternalRelease();
}

STDMETHODIMP COleDropTarget::XDropTarget::QueryInterface(
    REFIID iid, LPVOID* ppvObj)
{
    METHOD_PROLOGUE_EX_(COleDropTarget, DropTarget)
    return pThis-&gt;ExternalQueryInterface(&amp;iid, ppvObj);
}
</PRE>
</TD></TR></TABLE>
</P>

<P>Once more, what MFC is doing is hidden behind a macro. In this case, the macro 
is METHOD_PROLOGUE_EX_, which creates a stack variable named 
<I>pThis</I> that points to 
<I>XDropTarget</I>'s parent&#8212;that is, the 
<I>COleDropTarget</I> object of which the 
<I>XDropTarget</I> object is a member. Knowing this, you can see that 
<I>XDropTarget</I>'s 
<I>IUnknown</I> methods delegate to 
<I>COleDropTarget</I>. Which begs a question or two: What do 
<I>COleDropTarget</I>'s 
<I>ExternalAddRef</I>, 
<I>ExternalRelease</I>, and 
<I>ExternalQueryInterface</I> functions do, and where do they come from?
</P>

<P>The second question is easy to answer. All three functions are members of 
<I>CCmdTarget</I>, and 
<I>COleDropTarget</I> is derived from 
<I>CCmdTarget</I>. To answer the first question, we need to look at the function implementations inside 
<I>CCmdTarget</I>. Here's an excerpt from the MFC source code file Oleunk.cpp:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
DWORD CCmdTarget::ExternalAddRef()
{
    [...]
    return InternalAddRef();
}

DWORD CCmdTarget::ExternalRelease()
{
    [...]
    return InternalRelease();
}

DWORD CCmdTarget::ExternalQueryInterface(const void* iid,
    LPVOID* ppvObj)
{
    [...]
    return InternalQueryInterface(iid, ppvObj);
}
</PRE>
</TD></TR></TABLE>
</P>

<P>
<I>ExternalAddRef</I>, 
<I>ExternalRelease</I>, and 
<I>ExternalQueryInterface</I> call another set of 
<I>CCmdTarget</I> functions named 
<I>InternalAddRef</I>, 
<I>InternalRelease</I>, and 
<I>InternalQueryInterface</I>. The 
<I>Internal</I> functions are a little more complicated, but if you look at them, 
you'll find that they do just what 
<I>AddRef</I>, 
<I>Release</I>, and 
<I>QueryInterface</I> are supposed to do, albeit in an MFC way. So now we know that the nested class's 
<I>IUnknown</I> methods delegate to the parent class and that the parent class inherits implementations of 
these methods from 
<I>CCmdTarget</I>. Let's keep going.
</P>


<A NAME="579"><H2>Interface Maps</H2></A>

<P>The most interesting 
<I>Internal</I> function is 
<I>InternalQueryInterface</I>. If you peek at it 
in Oleunk.cpp, you'll see that it calls a little-known function named 
<I>GetInterface</I>, which belongs to a little-known class named 
<I>CUnknown</I>. 
<I>GetInterface</I> does a table lookup to determine whether this class supports the specified interface. It then retrieves a pointer to the nested class that implements the interface and returns it to 
<I>InternalQueryInterface</I>. So MFC uses a table-driven mechanism to implement 
<I>QueryInterface</I>. But where do the tables come from?</P>

<P>Once more, we can look to 
<I>COleDropTarget</I> for an example. At the very end of 
<I>COleDropTarget</I>'s class declaration is the statement
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
DECLARE_INTERFACE_MAP()
</PRE>
</TD></TR></TABLE>
</P>

<P>And in 
<I>COleDropTarget</I>'s implementation is this set of related statements:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
BEGIN_INTERFACE_MAP(COleDropTarget, CCmdTarget)
    INTERFACE_PART(COleDropTarget, IID_IDropTarget, DropTarget)
END_INTERFACE_MAP()
</PRE>
</TD></TR></TABLE>
</P>

<P>DECLARE_INTERFACE_MAP is an MFC macro that declares an interface 
map&#8212;a table containing one entry for each interface that a class (in reality, a nested 
class) implements. BEGIN_INTERFACE_MAP and END_INTERFACE_MAP are also 
macros. They define the contents of the interface map. Just as message maps tell MFC 
which messages a class provides handlers for, interface maps tell MFC which COM 
interfaces a class supports and which nested classes provide the interface 
implementations. Each INTERFACE_PART macro that appears between 
BEGIN_INTERFACE_MAP and END_INTERFACE_MAP constitutes one entry in the table. In this example, 
the INTERFACE_PART statement tells MFC that the interface map is a member of 
<I>COleDropTarget</I>, that 
<I>COleDropTarget</I> implements the 
<I>IDropTarget</I> interface, and that the nested class containing the actual 
<I>IDropTarget</I> implementation is 
<I>XDropTarget</I>. INTERFACE_PART prepends an 
<I>X</I> to the class name in the same manner as BEGIN_INTERFACE_PART.
</P>

<P>Because an interface map can contain any number of INTERFACE_PART 
macros, MFC classes aren't limited to one COM interface each; they can implement 
several. For each INTERFACE_PART entry that appears in a class's interface map, 
there is one BEGIN_INTERFACE_PART/END_INTERFACE_PART block in the class declaration. Take a look at 
<I>COleControl</I>'s interface map in Ctlcore.cpp and the numerous BEGIN_INTERFACE_PART/END_INTERFACE_PART blocks in AfxCtl.h and you'll see what I mean.
</P>


<A NAME="580"><H2>MFC and Aggregation</H2></A>

<P>Does it seem curious that 
<I>CCmdTarget</I> has two sets of functions with 
<I>QueryInterface</I>, 
<I>AddRef</I>, and 
<I>Release</I> in their names? When I showed you the source code for the 
<I>External</I> functions, I omitted (for clarity) the part that explains why. Here it is again, but this time in unabbreviated form:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
DWORD CCmdTarget::ExternalAddRef()
{
    // delegate to controlling unknown if aggregated
    if (m_pOuterUnknown != NULL)
        return m_pOuterUnknown-&gt;AddRef();

    return InternalAddRef();
}

DWORD CCmdTarget::ExternalRelease()
{
    // delegate to controlling unknown if aggregated
    if (m_pOuterUnknown != NULL)
        return m_pOuterUnknown-&gt;Release();

    return InternalRelease();
}

DWORD CCmdTarget::ExternalQueryInterface(const void* iid,
    LPVOID* ppvObj)
{
    // delegate to controlling unknown if aggregated
    if (m_pOuterUnknown != NULL)
        return m_pOuterUnknown-&gt;QueryInterface(*(IID*)iid, ppvObj);

    return InternalQueryInterface(iid, ppvObj);
}
</PRE>
</TD></TR></TABLE>
</P>

<P>Observe that the 
<I>External</I> functions call the 
<I>Internal</I> functions only if 
<I>m_pOuterUnknown</I> holds a NULL value. 
<I>m_pOuterUnknown</I> is a 
<I>CCmdTarget</I> member variable that holds an object's 
<I>controlling unknown</I>. If 
<I>m_pOuterUnknown</I> is not NULL, the 
<I>External</I> functions delegate through the pointer held in 
<I>m_pOuterUnknown</I>. If you're familiar with COM aggregation, you can probably guess what's going on here. But if aggregation is new to you, the preceding code requires further explanation.
</P>

<P>COM has never supported inheritance in the way that C++ does. In other 
words, you can't derive one COM object from another in the way that you can derive 
one C++ class from another. However, COM does support two mechanisms&#8212;
<I>containment</I> and 
<I>aggregation</I>&#8212;for object reuse.
</P>

<P>Containment is the simpler of the two. To illustrate how it works, let's say 
you've written an object that contains a pair of methods named 
<I>Add</I> and 
<I>Subtract</I>. Now suppose someone else has written a COM object with 
<I>Multiply</I> and 
<I>Divide</I> methods that you'd like to incorporate into your object. One way to &quot;borrow&quot; the other object's methods is to have your object create the other object with 
<I>CoCreateInstance</I> and call its methods as needed. Your object is the outer object, the other object is the inner object, and if 
<I>m_pInnerObject</I> holds a pointer to the interface on the inner object that implements 
<I>Multiply</I> and 
<I>Divide</I>, you might also include 
<I>Multiply</I> and 
<I>Divide</I> methods in your object and implement them like this:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
HRESULT __stdcall CComClass::Multiply (int a, int b, int* pResult)
{
    return m_pInnerObject-&gt;Multiply (a, b, pResult);
}

HRESULT __stdcall CComClass::Divide (int a, int b, int* pResult)
{
    return m_pInnerObject-&gt;Divide (a, b, pResult);
}
</PRE>
</TD></TR></TABLE>
</P>

<P>That's containment in a nutshell. Figure 18-5 shows the relationship between the 
inner and outer objects. Notice that the inner object's interface is exposed only to the 
outer object, not to the clients of the outer object.
</P>

<P>
<img src="images/F18mg05.JPG" width=219 height=129 border="0">
</p><p>
<!-- CAPTION --><B>Figure 18-5.</B> <I>Containment.</I><!-- /CAPTION -->
</p>

<P>Aggregation is altogether different. When one object aggregates another, 
the aggregate object exposes the interfaces of both the inner and the outer objects. 
(See Figure 18-6.) The client has no idea that the object is actually an aggregate of two 
or more objects.
</P>

<P>
<img src="images/F18mg06.JPG" width=219 height=129 border="0">
</p><p>
<!-- CAPTION --><B>Figure 18-6.</B> <I>Aggregation.</I><!-- /CAPTION -->
</p>

<P>Aggregation is similar to containment in that the outer object creates the 
inner object. But the similarities end there. For aggregation to work, the inner object 
and the outer object must work together to create the illusion that they're really one 
object. Both objects must adhere to a strict set of rules governing their behavior. One 
of those rules says that the outer object must pass its own 
<I>IUnknown</I> pointer to the inner object. This pointer becomes the inner object's controlling unknown. If a client calls an 
<I>IUnknown</I> method on the inner object, the inner object must delegate to the outer object by calling <I>QueryInterface</I>, 
<I>AddRef</I>, or 
<I>Release</I> through the controlling unknown. That's what happens when 
<I>CCmdTarget</I>'s 
<I>External</I> functions call 
<I>QueryInterface</I>, 
<I>AddRef</I>, or 
<I>Release</I> through 
<I>m_pOuterUnknown</I>. If the object is aggregated, 
<I>m_pOuterUnknown</I> is non-NULL and the 
<I>External</I> functions delegate to the outer object. Otherwise, the object isn't aggregated and the 
<I>Internal</I> functions are called instead.
</P>

<P>A key difference between containment and aggregation is that any object 
can be contained by another object, but only objects that specifically support 
aggregation can be aggregated. MFC makes aggregation easy because it builds in 
aggregation support for free.
</P>


<A NAME="581"><H2>MFC and Class Factories</H2></A>

<P>Any class library that places a friendly wrapper around COM should include 
support for class factories. COM class factories typically contain a lot of boilerplate code 
that varies little from one application to the next, so they're perfect candidates to be 
hidden away inside a C++ class.
</P>

<P>MFC provides a canned implementation of COM class factories in 
<I>COleObjectFactory</I>. MFC's 
<I>COleObjectFactory</I> class implements two COM interfaces: 
<I>IClassFactory</I> and 
<I>IClassFactory2</I>. 
<I>IClassFactory2 </I>is a superset of 
<I>IClassFactory</I>; it supports all of 
<I>IClassFactory</I>'s methods and adds licensing methods that are used primarily 
by ActiveX controls.
</P>

<P>When you create a 
<I>COleObjectFactory</I>, you feed its constructor four critical 
pieces of information. The first is the CLSID of the object that the class factory creates. 
The second is a RUNTIME_CLASS pointer identifying the C++ class that implements 
objects of that type. The third is a BOOL that tells COM whether this server, if it's 
an EXE, is capable of creating multiple object instances. If this parameter is TRUE and 10 clients call 
<I>CoCreateInstance</I> on the COM class that this server implements, 
10 different instances of the EXE are launched. If the parameter is FALSE, one 
instance of the EXE serves all 10 clients. The fourth and final parameter to 
<I>COleObjectFactory</I>'s constructor is the ProgID of the object that the class factory creates. ProgID is 
short for Program ID; it's a human-readable name (for example, &quot;Math.Object&quot;) that 
can be used in lieu of a CLSID to identify a COM class. The following code fragment creates a <I>COleObjectFactory</I> that instantiates 
<I>CComClass</I> when CLSID_Math is passed to a COM activation function:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
COleObjectFactory cf (
    CLSID_Math,                  // The object's CLSID
    RUNTIME_CLASS (CComClass),   // Class representing the object
    FALSE,                       // Many clients, one EXE
    _T (&quot;Math.Object&quot;)           // The object's ProgID
);
</PRE>
</TD></TR></TABLE>
</P>

<P>Most MFC applications don't explicitly declare an instance of 
<I>COleObjectFactory</I>; instead, they use MFC's DECLARE_OLECREATE and IMPLEMENT_OLECREATE macros. When the preprocessor encounters
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
// In the class declaration
DECLARE_OLECREATE (CComClass)

// In the class implementation
IMPLEMENT_OLECREATE (CComClass, &quot;Math.Object&quot;, 0x708813ac,
    0x88d6, 0x11d1, 0x8e, 0x53, 0x00, 0x60, 0x08, 0xa8, 0x27, 0x31)
</PRE>
</TD></TR></TABLE>
</P>
	
	
<P>it outputs this:
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
// In the class declaration
public:
    static COleObjectFactory factory;
    static const GUID guid;

// In the class implementation
COleObjectFactory CComClass::factory(CComClass::guid,
    RUNTIME_CLASS(CComClass), FALSE, _T(&quot;Math.Object&quot;));
const GUID CComClass::guid =
    { 0x708813ac, 0x88d6, 0x11d1, { 0x8e, 0x53, 0x00,
      0x60, 0x08, 0xa8, 0x27, 0x31} };
</PRE>
</TD></TR></TABLE>
</P>

<P>The one drawback to the OLECREATE macros is that they contain hardcoded references to <I>COleObjectFactory</I>. If you derive a class from 
<I>COleObjectFactory</I> and want to use it in an application, you must either discard the macros and hand-code the references to the derived class or write your own OLECREATE macros. Programmers occasionally do find it useful to derive their own classes from 
<I>COleObjectFactory</I> to modify the class factory's behavior. By overriding the virtual 
<I>OnCreateObject</I> function, for example, you can create a &quot;singleton&quot; class factory&#8212;a class factory that creates an object the first time 
<I>IClassFactory::CreateInstance</I> is called and hands out pointers to the existing object in response to subsequent activation requests.
</P>

<P>Internally, MFC maintains a linked list of all the 
<I>COleObjectFactory</I> objects that an application creates. (Look inside 
<I>COleObjectFactory</I>'s constructor and you'll 
see the code that adds each newly instantiated object to the list.) 
<I>COleObjectFactory</I> includes handy member functions for registering all an application's class factories 
with the operating system and for registering the objects that the class factories create 
in the system registry. The statement
</P>

<P>
<TABLE CELLPADDING=5 WIDTH ="95%">
<TR><TD>
<PRE>
COleObjectFactory::UpdateRegistryAll ();
</PRE>
</TD></TR></TABLE>
</P>

<P>adds to the registry all the information required to create any object that is served 
up by this application's class factories. That's powerful, because the alternative is to 
write low-level code that relies on Win32 registry functions to update the registry yourself.
</P>


<A NAME="582"><H2>Putting It All in Perspective</H2></A>

<P>Has this chapter covered everything there is to know about the relationship 
between MFC and COM? Hardly. There's plenty more, as you'll discover in the next three 
chapters. But this chapter has set the stage for the ones that follow. Now when you see 
a diagram like the one in Figure 18-1, you'll understand what 
you're looking at and have a pretty good idea of how MFC implements it. Plus, when 
you look over a wizard-generated source code listing or dig down into the MFC 
source code, you'll know what statements like INTERFACE_PART and 
IMPLEMENT_OLECREATE mean.
</P>

<P>If COM is new to you, you're probably feeling a little overwhelmed right 
now. Don't despair. Learning COM is a lot like learning to program Windows: You 
endure the obligatory six months of mental fog before it all begins to make sense. The 
good news is that you don't have to be an expert on COM to build COM-based 
applications with MFC. In fact, you don't have to know much about COM at all. But if
you believe (as I do) that the best programmers are the ones who understand what 
goes on under the hood, the information presented in this chapter will serve you well 
in the long run.
</P>


</BODY>

</HTML>




