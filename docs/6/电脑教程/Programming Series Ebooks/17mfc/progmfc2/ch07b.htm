<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>The Classic Controls</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch07a.htm", "ch07c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="175"><H1>The Classic Controls</H1></A>

<P>Windows makes the classic controls available to the application programs that it 
hosts by registering six predefined WNDCLASSes. The control types, their 
WNDCLASSes, and the corresponding MFC classes are shown in the following table.</P>

<P><B>The Classic Controls</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Control Type</I></th>     
<th valign="top"><I>WNDCLASS</I></th>
<th valign="top"><I>MFC Class</I></th>
</tr>
<tr>
<td valign="top">Buttons</td>     
<td valign="top">&quot;BUTTON&quot;</td>     
<td valign="top"><I>CButton</I></td>
</tr>
<tr>
<td valign="top">List boxes</td>     
<td valign="top">&quot;LISTBOX&quot;</td>     
<td valign="top"><I>CListBox</I></td>
</tr>
<tr>
<td valign="top">Edit controls</td>     
<td valign="top">&quot;EDIT&quot;</td>     
<td valign="top"><I>CEdit</I></td>
</tr>
<tr>
<td valign="top">Combo boxes</td>     
<td valign="top">&quot;COMBOBOX&quot;</td>     
<td valign="top"><I>CComboBox</I></td>
</tr>
<tr>
<td valign="top">Scroll bars</td>     
<td valign="top">&quot;SCROLLBAR&quot;</td>     
<td valign="top"><I>CScrollBar</I></td>
</tr>
<tr>
<td valign="top">Static controls</td>     
<td valign="top">&quot;STATIC&quot;</td>     
<td valign="top"><I>CStatic</I></td>
</tr></table></p>

<P>A control is created by instantiating one of the MFC control classes and 
calling the resulting object's <I>Create</I> function. If 
<I>m_wndPushButton</I> is a <I>CButton</I> object, 
the statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndPushButton.Create (_T (&quot;Start&quot;), WS_CHILD &#166; WS_VISIBLE &#166;
    BS_PUSHBUTTON, rect, this, IDC_BUTTON);
</pre>
</td></tr></table>

<P>creates a push button control labeled &quot;Start.&quot; The first parameter is the text 
that appears on the button face. The second is the button style, which is a combination of 
conventional (WS_) window styles and button-specific (BS_) window styles. 
Together, WS_CHILD, WS_VISIBLE, and BS_PUSHBUTTON create a push button control 
that is a child of the<I> </I>window identified in the fourth parameter and that is visible on 
the screen. (If you omit WS_VISIBLE from the window style, the control won't 
become visible until you call <I>ShowWindow</I> on it.). 
<I>rect</I> is a RECT structure or a <I>CRect</I> 
object specifying the control's size and location, in pixels, relative to the upper left 
corner of its parent's client area. <I>this</I> identifies the parent window, and IDC_BUTTON is 
an integer value that identifies the control. This value is also known as the 
<I>child window ID</I> or <I>control ID</I>. It's important to assign a unique ID to each control you 
create within a given window so that you can map the control's notification messages 
to member functions in the parent window class.</P>

<P>List boxes and edit controls assume a &quot;flat&quot; look when they're created with 
<I>Create</I>. To endow them with the contemporary chiseled look that most users have 
grown accustomed to (Figure 7-1), you need to create list boxes and edit controls 
with <I>CreateEx</I> instead of <I>Create</I> and include a WS_EX_CLIENTEDGE flag in the 
extended style specified in the function's first parameter. If 
<I>m_wndListBox</I> is a <I>CListBox</I> object, the following statement creates a list box with chiseled edges and parents it to 
the window identified by the <I>this</I> pointer:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndListBox.CreateEx (WS_EX_CLIENTEDGE, _T (&quot;LISTBOX&quot;), NULL,
    WS_CHILD | WS_VISIBLE | LBS_STANDARD, rect, this, IDC_LISTBOX);
</pre>
</td></tr></table>

<P>As an alternative, you can derive your own class from 
<I>CListBox</I>, override <I>PreCreateWindow</I> in the derived class, and apply WS_EX_CLIENTEDGE to the window 
style in the <I>PreCreateWindow</I>, as demonstrated here:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL CMyListBox::PreCreateWindow (CREATESTRUCT&amp; cs)
{
    if (!CListBox::PreCreateWindow (cs))
        return FALSE;

    cs.dwExStyle |= WS_EX_CLIENTEDGE;
      <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
    return TRUE;
}
</pre>
</td></tr></table>

<P>With <I>PreCreateWindow</I> implemented like this, a 
<I>CMyListBox</I> object will have chiseled borders regardless of how it's created.</P>

<P>
<img src="images/F07mg01.GIF" width=342 height=266 border="0">
</p><p>
<!-- CAPTION --><B>Figure 7-1.</B> <I>A list box with flat edges (left) and chiseled edges (right).</I><!-- /CAPTION -->
</p>

<P>A control sends notifications to its parent in the form of WM_COMMAND 
messages. The kinds of notifications that are sent vary with the control type, but in 
each case, information encoded in the message's 
<I>wParam </I>and <I>lParam</I> parameters identifies the control that sent the message and the action that prompted the message. 
For example, the WM_COMMAND message sent when a push button is clicked 
contains the notification code BN_CLICKED in the upper 16 bits of 
<I>wParam</I>, the control ID in the lower 16 bits of 
<I>wParam</I>, and the control's window handle in 
<I>lParam</I>.</P>

<P>Rather than process raw WM_COMMAND messages, most MFC applications 
use message maps to link control notifications to class member functions. For 
example, the following message-map entry maps clicks of the push button whose control ID 
is IDC_BUTTON to the member function 
<I>OnButtonClicked</I>:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
ON_BN_CLICKED (IDC_BUTTON, OnButtonClicked)
</pre>
</td></tr></table>

<P>ON_BN_CLICKED is one of several control-related message-map macros that 
MFC provides. For example, there are ON_EN macros for edit controls and ON_LBN 
macros for list box controls. There's also the generic ON_CONTROL macro, which 
handles all notifications and all control types, and ON_CONTROL_RANGE, which maps 
identical notifications from two or more controls to a common notification handler.</P>

<P>Controls send messages to their parents, but it's no less common for parents 
to send messages to controls. For example, a check mark is placed in a check box 
control by sending the control a BM_SETCHECK message with 
<I>wParam</I> equal to BST_CHECKED. MFC simplifies message-based control interfaces by building 
member functions into its control classes that wrap BM_SETCHECK and other control 
messages. For example, the statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndCheckBox.SetCheck (BST_CHECKED);
</pre>
</td></tr></table>

<P>places a check mark inside a check box represented by a 
<I>CButton</I> object named <I>m_wndCheckBox</I>.</P>

<P>Because a control is a window, some of the member functions that the 
control classes inherit from <I>CWnd</I> are useful for control programming. For example, the 
same <I>SetWindowText</I> function that changes the text in a window's title bar inserts text 
into an edit control, too. Other useful 
<I>CWnd</I> functions include <I>GetWindowText</I>, 
which retrieves text from a control; 
<I>EnableWindow</I>, which enables and disables a 
control; and <I>SetFont</I>, which changes a control's font. If you want to do something to a 
control and can't find an appropriate member function in the control class, check 
<I>CWnd</I>'s list of member functions. You'll probably find the one you're looking for.</P>

<A NAME="176"><H2>The <I>CButton</I> Class</H2></A>
<P><I>CButton</I> represents button controls based on the &quot;BUTTON&quot; WNDCLASS. 
Button controls come in four flavors: push buttons, check boxes, radio buttons, and 
group boxes. All four button types are shown in Figure 7-2.</P>

<P>
<img src="images/F07mg02x.GIF" width=414 height=163 border=0>
</p><p>
<!-- CAPTION --><B>Figure 7-2.</B> <I>The four types of button controls.</I><!-- /CAPTION -->
</p>

<P>When you create a button control, you specify which of the four button 
types you want to create by including one of the following flags in the button's window style:</P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Style</I></th>     
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top">BS_PUSHBUTTON</td>     
<td valign="top">Creates a standard push button control</td>
</tr>
<tr>
<td valign="top">BS_DEFPUSHBUTTON</td>     
<td valign="top">Creates a default push button; used in dialog boxes to identify the push button that's clicked if Enter is pressed</td>
</tr>
<tr>
<td valign="top">BS_CHECKBOX</td>     
<td valign="top">Creates a check box control</td>
</tr>
<tr>
<td valign="top">BS_AUTOCHECKBOX</td>     
<td valign="top">Creates a check box control that checks and unchecks itself when clicked</td>
</tr>
<tr>
<td valign="top">BS_3STATE</td>     
<td valign="top">Creates a three-state check box control</td>
</tr>
<tr>
<td valign="top">BS_AUTO3STATE</td>     
<td valign="top">Creates a three-state check box control that cycles through three states&#8212;checked, unchecked, and indeterminate&#8212;when clicked</td>
</tr>
<tr>
<td valign="top">BS_RADIOBUTTON</td>     
<td valign="top">Creates a radio button control</td>
</tr>
<tr>
<td valign="top">BS_AUTORADIOBUTTON</td>     
<td valign="top">Creates a radio button control that, when clicked, checks itself and unchecks other radio buttons in the group</td>
</tr>
<tr>
<td valign="top">BS_GROUPBOX</td>     
<td valign="top">Creates a group box control</td>
</tr></table></p>

<P>In addition, you can OR one or more of the following values into the window 
style to control the alignment of the text on the button face:</P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Style</I></th>     
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top">BS_LEFTTEXT</td>     
<td valign="top">Moves the text accompanying a radio button or check box control from the button's right (the default) to its left</td> 
</tr>
<tr>
<td valign="top">BS_RIGHTBUTTON</td> 
<td valign="top">Same as BS_LEFTTEXT</td> 
</tr>
<tr>
<td valign="top">BS_LEFT</td> 
<td valign="top">Left justifies the button text in the control rectangle</td> 
</tr>
<tr>
<td valign="top">BS_CENTER</td> 
<td valign="top">Centers the button text in the control rectangle</td> 
</tr>
<tr>
<td valign="top">BS_RIGHT</td>      
<td valign="top">Right justifies the button text in the control rectangle</td> 
</tr>
<tr>
<td valign="top">BS_TOP</td>      
<td valign="top">Positions the button text at the top of the control rectangle</td> 
</tr>
<tr>
<td valign="top">BS_VCENTER</td>      
<td valign="top">Positions the button text in the center of the control rectangle vertically</td> 
</tr>
<tr>
<td valign="top">BS_BOTTOM</td>      
<td valign="top">Positions the button text at the bottom of the control rectangle</td> 
</tr>
<tr>
<td valign="top">BS_MULTILINE</td>      
<td valign="top">Allows text too long to fit on one line to be broken into two or more lines</td> 
</tr></table></p>

<P>There are other button styles, but most of them are rarely used. For 
example, BS_NOTIFY programs a button to send BN_DOUBLECLICKED, BN_KILLFOCUS, 
and BN_SETFOCUS notifications. BS_OWNERDRAW creates an 
<I>owner-draw</I> button&#8212;one whose appearance is maintained by the button's parent rather than the button 
itself. Owner-draw buttons have been largely superseded by bitmap buttons and icon 
buttons. You'll learn more about bitmap buttons and icon buttons later in this chapter.</P>

<A NAME="177"><H3>Push Buttons</H3></A>

<P>A push button is a button control created with the style BS_PUSHBUTTON. 
When clicked, a push button control sends its parent a BN_CLICKED notification 
encapsulated in a WM_COMMAND message. Absent the button style BS_NOTIFY, a 
push button sends no other types of notifications.</P>

<P>MFC's ON_BN_CLICKED macro links BN_CLICKED notifications to 
member functions in the parent window class. The message-map entry</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
ON_BN_CLICKED (IDC_BUTTON, OnButtonClicked)
</pre>
</td></tr></table>

<P>connects <I>OnButtonClicked</I> to clicks of the push button whose control ID is 
IDC_BUTTON. A trivial implementation of 
<I>OnButtonClicked</I> looks like this:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
void CMainWindow::OnButtonClicked ()
{
    MessageBox (_T (&quot;I've been clicked!&quot;));
}
</pre>
</td></tr></table>

<P>Like command handlers for menu items, BN_CLICKED handlers accept no 
parameters and return no values.</P>

<A NAME="178"><H3>Check Boxes</H3></A>

<P>Check boxes are buttons created with the style BS_CHECKBOX, 
BS_AUTOCHECKBOX, BS_3STATE, or BS_AUTO3STATE. BS_CHECKBOX and 
BS_AUTOCHECKBOX check boxes can assume two states: checked and unchecked. A check box is 
checked and unchecked with 
<I>CButton::SetCheck</I>:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndCheckBox.SetCheck (BST_CHECKED);   // Check
m_wndCheckBox.SetCheck (BST_UNCHECKED); // Uncheck
</pre>
</td></tr></table>

<P>To find out whether a check box is checked, use 
<I>CButton::GetCheck</I>. A return value equal to BST_CHECKED means the box is checked. BST_UNCHECKED means it's not.</P>

<P>Like push button controls, check boxes send BN_CLICKED notifications to 
their parents when clicked. The check mark in a BS_AUTOCHECKBOX check box 
toggles on and off automatically in response to button clicks. The check mark in a 
BS_CHECKBOX check box doesn't. Therefore, BS_CHECKBOX-style check boxes are of 
little use unless you write BN_CLICKED handlers to go with them. The following 
BN_CLICKED handler toggles <I>m_wndCheckBox</I>'s check mark on and off:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
void CMainWindow::OnCheckBoxClicked ()
{
    m_wndCheckBox.SetCheck (m_wndCheckBox.GetCheck () ==
        BST_CHECKED ? BST_UNCHECKED : BST_CHECKED);
}
</pre>
</td></tr></table>

<P>The BS_3STATE and BS_AUTO3STATE button styles create a check box that 
can assume a third state in addition to the checked and unchecked states. The third 
state is called the <I>indeterminate</I> state and is entered when the user clicks a 
BS_AUTO3STATE check box that is currently checked or when 
<I>SetCheck</I> is called with a BST_INDETERMINATE parameter:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndCheckBox.SetCheck (BST_INDETERMINATE);
</pre>
</td></tr></table>

<P>An indeterminate check box contains a grayed check mark. The indeterminate state 
is used to indicate that something is neither wholly on nor wholly off. For example, 
a word processing program might set a check box labeled &quot;Bold&quot; to the 
indeterminate state when the user selects a mix of normal and boldface text.</P>

<A NAME="179"><H3>Radio Buttons</H3></A>

<P>A radio button is a button control with the style BS_RADIOBUTTON or 
BS_AUTORADIOBUTTON. Radio buttons normally come in groups, with each button 
representing one in a list of mutually exclusive options. When clicked, a 
BS_AUTORADIOBUTTON radio button checks itself 
<I>and</I> unchecks the other radio buttons in the group. If you 
use the BS_RADIOBUTTON style instead, it's up to you to do the checking and 
unchecking using <I>CButton::SetCheck</I>.</P>

<P>Radio buttons send BN_CLICKED notifications to their parents, just as 
push buttons and check boxes do. The following BN_CLICKED handler checks the 
<I>m_wndRadioButton1</I> radio button and unchecks three other radio buttons in the same group:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
void CMainWindow::OnRadioButton1Clicked ()
{
    m_wndRadioButton1.SetCheck (BST_CHECKED);
    m_wndRadioButton2.SetCheck (BST_UNCHECKED);
    m_wndRadioButton3.SetCheck (BST_UNCHECKED);
    m_wndRadioButton4.SetCheck (BST_UNCHECKED);
}
</pre>
</td></tr></table>

<P>Unchecking the other radio buttons maintains the exclusivity of the selection. 
A BN_CLICKED handler isn't necessary for BS_AUTORADIOBUTTON radio 
buttons, though you can still provide one if you want to respond to changes in a radio 
button's state at the instant the button is clicked.</P>

<P>For BS_AUTORADIOBUTTON radio buttons to properly deselect the 
other buttons in the group, you must group the buttons so that Windows knows 
which buttons belong to the group. To create a group of BS_AUTORADIOBUTTON 
radio buttons, follow this procedure:</P>

<OL>
<P><LI>
In your application's code, create the buttons in sequence, one after 
another; don't create any other controls in between.
</LI></P>

<P><LI>
To mark the beginning of the group, assign the style WS_GROUP to 
the first radio button you create.
</LI></P>

<P><LI>
If you create additional controls after the last radio button is created, 
assign the WS_GROUP style to the first additional control that you 
create. This implicitly marks the previous control (the last radio button) as 
the final one in the group. If there are no other controls after the radio 
buttons but there are other controls in the window, mark the first control 
with WS_GROUP to prevent the radio button group from wrapping around.
</LI></P>
</OL>

<P>The following example demonstrates how to create four 
BS_AUTORADIOBUTTON radio buttons belonging to one group and three belonging to another 
group, with a check box control in between:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndRadioButton1.Create (_T (&quot;COM1&quot;), WS_CHILD &#166; WS_VISIBLE &#166;
    WS_GROUP &#166; BS_AUTORADIOBUTTON, rect1, this, IDC_COM1);
m_wndRadioButton2.Create (_T (&quot;COM2&quot;), WS_CHILD &#166; WS_VISIBLE &#166;
    BS_AUTORADIOBUTTON, rect2, this, IDC_COM2);
m_wndRadioButton3.Create (_T (&quot;COM3&quot;), WS_CHILD &#166; WS_VISIBLE &#166;
    BS_AUTORADIOBUTTON, rect3, this, IDC_COM3);
m_wndRadioButton4.Create (_T (&quot;COM4&quot;), WS_CHILD &#166; WS_VISIBLE &#166;
    BS_AUTORADIOBUTTON, rect4, this, IDC_COM4);
m_wndRadioButton1.SetCheck (BST_CHECKED);

m_wndCheckBox.Create (_T (&quot;Save settings on exit&quot;),
    WS_CHILD &#166; WS_VISIBLE &#166; WS_GROUP &#166; BS_AUTOCHECKBOX,
    rectCheckBox, this, IDC_SAVESETTINGS);

m_wndRadioButton5.Create (_T (&quot;9600&quot;), WS_CHILD &#166; WS_VISIBLE &#166;
    WS_GROUP &#166; BS_AUTORADIOBUTTON, rect5, this, IDC_9600);
m_wndRadioButton6.Create (_T (&quot;14400&quot;), WS_CHILD &#166; WS_VISIBLE &#166;
    BS_AUTORADIOBUTTON, rect6, this, IDC_14400);
m_wndRadioButton7.Create (_T (&quot;28800&quot;), WS_CHILD &#166; WS_VISIBLE &#166;
    BS_AUTORADIOBUTTON, rect7, this, IDC_28800);
m_wndRadioButton5.SetCheck (BST_CHECKED);
</pre>
</td></tr></table>

<P>Because of the BS_AUTORADIOBUTTON styles and the logical grouping 
provided by the WS_GROUP bits, checking any of the first four radio buttons 
automatically unchecks the other three in the group, and checking any radio button in the 
second group automatically unchecks the other two.</P>

<P>For good form, the code above calls 
<I>SetCheck</I> to check a button in each group. One of the buttons in a group of radio buttons should always be checked, even if 
the user has yet to provide any input. Radio buttons are never checked by default, so 
it's your responsibility to do the initializing.</P>

<A NAME="180"><H3>Group Boxes</H3></A>

<P>A group box is a button control created with the style BS_GROUPBOX. It is 
unlike other button controls in that it never receives the input focus and never sends 
notifications to its parent.</P>

<P>The sole function of the group box is to visually delineate control groups. 
Enclosing groups of controls in group boxes makes it apparent to the user which 
controls go together. Group boxes have nothing to do with the 
<I>logical </I>grouping of controls, so don't expect a series of radio buttons to function as a group simply because 
there's a group box around them.</P>

<A NAME="181"><H2>The <I>CListBox</I> Class</H2></A>
<P>MFC's <I>CListBox</I> class encapsulates list box controls, which display lists of text 
strings called <I>items</I>. A list box optionally sorts the items that are added to it, and scrolling 
is built in so that the number of items a list box can display isn't limited by the 
physical dimensions of the list box window.</P>

<P>List boxes are extremely useful for presenting lists of information and 
allowing users to select items from those lists. When an item is clicked or double-clicked, 
most list boxes (technically, those with LBS_NOTIFY in their window styles) notify 
their parents with WM_COMMAND messages. MFC simplifies the processing of 
these messages by providing ON_LBN message-map macros that you can use to route 
list box notifications to handling functions in the parent window class.</P>

<P>A standard list box displays text strings in a vertical column and allows only 
one item to be selected at a time. The currently selected item is highlighted with the 
system color COLOR_HIGHLIGHT. Windows supports a number of variations on 
the standard list box, including multiple-selection list boxes, multicolumn list boxes, 
and owner-draw list boxes that display images instead of text.</P>

<A NAME="182"><H3>Creating a List Box</H3></A>

<P>The following statement creates a standard list box from a 
<I>CListBox</I> object named <I>m_wndListBox</I>:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndListBox.Create (WS_CHILD &#166; WS_VISIBLE &#166; LBS_STANDARD,
    rect, this, IDC_LISTBOX);
</pre>
</td></tr></table>

<P>LBS_STANDARD combines the styles WS_BORDER, WS_VSCROLL, LBS_NOTIFY, 
and LBS_SORT to create a list box that has a border and a vertical scroll bar, that 
notifies its parent when the selection changes or an item is double-clicked, and that 
alphabetically sorts the strings that are added to it. By default, the scroll bar is visible 
only when the number of items in the list box exceeds the number that can be 
displayed. To make the scroll bar visible at all times, include the style 
LBS_DISABLENOSCROLL. A list box doesn't have a vertical scroll bar unless the style WS_VSCROLL or 
LBS_STANDARD is included. Similarly, it doesn't have a border unless it is created 
with the style WS_BORDER or LBS_STANDARD. You might want to omit the border if 
you create a list box that encompasses the entire client area of its parent. These and 
other styles used to customize a list box's appearance and behavior are summarized in 
the table below.</P>

<P>List boxes have keyboard interfaces built in. When a single-selection list 
box has the input focus, the up arrow, down arrow, Page Up, Page Down, Home, 
and End keys move the highlighted bar identifying the current selection. In addition, 
pressing a character key moves the selection to the next item beginning with that 
character. Keyboard input works in multiple-selection list boxes, too, but it's the position 
of a dotted focus rectangle, not the selection, that changes. Pressing the spacebar 
toggles the selection state of the item with the focus in a multiple-selection list box.</P>

<P>You can customize a list box's keyboard interface by including the 
LBS_WANTKEYBOARDINPUT style and processing WM_VKEYTOITEM and 
WM_CHARTOITEM messages. An MFC application can map these messages to 
<I>OnVKeyToItem</I> and <I>OnCharToItem</I> handlers using the ON_WM_VKEYTOITEM and ON_WM_CHARTOITEM 
macros. A derived list box class can handle these messages itself by overriding the 
virtual <I>CListBox::VKeyToItem</I> and 
<I>CListBox::CharToItem</I> functions. One use for this 
capability is to create a self-contained list box class that responds to presses of Ctrl-D by 
deleting the item that is currently selected.</P>

<P><B>List Box Styles</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Style</I></th>     
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top">LBS_STANDARD</td>     
<td valign="top">Creates a &quot;standard&quot; list box that has a border and 
a vertical scroll bar, notifies its parent window 
when the selection changes or an item is 
double-clicked, and sorts items alphabetically.</td>
</tr>
<tr>
<td valign="top">LBS_SORT</td>     
<td valign="top">Sorts items that are added to the list box.</td>
</tr>
<tr>
<td valign="top">LBS_NOSEL</td>     
<td valign="top">Creates a list box whose items can be viewed 
but not selected.</td>
</tr>
<tr>
<td valign="top">LBS_NOTIFY</td>     
<td valign="top">Creates a list box that notifies its parent when 
the selection changes or an item is double-clicked.</td>
</tr>
<tr>
<td valign="top">LBS_DISABLENOSC ROLL</td>     
<td valign="top">Disables the list box's scroll bar when it isn't 
needed. Without this style, an unneeded scroll bar is 
hidden rather than disabled.</td>
</tr>
<tr>
<td valign="top">LBS_MULTIPLESEL</td>     
<td valign="top">Creates a multiple-selection list box.</td>
</tr>
<tr>
<td valign="top">LBS_EXTENDEDSEL</td>    
<td valign="top">Adds extended selection support to a 
multiple-selection list box.</td>
</tr>
<tr>
<td valign="top">LBS_MULTICOLUMN</td>     
<td valign="top">Creates a multicolumn list box.</td>
</tr>
<tr>
<td valign="top">LBS_OWNERDRAWVARIABLE</td>     
<td valign="top">Creates an owner-draw list box whose items 
can vary in height.</td>
</tr>
<tr>
<td valign="top">LBS_OWNERDRAWFIXED</td>     
<td valign="top">Creates an owner-draw list box whose items 
are the same height.</td>
</tr>
<tr>
<td valign="top">LBS_USETABSTOPS</td>     
<td valign="top">Configures the list box to expand tab characters 
in item text.</td>
</tr>
<tr>
<td valign="top">LBS_NOREDRAW</td>     
<td valign="top">Creates a list box that doesn't automatically 
redraw itself when an item is added or removed.</td>
</tr>
<tr>
<td valign="top">LBS_HASSTRINGS</td>     
<td valign="top">Creates a list box that &quot;remembers&quot; the strings 
added to it. Conventional list boxes have this style by 
default; owner-draw list boxes don't.</td>
</tr>
<tr>
<td valign="top">LBS_WANTKEYBOARDINPUT</td>     
<td valign="top">Creates a list box that sends its parent a 
WM_VKEYTOITEM or WM_CHARTOITEM message when a key is pressed. This style is used to customize the list box's response to keyboard input.</td>
</tr>
<tr>
<td valign="top">LBS_NOINTEGRALHEIGHT</td>     
<td valign="top">Allows a list box to assume any height. By 
default, Windows sets a list box's height to a multiple 
of the item height to prevent items from being partially clipped.</td>
</tr></table></p>

<P>Because the default font that Windows uses for list boxes is 
proportionally spaced, it is virtually impossible to line up columns of information in a list box 
by separating them with space characters. One way to create a columnar list box 
display is to use <I>SetFont</I> to apply a fixed-pitch font to the list box. A better solution is 
to assign the list box the style LBS_USETABSTOPS and separate columns of 
information with tab characters. An LBS_USETABSTOPS list box treats tab characters the 
way a word processor does, automatically advancing to the next tab stop when a tab 
character is encountered. By default, tab stops are evenly spaced about eight 
character widths apart. You can change the default tab stop settings with the 
<I>CListBox::SetTabStops</I> function. 
<I>SetTabStops</I> measures distances in <I>dialog 
units</I>. One dialog unit is approximately equal to one-fourth the width of a character in the system font. 
The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndListBox.SetTabStops (64);
</pre>
</td></tr></table>

<P>sets the space between tab stops to 64 dialog units, and</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
int nTabStops[] = { 32, 48, 64, 128 };
m_wndListBox.SetTabStops (4, nTabStops);
</pre>
</td></tr></table>

<P>places tab stops at 32, 48, 64, and 128 dialog units from the left margin.</P>

<P>By default, a list box repaints itself whenever an item is added or 
removed. Usually that's just what you want, but if you're adding hundreds or perhaps 
thousands of items in rapid-fire fashion, the repeated repaints produce an unsightly 
flashing effect and slow down the insertion process. You can use LBS_NOREDRAW to 
create a list box that doesn't automatically repaint itself. Such a list box will be 
repainted only when its client area is invalidated.</P>

<P>An alternative to using LBS_NOREDRAW is to disable redraws before 
beginning a lengthy insertion process and to reenable them after the last item is inserted. 
You can enable and disable redraws programmatically by sending a list box 
WM_SETREDRAW messages, as shown here:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndListBox.SendMessage (WM_SETREDRAW, FALSE, 0); // Disable redraws.
     <img src="images/grayvellip.JPG" width=3 height=13 border="0">
m_wndListBox.SendMessage (WM_SETREDRAW, TRUE, 0);  // Enable redraws.
</pre>
</td></tr></table>

<P>A list box is automatically repainted when redraws are enabled with 
WM_SETREDRAW, so it's not necessary to follow up with a call to 
<I>Invalidate</I>.</P>

<P>Unless a list box is created with the style LBS_MULTIPLESEL, only one item 
can be selected at a time. In a single-selection list box, clicking an unselected item 
both selects that item and deselects the one that was formerly selected. In a 
multiple-selection list box, any number of items can be selected. Most multiple-selection 
list boxes are also created with the style LBS_EXTENDEDSEL, which enables 
extended selections. In an extended-selection list box, the user selects the first item by 
clicking it and selects subsequent items by clicking with the Ctrl key pressed. In addition, 
the user can select entire ranges of contiguous items by clicking the first item in the 
range and then clicking the last item in the range with the Shift key held down. The 
Ctrl and Shift keys can be combined to select multiple items and ranges, the net 
result being a handy interface for selecting arbitrary combinations of items.</P>

<P>The LBS_MULTICOLUMN style creates a multicolumn list box. Multicolumn 
list boxes are usually created with the WS_HSCROLL style so that their contents can 
be scrolled horizontally if not all the items can be displayed at once. (Multicolumn 
list boxes can't be scrolled vertically.) You can adjust the column width with the 
<I>CListBox::SetColumnWidth</I> function. Normally, the column width should be based on 
the average width of a character in the list box font. The default column width is 
enough to display about 16 characters in the default list box font, so if you'll be inserting 
strings longer than that, you should expand the column width to prevent columns 
from overlapping.</P>

<A NAME="183"><H3>Adding and Removing Items</H3></A>

<P>A list box is empty until items are added to it. Items are added with 
<I>CListBox::AddString</I> and 
<I>CListBox::InsertString</I>. The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndListBox.AddString (string);
</pre>
</td></tr></table>

<P>adds the <I>CString</I> object named 
<I>string</I> to the list box. If the list box style 
includes LBS_SORT, the string is positioned according to its lexical value; otherwise, it is 
added to the end of the list. <I>InsertString</I> adds an item to the list box at a location 
specified by a 0-based index. The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndListBox.InsertString (3, string);
</pre>
</td></tr></table>

<P>inserts <I>string</I> into the list box and makes it the fourth item. LBS_SORT has no 
effect on strings added with <I>InsertString</I>.</P>

<P>Both <I>AddString</I> and <I>InsertString</I> return a 0-based index specifying the 
string's position in the list box. If either function fails, it returns LB_ERRSPACE to 
indicate that the list box is full or LB_ERR to indicate that the insertion failed for other 
reasons. You shouldn't see the LB_ERRSPACE return value very often in 32-bit 
Windows because the capacity of a list box is limited only by available memory. 
<I>CListBox::GetCount</I> returns the number of items in a list box.</P>

<P><I>CListBox::DeleteString</I> removes an item from a list box. It takes a single 
parameter: the index of the item to be removed. It returns the number of items remaining in 
the list box. To remove all items from a list box at once, use 
<I>CListBox::ResetContent</I>.</P>

<P>If desired, you can use 
<I>CListBox::SetItemDataPtr</I> or <I>CListBox::SetItemData</I> to associate a 32-bit pointer or a DWORD value with an item in a list box. A pointer 
or DWORD associated with an item can be retrieved with 
<I>CListBox::GetItemDataPtr</I> or 
<I>CListBox::GetItemData</I>. One use for this feature is to associate extra data with the 
items in a list box. For example, you could associate a data structure containing an 
address and a phone number with a list box item holding a person's name. Because 
<I>GetItemDataPtr</I> returns a pointer to a void data type, you'll need to cast the pointer that 
it returns.</P>

<P>Another technique programmers use to associate extra data&#8212;particularly 
text-based data&#8212;with list box items is to create an LBS_USETABSTOPS-style list box, 
set the first tab stop to a position beyond the list box's right border, and append a 
string consisting of a tab character followed by the extra data to the list box item. The 
text to the right of the tab character will be invisible, but 
<I>CListBox::GetText</I> will return the full text of the list box item&#8212;additional text included.</P>

<A NAME="184"><H3>Finding and Retrieving Items</H3></A>

<P>The <I>CListBox</I> class also includes member functions for getting and setting the 
current selection and for finding and retrieving items. 
<I>CListBox::GetCurSel</I> returns the 0-based index of the item that is currently selected. A return value equal to LB_ERR 
means that nothing is selected. <I>GetCurSel</I> is often called following a notification 
signifying that the selection changed or an item was double-clicked. A program can set the 
current selection with the <I>SetCurSel </I>function. Passing 
<I>SetCurSel </I>the value -1 deselects all items, causing the bar highlighting the current selection to disappear from the list box. 
To find out whether a particular item is selected, use 
<I>CListBox::GetSel</I>.</P>

<P><I>SetCurSel</I> identifies an item by its index, but items can also be selected by 
content. <I>CListBox::SelectString</I> searches a single-selection list box for an item that begins 
with a specified text string and selects the item if a match is found. The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndListBox.SelectString (-1, _T (&quot;Times&quot;));
</pre>
</td></tr></table>

<P>starts the search with the first item in the list box and highlights the first item that 
begins with &quot;Times&quot;&#8212;for example, &quot;Times New Roman&quot; or &quot;Times Roman.&quot; The 
search is not case-sensitive. The first parameter to 
<I>SelectString </I>specifies<I> </I>the index of the 
item before the one at which the search begins; -1 instructs the list box to start with item 
0. If the search is begun anywhere else, the search will wrap around to the first item 
if necessary so that all list box items are searched.</P>

<P>To search a list box for a particular item without changing the selection, 
use <I>CListBox::FindString</I> or 
<I>CListBox::FindStringExact</I>. 
<I>FindString</I> performs a string search on a list box's contents and returns the index of the first item whose text matches 
or begins with a specified string. A return value equal to LB_ERR means that no 
match was found. <I>FindStringExact</I> does the same but reports a match only if the item 
text matches the search text exactly. Once you have an item's index in hand, you 
can retrieve the text of the item with 
<I>CListBox::GetText</I>. The following statements 
query the list box for the currently selected item and copy the text of that item to a 
<I>CString</I> named <I>string</I>:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CString string;
int nIndex = m_wndListBox.GetCurSel ();
if (nIndex != LB_ERR)
    m_wndListBox.GetText (nIndex, string);
</pre>
</td></tr></table>

<P>An alternative form of <I>GetText</I> accepts a pointer to a character array rather than 
a <I>CString</I> reference. You can use 
<I>CListBox::GetTextLen</I> to determine how large the 
array should be before calling the array version of 
<I>GetText</I>.</P>

<P>Selections in multiple-selection list boxes are handled differently than 
selections in single-selection list boxes. In particular, the 
<I>GetCurSel</I>, <I>SetCurSel</I>, and 
<I>SelectString</I> functions don't work with multiple-selection list boxes. Instead, items are 
selected (and deselected) with the <I>SetSel</I> and 
<I>SelItemRange</I> functions. The following 
statements select items 0, 5, 6, 7, 8, and 9 and deselect item 3:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndListBox.SetSel (0);
m_wndListBox.SelItemRange (TRUE, 5, 9);
m_wndListBox.SetSel (3, FALSE);
</pre>
</td></tr></table>

<P><I>CListBox</I> also provides the 
<I>GetSelCount</I> function for getting a count of selected 
items and the <I>GetSelItems</I> function for retrieving the indexes of all selected items. In a 
multiple-selection list box, the dotted rectangle representing the item with the focus can be 
moved without changing the current selection. The focus rectangle can be moved and 
queried with <I>SetCaretIndex</I> and 
<I>GetCaretIndex</I>. Most other list box functions, including 
<I>GetText</I>, <I>GetTextLength</I>, 
<I>FindString</I>, and <I>FindStringExact</I>, work the same for 
multiple-selection list boxes as they do for the single-selection variety.</P>

<A NAME="185"><H3>List Box Notifications</H3></A>

<P>A list box sends notifications to its parent window via WM_COMMAND messages. 
In an MFC application, list box notifications are mapped to class member functions 
with ON_LBN message-map entries. The table below lists the six notification types and the corresponding ON_LBN macros. LBN_DBLCLK, 
LBN_SELCHANGE, and LBN_SELCANCEL notifications are sent only if the list box was created with 
the style LBS_NOTIFY or LBS_STANDARD. The others are sent regardless of list box style.</P>

<P><B>List Box Notifications</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Notification</I></th>
<th valign="top"><I>Sent When</I></th>
<th valign="top"><I>Message-Map Macro</I></th>
<th valign="top"><I>LBS_NOTIFY Required?</I></th>
</tr>
<tr>
<td valign="top">LBN_SETFOCUS</td>     
<td valign="top">The list box gains the input focus.</td>      
<td valign="top">ON_LBN_SETFOCUS</td>     
<td valign="top">No</td>  
</tr>
<tr>
<td valign="top">LBN_KILLFOCUS</td>     
<td valign="top">The list box loses the input focus.</td>     
<td valign="top">ON_LBN_KILLFOCUS</td>     
<td valign="top">No</td>
</tr>
<tr> 
<td valign="top">LBN_ERRSPACE</td>     
<td valign="top">An operation failed because of insufficient memory.</td>      
<td valign="top">ON_LBN_ERRSPACE</td>     
<td valign="top">No</td>
</tr>
<tr>   
<td valign="top">LBN_DBLCLK</td>    
<td valign="top">An item is double-clicked.</td>
<td valign="top">ON_LBN_DBLCLK</td>
<td valign="top">Yes</td>
</tr>
<tr>  
<td valign="top">LBN_SELCHANGE</td>
<td valign="top">The selection changes.</td>
<td valign="top">ON_LBN_SELCHANGE</td>
<td valign="top">Yes</td>
</tr>
<tr>
<td valign="top">LBN_SELCANCEL</td>
<td valign="top">The selection is canceled.</td>
<td valign="top">ON_LBN_SELCANCEL</td>
<td valign="top">Yes</td>
</tr></table></p>

<P>The two list box notifications that programmers rely on most are 
LBN_DBLCLK and LBN_SELCHANGE. LBN_DBLCLK is sent when a list box item is 
double-clicked. To determine the index of the item that was double-clicked in a single-selection 
list box, use <I>CListBox::GetCurSel</I>. The following code fragment displays the item in 
a message box:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
// In CMainWindow's message map
ON_LBN_DBLCLK (IDC_LISTBOX, OnItemDoubleClicked)
     <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
void CMainWindow::OnItemDoubleClicked ()
{
    CString string;
    int nIndex = m_wndListBox.GetCurSel ();
    m_wndListBox.GetText (nIndex, string);
    MessageBox (string);
}
</pre>
</td></tr></table>

<P>For a multiple-selection list box, use 
<I>GetCaretIndex</I> instead of <I>GetCurSel</I> to 
determine which item was double-clicked.</P>

<P>A list box sends an LBN_SELCHANGE notification when the user changes 
the selection, but not when the selection is changed programmatically. A 
single-selection list box sends an LBN_SELCHANGE notification when the selection moves because 
of a mouse click or keystroke. A multiple-selection list box sends an 
LBN_SELCHANGE notification when an item is clicked, when an item's selection state is toggled with 
the spacebar, and when the focus rectangle is moved.</P>

<A NAME="186"><H2>The <I>CStatic</I> Class</H2></A>
<P><I>CStatic</I>, which represents static controls created from the &quot;STATIC&quot; WNDCLASS, 
is the simplest of the MFC control classes. At least it 
<I>used</I> to be: Windows 95 added so many new features to static controls that 
<I>CStatic</I> now rivals <I>CButton</I> and some of 
the other control classes for complexity.</P>

<P>Static controls come in three flavors: text, rectangles, and images. Static 
text controls are often used to label other controls. The following statement creates a 
static text control that displays the string &quot;Name&quot;:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndStatic.Create (_T (&quot;Name&quot;), WS_CHILD &#166; WS_VISIBLE &#166; SS_LEFT,
    rect, this, IDC_STATIC);
</pre>
</td></tr></table>

<P>SS_LEFT creates a static text control whose text is left-aligned. If the control text 
is too long to fit on one line, it wraps around to the next one. To prevent wrapping, 
use SS_LEFTNOWORDWRAP instead of SS_LEFT. Text can be centered horizontally 
or right-aligned in a static control by substituting SS_CENTER or SS_RIGHT for 
SS_LEFT or SS_LEFTNOWORDWRAP. Another alternative is the little-used SS_SIMPLE 
style, which is similar to SS_LEFT but creates a control whose text can't be altered 
with <I>CWnd::SetWindowText</I>.</P>

<P>By default, the text assigned to a static text control is aligned along the 
upper edge of the control rectangle. To center text vertically in the control rectangle, OR 
an SS_CENTERIMAGE flag into the control style. You can also draw a sunken 
border around a static control by including the style SS_SUNKEN.</P>

<P>A second use for static controls is to draw rectangles. The control style 
specifies the type of rectangle that is drawn. Here are the styles you can choose from:</P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Style</I></th>     
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top">SS_BLACKFRAME</td>     
<td valign="top">Hollow rectangle painted in the system color 
COLOR_WINDOWFRAME (default = black)</td>
</tr>
<tr>
<td valign="top">SS_BLACKRECT</td>     
<td valign="top">Solid rectangle painted in the system color 
COLOR_WINDOWFRAME (default = black)</td>
</tr>
<tr>
<td valign="top">SS_ETCHEDFRAME</td>     
<td valign="top">Hollow rectangle with etched borders</td>
</tr>
<tr>
<td valign="top">SS_ETCHEDHORZ</td>     
<td valign="top">Hollow rectangle with etched top and bottom borders</td>
</tr>
<tr>
<td valign="top">SS_ETCHEDVERT</td>    
<td valign="top">Hollow rectangle with etched left and right borders</td>
</tr>
<tr>
<td valign="top">SS_GRAYFRAME</td>
<td valign="top">Hollow rectangle painted in the system color 
COLOR_BACKGROUND (default = gray)</td>
</tr>
<tr>
<td valign="top">SS_GRAYRECT</td>
<td valign="top">Solid rectangle painted in the system color 
COLOR_BACKGROUND (default = gray)</td>
</tr>
<tr>
<td valign="top">SS_WHITEFRAME</td>
<td valign="top">Hollow rectangle painted in the system color 
COLOR_WINDOW (default = white)</td>
</tr>
<tr>
<td valign="top">SS_WHITERECT</td>
<td valign="top">Solid rectangle painted in the system color 
COLOR_WINDOW (default = white)</td>
</tr></table></p>

<P>The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndStatic.Create (_T (&quot;&quot;), WS_CHILD &#166; WS_VISIBLE &#166; SS_ETCHEDFRAME,
    rect, this, IDC_STATIC);
</pre>
</td></tr></table>

<P>creates a static control that resembles a group box. For best results, you should 
draw etched rectangles on surfaces whose color is the same as the default dialog box 
color (the system color COLOR_3DFACE). A static rectangle control doesn't display 
text, even if you specify a nonnull text string in the call to 
<I>Create</I>.</P>

<P>A third use for static controls is to display images formed from bitmaps, 
icons, cursors, or GDI metafiles. A static image control uses one of the following styles:</P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Style</I></th>     
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top">SS_BITMAP</td>     
<td valign="top">A static control that displays a bitmap</td>
</tr>
<tr>
<td valign="top">SS_ENHMETAFILE</td>
<td valign="top">A static control that displays a metafile</td>
</tr>
<tr>
<td valign="top">SS_ICON</td>
<td valign="top">A static control that displays an icon or a cursor</td>
</tr></table></p>

<P>After creating an image control, you associate a bitmap, metafile, icon, or 
cursor with it by calling its <I>SetBitmap</I>, 
<I>SetEnhMetaFile</I>, <I>SetIcon</I>, or 
<I>SetCursor</I> function. The statements</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndStatic.Create (_T (&quot;&quot;), WS_CHILD &#166; WS_VISIBLE &#166; SS_ICON,
    rect, this, IDC_STATIC);
m_wndStatic.SetIcon (hIcon);
</pre>
</td></tr></table>

<P>create a static control that displays an icon and assign it the icon whose handle 
is <I>hIcon</I>. By default, the icon image is positioned in the upper left corner of the 
control, and if the image is larger than the control rectangle, the rectangle is 
automatically expanded so the image won't be clipped. To center the image in the 
control rectangle, OR SS_CENTERIMAGE into the control style. SS_CENTERIMAGE 
prevents the system from automatically sizing the control rectangle if it's too small to show 
the entire image, so if you use SS_CENTERIMAGE, be sure that the control rectangle 
is large enough to display the image. Sizing isn't an issue with 
SS_ENHMETAFILE-style controls because metafile images scale to match the control size. For a neat 
special effect, place a sunken border around an image control by ORing SS_SUNKEN 
into the control style.</P>

<P>By default, a static control sends no notifications to its parent. But a static 
control created with the SS_NOTIFY style sends the four types of notifications listed 
in the following table.</P>

<P><B>Static Control Notifications</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Notification</I></th>    
<th valign="top"><I>Sent When</I></th>
<th valign="top"><I>Message-Map Macro</I></th>
</tr>
<tr>
<td valign="top">STN_CLICKED</td>     
<td valign="top">The control is clicked.</td>
<td valign="top">ON_STN_CLICKED</td>
</tr>
<tr>
<td valign="top">STN_DBLCLK</td>
<td valign="top">The control is double-clicked.</td>
<td valign="top">ON_STN_DBLCLK</td>
</tr>
<tr>
<td valign="top">STN_DISABLE</td>
<td valign="top">The control is disabled.</td>
<td valign="top">ON_STN_DISABLE</td>
</tr>
<tr>
<td valign="top">STN_ENABLE</td>
<td valign="top">The control is enabled.</td>
<td valign="top">ON_STN_ENABLE</td>
</tr></table></p>

<P>The STN_CLICKED and STN_DBLCLK notifications allow you to create 
static controls that respond to mouse clicks. The statements</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
// In CMainWindow's message map
ON_STN_CLICKED (IDC_STATIC, OnClicked)
      <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
// In CMainWindow::OnCreate
m_wndStatic.Create (_T (&quot;Click me&quot;), WS_CHILD &#166; WS_VISIBLE &#166;
    SS_CENTER &#166; SS_CENTERIMAGE &#166; SS_NOTIFY &#166; SS_SUNKEN, rect,
    this, IDC_STATIC);
      <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
void CMainWindow::OnClicked ()
{
    m_wndStatic.PostMessage (WM_CLOSE, 0, 0);
}
</pre>
</td></tr></table>

<P>create a static control that displays &quot;Click me&quot; in the center of a sunken rectangle 
and disappears from the screen when clicked. If a static control lacks the SS_NOTIFY 
style, mouse messages go through to the underlying window because the control's 
window procedure returns HTTRANSPARENT in response to WM_NCHITTEST messages.</P>

<A NAME="187"><H2>The FontView Application</H2></A>

<P>Let's put what we've learned so far about buttons, list boxes, and static controls 
to use in an application. The FontView program shown in Figure 7-3 lists the names 
of all the fonts installed on the host PC in a list box. When a font name is selected, 
a sample is drawn in the group box at the bottom of the window. The sample text 
is really a static control, so all FontView has to do to display a font sample is call 
the control's <I>SetFont</I> function. If the check box labeled Show TrueType Fonts Only is checked, non-TrueType fonts are excluded from the list. In addition to showing 
how push button, check box, list box, group box, and static controls are used, 
FontView also demonstrates a very important MFC programming technique&#8212;the use of 
C++ member functions as callback functions. The term 
<I>callback function</I> might not mean much to you at the moment, but you'll learn all about it shortly.</P>

<P>
<img src="images/F07mg03.GIF" width=346 height=363 border="0">
</p><p>
<!-- CAPTION --><B>Figure 7-3.</B> <I>The FontView window.</I><!-- /CAPTION -->
</p>

<P>FontView's source code appears in Figure 7-4. The controls are created one 
by one in <I>CMainWindow::OnCreate</I>. All but one&#8212;the static control that displays the 
font sample&#8212;is assigned an 8-point MS Sans Serif font. Rather than use raw pixel 
counts to size and position the controls, FontView uses distances based on the width 
and height of 8-point MS Sans Serif characters to achieve independence from the 
physical resolution of the display device. The character height and width are measured 
by selecting the font into a device context and calling 
<I>CDC::GetTextMetrics</I> with a pointer to a TEXTMETRIC structure:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CFont* pOldFont = dc.SelectObject (&amp;m_fontMain);
TEXTMETRIC tm;
dc.GetTextMetrics (&amp;tm);
m_cxChar = tm.tmAveCharWidth;
m_cyChar = tm.tmHeight + tm.tmExternalLeading;
</pre>
</td></tr></table>

<P>On return, the structure's 
<I>tmAveCharWidth</I> field holds the average character 
width. (Actual character width can vary from character to character in a proportionally 
spaced font.) Summing the <I>tmHeight</I> and 
<I>tmExternalLeading</I> fields yields the height of 
one line of text, including interline spacing.</P>

<p><B>Figure 7-4.</B> <I>The FontView application.</I></p>

<table cellpadding=5 width="95%"><tr><td>
<A NAME="188"><H3>FontView.h</H3></A>
<pre>
class CMyApp : public CWinApp
{
public:
    virtual BOOL InitInstance ();
};

class CMainWindow : public CWnd
{
protected:
    int m_cxChar;
    int m_cyChar;

    CFont m_fontMain;
    CFont m_fontSample;

    CStatic m_wndLBTitle;
    CListBox m_wndListBox;
    CButton m_wndCheckBox;
    CButton m_wndGroupBox;
    CStatic m_wndSampleText;
    CButton m_wndPushButton;

    void FillListBox ();

public:
    CMainWindow ();

    static int CALLBACK EnumFontFamProc (ENUMLOGFONT* lpelf,
        NEWTEXTMETRIC* lpntm, int nFontType, LPARAM lParam);

protected:
    virtual void PostNcDestroy ();

    afx_msg int OnCreate (LPCREATESTRUCT lpcs);
    afx_msg void OnPushButtonClicked ();   
    afx_msg void OnCheckBoxClicked ();
    afx_msg void OnSelChange ();

    DECLARE_MESSAGE_MAP ()
};
</pre>
</td></tr></table>

<table cellpadding=5 width="95%"><tr><td>
<h3>FontView.cpp</h3>
<pre>
#include &lt;afxwin.h&gt;
#include &quot;FontView.h&quot;

#define IDC_PRINT       100
#define IDC_CHECKBOX    101
#define IDC_LISTBOX     102
#define IDC_SAMPLE      103

CMyApp myApp;

/////////////////////////////////////////////////////////////////////////
// CMyApp member functions

BOOL CMyApp::InitInstance ()
{
    m_pMainWnd = new CMainWindow;
    m_pMainWnd-&gt;ShowWindow (m_nCmdShow);
    m_pMainWnd-&gt;UpdateWindow ();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////
// CMainWindow message map and member functions

BEGIN_MESSAGE_MAP (CMainWindow, CWnd)
    ON_WM_CREATE ()
    ON_BN_CLICKED (IDC_PRINT, OnPushButtonClicked)
    ON_BN_CLICKED (IDC_CHECKBOX, OnCheckBoxClicked)
    ON_LBN_SELCHANGE (IDC_LISTBOX, OnSelChange)
END_MESSAGE_MAP ()

CMainWindow::CMainWindow ()
{
    CString strWndClass = AfxRegisterWndClass (
        0,
        myApp.LoadStandardCursor (IDC_ARROW),
        (HBRUSH) (COLOR_3DFACE + 1),
        myApp.LoadStandardIcon (IDI_WINLOGO)
    );
    CreateEx (0, strWndClass, _T (&quot;FontView&quot;),
        WS_OVERLAPPED &#166; WS_SYSMENU &#166; WS_CAPTION &#166; WS_MINIMIZEBOX,
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
        NULL, NULL, NULL);

    CRect rect (0, 0, m_cxChar * 68, m_cyChar * 26);
    CalcWindowRect (&amp;rect);

    SetWindowPos (NULL, 0, 0, rect.Width (), rect.Height (),
        SWP_NOZORDER &#166; SWP_NOMOVE &#166; SWP_NOREDRAW);
}

int CMainWindow::OnCreate (LPCREATESTRUCT lpcs)
{
    if (CWnd::OnCreate (lpcs) == -1)
        return -1;

    //
    // Create an 8-point MS Sans Serif font to use in the controls.
    //
    m_fontMain.CreatePointFont (80, _T (&quot;MS Sans Serif&quot;));

    //
    // Compute the average width and height of a character in the font.
    //
    CClientDC dc (this);
    CFont* pOldFont = dc.SelectObject (&amp;m_fontMain);
    TEXTMETRIC tm;
    dc.GetTextMetrics (&amp;tm);
    m_cxChar = tm.tmAveCharWidth;
    m_cyChar = tm.tmHeight + tm.tmExternalLeading;
    dc.SelectObject (pOldFont);

    //
    // Create the controls that will appear in the FontView window.
    //
    CRect rect (m_cxChar * 2, m_cyChar, m_cxChar * 48, m_cyChar * 2);
    m_wndLBTitle.Create (_T (&quot;Typefaces&quot;), WS_CHILD &#166; WS_VISIBLE &#166; SS_LEFT,
        rect, this);

    rect.SetRect (m_cxChar * 2, m_cyChar * 2, m_cxChar * 48,
        m_cyChar * 18);
    m_wndListBox.CreateEx (WS_EX_CLIENTEDGE, _T (&quot;listbox&quot;), NULL,
        WS_CHILD &#166; WS_VISIBLE &#166; LBS_STANDARD, rect, this, IDC_LISTBOX);

    rect.SetRect (m_cxChar * 2, m_cyChar * 19, m_cxChar * 48,
        m_cyChar * 20);
    m_wndCheckBox.Create (_T (&quot;Show TrueType fonts only&quot;),  WS_CHILD &#166;
        WS_VISIBLE &#166; BS_AUTOCHECKBOX, rect, this, IDC_CHECKBOX);

	rect.SetRect (m_cxChar * 2, m_cyChar * 21, m_cxChar * 66,
        m_cyChar * 25);
    m_wndGroupBox.Create (_T (&quot;Sample&quot;),  WS_CHILD &#166; WS_VISIBLE &#166; BS_GROUPBOX,
        rect, this, (UINT) -1);

    rect.SetRect (m_cxChar * 4, m_cyChar * 22, m_cxChar * 64,
        (m_cyChar * 99) / 4);
    m_wndSampleText.Create (_T (&quot;&quot;), WS_CHILD &#166; WS_VISIBLE &#166; SS_CENTER, rect,
        this, IDC_SAMPLE);

    rect.SetRect (m_cxChar * 50, m_cyChar * 2, m_cxChar * 66,
        m_cyChar * 4);
    m_wndPushButton.Create (_T (&quot;Print Sample&quot;), WS_CHILD &#166; WS_VISIBLE &#166;
        WS_DISABLED &#166; BS_PUSHBUTTON, rect, this, IDC_PRINT);

    //
    // Set each control's font to 8-point MS Sans Serif.
    //
    m_wndLBTitle.SetFont (&amp;m_fontMain, FALSE);
    m_wndListBox.SetFont (&amp;m_fontMain, FALSE);
    m_wndCheckBox.SetFont (&amp;m_fontMain, FALSE);
    m_wndGroupBox.SetFont (&amp;m_fontMain, FALSE);
    m_wndPushButton.SetFont (&amp;m_fontMain, FALSE);

    //
    // Fill the list box with typeface names and return.
    //
    FillListBox ();
    return 0;
}

void CMainWindow::PostNcDestroy ()
{
    delete this;
}

void CMainWindow::OnPushButtonClicked ()
{
    MessageBox (_T (&quot;This feature is currently unimplemented. Sorry!&quot;),
        _T (&quot;Error&quot;), MB_ICONINFORMATION &#166; MB_OK);
}

void CMainWindow::OnCheckBoxClicked ()
{
    FillListBox ();
    OnSelChange ();
}

void CMainWindow::OnSelChange ()
{
    int nIndex = m_wndListBox.GetCurSel ();

    if (nIndex == LB_ERR) {
        m_wndPushButton.EnableWindow (FALSE);
        m_wndSampleText.SetWindowText (_T (&quot;&quot;));
    }
    else {
        m_wndPushButton.EnableWindow (TRUE);
        if ((HFONT) m_fontSample != NULL)
            m_fontSample.DeleteObject ();

        CString strFaceName;
        m_wndListBox.GetText (nIndex, strFaceName);

        m_fontSample.CreateFont (-m_cyChar * 2, 0, 0, 0, FW_NORMAL,
            0, 0, 0, DEFAULT_CHARSET, OUT_CHARACTER_PRECIS,
            CLIP_CHARACTER_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH &#166;
            FF_DONTCARE, strFaceName);

        m_wndSampleText.SetFont (&amp;m_fontSample);
        m_wndSampleText.SetWindowText (_T (&quot;AaBbCcDdEeFfGg&quot;));
    }
}

void CMainWindow::FillListBox ()
{
    m_wndListBox.ResetContent ();

    CClientDC dc (this);
    ::EnumFontFamilies ((HDC) dc, NULL, (FONTENUMPROC) EnumFontFamProc,
        (LPARAM) this);
}

int CALLBACK CMainWindow::EnumFontFamProc (ENUMLOGFONT* lpelf,
    NEWTEXTMETRIC* lpntm, int nFontType, LPARAM lParam)
{
    CMainWindow* pWnd = (CMainWindow*) lParam;

    if ((pWnd-&gt;m_wndCheckBox.GetCheck () == BST_UNCHECKED) ||
        (nFontType &amp; TRUETYPE_FONTTYPE))
        pWnd-&gt;m_wndListBox.AddString (lpelf-&gt;elfLogFont.lfFaceName);
    return 1;
}
</pre>
</td></tr></table>

<P><I>CMainWindow</I> processes three types of control notifications: 
BN_CLICKED notifications from the push button, BN_CLICKED notifications from the check 
box, and LBN_SELCHANGE notifications from the list box. The corresponding 
message-map entries look like this:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
ON_BN_CLICKED (IDC_PRINT, OnPushButtonClicked)
ON_BN_CLICKED (IDC_CHECKBOX, OnCheckBoxClicked)
ON_LBN_SELCHANGE (IDC_LISTBOX, OnSelChange)
</pre>
</td></tr></table>

<P><I>OnPushButtonClicked</I> is activated when the Print Sample button is clicked. 
Because printing is a complex undertaking in a Windows application, 
<I>OnPushButtonClicked</I> does nothing more than display a message box. 
<I>OnCheckBoxClicked</I> handles BN_CLICKED notifications from the check box. Since the check box style includes 
a BS_AUTOCHECKBOX flag, the check mark toggles on and off automatically in 
response to button clicks. 
<I>OnCheckBoxClicked</I>'s job is to refresh the contents of the list 
box each time the check mark is toggled. To do that, it calls 
<I>CMainWindow::FillListBox</I> to reinitialize the list box and then calls 
<I>CMainWindow::OnSelChange</I> to update the sample text.</P>

<P><I>OnSelChange</I> is also called whenever the list box selection changes. It 
calls <I>GetCurSel</I> to get the index of the currently selected item. If 
<I>GetCurSel</I> returns LB_ERR, indicating that nothing is selected, 
<I>OnSelChange</I> disables the push button and 
erases the sample text. Otherwise, it enables the button, retrieves the text of the 
selected item with <I>CListBox::GetText</I>, and creates a font whose typeface name equals the 
string returned by <I>GetText</I>. It then assigns the font to the static control and sets the 
control text to &quot;AaBbCcDdEeFfGg.&quot;</P>

<A NAME="189"><H3>Font Enumerations and Callback Functions</H3></A>

<P>The job of filling the list box with font names falls to 
<I>CMainWindow::FillListBox</I>. 
<I>FillListBox</I> is called by <I>OnCreate</I> to initialize the list box when the program is 
started. It is also called by 
<I>OnCheckBoxClicked</I> to reinitialize the list box when the 
Show TrueType Fonts Only check box is clicked. 
<I>FillListBox</I> first clears the list box by 
calling <I>CListBox::ResetContent</I>. It then enumerates all the fonts installed in the 
system and adds the corresponding typeface names to the list box.</P>

<P><I>FillListBox </I>begins the enumeration process by constructing a device 
context object named <I>dc</I>, using the 
<I>CDC</I> class's HDC operator to extract a device context 
handle, and passing that handle to the 
<I>::EnumFontFamilies</I> function:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CClientDC dc (this);
::EnumFontFamilies ((HDC) dc, NULL, (FONTENUMPROC) EnumFontFamProc,
    (LPARAM) this);
	</pre>
</td></tr></table>

<P>The NULL second parameter tells 
<I>::EnumFontFamilies</I> to enumerate all installed 
fonts. The next parameter is the address of a callback 
function<I>.</I> A <I>callback function</I> is a function in your application that Windows 
<I>calls back</I> with information you requested. For each font that 
<I>::EnumFontFamilies</I> enumerates, Windows calls your callback 
function one time. An <I>::EnumFontFamilies</I> callback function must be prototyped like this:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
int CALLBACK EnumFontFamProc (ENUMLOGFONT* lpelf,
    NEWTEXTMETRIC* lpntm, int nFontType, LPARAM lParam)
</pre>
</td></tr></table>

<P><I>lpelf</I> is a pointer to an ENUMLOGFONT structure, which contains a wealth of 
information about the font, including its typeface name. 
<I>lpntm</I> is a pointer to a structure of type NEWTEXTMETRIC, which contains font metrics&#8212;height, average 
character width, and so on. <I>nFontType</I> specifies the font type. TrueType fonts are identified 
by logically ANDing <I>nFontType</I> with the value TRUETYPE_FONTTYPE. If the result 
is nonzero, the font is a TrueType font. The fourth and final parameter, 
<I>lParam</I>, is an optional 32-bit LPARAM value passed to 
<I>::EnumFontFamilies</I>. <I>FillListBox</I> passes 
the <I>this</I> pointer referring to 
<I>CMainWindow</I>, for reasons I'll explain in a moment.</P>

<P>FontView's callback function is a member of 
<I>CMainWindow</I>. It's actually the callback function, not 
<I>FillListBox</I>, that adds the typeface names to the list box. 
Each time <I>CMainWindow::EnumFontFamProc</I> is called, it casts the 
<I>lParam</I> value passed to it from 
<I>FillListBox</I> into a <I>CMainWindow</I> pointer:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
CMainWindow* pWnd = (CMainWindow*) lParam;
</pre>
</td></tr></table>

<P>It then uses the pointer to add the typeface name to the list box, but only if the 
Show TrueType Fonts Only check box is unchecked or the font is a TrueType font:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
if ((pWnd-&gt;m_wndCheckBox.GetCheck () == BST_UNCHECKED) &#166;&#166;
    (nFontType &amp; TRUETYPE_FONTTYPE))
    pWnd-&gt;m_wndListBox.AddString (lpelf-&gt;elfLogFont.lfFaceName);
return 1;
</pre>
</td></tr></table>

<P>The nonzero return value tells Windows to continue the enumeration process. 
(The callback function can halt the process at any time by returning 0, a handy option 
to have if you've allocated a fixed amount of memory to store font information and 
the memory fills up.) After Windows has called 
<I>EnumFontFamProc</I> for the last time, the call that 
<I>FillListBox</I> placed to 
<I>::EnumFontFamilies</I> returns and the enumeration 
process is complete.</P>

<P>Why does <I>FillListBox</I> pass a <I>this</I> pointer to the callback function, and why 
does <I>EnumFontFamProc</I> cast the pointer to a 
<I>CMainWindow</I> pointer when it, too, is a member of 
<I>CMainWindow</I>? Look closely at the declaration for 
<I>CMainWindow</I> in FontView.h, and you'll see that 
<I>EnumFontFamProc</I> is a static member function.A static class member function doesn't receive a 
<I>this</I> pointer, so it can't access nonstatic members of its own class. To call 
<I>m_wndCheckBox</I>'s<I> GetCheck</I> function and 
<I>m_wndListBox</I>'s<I> AddString</I>, 
<I>EnumFontFamProc</I> needs pointers to 
<I>m_wndCheckBox</I> and <I>m_wndListBox</I> or a pointer to the 
<I>CMainWindow</I> object to which those objects 
belong. By casting the <I>lParam</I> value passed to 
<I>FillListBox</I> to a <I>CMainWindow</I> 
pointer, <I>EnumFontFamProc</I> is able to access nonstatic members of the 
<I>CMainWindow</I> class just as if it were a nonstatic member function.</P>

<P><I>EnumFontFamProc</I> is static because callbacks require special handling in 
C++ applications. Windows rigidly defines a callback function's interface&#8212;the 
parameters passed to it through its argument list. When a member function of a C++ class 
is declared, the compiler silently tacks on an extra argument to hold the 
<I>this</I> pointer. Unfortunately, the added parameter means that the callback function's argument 
list doesn't match the argument list Windows expects, and all sorts of bad things 
can happen as a result, including invalid memory access errors, the nemeses of all 
Windows programmers. There are several solutions to this problem, but declaring the 
callback to be a static member function is among the simplest and most direct. In C++, a 
static member function isn't passed a <I>this</I> pointer, so its argument list is unaltered.</P>

<P>Callback functions are common in Windows, so the technique 
demonstrated here is useful for more than just enumerating fonts. Many Windows API 
functions that rely on callbacks support an application-defined 
<I>lParam</I> value, which is perfect for passing 
<I>this</I> pointers to statically declared callback functions. Should you use 
an enumeration function that doesn't support an application-defined 
<I>lParam</I>, you'll have to resort to other means to make a pointer available. One alternative is to make 
the <I>this</I> pointer visible to the callback function by copying it to a global variable.</P>

<A NAME="190"><H2>The <I>CEdit</I> Class</H2></A>
<P>MFC's <I>CEdit</I> class encapsulates the functionality of edit controls. Edit controls are 
used for text entry and editing and come in two varieties: single-line and multiline. 
Single-line edit controls are perfect for soliciting one-line text strings such as names, 
passwords, and product IDs. (See Figure 7-5.) To see a multiline edit control in 
action, start the Notepad applet that comes with Windows. The client area of the 
Notepad window is a multiline edit control.</P>

<P>
<img src="images/F07mg05.GIF" width=390 height=144 border="0">
</p><p>
<!-- CAPTION --><B>Figure 7-5.</B> <I>A dialog box with two single-line edit controls.</I><!-- /CAPTION -->
</p>

<P>An edit control is limited to about 60 KB of text. That's not much of a 
restriction for single-line edit controls, but for a multiline edit control it can be constraining. If 
you need to handle large amounts of text, use the 
<I>rich edit control</I> instead&#8212;an enhanced version of the standard edit control that is part of the common controls library. 
Though designed to handle richly formatted text of the type seen in word processors, rich 
edit controls are quite capable of handling ordinary text, too. The 
Windows WordPad applet uses a rich edit control for text entry and editing. You'll use a rich edit control to build 
a WordPad-like application of your own in <a href="ch12a.htm">Chapter 12</a>.</P>

<A NAME="191"><H3>Creating an Edit Control</H3></A>

<P>If <I>m_wndEdit</I> is a <I>CEdit</I> object, the statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.Create (WS_CHILD &#166; WS_VISIBLE &#166; WS_BORDER &#166;
    ES_AUTOHSCROLL, rect, this, IDC_EDIT);
</pre>
</td></tr></table>

<P>creates a single-line edit control that automatically scrolls horizontally when the 
caret moves beyond the control's border. Including ES_MULTILINE in the window 
style creates a multiline edit control instead:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.Create (WS_CHILD &#166; WS_VISIBLE &#166; WS_BORDER &#166;
    WS_HSCROLL &#166; WS_VSCROLL &#166; ES_MULTILINE, rect, this, IDC_EDIT);
</pre>
</td></tr></table>

<P>WS_HSCROLL and WS_VSCROLL add horizontal and vertical scroll bars to the 
control. You can use <I>CEdit::SetRect</I> or 
<I>CEdit::SetRectNP</I> to define the control's 
editable area independent of the control's borders. One use for these functions is to define 
a page size that remains constant even if the control is resized. You can also 
use <I>CEdit::SetMargins</I> to specify left and right margin widths in pixels. The default 
margin widths are 0. The window styles listed in the table below are 
specific to edit controls.</P>

<P>When it is first created, an edit control will accept only about 30,000 
characters. You can raise or lower the limit with 
<I>CEdit::LimitText</I> or the Win32-specific 
<I>CEdit::SetLimitText</I>. The following statement sets the maximum number of characters that 
an edit control will accept to 32:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.SetLimitText (32);
</pre>
</td></tr></table>

<P>When used with a multiline edit control, 
<I>SetLimitText</I> limits the total amount of 
text entered into the control, not the length of each line. There is no built-in way to 
limit the number of characters per line in a multiline edit control, but there are ways 
you can do it manually. One approach is to use 
<I>SetFont</I> to switch the edit control font to a fixed-pitch font and 
<I>CEdit::SetRect</I> to specify a formatting rectangle whose width 
is slightly greater than the width of a character times the desired number of 
characters per line.</P>

<P><B>Edit Control Styles</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Style</I></th>
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top">ES_LEFT</td>     
<td valign="top">Left-aligns text in the control.</td>
</tr>
<tr>
<td valign="top">ES_CENTER</td>     
<td valign="top">Centers text in the control.</td>
</tr>
<tr>
<td valign="top">ES_RIGHT</td>    
<td valign="top">Right-aligns text in the control.</td>
</tr>
<tr>
<td valign="top">ES_AUTOHSCROLL</td>
<td valign="top">Permits the edit control to scroll horizontally without a 
horizontal scroll bar. To add a horizontal scroll bar, include the 
style WS_HSCROLL.</td>
</tr>
<tr>
<td valign="top">ES_AUTOVSCROLL</td>
<td valign="top">Permits the edit control to scroll vertically without a vertical scroll bar. To add a vertical scroll bar, include the style WS_VSCROLL.</td>
</tr>
<tr>
<td valign="top">ES_MULTILINE</td>
<td valign="top">Creates a multiline edit control.</td>
</tr>
<tr>
<td valign="top">ES_LOWERCASE</td>
<td valign="top">Displays all characters in lowercase.</td>
</tr>
<tr>
<td valign="top">ES_UPPERCASE</td>
<td valign="top">Displays all characters in uppercase.</td>
</tr>
<tr>
<td valign="top">ES_PASSWORD</td>
<td valign="top">Displays asterisks instead of typed characters.</td>
</tr>
<tr>
<td valign="top">ES_READONLY</td>
<td valign="top">Creates an edit control whose text can't be edited.</td>
</tr>
<tr>
<td valign="top">ES_NOHIDESEL</td>
<td valign="top">Prevents the edit control from hiding the selection when 
the control loses the input focus.</td>
</tr>
<tr>
<td valign="top">ES_OEMCONVERT</td>
<td valign="top">Performs an ANSI-to-OEM-to-ANSI conversion on all 
characters typed into the control so that the application won't get 
unexpected results if it performs an ANSI-to-OEM conversion of 
its own. Obsolete.</td>
</tr>
<tr>
<td valign="top">ES_WANTRETURN</td>
<td valign="top">Programs the Enter key to insert line breaks instead of 
invoking the default push button for multiline edit controls used 
in dialog boxes.</td>
</tr></table></p>

<P>Another function sometimes used to initialize an edit control is 
<I>CEdit::SetTabStops</I>, which sets the spacing between tab stops. Default tab stops are set about 8 
character widths apart. You can space the tab stops however you like and can even vary 
the spacing between stops. Like 
<I>CListBox::SetTabStops</I>, 
<I>CEdit::SetTabStops</I> measures distances in dialog units.</P>

<A NAME="192"><H3>Inserting and Retrieving Text</H3></A>

<P>Text is inserted into an edit control with 
<I>SetWindowText</I> and retrieved with 
<I>GetWindowText</I>. <I>CEdit</I> inherits both functions from its base class, 
<I>CWnd</I>. The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.SetWindowText (_T (&quot;Hello, MFC&quot;));
</pre>
</td></tr></table>

<P>inserts the text string &quot;Hello, MFC&quot; into the edit control 
<I>m_wndEdit</I>, and</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.GetWindowText (string);
</pre>
</td></tr></table>

<P>retrieves the text into a <I>CString</I> object named 
<I>string</I>. <I>GetWindowText</I> and 
<I>SetWindowText</I> work with both single-line and multiline edit controls. Text inserted 
with <I>SetWindowText</I> replaces existing text, and 
<I>GetWindowText</I> returns all the text in the edit control, even if the text spans multiple lines. To erase all the text in an edit 
control, call <I>SetWindowText</I> with a null string:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.SetWindowText (_T (&quot;&quot;));
</pre>
</td></tr></table>

<P>You can insert text into an edit control without erasing what's already there 
with <I>CEdit::ReplaceSel</I>. If one or more characters are selected when 
<I>ReplaceSel</I> is called, the inserted text replaces the selected text; otherwise, the new text is inserted at 
the current caret position.</P>

<P>A multiline edit control inserts line breaks automatically. If you'd like to 
know where the line breaks fall in text retrieved from a multiline edit control, use 
<I>CEdit::FmtLines</I> to enable soft line breaks before calling 
<I>GetWindowText</I>:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.FmtLines (TRUE);
</pre>
</td></tr></table>

<P>With soft line breaks enabled, each line is delimited with two carriage returns 
(13) followed by a line feed character (10). To disable soft line breaks, call 
<I>FmtLines</I> with a FALSE parameter:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.FmtLines (FALSE);
</pre>
</td></tr></table>

<P>Now line breaks won't be denoted in any special way. Hard returns&#8212;line 
breaks inserted manually when the user presses the Enter key&#8212;are signified by single 
carriage return/line feed pairs regardless of the 
<I>FmtLines</I> setting. <I>FmtLines</I> doesn't 
affect the appearance of the text in a multiline edit control. It affects only the way 
in which the control stores text internally and the format of text retrieved with 
<I>GetWindowText</I>.</P>

<P>To read just one line of text from a multiline edit control, use 
<I>CEdit::GetLine</I>. <I>GetLine</I> copies the contents of a line to a buffer whose address you provide. The 
line is identified with a 0-based index. The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.GetLine (0, pBuffer, nBufferSize);
</pre>
</td></tr></table>

<P>copies the first line of text in a multiline edit control to the buffer pointed to by 
<I>pBuffer</I>. The third parameter is the buffer size, in bytes (not characters). 
<I>GetLine</I> returns the number of bytes copied to the buffer. You can determine how much buffer 
space you need before retrieving a line with 
<I>CEdit::LineLength</I>. And you can find out how many lines of text a multiline edit control contains by calling 
<I>CEdit::GetLineCount</I>. Note that 
<I>GetLineCount</I> never returns 0; the return value is 1 even if no text has 
been entered.</P>

<A NAME="193"><H3>Clear, Cut, Copy, Paste, and Undo</H3></A>

<P><I>CEdit</I> provides easy-to-use member functions that perform the programmatic 
equivalents of the Clear, Cut, Copy, Paste, and Undo items in the Edit menu. The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.Clear ();
</pre>
</td></tr></table>

<P>removes the selected text without affecting what's on the clipboard. The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.Cut ();
</pre>
</td></tr></table>

<P>removes the selected text and copies it to the clipboard. And the statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.Copy ();
</pre>
</td></tr></table>

<P>copies the selected text to the clipboard without altering the contents of the edit control.</P>

<P>You can query an edit control for the current selection by calling 
<I>CEdit::GetSel</I>, which returns a DWORD value with two packed 16-bit integers specifying the 
indexes of the beginning and ending characters in the selection. An alternate form of 
<I>GetSel</I> copies the indexes to a pair of integers whose addresses are passed by reference. 
If the indexes are equal, no text is currently selected. The following 
<I>IsTextSelected</I> function, which you might add to an edit control class derived from 
<I>CEdit</I>, returns a nonzero value if a selection exists and 0 if one doesn't exist:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL CMyEdit::IsTextSelected ()
{
    int nStart, nEnd;
    GetSel (nStart, nEnd);
    return (nStart != nEnd);
}
</pre>
</td></tr></table>

<P><I>CEdit::Cut</I> and <I>CEdit::Copy</I> do nothing if no text is selected.</P>

<P>Text can be selected programmatically with 
<I>CEdit::SetSel</I>. The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.SetSel (100, 150);
</pre>
</td></tr></table>

<P>selects 50 characters beginning with the 101st (the character whose 0-based index 
is 100) and scrolls the selection into view if it isn't visible already. To prevent 
scrolling, include a third parameter and set it equal to TRUE.</P>

<P>When programmatically selecting text in a multiline edit control, you often 
need to convert a line number and possibly an offset within that line into an index that 
can be passed to <I>SetSel</I>. 
<I>CEdit::LineIndex</I> accepts a 0-based line number and returns 
the index of the first character in that line. The next example uses 
<I>LineIndex</I> to determine the index of the first character in the eighth line of a multiline edit 
control, <I>LineLength</I> to retrieve the line's length, and 
<I>SetSel</I> to select everything on that line:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
int nStart = m_wndEdit.LineIndex (7);
int nLength = m_wndEdit.LineLength (nStart);
m_wndEdit.SetSel (nStart, nStart + nLength);
</pre>
</td></tr></table>

<P><I>CEdit</I> also provides a function named 
<I>LineFromChar</I> for computing a line number from a character index.</P>

<P><I>CEdit::Paste</I> pastes text into an edit control. The following statement pastes 
the text that currently resides in the Windows clipboard into an edit control 
named <I>m_wndEdit</I>:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.Paste ();
</pre>
</td></tr></table>

<P>If the clipboard contains no text, 
<I>CEdit::Paste</I> does nothing. If no text is selected 
when <I>Paste</I> is called, the clipboard text is inserted at the current caret position. If a 
selection exists, the text retrieved from the clipboard replaces the text selected in the 
control. You can determine ahead of time whether the clipboard contains text 
(and therefore whether the <I>Paste</I> function will actually do anything) by calling 
<I>::IsClipboardFormatAvailable</I>. The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL bCanPaste = ::IsClipboardFormatAvailable (CF_TEXT);
</pre>
</td></tr></table>

<P>sets <I>bCanPaste</I> to nonzero if text is available from the clipboard, and 0 if it isn't.</P>

<P>Edit controls also feature a built-in undo capability that &quot;rolls back&quot; the 
previous editing operation. The statement</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndEdit.Undo ();
</pre>
</td></tr></table>

<P>undoes the last operation, provided that the operation can be undone. You can 
determine ahead of time whether calling 
<I>Undo</I> will accomplish anything with 
<I>CEdit::CanUndo</I>. A related function, 
<I>CEdit::EmptyUndoBuffer</I>, manually resets the undo flag 
so that subsequent calls to <I>Undo</I> will do nothing (and calls to 
<I>CanUndo</I> will return FALSE) until another editing operation is performed.</P>

<A NAME="194"><H3>Edit Control Notifications</H3></A>

<P>Edit controls send notifications to their parents to report various input events. In 
MFC applications, these notifications are mapped to handling functions with ON_EN 
message map macros. Edit control notifications and the corresponding message 
map macros are summarized in the table below.</P>

<P>A common use for EN_CHANGE notifications is to dynamically update 
other controls as text is entered into an edit control. The following code updates a 
push button (<I>m_wndPushButton</I>) as text is entered into an edit control 
(<I>m_wndEdit</I>, ID=IDC_EDIT) so that the push button is enabled if the edit control contains at 
least one character and disabled if it doesn't:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
// In CMainWindow's message map
ON_EN_CHANGE (IDC_EDIT, OnUpdatePushButton)
     <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
void CMainWindow::OnUpdatePushButton ()
{
    m_wndPushButton.EnableWindow (m_wndEdit.LineLength ());
}
</pre>
</td></tr></table>

<P><B>Edit Control Notifications</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Notification</I></th>     
<th valign="top"><I>Sent When</I></th>     
<th valign="top"><I>Message-Map Macro</I></th>
</tr>
<tr>
<td valign="top">EN_UPDATE</td>     
<td valign="top">The control's text is about to change.</td>    
<td valign="top">ON_EN_UPDATE</td>
</tr>
<tr>
<td valign="top">EN_CHANGE</td>     
<td valign="top">The control's text has changed.</td>     
<td valign="top">ON_EN_CHANGE</td>
</tr>
<tr>
<td valign="top">EN_KILLFOCUS</td>     
<td valign="top">The edit control loses  the input focus.</td>     
<td valign="top">ON_EN_KILLFOCUS</td>
</tr>
<tr>
<td valign="top">EN_SETFOCUS</td>     
<td valign="top">The edit control receives the input focus.</td>     
<td valign="top">ON_EN_SETFOCUS</td>
</tr>
<tr>
<td valign="top">EN_HSCROLL</td>     
<td valign="top">The edit control is scrolled horizontally using a scroll bar.</td>     
<td valign="top">ON_EN_HSCROLL</td>
</tr>
<tr>    
<td valign="top">EN_VSCROLL</td>     
<td valign="top">The edit control is scrolled  vertically using a scroll bar.</td>     
<td valign="top">ON_EN_VSCROLL</td>
</tr>
<tr>
<td valign="top">EN_MAXTEXT</td>     
<td valign="top">A character can't be entered because the edit control already  contains the number of characters specified with <I>CEdit::LimitText</I> or <I>CEdit::SetLimitText</I>. This notification is also sent if a character can't be entered because the caret is at the right or the bottom edge of the control's formatting rectangle and the control doesn't support scrolling.</td>
<td valign="top">ON_EN_MAXTEXT</td>
</tr>
<tr>
<td valign="top">EN_ERRSPACE</td>     
<td valign="top">An operation fails because of insufficient memory.</td>      
<td valign="top">ON_EN_ERRSPACE</td>
</tr></table></p>

<P>Providing interactive feedback of this nature is generally considered good user 
interface design. Most users would rather see a button remain disabled until all of 
the required information is entered than click a button and receive an error message.</P>

<A NAME="195"><H2>Presto! Instant Notepad</H2></A>

<P>The MyPad application, portions of whose source code are reproduced in Figure 
7-6, uses a multiline edit control to create a near clone of the Windows Notepad 
applet. As you can see from the source code, the edit control does the bulk of the work. 
<I>CEdit</I> functions such as <I>Undo</I> and 
<I>Cut</I> allow you to implement commands in the Edit 
menu with just one line of code.</P>

<P>MyPad is a view-based application that I began by running the MFC 
AppWizard but unchecking the Document/View Architecture Support box in Step 1. To 
avoid unnecessary code, I unchecked the ActiveX Controls box in AppWizard's Step 
3 dialog, too. After running AppWizard, I added a New command to the File menu 
and a Delete command to the Edit menu using the Visual C++ resource editor. I also 
used the resource editor to add an accelerator (Ctrl-N) for the New command. I then 
used ClassWizard to add command handlers, update handlers, and message handlers.</P>

<P>The view's WM_CREATE message handler creates the edit control by 
calling <I>Create</I> on the <I>CEdit</I> data member named 
<I>m_wndEdit</I>. <I>OnCreate</I> sets the control's 
width and height to 0, but <I>OnSize</I> resizes the control to fill the view's client area 
whenever the view receives a WM_SIZE message. The first WM_SIZE message arrives 
before the view becomes visible on the screen; subsequent WM_SIZE messages arrive 
anytime the MyPad window (and consequently, the view) is resized. A one-line 
WM_SETFOCUS handler in the view class shifts the input focus to the edit control 
whenever the view receives the input focus.</P>

<p><B>Figure 7-6.</B> <I>The MyPad application.</I></p>

<table cellpadding=5 width="95%"><tr><td>
<A NAME="196"><H3>MainFrm.h</H3></A>
<pre>
// MainFrm.h : interface of the CMainFrame class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__0FA1D288_8471_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_MAINFRM_H__0FA1D288_8471_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

#include &quot;ChildView.h&quot;

class CMainFrame : public CFrameWnd
{
    
public:
    CMainFrame();
protected: 
    DECLARE_DYNAMIC(CMainFrame)

// Attributes
public:

// Operations
public:
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, 
        AFX_CMDHANDLERINFO* pHandlerInfo);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext&amp; dc) const;
#endif
    CChildView    m_wndView;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg void OnSetFocus(CWnd *pOldWnd);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(AFX_MAINFRM_H__0FA1D288_8471_11D2_8E53_006008A82731__INCLUDED_)
</pre>
</td></tr></table>

<table cellpadding=5 width="95%"><tr><td>
<h3>MainFrm.cpp</h3>
<pre>
// MainFrm.cpp : implementation of the CMainFrame class
//

#include &quot;stdafx.h&quot;
#include &quot;MyPad.h&quot;

#include &quot;MainFrm.h&quot;
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNAMIC(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_SETFOCUS()
    ON_WM_CREATE()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

///////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
}

CMainFrame::~CMainFrame()
{
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT&amp; cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    cs.dwExStyle &amp;= ~WS_EX_CLIENTEDGE;
    cs.lpszClass = AfxRegisterWndClass(0);
    return TRUE;
}

///////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}
void CMainFrame::Dump(CDumpContext&amp; dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

///////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
void CMainFrame::OnSetFocus(CWnd* pOldWnd)
{
    // forward focus to the view window
    m_wndView.SetFocus();
}

BOOL CMainFrame::OnCmdMsg(UINT nID, int nCode, void* pExtra, 
    AFX_CMDHANDLERINFO* pHandlerInfo)

{

    // let the view have first crack at the command
    if (m_wndView.OnCmdMsg(nID, nCode, pExtra, pHandlerInfo))
        return TRUE;

    // otherwise, do default handling
    return CFrameWnd::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo);
}


int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    if (!m_wndView.Create(NULL, NULL, AFX_WS_DEFAULT_VIEW,
        CRect(0, 0, 0, 0), this, AFX_IDW_PANE_FIRST, NULL))
    {
        TRACE0(&quot;Failed to create view window\n&quot;);
        return -1;
    }
    return 0;
}
</pre>
</td></tr></table>

<table cellpadding=5 width="95%"><tr><td>
<A NAME="197"><H3>ChildView.h</H3></A>
<pre>
// ChildView.h : interface of the CChildView class
//
///////////////////////////////////////////////////////////////////////////

#if !defined(AFX_CHILDVIEW_H__0FA1D28A_8471_11D2_8E53_006008A82731__INCLUDED_)
#define AFX_CHILDVIEW_H__0FA1D28A_8471_11D2_8E53_006008A82731__INCLUDED_

#if _MSC_VER &gt; 1000
#pragma once
#endif // _MSC_VER &gt; 1000

///////////////////////////////////////////////////////////////////////////
// CChildView window

class CChildView : public CWnd
{
// Construction
public:
    CChildView();

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CChildView)
    protected:
    virtual BOOL PreCreateWindow(CREATESTRUCT&amp; cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CChildView();

    // Generated message map functions
protected:
    BOOL IsTextSelected ();
    CEdit m_wndEdit;
    //{{AFX_MSG(CChildView)
    afx_msg void OnPaint();
    afx_msg void OnEditCut();
    afx_msg void OnEditCopy();
    afx_msg void OnEditPaste();
    afx_msg void OnEditDelete();
    afx_msg void OnEditUndo();
    afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditDelete(CCmdUI* pCmdUI);
    afx_msg void OnUpdateEditUndo(CCmdUI* pCmdUI);
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnFileNew();
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

///////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations 
// immediately before the previous line.

#endif 
// !defined(AFX_CHILDVIEW_H__0FA1D28A_8471_11D2_8E53_006008A82731__INCLUDED_)
</pre>
</td></tr></table>

<table cellpadding=5 width="95%"><tr><td>
<h3>ChildView.cpp</h3>
<pre>
// ChildView.cpp : implementation of the CChildView class
//

#include &quot;stdafx.h&quot;
#include &quot;MyPad.h&quot;
#include &quot;ChildView.h&quot;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

///////////////////////////////////////////////////////////////////////////
// CChildView

CChildView::CChildView()
{
}

CChildView::~CChildView()
{
}

BEGIN_MESSAGE_MAP(CChildView,CWnd )
    //{{AFX_MSG_MAP(CChildView)
    ON_WM_PAINT()
    ON_WM_CREATE()
    ON_WM_SIZE()
    ON_WM_SETFOCUS()
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_COMMAND(ID_EDIT_DELETE, OnEditDelete)
    ON_COMMAND(ID_EDIT_UNDO, OnEditUndo)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
    ON_UPDATE_COMMAND_UI(ID_EDIT_DELETE, OnUpdateEditDelete)
    ON_UPDATE_COMMAND_UI(ID_EDIT_UNDO, OnUpdateEditUndo)
    ON_COMMAND(ID_FILE_NEW, OnFileNew)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


///////////////////////////////////////////////////////////////////////////
// CChildView message handlers

BOOL CChildView::PreCreateWindow(CREATESTRUCT&amp; cs) 
{
    if (!CWnd::PreCreateWindow(cs))
        return FALSE;

    cs.dwExStyle &#166;= WS_EX_CLIENTEDGE;
    cs.style &amp;= ~WS_BORDER;
    cs.lpszClass = AfxRegisterWndClass(CS_HREDRAW&#166;CS_VREDRAW&#166;CS_DBLCLKS, 
        ::LoadCursor(NULL, IDC_ARROW), HBRUSH(COLOR_WINDOW+1), NULL);

    return TRUE;
}
void CChildView::OnPaint() 
{
    CPaintDC dc(this);
}

int CChildView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CWnd ::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    m_wndEdit.Create (WS_CHILD &#166; WS_VISIBLE &#166; WS_VSCROLL &#166; ES_MULTILINE &#166;
        ES_AUTOVSCROLL, CRect (0, 0, 0, 0), this, IDC_EDIT);
    return 0;
}

void CChildView::OnSize(UINT nType, int cx, int cy) 
{
    CWnd ::OnSize(nType, cx, cy);
    m_wndEdit.MoveWindow (0, 0, cx, cy);
}

void CChildView::OnSetFocus(CWnd* pOldWnd) 
{
    m_wndEdit.SetFocus ();    
}

void CChildView::OnEditCut() 
{
    m_wndEdit.Cut ();
 }

void CChildView::OnEditCopy() 
{
    m_wndEdit.Copy ();
}

void CChildView::OnEditPaste() 
{
    m_wndEdit.Paste ();
}

void CChildView::OnEditDelete() 
{
    m_wndEdit.Clear ();
}

void CChildView::OnEditUndo() 
{
    m_wndEdit.Undo ();
}

void CChildView::OnUpdateEditCut(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable (IsTextSelected ());
}

void CChildView::OnUpdateEditCopy(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable (IsTextSelected ());
}

void CChildView::OnUpdateEditPaste(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable (::IsClipboardFormatAvailable (CF_TEXT));
}

void CChildView::OnUpdateEditDelete(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable (IsTextSelected ());
}

void CChildView::OnUpdateEditUndo(CCmdUI* pCmdUI) 
{
    pCmdUI-&gt;Enable (m_wndEdit.CanUndo ());
}

void CChildView::OnFileNew() 
{
    m_wndEdit.SetWindowText (_T (&quot;&quot;));
}

BOOL CChildView::IsTextSelected()
{
    int nStart, nEnd;
    m_wndEdit.GetSel (nStart, nEnd);
    return (nStart != nEnd);
}
</pre>
</td></tr></table>

<A NAME="198"><H2>The <I> CComboBox</I> Class</H2></A>
<P>The combo box combines a single-line edit control and a list box into one 
convenient package. Combo boxes come in three varieties: simple, drop-down, and 
drop-down list. Figure 7-7 shows a drop-down list combo box with its list displayed.</P>

<P>
<img src="images/F07mg07.GIF" width=230 height=193 border="0">
</p><p>
<!-- CAPTION --><B>Figure 7-7.</B> <I>A combo box with a drop-down list displayed.</I><!-- /CAPTION -->
</p>

<P>Simple combo boxes are the least used of the three combo box types. A 
simple combo box's list box is permanently displayed. When the user selects an item 
from the list, that item is automatically copied to the edit control. The user can also 
type text directly into the edit control. If the text the user enters matches an item in the 
list box, the item is automatically highlighted and scrolled into view.</P>

<P>A drop-down combo box differs from a simple combo box in that its list box 
is displayed only on demand. A drop-down list combo box works the same way 
but doesn't allow text to be typed into the edit control. This restriction effectively 
limits the user's selection to items appearing in the list box.</P>

<P>The style flags you pass to <I>Create</I> or 
<I>CreateEx</I> determine what type of combo box you create. CBS_SIMPLE creates a simple combo box, CBS_DROPDOWN 
creates a drop-down combo box, and CBS_DROPDOWNLIST creates a drop-down list 
combo box. Other styles control additional aspects of the combo box's appearance and 
behavior, as shown in the table below. Many of these styles will look familiar 
because they're patterned after list box and edit control styles. 
CBS_AUTOHSCROLL, for example, does the same thing for the edit control portion of a combo box 
control that ES_AUTOHSCROLL does for a stand-alone edit control. When you create a 
combo box control, don't forget to include the style WS_VSCROLL if you want the list box 
to have a vertical scroll bar and WS_BORDER if you want the control's border to be 
visible. If <I>m_wndComboBox</I> is a 
<I>CComboBox</I> object, the statement</P>


<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndComboBox.Create (WS_CHILD &#166; WS_VISIBLE &#166; WS_BORDER &#166;
    WS_VSCROLL &#166; CBS_DROPDOWNLIST &#166; CBS_SORT, rect, this,
    IDC_COMBOBOX);
	</pre>
</td></tr></table>

<P>creates a drop-down list combo box whose list box contains a vertical scroll bar 
when the number of items in the list box exceeds the number of items that can be 
displayed and that automatically sorts the items added to it. The control rectangle you 
specify in the call to <I>CComboBox::Create</I> should be large enough to encompass the list 
box part of the control as well as the edit box. </P>

<P><B>Combo Box Styles</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Style</I></th>     
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top">CBS_AUTOHSCROLL</td>     
<td valign="top">Enables horizontal scrolling in the edit control 
portion of a combo box.</td> 
</tr>
<tr>
<td valign="top">CBS_DISABLENOSCROLL</td>      
<td valign="top">Disables the combo box list box's scroll bar when 
it isn't needed. Without this style, an unneeded scroll 
bar is hidden rather than disabled.</td> 
</tr>
<tr>
<td valign="top">CBS_DROPDOWN</td>      
<td valign="top">Creates a drop-down combo box.</td> 
</tr>
<tr>
<td valign="top">CBS_DROPDOWNLIST</td>      
<td valign="top">Creates a drop-down list combo box.</td> 
</tr>
<tr>
<td valign="top">CBS_HASSTRINGS</td>      
<td valign="top">Creates a combo box that &quot;remembers&quot; the 
strings added to it. Conventional combo boxes have this 
style by default; owner-draw combo boxes don't.</td> 
</tr>
<tr>
<td valign="top">CBS_LOWERCASE</td>      
<td valign="top">Forces all text in the combo box to lowercase.</td> 
</tr>
<tr>
<td valign="top">CBS_NOINTEGRALHEIGHT</td>      
<td valign="top">Prevents the combo box's list box height from 
having to be an exact multiple of the item height.</td> 
</tr>
<tr>
<td valign="top">CBS_OEMCONVERT</td>      
<td valign="top">A combo box whose edit control performs an 
ANSI-to-OEM-to-ANSI conversion on all characters so that 
the application won't get unexpected results if it 
performs an ANSI-to-OEM conversion of its own. Obsolete.</td> 
</tr>
<tr>
<td valign="top">CBS_OWNERDRAWFIXED</td>      
<td valign="top">Creates an owner-draw combo box whose items 
are all the same height.</td> 
</tr>
<tr>
<td valign="top">CBS_OWNERDRAWVARIABLE</td>      
<td valign="top">Creates an owner-draw combo box whose items 
can vary in height.</td> 
</tr>
<tr>
<td valign="top">CBS_SIMPLE</td>      
<td valign="top">Creates a simple combo box.</td> 
</tr>
<tr>
<td valign="top">CBS_SORT</td>      
<td valign="top">Automatically sorts items as they are added.</td> 
</tr>
<tr>
<td valign="top">CBS_UPPERCASE</td>      
<td valign="top">Forces all text in the combo box to uppercase.</td> 
</tr></table></p>

<P>Not surprisingly, the list of <I>CComboBox</I> member functions reads a lot like 
the list of member functions for <I>CEdit</I> and 
<I>CListBox</I>. Items are added to a combo box, 
for example, with <I>CComboBox::AddString</I> and 
<I>CComboBox::InsertString</I>, and the maximum character count for a combo box's edit control is set with 
<I>CComboBox::LimitText</I>. The 
<I>GetWindowText</I> and <I>SetWindowText</I> functions that 
<I>CComboBox</I> inherits from <I>CWnd</I> get and set the text in the edit control. Functions unique to combo boxes 
include <I>GetLBText</I>, which retrieves the text of an item identified by a 0-based 
index; <I>GetLBTextLen</I>, which returns the length of an item, in characters; 
<I>ShowDropDown</I>, which hides or displays the drop-down list box; and 
<I>GetDroppedState</I>, which returns a value indicating whether the drop-down list is currently displayed.</P>

<A NAME="199"><H3>Combo Box Notifications</H3></A>

<P>Combo boxes send notifications to their parents much as edit controls and list 
boxes do. The following table lists the notifications the parent can expect, the 
corresponding MFC message-map macros, and the types of combo boxes the notifications apply to.</P>

<P><B>Combo Box Notifications</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Notification</I></th>     
<th valign="top"><I>Message-Macro Map</I></th>
<th valign="top"><I>Simple</I></th>
<th valign="top"><I>Drop-Down</I></th>
<th valign="top"><I>Drop-Down List</I></th>
</tr>
<tr>
<td valign="top">CBN_DROPDOWN<BR>
Sent when the drop-down list is displayed.</td>  
<td valign="top">ON_CBN_DROPDOWN</td>
<td valign="top"></td>
<td valign="top">&#8730;</td>     
<td valign="top">&#8730;</td>
</tr>
<tr>
<td valign="top">CBN_CLOSEUP<BR>
Sent when the drop-down list is closed.</td>     
<td valign="top">ON_CBN_CLOSEUP</td>
<td valign="top"></td>          
<td valign="top">&#8730;</td>     
<td valign="top">&#8730;</td>
</tr>
<tr>
<td valign="top">CBN_DBLCLK<BR>
Sent when an item is double-clicked.</td>     
<td valign="top">ON_CBN_DBLCLK</td>     
<td valign="top">&#8730;</td>
<td valign="top"></td>
<td valign="top"></td>  
</tr>
<tr>  
<td valign="top">CBN_SELCHANGE<BR>
Sent when the selection changes.</td>    
<td valign="top">ON_CBN_SELCHANGE</td>    
<td valign="top">&#8730;</td>     
<td valign="top">&#8730;</td>     
<td valign="top">&#8730;</td>
</tr>
<tr>
<td valign="top">CBN_SELENDOK<BR>
Sent when a selection is made.</td>     
<td valign="top">ON_CBN_SELENDOK</td>     
<td valign="top">&#8730;</td>     
<td valign="top">&#8730;</td>     
<td valign="top">&#8730;</td>
</tr>
<tr>
<td valign="top">CBN_SELENDCANCEL<BR>
Sent when a selection is canceled.</td>     
<td valign="top">ON_CBN_SELENDCANCEL</td>
<td valign="top"></td>          
<td valign="top">&#8730;</td>     
<td valign="top">&#8730;</td>
</tr>
<tr>
<td valign="top">CBN_EDITUPDATE<BR>
Sent when the text in the edit control is about to change.</td>
<td valign="top">N_CBN_EDITUPDATE</td>
<td valign="top">&#8730;</td>
<td valign="top">&#8730;</td>
<td valign="top"></td>
</tr>
<tr>
<td valign="top">CBN_EDITCHANGE<BR>
Sent when the text in the  edit control has changed.</td>
<td valign="top">ON_CBN_EDITCHANGE</td>    
<td valign="top">&#8730;</td>     
<td valign="top">&#8730;</td>
<td valign="top"></td>
</tr>
<tr>
<td valign="top">CBN_KILLFOCUS<BR>
Sent when the combo box loses the input focus.</td>
<td valign="top">ON_CBN_KILLFOCUS</td>
<td valign="top">&#8730;</td>
<td valign="top">&#8730;</td>
<td valign="top">&#8730;</td>
</tr>
<tr>
<td valign="top">CBN_SETFOCUS<BR>
Sent when the combo box receives the input focus.</td>
<td valign="top">ON_CBN_SETFOCUS</td>
<td valign="top">&#8730;</td>
<td valign="top">&#8730;</td>
<td valign="top">&#8730;</td>
</tr>
<tr>
<td valign="top">CBN_ERRSPACE<BR>
Sent when an operation fails because of insufficient memory.</td>
<td valign="top">ON_CBN_ERRSPACE</td>
<td valign="top">&#8730;</td>
<td valign="top">&#8730;</td>
<td valign="top">&#8730;</td>
</tr></table></p>

<P>Not all notifications apply to all combo box types. CBN_DROPDOWN 
and CBN_CLOSEUP notifications, for example, aren't sent to CBS_SIMPLE combo 
boxes because a simple combo box's list box doesn't open and close. By the same 
token, CBS_DROPDOWN and CBS_DROPDOWNLIST-style combo boxes don't receive 
CBN_DBLCLK notifications because the items in their lists can't be double-clicked. 
(Why? Because the list box closes after the first click.) CBN_EDITUPDATE and 
CBN_EDITCHANGE notifications are equivalent to EN_UPDATE and EN_CHANGE 
notifications sent by edit controls, and CBN_SELCHANGE is to combo boxes as 
LBN_SELCHANGE is to list boxes.</P>

<P>One nuance you should be aware of when processing CBN_SELCHANGE 
notifications is that when a notification arrives, the edit control might not have been 
updated to match the list box selection. Therefore, you should use 
<I>GetLBText</I> to retrieve the newly selected text instead of 
<I>GetWindowText</I>. You can get the index of the selected item 
with <I>CComboBox::GetCurSel</I>.</P>

<A NAME="200"><H2>The <I>CScrollBar</I> Class</H2></A>
<P>MFC's <I>CScrollBar</I> class encapsulates scroll bar controls created from the 
&quot;SCROLLBAR&quot; WNDCLASS. Scroll bar controls are identical in most respects to the &quot;window&quot; 
scroll bars used in Chapter 2's Accel application. But whereas window scroll bars are 
created by adding WS_VSCROLL and WS_HSCROLL flags to the window style, scroll 
bar controls are created explicitly with 
<I>CScrollBar::Create</I>. And though a window 
scroll bar runs the full length of the window's client area and is inherently glued to 
the window border, scroll bar controls can be placed anywhere in the window and 
can be set to any height and width.</P>

<P>You create vertical scroll bars by specifying the style SBS_VERT and 
horizontal scroll bars by specifying SBS_HORZ. If 
<I>m_wndVScrollBar</I> and <I>m_wndHScrollBar</I> 
are <I>CScrollBar</I> objects, the statements</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
m_wndVScrollBar.Create (WS_CHILD &#166; WS_VISIBLE &#166; WS_BORDER &#166;
    SBS_VERT, rectVert, this, IDC_VSCROLLBAR);
m_wndHScrollBar.Create (WS_CHILD &#166; WS_VISIBLE &#166; WS_BORDER &#166;
    SBS_HORZ, rectHorz, this, IDC_HSCROLLBAR);
</pre>
</td></tr></table>

<P>create two scroll bar controls, one vertical and the other horizontal.</P>

<P>You can query Windows for the standard width of a vertical scroll bar or 
the standard height of a horizontal scroll bar with the 
<I>::GetSystemMetrics</I> API function. The following code fragment sets 
<I>nWidth</I> and <I>nHeight</I> to the system's standard 
scroll bar width and height:</P>

<table cellpadding=5 width="95%"><tr><td>
<pre>
int nWidth = ::GetSystemMetrics (SM_CXVSCROLL);
int nHeight = ::GetSystemMetrics (SM_CYHSCROLL);
</pre>
</td></tr></table>

<P>An alternative method for creating a scroll bar with a standard height or width is 
to specify the style SBS_TOPALIGN, SBS_BOTTOMALIGN, SBS_LEFTALIGN, or 
SBS_RIGHTALIGN when creating it. SBS_LEFTALIGN and SBS_RIGHTALIGN align a 
vertical scroll bar control along the left or right border of the rectangle specified in 
the call to <I>Create</I> and assign it a standard width. SBS_TOPALIGN and 
SBS_BOTTOMALIGN align a horizontal scroll bar control along the top or bottom border of the 
rectangle and assign it a standard height.</P>

<P>Unlike the other classic controls, scroll bar controls don't send 
WM_COMMAND messages; they send WM_VSCROLL and WM_HSCROLL messages instead. 
MFC applications process these messages with 
<I>OnVScroll</I> and <I>OnHScroll</I> handlers, as 
described in Chapter 2. I didn't mention two scroll bar notification codes in Chapter 
2 because they apply only to scroll bar controls. SB_TOP means that the user 
pressed the Home key while the scroll bar had the input focus, and SB_BOTTOM means 
the user pressed End.</P>

<P>MFC's <I>CScrollBar</I> class includes a handful of functions for manipulating scroll 
bars, most of which should seem familiar to you because they work just like the 
similarly named <I>CWnd</I> functions. 
<I>CScrollBar::GetScrollPos</I> and 
<I>CScrollBar::SetScrollPos</I> get and set the scroll bar's thumb position. 
<I>CScrollBar::GetScrollRange</I> and 
<I>CScrollBar::SetScrollRange</I> get and set the scroll bar range. You use 
<I>CScrollBar::SetScrollInfo</I> to set the range, position, and thumb size in one step. For details, refer to the discussion 
of <I>CWnd::SetScrollInfo</I> in Chapter 2.</P>

</BODY>
</HTML>




