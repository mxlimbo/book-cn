<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>The Windows GDI</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch02a.htm", "ch02c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="28"><H1>The Windows GDI</H1></A>

<p>
In a single-tasking environment such as MS-DOS, the name of the game when it comes to screen output is &quot;anything goes.&quot; A running application is free to do just 
about whatever it wants whenever it wants, whether that involves drawing a line on the screen, reprogramming the adapter's color palette, or switching to another video 
mode. In a windowed, multitasking environment such as Windows, programs can't be afforded such freedom because the output from program A must be protected from the output of program B. First and foremost, this means that each program's output must be restricted to its own window. The GDI uses a simple mechanism to make sure every program that draws in a window plays by the rules. That mechanism is the 
device context.
</P>

<p>
When a Windows program draws to a screen, a printer, or any other output device, it doesn't output pixels directly to the device. Instead, it draws to a logical &quot;display surface&quot; represented by a device context (DC). A device context is a data structure deep inside Windows that contains fields describing everything the GDI needs to know about the display surface, including the physical device with which it is associated and assorted state information. Before it draws anything on the screen, a Windows program acquires a device context handle from the GDI. It then passes that handle back to the GDI each time it calls a GDI output function. Without a valid device context handle, the GDI won't draw the first pixel. And through the device context, the GDI can make sure that everything the program draws is clipped to a particular area of the screen. Device contexts play a huge role in making the GDI device-independent because, given a handle to a device context, the same GDI functions can be used to draw to a diverse assortment of output devices.
</P>

<p>
When you program Windows with MFC, the device context has even greater significance. In addition to serving as the key that unlocks the door to output devices, a device context object encapsulates the GDI functions that programs use to 
generate output. In MFC, you don't grab a handle to a device context and call GDI output functions, at least not directly; instead, you create a device context object and call its member functions to do your drawing. MFC's 
<I>CDC</I> class wraps a Windows device context and the GDI functions that require a device context handle into one 
convenient package, and <I>CDC</I>-derived classes such as 
<I>CPaintDC</I> and <I>CClientDC</I> represent the different types of device contexts that Windows applications use.
</P>

<A NAME="29"><H2>The MFC Device Context Classes</H2></A>


<p>
One way to get a device context in an MFC application is to call <I>CWnd::GetDC</I>, which returns a pointer to a 
<I>CDC</I> object representing a Windows device context. A 
device context pointer acquired with <I>CWnd::GetDC</I> should be released with <I>CWnd::ReleaseDC</I> when drawing is completed. The following code gets a <I>CDC</I> pointer from <I>GetDC</I>, does some drawing, and calls <I>ReleaseDC</I> to release the device context:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<PRE>CDC* pDC = GetDC ();
// Do some drawing
ReleaseDC (pDC);
</PRE>
</td></tr></table></p>
<p>
If the same code were to appear in an 
<I>OnPaint</I> handler, you would use 
<I>CWnd::BeginPaint</I> and <I>CWnd::EndPaint</I> in place of 
<I>GetDC</I> and <I>ReleaseDC</I> to ensure proper handling of the WM_PAINT message:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<PRE>PAINTSTRUCT ps;
CDC* pDC = BeginPaint (&amp;ps);
// Do some drawing
EndPaint (&amp;ps);
</PRE>
</td></tr></table></p>

<p>
The GDI also supports <I>metafiles,</I> which store sequences of GDI commands that 
can be &quot;played back&quot; to produce physical output. To acquire a device context for 
a metafile's output, you would use yet another set of functions to obtain and 
release the <I>CDC</I> pointer. And to acquire a 
<I>CDC</I> pointer for a device context that permits 
drawing anywhere in the window (as opposed to one that permits drawing only in 
the window's client area), you would call 
<I>CWnd::GetWindowDC</I> rather than <I>GetDC</I> 
and release the device context with 
<I>ReleaseDC</I>.
</P>

<p>
To save you the trouble of having to remember which functions to call to acquire and release a device context (and to help ensure that a device context is properly released when the message handler that uses the device context ends), MFC provides the <I>CDC</I>-derived classes listed in the following table.
</P>

<p>
<b>Special-Purpose Device Context Classes</b></p>
<p><table cellpadding=5 width="95%"><tr>
<th valign="top">Class Name</th>
<th valign="top">Description</th>
</tr>
<tr>
<td valign="top">CPaintDC</td>
<td valign="top">For drawing in a window's client area 
(<I>OnPaint</I> handlers only)</td>
</tr>
<tr>
<td valign="top">CClientDC</td>
<td valign="top">For drawing in a window's client area (anywhere but <I>OnPaint</I>)</td>
</tr>
<tr>
<td valign="top">CWindowDC</td>
<td valign="top">For drawing anywhere in a window, including the nonclient area</td>
</tr>
<tr>
<td valign="top">CMetaFileDC</td>
<td valign="top">For drawing to a GDI metafile</td>
</tr>
</table></p>


<p>
These classes are designed to be instantiated directly. Each class's constructor and destructor call the appropriate functions to get and release the device context so that using a device context is no more complicated than this:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<PRE>CPaintDC dc (this);
// Do some drawing
</PRE>
</td></tr></table></p>

<p>
The pointer passed to the class constructor identifies the window that the device context pertains to.
</P>

<p>
When a device context object is constructed on the stack, its destructor is 
called automatically when the object goes out of scope. And when the destructor is called, 
the device context is released back to Windows. The only time you need to be 
concerned about releasing one of these device contexts yourself is when (and if) you create 
a device context object on the heap with 
<I>new</I>, as shown here:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<PRE>CPaintDC* pDC = new CPaintDC (this);
</PRE>
</td></tr></table></p>

<p>
In this case, it's important to execute a
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<PRE>delete pDC;
</PRE>
</td></tr></table></p>

<p>
statement before the function that created the device context ends so that the object's destructor will be called and the device context will be released. On some occasions, it's useful to create a device context on the heap rather than on the stack, but generally you're a lot better off creating device context objects on the stack and letting 
the compiler do the deleting for you.
</P>

<A NAME="30"><H3>The <I>CPaintDC</I> Class</H3></A>
<p>
MFC's <I>CPaintDC</I> class lets you paint in a window's client area in response 
to WM_PAINT messages. You should use it only in 
<I>OnPaint</I> handlers and never anywhere else. WM_PAINT messages are different from all other Windows messages in one 
very important respect: If the handler fails to call the Windows 
<I>::BeginPaint </I>and <I>::EndPaint</I> functions (or the MFC equivalents, 
<I>CWnd::BeginPaint</I> and <I>CWnd::EndPaint</I>), 
the message will not be removed from the message queue no matter how much 
drawing you do. Consequently, the application will get stuck processing the same 
WM_PAINT message over and over. <I>CPaintDC</I> virtually ensures that this won't happen by 
calling <I>::BeginPaint</I> and <I>::EndPaint</I> from its constructor and destructor, respectively.
</P>

<A NAME="31"><H3>The <I>CClientDC</I> and <I>CWindowDC</I> Classes</H3></A>
<p>
Windows programs don't always limit their painting to 
<I>OnPaint</I>. If you write an application that draws a circle on the screen whenever a mouse button is 
clicked, you'll probably want to paint the circle immediately&#8212;when you receive the 
button-click message&#8212;rather than wait for the next WM_PAINT message.
</P>

<p>
That's what MFC's <I>CClientDC</I> class is for. 
<I>CClientDC</I> creates a client-area device context that can be used outside 
<I>OnPaint</I>. The following message handler uses 
<I>CClientDC</I> and two <I>CDC</I> member functions to draw an X connecting the corners 
of the window's client area when the left mouse button is clicked:
</P>

<P><table cellpadding=5 width="95%"><tr><td>	
<PRE>void CMainWindow::OnLButtonDown (UINT nFlags, CPoint point)
{
    CRect rect;
    GetClientRect (&amp;rect);

    CClientDC dc (this);
    dc.MoveTo (rect.left, rect.top);
    dc.LineTo (rect.right, rect.bottom);
    dc.MoveTo (rect.right, rect.top);
    dc.LineTo (rect.left, rect.bottom);
}
</PRE>
</td></tr></table></P>

<p>
<I>left</I>, <I>right</I>, <I>top</I>, and 
<I>bottom</I> are public member variables defined in MFC's 
<I>CRect</I> class. They store the coordinates of the rectangle's four sides. 
<I>MoveTo</I> and <I>LineTo</I> are line-drawing functions that 
<I>CClientDC</I> inherits from <I>CDC</I>. You'll learn more about 
these two functions in a moment.
</P>

<p>
For the rare occasions on which you'd like to paint not only the window's client area but also the nonclient area (the title bar, the window border, and so on), MFC provides the <I>CWindowDC</I> class. 
<I>CWindowDC</I> is similar to <I>CClientDC</I>, but the 
device context it represents encompasses everything within the window's borders. Programmers sometimes use <I>CWindowDC</I> for unusual effects such as custom-drawn title bars and windows with rounded corners. In general, you won't need <I>CWindowDC</I> very often. If you do want to do your own painting in a window's nonclient area, you can trap WM_NCPAINT messages with an <I>OnNcPaint</I> handler to determine when the nonclient area needs to be painted. Unlike <I>OnPaint</I>, an <I>OnNcPaint</I> handler need not (and should not) call <I>BeginPaint</I> and <I>EndPaint</I>.
</P>

<p>
For the even rarer occasions on which a program requires access to the 
entire screen, you can create a <I>CClientDC</I> or 
<I>CWindowDC</I> object and pass its constructor a NULL pointer. The statements
</P>

<P><table cellpadding=5 width="95%"><tr><td>	
<PRE>CClientDC dc (NULL);
dc.Ellipse (0, 0, 100, 100);
</PRE>
</td></tr></table></P>
<p>
draw a circle in the upper left corner of the screen. Screen capture programs 
frequently use full-screen DCs to access the whole screen. Needless to say, drawing outside 
your own window is a very unfriendly thing to do unless you have a specific reason 
for doing so.
</P>

<A NAME="32"><H2>Device Context Attributes</H2></A>

<p>
When you draw to the screen with <I>CDC</I> output functions, certain characteristics 
of the output aren't specified in the function call but are obtained from the device 
context itself. When you call <I>CDC::DrawText</I>, for example, you specify the text 
string and the rectangle in which the string will appear, but you don't specify the text 
color or the font because both are attributes of the device context. The following table 
lists some of the most useful device context attributes and the 
<I>CDC</I> functions used to access them.
</P>

<p>
<b>Key Device Context Attributes</b>
</P>
<P>
<table cellpadding=5 width="95%">
<tr>	
<th valign="top">Attribute </th>
<th valign="top">Default</th>
<th valign="top">Set with</th>
<th valign="top">Get with</th>
</tr>
<tr>
<td valign="top">Text color</td>
<td valign="top">Black</td>
<td valign="top">CDC::SetTextColor</td>
<td valign="top">CDC::GetTextColor</td>
</tr>
<tr>
<td valign="top">Background color </td>
<td valign="top">White</td>
<td valign="top">CDC::SetBkColor</td>
<td valign="top">CDC::GetBkColor</td>
</tr>
<tr>
<td valign="top">Background mode</td>
<td valign="top">OPAQUE</td>
<td valign="top">CDC::SetBkMode</td>
<td valign="top">CDC::GetBkMode</td>
</tr>
<tr>
<td valign="top">Mapping mode</td>
<td valign="top">MM_TEXT</td>
<td valign="top">CDC::SetMapMode</td>
<td valign="top">CDC::GetMapMode</td>
</tr>
<tr>
<td valign="top">Drawing mode</td>
<td valign="top">R2_COPYPEN</td>
<td valign="top">CDC::SetROP2</td>
<td valign="top">CDC::GetROP2</td>
</tr>
<tr>
<td valign="top">Current position</td>
<td valign="top">(0,0)</td>
<td valign="top">CDC::MoveTo</td>
<td valign="top">CDC::GetCurrentPosition</td>
</tr>
<tr>
<td valign="top">Current pen </td>
<td valign="top">BLACK_PEN</td>
<td valign="top">CDC::SelectObject</td>
<td valign="top">CDC::SelectObject</td>
</tr>
<tr>
<td valign="top">Current brush</td>
<td valign="top">WHITE_BRUSH</td>
<td valign="top">CDC::SelectObject</td>
<td valign="top">CDC::SelectObject</td>
</tr>
<tr>
<td valign="top">Current font </td>
<td valign="top">SYSTEM_FONT</td>
<td valign="top">CDC::SelectObject</td>
<td valign="top">CDC::SelectObject</td>
</tr>
</table>
</P>

 



   


<p>
Different <I>CDC</I> output functions use device context attributes in different ways. For example, when you draw a line with <I>LineTo</I>, the current pen determines the line's color, width, and style (solid, dotted, dashed, and so on). Similarly, when you draw a rectangle with the <I>Rectangle</I> function, the GDI borders the rectangle with the 
current pen and fills the rectangle with the current brush. All text output functions use the current font. The text color and the background color control the colors used when text is output. The text color determines the color of the characters, and the background color determines what color is used to fill behind them. The background color is also used to fill the gaps between line segments when dotted or dashed lines are drawn with the <I>LineTo</I> function and to fill the open areas between hatch marks painted by a hatch brush. If you'd like the background color to be ignored entirely, you can set the background mode to &quot;transparent,&quot; like this:
</P>
<P><table cellpadding=5 width="95%"><tr><td>	
<PRE>dc.SetBkMode (TRANSPARENT);
</PRE>
</td></tr></table></P>

<p>
Inserting this statement before the call to 
<I>DrawText</I> in Chapter 1's Hello program eliminates the white rectangle surrounding &quot;Hello, MFC&quot; that's visible when the window background color is nonwhite.
</P>

<p>
The <I>CDC</I> function you'll use more than any other to modify the attributes of 
a device context is <I>SelectObject</I>. The following six items are GDI objects that can 
be selected into a device context with 
<I>SelectObject</I>:
</P>

<UL>
<P><LI>Pens</LI></p>

<p><LI>Brushes</LI></p>

<p><LI>Fonts</LI></p>

<p><LI> Bitmaps</LI></p>

<p><LI>Palettes</LI></p>

<p><LI>Regions</LI></p>
</UL>
<p>
In MFC, pens, brushes, and fonts are represented by the classes 
<I>CPen</I>, <I>CBrush</I>, and <I>CFont</I>. (Bitmaps, palettes, and regions are discussed in <a href="ch15a.htm">Chapter 15</a>.) Unless 
you call <I>SelectObject</I> to change the current pen, brush, or font, the GDI uses the 
device context's defaults. The default pen draws solid black lines 1 pixel wide. The 
default brush paints solid white. The default font is a rather plain proportional font with 
a height of roughly 12 points. You can create pens, brushes, and fonts of your 
own and select them into a device context to change the attributes of the output. To 
draw a solid red circle with a 10-pixel-wide black border, for example, you can create 
a black pen 10 pixels wide and a red brush and select them into the device 
context with <I>SelectObject</I> before calling 
<I>Ellipse</I>. If <I>pPen</I> is a pointer to a 
<I>CPen</I> object, <I>pBrush</I> is a pointer to a 
<I>CBrush</I> object, and <I>dc</I> represents a device context, the code 
might look like this:
</P>

<P><table cellpadding=5 width="95%"><tr><td>	<PRE>dc.SelectObject (pPen);
dc.SelectObject (pBrush);
dc.Ellipse (0, 0, 100, 100);
</PRE>
</td></tr></table></P>

<p>
<I>SelectObject</I> is overloaded to accept pointers to objects of various types. Its 
return value is a pointer to the object of the same type that was previously selected into 
the device context.
</P>

<P>
Each time you acquire a device context from Windows, its attributes are reset to the defaults. Consequently, if you want to use a red pen and a blue brush to paint your window in response to WM_PAINT messages, you must select them into 
the device context each time <I>OnPaint</I> is called and a new <I>CPaintDC</I> object is created. Otherwise, the default pen and brush will be used. If you'd like to avoid 
reinitializing a device context every time you use it, you can save its state with the <I>CDC::SaveDC</I> function and restore it the next time around with <I>CDC::RestoreDC</I>. Another option is to register a custom WNDCLASS that includes the CS_OWNDC style, which causes Windows to allocate to each instance of your application its own private device context that retains its settings. (A related but seldom used WNDCLASS style, CS_CLASSDC, allocates a &quot;semiprivate&quot; device context that is shared by all windows created from the same WNDCLASS.) If you select a red pen and a blue brush into a private device context, they remain selected until they're explicitly replaced.
</P>

<A NAME="33"><H2>The Drawing Mode</H2></A>

<p>
When the GDI outputs pixels to a logical display surface, it doesn't simply 
output pixel colors. Rather, it combines the colors of the pixels that it's outputting with 
the colors of the pixels at the destination using a combination of Boolean 
operations. The logic that's employed depends on the device context's current drawing 
mode, which you can change with 
<I>CDC::SetROP2</I> (short for &quot;Set Raster Operation To&quot;). 
The default drawing mode is R2_COPYPEN, which does, in fact, copy pixels to the 
display surface. But there are 15 other drawing modes to choose from, as shown in 
the table below. Together, these drawing modes represent all the 
possible operations that can be performed by combining the Boolean primitives AND, 
OR, XOR, and NOT.
</P>

<p>
Why would you ever need to change the drawing mode? Suppose you want 
to draw a line not by copying pixels to the display surface but by inverting the colors 
of the pixels already there. It's easy to do; you just set the drawing mode to 
R2_NOT before drawing the line:
</P>

<P><table cellpadding=5 width="95%"><tr><td>	<PRE>dc.SetROP2 (R2_NOT);
dc.MoveTo (0, 0);
dc.LineTo (100, 100);
</PRE>
</td></tr></table></P>

<p>
This little trick might be more useful than you think, because it's a great way to 
rubber-band lines and rectangles. You'll see an example of what I mean in <a href="ch03a.htm">Chapter 3</a>.
</P>

<p>
<b>GDI Drawing Modes</b></p>
<p>
<table cellpadding=5 width="95%"><tr>
<th valign="top">Drawing Mode</th>
<th valign="top">Operation(s) Performed</th>
</tr>
<tr>
<td valign="top">R2_NOP</td>
<td valign="top">dest = dest</td>
</tr>
<tr>
<td valign="top">R2_NOT</td>
<td valign="top">dest = NOT dest</td>
</tr>
<tr>
<td valign="top">R2_BLACK </td>
<td valign="top">dest = BLACK</td>
</tr>
<tr>
<td valign="top">R2_WHITE</td>
<td valign="top">dest = WHITE</td>
</tr>
<tr>
<td valign="top">R2_COPYPEN </td>
<td valign="top">dest = src</td>
</tr>
<tr>
<td valign="top">R2_NOTCOPYPEN </td>
<td valign="top">dest = NOT src</td>
</tr>
<tr>
<td valign="top">R2_MERGEPENNOT  </td>
<td valign="top">dest = (NOT dest) OR src</td>
</tr>
<tr>
<td valign="top">R2_MASKPENNOT </td>
<td valign="top"> dest = (NOT dest) AND src</td>
</tr>
<tr>
<td valign="top">R2_MERGENOTPEN</td>
<td valign="top">  dest = (NOT src) OR dest</td>
</tr>
<tr>
<td valign="top">R2_MASKNOTPEN </td>
<td valign="top">dest = (NOT src) AND dest</td>
</tr>   
<tr>
<td valign="top">R2_MERGEPEN </td>
<td valign="top">dest = dest OR src</td>
</tr>
<tr>
<td valign="top">R2_NOTMERGEPEN </td>
<td valign="top">dest = NOT (dest OR src)</td>
</tr>
<tr>
<td valign="top">R2_MASKPEN </td>
<td valign="top">dest = dest AND src</td>
</tr>
<tr>
<td valign="top">R2_NOTMASKPEN</td>
<td valign="top">dest = NOT (dest AND src)</td>
</tr>
<tr>
<td valign="top">R2_XORPEN</td>
<td valign="top">dest = src XOR dest</td>
</tr>
<tr>
<td valign="top">R2_NOTXORPEN</td>
<td valign="top">dest = NOT (src XOR dest)</td>
</tr>
<tr>
<td valign="top"></td>
<td valign="top"></td>
</tr></table>
</P>

<A NAME="34"><H2>The Mapping Mode</H2></A>

<p>
Without a doubt, the aspect of GDI programming that new Windows programmers find the most confusing is the mapping mode. Simply put, the <I>mapping mode</I> is the attribute of the device context that governs how logical coordinates are translated into device coordinates. <I>Logical coordinates</I> are the coordinates you pass to <I>CDC</I> output functions. <I>Device coordinates</I> are the corresponding pixel positions within a window. When you call the <I>Rectangle</I> function like this:
</P>

<P><table cellpadding=5 width="95%"><tr><td>	
<PRE>dc.Rectangle (0, 0, 200, 100);
</PRE>
</td></tr></table></P>

<p>
you're not necessarily telling the GDI to draw a rectangle that's 200 pixels wide and 100 pixels tall; you're telling it to draw a rectangle that's 200 units wide and 100 units tall. In the default mapping mode, MM_TEXT, it just so happens that 1 unit equals 1 pixel. But in other mapping modes, logical units are translated into device units differently. In the MM_LOENGLISH mapping mode, for example, 1 unit equals 1/100 of an inch. Therefore, drawing a rectangle that measures 200 units by 100 units in the MM_LOENGLISH mapping mode produces a 2-inch by 1-inch rectangle. Using a non-MM_TEXT mapping mode is a convenient way to scale your output so that sizes and distances are independent of the output device's physical resolution.
</P>

<p>
Windows supports eight different mapping modes. Their properties are 
summarized in the following table.
</P>

<p>
<b>GDI Mapping Modes</b>
</p>

<p><table cellpadding=5 width="95%"><tr>
<th valign="top">Mapping Mode   </th>
<th valign="top">Distance Corresponding to One Logical Unit </th>
<th valign="top">Orientation of the x and y Axes</th>
</tr>
<tr>
<td valign="top">MM_TEXT</td>
<td valign="top">1 pixel</td>
<td valign="top"><img src="images/G02mg01.JPG" width=61 height=67 border=0></td>
</tr>
<tr>
<td valign="top">MM_LOMETRIC</td>
<td valign="top">0.1 mm</td>
<td valign="top"><img src="images/G02mg02.JPG" width=61 height=67 border=0></td>
</tr>
<tr>
<td valign="top">MM_HIMETRIC   </td>
<td valign="top">0.01 mm</td>
<td valign="top"><img src="images/G02mg03.JPG" width=61 height=67 border=0></td>
</tr>
<tr>
<td valign="top">MM_LOENGLISH </td>
<td valign="top">0.01 in.</td>
<td valign="top"><img src="images/G02mg04.JPG" width=61 height=67 border=0></td>
</tr>
<tr>
<td valign="top">MM_HIENGLISH</td>
<td valign="top">0.001 in.</td>
<td valign="top"><img src="images/G02mg05.JPG" width=61 height=67 border=0></td>
</tr>
<tr>
<td valign="top">MM_TWIPS </td>
<td valign="top">1/1440 in. (0.0007 in.)</td>
<td valign="top"><img src="images/G02mg06.JPG" width=61 height=67 border=0></td>
</tr>
<tr>
<td valign="top">MM_ISOTROPIC</td>
<td valign="top">User-defined (<I>x</I> and <I>y</I> scale identically) </td>
<td valign="top">User-defined</td>
</tr>      
<tr>
<td valign="top">MM_ANISOTROPIC</td>
<td valign="top">User-defined (<I>x</I> and <I>y</I> scale independently)</td>
<td valign="top">User-defined</td>
</tr>
</table></p>

<p>
When you draw in the MM_TEXT mapping mode, you're using the 
coordinate system shown in Figure 2-1. The origin is in the upper left corner of the window, the positive <I>x</I> axis points to the right, the positive <I>y</I> axis points downward, and 1 unit equals 1 pixel. If you switch to one of the &quot;metric&quot; mapping modes&#8212;MM_LOENGLISH, MM_HIENGLISH, MM_LOMETRIC, MM_HIMETRIC, or MM_TWIPS&#8212;the <I>y</I> axis flips so that positive <I>y</I> points upward and logical units are scaled to represent real distances rather than raw pixel counts. The origin, however, remains in the upper left corner. One thing to remember when using a metric mapping mode is that you 
must use negative <I>y</I> values if you want to see your output. The statement
</P>

<P><table cellpadding=5 width="95%"><tr><td>	
<PRE>dc.Rectangle (0, 0, 200, 100);
</PRE>
</td></tr></table></P>

<p>
draws a 200-pixel by 100-pixel rectangle in the MM_TEXT mapping mode. The 
same statement produces no output in the MM_LOENGLISH mapping mode because 
positive <I>y</I> coordinates lie outside the visible part of the window. To make the 
rectangle visible, you must negate the <I>y</I> coordinates, as shown here:
</P>
<P><table cellpadding=5 width="95%"><tr><td>	
<PRE>dc.Rectangle (0, 0, 200, -100);
</PRE>
</td></tr></table></P>

<p>
If you switch to a non-MM_TEXT mapping mode and suddenly your application's output is no longer visible, check the sign of your <I>y</I> coordinates. Positive <I>y</I> coordinates will be the problem almost every time.
</p>

<p>
<A HREF="javascript:fullSize('F02mg01x.htm')"> <img src="IMAGES/F02mg01.JPG" width=404 height=177 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 2-1.</B> <I>The MM_TEXT coordinate system.</I><!-- /CAPTION -->
</p>

<p>
The default mapping mode is MM_TEXT. If you want to use one of the 
other mapping modes, you must call 
<I>CDC::SetMapMode</I> to change the mapping mode. 
The following statements switch to the MM_LOMETRIC mapping mode and draw an ellipse whose major axis is 5 centimeters long and whose minor axis measures 3 centimeters:
</P>

<P><table cellpadding=5 width="95%"><tr><td>	
<PRE>dc.SetMapMode (MM_LOMETRIC);
dc.Ellipse (0, 0, 500, -300);
</PRE>
</td></tr></table></P>

<p>
You can see that there's really nothing tricky about mapping modes. Things get 
slightly more complicated when you use the MM_ISOTROPIC and MM_ANISOTROPIC 
modes and when you do hit-testing on objects drawn in non-MM_TEXT mapping 
modes, but even that doesn't have to be difficult. The MM_ISOTROPIC and 
MM_ANISOTROPIC mapping modes are discussed in the next section.
</P>

<p>
One thing to keep in mind when you use the metric mapping modes is that 
on display screens, 1 logical inch usually doesn't equal 1 physical inch. In other 
words, if you draw a line that's 100 units long in the MM_LOENGLISH mapping mode, the 
line probably won't be exactly 1 inch long. The reason? Windows doesn't know the 
physical resolution of your monitor&#8212;the number of dots per inch (dpi) it's capable of 
displaying horizontally and vertically. (This might change in a future version of 
Windows.) The same is not true of printers and other hardcopy devices, however. The 
printer driver knows that a 600 dpi laser printer can print exactly 600 dots per inch, so a 
100-unit line drawn in the MM_LOENGLISH mapping mode will measure exactly 1 
inch on the printed page.
</P>

<A NAME="35"><H2>Programmable Mapping Modes</H2></A>

<p>
The MM_ISOTROPIC and MM_ANISOTROPIC mapping modes differ from the 
other mapping modes in one important respect: It's you, not Windows, who 
determines how logical coordinates are converted into device coordinates. For this reason, these mapping modes are sometimes called the &quot;roll-your-own&quot; or &quot;programmable&quot; mapping modes. Want a mapping mode in which 1 unit equals 1 centimeter? No problem: Just use the MM_ANISOTROPIC mapping mode and set its scaling 
parameters accordingly.
</P>

<p>
The most common use for the MM_ISOTROPIC and MM_ANISOTROPIC 
mapping modes is for drawing output that automatically scales to match the window size. The following code fragment uses the MM_ANISOTROPIC mapping mode to draw an ellipse that touches all four borders of the window in which it is drawn:
</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
CRect rect;
GetClientRect (&amp;rect);
dc.SetMapMode (MM_ANISOTROPIC);
dc.SetWindowExt (500, 500);
dc.SetViewportExt (rect.Width (), rect.Height ());
dc.Ellipse (0, 0, 500, 500);
</PRE>
</td></tr></table></P>

<p>
See how it works? No matter what physical size the window is, you've told Windows that the window's <I>logical</I> size is 500 units by 500 units. Therefore, a bounding box that stretches from (0,0) to (500,500) encompasses the entire window. Initializing a device context in this way places the origin at the upper left corner of the window and orients the axes so that positive <I>x</I> points to the right and positive <I>y</I> points downward. If you'd rather have the <I>y</I> axis point upward (as it does in the metric mapping modes), you can reverse its direction by negating the <I>y</I> value passed to either <I>SetWindowExt</I> or <I>SetViewportExt</I>:
</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>
CRect rect;
GetClientRect (&amp;rect);
dc.SetMapMode (MM_ANISOTROPIC);
dc.SetWindowExt (500, -500);
dc.SetViewportExt (rect.Width (), rect.Height ());
dc.Ellipse (0, 0, 500, -500);
</PRE>
</td></tr></table></P>

<p>
Now you must use negative <I>y</I> coordinates to draw in the window. Only 
the MM_ISOTROPIC and MM_ANISOTROPIC mapping modes allow the directions of 
the <I>x</I> and <I>y</I> axes to be reversed. That's why the table in the previous section listed 
these two mapping modes' axis orientations as user defined. 
</P>

<p>
The only difference between the MM_ISOTROPIC and 
MM_ANISOTROPIC mapping modes is that in the former, the scaling factors for the <I>x</I> and <I>y</I> directions are always the same. In other words, 100 horizontal units equals the same physical distance as 100 vertical units. Isotropic means &quot;equal in all directions.&quot; The 
MM_ISOTROPIC mapping mode is ideal for drawing circles and squares. The following code draws a circle that spans the width or height of a window, whichever is smaller:
</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>CRect rect;
GetClientRect (&amp;rect);
dc.SetMapMode (MM_ISOTROPIC);
dc.SetWindowExt (500, 500);
dc.SetViewportExt (rect.Width (), rect.Height ());
dc.Ellipse (0, 0, 500, 500);
</PRE>
</td></tr></table></P>

<p>
As far as Windows is concerned, the window's logical size is once again 500 units 
by 500 units. But now the GDI takes the output device's aspect ratio into 
consideration when converting logical units to device units. <a href="ch14a.htm">Chapter 14</a>'s Clock program uses 
the MM_ISOTROPIC mapping mode to draw a round clock face and to automatically 
scale the clock size to the window size. Without the MM_ISOTROPIC mapping mode, 
Clock would have to do all of the scaling manually.
</P>

<p>
Let's talk a bit about the <I>SetWindowExt</I> and 
<I>SetViewportExt</I> functions. Officially, 
<I>SetWindowExt</I> sets the &quot;window extents&quot; and 
<I>SetViewportExt</I> sets the &quot;viewport 
extents.&quot; Think of a window as something whose size is measured in logical units and a 
viewport as something whose size is measured in device units, or pixels. When Windows 
converts between logical coordinates and device coordinates, it uses a pair of 
formulas that factor in the window's logical dimensions (the window extents) and its 
physical dimensions (the viewport extents) as well as the location of the origin. When you 
set the window extents and viewport extents, you're effectively programming in 
your own scaling parameters. Generally, the viewport extents are simply the size (in 
pixels) of the window you're drawing in and the window extents are the window's 
desired size in logical units.
</P>

<p>
One caveat regarding the use of 
<I>SetWindowExt</I> and <I>SetViewportExt</I> is that in 
the MM_ISOTROPIC mapping mode, you should call <I>SetWindowExt</I> first. Otherwise, a portion of the window's client area might fall outside the window's logical extents and become unusable. In the MM_ANISOTROPIC mapping mode, it doesn't matter which are set first&#8212;the window extents or the viewport extents.
</P>

<A NAME="36"><H2>Coordinate Conversions</H2></A>

<p>
You can translate logical coordinates to device coordinates using the 
<I>CDC::LPtoDP</I> function. Conversely, you can translate device coordinates to logical coordinates with <I>CDC::DPtoLP</I>.
</P>

<p>
Let's say you want to know where the center of a window is in device 
coordinates. All you have to do is halve the window's pixel width and height. 
<I>CWnd::GetClientRect</I> returns a window's pixel dimensions.
</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>CRect rect;
GetClientRect (&amp;rect);
CPoint point (rect.Width () / 2, rect.Height () / 2);
</PRE>
</td></tr></table></P>

<p>
If you want to know where the center point is in MM_LOENGLISH units, 
however, you need <I>DPtoLP</I>:
</P>
<P><table cellpadding=5 width="95%"><tr><td>
<PRE>CRect rect;
GetClientRect (&amp;rect);
CPoint point (rect.Width () / 2, rect.Height () / 2);
CClientDC dc (this);
dc.SetMapMode (MM_LOENGLISH);
dc.DPtoLP (&amp;point);
</PRE>
</td></tr></table></P>

<p>
When <I>DPtoLP</I> returns, <I>point</I> holds the coordinates of the center point in logical 
(that is, MM_LOENGLISH) coordinates. If, on the other hand, you want to know the 
pixel coordinates of the point whose MM_LOENGLISH coordinates are (100,100), you 
use <I>LPtoDP</I>:
</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>CPoint point (100, 100);
CClientDC dc (this);
dc.SetMapMode (MM_LOENGLISH);
dc.LPtoDP (&amp;point);
</PRE>
</td></tr></table></P>

<p>
One situation in which <I>LPtoDP</I> and 
<I>DPtoLP</I> are indispensable is when you're performing hit-testing in response to mouse clicks. Mouse clicks are always reported in device coordinates, so if you've drawn a rectangle in MM_LOENGLISH coordinates and you want to know whether a mouse click occurred inside that rectangle, you must either convert the rectangle's coordinates to device coordinates or convert the click coordinates to logical coordinates. Otherwise, you'll be comparing apples 
and oranges.
</P>

<A NAME="37"><H2>Moving the Origin</H2></A>

<p>
By default, a device context's origin is in the upper left corner of the display surface. Even if you change the mapping mode, the origin remains in the upper left corner. But just as you can change the mapping mode, you can also move the origin. MFC's <I>CDC</I> class provides two functions for moving the origin. 
<I>CDC::SetWindowOrg</I> moves the window origin, and 
<I>CDC::SetViewportOrg</I> moves the viewport origin. You'll 
normally use one but not both. Using both can be very confusing.
</P>

<p>
Suppose you'd like to move the origin to the center of the window so that 
you can center what you draw by centering your output around the point (0,0). 
Assuming that <I>dc</I> is a device context object, here's one way to do it:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<PRE>CRect rect;
GetClientRect (&amp;rect);
dc.SetViewportOrg (rect.Width () / 2, rect.Height () / 2);
</PRE>
</td></tr></table></p>

<p>
Here's another way to accomplish the same thing, assuming that you're working 
in the MM_LOENGLISH mapping mode:
</P>

<P><table cellpadding=5 width="95%"><tr><td>
<PRE>CRect rect;
GetClientRect (&amp;rect);
CPoint point (rect.Width () / 2, rect.Height () / 2);
dc.SetMapMode (MM_LOENGLISH);
dc.DPtoLP (&amp;point);
dc.SetWindowOrg (-point.x, -point.y);
</PRE>
</td></tr></table></P>

<p>
It's easy to get <I>SetViewportOrg</I> and 
<I>SetWindowOrg</I> confused, but the distinction between them is actually quite clear. Changing the viewport origin to (<I>x</I>,<I>y</I>) with <I>SetViewportOrg</I> tells Windows to map the logical point (0,0) to the device point 
(<I>x</I>,<I>y</I>). Changing the window origin to 
(<I>x</I>,<I>y</I>) with <I>SetWindowOrg</I> does essentially the reverse, telling Windows to map the logical point (<I>x</I>,<I>y</I>) to the device point (0,0)&#8212;the upper left corner of the display surface. In the MM_TEXT mapping mode, the only real difference between the two functions is the signs of <I>x</I> and <I>y</I>. In other mapping modes, there's more to it than that because 
<I>SetViewportOrg</I> deals in device coordinates 
and <I>SetWindowOrg</I> deals in logical coordinates. You'll see examples of how both functions are used later in this chapter.
</P>

<p>
As a final example, suppose you're drawing in the MM_HIMETRIC mapping mode, where 1 unit equals 1/100 of a millimeter, positive <I>x</I> points to the right, and positive <I>y</I> points upward, and you'd like to move the origin to the lower left corner of the window. Here's an easy way to do it:
</P>

<p><table cellpadding=5 width="95%"><tr><td>
<PRE>CRect rect;
GetClientRect (&amp;rect);
dc.SetViewportOrg (0, rect.Height ());
</PRE>
</td></tr></table></P>

<p>
Now you can draw with positive <I>x</I> and 
<I>y</I> values using coordinates relative to the window's lower left corner.
</P>

<A NAME="38"><H2>A Final Word on Coordinate Systems</H2></A>

<p>
When you talk about mapping modes, window origins, viewport origins, and 
other idioms related to the GDI's handling of coordinates, it's easy to get tangled up in 
the terminology. Understanding the difference between the device coordinate system 
and the logical coordinate system might help clear some of the cobwebs.
</P>

<p>
In the device coordinate system, distances are measured in pixels. The 
device point (0,0) is always in the upper left corner of the display surface, and the positive <I>x</I> and <I>y</I> axes always point right and downward. The logical coordinate system is altogether different. The origin can be placed anywhere, and both the orientation of the <I>x</I> and <I>y</I> axes and the scaling factor (the number of pixels that correspond to 1 logical unit) vary with the mapping mode. To be precise, they vary with the window extents and the viewport extents. You can change these extents in the MM_ISOTROPIC and MM_ANISOTROPIC mapping modes but not in the other mapping modes.
</P>

<p>
You'll sometimes hear Windows programmers talk about &quot;client 
coordinates&quot; and &quot;screen coordinates.&quot; Client coordinates are simply device coordinates relative to the upper left corner of a window's client area. Screen coordinates are device coordinates relative to the upper left corner of the screen. You can convert from 
client coordinates to screen coordinates and vice versa using the 
<I>CWnd::ClientToScreen</I> and <I>CWnd::ScreenToClient</I> functions. Why these functions are useful will become apparent to you the first time you call a Windows function that returns screen coordinates and you pass them to a function that requires client coordinates, or vice versa.
</P>

<A NAME="39"><H2>Getting Information About a Device</H2></A>

<p>
Sometimes it's helpful to get information about a device before you send output to it. The <I>CDC::GetDeviceCaps</I> function lets you retrieve all kinds of information about a device, from the number of colors it supports to the number of pixels it can display horizontally and vertically. The following code initializes <I>cx</I> and <I>cy</I> to the width and height of the screen, in pixels:
</P>

<P><table cellpadding=5 width="95%"><tr><td>	
<PRE>CClientDC dc (this);
int cx = dc.GetDeviceCaps (HORZRES);
int cy = dc.GetDeviceCaps (VERTRES);
</PRE>
</td></tr></table></P>

<p>
If the screen resolution is 1,024 by 768, 
<I>cx</I> and <I>cy</I> will be set to 1,024 and 768, 
respectively.
</P>

<p>
The table below lists some of the parameters you can pass to <I>GetDeviceCaps</I> to acquire information about the physical output device associated with a device context. How you interpret the results depends somewhat on the device type. For example, calling 
<I>GetDeviceCaps</I> with a HORZRES parameter for a screen DC returns the screen width in pixels. Make the same call to a printer DC and 
you get back the width of the printable page, once more in pixels. As a rule, values that imply any kind of scaling (for example, LOGPIXELSX and LOGPIXELSY) return physically correct values for printers and other hardcopy devices but not for screens. For a 600 dpi laser printer, both LOGPIXELSX and LOGPIXELSY return 600. For a screen, both will probably return 96, regardless of the physical screen size or resolution.
</P>

<p>
Interpreting the color information returned by the NUMCOLORS, 
BITSPIXEL, and PLANES parameters of <I>GetDeviceCaps</I> is a bit tricky. For a printer or a plotter, you can usually find out how many colors the device is capable of displaying from the NUMCOLORS parameter. For a monochrome printer, NUMCOLORS returns 2.
</P>

<p>
<b>Useful <I>GetDeviceCaps</I> Parameters</b>
</p><p>
<table cellpadding=5 width="95%">
<tr>
<th valign="top">Parameter </th>
<th valign="top">Returns</th>
</tr>
<tr>
<td valign="top">HORZRES </td>
<td valign="top">Width of the display surface in pixels</td>
</tr>
<tr>
<td valign="top">VERTRES</td>
<td valign="top">Height of the display surface in pixels</td>
</tr>
<tr>
<td valign="top">HORZSIZE</td>
<td valign="top">Width of the display surface in millimeters</td>
</tr>
<tr>
<td valign="top">VERTSIZE</td>
<td valign="top">     Height of the display surface in millimeters</td>
</tr>
<tr>
<td valign="top">LOGPIXELSX </td>
<td valign="top">Number of pixels per logical inch horizontally</td>
</tr>
<tr>
<td valign="top">LOGPIXELSY </td>
<td valign="top"> Number of pixels per logical inch vertically</td>
</tr>
<tr>
<td valign="top">NUMCOLORS </td>
<td valign="top">For a display device, the number of static colors; for 
a printer or plotter, the number of colors supported</td>
</tr>
<tr>
<td valign="top">BITSPIXEL </td>
<td valign="top">Number of bits per pixel</td>
</tr>
<tr>
<td valign="top">PLANES </td>
<td valign="top">Number of bit planes</td>
</tr>
<tr>
<td valign="top">RASTERCAPS </td>
<td valign="top">Bit flags detailing certain characteristics of the 
device, such as whether it is palettized and whether it can 
display bitmapped images</td>
</tr>
<tr>
<td valign="top">TECHNOLOGY</td>
<td valign="top">Bit flags identifying the device type&#8212;screen, printer, plotter, and so on</td>
</tr></table>
</P>

<p>
However, the color resolution of the screen (the number of colors that can 
be displayed onscreen simultaneously) is computed by multiplying BITSPIXEL 
and PLANES and raising 2 to the power of the result, as demonstrated here:
</P>
<P><table cellpadding=5 width="95%"><tr><td>	
<PRE>CClientDC dc (this);
int nPlanes = dc.GetDeviceCaps (PLANES);
int nBPP = dc.GetDeviceCaps (BITSPIXEL);
int nColors = 1 &lt;&lt; (nPlanes * nBPP);
</PRE>
</td></tr></table></P>

<p>
If this code is executed on a PC equipped with a 256-color video adapter, 
<I>nColors</I> equals 256. Calling 
<I>GetDeviceCaps</I> with a NUMCOLORS parameter, meanwhile, 
returns not 256 but 20&#8212;the number of &quot;static colors&quot; that Windows programs into the 
video adapter's color palette. I'll have more to say about the color characteristics of 
screens and video adapters and also about static colors in <a href="ch15a.htm">Chapter 15</a>.
</P>

<p>
I'll use <I>GetDeviceCaps</I> several times in this book to adapt the sample programs' output to the physical attributes of the output device. The first use will come later in this chapter, when the screen's LOGPIXELSX and LOGPIXELSY parameters are used to draw rectangles 1 logical inch long and 1/4 logical inch tall in the MM_TEXT 
mapping mode.
</P>

</BODY>
</HTML>




