<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Drawing with the GDI</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch02b.htm", "ch02d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="40"><H1>Drawing with the GDI</H1></A>

<p>
Enough of the preliminaries. By now, you probably feel as if you asked for the time and got an explanation of watchmaking. Everything you've learned so far in this chapter will come in handy sooner or later&#8212;trust me. But now let's talk about functions for outputting pixels to the screen.
</P>

<p>
The functions discussed in the next several sections are by no means all of the available GDI output functions. A full treatment of every one would require a chapter much larger than this one. When you finish reading this chapter, look at the complete list of <I>CDC</I> member functions in your MFC documentation. Doing so will give you a better feel for the wide-ranging scope of the Windows GDI and let you know where to go when you need help.
</P>

<A NAME="41"><H2>Drawing Lines and Curves</H2></A>

<p>
MFC's <I>CDC</I> class includes a number of member functions that you can use to draw lines and curves. The following table lists the key functions. There are others, but these paint a pretty good picture of the range of available line-drawing and curve-drawing functions.
</P>

<p>
<b><I>CDC</I> Functions for Drawing Lines and Curves</b>
</P>
<p><table cellpadding=5 width="95%"><tr>
<th valign="top">Function</th>  
<th valign="top">Description</th>
</tr>
<tr>
<td valign="top"><i>MoveTo</i></td>
<td valign="top">Sets the current position in preparation for drawing</td>
</tr>
<tr>
<td valign="top"><I>LineTo</I> </td>
<td valign="top">Draws a line from the current position to a specified position and moves the current position to the end of the line
</td>
</tr>
<tr>
<td valign="top"><I>Polyline</I></td>
<td valign="top">Connects a set of points with line segments</td>
</tr>
<tr>
<td valign="top"><I>PolylineTo</I> </td>
<td valign="top"> Connects a set of points with line segments beginning 
with the current position and moves the current position to 
the end of the polyline</td>
</tr>
<tr>
<td valign="top"><I>Arc</I> </td>
<td valign="top">Draws an arc</td>
</tr>
<tr>
<td valign="top"><I>ArcTo</I></td>
<td valign="top">Draws an arc and moves the current position to the end 
of the arc</td>
</tr>
<tr>
<td valign="top"><I>PolyBezier</I></td>
<td valign="top">Draws one or more B&eacute;zier splines</td>
</tr>
<tr>
<td valign="top"><I>PolyBezierTo</I> </td>
<td valign="top">Draws one or more B&eacute;zier splines and moves the 
current position to the end of the final spline</td>
</tr>
<tr>
<td valign="top"><I>PolyDraw</I></td>
<td valign="top">Draws a series of line segments and B&eacute;zier splines through a set of points and moves the current position to the end of the final line segment or spline</td>
</tr>
</table></p>

<p>
Drawing a straight line is simple. You just set the current position to one end 
of the line and call <I>LineTo</I> with the coordinates of the other:
</P>

<P><table cellpadding=5 width="95%"><tr><td>	
<PRE>dc.MoveTo (0, 0);
dc.LineTo (0, 100);
</PRE>
</td></tr></table></P>

<p>
To draw another line that's connected to the previous one, you call 
<I>LineTo</I> again. There's no need to call 
<I>MoveTo</I> a second time because the first call to 
<I>LineTo</I> sets the current position to the end of the line:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>dc.MoveTo (0, 0);
dc.LineTo (0, 100);
dc.LineTo (100, 100);
</pre>
</td></tr></table></p>

<p>
You can draw several lines in one fell swoop using 
<I>Polyline</I> or <I>PolylineTo</I>. The only difference between the two is that <I>PolylineTo</I> uses the device context's current position and <I>Polyline</I> does not. The following statements draw a box that 
measures 100 units to a side from a set of points describing the box's vertices:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>POINT aPoint[5] = { 0, 0, 0, 100, 100, 100, 100, 0, 0, 0 };
dc.Polyline (aPoint, 5);
</pre>
</td></tr></table></p>

<p>
These statements draw the same box using 
<I>PolylineTo</I>:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>dc.MoveTo (0, 0);
POINT aPoint[4] = { 0, 100, 100, 100, 100, 0, 0, 0 };
dc.PolylineTo (aPoint, 4);
</pre>
</td></tr></table></p>

<p>
When <I>PolylineTo</I> returns, the current position is set to the endpoint of the final 
line segment&#8212;in this case, (0,0). If 
<I>Polyline</I> is used instead, the current position is 
not altered.
</P>

<p>
Charles Petzold's <I>Programming Windows</I> contains an excellent example showing how and why polylines can be useful. The following 
<I>OnPaint</I> function, which is basically just an MFC adaptation of Charles's code, uses <I>CDC::Polyline</I> to draw a sine wave that fills the interior of a window:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>#include &lt;math.h&gt;
#define SEGMENTS 500
#define PI 3.1415926
   <img src="images/grayvellip.JPG" width=3 height=13 border="0">
void CMainWindow::OnPaint ()
{
    CRect rect;
    GetClientRect (&amp;rect);
    int nWidth = rect.Width ();
    int nHeight = rect.Height ();

    CPaintDC dc (this);
    CPoint aPoint[SEGMENTS];

    for (int i=0; i&lt;SEGMENTS; i++) {
        aPoint[i].x = (i * nWidth) / SEGMENTS;
        aPoint[i].y = (int) ((nHeight / 2) *
            (1 - (sin ((2 * PI * i) / SEGMENTS))));
    }
    dc.Polyline (aPoint, SEGMENTS);
}
</pre>
</td></tr></table></p>

<p>
You can see the results for yourself by substituting this code for the <I>OnPaint</I> function in Chapter 1's Hello program. Note the use of the <I>CRect</I> functions <I>Width</I> and <I>Height</I> to compute the width and height of the window's client area. 
</P>

<P>
An arc is a curve taken from the circumference of a circle or an ellipse. You can draw arcs quite easily with <I>CDC::Arc</I>. You just pass it a rectangle whose borders circumscribe the ellipse and a pair of points that specify the endpoints of two imaginary lines drawn outward from the center of the ellipse. The points at which the lines intersect the ellipse are the starting and ending points of the arc. (The lines must be long enough to at least touch the circumference of the ellipse; otherwise, the results won't be what you expect.) The following code draws an arc representing the upper left quadrant of an ellipse that is 200 units wide and 100 units high:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>CRect rect (0, 0, 200, 100);
CPoint point1 (0, -500);
CPoint point2 (-500, 0);
dc.Arc (rect, point1, point2);
</pre>
</td></tr></table></p>

<p>
To reverse the arc and draw the upper right, lower right, and lower left quadrants of the ellipse, simply reverse the order in which <I>point1</I> and <I>point2</I> are passed to the <I>Arc</I> function. If you'd like to know where the arc ended (an item of information that's useful when using lines and arcs to draw three-dimensional pie charts), use <I>ArcTo</I> instead of <I>Arc</I> and then use <I>CDC::GetCurrentPosition</I> to locate the endpoint. Be careful, though. In addition to drawing the arc itself, <I>ArcTo</I> draws a line from the old current position to the arc's starting point. What's more, <I>ArcTo</I> is one of a handful of GDI functions that's not implemented in Windows 98. If you call it on a platform other than Windows NT or Windows 2000, nothing will be output.
</p><p>
If splines are more your style, the GDI can help out there, too. <I>CDC::PolyBezier</I> draws B&eacute;zier splines&#8212;smooth curves defined by two endpoints and two 
intermediate points that exert &quot;pull.&quot; Originally devised to help engineers build mathematical models of car bodies, B&eacute;zier splines, or simply &quot;B&eacute;ziers,&quot; as they are more often known, are used today in everything from fonts to warhead designs. The following code fragment uses two B&eacute;zier splines to draw a figure that resembles the famous Nike &quot;swoosh&quot; symbol. (See Figure 2-2.)
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>POINT aPoint1[4] = { 120, 100, 120, 200, 250, 150, 500, 40 };
POINT aPoint2[4] = { 120, 100,  50, 350, 250, 200, 500, 40 };
dc.PolyBezier (aPoint1, 4);
dc.PolyBezier (aPoint2, 4);
</pre>
</td></tr></table></p>

<p>
The curves drawn here are independent splines that happen to join at the 
endpoints. To draw a continuous curve by joining two or more splines, add three points to the POINT array for each additional spline and increase the number of points specified in <I>PolyBezier</I>'s second parameter accordingly.
</P>

<P>
<A HREF="javascript:fullSize('F02mg02x.htm')"> <img src="IMAGES/F02mg02.JPG" width=404 height=302 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 2-2.</B> <I>A famous shoe logo drawn with B&eacute;zier splines.</I><!-- /CAPTION -->
</p>

<p>
One peculiarity of all GDI line-drawing and curve-drawing functions is 
that the final pixel is never drawn. If you draw a line from (0,0) to (100,100) with the statements
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>dc.MoveTo (0, 0);
dc.LineTo (100, 100);
</pre>
</td></tr></table></p>

<p>
the pixel at (0,0) is set to the line color, as are the pixels at (1,1), (2,2), and so on. But the pixel at (100,100) is still the color it was before. If you want the line's final pixel to be drawn, too, you must draw it yourself. One way to do that is to use the <I>CDC::SetPixel</I> function, which sets a single pixel to the color you specify.
</P>

<A NAME="42"><H2>Drawing Ellipses, Polygons, and Other Shapes</H2></A>

<p>
The GDI doesn't limit you to simple lines and curves. It also lets you draw ellipses, rectangles, pie-shaped wedges, and other closed figures. MFC's <I>CDC</I> class wraps the associated GDI functions in handy class member functions that you can call on a device context object or through a pointer to a device context object. The following table lists a few of those functions.
</P>

<p>
<b><I>CDC</I> Functions for Drawing Closed Figures</b>
</P>


<p><table cellpadding=5 width="95%"><tr>
<th valign="top">Function</th>     
<th valign="top">Description</th>
</tr>
<tr>
<td valign="top"><I>Chord</I> </td>
<td valign="top"> Draws a closed figure bounded by the intersection of an ellipse and a line</td>
</tr>
<tr>
<td valign="top"><I>Ellipse</I></td>
<td valign="top">Draws a circle or an ellipse</td>
</tr>
<tr>
<td valign="top"><I>Pie</I></td>
<td valign="top"> Draws a pie-shaped wedge</td>
</tr>
<tr>
<td valign="top"><I>Polygon</I></td>
<td valign="top">Connects a set of points to form a polygon</td>
</tr>
<tr>
<td valign="top"><I>Rectangle</I></td>
<td valign="top">Draws a rectangle with square corners</td>
</tr>
<tr>
<td valign="top"><I>RoundRect</I> </td>
<td valign="top">Draws a rectangle with rounded corners</td>
</tr></table></p>


<p>
GDI functions that draw closed figures take as a parameter the coordinates of a &quot;bounding box.&quot; When you draw a circle with the <I>Ellipse</I> function, for example, you don't specify a center point and a radius; instead, you specify the circle's bounding box. You can pass the coordinates explicitly, like this:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>dc.Ellipse (0, 0, 100, 100);
</pre>
</td></tr></table></p>

<p>
or pass them in a RECT structure or a 
<I>CRect</I> object, like this:
</P>
<p><table cellpadding=5 width="95%"><tr><td>
<pre>CRect rect (0, 0, 100, 100);
dc.Ellipse (rect);
</pre>
</td></tr></table></p>

<p>
When this circle is drawn, it touches the 
<I>x</I>=0 line at the left of the bounding box 
and the <I>y</I>=0 line at the top, but it falls 1 pixel short of the 
<I>x</I>=100 line at the right and 1 pixel short of the 
<I>y</I>=100 line at the bottom. In other words, figures are drawn 
from the left and upper limits of the bounding box up to (but not including) the right and lower limits. If you call the <I>CDC::Rectangle</I> function, like this:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>dc.Rectangle (0, 0, 8, 4);
</pre>
</td></tr></table></p>

<p>
you get the output shown in Figure 2-3. Observe that the right and lower limits of the rectangle fall at <I>x</I>=7 and <I>y</I>=3, not 
<I>x</I>=8 and <I>y</I>=4.
</P>

<p>
<A HREF="javascript:fullSize('F02mg03x.htm')"> <img src="images/F02mg03.JPG" width=404 height=230 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 2-3.</B> <I>A rectangle drawn with the statement dc.Rectangle (0, 0, 8, 4).</I><!-- /CAPTION -->
</p>

<p>
<I>Rectangle</I> and <I>Ellipse</I> are about as straightforward as they come. You provide the bounding box, and Windows does the drawing. If you want to draw a rectangle that has rounded corners, use <I>RoundRect</I> instead of <I>Rectangle</I>.
</P>

<p>
The <I>Pie</I> and <I>Chord</I> functions merit closer scrutiny, however. Both are syntactically identical to the <I>Arc</I> function discussed in the previous section. The difference is in the output. (See Figure 2-4.) <I>Pie</I> draws a closed figure by drawing straight 
lines connecting the ends of the arc to the center of the ellipse. 
<I>Chord</I> closes the figure by connecting the arc's endpoints. The following <I>OnPaint</I> handler uses <I>Pie</I> to draw a pie chart that depicts four quarterly revenue values:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>#include &lt;math.h&gt;
#define PI 3.1415926
   <img src="images/grayvellip.JPG" width=3 height=13 border="0">
void CMainWindow::OnPaint ()
{
    CPaintDC dc (this);
    int nRevenues[4] = { 125, 376, 252, 184 };

    CRect rect;
    GetClientRect (&amp;rect);
    dc.SetViewportOrg (rect.Width () / 2, rect.Height () / 2);

    int nTotal = 0;
    for (int i=0; i&lt;4; i++)
        nTotal += nRevenues[i];

    int x1 = 0;
    int y1 = -1000;
    int nSum = 0;

    for (i=0; i&lt;4; i++) {
        nSum += nRevenues[i];
        double rad = ((double) (nSum * 2 * PI) / (double) nTotal) + PI;
        int x2 = (int) (sin (rad) * 1000);
        int y2 = (int) (cos (rad) * 1000 * 3) / 4;
        dc.Pie (-200, -150, 200, 150, x1, y1, x2, y2);
        x1 = x2;
        y1 = y2;
    }
}

</pre>
</td></tr></table></p>

<p>
Note that the origin is moved to the center of the window with 
<I>SetViewportOrg</I> before any drawing takes place so that the chart will also be centered.
</P>

<P>
<IMG SRC="images/F02mg04.GIF" width=391 height=183 border=0>
</p><p>
<!-- CAPTION --><B>Figure 2-4.</B> <I>Output from the Arc, Chord, and Pie functions.</I><!-- /CAPTION -->
</p>

<A NAME="43"><H2>GDI Pens and the <I>CPen</I> Class</H2></A>
<p>
Windows uses the pen that is currently selected into the device context to draw lines and curves and also to border figures drawn with <I>Rectangle</I>, <I>Ellipse</I>, and other shape-drawing functions. The default pen draws solid black lines that are 1 pixel wide. To change the way lines are drawn, you must create a GDI pen and select it into 
the device context with <I>CDC::SelectObject</I>.</p>
<p>
MFC represents GDI pens with the class <I>CPen</I>. The simplest way to create a 
pen is to construct a <I>CPen</I> object and pass it the parameters defining the pen:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>CPen pen (PS_SOLID, 1, RGB (255, 0, 0));
</pre>
</td></tr></table></p>

<p>
A second way to create a GDI pen is to construct an uninitialized 
<I>CPen</I> object and call <I>CPen::CreatePen</I>:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>CPen pen;
pen.CreatePen (PS_SOLID, 1, RGB (255, 0, 0));
</pre>
</td></tr></table></p>

<p>
Yet a third method is to construct an uninitialized 
<I>CPen</I> object, fill in a LOGPEN structure describing the pen, and then call <I>CPen::CreatePenIndirect</I> to create the pen:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>CPen pen;
LOGPEN lp;
lp.lopnStyle = PS_SOLID;
lp.lopnWidth.x = 1;
lp.lopnColor = RGB (255, 0, 0);
pen.CreatePenIndirect (&amp;lp);
</pre>
</td></tr></table></p>

<p>
LOGPEN's <I>lopnWidth</I> field is a POINT data structure. The structure's <I>x</I> data member specifies the pen width. The 
<I>y</I> data member is not used.  
</P>

<P>
<I>CreatePen</I> and <I>CreatePenIndirect</I> return TRUE if a pen is successfully created, FALSE if it is not. If you allow <I>CPen</I>'s constructor to create the pen, an exception of type <I>CResourceException</I> is thrown if the pen can't be created. This should happen only if Windows is critically low on memory.  
</P>

<P>
A pen has three defining characteristics: style, width, and color. The examples above create a pen whose style is PS_SOLID, whose width is 1, and whose color is bright red. The first of the three parameters passed to <I>CPen::CPen</I> and <I>CPen::CreatePen </I>specifies the pen style, which defines the type of line the pen draws. PS_SOLID creates a pen that draws solid, unbroken lines. Other pen styles are shown in Figure 2-5. 
</P>

<P>
<IMG SRC="images/F02mg05.GIF" width=399 height=311 border=0>
</p><p>
<!-- CAPTION --><B>Figure 2-5.</B> <I>Pen styles.</I><!-- /CAPTION -->
</p>

<P>
The special PS_INSIDEFRAME style draws solid lines that stay within the bounding rectangle, or &quot;inside the frame,&quot; of the figure being drawn. If you use any of the other pen styles to draw a circle whose diameter is 100 units using a PS_SOLID pen that is 20 units wide, for example, the actual diameter of the circle, measured across the circle's outside edge, is 120 units, as shown in Figure 2-6. Why? Because the border drawn by the pen extends 10 units outward on either side of the theoretical circle. Draw the same circle with a PS_INSIDEFRAME pen, and the diameter is exactly 100 units. The PS_INSIDEFRAME style does not affect lines drawn with <I>LineTo</I> and other functions that don't use a bounding rectangle.
</P>

<p>
<A HREF="javascript:fullSize('F02mg06x.htm')"> <img src="IMAGES/F02mg06.JPG" width=404 height=205 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 2-6.</B> <I>The PS_INSIDEFRAME pen style.</I><!-- /CAPTION -->
</p>

<P>
The pen style PS_NULL creates what Windows programmers refer to as a 
&quot;NULL pen.&quot; Why would you ever want to create a NULL pen? Believe it or not, there are times when a NULL pen can come in handy. Suppose, for example, that you want to draw a solid red circle with no border. If you draw the circle with MFC's <I>CDC::Ellipse</I> function, Windows automatically borders the circle with the pen currently 
selected into the device context. You can't tell the <I>Ellipse</I> function that you don't want a border, but you <I>can</I> select a NULL pen into the device context so that the circle will have no visible border. NULL brushes are used in a similar way. If you want the circle to have a border but want the interior of the circle to be transparent, you can select a NULL brush into the device context before you draw.
</P>

<p>
The second parameter passed to <I>CPen</I>'s pen-create functions specifies the width of the lines drawn with the pen. Pen widths are specified in logical units whose physical meanings depend on the current mapping mode. You can create PS_SOLID, PS_NULL, and PS_INSIDEFRAME pens of any logical width, but PS_DASH, PS_DOT, PS_DASHDOT, and PS_DASHDOTDOT pens must be 1 logical unit wide. Specifying a pen width of 0 in any style creates a pen that is 1 pixel wide, no matter what the mapping mode.
</P>

<p>
The third and final parameter specified when a pen is created is the pen's color. Windows uses a 24-bit RGB color model in which each possible color is defined by red, green, and blue color values from 0 through 255. The higher the value, the brighter the corresponding color component. The RGB macro combines values that specify the three independent color components into one COLORREF value that can be 
passed to the GDI. The statement
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>CPen pen (PS_SOLID, 1, RGB (255, 0, 0));
</pre>
</td></tr></table></p>

<p>
creates a bright red pen, and the statement
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>CPen pen (PS_SOLID, 1, RGB (255, 255, 0));
</pre>
</td></tr></table></p>

<p>
creates a bright yellow pen by combining red and green. If the display adapter doesn't support 24-bit color, Windows compensates by dithering colors that it can't display directly. Be aware, however, that only PS_INSIDEFRAME pens greater than 1 logical unit in width can use dithered colors. For the other pen styles, Windows maps the color of the pen to the nearest solid color that can be displayed. You can be 
reasonably certain of getting the exact color you want on all adapters by sticking to the &quot;primary&quot; colors shown in the table below. These colors are part of the basic palette that Windows programs into the color registers of every video adapter to ensure that a common subset of colors is available to all programs.
</P>

<P>
<b>Primary GDI Colors</b></p>
<p><table cellpadding=5 width="95%">

<tr>
<th valign="top">Color</th>
<th valign="top">R</th>
<th valign="top">G</th>
<th valign="top">B</th>
<th valign="top">Color</th>
<th valign="top">R</th>
<th valign="top">G</th>
<th valign="top">B</th>
</tr>
<tr>
<td valign="top">Black</td>
<td valign="top">0</td>
<td valign="top">0</td>
<td valign="top">0</td>
<td valign="top">Light gray</td>
<td valign="top">192</td>
<td valign="top">192</td>
<td valign="top">192</td>
</tr>
<tr>
<td valign="top">Blue</td>
<td valign="top">0</td>
<td valign="top">0</td>
<td valign="top">192</td>
<td valign="top">Bright blue</td>
<td valign="top">0</td>
<td valign="top">0</td>
<td valign="top">255</td>
</tr>
<tr>
<td valign="top">Green</td>
<td valign="top">0</td>
<td valign="top">192</td>
<td valign="top">0</td>
<td valign="top">Bright green</td>
<td valign="top">0</td>
<td valign="top">255</td>
<td valign="top">0</td>
</tr>
<tr>
<td valign="top">Cyan</td>
<td valign="top">0</td>
<td valign="top">192</td>
<td valign="top">192</td>
<td valign="top">Bright cyan</td>
<td valign="top">0</td>
<td valign="top">255</td>
<td valign="top">255</td>
</tr>
<tr>
<td valign="top">Red</td>
<td valign="top">192</td>
<td valign="top">0</td>
<td valign="top">0</td>
<td valign="top">Bright red</td>
<td valign="top">255</td>
<td valign="top">0</td>
<td valign="top">0</td>
</tr>
<tr>
<td valign="top">Magenta</td>
<td valign="top">192</td>
<td valign="top">0</td>
<td valign="top">192</td>
<td valign="top">Bright magenta</td>
<td valign="top">255</td>
<td valign="top">0</td>
<td valign="top">255</td>
</tr>
<tr>
<td valign="top">Yellow</td>
<td valign="top">192</td>
<td valign="top">192</td>
<td valign="top">0</td>
<td valign="top">Bright yellow</td>
<td valign="top">255</td>
<td valign="top">255</td>
<td valign="top">0</td>
</tr>

<tr>
<td valign="top">Dark gray</td>
<td valign="top">128</td>
<td valign="top">128</td>
<td valign="top">128</td>
<td valign="top">White</td>
<td valign="top">255</td>
<td valign="top">255</td>
<td valign="top">255</td>   
</tr>
</table></p>

<p>
How do you use a pen once it's created? Simple: You select it into a 
device context. The following code snippet creates a red pen that's 10 units wide and draws an ellipse with it:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>CPen pen (PS_SOLID, 10, RGB (255, 0, 0));
CPen* pOldPen = dc.SelectObject (&amp;pen);
dc.Ellipse (0, 0, 100, 100);
</pre>
</td></tr></table></p>

<p>
The ellipse is filled with the color or pattern of the current brush, which defaults to white. To change the default, you need to create a GDI brush and select it into the device context before calling <I>Ellipse</I>. I'll demonstrate how to do that in just a moment.
</P>

<A NAME="44"><H3>Extended Pens</H3></A>

<p>
If none of the basic pen styles suits your needs, you can use a separate class of pens known as &quot;extended&quot; pens, which the Windows GDI and MFC's <I>CPen</I> class support. These pens offer a greater variety of output options. For example, you can create an extended pen that draws a pattern described by a bitmap image or uses a dithered color. You can also exercise precise control over endpoints and joins by 
specifying the end cap style (flat, round, or square) and join style (beveled, mitered, or rounded). The following code creates an extended pen 16 units wide that draws solid green lines with flat ends. Where two lines meet, the adjoining ends are rounded to form a smooth intersection:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>LOGBRUSH lb;
lb.lbStyle = BS_SOLID;
lb.lbColor = RGB (0, 255, 0);
CPen pen (PS_GEOMETRIC &#166; PS_SOLID &#166; PS_ENDCAP_FLAT &#166;
    PS_JOIN_ROUND, 16, &amp;lb);
</pre>
</td></tr></table></p>

<p>
Windows places several restrictions on the use of extended pens, not the 
least of which is that endpoint joins will work only if the figure is first drawn as a &quot;path&quot; and is then rendered with 
<I>CDC::StrokePath</I> or a related function. You define a 
path by enclosing drawing commands between calls to <I>CDC::BeginPath</I> and <I>CDC::EndPath</I>, as shown here:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>dc.BeginPath ();        // Begin the path definition
dc.MoveTo (0, 0);       // Create a triangular path
dc.LineTo (100, 200);
dc.LineTo (200, 100);
dc.CloseFigure ();
dc.EndPath ();          // End the path definition
dc.StrokePath ();       // Draw the triangle
</pre>
</td></tr></table></p>

<p>
Paths are a powerful feature of the GDI that you can use to create all sorts of interesting effects. We'll look more closely at paths&#8212;and at the <I>CDC</I> functions that use them&#8212;in <a href="ch15a.htm">Chapter 15</a>.
</P>

<A NAME="45"><H2>GDI Brushes and the <I>CBrush</I> Class</H2></A>
<p>
By default, closed figures drawn with <I>Rectangle</I>, <I>Ellipse</I>, and other <I>CDC</I> output functions are filled with white pixels. You can change the fill color by creating a GDI brush and selecting it into the device context prior to drawing. 
</P>

<P>
MFC's <I>CBrush</I> class encapsulates GDI brushes. Brushes come in three basic varieties: solid, hatch, and pattern. Solid brushes paint with solid colors. If the 
display hardware won't allow a solid brush color to be displayed directly, Windows simulates the color by dithering colors that 
<I>can</I> be displayed. A hatch brush paints with one of six predefined crosshatch patterns that are similar to ones commonly found in engineering and architectural drawings. A pattern brush paints with a bitmap. The <I>CBrush</I> class provides a constructor for each different brush style.</p>

<p>You can create a solid brush in one step by passing a COLORREF value to the <I>CBrush</I> constructor:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>CBrush brush (RGB (255, 0, 0));
</pre>
</td></tr></table></p>

<p>
Or you can create a solid brush in two steps by creating an uninitialized <I>CBrush</I> object and calling <I>CBrush::CreateSolidBrush</I>:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>CBrush brush;
brush.CreateSolidBrush (RGB (255, 0, 0));
</pre>
</td></tr></table></p>

<p>
Both examples create a solid brush that paints in bright red. You can also create a brush by initializing a LOGBRUSH structure and calling 
<I>CBrush::CreateBrushIndirect</I>. As with <I>CPen</I> constructors, all <I>CBrush</I> constructors that create a brush for you throw a resource exception if the GDI is low on memory and a brush can't be created.
</P>

<p>
Hatch brushes are created by passing <I>CBrush</I>'s<I> </I>constructor both a hatch index and a COLORREF value or by calling <I>CBrush::CreateHatchBrush</I>. The statement
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>CBrush brush (HS_DIAGCROSS, RGB (255, 0, 0));
</pre>
</td></tr></table></p>

<p>
creates a hatch brush that paints perpendicular crosshatch lines oriented at 
45-degree angles, as do these statements:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>CBrush brush;
brush.CreateHatchBrush (HS_DIAGCROSS, RGB (255, 0, 0));
</pre>
</td></tr></table></p>

<p>
HS_DIAGCROSS is one of six hatch styles you can choose from. (See Figure 
2-7.) When you paint with a hatch brush, Windows fills the space between hatch lines with the default background color (white) unless you change the device context's current background color with <I>CDC::SetBkColor</I> or turn off background fills by changing the background mode from OPAQUE to TRANSPARENT with <I>CDC::SetBkMode</I>. The statements
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>CBrush brush (HS_DIAGCROSS, RGB (255, 255, 255));
dc.SelectObject (&amp;brush);
dc.SetBkColor (RGB (192, 192, 192));
dc.Rectangle (0, 0, 100, 100);
</pre>
</td></tr></table></p>

<p>
draw a rectangle 100 units square and fill it with white crosshatch lines drawn against a light gray background. The statements
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>CBrush brush (HS_DIAGCROSS, RGB (0, 0, 0));
dc.SelectObject (&amp;brush);
dc.SetBkMode (TRANSPARENT);
dc.Rectangle (0, 0, 100, 100);
</pre>
</td></tr></table></p>

<p>
draw a black crosshatched rectangle against the existing background.
</P>

<p>
<A HREF="javascript:fullSize('F02mg07x.htm')"> <img src="IMAGES/F02mg07.JPG" width=404 height=184 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 2-7.</B> <I>Hatch brush styles.</I><!-- /CAPTION -->
</p>

<A NAME="46"><H3>The Brush Origin</H3></A>

<p>
One attribute of a device context that you should be aware of when using 
dithered brush colors or hatch brushes is the brush origin. When Windows fills an area with a hatched or dithered brush pattern, it tiles an 8-pixel by 8-pixel pattern horizontally and vertically within the affected area. By default, the origin for this pattern, better known as the <I>brush origin,</I> is the device point (0,0)&#8212;the screen pixel in the upper left corner of the window. This means that a pattern drawn in a rectangle that begins 100 pixels to the right of and below the origin will be aligned somewhat differently with respect to the rectangle's border than a pattern drawn in a rectangle positioned a 
few pixels to the left or right, as shown in Figure 2-8. In many applications, it doesn't matter; the user isn't likely to notice minute differences in brush alignment. However, in some situations it matters a great deal.
</P>

<P>
<A HREF="javascript:fullSize('F02mg08x.htm')"> <img src="IMAGES/F02mg08.JPG" width=404 height=163 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 2-8.</B> <I>Brush alignment.</I><!-- /CAPTION -->
</p>

<p>
Suppose you're using a hatch brush to fill a rectangle and you're animating the motion of that rectangle by repeatedly erasing it and redrawing it 1 pixel to the right or the left. If you don't reset the brush origin to a point that stays in the same position relative to the rectangle before each redraw, the hatch pattern will &quot;walk&quot; as the rectangle moves.
</P>

<p>
The solution? Before selecting the brush into the device context and 
drawing the rectangle, call <I>CGdiObject::UnrealizeObject</I> on the brush object to permit the brush origin to be moved. Then call 
<I>CDC::SetBrushOrg</I> to align the brush origin with the rectangle's upper left corner, as shown here:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>CPoint point (x1, y1);
dc.LPtoDP (&amp;point);
point.x %= 8;
point.y %= 8;
brush.UnrealizeObject ();
dc.SetBrushOrg (point);
dc.SelectObject (&amp;brush);
dc.Rectangle (x1, y1, x2, y2);
</pre>
</td></tr></table></p>

<p>
In this example, <I>point</I> is a <I>CPoint</I> object that holds the logical coordinates of the rectangle's upper left corner. <I>LPtoDP</I> is called to convert logical coordinates into device coordinates (brush origins are always specified in device coordinates), and a modulo-8 operation is performed on the resulting values because coordinates passed to <I>SetBrushOrg</I> should fall within the range 0 through 7. Now the hatch pattern will be aligned consistently no matter where in the window the rectangle is drawn.
</P>

<A NAME="47"><H2>Drawing Text</H2></A>

<p>
You've already seen one way to output text to a window. The 
<I>CDC::DrawText</I> function writes a string of text to a display surface. You tell <I>DrawText</I> where to draw its output by specifying both a formatting rectangle and a series of option flags indicating how the text is to be positioned within the rectangle. In Chapter 1's Hello 
program, the statement
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>dc.DrawText (_T (&quot;Hello, MFC&quot;), -1, &amp;rect,
    DT_SINGLELINE &#166; DT_CENTER &#166; DT_VCENTER);
</pre>
</td></tr></table></p>

<p>
drew &quot;Hello, MFC&quot; so that it was centered in the window. 
<I>rect</I> was a rectangle object initialized with the coordinates of the window's client area, and the DT_CENTER and DT_VCENTER flags told <I>DrawText</I> to center its output in the rectangle both horizontally and vertically.
</P>

<p>
<I>DrawText</I> is one of several text-related functions that are members of MFC's <I>CDC</I> class. Some of the others are listed in the table below. One of the most useful is <I>TextOut</I>, which outputs text like <I>DrawText</I> but accepts an <I>x</I>-<I>y</I> 
coordinate pair that specifies where the text will be output and also uses the current position if it is asked to. The statement
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>dc.TextOut (0, 0, CString (_T (&quot;Hello, MFC&quot;)));
</pre>
</td></tr></table></p>

<p>
writes &quot;Hello, MFC&quot; to the upper left of the display surface represented by <I>dc</I>. A related function named <I>TabbedTextOut</I> works just like <I>TextOut</I> except that it expands tab characters into white space. (If a string passed to <I>TextOut</I> contains tabs, the characters show up as rectangles in most fonts.) Tab positions are specified in the call to <I>TabbedTextOut</I>. A related function named 
<I>ExtTextOut</I> gives you the added option of filling a rectangle surrounding the output text with an opaque background color. It also gives the programmer precise control over intercharacter spacing.
</P>

<p>
By default, the coordinates passed to 
<I>TextOut</I>, <I>TabbedTextOut</I>, and 
<I>ExtTextOut</I> specify the location of the upper left corner of the text's leftmost character cell. However, the relationship between the coordinates passed to <I>TextOut</I> and the characters in the output string, a property known as the <I>text alignment</I>, is an attribute of the device context. You can change it with <I>CDC::SetTextAlign</I>. For example, after a
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>dc.SetTextAlign (TA_RIGHT);
</pre>
</td></tr></table></p>

<p>
statement is executed, the <I>x</I> coordinate passed to 
<I>TextOut</I> specifies the rightmost position in the character cell&#8212;perfect for drawing right-aligned text.
</P>

<p>
You can also call <I>SetTextAlign</I> with a TA_UPDATECP flag to instruct <I>TextOut</I> to ignore the <I>x</I> and <I>y</I> arguments passed to it and use the device context's current position instead. When the text alignment includes TA_UPDATECP, <I>TextOut</I> updates the <I>x</I> component of the current position each time a string is output. One use for this feature is to achieve proper spacing between two or more character strings that are output on the same line.
</P>

<p>
<b><I>CDC</I> Text Functions</b>
</P>

<p><table cellpadding=5 width="95%"><tr>
<th valign="top">Function</th>    
<th valign="top">Description</th>
</tr>
<tr>
<td valign="top"><I>DrawText</I> </td>
<td valign="top">Draws text in a formatting rectangle</td>
</tr>
<tr>
<td valign="top"><I>TextOut</I> </td>
<td valign="top">Outputs a line of text at the current or 
specified position</td>
</tr>
<tr>
<td valign="top"><I>TabbedTextOut</I> </td>
<td valign="top">Outputs a line of text that includes tabs</td>
</tr>
<tr>
<td valign="top"><I>ExtTextOut</I> </td>
<td valign="top">Outputs a line of text and optionally fills a 
rectangle with a background color or varies the 
intercharacter spacing</td>
</tr>    
<tr>
<td valign="top"><I>GetTextExtent</I> </td>
<td valign="top">Computes the width of a string in the current font</td>
</tr>
<tr>
<td valign="top"><I>GetTabbedTextExtent</I></td>
<td valign="top">Computes the width of a string with tabs in the 
current font</td>
</tr>
<tr>
<td valign="top"><I>GetTextMetrics</I> </td>
<td valign="top">Returns font metrics (character height, average 
character width, and so on) for the current font</td>
</tr>
<tr>
<td valign="top"><I>SetTextAlign</I> </td>
<td valign="top">Sets alignment parameters for 
<I>TextOut</I> and other output functions</td>
</tr>
<tr>
<td valign="top"><I>SetTextJustification</I></td>
<td valign="top">Specifies the added width that is needed to justify 
a string of text</td>
</tr>
<tr>
<td valign="top"><I>SetTextColor</I></td>
<td valign="top">Sets the device context's text output color</td>
</tr>
<tr>
<td valign="top"><I>SetBkColor</I></td>
<td valign="top">Sets the device context's background color, 
which determines the fill color used behind characters 
that are output to a display surface</td>
</tr>
</table></p>


<p>
Two functions&#8212;<I>GetTextMetrics</I> and <I>GetTextExtent</I>&#8212;let you retrieve information about the font that is currently selected into the device context. <I>GetTextMetrics</I> fills a TEXTMETRIC structure with information on the characters that make up the font. <I>GetTextExtent</I> returns the width of a given string, in logical units, rendered in that font. (Use <I>GetTabbedTextExtent</I> if the string contains tab characters.) One use for <I>GetTextExtent</I> is to gauge the width of a string prior to outputting it in order to compute how much space is needed between words to fully justify the text. If <I>nWidth</I> is the distance between left and right margins, the following code outputs the text &quot;Now is the time&quot; and justifies the output to both margins:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>CString string = _T (&quot;Now is the time&quot;);
CSize size = dc.GetTextExtent (string);
dc.SetTextJustification (nWidth - size.cx, 3);
dc.TextOut (0, y, string);
</pre>
</td></tr></table></p>

<p>
The second parameter passed to <I>SetTextJustification</I> specifies the number of break characters in the string. The default break character is the space character. After <I>SetTextJustification</I> is called, subsequent calls to <I>TextOut</I> and related text output functions distribute the space specified in the <I>SetTextJustification</I>'s first parameter evenly between all the break characters.
</P>

<A NAME="48"><H2>GDI Fonts and the <I>CFont</I> Class</H2></A>
<p>
All <I>CDC</I> text functions use the font that is currently selected into the device context. A <I>font</I> is a group of characters of a particular size (height) and typeface that share common attributes such as character weight&#8212;for example, normal or boldface. In classical typography, font sizes are measured in units called <I>points</I>. One point equals about 1/72 inch. Each character in a 12-point font is nominally 1/6 inch tall, but in Windows, the actual height can vary somewhat depending on the physical characteristics of the output device. The term <I>typeface</I> describes a font's basic style. Times New Roman is one example of a typeface; Courier New is another.
</P>

<P>
A font is a GDI object, just as a pen or a brush is. In MFC, fonts are represented by objects of the <I>CFont</I> class. Once a <I>CFont</I> object is constructed, you create the underlying GDI font by calling the 
<I>CFont</I> object's <I>CreateFont</I>, <I>CreateFontIndirect</I>, <I>CreatePointFont</I>, or <I>CreatePointFontIndirect</I> function. Use 
<I>CreateFont</I> or <I>CreateFontIndirect</I> if you want to specify the font size in pixels, and use <I>CreatePointFont</I> and 
<I>CreatePointFontIndirect</I> to specify the font size in points. Creating a 12-point Times New Roman screen font with <I>CreatePointFont</I> requires just two lines of code:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>CFont font;
font.CreatePointFont (120, _T (&quot;Times New Roman&quot;));
</pre>
</td></tr></table></p>

<p>
Doing the same with <I>CreateFont</I> requires you to query the device context for the logical number of pixels per inch in the vertical direction and to convert points to pixels:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>CClientDC dc (this);
int nHeight = -((dc.GetDeviceCaps (LOGPIXELSY) * 12) / 72);
CFont font;
font.CreateFont (nHeight, 0, 0, 0, FW_NORMAL, 0, 0, 0,
    DEFAULT_CHARSET, OUT_CHARACTER_PRECIS, CLIP_CHARACTER_PRECIS,
    DEFAULT_QUALITY, DEFAULT_PITCH &#166; FF_DONTCARE,
    _T (&quot;Times New Roman&quot;));
</pre>
</td></tr></table></p>

<p>
Incidentally, the numeric value passed to <I>CreatePointFont</I> is the desired point size <I>times 10</I>. This allows you to control the font size down to 1/10 point&#8212;plenty accurate enough for most applications, considering the relatively low resolution of most screens and other commonly used output devices.</p>

<p>The many parameters passed to <I>CreateFont</I> specify, among other things, the font weight and whether characters in the font are italicized. You can't create a 
bold, italic font with <I>CreatePointFont</I>, but you can with 
<I>CreatePointFontIndirect</I>. The following code creates a 12-point bold, italic Times New Roman font using <I>CreatePointFontIndirect</I>.
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>LOGFONT lf;
::ZeroMemory (&amp;lf, sizeof (lf));
lf.lfHeight = 120;
lf.lfWeight = FW_BOLD;
lf.lfItalic = TRUE;
::lstrcpy (lf.lfFaceName, _T (&quot;Times New Roman&quot;));

CFont font;
font.CreatePointFontIndirect (&amp;lf);
</pre>
</td></tr></table></p>

<p>
LOGFONT is a structure whose fields define all the characteristics of a font. <I>::ZeroMemory</I> is an API function that zeroes a block of memory, and <I>::lstrcpy</I> is an API function that copies a text string from one memory location to another. You can use the C run 
time's <I>memset</I> and <I>strcpy</I> functions instead (actually, you should use <I>_tcscpy</I> in lieu of <I>strcpy</I> so the call will work with ANSI or Unicode characters), but using Windows API functions frequently makes an executable smaller by reducing the amount of 
statically linked code. 
</P>

<P>
After creating a font, you can select it into a device context and draw with it using <I>DrawText</I>, <I>TextOut</I>, and other <I>CDC</I> text functions. The following <I>OnPaint</I> handler draws &quot;Hello, MFC&quot; in the center of a window. But this time the text is drawn using a 72-point Arial typeface, complete with drop shadows. (See Figure 2-9.)
</P>


<p><table cellpadding=5 width="95%"><tr><td>	<pre>void CMainWindow::OnPaint ()
{
    CRect rect;
    GetClientRect (&amp;rect);

    CFont font;
    font.CreatePointFont (720, _T (&quot;Arial&quot;));

    CPaintDC dc (this);
    dc.SelectObject (&amp;font);
    dc.SetBkMode (TRANSPARENT);

    CString string = _T (&quot;Hello, MFC&quot;);

    rect.OffsetRect (16, 16);
    dc.SetTextColor (RGB (192, 192, 192));
    dc.DrawText (string, &amp;rect, DT_SINGLELINE &#166;
        DT_CENTER &#166; DT_VCENTER);

    rect.OffsetRect (-16, -16);
    dc.SetTextColor (RGB (0, 0, 0));
    dc.DrawText (string, &amp;rect, DT_SINGLELINE &#166;
        DT_CENTER &#166; DT_VCENTER);
}
</pre>
</td></tr></table></p>


<p>
<A HREF="javascript:fullSize('F02mg09x.htm')"> <img src="IMAGES/F02mg09.JPG" width=404 height=302 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 2-9.</B> <I>&quot;Hello, MFC&quot; rendered in 72-point Arial with drop shadows.</I><!-- /CAPTION -->
</p>

<P>
The shadow effect is achieved by drawing the text string twice&#8212;once a few pixels to the right of and below the center of the window, and once in the center. MFC's <I>CRect::OffsetRect</I> function makes it a snap to &quot;move&quot; rectangles by offsetting them a specified distance in the <I>x</I> and <I>y</I> directions.
</P>

<P>
What happens if you try to create, say, a Times New Roman font on a 
system that doesn't have Times New Roman installed? Rather than fail the call, the GDI will pick a similar typeface that <I>is</I> installed. An internal font-mapping algorithm is called to pick the best match, and the results aren't always what one might expect. But at least your application won't output text just fine on one system and mysteriously 
output nothing on another.
</P>

<A NAME="49"><H2>Raster Fonts vs. TrueType Fonts</H2></A>

<p>
Most GDI fonts fall into one of two categories: raster fonts and TrueType fonts. Raster fonts are stored as bitmaps and look best when they're displayed in their native sizes. One of the most useful raster fonts provided with Windows is MS Sans Serif, which is commonly used (in its 8-point size) on push buttons, radio buttons, and other dialog box controls. Windows can scale raster fonts by duplicating rows and 
columns of pixels, but the results are rarely pleasing to the eye due to stair-stepping effects. 
</P>

<P>
The best fonts are TrueType fonts because they scale well to virtually any size. Like PostScript fonts, TrueType fonts store character outlines as mathematical formulas. They also include &quot;hint&quot; information that's used by the GDI's TrueType font rasterizer to enhance scalability. You can pretty much bank on the fact that any system your application runs on will have the following TrueType fonts installed, because all four are provided with Windows:
</P>

<p>
<UL>
<p><LI>Times New Roman</LI></P>
<P><LI>Arial</LI></P>
<P><LI>Courier New</LI></P>
<P><LI>Symbol</LI></P>
</UL>
</P>

<P>
In <a href="ch07a.htm">Chapter 7</a>, you'll learn how to query the system for font information and how to enumerate the fonts that are installed. Such information can be useful if your application requires precise character output or if you want to present a list of installed fonts to the user.
</P>

<A NAME="50"><H2>Rotated Text</H2></A>

<p>
One question that's frequently asked about GDI text output is &quot;How do I display rotated text?&quot; There are two ways to do it, one of which works only in Microsoft Windows NT and Windows 2000. The other method is compatible with all 32-bit versions of Windows, so it's the one I'll describe here. 
</p>

<p>
The secret is to create a font with <I>CFont::CreateFontIndirect</I> or 
<I>CFont::CreatePointFontIndirect</I> and to specify the desired rotation angle (in degrees) times 10 in the LOGFONT structure's <I>lfEscapement</I> and <I>lfOrientation</I> fields. Then you output the text in the normal manner&#8212;for example, using <I>CDC::TextOut</I>. Conventional text has an escapement and orientation of 0; that is, it has no slant and is drawn on a horizontal. Setting these values to 450 rotates the text counterclockwise 45 degrees. The following <I>OnPaint</I> handler increments <I>lfEscapement</I> and <I>lfOrientation</I> in units of 15 degrees and uses the resulting fonts to draw the radial text array shown in Figure 2-10:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>void CMainWindow::OnPaint ()
{
    CRect rect;
    GetClientRect (&amp;rect);

    CPaintDC dc (this);
    dc.SetViewportOrg (rect.Width () / 2, rect.Height () / 2);
    dc.SetBkMode (TRANSPARENT);

    for (int i=0; i&lt;3600; i+=150) {
        LOGFONT lf;
        ::ZeroMemory (&amp;lf, sizeof (lf));
        lf.lfHeight = 160;
        lf.lfWeight = FW_BOLD;
        lf.lfEscapement = i;
        lf.lfOrientation = i;
        ::lstrcpy (lf.lfFaceName, _T (&quot;Arial&quot;));

        CFont font;
        font.CreatePointFontIndirect (&amp;lf);

        CFont* pOldFont = dc.SelectObject (&amp;font);
        dc.TextOut (0, 0, CString (_T (&quot;          Hello, MFC&quot;)));
        dc.SelectObject (pOldFont);
    }
}
</pre>
</td></tr></table></p>


<p>
This technique works great with TrueType fonts, but it doesn't work at all with raster fonts. 
</P>

<P>
<A HREF="javascript:fullSize('F02mg10x.htm')"> <img src="IMAGES/F02mg10.JPG" width=404 height=302 border=0 ALT="Click to view at full size."> </A>
</P><P>
<!-- CAPTION --><B>Figure 2-10.</B> <I>Rotated text.</I><!-- /CAPTION -->
</P>

<A NAME="51"><H2>Stock Objects</H2></A>

<p>
Windows predefines a handful of pens, brushes, fonts, and other GDI objects that can be used without being explicitly created. Called 
<I>stock objects</I>, these GDI objects can be selected into a device context with the <I>CDC::SelectStockObject</I> function or assigned to an existing <I>CPen</I>, <I>CBrush</I>, or other object with 
<I>CGdiObject::CreateStockObject</I>. <I>CGdiObject</I> is the base class for <I>CPen</I>, <I>CBrush</I>, <I>CFont</I>, and other MFC 
classes that represent GDI objects. 
</P>

<P>
The following table shows a partial list of the available stock objects. Stock pens go by the names WHITE_PEN, BLACK_PEN, and NULL_PEN. WHITE_PEN and BLACK_PEN draw solid lines that are 1 pixel wide. NULL_PEN draws nothing. The stock brushes include one white brush, one black brush, and three shades of gray. HOLLOW_BRUSH and NULL_BRUSH are two different ways of referring to the 
same thing&#8212;a brush that paints nothing. SYSTEM_FONT is the font that's selected into every device context by default.
</P>

<P>
<b>Commonly Used Stock Objects</b></p>
<p><table cellpadding=5 width="95%"><tr>
<th valign="top">Object</th>   
<th valign="top">Description</th>
</tr>
<tr>
<td valign="top">NULL_PEN</td>
<td valign="top">Pen that draws nothing</td>
</tr>
<tr>
<td valign="top">BLACK_PEN</td>
<td valign="top">Black pen that draws solid lines 1 pixel wide</td>
</tr>
<tr>
<td valign="top">WHITE_PEN</td>
<td valign="top">White pen that draws solid lines 1 pixel wide</td>
</tr>
<tr>
<td valign="top">NULL_BRUSH</td>
<td valign="top">Brush that draws nothing</td>
</tr>    
<tr>
<td valign="top">HOLLOW_BRUSH</td>
<td valign="top">Brush that draws nothing (same as NULL_BRUSH)</td>
</tr>     
<tr>
<td valign="top">BLACK_BRUSH</td>
<td valign="top">Black brush</td>
</tr>   
<tr>
<td valign="top">DKGRAY_BRUSH</td>
<td valign="top">Dark gray brush</td>
</tr>
<tr>
<td valign="top">GRAY_BRUSH</td>
<td valign="top">Medium gray brush</td>
</tr>
<tr>
<td valign="top">LTGRAY_BRUSH </td>
<td valign="top">Light gray brush</td>
</tr>    
<tr>
<td valign="top">WHITE_BRUSH </td>
<td valign="top">White brush</td>
</tr>  
<tr>
<td valign="top">ANSI_FIXED_FONT </td>
<td valign="top">Fixed-pitch ANSI font</td>
</tr>
<tr>
<td valign="top">ANSI_VAR_FONT</td>
<td valign="top">Variable-pitch ANSI font</td>
</tr>     
<tr>
<td valign="top">SYSTEM_FONT</td>
<td valign="top">Variable-pitch system font</td>
</tr>
<tr>
<td valign="top">SYSTEM_FIXED_FONT</td>
<td valign="top">Fixed-pitch system font</td>
</tr>    
</table></p>


<p>
Suppose you want to draw a light gray circle with no border. How do you do it? Here's one way:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>CPen pen (PS_NULL, 0, (RGB (0, 0, 0)));
dc.SelectObject (&amp;pen);
CBrush brush (RGB (192, 192, 192));
dc.SelectObject (&amp;brush);
dc.Ellipse (0, 0, 100, 100);
</pre>
</td></tr></table></p>

<p>
But since NULL pens and light gray brushes are stock objects, here's a better way:
</P>
<p><table cellpadding=5 width="95%"><tr><td>	<pre>dc.SelectStockObject (NULL_PEN);
dc.SelectStockObject (LTGRAY_BRUSH);
dc.Ellipse (0, 0, 100, 100);
</pre>
</td></tr></table></p>

<p>
The following code demonstrates a third way to draw the circle. This time 
the stock objects are assigned to a <I>CPen</I> and a 
<I>CBrush</I> rather than selected into the device context directly:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>CPen pen;
pen.CreateStockObject (NULL_PEN);
dc.SelectObject (&amp;pen);

CBrush brush;
brush.CreateStockObject (LTGRAY_BRUSH);
dc.SelectObject (&amp;brush);

dc.Ellipse (0, 0, 100, 100);
</pre>
</td></tr></table></p>

<p>
Which of the three methods you use is up to you. The second method is the shortest, and it's the only one that's guaranteed not to throw an exception since it doesn't create any GDI objects.
</P>

<A NAME="52"><H2>Deleting GDI Objects</H2></A>

<p>
Pens, brushes, and other objects created from 
<I>CGdiObject</I>-derived classes are resources that consume space in memory, so it's important to delete them when you no longer need them. If you create a <I>CPen</I>, <I>CBrush</I>, <I>CFont</I>, or other <I>CGdiObject</I> on the stack, the associated GDI object is automatically deleted when <I>CGdiObject</I> goes out of scope. If you create a <I>CGdiObject</I> on the heap with <I>new</I>, be sure to delete it at some point so that its destructor will be called. The GDI object associated with a <I>CGdiObject</I> can be explicitly deleted by calling <I>CGdiObject::DeleteObject</I>. You never need to 
delete stock objects, even if they are &quot;created&quot; with <I>CreateStockObject</I>. 
</P>

<P>
In 16-bit Windows, GDI objects frequently contributed to the problem of resource leakage, in which the Free System Resources figure reported by Program Manager gradually decreased as applications were started and terminated because some programs failed to delete the GDI objects they created. All 32-bit versions of Windows track the resources a program allocates and deletes them when the program ends. However, it's <I>still</I> important to delete GDI objects when they're no longer needed so that the GDI doesn't run out of memory while a program is running. Imagine an <I>OnPaint</I> handler that creates 10 pens and brushes every time it's called but neglects 
to delete them. Over time, <I>OnPaint</I> might create thousands of GDI objects that occupy space in system memory owned by the Windows GDI. Pretty soon, calls to create pens and brushes will fail, and the application's <I>OnPaint</I> handler will mysteriously stop working.
</P>

<p>
In Visual C++, there's an easy way to tell whether you're failing to delete pens, brushes, and other resources: Simply run a debug build of your application in debugging mode. When the application terminates, resources that weren't freed will be listed in the debugging window. MFC tracks memory allocations for <I>CPen</I>, <I>CBrush</I>, and other 
<I>CObject</I>-derived classes so that it can notify you when an object hasn't been deleted. If you have difficulty ascertaining from the debug messages which objects weren't deleted, add the statement
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>#define new DEBUG_NEW
</pre>
</td></tr></table></p>

<p>
to your application's source code files after the statement that includes Afxwin.h. (In AppWizard-generated applications, this statement is included automatically.) Debug messages for unfreed objects will then include line numbers and file names to help you pinpoint leaks.
</P>

<A NAME="53"><H2>Deselecting GDI Objects</H2></A>

<p>
It's important to delete the GDI objects you create, but it's equally important to never delete a GDI object while it's selected into a device context. Code that attempts to paint with a deleted object is buggy code. The only reason it doesn't crash is that the Windows GDI is sprinkled with error-checking code to prevent such crashes 
from occurring.
</P>

<p>
Abiding by this rule isn't as easy as it sounds. The following 
<I>OnPaint</I> handler allows a brush to be deleted while it's selected into a device context. Can you figure out why?
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>void CMainWindow::OnPaint ()
{
    CPaintDC dc (this);
    CBrush brush (RGB (255, 0, 0));
    dc.SelectObject (&amp;brush);
    dc.Ellipse (0, 0, 200, 100);
}
</pre>
</td></tr></table></p>

<p>
Here's the problem. A <I>CPaintDC</I> object and a 
<I>CBrush</I> object are created on the stack. Since the 
<I>CBrush</I> is created second, its destructor gets called first. Consequently, the associated GDI brush is deleted before <I>dc</I> goes out of scope. You could fix this by creating the brush first and the DC second, but code whose robustness relies on stack variables being created in a particular order is bad code indeed. As far as maintainability goes, it's a nightmare.
</P>

<p>
The solution is to select the <I>CBrush</I> out of the device context before the <I>CPaintDC</I> object goes out of scope. There is no 
<I>UnselectObject</I> function, but you can select an object out of a device context by selecting in another object. Most Windows programmers make it a practice to save the pointer returned by the first call 
to <I>SelectObject</I> for each object type and then use that pointer to reselect the default object. An equally viable approach is to select stock objects into the device context to replace the objects that are currently selected in. The first of these two methods is 
illustrated by the following code:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>CPen pen (PS_SOLID, 1, RGB (255, 0, 0));
CPen* pOldPen = dc.SelectObject (&amp;pen);
CBrush brush (RGB (0, 0, 255));
CBrush* pOldBrush = dc.SelectObject (&amp;brush);
  <img src="images/grayvellip.JPG" width=3 height=13 border="0">
dc.SelectObject (pOldPen);
dc.SelectObject (pOldBrush);
</pre>
</TD></TR></table></p>

<p>
The second method works like this:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>CPen pen (PS_SOLID, 1, RGB (255, 0, 0));
dc.SelectObject (&amp;pen);
CBrush brush (RGB (0, 0, 255));
dc.SelectObject (&amp;brush); 
  <img src="images/grayvellip.JPG" width=3 height=13 border="0">
dc.SelectStockObject (BLACK_PEN);
dc.SelectStockObject (WHITE_BRUSH);
</pre>
</td></TR></table></p>

<p>
The big question is why this is necessary. The simple truth is that it's not. In modern versions of Windows, there's no harm in allowing a GDI object to be deleted a split second before a device context is released, especially if you're absolutely sure that no drawing will be done in the interim. Still, cleaning up a device context by deselecting the GDI objects you selected in is a common practice in Windows programming.
It's also considered good form, so it's something I'll do throughout this book.
</P> 

<P>
Incidentally, GDI objects are occasionally created on the heap, like this:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	<pre>CPen* pPen = new CPen (PS_SOLID, 1, RGB (255, 0, 0));
CPen* pOldPen = dc.SelectObject (pPen);
</pre>
</td></tr></table></p>

<p>
At some point, the pen must be selected out of the device context and deleted. 
The code to do it might look like this:
</P>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>dc.SelectObject (pOldPen);
delete pPen;
</pre>
</td></tr></table></p>

<p>
Since the <I>SelectObject</I> function returns a pointer to the object selected out of the 
device context, it might be tempting to try to deselect the pen and delete it in one step:</p>

<p><table cellpadding=5 width="95%"><tr><td>	
<pre>delete dc.SelectObject (pOldPen);
</pre>
</td></tr></table></p>

<p>
But don't do this. It works fine with pens, but it might not work with 
brushes. Why? Because if you create two identical 
<I>CBrush</I>es, 32-bit Windows conserves memory by creating just one GDI brush and you'll wind up with two 
<I>CBrush</I> pointers that reference the same HBRUSH. (An HBRUSH is a handle that uniquely identifies a 
GDI brush, just as an HWND identifies a window and an HDC identifies a device context. A <I>CBrush</I> wraps an HBRUSH and stores the HBRUSH handle in its <I>m_hObject</I> data member.) Because <I>CDC::SelectObject</I> uses an internal table maintained by MFC 
to convert the HBRUSH handle returned by <I>SelectObject</I> to a <I>CBrush</I> pointer and because that table assumes a one-to-one mapping between HBRUSHes and <I>CBrush</I>es, the <I>CBrush</I> pointer you get back might not match the <I>CBrush</I> pointer returned by <I>new</I>. Be sure you pass <I>delete</I> the pointer returned by <I>new</I>. Then both the GDI object and the C++ object will be properly destroyed.
</P>

<A NAME="54"><H2>The Ruler Application</H2></A>

<p>
The best way to get acquainted with the GDI and the MFC classes that encapsulate it is to write code. Let's start with a very simple application. Figure 2-12 contains the source code for Ruler, a program that draws a 12-inch ruler on the screen. Ruler's output is shown in Figure 2-11.
</P>

<P>
<A HREF="javascript:fullSize('F02mg11x.htm')"> <img src="IMAGES/F02mg11.JPG" width=404 height=302 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 2-11.</B> <I>The Ruler window.</I><!-- /CAPTION -->
</p>

<p><B>Figure 2-12.</B> <I>The Ruler application.</I></p>


<p><table cellpadding=5 width="95%"><tr><td>	
<A NAME="55"><H3>Ruler.h</H3></A>
<pre>class CMyApp : public CWinApp
{
public:
    virtual BOOL InitInstance ();
};

class CMainWindow : public CFrameWnd
{
public:
    CMainWindow ();

protected:
    afx_msg void OnPaint ();
    DECLARE_MESSAGE_MAP ()
};
</pre>
</td></tr></table></p>

<p><table cellpadding=5 width="95%"><tr><td>	
<A NAME="56"><H3>Ruler.cpp</H3></A>
<pre>#include &lt;afxwin.h&gt;
#include &quot;Ruler.h&quot;

CMyApp myApp;

/////////////////////////////////////////////////////////////////////////
// CMyApp member functions

BOOL CMyApp::InitInstance ()
{
    m_pMainWnd = new CMainWindow;
    m_pMainWnd-&gt;ShowWindow (m_nCmdShow);
    m_pMainWnd-&gt;UpdateWindow ();
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////
// CMainWindow message map and member functions

BEGIN_MESSAGE_MAP (CMainWindow, CFrameWnd)
    ON_WM_PAINT ()
END_MESSAGE_MAP ()

CMainWindow::CMainWindow ()
{
    Create (NULL, _T (&quot;Ruler&quot;));
}

void CMainWindow::OnPaint ()
{
    CPaintDC dc (this);
    
    //
    // Initialize the device context.
    //
    dc.SetMapMode (MM_LOENGLISH);
    dc.SetTextAlign (TA_CENTER &#166; TA_BOTTOM);
    dc.SetBkMode (TRANSPARENT);

    //
    // Draw the body of the ruler.
    //

    CBrush brush (RGB (255, 255, 0));
    CBrush* pOldBrush = dc.SelectObject (&amp;brush);
    dc.Rectangle (100, -100, 1300, -200);
    dc.SelectObject (pOldBrush);

    //
    // Draw the tick marks and labels.
    //
    for (int i=125; i&lt;1300; i+=25) {
        dc.MoveTo (i, -192);
        dc.LineTo (i, -200);
    }

    for (i=150; i&lt;1300; i+=50) {
        dc.MoveTo (i, -184);
        dc.LineTo (i, -200);
    }

    for (i=200; i&lt;1300; i+=100) {
        dc.MoveTo (i, -175);
        dc.LineTo (i, -200);

        CString string;
        string.Format (_T (&quot;%d&quot;), (i / 100) - 1);
        dc.TextOut (i, -175, string);
    }

}
</pre>
</td></tr></table></p>


<P>
The structure of Ruler is similar to that of the Hello application presented in Chapter 1. The <I>CMyApp</I> class represents the application itself. <I>CMyApp::InitInstance</I> creates a frame window by constructing a <I>CMainWindow</I> object, and <I>CMainWindow</I>'s constructor calls <I>Create</I> to create the window you see on the screen. <I>CMainWindow::OnPaint</I> handles all the drawing. The body of the ruler is drawn with <I>CDC::Rectangle,</I> and the hash marks are drawn with <I>CDC::LineTo</I> and <I>CDC::MoveTo</I>. Before the rectangle is drawn, a yellow brush is selected into the device context so that the body of the ruler will be painted yellow. Numeric labels are drawn with <I>CDC::TextOut</I> and positioned over the tick marks by calling <I>SetTextAlign</I> with TA_CENTER and TA_BOTTOM flags and passing <I>TextOut</I> the coordinates of the top of each tick mark. Before <I>TextOut</I> is called for the first time, the device context's background mode is set to TRANSPARENT. Otherwise, the numbers on the face of the ruler would be drawn with white backgrounds.
</P>

<p>
Rather than hardcode the strings passed to 
<I>TextOut</I>, Ruler uses <I>CString::Format</I> to generate text on the fly. <I>CString</I> is the MFC class that represents text 
strings. <I>CString::Format</I> works like C's <I>printf</I> function, converting numeric values to text and substituting them for placeholders in a formatting string. Windows programmers who work in C frequently use the <I>::wsprintf</I> API function for text formatting. <I>Format</I> does the same thing for <I>CString</I> objects without requiring an external function call. And unlike <I>::wsprintf</I>, <I>Format</I> supports the full range of <I>printf</I> formatting codes, including codes for floating-point and string variable types. 
</p>

<p>
Ruler uses the MM_LOENGLISH mapping mode to scale its output so that 1 inch on the ruler corresponds to 1 logical inch on the screen. Hold a real ruler up to the screen and on most PCs you'll find that 1 logical inch equals a little more than 1 physical inch. If the ruler is output to a printer instead, logical inches and physical inches will match exactly.
</P>

</BODY>
</HTML>




