<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>The OLE Clipboard</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch19b.htm", "ch19d.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="592"><H1>The OLE Clipboard</H1></A>

<P>The OLE clipboard is a modern-day version of the legacy clipboard. It is also backward-compatible. Thanks to some magic built into the OLE libraries, you can put a text string, a bitmap, or some other item on the OLE clipboard and an application that knows nothing about OLE can paste that item just as if it had come from the legacy clipboard. Conversely, an application can use the OLE clipboard to retrieve data from the legacy clipboard.</p>

<p>What's different about the OLE clipboard, and why is it superior to the old clipboard? There are two major differences between the two. First, the OLE clipboard is completely COM-based; all data is transferred by calling methods through pointers to COM interfaces. Second, the OLE clipboard supports storage media other than global memory. The legacy clipboard, in contrast, uses memory for <I>all</I> data transfers, which effectively limits the size of items transferred through the clipboard to the amount of memory available. Because of the legacy clipboard's inability to use media other than memory for data transfers, the compatibility between the legacy clipboard and the OLE clipboard is subject to the limitation that only items transferred through memory can be copied to one and retrieved from the other.</p>

<p>The first reason alone isn't enough to justify forsaking the legacy clipboard. COM is trendy and objects are cool, but without MFC, code that interacts with the OLE clipboard is much more complex than legacy clipboard code. But the second reason&#8212;the freedom to use alternative storage media&#8212;is just cause to use the OLE clipboard. Transferring a 4-GB bitmap through the legacy clipboard is impossible because current versions of Windows don't support memory objects that large. With the OLE clipboard, however, you can transfer anything that will fit on your hard disk. In fact, with a little ingenuity, you can transfer anything at all&#8212;even items too large to fit on a hard disk. Given the huge volumes of information that many modern applications are forced to deal with, the OLE clipboard can be a very handy tool indeed.</p>

<A NAME="593"><H2>OLE Clipboard Basics</H2></A>

<P>The first and most fundamental notion to understand about the OLE clipboard is that when you place an item of data on it, you don't actually place the data itself. Instead, you place a COM data object that encapsulates the data. A <I>data object</I> is a COM object that implements the <I>IDataObject</I> interface. <I>IDataObject</I> has two methods that play key roles in the operation of the OLE clipboard: <I>SetData</I> and <I>GetData</I>. Assuming that the data object is a generic data repository (as opposed to an object that is custom-fit to handle a particular set of data), a data provider stuffs data into the data object with <I>IDataObject::SetData</I>. It then places the object on the OLE clipboard with <I>::OleSetClipboard</I>. A data consumer calls <I>::OleGetClipboard</I> to get the clipboard data object's <I>IDataObject</I> pointer, and then it calls <I>IDataObject::GetData</I> to retrieve the data.</p>

<p>Figure 19-1 provides a conceptual look at OLE clipboard operations. This is a simplified view in that the <I>IDataObject</I> pointer returned by <I>::OleGetClipboard</I> isn't really the <I>IDataObject</I> pointer that was passed to <I>::OleSetClipboard</I>. Rather, it's a pointer to the <I>IDataObject</I> interface implemented by a system-provided clipboard data object that wraps the data object provided to <I>::OleSetClipboard</I> and also allows consumers to access data on the legacy clipboard. Fortunately, this bit of indirection doesn't affect the code you write one iota. You simply use the <I>IDataObject</I> interface to interact with the data object. The system does the rest.</p>

<p>
<A HREF="javascript:fullSize('F19mg01x.htm')"> <img src="images/F19mg01.JPG" width=404 height=303 border=0 ALT="Click to view at full size."> </A>
</p><p>
<!-- CAPTION --><B>Figure 19-1.</B> <I>Transferring data through the OLE clipboard.</I><!-- /CAPTION -->
</p>

<p>Using the OLE clipboard sounds reasonably simple, but nothing is simple when COM and OLE are involved. The hard part is writing the code for a data object and implementing not only <I>IDataObject::GetData</I> and <I>IDataObject::SetData</I> but also the other <I>IDataObject</I> methods. But first things first. Assuming that you've already implemented a data object and that <I>pdo</I> holds a pointer to the object's <I>IDataObject</I> interface, here's one way to place a text string on the OLE clipboard:</p>

<p><table width="95%" cellpadding="5" valign="TOP"><tr><td>
<PRE>
// Copy the text string to a global memory block.
char szText[] = &quot;Hello, world&quot;;
HANDLE hData = ::GlobalAlloc (GMEM_MOVEABLE, ::lstrlen (szText) + 1);
LPSTR pData = (LPSTR) ::GlobalLock (hData);
::lstrcpy (pData, szText);
::GlobalUnlock (hData);

// Initialize a FORMATETC structure and a STGMEDIUM structure that
// describe the data and the location at which it's stored.
FORMATETC fe;
fe.cfFormat = CF_TEXT;          // Clipboard format=CF_TEXT
fe.ptd = NULL;               // Target device=Screen
fe.dwAspect = DVASPECT_CONTENT;     // Level of detail=Full content
fe.lindex = -1;               // Index=Not applicable
fe.tymed = TYMED_HGLOBAL;     // Storage medium=Memory

STGMEDIUM stgm;
stgm.tymed = TYMED_HGLOBAL;     // Storage medium=Memory
stgm.hGlobal = hData;          // Handle to memory block
stgm.pUnkForRelease = NULL;     // Use ReleaseStgMedium

// Place the data object on the OLE clipboard.
pdo-&gt;SetData (&amp;fe, &amp;stgm, FALSE);
::OleSetClipboard (pdo);
pdo-&gt;Release ();
</PRE>
</td></tr></table></p>

<P>The <I>Release</I> call in the final statement assumes that the application that created the data object has no more use for it after handing it off to the OLE clipboard. Calling <I>Release</I> on the data object won't cause the object to self-delete because <I>::OleSetClipboard</I> performs an <I>AddRef</I> on the <I>IDataObject</I> pointer passed to it.</p>

<p>Retrieving the text string is a little less work because we don't have to create a data object. But the process still isn't quite as straightforward as the one for retrieving a string from the legacy clipboard:</p>

<p><table width="95%" cellpadding="5" valign="TOP"><tr><td>
<PRE>
char szText[BUFLEN];
IDataObject* pdo;
STGMEDIUM stgm;

FORMATETC fe = {
    CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL
};

if (SUCCEEDED (::OleGetClipboard (&amp;pdo))) {
    if (SUCCEEDED (pdo-&gt;GetData (&amp;fe, &amp;stgm) &amp;&amp; stgm.hGlobal != NULL)) {
        LPCSTR pData = (LPCSTR) ::GlobalLock (stgm.hGlobal);
        if (::lstrlen (pData) &lt; BUFLEN)
            ::lstrcpy (szText, pData);
        ::GlobalUnlock (stgm.hGlobal);
        ::ReleaseStgMedium (&amp;stgm);
    }
    pdo-&gt;Release ();
}
</PRE>
</td></tr></table></p>

<P>If the data object can't provide the requested data, it returns an HRESULT signifying failure. The SUCCEEDED macro used in this example is the same one that we used to test HRESULTs in <a href="ch18a.htm">Chapter 18</a>.</p>

<P>Two structures play key roles in the operation of <I>SetData</I> and <I>GetData</I>: FORMATETC and STGMEDIUM. FORMATETC<B> </B>describes the format of the data and identifies the type of <I>storage medium</I> (for example, global memory block or file) that holds the data. Here's how FORMATETC is defined in Objidl.h:</p>

<p><table width="95%" cellpadding="5" valign="TOP"><tr><td>
<PRE>
typedef struct  tagFORMATETC {
    CLIPFORMAT cfFormat;     // Clipboard format
    DVTARGETDEVICE *ptd;     // Target device
    DWORD dwAspect;     // Level of detail
    LONG lindex;          // Page number or other index
    DWORD tymed;          // Type of storage medium
} FORMATETC;
</PRE>
</td></tr></table></p>

<P>The two most important fields are <I>cfFormat</I> and <I>tymed</I>. <I>cfFormat</I> holds a clipboard format ID. The ID can be a standard clipboard format ID such as CF_TEXT or CF_BITMAP, or it can be a private clipboard format ID. <I>tymed</I> identifies the type of storage medium and can be any one of the values listed in the following table. Most OLE clipboard data transfers still use old-fashioned global memory blocks, but as you can plainly see, FORMATETC supports other media types as well.</p>

<p><b><I>IDataObject</I> Storage Media Types</b></p>

<p><table width="95%" cellpadding=5>
<tr>
<th valign="top">tymed <i>Flag</i></th>
<th valign="top"><i>Storage Medium Type</i></th>
</tr><tr>
<td valign="top">TYMED_HGLOBAL</td>
<td valign="top">Global memory block</td>
</tr><tr>
<td valign="top">TYMED_FILE</td>
<td valign="top">File</td>
</tr><tr>
<td valign="top">TYMED_ISTREAM</td>
<td valign="top">Stream object (implements interface 
<I>IStream</I>)</td>
</tr><tr>
<td valign="top">TYMED_ISTORAGE</td>
<td valign="top">Storage object (implements interface 
<I>IStorage</I>)</td>
</tr><tr>
<td valign="top">TYMED_GDI</td>
<td valign="top">GDI bitmap</td>
</tr><tr>
<td valign="top">TYMED_MFPICT</td>
<td valign="top">Metafile picture</td>
</tr><tr>
<td valign="top">TYMED_ENHMF</td>
<td valign="top">GDI enhanced metafile</td>
</tr>
</table></p>

<p>FORMATETC identifies the storage medium type, but the STGMEDIUM structure identifies the storage medium itself. For example, if data is stored in a global memory block, the STGMEDIUM structure holds an HGLOBAL. If the data lives in a file instead, the STGMEDIUM holds a pointer to a character string that specifies the file name. STGMEDIUM holds other information as well. Here's how the structure is defined:</p>

<p><table width="95%" cellpadding="5" valign="TOP"><tr><td>
<PRE>
typedef struct  tagSTGMEDIUM {
    DWORD tymed;
    union {
        HBITMAP hBitmap;               // TYMED_GDI
        HMETAFILEPICT hMetaFilePict;     // TYMED_MFPICT
        HENHMETAFILE hEnhMetaFile;     // TYMED_ENHMF
        HGLOBAL hGlobal;               // TYMED_HGLOBAL
        LPOLESTR lpszFileName;          // TYMED_FILE
        IStream *pstm;               // TYMED_STREAM
        IStorage *pstg;               // TYMED_STORAGE
    };
    IUnknown *pUnkForRelease;
} STGMEDIUM;
</PRE>
</td></tr></table></p>

<P>Here<I> tymed</I> holds a TYMED value that identifies the storage medium type, just as FORMATETC's <I>tymed</I> field does. <I>hBitmap</I>, <I>hMetaFilePict</I>, and other members of the embedded union identify the actual storage. Finally, <I>pUnkForRelease</I> holds a pointer to the COM interface whose <I>Release</I> method releases the storage medium. When an application retrieves an item from the OLE clipboard with <I>IDataObject::GetData</I>, that application is responsible for releasing the storage medium when it's no longer needed. For a memory block, &quot;release&quot; means to free the block; for a file, it means to delete the file. COM provides an API function named <I>::ReleaseStgMedium</I> that an application can call to release a storage medium. If you simply set <I>pUnkForRelease</I> to NULL when you initialize a STGMEDIUM, <I>::ReleaseStgMedium</I> will free the storage medium using logic that is appropriate for the storage medium type.</p>

<P>There's much more that could be written about these data structures, but the description offered here should be enough to enable you to understand the examples in the previous section. The first example initialized a FORMATETC structure to describe an ANSI text string (<I>cfFormat</I>=CF_TEXT) stored in a global memory block (<I>tymed</I>=TYMED_HGLOBAL). It also wrapped the memory block with a STGMEDIUM (<I>hGlobal</I>=<I>hData</I> and <I>tymed</I>=TYMED_HGLOBAL). Both structures were passed by address to <I>IDataObject::SetData</I>.</p>

<P>In the second example, a FORMATETC structure was initialized with the same parameters and the STGMEDIUM structure was left uninitialized. Both were passed to <I>IDataObject::GetData</I> to retrieve the text string. In this case, the parameters in the FORMATETC structure told the data object what kind of data and what type of storage medium the caller wanted. On return from <I>IDataObject::GetData</I>, the STGMEDIUM structure held the HGLOBAL through which the data could be accessed.</p>

<P>By now, you're probably beginning to understand why programming the OLE clipboard is more involved than programming the legacy clipboard. You haven't seen the half of it yet, however, because I haven't shown the code for the data object. Remember, a data object is a COM object that implements the <I>IDataObject</I> interface. <I>IDataObject</I> is part of a COM-based data transfer protocol that Microsoft has christened Uniform Data Transfer, or UDT. I mentioned earlier that <I>GetData</I> and <I>SetData</I> are just two of the <I>IDataObject</I> methods you must wrestle with. The table below contains a complete list.</P>

<p><b><I>IDataObject</I> Methods</b></p>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top">Method</th>
<th valign="top">Description</th>
</tr><tr>
<td valign="top"><I>GetData</I></td>
<td valign="top">Retrieves data from the data object (object provides the storage medium)</td>
</tr><tr>
<td valign="top"><I>GetDataHere</I></td>
<td valign="top">Retrieves data from the data object (caller provides the storage medium)</td>
</tr><tr>
<td valign="top"><I>QueryGetData</I></td>
<td valign="top">Determines whether data is available in a particular format</td>
</tr><tr>
<td valign="top"><I>GetCanonicalFormatEtc</I></td>
<td valign="top">Creates a different but logically equivalent FORMATETC</td>
</tr><tr>
<td valign="top"><I>SetData</I></td>
<td valign="top">Provides data to the data object</td>
</tr><tr>
<td valign="top"><I>EnumFormatEtc</I></td>
<td valign="top">Used to enumerate available data formats</td>
</tr><tr>
<td valign="top"><I>DAdvise</I></td>
<td valign="top">Establishes an advisory connection to the data object</td>
</tr><tr>
<td valign="top"><I>DUnadvise</I></td>
<td valign="top">Terminates an advisory connection</td>
</tr><tr>
<td valign="top"><I>EnumDAdvise</I></td>
<td valign="top">Enumerates existing advisory connections</td>
</tr>
</table></p>

<p>You don't have to implement all these methods to perform a simple clipboard data transfer (some methods can simply return the special COM error code E_NOTIMPL), but implementing <I>IDataObject</I> is still a nontrivial task. Copying a simple text string to the legacy clipboard requires just a few lines of code. Copying the same text string to the OLE clipboard can require several hundred lines, primarily because of the added overhead of implementing a full-blown COM data object.</p>

<p>If having to write hundreds of lines of code to copy a string to the clipboard seems silly, take heart. MFC greatly simplifies matters by providing the data object for you and by wrapping it in friendly C++ classes that hide the FORMATETC structures and the STGMEDIUM structures and other low-level nuts and bolts of the <I>IDataObject</I> interface. Generally speaking, using the OLE clipboard in an MFC application is no more difficult than using the legacy clipboard, particularly when you use global memory as the storage medium. And you retain the option of using files and other storage media as alternatives to global memory. All things considered, MFC's abstraction of the OLE clipboard is a big win for programmers. Let's see if you agree.</p>

<A NAME="594"><H2>MFC, Global Memory, and the OLE Clipboard</H2></A>

<P>MFC's OLE clipboard support is concentrated in two classes. The first, <I>COleDataSource</I>, models the provider side of clipboard operations. The second, <I>COleDataObject</I>, models the consumer side. In other words, you use <I>COleDataSource</I> to place data on the OLE clipboard and <I>COleDataObject</I> to retrieve it. Not surprisingly, <I>COleDataSource</I> contains a generic implementation of COM's <I>IDataObject</I> interface. You can see this implementation for yourself in the MFC source code file Oledobj2.cpp. If you're not familiar with the manner in which MFC classes implement COM interfaces, you might want to review <a href="ch18a.htm">Chapter 18</a> before reading the source code.</p>

<p>Placing an item that's stored in global memory on the OLE clipboard is easy when you let <I>COleDataSource</I> do the dirty work. Here are the steps:</p>

<OL>
<p><li>Create a <I>COleDataSource</I> object on the heap (not on the stack).</li></p>

<p><li>Call <I>COleDataSource::CacheGlobalData</I> to hand the HGLOBAL to the <I>COleDataSource</I> object.</li></p>

<p><li>Place the object on the OLE clipboard by calling <I>COleDataSource::SetClipboard</I>.</li></p>
</OL>

<P>The following example uses <I>COleDataSource</I> to make an ANSI text string available through the OLE clipboard:</p>

<p><table width="95%" cellpadding="5" valign="TOP"><tr><td>
<PRE>
char szText[] = &quot;Hello, world&quot;; // ANSI characters
HANDLE hData = ::GlobalAlloc (GMEM_MOVEABLE, ::lstrlen (szText) + 1);
LPSTR pData = (LPSTR) ::GlobalLock (hData);
::lstrcpy (pData, szText);
::GlobalUnlock (hData);

COleDataSource* pods = new COleDataSource;
pods-&gt;CacheGlobalData (CF_TEXT, hData);
pods-&gt;SetClipboard ();
</PRE>
</td></tr></table></p>

<P>Notice that the <I>COleDataSource</I> object is created on the heap, not on the stack. That fact is important because the object must remain in memory until a call to <I>IUnknown::Release</I> drops the data object's reference count to 0, at which time the object self-deletes. If you were to create the <I>COleDataSource</I> on the stack, the object would be deleted the moment it went out of scope.</p>

<P>MFC's <I>COleDataObject</I> provides a handy mechanism for retrieving items from the OLE clipboard. Here's the procedure for retrieving an item stored in global memory:</p>

<OL>
<p><li>Create a <I>COleDataObject</I> object.</li></p>

<p><li>Call <I>COleDataObject::AttachClipboard</I> to connect the <I>COleDataObject</I> to the OLE clipboard.</li></p>

<p><li>Use <I>COleDataObject::GetGlobalData</I> to retrieve the item.</li></p>

<p><li>Free the global memory block returned by <I>GetGlobalData</I>.</li></p>
</OL>

<P>And here's how the text string placed on the OLE clipboard in the previous example is retrieved using <I>COleDataObject</I>:</P>

<p><table width="95%" cellpadding="5" valign="TOP"><tr><td>
<PRE>
char szText[BUFLEN];
COleDataObject odo;
odo.AttachClipboard ();
HANDLE hData = odo.GetGlobalData (CF_TEXT);

if (hData != NULL) {
    LPCSTR pData = (LPCSTR) ::GlobalLock (hData);
    if (::lstrlen (pData) &lt; BUFLEN)
        ::lstrcpy (szText, pData);
    ::GlobalUnlock (hData);
    ::GlobalFree (hData);
}
</PRE>
</td></tr></table></p>

<P>The <I>AttachClipboard</I> function creates a logical connection between a <I>COleDataObject</I> and the OLE clipboard. Once the connection is made, MFC transforms calls to <I>GetGlobalData</I> and other <I>COleDataObject</I> data retrieval functions into <I>GetData</I> calls through the <I>IDataObject</I> pointer returned by <I>::OleGetClipboard</I>. Don't forget that it's your responsibility to free the global memory block returned by <I>GetGlobalData</I>. That requirement explains the call to <I>::GlobalFree</I> in the preceding example.</p>

<A NAME="595"><H2>Using Alternative Storage Media</H2></A>

<P>All the examples presented so far in this chapter have used global memory as the transfer medium. But remember that the OLE clipboard supports other media types, too. <I>COleDataSource::CacheGlobalData</I> and <I>COleDataObject::GetGlobalData</I> are hardwired to use global memory blocks. You can use the more generic <I>COleDataSource::CacheData</I> and <I>COleDataObject::GetData</I> functions to transfer data in other types of storage media.</p>

<P>The next example demonstrates how to transfer a text string through the OLE clipboard using a file as the transfer medium. The string is first copied into a temporary file. Then FORMATETC and STGMEDIUM structures are initialized with information describing the file and the data that it contains. Finally, the information is passed to <I>COleDataSource::CacheData</I>, and the data object is placed on the OLE clipboard with <I>COleDataSource::SetClipboard</I>:</P>

<p><table width="95%" cellpadding="5" valign="TOP"><tr><td>
<PRE>
char szText[] = &quot;Hello, world&quot;;
TCHAR szPath[MAX_PATH], szFileName[MAX_PATH];
::GetTempPath (sizeof (szPath) / sizeof (TCHAR), szPath);
::GetTempFileName (szPath, _T (&quot;tmp&quot;), 0, szFileName);

CFile file;
if (file.Open (szFileName, CFile::modeCreate | CFile::modeWrite)) {
    file.Write (szText, ::lstrlen (szText) + 1);
    file.Close ();

    LPWSTR pwszFileName =
        (LPWSTR) ::CoTaskMemAlloc (MAX_PATH * sizeof (WCHAR));

#ifdef UNICODE
    ::lstrcpy (pwszFileName, szFileName);
#else
    ::MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, szFileName, -1,
        pwszFileName, MAX_PATH);
#endif

    FORMATETC fe = {
        CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_FILE
    };

    STGMEDIUM stgm;
    stgm.tymed = TYMED_FILE;
    stgm.lpszFileName = pwszFileName;
    stgm.pUnkForRelease = NULL;

    COleDataSource* pods = new COleDataSource;
    pods-&gt;CacheData (CF_TEXT, &amp;stgm, &amp;fe);
    pods-&gt;SetClipboard ();
}
</PRE>
</td></tr></table></p>

<P>The file name whose address is copied to the STGMEDIUM structure prior to calling <I>CacheData</I> must be composed of Unicode characters. This is always true, even in Windows 98. You must also allocate the file name buffer using the COM function <I>::CoTaskMemAlloc</I>. Among other things, this ensures that the buffer is properly freed when <I>::ReleaseStgMedium</I> calls <I>::CoTaskMemFree</I> on the buffer pointer.</p>

<p>On the consumer side, you can use <I>COleDataObject::GetData</I> to retrieve the string from the clipboard:</p>

<p><table width="95%" cellpadding="5" valign="TOP"><tr><td>
<PRE>
char szText[BUFLEN];
STGMEDIUM stgm;

FORMATETC fe = {
    CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_FILE
};

COleDataObject odo;
odo.AttachClipboard ();

if (odo.GetData (CF_TEXT, &amp;stgm, &amp;fe) &amp;&amp; stgm.tymed == TYMED_FILE) {
    TCHAR szFileName[MAX_PATH];

#ifdef UNICODE
    ::lstrcpy (szFileName, stgm.lpszFileName);
#else
    ::WideCharToMultiByte (CP_ACP, 0, stgm.lpszFileName,
        -1, szFileName, sizeof (szFileName) / sizeof (TCHAR), NULL, NULL);
#endif

    CFile file;
    if (file.Open (szFileName, CFile::modeRead)) {
        DWORD dwSize = file.GetLength ();
        if (dwSize &lt; BUFLEN)
            file.Read (szText, (UINT) dwSize);
        file.Close ();
    }
    ::ReleaseStgMedium (&amp;stgm);
}
</PRE>
</td></tr></table></p>

<P>When you retrieve data with <I>COleDataObject::GetData</I>, you are responsible for freeing the storage medium, which is why <I>::ReleaseStgMedium</I> is called in the final statement of this example.</p>

<p>Of course, transferring small text strings through files rather than global memory blocks doesn't make much sense. If the item being transferred is a large bitmap, however, such a transfer might make a lot of sense&#8212;especially if the bitmap is already stored on disk somewhere. I used text strings in this section's examples to make the code as simple and uncluttered as possible, but the principle represented here applies to data of all types.</p>

<A NAME="596"><H2>Treating the OLE Clipboard as a <I>CFile</I></H2></A>
<P>MFC's <I>COleDataObject::GetFileData</I> function provides a handy abstraction of the OLE clipboard that enables data stored in any of the following storage media to be retrieved as if the clipboard were an ordinary <I>CFile</I>:</p>

<UL>
<p><li>TYMED_HGLOBAL</LI></P>
<p><li>TYMED_FILE</LI></P>
<p><li>TYMED_MFPICT</LI></P>
<p><li>TYMED_ISTREAM</LI></P>
</UL>

<p>If successful, <I>GetFileData</I> returns a pointer to a <I>CFile</I> object that wraps the item retrieved from the clipboard. You can call <I>CFile::Read</I> through that pointer to read the data out.</p>

<p>The following example demonstrates how to use <I>GetFileData</I> to retrieve a string from the OLE clipboard:</p>

<p><table width="95%" cellpadding="5" valign="TOP"><tr><td>
<PRE>
char szText[BUFLEN];
COleDataObject odo;
odo.AttachClipboard ();

CFile* pFile = odo.GetFileData (CF_TEXT);

if (pFile != NULL) {
    DWORD dwSize = pFile-&gt;GetLength ();
    if (dwSize &lt; BUFLEN)
        pFile-&gt;Read (szText, (UINT) dwSize);
    delete pFile; // Don't forget this!
}
</PRE>
</td></tr></table></p>

<P>Again, notice that you are responsible for deleting the <I>CFile</I> object whose address is returned by <I>GetFileData</I>. If you forget to delete it, you'll suffer memory leaks.</p>

<p>The code above is the functional equivalent of the <I>GetData</I> example presented in the previous section, but with two added benefits. One, it's simpler. Two, it works whether data is stored in a global memory block, a file, or a stream. In other words, one size fits all. To get the same results with <I>GetData</I>, you'd have to do something like this:</p>

<p><table width="95%" cellpadding="5" valign="TOP"><tr><td>
<PRE>
char szText[BUFLEN];
STGMEDIUM stgm;

COleDataObject odo;
odo.AttachClipboard ();

FORMATETC fe = {
    CF_TEXT, NULL, DVASPECT_CONTENT, -1,
    TYMED_FILE | TYMED_HGLOBAL | TYMED_ISTREAM
};

if (odo.GetData (CF_TEXT, &amp;stgm, &amp;fe)) {
    switch (stgm.tymed) {

    case TYMED_FILE:
        // Read the string from a file.
            .
            .
            .
        break;

    case TYMED_HGLOBAL:
        // Read the string from a global memory block.
            .
            .
            .
        break;

    case TYMED_ISTREAM:
        // Read the string from a stream object.
            .
            .
            .
        break;
    }
    ::ReleaseStgMedium (&amp;stgm);
}
</PRE>
</td></tr></table></p>

<P>Notice the use of multiple TYMED flags in the FORMATETC structure passed to <I>GetData</I>. TYMED flags can be OR'd together in this manner to inform a data object that the caller will accept data in a variety of different storage media.</p>

<A NAME="597"><H2>Multiple Formats and Multiple Storage Media</H2></A>

<P>A data provider can call <I>CacheData</I> or <I>CacheGlobalData </I>as many times as necessary to make data available to data consumers in a variety of formats. The following code offers an item in two formats: a private format registered with <I>::RegisterClipboardFormat</I> (<I>nFormat</I>) and a CF_TEXT format:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
COleDataSource* pods = new COleDataSource;
pods-&gt;CacheGlobalData (nFormat, hPrivateData);
pods-&gt;CacheGlobalData (CF_TEXT, hTextData);
pods-&gt;SetClipboard ();
</pre>
</td></tr></table></p>

<P>You can also make multiple data items available in the same format but in different storage media. Suppose you want to make CF_TEXT data available ineither a global memory block or a file. Assuming that <I>pwszFileName</I> has already been initialized to point to a file name (expressed in Unicode characters), here's how you go about it:</p>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
FORMATETC fe = {
    CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_FILE
};

STGMEDIUM stgm;
stgm.tymed = TYMED_FILE;
stgm.lpszFileName = pwszFileName;
stgm.pUnkForRelease = NULL;

COleDataSource* pods = new COleDataSource;
pods-&gt;CacheGlobalData (CF_TEXT, hTextData);     // TYMED_HGLOBAL
pods-&gt;CacheData (CF_TEXT, &amp;stgm, &amp;fe);          // TYMED_FILE
pods-&gt;SetClipboard ();
</pre>
</td></tr></table></p>

<P>Calling <I>CacheData</I> and <I>CacheGlobalData</I> more than once and then placing the data object on the clipboard is analogous to calling <I>::SetClipboardData</I> multiple times to place two or more formats on the legacy clipboard. However, the legacy clipboard won't accept two items that are of the same format. The OLE clipboard will&#8212;as long as each FORMATETC structure has a unique <I>tymed</I> value, which is another way of saying that the items are stored indifferent types of storage media.</p>

<A NAME="598"><H2>Checking Data Availability</H2></A>

<P>The API function <I>::IsClipboardFormatAvailable</I> allows users of the legacy clipboard to find out whether data is available in a certain format. <I>COleDataObject</I>::<I>IsDataAvailable</I> lets OLE clipboard users do the same. The following code fragment checks to see whether CF_TEXT data is available in an HGLOBAL:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
COleDataObject odo;
odo.AttachClipboard ();
if (odo.IsDataAvailable (CF_TEXT)) {
    // CF_TEXT is available in an HGLOBAL.
}
else {
    // CF_TEXT is not available in an HGLOBAL.
}
</pre>
</td></tr></table></p>

<P>To check for storage media types other than global memory, you simply initialize a FORMATETC structure and pass its address to <I>IsDataAvailable</I>, as shown here:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
COleDataObject odo;
odo.AttachClipboard ();

FORMATETC fe = {
    CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_ISTREAM
};

if (odo.IsDataAvailable (CF_TEXT, &amp;fe)) {
    // CF_TEXT is available in a stream object.
}
else {
    // CF_TEXT is not available in a stream object.
}
</pre>
</td></tr></table></p>

<P>If you want to, you can OR several TYMED flags into the <I>tymed</I> field of the FORMATETC structure passed to <I>IsDataAvailable</I>. The return value will be nonzero if data is available in any of the requested storage media.</P>

<p><div class="note"><blockquote>
<b>NOTE</b><HR>
As a result of a bug in MFC 6.0, <I>COleDataObject::IsDataAvailable</I> sometimes returns a nonzero value if the requested data is available in <I>any</I> storage medium. In effect, the media type information passed to <I>IsDataAvailable</I> in a FORMATETC structure is ignored. Significantly, the bug manifests itself only if <I>IsDataAvailable</I> is called on a <I>COleDataObject</I> that's attached to the OLE clipboard, and it affects some data types (notably CF_TEXT data) more than others. <I>IsDataAvailable</I> works as advertised when <I>COleDataObject</I> is used to implement an OLE drop target. 
</blockquote></div></p>

<P>Data consumers can use the <I>COleDataObject</I> functions <I>BeginEnumFormats</I> and <I>GetNextFormat</I> to enumerate the various formats available. The following code fragment enumerates all the formats available on the OLE clipboard:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
COleDataObject odo;
odo.AttachClipboard ();

FORMATETC fe;
odo.BeginEnumFormats ();
while (odo.GetNextFormat (&amp;fe)) {
    // FORMATETC structure describes the next available format.
}
</pre>
</td></tr></table></p>

<P>If a particular data format is available in two or more types of storage media, <I>GetNextFormat</I> is supposed to either initialize the FORMATETC structure's <I>tymed</I> field with bit flags identifying each storage medium type or return a unique FORMATETC structure for each <I>tymed</I>. However, an interesting (and potentially aggravating) anomaly can occur. If the OLE clipboard contains two data items with identical <I>cfFormat</I>s but different <I>tymed</I>s, <I>GetNextFormat</I> will return information for only one of them. This appears to be a bug in the system-supplied clipboard data objectwhose <I>IDataObject</I> pointer is returned by <I>::OleGetClipboard</I>. If you need to know what media types a given clipboard format is available in, use <I>IsDataAvailable</I> to query for individual combinations of clipboard formats and storage media.</P>

<A NAME="599"><H2>Delayed Rendering with <I>COleDataSource</I></H2></A>
<P>Does the OLE clipboard support delayed rendering? The short answer is yes, although in truth, MFC's implementation of <I>COleDataSource</I>, not the OLE clipboard, makes delayed rendering work. A glimpse under the hood of <I>COleDataSource</I> explains why.</P>

<P>A <I>COleDataSource</I> object is first and foremost a data cache. Internally, it maintains an array of FORMATETC and STGMEDIUM structures that describe the data that is currently available. When an application calls <I>CacheData</I> or <I>CacheGlobalData</I>, a STGMEDIUM structure with a <I>tymed</I> value that describes the storage medium type is added to the array. If an application calls <I>DelayRenderData</I> instead, a STGMEDIUM structure that contains a NULL <I>tymed</I> value is added to the array. When asked to retrieve that data, the <I>COleDataSource</I> sees the NULL <I>tymed</I> value and knows that the data was promised via delayed rendering. <I>COleDataSource</I> responds by calling a virtual function named <I>OnRenderData</I>. Your job is to override this function in a derived class so that you can provide the data on request.</P>

<P>Here's an example that demonstrates how to place a bitmap on the OLE clipboard using delayed rendering. The first step is to make a copy of the bitmap and store it in a file. (You could store it in memory, but that might defeat the purpose of using delayed rendering in the first place.) The second step is to call <I>DelayRenderData</I>:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
FORMATETC fe = {
    CF_BITMAP, NULL, DVASPECT_CONTENT, -1, TYMED_GDI
};

CMyDataSource* pmds = new CMyDataSource;
pmds-&gt;DelayRenderData (CF_BITMAP, &amp;fe);
pmds-&gt;SetClipboard ();
</pre>
</td></tr></table></p>

<P><I>CMyDataSource</I> is a <I>COleDataSource</I> derivative. Here's the 
<I>OnRenderData</I> function that renders the bitmap to a TYMED_GDI storage medium when the data source is asked to hand over the bitmap:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL CMyDataSource::OnRenderData (LPFORMATETC lpFormatEtc,
    LPSTGMEDIUM lpStgMedium) 
{
    if (COleDataSource::OnRenderData (lpFormatEtc, lpStgMedium))
        return TRUE;

    if (lpFormatEtc-&gt;cfFormat == CF_BITMAP &amp;&amp;
        lpFormatEtc-&gt;tymed &amp; TYMED_GDI) {

        // Re-create the bitmap from the file, and store the
        // handle in hBitmap. 	
            .
            .
            .
        lpFormatEtc-&gt;cfFormat = CF_BITMAP;
        lpFormatEtc-&gt;ptd = NULL;
        lpFormatEtc-&gt;dwAspect = DVASPECT_CONTENT;
        lpFormatEtc-&gt;lindex = -1;
        lpFormatEtc-&gt;tymed = TYMED_GDI;

        lpStgMedium-&gt;tymed = TYMED_GDI;
        lpStgMedium-&gt;hBitmap = hBitmap;
        lpStgMedium-&gt;pUnkForRelease = NULL;

        CacheData (CF_BITMAP, lpStgMedium, lpFormatEtc);
        return TRUE;
    }
    return FALSE;
}
</pre>
</td></tr></table></p>

<P>Other than the fact that you have to derive a class and override <I>OnRenderData</I>, delayed rendering with a <I>COleDataSource</I> isn't much different from immediate rendering.</P>

<P>Other <I>COleDataSource</I> functions can sometimes simplify the delayed rendering code that you write. For example, if you intend to render data only to HGLOBAL storage media, you can override <I>OnRenderGlobalData</I> instead of <I>OnRenderData</I>. You can use a separate set of <I>COleDataSource</I> functions named <I>DelayRenderFileData</I> and <I>OnRenderFileData</I> functions to delay-render data using <I>CFile</I> output functions.</P>

<P>One detail to be aware of when you use, <I>COleDataSource</I> delayed rendering is that if the storage type is TYMED_HGLOBAL, TYMED_FILE, TYMED_ISTREAM, or TYMED_ISTORAGE, the storage medium might be allocated before <I>OnRenderData</I> is called. If the storage medium is preallocated, <I>OnRenderData</I> must render the data into the existing storage medium rather than create a new storage medium itself. The <I>tymed</I> value in the STGMEDIUM structure whose address is passed to <I>OnRenderData</I> tells the tale. If <I>lpStgMedium-&gt;tymed</I> is TYMED_NULL, <I>OnRenderData</I> is responsible for allocating the storage medium. If <I>lpStgMedium-&gt;tymed</I> holds any other value, the caller has supplied the storage medium and <I>lpStgMedium-&gt;tymed</I> identifies the storage type. The following code sample demonstrates proper handling of <I>OnRenderData</I> for media types that are subject to preallocation:</P>

<p><table cellpadding=5 width="95%"><tr><td>
<pre>
BOOL CMyDataSource::OnRenderData (LPFORMATETC lpFormatEtc,
    LPSTGMEDIUM lpStgMedium) 
{
    if (COleDataSource::OnRenderData (lpFormatEtc, lpStgMedium))
        return TRUE;

    if (lpStgMedium-&gt;tymed == TYMED_NULL) { // Medium is not preallocated.
        if (lpFormatEtc-&gt;tymed &amp; TYMED_HGLOBAL) {
            // Allocate a global memory block, render the data
            // into it, and then copy the handle to lpStgMedium-&gt;hGlobal.
           }
    }
    else { // Medium is preallocated.
        if (lpStgMedium-&gt;tymed == TYMED_HGLOBAL) {
            // Render the data into the global memory block whose
            // handle is stored in lpStgMedium-&gt;hGlobal.
        }
    }
}
</pre>
</td></tr></table></p>

<P>This example addresses only the case in which the storage medium is an HGLOBAL, but the principle should be clear nonetheless.</P>

<P>The most common reason for using <I>COleDataSource</I>'s brand of delayed rendering is to provide data in a variety of storage media without having to allocate each and every storage medium up front. If you're willing to provide, say, CF_TEXT data in several different media, you can call 
<I>DelayRenderData</I> and pass in a FORMATETC structure whose <I>tymed</I> field contains bit flags representing each of the media types that you support. Then you can render the data in any medium that the data consumer requests by inspecting the <I>tymed</I> field of the FORMATETC structure passed to <I>OnRenderData</I>. If the consumer asks for the data in a medium that you don't support, you can simply fail the call to <I>OnRenderData</I> by returning FALSE.</P>

<A NAME="600"><H2><I>COleDataSource</I> and <I>COleDataObject</I> in Review</H2></A>
<P>You now know how to use MFC's <I>COleDataSource</I> and <I>COleDataObject</I> classes to interact with the OLE clipboard. Just to put things in perspective (and to reinforce what you've already learned), the following tables provide a brief summary of the most useful <I>COleDataSource</I> and <I>COleDataObject</I> member functions. These classes have other functions as well, but those listed here are the ones that you're most likely to need.</P>

<P><B>Key <I>COleDataSource</I> Member Functions</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Function</I></th>    
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top"><I>SetClipboard</I></td>     
<td valign="top">Places the <I>COleDataSource</I> on the OLE clipboard</td>
</tr>
<tr>
<td valign="top"><I>CacheData</I></td>     
<td valign="top">Provides data to the <I>COleDataSource</I></td>
</tr>
<tr>
<td valign="top"><I>CacheGlobalData</I></td>
<td valign="top">Provides data stored in global memory to the <I>COleDataSource</I></td>
</tr>
<tr>
<td valign="top"><I>DelayRenderData</I></td>     
<td valign="top">Offers data for delayed rendering</td>
</tr>
<tr>
<td valign="top"><I>DelayRenderFileData</I></td>     
<td valign="top">Offers data for delayed rendering using <I>CFile</I> output functions</td>
</tr>
<tr>
<td valign="top"><I>OnRenderData</I></td>     
<td valign="top">Called to render data to an arbitrary storage medium</td>
</tr>
<tr>
<td valign="top"><I>OnRenderFileData</I></td>     
<td valign="top">Called to render data to a <I>CFile</I></td>
</tr>
<tr>
<td valign="top"><I>OnRenderGlobalData</I></td>     
<td valign="top">Called to render data to an HGLOBAL</td>
</tr></table></p>

<P><B>Key <I>COleDataObject</I> Member Functions</B></P>

<p><table cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Function</I></th>     
<th valign="top"><I>Description</I></th>
</tr>
<tr>
<td valign="top"><I>AttachClipboard</I></td>     
<td valign="top">Attaches the <I>COleDataObject</I> to the OLE clipboard</td>
</tr>
<tr>
<td valign="top"><I>GetData</I></td>
<td valign="top">Retrieves data from the data object to which the <I>COleDataObject</I> is attached</td>
</tr>
<tr>
<td valign="top"><I>GetFileData</I></td>
<td valign="top">Retrieves data using <I>CFile</I> functions</td>
</tr>
<tr>
<td valign="top"><I>GetGlobalData</I></td>
<td valign="top">Retrieves data in an HGLOBAL</td>
</tr>
<tr>
<td valign="top"><I>IsDataAvailable</I></td>
<td valign="top">Determines whether data is available in a particular 
format and storage medium</td>
</tr>
<tr>
<td valign="top"><I>BeginEnumFormats</I></td>
<td valign="top">Begins the process of enumerating available data formats</td>
</tr>
<tr>
<td valign="top"><I>GetNextFormat</I></td>
<td valign="top">Fills a FORMATETC structure with information describing the next available data format</td>
</tr></table></p>

<P>Earlier, I said that the primary reason to use the OLE clipboard is to gain the ability to use storage media other than global memory. That's true, but there's another reason, too. Thanks to the abstractions offered by <I>COleDataSource</I> and <I>COleDataObject</I>, once you write MFC code to utilize the OLE clipboard, you only have to do a little more work to add support for an even more convenient form of data transfer: OLE drag-and-drop. OLE drag-and-drop lets the user transfer data by grabbing it with the mouse and dragging it. Writing OLE drag-and-drop code without a class library to help out isn't any fun, but MFC makes the process as hassle-free as possible.</P>

</BODY>
</HTML>




