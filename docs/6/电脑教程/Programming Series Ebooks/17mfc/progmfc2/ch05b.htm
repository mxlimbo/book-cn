<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Arrays</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch05a.htm", "ch05c.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="149"><H1>Arrays</H1></A>
<P>One of the greatest weaknesses of C and C++ is that arrays are not 
bounds-checked. Consider the following code, which reflects one of the most common bugs found in C and C++ applications:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
int array[10];
for (int i=0; i&lt;=10; i++)
    array[i] = i + 1;
</pre>
</td></tr></table>
</P>
	
<P>This code is buggy because the final iteration of the 
<I>for</I> loop writes past the end of the array. When executed, it will cause an access violation.</P>

<P>C++ programmers frequently combat such problems by writing array classes 
that perform internal bounds checks. The following array class features 
<I>Get</I> and <I>Set</I> functions that check the array indexes passed to them and assert when passed an 
invalid index:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
class CArray
{
protected:
    int m_nSize;     // Number of elements in the array.
    int* m_pData;    // Where the array's elements are stored.

public:
    CArray (int nSize)
    {
        m_nSize = nSize;
        m_pData = new int[nSize];
    }
    ~CArray ()
    {
        m_nSize = 0;
        if (m_pData != NULL) {
            delete[] m_pData;
            m_pData = NULL;
        }
    }
    int Get (int nIndex)
    {
        assert (nIndex &gt;= 0 &amp;&amp; nIndex &lt; m_nSize);
        return m_pData[nIndex];
    }
    void Set (int nIndex, int nVal)
    {
        assert (nIndex &gt;= 0 &amp;&amp; nIndex &lt; m_nSize);
        m_pData[nIndex] = nVal;
    }
};
</pre>
</td></tr></table>
</P>

<P>With this simple class serving as a container for an array of integers, the 
following code will assert when <I>Set</I> is called for the final time:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CArray array (10);
for (int i=0; i&lt;=10; i++)
    array.Set (i, i + 1); // Asserts when i == 10.
</pre>
</td></tr></table>	
</P>
	
<P>Now the error will be caught before an access violation occurs.</P>

<A NAME="150"><H2>The MFC Array Classes</H2></A>

<P>You don't have to write array classes yourself because MFC provides an 
assortment of them for you. First there's the generic 
<I>CArray</I> class, which is actually a template class from which you can create type-safe arrays for data of any type. 
<I>CArray</I> is defined in the header file Afxtempl.h. Then there are the nontemplatized array classes, 
each of which is designed to hold a particular type of data. These classes are defined 
in Afxcoll.h. The following table lists the nontemplatized MFC array classes and the 
types of data that they store.</P>

<P><b>Type-Specific MFC Array Classes</b></P>

<P>
<table valign="top" cellpadding=5 width="95%">
<tr>
<th valign="top"><I>Class Name</I></th>
<th valign="top"><I>Data Type</I></th>
</tr>
<tr>
<td valign="top"><I>CByteArray</I></td>
<td valign="top">8-bit bytes (BYTEs)</td>
</tr>
<tr>
<td valign="top"><I>CWordArray</I></td>
<td valign="top">16-bit words (WORDs)</td>
</tr>
<tr>
<td valign="top"><I>CDWordArray</I></td>
<td valign="top">32-bit double words (DWORDs)</td>
</tr>
<tr>
<td valign="top"><I>CUIntArray</I></td>
<td valign="top">Unsigned integers (UINTs)</td>
</tr>
<tr>
<td valign="top"><I>CStringArray</I></td>
<td valign="top"><I>CStrings</I></td>
</tr>
<tr>
<td valign="top"><I>CPtrArray</I></td>
<td valign="top">void pointers</td>
</tr>
<tr>
<td valign="top"><I>CObArray</I> </td>
<td valign="top"><I>CObject</I> pointers</td>
</tr>
</table>
</P>
     
<P>Once you learn to use one of these array classes, you can use the others 
too, because all share a common set of member functions. The following example 
declares an array of 10 UINTs and initializes it with the numbers 1 through 10:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CUIntArray array;
array.SetSize (10);
for (int i=0; i&lt;10; i++)
    array[i] = i + 1;
</pre>
</td></tr></table>
</P>
	
<P>You can use the same approach to declare an array of 
<I>CString</I>s and initialize it with textual representations of the integers 1 through 10:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CStringArray array;
array.SetSize (10);
for (int i=0; i&lt;10; i++) {
    CString string;
    string.Format (_T (&quot;%d&quot;), i);
    array[i] = string;
}
</pre>
</td></tr></table>
</P>

<P>In both cases, <I>SetSize</I> sizes the array to hold 10 elements. In both cases, the 
overloaded [] operator calls the array's 
<I>SetAt</I> function, which copies a value to an 
element at a specified location in the array. And in both cases, the code asserts if the 
array's bounds are violated. The bounds check is built into the code for 
<I>SetAt</I>:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
ASSERT(nIndex &gt;= 0 &amp;&amp; nIndex &lt; m_nSize);
</pre>
</TD></TR></TABLE>
</P>

<P>You can see this code for yourself in the MFC source code file Afxcoll.inl.</P>
<P>You can insert items into an array without overwriting the items that are already there by using the <I>InsertAt</I> function. Unlike 
<I>SetAt</I>, which simply assigns a value to an existing array element, <I>InsertAt</I> makes room for the new element by moving 
elements above the insertion point upward in the array. The following statements initialize an array with the numbers 1 through 4 and 6 through 10, and then insert a 5 between the 4 and the 6:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CUIntArray array;
array.SetSize (9);
for (int i=0; i&lt;4; i++)
    array[i] = i + 1;
for (i=4; i&lt;9; i++)
    array[i] = i + 2;
array.InsertAt (4, 5); // Insert a 5 at index 4.
</pre>
</TD></TR></TABLE>
</P>

<P>You can also pass a third parameter to 
<I>InsertAt</I> specifying the number of times the item should be inserted or pass a pointer to another array object in parameter 2 
to insert an entire array. Note that this example sets the array size to 9, not 10, yet 
no assertion occurs when <I>InsertAt</I> is called. That's because 
<I>InsertAt</I> is one of a handful of array functions that automatically grow the array as new items are added. 
Dynamically sized arrays are discussed in the next section.</P>

<P>Values can be retrieved from an MFC array using standard array addressing 
syntax. The following example reads back the UINTs written to the 
<I>CUIntArray</I> in the previous example:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
for (int i=0; i&lt;10; i++)
    UINT nVal = array[i];
</pre>
</TD></TR></TABLE>
</P>	
	
<P>Used this way, the [] operator calls the array's 
<I>GetAt</I> function, which retrieves a value from a specified position in the array&#8212;with bounds checking, of course. If you'd 
prefer, you can call <I>GetAt</I> directly rather than use the 
[] operator.</P>

<P>To find out how many elements an array contains, call the array's 
<I>GetSize</I> function. You can also call 
<I>GetUpperBound</I>, which returns the 0-based index of the 
array's upper bound&#8212;the number of elements in the array minus 1.</P>
<P>MFC's array classes provide two functions for removing elements from an array: <I>RemoveAt</I> and <I>RemoveAll</I>. 
<I>RemoveAt</I> removes one or more items from the array 
and shifts down any items above the ones that were removed. 
<I>RemoveAll</I> empties the array. Both functions adjust the array's upper bounds to reflect the number of items 
that were removed, as the following example demonstrates:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
// Add 10 items.
CUIntArray array;
array.SetSize (10);
for (int i=0; i&lt;10; i++)
    array[i] = i + 1;

// Remove the item at index 0.
array.RemoveAt (0);
TRACE (_T (&quot;Count = %d\n&quot;), array.GetSize ()); // 9 left.

// Remove items 0, 1, and 2.
array.RemoveAt (0, 3);
TRACE (_T (&quot;Count = %d\n&quot;), array.GetSize ()); // 6 left.

// Empty the array.
array.RemoveAll ();
TRACE (_T (&quot;Count = %d\n&quot;), array.GetSize ()); // 0 left.
</pre>
</TD></TR></TABLE>
</P>


<P>The <I>Remove</I> functions delete elements, but they don't delete the objects 
that the elements point to if the elements are pointers. If 
<I>array</I> is a <I>CPtrArray</I> or a 
<I>CObArray</I> and you want to empty the array 
<I>and</I> delete the objects referenced by the 
deleted pointers, rather than write</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
array.RemoveAll ();
</pre>
</TD></TR></TABLE>
</P>

<P>you should write this:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
int nSize = array.GetSize ();
for (int i=0; i&lt;nSize; i++)
    delete array[i];
array.RemoveAll ();
</pre>
</TD></TR></TABLE>
</P>

<P>Failure to delete the objects whose addresses are stored in a pointer array will 
result in memory leaks. The same is true of MFC lists and maps that store pointers.</P>

<A NAME="151"><H2>Dynamic Array Sizing</H2></A>

<P>Besides being bounds-checked, the MFC array classes also support dynamic 
sizing. You don't have to predict ahead of time how many elements a dynamically sized 
array should have because the memory set aside to store array elements can be grown 
as elements are added and shrunk as elements are removed.</P>

<P>One way to dynamically grow an MFC array is to call 
<I>SetSize</I>. You can call <I>SetSize</I> as often as needed to allocate additional memory for storage. Suppose you 
initially size an array to hold 10 items but later find that it needs to hold 20. Simply call 
<I>SetSize</I> a second time to make room for the additional items:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
// Add 10 items.
CUIntArray array;
array.SetSize (10);
for (int i=0; i&lt;10; i++)
    array[i] = i + 1;
        <img src="images/grayvellip.JPG" width=3 height=13 alt="" border="0">
// Add 10 more.
array.SetSize (20);
for (i=10; i&lt;20; i++)
    array[i] = i + 1;
</pre>
</TD></TR></TABLE>
</P>
	
<P>When an array is resized this way, the original items retain their values. Thus, 
only the new items require explicit initialization following a call to 
<I>SetSize</I>.</P>

<P>Another way to grow an array is to use 
<I>SetAtGrow</I> instead of <I>SetAt</I> to add 
items. For example, the following code attempts to use 
<I>SetAt</I> to add 10 items to an array of UINTs:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CUIntArray array;
for (int i=0; i&lt;10; i++)
    array.SetAt (i, i + 1);
</pre>
</TD></TR></TABLE>
</P>
	
<P>This code will assert the first time 
<I>SetAt</I> is called. Why? Because the array's size is 
0 (note the absence of a call to <I>SetSize</I>), and 
<I>SetAt</I> doesn't automatically grow the array to accommodate new elements. Change 
<I>SetAt</I> to <I>SetAtGrow</I>, however, and the 
code works just fine:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CUIntArray array;
for (int i=0; i&lt;10; i++)
    array.SetAtGrow (i, i + 1);
</pre>
</TD></TR></TABLE>
</P>
	
<P>Unlike <I>SetAt</I>, <I>SetAtGrow</I> automatically grows the array's memory allocation if 
necessary. So does <I>Add</I>, which adds an item to the end of the array. The next example 
is functionally identical to the previous one, but it uses 
<I>Add</I> instead of <I>SetAtGrow</I> to add elements to the array:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CUIntArray array;
for (int i=0; i&lt;10; i++)
    array.Add (i + 1);
</pre>
</TD></TR></TABLE>
</P>
	
<P>Other functions that automatically grow an array to accommodate new items 
include <I>InsertAt</I>, <I>Append</I> (which appends one array to another), and 
<I>Copy</I>, which, as the name implies, copies one array to another.</P>

<P>MFC grows an array by allocating a new memory buffer and copying items 
from the old buffer to the new one. If a grow operation fails because of insufficient 
memory, MFC throws an exception. To trap such errors when they occur, wrap calls that 
grow an array in a <I>try</I> block accompanied by a 
<I>catch</I> handler for <I>CMemoryException</I>s:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
try {
    CUIntArray array;
    array.SetSize (1000); // Might throw a CMemoryException.
        <img src="images/grayvellip.JPG" width=3 height=13 border="0">
}
catch (CMemoryException* e) {
    AfxMessageBox (_T (&quot;Error: Insufficient memory&quot;));
    e-&gt;Delete (); // Delete the exception object.
}
</pre>
</TD></TR></TABLE>
</P>

<P>This <I>catch</I> handler displays an error message warning the user that the system is 
low on memory. In real life, more extensive measures might be required to recover 
gracefully from out-of-memory situations.</P>

<P>Because a new memory allocation is performed every time an array's size 
is increased, growing an array too frequently can adversely impact performance 
and can also lead to memory fragmentation. Consider the following code fragment:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CUIntArray array;
for (int i=0; i&lt;100000; i++)
    array.Add (i + 1);
</pre>
</TD></TR></TABLE>
</P>	
	
<P>These statements look innocent enough, but they're inefficient because they 
require thousands of separate memory allocations. That's why MFC lets you specify a 
<I>grow size</I> in <I>SetSize</I>'s optional second parameter. The following code initializes the 
array more efficiently because it tells MFC to allocate space for 10,000 new UINTs 
whenever more memory is required:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CUIntArray array;
array.SetSize (0, 10000);
for (int i=0; i&lt;100000; i++)
    array.Add (i + 1);
</pre>
</TD></TR></TABLE>
</P>
	
<P>Of course, this code would be even better if it allocated room for 100,000 items 
up front. But very often it's impossible to predict in advance how many elements 
the array will be asked to hold. Large grow sizes are beneficial if you anticipate 
adding many items to an array but can't determine just how big the number will be up front.</P>

<P>If you don't specify a grow size, MFC picks one for you using a simple 
formula based on the array size. The larger the array, the larger the grow size. If you 
specify 0 as the array size or don't call 
<I>SetSize</I> at all, the default grow size is 4 items. In 
the first of the two examples in the previous paragraph, the 
<I>for</I> loop causes memory to be allocated and reallocated no less than 25,000 times. Setting the grow size to 
10,000 reduces the allocation count to just 10.</P>

<P>The same <I>SetSize</I> function used to grow an array can also be used to reduce 
the number of array elements. When it downsizes an array, however, 
<I>SetSize</I> doesn't automatically shrink the buffer in which the array's data is stored. No memory is 
freed until you call the array's <I>FreeExtra</I> function, as demonstrated here:
</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
array.SetSize (50);     // Allocate room for 50 elements.
array.SetSize (30);     // Shrink the array size to 30 elements.
array.FreeExtra ();     // Shrink the buffer to fit exactly 30 elements.
</pre>
</TD></TR></TABLE>
</P>

<P>You should also call<I> FreeExtra</I> after 
<I>RemoveAt</I> and <I>RemoveAll</I> if you want to 
shrink the array to the minimum size necessary to hold the remaining elements.</P>

<A NAME="152"><H2>Creating Type-Safe Array Classes with <I>CArray</I></H2></A>
<P><I>CUIntArray</I>, <I>CStringArray</I>, and other MFC array classes work with specific data 
types. But suppose you need an array for another data type&#8212;say, 
<I>CPoint</I> objects. Because there is no 
<I>CPointArray</I> class, you must create your own from MFC's 
<I>CArray</I> class. <I>CArray</I> is a template class used to build type-safe array classes for arbitrary data types.</P>

<P>To illustrate, the following code sample declares a type-safe array class for 
<I>CPoint</I> objects and then instantiates the class and initializes it with an array of 
<I>CPoint</I>s describing a line:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
CArray&lt;CPoint, CPoint&amp;&gt; array;

// Populate the array, growing it as needed.
for (int i=0; i&lt;10; i++)
    array.SetAtGrow (i, CPoint (i*10, 0));

// Enumerate the items in the array.
int nCount = array.GetSize ();
for (i=0; i&lt;nCount; i++) {
    CPoint point = array[i];
    TRACE (_T (&quot;x=%d, y=%d\n&quot;), point.x, point.y);
}
</pre>
</TD></TR></TABLE>
</P>

<P>The first <I>CArray</I> template parameter specifies the type of data stored in the array; 
the second specifies how the type is represented in parameter lists. You could use 
<I>CPoint</I>s instead of <I>CPoint</I> references, but references are more efficient when the size of 
the item exceeds the size of a pointer.</P>

<P>You can use data of any kind&#8212;even classes of your own creation&#8212;in 
<I>CArray</I>'s template parameters. The following example declares a class that represents 
points in three-dimensional space and fills an array with 10 class instances:</P>


<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
class CPoint3D
{
public:
    CPoint3D ()
    {
        x = y = z = 0;
    }
    CPoint3D (int xPos, int yPos, int zPos)
    {
        x = xPos;
        y = yPos;
        z = zPos;
    }
    int x, y, z;
};

CArray&lt;CPoint3D, CPoint3D&amp;&gt; array;

// Populate the array, growing it as needed.
for (int i=0; i&lt;10; i++)
    array.SetAtGrow (i, CPoint3D (i*10, 0, 0));

// Enumerate the items in the array.
int nCount = array.GetSize ();
for (i=0; i&lt;nCount; i++) {
    CPoint3D point = array[i];
    TRACE (_T (&quot;x=%d, y=%d, z=%d\n&quot;), point.x, point.y, point.z);
}
</pre>
</TD></TR></TABLE>
</P>

<P>It's important to include default constructors in classes you use with 
<I>CArray</I> and other template-based MFC collection classes because MFC uses a class's default 
constructor to create new items when functions such as 
<I>InsertAt</I> are called.</P>

<P>With <I>CArray</I> at your disposal, you can, if you want to, do without the older 
(and nontemplatized) MFC array classes such as 
<I>CUIntArray</I> and use templates exclusively. The following 
<I>typedef</I> declares a <I>CUIntArray</I> data type that is functionally 
equivalent to MFC's <I>CUIntArray</I>:</P>

<P>
<table valign="top" cellpadding=5 width="95%"><tr><td>
<pre>
typedef CArray&lt;UINT, UINT&gt; CUIntArray;
</pre>
</TD></TR></TABLE>
</P>

<P>Ultimately, the choice of which 
<I>CUIntArray</I> class to use is up to you. However, 
the MFC documentation recommends that you use the template classes whenever 
possible, in part because doing so is more in keeping with modern C++ 
programming practices.</P>

</BODY>
</HTML>




