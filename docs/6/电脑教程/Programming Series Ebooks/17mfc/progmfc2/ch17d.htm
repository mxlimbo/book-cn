<HTML>
<HEAD>
	<link rel="STYLESHEET" type="text/css" href="Library.css">
<TITLE>Odds and Ends</TITLE>


</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000">
<SCRIPT LANGUAGE="JavaScript">
<!--

function fullSize(sURL){
	window.open(sURL,'scrshot','width=500,height=375,top=20,left=20,directories=no , Toolbar = no, resizable = yes, menubar = no, ScrollBars = yes ');
}

function LibraryHeaderNav(sBackward, sForward, sImgLeftOff, sImgLeftOn, sImgRightOff, sImgRightOn, iH, iW, sImgLeftStyle, sImgRightStyle, sImgRuleStyle, sRuleColor, sRuleSize){
	var tableStr;
	//validate questionable args for defs
	tableStr = "<TABLE BORDER=0 CELLPADDING=0 CELLSPACING=0 border=0 width=100%>";
	tableStr += "<TR VALIGN=top ALIGN=right>";

	tableStr += "<TD align=right class=" + sImgRuleStyle + ">&nbsp;</TD>";	
	
	tableStr += "<TD width=34 align=right class=" + sImgLeftStyle + ">";
	tableStr += "<A href='" + sBackward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgLeftOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgLeftOff + '\'\"';
	tableStr += " SRC='" + sImgLeftOff + "' vspace=0 hspace=0></a></TD>";
	
	tableStr += "<TD width=34 align=left class=" + sImgRightStyle + ">";
	tableStr += "<A href='" + sForward + "'>";
	tableStr += "<IMG HEIGHT=" + iH + " WIDTH=" + iW + " BORDER=0";
	tableStr += ' OnMouseOver=\"this.src=\'' + sImgRightOn + '\'\"';
	tableStr += ' OnMouseOut=\"this.src=\'' + sImgRightOff + '\'\"';
	tableStr += " SRC='" + sImgRightOff + "' vspace=0 hspace=0></a></TD></TR>";

	tableStr += "<TR VALIGN=top>";
	tableStr += "<TD height=3 align=center colspan=3 class=" + sImgRuleStyle + ">";
	tableStr += "<HR color=" + sRuleColor + " size=" + sRuleSize + "></TD></TR></TABLE>";
	//alert(tableStr);
	document.write(tableStr);
}

 																						     //purple is: #aa22aa   orange is: #ff9900
LibraryHeaderNav("ch17c.htm", "ch18a.htm", "images/unit_o_a1.gif", "images/unit_o_a2.gif", "images/unit_o_b1.gif", "images/unit_o_b2.gif", 18, 34, "unit01", "unit02", "headerrule", "#ff9900", "2");
//--></SCRIPT>

<A NAME="560"><H1>Odds and Ends</H1></A>

<p>Here are a few odds and ends related to multitasking and multithreading that might be useful to you.</p>

<A NAME="561"><H2>Message Pumps</H2></A>

<p>A common misconception programmers have about multithreading is that it makes applications run faster. On a single-processor machine, it doesn't; however, it does make applications more <i>responsive</i>. One way to demonstrate the difference in responsiveness multithreading can make is to write an application that draws a few thousand ellipses in response to a menu command. If the drawing is done by the primary thread and the thread doesn't occasionally take time out to check its message queue and dispatch any waiting messages, input will be frozen until the drawing loop has run its course. If the same application is written so that drawing is done in a separate thread, it will continue to respond to user input while the drawing loop executes.</p>

<p>In a scenario as simple as this, however, multithreading might be overkill. An alternative solution is to use a <i>message pump</i> to keep the messages flowing while the primary thread draws ellipses. Suppose the message handler that does the drawing looks like this:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>void CMainWindow::OnStartDrawing ()
{
    for (int i=0; i&lt;NUMELLIPSES; i++)
        DrawRandomEllipse ();
}
</pre></td>
		</tr>
	</table></p>

<p>If NUMELLIPSES is a large number, the program could be stuck for a long time once the <i>for</i> loop is started. You could try adding another menu command that sets a flag and interrupts the <i>for</i> loop, as shown here:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>void CMainWindow::OnStartDrawing ()
{
    m_bQuit = FALSE;
    for (int i=0; i&lt;NUMELLIPSES &amp;&amp; !m_bQuit; i++)
        DrawRandomEllipse ();
}

void CMainWindow::OnStopDrawing ()
{
    m_bQuit = TRUE;
}
</pre></td>
		</tr>
	</table></p>

<p>But that wouldn't work. Why not? Because the WM_COMMAND message that activates <i>OnStopDrawing</i> can't get through as long as the <i>for</i> loop in <i>OnStartDrawing</i> executes without pumping messages. In fact, a menu can't even be pulled down while the <i>for</i> loop is running.</p>

<p>This problem is easily solved with a message pump. Here's the proper way to execute a lengthy procedure in a single-threaded MFC program:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>void CMainWindow::OnStartDrawing ()
{
    m_bQuit = FALSE;
    for (int i=0; i&lt;NUMELLIPSES &amp;&amp; !m_bQuit; i++) {
        DrawRandomEllipse ();
        if (!PeekAndPump ())
            break;
    }
}

void CMainWindow::OnStopDrawing ()
{
    m_bQuit = TRUE;
}

BOOL CMainWindow::PeekAndPump ()
{
    MSG msg;
    while (::PeekMessage (&amp;msg, NULL, 0, 0, PM_NOREMOVE)) {
        if (!AfxGetApp ()-&gt;PumpMessage ()) {
            ::PostQuitMessage (0);
            return FALSE;
        }
    }
    LONG lIdle = 0;
    while (AfxGetApp ()-&gt;OnIdle (lIdle++));
    return TRUE;
}
</pre></td>
		</tr>
	</table></p>

<p><i>PeekAndPump</i> enacts a message loop within a message loop. Called at the conclusion of each iteration through <i>OnStartDrawing</i>'s <i>for</i> loop, <i>PeekAndPump</i> first calls <i>CWinThread::PumpMessage</i> to retrieve and dispatch messages if <i>::PeekMessage</i> indicates that messages are waiting in the queue. A 0 return from <i>PumpMessage</i> indicates that the last message retrieved and dispatched was a WM_QUIT message, which calls for special handling because the application won't terminate unless the WM_QUIT message is retrieved by the <i>main</i> message loop. That's why <i>PeekAndPump</i> posts another WM_QUIT message to the queue if <i>PumpMessage</i> returns 0, and why the <i>for</i> loop in <i>OnStartDrawing</i> falls through if <i>PeekAndPump</i> returns 0. If a WM_QUIT message doesn't prompt an early exit, <i>PeekAndPump</i> simulates the framework's idle mechanism by calling the application object's <i>OnIdle</i> function before returning.</p>

<p>With <i>PeekAndPump</i> inserted into the drawing loop, the WM_COMMAND message that activates <i>OnStopDrawing</i> is retrieved and dispatched normally. Because <i>OnStopDrawing</i> sets <i>m_bQuit</i> to TRUE, the drawing loop will fall through before the next ellipse is drawn.</p>

<A NAME="562"><H2>Launching Other Processes</H2></A>

<p>Win32 processes can launch other processes with the same ease with which they launch threads. The following statements launch Notepad.exe from the Windows directory of drive C:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>STARTUPINFO si;
::ZeroMemory (&amp;si, sizeof (STARTUPINFO));
si.cb = sizeof (STARTUPINFO);
PROCESS_INFORMATION pi;

if (::CreateProcess (NULL, _T (&quot;C:\\Windows\\Notepad&quot;), NULL,
    NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &amp;si, &amp;pi)) {
    ::CloseHandle (pi.hThread);
    ::CloseHandle (pi.hProcess);
}
</pre></td>
		</tr>
	</table></p>

<p><i>::CreateProcess</i> is a versatile function that takes the name of (and optionally the path to) an executable file and then loads and executes it. If the drive and directory name are omitted from the executable file name, the system automatically searches for the file in the Windows directory, the Windows system directory, all directories in the current path, and in selected other locations. The file name can also include command line parameters, as in</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>&quot;C:\\Windows\\Notepad C:\\Windows\\Desktop\\Ideas.txt&quot;
</pre></td>
		</tr>
	</table></p>

<p><i>::CreateProcess</i> fills a PROCESS_INFORMATION structure with pertinent information about the process, including the process handle (<i>hProcess</i>) and the handle of the process's primary thread (<i>hThread</i>). You should close these handles with <i>::CloseHandle</i> after the process is started. If you have no further use for the handles, you can close them as soon as <i>::CreateProcess</i> returns.</p>

<p>A nonzero return from <i>::CreateProcess</i> means that the process was successfully launched. Win32 processes are launched and executed asynchronously, so <i>::CreateProcess</i> does <i>not</i> wait until the process has ended to return. If you'd like to launch another process and suspend the current process until the process that it launched terminates, call <i>::WaitForSingleObject</i> on the process handle, as shown here:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>STARTUPINFO si;
::ZeroMemory (&amp;si, sizeof (STARTUPINFO));
si.cb = sizeof (STARTUPINFO);
PROCESS_INFORMATION pi;

if (::CreateProcess (NULL, _T (&quot;C:\\Windows\\Notepad&quot;), NULL,
    NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &amp;si, &amp;pi)) {
    ::CloseHandle (pi.hThread);
    ::WaitForSingleObject (pi.hProcess, INFINITE);
    ::CloseHandle (pi.hProcess);
}
</pre></td>
		</tr>
	</table></p>

<p>Processes have exit codes just as threads do. If <i>::WaitForSingleObject</i> returns anything but WAIT_FAILED, you can call <i>::GetExitCodeProcess</i> to retrieve the process's exit code.</p>

<p>Sometimes the need arises to launch a process and delay just long enough to make sure the process is started and responding to user input. If process A launches process B and process B creates a window, for example, and process A wants to send that window a message, process A might have to wait for a moment after <i>::CreateProcess</i> returns to give process B time to create a window and begin processing messages. This problem is easily solved with the Win32 <i>::WaitForInputIdle</i> function:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>STARTUPINFO si;
::ZeroMemory (&amp;si, sizeof (STARTUPINFO));
si.cb = sizeof (STARTUPINFO);
PROCESS_INFORMATION pi;

if (::CreateProcess (NULL, _T (&quot;C:\\Windows\\Notepad&quot;), NULL,
    NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &amp;si, &amp;pi)) {
    ::CloseHandle (pi.hThread);
    ::WaitForInputIdle (pi.hProcess, INFINITE);
    // Get B's window handle and send or post a message.
    ::CloseHandle (pi.hProcess);
}
</pre></td>
		</tr>
	</table></p>

<p><i>::WaitForInputIdle</i> suspends the current process until the specified process begins processing messages and empties its message queue. I didn't show the code to find the window handle because there isn't a simple MFC or API function you can call to convert a process handle into a window handle. Instead, you must use <i>::EnumWindows</i>, <i>::FindWindow</i>, or a related function to search for the window based on some known characteristic of the owning process.</p>

<A NAME="563"><H2>File Change Notifications</H2></A>

<p>Earlier in this chapter, I mentioned that the HANDLE parameter passed to <i>::WaitForSingleObject</i> can be a &quot;file change notification handle.&quot; The Win32 API includes a function named <i>::FindFirstChangeNotification</i> that returns a handle you can use to wake a blocked thread whenever a change occurs in a specified directory or its subdirectories&#8212;for example, when a file is renamed or deleted or a new directory is created.</p>

<p>Let's say you want to enhance <a href="ch11a.htm">Chapter 11</a>'s Wanderer application so that changes to the file system are instantly reflected in the left or right pane. The most efficient way to do it is to start a background thread and have it block on one or more file change notification handles. Here's what the thread function for a thread that monitors drive C: might look like:</p>

<p>
	<table cellpadding="5" width="95%">
		<tr>
			<td>
<pre>UINT ThreadFunc (LPVOID pParam)
{
    HWND hwnd = (HWND) pParam; // Window to notify
    HANDLE hChange = ::FindFirstChangeNotification (_T (&quot;C:\\&quot;),
        TRUE, FILE_NOTIFY_CHANGE_FILE_NAME &#166; FILE_NOTIFY_CHANGE_DIR_NAME);

    if (hChange == INVALID_HANDLE_VALUE) {
        TRACE (_T (&quot;Error: FindFirstChangeNotification failed\n&quot;));
        return (UINT) -1;
    }

    while (...) {
        ::WaitForSingleObject (hChange, INFINITE);
        ::PostMessage (hwnd, WM_USER_CHANGE_NOTIFY, 0, 2);
        ::FindNextChangeNotification (hChange); // Reset
    }
    ::FindCloseChangeNotification (hChange);
    return 0;
}
</pre></td>
		</tr>
	</table></p>

<p>The first parameter passed to <i>::FindFirstChangeNotification</i> identifies the directory you want to monitor, the second specifies whether you want to monitor just that directory (FALSE) or that directory and all its subdirectories (TRUE), and the third specifies the kinds of changes that the thread should be notified of. In this example, the thread will be awakened when a file is created, renamed, or deleted anywhere on the C: drive (FILE_NOTIFY_CHANGE_FILE_NAME) or when a directory is created, renamed, or deleted (FILE_NOTIFY_CHANGE_DIR_NAME). When the thread is awakened, it posts a user-defined message to the window whose handle was passed in <i>pParam</i>. The message's <i>lParam</i> holds a drive number (2 for drive C:). The window that receives the message&#8212;presumably the application's top-level frame window&#8212;can respond to the message by updating its views. Keep in mind that a thread awakened by a file change notification doesn't receive any information about the nature of the change or about where in the directory tree the change occurred, so it must scan the file system if it wants to determine what caused the file change notification.</p>

<p>It's also possible to structure the thread so that it monitors not just one drive, but several. All you would have to do is call <i>::FindFirstChangeNotification</i> once per drive to acquire a separate file change notification handle for each drive and use <i>::WaitForMultipleObjects</i> to block on all the file change notifications simultaneously. <i>::WaitForMultipleObjects</i> is the Win32 API equivalent of <i>CMultiLock::Lock</i>. Passing FALSE in the third parameter to a call to <i>::WaitForMultipleObjects</i> tells the system to wake the thread when any one of the objects that the thread is blocking on becomes signaled.</p>
</body>
</html>




